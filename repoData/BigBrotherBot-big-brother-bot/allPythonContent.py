__FILENAME__ = clients
# coding: latin-1
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#    26/11/2012 - 1.5 - courgette
#    * add database columns 'login' and 'password' to the Client model
#    27/08/2012 - 1.4.1 - courgette
#    * fix bug in getByMagic when parameter is a cid which is not in use. was returning [None] instead of []
#    28/10/2012 - 1.4.0 - courgette
#    * Client.save() now raises a EVT_CLIENT_UPDATE event
#    16/07/2011 - 1.3.6 - xlr8or
#    * Client.bot added - ability to identify a bot
#    08/04/2011 - 1.3.5 - Courgette
#    * make sure Clients.empty() does not delete hidden clients
#    08/04/2011 - 1.3.4 - Courgette
#    * changes to allow cid to be a unicode string
#    30/03/2011 - 1.3.3 - Courgette
#    * newClient() now returns the created client object
#    26/03/2011 - 1.3.2 - Courgette
#    * fix bug on Client.__init__()
#    12/11/2010 - 1.3.1 - Courgette
#    * harden _set_name for cases where console is not set
#    01/11/2010 - 1.3.0 - Courgette
#    * Clients::getClientsByName() now ignores blank characters from names
#    * add automated tests for Clients::getClientsByName()
#    15/08/2010 - 1.2.13 - xlr8or
#    * Minor addition for bfbc2 in alias checking
#    21/05/2010 - 1.2.12 - xlr8or
#    * Catch ValueError in clients.getByCID to allow names as CID's, but still
#      fix the previous exploit in q3a based games 
#    11/05/2010 - 1.2.11 - Courgette
#    * fix exploit by using player cid prefixed with '0' for commands making use
#      of clients.getByCID
#    08/01/2010 - 1.2.10 - xlr8or
#    * disabled adding aliasses for world
#    01/01/2001 - 1.2.9 - Courgette
#    * clients get* methods' code is now more meaningful as : 
#        b = weakref.ref(a)() 
#        b = a
#    are strictly identical 
#    01/01/2010 - 1.2.8 - Courgette
#    * fix bug in Clients.getByName()
#    14/12/2009 - 1.2.7 - Courgette
#    * Change the way client.name and client.exactName are set and when the 
#      client name changed event is triggered
#    * A new alias is given the default num_used 1 (was 0)
#    2/26/2009 - 1.2.6 - xlr8or
#     Changed lastVisit to a global client variable
#    5/6/2008 - 1.2.5 - xlr8or
#     Client object now saves the current IP in auth function
#    10/29/2005 - 1.2.0 - ThorN
#     Removed direct references to PunkBuster. Authorization is now proxied
#      through the console.
#    7/23/2005 - 1.1.0 - ThorN
#     Added data field to Penalty
#     Added data parameter to Client.warn()
#     Added data parameter to Client.tempban()
import b3
import b3.events
import functions
import re
import string
import sys
import threading
import time
import traceback

__author__  = 'ThorN'
__version__ = '1.5'


class ClientVar(object):
    value = None

    def __init__(self, value):
        self.value = value

    def toInt(self):
        if self.value == None:
            return 0

        return int(self.value)

    def toString(self):
        if self.value == None:
            return ''

        return str(self.value)

    def items(self):
        if self.value == None:
            return ()

        return self.value.items()

    def length(self):
        if self.value == None:
            return 0

        return len(self.value)

#-----------------------------------------------------------------------------------------------------------------------
class Client(object):
    # fields in storage
    guid = ''
    pbid = ''
    name = ''
    ip   = ''
    greeting = ''
    autoLogin = 1
    maskLevel = 0
    groupBits = 0
    login = ''
    password = ''

    # fields on object
    console = None
    cid = None
    exactName = None
    team = b3.TEAM_UNKNOWN
    maxGroup = None
    authed = False
    hide = False # set to true for non-player clients (world entities)
    bot = False

    state = None
    authorizing = False
    connected = True
    lastVisit = None

    _pluginData = None
    _timeAdd = 0
    _timeEdit = 0
    _tempLevel = None
    _data = None

    def __init__(self, **kwargs):
        self._pluginData = {}
        self.state = b3.STATE_UNKNOWN
        self._data = {}        

        # make sure to set console before anything else
        if 'console' in kwargs:
            self.console = kwargs['console']
            
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

    def isvar(self, plugin, key):
        try:
            d = self._pluginData[id(plugin)][key]
            return True
        except:
            return False

    def setvar(self, plugin, key, value=None):
        try:
            self._pluginData[id(plugin)]
        except:
            self._pluginData[id(plugin)] = {}

        try:
            self._pluginData[id(plugin)][key].value = value
        except:
            self._pluginData[id(plugin)][key] = ClientVar(value)

        return self._pluginData[id(plugin)][key]

    def var(self, plugin, key, default=None):
        try:
            return self._pluginData[id(plugin)][key]
        except:
            return self.setvar(plugin, key, default)

    def varlist(self, plugin, key, default=None):
        if not default:
            default = []

        return self.var(plugin, key, default)

    def vardict(self, plugin, key, default=None):
        if not default:
            default = {}

        return self.var(plugin, key, default)

    def delvar(self, plugin, key):
        try:
            del self._pluginData[id(plugin)][key]
        except:
            pass

    def getBans(self):
        return self.console.storage.getClientPenalties(self, type=('Ban', 'TempBan'))

    bans = property(getBans)

    def getWarnings(self):
        return self.console.storage.getClientPenalties(self, type='Warning')

    warnings = property(getWarnings)

    _groups = None
    def getGroups(self):
        if not self._groups:
            self._groups = []
            groups = self.console.storage.getGroups()

            guest_group = None
            for g in groups:
                if g.id == 0:
                    guest_group = g
                if g.id & self._groupBits:
                    self._groups.append(g)
            if not len(self._groups) and guest_group:
                self._groups.append(guest_group)
        return self._groups

    groups = property(getGroups)

    def getAliases(self):
        return self.console.storage.getClientAliases(self)

    aliases = property(getAliases)

    def getIpAddresses(self):
        return self.console.storage.getClientIpAddresses(self)

    ip_addresses = property(getIpAddresses)

    def getattr(self, name, default=None):
        return getattr(self, name, default)

    #------------------------
    _pbid = ''
    def _set_pbid(self, pbid):
        if self.getattr('_pbid') and self._pbid != pbid:
            self.console.error('Client has pbid but its not the same %s <> %s', self._pbid, pbid)

        self._pbid = pbid

    def _get_pbid(self):
        return self._pbid

    pbid = property(_get_pbid, _set_pbid)

    #------------------------
    _guid = ''
    def _set_guid(self, guid):
        if guid and len(guid) > 2:
            if self._guid and self._guid != guid:
                self.console.error('Client has guid but its not the same %s <> %s', self._guid, guid)
                self.authed = False
            elif not self._guid:
                self._guid = guid
        else:
            self.authed = False
            self._guid = ''

    def _get_guid(self):
        return self._guid

    guid = property(_get_guid, _set_guid)

    #------------------------
    _groupBits = 0
    def _set_groupBits(self, bits):
        self._groupBits = int(bits)
        self.refreshLevel()

    def _get_groupBits(self):
        return self._groupBits

    groupBits = property(_get_groupBits, _set_groupBits)

    def addGroup(self, group):
        self.groupBits = self.groupBits | group.id

    def setGroup(self, group):
        self.groupBits = group.id

    def remGroup(self, group):
        self.groupBits = self.groupBits ^ group.id

    def inGroup(self, group):
        return self.groupBits & group.id

    #------------------------
    _id = 0
    def _set_id(self, v):
        if not v:
            self._id = 0
        else:
            self._id = int(v)

    def _get_id(self):
        return self._id

    id = property(_get_id, _set_id)

    #------------------------
    _connections = 0
    def _set_connections(self, v):
        self._connections = int(v)

    def _get_connections(self):
        return self._connections

    connections = property(_get_connections, _set_connections)

    #------------------------
    _maskLevel = 0
    def _set_maskLevel(self, v):
        self._maskLevel = int(v)

    def _get_maskLevel(self):
        return self._maskLevel

    maskLevel = property(_get_maskLevel, _set_maskLevel)

    #------------------------
    _maskGroup = None
    def _set_maskGroup(self, g):
        self.maskLevel = g.id
        self._maskGroup = None

    def _get_maskGroup(self):
        if not self.maskLevel:
            return None
        elif not self._maskGroup:
            groups = self.console.storage.getGroups()

            for g in groups:
                if g.id & self.maskLevel:
                    self._maskGroup = g
                    break

        return self._maskGroup

    maskGroup = property(_get_maskGroup, _set_maskGroup)

    def _get_maskedGroup(self):
        group = self.maskGroup
        if group:
            return group
        else:
            return self.maxGroup

    maskedGroup = property(_get_maskedGroup)

    def _get_maskedLevel(self):
        group = self.maskedGroup
        if group:
            return group.level
        else:
            return 0

    maskedLevel = property(_get_maskedLevel)

    #------------------------
    _ip = ''
    def _set_ip(self, ip):
        if ':' in ip:
            ip = ip[0:ip.find(':')]
        if self._ip != ip:
            self.makeIpAlias(self._ip)
        self._ip = ip

    def _get_ip(self):
        return self._ip

    ip = property(_get_ip, _set_ip)

    #------------------------
    def _set_timeAdd(self, time):
        self._timeAdd = int(time)

    def _get_timeAdd(self):
        return self._timeAdd

    timeAdd = property(_get_timeAdd, _set_timeAdd)

    #------------------------
    def _set_data(self, data):
        for k, v in data.iteritems():
            self._data[k] = v

    def _get_data(self):
        return self._data

    data = property(_get_data, _set_data)

    #------------------------
    def _set_timeEdit(self, time):
        self._timeEdit = int(time)

    def _get_timeEdit(self):
        return self._timeEdit

    timeEdit = property(_get_timeEdit, _set_timeEdit)

    #------------------------
    _team = b3.TEAM_UNKNOWN
    def _set_team(self, team):
        if self._team != team:
            self._team = team
            if self.console:
                self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_TEAM_CHANGE, self.team, self))

    def _get_team(self):
        return self._team

    team = property(_get_team, _set_team)

    #------------------------
    _name = ''
    _exactName = ''

    def _set_name(self, name):
        if self.console:
            newName = self.console.stripColors(name)
        else:
            newName = name.strip()

        if self._name == newName:
            if self.console:
                self.console.verbose2('Aborted Making Alias for cid: %s, name is the same' % self.cid)
            return
        if self.cid == '-1' or self.cid == 'Server': # bfbc2 addition
            if self.console:
                self.console.verbose2('Aborted Making Alias for cid: %s, must be B3' % self.cid)
            return
        
        self.makeAlias(self._name)
        self._name = newName
        self._exactName = name + '^7'
            
        if self.console and self.authed:
            self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_NAME_CHANGE, self.name, self))

    def _get_name(self):
        return self._name
        
    def _get_exactName(self):
        return self._exactName

    name = property(_get_name, _set_name)
    exactName = property(_get_exactName, _set_name)

    #------------------------
    _maxLevel = None
    _maxGroup = None
    def _get_maxLevel(self):
        if self._maxLevel == None:
            if self.groups and len(self.groups):
                m = -1
                for g in self.groups:
                    if g.level > m:
                        m = g.level
                        self._maxGroup = g

                self._maxLevel = m
            elif self._tempLevel:
                self._maxGroup = Group(id=-1, name='Unspecified', level=self._tempLevel)
                return self._tempLevel
            else:
                return 0

        return self._maxLevel

    maxLevel = property(_get_maxLevel)

    def _get_maxGroup(self):
        self._get_maxLevel()
        return self._maxGroup

    maxGroup = property(_get_maxGroup)

    def refreshLevel(self):
        self._maxLevel = None
        self._groups = None

    #------------------------
    def disconnect(self):
        self.console.clients.disconnect(self)

    def kick(self, reason='', keyword=None, admin=None, silent=False, data='', *kwargs):
        self.console.kick(self, reason, admin, silent)

        if self.id:
            ban = ClientKick()
            ban.timeExpire = 0
            ban.clientId = self.id
            ban.keyword = keyword
            ban.data = data

            if admin:
                ban.adminId = admin.id
            else:
                ban.adminId = 0

            ban.reason = reason
            ban.save(self.console)

    def ban(self, reason='', keyword=None, admin=None, silent=False, data='', *kwargs):
        self.console.ban(self, reason, admin, silent)

        if self.id:
            ban = ClientBan()
            ban.timeExpire = -1
            ban.clientId = self.id
            ban.keyword = keyword
            ban.data = data

            if admin:
                ban.adminId = admin.id
            else:
                ban.adminId = 0

            ban.reason = reason
            ban.save(self.console)

    def reBan(self, ban):
        if ban.timeExpire == -1:
            self.console.ban(self, ban.reason, None, True)
        elif ban.timeExpire > self.console.time():
            self.console.tempban(self, ban.reason, int((ban.timeExpire - self.console.time()) / 60), None, True)

    def unban(self, reason='', admin=None, silent=False, *kwargs):
        self.console.unban(self, reason, admin, silent)
        for ban in self.bans:
            ban.inactive = 1
            ban.save(self.console)

    def tempban(self, reason='', keyword=None, duration=2, admin=None, silent=False, data='', *kwargs):
        duration = functions.time2minutes(duration)
        self.console.tempban(self, reason, duration, admin, silent)

        if self.id:
            ban = ClientTempBan()
            ban.timeExpire = self.console.time() + (duration * 60)
            ban.clientId = self.id
            ban.duration = duration
            ban.keyword = keyword
            ban.data = data

            if admin:
                ban.adminId = admin.id
            else:
                ban.adminId = 0

            ban.reason = reason
            ban.save(self.console)

    def message(self, msg):
        self.console.message(self, msg)

    def warn(self, duration, warning, keyword=None, admin=None, data=''):
        if self.id:
            duration = functions.time2minutes(duration)

            warn = ClientWarning()
            warn.timeExpire = self.console.time() + (duration * 60)
            warn.clientId = self.id
            warn.duration = duration
            warn.data = data

            if admin:
                warn.adminId = admin.id
            else:
                warn.adminId = 0

            warn.reason = warning
            warn.keyword = keyword
            warn.save(self.console)

            return warn
        return None

    def notice(self, notice, spare, admin=None):
        if self.id:
            warn = ClientNotice()
            warn.timeAdd = self.console.time()
            warn.clientId = self.id

            if admin:
                warn.adminId = admin.id
            else:
                warn.adminId = 0

            warn.reason = notice
            warn.save(self.console)

    def _get_numWarns(self):
        if not self.id:
            return 0

        return self.console.storage.numPenalties(self, 'Warning')

    numWarnings = property(_get_numWarns)

    def _get_lastWarn(self):
        if not self.id:
            return None

        return self.console.storage.getClientLastPenalty(self, 'Warning')

    lastWarning = property(_get_lastWarn)

    def _get_firstWarn(self):
        if not self.id:
            return None

        return self.console.storage.getClientFirstPenalty(self, 'Warning')

    firstWarning = property(_get_firstWarn)



    def _get_numBans(self):
        if not self.id:
            return 0

        return self.console.storage.numPenalties(self, ('Ban', 'TempBan'))

    numBans = property(_get_numBans)

    def _get_lastBan(self):
        if not self.id:
            return None

        return self.console.storage.getClientLastPenalty(self, ('Ban', 'TempBan'))

    lastBan = property(_get_lastBan)

    def makeAlias(self, name):
        if not self.id or not name:
            return

        try:
            alias = self.console.storage.getClientAlias(Alias(clientId=self.id,alias=name))
        except KeyError:
            alias = None

        if alias:
            if alias.numUsed > 0:
                alias.numUsed += 1
            else:
                alias.numUsed = 1
        else:
            alias = Alias(clientId=self.id, alias=name)

        alias.save(self.console)
        self.console.bot('New alias for %s: %s', str(self.id), alias.alias)

    def makeIpAlias(self, ip):
        if not self.id or not ip:
            return

        try:
            alias = self.console.storage.getClientIpAddress(IpAlias(clientId=self.id, ip=ip))
        except KeyError:
            alias = None

        if alias:
            if alias.numUsed > 0:
                alias.numUsed += 1
            else:
                alias.numUsed = 1
        else:
            alias = IpAlias(clientId=self.id, ip=ip)

        alias.save(self.console)
        self.console.bot('New alias for %s: %s', str(self.id), alias.ip)

    def save(self, console=None):
        self.timeEdit = time.time()

        if self.guid == None or str(self.guid) == '0':
            # can't save a client without a guid
            return False
        else:
            if console:
                self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_UPDATE, data=self, client=self))
            return self.console.storage.setClient(self)

    def auth(self):
        if not self.authed and self.guid and not self.authorizing:
            self.authorizing = True

            name = self.name
            ip = self.ip
            try:
                inStorage = self.console.storage.getClient(self)
            except KeyError, msg:
                self.console.debug('User not found %s: %s', self.guid, msg)
                inStorage = False
            except Exception, e:
                self.console.error('auth self.console.storage.getClient(client) - %s\n%s', e, traceback.extract_tb(sys.exc_info()[2]))
                self.authorizing = False
                return False

            #lastVisit = None
            if inStorage:
                self.console.bot('Client found in storage %s, welcome back %s', str(self.id), self.name)
                self.lastVisit = self.timeEdit
            else:
                self.console.bot('Client not found in the storage %s, create new', str(self.guid))

            self.connections = int(self.connections) + 1
            self.name = name
            self.ip = ip
            self.save()
            self.authed = True

            self.console.debug('Client Authorized: [%s] %s - %s', self.cid, self.name, self.guid)

            # check for bans
            if self.numBans > 0:
                ban = self.lastBan
                if ban:
                    self.reBan(ban)
                    self.authorizing = False
                    return False

            self.refreshLevel()

            self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_AUTH,
                self,
                self))

            self.authorizing = False

            return self.authed
        else:
            return False

    def __str__(self):
        return "Client<@%s:%s|%s:\"%s\":%s>" % (self.id, self.guid, self.pbid, self.name, self.cid)

#-----------------------------------------------------------------------------------------------------------------------
class Struct(object):
    def __init__(self, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

    #------------------------
    _id = 0
    def _set_id(self, v):
        if not v:
            self._id = 0
        else:
            self._id = int(v)

    def _get_id(self):
        return self._id

    id = property(_get_id, _set_id)

#-----------------------------------------------------------------------------------------------------------------------
class Penalty(Struct):
    type = ''
    inactive = 0
    clientId = None
    adminId  = None
    reason = ''
    keyword = ''
    data = ''

    def _set_timeExpire(self, v):
        self._timeExpire = int(v)

    def _get_timeExpire(self):
        return self._timeExpire

    timeExpire = property(_get_timeExpire, _set_timeExpire)

    def _set_timeAdd(self, v):
        self._timeAdd = int(v)

    def _get_timeAdd(self):
        return self._timeAdd

    timeAdd = property(_get_timeAdd, _set_timeAdd)

    def _set_timeEdit(self, v):
        self._timeEdit = int(v)

    def _get_timeEdit(self):
        return self._timeEdit

    timeEdit = property(_get_timeEdit, _set_timeEdit)

    def _set_duration(self, v):
        self._duration = functions.time2minutes(v)

    def _get_duration(self):
        return self._duration

    duration = property(_get_duration, _set_duration)

    def save(self, console):
        self.timeEdit = console.time()

        if not self.id:
            self.timeAdd = console.time()
        return console.storage.setClientPenalty(self)

class ClientWarning(Penalty):
    type = 'Warning'

    def _get_reason(self):
        return self.reason
    def _set_reason(self, value):
        self.reason = value

    warning = property(_get_reason, _set_reason)

class ClientNotice(Penalty):
    type = 'Notice'

    def _get_reason(self):
        return self.reason
    def _set_reason(self, value):
        self.reason = value

    notice = property(_get_reason, _set_reason)

class ClientBan(Penalty):
    type = 'Ban'

class ClientTempBan(Penalty):
    type = 'TempBan'

class ClientKick(Penalty):
    type = 'Kick'

#-----------------------------------------------------------------------------------------------------------------------
class Alias(Struct):
    alias    = ''
    timeAdd  = 0
    timeEdit = 0
    numUsed  = 1
    clientId = 0

    def save(self, console):
        self.timeEdit = console.time()

        if not self.id:
            self.timeAdd = console.time()
        return console.storage.setClientAlias(self)

#-----------------------------------------------------------------------------------------------------------------------
class IpAlias(Struct):
    ip = None
    timeAdd  = 0
    timeEdit = 0
    numUsed  = 1
    clientId = 0

    def save(self, console):
        self.timeEdit = console.time()

        if not self.id:
            self.timeAdd = console.time()
        return console.storage.setClientIpAddresse(self)
    
    def __str__(self):
        return "IpAlias(id=%s, ip=\"%s\", clientId=%s, numUsed=%s)" % (self.id, self.ip, self.clientId, self.numUsed)

#-----------------------------------------------------------------------------------------------------------------------
class Group(Struct):
    name    = ''
    keyword = ''
    level    = 0
    timeAdd  = 0
    timeEdit = 0

    def save(self, console):
        self.timeEdit = console.time()

        if not self.id:
            self.timeAdd = console.time()
        return console.storage.setGroup(self)

    def __repr__(self):
        return "Group(%r)" % self.__dict__

#-----------------------------------------------------------------------------------------------------------------------
class Clients(dict):
    _nameIndex    = None
    _guidIndex    = None
    _exactNameIndex = None
    _authorizing = False

    console = None

    def __init__(self, console):
        self.console = console
        self._nameIndex    = {}
        self._guidIndex    = {}
        self._exactNameIndex = {}

    def find(self, id, max=None):
        matches = self.getByMagic(id)

        if len(matches) == 0:
            return None
        elif len(matches) > max:
            return matches[0:max]
        else:
            return matches

    def getByName(self, name):
        name = name.lower()

        try:
            return self[self._nameIndex[name]]
        except:
            for cid,c in self.items():
                if c.name and c.name.lower() == name:
                    #self.console.debug('Found client by name %s = %s', name, c.name)
                    self._nameIndex[name] = c.cid
                    return c

        return None

    def getByExactName(self, name):
        name = name.lower() + '^7'

        try:
            c = self[self._exactNameIndex[name]]
            #self.console.debug('Found client by exact name in index %s = %s : %s', name, c.exactName, c.__class__.__name__)
            return c
        except:
            for cid,c in self.items():
                if c.exactName and c.exactName.lower() == name:
                    #self.console.debug('Found client by exact name %s = %s', name, c.exactName)
                    self._exactNameIndex[name] = c.cid
                    return c

        return None

    def getList(self):
        clist = []
        for cid,c in self.items():
            if not c.hide:
                clist.append(c)
        return clist

    def getClientsByLevel(self, min=0, max=100, masked=False):
        clist = []
        min, max = int(min), int(max)
        for cid,c in self.items():
            if c.hide:
                continue
            elif not masked and c.maskGroup and c.maskGroup.level >= min and c.maskGroup.level <= max:
                clist.append(c)
            elif not masked and c.maskGroup:
                continue
            elif c.maxLevel >= min and c.maxLevel <= max:
                #self.console.debug('getClientsByLevel hidden = %s', c.hide)
                clist.append(c)
        return clist

    def getClientsByName(self, name):
        clist = []
        needle = re.sub(r'\s', '', name.lower())
        for cid,c in self.items():
            cleanname = re.sub(r'\s', '', c.name.lower())
            if not c.hide and needle in cleanname:
                clist.append(c)
        return clist

    def getClientLikeName(self, name):
        name = name.lower()
        for cid,c in self.items():
            if not c.hide and string.find(c.name.lower(), name) != -1:
                return c

        return None

    def getClientsByState(self, state):
        clist = []
        for cid,c in self.items():
            if not c.hide and c.state == state:
                clist.append(c)

        return clist

    def getByDB(self, id):
        m = re.match(r'^@([0-9]+)$', id)
        if m:
            # seems to be a client db id
            try:
                sclient = self.console.storage.getClientsMatching({ 'id' : m.group(1) })

                if not sclient:
                    return []
                else:
                    clients = []
                    for c in sclient:
                        c.clients = self
                        c.console = self.console
                        c.exactName = c.name
                        clients.append(c)
                        if len(clients) == 5:
                            break

                    return clients
            except:
                return []
        else:
            return self.lookupByName(id)

    def getByMagic(self, id):
        id = id.strip()

        if re.match(r'^[0-9]+$', id):
            # seems to be a client id
            client = self.getByCID(id)
            if client:
                return [client]
            else:
                return []
        elif re.match(r'^@([0-9]+)$', id):
            return self.getByDB(id)
        elif id[:1] == '\\':
            c = self.getByName(id[1:])
            if c and not c.hide:
                return [c]
            else:
                return []
        else:
            return self.getClientsByName(id)

    def getByGUID(self, guid):
        guid = guid.upper()

        try:
            return self[self._guidIndex[guid]]
        except:
            for cid,c in self.items():
                if c.guid and c.guid == guid:
                    self._guidIndex[guid] = c.cid
                    return c
                elif functions.fuzzyGuidMatch(c.guid, guid):
                    # Found by fuzzy matching, don't index
                    return c
                    
        return None

    def getByCID(self, cid):
        try:
            c = self[cid]
        except KeyError:
            return None
        except Exception, e:
            self.console.error('Unexpected error getByCID(%s) - %s', cid, e)
        else:
            #self.console.debug('Found client by CID %s = %s', cid, c.name)
            if c.cid == cid:
                return c
            else: 
                return None

        return None

    def lookupByName(self, name):
        # first check connected users
        c = self.getClientLikeName(name)
        if c and not c.hide:
            return [c]

        sclient = self.console.storage.getClientsMatching({ '%name%' : name })

        if not sclient:
            return []
        else:
            clients = []
            for c in sclient:
                c.clients = self
                c.console = self.console
                c.exactName = c.name
                clients.append(c)
                if len(clients) == 5:
                    break

            return clients

    def lookupSuperAdmins(self):
        try:
            group = Group(keyword='superadmin')
            group = self.console.storage.getGroup(group)
        except Exception, e:
            self.console.error('^7Could not get superadmin group: %s', e)
            return False

        sclient = self.console.storage.getClientsMatching({ '&group_bits' : group.id })

        if not sclient:
            return []
        else:
            clients = []
            for c in sclient:
                c.clients = self
                c.console = self.console
                c.exactName = c.name
                clients.append(c)
 
            return clients

    def disconnect(self, client):
        client.connected = False
        if client.cid == None:
            return
        
        cid = client.cid
        if self.has_key(cid):
            self[cid] = None
            del self[cid]
            self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_DISCONNECT, cid, client=client))

        self.resetIndex()

    def resetIndex(self):
        # reset the indexes
        self._nameIndex    = {}
        self._guidIndex    = {}
        self._exactNameIndex = {}

    def newClient(self, cid, **kwargs):
        client = Client(console=self.console, cid=cid, timeAdd=self.console.time(), **kwargs)
        self[client.cid] = client
        self.resetIndex()

        self.console.debug('Client Connected: [%s] %s - %s (%s)', self[client.cid].cid, self[client.cid].name, self[client.cid].guid, self[client.cid].data)

        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_CONNECT,
            client,
            client))
    
        if client.guid:
            client.auth()
        elif not client.authed:
            self.authorizeClients()
        return client

    def empty(self):
        self.clear()

    def clear(self):
        self.resetIndex()
        for cid,c in self.items():
            if not c.hide:
                del self[cid]

    def sync(self):
        mlist = self.console.sync()

        # remove existing clients
        self.clear()

        # add list of matching clients
        for cid, c in mlist.iteritems():
            self[cid] = c

    def authorizeClients(self):
        if not self._authorizing:
            # lookup is delayed to allow time for auth
            # it will also allow us to batch the lookups if several players
            # are joining at once
            self._authorizing = True
            t = threading.Timer(5, self._authorizeClients)
            t.start()

    def _authorizeClients(self):
        self.console.authorizeClients()
        self._authorizing = False

if __name__ == '__main__':
    from b3.fake import fakeConsole
    from b3.fake import joe

    game = b3.game.Game(fakeConsole, 'fakegamename')
    joe.connects(cid=3)

    print 'maxLevel: '
    print joe.maxLevel
    print type(joe.maxLevel)


########NEW FILE########
__FILENAME__ = config
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# change log :
# 22/02/2009 - 1.2.1 - Courgette
# - fix the compatibility issue with ElementTree  and display an explicit
#    error message to avoid noobish questions on B3 forums :P
# 14/11/2009 - 1.2.2 - Courgette
# - detect xml parsing errors and raise a specific exception in that case
# 22/11/2009 - 1.2.3 - Courgette
# - fix bug with resolution of @conf on linux
# 29/11/2009 - 1.3.0 - Courgette
# XmlConfigParser can also be parsed from string
# 20/12/2009 - 1.3.1 - Courgette
# Fix bug in resolving @b3 which was failing for the win32 standalone release
# 03/12/2011 - 1.3.2 - Courgette
# Fixes xlr8or/big-brother-bot#18 : @conf in XML only works when b3_run.py config parameter contains path component
# 31/03/2012 - 1.3.3 -Courgette
# Change behavior of XmlConfigParser methods getboolean, getint, getfloat when config value is an empty string
# 11/04/2012 - 1.4 - Courgette
# CfgConfigParser now implements methods getDuration, getboolean, getpath, loadFromString
#
__author__  = 'ThorN'
__version__ = '1.4'

import sys, time
import b3
from xml.parsers.expat import ExpatError

try:
    from b3.lib.elementtree import ElementTree
except ImportError, err:
    try:
        from xml.etree import ElementTree
    except ImportError, err:
        sys.stderr.write("""FATAL ERROR : Cannot load elementtree
      Check that you have installed ElementTree.
      On Linux Debian : apt-get install python-elementtree
      """)
        sys.exit(1)

import ConfigParser
import os
import b3.functions


class B3ConfigParserMixin:
    """ mixin implementing ConfigParser methods more useful for B3 business """

    def getTextTemplate(self, section, setting=None, **kwargs):
        value = b3.functions.vars2printf(self.get(section, setting, True)).strip()
        if len(kwargs):
            return value % kwargs
        else:
            return value

    def getDuration(self, section, setting=None):
        value = self.get(section, setting).strip()
        return b3.functions.time2minutes(value)

    def getboolean(self, section, setting):
        value_raw = self.get(section, setting)
        value = value_raw.lower() if value_raw else ''

        if value in ('yes', '1', 'on', 'true'):
            return True
        elif value in ('no', '0', 'off', 'false'):
            return False
        else:
            raise ValueError("%s.%s : '%s' is not a boolean value" % (section, setting, value))

    def getpath(self, section, setting):
        """Return an absolute path name and expand the user prefix (~)"""
        path = self.get(section, setting)

        if path[0:3] == '@b3':
            path = "%s/%s" % (b3.getB3Path(), path[3:])
        elif path[0:6] == '@conf/' or path[0:6] == '@conf\\':
            path = os.path.join(b3.getConfPath(), path[6:])

        return os.path.normpath(os.path.expanduser(path))


class XmlConfigParser(B3ConfigParserMixin):
    """\
    A config parser class that mimics the ConfigParser settings but reads
    from an XML format
    """

    _xml = None
    _settings = None

    fileName = ''
    fileMtime = 0

    def readfp(self, fp):
        """\
        Read the xml config file from a file pointer
        """
        try:
            self._xml = ElementTree.parse(fp)
        except ExpatError, e:
            raise ConfigFileNotValid("%s" % e)

        self._loadSettings()

    def setXml(self, xml):
        """\
        Read the xml config file from a string
        """
        self._xml = ElementTree.fromstring(xml)

        self._loadSettings()

    def _loadSettings(self):
        self._settings = {}
        for settings in self._xml.findall("./settings"):
            section = settings.get('name')

            self._settings[section] = {}

            for setting in settings.findall("./set"):
                name  = setting.get('name')
                value = setting.text

                self._settings[section][name] = value


    def get(self, section, setting=None, dummy=False):
        if setting is None:
            # parse as xpath
            return self._xml.findall(section)
        else:
            try:
                data = self._settings[section][setting]
                if data is None:
                    return ''
                else:
                    return data
            except KeyError:
                raise ConfigParser.NoOptionError(setting, section)

    def getint(self, section, setting):
        value = self.get(section, setting)
        if value is None:
            raise ValueError("%s.%s : '' is not an integer" % (section, setting))
        return int(self.get(section, setting))

    def getfloat(self, section, setting):
        value = self.get(section, setting)
        if value is None:
            raise ValueError("%s.%s : '' is not a number" % (section, setting))
        return float(self.get(section, setting))

    def sections(self):
        return self._settings.keys()

    def options(self, section):
        return self._settings[section].keys()

    def has_section(self, section):
        try:
            self._settings[section]
        except KeyError:
            return False
        else:
            return True

    def has_option(self, section, setting):
        try:
            self._settings[section][setting]
        except KeyError:
            return False
        else:
            return True

    def items(self, section):
        return self._settings[section].items()

    def load(self, fileName):

        if not os.path.isfile(fileName):
            raise ConfigFileNotFound(fileName)

        f = file(fileName, 'r')
        self.readfp(f)
        f.close()

        self.fileName  = fileName
        self.fileMtime = os.path.getmtime(self.fileName)

        return True

    def loadFromString(self, xmlstring):
        """\
        Read the xml config from a string
        """
        
        self.fileName  = None
        self.fileMtime = time.time()
        
        try:
            self._xml = ElementTree.XML(xmlstring)
        except ExpatError, e:
            raise ConfigFileNotValid("%s" % e)

        self._loadSettings()
        return True

    def save(self):
        # not implemented
        return True

    def set(self, section, option, value):
        # not implemented
        pass
        

class CfgConfigParser(B3ConfigParserMixin, ConfigParser.ConfigParser):
    """\
    A config parser class that mimics the ConfigParser, reads the cfg format
    """

    fileName = ''
    fileMtime = 0

    def get(self, section, option, *args, **kwargs):
        try:
            return ConfigParser.ConfigParser.get(self, section, option, *args, **kwargs)
        except ConfigParser.NoSectionError:
            # plugins are used to only catch NoOptionError
            raise ConfigParser.NoOptionError(option, section)

    def load(self, fileName):
        f = file(fileName, 'r')
        self.readfp(f)
        f.close()

        self.fileName  = fileName
        self.fileMtime = os.path.getmtime(self.fileName)

        return True

    def loadFromString(self, cfg_string):
        """ Read the cfg config from a string """
        import StringIO
        fp = StringIO.StringIO(cfg_string)
        self.readfp(fp)
        fp.close()
        self.fileName  = None
        self.fileMtime = time.time()
        return True

    def save(self):
        f = file(self.fileName, 'w')
        self.write(f)
        f.close()

        return True



def load(fileName):
    if os.path.splitext(fileName)[1].lower() == '.xml':
        config = XmlConfigParser()
    else:
        config = CfgConfigParser()

    fileName = os.path.normpath(fileName)
    if fileName[0:4] == '@b3\\' or fileName[0:4] == '@b3/':
        fileName = os.path.normpath("%s/%s" % (b3.getB3Path(), fileName[3:]))
    elif fileName[0:6] == '@conf\\' or fileName[0:6] == '@conf/':
        fileName = os.path.normpath("%s/%s" % (b3.getConfPath(), fileName[5:]))

    if config.load(fileName):
        return config
    else:
        return None


class ConfigFileNotFound(Exception):
    def __init__(self, value):
        Exception.__init__(self, value)
    def __str__(self):
        return repr(self.value)


class ConfigFileNotValid(Exception):
    def __init__(self, value):
        Exception.__init__(self, value)
    def __str__(self):
        return repr(self.value)

########NEW FILE########
__FILENAME__ = cron
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 11/30/2005 - 1.3.0 - ThorN
#    * Added PluginCronTab
# 10/24/2010 - 1.4.0 - Courgette
#    * make the cron able to run command every second (was limited to every 15 seconds before)
#    * more cron syntax accepted. '5-12/2, 30, 40-42' is now a valid syntax to specify [5,7,9,11,30,40,41,42]
#    * add tests
# 11/16/2010 - 1.4.1 - Courgette
#    * removing a non existing crontab does not raise a KeyError anymore
#
__author__  = 'ThorN, Courgette'
__version__ = '1.4.1'

import re, thread, threading, time, traceback, sys

class ReMatcher:
    _re = None
    def match(self, regexp, value):
        self._re = re.match(regexp, value)
        return self._re

    def _get_match(self):
        return self._re

    results = property(_get_match)

class CronTab(object):
    _second = None
    _minute = None
    _hour = None
    _day = None
    _month = None
    _dow = None
    command = None
    maxRuns = 0
    numRuns = 0

    def __init__(self, command, second=0, minute='*', hour='*', day='*', month='*', dow='*'):
        self.second = second
        self.minute = minute
        self.hour = hour
        self.day = day
        self.month = month
        self.dow = dow
        self.command = command

    def run(self):
        self.command()

    def _set_second(self, value):
        self._second = self._getRate(value, 60)
    def _get_second(self):
        return self._second
    second = property(_get_second, _set_second)

    def _set_minute(self, value):
        self._minute = self._getRate(value, 60)
    def _get_minute(self):
        return self._minute
    minute = property(_get_minute, _set_minute)

    def _set_hour(self, value):
        self._hour = self._getRate(value, 24)
    def _get_hour(self):
        return self._hour
    hour = property(_get_hour, _set_hour)

    def _set_day(self, value):
        self._day = self._getRate(value, 31)
    def _get_day(self):
        return self._day
    day = property(_get_day, _set_day)

    def _set_month(self, value):
        self._month = self._getRate(value, 12)
    def _get_month(self):
        return self._month
    month = property(_get_month, _set_month)

    def _set_dow(self, value):
        self._dow = self._getRate(value, 7)
    def _get_dow(self):
        return self._dow
    dow = property(_get_dow, _set_dow)

    def _getRate(self, rate, max=None):
        if type(rate) == str:
            if ',' in rate:
                # 10,20,30 = [10, 20, 30]
                # 5,6,7,20,30 = [5-7, 20, 30]
                # 5,7,9,11,30,40,41,42 = [5-12/2, 30, 40-42]
                myset = {}
                for fragment in rate.split(','):
                    result = self._getRateFromFragment(fragment.strip(), max) 
                    if type(result) == int:
                        myset[result] = None
                    else:
                        for val in result:
                            myset[int(val)] = None
                mylist = myset.keys()
                mylist.sort()
                return mylist
            else:
                return self._getRateFromFragment(rate, max)
        elif type(rate) == int:
            if rate < 0 or rate >= max:
                raise ValueError('accepted range is 0-%s' % (max-1))
            return rate
        elif type(rate) == float:
            if int(rate) < 0 or int(rate) >= max:
                raise ValueError('accepted range is 0-%s' % (max-1))
            return int(rate)

        raise TypeError('"%s" is not a known cron rate type' % rate)
    
    def _getRateFromFragment(self, rate, max):
        r = ReMatcher()
        if rate == '*':
            return -1
        elif r.match(r'^([0-9]+)$', rate):
            if int(rate) >= max:
                raise ValueError('%s cannot be over %s' % (rate, max-1))
            return int(rate)
        elif r.match(r'^\*/([0-9]+)$', rate):
            # */10 = [0, 10, 20, 30, 40, 50]
            step = int(r.results.group(1))
            if step > max:
                raise ValueError('%s cannot be over every %s' % (rate, max-1))
            return range(0, max, step)
        elif r.match(r'^(?P<lmin>[0-9]+)-(?P<lmax>[0-9]+)(/(?P<step>[0-9]+))?$', rate):
            # 10-20 = [0, 10, 20, 30, 40, 50]
            lmin = int(r.results.group('lmin'))
            lmax = int(r.results.group('lmax'))
            step = r.results.group('step')
            if step is None:
                step = 1
            else:
                step = int(step)
            if step > max:
                raise ValueError('%s is out of accepted range 0-%s' % (step, max))
            if lmin < 0 or lmax > max:
                raise ValueError('%s is out of accepted range 0-%s' % (rate, max-1))
            if lmin > lmax:
                raise ValueError('%s cannot be greater than %s in %s' % (lmin, lmax, rate))
            return range(lmin, lmax + 1, step)
        raise TypeError('"%s" is not a known cron rate type' % rate)
    
    def _match(self, unit, value):
        if type(unit) == int:
            if unit == -1 or unit == value:
                return True
        elif value in unit:
            return True
        return False

    def match(self, timetuple):
        # See if the cron entry matches the current time
        # second
        timeMatch = self._match(self.second, timetuple[5] - (timetuple[5] % 1))
        # minute
        timeMatch = timeMatch and self._match(self.minute, timetuple[4])
        # hour
        timeMatch = timeMatch and self._match(self.hour, timetuple[3])
        # day
        timeMatch = timeMatch and self._match(self.day, timetuple[2])
        # month
        timeMatch = timeMatch and self._match(self.month, timetuple[1])
        # weekday (in crontab 0 is Mon)
        timeMatch = timeMatch and self._match(self.dow, timetuple[6])
        return timeMatch

class OneTimeCronTab(CronTab):
    def __init__(self, command, second=0, minute='*', hour='*', day='*', month='*', dow='*'):
        CronTab.__init__(self, command, second, minute, hour, day, month, dow)
        self.maxRuns = 1

class PluginCronTab(CronTab):
    plugin = None

    def __init__(self, plugin, command, second=0, minute='*', hour='*', day='*', month='*', dow='*'):
        CronTab.__init__(self, command, second, minute, hour, day, month, dow)
        self.plugin = plugin

    def match(self, timetuple):
        if self.plugin.isEnabled():
            return CronTab.match(self, timetuple)
        else:
            return False

    def run(self):
        if self.plugin.isEnabled():
            CronTab.run(self)

class Cron(object):
    def __init__(self, console):
        self._tabs = {}
        self.console = console

        # thread will stop if this event gets set
        self._stopEvent = threading.Event()

    def create(self, command, second='*', minute='*', hour='*', day='*', month='*', dow='*'):
        t = CronTab(command, second, minute, hour, day, month, dow)
        return self.add(t)

    def add(self, tab):
        self._tabs[id(tab)] = tab
        self.console.verbose('Added crontab %s (%s) - %ss %sm %sh %sd %sM %sDOW' % (tab.command, id(tab), tab.second, tab.minute, tab.hour, tab.day, tab.month, tab.dow))
        return id(tab)

    def __add__(self, tab):
        self.add(tab)

    def __sub__(self, tab):
        self.cancel(id(tab))

    def cancel(self, id):
        try:
            del self._tabs[id]
            self.console.verbose('Removed crontab %s' % id)
        except KeyError:
            self.console.verbose('crontab %s not found' % id)

    def start(self):
        #self.run()
        thread.start_new_thread(self.run, ())

    def time(self):
        return time.time()

    def stop(self):
        """Stop the cron scheduler"""
        self._stopEvent.set()

    def run(self):
        self.console.info("cron scheduler started")
        nextTime = self.getNextTime()
        while not self._stopEvent.isSet():
            now = self.time()

            if now < nextTime:
                self._stopEvent.wait(nextTime - now + .1)

            # Check if the time has changed by more than two minutes. This
            # case arises when the system clock is changed. We must reset the timer.
            if abs(self.time() - nextTime) > 120:
                nextTime = self.getNextTime()

            t = time.gmtime(nextTime)
            for k,c in self._tabs.items():
                if c.match(t):
                    if c.maxRuns > 0 and c.numRuns + 1 > c.maxRuns:
                        # reached max executions, remove tab
                        del self._tabs[k]
                    else:
                        c.numRuns = c.numRuns + 1

                        try:
                            c.run()
                        except Exception, msg:
                            self.console.error('Error executing crontab %s: %s\n%s', c.command, msg, traceback.extract_tb(sys.exc_info()[2]))

            nextTime = nextTime + 1
        self.console.info("cron scheduler ended")


    def getNextTime(self):
        # store the time first, we don't want it to change on us
        t = time.time()

        # current time, minus it's 1 second remainder, plus 1 seconds
        # will round to the next nearest 1 seconds
        return (t - t % 1) + 1



########NEW FILE########
__FILENAME__ = cvar
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

__author__  = 'ThorN'
__version__ = '1.0.1'

class Cvar(object):
    name = ''
    value = None
    default = None

    def __init__(self, name, **kwargs):
        self.name = name

        if kwargs.has_key('value'):
            self.value = kwargs['value']

        if kwargs.has_key('default'):
            self.default = kwargs['default']

    def __getitem__(self, key):
        if type(key) is int:
            if key == 0:
                return self.value
            elif key == 1:
                return self.default
            else:
                raise KeyError('No key %s' % key)
        else:
            return self.__dict__[key]

    def __repr__(self):
        return '<%s name: "%s", value: "%s", default: "%s">' % (self.__class__.__name__, self.name, self.value, self.default)

    def getString(self):
        return str(self.value)
        
    def getInt(self):
        return int(self.value)

    def getFloat(self):
        return float(self.value)

    def getBoolean(self):
        if self.value in ('yes', '1', 'on', 'true'):
            return True
        elif self.value in ('no', '0', 'off', 'false'):
            return False
        else:
            raise ValueError('%s is not a boolean value' % (self.value))

    def save(self, console):
        """\
        Set the cvars current value
        """
        console.setCvar(self.name, self.value)        

if __name__ == '__main__':
    x = Cvar('testvar', value='1', default='1')

    print x

    print x.name
    print x.value
    print x.default

    print x.getString()
    print x.getInt()
    print x.getFloat()
    print x.getBoolean()

    print x[0]
    print x[1]
    print x[2]
########NEW FILE########
__FILENAME__ = decorators
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#

__author__    = 'Courgette'
__version__   = '1.0'

from functools import partial

class memoize(object):
    """cache the return value of a method

    This class is meant to be used as a decorator of methods. The return value
    from a given method invocation will be cached on the instance whose method
    was invoked. All arguments passed to a method decorated with memoize must
    be hashable.

    If a memoized method is invoked directly on its class the result will not
    be cached. Instead the method will be invoked like a static method:
    class Obj(object):
        @memoize
        def add_to(self, arg):
            return self + arg
    Obj.add_to(1) # not enough arguments
    Obj.add_to(1, 2) # returns 3, result is not cached

    See http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/
    """
    def __init__(self, func):
        self.func = func
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self.func
        return partial(self, obj)
    def __call__(self, *args, **kw):
        obj = args[0]
        try:
            cache = obj.__cache
        except AttributeError:
            cache = obj.__cache = {}
        key = (self.func, args[1:], frozenset(kw.items()))
        try:
            res = cache[key]
        except KeyError:
            res = cache[key] = self.func(*args, **kw)
        return res


########NEW FILE########
__FILENAME__ = events
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# 27/6/2009 : xlr8or: added CLIENT_ACTION event
# 11/11/2009 - 1.1.2 - Courgette
#    * minor transparent changes to the code 
# 30/03/2011 - 1.1.3 - SGT
#    * add EVT_CLIENT_UNBAN
# 06/06/2011 - 1.1.4 - Courgette
#    * add EventsStats class
# 26/03/2011 - 1.2 - Courgette
#    * add event EVT_GAME_MAP_CHANGE
# 27/08/2012 - 1.3 - Courgette
#    * add getKey(event_id) method
# 19/02/2013 - 1.4 - Courgette
#    * fix EventsStats.dumpStats which would fail if called before any event was seen
#    * make EventsStats.dumpStats computations abort if B3 log level lower than required to display the results

__author__  = 'ThorN, xlr8or, Courgette'
__version__ = '1.4'

import re
from collections import deque
import b3
from b3.functions import meanstdv
from b3.decorators import memoize
from b3.output import VERBOSE
from logging import DEBUG

class Events:
    def __init__(self):
        self._eventNames = {}
        self._events = {}
        self.loadEvents((
            ('EVT_EXIT', 'Program Exit'),
            ('EVT_STOP', 'Stop Process'),
            ('EVT_UNKNOWN', 'Unknown Event'),
            ('EVT_CUSTOM', 'Custom Event'),
            ('EVT_CLIENT_SAY', 'Say'),
            ('EVT_CLIENT_TEAM_SAY', 'Team Say'),
            ('EVT_CLIENT_PRIVATE_SAY', 'Private Message'),
            ('EVT_CLIENT_CONNECT', 'Client Connect'),
            ('EVT_CLIENT_AUTH', 'Client Authenticated'),
            ('EVT_CLIENT_DISCONNECT', 'Client Disconnect'),
            ('EVT_CLIENT_UPDATE', 'Client Update'),
            ('EVT_CLIENT_KILL', 'Client Kill'),
            ('EVT_CLIENT_GIB', 'Client Gib'),
            ('EVT_CLIENT_GIB_TEAM', 'Client Gib Team'),
            ('EVT_CLIENT_GIB_SELF', 'Client Gib Self'),
            ('EVT_CLIENT_SUICIDE', 'Client Suicide'),
            ('EVT_CLIENT_KILL_TEAM', 'Client Team Kill'),
            ('EVT_CLIENT_DAMAGE', 'Client Damage'),
            ('EVT_CLIENT_DAMAGE_SELF', 'Client Damage Self'),
            ('EVT_CLIENT_DAMAGE_TEAM', 'Client Team Damage'),
            ('EVT_CLIENT_JOIN', 'Client Join Team'),
            ('EVT_CLIENT_NAME_CHANGE', 'Client Name Change'),
            ('EVT_CLIENT_TEAM_CHANGE', 'Client Team Change'),
            ('EVT_CLIENT_ITEM_PICKUP', 'Client Item Pickup'),
            ('EVT_CLIENT_ACTION', 'Client Action'),
            ('EVT_CLIENT_KICK', 'Client Kicked'),
            ('EVT_CLIENT_BAN', 'Client Banned'),
            ('EVT_CLIENT_BAN_TEMP', 'Client Temp Banned'),
            ('EVT_CLIENT_UNBAN', 'Client Unbanned'),
            ('EVT_GAME_ROUND_START', 'Game Round Start'),
            ('EVT_GAME_ROUND_END', 'Game Round End'),
            ('EVT_GAME_WARMUP', 'Game Warmup'),
            ('EVT_GAME_EXIT', 'Game Exit'),
            ('EVT_GAME_MAP_CHANGE', 'map changed'),
        ))        

    def createEvent(self, key, name=None):
        g = globals()

        try:
            id = self._events[key] = g[key]
        except:
            id = self._events[key] = len(self._events) + 1

        if name:        
            self._eventNames[id] = name
        else:
            self._eventNames[id] = 'Unnamed (%s)' % key

        g[key] = id

        return id

    def getName(self, key):
        try:
            return self._eventNames[self.getId(key)]
        except:
            return 'Unknown (%s)' % key

    def getId(self, key):
        if re.match('^[0-9]+$', str(key)):
            return int(key)
        else:
            try:
                return self._events[key]
            except:
                return None

    @memoize
    def getKey(self, event_id):
        """Get the key of a given event ID"""
        matching_keys = [k for k, v in self._events.iteritems() if v == event_id]
        if not len(matching_keys):
            raise KeyError, "could not find any B3 event with ID %s" % event_id
        assert len(matching_keys) == 1, "expecting only one event key per event ID. %r" % matching_keys
        return matching_keys[0]

    def loadEvents(self, events):
        for k,n in events:
            self.createEvent(k, n)

    def _get_events(self):
        return self._events

    events = property(_get_events)

class Event(object):
    def __init__(self, type, data, client=None, target=None):
        self.time = b3.console.time()
        self.type = type
        self.data = data
        self.client = client
        self.target = target
    def __str__(self):
        return "Event<%s>(%r, %s, %s)" % (eventManager.getKey(self.type), self.data, self.client, self.target)


class EventsStats(object):
    def __init__(self, console, max_samples=100):
        self.console = console
        self._max_samples = max_samples
        self._handling_timers = {}
        self._queue_wait = deque(maxlen=max_samples)
        
    def add_event_handled(self, plugin_name, event_name, milliseconds_elapsed):
        if not self._handling_timers.has_key(plugin_name):
            self._handling_timers[plugin_name] = {}
        if not self._handling_timers[plugin_name].has_key(event_name):
            self._handling_timers[plugin_name][event_name] = deque(maxlen=self._max_samples)
        self._handling_timers[plugin_name][event_name].append(milliseconds_elapsed)
        self.console.verbose2("%s event handled by %s in %0.3f ms", event_name, plugin_name, milliseconds_elapsed)

    def add_event_wait(self,milliseconds_wait):
        self._queue_wait.append(milliseconds_wait)
        
    def dumpStats(self):
        if self.console.log.isEnabledFor(VERBOSE):
            for plugin_name, plugin_timers in self._handling_timers.iteritems():
                for event_name, event_timers in plugin_timers.iteritems():
                    mean, stdv = meanstdv(event_timers)
                    if len(event_timers):
                        self.console.verbose("%s %s : (ms) min(%0.1f), max(%0.1f), mean(%0.1f), stddev(%0.1f)",
                              plugin_name, event_name,  min(event_timers),
                              max(event_timers), mean, stdv)

        if self.console.log.isEnabledFor(DEBUG):
            mean, stdv = meanstdv(self._queue_wait)
            if len(self._queue_wait):
                self.console.debug("Events waiting in queue stats : (ms) min(%0.1f), max(%0.1f), mean(%0.1f), stddev(%0.1f)",
                                 min(self._queue_wait), max(self._queue_wait), mean, stdv)
    
#-----------------------------------------------------------------------------------------------------------------------
# raise to cancel event processing
class VetoEvent(Exception):
    pass

eventManager = Events()

########NEW FILE########
__FILENAME__ = xlrstats
##################################################################
#
# XLRstats
# statistics-generating plugin for B3 (www.bigbrotherbot.net)
# (c) 2004, 2005 Tim ter Laak (ttlogic@xlr8or.com)
#
# This program is free software and licensed under the terms of
# the GNU General Public License (GPL), version 2.
#
##################################################################
# CHANGELOG
# 5/6/2008 - 0.6.0 - Mark Weirath (xlr8or@xlr8or.com)
#   Added weapon replacements
#   Added commands !xlrtopstats and !xlrhide
# 8/9/2008 - 0.6.1 - Mark Weirath (xlr8or@xlr8or.com)
#   Added onemaponly for 24/7 servers to count rounds correct
# 27/6/2009 - 0.6.5 - Mark Weirath (xlr8or@xlr8or.com)
#   No longer save worldkills
# 28/6/2009 - 1.0.0 - Mark Weirath (xlr8or@xlr8or.com)
#   Added Action classes
# 5/2/2010 - 2.0.0 - Mark Weirath (xlr8or@xlr8or.com)
#   Added Assist Bonus and History
# 21/2/2010 - 2.1.0 - Mark Weirath (xlr8or@xlr8or.com)
#   Better assist mechanism
# 23/2/2010 - 2.2.0 - Mark Weirath (xlr8or@xlr8or.com)
#   Adding table maintenance on startup
# 24/2/2010 - 2.2.1 - Mark Weirath (xlr8or@xlr8or.com)
#   Repaired self._xlrstatstables bug
# 24/2/2010 - 2.2.2 - Mark Weirath (xlr8or@xlr8or.com)
#   Repaired updateTableColumns() bug
# 24-3-2010 - 2.2.3 - Mark Weirath - Minor fix in onEvent()
# 10-8-2010 - 2.2.4 - Mark Weirath - BFBC2 adaptions (Bot Guid is Server, not WORLD) 
# 20-8-2010 - 2.2.5 - Mark Weirath
#   Allow external function call for cmd_xlrtopstats
#   Retrieve variables from webfront installation for topstats results
# 23-8-2010 - 2.2.6 - Mark Weirath
#   BugFix: Requires ConfigFile for the commands
# 3-9-2010 - 2.2.7 - Mark Weirath
#   Default action bonus set to +3 skillpoints (was 0)
# 13-10-2010 - 2.2.8 - Mark Weirath
#   BugFix: Empty field webfront Url is now allowed in config
# 08-11-2010 - 2.2.9 - Mark Weirath
#   Harden retrieval of webfront variables
# 07-01-2011 - 2.3 - Mark Weirath
#   XLRstats can now install default database tables when missing
# 07-01-2011 - 2.3.1 - Mark Weirath
#   Ability to disable plugin when not enough players are online
# 07-01-2011 - 2.3.2 - Mark Weirath
#   Update weapon tables for cod7.
# 16-04-2011 - 2.3.3 - Mark Weirath
#   Make sure we hide WORLD and Server in the webfront
# 16-05-2011 - 2.4.0 - Mark Weirath
#   Make use of sql files for updating table, no more methods in the plugin
# 15-07-2011 - 2.5.0 - Mark Weirath
#   Pythonized code.
#   Added ability to hide bots from webfront and exclude damage/kills to and from bots to be processed
# 24-09-2011 - 2.6.0 - Mark Weirath
#   history functionality and crontabs moved to separate sub-plugin
# 24-09-2011 - 2.6.1 - Mark Weirath
#   added update .sql file to distro to enable weaponnames > 32 characters.
#   no actual code was altered in the plugin except for the version to mark the change.
# 19-10-2011 - 2.6.2 - Mark Weirath
#   moved polling for webfront variables to a separate thread, to avoid startup delay when website is offline
# 31-01-2012 - 2.7.0 - Mark Weirath
#   integration of the ctime plugin as a subplugin
# 03-03-2012 - 2.7.1 - Mark Weirath
#   added silent mode and some minor rewrites

# CTime Plugin was created by Anubis and integrated in XLRstats since version 2.7.0
# Updates to this part of the plugin by:
# AFC~Gagi2~ (gagi2@austrian-funclan.com) and xlr8or

# This section is DoxuGen information. More information on how to comment your code
# is available at http://wiki.bigbrotherbot.net/doku.php/customize:doxygen_rules
## @file
# XLRstats Real Time playerstats plugin

__author__ = 'Tim ter Laak / Mark Weirath'
__version__ = '2.7.1' #final version before v3

# Version = major.minor.patches

import datetime
import time
import re
import thread
import threading
import urllib2
import b3
import b3.events
import b3.plugin
import b3.cron

KILLER = "killer"
VICTIM = "victim"
ASSISTER = "assister"

class XlrstatsPlugin(b3.plugin.Plugin):
    requiresConfigFile = True

    _world_clientid = None
    _ffa = ['dm', 'ffa', 'syc-ffa']
    _damage_able_games = ['cod'] # will only count assists when damage is 50 points or more.
    _damage_ability = False
    hide_bots = True # set client.hide to True so bots are hidden from the stats
    exclude_bots = True # kills and damage to and from bots do not affect playerskill

    # history management
    _cronTabWeek = None
    _cronTabMonth = None
    _cronTabKillBonus = None

    # webfront variables
    webfrontUrl = ''
    webfrontConfigNr = 0
    _minKills = 500
    _minRounds = 50
    _maxDays = 14

    # config variables
    defaultskill = 1000
    minlevel = 1
    onemaponly = False

    Kfactor_high = 16
    Kfactor_low = 4
    Kswitch_kills = 100

    steepness = 600
    suicide_penalty_percent = 0.05
    tk_penalty_percent = 0.1
    kill_bonus = 1.5
    assist_bonus = 0.5
    assist_timespan = 2 # on non damage based games: damage before death timespan
    damage_assist_release = 10 # on damage based games: release the assist (wil overwrite self.assist_timespan on startup)
    prematch_maxtime = 70
    announce = False
    keep_history = True
    keep_time = True
    minPlayers = 3 # minimum number of players to collect stats
    _currentNrPlayers = 0 # current number of players present
    silent = False # Disables the announcement when collecting stats = stealth mode

    # keep some private map data to detect prematches and restarts
    last_map = None
    last_roundtime = None

    # names for various stats tables
    playerstats_table = 'xlr_playerstats'
    weaponstats_table = 'xlr_weaponstats'
    weaponusage_table = 'xlr_weaponusage'
    bodyparts_table = 'xlr_bodyparts'
    playerbody_table = 'xlr_playerbody'
    opponents_table = 'xlr_opponents'
    mapstats_table = 'xlr_mapstats'
    playermaps_table = 'xlr_playermaps'
    actionstats_table = 'xlr_actionstats'
    playeractions_table = 'xlr_playeractions'
    clients_table = 'clients'
    penalties_table = 'penalties'
    # default tablenames for the history subplugin
    history_monthly_table = 'xlr_history_monthly'
    history_weekly_table = 'xlr_history_weekly'
    # default table name for the ctime subplugin
    ctime_table = 'ctime'
    #
    _defaultTableNames = True


    def startup(self):
        # get the admin plugin so we can register commands
        self._adminPlugin = self.console.getPlugin('admin')
        if not self._adminPlugin:
            # something is wrong, can't start without admin plugin
            self.error('Could not find admin plugin')
            return False

        # register our commands
        if 'commands' in self.config.sections():
            for cmd in self.config.options('commands'):
                level = self.config.get('commands', cmd)
                sp = cmd.split('-')
                alias = None
                if len(sp) == 2:
                    cmd, alias = sp

                func = self.getCmd(cmd)
                if func:
                    self._adminPlugin.registerCommand(self, cmd, level, func, alias)

        #define a shortcut to the storage.query function
        self.query = self.console.storage.query

        # initialize tablenames
        PlayerStats._table = self.playerstats_table
        WeaponStats._table = self.weaponstats_table
        WeaponUsage._table = self.weaponusage_table
        Bodyparts._table = self.bodyparts_table
        PlayerBody._table = self.playerbody_table
        Opponents._table = self.opponents_table
        MapStats._table = self.mapstats_table
        PlayerMaps._table = self.playermaps_table
        ActionStats._table = self.actionstats_table
        PlayerActions._table = self.playeractions_table

        #--OBSOLETE
        # create tables if necessary
        # This needs to be done here, because table names were loaded from config
        #PlayerStats.createTable(ifNotExists=True)
        #WeaponStats.createTable(ifNotExists=True)
        #WeaponUsage.createTable(ifNotExists=True)
        #Bodyparts.createTable(ifNotExists=True)
        #PlayerBody.createTable(ifNotExists=True)
        #Opponents.createTable(ifNotExists=True)
        #MapStats.createTable(ifNotExists=True)
        #PlayerMaps.createTable(ifNotExists=True)
        #--end OBS

        # create default tables if not present
        # removed to avoid MySQL 5.5 issues locking the db
        #if self._defaultTableNames:
        #    self.console.storage.queryFromFile("@b3/sql/xlrstats.sql", silent=True)

        # register the events we're interested in.
        self.registerEvent(b3.events.EVT_CLIENT_JOIN)
        self.registerEvent(b3.events.EVT_CLIENT_KILL)
        self.registerEvent(b3.events.EVT_CLIENT_KILL_TEAM)
        self.registerEvent(b3.events.EVT_CLIENT_SUICIDE)
        self.registerEvent(b3.events.EVT_GAME_ROUND_START)
        self.registerEvent(b3.events.EVT_CLIENT_ACTION) #for game-events/actions
        self.registerEvent(b3.events.EVT_CLIENT_DAMAGE) #for assist recognition

        # get the Client.id for the bot itself (guid: WORLD or Server(bfbc2/moh/hf))
        sclient = self.console.clients.getByGUID("WORLD")
        if sclient is None:
            sclient = self.console.clients.getByGUID("Server")
        if sclient is not None:
            self._world_clientid = sclient.id
            self.debug('Got client id for B3: %s; %s' % (self._world_clientid, sclient.name))
            #make sure its hidden in the webfront
            player = self.get_PlayerStats(sclient)
            if player:
                player.hide = 1
                self.save_Stat(player)


        #determine the ability to work with damage based assists
        if self.console.gameName[:3] in self._damage_able_games:
            self._damage_ability = True
            self.assist_timespan = self.damage_assist_release

        #investigate if we can and want to keep a history
        self._xlrstatstables = [self.playerstats_table, self.weaponstats_table, self.weaponusage_table,
                                self.bodyparts_table, self.playerbody_table, self.opponents_table, self.mapstats_table,
                                self.playermaps_table, self.actionstats_table, self.playeractions_table]
        if self.keep_history:
            self._xlrstatstables = [self.playerstats_table, self.weaponstats_table, self.weaponusage_table,
                                    self.bodyparts_table, self.playerbody_table, self.opponents_table,
                                    self.mapstats_table, self.playermaps_table, self.actionstats_table,
                                    self.playeractions_table, self.history_monthly_table, self.history_weekly_table]
            _tables = self.showTables(xlrstats=True)
            if (self.history_monthly_table in _tables) and (self.history_monthly_table in _tables):
                self.verbose('History tables are present! Starting Subplugin XLRstatsHistory.')
                #start the xlrstats history plugin
                p = XlrstatshistoryPlugin(self.console, self.history_weekly_table, self.history_monthly_table,
                                          self.playerstats_table)
                p.startup()
            else:
                self.keep_history = False
                self._xlrstatstables = [self.playerstats_table, self.weaponstats_table, self.weaponusage_table,
                                        self.bodyparts_table, self.playerbody_table, self.opponents_table,
                                        self.mapstats_table, self.playermaps_table, self.actionstats_table,
                                        self.playeractions_table]
                self.error(
                    'History Tables are NOT present! Please run b3/docs/xlrstats.sql on your database to install missing tables!')

        #check and update columns in existing tables // This is not working with MySQL server 5.5!
        #self.updateTableColumns()
        #optimize xlrstats tables
        #self.optimizeTables(self._xlrstatstables)

        #let's try and get some variables from our webfront installation
        if self.webfrontUrl and self.webfrontUrl != '':
            thread1 = threading.Thread(target=self.getWebsiteVariables)
            thread1.start()
        else:
            self.debug('No Webfront Url available, using defaults')

        #set proper kill_bonus and crontab
        self.calculateKillBonus()
        if self._cronTabKillBonus:
            self.console.cron - self._cronTabKillBonus
        self._cronTabKillBonus = b3.cron.PluginCronTab(self, self.calculateKillBonus, 0, '*/10')
        self.console.cron + self._cronTabKillBonus

        #start the ctime subplugin
        if self.keep_time:
            p = CtimePlugin(self.console, self.ctime_table)
            p.startup()

        #start the xlrstats controller
        p = XlrstatscontrollerPlugin(self.console, self.minPlayers, self.silent)
        p.startup()

        #get the map we're in, in case this is a new map and we need to create a db record for it.
        map = self.get_MapStats(self.console.game.mapName)
        if map:
            self.verbose('Map %s ready' % map.name)

        msg = 'XLRstats v. %s by %s started.' % (__version__, __author__)
        self.console.say(msg)
        #end startup sequence


    def onLoadConfig(self):
        try:
            self.silent = self.config.getbool('settings', 'silent')
        except:
            self.debug('Using default value (%s) for settings::silent', self.silent)

        try:
            self.hide_bots = self.config.getbool('settings', 'hide_bots')
        except:
            self.debug('Using default value (%s) for settings::hide_bots', self.hide_bots)

        try:
            self.exclude_bots = self.config.getbool('settings', 'exclude_bots')
        except:
            self.debug('Using default value (%s) for settings::exclude_bots', self.exclude_bots)

        try:
            self.minPlayers = self.config.getint('settings', 'minplayers')
        except:
            self.debug('Using default value (%s) for settings::minplayers', self.minPlayers)

        try:
            self.webfrontUrl = self.config.get('settings', 'webfronturl')
        except:
            self.debug('Using default value (%s) for settings::webfronturl', self.webfrontUrl)

        try:
            self.webfrontConfigNr = self.config.getint('settings', 'servernumber')
        except:
            self.debug('Using default value (%i) for settings::servernumber', self.webfrontConfigNr)

        try:
            self.keep_history = self.config.getboolean('settings', 'keep_history')
        except:
            self.debug('Using default value (%i) for settings::keep_history', self.keep_history)

        try:
            self.onemaponly = self.config.getboolean('settings', 'onemaponly')
        except:
            self.debug('Using default value (%i) for settings::onemaponly', self.onemaponly)

        try:
            self.minlevel = self.config.getint('settings', 'minlevel')
        except:
            self.debug('Using default value (%i) for settings::minlevel', self.minlevel)

        try:
            self.defaultskill = self.config.getint('settings', 'defaultskill')
        except:
            self.debug('Using default value (%i) for settings::defaultskill', self.defaultskill)

        try:
            self.Kfactor_high = self.config.getint('settings', 'Kfactor_high')
        except:
            self.debug('Using default value (%i) for settings::Kfactor_high', self.Kfactor_high)

        try:
            self.Kfactor_low = self.config.getint('settings', 'Kfactor_low')
        except:
            self.debug('Using default value (%i) for settings::Kfactor_low', self.Kfactor_low)

        try:
            self.Kswitch_kills = self.config.getint('settings', 'Kswitch_kills')
        except:
            self.debug('Using default value (%i) for settings::Kswitch_kills', self.Kswitch_kills)

        try:
            self.steepness = self.config.getint('settings', 'steepness')
        except:
            self.debug('Using default value (%i) for settings::steepness', self.steepness)

        try:
            self.suicide_penalty_percent = self.config.getfloat('settings', 'suicide_penalty_percent')
        except:
            self.debug('Using default value (%f) for settings::suicide_penalty_percent', self.suicide_penalty_percent)

        try:
            self.tk_penalty_percent = self.config.getfloat('settings', 'tk_penalty_percent')
        except:
            self.debug('Using default value (%f) for settings::tk_penalty_percent', self.tk_penalty_percent)

        #--OBSOLETE
        #try:
        #    self.kill_bonus = self.config.getfloat('settings', 'kill_bonus')
        #except:
        #    self.kill_bonus = 1.2
        #    self.debug('Using default value (%f) for settings::kill_bonus', self.kill_bonus)

        #try:
        #    self.assist_bonus = self.config.getfloat('settings', 'assist_bonus')
        #    #cap off the assistbonus, so it will not be better rewarded than a kill
        #    if self.assist_bonus > 0.9:
        #        self.assist_bonus = 0.9
        #except:
        #    self.debug('Using default value (%f) for settings::assist_bonus', self.assist_bonus)
        #--end OBS

        try:
            self.assist_timespan = self.config.getint('settings', 'assist_timespan')
        except:
            self.debug('Using default value (%d) for settings::assist_timespan', self.assist_timespan)

        try:
            self.damage_assist_release = self.config.getint('settings', 'damage_assist_release')
        except:
            self.debug('Using default value (%d) for settings::damage_assist_release', self.damage_assist_release)

        try:
            self.prematch_maxtime = self.config.getint('settings', 'prematch_maxtime')
        except:
            self.debug('Using default value (%d) for settings::prematch_maxtime', self.prematch_maxtime)

        try:
            self.announce = self.config.getboolean('settings', 'announce')
        except:
            self.debug('Using default value (%d) for settings::announce', self.announce)

        try:
            self.keep_time = self.config.getboolean('settings', 'keep_time')
        except:
            self.debug('Using default value (%d) for settings::keep_time', self.keep_time)

        # Tablenames and stuff
        try:
            self.playerstats_table = self.config.get('tables', 'playerstats')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::playerstats', self.playerstats_table)

        try:
            self.weaponstats_table = self.config.get('tables', 'weaponstats')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::weaponstats', self.weaponstats_table)

        try:
            self.weaponusage_table = self.config.get('tables', 'weaponusage')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::weaponusage', self.weaponusage_table)

        try:
            self.bodyparts_table = self.config.get('tables', 'bodyparts')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::bodyparts', self.bodyparts_table)

        try:
            self.playerbody_table = self.config.get('tables', 'playerbody')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::playerbody', self.playerbody_table)

        try:
            self.opponents_table = self.config.get('tables', 'opponents')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::opponents', self.opponents_table)

        try:
            self.mapstats_table = self.config.get('tables', 'mapstats')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::mapstats', self.mapstats_table)

        try:
            self.playermaps_table = self.config.get('tables', 'playermaps')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::playermaps', self.playermaps_table)

        try:
            self.actionstats_table = self.config.get('tables', 'actionstats')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::actionstats', self.actionstats_table)

        try:
            self.playeractions_table = self.config.get('tables', 'playeractions')
            self._defaultTableNames = False
        except:
            self.debug('Using default value (%s) for tables::playeractions', self.playeractions_table)

        #history tables
        try:
            self.history_monthly_table = self.config.get('tables', 'history_monthly')
            self._defaultTableNames = False
        except:
            self.history_monthly_table = 'xlr_history_monthly'
            self.debug('Using default value (%s) for tables::history_monthly', self.history_monthly_table)

        try:
            self.history_weekly_table = self.config.get('tables', 'history_weekly')
            self._defaultTableNames = False
        except:
            self.history_weekly_table = 'xlr_history_weekly'
            self.debug('Using default value (%s) for tables::history_weekly', self.history_weekly_table)

        #ctime table
        try:
            self.ctime_table = self.config.get('tables', 'ctime')
            self._defaultTableNames = False
        except:
            self.ctime_table = 'ctime'
            self.debug('Using default value (%s) for tables::ctime', self.ctime_table)

        return


    def getCmd(self, cmd):
        cmd = 'cmd_%s' % cmd
        if hasattr(self, cmd):
            func = getattr(self, cmd)
            return func

        return None


    def onEvent(self, event):
        if event.type == b3.events.EVT_CLIENT_JOIN:
            self.join(event.client)
        elif event.type == b3.events.EVT_CLIENT_KILL:
            self.kill(event.client, event.target, event.data)
        elif event.type == b3.events.EVT_CLIENT_KILL_TEAM:
            if self.console.game.gameType in self._ffa:
                self.kill(event.client, event.target, event.data)
            else:
                self.teamkill(event.client, event.target, event.data)
        elif event.type == b3.events.EVT_CLIENT_DAMAGE:
            self.damage(event.client, event.target, event.data)
        elif event.type == b3.events.EVT_CLIENT_SUICIDE:
            self.suicide(event.client, event.target, event.data)
        elif event.type == b3.events.EVT_GAME_ROUND_START:
            self.roundstart()
        elif event.type == b3.events.EVT_CLIENT_ACTION:
            self.action(event.client, event.data)
        else:
            self.dumpEvent(event)


    def dumpEvent(self, event):
        self.debug('xlrstats.dumpEvent -- Type %s, Client %s, Target %s, Data %s',
                   event.type, event.client, event.target, event.data)


    def getWebsiteVariables(self):
        """
        Thread that polls for XLRstats webfront variables
        """
        _request = str(self.webfrontUrl.rstrip('/')) + '/?config=' + str(self.webfrontConfigNr) + '&func=pluginreq'
        try:
            f = urllib2.urlopen(_request)
            _result = f.readline().split(',')
            # Our webfront will present us 3 values
            if len(_result) == 3:
                # Force the collected strings to their final type. If an error occurs they will fail the try statement.
                self._minKills = int(_result[0])
                self._minRounds = int(_result[1])
                self._maxDays = int(_result[2])
                self.debug('Successfuly retrieved webfront variables: minkills: %i, minrounds: %i, maxdays: %i' % (
                    self._minKills, self._minRounds, self._maxDays))
        except Exception:
            self.debug('Couldn\'t retrieve webfront variables, using defaults')


    def win_prob(self, player_skill, opponent_skill):
        return 1 / ( 10 ** ( (opponent_skill - player_skill) / self.steepness ) + 1 )


    # Retrieves an existing stats record for given client,
    # or makes a new one IFF client's level is high enough
    # Otherwise (also on error), it returns None.
    def get_PlayerStats(self, client=None):
        if client is None:
            id = self._world_clientid
        else:
            id = client.id
        q = 'SELECT * from %s WHERE client_id = %s LIMIT 1' % (self.playerstats_table, id)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s = PlayerStats()
            s.id = r['id']
            s.client_id = r['client_id']
            s.kills = r['kills']
            s.deaths = r['deaths']
            s.teamkills = r['teamkills']
            s.teamdeaths = r['teamdeaths']
            s.suicides = r['suicides']
            s.ratio = r['ratio']
            s.skill = r['skill']
            s.assists = r['assists']
            s.assistskill = r['assistskill']
            s.curstreak = r['curstreak']
            s.winstreak = r['winstreak']
            s.losestreak = r['losestreak']
            s.rounds = r['rounds']
            s.hide = r['hide']
            return s
        elif (client is None) or (client.maxLevel >= self.minlevel):
            s = PlayerStats()
            s._new = True
            s.skill = self.defaultskill
            s.client_id = id
            return s
        else:
            return None

    def get_PlayerAnon(self):
        return self.get_PlayerStats(None)

    def get_WeaponStats(self, name):
        s = WeaponStats()
        q = 'SELECT * from %s WHERE name = "%s" LIMIT 1' % (self.weaponstats_table, name)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.name = r['name']
            s.kills = r['kills']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            return s
        else:
            s._new = True
            s.name = name
            return s

    def get_Bodypart(self, name):
        s = Bodyparts()
        q = 'SELECT * from %s WHERE name = "%s" LIMIT 1' % (self.bodyparts_table, name)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.name = r['name']
            s.kills = r['kills']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            return s
        else:
            s._new = True
            s.name = name
            return s

    def get_MapStats(self, name):
        s = MapStats()
        q = 'SELECT * from %s WHERE name = "%s" LIMIT 1' % (self.mapstats_table, name)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.name = r['name']
            s.kills = r['kills']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            s.rounds = r['rounds']
            return s
        else:
            s._new = True
            s.name = name
            return s


    def get_WeaponUsage(self, weaponid, playerid):
        s = WeaponUsage()
        q = 'SELECT * from %s WHERE weapon_id = %s AND player_id = %s LIMIT 1' % (
            self.weaponusage_table, weaponid, playerid)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.player_id = r['player_id']
            s.weapon_id = r['weapon_id']
            s.kills = r['kills']
            s.deaths = r['deaths']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            s.teamdeaths = r['teamdeaths']
            return s
        else:
            s._new = True
            s.player_id = playerid
            s.weapon_id = weaponid
            return s

    def get_Opponent(self, killerid, targetid):
        s = Opponents()
        q = 'SELECT * from %s WHERE killer_id = %s AND target_id = %s LIMIT 1' % (
            self.opponents_table, killerid, targetid)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.killer_id = r['killer_id']
            s.target_id = r['target_id']
            s.kills = r['kills']
            s.retals = r['retals']
            return s
        else:
            s._new = True
            s.killer_id = killerid
            s.target_id = targetid
            return s

    def get_PlayerBody(self, playerid, bodypartid):
        s = PlayerBody()
        q = 'SELECT * from %s WHERE bodypart_id = %s AND player_id = %s LIMIT 1' % (
            self.playerbody_table, bodypartid, playerid)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.player_id = r['player_id']
            s.bodypart_id = r['bodypart_id']
            s.kills = r['kills']
            s.deaths = r['deaths']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            s.teamdeaths = r['teamdeaths']
            return s
        else:
            s._new = True
            s.player_id = playerid
            s.bodypart_id = bodypartid
            return s

    def get_PlayerMaps(self, playerid, mapid):
        if not mapid:
            self.error('Map not recognized, trying to initialise map...')
            map = self.get_MapStats(self.console.game.mapName)
            if map:
                self.verbose('Map %s successfully initialised.' % map.name)
                mapid = map.id
            else:
                return None

        s = PlayerMaps()
        q = 'SELECT * from %s WHERE map_id = %s AND player_id = %s LIMIT 1' % (self.playermaps_table, mapid, playerid)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.player_id = r['player_id']
            s.map_id = r['map_id']
            s.kills = r['kills']
            s.deaths = r['deaths']
            s.suicides = r['suicides']
            s.teamkills = r['teamkills']
            s.teamdeaths = r['teamdeaths']
            s.rounds = r['rounds']
            return s
        else:
            s._new = True
            s.player_id = playerid
            s.map_id = mapid
            return s

    def get_ActionStats(self, name):
        s = ActionStats()
        q = 'SELECT * from %s WHERE name = "%s" LIMIT 1' % (self.actionstats_table, name)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.name = r['name']
            s.count = r['count']
            return s
        else:
            s._new = True
            s.name = name
            return s

    def get_PlayerActions(self, playerid, actionid):
        s = PlayerActions()
        q = 'SELECT * from %s WHERE action_id = %s AND player_id = %s LIMIT 1' % (
            self.playeractions_table, actionid, playerid)
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            r = cursor.getRow()
            s.id = r['id']
            s.player_id = r['player_id']
            s.action_id = r['action_id']
            s.count = r['count']
            return s
        else:
            s._new = True
            s.player_id = playerid
            s.action_id = actionid
            return s


    def save_Stat(self, stat):
        #self.verbose('*----> XLRstats: Saving statistics for %s' %type(stat))
        #self.verbose('*----> Contents: %s' %stat)
        if hasattr(stat, '_new'):
            q = stat._insertquery()
            #self.debug('Inserting using: ', q)
            cursor = self.query(q)
            if cursor.rowcount > 0:
                stat.id = cursor.lastrowid
                delattr(stat, '_new')
        else:
            q = stat._updatequery()
            #self.debug('Updating using: ', q)
            self.query(q)

        #print 'save_Stat: q= ', q    
        #self.query(q)
        # we could not really do anything with error checking on saving. 
        # If it fails, that's just bad luck. 
        return

    def check_Assists(self, client, target, data, etype=None):
        #determine eventual assists // an assist only counts if damage was done within # secs. before death
        #it will also punish teammates that have a 'negative' assist!
        _count = 0 # number of assists to return
        _sum = 0   # sum of assistskill returned
        _vsum = 0  # sum of victims skill deduction returned
        self.verbose('----> XLRstats: %s Killed %s (%s), checking for assists' % (client.name, target.name, etype))

        try:
            ainfo = target._attackers
        except:
            target._attackers = {}
            ainfo = target._attackers

        for k, v in ainfo.iteritems():
            if k == client.cid:
                #don't award the killer for the assist aswell
                continue
            elif time.time() - v < self.assist_timespan:
                assister = self.console.clients.getByCID(k)
                self.verbose('----> XLRstats: assister = %s' % assister.name)

                anonymous = None

                victimstats = self.get_PlayerStats(target)
                assiststats = self.get_PlayerStats(assister)

                # if both should be anonymous, we have no work to do
                if (assiststats is None) and (victimstats is None):
                    self.verbose('----> XLRstats: check_Assists: %s & %s both anonymous, continueing' % (
                        assister.name, target.name))
                    continue

                if victimstats is None:
                    anonymous = VICTIM
                    victimstats = self.get_PlayerAnon()
                    if victimstats is None:
                        continue

                if assiststats is None:
                    anonymous = ASSISTER
                    assiststats = self.get_PlayerAnon()
                    if assiststats is None:
                        continue

                #calculate the win probability for the assister and victim
                assist_prob = self.win_prob(assiststats.skill, victimstats.skill)
                #performance patch provided by IzNoGod: ELO states that assist_prob + victim_prob = 1
                #victim_prob = self.win_prob(victimstats.skill, assiststats.skill)
                victim_prob = 1 - assist_prob

                self.verbose('----> XLRstats: win probability for %s: %s' % (assister.name, assist_prob))
                self.verbose('----> XLRstats: win probability for %s: %s' % (target.name, victim_prob))

                #get applicable weapon replacement
                actualweapon = data[1]
                for r in data:
                    try:
                        actualweapon = self.config.get('replacements', r)
                    except:
                        pass

                #get applicable weapon multiplier
                try:
                    weapon_factor = self.config.getfloat('weapons', actualweapon)
                except:
                    weapon_factor = 1.0

                #calculate new skill for the assister
                if anonymous != ASSISTER:
                    if assiststats.kills > self.Kswitch_kills:
                        Kfactor = self.Kfactor_low
                    else:
                        Kfactor = self.Kfactor_high

                    oldskill = assiststats.skill
                    if ( target.team == assister.team ) and not ( self.console.game.gameType in self._ffa ):
                        #assister is a teammate and needs skill and assists reduced
                        _assistbonus = self.assist_bonus * Kfactor * weapon_factor * (0 - assist_prob)
                        assiststats.skill = float(assiststats.skill) + _assistbonus
                        assiststats.assistskill = float(assiststats.assistskill) + _assistbonus
                        assiststats.assists -= 1 #negative assist
                        self.verbose(
                            '----> XLRstats: Assistpunishment deducted for %s: %s (oldsk: %.3f - newsk: %.3f)' % (
                                assister.name, assiststats.skill - oldskill, oldskill, assiststats.skill))
                        _count += 1
                        _sum += _assistbonus
                        if self.announce and not assiststats.hide:
                            assister.message('^5XLRstats:^7 Teamdamaged (%s) -> skill: ^1%.3f^7 -> ^2%.1f^7' % (
                                target.name, assiststats.skill - oldskill, assiststats.skill))
                    else:
                        #this is a real assist
                        _assistbonus = self.assist_bonus * Kfactor * weapon_factor * (1 - assist_prob)
                        assiststats.skill = float(assiststats.skill) + _assistbonus
                        assiststats.assistskill = float(assiststats.assistskill) + _assistbonus
                        assiststats.assists += 1
                        self.verbose('----> XLRstats: Assistbonus awarded for %s: %s (oldsk: %.3f - newsk: %.3f)' % (
                            assister.name, assiststats.skill - oldskill, oldskill, assiststats.skill))
                        _count += 1
                        _sum += _assistbonus
                        if self.announce and not assiststats.hide:
                            assister.message('^5XLRstats:^7 Assistbonus (%s) -> skill: ^2+%.3f^7 -> ^2%.1f^7' % (
                                target.name, assiststats.skill - oldskill, assiststats.skill))
                    self.save_Stat(assiststats)

                #calculate new skill for the victim
                if anonymous != VICTIM:
                    if victimstats.kills > self.Kswitch_kills:
                        Kfactor = self.Kfactor_low
                    else:
                        Kfactor = self.Kfactor_high

                    oldskill = victimstats.skill
                    if ( target.team == assister.team ) and not ( self.console.game.gameType in self._ffa ):
                        #assister was a teammate, this should not affect victims skill.
                        pass
                    else:
                        #this is a real assist
                        _assistdeduction = self.assist_bonus * Kfactor * weapon_factor * (0 - victim_prob)
                        victimstats.skill = float(victimstats.skill) + _assistdeduction
                        self.verbose('----> XLRstats: Assist skilldeduction for %s: %s (oldsk: %.3f - newsk: %.3f)' % (
                            target.name, victimstats.skill - oldskill, oldskill, victimstats.skill))
                        _vsum += _assistdeduction
                    self.save_Stat(victimstats)

        #end of assist reward function, return the number of assists 
        return _count, _sum, _vsum

    def kill(self, client, target, data):
        if (client is None) or (client.id == self._world_clientid):
            return
        if target is None:
            return
        if data is None:
            return

        # exclude botkills?
        if (client.bot or target.bot) and self.exclude_bots:
            self.verbose('Bot involved, do not process!')
            return

        _assists_count, _assists_sum, _victim_sum = self.check_Assists(client, target, data, 'kill')

        anonymous = None

        killerstats = self.get_PlayerStats(client)
        victimstats = self.get_PlayerStats(target)

        # if both should be anonymous, we have no work to do
        if (killerstats is None) and (victimstats is None):
            return

        if killerstats is None:
            anonymous = KILLER
            killerstats = self.get_PlayerAnon()
            if killerstats is None:
                return
            killerstats.skill = self.defaultskill

        if victimstats is None:
            anonymous = VICTIM
            victimstats = self.get_PlayerAnon()
            if victimstats is None:
                return

        #calculate winning probabilities for both players
        killer_prob = self.win_prob(killerstats.skill, victimstats.skill)
        #performance patch provided by IzNoGod: ELO states that killer_prob + victim_prob = 1
        #victim_prob = self.win_prob(victimstats.skill, killerstats.skill)
        victim_prob = 1 - killer_prob

        #get applicable weapon replacement
        actualweapon = data[1]
        for r in data:
            try:
                actualweapon = self.config.get('replacements', r)
            except:
                pass

        #get applicable weapon multiplier
        try:
            weapon_factor = self.config.getfloat('weapons', actualweapon)
        except:
            weapon_factor = 1.0

        #calculate new stats for the killer
        if anonymous != KILLER:
            if killerstats.kills > self.Kswitch_kills:
                Kfactor = self.Kfactor_low
            else:
                Kfactor = self.Kfactor_high

            oldskill = killerstats.skill
            #pure skilladdition for a 100% kill
            _skilladdition = self.kill_bonus * Kfactor * weapon_factor * (1 - killer_prob)
            #deduct the assists from the killers skill, but no more than 50%
            if _assists_sum == 0:
                pass
            elif _assists_sum >= ( _skilladdition / 2 ):
                _skilladdition /= 2
                self.verbose(
                    '----> XLRstats: Killer: assists > 50perc: %.3f - skilladd: %.3f' % (_assists_sum, _skilladdition))
            else:
                _skilladdition -= _assists_sum
                self.verbose(
                    '----> XLRstats: Killer: assists < 50perc: %.3f - skilladd: %.3f' % (_assists_sum, _skilladdition))

            killerstats.skill = float(killerstats.skill) + _skilladdition
            self.verbose('----> XLRstats: Killer: oldsk: %.3f - newsk: %.3f' % (oldskill, killerstats.skill))
            killerstats.kills = int(killerstats.kills) + 1

            if int(killerstats.deaths) != 0:
                killerstats.ratio = float(killerstats.kills) / float(killerstats.deaths)
            else:
                killerstats.ratio = 0.0

            if int(killerstats.curstreak) > 0:
                killerstats.curstreak = int(killerstats.curstreak) + 1
            else:
                killerstats.curstreak = 1

            if int(killerstats.curstreak) > int(killerstats.winstreak):
                killerstats.winstreak = int(killerstats.curstreak)
            else:
                killerstats.winstreak = int(killerstats.winstreak)

            if self.announce and not killerstats.hide:
                client.message('^5XLRstats:^7 Killed %s -> skill: ^2+%.3f^7 -> ^2%.1f^7' % (
                    target.name, (killerstats.skill - oldskill), killerstats.skill))
            self.save_Stat(killerstats)

        #calculate new stats for the victim
        if anonymous != VICTIM:
            if victimstats.kills > self.Kswitch_kills:
                Kfactor = self.Kfactor_low
            else:
                Kfactor = self.Kfactor_high

            oldskill = victimstats.skill

            #pure skilldeduction for a 100% kill
            _skilldeduction = Kfactor * weapon_factor * (0 - victim_prob)
            #deduct the assists from the victims skill deduction, but no more than 50%
            if _victim_sum == 0:
                pass
            elif _victim_sum <= ( _skilldeduction / 2 ): #carefull, negative numbers here
                _skilldeduction /= 2
                self.verbose('----> XLRstats: Victim: assists > 50perc: %.3f - skilldeduct: %.3f' % (
                    _victim_sum, _skilldeduction))
            else:
                _skilldeduction -= _victim_sum
                self.verbose('----> XLRstats: Victim: assists < 50perc: %.3f - skilldeduct: %.3f' % (
                    _victim_sum, _skilldeduction))

            victimstats.skill = float(victimstats.skill) + _skilldeduction
            self.verbose('----> XLRstats: Victim: oldsk: %.3f - newsk: %.3f' % (oldskill, victimstats.skill))
            victimstats.deaths = int(victimstats.deaths) + 1

            victimstats.ratio = float(victimstats.kills) / float(victimstats.deaths)

            if int(victimstats.curstreak) < 0:
                victimstats.curstreak = int(victimstats.curstreak) - 1
            else:
                victimstats.curstreak = -1

            if victimstats.curstreak < int(victimstats.losestreak):
                victimstats.losestreak = victimstats.curstreak
            else:
                victimstats.losestreak = int(victimstats.losestreak)

            if self.announce and not victimstats.hide:
                target.message('^5XLRstats:^7 Killed by %s -> skill: ^1%.3f^7 -> ^2%.1f^7' % (
                    client.name, (victimstats.skill - oldskill), victimstats.skill))
            self.save_Stat(victimstats)

        #make sure the record for anonymous is really created with an insert once
        if anonymous:
            if (anonymous == KILLER) and (hasattr(killerstats, '_new')):
                self.save_Stat(killerstats)
            elif (anonymous == VICTIM) and (hasattr(victimstats, '_new')):
                self.save_Stat(victimstats)

                #adjust the "opponents" table to register who killed who
        opponent = self.get_Opponent(targetid=victimstats.id, killerid=killerstats.id)
        retal = self.get_Opponent(targetid=killerstats.id, killerid=victimstats.id)
        #the above should always succeed, but you never know...
        if opponent and retal:
            opponent.kills += 1
            retal.retals += 1
            self.save_Stat(opponent)
            self.save_Stat(retal)

        #adjust weapon statistics
        weaponstats = self.get_WeaponStats(name=actualweapon)
        if weaponstats:
            weaponstats.kills += 1
            self.save_Stat(weaponstats)

            w_usage_killer = self.get_WeaponUsage(playerid=killerstats.id, weaponid=weaponstats.id)
            w_usage_victim = self.get_WeaponUsage(playerid=victimstats.id, weaponid=weaponstats.id)
            if w_usage_killer and w_usage_victim:
                w_usage_killer.kills += 1
                w_usage_victim.deaths += 1
                self.save_Stat(w_usage_killer)
                self.save_Stat(w_usage_victim)

        #adjust bodypart statistics
        bodypart = self.get_Bodypart(name=data[2])
        if bodypart:
            bodypart.kills += 1
            self.save_Stat(bodypart)

            bp_killer = self.get_PlayerBody(playerid=killerstats.id, bodypartid=bodypart.id)
            bp_victim = self.get_PlayerBody(playerid=victimstats.id, bodypartid=bodypart.id)
            if bp_killer and bp_victim:
                bp_killer.kills += 1
                bp_victim.deaths += 1
                self.save_Stat(bp_killer)
                self.save_Stat(bp_victim)

        #adjust map statistics
        map = self.get_MapStats(self.console.game.mapName)
        if map:
            map.kills += 1
            self.save_Stat(map)

            map_killer = self.get_PlayerMaps(playerid=killerstats.id, mapid=map.id)
            map_victim = self.get_PlayerMaps(playerid=victimstats.id, mapid=map.id)
            if map_killer and map_victim:
                map_killer.kills += 1
                map_victim.deaths += 1
                self.save_Stat(map_killer)
                self.save_Stat(map_victim)

        #end of kill function
        return

    def damage(self, client, target, data):
        if client.id == self._world_clientid:
            self.verbose('----> XLRstats: onDamage: WORLD-damage, moving on...')
            return None
        if client.cid == target.cid:
            self.verbose(
                '----> XLRstats: onDamage: self damage: %s damaged %s, continueing' % (client.name, target.name))
            return None
            # exclude botdamage?
        if (client.bot or target.bot) and self.exclude_bots:
            self.verbose('Bot involved, do not process!')
            return None

        #check if game is _damage_able -> 50 points or more damage will award an assist
        if self._damage_ability and data[0] < 50:
            self.verbose('---> XLRstats: Not enough damage done to award an assist')
            return

        try:
            target._attackers[client.cid] = time.time()
        except:
            target._attackers = {}
            target._attackers[client.cid] = time.time()
        self.verbose('----> XLRstats: onDamage: attacker added: %s (%s) damaged %s (%s)' % (
            client.name, client.cid, target.name, target.cid))
        self.verbose('----> XLRstats: Assistinfo: %s' % target._attackers)

    def suicide(self, client, target, data):
        if client is None:
            return
        if target is None:
            return
        if data is None:
            return

        self.check_Assists(client, target, data, 'suicide')

        playerstats = self.get_PlayerStats(client)

        if playerstats is None:
            #anonymous player. We're not interested :)
            return

        playerstats.suicides += 1
        if playerstats.curstreak < 0:
            playerstats.curstreak -= 1
        else:
            playerstats.curstreak = -1
        if playerstats.curstreak < playerstats.losestreak:
            playerstats.losestreak = playerstats.curstreak

        oldskill = playerstats.skill
        playerstats.skill = (1 - (self.suicide_penalty_percent / 100.0) ) * float(playerstats.skill)
        if self.announce and not playerstats.hide:
            client.message('^5XLRstats:^7 Suicide -> skill: ^1%.3f^7 -> ^2%.1f^7' % (
                playerstats.skill - oldskill, playerstats.skill))
        self.save_Stat(playerstats)

        #get applicable weapon replacement
        actualweapon = data[1]
        for r in data:
            try:
                actualweapon = self.config.get('replacements', r)
            except:
                pass

        #update weapon stats
        weaponstats = self.get_WeaponStats(name=actualweapon)
        if weaponstats:
            weaponstats.suicides += 1
            self.save_Stat(weaponstats)

            w_usage = self.get_WeaponUsage(playerid=playerstats.id, weaponid=weaponstats.id)
            if w_usage:
                w_usage.suicides += 1
                self.save_Stat(w_usage)

        #update bodypart stats
        bodypart = self.get_Bodypart(name=data[2])
        if bodypart:
            bodypart.suicides += 1
            self.save_Stat(bodypart)

            bp_player = self.get_PlayerBody(playerid=playerstats.id, bodypartid=bodypart.id)
            if bp_player:
                bp_player.suicides = int(bp_player.suicides) + 1
                self.save_Stat(bp_player)

        #adjust map statistics
        map = self.get_MapStats(self.console.game.mapName)
        if map:
            map.suicides += 1
            self.save_Stat(map)

            map_player = self.get_PlayerMaps(playerid=playerstats.id, mapid=map.id)
            if map_player:
                map_player.suicides += 1
                self.save_Stat(map_player)

        #end of function suicide
        return

    def teamkill(self, client, target, data):
        if client is None:
            return
        if target is None:
            return
        if data is None:
            return

        anonymous = None

        self.check_Assists(client, target, data, 'teamkill')

        killerstats = self.get_PlayerStats(client)
        victimstats = self.get_PlayerStats(target)

        # if both should be anonymous, we have no work to do
        if (killerstats is None) and (victimstats is None):
            return

        if killerstats is None:
            anonymous = KILLER
            killerstats = self.get_PlayerAnon()
            if killerstats is None:
                return
            killerstats.skill = self.defaultskill

        if victimstats is None:
            anonymous = VICTIM
            victimstats = self.get_PlayerAnon()
            if victimstats is None:
                return
            victimstats.skill = self.defaultskill

        if anonymous != KILLER:
            #Calculate new stats for the killer
            oldskill = killerstats.skill
            killerstats.skill = (1 - (self.tk_penalty_percent / 100.0) ) * float(killerstats.skill)
            killerstats.teamkills += 1
            killerstats.curstreak = 0   # break off current streak as it is now "impure"
            if self.announce and not killerstats.hide:
                client.message('^5XLRstats:^7 Teamkill -> skill: ^1%.3f^7 -> ^2%.1f^7' % (
                    killerstats.skill - oldskill, killerstats.skill))
            self.save_Stat(killerstats)

        if anonymous != VICTIM:
            #Calculate new stats for the victim
            victimstats.teamdeaths += 1
            self.save_Stat(victimstats)

        # do not register a teamkill in the "opponents" table

        #get applicable weapon replacement
        actualweapon = data[1]
        for r in data:
            try:
                actualweapon = self.config.get('replacements', r)
            except:
                pass

        #adjust weapon statistics
        weaponstats = self.get_WeaponStats(name=actualweapon)
        if weaponstats:
            weaponstats.teamkills += 1
            self.save_Stat(weaponstats)

            w_usage_killer = self.get_WeaponUsage(playerid=killerstats.id, weaponid=weaponstats.id)
            w_usage_victim = self.get_WeaponUsage(playerid=victimstats.id, weaponid=weaponstats.id)
            if w_usage_killer and w_usage_victim:
                w_usage_killer.teamkills += 1
                w_usage_victim.teamdeaths += 1
                self.save_Stat(w_usage_killer)
                self.save_Stat(w_usage_victim)

        #adjust bodypart statistics
        bodypart = self.get_Bodypart(name=data[2])
        if bodypart:
            bodypart.teamkills += 1
            self.save_Stat(bodypart)

            bp_killer = self.get_PlayerBody(playerid=killerstats.id, bodypartid=bodypart.id)
            bp_victim = self.get_PlayerBody(playerid=victimstats.id, bodypartid=bodypart.id)
            if bp_killer and bp_victim:
                bp_killer.teamkills += 1
                bp_victim.teamdeaths += 1
                self.save_Stat(bp_killer)
                self.save_Stat(bp_victim)

        #adjust map statistics
        map = self.get_MapStats(self.console.game.mapName)
        if map:
            map.teamkills += 1
            self.save_Stat(map)

            map_killer = self.get_PlayerMaps(playerid=killerstats.id, mapid=map.id)
            map_victim = self.get_PlayerMaps(playerid=victimstats.id, mapid=map.id)
            if map_killer and map_victim:
                map_killer.teamkills += 1
                map_victim.teamdeaths += 1
                self.save_Stat(map_killer)
                self.save_Stat(map_victim)

        #end of function teamkill
        return


    def join(self, client):
        if client is None:
            return

        # test if it is a bot and flag it
        if client.guid[:3] == 'BOT':
            self.verbose('Bot found!')
            client.bot = True

        player = self.get_PlayerStats(client)
        if player:
            player.rounds = int(player.rounds) + 1
            if client.bot:
                if self.hide_bots:
                    self.verbose('Hiding Bot!')
                    player.hide = True
                else:
                    self.verbose('Unhiding Bot!')
                    player.hide = False
            self.save_Stat(player)

            map = self.get_MapStats(self.console.game.mapName)
            if map:
                playermap = self.get_PlayerMaps(player.id, map.id)
                if playermap:
                    playermap.rounds += 1
                    self.save_Stat(playermap)
        return

    def roundstart(self):
        #disable k/d counting if minimum players are not met

        if self.last_map is None:
            self.last_map = self.console.game.mapName
            #self.last_roundtime = self.console.game._roundTimeStart
        else:
            if not self.onemaponly and ( self.last_map == self.console.game.mapName) and  (
                self.console.game.roundTime() < self.prematch_maxtime):
                #( self.console.game._roundTimeStart - self.last_roundtime < self.prematch_maxtime) ):
                return
            else:
                self.last_map = self.console.game.mapName
                #self.last_roundtime = self.console.game._roundTimeStart

        map = self.get_MapStats(self.console.game.mapName)
        if map:
            map.rounds += 1
            self.save_Stat(map)

        return

    def action(self, client, data):
        #self.verbose('----> XLRstats: Entering actionfunc.')
        if client is None:
            return

        action = self.get_ActionStats(name=data)
        if action:
            action.count += 1
            #self.verbose('----> XLRstats: Actioncount: %s' %action.count)
            #self.verbose('----> XLRstats: Actionname: %s' %action.name)
            #if hasattr(action, '_new'):
            #    self.verbose('----> XLRstats: insertquery: %s' %action._insertquery())
            #else:
            #    self.verbose('----> XLRstats: updatequery: %s' %action._updatequery())
            self.save_Stat(action)

        #is it an anonymous client, stop here
        playerstats = self.get_PlayerStats(client)
        if playerstats is None:
            #self.verbose('----> XLRstats: Anonymous client')
            return

        playeractions = self.get_PlayerActions(playerid=playerstats.id, actionid=action.id)
        if playeractions:
            playeractions.count += 1
            #self.verbose('----> XLRstats: Players Actioncount: %s' %playeractions.count)
            #if hasattr(playeractions, '_new'):
            #    self.verbose('----> XLRstats: insertquery: %s' %playeractions._insertquery())
            #else:
            #    self.verbose('----> XLRstats: updatequery: %s' %playeractions._updatequery())
            self.save_Stat(playeractions)

        #get applicable action bonus
        try:
            action_bonus = self.config.getfloat('actions', action.name)
            #self.verbose('----> XLRstats: Found a bonus for %s: %s' %(action.name, action_bonus))
        except:
            action_bonus = 3

        if action_bonus:
            #self.verbose('----> XLRstats: Old Skill: %s.' %playerstats.skill)
            playerstats.skill += action_bonus
            #self.verbose('----> XLRstats: New Skill: %s.' %playerstats.skill)
            self.save_Stat(playerstats)

        return

    def cmd_xlrstats(self, data, client, cmd=None):
        """\
        [<name>] - list a players XLR stats
        """
        if data:
            sclient = self._adminPlugin.findClientPrompt(data, client)
            if not sclient: return
        else:
            sclient = client

        stats = self.get_PlayerStats(sclient)

        if stats:
            if stats.hide == 1:
                client.message('^3XLR Stats: ^7Stats for %s are not available (hidden).' % sclient.exactName)
                return None
            else:
                message = '^3XLR Stats: ^7%s ^7: K ^2%s ^7D ^3%s ^7TK ^1%s ^7Ratio ^5%1.02f ^7Skill ^3%1.02f' % (
                    sclient.exactName, stats.kills, stats.deaths, stats.teamkills, stats.ratio, stats.skill)
                cmd.sayLoudOrPM(client, message)
        else:
            client.message('^3XLR Stats: ^7Could not find stats for %s' % sclient.exactName)

        return

    # Start a thread to get the top players
    def cmd_xlrtopstats(self, data, client, cmd=None, ext=False):
        """\
        [<#>] - list the top # players of the last 14 days.
        """
        thread.start_new_thread(self.doTopList, (data, client, cmd, ext))

        return

    # Retrieves the Top # Players
    def doTopList(self, data, client, cmd=None, ext=False):
        if data:
            if re.match('^[0-9]+$', data, re.I):
                limit = int(data)
                if limit > 10:
                    limit = 10
        else:
            limit = 3


        #q = 'SELECT `%s`.name, `%s`.time_edit, `%s`.id, kills, deaths, ratio, skill, winstreak, losestreak, rounds, fixed_name, ip FROM `%s`, `%s` WHERE (`%s`.id = `%s`.client_id) AND ((`%s`.kills > 100) OR (`%s`.rounds > 10)) AND (`%s`.hide = 0) AND (UNIX_TIMESTAMP(NOW()) - `%s`.time_edit  < 14*60*60*24) AND `%s`.id NOT IN ( SELECT distinct(target.id) FROM `%s` as penalties, `%s` as target WHERE (penalties.type = "Ban" OR penalties.type = "TempBan") AND inactive = 0 AND penalties.client_id = target.id AND ( penalties.time_expire = -1 OR penalties.time_expire > UNIX_TIMESTAMP(NOW()) ) ) ORDER BY `%s`.`skill` DESC LIMIT %s' % (self.clients_table, self.clients_table, self.playerstats_table, self.clients_table, self.playerstats_table, self.clients_table, self.playerstats_table, self.playerstats_table, self.playerstats_table, self.playerstats_table, self.clients_table, self.clients_table, self.penalties_table, self.clients_table, self.playerstats_table, limit)
        q = 'SELECT `%s`.name, `%s`.time_edit, `%s`.id, kills, deaths, ratio, skill, winstreak, losestreak, rounds, fixed_name, ip \
        FROM `%s`, `%s` \
            WHERE (`%s`.id = `%s`.client_id) \
            AND ((`%s`.kills > %s) \
            OR (`%s`.rounds > %s)) \
            AND (`%s`.hide = 0) \
            AND (UNIX_TIMESTAMP(NOW()) - `%s`.time_edit  < %s*60*60*24) \
            AND `%s`.id NOT IN \
                ( SELECT distinct(target.id) FROM `%s` as penalties, `%s` as target \
                WHERE (penalties.type = "Ban" \
                OR penalties.type = "TempBan") \
                AND inactive = 0 \
                AND penalties.client_id = target.id \
                AND ( penalties.time_expire = -1 \
                OR penalties.time_expire > UNIX_TIMESTAMP(NOW()) ) ) \
        ORDER BY `%s`.`skill` DESC LIMIT %s'\
        % (self.clients_table, self.clients_table, self.playerstats_table, self.clients_table, self.playerstats_table,\
           self.clients_table, self.playerstats_table, self.playerstats_table, self._minKills, self.playerstats_table,\
           self._minRounds, self.playerstats_table, self.clients_table, self._maxDays, self.clients_table,
           self.penalties_table,\
           self.clients_table, self.playerstats_table, limit)

        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            message = '^3XLR Stats Top %s Players:' % limit
            if ext:
                self.console.say(message)
            else:
                cmd.sayLoudOrPM(client, message)
            c = 1
            while not cursor.EOF:
                r = cursor.getRow()
                message = '^3# %s: ^7%s ^7: Skill ^3%1.02f ^7Ratio ^5%1.02f ^7Kills: ^2%s' % (
                    c, r['name'], r['skill'], r['ratio'], r['kills'])
                if ext:
                    self.console.say(message)
                else:
                    cmd.sayLoudOrPM(client, message)
                cursor.moveNext()
                c += 1
                time.sleep(1)
        else:
            self.debug('No players qualified for the toplist yet...')
            message = 'Qualify for the toplist by making %i kills, or playing %i rounds!' % (
                self._minKills, self._minRounds)
            if ext:
                self.console.say(message)
            else:
                cmd.sayLoudOrPM(client, message)
            return None

        return

    def cmd_xlrhide(self, data, client, cmd=None):
        """\
        <player> <on/off> - Hide/unhide a player from the stats
        """
        # this will split the player name and the message
        input = self._adminPlugin.parseUserCmd(data)
        if input:
            # input[0] is the player id
            sclient = self._adminPlugin.findClientPrompt(input[0], client)
            if not sclient:
                # a player matchin the name was not found, a list of closest matches will be displayed
                # we can exit here and the user will retry with a more specific player
                return False
        else:
            client.message('^7Invalid data, try !help xlrhide')
            return False

        if not input[1]:
            client.message('^7Missing data, try !help xlrhide')
            return False

        m = input[1]
        if m in ('on', '1'):
            if client != sclient:
                sclient.message('^3You are invisible in xlrstats!')
            client.message('^3%s INVISIBLE in xlrstats!' % sclient.exactName)
            hide = 1
        elif m in ('off', '0'):
            if client != sclient:
                sclient.message('^3You are visible in xlrstats!')
            client.message('^3%s VISIBLE in xlrstats!' % sclient.exactName)
            hide = 0
        else:
            client.message('^7Invalid or missing data, try !help xlrhide')

        player = self.get_PlayerStats(sclient)
        if player:
            player.hide = int(hide)
            self.save_Stat(player)

        return

    ## @todo: add mysql condition
    def updateTableColumns(self):
        self.verbose('Checking if we need to update tables for version 2.0.0')
        #v2.0.0 additions to the playerstats table:
        self._addTableColumn('assists', PlayerStats._table, 'MEDIUMINT( 8 ) NOT NULL DEFAULT "0" AFTER `skill`')
        self._addTableColumn('assistskill', PlayerStats._table, 'FLOAT NOT NULL DEFAULT "0" AFTER `assists`')
        #alterations to columns in existing tables:
        self._updateTableColumns()
        return None
        #end of update check

    def _addTableColumn(self, c1, t1, specs):
        try:
            self.query('SELECT `%s` FROM %s limit 1;' % (c1, t1))
        except Exception, e:
            if e[0] == 1054:
                self.console.debug('Column does not yet exist: %s' % e)
                self.query('ALTER TABLE %s ADD `%s` %s ;' % (t1, c1, specs))
                self.console.info('Created new column `%s` on %s' % (c1, t1))
            else:
                self.console.error('Query failed - %s: %s' % (type(e), e))

    def _updateTableColumns(self):
        try:
            #need to update the weapon-identifier columns in these tables for cod7. This game knows over 255 weapons/variations
            self.query(
                'ALTER TABLE  `%s` CHANGE  `id`  `id` SMALLINT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT;' % WeaponStats._table)
            self.query(
                'ALTER TABLE  `%s` CHANGE  `weapon_id`  `weapon_id` SMALLINT( 5 ) UNSIGNED NOT NULL DEFAULT  "0";' % WeaponUsage._table)
        except:
            pass

    def showTables(self, xlrstats=False):
        _tables = []
        q = 'SHOW TABLES'
        cursor = self.query(q)
        if cursor and (cursor.rowcount > 0):
            while not cursor.EOF:
                r = cursor.getRow()
                n = str(r.values()[0])
                if xlrstats and not n in self._xlrstatstables:
                    pass
                else:
                    _tables.append(r.values()[0])
                cursor.moveNext()
        if xlrstats:
            self.console.verbose('Available XLRstats tables in this database: %s' % _tables)
        else:
            self.console.verbose('Available tables in this database: %s' % _tables)
        return _tables

    def optimizeTables(self, t=None):
        if not t:
            t = self.showTables()
        if type(t) == type(''):
            _tables = str(t)
        else:
            _tables = ', '.join(t)
        self.debug('Optimizing Table(s): %s' % _tables)
        try:
            self.query('OPTIMIZE TABLE %s' % _tables)
            self.debug('Optimize Success')
        except Exception, msg:
            self.error('Optimizing Table(s) Failed: %s, trying to repair...' % msg)
            self.repairTables(t)

    def repairTables(self, t=None):
        if not t:
            t = self.showTables()
        if type(t) == type(''):
            _tables = str(t)
        else:
            _tables = ', '.join(t)
        self.debug('Repairing Table(s): %s' % _tables)
        try:
            self.query('REPAIR TABLE %s' % _tables)
            self.debug('Repair Success')
        except Exception, msg:
            self.error('Repairing Table(s) Failed: %s' % msg)

    def calculateKillBonus(self):
        self.debug('Calculating kill_bonus')
        # make sure max and diff are floating numbers (may be redundant)
        max = 0.0
        diff = 0.0
        _oldkillbonus = self.kill_bonus

        q = 'SELECT MAX(skill) AS max_skill FROM %s' % self.playerstats_table
        cursor = self.query(q)
        r = cursor.getRow()
        max = r['max_skill']
        if max is None:
            max = self.defaultskill
        diff = max - self.defaultskill
        if diff < 0:
            self.kill_bonus = 2.0
        elif diff < 400:
            self.kill_bonus = 1.5
        else:
            c = 200.0 / diff + 1
            self.kill_bonus = round(c, 1)
        self.assist_bonus = self.kill_bonus / 3
        if self.kill_bonus != _oldkillbonus:
            self.debug('kill_bonus set to: %s' % self.kill_bonus)
            self.debug('assist_bonus set to: %s' % self.assist_bonus)


class XlrstatscontrollerPlugin(b3.plugin.Plugin):
    """This is a helper class/plugin that enables and disables the main XLRstats plugin
    It can not be called directly or separately from the XLRstats plugin!"""

    def __init__(self, console, minPlayers=3, silent=False):
        self.console = console
        self.minPlayers = minPlayers
        self.silent = silent
        # empty message cache
        self._messages = {}
        self.registerEvent(b3.events.EVT_STOP)
        self.registerEvent(b3.events.EVT_EXIT)

    def startup(self):
        self.console.debug('Starting SubPlugin: XlrstatsControllerPlugin')
        #get a reference to the main Xlrstats plugin
        self._xlrstatsPlugin = self.console.getPlugin('xlrstats')
        # register the events we're interested in.
        self.registerEvent(b3.events.EVT_CLIENT_JOIN)
        self.registerEvent(b3.events.EVT_GAME_ROUND_START)

    def onEvent(self, event):
        if event.type == b3.events.EVT_CLIENT_JOIN:
            self.checkMinPlayers()
        elif event.type == b3.events.EVT_GAME_ROUND_START:
            self.checkMinPlayers(_roundstart=True)

    def checkMinPlayers(self, _roundstart=False):
        """Checks if minimum amount of players are present
        if minimum amount of players is reached will enable stats collecting
        and if not it disables stats counting on next roundstart"""
        self._currentNrPlayers = len(self.console.clients.getList())
        self.debug(
            'Checking number of players online. Minimum = %s, Current = %s' % (self.minPlayers, self._currentNrPlayers))
        if self._currentNrPlayers < self.minPlayers and self._xlrstatsPlugin.isEnabled() and _roundstart:
            self.info('Disabling XLRstats: Not enough players online')
            if not self.silent:
                self.console.say('XLRstats Disabled: Not enough players online!')
            self._xlrstatsPlugin.disable()
        elif self._currentNrPlayers >= self.minPlayers and not self._xlrstatsPlugin.isEnabled():
            self.info('Enabling XLRstats: Collecting Stats')
            if not self.silent:
                self.console.say('XLRstats Enabled: Now collecting stats!')
            self._xlrstatsPlugin.enable()
        else:
            if self._xlrstatsPlugin.isEnabled():
                _status = 'Enabled'
            else:
                _status = 'Disabled'
            self.debug('Nothing to do at the moment. XLRstats is already %s' % _status)


class XlrstatshistoryPlugin(b3.plugin.Plugin):
    """This is a helper class/plugin that saves history snapshots
    It can not be called directly or separately from the XLRstats plugin!"""

    def __init__(self, console, weeklyTable, monthlyTable, playerstatsTable):
        self.console = console
        self.history_weekly_table = weeklyTable
        self.history_monthly_table = monthlyTable
        self.playerstats_table = playerstatsTable
        # empty message cache
        self._messages = {}
        self.registerEvent(b3.events.EVT_STOP)
        self.registerEvent(b3.events.EVT_EXIT)

    def startup(self):
        self.console.debug('Starting SubPlugin: XlrstatsHistoryPlugin')
        #define a shortcut to the storage.query function
        self.query = self.console.storage.query

        self.console.verbose('XlrstatshistoryPlugin: Installing history Crontabs:')
        # remove existing crontabs
        try:
            self.console.cron - self._cronTabMonth
        except:
            pass
        try:
            self.console.cron - self._cronTabWeek
        except:
            pass
        try:
            # install crontabs
            self._cronTabMonth = b3.cron.PluginCronTab(self, self.snapshot_month, 0, 0, 0, 1, '*', '*')
            self.console.cron + self._cronTabMonth
            self._cronTabWeek = b3.cron.PluginCronTab(self, self.snapshot_week, 0, 0, 0, '*', '*', 1) # day 1 is monday
            self.console.cron + self._cronTabWeek
        except Exception, msg:
            self.console.error('XlrstatshistoryPlugin: Unable to install History Crontabs: %s' % msg)


    def snapshot_month(self):
        sql = (
            'INSERT INTO ' + self.history_monthly_table + ' (`client_id` , `kills` , `deaths` , `teamkills` , `teamdeaths` , `suicides` ' +
            ', `ratio` , `skill` , `assists` , `assistskill` , `winstreak` , `losestreak` , `rounds`, `year`, `month`, `week`, `day`)' +
            '  SELECT `client_id` , `kills`, `deaths` , `teamkills` , `teamdeaths` , `suicides` , `ratio` , `skill` , `assists` , `assistskill` , `winstreak` ' +
            ', `losestreak` , `rounds`, YEAR(NOW()), MONTH(NOW()), WEEK(NOW(),3), DAY(NOW())' +
            '  FROM `' + self.playerstats_table + '`' )
        try:
            self.query(sql)
            self.verbose('Monthly XLRstats snapshot created')
        except Exception, msg:
            self.error('Creating history snapshot failed: %s' % msg)


    def snapshot_week(self):
        sql = (
            'INSERT INTO ' + self.history_weekly_table + ' (`client_id` , `kills` , `deaths` , `teamkills` , `teamdeaths` , `suicides` ' +
            ', `ratio` , `skill` , `assists` , `assistskill` , `winstreak` , `losestreak` , `rounds`, `year`, `month`, `week`, `day`)' +
            '  SELECT `client_id` , `kills`, `deaths` , `teamkills` , `teamdeaths` , `suicides` , `ratio` , `skill` , `assists` , `assistskill` , `winstreak` ' +
            ', `losestreak` , `rounds`, YEAR(NOW()), MONTH(NOW()), WEEK(NOW(),3), DAY(NOW())' +
            '  FROM `' + self.playerstats_table + '`' )
        try:
            self.query(sql)
            self.verbose('Weekly XLRstats snapshot created')
        except Exception, msg:
            self.error('Creating history snapshot failed: %s' % msg)

class TimeStats:
    came = None
    left = None
    client = None

class CtimePlugin(b3.plugin.Plugin):
    """This is a helper class/plugin that saves client join and disconnect time info
    It can not be called directly or separately from the XLRstats plugin!"""

    _clients = {}
    _cronTab = None
    _max_age_in_days = 31
    _hours = 5
    _minutes = 0

    def __init__(self, console, cTimeTable):
        self.console = console
        self.ctime_table = cTimeTable
        self.registerEvent(b3.events.EVT_CLIENT_AUTH)
        self.registerEvent(b3.events.EVT_CLIENT_DISCONNECT)
        self.query = self.console.storage.query
        tzName = self.console.config.get('b3', 'time_zone').upper()
        tzOffest = b3.timezones.timezones[tzName]
        hoursGMT = (self._hours - tzOffest)%24
        self.debug(u'%02d:%02d %s => %02d:%02d UTC' % (self._hours, self._minutes, tzName, hoursGMT, self._minutes))
        self.info(u'everyday at %2d:%2d %s, connection info older than %s days will be deleted' % (self._hours, self._minutes, tzName, self._max_age_in_days))
        self._cronTab = b3.cron.PluginCronTab(self, self.purge, 0, self._minutes, hoursGMT, '*', '*', '*')
        self.console.cron + self._cronTab

    def purge(self):
        if not self._max_age_in_days or self._max_age_in_days == 0:
            self.warning(u'max_age is invalid [%s]' % self._max_age_in_days)
            return False

        self.info(u'purge of connection info older than %s days ...' % self._max_age_in_days)
        q = "DELETE FROM %s WHERE came < %i" % (self.ctime_table, (self.console.time() - (self._max_age_in_days*24*60*60)))
        self.debug(u'CTIME QUERY: %s ' % q)
        cursor = self.console.storage.query(q)

    def onEvent(self, event):
        if event.type == b3.events.EVT_CLIENT_AUTH:
            if  not event.client or\
                not event.client.id or\
                event.client.cid == None or\
                not event.client.connected or\
                event.client.hide:
                return

            self.update_time_stats_connected(event.client)

        elif event.type == b3.events.EVT_CLIENT_DISCONNECT:
            self.update_time_stats_exit(event.data)

    def update_time_stats_connected(self, client):
        if self._clients.has_key(client.cid):
            self.debug(u'CTIME CONNECTED: Client exist! : %s' % client.cid)
            tmpts = self._clients[client.cid]
            if tmpts.client.guid == client.guid:
                self.debug(u'CTIME RECONNECTED: Player %s connected again, but playing since: %s' %  (client.exactName, tmpts.came))
                return
            else:
                del self._clients[client.cid]

        ts = TimeStats()
        ts.client = client
        ts.came = datetime.datetime.now()
        self._clients[client.cid] = ts
        self.debug(u'CTIME CONNECTED: Player %s started playing at: %s' % (client.exactName, ts.came))

    def formatTD(self, td):
        hours = td // 3600
        minutes = (td % 3600) // 60
        seconds = td % 60
        return '%s:%s:%s' % (hours, minutes, seconds)

    def update_time_stats_exit(self, clientid):
        self.debug(u'CTIME LEFT:')
        if self._clients.has_key(clientid):
            ts = self._clients[clientid]
            # Fail: Sometimes PB in cod4 returns 31 character guids, we need to dump them. Lets look ahead and do this for the whole codseries.
            #if(self.console.gameName[:3] == 'cod' and self.console.PunkBuster and len(ts.client.guid) != 32):
            #    pass
            #else:
            ts.left = datetime.datetime.now()
            diff = (int(time.mktime(ts.left.timetuple())) - int(time.mktime(ts.came.timetuple())))

            self.debug(u'CTIME LEFT: Player: %s played this time: %s sec' % (ts.client.exactName, diff))
            self.debug(u'CTIME LEFT: Player: %s played this time: %s' % (ts.client.exactName, self.formatTD(diff)))
            #INSERT INTO `ctime` (`guid`, `came`, `left`) VALUES ("6fcc4f6d9d8eb8d8457fd72d38bb1ed2", 1198187868, 1226081506)
            q = 'INSERT INTO %s (guid, came, gone, nick) VALUES (\"%s\", \"%s\", \"%s\", \"%s\")' % (self.ctime_table, ts.client.guid, int(time.mktime(ts.came.timetuple())), int(time.mktime(ts.left.timetuple())), ts.client.name)
            self.query(q)

            self._clients[clientid].left = None
            self._clients[clientid].came = None
            self._clients[clientid].client = None

            del self._clients[clientid]

        else:
            self.debug(u'CTIME LEFT: Player %s var not set!' % clientid)

#-----------------------------------------------------------------------------------------------------------------------
# This is an abstract class. Do not call directly.
class StatObject(object):
    _table = None

    def _insertquery(self):
        return None

    def _updatequery(self):
        return None


class PlayerStats(StatObject):
    #default name of the table for this data object
    _table = 'playerstats'

    #fields of the table
    id = None
    client_id = 0

    kills = 0
    deaths = 0
    teamkills = 0
    teamdeaths = 0
    suicides = 0

    ratio = 0
    skill = 0
    assists = 0
    assistskill = 0
    curstreak = 0
    winstreak = 0
    losestreak = 0
    rounds = 0
    hide = 0

    # the following fields are used only by the PHP presentation code
    fixed_name = ""

    def _insertquery(self):
        q = 'INSERT INTO %s ( client_id, kills, deaths, teamkills, teamdeaths, suicides, ratio, skill, assists, assistskill, curstreak, winstreak, losestreak, rounds, hide ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)' % (
            self._table, self.client_id, self.kills, self.deaths, self.teamkills, self.teamdeaths, self.suicides,
            self.ratio
            , self.skill, self.assists, self.assistskill, self.curstreak, self.winstreak, self.losestreak, self.rounds,
            self.hide)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET client_id=%s, kills=%s, deaths=%s, teamkills=%s, teamdeaths=%s, suicides=%s, ratio=%s, skill=%s, assists=%s, assistskill=%s, curstreak=%s, winstreak=%s, losestreak=%s, rounds=%s, hide=%s WHERE id=%s' % (
            self._table, self.client_id, self.kills, self.deaths, self.teamkills, self.teamdeaths, self.suicides,
            self.ratio
            , self.skill, self.assists, self.assistskill, self.curstreak, self.winstreak, self.losestreak, self.rounds,
            self.hide, self.id)
        return q


class WeaponStats(StatObject):
    #default name of the table for this data object
    _table = 'weaponstats'

    #fields of the table
    id = None
    name = ''
    kills = 0
    suicides = 0
    teamkills = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( name, kills, suicides, teamkills ) VALUES ("%s", %s, %s, %s)' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET name="%s", kills=%s, suicides=%s, teamkills=%s WHERE id=%s' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills, self.id)
        return q


class WeaponUsage(StatObject):
    #default name of the table for this data object
    _table = 'weaponusage'

    #fields of the table
    id = None
    player_id = 0
    weapon_id = 0
    kills = 0
    deaths = 0
    suicides = 0
    teamkills = 0
    teamdeaths = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( player_id, weapon_id, kills, deaths, suicides, teamkills, teamdeaths ) VALUES (%s, %s, %s, %s, %s, %s, %s)' % (
            self._table, self.player_id, self.weapon_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET player_id=%s, weapon_id=%s, kills=%s, deaths=%s, suicides=%s, teamkills=%s, teamdeaths=%s WHERE id=%s' % (
            self._table, self.player_id, self.weapon_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths, self.id)
        return q


class Bodyparts(StatObject):
    #default name of the table for this data object
    _table = 'bodyparts'

    #fields of the table
    id = None
    name = ''
    kills = 0
    suicides = 0
    teamkills = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( name, kills, suicides, teamkills ) VALUES ("%s", %s, %s, %s)' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET name="%s", kills=%s, suicides=%s, teamkills=%s WHERE id=%s' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills, self.id)
        return q


class MapStats(StatObject):
    #default name of the table for this data object
    _table = 'mapstats'

    #fields of the table
    id = None
    name = ''
    kills = 0
    suicides = 0
    teamkills = 0
    rounds = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( name, kills, suicides, teamkills, rounds ) VALUES ("%s", %s, %s, %s, %s)' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills, self.rounds)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET name="%s", kills=%s, suicides=%s, teamkills=%s, rounds=%s WHERE id=%s' % (
            self._table, self.name, self.kills, self.suicides, self.teamkills, self.rounds, self.id)
        return q


class PlayerBody(StatObject):
    #default name of the table for this data object
    _table = 'playerbody'

    #fields of the table
    id = None
    player_id = 0
    bodypart_id = 0
    kills = 0
    deaths = 0
    suicides = 0
    teamkills = 0
    teamdeaths = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( player_id, bodypart_id, kills, deaths, suicides, teamkills, teamdeaths ) VALUES (%s, %s, %s, %s, %s, %s, %s)' % (
            self._table, self.player_id, self.bodypart_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET player_id=%s, bodypart_id=%s, kills=%s, deaths=%s, suicides=%s, teamkills=%s, teamdeaths=%s WHERE id=%s' % (
            self._table, self.player_id, self.bodypart_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths, self.id)
        return q


class PlayerMaps(StatObject):
    #default name of the table for this data object
    _table = 'playermaps'

    #fields of the table
    id = 0
    player_id = 0
    map_id = 0
    kills = 0
    deaths = 0
    suicides = 0
    teamkills = 0
    teamdeaths = 0
    rounds = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( player_id, map_id, kills, deaths, suicides, teamkills, teamdeaths, rounds ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)' % (
            self._table, self.player_id, self.map_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths, self.rounds)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET player_id=%s, map_id=%s, kills=%s, deaths=%s, suicides=%s, teamkills=%s, teamdeaths=%s, rounds=%s WHERE id=%s' % (
            self._table, self.player_id, self.map_id, self.kills, self.deaths, self.suicides, self.teamkills,
            self.teamdeaths, self.rounds, self.id)
        return q


class Opponents(StatObject):
    #default name of the table for this data object
    _table = 'opponents'

    #fields of the table
    id = None
    killer_id = 0
    target_id = 0
    kills = 0
    retals = 0

    def _insertquery(self):
        q = 'INSERT INTO %s (killer_id, target_id, kills, retals) VALUES (%s, %s, %s, %s)' % (
            self._table, self.killer_id, self.target_id, self.kills, self.retals)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET killer_id=%s, target_id=%s, kills=%s, retals=%s WHERE id=%s' % (
            self._table, self.killer_id, self.target_id, self.kills, self.retals, self.id)
        return q


class ActionStats(StatObject):
    #default name of the table for this data object
    _table = 'actionstats'

    #fields of the table
    id = None
    name = ''
    count = 0

    def _insertquery(self):
        q = 'INSERT INTO %s (name, count) VALUES ("%s", %s)' % (self._table, self.name, self.count)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET name="%s", count=%s WHERE id=%s' % (self._table, self.name, self.count, self.id)
        return q


class PlayerActions(StatObject):
    #default name of the table for this data object
    _table = 'playeractions'

    #fields of the table
    id = None
    player_id = 0
    action_id = 0
    count = 0

    def _insertquery(self):
        q = 'INSERT INTO %s ( player_id, action_id, count ) VALUES (%s, %s, %s)' % (
            self._table, self.player_id, self.action_id, self.count)
        return q

    def _updatequery(self):
        q = 'UPDATE %s SET player_id=%s, action_id=%s, count=%s WHERE id=%s' % (
            self._table, self.player_id, self.action_id, self.count, self.id)
        return q


if __name__ == '__main__':
    print '\nThis is version ' + __version__ + ' by ' + __author__ + ' for BigBrotherBot.\n'

"""\
Crontab:
*  *  *  *  *  command to be executed
-  -  -  -  -
|  |  |  |  |
|  |  |  |  +----- day of week (0 - 6) (Sunday=0)
|  |  |  +------- month (1 - 12)
|  |  +--------- day of month (1 - 31)
|  +----------- hour (0 - 23)
+------------- min (0 - 59)

Query:
INSERT INTO xlr_history_weekly (`client_id` , `kills` , `deaths` , `teamkills` , `teamdeaths` , `suicides` , `ratio` , `skill` , `winstreak` , `losestreak` , `rounds`, `year`, `month`, `week`, `day`) 
  SELECT `client_id` , `kills` , `deaths` , `teamkills` , `teamdeaths` , `suicides` , `ratio` , `skill` , `winstreak` , `losestreak` , `rounds`, YEAR(NOW()), MONTH(NOW()), WEEK(NOW(),3), DAY(NOW()) 
  FROM `xlr_playerstats`
"""


# local variables:
# tab-width: 4

########NEW FILE########
__FILENAME__ = fake
""" 
    This module make plugin testing simple. It provides you
    with fakeConsole and joe which can be used to say commands
    as if it where a player.
"""
""" Example with the spamcontrol plugin :
    
if __name__ == '__main__':
    from b3.fake import fakeConsole
    from b3.fake import joe
    
    p = SpamcontrolPlugin(fakeConsole, '@b3/conf/plugin_spamcontrol.xml')
    p.onStartup()
    
    p.info("---------- start spamming")
    joe.says("i'm spammmmmmmmmming")
    time.sleep(1)
    joe.says("i'm spammmmmmmmmming")
    time.sleep(1)
    joe.says("i'm spammmmmmmmmming")
    time.sleep(1)
    joe.says("i'm spammmmmmmmmming")
    time.sleep(1)
    joe.says("i'm spammmmmmmmmming")
    time.sleep(1)
    joe.says("i'm spammmmmmmmmming")
"""
""" Example with the adv plugin

if __name__ == '__main__':
    from b3.fake import fakeConsole
    from b3.fake import joe
    
    p = AdvPlugin(fakeConsole, '@b3/conf/plugin_adv.xml')
    p.onStartup()
    
    p.adv()
    print "-----------------------------"
    time.sleep(2)
    
    joe._maxLevel = 100
    joe.authed = True
    joe.says('!advlist')
    time.sleep(2)
    joe.says('!advrem 0')
    time.sleep(2)
    joe.says('!advrate 1')
    while True: pass # so we can see cron events 
"""
""" Example with the censor plugin :
    
if __name__ == '__main__':
    import time
    from b3.fake import fakeConsole
    from b3.fake import joe
    
    p = CensorPlugin(fakeConsole, '@b3/conf/plugin_censor.xml')
    p.onStartup()

    fakeConsole.noVerbose = True
    joe._maxLevel = 0
    joe.connected = True
    
    #p.onEvent(b3.events.Event(b3.events.EVT_CLIENT_SAY, "fuck", joe))
    joe.says('hello')
    joe.says('fuck')
    joe.says('nothing wrong')
    joe.says('ass')
    joe.says('shit')
    
    time.sleep(2)
"""

# CHANGELOG
# 1.3
#    * add FakeConsole.saybig(msg)
#    * FakeConsole.write() do not fail when arg is not a string
# 1.4 - 2010/11/01
#    * improve FakeStorage implementation
# 1.5 - 2010/11/21
#    * FakeConsole event mechanism does not involve a Queue anymore as this
#      class is meant to test one plugin at a time there is no need for 
#      producer/consumer pattern. This speeds up tests and simplifies the use
#      of a debugger. Also tests do not neet time.sleep() to make sure the events
#      were handled before checking results and moving on (unittest friendly)
# 1.6 - 2010/11/21
# * remove more time.sleep()
# * add message_history for FakeClient which allow to test if a client was sent a message afterward (unittest)
# 1.7 - 2011/06/04
# * replace FakeStorage with DatabaseStorage("sqlite://:memory:")
# 1.8 - 2011/06/06
# * add ban()
# * change data format for EVT_CLIENT_BAN_TEMP and EVT_CLIENT_BAN events
# 1.9 - 2011/06/09
# * FakeConsole now uses the logging module
# 1.10 - 2011/12/29
# * fix issue with plugins' registered events when importing fakeConsole in different TestSuites
# 1.11 - 2012/04/15
# * fix issue with message_history of FakeClient which was shared between instances
__version__ = '1.11'


from b3.cvar import Cvar
from b3.plugins.admin import AdminPlugin
from b3.storage.database import DatabaseStorage
from sys import stdout
import StringIO
import b3.events
import b3.output
import b3.parser
import b3.parsers.punkbuster
import logging
from logging import handlers
import re
import time
import traceback
import sys

class FakeConsole(b3.parser.Parser):
    Events = b3.events.eventManager = b3.events.Events()
    screen = stdout
    noVerbose = False
    input = None
    
    def __init__(self, config):
        b3.console = self
        self._timeStart = self.time()
        
        logging.basicConfig(level=b3.output.VERBOSE2, format='%(asctime)s\t%(levelname)s\t%(message)s')
        self.log = logging.getLogger('output')
        
        
        if isinstance(config, b3.config.XmlConfigParser) \
            or isinstance(config, b3.config.CfgConfigParser):
            self.config = config
        else:
            self.config = b3.config.load(config)
        
        self.storage =  DatabaseStorage("sqlite://:memory:", self)
        self.clients  = b3.clients.Clients(self)
        self.game = b3.game.Game(self, "fakeGame")
        self.game.mapName = 'ut4_turnpike'
        self.cvars = {}
        self._handlers = {}
        
        if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
            self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)
        
        self.input = StringIO.StringIO()
        self.working = True
    
    def run(self):
        pass
    def queueEvent(self, event, expire=10):
        """Queue an event for processing. NO QUEUE, NO THREAD for faking speed up"""
        if not hasattr(event, 'type'):
            return False
        elif self._handlers.has_key(event.type):    # queue only if there are handlers to listen for this event
            self.verbose('Queueing event %s %s', self.Events.getName(event.type), event.data)
            self._handleEvent(event)
            return True
        return False
    
    def _handleEvent(self, event):
        """NO QUEUE, NO THREAD for faking speed up"""
        if event.type == b3.events.EVT_EXIT or event.type == b3.events.EVT_STOP:
            self.working = False

        nomore = False
        for hfunc in self._handlers[event.type]:
            if not hfunc.isEnabled():
                continue
            elif nomore:
                break

            self.verbose('Parsing Event: %s: %s', self.Events.getName(event.type), hfunc.__class__.__name__)
            try:
                hfunc.parseEvent(event)
                time.sleep(0.001)
            except b3.events.VetoEvent:
                # plugin called for event hault, do not continue processing
                self.bot('Event %s vetoed by %s', self.Events.getName(event.type), str(hfunc))
                nomore = True
            except SystemExit, e:
                self.exitcode = e.code
            except Exception, msg:
                self.error('handler %s could not handle event %s: %s: %s %s', hfunc.__class__.__name__, self.Events.getName(event.type), msg.__class__.__name__, msg, traceback.extract_tb(sys.exc_info()[2]))

    def shutdown(self):
        """Shutdown B3 - needed to be changed in FakeConsole due to no thread for dispatching events"""
        try:
            if self.working and self.exiting.acquire():
                self.bot('Shutting down...')
                self.working = False
                self._handleEvent(b3.events.Event(b3.events.EVT_STOP, ''))
                if self._cron:
                    self._cron.stop()
                self.bot('Shutting down database connections...')
                self.storage.shutdown()
        except Exception, e:
            self.error(e)

    def getPlugin(self, name):
        if name == 'admin':
            return fakeAdminPlugin
        else:
            return b3.parser.Parser.getPlugin(self, name)
    
    def sync(self):
        return {}
    
    def getNextMap(self):
        return "ut4_theNextMap"
    
    def getPlayerScores(self):
        return {0:5,1:4}
    
    def say(self, msg):
        """send text to the server"""
        print ">>> %s" % re.sub(re.compile('\^[0-9]'), '', msg).strip()
    
    def saybig(self, msg):
        """send bigtext to the server"""
        print "+++ %s" % re.sub(re.compile('\^[0-9]'), '', msg).strip()
    
    def write(self, msg, maxRetries=0):
        """send text to the console"""
        if type(msg) == str:
            print "### %s" % re.sub(re.compile('\^[0-9]'), '', msg).strip()
        else:
            # which happens for BFBC2
            print "### %s" % msg
    
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def authorizeClients(self):
        pass

    def ban(self, client, reason, admin, silent):
        """permban a client"""
        print '>>>permbanning %s (%s)' % (client.name, reason)
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN', {'reason': reason, 'admin': admin}, client))
        client.disconnect()
    
    def tempban(self, client, reason, duration, admin, silent):
        """tempban a client"""
        from functions import minutesStr
        print '>>>tempbanning %s for %s (%s)' % (client.name, reason, minutesStr(duration))
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN_TEMP', {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                      , client))
        client.disconnect()
    
    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        """unban a client"""
        print '>>>unbanning %s (%s)' % (client.name, reason)
        self.queueEvent(self.getEvent('EVT_CLIENT_UNBAN', reason, client))

    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        print '>>>kick %s for %s' % (client.name, reason)
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_KICK, reason, client))
        client.disconnect()
    
    def message(self, client, text):
        if client is None:
            self.say(text)
        elif client.cid is None:
            pass
        else:
            print "sending msg to %s: %s" % (client.name, re.sub(re.compile('\^[0-9]'), '', text).strip())
    
    def getCvar(self, key):
        print "get cvar %s" % key
        return self.cvars.get(key)

    def setCvar(self, key, value):
        print "set cvar %s" % key
        c = Cvar(name=key,value=value)
        self.cvars[key] = c



class FakeClient(b3.clients.Client):
    console = None

    def __init__(self, console, **kwargs):
        self.console = console
        self.message_history = [] # this allows unittests to check if a message was sent to the client
        b3.clients.Client.__init__(self, **kwargs)
                
    def clearMessageHistory(self):
        self.message_history = []
    def getMessageHistoryLike(self, needle):
        clean_needle = re.sub(re.compile('\^[0-9]'), '', needle).strip()
        for m in self.message_history:
            if clean_needle in m:
                return m
        return None
    def getAllMessageHistoryLike(self, needle):
        result = []
        clean_needle = re.sub(re.compile('\^[0-9]'), '', needle).strip()
        for m in self.message_history:
            if clean_needle in m:
                result.append(m)
        return result
    
    def message(self, msg):
        cleanmsg = re.sub(re.compile('\^[0-9]'), '', msg).strip()
        self.message_history.append(cleanmsg)
        print "sending msg to %s: %s" % (self.name, cleanmsg)
    def warn(self, duration, warning, keyword=None, admin=None, data=''):
        w = b3.clients.Client.warn(self, duration, warning, keyword=None, admin=None, data='')
        print(">>>>%s gets a warning : %s" % (self, w))
    def connects(self, cid):
        print "\n%s connects to the game on slot #%s" % (self.name, cid)
        self.cid = cid
        self.timeAdd = self.console.time()
        #self.console.clients.newClient(cid)
        clients = self.console.clients
        clients[self.cid] = self
        clients.resetIndex()

        self.console.debug('Client Connected: [%s] %s - %s (%s)', clients[self.cid].cid, clients[self.cid].name, clients[self.cid].guid, clients[self.cid].data)

        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_CONNECT, self, self))
    
        if self.guid:
            self.auth()
        elif not self.authed:
            clients._authorizeClients()
         
    def disconnects(self):
        print "\n%s disconnects from slot #%s" % (self.name, self.cid)
        self.console.clients.disconnect(self)
        self.cid = None
        self.authed = False
        self._pluginData = {}
        self.state = b3.STATE_UNKNOWN
    
    def says(self, msg):
        print "\n%s says \"%s\"" % (self.name, msg)
        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_SAY, msg, self))
        
    def says2team(self, msg):
        print "\n%s says to team \"%s\"" % (self.name, msg)
        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, msg, self))
        
    def damages(self, victim, points=34.0):
        print "\n%s damages %s for %s points" % (self.name, victim.name, points)
        if self == victim:
            e = b3.events.EVT_CLIENT_DAMAGE_SELF
        elif self.team != b3.TEAM_UNKNOWN and self.team == victim.team:
            e = b3.events.EVT_CLIENT_DAMAGE_TEAM
        else:
            e = b3.events.EVT_CLIENT_DAMAGE
        self.console.queueEvent( b3.events.Event(e, (points, 1, 1, 1), self, victim))
        
    def kills(self, victim):
        print "\n%s kills %s" % (self.name, victim.name)
        if self == victim:
            self.suicides()
            return
        elif self.team != b3.TEAM_UNKNOWN and self.team == victim.team:
            e = b3.events.EVT_CLIENT_KILL_TEAM
        else:
            e = b3.events.EVT_CLIENT_KILL
        self.console.queueEvent(b3.events.Event(e, (100, 1, 1, 1), self, victim))
        
    def suicides(self):
        print "\n%s kills himself" % self.name
        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_SUICIDE, 
                                                       (100, 1, 1, 1), 
                                                       self, victim))
        
    def doAction(self, actiontype):
        self.console.queueEvent((b3.events.Event(b3.events.EVT_CLIENT_ACTION, actiontype, self)))

    def triggerEvent(self, type, data, target=None):
        print "\n%s trigger event %s" % (self.name, type)
        self.console.queueEvent(b3.events.Event(type, data, self, target))


#####################################################################################

print "creating fakeConsole with @b3/conf/b3.distribution.xml"
fakeConsole = FakeConsole('@b3/conf/b3.distribution.xml')

print "creating fakeAdminPlugin with @b3/conf/plugin_admin.xml"
fakeAdminPlugin = AdminPlugin(fakeConsole, '@b3/conf/plugin_admin.xml')
fakeAdminPlugin.onStartup()

joe = FakeClient(fakeConsole, name="Joe", exactName="Joe", guid="zaerezarezar", groupBits=1, team=b3.TEAM_UNKNOWN)
simon = FakeClient(fakeConsole, name="Simon", exactName="Simon", guid="qsdfdsqfdsqf", groupBits=0, team=b3.TEAM_UNKNOWN)
reg = FakeClient(fakeConsole, name="Reg", exactName="Reg", guid="qsdfdsqfdsqf33", groupBits=4, team=b3.TEAM_UNKNOWN)
moderator = FakeClient(fakeConsole, name="Moderator", exactName="Moderator", guid="sdf455ezr", groupBits=8, team=b3.TEAM_UNKNOWN)
admin = FakeClient(fakeConsole, name="Level-40-Admin", exactName="Level-40-Admin", guid="875sasda", groupBits=16, team=b3.TEAM_UNKNOWN)
superadmin = FakeClient(fakeConsole, name="God", exactName="God", guid="f4qfer654r", groupBits=128, team=b3.TEAM_UNKNOWN)

########NEW FILE########
__FILENAME__ = functions
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# 27/03/2010 - 1.2.1 - xlr8or - set default port for mysql
# 11/04/2010 - 1.2.2 - Courgette - make splitDSN support usernames containing '@'
# 01/09/2010 - 1.3 - Courgette - make splitDSN add default ftp and sftp port
# 08/11/2010 - 1.3.1 - GrosBedo - vars2printf is now more robust against empty strings
# 01/12/2010 - 1.3.2 - Courgette - checkUpdate now uses a custom short timeout to
#   prevent blocking the bot when the B3 server is hanging
# 17/04/2011 - 1.3.3 - Courgette - make sanitizeMe unicode compliant
# 06/06/2011 - 1.4.0 - Courgette - add meanstdv()
# 07/06/2011 - 1.4.1 - Courgette - fix meanstdv()
# 17/06/2012 - 1.5   - Courgette - add getStuffSoundingLike()
# 19/10/2012 - 1.6   - Courgette - improve getStuffSoundingLike() so it discards non letter/digit characters
# 20/10/2012 - 1.7   - Courgette - fix soundex() error when input string is unicode
# 26/11/2012 - 1.8   - Courgette - add hash_password()
#
__author__    = 'ThorN, xlr8or'
__version__   = '1.8'

import b3
import re
import os
import sys
import imp
import string
import urllib2
from hashlib import md5


def getModule(name):
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod




#--------------------------------------------------------------------------------------------------
def main_is_frozen():
    """detect if b3 is running from b3_run.exe"""
    return (hasattr(sys, "frozen") or # new py2exe
        hasattr(sys, "importers") or # old py2exe
        imp.is_frozen("__main__")) # tools/freeze

#--------------------------------------------------------------------------------------------------
def splitDSN(url):
    m = re.match(r'^(?:(?P<protocol>[a-z]+)://)?(?:(?P<user>[^:]+)(?::(?P<password>[^@]+))?@)?(?P<host>[^/:]+)?(?::(?P<port>\d+))?(?P<path>.*)', url)
    if not m:
        return None

    g = m.groupdict()

    if not g['protocol']:
        g['protocol'] = 'file'
    if g['protocol'] == 'file':
        if g['host'] and g['path']:
            g['path'] = '%s%s' % (g['host'], g['path'])
            g['host'] = None
        elif g['host']:
            g['path'] = g['host']
            g['host'] = None
    elif g['protocol'] == 'exec':
        if g['host'] and g['path']:
            g['path'] = '%s/%s' % (g['host'], g['path'])
            g['host'] = None
        elif g['host']:
            g['path'] = g['host']
            g['host'] = None

    if g['port']:
        g['port'] = int(g['port'])
    elif g['protocol'] == 'ftp':
        g['port'] = 21
    elif g['protocol'] == 'sftp':
        g['port'] = 22
    elif g['protocol'] == 'mysql':
        g['port'] = 3306

    return g

#--------------------------------------------------------------------------------------------------
def confirm(client):
    msg = 'No confirmation...'
    try:
        #first test again known guids
        f = urllib2.urlopen('http://www.bigbrotherbot.net/confirm.php?uid=%s' %client.guid)
        response = f.read()
        if not response == 'Error' and not response == 'False':
            msg = '%s is confirmed to be %s!' %(client.name, response)
        else:
            #if it fails, try ip (must be static)
            f = urllib2.urlopen('http://www.bigbrotherbot.net/confirm.php?ip=%s' %client.ip)
            response = f.read()
            if not response == 'Error' and not response == 'False':
                msg = '%s is confirmed to be %s!' %(client.name, response)
    except:
        pass
    return msg

#--------------------------------------------------------------------------------------------------
def minutes2int(mins):
    if re.match('^[0-9.]+$', mins):
        return round(float(mins), 2)
    else:
        return 0

#--------------------------------------------------------------------------------------------------
def time2minutes(timeStr):
    if not timeStr:
        return 0
    elif type(timeStr) is int:
        return timeStr

    timeStr = str(timeStr)
    if not timeStr:
        return 0
    elif timeStr[-1:] == 'h':
        return minutes2int(timeStr[:-1]) * 60
    elif timeStr[-1:] == 'm':
        return minutes2int(timeStr[:-1])
    elif timeStr[-1:] == 's':
        return minutes2int(timeStr[:-1]) / 60
    elif timeStr[-1:] == 'd':
        return minutes2int(timeStr[:-1]) * 60 * 24
    elif timeStr[-1:] == 'w':
        return minutes2int(timeStr[:-1]) * 60 * 24 * 7
    else:
        return minutes2int(timeStr)

#--------------------------------------------------------------------------------------------------
def minutesStr(timeStr):
    mins = float(time2minutes(timeStr))

    if mins < 1:
        num = round(mins * 60, 1)
        s = '%s second'
    elif mins < 60:
        num = round(mins, 1)
        s = '%s minute'
    elif mins < 1440:
        num = round(mins / 60, 1)
        s = '%s hour'
    elif mins < 10080:
        num = round((mins / 60) / 24, 1)
        s = '%s day'
    elif mins < 525600:
        num = round(((mins / 60) / 24) / 7, 1)
        s = '%s week'
    else:
        num = round(((mins / 60) / 24) / 365, 1)
        s = '%s year'

    # convert to int if num is whole
    num = int(num) if num%1==0 else num

    if num >= 2:
        s += 's'

    return s % num

def vars2printf(inputStr):
    if inputStr is not None and inputStr != '':
        return re.sub(r'\$([a-zA-Z]+)', r'%(\1)s', inputStr)
    else:
        return ''

#--------------------------------------------------------------------------------------------------
def levenshteinDistance(a,b):
    c = {}
    n = len(a); m = len(b)

    for i in range(0,n+1):
        c[i,0] = i
    for j in range(0,m+1):
        c[0,j] = j

    for i in range(1,n+1):
        for j in range(1,m+1):
            x = c[i-1,j]+1
            y = c[i,j-1]+1
            if a[i-1] == b[j-1]:
                z = c[i-1,j-1]
            else:
                z = c[i-1,j-1]+1
            c[i,j] = min(x,y,z)
    return c[n,m]


def soundex(str):
    """Return the soundex value to a string argument."""

    IGNORE = "~!@#$%^&*()_+=-`[]\|;:'/?.,<>\" \t\f\v"
    TABLE  = string.maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                          '01230120022455012623010202')

    str = string.strip(string.upper(str))
    if not str:
        return "Z000"
    str2 = str[0]
    str = string.translate(str.encode('ascii', 'ignore'), TABLE, IGNORE)
    if not str:
        return "Z000"
    prev = str[0]
    for x in str[1:]:
        if x != prev and x != "0":
                str2 = str2 + x
        prev = x
    # pad with zeros
    str2 += "0000"
    return str2[:4]


"""
Calculate mean and standard deviation of data x[]:
    mean = {\sum_i x_i \over n}
    std = sqrt(\sum_i (x_i - mean)^2 \over n-1)
credit: http://www.physics.rutgers.edu/~masud/computing/WPark_recipes_in_python.html
"""
def meanstdv(x):
    from math import sqrt
    n, mean, std = len(x), 0, 0
    for a in x:
        mean = mean + a
    try:
        mean = mean / float(n)
    except ZeroDivisionError:
        mean = 0
    for a in x:
        std = std + (a - mean)**2
    try:
        std = sqrt(std / float(n-1))
    except ZeroDivisionError:
        std = 0
    return mean, std

def fuzzyGuidMatch(a, b):
    a = a.upper()
    b = b.upper()

    if a == b:
        return True
    
    # put the longest first
    if len(b) > len(a):
        a, b = b, a

    if len(a) == 32 and len(b) == 31:
        # Looks like a truncated id, check using levenshtein
        # Use levenshteinDistance to find GUIDs off by 1 char, as caused by a bug in COD Punkbuster
        distance = levenshteinDistance(a, b)
        if distance <= 1:
            return True
    
    return False

#--------------------------------------------------------------------------------------------------
def sanitizeMe(s):
    if s:
        return re.sub(r'[\x00-\x1F]|[\x7F-\xff]', '?', s)
    else:
        return ''

#--------------------------------------------------------------------------------------------------
## @todo see if functions.executeSQL() and storage.DatabaseStorage.queryFromFile() can be combined.
def executeSql(db, file):
    """This method executes an external sql file on the current database
    A similar function can be found in storage.DatabaseStorage.queryFromFile()
    This one returns if a file is not found.
    """
    sqlFile = b3.getAbsolutePath(file)
    if os.path.exists(sqlFile):
        try:
            f = open(sqlFile, 'r')
        except Exception:
            return 'couldnotopen'
        sql_text = f.read()
        f.close()
        sql_statements = sql_text.split(';')
        for s in sql_statements:
            try:
                db.query(s)
            except Exception:
                pass
    else:
        return 'notfound'
    return 'success'
#--------------------------------------------------------------------------------------------------


def getStuffSoundingLike(stuff, expected_stuff):
    """found matching stuff for the given expected_stuff list.
    If no exact match is found, then return close candidates using by substring match.
    If no subtring matches, then use soundex and then LevenshteinDistance algorithms
    """
    re_not_text = re.compile("[^a-z0-9]", re.IGNORECASE)
    def clean(txt):
        return re.sub(re_not_text, '', txt.lower())
    clean_stuff = clean(stuff)
    soundex1 = soundex(stuff)

    clean_expected_stuff = dict()
    for i in expected_stuff:
        clean_expected_stuff[clean(i)] = i

    match = []
    # given stuff could be the exact match
    if stuff in expected_stuff:
        match = [stuff]
    elif clean_stuff in clean_expected_stuff:
        match = [clean_expected_stuff[clean_stuff]]
    else:
        # stuff could be a substring of one of the expected value
        matching_subset = filter(lambda x: x.lower().find(clean_stuff) >= 0, clean_expected_stuff.keys())
        if len(matching_subset) == 1:
            match = [clean_expected_stuff[matching_subset[0]]]
        elif len(matching_subset) > 1:
            match = [clean_expected_stuff[i] for i in matching_subset]
        else:
            # no luck with subset lookup, fallback on soundex magic
            for m in clean_expected_stuff.keys():
                s = soundex(m)
                if s == soundex1:
                    match.append(clean_expected_stuff[m])

    if not len(match):
        match = expected_stuff
        match.sort(key=lambda _map: levenshteinDistance(clean_stuff, _map.strip()))
    return match


def hash_password(password):
    return md5(password).hexdigest()
########NEW FILE########
__FILENAME__ = game
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
#
# 26/03/2011 - 1.3 - Courgette
#    * add event EVT_GAME_MAP_CHANGE
# 21/07/2011 - 1.3.1 - Freelander
#    * prevent status plugin errors during map change
#

__author__  = 'ThorN'
__version__ = '1.3.1'

import time
from b3.events import Event, EVT_GAME_MAP_CHANGE

class Game(object):
    _mapName = None
    timeLimit = None
    fragLimit = None
    captureLimit = None
    gameType = None
    _roundTimeStart = None
    _mapTimeStart = None
    rounds = 0
    gameName = None
    modName = None

    def __init__(self, console, gameName):
        self.console = console
        self.gameName = gameName
        self.startRound()

    def __getattr__(self, key):
        if self.__dict__.has_key(key):
            return self.__dict__[key]
        return None

    def __setitem__(self, key, value):
        self.__dict__[key] = value
        return self.__dict__[key]

    def _get_mapName(self):
        return self._mapName

    def _set_mapName(self, newmap):
        if self._mapName != newmap:
            self.console.queueEvent(Event(EVT_GAME_MAP_CHANGE, {'old': self._mapName, 'new': newmap}))
        self._mapName = newmap
    
    mapName = property(_get_mapName, _set_mapName)

    def mapTime(self):
        if self._mapTimeStart:
            return self.console.time() - self._mapTimeStart
        return None

    def roundTime(self):
        return self.console.time() - self._roundTimeStart

    def startRound(self):
        if not self._mapTimeStart:
            self.startMap()

        self._roundTimeStart = self.console.time()
        self.rounds = self.rounds + 1

    def startMap(self, mapName=None):
        if mapName:
            self.mapName = mapName

        self._mapTimeStart = self.console.time()

    def mapEnd(self):
        self._mapTimeStart = None
        
        
if __name__ == '__main__':
    from b3.plugin import Plugin
    from b3.fake import fakeConsole
    
    fakeplugin = Plugin(fakeConsole)
    def onEvent(event):
        if event.type == EVT_GAME_MAP_CHANGE:
            fakeConsole.debug("event EVT_GAME_MAP_CHANGE : %r" % event.data)
            fakeConsole.debug("previous map was %s" % event.data['old'])
            fakeConsole.debug("new map is %s" % event.data['new'])
    fakeplugin.onEvent = onEvent
    
    fakeConsole.registerHandler(EVT_GAME_MAP_CHANGE, fakeplugin)
    
    game = Game(fakeConsole, 'fakegamename')
    
    print('setting map name to map1...')
    game.mapName = 'map1'
    assert game.mapName == 'map1'

    time.sleep(2)
    print('setting map name to map2...')
    game.mapName = 'map2'
    assert game.mapName == 'map2'
        
    time.sleep(2)
    print('setting map name to map2...')
    game.mapName = 'map2'
    assert game.mapName == 'map2'
        
    time.sleep(2)
    print('setting map name to map3...')
    game.mapName = 'map3'
    assert game.mapName == 'map3'
    
        

########NEW FILE########
__FILENAME__ = game_event_router
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
import re


"""
This module helps defining handlers functions to be called when a game event is received by providing :

  - a decorator for associating a regular expression to a handling function : @ger.gameEvent(<regular expression>, ...)
  - a method getHandler(<text>) that return a tuple <func, dict> where *func* is the first handler function defined
    with the gameEvent decorator that matches the given *text* and *dict* is a dict of all matched groups from the
    regular expression that was associated to *func* with the decorator.


Usage :
-------

This tool is meant to be used by B3 game parsers which need to parse game event (in the form of a string) and call
a function that takes action for this type of game event.

To make a B3 parser take advantage of the GameEventRouter, the B3 parser needs to redefine the *parseLine* method
as follow :

from b3.game_event_router import Game_event_router

ger = Game_event_router()

def parseLine(self, line):
    if line is None:
        return
    hfunc, param_dict = ger.getHandler(line)
    if hfunc:
        self.verbose2("calling %s%r" % (hfunc.func_name, param_dict))
        event = hfunc(self, **param_dict)
        if event:
            self.queueEvent(event)


Let say you need to print "Robin joined team BLUE" when parsing a game event which is "join: Robin, BLUE" then you would
have the following method in your B3 game parser :

@ger.gameEvent("^join: (?P<name>.+), (?P<team>.+)$")
def on_connect(self, name, team):
    print "%s joined team %s" % (name, team)


Note that the handler function must have parameters that matches the regular expression groups.

The @ger.gameEvent decorator accepts multiple parameters if you need to have one handling function for multiple kind of
game events. Note that those regular expressions should all define the same groups.

"""


class Game_event_router(object):

    def __init__(self):
        # will hold mapping between regular expressions and handler functions
        self._gameevents_mapping = list()


    def gameEvent(self, *decorator_param):
        """
        python decorator to easily map a handler function to a regular expression mathching a game event
        """
        def wrapper(func):
            for param in decorator_param:
                if isinstance(param, type(re.compile(''))):
                    self._gameevents_mapping.append((param, func))
                elif isinstance(param, basestring):
                    self._gameevents_mapping.append((re.compile(param), func))
            return func
        return wrapper



    def getHandler(self, gameEvent):
        """
        for a given game event, return the corresponding handler function and a dict of the matched regular expression groups
        """
        for regex, hfunc in self._gameevents_mapping:
            match = regex.match(gameEvent)
            if match:
                return hfunc, match.groupdict()
        return None, {}


########NEW FILE########
__FILENAME__ = argparse
# -*- coding: utf-8 -*-

# Copyright  2006-2009 Steven J. Bethard <steven.bethard@gmail.com>.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy
# of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""Command-line parsing library

This module is an optparse-inspired command-line parsing library that:

    - handles both optional and positional arguments
    - produces highly informative usage messages
    - supports parsers that dispatch to sub-parsers

The following is a simple usage example that sums integers from the
command-line and writes the result to a file::

    parser = argparse.ArgumentParser(
        description='sum the integers at the command line')
    parser.add_argument(
        'integers', metavar='int', nargs='+', type=int,
        help='an integer to be summed')
    parser.add_argument(
        '--log', default=sys.stdout, type=argparse.FileType('w'),
        help='the file where the sum should be written')
    args = parser.parse_args()
    args.log.write('%s' % sum(args.integers))
    args.log.close()

The module contains the following public classes:

    - ArgumentParser -- The main entry point for command-line parsing. As the
        example above shows, the add_argument() method is used to populate
        the parser with actions for optional and positional arguments. Then
        the parse_args() method is invoked to convert the args at the
        command-line into an object with attributes.

    - ArgumentError -- The exception raised by ArgumentParser objects when
        there are errors with the parser's actions. Errors raised while
        parsing the command-line are caught by ArgumentParser and emitted
        as command-line messages.

    - FileType -- A factory for defining types of files to be created. As the
        example above shows, instances of FileType are typically passed as
        the type= argument of add_argument() calls.

    - Action -- The base class for parser actions. Typically actions are
        selected by passing strings like 'store_true' or 'append_const' to
        the action= argument of add_argument(). However, for greater
        customization of ArgumentParser actions, subclasses of Action may
        be defined and passed as the action= argument.

    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
        ArgumentDefaultsHelpFormatter -- Formatter classes which
        may be passed as the formatter_class= argument to the
        ArgumentParser constructor. HelpFormatter is the default,
        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
        not to change the formatting for help text, and
        ArgumentDefaultsHelpFormatter adds information about argument defaults
        to the help.

All other classes in this module are considered implementation details.
(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
considered public as object names -- the API of the formatter objects is
still considered an implementation detail.)
"""

__version__ = '1.1'
__all__ = [
    'ArgumentParser',
    'ArgumentError',
    'Namespace',
    'Action',
    'FileType',
    'HelpFormatter',
    'RawDescriptionHelpFormatter',
    'RawTextHelpFormatter',
    'ArgumentDefaultsHelpFormatter',
]


import copy as _copy
import os as _os
import re as _re
import sys as _sys
import textwrap as _textwrap

from gettext import gettext as _

try:
    _set = set
except NameError:
    from sets import Set as _set

try:
    _basestring = basestring
except NameError:
    _basestring = str

try:
    _sorted = sorted
except NameError:

    def _sorted(iterable, reverse=False):
        result = list(iterable)
        result.sort()
        if reverse:
            result.reverse()
        return result


def _callable(obj):
    return hasattr(obj, '__call__') or hasattr(obj, '__bases__')

# silence Python 2.6 buggy warnings about Exception.message
if _sys.version_info[:2] == (2, 6):
    import warnings
    warnings.filterwarnings(
        action='ignore',
        message='BaseException.message has been deprecated as of Python 2.6',
        category=DeprecationWarning,
        module='argparse')


SUPPRESS = '==SUPPRESS=='

OPTIONAL = '?'
ZERO_OR_MORE = '*'
ONE_OR_MORE = '+'
PARSER = 'A...'
REMAINDER = '...'

# =============================
# Utility functions and classes
# =============================

class _AttributeHolder(object):
    """Abstract base class that provides __repr__.

    The __repr__ method returns a string in the format::
        ClassName(attr=name, attr=name, ...)
    The attributes are determined either by a class-level attribute,
    '_kwarg_names', or by inspecting the instance __dict__.
    """

    def __repr__(self):
        type_name = type(self).__name__
        arg_strings = []
        for arg in self._get_args():
            arg_strings.append(repr(arg))
        for name, value in self._get_kwargs():
            arg_strings.append('%s=%r' % (name, value))
        return '%s(%s)' % (type_name, ', '.join(arg_strings))

    def _get_kwargs(self):
        return _sorted(self.__dict__.items())

    def _get_args(self):
        return []


def _ensure_value(namespace, name, value):
    if getattr(namespace, name, None) is None:
        setattr(namespace, name, value)
    return getattr(namespace, name)


# ===============
# Formatting Help
# ===============

class HelpFormatter(object):
    """Formatter for generating usage messages and argument help strings.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def __init__(self,
                 prog,
                 indent_increment=2,
                 max_help_position=24,
                 width=None):

        # default setting for width
        if width is None:
            try:
                width = int(_os.environ['COLUMNS'])
            except (KeyError, ValueError):
                width = 80
            width -= 2

        self._prog = prog
        self._indent_increment = indent_increment
        self._max_help_position = max_help_position
        self._width = width

        self._current_indent = 0
        self._level = 0
        self._action_max_length = 0

        self._root_section = self._Section(self, None)
        self._current_section = self._root_section

        self._whitespace_matcher = _re.compile(r'\s+')
        self._long_break_matcher = _re.compile(r'\n\n\n+')

    # ===============================
    # Section and indentation methods
    # ===============================
    def _indent(self):
        self._current_indent += self._indent_increment
        self._level += 1

    def _dedent(self):
        self._current_indent -= self._indent_increment
        assert self._current_indent >= 0, 'Indent decreased below 0.'
        self._level -= 1

    class _Section(object):

        def __init__(self, formatter, parent, heading=None):
            self.formatter = formatter
            self.parent = parent
            self.heading = heading
            self.items = []

        def format_help(self):
            # format the indented section
            if self.parent is not None:
                self.formatter._indent()
            join = self.formatter._join_parts
            for func, args in self.items:
                func(*args)
            item_help = join([func(*args) for func, args in self.items])
            if self.parent is not None:
                self.formatter._dedent()

            # return nothing if the section was empty
            if not item_help:
                return ''

            # add the heading if the section was non-empty
            if self.heading is not SUPPRESS and self.heading is not None:
                current_indent = self.formatter._current_indent
                heading = '%*s%s:\n' % (current_indent, '', self.heading)
            else:
                heading = ''

            # join the section-initial newline, the heading and the help
            return join(['\n', heading, item_help, '\n'])

    def _add_item(self, func, args):
        self._current_section.items.append((func, args))

    # ========================
    # Message building methods
    # ========================
    def start_section(self, heading):
        self._indent()
        section = self._Section(self, self._current_section, heading)
        self._add_item(section.format_help, [])
        self._current_section = section

    def end_section(self):
        self._current_section = self._current_section.parent
        self._dedent()

    def add_text(self, text):
        if text is not SUPPRESS and text is not None:
            self._add_item(self._format_text, [text])

    def add_usage(self, usage, actions, groups, prefix=None):
        if usage is not SUPPRESS:
            args = usage, actions, groups, prefix
            self._add_item(self._format_usage, args)

    def add_argument(self, action):
        if action.help is not SUPPRESS:

            # find all invocations
            get_invocation = self._format_action_invocation
            invocations = [get_invocation(action)]
            for subaction in self._iter_indented_subactions(action):
                invocations.append(get_invocation(subaction))

            # update the maximum item length
            invocation_length = max([len(s) for s in invocations])
            action_length = invocation_length + self._current_indent
            self._action_max_length = max(self._action_max_length,
                                          action_length)

            # add the item to the list
            self._add_item(self._format_action, [action])

    def add_arguments(self, actions):
        for action in actions:
            self.add_argument(action)

    # =======================
    # Help-formatting methods
    # =======================
    def format_help(self):
        help = self._root_section.format_help()
        if help:
            help = self._long_break_matcher.sub('\n\n', help)
            help = help.strip('\n') + '\n'
        return help

    def _join_parts(self, part_strings):
        return ''.join([part
                        for part in part_strings
                        if part and part is not SUPPRESS])

    def _format_usage(self, usage, actions, groups, prefix):
        if prefix is None:
            prefix = _('usage: ')

        # if usage is specified, use that
        if usage is not None:
            usage = usage % dict(prog=self._prog)

        # if no optionals or positionals are available, usage is just prog
        elif usage is None and not actions:
            usage = '%(prog)s' % dict(prog=self._prog)

        # if optionals and positionals are available, calculate usage
        elif usage is None:
            prog = '%(prog)s' % dict(prog=self._prog)

            # split optionals from positionals
            optionals = []
            positionals = []
            for action in actions:
                if action.option_strings:
                    optionals.append(action)
                else:
                    positionals.append(action)

            # build full usage string
            format = self._format_actions_usage
            action_usage = format(optionals + positionals, groups)
            usage = ' '.join([s for s in [prog, action_usage] if s])

            # wrap the usage parts if it's too long
            text_width = self._width - self._current_indent
            if len(prefix) + len(usage) > text_width:

                # break usage into wrappable parts
                part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'
                opt_usage = format(optionals, groups)
                pos_usage = format(positionals, groups)
                opt_parts = _re.findall(part_regexp, opt_usage)
                pos_parts = _re.findall(part_regexp, pos_usage)
                assert ' '.join(opt_parts) == opt_usage
                assert ' '.join(pos_parts) == pos_usage

                # helper for wrapping lines
                def get_lines(parts, indent, prefix=None):
                    lines = []
                    line = []
                    if prefix is not None:
                        line_len = len(prefix) - 1
                    else:
                        line_len = len(indent) - 1
                    for part in parts:
                        if line_len + 1 + len(part) > text_width:
                            lines.append(indent + ' '.join(line))
                            line = []
                            line_len = len(indent) - 1
                        line.append(part)
                        line_len += len(part) + 1
                    if line:
                        lines.append(indent + ' '.join(line))
                    if prefix is not None:
                        lines[0] = lines[0][len(indent):]
                    return lines

                # if prog is short, follow it with optionals or positionals
                if len(prefix) + len(prog) <= 0.75 * text_width:
                    indent = ' ' * (len(prefix) + len(prog) + 1)
                    if opt_parts:
                        lines = get_lines([prog] + opt_parts, indent, prefix)
                        lines.extend(get_lines(pos_parts, indent))
                    elif pos_parts:
                        lines = get_lines([prog] + pos_parts, indent, prefix)
                    else:
                        lines = [prog]

                # if prog is long, put it on its own line
                else:
                    indent = ' ' * len(prefix)
                    parts = opt_parts + pos_parts
                    lines = get_lines(parts, indent)
                    if len(lines) > 1:
                        lines = []
                        lines.extend(get_lines(opt_parts, indent))
                        lines.extend(get_lines(pos_parts, indent))
                    lines = [prog] + lines

                # join lines into usage
                usage = '\n'.join(lines)

        # prefix with 'usage:'
        return '%s%s\n\n' % (prefix, usage)

    def _format_actions_usage(self, actions, groups):
        # find group indices and identify actions in groups
        group_actions = _set()
        inserts = {}
        for group in groups:
            try:
                start = actions.index(group._group_actions[0])
            except ValueError:
                continue
            else:
                end = start + len(group._group_actions)
                if actions[start:end] == group._group_actions:
                    for action in group._group_actions:
                        group_actions.add(action)
                    if not group.required:
                        inserts[start] = '['
                        inserts[end] = ']'
                    else:
                        inserts[start] = '('
                        inserts[end] = ')'
                    for i in range(start + 1, end):
                        inserts[i] = '|'

        # collect all actions format strings
        parts = []
        for i, action in enumerate(actions):

            # suppressed arguments are marked with None
            # remove | separators for suppressed arguments
            if action.help is SUPPRESS:
                parts.append(None)
                if inserts.get(i) == '|':
                    inserts.pop(i)
                elif inserts.get(i + 1) == '|':
                    inserts.pop(i + 1)

            # produce all arg strings
            elif not action.option_strings:
                part = self._format_args(action, action.dest)

                # if it's in a group, strip the outer []
                if action in group_actions:
                    if part[0] == '[' and part[-1] == ']':
                        part = part[1:-1]

                # add the action string to the list
                parts.append(part)

            # produce the first way to invoke the option in brackets
            else:
                option_string = action.option_strings[0]

                # if the Optional doesn't take a value, format is:
                #    -s or --long
                if action.nargs == 0:
                    part = '%s' % option_string

                # if the Optional takes a value, format is:
                #    -s ARGS or --long ARGS
                else:
                    default = action.dest.upper()
                    args_string = self._format_args(action, default)
                    part = '%s %s' % (option_string, args_string)

                # make it look optional if it's not required or in a group
                if not action.required and action not in group_actions:
                    part = '[%s]' % part

                # add the action string to the list
                parts.append(part)

        # insert things at the necessary indices
        for i in _sorted(inserts, reverse=True):
            parts[i:i] = [inserts[i]]

        # join all the action items with spaces
        text = ' '.join([item for item in parts if item is not None])

        # clean up separators for mutually exclusive groups
        open = r'[\[(]'
        close = r'[\])]'
        text = _re.sub(r'(%s) ' % open, r'\1', text)
        text = _re.sub(r' (%s)' % close, r'\1', text)
        text = _re.sub(r'%s *%s' % (open, close), r'', text)
        text = _re.sub(r'\(([^|]*)\)', r'\1', text)
        text = text.strip()

        # return the text
        return text

    def _format_text(self, text):
        if '%(prog)' in text:
            text = text % dict(prog=self._prog)
        text_width = self._width - self._current_indent
        indent = ' ' * self._current_indent
        return self._fill_text(text, text_width, indent) + '\n\n'

    def _format_action(self, action):
        # determine the required width and the entry label
        help_position = min(self._action_max_length + 2,
                            self._max_help_position)
        help_width = self._width - help_position
        action_width = help_position - self._current_indent - 2
        action_header = self._format_action_invocation(action)

        # ho nelp; start on same line and add a final newline
        if not action.help:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup

        # short action name; start on the same line and pad two spaces
        elif len(action_header) <= action_width:
            tup = self._current_indent, '', action_width, action_header
            action_header = '%*s%-*s  ' % tup
            indent_first = 0

        # long action name; start on the next line
        else:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup
            indent_first = help_position

        # collect the pieces of the action help
        parts = [action_header]

        # if there was help for the action, add lines of help text
        if action.help:
            help_text = self._expand_help(action)
            help_lines = self._split_lines(help_text, help_width)
            parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))
            for line in help_lines[1:]:
                parts.append('%*s%s\n' % (help_position, '', line))

        # or add a newline if the description doesn't end with one
        elif not action_header.endswith('\n'):
            parts.append('\n')

        # if there are any sub-actions, add their help as well
        for subaction in self._iter_indented_subactions(action):
            parts.append(self._format_action(subaction))

        # return a single string
        return self._join_parts(parts)

    def _format_action_invocation(self, action):
        if not action.option_strings:
            metavar, = self._metavar_formatter(action, action.dest)(1)
            return metavar

        else:
            parts = []

            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            else:
                default = action.dest.upper()
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    parts.append('%s %s' % (option_string, args_string))

            return ', '.join(parts)

    def _metavar_formatter(self, action, default_metavar):
        if action.metavar is not None:
            result = action.metavar
        elif action.choices is not None:
            choice_strs = [str(choice) for choice in action.choices]
            result = '{%s}' % ','.join(choice_strs)
        else:
            result = default_metavar

        def format(tuple_size):
            if isinstance(result, tuple):
                return result
            else:
                return (result, ) * tuple_size
        return format

    def _format_args(self, action, default_metavar):
        get_metavar = self._metavar_formatter(action, default_metavar)
        if action.nargs is None:
            result = '%s' % get_metavar(1)
        elif action.nargs == OPTIONAL:
            result = '[%s]' % get_metavar(1)
        elif action.nargs == ZERO_OR_MORE:
            result = '[%s [%s ...]]' % get_metavar(2)
        elif action.nargs == ONE_OR_MORE:
            result = '%s [%s ...]' % get_metavar(2)
        elif action.nargs == REMAINDER:
            result = '...'
        elif action.nargs == PARSER:
            result = '%s ...' % get_metavar(1)
        else:
            formats = ['%s' for _ in range(action.nargs)]
            result = ' '.join(formats) % get_metavar(action.nargs)
        return result

    def _expand_help(self, action):
        params = dict(vars(action), prog=self._prog)
        for name in list(params):
            if params[name] is SUPPRESS:
                del params[name]
        for name in list(params):
            if hasattr(params[name], '__name__'):
                params[name] = params[name].__name__
        if params.get('choices') is not None:
            choices_str = ', '.join([str(c) for c in params['choices']])
            params['choices'] = choices_str
        return self._get_help_string(action) % params

    def _iter_indented_subactions(self, action):
        try:
            get_subactions = action._get_subactions
        except AttributeError:
            pass
        else:
            self._indent()
            for subaction in get_subactions():
                yield subaction
            self._dedent()

    def _split_lines(self, text, width):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.wrap(text, width)

    def _fill_text(self, text, width, indent):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.fill(text, width, initial_indent=indent,
                                           subsequent_indent=indent)

    def _get_help_string(self, action):
        return action.help


class RawDescriptionHelpFormatter(HelpFormatter):
    """Help message formatter which retains any formatting in descriptions.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _fill_text(self, text, width, indent):
        return ''.join([indent + line for line in text.splitlines(True)])


class RawTextHelpFormatter(RawDescriptionHelpFormatter):
    """Help message formatter which retains formatting of all help text.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _split_lines(self, text, width):
        return text.splitlines()


class ArgumentDefaultsHelpFormatter(HelpFormatter):
    """Help message formatter which adds default values to argument help.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _get_help_string(self, action):
        help = action.help
        if '%(default)' not in action.help:
            if action.default is not SUPPRESS:
                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
                if action.option_strings or action.nargs in defaulting_nargs:
                    help += ' (default: %(default)s)'
        return help


# =====================
# Options and Arguments
# =====================

def _get_action_name(argument):
    if argument is None:
        return None
    elif argument.option_strings:
        return  '/'.join(argument.option_strings)
    elif argument.metavar not in (None, SUPPRESS):
        return argument.metavar
    elif argument.dest not in (None, SUPPRESS):
        return argument.dest
    else:
        return None


class ArgumentError(Exception):
    """An error from creating or using an argument (optional or positional).

    The string value of this exception is the message, augmented with
    information about the argument that caused it.
    """

    def __init__(self, argument, message):
        self.argument_name = _get_action_name(argument)
        self.message = message

    def __str__(self):
        if self.argument_name is None:
            format = '%(message)s'
        else:
            format = 'argument %(argument_name)s: %(message)s'
        return format % dict(message=self.message,
                             argument_name=self.argument_name)


class ArgumentTypeError(Exception):
    """An error from trying to convert a command line string to a type."""
    pass


# ==============
# Action classes
# ==============

class Action(_AttributeHolder):
    """Information about how to convert command line strings to Python objects.

    Action objects are used by an ArgumentParser to represent the information
    needed to parse a single argument from one or more strings from the
    command line. The keyword arguments to the Action constructor are also
    all attributes of Action instances.

    Keyword Arguments:

        - option_strings -- A list of command-line option strings which
            should be associated with this action.

        - dest -- The name of the attribute to hold the created object(s)

        - nargs -- The number of command-line arguments that should be
            consumed. By default, one argument will be consumed and a single
            value will be produced.  Other values include:
                - N (an integer) consumes N arguments (and produces a list)
                - '?' consumes zero or one arguments
                - '*' consumes zero or more arguments (and produces a list)
                - '+' consumes one or more arguments (and produces a list)
            Note that the difference between the default and nargs=1 is that
            with the default, a single value will be produced, while with
            nargs=1, a list containing a single value will be produced.

        - const -- The value to be produced if the option is specified and the
            option uses an action that takes no values.

        - default -- The value to be produced if the option is not specified.

        - type -- The type which the command-line arguments should be converted
            to, should be one of 'string', 'int', 'float', 'complex' or a
            callable object that accepts a single string argument. If None,
            'string' is assumed.

        - choices -- A container of values that should be allowed. If not None,
            after a command-line argument has been converted to the appropriate
            type, an exception will be raised if it is not a member of this
            collection.

        - required -- True if the action must always be specified at the
            command line. This is only meaningful for optional command-line
            arguments.

        - help -- The help string describing the argument.

        - metavar -- The name to be used for the option's argument with the
            help string. If None, the 'dest' value will be used as the name.
    """

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        self.option_strings = option_strings
        self.dest = dest
        self.nargs = nargs
        self.const = const
        self.default = default
        self.type = type
        self.choices = choices
        self.required = required
        self.help = help
        self.metavar = metavar

    def _get_kwargs(self):
        names = [
            'option_strings',
            'dest',
            'nargs',
            'const',
            'default',
            'type',
            'choices',
            'help',
            'metavar',
        ]
        return [(name, getattr(self, name)) for name in names]

    def __call__(self, parser, namespace, values, option_string=None):
        raise NotImplementedError(_('.__call__() not defined'))


class _StoreAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for store actions must be > 0; if you '
                             'have nothing to store, actions such as store '
                             'true or store const may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_StoreAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)


class _StoreConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_StoreConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, self.const)


class _StoreTrueAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=False,
                 required=False,
                 help=None):
        super(_StoreTrueAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=True,
            default=default,
            required=required,
            help=help)


class _StoreFalseAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=True,
                 required=False,
                 help=None):
        super(_StoreFalseAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=False,
            default=default,
            required=required,
            help=help)


class _AppendAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for append actions must be > 0; if arg '
                             'strings are not supplying the value to append, '
                             'the append const action may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_AppendAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(values)
        setattr(namespace, self.dest, items)


class _AppendConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_AppendConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(self.const)
        setattr(namespace, self.dest, items)


class _CountAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 default=None,
                 required=False,
                 help=None):
        super(_CountAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        new_count = _ensure_value(namespace, self.dest, 0) + 1
        setattr(namespace, self.dest, new_count)


class _HelpAction(Action):

    def __init__(self,
                 option_strings,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help=None):
        super(_HelpAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help()
        parser.exit()


class _VersionAction(Action):

    def __init__(self,
                 option_strings,
                 version=None,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help=None):
        super(_VersionAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)
        self.version = version

    def __call__(self, parser, namespace, values, option_string=None):
        version = self.version
        if version is None:
            version = parser.version
        formatter = parser._get_formatter()
        formatter.add_text(version)
        parser.exit(message=formatter.format_help())


class _SubParsersAction(Action):

    class _ChoicesPseudoAction(Action):

        def __init__(self, name, help):
            sup = super(_SubParsersAction._ChoicesPseudoAction, self)
            sup.__init__(option_strings=[], dest=name, help=help)

    def __init__(self,
                 option_strings,
                 prog,
                 parser_class,
                 dest=SUPPRESS,
                 help=None,
                 metavar=None):

        self._prog_prefix = prog
        self._parser_class = parser_class
        self._name_parser_map = {}
        self._choices_actions = []

        super(_SubParsersAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=PARSER,
            choices=self._name_parser_map,
            help=help,
            metavar=metavar)

    def add_parser(self, name, **kwargs):
        # set prog from the existing prefix
        if kwargs.get('prog') is None:
            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)

        # create a pseudo-action to hold the choice help
        if 'help' in kwargs:
            help = kwargs.pop('help')
            choice_action = self._ChoicesPseudoAction(name, help)
            self._choices_actions.append(choice_action)

        # create the parser and add it to the map
        parser = self._parser_class(**kwargs)
        self._name_parser_map[name] = parser
        return parser

    def _get_subactions(self):
        return self._choices_actions

    def __call__(self, parser, namespace, values, option_string=None):
        parser_name = values[0]
        arg_strings = values[1:]

        # set the parser name if requested
        if self.dest is not SUPPRESS:
            setattr(namespace, self.dest, parser_name)

        # select the parser
        try:
            parser = self._name_parser_map[parser_name]
        except KeyError:
            tup = parser_name, ', '.join(self._name_parser_map)
            msg = _('unknown parser %r (choices: %s)' % tup)
            raise ArgumentError(self, msg)

        # parse all the remaining options into the namespace
        parser.parse_args(arg_strings, namespace)


# ==============
# Type classes
# ==============

class FileType(object):
    """Factory for creating file object types

    Instances of FileType are typically passed as type= arguments to the
    ArgumentParser add_argument() method.

    Keyword Arguments:
        - mode -- A string indicating how the file is to be opened. Accepts the
            same values as the builtin open() function.
        - bufsize -- The file's desired buffer size. Accepts the same values as
            the builtin open() function.
    """

    def __init__(self, mode='r', bufsize=None):
        self._mode = mode
        self._bufsize = bufsize

    def __call__(self, string):
        # the special argument "-" means sys.std{in,out}
        if string == '-':
            if 'r' in self._mode:
                return _sys.stdin
            elif 'w' in self._mode:
                return _sys.stdout
            else:
                msg = _('argument "-" with mode %r' % self._mode)
                raise ValueError(msg)

        # all other arguments are used as file names
        if self._bufsize:
            return open(string, self._mode, self._bufsize)
        else:
            return open(string, self._mode)

    def __repr__(self):
        args = [self._mode, self._bufsize]
        args_str = ', '.join([repr(arg) for arg in args if arg is not None])
        return '%s(%s)' % (type(self).__name__, args_str)

# ===========================
# Optional and Positional Parsing
# ===========================

class Namespace(_AttributeHolder):
    """Simple object for storing attributes.

    Implements equality by attribute names and values, and provides a simple
    string representation.
    """

    def __init__(self, **kwargs):
        for name in kwargs:
            setattr(self, name, kwargs[name])

    def __eq__(self, other):
        return vars(self) == vars(other)

    def __ne__(self, other):
        return not (self == other)

    def __contains__(self, key):
        return key in self.__dict__


class _ActionsContainer(object):

    def __init__(self,
                 description,
                 prefix_chars,
                 argument_default,
                 conflict_handler):
        super(_ActionsContainer, self).__init__()

        self.description = description
        self.argument_default = argument_default
        self.prefix_chars = prefix_chars
        self.conflict_handler = conflict_handler

        # set up registries
        self._registries = {}

        # register actions
        self.register('action', None, _StoreAction)
        self.register('action', 'store', _StoreAction)
        self.register('action', 'store_const', _StoreConstAction)
        self.register('action', 'store_true', _StoreTrueAction)
        self.register('action', 'store_false', _StoreFalseAction)
        self.register('action', 'append', _AppendAction)
        self.register('action', 'append_const', _AppendConstAction)
        self.register('action', 'count', _CountAction)
        self.register('action', 'help', _HelpAction)
        self.register('action', 'version', _VersionAction)
        self.register('action', 'parsers', _SubParsersAction)

        # raise an exception if the conflict handler is invalid
        self._get_handler()

        # action storage
        self._actions = []
        self._option_string_actions = {}

        # groups
        self._action_groups = []
        self._mutually_exclusive_groups = []

        # defaults storage
        self._defaults = {}

        # determines whether an "option" looks like a negative number
        self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')

        # whether or not there are any optionals that look like negative
        # numbers -- uses a list so it can be shared and edited
        self._has_negative_number_optionals = []

    # ====================
    # Registration methods
    # ====================
    def register(self, registry_name, value, object):
        registry = self._registries.setdefault(registry_name, {})
        registry[value] = object

    def _registry_get(self, registry_name, value, default=None):
        return self._registries[registry_name].get(value, default)

    # ==================================
    # Namespace default accessor methods
    # ==================================
    def set_defaults(self, **kwargs):
        self._defaults.update(kwargs)

        # if these defaults match any existing arguments, replace
        # the previous default on the object with the new one
        for action in self._actions:
            if action.dest in kwargs:
                action.default = kwargs[action.dest]

    def get_default(self, dest):
        for action in self._actions:
            if action.dest == dest and action.default is not None:
                return action.default
        return self._defaults.get(dest, None)


    # =======================
    # Adding argument actions
    # =======================
    def add_argument(self, *args, **kwargs):
        """
        add_argument(dest, ..., name=value, ...)
        add_argument(option_string, option_string, ..., name=value, ...)
        """

        # if no positional args are supplied or only one is supplied and
        # it doesn't look like an option string, parse a positional
        # argument
        chars = self.prefix_chars
        if not args or len(args) == 1 and args[0][0] not in chars:
            if args and 'dest' in kwargs:
                raise ValueError('dest supplied twice for positional argument')
            kwargs = self._get_positional_kwargs(*args, **kwargs)

        # otherwise, we're adding an optional argument
        else:
            kwargs = self._get_optional_kwargs(*args, **kwargs)

        # if no default was supplied, use the parser-level default
        if 'default' not in kwargs:
            dest = kwargs['dest']
            if dest in self._defaults:
                kwargs['default'] = self._defaults[dest]
            elif self.argument_default is not None:
                kwargs['default'] = self.argument_default

        # create the action object, and add it to the parser
        action_class = self._pop_action_class(kwargs)
        if not _callable(action_class):
            raise ValueError('unknown action "%s"' % action_class)
        action = action_class(**kwargs)

        # raise an error if the action type is not callable
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            raise ValueError('%r is not callable' % type_func)

        return self._add_action(action)

    def add_argument_group(self, *args, **kwargs):
        group = _ArgumentGroup(self, *args, **kwargs)
        self._action_groups.append(group)
        return group

    def add_mutually_exclusive_group(self, **kwargs):
        group = _MutuallyExclusiveGroup(self, **kwargs)
        self._mutually_exclusive_groups.append(group)
        return group

    def _add_action(self, action):
        # resolve any conflicts
        self._check_conflict(action)

        # add to actions list
        self._actions.append(action)
        action.container = self

        # index the action by any option strings it has
        for option_string in action.option_strings:
            self._option_string_actions[option_string] = action

        # set the flag if any option strings look like negative numbers
        for option_string in action.option_strings:
            if self._negative_number_matcher.match(option_string):
                if not self._has_negative_number_optionals:
                    self._has_negative_number_optionals.append(True)

        # return the created action
        return action

    def _remove_action(self, action):
        self._actions.remove(action)

    def _add_container_actions(self, container):
        # collect groups by titles
        title_group_map = {}
        for group in self._action_groups:
            if group.title in title_group_map:
                msg = _('cannot merge actions - two groups are named %r')
                raise ValueError(msg % (group.title))
            title_group_map[group.title] = group

        # map each action to its group
        group_map = {}
        for group in container._action_groups:

            # if a group with the title exists, use that, otherwise
            # create a new group matching the container's group
            if group.title not in title_group_map:
                title_group_map[group.title] = self.add_argument_group(
                    title=group.title,
                    description=group.description,
                    conflict_handler=group.conflict_handler)

            # map the actions to their new group
            for action in group._group_actions:
                group_map[action] = title_group_map[group.title]

        # add container's mutually exclusive groups
        # NOTE: if add_mutually_exclusive_group ever gains title= and
        # description= then this code will need to be expanded as above
        for group in container._mutually_exclusive_groups:
            mutex_group = self.add_mutually_exclusive_group(
                required=group.required)

            # map the actions to their new mutex group
            for action in group._group_actions:
                group_map[action] = mutex_group

        # add all actions to this container or their group
        for action in container._actions:
            group_map.get(action, self)._add_action(action)

    def _get_positional_kwargs(self, dest, **kwargs):
        # make sure required is not specified
        if 'required' in kwargs:
            msg = _("'required' is an invalid argument for positionals")
            raise TypeError(msg)

        # mark positional arguments as required if at least one is
        # always required
        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
            kwargs['required'] = True
        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
            kwargs['required'] = True

        # return the keyword arguments with no option strings
        return dict(kwargs, dest=dest, option_strings=[])

    def _get_optional_kwargs(self, *args, **kwargs):
        # determine short and long option strings
        option_strings = []
        long_option_strings = []
        for option_string in args:
            # error on strings that don't start with an appropriate prefix
            if not option_string[0] in self.prefix_chars:
                msg = _('invalid option string %r: '
                        'must start with a character %r')
                tup = option_string, self.prefix_chars
                raise ValueError(msg % tup)

            # strings starting with two prefix characters are long options
            option_strings.append(option_string)
            if option_string[0] in self.prefix_chars:
                if len(option_string) > 1:
                    if option_string[1] in self.prefix_chars:
                        long_option_strings.append(option_string)

        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
        dest = kwargs.pop('dest', None)
        if dest is None:
            if long_option_strings:
                dest_option_string = long_option_strings[0]
            else:
                dest_option_string = option_strings[0]
            dest = dest_option_string.lstrip(self.prefix_chars)
            if not dest:
                msg = _('dest= is required for options like %r')
                raise ValueError(msg % option_string)
            dest = dest.replace('-', '_')

        # return the updated keyword arguments
        return dict(kwargs, dest=dest, option_strings=option_strings)

    def _pop_action_class(self, kwargs, default=None):
        action = kwargs.pop('action', default)
        return self._registry_get('action', action, action)

    def _get_handler(self):
        # determine function from conflict handler string
        handler_func_name = '_handle_conflict_%s' % self.conflict_handler
        try:
            return getattr(self, handler_func_name)
        except AttributeError:
            msg = _('invalid conflict_resolution value: %r')
            raise ValueError(msg % self.conflict_handler)

    def _check_conflict(self, action):

        # find all options that conflict with this option
        confl_optionals = []
        for option_string in action.option_strings:
            if option_string in self._option_string_actions:
                confl_optional = self._option_string_actions[option_string]
                confl_optionals.append((option_string, confl_optional))

        # resolve any conflicts
        if confl_optionals:
            conflict_handler = self._get_handler()
            conflict_handler(action, confl_optionals)

    def _handle_conflict_error(self, action, conflicting_actions):
        message = _('conflicting option string(s): %s')
        conflict_string = ', '.join([option_string
                                     for option_string, action
                                     in conflicting_actions])
        raise ArgumentError(action, message % conflict_string)

    def _handle_conflict_resolve(self, action, conflicting_actions):

        # remove all conflicting options
        for option_string, action in conflicting_actions:

            # remove the conflicting option
            action.option_strings.remove(option_string)
            self._option_string_actions.pop(option_string, None)

            # if the option now has no option string, remove it from the
            # container holding it
            if not action.option_strings:
                action.container._remove_action(action)


class _ArgumentGroup(_ActionsContainer):

    def __init__(self, container, title=None, description=None, **kwargs):
        # add any missing keyword arguments by checking the container
        update = kwargs.setdefault
        update('conflict_handler', container.conflict_handler)
        update('prefix_chars', container.prefix_chars)
        update('argument_default', container.argument_default)
        super_init = super(_ArgumentGroup, self).__init__
        super_init(description=description, **kwargs)

        # group attributes
        self.title = title
        self._group_actions = []

        # share most attributes with the container
        self._registries = container._registries
        self._actions = container._actions
        self._option_string_actions = container._option_string_actions
        self._defaults = container._defaults
        self._has_negative_number_optionals = \
            container._has_negative_number_optionals

    def _add_action(self, action):
        action = super(_ArgumentGroup, self)._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        super(_ArgumentGroup, self)._remove_action(action)
        self._group_actions.remove(action)


class _MutuallyExclusiveGroup(_ArgumentGroup):

    def __init__(self, container, required=False):
        super(_MutuallyExclusiveGroup, self).__init__(container)
        self.required = required
        self._container = container

    def _add_action(self, action):
        if action.required:
            msg = _('mutually exclusive arguments must be optional')
            raise ValueError(msg)
        action = self._container._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        self._container._remove_action(action)
        self._group_actions.remove(action)


class ArgumentParser(_AttributeHolder, _ActionsContainer):
    """Object for parsing command line strings into Python objects.

    Keyword Arguments:
        - prog -- The name of the program (default: sys.argv[0])
        - usage -- A usage message (default: auto-generated from arguments)
        - description -- A description of what the program does
        - epilog -- Text following the argument descriptions
        - parents -- Parsers whose arguments should be copied into this one
        - formatter_class -- HelpFormatter class for printing help messages
        - prefix_chars -- Characters that prefix optional arguments
        - fromfile_prefix_chars -- Characters that prefix files containing
            additional arguments
        - argument_default -- The default value for all arguments
        - conflict_handler -- String indicating how to handle conflicts
        - add_help -- Add a -h/-help option
    """

    def __init__(self,
                 prog=None,
                 usage=None,
                 description=None,
                 epilog=None,
                 version=None,
                 parents=[],
                 formatter_class=HelpFormatter,
                 prefix_chars='-',
                 fromfile_prefix_chars=None,
                 argument_default=None,
                 conflict_handler='error',
                 add_help=True):

        if version is not None:
            import warnings
            warnings.warn(
                """The "version" argument to ArgumentParser is deprecated. """
                """Please use """
                """"add_argument(..., action='version', version="N", ...)" """
                """instead""", DeprecationWarning)

        superinit = super(ArgumentParser, self).__init__
        superinit(description=description,
                  prefix_chars=prefix_chars,
                  argument_default=argument_default,
                  conflict_handler=conflict_handler)

        # default setting for prog
        if prog is None:
            prog = _os.path.basename(_sys.argv[0])

        self.prog = prog
        self.usage = usage
        self.epilog = epilog
        self.version = version
        self.formatter_class = formatter_class
        self.fromfile_prefix_chars = fromfile_prefix_chars
        self.add_help = add_help

        add_group = self.add_argument_group
        self._positionals = add_group(_('positional arguments'))
        self._optionals = add_group(_('optional arguments'))
        self._subparsers = None

        # register types
        def identity(string):
            return string
        self.register('type', None, identity)

        # add help and version arguments if necessary
        # (using explicit default to override global argument_default)
        if self.add_help:
            self.add_argument(
                '-h', '--help', action='help', default=SUPPRESS,
                help=_('show this help message and exit'))
        if self.version:
            self.add_argument(
                '-v', '--version', action='version', default=SUPPRESS,
                version=self.version,
                help=_("show program's version number and exit"))

        # add parent arguments and defaults
        for parent in parents:
            self._add_container_actions(parent)
            try:
                defaults = parent._defaults
            except AttributeError:
                pass
            else:
                self._defaults.update(defaults)

    # =======================
    # Pretty __repr__ methods
    # =======================
    def _get_kwargs(self):
        names = [
            'prog',
            'usage',
            'description',
            'version',
            'formatter_class',
            'conflict_handler',
            'add_help',
        ]
        return [(name, getattr(self, name)) for name in names]

    # ==================================
    # Optional/Positional adding methods
    # ==================================
    def add_subparsers(self, **kwargs):
        if self._subparsers is not None:
            self.error(_('cannot have multiple subparser arguments'))

        # add the parser class to the arguments if it's not present
        kwargs.setdefault('parser_class', type(self))

        if 'title' in kwargs or 'description' in kwargs:
            title = _(kwargs.pop('title', 'subcommands'))
            description = _(kwargs.pop('description', None))
            self._subparsers = self.add_argument_group(title, description)
        else:
            self._subparsers = self._positionals

        # prog defaults to the usage message of this parser, skipping
        # optional arguments and with no "usage:" prefix
        if kwargs.get('prog') is None:
            formatter = self._get_formatter()
            positionals = self._get_positional_actions()
            groups = self._mutually_exclusive_groups
            formatter.add_usage(self.usage, positionals, groups, '')
            kwargs['prog'] = formatter.format_help().strip()

        # create the parsers action and add it to the positionals list
        parsers_class = self._pop_action_class(kwargs, 'parsers')
        action = parsers_class(option_strings=[], **kwargs)
        self._subparsers._add_action(action)

        # return the created parsers action
        return action

    def _add_action(self, action):
        if action.option_strings:
            self._optionals._add_action(action)
        else:
            self._positionals._add_action(action)
        return action

    def _get_optional_actions(self):
        return [action
                for action in self._actions
                if action.option_strings]

    def _get_positional_actions(self):
        return [action
                for action in self._actions
                if not action.option_strings]

    # =====================================
    # Command line argument parsing methods
    # =====================================
    def parse_args(self, args=None, namespace=None):
        args, argv = self.parse_known_args(args, namespace)
        if argv:
            msg = _('unrecognized arguments: %s')
            self.error(msg % ' '.join(argv))
        return args

    def parse_known_args(self, args=None, namespace=None):
        # args default to the system args
        if args is None:
            args = _sys.argv[1:]

        # default Namespace built from parser defaults
        if namespace is None:
            namespace = Namespace()

        # add any action defaults that aren't present
        for action in self._actions:
            if action.dest is not SUPPRESS:
                if not hasattr(namespace, action.dest):
                    if action.default is not SUPPRESS:
                        default = action.default
                        if isinstance(action.default, _basestring):
                            default = self._get_value(action, default)
                        setattr(namespace, action.dest, default)

        # add any parser defaults that aren't present
        for dest in self._defaults:
            if not hasattr(namespace, dest):
                setattr(namespace, dest, self._defaults[dest])

        # parse the arguments and exit if there are any errors
        try:
            return self._parse_known_args(args, namespace)
        except ArgumentError:
            err = _sys.exc_info()[1]
            self.error(str(err))

    def _parse_known_args(self, arg_strings, namespace):
        # replace arg strings that are file references
        if self.fromfile_prefix_chars is not None:
            arg_strings = self._read_args_from_files(arg_strings)

        # map all mutually exclusive arguments to the other arguments
        # they can't occur with
        action_conflicts = {}
        for mutex_group in self._mutually_exclusive_groups:
            group_actions = mutex_group._group_actions
            for i, mutex_action in enumerate(mutex_group._group_actions):
                conflicts = action_conflicts.setdefault(mutex_action, [])
                conflicts.extend(group_actions[:i])
                conflicts.extend(group_actions[i + 1:])

        # find all option indices, and determine the arg_string_pattern
        # which has an 'O' if there is an option at an index,
        # an 'A' if there is an argument, or a '-' if there is a '--'
        option_string_indices = {}
        arg_string_pattern_parts = []
        arg_strings_iter = iter(arg_strings)
        for i, arg_string in enumerate(arg_strings_iter):

            # all args after -- are non-options
            if arg_string == '--':
                arg_string_pattern_parts.append('-')
                for arg_string in arg_strings_iter:
                    arg_string_pattern_parts.append('A')

            # otherwise, add the arg to the arg strings
            # and note the index if it was an option
            else:
                option_tuple = self._parse_optional(arg_string)
                if option_tuple is None:
                    pattern = 'A'
                else:
                    option_string_indices[i] = option_tuple
                    pattern = 'O'
                arg_string_pattern_parts.append(pattern)

        # join the pieces together to form the pattern
        arg_strings_pattern = ''.join(arg_string_pattern_parts)

        # converts arg strings to the appropriate and then takes the action
        seen_actions = _set()
        seen_non_default_actions = _set()

        def take_action(action, argument_strings, option_string=None):
            seen_actions.add(action)
            argument_values = self._get_values(action, argument_strings)

            # error if this argument is not allowed with other previously
            # seen arguments, assuming that actions that use the default
            # value don't really count as "present"
            if argument_values is not action.default:
                seen_non_default_actions.add(action)
                for conflict_action in action_conflicts.get(action, []):
                    if conflict_action in seen_non_default_actions:
                        msg = _('not allowed with argument %s')
                        action_name = _get_action_name(conflict_action)
                        raise ArgumentError(action, msg % action_name)

            # take the action if we didn't receive a SUPPRESS value
            # (e.g. from a default)
            if argument_values is not SUPPRESS:
                action(self, namespace, argument_values, option_string)

        # function to convert arg_strings into an optional action
        def consume_optional(start_index):

            # get the optional identified at this index
            option_tuple = option_string_indices[start_index]
            action, option_string, explicit_arg = option_tuple

            # identify additional optionals in the same arg string
            # (e.g. -xyz is the same as -x -y -z if no args are required)
            match_argument = self._match_argument
            action_tuples = []
            while True:

                # if we found no optional action, skip it
                if action is None:
                    extras.append(arg_strings[start_index])
                    return start_index + 1

                # if there is an explicit argument, try to match the
                # optional's string arguments to only this
                if explicit_arg is not None:
                    arg_count = match_argument(action, 'A')

                    # if the action is a single-dash option and takes no
                    # arguments, try to parse more single-dash options out
                    # of the tail of the option string
                    chars = self.prefix_chars
                    if arg_count == 0 and option_string[1] not in chars:
                        action_tuples.append((action, [], option_string))
                        for char in self.prefix_chars:
                            option_string = char + explicit_arg[0]
                            explicit_arg = explicit_arg[1:] or None
                            optionals_map = self._option_string_actions
                            if option_string in optionals_map:
                                action = optionals_map[option_string]
                                break
                        else:
                            msg = _('ignored explicit argument %r')
                            raise ArgumentError(action, msg % explicit_arg)

                    # if the action expect exactly one argument, we've
                    # successfully matched the option; exit the loop
                    elif arg_count == 1:
                        stop = start_index + 1
                        args = [explicit_arg]
                        action_tuples.append((action, args, option_string))
                        break

                    # error if a double-dash option did not use the
                    # explicit argument
                    else:
                        msg = _('ignored explicit argument %r')
                        raise ArgumentError(action, msg % explicit_arg)

                # if there is no explicit argument, try to match the
                # optional's string arguments with the following strings
                # if successful, exit the loop
                else:
                    start = start_index + 1
                    selected_patterns = arg_strings_pattern[start:]
                    arg_count = match_argument(action, selected_patterns)
                    stop = start + arg_count
                    args = arg_strings[start:stop]
                    action_tuples.append((action, args, option_string))
                    break

            # add the Optional to the list and return the index at which
            # the Optional's string args stopped
            assert action_tuples
            for action, args, option_string in action_tuples:
                take_action(action, args, option_string)
            return stop

        # the list of Positionals left to be parsed; this is modified
        # by consume_positionals()
        positionals = self._get_positional_actions()

        # function to convert arg_strings into positional actions
        def consume_positionals(start_index):
            # match as many Positionals as possible
            match_partial = self._match_arguments_partial
            selected_pattern = arg_strings_pattern[start_index:]
            arg_counts = match_partial(positionals, selected_pattern)

            # slice off the appropriate arg strings for each Positional
            # and add the Positional and its args to the list
            for action, arg_count in zip(positionals, arg_counts):
                args = arg_strings[start_index: start_index + arg_count]
                start_index += arg_count
                take_action(action, args)

            # slice off the Positionals that we just parsed and return the
            # index at which the Positionals' string args stopped
            positionals[:] = positionals[len(arg_counts):]
            return start_index

        # consume Positionals and Optionals alternately, until we have
        # passed the last option string
        extras = []
        start_index = 0
        if option_string_indices:
            max_option_string_index = max(option_string_indices)
        else:
            max_option_string_index = -1
        while start_index <= max_option_string_index:

            # consume any Positionals preceding the next option
            next_option_string_index = min([
                index
                for index in option_string_indices
                if index >= start_index])
            if start_index != next_option_string_index:
                positionals_end_index = consume_positionals(start_index)

                # only try to parse the next optional if we didn't consume
                # the option string during the positionals parsing
                if positionals_end_index > start_index:
                    start_index = positionals_end_index
                    continue
                else:
                    start_index = positionals_end_index

            # if we consumed all the positionals we could and we're not
            # at the index of an option string, there were extra arguments
            if start_index not in option_string_indices:
                strings = arg_strings[start_index:next_option_string_index]
                extras.extend(strings)
                start_index = next_option_string_index

            # consume the next optional and any arguments for it
            start_index = consume_optional(start_index)

        # consume any positionals following the last Optional
        stop_index = consume_positionals(start_index)

        # if we didn't consume all the argument strings, there were extras
        extras.extend(arg_strings[stop_index:])

        # if we didn't use all the Positional objects, there were too few
        # arg strings supplied.
        if positionals:
            self.error(_('too few arguments'))

        # make sure all required actions were present
        for action in self._actions:
            if action.required:
                if action not in seen_actions:
                    name = _get_action_name(action)
                    self.error(_('argument %s is required') % name)

        # make sure all required groups had one option present
        for group in self._mutually_exclusive_groups:
            if group.required:
                for action in group._group_actions:
                    if action in seen_non_default_actions:
                        break

                # if no actions were used, report the error
                else:
                    names = [_get_action_name(action)
                             for action in group._group_actions
                             if action.help is not SUPPRESS]
                    msg = _('one of the arguments %s is required')
                    self.error(msg % ' '.join(names))

        # return the updated namespace and the extra arguments
        return namespace, extras

    def _read_args_from_files(self, arg_strings):
        # expand arguments referencing files
        new_arg_strings = []
        for arg_string in arg_strings:

            # for regular arguments, just add them back into the list
            if arg_string[0] not in self.fromfile_prefix_chars:
                new_arg_strings.append(arg_string)

            # replace arguments referencing files with the file content
            else:
                try:
                    args_file = open(arg_string[1:])
                    try:
                        arg_strings = []
                        for arg_line in args_file.read().splitlines():
                            for arg in self.convert_arg_line_to_args(arg_line):
                                arg_strings.append(arg)
                        arg_strings = self._read_args_from_files(arg_strings)
                        new_arg_strings.extend(arg_strings)
                    finally:
                        args_file.close()
                except IOError:
                    err = _sys.exc_info()[1]
                    self.error(str(err))

        # return the modified argument list
        return new_arg_strings

    def convert_arg_line_to_args(self, arg_line):
        return [arg_line]

    def _match_argument(self, action, arg_strings_pattern):
        # match the pattern for this action to the arg strings
        nargs_pattern = self._get_nargs_pattern(action)
        match = _re.match(nargs_pattern, arg_strings_pattern)

        # raise an exception if we weren't able to find a match
        if match is None:
            nargs_errors = {
                None: _('expected one argument'),
                OPTIONAL: _('expected at most one argument'),
                ONE_OR_MORE: _('expected at least one argument'),
            }
            default = _('expected %s argument(s)') % action.nargs
            msg = nargs_errors.get(action.nargs, default)
            raise ArgumentError(action, msg)

        # return the number of arguments matched
        return len(match.group(1))

    def _match_arguments_partial(self, actions, arg_strings_pattern):
        # progressively shorten the actions list by slicing off the
        # final actions until we find a match
        result = []
        for i in range(len(actions), 0, -1):
            actions_slice = actions[:i]
            pattern = ''.join([self._get_nargs_pattern(action)
                               for action in actions_slice])
            match = _re.match(pattern, arg_strings_pattern)
            if match is not None:
                result.extend([len(string) for string in match.groups()])
                break

        # return the list of arg string counts
        return result

    def _parse_optional(self, arg_string):
        # if it's an empty string, it was meant to be a positional
        if not arg_string:
            return None

        # if it doesn't start with a prefix, it was meant to be positional
        if not arg_string[0] in self.prefix_chars:
            return None

        # if the option string is present in the parser, return the action
        if arg_string in self._option_string_actions:
            action = self._option_string_actions[arg_string]
            return action, arg_string, None

        # if it's just a single character, it was meant to be positional
        if len(arg_string) == 1:
            return None

        # if the option string before the "=" is present, return the action
        if '=' in arg_string:
            option_string, explicit_arg = arg_string.split('=', 1)
            if option_string in self._option_string_actions:
                action = self._option_string_actions[option_string]
                return action, option_string, explicit_arg

        # search through all possible prefixes of the option string
        # and all actions in the parser for possible interpretations
        option_tuples = self._get_option_tuples(arg_string)

        # if multiple actions match, the option string was ambiguous
        if len(option_tuples) > 1:
            options = ', '.join([option_string
                for action, option_string, explicit_arg in option_tuples])
            tup = arg_string, options
            self.error(_('ambiguous option: %s could match %s') % tup)

        # if exactly one action matched, this segmentation is good,
        # so return the parsed action
        elif len(option_tuples) == 1:
            option_tuple, = option_tuples
            return option_tuple

        # if it was not found as an option, but it looks like a negative
        # number, it was meant to be positional
        # unless there are negative-number-like options
        if self._negative_number_matcher.match(arg_string):
            if not self._has_negative_number_optionals:
                return None

        # if it contains a space, it was meant to be a positional
        if ' ' in arg_string:
            return None

        # it was meant to be an optional but there is no such option
        # in this parser (though it might be a valid option in a subparser)
        return None, arg_string, None

    def _get_option_tuples(self, option_string):
        result = []

        # option strings starting with two prefix characters are only
        # split at the '='
        chars = self.prefix_chars
        if option_string[0] in chars and option_string[1] in chars:
            if '=' in option_string:
                option_prefix, explicit_arg = option_string.split('=', 1)
            else:
                option_prefix = option_string
                explicit_arg = None
            for option_string in self._option_string_actions:
                if option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # single character options can be concatenated with their arguments
        # but multiple character options always have to have their argument
        # separate
        elif option_string[0] in chars and option_string[1] not in chars:
            option_prefix = option_string
            explicit_arg = None
            short_option_prefix = option_string[:2]
            short_explicit_arg = option_string[2:]

            for option_string in self._option_string_actions:
                if option_string == short_option_prefix:
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, short_explicit_arg
                    result.append(tup)
                elif option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # shouldn't ever get here
        else:
            self.error(_('unexpected option string: %s') % option_string)

        # return the collected option tuples
        return result

    def _get_nargs_pattern(self, action):
        # in all examples below, we have to allow for '--' args
        # which are represented as '-' in the pattern
        nargs = action.nargs

        # the default (None) is assumed to be a single argument
        if nargs is None:
            nargs_pattern = '(-*A-*)'

        # allow zero or one arguments
        elif nargs == OPTIONAL:
            nargs_pattern = '(-*A?-*)'

        # allow zero or more arguments
        elif nargs == ZERO_OR_MORE:
            nargs_pattern = '(-*[A-]*)'

        # allow one or more arguments
        elif nargs == ONE_OR_MORE:
            nargs_pattern = '(-*A[A-]*)'

        # allow any number of options or arguments
        elif nargs == REMAINDER:
            nargs_pattern = '([-AO]*)'

        # allow one argument followed by any number of options or arguments
        elif nargs == PARSER:
            nargs_pattern = '(-*A[-AO]*)'

        # all others should be integers
        else:
            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)

        # if this is an optional action, -- is not allowed
        if action.option_strings:
            nargs_pattern = nargs_pattern.replace('-*', '')
            nargs_pattern = nargs_pattern.replace('-', '')

        # return the pattern
        return nargs_pattern

    # ========================
    # Value conversion methods
    # ========================
    def _get_values(self, action, arg_strings):
        # for everything but PARSER args, strip out '--'
        if action.nargs not in [PARSER, REMAINDER]:
            arg_strings = [s for s in arg_strings if s != '--']

        # optional argument produces a default when not present
        if not arg_strings and action.nargs == OPTIONAL:
            if action.option_strings:
                value = action.const
            else:
                value = action.default
            if isinstance(value, _basestring):
                value = self._get_value(action, value)
                self._check_value(action, value)

        # when nargs='*' on a positional, if there were no command-line
        # args, use the default if it is anything other than None
        elif (not arg_strings and action.nargs == ZERO_OR_MORE and
              not action.option_strings):
            if action.default is not None:
                value = action.default
            else:
                value = arg_strings
            self._check_value(action, value)

        # single argument or optional argument produces a single value
        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
            arg_string, = arg_strings
            value = self._get_value(action, arg_string)
            self._check_value(action, value)

        # REMAINDER arguments convert all values, checking none
        elif action.nargs == REMAINDER:
            value = [self._get_value(action, v) for v in arg_strings]

        # PARSER arguments convert all values, but check only the first
        elif action.nargs == PARSER:
            value = [self._get_value(action, v) for v in arg_strings]
            self._check_value(action, value[0])

        # all other types of nargs produce a list
        else:
            value = [self._get_value(action, v) for v in arg_strings]
            for v in value:
                self._check_value(action, v)

        # return the converted value
        return value

    def _get_value(self, action, arg_string):
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            msg = _('%r is not callable')
            raise ArgumentError(action, msg % type_func)

        # convert the value to the appropriate type
        try:
            result = type_func(arg_string)

        # ArgumentTypeErrors indicate errors
        except ArgumentTypeError:
            name = getattr(action.type, '__name__', repr(action.type))
            msg = str(_sys.exc_info()[1])
            raise ArgumentError(action, msg)

        # TypeErrors or ValueErrors also indicate errors
        except (TypeError, ValueError):
            name = getattr(action.type, '__name__', repr(action.type))
            msg = _('invalid %s value: %r')
            raise ArgumentError(action, msg % (name, arg_string))

        # return the converted value
        return result

    def _check_value(self, action, value):
        # converted value must be one of the choices (if specified)
        if action.choices is not None and value not in action.choices:
            tup = value, ', '.join(map(repr, action.choices))
            msg = _('invalid choice: %r (choose from %s)') % tup
            raise ArgumentError(action, msg)

    # =======================
    # Help-formatting methods
    # =======================
    def format_usage(self):
        formatter = self._get_formatter()
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)
        return formatter.format_help()

    def format_help(self):
        formatter = self._get_formatter()

        # usage
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)

        # description
        formatter.add_text(self.description)

        # positionals, optionals and user-defined groups
        for action_group in self._action_groups:
            formatter.start_section(action_group.title)
            formatter.add_text(action_group.description)
            formatter.add_arguments(action_group._group_actions)
            formatter.end_section()

        # epilog
        formatter.add_text(self.epilog)

        # determine help from format above
        return formatter.format_help()

    def format_version(self):
        import warnings
        warnings.warn(
            'The format_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        formatter = self._get_formatter()
        formatter.add_text(self.version)
        return formatter.format_help()

    def _get_formatter(self):
        return self.formatter_class(prog=self.prog)

    # =====================
    # Help-printing methods
    # =====================
    def print_usage(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_usage(), file)

    def print_help(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_help(), file)

    def print_version(self, file=None):
        import warnings
        warnings.warn(
            'The print_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        self._print_message(self.format_version(), file)

    def _print_message(self, message, file=None):
        if message:
            if file is None:
                file = _sys.stderr
            file.write(message)

    # ===============
    # Exiting methods
    # ===============
    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
        _sys.exit(status)

    def error(self, message):
        """error(message: string)

        Prints a usage message incorporating the message to stderr and
        exits.

        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        """
        self.print_usage(_sys.stderr)
        self.exit(2, _('%s: error: %s\n') % (self.prog, message))

########NEW FILE########
__FILENAME__ = cache
"""Cache object

The Cache object is used to manage a set of cache files and their
associated backend. The backends can be rotated on the fly by
specifying an alternate type when used.

Advanced users can add new backends in b3.lib.beaker.backends

"""

import warnings

import b3.lib.beaker.container as container
import b3.lib.beaker.util as util
from b3.lib.beaker.exceptions import BeakerException, InvalidCacheBackendError

import b3.lib.beaker.ext.memcached as memcached
import b3.lib.beaker.ext.database as database
import b3.lib.beaker.ext.sqla as sqla
import b3.lib.beaker.ext.google as google

# Initialize the basic available backends
clsmap = {
          'memory':container.MemoryNamespaceManager,
          'dbm':container.DBMNamespaceManager,
          'file':container.FileNamespaceManager,
          'ext:memcached':memcached.MemcachedNamespaceManager,
          'ext:database':database.DatabaseNamespaceManager,
          'ext:sqla': sqla.SqlaNamespaceManager,
          'ext:google': google.GoogleNamespaceManager,
          }

# Initialize the cache region dict
cache_regions = {}
cache_managers = {}

try:
    import pkg_resources

    # Load up the additional entry point defined backends
    for entry_point in pkg_resources.iter_entry_points('beaker.backends'):
        try:
            NamespaceManager = entry_point.load()
            name = entry_point.name
            if name in clsmap:
                raise BeakerException("NamespaceManager name conflict,'%s' "
                                      "already loaded" % name)
            clsmap[name] = NamespaceManager
        except (InvalidCacheBackendError, SyntaxError):
            # Ignore invalid backends
            pass
        except:
            import sys
            from pkg_resources import DistributionNotFound
            # Warn when there's a problem loading a NamespaceManager
            if not isinstance(sys.exc_info()[1], DistributionNotFound):
                import traceback
                from StringIO import StringIO
                tb = StringIO()
                traceback.print_exc(file=tb)
                warnings.warn("Unable to load NamespaceManager entry point: '%s': "
                              "%s" % (entry_point, tb.getvalue()), RuntimeWarning,
                              2)
except ImportError:
    pass




def cache_region(region, *deco_args):
    """Decorate a function to cache itself using a cache region

    The region decorator requires arguments if there are more than
    2 of the same named function, in the same module. This is
    because the namespace used for the functions cache is based on
    the functions name and the module.


    Example::

        # Add cache region settings to beaker:
        b3.lib.beaker.cache.cache_regions.update(dict_of_config_region_options))

        @cache_region('short_term', 'some_data')
        def populate_things(search_term, limit, offset):
            return load_the_data(search_term, limit, offset)

        return load('rabbits', 20, 0)

    .. note::

        The function being decorated must only be called with
        positional arguments.

    """
    cache = [None]

    def decorate(func):
        namespace = util.func_namespace(func)
        def cached(*args):
            reg = cache_regions[region]
            if not reg.get('enabled', True):
                return func(*args)

            if not cache[0]:
                if region not in cache_regions:
                    raise BeakerException('Cache region not configured: %s' % region)
                cache[0] = Cache._get_cache(namespace, reg)

            cache_key = " ".join(map(str, deco_args + args))
            def go():
                return func(*args)

            return cache[0].get_value(cache_key, createfunc=go)
        cached._arg_namespace = namespace
        cached._arg_region = region
        return cached
    return decorate


def region_invalidate(namespace, region, *args):
    """Invalidate a cache region namespace or decorated function

    This function only invalidates cache spaces created with the
    cache_region decorator.

    :param namespace: Either the namespace of the result to invalidate, or the
        cached function reference

    :param region: The region the function was cached to. If the function was
        cached to a single region then this argument can be None

    :param args: Arguments that were used to differentiate the cached
        function as well as the arguments passed to the decorated
        function

    Example::

        # Add cache region settings to beaker:
        b3.lib.beaker.cache.cache_regions.update(dict_of_config_region_options))

        def populate_things(invalidate=False):

            @cache_region('short_term', 'some_data')
            def load(search_term, limit, offset):
                return load_the_data(search_term, limit, offset)

            # If the results should be invalidated first
            if invalidate:
                region_invalidate(load, None, 'some_data',
                                        'rabbits', 20, 0)
            return load('rabbits', 20, 0)

    """
    if callable(namespace):
        if not region:
            region = namespace._arg_region
        namespace = namespace._arg_namespace

    if not region:
        raise BeakerException("Region or callable function "
                                    "namespace is required")
    else:
        region = cache_regions[region]

    cache = Cache._get_cache(namespace, region)
    cache_key = " ".join(str(x) for x in args)
    cache.remove_value(cache_key)


class Cache(object):
    """Front-end to the containment API implementing a data cache.

    :param namespace: the namespace of this Cache

    :param type: type of cache to use

    :param expire: seconds to keep cached data

    :param expiretime: seconds to keep cached data (legacy support)

    :param starttime: time when cache was cache was

    """
    def __init__(self, namespace, type='memory', expiretime=None,
                 starttime=None, expire=None, **nsargs):
        try:
            cls = clsmap[type]
            if isinstance(cls, InvalidCacheBackendError):
                raise cls
        except KeyError:
            raise TypeError("Unknown cache implementation %r" % type)

        self.namespace = cls(namespace, **nsargs)
        self.expiretime = expiretime or expire
        self.starttime = starttime
        self.nsargs = nsargs

    @classmethod
    def _get_cache(cls, namespace, kw):
        key = namespace + str(kw)
        try:
            return cache_managers[key]
        except KeyError:
            cache_managers[key] = cache = cls(namespace, **kw)
            return cache

    def put(self, key, value, **kw):
        self._get_value(key, **kw).set_value(value)
    set_value = put

    def get(self, key, **kw):
        """Retrieve a cached value from the container"""
        return self._get_value(key, **kw).get_value()
    get_value = get

    def remove_value(self, key, **kw):
        mycontainer = self._get_value(key, **kw)
        if mycontainer.has_current_value():
            mycontainer.clear_value()
    remove = remove_value

    def _get_value(self, key, **kw):
        if isinstance(key, unicode):
            key = key.encode('ascii', 'backslashreplace')

        if 'type' in kw:
            return self._legacy_get_value(key, **kw)

        kw.setdefault('expiretime', self.expiretime)
        kw.setdefault('starttime', self.starttime)

        return container.Value(key, self.namespace, **kw)

    @util.deprecated("Specifying a "
            "'type' and other namespace configuration with cache.get()/put()/etc. "
            "is deprecated. Specify 'type' and other namespace configuration to "
            "cache_manager.get_cache() and/or the Cache constructor instead.")
    def _legacy_get_value(self, key, type, **kw):
        expiretime = kw.pop('expiretime', self.expiretime)
        starttime = kw.pop('starttime', None)
        createfunc = kw.pop('createfunc', None)
        kwargs = self.nsargs.copy()
        kwargs.update(kw)
        c = Cache(self.namespace.namespace, type=type, **kwargs)
        return c._get_value(key, expiretime=expiretime, createfunc=createfunc,
                            starttime=starttime)

    def clear(self):
        """Clear all the values from the namespace"""
        self.namespace.remove()

    # dict interface
    def __getitem__(self, key):
        return self.get(key)

    def __contains__(self, key):
        return self._get_value(key).has_current_value()

    def has_key(self, key):
        return key in self

    def __delitem__(self, key):
        self.remove_value(key)

    def __setitem__(self, key, value):
        self.put(key, value)


class CacheManager(object):
    def __init__(self, **kwargs):
        """Initialize a CacheManager object with a set of options

        Options should be parsed with the
        :func:`~beaker.util.parse_cache_config_options` function to
        ensure only valid options are used.
        
        """
        self.kwargs = kwargs
        self.regions = kwargs.pop('cache_regions', {})
        
        # Add these regions to the module global
        cache_regions.update(self.regions)
    
    def get_cache(self, name, **kwargs):
        kw = self.kwargs.copy()
        kw.update(kwargs)
        return Cache._get_cache(name, kw)
    
    def get_cache_region(self, name, region):
        if region not in self.regions:
            raise BeakerException('Cache region not configured: %s' % region)
        kw = self.regions[region]
        return Cache._get_cache(name, kw)
    
    def region(self, region, *args):
        """Decorate a function to cache itself using a cache region
        
        The region decorator requires arguments if there are more than
        2 of the same named function, in the same module. This is
        because the namespace used for the functions cache is based on
        the functions name and the module.
        
        
        Example::
            
            # Assuming a cache object is available like:
            cache = CacheManager(dict_of_config_options)
            
            
            def populate_things():
                
                @cache.region('short_term', 'some_data')
                def load(search_term, limit, offset):
                    return load_the_data(search_term, limit, offset)
                
                return load('rabbits', 20, 0)
        
        .. note::
            
            The function being decorated must only be called with
            positional arguments.
        
        """
        return cache_region(region, *args)

    def region_invalidate(self, namespace, region, *args):
        """Invalidate a cache region namespace or decorated function
        
        This function only invalidates cache spaces created with the
        cache_region decorator.
        
        :param namespace: Either the namespace of the result to invalidate, or the
           name of the cached function
        
        :param region: The region the function was cached to. If the function was
            cached to a single region then this argument can be None
        
        :param args: Arguments that were used to differentiate the cached
            function as well as the arguments passed to the decorated
            function

        Example::
            
            # Assuming a cache object is available like:
            cache = CacheManager(dict_of_config_options)
            
            def populate_things(invalidate=False):
                
                @cache.region('short_term', 'some_data')
                def load(search_term, limit, offset):
                    return load_the_data(search_term, limit, offset)
                
                # If the results should be invalidated first
                if invalidate:
                    cache.region_invalidate(load, None, 'some_data',
                                            'rabbits', 20, 0)
                return load('rabbits', 20, 0)
            
        
        """
        return region_invalidate(namespace, region, *args)
        if callable(namespace):
            if not region:
                region = namespace._arg_region
            namespace = namespace._arg_namespace

        if not region:
            raise BeakerException("Region or callable function "
                                    "namespace is required")
        else:
            region = self.regions[region]
        
        cache = self.get_cache(namespace, **region)
        cache_key = " ".join(str(x) for x in args)
        cache.remove_value(cache_key)

    def cache(self, *args, **kwargs):
        """Decorate a function to cache itself with supplied parameters

        :param args: Used to make the key unique for this function, as in region()
            above.

        :param kwargs: Parameters to be passed to get_cache(), will override defaults

        Example::

            # Assuming a cache object is available like:
            cache = CacheManager(dict_of_config_options)
            
            
            def populate_things():
                
                @cache.cache('mycache', expire=15)
                def load(search_term, limit, offset):
                    return load_the_data(search_term, limit, offset)
                
                return load('rabbits', 20, 0)
        
        .. note::
            
            The function being decorated must only be called with
            positional arguments. 

        """
        cache = [None]
        key = " ".join(str(x) for x in args)
        
        def decorate(func):
            namespace = util.func_namespace(func)
            def cached(*args):
                if not cache[0]:
                    cache[0] = self.get_cache(namespace, **kwargs)
                cache_key = key + " " + " ".join(str(x) for x in args)
                def go():
                    return func(*args)
                return cache[0].get_value(cache_key, createfunc=go)
            cached._arg_namespace = namespace
            return cached
        return decorate

    def invalidate(self, func, *args, **kwargs):
        """Invalidate a cache decorated function
        
        This function only invalidates cache spaces created with the
        cache decorator.
        
        :param func: Decorated function to invalidate
        
        :param args: Used to make the key unique for this function, as in region()
            above.

        :param kwargs: Parameters that were passed for use by get_cache(), note that
            this is only required if a ``type`` was specified for the
            function

        Example::
            
            # Assuming a cache object is available like:
            cache = CacheManager(dict_of_config_options)
            
            
            def populate_things(invalidate=False):
                
                @cache.cache('mycache', type="file", expire=15)
                def load(search_term, limit, offset):
                    return load_the_data(search_term, limit, offset)
                
                # If the results should be invalidated first
                if invalidate:
                    cache.invalidate(load, 'mycache', 'rabbits', 20, 0, type="file")
                return load('rabbits', 20, 0)
        
        """
        namespace = func._arg_namespace

        cache = self.get_cache(namespace, **kwargs)
        cache_key = " ".join(str(x) for x in args)
        cache.remove_value(cache_key)

########NEW FILE########
__FILENAME__ = container
"""Container and Namespace classes"""
import anydbm
import cPickle
import logging
import os
import time

import b3.lib.beaker.util as util
from b3.lib.beaker.exceptions import CreationAbortedError, MissingCacheParameter
from b3.lib.beaker.synchronization import _threading, file_synchronizer, \
     mutex_synchronizer, NameLock, null_synchronizer

__all__ = ['Value', 'Container', 'ContainerContext',
           'MemoryContainer', 'DBMContainer', 'NamespaceManager',
           'MemoryNamespaceManager', 'DBMNamespaceManager', 'FileContainer',
           'OpenResourceNamespaceManager',
           'FileNamespaceManager', 'CreationAbortedError']


logger = logging.getLogger('b3.lib.beaker.container')
if logger.isEnabledFor(logging.DEBUG):
    debug = logger.debug
else:
    def debug(message, *args):
        pass


class NamespaceManager(object):
    """Handles dictionary operations and locking for a namespace of
    values.
    
    The implementation for setting and retrieving the namespace data is
    handled by subclasses.
    
    NamespaceManager may be used alone, or may be privately accessed by
    one or more Container objects.  Container objects provide per-key
    services like expiration times and automatic recreation of values.
    
    Multiple NamespaceManagers created with a particular name will all
    share access to the same underlying datasource and will attempt to
    synchronize against a common mutex object.  The scope of this
    sharing may be within a single process or across multiple
    processes, depending on the type of NamespaceManager used.
    
    The NamespaceManager itself is generally threadsafe, except in the
    case of the DBMNamespaceManager in conjunction with the gdbm dbm
    implementation.

    """
    
    @classmethod
    def _init_dependencies(cls):
        pass
        
    def __init__(self, namespace):
        self._init_dependencies()
        self.namespace = namespace
        
    def get_creation_lock(self, key):
        raise NotImplementedError()

    def do_remove(self):
        raise NotImplementedError()

    def acquire_read_lock(self):
        pass

    def release_read_lock(self):
        pass

    def acquire_write_lock(self, wait=True):
        return True

    def release_write_lock(self):
        pass

    def has_key(self, key):
        return self.__contains__(key)

    def __getitem__(self, key):
        raise NotImplementedError()
        
    def __setitem__(self, key, value):
        raise NotImplementedError()
    
    def set_value(self, key, value, expiretime=None):
        """Optional set_value() method called by Value.
        
        Allows an expiretime to be passed, for namespace
        implementations which can prune their collections
        using expiretime.
        
        """
        self[key] = value
        
    def __contains__(self, key):
        raise NotImplementedError()

    def __delitem__(self, key):
        raise NotImplementedError()
    
    def keys(self):
        raise NotImplementedError()
    
    def remove(self):
        self.do_remove()
        

class OpenResourceNamespaceManager(NamespaceManager):
    """A NamespaceManager where read/write operations require opening/
    closing of a resource which is possibly mutexed.
    
    """
    def __init__(self, namespace):
        NamespaceManager.__init__(self, namespace)
        self.access_lock = self.get_access_lock()
        self.openers = 0
        self.mutex = _threading.Lock()

    def get_access_lock(self):
        raise NotImplementedError()

    def do_open(self, flags): 
        raise NotImplementedError()

    def do_close(self): 
        raise NotImplementedError()

    def acquire_read_lock(self): 
        self.access_lock.acquire_read_lock()
        try:
            self.open('r', checkcount = True)
        except:
            self.access_lock.release_read_lock()
            raise
            
    def release_read_lock(self):
        try:
            self.close(checkcount = True)
        finally:
            self.access_lock.release_read_lock()
        
    def acquire_write_lock(self, wait=True): 
        r = self.access_lock.acquire_write_lock(wait)
        try:
            if (wait or r): 
                self.open('c', checkcount = True)
            return r
        except:
            self.access_lock.release_write_lock()
            raise
            
    def release_write_lock(self): 
        try:
            self.close(checkcount=True)
        finally:
            self.access_lock.release_write_lock()

    def open(self, flags, checkcount=False):
        self.mutex.acquire()
        try:
            if checkcount:
                if self.openers == 0: 
                    self.do_open(flags)
                self.openers += 1
            else:
                self.do_open(flags)
                self.openers = 1
        finally:
            self.mutex.release()

    def close(self, checkcount=False):
        self.mutex.acquire()
        try:
            if checkcount:
                self.openers -= 1
                if self.openers == 0: 
                    self.do_close()
            else:
                if self.openers > 0:
                    self.do_close()
                self.openers = 0
        finally:
            self.mutex.release()

    def remove(self):
        self.access_lock.acquire_write_lock()
        try:
            self.close(checkcount=False)
            self.do_remove()
        finally:
            self.access_lock.release_write_lock()

class Value(object):
    __slots__ = 'key', 'createfunc', 'expiretime', 'expire_argument', 'starttime', 'storedtime',\
                'namespace'

    def __init__(self, key, namespace, createfunc=None, expiretime=None, starttime=None):
        self.key = key
        self.createfunc = createfunc
        self.expire_argument = expiretime
        self.starttime = starttime
        self.storedtime = -1
        self.namespace = namespace

    def has_value(self):
        """return true if the container has a value stored.

        This is regardless of it being expired or not.

        """
        self.namespace.acquire_read_lock()
        try:    
            return self.namespace.has_key(self.key)
        finally:
            self.namespace.release_read_lock()

    def can_have_value(self):
        return self.has_current_value() or self.createfunc is not None  

    def has_current_value(self):
        self.namespace.acquire_read_lock()
        try:    
            has_value = self.namespace.has_key(self.key)
            if has_value:
                try:
                    stored, expired, value = self._get_value()
                    return not self._is_expired(stored, expired)
                except KeyError:
                    pass
            return False
        finally:
            self.namespace.release_read_lock()

    def _is_expired(self, storedtime, expiretime):
        """Return true if this container's value is expired."""
        return (
            (
                self.starttime is not None and
                storedtime < self.starttime
            )
            or
            (
                expiretime is not None and
                time.time() >= expiretime + storedtime
            )
        )

    def get_value(self):
        self.namespace.acquire_read_lock()
        try:
            has_value = self.has_value()
            if has_value:
                try:
                    stored, expired, value = self._get_value()
                    if not self._is_expired(stored, expired):
                        return value
                except KeyError:
                    # guard against un-mutexed backends raising KeyError
                    has_value = False
                    
            if not self.createfunc:
                raise KeyError(self.key)
        finally:
            self.namespace.release_read_lock()

        has_createlock = False
        creation_lock = self.namespace.get_creation_lock(self.key)
        if has_value:
            if not creation_lock.acquire(wait=False):
                debug("get_value returning old value while new one is created")
                return value
            else:
                debug("lock_creatfunc (didnt wait)")
                has_createlock = True

        if not has_createlock:
            debug("lock_createfunc (waiting)")
            creation_lock.acquire()
            debug("lock_createfunc (waited)")

        try:
            # see if someone created the value already
            self.namespace.acquire_read_lock()
            try:
                if self.has_value():
                    try:
                        stored, expired, value = self._get_value()
                        if not self._is_expired(stored, expired):
                            return value
                    except KeyError:
                        # guard against un-mutexed backends raising KeyError
                        pass
            finally:
                self.namespace.release_read_lock()

            debug("get_value creating new value")
            v = self.createfunc()
            self.set_value(v)
            return v
        finally:
            creation_lock.release()
            debug("released create lock")

    def _get_value(self):
        value = self.namespace[self.key]
        try:
            stored, expired, value = value
        except ValueError:
            if not len(value) == 2:
                raise
            # Old format: upgrade
            stored, value = value
            expired = self.expire_argument
            debug("get_value upgrading time %r expire time %r", stored, self.expire_argument)
            self.namespace.release_read_lock()
            self.set_value(value, stored)
            self.namespace.acquire_read_lock()
        except TypeError:
            # occurs when the value is None.  memcached 
            # may yank the rug from under us in which case 
            # that's the result
            raise KeyError(self.key)            
        return stored, expired, value

    def set_value(self, value, storedtime=None):
        self.namespace.acquire_write_lock()
        try:
            if storedtime is None:
                storedtime = time.time()
            debug("set_value stored time %r expire time %r", storedtime, self.expire_argument)
            self.namespace.set_value(self.key, (storedtime, self.expire_argument, value))
        finally:
            self.namespace.release_write_lock()

    def clear_value(self):
        self.namespace.acquire_write_lock()
        try:
            debug("clear_value")
            if self.namespace.has_key(self.key):
                try:
                    del self.namespace[self.key]
                except KeyError:
                    # guard against un-mutexed backends raising KeyError
                    pass
            self.storedtime = -1
        finally:
            self.namespace.release_write_lock()

class AbstractDictionaryNSManager(NamespaceManager):
    """A subclassable NamespaceManager that places data in a dictionary.
    
    Subclasses should provide a "dictionary" attribute or descriptor
    which returns a dict-like object.   The dictionary will store keys
    that are local to the "namespace" attribute of this manager, so
    ensure that the dictionary will not be used by any other namespace.

    e.g.::
    
        import collections
        cached_data = collections.defaultdict(dict)
        
        class MyDictionaryManager(AbstractDictionaryNSManager):
            def __init__(self, namespace):
                AbstractDictionaryNSManager.__init__(self, namespace)
                self.dictionary = cached_data[self.namespace]
                
    The above stores data in a global dictionary called "cached_data",
    which is structured as a dictionary of dictionaries, keyed
    first on namespace name to a sub-dictionary, then on actual
    cache key to value.
    
    """
    
    def get_creation_lock(self, key):
        return NameLock(
            identifier="memorynamespace/funclock/%s/%s" % (self.namespace, key),
            reentrant=True
        )

    def __getitem__(self, key): 
        return self.dictionary[key]

    def __contains__(self, key): 
        return self.dictionary.__contains__(key)

    def has_key(self, key): 
        return self.dictionary.__contains__(key)
        
    def __setitem__(self, key, value):
        self.dictionary[key] = value
    
    def __delitem__(self, key):
        del self.dictionary[key]

    def do_remove(self):
        self.dictionary.clear()
        
    def keys(self):
        return self.dictionary.keys()
    
class MemoryNamespaceManager(AbstractDictionaryNSManager):
    namespaces = util.SyncDict()

    def __init__(self, namespace, **kwargs):
        AbstractDictionaryNSManager.__init__(self, namespace)
        self.dictionary = MemoryNamespaceManager.namespaces.get(self.namespace,
                                                                dict)

class DBMNamespaceManager(OpenResourceNamespaceManager):
    def __init__(self, namespace, dbmmodule=None, data_dir=None, 
            dbm_dir=None, lock_dir=None, digest_filenames=True, **kwargs):
        self.digest_filenames = digest_filenames
        
        if not dbm_dir and not data_dir:
            raise MissingCacheParameter("data_dir or dbm_dir is required")
        elif dbm_dir:
            self.dbm_dir = dbm_dir
        else:
            self.dbm_dir = data_dir + "/container_dbm"
        util.verify_directory(self.dbm_dir)
        
        if not lock_dir and not data_dir:
            raise MissingCacheParameter("data_dir or lock_dir is required")
        elif lock_dir:
            self.lock_dir = lock_dir
        else:
            self.lock_dir = data_dir + "/container_dbm_lock"
        util.verify_directory(self.lock_dir)

        self.dbmmodule = dbmmodule or anydbm

        self.dbm = None
        OpenResourceNamespaceManager.__init__(self, namespace)

        self.file = util.encoded_path(root= self.dbm_dir,
                                      identifiers=[self.namespace],
                                      extension='.dbm',
                                      digest_filenames=self.digest_filenames)
        
        debug("data file %s", self.file)
        self._checkfile()

    def get_access_lock(self):
        return file_synchronizer(identifier=self.namespace,
                                 lock_dir=self.lock_dir)
                                 
    def get_creation_lock(self, key):
        return file_synchronizer(
                    identifier = "dbmcontainer/funclock/%s" % self.namespace, 
                    lock_dir=self.lock_dir
                )

    def file_exists(self, file):
        if os.access(file, os.F_OK): 
            return True
        else:
            for ext in ('db', 'dat', 'pag', 'dir'):
                if os.access(file + os.extsep + ext, os.F_OK):
                    return True
                    
        return False
    
    def _checkfile(self):
        if not self.file_exists(self.file):
            g = self.dbmmodule.open(self.file, 'c') 
            g.close()
                
    def get_filenames(self):
        list = []
        if os.access(self.file, os.F_OK):
            list.append(self.file)
            
        for ext in ('pag', 'dir', 'db', 'dat'):
            if os.access(self.file + os.extsep + ext, os.F_OK):
                list.append(self.file + os.extsep + ext)
        return list

    def do_open(self, flags):
        debug("opening dbm file %s", self.file)
        try:
            self.dbm = self.dbmmodule.open(self.file, flags)
        except:
            self._checkfile()
            self.dbm = self.dbmmodule.open(self.file, flags)

    def do_close(self):
        if self.dbm is not None:
            debug("closing dbm file %s", self.file)
            self.dbm.close()
        
    def do_remove(self):
        for f in self.get_filenames():
            os.remove(f)
        
    def __getitem__(self, key): 
        return cPickle.loads(self.dbm[key])

    def __contains__(self, key): 
        return self.dbm.has_key(key)
        
    def __setitem__(self, key, value):
        self.dbm[key] = cPickle.dumps(value)

    def __delitem__(self, key):
        del self.dbm[key]

    def keys(self):
        return self.dbm.keys()


class FileNamespaceManager(OpenResourceNamespaceManager):
    def __init__(self, namespace, data_dir=None, file_dir=None, lock_dir=None,
                 digest_filenames=True, **kwargs):
        self.digest_filenames = digest_filenames
        
        if not file_dir and not data_dir:
            raise MissingCacheParameter("data_dir or file_dir is required")
        elif file_dir:
            self.file_dir = file_dir
        else:
            self.file_dir = data_dir + "/container_file"
        util.verify_directory(self.file_dir)

        if not lock_dir and not data_dir:
            raise MissingCacheParameter("data_dir or lock_dir is required")
        elif lock_dir:
            self.lock_dir = lock_dir
        else:
            self.lock_dir = data_dir + "/container_file_lock"
        util.verify_directory(self.lock_dir)
        OpenResourceNamespaceManager.__init__(self, namespace)

        self.file = util.encoded_path(root=self.file_dir, 
                                      identifiers=[self.namespace],
                                      extension='.cache',
                                      digest_filenames=self.digest_filenames)
        self.hash = {}
        
        debug("data file %s", self.file)

    def get_access_lock(self):
        return file_synchronizer(identifier=self.namespace,
                                 lock_dir=self.lock_dir)
                                 
    def get_creation_lock(self, key):
        return file_synchronizer(
                identifier = "filecontainer/funclock/%s" % self.namespace, 
                lock_dir = self.lock_dir
                )
        
    def file_exists(self, file):
        return os.access(file, os.F_OK)

    def do_open(self, flags):
        if self.file_exists(self.file):
            fh = open(self.file, 'rb')
            try:
                self.hash = cPickle.load(fh)
            except (IOError, OSError, EOFError, cPickle.PickleError, ValueError):
                pass
            fh.close()

        self.flags = flags
        
    def do_close(self):
        if self.flags == 'c' or self.flags == 'w':
            fh = open(self.file, 'wb')
            cPickle.dump(self.hash, fh)
            fh.close()

        self.hash = {}
        self.flags = None
                
    def do_remove(self):
        try:
            os.remove(self.file)
        except OSError, err:
            # for instance, because we haven't yet used this cache,
            # but client code has asked for a clear() operation...
            pass
        self.hash = {}
        
    def __getitem__(self, key): 
        return self.hash[key]

    def __contains__(self, key): 
        return self.hash.has_key(key)
        
    def __setitem__(self, key, value):
        self.hash[key] = value

    def __delitem__(self, key):
        del self.hash[key]

    def keys(self):
        return self.hash.keys()


#### legacy stuff to support the old "Container" class interface

namespace_classes = {}

ContainerContext = dict
    
class ContainerMeta(type):
    def __init__(cls, classname, bases, dict_):
        namespace_classes[cls] = cls.namespace_class
        return type.__init__(cls, classname, bases, dict_)
    def __call__(self, key, context, namespace, createfunc=None,
                 expiretime=None, starttime=None, **kwargs):
        if namespace in context:
            ns = context[namespace]
        else:
            nscls = namespace_classes[self]
            context[namespace] = ns = nscls(namespace, **kwargs)
        return Value(key, ns, createfunc=createfunc,
                     expiretime=expiretime, starttime=starttime)

class Container(object):
    __metaclass__ = ContainerMeta
    namespace_class = NamespaceManager

class FileContainer(Container):
    namespace_class = FileNamespaceManager

class MemoryContainer(Container):
    namespace_class = MemoryNamespaceManager

class DBMContainer(Container):
    namespace_class = DBMNamespaceManager

DbmContainer = DBMContainer

########NEW FILE########
__FILENAME__ = converters
# (c) 2005 Ian Bicking and contributors; written for Paste (http://pythonpaste.org)
# Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
def asbool(obj):
    if isinstance(obj, (str, unicode)):
        obj = obj.strip().lower()
        if obj in ['true', 'yes', 'on', 'y', 't', '1']:
            return True
        elif obj in ['false', 'no', 'off', 'n', 'f', '0']:
            return False
        else:
            raise ValueError(
                "String is not true/false: %r" % obj)
    return bool(obj)

def aslist(obj, sep=None, strip=True):
    if isinstance(obj, (str, unicode)):
        lst = obj.split(sep)
        if strip:
            lst = [v.strip() for v in lst]
        return lst
    elif isinstance(obj, (list, tuple)):
        return obj
    elif obj is None:
        return []
    else:
        return [obj]

########NEW FILE########
__FILENAME__ = jcecrypto
"""
Encryption module that uses the Java Cryptography Extensions (JCE).

Note that in default installations of the Java Runtime Environment, the
maximum key length is limited to 128 bits due to US export
restrictions. This makes the generated keys incompatible with the ones
generated by pycryptopp, which has no such restrictions. To fix this,
download the "Unlimited Strength Jurisdiction Policy Files" from Sun,
which will allow encryption using 256 bit AES keys.
"""
from javax.crypto import Cipher
from javax.crypto.spec import SecretKeySpec, IvParameterSpec

import jarray

# Initialization vector filled with zeros
_iv = IvParameterSpec(jarray.zeros(16, 'b'))

def aesEncrypt(data, key):
    cipher = Cipher.getInstance('AES/CTR/NoPadding')
    skeySpec = SecretKeySpec(key, 'AES')
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, _iv)
    return cipher.doFinal(data).tostring()

# magic.
aesDecrypt = aesEncrypt

def getKeyLength():
    maxlen = Cipher.getMaxAllowedKeyLength('AES/CTR/NoPadding')
    return min(maxlen, 256) / 8

########NEW FILE########
__FILENAME__ = pbkdf2
#!/usr/bin/python
# -*- coding: ascii -*-
###########################################################################
# PBKDF2.py - PKCS#5 v2.0 Password-Based Key Derivation
#
# Copyright (C) 2007 Dwayne C. Litzenberger <dlitz@dlitz.net>
# All rights reserved.
# 
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation.
# 
# THE AUTHOR PROVIDES THIS SOFTWARE ``AS IS'' AND ANY EXPRESSED OR 
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Country of origin: Canada
#
###########################################################################
# Sample PBKDF2 usage:
#   from Crypto.Cipher import AES
#   from PBKDF2 import PBKDF2
#   import os
#
#   salt = os.urandom(8)    # 64-bit salt
#   key = PBKDF2("This passphrase is a secret.", salt).read(32) # 256-bit key
#   iv = os.urandom(16)     # 128-bit IV
#   cipher = AES.new(key, AES.MODE_CBC, iv)
#     ...
#
# Sample crypt() usage:
#   from PBKDF2 import crypt
#   pwhash = crypt("secret")
#   alleged_pw = raw_input("Enter password: ")
#   if pwhash == crypt(alleged_pw, pwhash):
#       print "Password good"
#   else:
#       print "Invalid password"
#
###########################################################################
# History:
#
#  2007-07-27 Dwayne C. Litzenberger <dlitz@dlitz.net>
#   - Initial Release (v1.0)
#
#  2007-07-31 Dwayne C. Litzenberger <dlitz@dlitz.net>
#   - Bugfix release (v1.1)
#   - SECURITY: The PyCrypto XOR cipher (used, if available, in the _strxor
#   function in the previous release) silently truncates all keys to 64
#   bytes.  The way it was used in the previous release, this would only be
#   problem if the pseudorandom function that returned values larger than
#   64 bytes (so SHA1, SHA256 and SHA512 are fine), but I don't like
#   anything that silently reduces the security margin from what is
#   expected.
#
###########################################################################

__version__ = "1.1"

from struct import pack
from binascii import b2a_hex
from random import randint

from base64 import b64encode

from b3.lib.beaker.crypto.util import hmac as HMAC, hmac_sha1 as SHA1

def strxor(a, b):
    return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])

class PBKDF2(object):
    """PBKDF2.py : PKCS#5 v2.0 Password-Based Key Derivation
    
    This implementation takes a passphrase and a salt (and optionally an
    iteration count, a digest module, and a MAC module) and provides a
    file-like object from which an arbitrarily-sized key can be read.

    If the passphrase and/or salt are unicode objects, they are encoded as
    UTF-8 before they are processed.

    The idea behind PBKDF2 is to derive a cryptographic key from a
    passphrase and a salt.
    
    PBKDF2 may also be used as a strong salted password hash.  The
    'crypt' function is provided for that purpose.
    
    Remember: Keys generated using PBKDF2 are only as strong as the
    passphrases they are derived from.
    """

    def __init__(self, passphrase, salt, iterations=1000,
                 digestmodule=SHA1, macmodule=HMAC):
        if not callable(macmodule):
            macmodule = macmodule.new
        self.__macmodule = macmodule
        self.__digestmodule = digestmodule
        self._setup(passphrase, salt, iterations, self._pseudorandom)

    def _pseudorandom(self, key, msg):
        """Pseudorandom function.  e.g. HMAC-SHA1"""
        return self.__macmodule(key=key, msg=msg,
            digestmod=self.__digestmodule).digest()
    
    def read(self, bytes):
        """Read the specified number of key bytes."""
        if self.closed:
            raise ValueError("file-like object is closed")

        size = len(self.__buf)
        blocks = [self.__buf]
        i = self.__blockNum
        while size < bytes:
            i += 1
            if i > 0xffffffff:
                # We could return "" here, but 
                raise OverflowError("derived key too long")
            block = self.__f(i)
            blocks.append(block)
            size += len(block)
        buf = "".join(blocks)
        retval = buf[:bytes]
        self.__buf = buf[bytes:]
        self.__blockNum = i
        return retval
    
    def __f(self, i):
        # i must fit within 32 bits
        assert (1 <= i and i <= 0xffffffff)
        U = self.__prf(self.__passphrase, self.__salt + pack("!L", i))
        result = U
        for j in xrange(2, 1+self.__iterations):
            U = self.__prf(self.__passphrase, U)
            result = strxor(result, U)
        return result
    
    def hexread(self, octets):
        """Read the specified number of octets. Return them as hexadecimal.

        Note that len(obj.hexread(n)) == 2*n.
        """
        return b2a_hex(self.read(octets))

    def _setup(self, passphrase, salt, iterations, prf):
        # Sanity checks:
        
        # passphrase and salt must be str or unicode (in the latter
        # case, we convert to UTF-8)
        if isinstance(passphrase, unicode):
            passphrase = passphrase.encode("UTF-8")
        if not isinstance(passphrase, str):
            raise TypeError("passphrase must be str or unicode")
        if isinstance(salt, unicode):
            salt = salt.encode("UTF-8")
        if not isinstance(salt, str):
            raise TypeError("salt must be str or unicode")

        # iterations must be an integer >= 1
        if not isinstance(iterations, (int, long)):
            raise TypeError("iterations must be an integer")
        if iterations < 1:
            raise ValueError("iterations must be at least 1")
        
        # prf must be callable
        if not callable(prf):
            raise TypeError("prf must be callable")

        self.__passphrase = passphrase
        self.__salt = salt
        self.__iterations = iterations
        self.__prf = prf
        self.__blockNum = 0
        self.__buf = ""
        self.closed = False
    
    def close(self):
        """Close the stream."""
        if not self.closed:
            del self.__passphrase
            del self.__salt
            del self.__iterations
            del self.__prf
            del self.__blockNum
            del self.__buf
            self.closed = True

def crypt(word, salt=None, iterations=None):
    """PBKDF2-based unix crypt(3) replacement.
    
    The number of iterations specified in the salt overrides the 'iterations'
    parameter.

    The effective hash length is 192 bits.
    """
    
    # Generate a (pseudo-)random salt if the user hasn't provided one.
    if salt is None:
        salt = _makesalt()

    # salt must be a string or the us-ascii subset of unicode
    if isinstance(salt, unicode):
        salt = salt.encode("us-ascii")
    if not isinstance(salt, str):
        raise TypeError("salt must be a string")

    # word must be a string or unicode (in the latter case, we convert to UTF-8)
    if isinstance(word, unicode):
        word = word.encode("UTF-8")
    if not isinstance(word, str):
        raise TypeError("word must be a string or unicode")

    # Try to extract the real salt and iteration count from the salt
    if salt.startswith("$p5k2$"):
        (iterations, salt, dummy) = salt.split("$")[2:5]
        if iterations == "":
            iterations = 400
        else:
            converted = int(iterations, 16)
            if iterations != "%x" % converted:  # lowercase hex, minimum digits
                raise ValueError("Invalid salt")
            iterations = converted
            if not (iterations >= 1):
                raise ValueError("Invalid salt")
    
    # Make sure the salt matches the allowed character set
    allowed = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./"
    for ch in salt:
        if ch not in allowed:
            raise ValueError("Illegal character %r in salt" % (ch,))

    if iterations is None or iterations == 400:
        iterations = 400
        salt = "$p5k2$$" + salt
    else:
        salt = "$p5k2$%x$%s" % (iterations, salt)
    rawhash = PBKDF2(word, salt, iterations).read(24)
    return salt + "$" + b64encode(rawhash, "./")

# Add crypt as a static method of the PBKDF2 class
# This makes it easier to do "from PBKDF2 import PBKDF2" and still use
# crypt.
PBKDF2.crypt = staticmethod(crypt)

def _makesalt():
    """Return a 48-bit pseudorandom salt for crypt().
    
    This function is not suitable for generating cryptographic secrets.
    """
    binarysalt = "".join([pack("@H", randint(0, 0xffff)) for i in range(3)])
    return b64encode(binarysalt, "./")

def test_pbkdf2():
    """Module self-test"""
    from binascii import a2b_hex
    
    #
    # Test vectors from RFC 3962
    #

    # Test 1
    result = PBKDF2("password", "ATHENA.MIT.EDUraeburn", 1).read(16)
    expected = a2b_hex("cdedb5281bb2f801565a1122b2563515")
    if result != expected:
        raise RuntimeError("self-test failed")

    # Test 2
    result = PBKDF2("password", "ATHENA.MIT.EDUraeburn", 1200).hexread(32)
    expected = ("5c08eb61fdf71e4e4ec3cf6ba1f5512b"
                "a7e52ddbc5e5142f708a31e2e62b1e13")
    if result != expected:
        raise RuntimeError("self-test failed")

    # Test 3
    result = PBKDF2("X"*64, "pass phrase equals block size", 1200).hexread(32)
    expected = ("139c30c0966bc32ba55fdbf212530ac9"
                "c5ec59f1a452f5cc9ad940fea0598ed1")
    if result != expected:
        raise RuntimeError("self-test failed")
    
    # Test 4
    result = PBKDF2("X"*65, "pass phrase exceeds block size", 1200).hexread(32)
    expected = ("9ccad6d468770cd51b10e6a68721be61"
                "1a8b4d282601db3b36be9246915ec82a")
    if result != expected:
        raise RuntimeError("self-test failed")
    
    #
    # Other test vectors
    #
    
    # Chunked read
    f = PBKDF2("kickstart", "workbench", 256)
    result = f.read(17)
    result += f.read(17)
    result += f.read(1)
    result += f.read(2)
    result += f.read(3)
    expected = PBKDF2("kickstart", "workbench", 256).read(40)
    if result != expected:
        raise RuntimeError("self-test failed")
    
    #
    # crypt() test vectors
    #

    # crypt 1
    result = crypt("cloadm", "exec")
    expected = '$p5k2$$exec$r1EWMCMk7Rlv3L/RNcFXviDefYa0hlql'
    if result != expected:
        raise RuntimeError("self-test failed")
    
    # crypt 2
    result = crypt("gnu", '$p5k2$c$u9HvcT4d$.....')
    expected = '$p5k2$c$u9HvcT4d$Sd1gwSVCLZYAuqZ25piRnbBEoAesaa/g'
    if result != expected:
        raise RuntimeError("self-test failed")

    # crypt 3
    result = crypt("dcl", "tUsch7fU", iterations=13)
    expected = "$p5k2$d$tUsch7fU$nqDkaxMDOFBeJsTSfABsyn.PYUXilHwL"
    if result != expected:
        raise RuntimeError("self-test failed")
    
    # crypt 4 (unicode)
    result = crypt(u'\u0399\u03c9\u03b1\u03bd\u03bd\u03b7\u03c2',
        '$p5k2$$KosHgqNo$9mjN8gqjt02hDoP0c2J0ABtLIwtot8cQ')
    expected = '$p5k2$$KosHgqNo$9mjN8gqjt02hDoP0c2J0ABtLIwtot8cQ'
    if result != expected:
        raise RuntimeError("self-test failed")

if __name__ == '__main__':
    test_pbkdf2()

# vim:set ts=4 sw=4 sts=4 expandtab:

########NEW FILE########
__FILENAME__ = pycrypto
"""Encryption module that uses pycryptopp or pycrypto"""
try:
    # Pycryptopp is preferred over Crypto because Crypto has had
    # various periods of not being maintained, and pycryptopp uses
    # the Crypto++ library which is generally considered the 'gold standard'
    # of crypto implementations
    from pycryptopp.cipher import aes

    def aesEncrypt(data, key):
        cipher = aes.AES(key)
        return cipher.process(data)
    
    # magic.
    aesDecrypt = aesEncrypt
    
except ImportError:
    from Crypto.Cipher import AES

    def aesEncrypt(data, key):
        cipher = AES.new(key)
        
        data = data + (" " * (16 - (len(data) % 16)))
        return cipher.encrypt(data)

    def aesDecrypt(data, key):
        cipher = AES.new(key)

        return cipher.decrypt(data).rstrip()

def getKeyLength():
    return 32

########NEW FILE########
__FILENAME__ = util
from warnings import warn
from b3.lib.beaker import util


try:
    # Use PyCrypto (if available)
    from Crypto.Hash import HMAC as hmac, SHA as hmac_sha1
    sha1 = hmac_sha1.new
    
except ImportError:
    
    # PyCrypto not available.  Use the Python standard library.
    import hmac

    # When using the stdlib, we have to make sure the hmac version and sha
    # version are compatible
    if util.py24:
        from sha import sha as sha1
        import sha as hmac_sha1
    else:
        # NOTE: We have to use the callable with hashlib (hashlib.sha1),
        # otherwise hmac only accepts the sha module object itself
        from hashlib import sha1
        hmac_sha1 = sha1


if util.py24:
    from md5 import md5
else:
    from hashlib import md5

########NEW FILE########
__FILENAME__ = exceptions
"""Beaker exception classes"""

class BeakerException(Exception):
    pass


class CreationAbortedError(Exception):
    """Deprecated."""


class InvalidCacheBackendError(BeakerException, ImportError):
    pass


class MissingCacheParameter(BeakerException):
    pass


class LockError(BeakerException):
    pass


class InvalidCryptoBackendError(BeakerException):
    pass

########NEW FILE########
__FILENAME__ = database
import cPickle
import logging
import pickle
from datetime import datetime

from b3.lib.beaker.container import OpenResourceNamespaceManager, Container
from b3.lib.beaker.exceptions import InvalidCacheBackendError, MissingCacheParameter
from b3.lib.beaker.synchronization import file_synchronizer, null_synchronizer
from b3.lib.beaker.util import verify_directory, SyncDict

log = logging.getLogger(__name__)

sa = None
pool = None
types = None

class DatabaseNamespaceManager(OpenResourceNamespaceManager):
    metadatas = SyncDict()
    tables = SyncDict()

    @classmethod
    def _init_dependencies(cls):
        global sa, pool, types
        if sa is not None:
            return
        try:
            import sqlalchemy as sa
            import sqlalchemy.pool as pool
            from sqlalchemy import types
        except ImportError:
            raise InvalidCacheBackendError("Database cache backend requires "
                                            "the 'sqlalchemy' library")
        
    def __init__(self, namespace, url=None, sa_opts=None, optimistic=False,
                 table_name='beaker_cache', data_dir=None, lock_dir=None,
                 **params):
        """Creates a database namespace manager
        
        ``url``
            SQLAlchemy compliant db url
        ``sa_opts``
            A dictionary of SQLAlchemy keyword options to initialize the engine
            with.
        ``optimistic``
            Use optimistic session locking, note that this will result in an
            additional select when updating a cache value to compare version
            numbers.
        ``table_name``
            The table name to use in the database for the cache.
        """
        OpenResourceNamespaceManager.__init__(self, namespace)
        
        if sa_opts is None:
            sa_opts = params

        if lock_dir:
            self.lock_dir = lock_dir
        elif data_dir:
            self.lock_dir = data_dir + "/container_db_lock"
        if self.lock_dir:
            verify_directory(self.lock_dir)            
        
        # Check to see if the table's been created before
        url = url or sa_opts['sa.url']
        table_key = url + table_name
        def make_cache():
            # Check to see if we have a connection pool open already
            meta_key = url + table_name
            def make_meta():
                # SQLAlchemy pops the url, this ensures it sticks around
                # later
                sa_opts['sa.url'] = url
                engine = sa.engine_from_config(sa_opts, 'sa.')
                meta = sa.MetaData()
                meta.bind = engine
                return meta
            meta = DatabaseNamespaceManager.metadatas.get(meta_key, make_meta)
            # Create the table object and cache it now
            cache = sa.Table(table_name, meta,
                             sa.Column('id', types.Integer, primary_key=True),
                             sa.Column('namespace', types.String(255), nullable=False),
                             sa.Column('accessed', types.DateTime, nullable=False),
                             sa.Column('created', types.DateTime, nullable=False),
                             sa.Column('data', types.PickleType, nullable=False),
                             sa.UniqueConstraint('namespace')
            )
            cache.create(checkfirst=True)
            return cache
        self.hash = {}
        self._is_new = False
        self.loaded = False
        self.cache = DatabaseNamespaceManager.tables.get(table_key, make_cache)
    
    def get_access_lock(self):
        return null_synchronizer()

    def get_creation_lock(self, key):
        return file_synchronizer(
            identifier ="databasecontainer/funclock/%s" % self.namespace,
            lock_dir = self.lock_dir)

    def do_open(self, flags):
        # If we already loaded the data, don't bother loading it again
        if self.loaded:
            self.flags = flags
            return
        
        cache = self.cache
        result = sa.select([cache.c.data], 
                           cache.c.namespace==self.namespace
                          ).execute().fetchone()
        if not result:
            self._is_new = True
            self.hash = {}
        else:
            self._is_new = False
            try:
                self.hash = result['data']
            except (IOError, OSError, EOFError, cPickle.PickleError,
                    pickle.PickleError):
                log.debug("Couln't load pickle data, creating new storage")
                self.hash = {}
                self._is_new = True
        self.flags = flags
        self.loaded = True
    
    def do_close(self):
        if self.flags is not None and (self.flags == 'c' or self.flags == 'w'):
            cache = self.cache
            if self._is_new:
                cache.insert().execute(namespace=self.namespace, data=self.hash,
                                       accessed=datetime.now(),
                                       created=datetime.now())
                self._is_new = False
            else:
                cache.update(cache.c.namespace==self.namespace).execute(
                    data=self.hash, accessed=datetime.now())
        self.flags = None
    
    def do_remove(self):
        cache = self.cache
        cache.delete(cache.c.namespace==self.namespace).execute()
        self.hash = {}
        
        # We can retain the fact that we did a load attempt, but since the
        # file is gone this will be a new namespace should it be saved.
        self._is_new = True

    def __getitem__(self, key): 
        return self.hash[key]

    def __contains__(self, key): 
        return self.hash.has_key(key)
        
    def __setitem__(self, key, value):
        self.hash[key] = value

    def __delitem__(self, key):
        del self.hash[key]

    def keys(self):
        return self.hash.keys()

class DatabaseContainer(Container):
    namespace_manager = DatabaseNamespaceManager

########NEW FILE########
__FILENAME__ = google
import cPickle
import logging
from datetime import datetime

from b3.lib.beaker.container import OpenResourceNamespaceManager, Container
from b3.lib.beaker.exceptions import InvalidCacheBackendError
from b3.lib.beaker.synchronization import null_synchronizer

log = logging.getLogger(__name__)

db = None

class GoogleNamespaceManager(OpenResourceNamespaceManager):
    tables = {}

    @classmethod
    def _init_dependencies(cls):
        global db
        if db is not None:
            return
        try:
            db = __import__('google.appengine.ext.db').appengine.ext.db
        except ImportError:
            raise InvalidCacheBackendError("Datastore cache backend requires the "
                                           "'google.appengine.ext' library")
    
    def __init__(self, namespace, table_name='beaker_cache', **params):
        """Creates a datastore namespace manager"""
        OpenResourceNamespaceManager.__init__(self, namespace)
        
        def make_cache():
            table_dict = dict(created=db.DateTimeProperty(),
                              accessed=db.DateTimeProperty(),
                              data=db.BlobProperty())
            table = type(table_name, (db.Model,), table_dict)
            return table
        self.table_name = table_name
        self.cache = GoogleNamespaceManager.tables.setdefault(table_name, make_cache())
        self.hash = {}
        self._is_new = False
        self.loaded = False
        self.log_debug = logging.DEBUG >= log.getEffectiveLevel()
        
        # Google wants namespaces to start with letters, change the namespace
        # to start with a letter
        self.namespace = 'p%s' % self.namespace
    
    def get_access_lock(self):
        return null_synchronizer()

    def get_creation_lock(self, key):
        # this is weird, should probably be present
        return null_synchronizer()

    def do_open(self, flags):
        # If we already loaded the data, don't bother loading it again
        if self.loaded:
            self.flags = flags
            return
        
        item = self.cache.get_by_key_name(self.namespace)
        
        if not item:
            self._is_new = True
            self.hash = {}
        else:
            self._is_new = False
            try:
                self.hash = cPickle.loads(str(item.data))
            except (IOError, OSError, EOFError, cPickle.PickleError):
                if self.log_debug:
                    log.debug("Couln't load pickle data, creating new storage")
                self.hash = {}
                self._is_new = True
        self.flags = flags
        self.loaded = True
    
    def do_close(self):
        if self.flags is not None and (self.flags == 'c' or self.flags == 'w'):
            if self._is_new:
                item = self.cache(key_name=self.namespace)
                item.data = cPickle.dumps(self.hash)
                item.created = datetime.now()
                item.accessed = datetime.now()
                item.put()
                self._is_new = False
            else:
                item = self.cache.get_by_key_name(self.namespace)
                item.data = cPickle.dumps(self.hash)
                item.accessed = datetime.now()
                item.put()
        self.flags = None
    
    def do_remove(self):
        item = self.cache.get_by_key_name(self.namespace)
        item.delete()
        self.hash = {}
        
        # We can retain the fact that we did a load attempt, but since the
        # file is gone this will be a new namespace should it be saved.
        self._is_new = True

    def __getitem__(self, key):
        return self.hash[key]

    def __contains__(self, key): 
        return self.hash.has_key(key)
        
    def __setitem__(self, key, value):
        self.hash[key] = value

    def __delitem__(self, key):
        del self.hash[key]

    def keys(self):
        return self.hash.keys()
        

class GoogleContainer(Container):
    namespace_class = GoogleNamespaceManager

########NEW FILE########
__FILENAME__ = memcached
from b3.lib.beaker.container import NamespaceManager, Container
from b3.lib.beaker.exceptions import InvalidCacheBackendError, MissingCacheParameter
from b3.lib.beaker.synchronization import file_synchronizer, null_synchronizer
from b3.lib.beaker.util import verify_directory, SyncDict
import warnings

memcache = None

class MemcachedNamespaceManager(NamespaceManager):
    clients = SyncDict()
    
    @classmethod
    def _init_dependencies(cls):
        global memcache
        if memcache is not None:
            return
        try:
            import pylibmc as memcache
        except ImportError:
            try:
                import cmemcache as memcache
                warnings.warn("cmemcache is known to have serious "
                            "concurrency issues; consider using 'memcache' or 'pylibmc'")
            except ImportError:
                try:
                    import memcache
                except ImportError:
                    raise InvalidCacheBackendError("Memcached cache backend requires either "
                                                        "the 'memcache' or 'cmemcache' library")
        
    def __init__(self, namespace, url=None, data_dir=None, lock_dir=None, **params):
        NamespaceManager.__init__(self, namespace)
       
        if not url:
            raise MissingCacheParameter("url is required") 
        
        if lock_dir:
            self.lock_dir = lock_dir
        elif data_dir:
            self.lock_dir = data_dir + "/container_mcd_lock"
        if self.lock_dir:
            verify_directory(self.lock_dir)            
        
        self.mc = MemcachedNamespaceManager.clients.get(url, memcache.Client, url.split(';'))

    def get_creation_lock(self, key):
        return file_synchronizer(
            identifier="memcachedcontainer/funclock/%s" % self.namespace,lock_dir = self.lock_dir)

    def _format_key(self, key):
        return self.namespace + '_' + key.replace(' ', '\302\267')

    def __getitem__(self, key):
        return self.mc.get(self._format_key(key))

    def __contains__(self, key):
        value = self.mc.get(self._format_key(key))
        return value is not None

    def has_key(self, key):
        return key in self

    def set_value(self, key, value, expiretime=None):
        if expiretime:
            self.mc.set(self._format_key(key), value, time=expiretime)
        else:
            self.mc.set(self._format_key(key), value)

    def __setitem__(self, key, value):
        self.set_value(key, value)
        
    def __delitem__(self, key):
        self.mc.delete(self._format_key(key))

    def do_remove(self):
        self.mc.flush_all()
    
    def keys(self):
        raise NotImplementedError("Memcache caching does not support iteration of all cache keys")

class MemcachedContainer(Container):
    namespace_class = MemcachedNamespaceManager

########NEW FILE########
__FILENAME__ = sqla
import cPickle
import logging
import pickle
from datetime import datetime

from b3.lib.beaker.container import OpenResourceNamespaceManager, Container
from b3.lib.beaker.exceptions import InvalidCacheBackendError, MissingCacheParameter
from b3.lib.beaker.synchronization import file_synchronizer, null_synchronizer
from b3.lib.beaker.util import verify_directory, SyncDict


log = logging.getLogger(__name__)

sa = None

class SqlaNamespaceManager(OpenResourceNamespaceManager):
    binds = SyncDict()
    tables = SyncDict()

    @classmethod
    def _init_dependencies(cls):
        global sa
        if sa is not None:
            return
        try:
            import sqlalchemy as sa
        except ImportError:
            raise InvalidCacheBackendError("SQLAlchemy, which is required by "
                                            "this backend, is not installed")

    def __init__(self, namespace, bind, table, data_dir=None, lock_dir=None,
                 **kwargs):
        """Create a namespace manager for use with a database table via
        SQLAlchemy.

        ``bind``
            SQLAlchemy ``Engine`` or ``Connection`` object

        ``table``
            SQLAlchemy ``Table`` object in which to store namespace data.
            This should usually be something created by ``make_cache_table``.
        """
        OpenResourceNamespaceManager.__init__(self, namespace)

        if lock_dir:
            self.lock_dir = lock_dir
        elif data_dir:
            self.lock_dir = data_dir + "/container_db_lock"
        if self.lock_dir:
            verify_directory(self.lock_dir)            

        self.bind = self.__class__.binds.get(str(bind.url), lambda: bind)
        self.table = self.__class__.tables.get('%s:%s' % (bind.url, table.name),
                                               lambda: table)
        self.hash = {}
        self._is_new = False
        self.loaded = False

    def get_access_lock(self):
        return null_synchronizer()

    def get_creation_lock(self, key):
        return file_synchronizer(
            identifier ="databasecontainer/funclock/%s" % self.namespace,
            lock_dir=self.lock_dir)

    def do_open(self, flags):
        if self.loaded:
            self.flags = flags
            return
        select = sa.select([self.table.c.data],
                           (self.table.c.namespace == self.namespace))
        result = self.bind.execute(select).fetchone()
        if not result:
            self._is_new = True
            self.hash = {}
        else:
            self._is_new = False
            try:
                self.hash = result['data']
            except (IOError, OSError, EOFError, cPickle.PickleError,
                    pickle.PickleError):
                log.debug("Couln't load pickle data, creating new storage")
                self.hash = {}
                self._is_new = True
        self.flags = flags
        self.loaded = True

    def do_close(self):
        if self.flags is not None and (self.flags == 'c' or self.flags == 'w'):
            if self._is_new:
                insert = self.table.insert()
                self.bind.execute(insert, namespace=self.namespace, data=self.hash,
                                  accessed=datetime.now(), created=datetime.now())
                self._is_new = False
            else:
                update = self.table.update(self.table.c.namespace == self.namespace)
                self.bind.execute(update, data=self.hash, accessed=datetime.now())
        self.flags = None

    def do_remove(self):
        delete = self.table.delete(self.table.c.namespace == self.namespace)
        self.bind.execute(delete)
        self.hash = {}
        self._is_new = True

    def __getitem__(self, key):
        return self.hash[key]

    def __contains__(self, key):
        return self.hash.has_key(key)

    def __setitem__(self, key, value):
        self.hash[key] = value

    def __delitem__(self, key):
        del self.hash[key]

    def keys(self):
        return self.hash.keys()


class SqlaContainer(Container):
    namespace_manager = SqlaNamespaceManager

def make_cache_table(metadata, table_name='beaker_cache'):
    """Return a ``Table`` object suitable for storing cached values for the
    namespace manager.  Do not create the table."""
    return sa.Table(table_name, metadata,
                    sa.Column('namespace', sa.String(255), primary_key=True),
                    sa.Column('accessed', sa.DateTime, nullable=False),
                    sa.Column('created', sa.DateTime, nullable=False),
                    sa.Column('data', sa.PickleType, nullable=False))

########NEW FILE########
__FILENAME__ = middleware
import warnings

try:
    from paste.registry import StackedObjectProxy
    beaker_session = StackedObjectProxy(name="Beaker Session")
    beaker_cache = StackedObjectProxy(name="Cache Manager")
except:
    beaker_cache = None
    beaker_session = None

from b3.lib.beaker.cache import CacheManager
from b3.lib.beaker.session import Session, SessionObject
from b3.lib.beaker.util import coerce_cache_params, coerce_session_params, \
    parse_cache_config_options


class CacheMiddleware(object):
    cache = beaker_cache
    
    def __init__(self, app, config=None, environ_key='beaker.cache', **kwargs):
        """Initialize the Cache Middleware
        
        The Cache middleware will make a Cache instance available
        every request under the ``environ['beaker.cache']`` key by
        default. The location in environ can be changed by setting
        ``environ_key``.
        
        ``config``
            dict  All settings should be prefixed by 'cache.'. This
            method of passing variables is intended for Paste and other
            setups that accumulate multiple component settings in a
            single dictionary. If config contains *no cache. prefixed
            args*, then *all* of the config options will be used to
            intialize the Cache objects.
        
        ``environ_key``
            Location where the Cache instance will keyed in the WSGI
            environ
        
        ``**kwargs``
            All keyword arguments are assumed to be cache settings and
            will override any settings found in ``config``

        """
        self.app = app
        config = config or {}
        
        self.options = {}
        
        # Update the options with the parsed config
        self.options.update(parse_cache_config_options(config))
        
        # Add any options from kwargs, but leave out the defaults this
        # time
        self.options.update(
            parse_cache_config_options(kwargs, include_defaults=False))
                
        # Assume all keys are intended for cache if none are prefixed with
        # 'cache.'
        if not self.options and config:
            self.options = config
        
        self.options.update(kwargs)
        self.cache_manager = CacheManager(**self.options)
        self.environ_key = environ_key
    
    def __call__(self, environ, start_response):
        if environ.get('paste.registry'):
            if environ['paste.registry'].reglist:
                environ['paste.registry'].register(self.cache,
                                                   self.cache_manager)
        environ[self.environ_key] = self.cache_manager
        return self.app(environ, start_response)


class SessionMiddleware(object):
    session = beaker_session
    
    def __init__(self, wrap_app, config=None, environ_key='beaker.session',
                 **kwargs):
        """Initialize the Session Middleware
        
        The Session middleware will make a lazy session instance
        available every request under the ``environ['beaker.session']``
        key by default. The location in environ can be changed by
        setting ``environ_key``.
        
        ``config``
            dict  All settings should be prefixed by 'session.'. This
            method of passing variables is intended for Paste and other
            setups that accumulate multiple component settings in a
            single dictionary. If config contains *no cache. prefixed
            args*, then *all* of the config options will be used to
            intialize the Cache objects.
        
        ``environ_key``
            Location where the Session instance will keyed in the WSGI
            environ
        
        ``**kwargs``
            All keyword arguments are assumed to be session settings and
            will override any settings found in ``config``

        """
        config = config or {}
        
        # Load up the default params
        self.options = dict(invalidate_corrupt=True, type=None, 
                           data_dir=None, key='beaker.session.id', 
                           timeout=None, secret=None, log_file=None)

        # Pull out any config args meant for beaker session. if there are any
        for dct in [config, kwargs]:
            for key, val in dct.iteritems():
                if key.startswith('beaker.session.'):
                    self.options[key[15:]] = val
                if key.startswith('session.'):
                    self.options[key[8:]] = val
                if key.startswith('session_'):
                    warnings.warn('Session options should start with session. '
                                  'instead of session_.', DeprecationWarning, 2)
                    self.options[key[8:]] = val
        
        # Coerce and validate session params
        coerce_session_params(self.options)
        
        # Assume all keys are intended for cache if none are prefixed with
        # 'cache.'
        if not self.options and config:
            self.options = config
        
        self.options.update(kwargs)
        self.wrap_app = wrap_app
        self.environ_key = environ_key
        
    def __call__(self, environ, start_response):
        session = SessionObject(environ, **self.options)
        if environ.get('paste.registry'):
            if environ['paste.registry'].reglist:
                environ['paste.registry'].register(self.session, session)
        environ[self.environ_key] = session
        environ['beaker.get_session'] = self._get_session
        
        def session_start_response(status, headers, exc_info = None):
            if session.accessed():
                session.persist()
                if session.__dict__['_headers']['set_cookie']:
                    cookie = session.__dict__['_headers']['cookie_out']
                    if cookie:
                        headers.append(('Set-cookie', cookie))
            return start_response(status, headers, exc_info)
        return self.wrap_app(environ, session_start_response)
    
    def _get_session(self):
        return Session({}, use_cookies=False, **self.options)


def session_filter_factory(global_conf, **kwargs):
    def filter(app):
        return SessionMiddleware(app, global_conf, **kwargs)
    return filter


def session_filter_app_factory(app, global_conf, **kwargs):
    return SessionMiddleware(app, global_conf, **kwargs)

########NEW FILE########
__FILENAME__ = session
import Cookie
import os
import random
import time
from datetime import datetime, timedelta
    
from b3.lib.beaker.crypto import hmac as HMAC, hmac_sha1 as SHA1, md5
from b3.lib.beaker.util import pickle

from b3.lib.beaker import crypto
from b3.lib.beaker.cache import clsmap
from b3.lib.beaker.exceptions import BeakerException, InvalidCryptoBackendError
from base64 import b64encode, b64decode


__all__ = ['SignedCookie', 'Session']

getpid = hasattr(os, 'getpid') and os.getpid or (lambda : '')

class SignedCookie(Cookie.BaseCookie):
    """Extends python cookie to give digital signature support"""
    def __init__(self, secret, input=None):
        self.secret = secret
        Cookie.BaseCookie.__init__(self, input)
    
    def value_decode(self, val):
        val = val.strip('"')
        sig = HMAC.new(self.secret, val[40:], SHA1).hexdigest()
        
        # Avoid timing attacks
        invalid_bits = 0
        input_sig = val[:40]
        if len(sig) != len(input_sig):
            return None, val
        
        for a, b in zip(sig, input_sig):
            invalid_bits += a != b
        
        if invalid_bits:
            return None, val
        else:
            return val[40:], val
    
    def value_encode(self, val):
        sig = HMAC.new(self.secret, val, SHA1).hexdigest()
        return str(val), ("%s%s" % (sig, val))


class Session(dict):
    """Session object that uses container package for storage.
    
    ``key``
        The name the cookie should be set to.
    ``timeout``
        How long session data is considered valid. This is used 
        regardless of the cookie being present or not to determine
        whether session data is still valid.
    ``cookie_domain``
        Domain to use for the cookie.
    ``secure``
        Whether or not the cookie should only be sent over SSL.
    """
    def __init__(self, request, id=None, invalidate_corrupt=False,
                 use_cookies=True, type=None, data_dir=None,
                 key='beaker.session.id', timeout=None, cookie_expires=True,
                 cookie_domain=None, secret=None, secure=False,
                 namespace_class=None, **namespace_args):
        if not type:
            if data_dir:
                self.type = 'file'
            else:
                self.type = 'memory'
        else:
            self.type = type

        self.namespace_class = namespace_class or clsmap[self.type]

        self.namespace_args = namespace_args
        
        self.request = request
        self.data_dir = data_dir
        self.key = key
        
        self.timeout = timeout
        self.use_cookies = use_cookies
        self.cookie_expires = cookie_expires
        
        # Default cookie domain/path
        self._domain = cookie_domain
        self._path = '/'
        self.was_invalidated = False
        self.secret = secret
        self.secure = secure
        self.id = id
        self.accessed_dict = {}
        
        if self.use_cookies:
            cookieheader = request.get('cookie', '')
            if secret:
                try:
                    self.cookie = SignedCookie(secret, input=cookieheader)
                except Cookie.CookieError:
                    self.cookie = SignedCookie(secret, input=None)
            else:
                self.cookie = Cookie.SimpleCookie(input=cookieheader)
            
            if not self.id and self.key in self.cookie:
                self.id = self.cookie[self.key].value
        
        self.is_new = self.id is None
        if self.is_new:
            self._create_id()
            self['_accessed_time'] = self['_creation_time'] = time.time()
        else:
            try:
                self.load()
            except:
                if invalidate_corrupt:
                    self.invalidate()
                else:
                    raise
        
    def _create_id(self):
        self.id = md5(
            md5("%f%s%f%s" % (time.time(), id({}), random.random(),
                              getpid())).hexdigest(), 
        ).hexdigest()
        self.is_new = True
        self.last_accessed = None
        if self.use_cookies:
            self.cookie[self.key] = self.id
            if self._domain:
                self.cookie[self.key]['domain'] = self._domain
            if self.secure:
                self.cookie[self.key]['secure'] = True
            self.cookie[self.key]['path'] = self._path
            if self.cookie_expires is not True:
                if self.cookie_expires is False:
                    expires = datetime.fromtimestamp( 0x7FFFFFFF )
                elif isinstance(self.cookie_expires, timedelta):
                    expires = datetime.today() + self.cookie_expires
                elif isinstance(self.cookie_expires, datetime):
                    expires = self.cookie_expires
                else:
                    raise ValueError("Invalid argument for cookie_expires: %s"
                                     % repr(self.cookie_expires))
                self.cookie[self.key]['expires'] = \
                    expires.strftime("%a, %d-%b-%Y %H:%M:%S GMT" )
            self.request['cookie_out'] = self.cookie[self.key].output(header='')
            self.request['set_cookie'] = False
    
    def created(self):
        return self['_creation_time']
    created = property(created)
    
    def _set_domain(self, domain):
        self['_domain'] = domain
        self.cookie[self.key]['domain'] = domain
        self.request['cookie_out'] = self.cookie[self.key].output(header='')
        self.request['set_cookie'] = True
    
    def _get_domain(self):
        return self._domain
    
    domain = property(_get_domain, _set_domain)
    
    def _set_path(self, path):
        self['_path'] = path
        self.cookie[self.key]['path'] = path
        self.request['cookie_out'] = self.cookie[self.key].output(header='')
        self.request['set_cookie'] = True
    
    def _get_path(self):
        return self._path
    
    path = property(_get_path, _set_path)

    def _delete_cookie(self):
        self.request['set_cookie'] = True
        self.cookie[self.key] = self.id
        if self._domain:
            self.cookie[self.key]['domain'] = self._domain
        if self.secure:
            self.cookie[self.key]['secure'] = True
        self.cookie[self.key]['path'] = '/'
        expires = datetime.today().replace(year=2003)
        self.cookie[self.key]['expires'] = \
            expires.strftime("%a, %d-%b-%Y %H:%M:%S GMT" )
        self.request['cookie_out'] = self.cookie[self.key].output(header='')
        self.request['set_cookie'] = True

    def delete(self):
        """Deletes the session from the persistent storage, and sends
        an expired cookie out"""
        if self.use_cookies:
            self._delete_cookie()
        self.clear()

    def invalidate(self):
        """Invalidates this session, creates a new session id, returns
        to the is_new state"""
        self.clear()
        self.was_invalidated = True
        self._create_id()
        self.load()
    
    def load(self):
        "Loads the data from this session from persistent storage"
        self.namespace = self.namespace_class(self.id,
            data_dir=self.data_dir, digest_filenames=False,
            **self.namespace_args)
        now = time.time()
        self.request['set_cookie'] = True
        
        self.namespace.acquire_read_lock()
        timed_out = False
        try:
            self.clear()
            try:
                session_data = self.namespace['session']

                # Memcached always returns a key, its None when its not
                # present
                if session_data is None:
                    session_data = {
                        '_creation_time':now,
                        '_accessed_time':now
                    }
                    self.is_new = True
            except (KeyError, TypeError):
                session_data = {
                    '_creation_time':now,
                    '_accessed_time':now
                }
                self.is_new = True
            
            if self.timeout is not None and \
               now - session_data['_accessed_time'] > self.timeout:
                timed_out= True
            else:
                # Properly set the last_accessed time, which is different
                # than the *currently* _accessed_time
                if self.is_new or '_accessed_time' not in session_data:
                    self.last_accessed = None
                else:
                    self.last_accessed = session_data['_accessed_time']
                
                # Update the current _accessed_time
                session_data['_accessed_time'] = now
                self.update(session_data)
                self.accessed_dict = session_data.copy()                
        finally:
            self.namespace.release_read_lock()
        if timed_out:
            self.invalidate()
    
    def save(self, accessed_only=False):
        """Saves the data for this session to persistent storage
        
        If accessed_only is True, then only the original data loaded
        at the beginning of the request will be saved, with the updated
        last accessed time.
        
        """
        # Look to see if its a new session that was only accessed
        # Don't save it under that case
        if accessed_only and self.is_new:
            return None
        
        if not hasattr(self, 'namespace'):
            self.namespace = self.namespace_class(
                                    self.id, 
                                    data_dir=self.data_dir,
                                    digest_filenames=False, 
                                    **self.namespace_args)
        
        self.namespace.acquire_write_lock()
        try:
            if accessed_only:
                data = dict(self.accessed_dict.items())
            else:
                data = dict(self.items())
            
            # Save the data
            if not data and 'session' in self.namespace:
                del self.namespace['session']
            else:
                self.namespace['session'] = data
        finally:
            self.namespace.release_write_lock()
        if self.is_new:
            self.request['set_cookie'] = True
    
    def revert(self):
        """Revert the session to its original state from its first
        access in the request"""
        self.clear()
        self.update(self.accessed_dict)
    
    # TODO: I think both these methods should be removed.  They're from
    # the original mod_python code i was ripping off but they really
    # have no use here.
    def lock(self):
        """Locks this session against other processes/threads.  This is
        automatic when load/save is called.
        
        ***use with caution*** and always with a corresponding 'unlock'
        inside a "finally:" block, as a stray lock typically cannot be
        unlocked without shutting down the whole application.

        """
        self.namespace.acquire_write_lock()

    def unlock(self):
        """Unlocks this session against other processes/threads.  This
        is automatic when load/save is called.

        ***use with caution*** and always within a "finally:" block, as
        a stray lock typically cannot be unlocked without shutting down
        the whole application.

        """
        self.namespace.release_write_lock()

class CookieSession(Session):
    """Pure cookie-based session
    
    Options recognized when using cookie-based sessions are slightly
    more restricted than general sessions.
    
    ``key``
        The name the cookie should be set to.
    ``timeout``
        How long session data is considered valid. This is used 
        regardless of the cookie being present or not to determine
        whether session data is still valid.
    ``encrypt_key``
        The key to use for the session encryption, if not provided the
        session will not be encrypted.
    ``validate_key``
        The key used to sign the encrypted session
    ``cookie_domain``
        Domain to use for the cookie.
    ``secure``
        Whether or not the cookie should only be sent over SSL.
    
    """
    def __init__(self, request, key='beaker.session.id', timeout=None,
                 cookie_expires=True, cookie_domain=None, encrypt_key=None,
                 validate_key=None, secure=False, **kwargs):
        
        if not crypto.has_aes and encrypt_key:
            raise InvalidCryptoBackendError("No AES library is installed, can't generate "
                                  "encrypted cookie-only Session.")
        
        self.request = request
        self.key = key
        self.timeout = timeout
        self.cookie_expires = cookie_expires
        self.encrypt_key = encrypt_key
        self.validate_key = validate_key
        self.request['set_cookie'] = False
        self.secure = secure
        self._domain = cookie_domain
        self._path = '/'
        
        try:
            cookieheader = request['cookie']
        except KeyError:
            cookieheader = ''
        
        if validate_key is None:
            raise BeakerException("No validate_key specified for Cookie only "
                                  "Session.")
        
        try:
            self.cookie = SignedCookie(validate_key, input=cookieheader)
        except Cookie.CookieError:
            self.cookie = SignedCookie(validate_key, input=None)
        
        self['_id'] = self._make_id()
        self.is_new = True
        
        # If we have a cookie, load it
        if self.key in self.cookie and self.cookie[self.key].value is not None:
            self.is_new = False
            try:
                self.update(self._decrypt_data())
            except:
                pass
            if self.timeout is not None and time.time() - \
               self['_accessed_time'] > self.timeout:
                self.clear()
            self.accessed_dict = self.copy()
            self._create_cookie()
    
    def created(self):
        return self['_creation_time']
    created = property(created)
    
    def id(self):
        return self['_id']
    id = property(id)

    def _set_domain(self, domain):
        self['_domain'] = domain
        self._domain = domain
        
    def _get_domain(self):
        return self._domain
    
    domain = property(_get_domain, _set_domain)
    
    def _set_path(self, path):
        self['_path'] = path
        self._path = path
    
    def _get_path(self):
        return self._path
    
    path = property(_get_path, _set_path)

    def _encrypt_data(self):
        """Serialize, encipher, and base64 the session dict"""
        if self.encrypt_key:
            nonce = b64encode(os.urandom(40))[:8]
            encrypt_key = crypto.generateCryptoKeys(self.encrypt_key,
                                             self.validate_key + nonce, 1)
            data = pickle.dumps(self.copy(), 2)
            return nonce + b64encode(crypto.aesEncrypt(data, encrypt_key))
        else:
            data = pickle.dumps(self.copy(), 2)
            return b64encode(data)
    
    def _decrypt_data(self):
        """Bas64, decipher, then un-serialize the data for the session
        dict"""
        if self.encrypt_key:
            nonce = self.cookie[self.key].value[:8]
            encrypt_key = crypto.generateCryptoKeys(self.encrypt_key,
                                             self.validate_key + nonce, 1)
            payload = b64decode(self.cookie[self.key].value[8:])
            data = crypto.aesDecrypt(payload, encrypt_key)
            return pickle.loads(data)
        else:
            data = b64decode(self.cookie[self.key].value)
            return pickle.loads(data)
    
    def _make_id(self):
        return md5(md5(
            "%f%s%f%s" % (time.time(), id({}), random.random(), getpid())
            ).hexdigest()
        ).hexdigest()
    
    def save(self, accessed_only=False):
        """Saves the data for this session to persistent storage"""
        if accessed_only and self.is_new:
            return
        if accessed_only:
            self.clear()
            self.update(self.accessed_dict)
        self._create_cookie()
    
    def expire(self):
        """Delete the 'expires' attribute on this Session, if any."""
        
        self.pop('_expires', None)
        
    def _create_cookie(self):
        if '_creation_time' not in self:
            self['_creation_time'] = time.time()
        if '_id' not in self:
            self['_id'] = self._make_id()
        self['_accessed_time'] = time.time()
        
        if self.cookie_expires is not True:
            if self.cookie_expires is False:
                expires = datetime.fromtimestamp( 0x7FFFFFFF )
            elif isinstance(self.cookie_expires, timedelta):
                expires = datetime.today() + self.cookie_expires
            elif isinstance(self.cookie_expires, datetime):
                expires = self.cookie_expires
            else:
                raise ValueError("Invalid argument for cookie_expires: %s"
                                 % repr(self.cookie_expires))
            self['_expires'] = expires
        elif '_expires' in self:
            expires = self['_expires']
        else:
            expires = None

        val = self._encrypt_data()
        if len(val) > 4064:
            raise BeakerException("Cookie value is too long to store")
        
        self.cookie[self.key] = val
        if '_domain' in self:
            self.cookie[self.key]['domain'] = self['_domain']
        elif self._domain:
            self.cookie[self.key]['domain'] = self._domain
        if self.secure:
            self.cookie[self.key]['secure'] = True
        
        self.cookie[self.key]['path'] = self.get('_path', '/')
        
        if expires:
            self.cookie[self.key]['expires'] = \
                expires.strftime("%a, %d-%b-%Y %H:%M:%S GMT" )
        self.request['cookie_out'] = self.cookie[self.key].output(header='')
        self.request['set_cookie'] = True
    
    def delete(self):
        """Delete the cookie, and clear the session"""
        # Send a delete cookie request
        self._delete_cookie()
        self.clear()
    
    def invalidate(self):
        """Clear the contents and start a new session"""
        self.delete()
        self['_id'] = self._make_id()


class SessionObject(object):
    """Session proxy/lazy creator
    
    This object proxies access to the actual session object, so that in
    the case that the session hasn't been used before, it will be
    setup. This avoid creating and loading the session from persistent
    storage unless its actually used during the request.
    
    """
    def __init__(self, environ, **params):
        self.__dict__['_params'] = params
        self.__dict__['_environ'] = environ
        self.__dict__['_sess'] = None
        self.__dict__['_headers'] = []
    
    def _session(self):
        """Lazy initial creation of session object"""
        if self.__dict__['_sess'] is None:
            params = self.__dict__['_params']
            environ = self.__dict__['_environ']
            self.__dict__['_headers'] = req = {'cookie_out':None}
            req['cookie'] = environ.get('HTTP_COOKIE')
            if params.get('type') == 'cookie':
                self.__dict__['_sess'] = CookieSession(req, **params)
            else:
                self.__dict__['_sess'] = Session(req, use_cookies=True,
                                                 **params)
        return self.__dict__['_sess']
    
    def __getattr__(self, attr):
        return getattr(self._session(), attr)
    
    def __setattr__(self, attr, value):
        setattr(self._session(), attr, value)
    
    def __delattr__(self, name):
        self._session().__delattr__(name)
    
    def __getitem__(self, key):
        return self._session()[key]
    
    def __setitem__(self, key, value):
        self._session()[key] = value
    
    def __delitem__(self, key):
        self._session().__delitem__(key)
    
    def __repr__(self):
        return self._session().__repr__()
    
    def __iter__(self):
        """Only works for proxying to a dict"""
        return iter(self._session().keys())
    
    def __contains__(self, key):
        return self._session().has_key(key)
    
    def get_by_id(self, id):
        """Loads a session given a session ID"""
        params = self.__dict__['_params']
        session = Session({}, use_cookies=False, id=id, **params)
        if session.is_new:
            return None
        return session
    
    def save(self):
        self.__dict__['_dirty'] = True
    
    def delete(self):
        self.__dict__['_dirty'] = True
        self._session().delete()
    
    def persist(self):
        """Persist the session to the storage
        
        If its set to autosave, then the entire session will be saved
        regardless of if save() has been called. Otherwise, just the
        accessed time will be updated if save() was not called, or
        the session will be saved if save() was called.
        
        """
        if self.__dict__['_params'].get('auto'):
            self._session().save()
        else:
            if self.__dict__.get('_dirty'):
                self._session().save()
            else:
                self._session().save(accessed_only=True)
    
    def dirty(self):
        return self.__dict__.get('_dirty', False)
    
    def accessed(self):
        """Returns whether or not the session has been accessed"""
        return self.__dict__['_sess'] is not None

########NEW FILE########
__FILENAME__ = synchronization
"""Synchronization functions.

File- and mutex-based mutual exclusion synchronizers are provided,
as well as a name-based mutex which locks within an application
based on a string name.

"""

import os
import sys
import tempfile

try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading

# check for fcntl module
try:
    sys.getwindowsversion()
    has_flock = False
except:
    try:
        import fcntl
        has_flock = True
    except ImportError:
        has_flock = False

from b3.lib.beaker import util
from b3.lib.beaker.exceptions import LockError

__all__  = ["file_synchronizer", "mutex_synchronizer", "null_synchronizer",
            "NameLock", "_threading"]


class NameLock(object):
    """a proxy for an RLock object that is stored in a name based
    registry.  
    
    Multiple threads can get a reference to the same RLock based on the
    name alone, and synchronize operations related to that name.

    """     
    locks = util.WeakValuedRegistry()

    class NLContainer(object):
        def __init__(self, reentrant):
            if reentrant:
                self.lock = _threading.RLock()
            else:
                self.lock = _threading.Lock()
        def __call__(self):
            return self.lock

    def __init__(self, identifier = None, reentrant = False):
        if identifier is None:
            self._lock = NameLock.NLContainer(reentrant)
        else:
            self._lock = NameLock.locks.get(identifier, NameLock.NLContainer,
                                            reentrant)

    def acquire(self, wait = True):
        return self._lock().acquire(wait)

    def release(self):
        self._lock().release()


_synchronizers = util.WeakValuedRegistry()
def _synchronizer(identifier, cls, **kwargs):
    return _synchronizers.sync_get((identifier, cls), cls, identifier, **kwargs)


def file_synchronizer(identifier, **kwargs):
    if not has_flock or 'lock_dir' not in kwargs:
        return mutex_synchronizer(identifier)
    else:
        return _synchronizer(identifier, FileSynchronizer, **kwargs)


def mutex_synchronizer(identifier, **kwargs):
    return _synchronizer(identifier, ConditionSynchronizer, **kwargs)


class null_synchronizer(object):
    def acquire_write_lock(self, wait=True):
        return True
    def acquire_read_lock(self):
        pass
    def release_write_lock(self):
        pass
    def release_read_lock(self):
        pass
    acquire = acquire_write_lock
    release = release_write_lock


class SynchronizerImpl(object):
    def __init__(self):
        self._state = util.ThreadLocal()

    class SyncState(object):
        __slots__ = 'reentrantcount', 'writing', 'reading'

        def __init__(self):
            self.reentrantcount = 0
            self.writing = False
            self.reading = False

    def state(self):
        if not self._state.has():
            state = SynchronizerImpl.SyncState()
            self._state.put(state)
            return state
        else:
            return self._state.get()
    state = property(state)
    
    def release_read_lock(self):
        state = self.state

        if state.writing: 
            raise LockError("lock is in writing state")
        if not state.reading: 
            raise LockError("lock is not in reading state")
        
        if state.reentrantcount == 1:
            self.do_release_read_lock()
            state.reading = False

        state.reentrantcount -= 1
        
    def acquire_read_lock(self, wait = True):
        state = self.state

        if state.writing: 
            raise LockError("lock is in writing state")
        
        if state.reentrantcount == 0:
            x = self.do_acquire_read_lock(wait)
            if (wait or x):
                state.reentrantcount += 1
                state.reading = True
            return x
        elif state.reading:
            state.reentrantcount += 1
            return True
            
    def release_write_lock(self):
        state = self.state

        if state.reading: 
            raise LockError("lock is in reading state")
        if not state.writing: 
            raise LockError("lock is not in writing state")

        if state.reentrantcount == 1:
            self.do_release_write_lock()
            state.writing = False

        state.reentrantcount -= 1
    
    release = release_write_lock
    
    def acquire_write_lock(self, wait  = True):
        state = self.state

        if state.reading: 
            raise LockError("lock is in reading state")
        
        if state.reentrantcount == 0:
            x = self.do_acquire_write_lock(wait)
            if (wait or x): 
                state.reentrantcount += 1
                state.writing = True
            return x
        elif state.writing:
            state.reentrantcount += 1
            return True

    acquire = acquire_write_lock

    def do_release_read_lock(self):
        raise NotImplementedError()
    
    def do_acquire_read_lock(self):
        raise NotImplementedError()
    
    def do_release_write_lock(self):
        raise NotImplementedError()
    
    def do_acquire_write_lock(self):
        raise NotImplementedError()


class FileSynchronizer(SynchronizerImpl):
    """a synchronizer which locks using flock().

    Adapted for Python/multithreads from Apache::Session::Lock::File,
    http://search.cpan.org/src/CWEST/Apache-Session-1.81/Session/Lock/File.pm
    
    This module does not unlink temporary files, 
    because it interferes with proper locking.  This can cause 
    problems on certain systems (Linux) whose file systems (ext2) do not 
    perform well with lots of files in one directory.  To prevent this
    you should use a script to clean out old files from your lock directory.
    
    """
    def __init__(self, identifier, lock_dir):
        super(FileSynchronizer, self).__init__()
        self._filedescriptor = util.ThreadLocal()
        
        if lock_dir is None:
            lock_dir = tempfile.gettempdir()
        else:
            lock_dir = lock_dir

        self.filename = util.encoded_path(
                            lock_dir, 
                            [identifier], 
                            extension='.lock'
                        )

    def _filedesc(self):
        return self._filedescriptor.get()
    _filedesc = property(_filedesc)
        
    def _open(self, mode):
        filedescriptor = self._filedesc
        if filedescriptor is None:
            filedescriptor = os.open(self.filename, mode)
            self._filedescriptor.put(filedescriptor)
        return filedescriptor
            
    def do_acquire_read_lock(self, wait):
        filedescriptor = self._open(os.O_CREAT | os.O_RDONLY)
        if not wait:
            try:
                fcntl.flock(filedescriptor, fcntl.LOCK_SH | fcntl.LOCK_NB)
                return True
            except IOError:
                os.close(filedescriptor)
                self._filedescriptor.remove()
                return False
        else:
            fcntl.flock(filedescriptor, fcntl.LOCK_SH)
            return True

    def do_acquire_write_lock(self, wait):
        filedescriptor = self._open(os.O_CREAT | os.O_WRONLY)
        if not wait:
            try:
                fcntl.flock(filedescriptor, fcntl.LOCK_EX | fcntl.LOCK_NB)
                return True
            except IOError:
                os.close(filedescriptor)
                self._filedescriptor.remove()
                return False
        else:
            fcntl.flock(filedescriptor, fcntl.LOCK_EX)
            return True
    
    def do_release_read_lock(self):
        self._release_all_locks()
    
    def do_release_write_lock(self):
        self._release_all_locks()
    
    def _release_all_locks(self):
        filedescriptor = self._filedesc
        if filedescriptor is not None:
            fcntl.flock(filedescriptor, fcntl.LOCK_UN)
            os.close(filedescriptor)
            self._filedescriptor.remove()


class ConditionSynchronizer(SynchronizerImpl):
    """a synchronizer using a Condition."""
    
    def __init__(self, identifier):
        super(ConditionSynchronizer, self).__init__()

        # counts how many asynchronous methods are executing
        self.async = 0

        # pointer to thread that is the current sync operation
        self.current_sync_operation = None

        # condition object to lock on
        self.condition = _threading.Condition(_threading.Lock())

    def do_acquire_read_lock(self, wait = True):    
        self.condition.acquire()
        try:
            # see if a synchronous operation is waiting to start
            # or is already running, in which case we wait (or just
            # give up and return)
            if wait:
                while self.current_sync_operation is not None:
                    self.condition.wait()
            else:
                if self.current_sync_operation is not None:
                    return False

            self.async += 1
        finally:
            self.condition.release()

        if not wait: 
            return True
        
    def do_release_read_lock(self):
        self.condition.acquire()
        try:
            self.async -= 1
        
            # check if we are the last asynchronous reader thread 
            # out the door.
            if self.async == 0:
                # yes. so if a sync operation is waiting, notifyAll to wake
                # it up
                if self.current_sync_operation is not None:
                    self.condition.notifyAll()
            elif self.async < 0:
                raise LockError("Synchronizer error - too many "
                                "release_read_locks called")
        finally:
            self.condition.release()
    
    def do_acquire_write_lock(self, wait = True):
        self.condition.acquire()
        try:
            # here, we are not a synchronous reader, and after returning,
            # assuming waiting or immediate availability, we will be.
        
            if wait:
                # if another sync is working, wait
                while self.current_sync_operation is not None:
                    self.condition.wait()
            else:
                # if another sync is working,
                # we dont want to wait, so forget it
                if self.current_sync_operation is not None:
                    return False
            
            # establish ourselves as the current sync 
            # this indicates to other read/write operations
            # that they should wait until this is None again
            self.current_sync_operation = _threading.currentThread()

            # now wait again for asyncs to finish
            if self.async > 0:
                if wait:
                    # wait
                    self.condition.wait()
                else:
                    # we dont want to wait, so forget it
                    self.current_sync_operation = None
                    return False
        finally:
            self.condition.release()
        
        if not wait: 
            return True

    def do_release_write_lock(self):
        self.condition.acquire()
        try:
            if self.current_sync_operation is not _threading.currentThread():
                raise LockError("Synchronizer error - current thread doesnt "
                                "have the write lock")

            # reset the current sync operation so 
            # another can get it
            self.current_sync_operation = None

            # tell everyone to get ready
            self.condition.notifyAll()
        finally:
            # everyone go !!
            self.condition.release()

########NEW FILE########
__FILENAME__ = util
"""Beaker utilities"""

try:
    import thread as _thread
    import threading as _threading
except ImportError:
    import dummy_thread as _thread
    import dummy_threading as _threading

from datetime import datetime, timedelta
import os
import string
import types
import weakref
import warnings
import sys

py3k = getattr(sys, 'py3kwarning', False) or sys.version_info >= (3, 0)
py24 = sys.version_info < (2,5)
jython = sys.platform.startswith('java')

if py3k or jython:
    import pickle
else:
    import cPickle as pickle

from b3.lib.beaker.converters import asbool
from threading import local as _tlocal


__all__  = ["ThreadLocal", "Registry", "WeakValuedRegistry", "SyncDict",
            "encoded_path", "verify_directory"]


def verify_directory(dir):
    """verifies and creates a directory.  tries to
    ignore collisions with other threads and processes."""

    tries = 0
    while not os.access(dir, os.F_OK):
        try:
            tries += 1
            os.makedirs(dir)
        except:
            if tries > 5:
                raise

    
def deprecated(message):
    def wrapper(fn):
        def deprecated_method(*args, **kargs):
            warnings.warn(message, DeprecationWarning, 2)
            return fn(*args, **kargs)
        # TODO: use decorator ?  functools.wrapper ?
        deprecated_method.__name__ = fn.__name__
        deprecated_method.__doc__ = "%s\n\n%s" % (message, fn.__doc__)
        return deprecated_method
    return wrapper
    
class ThreadLocal(object):
    """stores a value on a per-thread basis"""

    __slots__ = '_tlocal'

    def __init__(self):
        self._tlocal = _tlocal()
    
    def put(self, value):
        self._tlocal.value = value
    
    def has(self):
        return hasattr(self._tlocal, 'value')
            
    def get(self, default=None):
        return getattr(self._tlocal, 'value', default)
            
    def remove(self):
        del self._tlocal.value
    
class SyncDict(object):
    """
    An efficient/threadsafe singleton map algorithm, a.k.a.
    "get a value based on this key, and create if not found or not
    valid" paradigm:
    
        exists && isvalid ? get : create

    Designed to work with weakref dictionaries to expect items
    to asynchronously disappear from the dictionary.  

    Use python 2.3.3 or greater !  a major bug was just fixed in Nov.
    2003 that was driving me nuts with garbage collection/weakrefs in
    this section.

    """    
    def __init__(self):
        self.mutex = _thread.allocate_lock()
        self.dict = {}
        
    def get(self, key, createfunc, *args, **kwargs):
        try:
            if self.has_key(key):
                return self.dict[key]
            else:
                return self.sync_get(key, createfunc, *args, **kwargs)
        except KeyError:
            return self.sync_get(key, createfunc, *args, **kwargs)

    def sync_get(self, key, createfunc, *args, **kwargs):
        self.mutex.acquire()
        try:
            try:
                if self.has_key(key):
                    return self.dict[key]
                else:
                    return self._create(key, createfunc, *args, **kwargs)
            except KeyError:
                return self._create(key, createfunc, *args, **kwargs)
        finally:
            self.mutex.release()

    def _create(self, key, createfunc, *args, **kwargs):
        self[key] = obj = createfunc(*args, **kwargs)
        return obj

    def has_key(self, key):
        return self.dict.has_key(key)
        
    def __contains__(self, key):
        return self.dict.__contains__(key)
    def __getitem__(self, key):
        return self.dict.__getitem__(key)
    def __setitem__(self, key, value):
        self.dict.__setitem__(key, value)
    def __delitem__(self, key):
        return self.dict.__delitem__(key)
    def clear(self):
        self.dict.clear()


class WeakValuedRegistry(SyncDict):
    def __init__(self):
        self.mutex = _threading.RLock()
        self.dict = weakref.WeakValueDictionary()

sha1 = None            
def encoded_path(root, identifiers, extension = ".enc", depth = 3,
                 digest_filenames=True):
                 
    """Generate a unique file-accessible path from the given list of
    identifiers starting at the given root directory."""
    ident = "_".join(identifiers)
    
    global sha1
    if sha1 is None:
        from b3.lib.beaker.crypto import sha1
        
    if digest_filenames:
        if py3k:
            ident = sha1(ident.encode('utf-8')).hexdigest()
        else:
            ident = sha1(ident).hexdigest()
    
    ident = os.path.basename(ident)

    tokens = []
    for d in range(1, depth):
        tokens.append(ident[0:d])
    
    dir = os.path.join(root, *tokens)
    verify_directory(dir)
    
    return os.path.join(dir, ident + extension)


def verify_options(opt, types, error):
    if not isinstance(opt, types):
        if not isinstance(types, tuple):
            types = (types,)
        coerced = False
        for typ in types:
            try:
                if typ in (list, tuple):
                    opt = [x.strip() for x in opt.split(',')]
                else:
                    if typ == bool:
                        typ = asbool
                    opt = typ(opt)
                coerced = True
            except:
                pass
            if coerced:
                break
        if not coerced:
            raise Exception(error)
    elif isinstance(opt, str) and not opt.strip():
        raise Exception("Empty strings are invalid for: %s" % error)
    return opt


def verify_rules(params, ruleset):
    for key, types, message in ruleset:
        if key in params:
            params[key] = verify_options(params[key], types, message)
    return params


def coerce_session_params(params):
    rules = [
        ('data_dir', (str, types.NoneType), "data_dir must be a string "
         "referring to a directory."),
        ('lock_dir', (str, types.NoneType), "lock_dir must be a string referring to a "
         "directory."),
        ('type', (str, types.NoneType), "Session type must be a string."),
        ('cookie_expires', (bool, datetime, timedelta), "Cookie expires was "
         "not a boolean, datetime, or timedelta instance."),
        ('cookie_domain', (str, types.NoneType), "Cookie domain must be a "
         "string."),
        ('id', (str,), "Session id must be a string."),
        ('key', (str,), "Session key must be a string."),
        ('secret', (str, types.NoneType), "Session secret must be a string."),
        ('validate_key', (str, types.NoneType), "Session encrypt_key must be "
         "a string."),
        ('encrypt_key', (str, types.NoneType), "Session validate_key must be "
         "a string."),
        ('secure', (bool, types.NoneType), "Session secure must be a boolean."),
        ('timeout', (int, types.NoneType), "Session timeout must be an "
         "integer."),
        ('auto', (bool, types.NoneType), "Session is created if accessed."),
    ]
    return verify_rules(params, rules)


def coerce_cache_params(params):
    rules = [
        ('data_dir', (str, types.NoneType), "data_dir must be a string "
         "referring to a directory."),
        ('lock_dir', (str, types.NoneType), "lock_dir must be a string referring to a "
         "directory."),
        ('type', (str,), "Cache type must be a string."),
        ('enabled', (bool, types.NoneType), "enabled must be true/false "
         "if present."),
        ('expire', (int, types.NoneType), "expire must be an integer representing "
         "how many seconds the cache is valid for"),
        ('regions', (list, tuple, types.NoneType), "Regions must be a "
         "comma seperated list of valid regions")
    ]
    return verify_rules(params, rules)


def parse_cache_config_options(config, include_defaults=True):
    """Parse configuration options and validate for use with the
    CacheManager"""
    
    # Load default cache options
    if include_defaults:
        options= dict(type='memory', data_dir=None, expire=None, 
                           log_file=None)
    else:
        options = {}
    for key, val in config.iteritems():
        if key.startswith('beaker.cache.'):
            options[key[13:]] = val
        if key.startswith('cache.'):
            options[key[6:]] = val
    coerce_cache_params(options)
    
    # Set cache to enabled if not turned off
    if 'enabled' not in options:
        options['enabled'] = True
    
    # Configure region dict if regions are available
    regions = options.pop('regions', None)
    if regions:
        region_configs = {}
        for region in regions:
            # Setup the default cache options
            region_options = dict(data_dir=options.get('data_dir'),
                                  lock_dir=options.get('lock_dir'),
                                  type=options.get('type'),
                                  enabled=options['enabled'],
                                  expire=options.get('expire'))
            region_len = len(region) + 1
            for key in options.keys():
                if key.startswith('%s.' % region):
                    region_options[key[region_len:]] = options.pop(key)
            coerce_cache_params(region_options)
            region_configs[region] = region_options
        options['cache_regions'] = region_configs
    return options

def func_namespace(func):
    """Generates a unique namespace for a function"""
    kls = None
    if hasattr(func, 'im_func'):
        kls = func.im_class
        func = func.im_func
    
    if kls:
        return '%s.%s' % (kls.__module__, kls.__name__)
    else:
        return '%s.%s' % (func.__module__, func.__name__)

########NEW FILE########
__FILENAME__ = corestats
#!/usr/bin/env python

#  corestats.py (COREy STATS) 
#  Copyright (c) 2006-2007, Corey Goldberg (corey@goldb.org)
#  updated on 2010-09 by GrosBedo
#
#    statistical calculation class
#    for processing numeric sequences
#
#  license: GNU LGPL
#
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
# CHANGELOG:
# 2010-09-14 - GrosBedo:
# * enhanced variance(), no more memory leak
# 2010-09-13 - GrosBedo:
# * added variance()
# * added mode()
# * added unique()
# * fixed median() algo
# 2010-09-09 - GrosBedo:
# * added percentileforvalue() (inverse of valueforpercentile() )
# * CRITICAL: removed the init function and the self.sequence float conversion (which was a BIG memory hog !)



import sys, math


class Stats:
    
    def sum(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            return sum(sequence)
    
    
    def count(self, sequence):
        return len(sequence)

    
    def min(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            return min(sequence)
    
    
    def max(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            return max(sequence)
    

    def mean(self, sequence):
        if len(sequence) < 1: 
            return None
        else: 
            return float(sum(sequence)) / len(sequence)    
    
    
    def median(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            sequence.sort()
            element_idx = float(len(sequence)) / 2
            if (element_idx != int(element_idx)):
                median1 = sequence[int(math.floor(element_idx))]
                median2 = sequence[int(math.ceil(element_idx))]
                return float(median1 + median2) / 2
            else:
                return sequence[int(element_idx)]
            

    def modeold(self, sequence):
        results = {}
        for item in sequence:
            results.setdefault(item, 0) # if index does not already exists, create it and set a value of 0
            results[item] += 1
        results = sorted(results.iteritems(), key=lambda (k,v):(v,k), reverse=True) # Sort by value (count), then if 2 keys have the same count, it will sort them by their keys
        return results

    def mode(self, sequence):
        """
        Enhanced version of mode(), inspired by statlib/stats.py
        The advantage is that this function (as well as mode) can return several modes at once (so you can see the next most frequent values)
        """
        scores = self.unique(sequence)
        scores.sort()
        freq = {}
        for item in scores:
            freq.setdefault(item, 0) # if index does not already exists, create it and set a value of 0
            freq[item] = sequence.count(item)
        results = sorted(freq.iteritems(), key=lambda (k,v):(v,k), reverse=True) # Sort by value (count), then if 2 keys have the same count, it will sort them by their keys
        return results

    def variance(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            avg = self.mean(sequence)
            sdsq = 0
            for i in sequence:
                sdsq += (i - avg) ** 2
            #sdsq = sum([(i - avg) ** 2 for i in sequence]) # this one-liner hogs a lot of memory, avoid
            variance = (float(sdsq) / (len(sequence) - 1))
            return variance
    
    def stdev(self, sequence):
        if len(sequence) < 1: 
            return None
        else:
            variance = self.variance(sequence)
            stdev = float(variance) ** 0.5
            return stdev

    def valueforpercentile(self, sequence, percentile):
        if len(sequence) < 1: 
            value = None
        elif (percentile > 100):
            sys.stderr.write('ERROR: percentile must be <= 100.  you supplied: %s\n'% percentile)
            value = None
        elif (percentile == 100):
            value = max(sequence)
        else:
            element_idx = int(len(sequence) * (float(percentile) / 100.0))
            sequence.sort()
            value = sequence[element_idx]
        return value

    def percentileforvalue(self, sequence, value):
        maxnb = max(sequence)
        minnb = min(sequence)
        if len(sequence) < 1: 
            percentile = None
        elif (value > maxnb or value < minnb ):
            #sys.stderr.write('ERROR: value must be between %s < value < %s.  you supplied: %s\n'% (minnb, maxnb, value))
            #percentile = None
            if (value > maxnb):
                percentile = 100
            else:
                percentile = 0
        else:
            sequence.sort()
            sequence.reverse()
            element_idx = sequence.index(value) # list.index() returns the first occurence, but we want to enclose all equal values, so we must reverse the sequence and do some calculations in order to get the right value
            element_idx = (len(sequence) - element_idx)
            percentile = float(element_idx) * 100.0 / len(sequence)
        return percentile

    def unique(self, sequence):
        return list(set(sequence))





# Sample script using this class:
# -------------------------------------------    
#    #!/usr/bin/env python
#    import corestats
#    
#    sequence = [1, 2.5, 7, 13.4, 8.0]
#    stats = corestats.Stats()
#    print stats.mean(sequence)
#    print stats.valueforpercentile(sequence, 90)
# -------------------------------------------
########NEW FILE########
__FILENAME__ = ElementInclude
#
# ElementTree
# $Id: ElementInclude.py 3225 2007-08-27 21:32:08Z fredrik $
#
# limited xinclude support for element trees
#
# history:
# 2003-08-15 fl   created
# 2003-11-14 fl   fixed default loader
#
# Copyright (c) 2003-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Limited XInclude support for the ElementTree package.
##

import ElementTree

def copy(elem):
    e = ElementTree.Element(elem.tag, elem.attrib)
    e.text = elem.text
    e.tail = elem.tail
    e[:] = elem
    return e

XINCLUDE = "{http://www.w3.org/2001/XInclude}"

XINCLUDE_INCLUDE = XINCLUDE + "include"
XINCLUDE_FALLBACK = XINCLUDE + "fallback"

##
# Fatal include error.

class FatalIncludeError(SyntaxError):
    pass

##
# Default loader.  This loader reads an included resource from disk.
#
# @param href Resource reference.
# @param parse Parse mode.  Either "xml" or "text".
# @param encoding Optional text encoding.
# @return The expanded resource.  If the parse mode is "xml", this
#    is an ElementTree instance.  If the parse mode is "text", this
#    is a Unicode string.  If the loader fails, it can return None
#    or raise an IOError exception.
# @throws IOError If the loader fails to load the resource.

def default_loader(href, parse, encoding=None):
    file = open(href)
    if parse == "xml":
        data = ElementTree.parse(file).getroot()
    else:
        data = file.read()
        if encoding:
            data = data.decode(encoding)
    file.close()
    return data

##
# Expand XInclude directives.
#
# @param elem Root element.
# @param loader Optional resource loader.  If omitted, it defaults
#     to {@link default_loader}.  If given, it should be a callable
#     that implements the same interface as <b>default_loader</b>.
# @throws FatalIncludeError If the function fails to include a given
#     resource, or if the tree contains malformed XInclude elements.
# @throws IOError If the function fails to load a given resource.

def include(elem, loader=None):
    if loader is None:
        loader = default_loader
    # look for xinclude elements
    i = 0
    while i < len(elem):
        e = elem[i]
        if e.tag == XINCLUDE_INCLUDE:
            # process xinclude directive
            href = e.get("href")
            parse = e.get("parse", "xml")
            if parse == "xml":
                node = loader(href, parse)
                if node is None:
                    raise FatalIncludeError(
                        "cannot load %r as %r" % (href, parse)
                        )
                node = copy(node)
                if e.tail:
                    node.tail = (node.tail or "") + e.tail
                elem[i] = node
            elif parse == "text":
                text = loader(href, parse, e.get("encoding"))
                if text is None:
                    raise FatalIncludeError(
                        "cannot load %r as %r" % (href, parse)
                        )
                if i:
                    node = elem[i-1]
                    node.tail = (node.tail or "") + text
                else:
                    elem.text = (elem.text or "") + text + (e.tail or "")
                del elem[i]
                continue
            else:
                raise FatalIncludeError(
                    "unknown parse type in xi:include tag (%r)" % parse
                )
        elif e.tag == XINCLUDE_FALLBACK:
            raise FatalIncludeError(
                "xi:fallback tag must be child of xi:include (%r)" % e.tag
                )
        else:
            include(e, loader)
        i = i + 1

########NEW FILE########
__FILENAME__ = ElementIron
#
# ElementTree
# $Id: ElementIron.py 443 2006-11-18 18:47:34Z effbot $
#
# an experimental ElementTree driver for IronPython.
#
# Copyright (c) 2006 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

import clr
clr.AddReference("System.Xml")

from System.IO import StringReader, TextReader
from System.Xml import XmlReader, XmlNodeType

# node types/categories
START = XmlNodeType.Element
DATA_TEXT = XmlNodeType.Text
DATA_CDATA = XmlNodeType.CDATA
DATA_SPACE = XmlNodeType.Whitespace
END = XmlNodeType.EndElement

def _ironparse(source):

    # internal event generator.  takes a TextReader subclass, a file-
    # like object, or a filename, and generates an event stream.  use
    # the parse() and iterparse() adapters to access this from user-
    # code.

    if isinstance(source, TextReader):
        pass # use as is
    elif hasattr(source, "read"):
        # FIXME: implement TextReader wrapper for Python I/O objects
        source = StringReader(source.read())

    # FIXME: handle settings here? (disable comments, etc)

    reader = XmlReader.Create(source)

    # tag cache
    tags = {}
    namespaces = []

    def gettag():
        key = reader.NamespaceURI, reader.LocalName
        try:
            tag = tags[key]
        except KeyError:
            if key[0]:
                tag = "{%s}%s" % key
            else:
                tag = key[1]
            tags[key] = tag
        return tag

    while reader.Read():
        node = reader.NodeType
        if node == START:
            tag = gettag()
            attrib = {}
            ns = 0 # count namespace declarations
            while reader.MoveToNextAttribute():
                if reader.LocalName == "xmlns":
                    ns += 1 # default namespace
                    yield "start-ns", ("", reader.Value)
                elif reader.Prefix == "xmlns":
                    ns += 1 # prefixed namespace
                    yield "start-ns", (reader.LocalName, reader.Value)
                else:
                    attrib[gettag()] = reader.Value
            namespaces.append(ns)
            reader.MoveToElement()
            yield "start", tag, attrib
            if reader.IsEmptyElement:
                yield "end", tag
                for i in xrange(namespaces.pop()):
                    yield "end-ns", None
        elif node == END:
            yield "end", tags[reader.NamespaceURI, reader.LocalName]
            for i in xrange(namespaces.pop()):
                yield "end-ns", None
        elif node == DATA_TEXT or node == DATA_SPACE or node == DATA_CDATA:
            yield "data", reader.Value
        else:
            pass # yield "unknown", node
    reader.Close()

class _iterparse:

    # iterparse generator.  we could use a generator method for this,
    # but we need to expose a custom attribute as well, and generators
    # cannot have arbitrary attributes

    def __init__(self, source, target, events):
        self.root = None
        self.source = source
        self.target = target
        self.events = events
    def __iter__(self):
        source = self.source
        target = self.target
        events = self.events
        if not events:
            events = ["end"]
        start = end = start_ns = end_ns = None
        for event in events:
            # use the passed-in objects as event codes
            if event == "start":
                start = event
            elif event == "end":
                end = event
            elif event == "start-ns":
                start_ns = event
            elif event == "end-ns":
                end_ns = event
        for event in _ironparse(source):
            code = event[0]
            if code == "start":
                elem = target.start(event[1], event[2])
                if start:
                    yield start, elem
            elif code == "end":
                elem = target.end(event[1])
                if end:
                    yield end, elem
            elif code == "data":
                target.data(event[1])
            elif code == "start-ns":
                if start_ns:
                    yield start_ns, event[1]
            elif code == "end-ns":
                if end_ns:
                    yield end_ns, event[1]
        self.root = target.close()

class ParserAPI(object):

    def __init__(self, target_factory):
        self.target_factory = target_factory

    def parse(self, source):
        target = self.target_factory()
        for event in _ironparse(source):
            code = event[0]
            if code == "start":
                target.start(event[1], event[2])
            elif code == "end":
                target.end(event[1])
            elif code == "data":
                target.data(event[1])
        return target.close()

    def iterparse(self, source, events=None):
        target = self.target_factory()
        return _iterparse(source, target, events)

    def fromstring(self, source):
        return self.parse(StringReader(source))

########NEW FILE########
__FILENAME__ = ElementPath
#
# ElementTree
# $Id: ElementPath.py 3225 2007-08-27 21:32:08Z fredrik $
#
# limited xpath support for element trees
#
# history:
# 2003-05-23 fl   created
# 2003-05-28 fl   added support for // etc
# 2003-08-27 fl   fixed parsing of periods in element names
#
# Copyright (c) 2003-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Implementation module for XPath support.  There's usually no reason
# to import this module directly; the <b>ElementTree</b> does this for
# you, if needed.
##

import re

xpath_tokenizer = re.compile(
    "(::|\.\.|\(\)|[/.*:\[\]\(\)@=])|((?:\{[^}]+\})?[^/:\[\]\(\)@=\s]+)|\s+"
    ).findall

class xpath_descendant_or_self:
    pass

##
# Wrapper for a compiled XPath.

class Path:

    ##
    # Create an Path instance from an XPath expression.

    def __init__(self, path):
        tokens = xpath_tokenizer(path)
        # the current version supports 'path/path'-style expressions only
        self.path = []
        self.tag = None
        if tokens and tokens[0][0] == "/":
            raise SyntaxError("cannot use absolute path on element")
        while tokens:
            op, tag = tokens.pop(0)
            if tag or op == "*":
                self.path.append(tag or op)
            elif op == ".":
                pass
            elif op == "/":
                self.path.append(xpath_descendant_or_self())
                continue
            else:
                raise SyntaxError("unsupported path syntax (%s)" % op)
            if tokens:
                op, tag = tokens.pop(0)
                if op != "/":
                    raise SyntaxError(
                        "expected path separator (%s)" % (op or tag)
                        )
        if self.path and isinstance(self.path[-1], xpath_descendant_or_self):
            raise SyntaxError("path cannot end with //")
        if len(self.path) == 1 and isinstance(self.path[0], type("")):
            self.tag = self.path[0]

    ##
    # Find first matching object.

    def find(self, element):
        tag = self.tag
        if tag is None:
            nodeset = self.findall(element)
            if not nodeset:
                return None
            return nodeset[0]
        for elem in element:
            if elem.tag == tag:
                return elem
        return None

    ##
    # Find text for first matching object.

    def findtext(self, element, default=None):
        tag = self.tag
        if tag is None:
            nodeset = self.findall(element)
            if not nodeset:
                return default
            return nodeset[0].text or ""
        for elem in element:
            if elem.tag == tag:
                return elem.text or ""
        return default

    ##
    # Find all matching objects.

    def findall(self, element):
        nodeset = [element]
        index = 0
        while 1:
            try:
                path = self.path[index]
                index = index + 1
            except IndexError:
                return nodeset
            set = []
            if isinstance(path, xpath_descendant_or_self):
                try:
                    tag = self.path[index]
                    if not isinstance(tag, type("")):
                        tag = None
                    else:
                        index = index + 1
                except IndexError:
                    tag = None # invalid path
                for node in nodeset:
                    new = list(node.getiterator(tag))
                    if new and new[0] is node:
                        set.extend(new[1:])
                    else:
                        set.extend(new)
            else:
                for node in nodeset:
                    for node in node:
                        if path == "*" or node.tag == path:
                            set.append(node)
            if not set:
                return []
            nodeset = set

_cache = {}

##
# (Internal) Compile path.

def _compile(path):
    p = _cache.get(path)
    if p is not None:
        return p
    p = Path(path)
    if len(_cache) >= 100:
        _cache.clear()
    _cache[path] = p
    return p

##
# Find first matching object.

def find(element, path):
    return _compile(path).find(element)

##
# Find text for first matching object.

def findtext(element, path, default=None):
    return _compile(path).findtext(element, default)

##
# Find all matching objects.

def findall(element, path):
    return _compile(path).findall(element)

########NEW FILE########
__FILENAME__ = ElementTree
#
# ElementTree
# $Id: ElementTree.py 3224 2007-08-27 21:23:39Z fredrik $
#
# light-weight XML support for Python 1.5.2 and later.
#
# history:
# 2001-10-20 fl   created (from various sources)
# 2001-11-01 fl   return root from parse method
# 2002-02-16 fl   sort attributes in lexical order
# 2002-04-06 fl   TreeBuilder refactoring, added PythonDoc markup
# 2002-05-01 fl   finished TreeBuilder refactoring
# 2002-07-14 fl   added basic namespace support to ElementTree.write
# 2002-07-25 fl   added QName attribute support
# 2002-10-20 fl   fixed encoding in write
# 2002-11-24 fl   changed default encoding to ascii; fixed attribute encoding
# 2002-11-27 fl   accept file objects or file names for parse/write
# 2002-12-04 fl   moved XMLTreeBuilder back to this module
# 2003-01-11 fl   fixed entity encoding glitch for us-ascii
# 2003-02-13 fl   added XML literal factory
# 2003-02-21 fl   added ProcessingInstruction/PI factory
# 2003-05-11 fl   added tostring/fromstring helpers
# 2003-05-26 fl   added ElementPath support
# 2003-07-05 fl   added makeelement factory method
# 2003-07-28 fl   added more well-known namespace prefixes
# 2003-08-15 fl   fixed typo in ElementTree.findtext (Thomas Dartsch)
# 2003-09-04 fl   fall back on emulator if ElementPath is not installed
# 2003-10-31 fl   markup updates
# 2003-11-15 fl   fixed nested namespace bug
# 2004-03-28 fl   added XMLID helper
# 2004-06-02 fl   added default support to findtext
# 2004-06-08 fl   fixed encoding of non-ascii element/attribute names
# 2004-08-23 fl   take advantage of post-2.1 expat features
# 2005-02-01 fl   added iterparse implementation
# 2005-03-02 fl   fixed iterparse support for pre-2.2 versions
# 2006-11-18 fl   added parser support for IronPython (ElementIron)
# 2007-08-27 fl   fixed newlines in attributes
#
# Copyright (c) 1999-2007 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

__all__ = [
    # public symbols
    "Comment",
    "dump",
    "Element", "ElementTree",
    "fromstring",
    "iselement", "iterparse",
    "parse",
    "PI", "ProcessingInstruction",
    "QName",
    "SubElement",
    "tostring",
    "TreeBuilder",
    "VERSION", "XML",
    "XMLTreeBuilder",
    ]

# parser api override (None = use default)
parser_api = None

# TODO: add support for custom namespace resolvers/default namespaces
# TODO: add improved support for incremental parsing

VERSION = "1.2.7"

##
# The <b>Element</b> type is a flexible container object, designed to
# store hierarchical data structures in memory. The type can be
# described as a cross between a list and a dictionary.
# <p>
# Each element has a number of properties associated with it:
# <ul>
# <li>a <i>tag</i>. This is a string identifying what kind of data
# this element represents (the element type, in other words).</li>
# <li>a number of <i>attributes</i>, stored in a Python dictionary.</li>
# <li>a <i>text</i> string.</li>
# <li>an optional <i>tail</i> string.</li>
# <li>a number of <i>child elements</i>, stored in a Python sequence</li>
# </ul>
#
# To create an element instance, use the {@link #Element} or {@link
# #SubElement} factory functions.
# <p>
# The {@link #ElementTree} class can be used to wrap an element
# structure, and convert it from and to XML.
##

import sys, re

try:
    import string
except:
    # emulate string module under IronPython
    class string(object):
        def join(self, seq, sep):
            return sep.join(seq)
        def replace(self, text, *args):
            return text.replace(*args)
        def split(self, text, *args):
            return text.split(*args)
        def strip(self, text, *args):
            return text.strip(*args)
    string = string()

class _SimpleElementPath:
    # emulate pre-1.2 find/findtext/findall behaviour
    def find(self, element, tag):
        for elem in element:
            if elem.tag == tag:
                return elem
        return None
    def findtext(self, element, tag, default=None):
        for elem in element:
            if elem.tag == tag:
                return elem.text or ""
        return default
    def findall(self, element, tag):
        if tag[:3] == ".//":
            return element.getiterator(tag[3:])
        result = []
        for elem in element:
            if elem.tag == tag:
                result.append(elem)
        return result

try:
    import ElementPath
except ImportError:
    # FIXME: issue warning in this case?
    ElementPath = _SimpleElementPath()

class DefaultParserAPI:

    def parse(self, source, parser=None):
        if not hasattr(source, "read"):
            source = open(source, "rb")
        if not parser:
            parser = XMLTreeBuilder()
        while 1:
            data = source.read(32768)
            if not data:
                break
            parser.feed(data)
        return parser.close()

    def iterparse(self, source, events):
        return _iterparse(source, events)

    def fromstring(self, text):
        parser = XMLTreeBuilder()
        parser.feed(text)
        return parser.close()

parser_api = default_parser_api = DefaultParserAPI()

##
# Internal element class.  This class defines the Element interface,
# and provides a reference implementation of this interface.
# <p>
# You should not create instances of this class directly.  Use the
# appropriate factory functions instead, such as {@link #Element}
# and {@link #SubElement}.
#
# @see Element
# @see SubElement
# @see Comment
# @see ProcessingInstruction

class _ElementInterface:
    # <tag attrib>text<child/>...</tag>tail

    ##
    # (Attribute) Element tag.

    tag = None

    ##
    # (Attribute) Element attribute dictionary.  Where possible, use
    # {@link #_ElementInterface.get},
    # {@link #_ElementInterface.set},
    # {@link #_ElementInterface.keys}, and
    # {@link #_ElementInterface.items} to access
    # element attributes.

    attrib = None

    ##
    # (Attribute) Text before first subelement.  This is either a
    # string or the value None, if there was no text.

    text = None

    ##
    # (Attribute) Text after this element's end tag, but before the
    # next sibling element's start tag.  This is either a string or
    # the value None, if there was no text.

    tail = None # text after end tag, if any

    def __init__(self, tag, attrib):
        self.tag = tag
        self.attrib = attrib
        self._children = []

    def __repr__(self):
        return "<Element %s at %x>" % (self.tag, id(self))

    ##
    # Creates a new element object of the same type as this element.
    #
    # @param tag Element tag.
    # @param attrib Element attributes, given as a dictionary.
    # @return A new element instance.

    def makeelement(self, tag, attrib):
        return Element(tag, attrib)

    ##
    # Returns the number of subelements.
    #
    # @return The number of subelements.

    def __len__(self):
        return len(self._children)

    ##
    # Returns the given subelement.
    #
    # @param index What subelement to return.
    # @return The given subelement.
    # @exception IndexError If the given element does not exist.

    def __getitem__(self, index):
        return self._children[index]

    ##
    # Replaces the given subelement.
    #
    # @param index What subelement to replace.
    # @param element The new element value.
    # @exception IndexError If the given element does not exist.
    # @exception AssertionError If element is not a valid object.

    def __setitem__(self, index, element):
        assert iselement(element)
        self._children[index] = element

    ##
    # Deletes the given subelement.
    #
    # @param index What subelement to delete.
    # @exception IndexError If the given element does not exist.

    def __delitem__(self, index):
        del self._children[index]

    ##
    # Returns a list containing subelements in the given range.
    #
    # @param start The first subelement to return.
    # @param stop The first subelement that shouldn't be returned.
    # @return A sequence object containing subelements.

    def __getslice__(self, start, stop):
        return self._children[start:stop]

    ##
    # Replaces a number of subelements with elements from a sequence.
    #
    # @param start The first subelement to replace.
    # @param stop The first subelement that shouldn't be replaced.
    # @param elements A sequence object with zero or more elements.
    # @exception AssertionError If a sequence member is not a valid object.

    def __setslice__(self, start, stop, elements):
        for element in elements:
            assert iselement(element)
        self._children[start:stop] = list(elements)

    ##
    # Deletes a number of subelements.
    #
    # @param start The first subelement to delete.
    # @param stop The first subelement to leave in there.

    def __delslice__(self, start, stop):
        del self._children[start:stop]

    ##
    # Adds a subelement to the end of this element.
    #
    # @param element The element to add.
    # @exception AssertionError If a sequence member is not a valid object.

    def append(self, element):
        assert iselement(element)
        self._children.append(element)

    ##
    # Inserts a subelement at the given position in this element.
    #
    # @param index Where to insert the new subelement.
    # @exception AssertionError If the element is not a valid object.

    def insert(self, index, element):
        assert iselement(element)
        self._children.insert(index, element)

    ##
    # Removes a matching subelement.  Unlike the <b>find</b> methods,
    # this method compares elements based on identity, not on tag
    # value or contents.
    #
    # @param element What element to remove.
    # @exception ValueError If a matching element could not be found.
    # @exception AssertionError If the element is not a valid object.

    def remove(self, element):
        assert iselement(element)
        self._children.remove(element)

    ##
    # Returns all subelements.  The elements are returned in document
    # order.
    #
    # @return A list of subelements.
    # @defreturn list of Element instances

    def getchildren(self):
        return self._children

    ##
    # Finds the first matching subelement, by tag name or path.
    #
    # @param path What element to look for.
    # @return The first matching element, or None if no element was found.
    # @defreturn Element or None

    def find(self, path):
        return ElementPath.find(self, path)

    ##
    # Finds text for the first matching subelement, by tag name or path.
    #
    # @param path What element to look for.
    # @param default What to return if the element was not found.
    # @return The text content of the first matching element, or the
    #     default value no element was found.  Note that if the element
    #     has is found, but has no text content, this method returns an
    #     empty string.
    # @defreturn string

    def findtext(self, path, default=None):
        return ElementPath.findtext(self, path, default)

    ##
    # Finds all matching subelements, by tag name or path.
    #
    # @param path What element to look for.
    # @return A list or iterator containing all matching elements,
    #    in document order.
    # @defreturn list of Element instances

    def findall(self, path):
        return ElementPath.findall(self, path)

    ##
    # Resets an element.  This function removes all subelements, clears
    # all attributes, and sets the text and tail attributes to None.

    def clear(self):
        self.attrib.clear()
        self._children = []
        self.text = self.tail = None

    ##
    # Gets an element attribute.
    #
    # @param key What attribute to look for.
    # @param default What to return if the attribute was not found.
    # @return The attribute value, or the default value, if the
    #     attribute was not found.
    # @defreturn string or None

    def get(self, key, default=None):
        return self.attrib.get(key, default)

    ##
    # Sets an element attribute.
    #
    # @param key What attribute to set.
    # @param value The attribute value.

    def set(self, key, value):
        self.attrib[key] = value

    ##
    # Gets a list of attribute names.  The names are returned in an
    # arbitrary order (just like for an ordinary Python dictionary).
    #
    # @return A list of element attribute names.
    # @defreturn list of strings

    def keys(self):
        return self.attrib.keys()

    ##
    # Gets element attributes, as a sequence.  The attributes are
    # returned in an arbitrary order.
    #
    # @return A list of (name, value) tuples for all attributes.
    # @defreturn list of (string, string) tuples

    def items(self):
        return self.attrib.items()

    ##
    # Creates a tree iterator.  The iterator loops over this element
    # and all subelements, in document order, and returns all elements
    # with a matching tag.
    # <p>
    # If the tree structure is modified during iteration, the result
    # is undefined.
    #
    # @param tag What tags to look for (default is to return all elements).
    # @return A list or iterator containing all the matching elements.
    # @defreturn list or iterator

    def getiterator(self, tag=None):
        nodes = []
        if tag == "*":
            tag = None
        if tag is None or self.tag == tag:
            nodes.append(self)
        for node in self._children:
            nodes.extend(node.getiterator(tag))
        return nodes

# compatibility
_Element = _ElementInterface

##
# Element factory.  This function returns an object implementing the
# standard Element interface.  The exact class or type of that object
# is implementation dependent, but it will always be compatible with
# the {@link #_ElementInterface} class in this module.
# <p>
# The element name, attribute names, and attribute values can be
# either 8-bit ASCII strings or Unicode strings.
#
# @param tag The element name.
# @param attrib An optional dictionary, containing element attributes.
# @param **extra Additional attributes, given as keyword arguments.
# @return An element instance.
# @defreturn Element

def Element(tag, attrib={}, **extra):
    attrib = attrib.copy()
    attrib.update(extra)
    return _ElementInterface(tag, attrib)

##
# Subelement factory.  This function creates an element instance, and
# appends it to an existing element.
# <p>
# The element name, attribute names, and attribute values can be
# either 8-bit ASCII strings or Unicode strings.
#
# @param parent The parent element.
# @param tag The subelement name.
# @param attrib An optional dictionary, containing element attributes.
# @param **extra Additional attributes, given as keyword arguments.
# @return An element instance.
# @defreturn Element

def SubElement(parent, tag, attrib={}, **extra):
    attrib = attrib.copy()
    attrib.update(extra)
    element = parent.makeelement(tag, attrib)
    parent.append(element)
    return element

##
# Comment element factory.  This factory function creates a special
# element that will be serialized as an XML comment.
# <p>
# The comment string can be either an 8-bit ASCII string or a Unicode
# string.
#
# @param text A string containing the comment string.
# @return An element instance, representing a comment.
# @defreturn Element

def Comment(text=None):
    element = Element(Comment)
    element.text = text
    return element

##
# PI element factory.  This factory function creates a special element
# that will be serialized as an XML processing instruction.
#
# @param target A string containing the PI target.
# @param text A string containing the PI contents, if any.
# @return An element instance, representing a PI.
# @defreturn Element

def ProcessingInstruction(target, text=None):
    element = Element(ProcessingInstruction)
    element.text = target
    if text:
        element.text = element.text + " " + text
    return element

PI = ProcessingInstruction

##
# QName wrapper.  This can be used to wrap a QName attribute value, in
# order to get proper namespace handling on output.
#
# @param text A string containing the QName value, in the form {uri}local,
#     or, if the tag argument is given, the URI part of a QName.
# @param tag Optional tag.  If given, the first argument is interpreted as
#     an URI, and this argument is interpreted as a local name.
# @return An opaque object, representing the QName.

class QName:
    def __init__(self, text_or_uri, tag=None):
        if tag:
            text_or_uri = "{%s}%s" % (text_or_uri, tag)
        self.text = text_or_uri
    def __str__(self):
        return self.text
    def __hash__(self):
        return hash(self.text)
    def __cmp__(self, other):
        if isinstance(other, QName):
            return cmp(self.text, other.text)
        return cmp(self.text, other)

##
# ElementTree wrapper class.  This class represents an entire element
# hierarchy, and adds some extra support for serialization to and from
# standard XML.
#
# @param element Optional root element.
# @keyparam file Optional file handle or name.  If given, the
#     tree is initialized with the contents of this XML file.

class ElementTree:

    def __init__(self, element=None, file=None):
        assert element is None or iselement(element)
        self._root = element # first node
        if file:
            self.parse(file)

    ##
    # Gets the root element for this tree.
    #
    # @return An element instance.
    # @defreturn Element

    def getroot(self):
        return self._root

    ##
    # Replaces the root element for this tree.  This discards the
    # current contents of the tree, and replaces it with the given
    # element.  Use with care.
    #
    # @param element An element instance.

    def _setroot(self, element):
        assert iselement(element)
        self._root = element

    ##
    # Loads an external XML document into this element tree.
    #
    # @param source A file name or file object.
    # @param parser An optional parser instance.  If not given, the
    #     standard {@link XMLTreeBuilder} parser is used.
    # @return The document root element.
    # @defreturn Element

    def parse(self, source, parser=None):
        if parser:
            tree = default_parser_api.parse(source, parser)
        else:
            tree = parser_api.parse(source)
        self._root = tree
        return tree

    ##
    # Creates a tree iterator for the root element.  The iterator loops
    # over all elements in this tree, in document order.
    #
    # @param tag What tags to look for (default is to return all elements)
    # @return An iterator.
    # @defreturn iterator

    def getiterator(self, tag=None):
        assert self._root is not None
        return self._root.getiterator(tag)

    ##
    # Finds the first toplevel element with given tag.
    # Same as getroot().find(path).
    #
    # @param path What element to look for.
    # @return The first matching element, or None if no element was found.
    # @defreturn Element or None

    def find(self, path):
        assert self._root is not None
        if path[:1] == "/":
            path = "." + path
        return self._root.find(path)

    ##
    # Finds the element text for the first toplevel element with given
    # tag.  Same as getroot().findtext(path).
    #
    # @param path What toplevel element to look for.
    # @param default What to return if the element was not found.
    # @return The text content of the first matching element, or the
    #     default value no element was found.  Note that if the element
    #     has is found, but has no text content, this method returns an
    #     empty string.
    # @defreturn string

    def findtext(self, path, default=None):
        assert self._root is not None
        if path[:1] == "/":
            path = "." + path
        return self._root.findtext(path, default)

    ##
    # Finds all toplevel elements with the given tag.
    # Same as getroot().findall(path).
    #
    # @param path What element to look for.
    # @return A list or iterator containing all matching elements,
    #    in document order.
    # @defreturn list of Element instances

    def findall(self, path):
        assert self._root is not None
        if path[:1] == "/":
            path = "." + path
        return self._root.findall(path)

    ##
    # Writes the element tree to a file, as XML.
    #
    # @param file A file name, or a file object opened for writing.
    # @param encoding Optional output encoding (default is US-ASCII).

    def write(self, file, encoding="us-ascii"):
        assert self._root is not None
        if not hasattr(file, "write"):
            file = open(file, "wb")
        if not encoding:
            encoding = "us-ascii"
        elif encoding != "utf-8" and encoding != "us-ascii":
            file.write("<?xml version='1.0' encoding='%s'?>\n" % encoding)
        self._write(file, self._root, encoding, {})

    def _write(self, file, node, encoding, namespaces):
        # write XML to file
        tag = node.tag
        if tag is Comment:
            file.write("<!-- %s -->" % _escape_cdata(node.text, encoding))
        elif tag is ProcessingInstruction:
            file.write("<?%s?>" % _escape_cdata(node.text, encoding))
        else:
            items = node.items()
            xmlns_items = [] # new namespaces in this scope
            try:
                if isinstance(tag, QName) or tag[:1] == "{":
                    tag, xmlns = fixtag(tag, namespaces)
                    if xmlns: xmlns_items.append(xmlns)
            except TypeError:
                _raise_serialization_error(tag)
            file.write("<" + _encode(tag, encoding))
            if items or xmlns_items:
                items.sort() # lexical order
                for k, v in items:
                    try:
                        if isinstance(k, QName) or k[:1] == "{":
                            k, xmlns = fixtag(k, namespaces)
                            if xmlns: xmlns_items.append(xmlns)
                    except TypeError:
                        _raise_serialization_error(k)
                    try:
                        if isinstance(v, QName):
                            v, xmlns = fixtag(v, namespaces)
                            if xmlns: xmlns_items.append(xmlns)
                    except TypeError:
                        _raise_serialization_error(v)
                    file.write(" %s=\"%s\"" % (_encode(k, encoding),
                                               _escape_attrib(v, encoding)))
                for k, v in xmlns_items:
                    file.write(" %s=\"%s\"" % (_encode(k, encoding),
                                               _escape_attrib(v, encoding)))
            if node.text or len(node):
                file.write(">")
                if node.text:
                    file.write(_escape_cdata(node.text, encoding))
                for n in node:
                    self._write(file, n, encoding, namespaces)
                file.write("</" + _encode(tag, encoding) + ">")
            else:
                file.write(" />")
            for k, v in xmlns_items:
                del namespaces[v]
        if node.tail:
            file.write(_escape_cdata(node.tail, encoding))

# --------------------------------------------------------------------
# helpers

##
# Checks if an object appears to be a valid element object.
#
# @param An element instance.
# @return A true value if this is an element object.
# @defreturn flag

def iselement(element):
    # FIXME: not sure about this; might be a better idea to look
    # for tag/attrib/text attributes
    return isinstance(element, _ElementInterface) or hasattr(element, "tag")

##
# Writes an element tree or element structure to sys.stdout.  This
# function should be used for debugging only.
# <p>
# The exact output format is implementation dependent.  In this
# version, it's written as an ordinary XML file.
#
# @param elem An element tree or an individual element.

def dump(elem):
    # debugging
    if not isinstance(elem, ElementTree):
        elem = ElementTree(elem)
    elem.write(sys.stdout)
    tail = elem.getroot().tail
    if not tail or tail[-1] != "\n":
        sys.stdout.write("\n")

def _encode(s, encoding):
    try:
        return s.encode(encoding)
    except AttributeError:
        return s # 1.5.2: assume the string uses the right encoding

if sys.version[:3] == "1.5":
    _escape = re.compile(r"[&<>\"\x80-\xff]+") # 1.5.2
else:
    _escape = re.compile(eval(r'u"[&<>\"\u0080-\uffff]+"'))

_escape_map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
}

_namespace_map = {
    # "well-known" namespace prefixes
    "http://www.w3.org/XML/1998/namespace": "xml",
    "http://www.w3.org/1999/xhtml": "html",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
    "http://schemas.xmlsoap.org/wsdl/": "wsdl",
}

def _raise_serialization_error(text):
    raise TypeError(
        "cannot serialize %r (type %s)" % (text, type(text).__name__)
        )

def _encode_entity(text, pattern=_escape):
    # map reserved and non-ascii characters to numerical entities
    def escape_entities(m, map=_escape_map):
        out = []
        append = out.append
        for char in m.group():
            text = map.get(char)
            if text is None:
                text = "&#%d;" % ord(char)
            append(text)
        return string.join(out, "")
    try:
        return _encode(pattern.sub(escape_entities, text), "ascii")
    except TypeError:
        _raise_serialization_error(text)

#
# the following functions assume an ascii-compatible encoding
# (or "utf-16")

def _escape_cdata(text, encoding=None, replace=string.replace):
    # escape character data
    try:
        if encoding:
            try:
                text = _encode(text, encoding)
            except UnicodeError:
                return _encode_entity(text)
        if "&" in text:
            text = replace(text, "&", "&amp;")
        if "<" in text:
            text = replace(text, "<", "&lt;")
        if ">" in text:
            text = replace(text, ">", "&gt;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

def _escape_attrib(text, encoding=None, replace=string.replace):
    # escape attribute value
    try:
        if encoding:
            try:
                text = _encode(text, encoding)
            except UnicodeError:
                return _encode_entity(text)
        if "&" in text:
            text = replace(text, "&", "&amp;")
        if "\"" in text:
            text = replace(text, "\"", "&quot;")
        if "<" in text:
            text = replace(text, "<", "&lt;")
        if ">" in text:
            text = replace(text, ">", "&gt;")
        if "\n" in text:
            text = replace(text, "\n", "&#10;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

def fixtag(tag, namespaces):
    # given a decorated tag (of the form {uri}tag), return prefixed
    # tag and namespace declaration, if any
    if isinstance(tag, QName):
        tag = tag.text
    namespace_uri, tag = string.split(tag[1:], "}", 1)
    prefix = namespaces.get(namespace_uri)
    if prefix is None:
        prefix = _namespace_map.get(namespace_uri)
        if prefix is None:
            prefix = "ns%d" % len(namespaces)
        namespaces[namespace_uri] = prefix
        if prefix == "xml":
            xmlns = None
        else:
            xmlns = ("xmlns:%s" % prefix, namespace_uri)
    else:
        xmlns = None
    return "%s:%s" % (prefix, tag), xmlns

##
# Parses an XML document into an element tree.
#
# @param source A filename or file object containing XML data.
# @param parser An optional parser instance.  If not given, the
#     standard {@link XMLTreeBuilder} parser is used.
# @return An ElementTree instance

def parse(source, parser=None):
    if parser:
        tree = default_parser_api.parse(source, parser)
    else:
        tree = parser_api.parse(source)
    return ElementTree(tree)

##
# Parses an XML document into an element tree incrementally, and reports
# what's going on to the user.
#
# @param source A filename or file object containing XML data.
# @param events A list of events to report back.  If omitted, only "end"
#     events are reported.
# @return A (event, elem) iterator.

def iterparse(source, events=None):
    return parser_api.iterparse(source, events)

class _iterparse:

    def __init__(self, source, events):
        if not hasattr(source, "read"):
            source = open(source, "rb")
        self._file = source
        self._events = []
        self._index = 0
        self.root = self._root = None
        self._parser = XMLTreeBuilder()
        # wire up the parser for event reporting
        parser = self._parser._parser
        append = self._events.append
        if events is None:
            events = ["end"]
        for event in events:
            if event == "start":
                try:
                    parser.ordered_attributes = 1
                    parser.specified_attributes = 1
                    def handler(tag, attrib_in, event=event, append=append,
                                start=self._parser._start_list):
                        append((event, start(tag, attrib_in)))
                    parser.StartElementHandler = handler
                except AttributeError:
                    def handler(tag, attrib_in, event=event, append=append,
                                start=self._parser._start):
                        append((event, start(tag, attrib_in)))
                    parser.StartElementHandler = handler
            elif event == "end":
                def handler(tag, event=event, append=append,
                            end=self._parser._end):
                    append((event, end(tag)))
                parser.EndElementHandler = handler
            elif event == "start-ns":
                def handler(prefix, uri, event=event, append=append):
                    try:
                        uri = _encode(uri, "ascii")
                    except UnicodeError:
                        pass
                    append((event, (prefix or "", uri)))
                parser.StartNamespaceDeclHandler = handler
            elif event == "end-ns":
                def handler(prefix, event=event, append=append):
                    append((event, None))
                parser.EndNamespaceDeclHandler = handler

    def next(self):
        while 1:
            try:
                item = self._events[self._index]
            except IndexError:
                if self._parser is None:
                    self.root = self._root
                    try:
                        raise StopIteration
                    except NameError:
                        raise IndexError
                # load event buffer
                del self._events[:]
                self._index = 0
                data = self._file.read(16384)
                if data:
                    self._parser.feed(data)
                else:
                    self._root = self._parser.close()
                    self._parser = None
            else:
                self._index = self._index + 1
                return item

    try:
        iter
        def __iter__(self):
            return self
    except NameError:
        def __getitem__(self, index):
            return self.next()

##
# Parses an XML document from a string constant.  This function can
# be used to embed "XML literals" in Python code.
#
# @param source A string containing XML data.
# @return An Element instance.
# @defreturn Element

def XML(text):
    api = parser_api or default_parser_api
    return api.fromstring(text)

##
# Parses an XML document from a string constant, and also returns
# a dictionary which maps from element id:s to elements.
#
# @param source A string containing XML data.
# @return A tuple containing an Element instance and a dictionary.
# @defreturn (Element, dictionary)

def XMLID(text):
    api = parser_api or default_parser_api
    tree = api.fromstring(text)
    ids = {}
    for elem in tree.getiterator():
        id = elem.get("id")
        if id:
            ids[id] = elem
    return tree, ids

##
# Parses an XML document from a string constant.  Same as {@link #XML}.
#
# @def fromstring(text)
# @param source A string containing XML data.
# @return An Element instance.
# @defreturn Element

fromstring = XML

##
# Generates a string representation of an XML element, including all
# subelements.
#
# @param element An Element instance.
# @return An encoded string containing the XML data.
# @defreturn string

def tostring(element, encoding=None):
    class dummy:
        pass
    data = []
    file = dummy()
    file.write = data.append
    ElementTree(element).write(file, encoding)
    return string.join(data, "")

##
# Generic element structure builder.  This builder converts a sequence
# of {@link #TreeBuilder.start}, {@link #TreeBuilder.data}, and {@link
# #TreeBuilder.end} method calls to a well-formed element structure.
# <p>
# You can use this class to build an element structure using a custom XML
# parser, or a parser for some other XML-like format.
#
# @param element_factory Optional element factory.  This factory
#    is called to create new Element instances, as necessary.

class TreeBuilder:

    def __init__(self, element_factory=None):
        self._data = [] # data collector
        self._elem = [] # element stack
        self._last = None # last element
        self._tail = None # true if we're after an end tag
        if element_factory is None:
            element_factory = _ElementInterface
        self._factory = element_factory

    ##
    # Flushes the parser buffers, and returns the toplevel documen
    # element.
    #
    # @return An Element instance.
    # @defreturn Element

    def close(self):
        assert len(self._elem) == 0, "missing end tags"
        assert self._last != None, "missing toplevel element"
        return self._last

    def _flush(self):
        if self._data:
            if self._last is not None:
                text = string.join(self._data, "")
                if self._tail:
                    assert self._last.tail is None, "internal error (tail)"
                    self._last.tail = text
                else:
                    assert self._last.text is None, "internal error (text)"
                    self._last.text = text
            self._data = []

    ##
    # Adds text to the current element.
    #
    # @param data A string.  This should be either an 8-bit string
    #    containing ASCII text, or a Unicode string.

    def data(self, data):
        self._data.append(data)

    ##
    # Opens a new element.
    #
    # @param tag The element name.
    # @param attrib A dictionary containing element attributes.
    # @return The opened element.
    # @defreturn Element

    def start(self, tag, attrs):
        self._flush()
        self._last = elem = self._factory(tag, attrs)
        if self._elem:
            self._elem[-1].append(elem)
        self._elem.append(elem)
        self._tail = 0
        return elem

    ##
    # Closes the current element.
    #
    # @param tag The element name.
    # @return The closed element.
    # @defreturn Element

    def end(self, tag):
        self._flush()
        self._last = self._elem.pop()
        assert self._last.tag == tag,\
               "end tag mismatch (expected %s, got %s)" % (
                   self._last.tag, tag)
        self._tail = 1
        return self._last

##
# Element structure builder for XML source data, based on the
# <b>expat</b> parser.
#
# @keyparam target Target object.  If omitted, the builder uses an
#     instance of the standard {@link #TreeBuilder} class.
# @keyparam html Predefine HTML entities.  This flag is not supported
#     by the current implementation.
# @see #ElementTree
# @see #TreeBuilder

class XMLTreeBuilder:

    def __init__(self, html=0, target=None):
        try:
            from xml.parsers import expat
        except ImportError:
            raise ImportError(
                "No module named expat; use SimpleXMLTreeBuilder instead"
                )
        self._parser = parser = expat.ParserCreate(None, "}")
        if target is None:
            target = TreeBuilder()
        self._target = target
        self._names = {} # name memo cache
        # callbacks
        parser.DefaultHandlerExpand = self._default
        parser.StartElementHandler = self._start
        parser.EndElementHandler = self._end
        parser.CharacterDataHandler = self._data
        # let expat do the buffering, if supported
        try:
            self._parser.buffer_text = 1
        except AttributeError:
            pass
        # use new-style attribute handling, if supported
        try:
            self._parser.ordered_attributes = 1
            self._parser.specified_attributes = 1
            parser.StartElementHandler = self._start_list
        except AttributeError:
            pass
        encoding = None
        if not parser.returns_unicode:
            encoding = "utf-8"
        # target.xml(encoding, None)
        self._doctype = None
        self.entity = {}

    def _fixtext(self, text):
        # convert text string to ascii, if possible
        try:
            return _encode(text, "ascii")
        except UnicodeError:
            return text

    def _fixname(self, key):
        # expand qname, and convert name string to ascii, if possible
        try:
            name = self._names[key]
        except KeyError:
            name = key
            if "}" in name:
                name = "{" + name
            self._names[key] = name = self._fixtext(name)
        return name

    def _start(self, tag, attrib_in):
        fixname = self._fixname
        tag = fixname(tag)
        attrib = {}
        for key, value in attrib_in.items():
            attrib[fixname(key)] = self._fixtext(value)
        return self._target.start(tag, attrib)

    def _start_list(self, tag, attrib_in):
        fixname = self._fixname
        tag = fixname(tag)
        attrib = {}
        if attrib_in:
            for i in range(0, len(attrib_in), 2):
                attrib[fixname(attrib_in[i])] = self._fixtext(attrib_in[i+1])
        return self._target.start(tag, attrib)

    def _data(self, text):
        return self._target.data(self._fixtext(text))

    def _end(self, tag):
        return self._target.end(self._fixname(tag))

    def _default(self, text):
        prefix = text[:1]
        if prefix == "&":
            # deal with undefined entities
            try:
                self._target.data(self.entity[text[1:-1]])
            except KeyError:
                from xml.parsers import expat
                raise expat.error(
                    "undefined entity %s: line %d, column %d" %
                    (text, self._parser.ErrorLineNumber,
                    self._parser.ErrorColumnNumber)
                    )
        elif prefix == "<" and text[:9] == "<!DOCTYPE":
            self._doctype = [] # inside a doctype declaration
        elif self._doctype is not None:
            # parse doctype contents
            if prefix == ">":
                self._doctype = None
                return
            text = string.strip(text)
            if not text:
                return
            self._doctype.append(text)
            n = len(self._doctype)
            if n > 2:
                type = self._doctype[1]
                if type == "PUBLIC" and n == 4:
                    name, type, pubid, system = self._doctype
                elif type == "SYSTEM" and n == 3:
                    name, type, system = self._doctype
                    pubid = None
                else:
                    return
                if pubid:
                    pubid = pubid[1:-1]
                self.doctype(name, pubid, system[1:-1])
                self._doctype = None

    ##
    # Handles a doctype declaration.
    #
    # @param name Doctype name.
    # @param pubid Public identifier.
    # @param system System identifier.

    def doctype(self, name, pubid, system):
        pass

    ##
    # Feeds data to the parser.
    #
    # @param data Encoded data.

    def feed(self, data):
        self._parser.Parse(data, 0)

    ##
    # Finishes feeding data to the parser.
    #
    # @return An element structure.
    # @defreturn Element

    def close(self):
        self._parser.Parse("", 1) # end of data
        tree = self._target.close()
        del self._target, self._parser # get rid of circular references
        return tree


# --------------------------------------------------------------------
# load platform specific extensions

if sys.platform == "cli":
    try:
        import ElementIron
    except ImportError:
        pass # fall back on optional pyexpat emulation
    else:
        parser_api = ElementIron.ParserAPI(TreeBuilder)

elif sys.platform.startswith("java"):
    try:
        import ElementJava
    except ImportError:
        pass
    else:
        parser_api = ElementJava.ParserAPI(TreeBuilder)

########NEW FILE########
__FILENAME__ = HTMLTreeBuilder
#
# ElementTree
# $Id: HTMLTreeBuilder.py 3225 2007-08-27 21:32:08Z fredrik $
#
# a simple tree builder, for HTML input
#
# history:
# 2002-04-06 fl   created
# 2002-04-07 fl   ignore IMG and HR end tags
# 2002-04-07 fl   added support for 1.5.2 and later
# 2003-04-13 fl   added HTMLTreeBuilder alias
# 2004-12-02 fl   don't feed non-ASCII charrefs/entities as 8-bit strings
# 2004-12-05 fl   don't feed non-ASCII CDATA as 8-bit strings
#
# Copyright (c) 1999-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Tools to build element trees from HTML files.
##

import htmlentitydefs
import re, string, sys
import mimetools, StringIO

import ElementTree

AUTOCLOSE = "p", "li", "tr", "th", "td", "head", "body"
IGNOREEND = "img", "hr", "meta", "link", "br"

if sys.version[:3] == "1.5":
    is_not_ascii = re.compile(r"[\x80-\xff]").search # 1.5.2
else:
    is_not_ascii = re.compile(eval(r'u"[\u0080-\uffff]"')).search

try:
    from HTMLParser import HTMLParser
except ImportError:
    from sgmllib import SGMLParser
    # hack to use sgmllib's SGMLParser to emulate 2.2's HTMLParser
    class HTMLParser(SGMLParser):
        # the following only works as long as this class doesn't
        # provide any do, start, or end handlers
        def unknown_starttag(self, tag, attrs):
            self.handle_starttag(tag, attrs)
        def unknown_endtag(self, tag):
            self.handle_endtag(tag)

##
# ElementTree builder for HTML source code.  This builder converts an
# HTML document or fragment to an ElementTree.
# <p>
# The parser is relatively picky, and requires balanced tags for most
# elements.  However, elements belonging to the following group are
# automatically closed: P, LI, TR, TH, and TD.  In addition, the
# parser automatically inserts end tags immediately after the start
# tag, and ignores any end tags for the following group: IMG, HR,
# META, and LINK.
#
# @keyparam builder Optional builder object.  If omitted, the parser
#     uses the standard <b>elementtree</b> builder.
# @keyparam encoding Optional character encoding, if known.  If omitted,
#     the parser looks for META tags inside the document.  If no tags
#     are found, the parser defaults to ISO-8859-1.  Note that if your
#     document uses a non-ASCII compatible encoding, you must decode
#     the document before parsing.
#
# @see elementtree.ElementTree

class HTMLTreeBuilder(HTMLParser):

    # FIXME: shouldn't this class be named Parser, not Builder?

    def __init__(self, builder=None, encoding=None):
        self.__stack = []
        if builder is None:
            builder = ElementTree.TreeBuilder()
        self.__builder = builder
        self.encoding = encoding or "iso-8859-1"
        HTMLParser.__init__(self)

    ##
    # Flushes parser buffers, and return the root element.
    #
    # @return An Element instance.

    def close(self):
        HTMLParser.close(self)
        return self.__builder.close()

    ##
    # (Internal) Handles start tags.

    def handle_starttag(self, tag, attrs):
        if tag == "meta":
            # look for encoding directives
            http_equiv = content = None
            for k, v in attrs:
                if k == "http-equiv":
                    http_equiv = string.lower(v)
                elif k == "content":
                    content = v
            if http_equiv == "content-type" and content:
                # use mimetools to parse the http header
                header = mimetools.Message(
                    StringIO.StringIO("%s: %s\n\n" % (http_equiv, content))
                    )
                encoding = header.getparam("charset")
                if encoding:
                    self.encoding = encoding
        if tag in AUTOCLOSE:
            if self.__stack and self.__stack[-1] == tag:
                self.handle_endtag(tag)
        self.__stack.append(tag)
        attrib = {}
        if attrs:
            for k, v in attrs:
                attrib[string.lower(k)] = v
        self.__builder.start(tag, attrib)
        if tag in IGNOREEND:
            self.__stack.pop()
            self.__builder.end(tag)

    ##
    # (Internal) Handles end tags.

    def handle_endtag(self, tag):
        if tag in IGNOREEND:
            return
        lasttag = self.__stack.pop()
        if tag != lasttag and lasttag in AUTOCLOSE:
            self.handle_endtag(lasttag)
        self.__builder.end(tag)

    ##
    # (Internal) Handles character references.

    def handle_charref(self, char):
        if char[:1] == "x":
            char = int(char[1:], 16)
        else:
            char = int(char)
        if 0 <= char < 128:
            self.__builder.data(chr(char))
        else:
            self.__builder.data(unichr(char))

    ##
    # (Internal) Handles entity references.

    def handle_entityref(self, name):
        entity = htmlentitydefs.entitydefs.get(name)
        if entity:
            if len(entity) == 1:
                entity = ord(entity)
            else:
                entity = int(entity[2:-1])
            if 0 <= entity < 128:
                self.__builder.data(chr(entity))
            else:
                self.__builder.data(unichr(entity))
        else:
            self.unknown_entityref(name)

    ##
    # (Internal) Handles character data.

    def handle_data(self, data):
        if isinstance(data, type('')) and is_not_ascii(data):
            # convert to unicode, but only if necessary
            data = unicode(data, self.encoding, "ignore")
        self.__builder.data(data)

    ##
    # (Hook) Handles unknown entity references.  The default action
    # is to ignore unknown entities.

    def unknown_entityref(self, name):
        pass # ignore by default; override if necessary

##
# An alias for the <b>HTMLTreeBuilder</b> class.

TreeBuilder = HTMLTreeBuilder

##
# Parse an HTML document or document fragment.
#
# @param source A filename or file object containing HTML data.
# @param encoding Optional character encoding, if known.  If omitted,
#     the parser looks for META tags inside the document.  If no tags
#     are found, the parser defaults to ISO-8859-1.
# @return An ElementTree instance

def parse(source, encoding=None):
    return ElementTree.parse(source, HTMLTreeBuilder(encoding=encoding))

if __name__ == "__main__":
    import sys
    ElementTree.dump(parse(open(sys.argv[1])))

########NEW FILE########
__FILENAME__ = SgmlopXMLTreeBuilder
#
# ElementTree
# $Id$
#
# A simple XML tree builder, based on the sgmlop library.
#
# Note that this version does not support namespaces.  This may be
# changed in future versions.
#
# history:
# 2004-03-28 fl   created
#
# Copyright (c) 1999-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Tools to build element trees from XML, based on the SGMLOP parser.
# <p>
# The current version does not support XML namespaces.
# <p>
# This tree builder requires the <b>sgmlop</b> extension module
# (available from
# <a href='http://effbot.org/downloads'>http://effbot.org/downloads</a>).
##

import ElementTree

##
# ElementTree builder for XML source data, based on the SGMLOP parser.
#
# @see elementtree.ElementTree

class TreeBuilder:

    def __init__(self, html=0):
        try:
            import sgmlop
        except ImportError:
            raise RuntimeError("sgmlop parser not available")
        self.__builder = ElementTree.TreeBuilder()
        if html:
            import htmlentitydefs
            self.entitydefs.update(htmlentitydefs.entitydefs)
        self.__parser = sgmlop.XMLParser()
        self.__parser.register(self)

    ##
    # Feeds data to the parser.
    #
    # @param data Encoded data.

    def feed(self, data):
        self.__parser.feed(data)

    ##
    # Finishes feeding data to the parser.
    #
    # @return An element structure.
    # @defreturn Element

    def close(self):
        self.__parser.close()
        self.__parser = None
        return self.__builder.close()

    def finish_starttag(self, tag, attrib):
        self.__builder.start(tag, attrib)

    def finish_endtag(self, tag):
        self.__builder.end(tag)

    def handle_data(self, data):
        self.__builder.data(data)

########NEW FILE########
__FILENAME__ = SimpleXMLTreeBuilder
#
# ElementTree
# $Id: SimpleXMLTreeBuilder.py 3225 2007-08-27 21:32:08Z fredrik $
#
# A simple XML tree builder, based on Python's xmllib
#
# Note that due to bugs in xmllib, this builder does not fully support
# namespaces (unqualified attributes are put in the default namespace,
# instead of being left as is).  Run this module as a script to find
# out if this affects your Python version.
#
# history:
# 2001-10-20 fl   created
# 2002-05-01 fl   added namespace support for xmllib
# 2002-08-17 fl   added xmllib sanity test
#
# Copyright (c) 1999-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Tools to build element trees from XML files, using <b>xmllib</b>.
# This module can be used instead of the standard tree builder, for
# Python versions where "expat" is not available (such as 1.5.2).
# <p>
# Note that due to bugs in <b>xmllib</b>, the namespace support is
# not reliable (you can run the module as a script to find out exactly
# how unreliable it is on your Python version).
##

import xmllib, string

import ElementTree

##
# ElementTree builder for XML source data.
#
# @see elementtree.ElementTree

class TreeBuilder(xmllib.XMLParser):

    def __init__(self, html=0):
        self.__builder = ElementTree.TreeBuilder()
        if html:
            import htmlentitydefs
            self.entitydefs.update(htmlentitydefs.entitydefs)
        xmllib.XMLParser.__init__(self)

    ##
    # Feeds data to the parser.
    #
    # @param data Encoded data.

    def feed(self, data):
        xmllib.XMLParser.feed(self, data)

    ##
    # Finishes feeding data to the parser.
    #
    # @return An element structure.
    # @defreturn Element

    def close(self):
        xmllib.XMLParser.close(self)
        return self.__builder.close()

    def handle_data(self, data):
        self.__builder.data(data)

    handle_cdata = handle_data

    def unknown_starttag(self, tag, attrs):
        attrib = {}
        for key, value in attrs.items():
            attrib[fixname(key)] = value
        self.__builder.start(fixname(tag), attrib)

    def unknown_endtag(self, tag):
        self.__builder.end(fixname(tag))


def fixname(name, split=string.split):
    # xmllib in 2.0 and later provides limited (and slightly broken)
    # support for XML namespaces.
    if " " not in name:
        return name
    return "{%s}%s" % tuple(split(name, " ", 1))


if __name__ == "__main__":
    import sys
    # sanity check: look for known namespace bugs in xmllib
    p = TreeBuilder()
    text = """\
    <root xmlns='default'>
       <tag attribute='value' />
    </root>
    """
    p.feed(text)
    tree = p.close()
    status = []
    # check for bugs in the xmllib implementation
    tag = tree.find("{default}tag")
    if tag is None:
        status.append("namespaces not supported")
    if tag is not None and tag.get("{default}attribute"):
        status.append("default namespace applied to unqualified attribute")
    # report bugs
    if status:
        print "xmllib doesn't work properly in this Python version:"
        for bug in status:
            print "-", bug
    else:
        print "congratulations; no problems found in xmllib"

########NEW FILE########
__FILENAME__ = SimpleXMLWriter
#
# SimpleXMLWriter
# $Id: SimpleXMLWriter.py 3225 2007-08-27 21:32:08Z fredrik $
#
# a simple XML writer
#
# history:
# 2001-12-28 fl   created
# 2002-11-25 fl   fixed attribute encoding
# 2002-12-02 fl   minor fixes for 1.5.2
# 2004-06-17 fl   added pythondoc markup
# 2004-07-23 fl   added flush method (from Jay Graves)
# 2004-10-03 fl   added declaration method
#
# Copyright (c) 2001-2004 by Fredrik Lundh
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The SimpleXMLWriter module is
#
# Copyright (c) 2001-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Tools to write XML files, without having to deal with encoding
# issues, well-formedness, etc.
# <p>
# The current version does not provide built-in support for
# namespaces. To create files using namespaces, you have to provide
# "xmlns" attributes and explicitly add prefixes to tags and
# attributes.
#
# <h3>Patterns</h3>
#
# The following example generates a small XHTML document.
# <pre>
#
# from elementtree.SimpleXMLWriter import XMLWriter
# import sys
#
# w = XMLWriter(sys.stdout)
#
# html = w.start("html")
#
# w.start("head")
# w.element("title", "my document")
# w.element("meta", name="generator", value="my application 1.0")
# w.end()
#
# w.start("body")
# w.element("h1", "this is a heading")
# w.element("p", "this is a paragraph")
#
# w.start("p")
# w.data("this is ")
# w.element("b", "bold")
# w.data(" and ")
# w.element("i", "italic")
# w.data(".")
# w.end("p")
#
# w.close(html)
# </pre>
##

import re, sys, string

try:
    unicode("")
except NameError:
    def encode(s, encoding):
        # 1.5.2: application must use the right encoding
        return s
    _escape = re.compile(r"[&<>\"\x80-\xff]+") # 1.5.2
else:
    def encode(s, encoding):
        return s.encode(encoding)
    _escape = re.compile(eval(r'u"[&<>\"\u0080-\uffff]+"'))

def encode_entity(text, pattern=_escape):
    # map reserved and non-ascii characters to numerical entities
    def escape_entities(m):
        out = []
        for char in m.group():
            out.append("&#%d;" % ord(char))
        return string.join(out, "")
    return encode(pattern.sub(escape_entities, text), "ascii")

del _escape

#
# the following functions assume an ascii-compatible encoding
# (or "utf-16")

def escape_cdata(s, encoding=None, replace=string.replace):
    s = replace(s, "&", "&amp;")
    s = replace(s, "<", "&lt;")
    s = replace(s, ">", "&gt;")
    if encoding:
        try:
            return encode(s, encoding)
        except UnicodeError:
            return encode_entity(s)
    return s

def escape_attrib(s, encoding=None, replace=string.replace):
    s = replace(s, "&", "&amp;")
    s = replace(s, "'", "&apos;")
    s = replace(s, "\"", "&quot;")
    s = replace(s, "<", "&lt;")
    s = replace(s, ">", "&gt;")
    if encoding:
        try:
            return encode(s, encoding)
        except UnicodeError:
            return encode_entity(s)
    return s

##
# XML writer class.
#
# @param file A file or file-like object.  This object must implement
#    a <b>write</b> method that takes an 8-bit string.
# @param encoding Optional encoding.

class XMLWriter:

    def __init__(self, file, encoding="us-ascii"):
        if not hasattr(file, "write"):
            file = open(file, "w")
        self.__write = file.write
        if hasattr(file, "flush"):
            self.flush = file.flush
        self.__open = 0 # true if start tag is open
        self.__tags = []
        self.__data = []
        self.__encoding = encoding

    def __flush(self):
        # flush internal buffers
        if self.__open:
            self.__write(">")
            self.__open = 0
        if self.__data:
            data = string.join(self.__data, "")
            self.__write(escape_cdata(data, self.__encoding))
            self.__data = []

    ##
    # Writes an XML declaration.

    def declaration(self):
        encoding = self.__encoding
        if encoding == "us-ascii" or encoding == "utf-8":
            self.__write("<?xml version='1.0'?>\n")
        else:
            self.__write("<?xml version='1.0' encoding='%s'?>\n" % encoding)

    ##
    # Opens a new element.  Attributes can be given as keyword
    # arguments, or as a string/string dictionary. You can pass in
    # 8-bit strings or Unicode strings; the former are assumed to use
    # the encoding passed to the constructor.  The method returns an
    # opaque identifier that can be passed to the <b>close</b> method,
    # to close all open elements up to and including this one.
    #
    # @param tag Element tag.
    # @param attrib Attribute dictionary.  Alternatively, attributes
    #    can be given as keyword arguments.
    # @return An element identifier.

    def start(self, tag, attrib={}, **extra):
        self.__flush()
        tag = escape_cdata(tag, self.__encoding)
        self.__data = []
        self.__tags.append(tag)
        self.__write("<%s" % tag)
        if attrib or extra:
            attrib = attrib.copy()
            attrib.update(extra)
            attrib = attrib.items()
            attrib.sort()
            for k, v in attrib:
                k = escape_cdata(k, self.__encoding)
                v = escape_attrib(v, self.__encoding)
                self.__write(" %s=\"%s\"" % (k, v))
        self.__open = 1
        return len(self.__tags)-1

    ##
    # Adds a comment to the output stream.
    #
    # @param comment Comment text, as an 8-bit string or Unicode string.

    def comment(self, comment):
        self.__flush()
        self.__write("<!-- %s -->\n" % escape_cdata(comment, self.__encoding))

    ##
    # Adds character data to the output stream.
    #
    # @param text Character data, as an 8-bit string or Unicode string.

    def data(self, text):
        self.__data.append(text)

    ##
    # Closes the current element (opened by the most recent call to
    # <b>start</b>).
    #
    # @param tag Element tag.  If given, the tag must match the start
    #    tag.  If omitted, the current element is closed.

    def end(self, tag=None):
        if tag:
            assert self.__tags, "unbalanced end(%s)" % tag
            assert escape_cdata(tag, self.__encoding) == self.__tags[-1],\
                   "expected end(%s), got %s" % (self.__tags[-1], tag)
        else:
            assert self.__tags, "unbalanced end()"
        tag = self.__tags.pop()
        if self.__data:
            self.__flush()
        elif self.__open:
            self.__open = 0
            self.__write(" />")
            return
        self.__write("</%s>" % tag)

    ##
    # Closes open elements, up to (and including) the element identified
    # by the given identifier.
    #
    # @param id Element identifier, as returned by the <b>start</b> method.

    def close(self, id):
        while len(self.__tags) > id:
            self.end()

    ##
    # Adds an entire element.  This is the same as calling <b>start</b>,
    # <b>data</b>, and <b>end</b> in sequence. The <b>text</b> argument
    # can be omitted.

    def element(self, tag, text=None, attrib={}, **extra):
        apply(self.start, (tag, attrib), extra)
        if text:
            self.data(text)
        self.end()

    ##
    # Flushes the output stream.

    def flush(self):
        pass # replaced by the constructor

########NEW FILE########
__FILENAME__ = TidyHTMLTreeBuilder
#
# ElementTree
# $Id: TidyHTMLTreeBuilder.py 2304 2005-03-01 17:42:41Z fredrik $
#

from elementtidy.TidyHTMLTreeBuilder import *

########NEW FILE########
__FILENAME__ = TidyTools
#
# ElementTree
# $Id: TidyTools.py 1862 2004-06-18 07:31:02Z Fredrik $
#
# tools to run the "tidy" command on an HTML or XHTML file, and return
# the contents as an XHTML element tree.
#
# history:
# 2002-10-19 fl   added to ElementTree library; added getzonebody function
#
# Copyright (c) 1999-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#

##
# Tools to build element trees from HTML, using the external <b>tidy</b>
# utility.
##

import glob, string, os, sys

from ElementTree import ElementTree, Element

NS_XHTML = "{http://www.w3.org/1999/xhtml}"

##
# Convert an HTML or HTML-like file to XHTML, using the <b>tidy</b>
# command line utility.
#
# @param file Filename.
# @param new_inline_tags An optional list of valid but non-standard
#     inline tags.
# @return An element tree, or None if not successful.

def tidy(file, new_inline_tags=None):

    command = ["tidy", "-qn", "-asxml"]

    if new_inline_tags:
        command.append("--new-inline-tags")
        command.append(string.join(new_inline_tags, ","))

    # FIXME: support more tidy options!

    # convert
    os.system(
        "%s %s >%s.out 2>%s.err" % (string.join(command), file, file, file)
        )
    # check that the result is valid XML
    try:
        tree = ElementTree()
        tree.parse(file + ".out")
    except:
        print "*** %s:%s" % sys.exc_info()[:2]
        print ("*** %s is not valid XML "
               "(check %s.err for info)" % (file, file))
        tree = None
    else:
        if os.path.isfile(file + ".out"):
            os.remove(file + ".out")
        if os.path.isfile(file + ".err"):
            os.remove(file + ".err")

    return tree

##
# Get document body from a an HTML or HTML-like file.  This function
# uses the <b>tidy</b> function to convert HTML to XHTML, and cleans
# up the resulting XML tree.
#
# @param file Filename.
# @return A <b>body</b> element, or None if not successful.

def getbody(file, **options):
    # get clean body from text file

    # get xhtml tree
    try:
        tree = apply(tidy, (file,), options)
        if tree is None:
            return
    except IOError, v:
        print "***", v
        return None

    NS = NS_XHTML

    # remove namespace uris
    for node in tree.getiterator():
        if node.tag.startswith(NS):
            node.tag = node.tag[len(NS):]

    body = tree.getroot().find("body")

    return body

##
# Same as <b>getbody</b>, but turns plain text at the start of the
# document into an H1 tag.  This function can be used to parse zone
# documents.
#
# @param file Filename.
# @return A <b>body</b> element, or None if not successful.

def getzonebody(file, **options):

    body = getbody(file, **options)
    if body is None:
        return

    if body.text and string.strip(body.text):
        title = Element("h1")
        title.text = string.strip(body.text)
        title.tail = "\n\n"
        body.insert(0, title)

    body.text = None

    return body

if __name__ == "__main__":

    import sys
    for arg in sys.argv[1:]:
        for file in glob.glob(arg):
            print file, "...", tidy(file)

########NEW FILE########
__FILENAME__ = XMLTreeBuilder
#
# ElementTree
# $Id: XMLTreeBuilder.py 3225 2007-08-27 21:32:08Z fredrik $
#
# an XML tree builder
#
# history:
# 2001-10-20 fl   created
# 2002-05-01 fl   added namespace support for xmllib
# 2002-07-27 fl   require expat (1.5.2 code can use SimpleXMLTreeBuilder)
# 2002-08-17 fl   use tag/attribute name memo cache
# 2002-12-04 fl   moved XMLTreeBuilder to the ElementTree module
#
# Copyright (c) 1999-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2007 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

##
# Tools to build element trees from XML files.
##

import ElementTree

##
# (obsolete) ElementTree builder for XML source data, based on the
# <b>expat</b> parser.
# <p>
# This class is an alias for ElementTree.XMLTreeBuilder.  New code
# should use that version instead.
#
# @see elementtree.ElementTree

class TreeBuilder(ElementTree.XMLTreeBuilder):
    pass

##
# (experimental) An alternate builder that supports manipulation of
# new elements.

class FancyTreeBuilder(TreeBuilder):

    def __init__(self, html=0):
        TreeBuilder.__init__(self, html)
        self._parser.StartNamespaceDeclHandler = self._start_ns
        self._parser.EndNamespaceDeclHandler = self._end_ns
        self.namespaces = []

    def _start(self, tag, attrib_in):
        elem = TreeBuilder._start(self, tag, attrib_in)
        self.start(elem)

    def _start_list(self, tag, attrib_in):
        elem = TreeBuilder._start_list(self, tag, attrib_in)
        self.start(elem)

    def _end(self, tag):
        elem = TreeBuilder._end(self, tag)
        self.end(elem)

    def _start_ns(self, prefix, value):
        self.namespaces.insert(0, (prefix, value))

    def _end_ns(self, prefix):
        assert self.namespaces.pop(0)[0] == prefix, "implementation confused"

    ##
    # Hook method that's called when a new element has been opened.
    # May access the <b>namespaces</b> attribute.
    #
    # @param element The new element.  The tag name and attributes are,
    #     set, but it has no children, and the text and tail attributes
    #     are still empty.

    def start(self, element):
        pass

    ##
    # Hook method that's called when a new element has been closed.
    # May access the <b>namespaces</b> attribute.
    #
    # @param element The new element.

    def end(self, element):
        pass

########NEW FILE########
__FILENAME__ = feedparser
#!/usr/bin/env python
"""Universal feed parser

Handles RSS 0.9x, RSS 1.0, RSS 2.0, CDF, Atom 0.3, and Atom 1.0 feeds

Visit http://feedparser.org/ for the latest version
Visit http://feedparser.org/docs/ for the latest documentation

Required: Python 2.1 or later
Recommended: Python 2.3 or later
Recommended: CJKCodecs and iconv_codec <http://cjkpython.i18n.org/>
"""

__version__ = "4.1"# + "$Revision: 1.92 $"[11:15] + "-cvs"
__license__ = """Copyright (c) 2002-2006, Mark Pilgrim, All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE."""
__author__ = "Mark Pilgrim <http://diveintomark.org/>"
__contributors__ = ["Jason Diamond <http://injektilo.org/>",
                    "John Beimler <http://john.beimler.org/>",
                    "Fazal Majid <http://www.majid.info/mylos/weblog/>",
                    "Aaron Swartz <http://aaronsw.com/>",
                    "Kevin Marks <http://epeus.blogspot.com/>"]
_debug = 0

# HTTP "User-Agent" header to send to servers when downloading feeds.
# If you are embedding feedparser in a larger application, you should
# change this to your application name and URL.
USER_AGENT = "UniversalFeedParser/%s +http://feedparser.org/" % __version__

# HTTP "Accept" header to send to servers when downloading feeds.  If you don't
# want to send an Accept header, set this to None.
ACCEPT_HEADER = "application/atom+xml,application/rdf+xml,application/rss+xml,application/x-netcdf,application/xml;q=0.9,text/xml;q=0.2,*/*;q=0.1"

# List of preferred XML parsers, by SAX driver name.  These will be tried first,
# but if they're not installed, Python will keep searching through its own list
# of pre-installed parsers until it finds one that supports everything we need.
PREFERRED_XML_PARSERS = ["drv_libxml2"]

# If you want feedparser to automatically run HTML markup through HTML Tidy, set
# this to 1.  Requires mxTidy <http://www.egenix.com/files/python/mxTidy.html>
# or utidylib <http://utidylib.berlios.de/>.
TIDY_MARKUP = 0

# List of Python interfaces for HTML Tidy, in order of preference.  Only useful
# if TIDY_MARKUP = 1
PREFERRED_TIDY_INTERFACES = ["uTidy", "mxTidy"]

# ---------- required modules (should come with any Python distribution) ----------
import sgmllib, re, sys, copy, urlparse, time, rfc822, types, cgi, urllib, urllib2
try:
    from cStringIO import StringIO as _StringIO
except:
    from StringIO import StringIO as _StringIO

# ---------- optional modules (feedparser will work without these, but with reduced functionality) ----------

# gzip is included with most Python distributions, but may not be available if you compiled your own
try:
    import gzip
except:
    gzip = None
try:
    import zlib
except:
    zlib = None

# If a real XML parser is available, feedparser will attempt to use it.  feedparser has
# been tested with the built-in SAX parser, PyXML, and libxml2.  On platforms where the
# Python distribution does not come with an XML parser (such as Mac OS X 10.2 and some
# versions of FreeBSD), feedparser will quietly fall back on regex-based parsing.
try:
    import xml.sax
    xml.sax.make_parser(PREFERRED_XML_PARSERS) # test for valid parsers
    from xml.sax.saxutils import escape as _xmlescape
    _XML_AVAILABLE = 1
except:
    _XML_AVAILABLE = 0
    def _xmlescape(data):
        data = data.replace('&', '&amp;')
        data = data.replace('>', '&gt;')
        data = data.replace('<', '&lt;')
        return data

# base64 support for Atom feeds that contain embedded binary data
try:
    import base64, binascii
except:
    base64 = binascii = None

# cjkcodecs and iconv_codec provide support for more character encodings.
# Both are available from http://cjkpython.i18n.org/
try:
    import cjkcodecs.aliases
except:
    pass
try:
    import iconv_codec
except:
    pass

# chardet library auto-detects character encodings
# Download from http://chardet.feedparser.org/
try:
    import chardet
    if _debug:
        import chardet.constants
        chardet.constants._debug = 1
except:
    chardet = None

# ---------- don't touch these ----------
class ThingsNobodyCaresAboutButMe(Exception): pass
class CharacterEncodingOverride(ThingsNobodyCaresAboutButMe): pass
class CharacterEncodingUnknown(ThingsNobodyCaresAboutButMe): pass
class NonXMLContentType(ThingsNobodyCaresAboutButMe): pass
class UndeclaredNamespace(Exception): pass

sgmllib.tagfind = re.compile('[a-zA-Z][-_.:a-zA-Z0-9]*')
sgmllib.special = re.compile('<!')
sgmllib.charref = re.compile('&#(x?[0-9A-Fa-f]+)[^0-9A-Fa-f]')

SUPPORTED_VERSIONS = {'': 'unknown',
                      'rss090': 'RSS 0.90',
                      'rss091n': 'RSS 0.91 (Netscape)',
                      'rss091u': 'RSS 0.91 (Userland)',
                      'rss092': 'RSS 0.92',
                      'rss093': 'RSS 0.93',
                      'rss094': 'RSS 0.94',
                      'rss20': 'RSS 2.0',
                      'rss10': 'RSS 1.0',
                      'rss': 'RSS (unknown version)',
                      'atom01': 'Atom 0.1',
                      'atom02': 'Atom 0.2',
                      'atom03': 'Atom 0.3',
                      'atom10': 'Atom 1.0',
                      'atom': 'Atom (unknown version)',
                      'cdf': 'CDF',
                      'hotrss': 'Hot RSS'
                      }

try:
    UserDict = dict
except NameError:
    # Python 2.1 does not have dict
    from UserDict import UserDict
    def dict(aList):
        rc = {}
        for k, v in aList:
            rc[k] = v
        return rc

class FeedParserDict(UserDict):
    keymap = {'channel': 'feed',
              'items': 'entries',
              'guid': 'id',
              'date': 'updated',
              'date_parsed': 'updated_parsed',
              'description': ['subtitle', 'summary'],
              'url': ['href'],
              'modified': 'updated',
              'modified_parsed': 'updated_parsed',
              'issued': 'published',
              'issued_parsed': 'published_parsed',
              'copyright': 'rights',
              'copyright_detail': 'rights_detail',
              'tagline': 'subtitle',
              'tagline_detail': 'subtitle_detail'}
    def __getitem__(self, key):
        if key == 'category':
            return UserDict.__getitem__(self, 'tags')[0]['term']
        if key == 'categories':
            return [(tag['scheme'], tag['term']) for tag in UserDict.__getitem__(self, 'tags')]
        realkey = self.keymap.get(key, key)
        if type(realkey) == types.ListType:
            for k in realkey:
                if UserDict.has_key(self, k):
                    return UserDict.__getitem__(self, k)
        if UserDict.has_key(self, key):
            return UserDict.__getitem__(self, key)
        return UserDict.__getitem__(self, realkey)

    def __setitem__(self, key, value):
        for k in self.keymap.keys():
            if key == k:
                key = self.keymap[k]
                if type(key) == types.ListType:
                    key = key[0]
        return UserDict.__setitem__(self, key, value)

    def get(self, key, default=None):
        if self.has_key(key):
            return self[key]
        else:
            return default

    def setdefault(self, key, value):
        if not self.has_key(key):
            self[key] = value
        return self[key]
        
    def has_key(self, key):
        try:
            return hasattr(self, key) or UserDict.has_key(self, key)
        except AttributeError:
            return False
        
    def __getattr__(self, key):
        try:
            return self.__dict__[key]
        except KeyError:
            pass
        try:
            assert not key.startswith('_')
            return self.__getitem__(key)
        except:
            raise AttributeError, "object has no attribute '%s'" % key

    def __setattr__(self, key, value):
        if key.startswith('_') or key == 'data':
            self.__dict__[key] = value
        else:
            return self.__setitem__(key, value)

    def __contains__(self, key):
        return self.has_key(key)

def zopeCompatibilityHack():
    global FeedParserDict
    del FeedParserDict
    def FeedParserDict(aDict=None):
        rc = {}
        if aDict:
            rc.update(aDict)
        return rc

_ebcdic_to_ascii_map = None
def _ebcdic_to_ascii(s):
    global _ebcdic_to_ascii_map
    if not _ebcdic_to_ascii_map:
        emap = (
            0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,
            16,17,18,19,157,133,8,135,24,25,146,143,28,29,30,31,
            128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,
            144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,
            32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,
            38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,
            45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,
            186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,
            195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,201,
            202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
            209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
            216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
            123,65,66,67,68,69,70,71,72,73,232,233,234,235,236,237,
            125,74,75,76,77,78,79,80,81,82,238,239,240,241,242,243,
            92,159,83,84,85,86,87,88,89,90,244,245,246,247,248,249,
            48,49,50,51,52,53,54,55,56,57,250,251,252,253,254,255
            )
        import string
        _ebcdic_to_ascii_map = string.maketrans( \
            ''.join(map(chr, range(256))), ''.join(map(chr, emap)))
    return s.translate(_ebcdic_to_ascii_map)

_urifixer = re.compile('^([A-Za-z][A-Za-z0-9+-.]*://)(/*)(.*?)')
def _urljoin(base, uri):
    uri = _urifixer.sub(r'\1\3', uri)
    return urlparse.urljoin(base, uri)

class _FeedParserMixin:
    namespaces = {'': '',
                  'http://backend.userland.com/rss': '',
                  'http://blogs.law.harvard.edu/tech/rss': '',
                  'http://purl.org/rss/1.0/': '',
                  'http://my.netscape.com/rdf/simple/0.9/': '',
                  'http://example.com/newformat#': '',
                  'http://example.com/necho': '',
                  'http://purl.org/echo/': '',
                  'uri/of/echo/namespace#': '',
                  'http://purl.org/pie/': '',
                  'http://purl.org/atom/ns#': '',
                  'http://www.w3.org/2005/Atom': '',
                  'http://purl.org/rss/1.0/modules/rss091#': '',
                  
                  'http://webns.net/mvcb/':                               'admin',
                  'http://purl.org/rss/1.0/modules/aggregation/':         'ag',
                  'http://purl.org/rss/1.0/modules/annotate/':            'annotate',
                  'http://media.tangent.org/rss/1.0/':                    'audio',
                  'http://backend.userland.com/blogChannelModule':        'blogChannel',
                  'http://web.resource.org/cc/':                          'cc',
                  'http://backend.userland.com/creativeCommonsRssModule': 'creativeCommons',
                  'http://purl.org/rss/1.0/modules/company':              'co',
                  'http://purl.org/rss/1.0/modules/content/':             'content',
                  'http://my.theinfo.org/changed/1.0/rss/':               'cp',
                  'http://purl.org/dc/elements/1.1/':                     'dc',
                  'http://purl.org/dc/terms/':                            'dcterms',
                  'http://purl.org/rss/1.0/modules/email/':               'email',
                  'http://purl.org/rss/1.0/modules/event/':               'ev',
                  'http://rssnamespace.org/feedburner/ext/1.0':           'feedburner',
                  'http://freshmeat.net/rss/fm/':                         'fm',
                  'http://xmlns.com/foaf/0.1/':                           'foaf',
                  'http://www.w3.org/2003/01/geo/wgs84_pos#':             'geo',
                  'http://postneo.com/icbm/':                             'icbm',
                  'http://purl.org/rss/1.0/modules/image/':               'image',
                  'http://www.itunes.com/DTDs/PodCast-1.0.dtd':           'itunes',
                  'http://example.com/DTDs/PodCast-1.0.dtd':              'itunes',
                  'http://purl.org/rss/1.0/modules/link/':                'l',
                  'http://search.yahoo.com/mrss':                         'media',
                  'http://madskills.com/public/xml/rss/module/pingback/': 'pingback',
                  'http://prismstandard.org/namespaces/1.2/basic/':       'prism',
                  'http://www.w3.org/1999/02/22-rdf-syntax-ns#':          'rdf',
                  'http://www.w3.org/2000/01/rdf-schema#':                'rdfs',
                  'http://purl.org/rss/1.0/modules/reference/':           'ref',
                  'http://purl.org/rss/1.0/modules/richequiv/':           'reqv',
                  'http://purl.org/rss/1.0/modules/search/':              'search',
                  'http://purl.org/rss/1.0/modules/slash/':               'slash',
                  'http://schemas.xmlsoap.org/soap/envelope/':            'soap',
                  'http://purl.org/rss/1.0/modules/servicestatus/':       'ss',
                  'http://hacks.benhammersley.com/rss/streaming/':        'str',
                  'http://purl.org/rss/1.0/modules/subscription/':        'sub',
                  'http://purl.org/rss/1.0/modules/syndication/':         'sy',
                  'http://purl.org/rss/1.0/modules/taxonomy/':            'taxo',
                  'http://purl.org/rss/1.0/modules/threading/':           'thr',
                  'http://purl.org/rss/1.0/modules/textinput/':           'ti',
                  'http://madskills.com/public/xml/rss/module/trackback/':'trackback',
                  'http://wellformedweb.org/commentAPI/':                 'wfw',
                  'http://purl.org/rss/1.0/modules/wiki/':                'wiki',
                  'http://www.w3.org/1999/xhtml':                         'xhtml',
                  'http://www.w3.org/XML/1998/namespace':                 'xml',
                  'http://schemas.pocketsoap.com/rss/myDescModule/':      'szf'
}
    _matchnamespaces = {}

    can_be_relative_uri = ['link', 'id', 'wfw_comment', 'wfw_commentrss', 'docs', 'url', 'href', 'comments', 'license', 'icon', 'logo']
    can_contain_relative_uris = ['content', 'title', 'summary', 'info', 'tagline', 'subtitle', 'copyright', 'rights', 'description']
    can_contain_dangerous_markup = ['content', 'title', 'summary', 'info', 'tagline', 'subtitle', 'copyright', 'rights', 'description']
    html_types = ['text/html', 'application/xhtml+xml']
    
    def __init__(self, baseuri=None, baselang=None, encoding='utf-8'):
        if _debug: sys.stderr.write('initializing FeedParser\n')
        if not self._matchnamespaces:
            for k, v in self.namespaces.items():
                self._matchnamespaces[k.lower()] = v
        self.feeddata = FeedParserDict() # feed-level data
        self.encoding = encoding # character encoding
        self.entries = [] # list of entry-level data
        self.version = '' # feed type/version, see SUPPORTED_VERSIONS
        self.namespacesInUse = {} # dictionary of namespaces defined by the feed

        # the following are used internally to track state;
        # this is really out of control and should be refactored
        self.infeed = 0
        self.inentry = 0
        self.incontent = 0
        self.intextinput = 0
        self.inimage = 0
        self.inauthor = 0
        self.incontributor = 0
        self.inpublisher = 0
        self.insource = 0
        self.sourcedata = FeedParserDict()
        self.contentparams = FeedParserDict()
        self._summaryKey = None
        self.namespacemap = {}
        self.elementstack = []
        self.basestack = []
        self.langstack = []
        self.baseuri = baseuri or ''
        self.lang = baselang or None
        if baselang:
            self.feeddata['language'] = baselang

    def unknown_starttag(self, tag, attrs):
        if _debug: sys.stderr.write('start %s with %s\n' % (tag, attrs))
        # normalize attrs
        attrs = [(k.lower(), v) for k, v in attrs]
        attrs = [(k, k in ('rel', 'type') and v.lower() or v) for k, v in attrs]
        
        # track xml:base and xml:lang
        attrsD = dict(attrs)
        baseuri = attrsD.get('xml:base', attrsD.get('base')) or self.baseuri
        self.baseuri = _urljoin(self.baseuri, baseuri)
        lang = attrsD.get('xml:lang', attrsD.get('lang'))
        if lang == '':
            # xml:lang could be explicitly set to '', we need to capture that
            lang = None
        elif lang is None:
            # if no xml:lang is specified, use parent lang
            lang = self.lang
        if lang:
            if tag in ('feed', 'rss', 'rdf:RDF'):
                self.feeddata['language'] = lang
        self.lang = lang
        self.basestack.append(self.baseuri)
        self.langstack.append(lang)
        
        # track namespaces
        for prefix, uri in attrs:
            if prefix.startswith('xmlns:'):
                self.trackNamespace(prefix[6:], uri)
            elif prefix == 'xmlns':
                self.trackNamespace(None, uri)

        # track inline content
        if self.incontent and self.contentparams.has_key('type') and not self.contentparams.get('type', 'xml').endswith('xml'):
            # element declared itself as escaped markup, but it isn't really
            self.contentparams['type'] = 'application/xhtml+xml'
        if self.incontent and self.contentparams.get('type') == 'application/xhtml+xml':
            # Note: probably shouldn't simply recreate localname here, but
            # our namespace handling isn't actually 100% correct in cases where
            # the feed redefines the default namespace (which is actually
            # the usual case for inline content, thanks Sam), so here we
            # cheat and just reconstruct the element based on localname
            # because that compensates for the bugs in our namespace handling.
            # This will horribly munge inline content with non-empty qnames,
            # but nobody actually does that, so I'm not fixing it.
            tag = tag.split(':')[-1]
            return self.handle_data('<%s%s>' % (tag, ''.join([' %s="%s"' % t for t in attrs])), escape=0)

        # match namespaces
        if tag.find(':') <> -1:
            prefix, suffix = tag.split(':', 1)
        else:
            prefix, suffix = '', tag
        prefix = self.namespacemap.get(prefix, prefix)
        if prefix:
            prefix = prefix + '_'

        # special hack for better tracking of empty textinput/image elements in illformed feeds
        if (not prefix) and tag not in ('title', 'link', 'description', 'name'):
            self.intextinput = 0
        if (not prefix) and tag not in ('title', 'link', 'description', 'url', 'href', 'width', 'height'):
            self.inimage = 0
        
        # call special handler (if defined) or default handler
        methodname = '_start_' + prefix + suffix
        try:
            method = getattr(self, methodname)
            return method(attrsD)
        except AttributeError:
            return self.push(prefix + suffix, 1)

    def unknown_endtag(self, tag):
        if _debug: sys.stderr.write('end %s\n' % tag)
        # match namespaces
        if tag.find(':') <> -1:
            prefix, suffix = tag.split(':', 1)
        else:
            prefix, suffix = '', tag
        prefix = self.namespacemap.get(prefix, prefix)
        if prefix:
            prefix = prefix + '_'

        # call special handler (if defined) or default handler
        methodname = '_end_' + prefix + suffix
        try:
            method = getattr(self, methodname)
            method()
        except AttributeError:
            self.pop(prefix + suffix)

        # track inline content
        if self.incontent and self.contentparams.has_key('type') and not self.contentparams.get('type', 'xml').endswith('xml'):
            # element declared itself as escaped markup, but it isn't really
            self.contentparams['type'] = 'application/xhtml+xml'
        if self.incontent and self.contentparams.get('type') == 'application/xhtml+xml':
            tag = tag.split(':')[-1]
            self.handle_data('</%s>' % tag, escape=0)

        # track xml:base and xml:lang going out of scope
        if self.basestack:
            self.basestack.pop()
            if self.basestack and self.basestack[-1]:
                self.baseuri = self.basestack[-1]
        if self.langstack:
            self.langstack.pop()
            if self.langstack: # and (self.langstack[-1] is not None):
                self.lang = self.langstack[-1]

    def handle_charref(self, ref):
        # called for each character reference, e.g. for '&#160;', ref will be '160'
        if not self.elementstack: return
        ref = ref.lower()
        if ref in ('34', '38', '39', '60', '62', 'x22', 'x26', 'x27', 'x3c', 'x3e'):
            text = '&#%s;' % ref
        else:
            if ref[0] == 'x':
                c = int(ref[1:], 16)
            else:
                c = int(ref)
            text = unichr(c).encode('utf-8')
        self.elementstack[-1][2].append(text)

    def handle_entityref(self, ref):
        # called for each entity reference, e.g. for '&copy;', ref will be 'copy'
        if not self.elementstack: return
        if _debug: sys.stderr.write('entering handle_entityref with %s\n' % ref)
        if ref in ('lt', 'gt', 'quot', 'amp', 'apos'):
            text = '&%s;' % ref
        else:
            # entity resolution graciously donated by Aaron Swartz
            def name2cp(k):
                import htmlentitydefs
                if hasattr(htmlentitydefs, 'name2codepoint'): # requires Python 2.3
                    return htmlentitydefs.name2codepoint[k]
                k = htmlentitydefs.entitydefs[k]
                if k.startswith('&#') and k.endswith(';'):
                    return int(k[2:-1]) # not in latin-1
                return ord(k)
            try: name2cp(ref)
            except KeyError: text = '&%s;' % ref
            else: text = unichr(name2cp(ref)).encode('utf-8')
        self.elementstack[-1][2].append(text)

    def handle_data(self, text, escape=1):
        # called for each block of plain text, i.e. outside of any tag and
        # not containing any character or entity references
        if not self.elementstack: return
        if escape and self.contentparams.get('type') == 'application/xhtml+xml':
            text = _xmlescape(text)
        self.elementstack[-1][2].append(text)

    def handle_comment(self, text):
        # called for each comment, e.g. <!-- insert message here -->
        pass

    def handle_pi(self, text):
        # called for each processing instruction, e.g. <?instruction>
        pass

    def handle_decl(self, text):
        pass

    def parse_declaration(self, i):
        # override internal declaration handler to handle CDATA blocks
        if _debug: sys.stderr.write('entering parse_declaration\n')
        if self.rawdata[i:i+9] == '<![CDATA[':
            k = self.rawdata.find(']]>', i)
            if k == -1: k = len(self.rawdata)
            self.handle_data(_xmlescape(self.rawdata[i+9:k]), 0)
            return k+3
        else:
            k = self.rawdata.find('>', i)
            return k+1

    def mapContentType(self, contentType):
        contentType = contentType.lower()
        if contentType == 'text':
            contentType = 'text/plain'
        elif contentType == 'html':
            contentType = 'text/html'
        elif contentType == 'xhtml':
            contentType = 'application/xhtml+xml'
        return contentType
    
    def trackNamespace(self, prefix, uri):
        loweruri = uri.lower()
        if (prefix, loweruri) == (None, 'http://my.netscape.com/rdf/simple/0.9/') and not self.version:
            self.version = 'rss090'
        if loweruri == 'http://purl.org/rss/1.0/' and not self.version:
            self.version = 'rss10'
        if loweruri == 'http://www.w3.org/2005/atom' and not self.version:
            self.version = 'atom10'
        if loweruri.find('backend.userland.com/rss') <> -1:
            # match any backend.userland.com namespace
            uri = 'http://backend.userland.com/rss'
            loweruri = uri
        if self._matchnamespaces.has_key(loweruri):
            self.namespacemap[prefix] = self._matchnamespaces[loweruri]
            self.namespacesInUse[self._matchnamespaces[loweruri]] = uri
        else:
            self.namespacesInUse[prefix or ''] = uri

    def resolveURI(self, uri):
        return _urljoin(self.baseuri or '', uri)
    
    def decodeEntities(self, element, data):
        return data

    def push(self, element, expectingText):
        self.elementstack.append([element, expectingText, []])

    def pop(self, element, stripWhitespace=1):
        if not self.elementstack: return
        if self.elementstack[-1][0] != element: return
        
        element, expectingText, pieces = self.elementstack.pop()
        output = ''.join(pieces)
        if stripWhitespace:
            output = output.strip()
        if not expectingText: return output

        # decode base64 content
        if base64 and self.contentparams.get('base64', 0):
            try:
                output = base64.decodestring(output)
            except binascii.Error:
                pass
            except binascii.Incomplete:
                pass
                
        # resolve relative URIs
        if (element in self.can_be_relative_uri) and output:
            output = self.resolveURI(output)
        
        # decode entities within embedded markup
        if not self.contentparams.get('base64', 0):
            output = self.decodeEntities(element, output)

        # remove temporary cruft from contentparams
        try:
            del self.contentparams['mode']
        except KeyError:
            pass
        try:
            del self.contentparams['base64']
        except KeyError:
            pass

        # resolve relative URIs within embedded markup
        if self.mapContentType(self.contentparams.get('type', 'text/html')) in self.html_types:
            if element in self.can_contain_relative_uris:
                output = _resolveRelativeURIs(output, self.baseuri, self.encoding)
        
        # sanitize embedded markup
        if self.mapContentType(self.contentparams.get('type', 'text/html')) in self.html_types:
            if element in self.can_contain_dangerous_markup:
                output = _sanitizeHTML(output, self.encoding)

        if self.encoding and type(output) != type(u''):
            try:
                output = unicode(output, self.encoding)
            except:
                pass

        # categories/tags/keywords/whatever are handled in _end_category
        if element == 'category':
            return output
        
        # store output in appropriate place(s)
        if self.inentry and not self.insource:
            if element == 'content':
                self.entries[-1].setdefault(element, [])
                contentparams = copy.deepcopy(self.contentparams)
                contentparams['value'] = output
                self.entries[-1][element].append(contentparams)
            elif element == 'link':
                self.entries[-1][element] = output
                if output:
                    self.entries[-1]['links'][-1]['href'] = output
            else:
                if element == 'description':
                    element = 'summary'
                self.entries[-1][element] = output
                if self.incontent:
                    contentparams = copy.deepcopy(self.contentparams)
                    contentparams['value'] = output
                    self.entries[-1][element + '_detail'] = contentparams
        elif (self.infeed or self.insource) and (not self.intextinput) and (not self.inimage):
            context = self._getContext()
            if element == 'description':
                element = 'subtitle'
            context[element] = output
            if element == 'link':
                context['links'][-1]['href'] = output
            elif self.incontent:
                contentparams = copy.deepcopy(self.contentparams)
                contentparams['value'] = output
                context[element + '_detail'] = contentparams
        return output

    def pushContent(self, tag, attrsD, defaultContentType, expectingText):
        self.incontent += 1
        self.contentparams = FeedParserDict({
            'type': self.mapContentType(attrsD.get('type', defaultContentType)),
            'language': self.lang,
            'base': self.baseuri})
        self.contentparams['base64'] = self._isBase64(attrsD, self.contentparams)
        self.push(tag, expectingText)

    def popContent(self, tag):
        value = self.pop(tag)
        self.incontent -= 1
        self.contentparams.clear()
        return value
        
    def _mapToStandardPrefix(self, name):
        colonpos = name.find(':')
        if colonpos <> -1:
            prefix = name[:colonpos]
            suffix = name[colonpos+1:]
            prefix = self.namespacemap.get(prefix, prefix)
            name = prefix + ':' + suffix
        return name
        
    def _getAttribute(self, attrsD, name):
        return attrsD.get(self._mapToStandardPrefix(name))

    def _isBase64(self, attrsD, contentparams):
        if attrsD.get('mode', '') == 'base64':
            return 1
        if self.contentparams['type'].startswith('text/'):
            return 0
        if self.contentparams['type'].endswith('+xml'):
            return 0
        if self.contentparams['type'].endswith('/xml'):
            return 0
        return 1

    def _itsAnHrefDamnIt(self, attrsD):
        href = attrsD.get('url', attrsD.get('uri', attrsD.get('href', None)))
        if href:
            try:
                del attrsD['url']
            except KeyError:
                pass
            try:
                del attrsD['uri']
            except KeyError:
                pass
            attrsD['href'] = href
        return attrsD
    
    def _save(self, key, value):
        context = self._getContext()
        context.setdefault(key, value)

    def _start_rss(self, attrsD):
        versionmap = {'0.91': 'rss091u',
                      '0.92': 'rss092',
                      '0.93': 'rss093',
                      '0.94': 'rss094'}
        if not self.version:
            attr_version = attrsD.get('version', '')
            version = versionmap.get(attr_version)
            if version:
                self.version = version
            elif attr_version.startswith('2.'):
                self.version = 'rss20'
            else:
                self.version = 'rss'
    
    def _start_dlhottitles(self, attrsD):
        self.version = 'hotrss'

    def _start_channel(self, attrsD):
        self.infeed = 1
        self._cdf_common(attrsD)
    _start_feedinfo = _start_channel

    def _cdf_common(self, attrsD):
        if attrsD.has_key('lastmod'):
            self._start_modified({})
            self.elementstack[-1][-1] = attrsD['lastmod']
            self._end_modified()
        if attrsD.has_key('href'):
            self._start_link({})
            self.elementstack[-1][-1] = attrsD['href']
            self._end_link()
    
    def _start_feed(self, attrsD):
        self.infeed = 1
        versionmap = {'0.1': 'atom01',
                      '0.2': 'atom02',
                      '0.3': 'atom03'}
        if not self.version:
            attr_version = attrsD.get('version')
            version = versionmap.get(attr_version)
            if version:
                self.version = version
            else:
                self.version = 'atom'

    def _end_channel(self):
        self.infeed = 0
    _end_feed = _end_channel
    
    def _start_image(self, attrsD):
        self.inimage = 1
        self.push('image', 0)
        context = self._getContext()
        context.setdefault('image', FeedParserDict())
            
    def _end_image(self):
        self.pop('image')
        self.inimage = 0

    def _start_textinput(self, attrsD):
        self.intextinput = 1
        self.push('textinput', 0)
        context = self._getContext()
        context.setdefault('textinput', FeedParserDict())
    _start_textInput = _start_textinput
    
    def _end_textinput(self):
        self.pop('textinput')
        self.intextinput = 0
    _end_textInput = _end_textinput

    def _start_author(self, attrsD):
        self.inauthor = 1
        self.push('author', 1)
    _start_managingeditor = _start_author
    _start_dc_author = _start_author
    _start_dc_creator = _start_author
    _start_itunes_author = _start_author

    def _end_author(self):
        self.pop('author')
        self.inauthor = 0
        self._sync_author_detail()
    _end_managingeditor = _end_author
    _end_dc_author = _end_author
    _end_dc_creator = _end_author
    _end_itunes_author = _end_author

    def _start_itunes_owner(self, attrsD):
        self.inpublisher = 1
        self.push('publisher', 0)

    def _end_itunes_owner(self):
        self.pop('publisher')
        self.inpublisher = 0
        self._sync_author_detail('publisher')

    def _start_contributor(self, attrsD):
        self.incontributor = 1
        context = self._getContext()
        context.setdefault('contributors', [])
        context['contributors'].append(FeedParserDict())
        self.push('contributor', 0)

    def _end_contributor(self):
        self.pop('contributor')
        self.incontributor = 0

    def _start_dc_contributor(self, attrsD):
        self.incontributor = 1
        context = self._getContext()
        context.setdefault('contributors', [])
        context['contributors'].append(FeedParserDict())
        self.push('name', 0)

    def _end_dc_contributor(self):
        self._end_name()
        self.incontributor = 0

    def _start_name(self, attrsD):
        self.push('name', 0)
    _start_itunes_name = _start_name

    def _end_name(self):
        value = self.pop('name')
        if self.inpublisher:
            self._save_author('name', value, 'publisher')
        elif self.inauthor:
            self._save_author('name', value)
        elif self.incontributor:
            self._save_contributor('name', value)
        elif self.intextinput:
            context = self._getContext()
            context['textinput']['name'] = value
    _end_itunes_name = _end_name

    def _start_width(self, attrsD):
        self.push('width', 0)

    def _end_width(self):
        value = self.pop('width')
        try:
            value = int(value)
        except:
            value = 0
        if self.inimage:
            context = self._getContext()
            context['image']['width'] = value

    def _start_height(self, attrsD):
        self.push('height', 0)

    def _end_height(self):
        value = self.pop('height')
        try:
            value = int(value)
        except:
            value = 0
        if self.inimage:
            context = self._getContext()
            context['image']['height'] = value

    def _start_url(self, attrsD):
        self.push('href', 1)
    _start_homepage = _start_url
    _start_uri = _start_url

    def _end_url(self):
        value = self.pop('href')
        if self.inauthor:
            self._save_author('href', value)
        elif self.incontributor:
            self._save_contributor('href', value)
        elif self.inimage:
            context = self._getContext()
            context['image']['href'] = value
        elif self.intextinput:
            context = self._getContext()
            context['textinput']['link'] = value
    _end_homepage = _end_url
    _end_uri = _end_url

    def _start_email(self, attrsD):
        self.push('email', 0)
    _start_itunes_email = _start_email

    def _end_email(self):
        value = self.pop('email')
        if self.inpublisher:
            self._save_author('email', value, 'publisher')
        elif self.inauthor:
            self._save_author('email', value)
        elif self.incontributor:
            self._save_contributor('email', value)
    _end_itunes_email = _end_email

    def _getContext(self):
        if self.insource:
            context = self.sourcedata
        elif self.inentry:
            context = self.entries[-1]
        else:
            context = self.feeddata
        return context

    def _save_author(self, key, value, prefix='author'):
        context = self._getContext()
        context.setdefault(prefix + '_detail', FeedParserDict())
        context[prefix + '_detail'][key] = value
        self._sync_author_detail()

    def _save_contributor(self, key, value):
        context = self._getContext()
        context.setdefault('contributors', [FeedParserDict()])
        context['contributors'][-1][key] = value

    def _sync_author_detail(self, key='author'):
        context = self._getContext()
        detail = context.get('%s_detail' % key)
        if detail:
            name = detail.get('name')
            email = detail.get('email')
            if name and email:
                context[key] = '%s (%s)' % (name, email)
            elif name:
                context[key] = name
            elif email:
                context[key] = email
        else:
            author = context.get(key)
            if not author: return
            emailmatch = re.search(r'''(([a-zA-Z0-9\_\-\.\+]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?))''', author)
            if not emailmatch: return
            email = emailmatch.group(0)
            # probably a better way to do the following, but it passes all the tests
            author = author.replace(email, '')
            author = author.replace('()', '')
            author = author.strip()
            if author and (author[0] == '('):
                author = author[1:]
            if author and (author[-1] == ')'):
                author = author[:-1]
            author = author.strip()
            context.setdefault('%s_detail' % key, FeedParserDict())
            context['%s_detail' % key]['name'] = author
            context['%s_detail' % key]['email'] = email

    def _start_subtitle(self, attrsD):
        self.pushContent('subtitle', attrsD, 'text/plain', 1)
    _start_tagline = _start_subtitle
    _start_itunes_subtitle = _start_subtitle

    def _end_subtitle(self):
        self.popContent('subtitle')
    _end_tagline = _end_subtitle
    _end_itunes_subtitle = _end_subtitle
            
    def _start_rights(self, attrsD):
        self.pushContent('rights', attrsD, 'text/plain', 1)
    _start_dc_rights = _start_rights
    _start_copyright = _start_rights

    def _end_rights(self):
        self.popContent('rights')
    _end_dc_rights = _end_rights
    _end_copyright = _end_rights

    def _start_item(self, attrsD):
        self.entries.append(FeedParserDict())
        self.push('item', 0)
        self.inentry = 1
        self.guidislink = 0
        id = self._getAttribute(attrsD, 'rdf:about')
        if id:
            context = self._getContext()
            context['id'] = id
        self._cdf_common(attrsD)
    _start_entry = _start_item
    _start_product = _start_item

    def _end_item(self):
        self.pop('item')
        self.inentry = 0
    _end_entry = _end_item

    def _start_dc_language(self, attrsD):
        self.push('language', 1)
    _start_language = _start_dc_language

    def _end_dc_language(self):
        self.lang = self.pop('language')
    _end_language = _end_dc_language

    def _start_dc_publisher(self, attrsD):
        self.push('publisher', 1)
    _start_webmaster = _start_dc_publisher

    def _end_dc_publisher(self):
        self.pop('publisher')
        self._sync_author_detail('publisher')
    _end_webmaster = _end_dc_publisher

    def _start_published(self, attrsD):
        self.push('published', 1)
    _start_dcterms_issued = _start_published
    _start_issued = _start_published

    def _end_published(self):
        value = self.pop('published')
        self._save('published_parsed', _parse_date(value))
    _end_dcterms_issued = _end_published
    _end_issued = _end_published

    def _start_updated(self, attrsD):
        self.push('updated', 1)
    _start_modified = _start_updated
    _start_dcterms_modified = _start_updated
    _start_pubdate = _start_updated
    _start_dc_date = _start_updated

    def _end_updated(self):
        value = self.pop('updated')
        parsed_value = _parse_date(value)
        self._save('updated_parsed', parsed_value)
    _end_modified = _end_updated
    _end_dcterms_modified = _end_updated
    _end_pubdate = _end_updated
    _end_dc_date = _end_updated

    def _start_created(self, attrsD):
        self.push('created', 1)
    _start_dcterms_created = _start_created

    def _end_created(self):
        value = self.pop('created')
        self._save('created_parsed', _parse_date(value))
    _end_dcterms_created = _end_created

    def _start_expirationdate(self, attrsD):
        self.push('expired', 1)

    def _end_expirationdate(self):
        self._save('expired_parsed', _parse_date(self.pop('expired')))

    def _start_cc_license(self, attrsD):
        self.push('license', 1)
        value = self._getAttribute(attrsD, 'rdf:resource')
        if value:
            self.elementstack[-1][2].append(value)
        self.pop('license')
        
    def _start_creativecommons_license(self, attrsD):
        self.push('license', 1)

    def _end_creativecommons_license(self):
        self.pop('license')

    def _addTag(self, term, scheme, label):
        context = self._getContext()
        tags = context.setdefault('tags', [])
        if (not term) and (not scheme) and (not label): return
        value = FeedParserDict({'term': term, 'scheme': scheme, 'label': label})
        if value not in tags:
            tags.append(FeedParserDict({'term': term, 'scheme': scheme, 'label': label}))

    def _start_category(self, attrsD):
        if _debug: sys.stderr.write('entering _start_category with %s\n' % repr(attrsD))
        term = attrsD.get('term')
        scheme = attrsD.get('scheme', attrsD.get('domain'))
        label = attrsD.get('label')
        self._addTag(term, scheme, label)
        self.push('category', 1)
    _start_dc_subject = _start_category
    _start_keywords = _start_category
        
    def _end_itunes_keywords(self):
        for term in self.pop('itunes_keywords').split():
            self._addTag(term, 'http://www.itunes.com/', None)
        
    def _start_itunes_category(self, attrsD):
        self._addTag(attrsD.get('text'), 'http://www.itunes.com/', None)
        self.push('category', 1)
        
    def _end_category(self):
        value = self.pop('category')
        if not value: return
        context = self._getContext()
        tags = context['tags']
        if value and len(tags) and not tags[-1]['term']:
            tags[-1]['term'] = value
        else:
            self._addTag(value, None, None)
    _end_dc_subject = _end_category
    _end_keywords = _end_category
    _end_itunes_category = _end_category

    def _start_cloud(self, attrsD):
        self._getContext()['cloud'] = FeedParserDict(attrsD)
        
    def _start_link(self, attrsD):
        attrsD.setdefault('rel', 'alternate')
        attrsD.setdefault('type', 'text/html')
        attrsD = self._itsAnHrefDamnIt(attrsD)
        if attrsD.has_key('href'):
            attrsD['href'] = self.resolveURI(attrsD['href'])
        expectingText = self.infeed or self.inentry or self.insource
        context = self._getContext()
        context.setdefault('links', [])
        context['links'].append(FeedParserDict(attrsD))
        if attrsD['rel'] == 'enclosure':
            self._start_enclosure(attrsD)
        if attrsD.has_key('href'):
            expectingText = 0
            if (attrsD.get('rel') == 'alternate') and (self.mapContentType(attrsD.get('type')) in self.html_types):
                context['link'] = attrsD['href']
        else:
            self.push('link', expectingText)
    _start_producturl = _start_link

    def _end_link(self):
        value = self.pop('link')
        context = self._getContext()
        if self.intextinput:
            context['textinput']['link'] = value
        if self.inimage:
            context['image']['link'] = value
    _end_producturl = _end_link

    def _start_guid(self, attrsD):
        self.guidislink = (attrsD.get('ispermalink', 'true') == 'true')
        self.push('id', 1)

    def _end_guid(self):
        value = self.pop('id')
        self._save('guidislink', self.guidislink and not self._getContext().has_key('link'))
        if self.guidislink:
            # guid acts as link, but only if 'ispermalink' is not present or is 'true',
            # and only if the item doesn't already have a link element
            self._save('link', value)

    def _start_title(self, attrsD):
        self.pushContent('title', attrsD, 'text/plain', self.infeed or self.inentry or self.insource)
    _start_dc_title = _start_title
    _start_media_title = _start_title

    def _end_title(self):
        value = self.popContent('title')
        context = self._getContext()
        if self.intextinput:
            context['textinput']['title'] = value
        elif self.inimage:
            context['image']['title'] = value
    _end_dc_title = _end_title
    _end_media_title = _end_title

    def _start_description(self, attrsD):
        context = self._getContext()
        if context.has_key('summary'):
            self._summaryKey = 'content'
            self._start_content(attrsD)
        else:
            self.pushContent('description', attrsD, 'text/html', self.infeed or self.inentry or self.insource)

    def _start_abstract(self, attrsD):
        self.pushContent('description', attrsD, 'text/plain', self.infeed or self.inentry or self.insource)

    def _end_description(self):
        if self._summaryKey == 'content':
            self._end_content()
        else:
            value = self.popContent('description')
            context = self._getContext()
            if self.intextinput:
                context['textinput']['description'] = value
            elif self.inimage:
                context['image']['description'] = value
        self._summaryKey = None
    _end_abstract = _end_description

    def _start_info(self, attrsD):
        self.pushContent('info', attrsD, 'text/plain', 1)
    _start_feedburner_browserfriendly = _start_info

    def _end_info(self):
        self.popContent('info')
    _end_feedburner_browserfriendly = _end_info

    def _start_generator(self, attrsD):
        if attrsD:
            attrsD = self._itsAnHrefDamnIt(attrsD)
            if attrsD.has_key('href'):
                attrsD['href'] = self.resolveURI(attrsD['href'])
        self._getContext()['generator_detail'] = FeedParserDict(attrsD)
        self.push('generator', 1)

    def _end_generator(self):
        value = self.pop('generator')
        context = self._getContext()
        if context.has_key('generator_detail'):
            context['generator_detail']['name'] = value
            
    def _start_admin_generatoragent(self, attrsD):
        self.push('generator', 1)
        value = self._getAttribute(attrsD, 'rdf:resource')
        if value:
            self.elementstack[-1][2].append(value)
        self.pop('generator')
        self._getContext()['generator_detail'] = FeedParserDict({'href': value})

    def _start_admin_errorreportsto(self, attrsD):
        self.push('errorreportsto', 1)
        value = self._getAttribute(attrsD, 'rdf:resource')
        if value:
            self.elementstack[-1][2].append(value)
        self.pop('errorreportsto')
        
    def _start_summary(self, attrsD):
        context = self._getContext()
        if context.has_key('summary'):
            self._summaryKey = 'content'
            self._start_content(attrsD)
        else:
            self._summaryKey = 'summary'
            self.pushContent(self._summaryKey, attrsD, 'text/plain', 1)
    _start_itunes_summary = _start_summary

    def _end_summary(self):
        if self._summaryKey == 'content':
            self._end_content()
        else:
            self.popContent(self._summaryKey or 'summary')
        self._summaryKey = None
    _end_itunes_summary = _end_summary
        
    def _start_enclosure(self, attrsD):
        attrsD = self._itsAnHrefDamnIt(attrsD)
        self._getContext().setdefault('enclosures', []).append(FeedParserDict(attrsD))
        href = attrsD.get('href')
        if href:
            context = self._getContext()
            if not context.get('id'):
                context['id'] = href
            
    def _start_source(self, attrsD):
        self.insource = 1

    def _end_source(self):
        self.insource = 0
        self._getContext()['source'] = copy.deepcopy(self.sourcedata)
        self.sourcedata.clear()

    def _start_content(self, attrsD):
        self.pushContent('content', attrsD, 'text/plain', 1)
        src = attrsD.get('src')
        if src:
            self.contentparams['src'] = src
        self.push('content', 1)

    def _start_prodlink(self, attrsD):
        self.pushContent('content', attrsD, 'text/html', 1)

    def _start_body(self, attrsD):
        self.pushContent('content', attrsD, 'application/xhtml+xml', 1)
    _start_xhtml_body = _start_body

    def _start_content_encoded(self, attrsD):
        self.pushContent('content', attrsD, 'text/html', 1)
    _start_fullitem = _start_content_encoded

    def _end_content(self):
        copyToDescription = self.mapContentType(self.contentparams.get('type')) in (['text/plain'] + self.html_types)
        value = self.popContent('content')
        if copyToDescription:
            self._save('description', value)
    _end_body = _end_content
    _end_xhtml_body = _end_content
    _end_content_encoded = _end_content
    _end_fullitem = _end_content
    _end_prodlink = _end_content

    def _start_itunes_image(self, attrsD):
        self.push('itunes_image', 0)
        self._getContext()['image'] = FeedParserDict({'href': attrsD.get('href')})
    _start_itunes_link = _start_itunes_image
        
    def _end_itunes_block(self):
        value = self.pop('itunes_block', 0)
        self._getContext()['itunes_block'] = (value == 'yes') and 1 or 0

    def _end_itunes_explicit(self):
        value = self.pop('itunes_explicit', 0)
        self._getContext()['itunes_explicit'] = (value == 'yes') and 1 or 0

if _XML_AVAILABLE:
    class _StrictFeedParser(_FeedParserMixin, xml.sax.handler.ContentHandler):
        def __init__(self, baseuri, baselang, encoding):
            if _debug: sys.stderr.write('trying StrictFeedParser\n')
            xml.sax.handler.ContentHandler.__init__(self)
            _FeedParserMixin.__init__(self, baseuri, baselang, encoding)
            self.bozo = 0
            self.exc = None
        
        def startPrefixMapping(self, prefix, uri):
            self.trackNamespace(prefix, uri)
        
        def startElementNS(self, name, qname, attrs):
            namespace, localname = name
            lowernamespace = str(namespace or '').lower()
            if lowernamespace.find('backend.userland.com/rss') <> -1:
                # match any backend.userland.com namespace
                namespace = 'http://backend.userland.com/rss'
                lowernamespace = namespace
            if qname and qname.find(':') > 0:
                givenprefix = qname.split(':')[0]
            else:
                givenprefix = None
            prefix = self._matchnamespaces.get(lowernamespace, givenprefix)
            if givenprefix and (prefix == None or (prefix == '' and lowernamespace == '')) and not self.namespacesInUse.has_key(givenprefix):
                    raise UndeclaredNamespace, "'%s' is not associated with a namespace" % givenprefix
            if prefix:
                localname = prefix + ':' + localname
            localname = str(localname).lower()
            if _debug: sys.stderr.write('startElementNS: qname = %s, namespace = %s, givenprefix = %s, prefix = %s, attrs = %s, localname = %s\n' % (qname, namespace, givenprefix, prefix, attrs.items(), localname))

            # qname implementation is horribly broken in Python 2.1 (it
            # doesn't report any), and slightly broken in Python 2.2 (it
            # doesn't report the xml: namespace). So we match up namespaces
            # with a known list first, and then possibly override them with
            # the qnames the SAX parser gives us (if indeed it gives us any
            # at all).  Thanks to MatejC for helping me test this and
            # tirelessly telling me that it didn't work yet.
            attrsD = {}
            for (namespace, attrlocalname), attrvalue in attrs._attrs.items():
                lowernamespace = (namespace or '').lower()
                prefix = self._matchnamespaces.get(lowernamespace, '')
                if prefix:
                    attrlocalname = prefix + ':' + attrlocalname
                attrsD[str(attrlocalname).lower()] = attrvalue
            for qname in attrs.getQNames():
                attrsD[str(qname).lower()] = attrs.getValueByQName(qname)
            self.unknown_starttag(localname, attrsD.items())

        def characters(self, text):
            self.handle_data(text)

        def endElementNS(self, name, qname):
            namespace, localname = name
            lowernamespace = str(namespace or '').lower()
            if qname and qname.find(':') > 0:
                givenprefix = qname.split(':')[0]
            else:
                givenprefix = ''
            prefix = self._matchnamespaces.get(lowernamespace, givenprefix)
            if prefix:
                localname = prefix + ':' + localname
            localname = str(localname).lower()
            self.unknown_endtag(localname)

        def error(self, exc):
            self.bozo = 1
            self.exc = exc
            
        def fatalError(self, exc):
            self.error(exc)
            raise exc

class _BaseHTMLProcessor(sgmllib.SGMLParser):
    elements_no_end_tag = ['area', 'base', 'basefont', 'br', 'col', 'frame', 'hr',
      'img', 'input', 'isindex', 'link', 'meta', 'param']
    
    def __init__(self, encoding):
        self.encoding = encoding
        if _debug: sys.stderr.write('entering BaseHTMLProcessor, encoding=%s\n' % self.encoding)
        sgmllib.SGMLParser.__init__(self)
        
    def reset(self):
        self.pieces = []
        sgmllib.SGMLParser.reset(self)

    def _shorttag_replace(self, match):
        tag = match.group(1)
        if tag in self.elements_no_end_tag:
            return '<' + tag + ' />'
        else:
            return '<' + tag + '></' + tag + '>'
        
    def feed(self, data):
        data = re.compile(r'<!((?!DOCTYPE|--|\[))', re.IGNORECASE).sub(r'&lt;!\1', data)
        #data = re.sub(r'<(\S+?)\s*?/>', self._shorttag_replace, data) # bug [ 1399464 ] Bad regexp for _shorttag_replace
        data = re.sub(r'<([^<\s]+?)\s*/>', self._shorttag_replace, data) 
        data = data.replace('&#39;', "'")
        data = data.replace('&#34;', '"')
        if self.encoding and type(data) == type(u''):
            data = data.encode(self.encoding)
        sgmllib.SGMLParser.feed(self, data)

    def normalize_attrs(self, attrs):
        # utility method to be called by descendants
        attrs = [(k.lower(), v) for k, v in attrs]
        attrs = [(k, k in ('rel', 'type') and v.lower() or v) for k, v in attrs]
        return attrs

    def unknown_starttag(self, tag, attrs):
        # called for each start tag
        # attrs is a list of (attr, value) tuples
        # e.g. for <pre class='screen'>, tag='pre', attrs=[('class', 'screen')]
        if _debug: sys.stderr.write('_BaseHTMLProcessor, unknown_starttag, tag=%s\n' % tag)
        uattrs = []
        # thanks to Kevin Marks for this breathtaking hack to deal with (valid) high-bit attribute values in UTF-8 feeds
        for key, value in attrs:
            if type(value) != type(u''):
                value = unicode(value, self.encoding)
            uattrs.append((unicode(key, self.encoding), value))
        strattrs = u''.join([u' %s="%s"' % (key, value) for key, value in uattrs]).encode(self.encoding)
        if tag in self.elements_no_end_tag:
            self.pieces.append('<%(tag)s%(strattrs)s />' % locals())
        else:
            self.pieces.append('<%(tag)s%(strattrs)s>' % locals())

    def unknown_endtag(self, tag):
        # called for each end tag, e.g. for </pre>, tag will be 'pre'
        # Reconstruct the original end tag.
        if tag not in self.elements_no_end_tag:
            self.pieces.append("</%(tag)s>" % locals())

    def handle_charref(self, ref):
        # called for each character reference, e.g. for '&#160;', ref will be '160'
        # Reconstruct the original character reference.
        self.pieces.append('&#%(ref)s;' % locals())
        
    def handle_entityref(self, ref):
        # called for each entity reference, e.g. for '&copy;', ref will be 'copy'
        # Reconstruct the original entity reference.
        self.pieces.append('&%(ref)s;' % locals())

    def handle_data(self, text):
        # called for each block of plain text, i.e. outside of any tag and
        # not containing any character or entity references
        # Store the original text verbatim.
        if _debug: sys.stderr.write('_BaseHTMLProcessor, handle_text, text=%s\n' % text)
        self.pieces.append(text)
        
    def handle_comment(self, text):
        # called for each HTML comment, e.g. <!-- insert Javascript code here -->
        # Reconstruct the original comment.
        self.pieces.append('<!--%(text)s-->' % locals())
        
    def handle_pi(self, text):
        # called for each processing instruction, e.g. <?instruction>
        # Reconstruct original processing instruction.
        self.pieces.append('<?%(text)s>' % locals())

    def handle_decl(self, text):
        # called for the DOCTYPE, if present, e.g.
        # <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        #     "http://www.w3.org/TR/html4/loose.dtd">
        # Reconstruct original DOCTYPE
        self.pieces.append('<!%(text)s>' % locals())
        
    _new_declname_match = re.compile(r'[a-zA-Z][-_.a-zA-Z0-9:]*\s*').match
    def _scan_name(self, i, declstartpos):
        rawdata = self.rawdata
        n = len(rawdata)
        if i == n:
            return None, -1
        m = self._new_declname_match(rawdata, i)
        if m:
            s = m.group()
            name = s.strip()
            if (i + len(s)) == n:
                return None, -1  # end of buffer
            return name.lower(), m.end()
        else:
            self.handle_data(rawdata)
#            self.updatepos(declstartpos, i)
            return None, -1

    def output(self):
        '''Return processed HTML as a single string'''
        return ''.join([str(p) for p in self.pieces])

class _LooseFeedParser(_FeedParserMixin, _BaseHTMLProcessor):
    def __init__(self, baseuri, baselang, encoding):
        sgmllib.SGMLParser.__init__(self)
        _FeedParserMixin.__init__(self, baseuri, baselang, encoding)

    def decodeEntities(self, element, data):
        data = data.replace('&#60;', '&lt;')
        data = data.replace('&#x3c;', '&lt;')
        data = data.replace('&#62;', '&gt;')
        data = data.replace('&#x3e;', '&gt;')
        data = data.replace('&#38;', '&amp;')
        data = data.replace('&#x26;', '&amp;')
        data = data.replace('&#34;', '&quot;')
        data = data.replace('&#x22;', '&quot;')
        data = data.replace('&#39;', '&apos;')
        data = data.replace('&#x27;', '&apos;')
        if self.contentparams.has_key('type') and not self.contentparams.get('type', 'xml').endswith('xml'):
            data = data.replace('&lt;', '<')
            data = data.replace('&gt;', '>')
            data = data.replace('&amp;', '&')
            data = data.replace('&quot;', '"')
            data = data.replace('&apos;', "'")
        return data
        
class _RelativeURIResolver(_BaseHTMLProcessor):
    relative_uris = [('a', 'href'),
                     ('applet', 'codebase'),
                     ('area', 'href'),
                     ('blockquote', 'cite'),
                     ('body', 'background'),
                     ('del', 'cite'),
                     ('form', 'action'),
                     ('frame', 'longdesc'),
                     ('frame', 'src'),
                     ('iframe', 'longdesc'),
                     ('iframe', 'src'),
                     ('head', 'profile'),
                     ('img', 'longdesc'),
                     ('img', 'src'),
                     ('img', 'usemap'),
                     ('input', 'src'),
                     ('input', 'usemap'),
                     ('ins', 'cite'),
                     ('link', 'href'),
                     ('object', 'classid'),
                     ('object', 'codebase'),
                     ('object', 'data'),
                     ('object', 'usemap'),
                     ('q', 'cite'),
                     ('script', 'src')]

    def __init__(self, baseuri, encoding):
        _BaseHTMLProcessor.__init__(self, encoding)
        self.baseuri = baseuri

    def resolveURI(self, uri):
        return _urljoin(self.baseuri, uri)
    
    def unknown_starttag(self, tag, attrs):
        attrs = self.normalize_attrs(attrs)
        attrs = [(key, ((tag, key) in self.relative_uris) and self.resolveURI(value) or value) for key, value in attrs]
        _BaseHTMLProcessor.unknown_starttag(self, tag, attrs)
        
def _resolveRelativeURIs(htmlSource, baseURI, encoding):
    if _debug: sys.stderr.write('entering _resolveRelativeURIs\n')
    p = _RelativeURIResolver(baseURI, encoding)
    p.feed(htmlSource)
    return p.output()

class _HTMLSanitizer(_BaseHTMLProcessor):
    acceptable_elements = ['a', 'abbr', 'acronym', 'address', 'area', 'b', 'big',
      'blockquote', 'br', 'button', 'caption', 'center', 'cite', 'code', 'col',
      'colgroup', 'dd', 'del', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset',
      'font', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'input',
      'ins', 'kbd', 'label', 'legend', 'li', 'map', 'menu', 'ol', 'optgroup',
      'option', 'p', 'pre', 'q', 's', 'samp', 'select', 'small', 'span', 'strike',
      'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th',
      'thead', 'tr', 'tt', 'u', 'ul', 'var']

    acceptable_attributes = ['abbr', 'accept', 'accept-charset', 'accesskey',
      'action', 'align', 'alt', 'axis', 'border', 'cellpadding', 'cellspacing',
      'char', 'charoff', 'charset', 'checked', 'cite', 'class', 'clear', 'cols',
      'colspan', 'color', 'compact', 'coords', 'datetime', 'dir', 'disabled',
      'enctype', 'for', 'frame', 'headers', 'height', 'href', 'hreflang', 'hspace',
      'id', 'ismap', 'label', 'lang', 'longdesc', 'maxlength', 'media', 'method',
      'multiple', 'name', 'nohref', 'noshade', 'nowrap', 'prompt', 'readonly',
      'rel', 'rev', 'rows', 'rowspan', 'rules', 'scope', 'selected', 'shape', 'size',
      'span', 'src', 'start', 'summary', 'tabindex', 'target', 'title', 'type',
      'usemap', 'valign', 'value', 'vspace', 'width']

    unacceptable_elements_with_end_tag = ['script', 'applet']

    def reset(self):
        _BaseHTMLProcessor.reset(self)
        self.unacceptablestack = 0
        
    def unknown_starttag(self, tag, attrs):
        if not tag in self.acceptable_elements:
            if tag in self.unacceptable_elements_with_end_tag:
                self.unacceptablestack += 1
            return
        attrs = self.normalize_attrs(attrs)
        attrs = [(key, value) for key, value in attrs if key in self.acceptable_attributes]
        _BaseHTMLProcessor.unknown_starttag(self, tag, attrs)
        
    def unknown_endtag(self, tag):
        if not tag in self.acceptable_elements:
            if tag in self.unacceptable_elements_with_end_tag:
                self.unacceptablestack -= 1
            return
        _BaseHTMLProcessor.unknown_endtag(self, tag)

    def handle_pi(self, text):
        pass

    def handle_decl(self, text):
        pass

    def handle_data(self, text):
        if not self.unacceptablestack:
            _BaseHTMLProcessor.handle_data(self, text)

def _sanitizeHTML(htmlSource, encoding):
    p = _HTMLSanitizer(encoding)
    p.feed(htmlSource)
    data = p.output()
    if TIDY_MARKUP:
        # loop through list of preferred Tidy interfaces looking for one that's installed,
        # then set up a common _tidy function to wrap the interface-specific API.
        _tidy = None
        for tidy_interface in PREFERRED_TIDY_INTERFACES:
            try:
                if tidy_interface == "uTidy":
                    from tidy import parseString as _utidy
                    def _tidy(data, **kwargs):
                        return str(_utidy(data, **kwargs))
                    break
                elif tidy_interface == "mxTidy":
                    from mx.Tidy import Tidy as _mxtidy
                    def _tidy(data, **kwargs):
                        nerrors, nwarnings, data, errordata = _mxtidy.tidy(data, **kwargs)
                        return data
                    break
            except:
                pass
        if _tidy:
            utf8 = type(data) == type(u'')
            if utf8:
                data = data.encode('utf-8')
            data = _tidy(data, output_xhtml=1, numeric_entities=1, wrap=0, char_encoding="utf8")
            if utf8:
                data = unicode(data, 'utf-8')
            if data.count('<body'):
                data = data.split('<body', 1)[1]
                if data.count('>'):
                    data = data.split('>', 1)[1]
            if data.count('</body'):
                data = data.split('</body', 1)[0]
    data = data.strip().replace('\r\n', '\n')
    return data

class _FeedURLHandler(urllib2.HTTPDigestAuthHandler, urllib2.HTTPRedirectHandler, urllib2.HTTPDefaultErrorHandler):
    def http_error_default(self, req, fp, code, msg, headers):
        if ((code / 100) == 3) and (code != 304):
            return self.http_error_302(req, fp, code, msg, headers)
        infourl = urllib.addinfourl(fp, headers, req.get_full_url())
        infourl.status = code
        return infourl

    def http_error_302(self, req, fp, code, msg, headers):
        if headers.dict.has_key('location'):
            infourl = urllib2.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers)
        else:
            infourl = urllib.addinfourl(fp, headers, req.get_full_url())
        if not hasattr(infourl, 'status'):
            infourl.status = code
        return infourl

    def http_error_301(self, req, fp, code, msg, headers):
        if headers.dict.has_key('location'):
            infourl = urllib2.HTTPRedirectHandler.http_error_301(self, req, fp, code, msg, headers)
        else:
            infourl = urllib.addinfourl(fp, headers, req.get_full_url())
        if not hasattr(infourl, 'status'):
            infourl.status = code
        return infourl

    http_error_300 = http_error_302
    http_error_303 = http_error_302
    http_error_307 = http_error_302
        
    def http_error_401(self, req, fp, code, msg, headers):
        # Check if
        # - server requires digest auth, AND
        # - we tried (unsuccessfully) with basic auth, AND
        # - we're using Python 2.3.3 or later (digest auth is irreparably broken in earlier versions)
        # If all conditions hold, parse authentication information
        # out of the Authorization header we sent the first time
        # (for the username and password) and the WWW-Authenticate
        # header the server sent back (for the realm) and retry
        # the request with the appropriate digest auth headers instead.
        # This evil genius hack has been brought to you by Aaron Swartz.
        host = urlparse.urlparse(req.get_full_url())[1]
        try:
            assert sys.version.split()[0] >= '2.3.3'
            assert base64 != None
            user, passw = base64.decodestring(req.headers['Authorization'].split(' ')[1]).split(':')
            realm = re.findall('realm="([^"]*)"', headers['WWW-Authenticate'])[0]
            self.add_password(realm, host, user, passw)
            retry = self.http_error_auth_reqed('www-authenticate', host, req, headers)
            self.reset_retry_count()
            return retry
        except:
            return self.http_error_default(req, fp, code, msg, headers)

def _open_resource(url_file_stream_or_string, etag, modified, agent, referrer, handlers):
    """URL, filename, or string --> stream

    This function lets you define parsers that take any input source
    (URL, pathname to local or network file, or actual data as a string)
    and deal with it in a uniform manner.  Returned object is guaranteed
    to have all the basic stdio read methods (read, readline, readlines).
    Just .close() the object when you're done with it.

    If the etag argument is supplied, it will be used as the value of an
    If-None-Match request header.

    If the modified argument is supplied, it must be a tuple of 9 integers
    as returned by gmtime() in the standard Python time module. This MUST
    be in GMT (Greenwich Mean Time). The formatted date/time will be used
    as the value of an If-Modified-Since request header.

    If the agent argument is supplied, it will be used as the value of a
    User-Agent request header.

    If the referrer argument is supplied, it will be used as the value of a
    Referer[sic] request header.

    If handlers is supplied, it is a list of handlers used to build a
    urllib2 opener.
    """

    if hasattr(url_file_stream_or_string, 'read'):
        return url_file_stream_or_string

    if url_file_stream_or_string == '-':
        return sys.stdin

    if urlparse.urlparse(url_file_stream_or_string)[0] in ('http', 'https', 'ftp'):
        if not agent:
            agent = USER_AGENT
        # test for inline user:password for basic auth
        auth = None
        if base64:
            urltype, rest = urllib.splittype(url_file_stream_or_string)
            realhost, rest = urllib.splithost(rest)
            if realhost:
                user_passwd, realhost = urllib.splituser(realhost)
                if user_passwd:
                    url_file_stream_or_string = '%s://%s%s' % (urltype, realhost, rest)
                    auth = base64.encodestring(user_passwd).strip()
        # try to open with urllib2 (to use optional headers)
        request = urllib2.Request(url_file_stream_or_string)
        request.add_header('User-Agent', agent)
        if etag:
            request.add_header('If-None-Match', etag)
        if modified:
            # format into an RFC 1123-compliant timestamp. We can't use
            # time.strftime() since the %a and %b directives can be affected
            # by the current locale, but RFC 2616 states that dates must be
            # in English.
            short_weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
            months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            request.add_header('If-Modified-Since', '%s, %02d %s %04d %02d:%02d:%02d GMT' % (short_weekdays[modified[6]], modified[2], months[modified[1] - 1], modified[0], modified[3], modified[4], modified[5]))
        if referrer:
            request.add_header('Referer', referrer)
        if gzip and zlib:
            request.add_header('Accept-encoding', 'gzip, deflate')
        elif gzip:
            request.add_header('Accept-encoding', 'gzip')
        elif zlib:
            request.add_header('Accept-encoding', 'deflate')
        else:
            request.add_header('Accept-encoding', '')
        if auth:
            request.add_header('Authorization', 'Basic %s' % auth)
        if ACCEPT_HEADER:
            request.add_header('Accept', ACCEPT_HEADER)
        request.add_header('A-IM', 'feed') # RFC 3229 support
        opener = apply(urllib2.build_opener, tuple([_FeedURLHandler()] + handlers))
        opener.addheaders = [] # RMK - must clear so we only send our custom User-Agent
        try:
            return opener.open(request)
        finally:
            opener.close() # JohnD
    
    # try to open with native open function (if url_file_stream_or_string is a filename)
    try:
        return open(url_file_stream_or_string)
    except:
        pass

    # treat url_file_stream_or_string as string
    return _StringIO(str(url_file_stream_or_string))

_date_handlers = []
def registerDateHandler(func):
    '''Register a date handler function (takes string, returns 9-tuple date in GMT)'''
    _date_handlers.insert(0, func)
    
# ISO-8601 date parsing routines written by Fazal Majid.
# The ISO 8601 standard is very convoluted and irregular - a full ISO 8601
# parser is beyond the scope of feedparser and would be a worthwhile addition
# to the Python library.
# A single regular expression cannot parse ISO 8601 date formats into groups
# as the standard is highly irregular (for instance is 030104 2003-01-04 or
# 0301-04-01), so we use templates instead.
# Please note the order in templates is significant because we need a
# greedy match.
_iso8601_tmpl = ['YYYY-?MM-?DD', 'YYYY-MM', 'YYYY-?OOO',
                'YY-?MM-?DD', 'YY-?OOO', 'YYYY', 
                '-YY-?MM', '-OOO', '-YY',
                '--MM-?DD', '--MM',
                '---DD',
                'CC', '']
_iso8601_re = [
    tmpl.replace(
    'YYYY', r'(?P<year>\d{4})').replace(
    'YY', r'(?P<year>\d\d)').replace(
    'MM', r'(?P<month>[01]\d)').replace(
    'DD', r'(?P<day>[0123]\d)').replace(
    'OOO', r'(?P<ordinal>[0123]\d\d)').replace(
    'CC', r'(?P<century>\d\d$)')
    + r'(T?(?P<hour>\d{2}):(?P<minute>\d{2})'
    + r'(:(?P<second>\d{2}))?'
    + r'(?P<tz>[+-](?P<tzhour>\d{2})(:(?P<tzmin>\d{2}))?|Z)?)?'
    for tmpl in _iso8601_tmpl]
del tmpl
_iso8601_matches = [re.compile(regex).match for regex in _iso8601_re]
del regex
def _parse_date_iso8601(dateString):
    '''Parse a variety of ISO-8601-compatible formats like 20040105'''
    m = None
    for _iso8601_match in _iso8601_matches:
        m = _iso8601_match(dateString)
        if m: break
    if not m: return
    if m.span() == (0, 0): return
    params = m.groupdict()
    ordinal = params.get('ordinal', 0)
    if ordinal:
        ordinal = int(ordinal)
    else:
        ordinal = 0
    year = params.get('year', '--')
    if not year or year == '--':
        year = time.gmtime()[0]
    elif len(year) == 2:
        # ISO 8601 assumes current century, i.e. 93 -> 2093, NOT 1993
        year = 100 * int(time.gmtime()[0] / 100) + int(year)
    else:
        year = int(year)
    month = params.get('month', '-')
    if not month or month == '-':
        # ordinals are NOT normalized by mktime, we simulate them
        # by setting month=1, day=ordinal
        if ordinal:
            month = 1
        else:
            month = time.gmtime()[1]
    month = int(month)
    day = params.get('day', 0)
    if not day:
        # see above
        if ordinal:
            day = ordinal
        elif params.get('century', 0) or \
                 params.get('year', 0) or params.get('month', 0):
            day = 1
        else:
            day = time.gmtime()[2]
    else:
        day = int(day)
    # special case of the century - is the first year of the 21st century
    # 2000 or 2001 ? The debate goes on...
    if 'century' in params.keys():
        year = (int(params['century']) - 1) * 100 + 1
    # in ISO 8601 most fields are optional
    for field in ['hour', 'minute', 'second', 'tzhour', 'tzmin']:
        if not params.get(field, None):
            params[field] = 0
    hour = int(params.get('hour', 0))
    minute = int(params.get('minute', 0))
    second = int(params.get('second', 0))
    # weekday is normalized by mktime(), we can ignore it
    weekday = 0
    # daylight savings is complex, but not needed for feedparser's purposes
    # as time zones, if specified, include mention of whether it is active
    # (e.g. PST vs. PDT, CET). Using -1 is implementation-dependent and
    # and most implementations have DST bugs
    daylight_savings_flag = 0
    tm = [year, month, day, hour, minute, second, weekday,
          ordinal, daylight_savings_flag]
    # ISO 8601 time zone adjustments
    tz = params.get('tz')
    if tz and tz != 'Z':
        if tz[0] == '-':
            tm[3] += int(params.get('tzhour', 0))
            tm[4] += int(params.get('tzmin', 0))
        elif tz[0] == '+':
            tm[3] -= int(params.get('tzhour', 0))
            tm[4] -= int(params.get('tzmin', 0))
        else:
            return None
    # Python's time.mktime() is a wrapper around the ANSI C mktime(3c)
    # which is guaranteed to normalize d/m/y/h/m/s.
    # Many implementations have bugs, but we'll pretend they don't.
    return time.localtime(time.mktime(tm))
registerDateHandler(_parse_date_iso8601)
    
# 8-bit date handling routines written by ytrewq1.
_korean_year  = u'\ub144' # b3e2 in euc-kr
_korean_month = u'\uc6d4' # bff9 in euc-kr
_korean_day   = u'\uc77c' # c0cf in euc-kr
_korean_am    = u'\uc624\uc804' # bfc0 c0fc in euc-kr
_korean_pm    = u'\uc624\ud6c4' # bfc0 c8c4 in euc-kr

_korean_onblog_date_re = \
    re.compile('(\d{4})%s\s+(\d{2})%s\s+(\d{2})%s\s+(\d{2}):(\d{2}):(\d{2})' % \
               (_korean_year, _korean_month, _korean_day))
_korean_nate_date_re = \
    re.compile(u'(\d{4})-(\d{2})-(\d{2})\s+(%s|%s)\s+(\d{,2}):(\d{,2}):(\d{,2})' % \
               (_korean_am, _korean_pm))
def _parse_date_onblog(dateString):
    '''Parse a string according to the OnBlog 8-bit date format'''
    m = _korean_onblog_date_re.match(dateString)
    if not m: return
    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s:%(second)s%(zonediff)s' % \
                {'year': m.group(1), 'month': m.group(2), 'day': m.group(3),\
                 'hour': m.group(4), 'minute': m.group(5), 'second': m.group(6),\
                 'zonediff': '+09:00'}
    if _debug: sys.stderr.write('OnBlog date parsed as: %s\n' % w3dtfdate)
    return _parse_date_w3dtf(w3dtfdate)
registerDateHandler(_parse_date_onblog)

def _parse_date_nate(dateString):
    '''Parse a string according to the Nate 8-bit date format'''
    m = _korean_nate_date_re.match(dateString)
    if not m: return
    hour = int(m.group(5))
    ampm = m.group(4)
    if (ampm == _korean_pm):
        hour += 12
    hour = str(hour)
    if len(hour) == 1:
        hour = '0' + hour
    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s:%(second)s%(zonediff)s' % \
                {'year': m.group(1), 'month': m.group(2), 'day': m.group(3),\
                 'hour': hour, 'minute': m.group(6), 'second': m.group(7),\
                 'zonediff': '+09:00'}
    if _debug: sys.stderr.write('Nate date parsed as: %s\n' % w3dtfdate)
    return _parse_date_w3dtf(w3dtfdate)
registerDateHandler(_parse_date_nate)

_mssql_date_re = \
    re.compile('(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})(\.\d+)?')
def _parse_date_mssql(dateString):
    '''Parse a string according to the MS SQL date format'''
    m = _mssql_date_re.match(dateString)
    if not m: return
    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s:%(second)s%(zonediff)s' % \
                {'year': m.group(1), 'month': m.group(2), 'day': m.group(3),\
                 'hour': m.group(4), 'minute': m.group(5), 'second': m.group(6),\
                 'zonediff': '+09:00'}
    if _debug: sys.stderr.write('MS SQL date parsed as: %s\n' % w3dtfdate)
    return _parse_date_w3dtf(w3dtfdate)
registerDateHandler(_parse_date_mssql)

# Unicode strings for Greek date strings
_greek_months = \
  { \
   u'\u0399\u03b1\u03bd': u'Jan',       # c9e1ed in iso-8859-7
   u'\u03a6\u03b5\u03b2': u'Feb',       # d6e5e2 in iso-8859-7
   u'\u039c\u03ac\u03ce': u'Mar',       # ccdcfe in iso-8859-7
   u'\u039c\u03b1\u03ce': u'Mar',       # cce1fe in iso-8859-7
   u'\u0391\u03c0\u03c1': u'Apr',       # c1f0f1 in iso-8859-7
   u'\u039c\u03ac\u03b9': u'May',       # ccdce9 in iso-8859-7
   u'\u039c\u03b1\u03ca': u'May',       # cce1fa in iso-8859-7
   u'\u039c\u03b1\u03b9': u'May',       # cce1e9 in iso-8859-7
   u'\u0399\u03bf\u03cd\u03bd': u'Jun', # c9effded in iso-8859-7
   u'\u0399\u03bf\u03bd': u'Jun',       # c9efed in iso-8859-7
   u'\u0399\u03bf\u03cd\u03bb': u'Jul', # c9effdeb in iso-8859-7
   u'\u0399\u03bf\u03bb': u'Jul',       # c9f9eb in iso-8859-7
   u'\u0391\u03cd\u03b3': u'Aug',       # c1fde3 in iso-8859-7
   u'\u0391\u03c5\u03b3': u'Aug',       # c1f5e3 in iso-8859-7
   u'\u03a3\u03b5\u03c0': u'Sep',       # d3e5f0 in iso-8859-7
   u'\u039f\u03ba\u03c4': u'Oct',       # cfeaf4 in iso-8859-7
   u'\u039d\u03bf\u03ad': u'Nov',       # cdefdd in iso-8859-7
   u'\u039d\u03bf\u03b5': u'Nov',       # cdefe5 in iso-8859-7
   u'\u0394\u03b5\u03ba': u'Dec',       # c4e5ea in iso-8859-7
  }

_greek_wdays = \
  { \
   u'\u039a\u03c5\u03c1': u'Sun', # caf5f1 in iso-8859-7
   u'\u0394\u03b5\u03c5': u'Mon', # c4e5f5 in iso-8859-7
   u'\u03a4\u03c1\u03b9': u'Tue', # d4f1e9 in iso-8859-7
   u'\u03a4\u03b5\u03c4': u'Wed', # d4e5f4 in iso-8859-7
   u'\u03a0\u03b5\u03bc': u'Thu', # d0e5ec in iso-8859-7
   u'\u03a0\u03b1\u03c1': u'Fri', # d0e1f1 in iso-8859-7
   u'\u03a3\u03b1\u03b2': u'Sat', # d3e1e2 in iso-8859-7   
  }

_greek_date_format_re = \
    re.compile(u'([^,]+),\s+(\d{2})\s+([^\s]+)\s+(\d{4})\s+(\d{2}):(\d{2}):(\d{2})\s+([^\s]+)')

def _parse_date_greek(dateString):
    '''Parse a string according to a Greek 8-bit date format.'''
    m = _greek_date_format_re.match(dateString)
    if not m: return
    try:
        wday = _greek_wdays[m.group(1)]
        month = _greek_months[m.group(3)]
    except:
        return
    rfc822date = '%(wday)s, %(day)s %(month)s %(year)s %(hour)s:%(minute)s:%(second)s %(zonediff)s' % \
                 {'wday': wday, 'day': m.group(2), 'month': month, 'year': m.group(4),\
                  'hour': m.group(5), 'minute': m.group(6), 'second': m.group(7),\
                  'zonediff': m.group(8)}
    if _debug: sys.stderr.write('Greek date parsed as: %s\n' % rfc822date)
    return _parse_date_rfc822(rfc822date)
registerDateHandler(_parse_date_greek)

# Unicode strings for Hungarian date strings
_hungarian_months = \
  { \
    u'janu\u00e1r':   u'01',  # e1 in iso-8859-2
    u'febru\u00e1ri': u'02',  # e1 in iso-8859-2
    u'm\u00e1rcius':  u'03',  # e1 in iso-8859-2
    u'\u00e1prilis':  u'04',  # e1 in iso-8859-2
    u'm\u00e1ujus':   u'05',  # e1 in iso-8859-2
    u'j\u00fanius':   u'06',  # fa in iso-8859-2
    u'j\u00falius':   u'07',  # fa in iso-8859-2
    u'augusztus':     u'08',
    u'szeptember':    u'09',
    u'okt\u00f3ber':  u'10',  # f3 in iso-8859-2
    u'november':      u'11',
    u'december':      u'12',
  }

_hungarian_date_format_re = \
  re.compile(u'(\d{4})-([^-]+)-(\d{,2})T(\d{,2}):(\d{2})((\+|-)(\d{,2}:\d{2}))')

def _parse_date_hungarian(dateString):
    '''Parse a string according to a Hungarian 8-bit date format.'''
    m = _hungarian_date_format_re.match(dateString)
    if not m: return
    try:
        month = _hungarian_months[m.group(2)]
        day = m.group(3)
        if len(day) == 1:
            day = '0' + day
        hour = m.group(4)
        if len(hour) == 1:
            hour = '0' + hour
    except:
        return
    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s%(zonediff)s' % \
                {'year': m.group(1), 'month': month, 'day': day,\
                 'hour': hour, 'minute': m.group(5),\
                 'zonediff': m.group(6)}
    if _debug: sys.stderr.write('Hungarian date parsed as: %s\n' % w3dtfdate)
    return _parse_date_w3dtf(w3dtfdate)
registerDateHandler(_parse_date_hungarian)

# W3DTF-style date parsing adapted from PyXML xml.utils.iso8601, written by
# Drake and licensed under the Python license.  Removed all range checking
# for month, day, hour, minute, and second, since mktime will normalize
# these later
def _parse_date_w3dtf(dateString):
    def __extract_date(m):
        year = int(m.group('year'))
        if year < 100:
            year = 100 * int(time.gmtime()[0] / 100) + int(year)
        if year < 1000:
            return 0, 0, 0
        julian = m.group('julian')
        if julian:
            julian = int(julian)
            month = julian / 30 + 1
            day = julian % 30 + 1
            jday = None
            while jday != julian:
                t = time.mktime((year, month, day, 0, 0, 0, 0, 0, 0))
                jday = time.gmtime(t)[-2]
                diff = abs(jday - julian)
                if jday > julian:
                    if diff < day:
                        day = day - diff
                    else:
                        month = month - 1
                        day = 31
                elif jday < julian:
                    if day + diff < 28:
                       day = day + diff
                    else:
                        month = month + 1
            return year, month, day
        month = m.group('month')
        day = 1
        if month is None:
            month = 1
        else:
            month = int(month)
            day = m.group('day')
            if day:
                day = int(day)
            else:
                day = 1
        return year, month, day

    def __extract_time(m):
        if not m:
            return 0, 0, 0
        hours = m.group('hours')
        if not hours:
            return 0, 0, 0
        hours = int(hours)
        minutes = int(m.group('minutes'))
        seconds = m.group('seconds')
        if seconds:
            seconds = int(seconds)
        else:
            seconds = 0
        return hours, minutes, seconds

    def __extract_tzd(m):
        '''Return the Time Zone Designator as an offset in seconds from UTC.'''
        if not m:
            return 0
        tzd = m.group('tzd')
        if not tzd:
            return 0
        if tzd == 'Z':
            return 0
        hours = int(m.group('tzdhours'))
        minutes = m.group('tzdminutes')
        if minutes:
            minutes = int(minutes)
        else:
            minutes = 0
        offset = (hours*60 + minutes) * 60
        if tzd[0] == '+':
            return -offset
        return offset

    __date_re = ('(?P<year>\d\d\d\d)'
                 '(?:(?P<dsep>-|)'
                 '(?:(?P<julian>\d\d\d)'
                 '|(?P<month>\d\d)(?:(?P=dsep)(?P<day>\d\d))?))?')
    __tzd_re = '(?P<tzd>[-+](?P<tzdhours>\d\d)(?::?(?P<tzdminutes>\d\d))|Z)'
    __tzd_rx = re.compile(__tzd_re)
    __time_re = ('(?P<hours>\d\d)(?P<tsep>:|)(?P<minutes>\d\d)'
                 '(?:(?P=tsep)(?P<seconds>\d\d(?:[.,]\d+)?))?'
                 + __tzd_re)
    __datetime_re = '%s(?:T%s)?' % (__date_re, __time_re)
    __datetime_rx = re.compile(__datetime_re)
    m = __datetime_rx.match(dateString)
    if (m is None) or (m.group() != dateString): return
    gmt = __extract_date(m) + __extract_time(m) + (0, 0, 0)
    if gmt[0] == 0: return
    return time.gmtime(time.mktime(gmt) + __extract_tzd(m) - time.timezone)
registerDateHandler(_parse_date_w3dtf)

def _parse_date_rfc822(dateString):
    '''Parse an RFC822, RFC1123, RFC2822, or asctime-style date'''
    data = dateString.split()
    if data[0][-1] in (',', '.') or data[0].lower() in rfc822._daynames:
        del data[0]
    if len(data) == 4:
        s = data[3]
        i = s.find('+')
        if i > 0:
            data[3:] = [s[:i], s[i+1:]]
        else:
            data.append('')
        dateString = " ".join(data)
    if len(data) < 5:
        dateString += ' 00:00:00 GMT'
    tm = rfc822.parsedate_tz(dateString)
    if tm:
        return time.gmtime(rfc822.mktime_tz(tm))
# rfc822.py defines several time zones, but we define some extra ones.
# 'ET' is equivalent to 'EST', etc.
_additional_timezones = {'AT': -400, 'ET': -500, 'CT': -600, 'MT': -700, 'PT': -800}
rfc822._timezones.update(_additional_timezones)
registerDateHandler(_parse_date_rfc822)    

def _parse_date(dateString):
    '''Parses a variety of date formats into a 9-tuple in GMT'''
    for handler in _date_handlers:
        try:
            date9tuple = handler(dateString)
            if not date9tuple: continue
            if len(date9tuple) != 9:
                if _debug: sys.stderr.write('date handler function must return 9-tuple\n')
                raise ValueError
            map(int, date9tuple)
            return date9tuple
        except Exception, e:
            if _debug: sys.stderr.write('%s raised %s\n' % (handler.__name__, repr(e)))
            pass
    return None

def _getCharacterEncoding(http_headers, xml_data):
    '''Get the character encoding of the XML document

    http_headers is a dictionary
    xml_data is a raw string (not Unicode)
    
    This is so much trickier than it sounds, it's not even funny.
    According to RFC 3023 ('XML Media Types'), if the HTTP Content-Type
    is application/xml, application/*+xml,
    application/xml-external-parsed-entity, or application/xml-dtd,
    the encoding given in the charset parameter of the HTTP Content-Type
    takes precedence over the encoding given in the XML prefix within the
    document, and defaults to 'utf-8' if neither are specified.  But, if
    the HTTP Content-Type is text/xml, text/*+xml, or
    text/xml-external-parsed-entity, the encoding given in the XML prefix
    within the document is ALWAYS IGNORED and only the encoding given in
    the charset parameter of the HTTP Content-Type header should be
    respected, and it defaults to 'us-ascii' if not specified.

    Furthermore, discussion on the atom-syntax mailing list with the
    author of RFC 3023 leads me to the conclusion that any document
    served with a Content-Type of text/* and no charset parameter
    must be treated as us-ascii.  (We now do this.)  And also that it
    must always be flagged as non-well-formed.  (We now do this too.)
    
    If Content-Type is unspecified (input was local file or non-HTTP source)
    or unrecognized (server just got it totally wrong), then go by the
    encoding given in the XML prefix of the document and default to
    'iso-8859-1' as per the HTTP specification (RFC 2616).
    
    Then, assuming we didn't find a character encoding in the HTTP headers
    (and the HTTP Content-type allowed us to look in the body), we need
    to sniff the first few bytes of the XML data and try to determine
    whether the encoding is ASCII-compatible.  Section F of the XML
    specification shows the way here:
    http://www.w3.org/TR/REC-xml/#sec-guessing-no-ext-info

    If the sniffed encoding is not ASCII-compatible, we need to make it
    ASCII compatible so that we can sniff further into the XML declaration
    to find the encoding attribute, which will tell us the true encoding.

    Of course, none of this guarantees that we will be able to parse the
    feed in the declared character encoding (assuming it was declared
    correctly, which many are not).  CJKCodecs and iconv_codec help a lot;
    you should definitely install them if you can.
    http://cjkpython.i18n.org/
    '''

    def _parseHTTPContentType(content_type):
        '''takes HTTP Content-Type header and returns (content type, charset)

        If no charset is specified, returns (content type, '')
        If no content type is specified, returns ('', '')
        Both return parameters are guaranteed to be lowercase strings
        '''
        content_type = content_type or ''
        content_type, params = cgi.parse_header(content_type)
        return content_type, params.get('charset', '').replace("'", '')

    sniffed_xml_encoding = ''
    xml_encoding = ''
    true_encoding = ''
    http_content_type, http_encoding = _parseHTTPContentType(http_headers.get('content-type'))
    # Must sniff for non-ASCII-compatible character encodings before
    # searching for XML declaration.  This heuristic is defined in
    # section F of the XML specification:
    # http://www.w3.org/TR/REC-xml/#sec-guessing-no-ext-info
    try:
        if xml_data[:4] == '\x4c\x6f\xa7\x94':
            # EBCDIC
            xml_data = _ebcdic_to_ascii(xml_data)
        elif xml_data[:4] == '\x00\x3c\x00\x3f':
            # UTF-16BE
            sniffed_xml_encoding = 'utf-16be'
            xml_data = unicode(xml_data, 'utf-16be').encode('utf-8')
        elif (len(xml_data) >= 4) and (xml_data[:2] == '\xfe\xff') and (xml_data[2:4] != '\x00\x00'):
            # UTF-16BE with BOM
            sniffed_xml_encoding = 'utf-16be'
            xml_data = unicode(xml_data[2:], 'utf-16be').encode('utf-8')
        elif xml_data[:4] == '\x3c\x00\x3f\x00':
            # UTF-16LE
            sniffed_xml_encoding = 'utf-16le'
            xml_data = unicode(xml_data, 'utf-16le').encode('utf-8')
        elif (len(xml_data) >= 4) and (xml_data[:2] == '\xff\xfe') and (xml_data[2:4] != '\x00\x00'):
            # UTF-16LE with BOM
            sniffed_xml_encoding = 'utf-16le'
            xml_data = unicode(xml_data[2:], 'utf-16le').encode('utf-8')
        elif xml_data[:4] == '\x00\x00\x00\x3c':
            # UTF-32BE
            sniffed_xml_encoding = 'utf-32be'
            xml_data = unicode(xml_data, 'utf-32be').encode('utf-8')
        elif xml_data[:4] == '\x3c\x00\x00\x00':
            # UTF-32LE
            sniffed_xml_encoding = 'utf-32le'
            xml_data = unicode(xml_data, 'utf-32le').encode('utf-8')
        elif xml_data[:4] == '\x00\x00\xfe\xff':
            # UTF-32BE with BOM
            sniffed_xml_encoding = 'utf-32be'
            xml_data = unicode(xml_data[4:], 'utf-32be').encode('utf-8')
        elif xml_data[:4] == '\xff\xfe\x00\x00':
            # UTF-32LE with BOM
            sniffed_xml_encoding = 'utf-32le'
            xml_data = unicode(xml_data[4:], 'utf-32le').encode('utf-8')
        elif xml_data[:3] == '\xef\xbb\xbf':
            # UTF-8 with BOM
            sniffed_xml_encoding = 'utf-8'
            xml_data = unicode(xml_data[3:], 'utf-8').encode('utf-8')
        else:
            # ASCII-compatible
            pass
        xml_encoding_match = re.compile('^<\?.*encoding=[\'"](.*?)[\'"].*\?>').match(xml_data)
    except:
        xml_encoding_match = None
    if xml_encoding_match:
        xml_encoding = xml_encoding_match.groups()[0].lower()
        if sniffed_xml_encoding and (xml_encoding in ('iso-10646-ucs-2', 'ucs-2', 'csunicode', 'iso-10646-ucs-4', 'ucs-4', 'csucs4', 'utf-16', 'utf-32', 'utf_16', 'utf_32', 'utf16', 'u16')):
            xml_encoding = sniffed_xml_encoding
    acceptable_content_type = 0
    application_content_types = ('application/xml', 'application/xml-dtd', 'application/xml-external-parsed-entity')
    text_content_types = ('text/xml', 'text/xml-external-parsed-entity')
    if (http_content_type in application_content_types) or \
       (http_content_type.startswith('application/') and http_content_type.endswith('+xml')):
        acceptable_content_type = 1
        true_encoding = http_encoding or xml_encoding or 'utf-8'
    elif (http_content_type in text_content_types) or \
         (http_content_type.startswith('text/')) and http_content_type.endswith('+xml'):
        acceptable_content_type = 1
        true_encoding = http_encoding or 'us-ascii'
    elif http_content_type.startswith('text/'):
        true_encoding = http_encoding or 'us-ascii'
    elif http_headers and (not http_headers.has_key('content-type')):
        true_encoding = xml_encoding or 'iso-8859-1'
    else:
        true_encoding = xml_encoding or 'utf-8'
    return true_encoding, http_encoding, xml_encoding, sniffed_xml_encoding, acceptable_content_type
    
def _toUTF8(data, encoding):
    '''Changes an XML data stream on the fly to specify a new encoding

    data is a raw sequence of bytes (not Unicode) that is presumed to be in %encoding already
    encoding is a string recognized by encodings.aliases
    '''
    if _debug: sys.stderr.write('entering _toUTF8, trying encoding %s\n' % encoding)
    # strip Byte Order Mark (if present)
    if (len(data) >= 4) and (data[:2] == '\xfe\xff') and (data[2:4] != '\x00\x00'):
        if _debug:
            sys.stderr.write('stripping BOM\n')
            if encoding != 'utf-16be':
                sys.stderr.write('trying utf-16be instead\n')
        encoding = 'utf-16be'
        data = data[2:]
    elif (len(data) >= 4) and (data[:2] == '\xff\xfe') and (data[2:4] != '\x00\x00'):
        if _debug:
            sys.stderr.write('stripping BOM\n')
            if encoding != 'utf-16le':
                sys.stderr.write('trying utf-16le instead\n')
        encoding = 'utf-16le'
        data = data[2:]
    elif data[:3] == '\xef\xbb\xbf':
        if _debug:
            sys.stderr.write('stripping BOM\n')
            if encoding != 'utf-8':
                sys.stderr.write('trying utf-8 instead\n')
        encoding = 'utf-8'
        data = data[3:]
    elif data[:4] == '\x00\x00\xfe\xff':
        if _debug:
            sys.stderr.write('stripping BOM\n')
            if encoding != 'utf-32be':
                sys.stderr.write('trying utf-32be instead\n')
        encoding = 'utf-32be'
        data = data[4:]
    elif data[:4] == '\xff\xfe\x00\x00':
        if _debug:
            sys.stderr.write('stripping BOM\n')
            if encoding != 'utf-32le':
                sys.stderr.write('trying utf-32le instead\n')
        encoding = 'utf-32le'
        data = data[4:]
    newdata = unicode(data, encoding)
    if _debug: sys.stderr.write('successfully converted %s data to unicode\n' % encoding)
    declmatch = re.compile('^<\?xml[^>]*?>')
    newdecl = '''<?xml version='1.0' encoding='utf-8'?>'''
    if declmatch.search(newdata):
        newdata = declmatch.sub(newdecl, newdata)
    else:
        newdata = newdecl + u'\n' + newdata
    return newdata.encode('utf-8')

def _stripDoctype(data):
    '''Strips DOCTYPE from XML document, returns (rss_version, stripped_data)

    rss_version may be 'rss091n' or None
    stripped_data is the same XML document, minus the DOCTYPE
    '''
    entity_pattern = re.compile(r'<!ENTITY([^>]*?)>', re.MULTILINE)
    data = entity_pattern.sub('', data)
    doctype_pattern = re.compile(r'<!DOCTYPE([^>]*?)>', re.MULTILINE)
    doctype_results = doctype_pattern.findall(data)
    doctype = doctype_results and doctype_results[0] or ''
    if doctype.lower().count('netscape'):
        version = 'rss091n'
    else:
        version = None
    data = doctype_pattern.sub('', data)
    return version, data
    
def parse(url_file_stream_or_string, etag=None, modified=None, agent=None, referrer=None, handlers=[]):
    '''Parse a feed from a URL, file, stream, or string'''
    result = FeedParserDict()
    result['feed'] = FeedParserDict()
    result['entries'] = []
    if _XML_AVAILABLE:
        result['bozo'] = 0
    if type(handlers) == types.InstanceType:
        handlers = [handlers]
    try:
        f = _open_resource(url_file_stream_or_string, etag, modified, agent, referrer, handlers)
        data = f.read()
    except Exception, e:
        result['bozo'] = 1
        result['bozo_exception'] = e
        data = ''
        f = None

    # if feed is gzip-compressed, decompress it
    if f and data and hasattr(f, 'headers'):
        if gzip and f.headers.get('content-encoding', '') == 'gzip':
            try:
                data = gzip.GzipFile(fileobj=_StringIO(data)).read()
            except Exception, e:
                # Some feeds claim to be gzipped but they're not, so
                # we get garbage.  Ideally, we should re-request the
                # feed without the 'Accept-encoding: gzip' header,
                # but we don't.
                result['bozo'] = 1
                result['bozo_exception'] = e
                data = ''
        elif zlib and f.headers.get('content-encoding', '') == 'deflate':
            try:
                data = zlib.decompress(data, -zlib.MAX_WBITS)
            except Exception, e:
                result['bozo'] = 1
                result['bozo_exception'] = e
                data = ''

    # save HTTP headers
    if hasattr(f, 'info'):
        info = f.info()
        result['etag'] = info.getheader('ETag')
        last_modified = info.getheader('Last-Modified')
        if last_modified:
            result['modified'] = _parse_date(last_modified)
    if hasattr(f, 'url'):
        result['href'] = f.url
        result['status'] = 200
    if hasattr(f, 'status'):
        result['status'] = f.status
    if hasattr(f, 'headers'):
        result['headers'] = f.headers.dict
    if hasattr(f, 'close'):
        f.close()

    # there are four encodings to keep track of:
    # - http_encoding is the encoding declared in the Content-Type HTTP header
    # - xml_encoding is the encoding declared in the <?xml declaration
    # - sniffed_encoding is the encoding sniffed from the first 4 bytes of the XML data
    # - result['encoding'] is the actual encoding, as per RFC 3023 and a variety of other conflicting specifications
    http_headers = result.get('headers', {})
    result['encoding'], http_encoding, xml_encoding, sniffed_xml_encoding, acceptable_content_type = \
        _getCharacterEncoding(http_headers, data)
    if http_headers and (not acceptable_content_type):
        if http_headers.has_key('content-type'):
            bozo_message = '%s is not an XML media type' % http_headers['content-type']
        else:
            bozo_message = 'no Content-type specified'
        result['bozo'] = 1
        result['bozo_exception'] = NonXMLContentType(bozo_message)
        
    result['version'], data = _stripDoctype(data)

    baseuri = http_headers.get('content-location', result.get('href'))
    baselang = http_headers.get('content-language', None)

    # if server sent 304, we're done
    if result.get('status', 0) == 304:
        result['version'] = ''
        result['debug_message'] = 'The feed has not changed since you last checked, ' + \
            'so the server sent no data.  This is a feature, not a bug!'
        return result

    # if there was a problem downloading, we're done
    if not data:
        return result

    # determine character encoding
    use_strict_parser = 0
    known_encoding = 0
    tried_encodings = []
    # try: HTTP encoding, declared XML encoding, encoding sniffed from BOM
    for proposed_encoding in (result['encoding'], xml_encoding, sniffed_xml_encoding):
        if not proposed_encoding: continue
        if proposed_encoding in tried_encodings: continue
        tried_encodings.append(proposed_encoding)
        try:
            data = _toUTF8(data, proposed_encoding)
            known_encoding = use_strict_parser = 1
            break
        except:
            pass
    # if no luck and we have auto-detection library, try that
    if (not known_encoding) and chardet:
        try:
            proposed_encoding = chardet.detect(data)['encoding']
            if proposed_encoding and (proposed_encoding not in tried_encodings):
                tried_encodings.append(proposed_encoding)
                data = _toUTF8(data, proposed_encoding)
                known_encoding = use_strict_parser = 1
        except:
            pass
    # if still no luck and we haven't tried utf-8 yet, try that
    if (not known_encoding) and ('utf-8' not in tried_encodings):
        try:
            proposed_encoding = 'utf-8'
            tried_encodings.append(proposed_encoding)
            data = _toUTF8(data, proposed_encoding)
            known_encoding = use_strict_parser = 1
        except:
            pass
    # if still no luck and we haven't tried windows-1252 yet, try that
    if (not known_encoding) and ('windows-1252' not in tried_encodings):
        try:
            proposed_encoding = 'windows-1252'
            tried_encodings.append(proposed_encoding)
            data = _toUTF8(data, proposed_encoding)
            known_encoding = use_strict_parser = 1
        except:
            pass
    # if still no luck, give up
    if not known_encoding:
        result['bozo'] = 1
        result['bozo_exception'] = CharacterEncodingUnknown( \
            'document encoding unknown, I tried ' + \
            '%s, %s, utf-8, and windows-1252 but nothing worked' % \
            (result['encoding'], xml_encoding))
        result['encoding'] = ''
    elif proposed_encoding != result['encoding']:
        result['bozo'] = 1
        result['bozo_exception'] = CharacterEncodingOverride( \
            'documented declared as %s, but parsed as %s' % \
            (result['encoding'], proposed_encoding))
        result['encoding'] = proposed_encoding

    if not _XML_AVAILABLE:
        use_strict_parser = 0
    if use_strict_parser:
        # initialize the SAX parser
        feedparser = _StrictFeedParser(baseuri, baselang, 'utf-8')
        saxparser = xml.sax.make_parser(PREFERRED_XML_PARSERS)
        saxparser.setFeature(xml.sax.handler.feature_namespaces, 1)
        saxparser.setContentHandler(feedparser)
        saxparser.setErrorHandler(feedparser)
        source = xml.sax.xmlreader.InputSource()
        source.setByteStream(_StringIO(data))
        if hasattr(saxparser, '_ns_stack'):
            # work around bug in built-in SAX parser (doesn't recognize xml: namespace)
            # PyXML doesn't have this problem, and it doesn't have _ns_stack either
            saxparser._ns_stack.append({'http://www.w3.org/XML/1998/namespace':'xml'})
        try:
            saxparser.parse(source)
        except Exception, e:
            if _debug:
                import traceback
                traceback.print_stack()
                traceback.print_exc()
                sys.stderr.write('xml parsing failed\n')
            result['bozo'] = 1
            result['bozo_exception'] = feedparser.exc or e
            use_strict_parser = 0
    if not use_strict_parser:
        feedparser = _LooseFeedParser(baseuri, baselang, known_encoding and 'utf-8' or '')
        feedparser.feed(data)
    result['feed'] = feedparser.feeddata
    result['entries'] = feedparser.entries
    result['version'] = result['version'] or feedparser.version
    result['namespaces'] = feedparser.namespacesInUse
    return result

if __name__ == '__main__':
    if not sys.argv[1:]:
        print __doc__
        sys.exit(0)
    else:
        urls = sys.argv[1:]
    zopeCompatibilityHack()
    from pprint import pprint
    for url in urls:
        print url
        print
        result = parse(url)
        pprint(result)
        print

#REVISION HISTORY
#1.0 - 9/27/2002 - MAP - fixed namespace processing on prefixed RSS 2.0 elements,
#  added Simon Fell's test suite
#1.1 - 9/29/2002 - MAP - fixed infinite loop on incomplete CDATA sections
#2.0 - 10/19/2002
#  JD - use inchannel to watch out for image and textinput elements which can
#  also contain title, link, and description elements
#  JD - check for isPermaLink='false' attribute on guid elements
#  JD - replaced openAnything with open_resource supporting ETag and
#  If-Modified-Since request headers
#  JD - parse now accepts etag, modified, agent, and referrer optional
#  arguments
#  JD - modified parse to return a dictionary instead of a tuple so that any
#  etag or modified information can be returned and cached by the caller
#2.0.1 - 10/21/2002 - MAP - changed parse() so that if we don't get anything
#  because of etag/modified, return the old etag/modified to the caller to
#  indicate why nothing is being returned
#2.0.2 - 10/21/2002 - JB - added the inchannel to the if statement, otherwise its
#  useless.  Fixes the problem JD was addressing by adding it.
#2.1 - 11/14/2002 - MAP - added gzip support
#2.2 - 1/27/2003 - MAP - added attribute support, admin:generatorAgent.
#  start_admingeneratoragent is an example of how to handle elements with
#  only attributes, no content.
#2.3 - 6/11/2003 - MAP - added USER_AGENT for default (if caller doesn't specify);
#  also, make sure we send the User-Agent even if urllib2 isn't available.
#  Match any variation of backend.userland.com/rss namespace.
#2.3.1 - 6/12/2003 - MAP - if item has both link and guid, return both as-is.
#2.4 - 7/9/2003 - MAP - added preliminary Pie/Atom/Echo support based on Sam Ruby's
#  snapshot of July 1 <http://www.intertwingly.net/blog/1506.html>; changed
#  project name
#2.5 - 7/25/2003 - MAP - changed to Python license (all contributors agree);
#  removed unnecessary urllib code -- urllib2 should always be available anyway;
#  return actual url, status, and full HTTP headers (as result['url'],
#  result['status'], and result['headers']) if parsing a remote feed over HTTP --
#  this should pass all the HTTP tests at <http://diveintomark.org/tests/client/http/>;
#  added the latest namespace-of-the-week for RSS 2.0
#2.5.1 - 7/26/2003 - RMK - clear opener.addheaders so we only send our custom
#  User-Agent (otherwise urllib2 sends two, which confuses some servers)
#2.5.2 - 7/28/2003 - MAP - entity-decode inline xml properly; added support for
#  inline <xhtml:body> and <xhtml:div> as used in some RSS 2.0 feeds
#2.5.3 - 8/6/2003 - TvdV - patch to track whether we're inside an image or
#  textInput, and also to return the character encoding (if specified)
#2.6 - 1/1/2004 - MAP - dc:author support (MarekK); fixed bug tracking
#  nested divs within content (JohnD); fixed missing sys import (JohanS);
#  fixed regular expression to capture XML character encoding (Andrei);
#  added support for Atom 0.3-style links; fixed bug with textInput tracking;
#  added support for cloud (MartijnP); added support for multiple
#  category/dc:subject (MartijnP); normalize content model: 'description' gets
#  description (which can come from description, summary, or full content if no
#  description), 'content' gets dict of base/language/type/value (which can come
#  from content:encoded, xhtml:body, content, or fullitem);
#  fixed bug matching arbitrary Userland namespaces; added xml:base and xml:lang
#  tracking; fixed bug tracking unknown tags; fixed bug tracking content when
#  <content> element is not in default namespace (like Pocketsoap feed);
#  resolve relative URLs in link, guid, docs, url, comments, wfw:comment,
#  wfw:commentRSS; resolve relative URLs within embedded HTML markup in
#  description, xhtml:body, content, content:encoded, title, subtitle,
#  summary, info, tagline, and copyright; added support for pingback and
#  trackback namespaces
#2.7 - 1/5/2004 - MAP - really added support for trackback and pingback
#  namespaces, as opposed to 2.6 when I said I did but didn't really;
#  sanitize HTML markup within some elements; added mxTidy support (if
#  installed) to tidy HTML markup within some elements; fixed indentation
#  bug in _parse_date (FazalM); use socket.setdefaulttimeout if available
#  (FazalM); universal date parsing and normalization (FazalM): 'created', modified',
#  'issued' are parsed into 9-tuple date format and stored in 'created_parsed',
#  'modified_parsed', and 'issued_parsed'; 'date' is duplicated in 'modified'
#  and vice-versa; 'date_parsed' is duplicated in 'modified_parsed' and vice-versa
#2.7.1 - 1/9/2004 - MAP - fixed bug handling &quot; and &apos;.  fixed memory
#  leak not closing url opener (JohnD); added dc:publisher support (MarekK);
#  added admin:errorReportsTo support (MarekK); Python 2.1 dict support (MarekK)
#2.7.4 - 1/14/2004 - MAP - added workaround for improperly formed <br/> tags in
#  encoded HTML (skadz); fixed unicode handling in normalize_attrs (ChrisL);
#  fixed relative URI processing for guid (skadz); added ICBM support; added
#  base64 support
#2.7.5 - 1/15/2004 - MAP - added workaround for malformed DOCTYPE (seen on many
#  blogspot.com sites); added _debug variable
#2.7.6 - 1/16/2004 - MAP - fixed bug with StringIO importing
#3.0b3 - 1/23/2004 - MAP - parse entire feed with real XML parser (if available);
#  added several new supported namespaces; fixed bug tracking naked markup in
#  description; added support for enclosure; added support for source; re-added
#  support for cloud which got dropped somehow; added support for expirationDate
#3.0b4 - 1/26/2004 - MAP - fixed xml:lang inheritance; fixed multiple bugs tracking
#  xml:base URI, one for documents that don't define one explicitly and one for
#  documents that define an outer and an inner xml:base that goes out of scope
#  before the end of the document
#3.0b5 - 1/26/2004 - MAP - fixed bug parsing multiple links at feed level
#3.0b6 - 1/27/2004 - MAP - added feed type and version detection, result['version']
#  will be one of SUPPORTED_VERSIONS.keys() or empty string if unrecognized;
#  added support for creativeCommons:license and cc:license; added support for
#  full Atom content model in title, tagline, info, copyright, summary; fixed bug
#  with gzip encoding (not always telling server we support it when we do)
#3.0b7 - 1/28/2004 - MAP - support Atom-style author element in author_detail
#  (dictionary of 'name', 'url', 'email'); map author to author_detail if author
#  contains name + email address
#3.0b8 - 1/28/2004 - MAP - added support for contributor
#3.0b9 - 1/29/2004 - MAP - fixed check for presence of dict function; added
#  support for summary
#3.0b10 - 1/31/2004 - MAP - incorporated ISO-8601 date parsing routines from
#  xml.util.iso8601
#3.0b11 - 2/2/2004 - MAP - added 'rights' to list of elements that can contain
#  dangerous markup; fiddled with decodeEntities (not right); liberalized
#  date parsing even further
#3.0b12 - 2/6/2004 - MAP - fiddled with decodeEntities (still not right);
#  added support to Atom 0.2 subtitle; added support for Atom content model
#  in copyright; better sanitizing of dangerous HTML elements with end tags
#  (script, frameset)
#3.0b13 - 2/8/2004 - MAP - better handling of empty HTML tags (br, hr, img,
#  etc.) in embedded markup, in either HTML or XHTML form (<br>, <br/>, <br />)
#3.0b14 - 2/8/2004 - MAP - fixed CDATA handling in non-wellformed feeds under
#  Python 2.1
#3.0b15 - 2/11/2004 - MAP - fixed bug resolving relative links in wfw:commentRSS;
#  fixed bug capturing author and contributor URL; fixed bug resolving relative
#  links in author and contributor URL; fixed bug resolvin relative links in
#  generator URL; added support for recognizing RSS 1.0; passed Simon Fell's
#  namespace tests, and included them permanently in the test suite with his
#  permission; fixed namespace handling under Python 2.1
#3.0b16 - 2/12/2004 - MAP - fixed support for RSS 0.90 (broken in b15)
#3.0b17 - 2/13/2004 - MAP - determine character encoding as per RFC 3023
#3.0b18 - 2/17/2004 - MAP - always map description to summary_detail (Andrei);
#  use libxml2 (if available)
#3.0b19 - 3/15/2004 - MAP - fixed bug exploding author information when author
#  name was in parentheses; removed ultra-problematic mxTidy support; patch to
#  workaround crash in PyXML/expat when encountering invalid entities
#  (MarkMoraes); support for textinput/textInput
#3.0b20 - 4/7/2004 - MAP - added CDF support
#3.0b21 - 4/14/2004 - MAP - added Hot RSS support
#3.0b22 - 4/19/2004 - MAP - changed 'channel' to 'feed', 'item' to 'entries' in
#  results dict; changed results dict to allow getting values with results.key
#  as well as results[key]; work around embedded illformed HTML with half
#  a DOCTYPE; work around malformed Content-Type header; if character encoding
#  is wrong, try several common ones before falling back to regexes (if this
#  works, bozo_exception is set to CharacterEncodingOverride); fixed character
#  encoding issues in BaseHTMLProcessor by tracking encoding and converting
#  from Unicode to raw strings before feeding data to sgmllib.SGMLParser;
#  convert each value in results to Unicode (if possible), even if using
#  regex-based parsing
#3.0b23 - 4/21/2004 - MAP - fixed UnicodeDecodeError for feeds that contain
#  high-bit characters in attributes in embedded HTML in description (thanks
#  Thijs van de Vossen); moved guid, date, and date_parsed to mapped keys in
#  FeedParserDict; tweaked FeedParserDict.has_key to return True if asking
#  about a mapped key
#3.0fc1 - 4/23/2004 - MAP - made results.entries[0].links[0] and
#  results.entries[0].enclosures[0] into FeedParserDict; fixed typo that could
#  cause the same encoding to be tried twice (even if it failed the first time);
#  fixed DOCTYPE stripping when DOCTYPE contained entity declarations;
#  better textinput and image tracking in illformed RSS 1.0 feeds
#3.0fc2 - 5/10/2004 - MAP - added and passed Sam's amp tests; added and passed
#  my blink tag tests
#3.0fc3 - 6/18/2004 - MAP - fixed bug in _changeEncodingDeclaration that
#  failed to parse utf-16 encoded feeds; made source into a FeedParserDict;
#  duplicate admin:generatorAgent/@rdf:resource in generator_detail.url;
#  added support for image; refactored parse() fallback logic to try other
#  encodings if SAX parsing fails (previously it would only try other encodings
#  if re-encoding failed); remove unichr madness in normalize_attrs now that
#  we're properly tracking encoding in and out of BaseHTMLProcessor; set
#  feed.language from root-level xml:lang; set entry.id from rdf:about;
#  send Accept header
#3.0 - 6/21/2004 - MAP - don't try iso-8859-1 (can't distinguish between
#  iso-8859-1 and windows-1252 anyway, and most incorrectly marked feeds are
#  windows-1252); fixed regression that could cause the same encoding to be
#  tried twice (even if it failed the first time)
#3.0.1 - 6/22/2004 - MAP - default to us-ascii for all text/* content types;
#  recover from malformed content-type header parameter with no equals sign
#  ('text/xml; charset:iso-8859-1')
#3.1 - 6/28/2004 - MAP - added and passed tests for converting HTML entities
#  to Unicode equivalents in illformed feeds (aaronsw); added and
#  passed tests for converting character entities to Unicode equivalents
#  in illformed feeds (aaronsw); test for valid parsers when setting
#  XML_AVAILABLE; make version and encoding available when server returns
#  a 304; add handlers parameter to pass arbitrary urllib2 handlers (like
#  digest auth or proxy support); add code to parse username/password
#  out of url and send as basic authentication; expose downloading-related
#  exceptions in bozo_exception (aaronsw); added __contains__ method to
#  FeedParserDict (aaronsw); added publisher_detail (aaronsw)
#3.2 - 7/3/2004 - MAP - use cjkcodecs and iconv_codec if available; always
#  convert feed to UTF-8 before passing to XML parser; completely revamped
#  logic for determining character encoding and attempting XML parsing
#  (much faster); increased default timeout to 20 seconds; test for presence
#  of Location header on redirects; added tests for many alternate character
#  encodings; support various EBCDIC encodings; support UTF-16BE and
#  UTF16-LE with or without a BOM; support UTF-8 with a BOM; support
#  UTF-32BE and UTF-32LE with or without a BOM; fixed crashing bug if no
#  XML parsers are available; added support for 'Content-encoding: deflate';
#  send blank 'Accept-encoding: ' header if neither gzip nor zlib modules
#  are available
#3.3 - 7/15/2004 - MAP - optimize EBCDIC to ASCII conversion; fix obscure
#  problem tracking xml:base and xml:lang if element declares it, child
#  doesn't, first grandchild redeclares it, and second grandchild doesn't;
#  refactored date parsing; defined public registerDateHandler so callers
#  can add support for additional date formats at runtime; added support
#  for OnBlog, Nate, MSSQL, Greek, and Hungarian dates (ytrewq1); added
#  zopeCompatibilityHack() which turns FeedParserDict into a regular
#  dictionary, required for Zope compatibility, and also makes command-
#  line debugging easier because pprint module formats real dictionaries
#  better than dictionary-like objects; added NonXMLContentType exception,
#  which is stored in bozo_exception when a feed is served with a non-XML
#  media type such as 'text/plain'; respect Content-Language as default
#  language if not xml:lang is present; cloud dict is now FeedParserDict;
#  generator dict is now FeedParserDict; better tracking of xml:lang,
#  including support for xml:lang='' to unset the current language;
#  recognize RSS 1.0 feeds even when RSS 1.0 namespace is not the default
#  namespace; don't overwrite final status on redirects (scenarios:
#  redirecting to a URL that returns 304, redirecting to a URL that
#  redirects to another URL with a different type of redirect); add
#  support for HTTP 303 redirects
#4.0 - MAP - support for relative URIs in xml:base attribute; fixed
#  encoding issue with mxTidy (phopkins); preliminary support for RFC 3229;
#  support for Atom 1.0; support for iTunes extensions; new 'tags' for
#  categories/keywords/etc. as array of dict
#  {'term': term, 'scheme': scheme, 'label': label} to match Atom 1.0
#  terminology; parse RFC 822-style dates with no time; lots of other
#  bug fixes
#4.1 - MAP - removed socket timeout; added support for chardet library

########NEW FILE########
__FILENAME__ = kthread
'''
kthread.py: A killable thread implementation.

Copyright (C) 2004 Connelly Barnes (connellybarnes@yahoo.com)

This module allows you to kill threads. The class KThread is a drop-in 
replacement for threading.Thread. It adds the kill() method, which should stop 
most threads in their tracks.

This library is free software; you can redistribute it and/or modify it under 
the terms of the GNU Lesser General Public License as published by the Free 
Software Foundation; either version 2.1 of the License, or (at your option) 
any later version.

This library is distributed in the hope that it will be useful, but WITHOUT 
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more 
details.

You should have received a copy of the GNU Lesser General Public License along 
with this library; if not, write to the Free Software Foundation, Inc., 59 
Temple Place, Suite 330, Boston, MA 02111-1307 USA 
'''

__first__ = '2004.9.9'
__last__ = '2004.10.29'

import sys
import trace
import threading
import time

class KThreadError(Exception):
    '''Encapsulates KThread exceptions.'''
    pass

class KThread(threading.Thread):
  """A subclass of threading.Thread, with a kill() method."""
  def __init__(self, *args, **keywords):
    threading.Thread.__init__(self, *args, **keywords)
    self.killed = False

  def start(self):
    """Start the thread."""
    self.__run_backup = self.run
    self.run = self.__run      # Force the Thread to install our trace.
    threading.Thread.start(self)

  def __run(self):
    """Hacked run function, which installs the trace."""
    sys.settrace(self.globaltrace)
    self.__run_backup()
    self.run = self.__run_backup

  def globaltrace(self, frame, why, arg):
    if why == 'call':
      return self.localtrace
    else:
      return None

  def localtrace(self, frame, why, arg):
    if self.killed:
      if why == 'line':
        raise SystemExit()
    return self.localtrace

  def kill(self):
    self.killed = True

if __name__ == '__main__':
    
    def func():
        print('Function started')
        for i in xrange(1000000):
            pass
        print('Function finished')

    A = KThread(target=func)
    A.start()
    for i in xrange(1000):
      pass
    A.kill()

    print('End of main program')

########NEW FILE########
__FILENAME__ = profilebrowser
# Excerpt from pstats.py rev 1.0  4/1/94 (from python v2.6) which define this class only when it's the entry point (main), so it is here copied to avoid compatibility issues with the next python's releases.

from pstats import *

import cmd
try:
    import readline
except ImportError:
    pass

class ProfileBrowser(cmd.Cmd):
    def __init__(self, profile=None):
        cmd.Cmd.__init__(self)
        self.prompt = "% "
        if profile is not None:
            self.stats = Stats(profile)
            self.stream = self.stats.stream
        else:
            self.stats = None
            self.stream = sys.stdout

    def generic(self, fn, line):
        args = line.split()
        processed = []
        for term in args:
            try:
                processed.append(int(term))
                continue
            except ValueError:
                pass
            try:
                frac = float(term)
                if frac > 1 or frac < 0:
                    print >> self.stream, "Fraction argument must be in [0, 1]"
                    continue
                processed.append(frac)
                continue
            except ValueError:
                pass
            processed.append(term)
        if self.stats:
            getattr(self.stats, fn)(*processed)
        else:
            print >> self.stream, "No statistics object is loaded."
        return 0
    def generic_help(self):
        print >> self.stream, "Arguments may be:"
        print >> self.stream, "* An integer maximum number of entries to print."
        print >> self.stream, "* A decimal fractional number between 0 and 1, controlling"
        print >> self.stream, "  what fraction of selected entries to print."
        print >> self.stream, "* A regular expression; only entries with function names"
        print >> self.stream, "  that match it are printed."

    def do_add(self, line):
        self.stats.add(line)
        return 0
    def help_add(self):
        print >> self.stream, "Add profile info from given file to current statistics object."

    def do_callees(self, line):
        return self.generic('print_callees', line)
    def help_callees(self):
        print >> self.stream, "Print callees statistics from the current stat object."
        self.generic_help()

    def do_callers(self, line):
        return self.generic('print_callers', line)
    def help_callers(self):
        print >> self.stream, "Print callers statistics from the current stat object."
        self.generic_help()

    def do_EOF(self, line):
        print >> self.stream, ""
        return 1
    def help_EOF(self):
        print >> self.stream, "Leave the profile brower."

    def do_quit(self, line):
        return 1
    def help_quit(self):
        print >> self.stream, "Leave the profile brower."

    def do_read(self, line):
        if line:
            try:
                self.stats = Stats(line)
            except IOError, args:
                print >> self.stream, args[1]
                return
            self.prompt = line + "% "
        elif len(self.prompt) > 2:
            line = self.prompt[-2:]
        else:
            print >> self.stream, "No statistics object is current -- cannot reload."
        return 0
    def help_read(self):
        print >> self.stream, "Read in profile data from a specified file."

    def do_reverse(self, line):
        self.stats.reverse_order()
        return 0
    def help_reverse(self):
        print >> self.stream, "Reverse the sort order of the profiling report."

    def do_sort(self, line):
        abbrevs = self.stats.get_sort_arg_defs()
        if line and not filter(lambda x,a=abbrevs: x not in a,line.split()):
            self.stats.sort_stats(*line.split())
        else:
            print >> self.stream, "Valid sort keys (unique prefixes are accepted):"
            for (key, value) in Stats.sort_arg_dict_default.iteritems():
                print >> self.stream, "%s -- %s" % (key, value[1])
        return 0
    def help_sort(self):
        print >> self.stream, "Sort profile data according to specified keys."
        print >> self.stream, "(Typing `sort' without arguments lists valid keys.)"
    def complete_sort(self, text, *args):
        return [a for a in Stats.sort_arg_dict_default if a.startswith(text)]

    def do_stats(self, line):
        return self.generic('print_stats', line)
    def help_stats(self):
        print >> self.stream, "Print statistics from the current stat object."
        self.generic_help()

    def do_strip(self, line):
        self.stats.strip_dirs()
        return 0
    def help_strip(self):
        print >> self.stream, "Strip leading path information from filenames in the report."

    def postcmd(self, stop, line):
        if stop:
            return stop
        return None
########NEW FILE########
__FILENAME__ = PurePythonGeoIP
#! /usr/bin/python

# PurePythonGeoIP.py
#
# Copyright (C) 2005 Guwashi <guwashi[AT]fooos[DOT]com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# This code is based on
# http://www.maxmind.com/app/python
# http://www.maxmind.com/download/geoip/api/pureperl

import re
import struct

PUREPYTHONGEOIP_VERSION = '1.0.0'

def nreverse(sequence):
    '''nreverse in Common Lisp. :)'''
    sequence.reverse()
    return sequence

class GeoIP:
    __STANDARD_RECORD_LENGTH = 3
    __GEOIP_COUNTRY_EDITION = 106
    __GEOIP_COUNTRY_BEGIN = 16776960

    __COUNTRIES = ('--','AP','EU','AD','AE','AF','AG','AI','AL','AM','AN','AO','AQ','AR','AS','AT','AU','AW','AZ','BA','BB','BD','BE','BF','BG','BH','BI','BJ','BM','BN','BO','BR','BS','BT','BV','BW','BY','BZ','CA','CC','CD','CF','CG','CH','CI','CK','CL','CM','CN','CO','CR','CU','CV','CX','CY','CZ','DE','DJ','DK','DM','DO','DZ','EC','EE','EG','EH','ER','ES','ET','FI','FJ','FK','FM','FO','FR','FX','GA','GB','GD','GE','GF','GH','GI','GL','GM','GN','GP','GQ','GR','GS','GT','GU','GW','GY','HK','HM','HN','HR','HT','HU','ID','IE','IL','IN','IO','IQ','IR','IS','IT','JM','JO','JP','KE','KG','KH','KI','KM','KN','KP','KR','KW','KY','KZ','LA','LB','LC','LI','LK','LR','LS','LT','LU','LV','LY','MA','MC','MD','MG','MH','MK','ML','MM','MN','MO','MP','MQ','MR','MS','MT','MU','MV','MW','MX','MY','MZ','NA','NC','NE','NF','NG','NI','NL','NO','NP','NR','NU','NZ','OM','PA','PE','PF','PG','PH','PK','PL','PM','PN','PR','PS','PT','PW','PY','QA','RE','RO','RU','RW','SA','SB','SC','SD','SE','SG','SH','SI','SJ','SK','SL','SM','SN','SO','SR','ST','SV','SY','SZ','TC','TD','TF','TG','TH','TJ','TK','TM','TN','TO','TP','TR','TT','TV','TW','TZ','UA','UG','UM','US','UY','UZ','VA','VC','VE','VG','VI','VN','VU','WF','WS','YE','YT','YU','ZA','ZM','ZR','ZW','A1','A2')
    __CODE3S = ('--','AP','EU','AND','ARE','AFG','ATG','AIA','ALB','ARM','ANT','AGO','AQ','ARG','ASM','AUT','AUS','ABW','AZE','BIH','BRB','BGD','BEL','BFA','BGR','BHR','BDI','BEN','BMU','BRN','BOL','BRA','BHS','BTN','BV','BWA','BLR','BLZ','CAN','CC','COD','CAF','COG','CHE','CIV','COK','CHL','CMR','CHN','COL','CRI','CUB','CPV','CX','CYP','CZE','DEU','DJI','DNK','DMA','DOM','DZA','ECU','EST','EGY','ESH','ERI','ESP','ETH','FIN','FJI','FLK','FSM','FRO','FRA','FX','GAB','GBR','GRD','GEO','GUF','GHA','GIB','GRL','GMB','GIN','GLP','GNQ','GRC','GS','GTM','GUM','GNB','GUY','HKG','HM','HND','HRV','HTI','HUN','IDN','IRL','ISR','IND','IO','IRQ','IRN','ISL','ITA','JAM','JOR','JPN','KEN','KGZ','KHM','KIR','COM','KNA','PRK','KOR','KWT','CYM','KAZ','LAO','LBN','LCA','LIE','LKA','LBR','LSO','LTU','LUX','LVA','LBY','MAR','MCO','MDA','MDG','MHL','MKD','MLI','MMR','MNG','MAC','MNP','MTQ','MRT','MSR','MLT','MUS','MDV','MWI','MEX','MYS','MOZ','NAM','NCL','NER','NFK','NGA','NIC','NLD','NOR','NPL','NRU','NIU','NZL','OMN','PAN','PER','PYF','PNG','PHL','PAK','POL','SPM','PCN','PRI','PSE','PRT','PLW','PRY','QAT','REU','ROM','RUS','RWA','SAU','SLB','SYC','SDN','SWE','SGP','SHN','SVN','SJM','SVK','SLE','SMR','SEN','SOM','SUR','STP','SLV','SYR','SWZ','TCA','TCD','TF','TGO','THA','TJK','TKL','TLS','TKM','TUN','TON','TUR','TTO','TUV','TWN','TZA','UKR','UGA','UM','USA','URY','UZB','VAT','VCT','VEN','VGB','VIR','VNM','VUT','WLF','WSM','YEM','YT','YUG','ZAF','ZMB','ZR','ZWE','A1','A2')
    __NAMES = ("--","Asia/Pacific Region","Europe","Andorra","United Arab Emirates","Afghanistan","Antigua and Barbuda","Anguilla","Albania","Armenia","Netherlands Antilles","Angola","Antarctica","Argentina","American Samoa","Austria","Australia","Aruba","Azerbaijan","Bosnia and Herzegovina","Barbados","Bangladesh","Belgium","Burkina Faso","Bulgaria","Bahrain","Burundi","Benin","Bermuda","Brunei Darussalam","Bolivia","Brazil","Bahamas","Bhutan","Bouvet Island","Botswana","Belarus","Belize","Canada","Cocos (Keeling) Islands","Congo, The Democratic Republic of the","Central African Republic","Congo","Switzerland","Cote D'Ivoire","Cook Islands","Chile","Cameroon","China","Colombia","Costa Rica","Cuba","Cape Verde","Christmas Island","Cyprus","Czech Republic","Germany","Djibouti","Denmark","Dominica","Dominican Republic","Algeria","Ecuador","Estonia","Egypt","Western Sahara","Eritrea","Spain","Ethiopia","Finland","Fiji","Falkland Islands (Malvinas)","Micronesia, Federated States of","Faroe Islands","France","France, Metropolitan","Gabon","United Kingdom","Grenada","Georgia","French Guiana","Ghana","Gibraltar","Greenland","Gambia","Guinea","Guadeloupe","Equatorial Guinea","Greece","South Georgia and the South Sandwich Islands","Guatemala","Guam","Guinea-Bissau","Guyana","Hong Kong","Heard Island and McDonald Islands","Honduras","Croatia","Haiti","Hungary","Indonesia","Ireland","Israel","India","British Indian Ocean Territory","Iraq","Iran, Islamic Republic of","Iceland","Italy","Jamaica","Jordan","Japan","Kenya","Kyrgyzstan","Cambodia","Kiribati","Comoros","Saint Kitts and Nevis",
"Korea, Democratic People's Republic of","Korea, Republic of","Kuwait","Cayman Islands","Kazakhstan","Lao People's Democratic Republic","Lebanon","Saint Lucia","Liechtenstein","Sri Lanka","Liberia","Lesotho","Lithuania","Luxembourg","Latvia","Libyan Arab Jamahiriya","Morocco","Monaco","Moldova, Republic of","Madagascar","Marshall Islands","Macedonia","Mali","Myanmar","Mongolia","Macau","Northern Mariana Islands","Martinique","Mauritania","Montserrat","Malta","Mauritius","Maldives","Malawi","Mexico","Malaysia","Mozambique","Namibia","New Caledonia","Niger","Norfolk Island","Nigeria","Nicaragua","Netherlands","Norway","Nepal","Nauru","Niue","New Zealand","Oman","Panama","Peru","French Polynesia","Papua New Guinea","Philippines","Pakistan","Poland","Saint Pierre and Miquelon","Pitcairn Islands","Puerto Rico","Palestinian Territory, Occupied","Portugal","Palau","Paraguay","Qatar","Reunion","Romania","Russian Federation","Rwanda","Saudi Arabia","Solomon Islands","Seychelles","Sudan","Sweden","Singapore","Saint Helena","Slovenia","Svalbard and Jan Mayen","Slovakia","Sierra Leone","San Marino","Senegal","Somalia","Suriname","Sao Tome and Principe","El Salvador","Syrian Arab Republic","Swaziland","Turks and Caicos Islands","Chad","French Southern Territories","Togo","Thailand","Tajikistan","Tokelau","Turkmenistan","Tunisia","Tonga","East Timor","Turkey","Trinidad and Tobago","Tuvalu","Taiwan","Tanzania, United Republic of","Ukraine","Uganda","United States Minor Outlying Islands","United States","Uruguay","Uzbekistan","Holy See (Vatican City State)","Saint Vincent and the Grenadines","Venezuela","Virgin Islands, British","Virgin Islands, U.S.","Vietnam","Vanuatu","Wallis and Futuna","Samoa","Yemen","Mayotte","Yugoslavia","South Africa","Zambia","Zaire","Zimbabwe",
"Anonymous Proxy","Satellite Provider")

    __RE_IP_DOTTED_FORM = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")

    GEOIP_STANDARD = 0 # TODO

    def addr_to_num(ip_address):
        '''Convert IP-address to number.'''
        # a = [int(s) for s in re.split('\.', ip_address)]
        a = map(int, re.split('\.', ip_address))
        return a[0] * 16777216L + a[1] * 65536L + a[2] * 256L + a[3]

    def open(db_file, flags):
        '''Create a new GeoIP object.'''
        gi = GeoIP()
        gi.db_file = db_file
        gi.flags = flags # TODO
        gi.fh = open(db_file, 'rb')
        gi.databaseType = GeoIP.__GEOIP_COUNTRY_EDITION # TODO
        gi.record_length = GeoIP.__STANDARD_RECORD_LENGTH # TODO
        gi.databaseSegments = GeoIP.__GEOIP_COUNTRY_BEGIN # TODO
        return gi

    def new(flags):
        '''Create a new GeoIP object.'''
        return GeoIP.open('/usr/local/share/GeoIP/GeoIP.dat', flags)

    def __seek_country(self, ipnum):
        '''Seek GeoIP data file to find country id.'''
        fh = self.fh
        record_length = self.record_length
        databaseSegments = self.databaseSegments
        offset = 0
        x0 = -1
        x1 = -1
        for depth in nreverse(range(32)):
            fh.seek(offset * 2 * record_length, 0)
            x0 = fh.read(record_length)
            x1 = fh.read(record_length)
            x0, = struct.unpack("<1l", x0 + "\0")
            x1, = struct.unpack("<1l", x1 + "\0")
            if ipnum & (1L << depth):
                if x1 >= databaseSegments:
                    return x1
                offset = x1
            else:
                if x0 >= databaseSegments:
                    return x0
                offset = x0
        raise Exception('Error Traversing Database for ipnum = %d - Perhaps database is corrupt?' % ipnum) # TODO

    def id_by_addr(self, ip_address):
        '''Find country id by IP-address.'''
        if self.__RE_IP_DOTTED_FORM.match(ip_address):
            return self.__seek_country(self.addr_to_num(ip_address)) - self.__GEOIP_COUNTRY_BEGIN
        else:
            return 0

    def id_to_country_code(id):
        '''Convert country id to country code.'''
        return GeoIP.__COUNTRIES[id]

    def id_to_country_code3(id):
        '''Convert country id to country code.'''
        return GeoIP.__CODE3S[id]

    def id_to_country_name(id):
        '''Convert country id to country code.'''
        return GeoIP.__NAMES[id]

    def country_code_by_addr(self, ip_address):
        '''Find country code by IP-address.'''
        return GeoIP.id_to_country_code(self.id_by_addr(ip_address))

    def country_code3_by_addr(self, ip_address):
        '''Find country code3 by IP-address.'''
        return GeoIP.id_to_country_code3(self.id_by_addr(ip_address))

    def country_name_by_addr(self, ip_address):
        '''Find country name by IP-address.'''
        return GeoIP.id_to_country_name(self.id_by_addr(ip_address))

    addr_to_num = staticmethod(addr_to_num)
    open = staticmethod(open)
    new = staticmethod(new)
    id_to_country_code = staticmethod(id_to_country_code)
    id_to_country_code3 = staticmethod(id_to_country_code3)
    id_to_country_name = staticmethod(id_to_country_name)

if '__main__' == __name__:
    import sys
    import string

    argc = len(sys.argv)
    gi = None
    if 2 == argc:
        gi = GeoIP.new(GeoIP.GEOIP_STANDARD)
    elif 3 == argc:
        gi = GeoIP.open(sys.argv[2], GeoIP.GEOIP_STANDARD)
    else:
        print "Usage:\n  %s <ipaddress> [geoipdatafile]" % sys.argv[0]
        sys.exit(1)

    ip = sys.argv[1]
    id = str(gi.id_by_addr(ip))
    code = gi.country_code_by_addr(ip)
    code3 = gi.country_code3_by_addr(ip)
    name = gi.country_name_by_addr(ip)

    print string.join(['ipaddress', 'id', 'code', 'code3', 'name'], "\t")
    print string.join([ip, id, code, code3, name], "\t")

########NEW FILE########
__FILENAME__ = dumbprofile
import pdb, sys, time, thread, threading

class CodeInfo( object ):
    """Code-object information for multiple calls of code"""
    def __init__( self, code ):
        """Open the frame"""
        self.local = 0
        self.cummulative = 0
        self.callcount = 0
        self.children = {}
        self.lines = {}
        if isinstance( code, (str,unicode)):
            self.filename = '~'
            self.firstline = 0
            self.name = code
        else:
            self.filename = code.co_filename
            self.firstline = code.co_firstlineno
            self.name = code.co_name 
        self.code = code
    def add_line( self, lineno, delta ):
        """Add line-number delta for line-profiling operations"""
        self.lines[lineno] = self.lines.get( lineno,0) + delta 
    def add_local( self, delta ):
        """Add local time to our counters"""
        self.local += delta
        self.callcount += 1
    def add_cummulative( self, delta, subframe ):
        """Add cummulative time to our counters"""
        self.cummulative += delta
        if subframe:
            current = self.children.get( subframe.code_info, 0 )
            self.children[ subframe.code_info ] = current + delta 
    def __repr__( self ):
        return '%s -> %s %s'%(
            (self.filename,self.firstline,self.name),
            (self.local, self.cummulative, self.callcount),
            self.lines
        )
    

class FrameInfo( object ):
    """Storage of frame information for a single frame"""
    def __init__( self, frame, profiler, current_time ):
        """Open the frame"""
        self.local = 0
        self.cummulative = 0
        self.code_info = profiler.code_info_for( frame.f_code )
        self.start_time = current_time
        self.lines = {}
        self.open_line = None
    def add_local( self, delta ):
        """Add local time to our counters"""
        self.code_info.add_local( delta )
    def add_cummulative( self, delta, subframe ):
        """Add cummulative time to our counters"""
        self.code_info.add_cummulative( delta, subframe )
    def start_line( self, lineno, start_time ):
        self.lines[lineno] = start_time
        self.open_line = lineno
    def add_line( self, lineno, stop_time ):
        """Add per-line timing to our counters"""
        if self.lines.has_key( lineno ):
            delta = stop_time - self.lines[lineno]
            print 'delta for lineno:', lineno, delta
            self.code_info.add_line( lineno, delta )

class SimpleProfiler( object ):
    def __init__( self ):
        self.frame_info = [None]*sys.getrecursionlimit()
        self.code_info = {}
        self.frame_depth = -1
        self.internal_time = 0
        self.last_time = None
    def describe( self, frame ):
        return frame.f_lineno,(frame.f_code.co_name, frame.f_code.co_firstlineno)
    def __call__( self, frame, event, arg):
        # Obviously this would need a real high-precision timer...
        t = time.time()
        if self.last_time:
            delta = t - self.last_time 
        else:
            delta = 0
        self.internal_time += delta 
        if event in ('call','c_call'):
            self.frame_depth += 1
            frame_info = FrameInfo( frame, self, self.internal_time )
            self.frame_info[ self.frame_depth ] = frame_info
        elif event in ('return','exception','c_return','c_exception'):
            frame_info = self.frame_info[ self.frame_depth ]
            if frame_info:
                if frame_info.open_line is not None:
                    frame_info.add_line( frame_info.open_line, self.internal_time )
                frame_delta = self.internal_time - frame_info.start_time
                for i in range( self.frame_depth ):
                    info = self.frame_info[i]
                    if i < len(self.frame_info):
                        other = self.frame_info[i+1]
                    else:
                        other = None
                    if info is None:
                        print i,self.frame_info[:i+1]
                    info.add_cummulative( frame_delta, other )
                frame_info.add_local( frame_delta )
            self.frame_info[ self.frame_depth ] = None
            self.frame_depth -= 1
            if self.frame_depth >= 0:
                frame_info = self.frame_info[ self.frame_depth ]
                if frame_info.open_line:
                    frame_info.add_line( frame_info.open_line, self.internal_time )
        elif event in ('line',):
            frame_info = self.frame_info[ self.frame_depth ]
            if frame_info:
                if frame_info.open_line is not None:
                    frame_info.add_line( frame_info.open_line, self.internal_time )
                frame_info.start_line( frame.f_lineno, self.internal_time )
        
        self.last_time = time.time()
        return self
    def do_line_time( self, frame ):
        frame_info.add_line( frame.f_lineno, line_delta )
    
    def code_info_for( self, code ):
        current = self.code_info.get(code)
        if current is None:
            self.code_info[code] = current = CodeInfo( code )
        return current

def test():
    23L**10000
    time.sleep( 3.0 )
    r()
    
def r( depth = 5 ):
    if depth < 0:
        return None 
    else:
        z = '22344'* 100000
        time.sleep( .5 )
        return r( depth - 1 )

if __name__ == "__main__":
    s = SimpleProfiler()
    sys.settrace( s )
    test()
    sys.settrace( None )
    for value in s.code_info.values():
        print value
    

########NEW FILE########
__FILENAME__ = hotshotreader
"""Module implementing the hotshot profile-data reader"""
from hotshot import _hotshot
import os
import parser
import symbol
import sys
import numpy
import time

class FileRecord( object ):
    """Record for a source-file in the system"""
    def __init__( self, fileno, filename ):
        """Create the record for this file"""
        self.fileno = fileno 
        self.filename = filename
        self.functions = {}

class FunctionRecord( object ):
    def __init__( self, fileno,lineno, name, file ):
        """Initialise the record for this function"""
        self.fileno = fileno
        self.lineno = lineno 
        self.file = file # note, this is a circular reference!
        self.key = (fileno,lineno)
        self.name = name 
        # accumArray being (local, cummulative) time elapsed
        self.accumArray = numpy.zeros( (2,), 'd' )
        # callArray being (direct, recursive) call counts
        self.callArray = numpy.zeros( (2,), 'l' )
        # children arcs are functions which were called by this function 
        # should have the total they took for each of them...
        self.childrenArcs = {
            # (functionrecord,functionrecord): cummulativeTime,
        }
    def get_local( self ):
        return self.accumArray[0]
    def get_localPer( self ):
        return self.accumArray[0]/(self.callArray[0] or 1)
    def get_cummulative( self ):
        return self.accumArray[1]
    def get_cummulativePer( self ):
        return self.accumArray[1]/(self.callArray[0] or 1)
    def get_calls( self ):
        return self.callArray[0]
    def get_recursive( self ):
        return self.callArray[1]
    def get_directory( self ):
        return os.path.dirname( self.file.filename )
    def get_filename( self ):
        return os.path.basename( self.file.filename )
    local = property( get_local, None, None, """Local elapsed time""" )
    cummulative = property( get_cummulative, None, None, """Cummulative elapsed time""" )
    localPer = property( get_localPer, None, None, """Local elapsed time per call (average)""" )
    cummulativePer = property( get_cummulativePer, None, None, """Cummulative elapsed time per call (average)""" )
    calls = property( get_calls, None, None, """Total number of calls to the function""" )
    recursive = property( get_recursive, None, None, """Calls to the function where the function is already on the call stack""" )
    directory = property( get_directory, None, None, """Directory in which our file is stored""" )
    filename = property( get_filename, None, None, """The (base) file name in which we are defined""" )

GIVES_DELTA = {
    _hotshot.WHAT_LINENO:1,
    _hotshot.WHAT_EXIT:1,
    _hotshot.WHAT_ENTER:1,
}
SECONDS_FRACTION = .000001



def loadHotshot( filename, yieldCount=10000 ):
    """Given a hotshot profile file, load to in-memory structures
    
    yields recordCount, { fileno: filename, ... }, { (fileno,lineno): FunctionRecord, ...}
    
    for every yieldCount records in the file
    """
    reader = _hotshot.logreader(filename)
    files = {}
    functions = {}
    stackSize = sys.getrecursionlimit() * 2
    frames = [None]*stackSize
    localDeltas = numpy.zeros( (stackSize,), 'l' )
    # make this local for speed...
    givesDelta = GIVES_DELTA.has_key
    
    secondsFraction = SECONDS_FRACTION
    getFunction = functions.get
    defineFile = _hotshot.WHAT_DEFINE_FILE
    defineFunction = _hotshot.WHAT_DEFINE_FUNC
    whatEnter = _hotshot.WHAT_ENTER
    whatExit = _hotshot.WHAT_EXIT
    depth = -1
    i = 0
    for i, (what, tdelta, fileno, lineno) in enumerate(reader):
        if (not i%yieldCount) and i:
            yield i, files, functions
        if givesDelta( what ):
            key = fileno,lineno 
            print 'lineno', lineno, tdelta, getattr(getFunction( key ),'name','')
            if what == whatEnter:
                key = (fileno,lineno)
                function = getFunction( key )
                depth += 1
                try:
                    localDeltas[depth] = 0
                except IndexError, err:
                    print 'extend localDeltas'
                    localDeltas = numpy.resize( localDeltas, (depth+200,))
                if function is not None:
                    try:
                        frames[depth] = function.accumArray
                    except IndexError, err:
                        print 'extend frames'
                        frames.extend( [None]*((depth+200)-len(frames)) )
                    function.callArray[0]+=1
                    # XXX like to get rid of this copy eventually...
                    for frame in frames[:depth]:
                        if frame is function.accumArray:
                            function.callArray[1] += 1
                            break
                else:
                    try:
                        frames[depth] = None
                    except IndexError, err:
                        print 'extend frames'
                        frames.extend( [None]*((depth+200)-len(frames)) )
            # should both enter and exit tdelta get credited to the lower function?
            # current does so
            localDeltas[depth] += tdelta
            if what == whatExit:
                # add time spent in this frame to cummulative for all open frames
                localDelta = localDeltas[depth]*secondsFraction
                # XXX should avoid this list-copy somehow...
                lastParent = None
                for frame in frames[:depth]:
                    if frame is not None:
                        frame[1] += localDelta
                try:
                    # add time spent in this instance of this frame to local cummulative for this frame
                    depth -= 1
                    if frames[depth] is not None:
                        frames[depth][0] += localDelta
                except IndexError, err:
                    print 'Warning frame underflow!'
        elif what == defineFile:
            files[ fileno ] = FileRecord( fileno, tdelta )
        elif what == defineFunction:
            file = files.get( fileno )
            record = FunctionRecord( fileno,lineno,tdelta, file)
            functions[ (fileno,lineno) ] = record
            if file is not None:
                file.functions[ lineno ] = record
        else:
            print 'unrecognised what', what
            for name in [n for n in dir(_hotshot) if n.startswith( 'WHAT_')]:
                if getattr( _hotshot,name) == what:
                    print ' == %s'%(name,)
                    break

    yield i, files, functions

def loadHotshot2( filename ):
    """Yield a tree-like structure with stack: total values"""
    reader = _hotshot.logreader(filename)
    givesDelta = GIVES_DELTA.has_key
    secondsFraction = SECONDS_FRACTION
    defineFile = _hotshot.WHAT_DEFINE_FILE
    defineFunction = _hotshot.WHAT_DEFINE_FUNC
    whatEnter = _hotshot.WHAT_ENTER
    whatExit = _hotshot.WHAT_EXIT
    whatLine = _hotshot.WHAT_LINENO
    whatLineTime = _hotshot.WHAT_LINE_TIMES
    stack = ()
    files = {}
    functions = {}
    heatmap = {}
    
    currentDelta = 0.0
    for i, (what, tdelta, fileno, lineno) in enumerate(reader):
        if givesDelta( what ):
            tdelta*=secondsFraction
            if what == whatEnter:
                key = (fileno,lineno)
                stack += (key,)
            heatmap[stack] = heatmap.get(stack,0.0) + tdelta
            if what == whatExit:
                stack = stack[:-1]
        elif what == defineFile:
            files[ fileno ] = FileRecord( fileno, tdelta )
        elif what == defineFunction:
            file = files.get( fileno )
            record = FunctionRecord( fileno,lineno,tdelta, file)
            functions[ (fileno,lineno) ] = record
            if file is not None:
                file.functions[ lineno ] = record
        elif what == whatLineTime:
            print 'line time',(tdelta,fileno,lineno)
        else:
            print 'unrecognised what', what
            for name in [n for n in dir(_hotshot) if n.startswith( 'WHAT_')]:
                if getattr( _hotshot,name) == what:
                    print ' == %s'%(name,)
                    break
    return asTree( heatmap ), functions
class StackInfo( object ):
    def __init__( self, stack, local ):
        self.stack = stack 
        self.local = local 
        self.cummulative = local
        self.children = []
    def addChild( self, child ):
        self.children.append( child )
        self.cummulative += child.cummulative 
    def __repr__( self ):
        return 'StackInfo( %s, %s, children=%s )'%( self.stack, self.local, self.children )
def asTree( heatmap ):
    """Convert stacks to trees"""
    values = sorted( heatmap.items() )
    current = root = StackInfo( * values[0] )
    inProcess = [current]
    for (key,total) in values[1:]:
        child = StackInfo( key, total )
        if len(key) > len(current.stack):
            current.addChild( child )
            inProcess.append( child )
            current = child
        elif len(key) == len(current.stack):
            # sibling of current...
            inProcess.pop( -1 )
            inProcess.append( child )
            current = child 
        else:
            # sibling of a parent...
            while len(key) <= len(current.stack):
                inProcess.pop( -1 )
                current = inProcess[-1]
            current.addChild( child )
            inProcess.append( child )
            current = child
    return current

if __name__ == "__main__":
    import pprint
#    startTime = time.time()
#    for i, files, functions in loadHotshot( sys.argv[1], 100000 ):
#        t2 = time.time()
#        print '%s records in %ss: %s records/second'%(
#            i, t2-startTime, i/((t2-startTime) or 1),
#        )
#    completion = time.time()
#    print 'FUNCTIONS'
#    functionValues = functions.items()
#    functionValues.sort()
#    for (fileno,lineno),value in functionValues:
#        key = (fileno,lineno)
#        print files.get(fileno).filename, lineno,
#        print value.calls, value.recursive, value.local, value.cummulative
#    print 'read %i records in %s seconds'%( i, completion-startTime )

    t1 = time.time()
    pprint.pprint( loadHotshot2( sys.argv[1] ) )
    t2 = time.time()
    print 'loadHotshot2: %s seconds'%( t2-t1 )
    

########NEW FILE########
__FILENAME__ = memdumploader
"""Module to load py_mem_dump records into RunSnakeRun

memory_dump:

    https://launchpad.net/pymemorydump

Produces memory overviews very similar to the run-time overviews
of cProfile.  This module maps the memory-dump information into
the recursive records that RunSnakeRun needs to display properly.
"""
import pstats, os, logging
log = logging.getLogger( 'runsnake.memdumploader' )
#log.setLevel( logging.DEBUG )

class MemDumpLoader( object ):
    """Load memory_dump statistics from file"""
    def __init__( self, *filenames ):
        self.filename = filenames
        self.rows = {}
        self.stats = pstats.Stats( *filenames )
        self.tree = self.load( self.stats.stats )
    def load( self, stats ):
        """Build a squaremap-compatible model from a memory_dump loader"""
        rows = self.rows
        for func, raw in stats.iteritems():
            try:
                rows[func] =  PStatRow( func,raw )
            except ValueError, err:
                log.info( 'Null row: %s', func )
        for row in rows.itervalues():
            row.weave( rows )
        roots = []
        for key,value in rows.items():
            if not value.parents:
                log.debug( 'Found node root: %s', value )
                roots.append( value )
            #print key,
            #print '  ', value.parents
        if len(roots) == 1:
            log.debug( 'Single root', roots[0] )
            return roots[0]
        elif roots:
            root = PStatGroup( '/', 'PYTHONPATH', children= roots, name="<sys.path>" )
            root.finalize()
            self.rows[ root.key ] = root
            return root
        raise RuntimeError( 'No top-level function???' )
    def load_location( self ):
        """Build a squaremap-compatible model for location-based hierarchy"""
        directories = {}
        files = {}
        root = PStatLocation( '/', 'PYTHONPATH' )
        self.location_rows = self.rows.copy()
        for child in self.rows.values():
            current = directories.get( child.directory )
            directory, filename = child.directory, child.filename
            if current is None:
                if directory == '':
                    current = root
                else:
                    current = PStatLocation( directory, '' )
                    self.location_rows[ current.key ] = current
                directories[ directory ] = current
            if filename == '~':
                filename = '<built-in>'
            file_current = files.get( (directory,filename) )
            if file_current is None:
                file_current = PStatLocation( directory, filename )
                self.location_rows[ file_current.key ] = file_current
                files[ (directory,filename) ] = file_current
                current.children.append( file_current )
            file_current.children.append( child )
        # now link the directories...
        for key,value in directories.items():
            if value is root:
                continue
            found = False
            while key:
                new_key,rest = os.path.split( key )
                if new_key == key:
                    break
                key = new_key
                parent = directories.get( key )
                if parent:
                    if value is not parent:
                        parent.children.append( value )
                        found = True
                        break
            if not found:
                root.children.append( value )
        # lastly, finalize all of the directory records...
        root.finalize()
        return root

class BaseStat( object ):
    def recursive_distinct( self, already_done=None, attribute='children' ):
        if already_done is None:
            already_done = {}
        for child in getattr(self,attribute,()):
            if not already_done.has_key( child ):
                already_done[child] = True
                yield child
                for descendent in child.recursive_distinct( already_done=already_done, attribute=attribute ):
                    yield descendent

    def descendants( self ):
        return list( self.recursive_distinct( attribute='children' ))
    def ancestors( self ):
        return list( self.recursive_distinct( attribute='parents' ))

class PStatRow( BaseStat ):
    """Simulates a HotShot profiler record using PStats module"""
    def __init__( self, key, raw ):
        self.children = []
        self.parents = []
        file,line,func = self.key = key
        try:
            dirname,basename = os.path.dirname(file),os.path.basename(file)
        except ValueError, err:
            dirname = ''
            basename = file
        nc, cc, tt, ct, callers = raw
        if nc == cc == tt == ct == 0:
            raise ValueError( 'Null stats row' )
        (
            self.calls, self.recursive, self.local, self.localPer,
            self.cummulative, self.cummulativePer, self.directory,
            self.filename, self.name, self.lineno
        ) = (
            nc,
            cc,
            tt,
            tt/(cc or 0.00000000000001),
            ct,
            ct/(nc or 0.00000000000001),
            dirname,
            basename,
            func,
            line,
        )
        self.callers = callers
    def __repr__( self ):
        return 'PStatRow( %r,%r,%r,%r, %s )'%(self.directory, self.filename, self.lineno, self.name, len(self.children))
    def add_child( self, child ):
        self.children.append( child )

    def weave( self, rows ):
        for caller,data in self.callers.iteritems():
            # data is (cc,nc,tt,ct)
            parent = rows.get( caller )
            if parent:
                self.parents.append( parent )
                parent.children.append( self )
    def child_cumulative_time( self, child ):
        total = self.cummulative
        if total:
            try:
                (cc,nc,tt,ct) = child.callers[ self.key ]
            except TypeError, err:
                ct = child.callers[ self.key ]
            return float(ct)/total
        return 0



class PStatGroup( BaseStat ):
    """A node/record that holds a group of children but isn't a raw-record based group"""
    # if LOCAL_ONLY then only take the raw-record's local values, not cummulative values
    LOCAL_ONLY = False
    def __init__( self, directory='', filename='', name='', children=None, local_children=None, tree=TREE_CALLS ):
        self.directory = directory
        self.filename = filename
        self.name = ''
        self.key = (directory,filename,name)
        self.children = children or []
        self.parents = []
        self.local_children = local_children or []
        self.tree = tree
    def __repr__( self ):
        return '%s( %r,%r,%s )'%(self.__class__.__name__,self.directory, self.filename, self.name)
    def finalize( self, already_done=None ):
        """Finalize our values (recursively) taken from our children"""
        if already_done is None:
            already_done = {}
        if already_done.has_key( self ):
            return True
        already_done[self] = True
        self.filter_children()
        children = self.children
        for child in children:
            if hasattr( child, 'finalize' ):
                child.finalize( already_done)
            child.parents.append( self )
        self.calculate_totals( self.children, self.local_children )
    def filter_children( self ):
        """Filter our children into regular and local children sets (if appropriate)"""
    def calculate_totals( self, children, local_children=None ):
        """Calculate our cummulative totals from children and/or local children"""
        for field,local_field in (('recursive','calls'),('cummulative','local')):
            values = []
            for child in children:
                if isinstance( child, PStatGroup ) or not self.LOCAL_ONLY:
                    values.append( getattr( child, field, 0 ) )
                elif isinstance( child, PStatRow ) and self.LOCAL_ONLY:
                    values.append( getattr( child, local_field, 0 ) )
            value = sum( values )
            setattr( self, field, value )
        if self.recursive:
            self.cummulativePer = self.cummulative/float(self.recursive)
        else:
            self.recursive = 0
        if local_children:
            for field in ('local','calls'):
                value = sum([ getattr( child, field, 0 ) for child in children] )
                setattr( self, field, value )
            if self.calls:
                self.localPer = self.local / self.calls
        else:
            self.local = 0
            self.calls = 0
            self.localPer = 0


class PStatLocation( PStatGroup ):
    """A row that represents a hierarchic structure other than call-patterns

    This is used to create a file-based hierarchy for the views

    Children with the name <module> are our "empty" space,
    our totals are otherwise just the sum of our children.
    """
    LOCAL_ONLY = True
    def __init__( self, directory, filename, tree=TREE_FILES):
        super( PStatLocation, self ).__init__( directory=directory, filename=filename, name='package', tree=tree )
    def filter_children( self ):
        """Filter our children into regular and local children sets"""
        real_children = []
        for child in self.children:
            if child.name == '<module>':
                self.local_children.append( child )
            else:
                real_children.append( child )
        self.children = real_children



if __name__ == "__main__":
    import sys
    p = PStatsLoader( sys.argv[1] )
    assert p.tree
    print p.tree

########NEW FILE########
__FILENAME__ = pstatsloader
"""Module to load cProfile/profile records as a tree of records"""
import pstats, os, logging
log = logging.getLogger( 'runsnake.pstatsloader' )
#log.setLevel( logging.DEBUG )
from gettext import gettext as _

TREE_CALLS, TREE_FILES = range( 2 )

class PStatsLoader( object ):
    """Load profiler statistic from """
    def __init__( self, *filenames ):
        self.filename = filenames
        self.rows = {}
        self.stats = pstats.Stats( *filenames )
        self.tree = self.load( self.stats.stats )
        self.location_rows = {}
        self.location_tree = l = self.load_location( )
    def load( self, stats ):
        """Build a squaremap-compatible model from a pstats class"""
        rows = self.rows
        for func, raw in stats.iteritems():
            try:
                rows[func] = row = PStatRow( func,raw )
            except ValueError, err:
                log.info( 'Null row: %s', func )
        for row in rows.itervalues():
            row.weave( rows )
        return self.find_root( rows )

    def find_root( self, rows ):
        """Attempt to find/create a reasonable root node from list/set of rows

        rows -- key: PStatRow mapping

        TODO: still need more robustness here, particularly in the case of
        threaded programs.  Should be tracing back each row to root, breaking
        cycles by sorting on cummulative time, and then collecting the traced
        roots (or, if they are all on the same root, use that).
        """
        maxes = sorted( rows.values(), key = lambda x: x.cummulative )
        if not maxes:
            raise RuntimeError( """Null results!""" )
        root = maxes[-1]
        roots = [root]
        for key,value in rows.items():
            if not value.parents:
                log.debug( 'Found node root: %s', value )
                if value not in roots:
                    roots.append( value )
        if len(roots) > 1:
            root = PStatGroup(
                directory='*',
                filename='*',
                name=_("<profiling run>"),
                children= roots,
            )
            root.finalize()
            self.rows[ root.key ] = root
        return root
    def load_location( self ):
        """Build a squaremap-compatible model for location-based hierarchy"""
        directories = {}
        files = {}
        root = PStatLocation( '/', 'PYTHONPATH' )
        self.location_rows = self.rows.copy()
        for child in self.rows.values():
            current = directories.get( child.directory )
            directory, filename = child.directory, child.filename
            if current is None:
                if directory == '':
                    current = root
                else:
                    current = PStatLocation( directory, '' )
                    self.location_rows[ current.key ] = current
                directories[ directory ] = current
            if filename == '~':
                filename = '<built-in>'
            file_current = files.get( (directory,filename) )
            if file_current is None:
                file_current = PStatLocation( directory, filename )
                self.location_rows[ file_current.key ] = file_current
                files[ (directory,filename) ] = file_current
                current.children.append( file_current )
            file_current.children.append( child )
        # now link the directories...
        for key,value in directories.items():
            if value is root:
                continue
            found = False
            while key:
                new_key,rest = os.path.split( key )
                if new_key == key:
                    break
                key = new_key
                parent = directories.get( key )
                if parent:
                    if value is not parent:
                        parent.children.append( value )
                        found = True
                        break
            if not found:
                root.children.append( value )
        # lastly, finalize all of the directory records...
        root.finalize()
        return root

class BaseStat( object ):
    def recursive_distinct( self, already_done=None, attribute='children' ):
        if already_done is None:
            already_done = {}
        for child in getattr(self,attribute,()):
            if not already_done.has_key( child ):
                already_done[child] = True
                yield child
                for descendent in child.recursive_distinct( already_done=already_done, attribute=attribute ):
                    yield descendent

    def descendants( self ):
        return list( self.recursive_distinct( attribute='children' ))
    def ancestors( self ):
        return list( self.recursive_distinct( attribute='parents' ))

class PStatRow( BaseStat ):
    """Simulates a HotShot profiler record using PStats module"""
    def __init__( self, key, raw ):
        self.children = []
        self.parents = []
        file,line,func = self.key = key
        try:
            dirname,basename = os.path.dirname(file),os.path.basename(file)
        except ValueError, err:
            dirname = ''
            basename = file
        nc, cc, tt, ct, callers = raw
        if nc == cc == tt == ct == 0:
            raise ValueError( 'Null stats row' )
        (
            self.calls, self.recursive, self.local, self.localPer,
            self.cummulative, self.cummulativePer, self.directory,
            self.filename, self.name, self.lineno
        ) = (
            nc,
            cc,
            tt,
            tt/(cc or 0.00000000000001),
            ct,
            ct/(nc or 0.00000000000001),
            dirname,
            basename,
            func,
            line,
        )
        self.callers = callers
    def __repr__( self ):
        return 'PStatRow( %r,%r,%r,%r, %s )'%(self.directory, self.filename, self.lineno, self.name, len(self.children))
    def add_child( self, child ):
        self.children.append( child )

    def weave( self, rows ):
        for caller,data in self.callers.iteritems():
            # data is (cc,nc,tt,ct)
            parent = rows.get( caller )
            if parent:
                self.parents.append( parent )
                parent.children.append( self )
    def child_cumulative_time( self, child ):
        total = self.cummulative
        if total:
            try:
                (cc,nc,tt,ct) = child.callers[ self.key ]
            except TypeError, err:
                ct = child.callers[ self.key ]
            return float(ct)/total
        return 0



class PStatGroup( BaseStat ):
    """A node/record that holds a group of children but isn't a raw-record based group"""
    # if LOCAL_ONLY then only take the raw-record's local values, not cummulative values
    LOCAL_ONLY = False
    def __init__( self, directory='', filename='', name='', children=None, local_children=None, tree=TREE_CALLS ):
        self.directory = directory
        self.filename = filename
        self.name = ''
        self.key = (directory,filename,name)
        self.children = children or []
        self.parents = []
        self.local_children = local_children or []
        self.tree = tree
    def __repr__( self ):
        return '%s( %r,%r,%s )'%(self.__class__.__name__,self.directory, self.filename, self.name)
    def finalize( self, already_done=None ):
        """Finalize our values (recursively) taken from our children"""
        if already_done is None:
            already_done = {}
        if already_done.has_key( self ):
            return True
        already_done[self] = True
        self.filter_children()
        children = self.children
        for child in children:
            if hasattr( child, 'finalize' ):
                child.finalize( already_done)
            child.parents.append( self )
        self.calculate_totals( self.children, self.local_children )
    def filter_children( self ):
        """Filter our children into regular and local children sets (if appropriate)"""
    def calculate_totals( self, children, local_children=None ):
        """Calculate our cummulative totals from children and/or local children"""
        for field,local_field in (('recursive','calls'),('cummulative','local')):
            values = []
            for child in children:
                if isinstance( child, PStatGroup ) or not self.LOCAL_ONLY:
                    values.append( getattr( child, field, 0 ) )
                elif isinstance( child, PStatRow ) and self.LOCAL_ONLY:
                    values.append( getattr( child, local_field, 0 ) )
            value = sum( values )
            setattr( self, field, value )
        if self.recursive:
            self.cummulativePer = self.cummulative/float(self.recursive)
        else:
            self.recursive = 0
        if local_children:
            for field in ('local','calls'):
                value = sum([ getattr( child, field, 0 ) for child in children] )
                setattr( self, field, value )
            if self.calls:
                self.localPer = self.local / self.calls
        else:
            self.local = 0
            self.calls = 0
            self.localPer = 0


class PStatLocation( PStatGroup ):
    """A row that represents a hierarchic structure other than call-patterns

    This is used to create a file-based hierarchy for the views

    Children with the name <module> are our "empty" space,
    our totals are otherwise just the sum of our children.
    """
    LOCAL_ONLY = True
    def __init__( self, directory, filename, tree=TREE_FILES):
        super( PStatLocation, self ).__init__( directory=directory, filename=filename, name='package', tree=tree )
    def filter_children( self ):
        """Filter our children into regular and local children sets"""
        real_children = []
        for child in self.children:
            if child.name == '<module>':
                self.local_children.append( child )
            else:
                real_children.append( child )
        self.children = real_children



if __name__ == "__main__":
    import sys
    p = PStatsLoader( sys.argv[1] )
    assert p.tree
    print p.tree

########NEW FILE########
__FILENAME__ = runsnake
#! /usr/bin/python
"""The main script for the RunSnakeRun profile viewer"""
import wx, sys, os, logging
try:
    from wx.py import editor
except ImportError, err:
    editor = None
from gettext import gettext as _
import pstats
import squaremap
import pstatsloader

if sys.platform == 'win32':
    windows = True
else:
    windows = False

log = logging.getLogger('runsnake.main')


ID_OPEN = wx.NewId()
ID_EXIT = wx.NewId()
ID_PACKAGE_VIEW = wx.NewId()
ID_PERCENTAGE_VIEW = wx.NewId()
ID_ROOT_VIEW = wx.NewId()
ID_BACK_VIEW = wx.NewId()
ID_UP_VIEW = wx.NewId()
ID_DEEPER_VIEW = wx.NewId()
ID_SHALLOWER_VIEW = wx.NewId()


class PStatsAdapter(squaremap.DefaultAdapter):

    percentageView = False
    total = 0

    def value(self, node, parent=None):
        if isinstance(parent, pstatsloader.PStatGroup):
            if parent.cummulative:
                return node.cummulative / parent.cummulative
            else:
                return 0
        return parent.child_cumulative_time(node)

    def label(self, node):
        if isinstance(node, pstatsloader.PStatGroup):
            return '%s / %s' % (node.filename, node.directory)
        if self.percentageView and self.total:
            time = '%0.2f%%' % round(node.cummulative * 100.0 / self.total, 2)
        else:
            time = '%0.3fs' % round(node.cummulative, 3)
        return '%s@%s:%s [%s]' % (node.name, node.filename, node.lineno, time)

    def empty(self, node):
        if node.cummulative:
            return node.local / float(node.cummulative)
        return 0.0

    def parents(self, node):
        return getattr(node, 'parents', [])

    color_mapping = None

    def background_color(self, node, depth):
        """Create a (unique-ish) background color for each node"""
        if self.color_mapping is None:
            self.color_mapping = {}
        color = self.color_mapping.get(node.key)
        if color is None:
            depth = len(self.color_mapping)
            red = (depth * 10) % 255
            green = 200 - ((depth * 5) % 200)
            blue = (depth * 25) % 200
            self.color_mapping[node.key] = color = wx.Color(red, green, blue)
        return color

    def SetPercentage(self, percent, total):
        """Set whether to display percentage values (and total for doing so)"""
        self.percentageView = percent
        self.total = total



class DirectoryViewAdapter(PStatsAdapter):
    """Provides a directory-view-only adapter for PStats objects"""

    def children(self, node):
        if isinstance(node, pstatsloader.PStatGroup):
            return node.children
        return []


class ColumnDefinition(object):
    """Definition of a given column for display"""

    index = None
    name = None
    attribute = None
    sortOn = None
    format = None
    defaultOrder = False
    percentPossible = False
    targetWidth = None

    def __init__(self, **named):
        for key, value in named.items():
            setattr(self, key, value)

    def get(self, function):
        """Get the value for this column from the function"""
        return getattr(function, self.attribute, '')

class ProfileView(wx.ListCtrl):
    """A sortable profile list control"""

    indicated = -1
    total = 0
    percentageView = False
    activated_node = None
    selected_node = None
    indicated_node = None

    def __init__(
        self, parent,
        id=-1,
        pos=wx.DefaultPosition, size=wx.DefaultSize,
        style=wx.LC_REPORT|wx.LC_VIRTUAL|wx.LC_VRULES|wx.LC_SINGLE_SEL,
        validator=wx.DefaultValidator,
        columns=None,
        name=_("ProfileView"),
    ):
        wx.ListCtrl.__init__(self, parent, id, pos, size, style, validator,
                             name)
        if columns is not None:
            self.columns = columns
        self.sortOrder = [ (self.columns[5].defaultOrder, self.columns[5]), ]
        self.sorted = []
        self.CreateControls()

    def SetPercentage(self, percent, total):
        """Set whether to display percentage values (and total for doing so)"""
        self.percentageView = percent
        self.total = total
        self.Refresh()

    def CreateControls(self):
        """Create our sub-controls"""
        wx.EVT_LIST_COL_CLICK(self, self.GetId(), self.OnReorder)
        wx.EVT_LIST_ITEM_SELECTED(self, self.GetId(), self.OnNodeSelected)
        wx.EVT_MOTION(self, self.OnMouseMove)
        wx.EVT_LIST_ITEM_ACTIVATED(self, self.GetId(), self.OnNodeActivated)
        for i, column in enumerate(self.columns):
            column.index = i
            self.InsertColumn(i, column.name)
            if not windows or column.targetWidth is None:
                self.SetColumnWidth(i, wx.LIST_AUTOSIZE)
            else:
                self.SetColumnWidth(i, column.targetWidth)
        self.SetItemCount(0)

    def OnNodeActivated(self, event):
        """We have double-clicked for hit enter on a node refocus squaremap to this node"""
        try:
            node = self.sorted[event.GetIndex()]
        except IndexError, err:
            log.warn(_('Invalid index in node activated: %(index)s'),
                     index=event.GetIndex())
        else:
            wx.PostEvent(
                self,
                squaremap.SquareActivationEvent(node=node, point=None,
                                                map=None)
            )

    def OnNodeSelected(self, event):
        """We have selected a node with the list control, tell the world"""
        try:
            node = self.sorted[event.GetIndex()]
        except IndexError, err:
            log.warn(_('Invalid index in node selected: %(index)s'),
                     index=event.GetIndex())
        else:
            if node is not self.selected_node:
                wx.PostEvent(
                    self,
                    squaremap.SquareSelectionEvent(node=node, point=None,
                                                   map=None)
                )

    def OnMouseMove(self, event):
        point = event.GetPosition()
        item, where = self.HitTest(point)
        if item > -1:
            try:
                node = self.sorted[item]
            except IndexError, err:
                log.warn(_('Invalid index in mouse move: %(index)s'),
                         index=event.GetIndex())
            else:
                wx.PostEvent(
                    self,
                    squaremap.SquareHighlightEvent(node=node, point=point,
                                                   map=None)
                )

    def SetIndicated(self, node):
        """Set this node to indicated status"""
        self.indicated_node = node
        self.indicated = self.NodeToIndex(node)
        self.Refresh(False)
        return self.indicated

    def SetSelected(self, node):
        """Set our selected node"""
        self.selected_node = node
        index = self.NodeToIndex(node)
        if index != -1:
            self.Focus(index)
            self.Select(index, True)
        return index

    def NodeToIndex(self, node):
        for i, n in enumerate(self.sorted):
            if n is node:
                return i
        return -1

    def columnByAttribute(self, name):
        for column in self.columns:
            if column.attribute == name:
                return column
        return None

    def OnReorder(self, event):
        """Given a request to reorder, tell us to reorder"""
        column = self.columns[event.GetColumn()]
        if column.sortOn:
            # multiple sorts for the click...
            columns = [self.columnByAttribute(attr) for attr in column.sortOn]
            diff = [(a, b) for a, b in zip(self.sortOrder, columns)
                    if b is not a[1]]
            if not diff:
                self.sortOrder[0] = (not self.sortOrder[0][0], column)
            else:
                self.sortOrder = [
                    (c.defaultOrder, c) for c in columns
                ] + [(a, b) for (a, b) in self.sortOrder if b not in columns]
        else:
            if column is self.sortOrder[0][1]:
                # reverse current major order
                self.sortOrder[0] = (not self.sortOrder[0][0], column)
            else:
                self.sortOrder = [(column.defaultOrder, column)] + [
                    (a, b)
                    for (a, b) in self.sortOrder if b is not column
                ]
        # TODO: store current selection and re-select after sorting...
        self.reorder()
        self.Refresh()

    def reorder(self):
        """Force a reorder of the displayed items"""
        self.sorted.sort(self.compareFunction)

    def compareFunction(self, first, second):
        """Compare two functions according to our current sort order"""
        for ascending, column in self.sortOrder:
            aValue, bValue = column.get(first), column.get(second)
            diff = cmp(aValue, bValue)
            if diff:
                if not ascending:
                    return -diff
                else:
                    return diff
        return 0

    def integrateRecords(self, functions):
        """Integrate records from the loader"""
        self.SetItemCount(len(functions))
        self.sorted = functions[:]
        self.reorder()
        self.Refresh()

    indicated_attribute = wx.ListItemAttr()
    indicated_attribute.SetBackgroundColour('#00ff00')

    def OnGetItemAttr(self, item):
        """Retrieve ListItemAttr for the given item (index)"""
        if self.indicated > -1 and item == self.indicated:
            return self.indicated_attribute
        return None

    def OnGetItemText(self, item, col):
        """Retrieve text for the item and column respectively"""
        # TODO: need to format for rjust and the like...
        try:
            column = self.columns[col]
            value = column.get(self.sorted[item])
        except IndexError, err:
            return None
        else:
            if column.percentPossible and self.percentageView and self.total:
                value = value / float(self.total) * 100.00
            if column.format:
                try:
                    return column.format % (value,)
                except Exception, err:
                    log.warn('Column %s could not format %r value: %s',
                        column.name, type(value), value
                    )
                    return str(value)
            else:
                return str(value)

    columns = [
        ColumnDefinition(
            name = _('Name'),
            attribute = 'name',
            defaultOrder = True,
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('Calls'),
            attribute = 'calls',
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('RCalls'),
            attribute = 'recursive',
            targetWidth = 40,
        ),
        ColumnDefinition(
            name = _('Local'),
            attribute = 'local',
            format = '%0.5f',
            percentPossible = True,
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('/Call'),
            attribute = 'localPer',
            format = '%0.5f',
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('Cum'),
            attribute = 'cummulative',
            format = '%0.5f',
            percentPossible = True,
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('/Call'),
            attribute = 'cummulativePer',
            format = '%0.5f',
            targetWidth = 50,
        ),
        ColumnDefinition(
            name = _('File'),
            attribute = 'filename',
            sortOn = ('filename', 'lineno', 'directory',),
            defaultOrder = True,
            targetWidth = 70,
        ),
        ColumnDefinition(
            name = _('Line'),
            attribute = 'lineno',
            sortOn = ('filename', 'lineno', 'directory'),
            defaultOrder = True,
            targetWidth = 30,
        ),
        ColumnDefinition(
            name = _('Directory'),
            attribute = 'directory',
            sortOn = ('directory', 'filename', 'lineno'),
            defaultOrder = True,
            targetWidth = 90,
        ),
    ]


class MainFrame(wx.Frame):
    """The root frame for the display of a single data-set"""

    loader = None
    percentageView = False
    directoryView = False
    historyIndex = -1
    activated_node = None
    selected_node = None
    TBFLAGS = (
        wx.TB_HORIZONTAL
        #| wx.NO_BORDER
        | wx.TB_FLAT
    )

    def __init__(
        self, parent=None, id=-1,
        title=_("Run Snake Run"),
        pos=wx.DefaultPosition,
        size=wx.DefaultSize,
        style=wx.DEFAULT_FRAME_STYLE|wx.CLIP_CHILDREN,
        name= _("RunSnakeRun"),
    ):
        """Initialise the Frame"""
        wx.Frame.__init__(self, parent, id, title, pos, size, style, name)
        # TODO: toolbar for back, up, root, directory-view, percentage view
        self.adapter = PStatsAdapter()
        self.CreateControls()
        self.history = [] # set of (activated_node, selected_node) pairs...

    def CreateControls(self):
        """Create our sub-controls"""
        self.CreateMenuBar()
        self.SetupToolBar()
        self.CreateStatusBar()
        self.leftSplitter = wx.SplitterWindow(
            self
        )
        self.rightSplitter = wx.SplitterWindow(
            self.leftSplitter
        )
        self.listControl = ProfileView(
            self.leftSplitter,
        )
        self.squareMap = squaremap.SquareMap(
            self.rightSplitter,
            padding = 6,
            labels = True,
            adapter = self.adapter,
        )
        self.tabs = wx.Notebook(
            self.rightSplitter,
        )

        self.calleeListControl = ProfileView(
            self.tabs,
        )
        self.allCalleeListControl = ProfileView(
            self.tabs,
        )
        self.allCallerListControl = ProfileView(
            self.tabs,
        )
        self.callerListControl = ProfileView(
            self.tabs,
        )
        self.CreateSourceWindow(self.tabs)
        self.ProfileListControls = [
            self.listControl,
            self.calleeListControl,
            self.allCalleeListControl,
            self.callerListControl,
            self.allCallerListControl,
        ]
        self.tabs.AddPage(self.calleeListControl, _('Callees'), True)
        self.tabs.AddPage(self.allCalleeListControl, _('All Callees'), False)
        self.tabs.AddPage(self.callerListControl, _('Callers'), False)
        self.tabs.AddPage(self.allCallerListControl, _('All Callers'), False)
        if editor:
            self.tabs.AddPage(self.sourceCodeControl, _('Source Code'), False)
        self.rightSplitter.SetSashSize(10)
        self.Maximize(True)
        # calculate size as proportional value for initial display...
        width, height = wx.GetDisplaySize()
        rightsplit = 2 * (height // 3)
        leftsplit = width // 3
        self.rightSplitter.SplitHorizontally(self.squareMap, self.tabs,
                                             rightsplit)
        self.leftSplitter.SplitVertically(self.listControl, self.rightSplitter,
                                          leftsplit)
        squaremap.EVT_SQUARE_HIGHLIGHTED(self.squareMap,
                                         self.OnSquareHighlightedMap)
        squaremap.EVT_SQUARE_SELECTED(self.listControl,
                                      self.OnSquareSelectedList)
        squaremap.EVT_SQUARE_SELECTED(self.squareMap, self.OnSquareSelectedMap)
        squaremap.EVT_SQUARE_ACTIVATED(self.squareMap, self.OnNodeActivated)
        for control in self.ProfileListControls:
            squaremap.EVT_SQUARE_ACTIVATED(control, self.OnNodeActivated)
            squaremap.EVT_SQUARE_HIGHLIGHTED(control,
                                             self.OnSquareHighlightedList)
        # TODO: create toolbar
        # TODO: create keyboard accelerators

    def CreateMenuBar(self):
        """Create our menu-bar for triggering operations"""
        menubar = wx.MenuBar()
        menu = wx.Menu()
        menu.Append(ID_OPEN, _('&Open'), _('Open a new profile file'))
        menu.AppendSeparator()
        menu.Append(ID_EXIT, _('&Close'), _('Close this RunSnakeRun window'))
        menubar.Append(menu, _('&File'))
        menu = wx.Menu()
        self.packageMenuItem = menu.AppendCheckItem(
            ID_PACKAGE_VIEW, _('&File View'),
            _('View time spent by package/module')
        )
        self.percentageMenuItem = menu.AppendCheckItem(
            ID_PERCENTAGE_VIEW, _('&Percentage View'),
            _('View time spent as percent of overall time')
        )
        self.rootViewItem = menu.Append(
            ID_ROOT_VIEW, _('&Root View (Home)'),
            _('View the root of the tree')
        )
        self.backViewItem = menu.Append(
            ID_BACK_VIEW, _('&Back'), _('Go back in your viewing history')
        )
        self.upViewItem = menu.Append(
            ID_UP_VIEW, _('&Up'),
            _('Go "up" to the parent of this node with the largest cummulative total')
        )

        # This stuff isn't really all that useful for profiling,
        # it's more about how to generate graphics to describe profiling...
#        self.deeperViewItem = menu.Append(
#            ID_DEEPER_VIEW, _('&Deeper'), _('View deeper squaremap views')
#        )
#        self.shallowerViewItem = menu.Append(
#            ID_SHALLOWER_VIEW, _('&Shallower'), _('View shallower squaremap views')
#        )
#        wx.ToolTip.Enable(True)
        menubar.Append(menu, _('&View'))
        self.SetMenuBar(menubar)

        wx.EVT_MENU(self, ID_EXIT, lambda evt: self.Close(True))
        wx.EVT_MENU(self, ID_OPEN, self.OnOpenFile)
        wx.EVT_MENU(self, ID_PACKAGE_VIEW, self.OnPackageView)
        wx.EVT_MENU(self, ID_PERCENTAGE_VIEW, self.OnPercentageView)
        wx.EVT_MENU(self, ID_UP_VIEW, self.OnUpView)
        wx.EVT_MENU(self, ID_DEEPER_VIEW, self.OnDeeperView)
        wx.EVT_MENU(self, ID_SHALLOWER_VIEW, self.OnShallowerView)
        wx.EVT_MENU(self, ID_ROOT_VIEW, self.OnRootView)
        wx.EVT_MENU(self, ID_BACK_VIEW, self.OnBackView)

    def CreateSourceWindow(self, tabs):
        """Create our source-view window for tabs"""
        if editor:
            self.sourceEditor = wx.py.editor.Editor(self.tabs)
            self.sourceCodeControl = wx.py.editor.EditWindow(
                self.sourceEditor, self.tabs, -1
            )
            self.sourceCodeControl.SetText(u"")
            self.sourceFileShown = None
            self.sourceCodeControl.setDisplayLineNumbers(True)

    def SetupToolBar(self):
        """Create the toolbar for common actions"""
        tb = self.CreateToolBar(self.TBFLAGS)
        tsize = (24, 24)
        tb.ToolBitmapSize = tsize
        open_bmp = wx.ArtProvider.GetBitmap(wx.ART_FILE_OPEN, wx.ART_TOOLBAR,
                                            tsize)
        tb.AddLabelTool(ID_OPEN, "Open", open_bmp, shortHelp="Open",
                        longHelp="Open a (c)Profile trace file")
        tb.AddSeparator()
#        self.Bind(wx.EVT_TOOL, self.OnOpenFile, id=ID_OPEN)
        self.rootViewTool = tb.AddLabelTool(
            ID_ROOT_VIEW, _("Root View"),
            wx.ArtProvider.GetBitmap(wx.ART_GO_HOME, wx.ART_TOOLBAR, tsize),
            shortHelp=_("Display the root of the current view tree (home view)")
        )
        self.rootViewTool = tb.AddLabelTool(
            ID_BACK_VIEW, _("Back"),
            wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_TOOLBAR, tsize),
            shortHelp=_("Back to the previously activated node in the call tree")
        )
        self.upViewTool = tb.AddLabelTool(
            ID_UP_VIEW, _("Up"),
            wx.ArtProvider.GetBitmap(wx.ART_GO_UP, wx.ART_TOOLBAR, tsize),
            shortHelp=_("Go one level up the call tree (highest-percentage parent)")
        )
        tb.AddSeparator()
        # TODO: figure out why the control is sizing the label incorrectly on Linux
        self.percentageViewTool = wx.CheckBox(tb, -1, _("Percent    "))
        self.percentageViewTool.SetToolTip(wx.ToolTip(
            _("Toggle display of percentages in list views")))
        tb.AddControl(self.percentageViewTool)
        wx.EVT_CHECKBOX(self.percentageViewTool,
                        self.percentageViewTool.GetId(), self.OnPercentageView)

        self.packageViewTool = wx.CheckBox(tb, -1, _("File View    "))
        self.packageViewTool.SetToolTip(wx.ToolTip(
            _("Switch between call-hierarchy and package/module/function hierarchy")))
        tb.AddControl(self.packageViewTool)
        wx.EVT_CHECKBOX(self.packageViewTool, self.packageViewTool.GetId(),
                        self.OnPackageView)
        tb.Realize()

    def OnOpenFile(self, event):
        """Request to open a new profile file"""
        dialog = wx.FileDialog(self, style=wx.OPEN|wx.FD_MULTIPLE)
        if dialog.ShowModal() == wx.ID_OK:
            paths = dialog.GetPaths()
            if self.loader:
                # we've already got a displayed data-set, open new window...
                frame = MainFrame()
                frame.Show(True)
                frame.load(*paths)
            else:
                self.load(*paths)

    def OnShallowerView(self, event):
        if not self.squareMap.max_depth:
            new_depth = self.squareMap.max_depth_seen or 0 - 5
        else:
            new_depth = self.squareMap.max_depth - 5
        self.squareMap.max_depth = max((1, new_depth))
        self.squareMap.Refresh()

    def OnDeeperView(self, event):
        if not self.squareMap.max_depth:
            new_depth = 5
        else:
            new_depth = self.squareMap.max_depth + 5
        self.squareMap.max_depth = max((self.squareMap.max_depth_seen or 0,
                                        new_depth))
        self.squareMap.Refresh()

    def OnPackageView(self, event):
        self.SetPackageView(not self.directoryView)

    def SetPackageView(self, directoryView):
        """Set whether to use directory/package based view"""
        self.directoryView = not self.directoryView
        self.packageMenuItem.Check(self.directoryView)
        self.packageViewTool.SetValue(self.directoryView)
        if self.loader:
            self.SetModel(self.loader)
        self.RecordHistory()

    def OnPercentageView(self, event):
        """Handle percentage-view event from menu/toolbar"""
        self.SetPercentageView(not self.percentageView)

    def SetPercentageView(self, percentageView):
        """Set whether to display percentage or absolute values"""
        self.percentageView = percentageView
        self.percentageMenuItem.Check(self.percentageView)
        self.percentageViewTool.SetValue(self.percentageView)
        total = self.loader.tree.cummulative
        for control in self.ProfileListControls:
            control.SetPercentage(self.percentageView, total)
        self.adapter.SetPercentage(self.percentageView, total)

    def OnUpView(self, event):
        """Request to move up the hierarchy to highest-weight parent"""
        node = self.activated_node
        if node:
            if self.directoryView:
                tree = pstatsloader.TREE_FILES
            else:
                tree = pstatsloader.TREE_CALLS
            parents = [
                parent for parent in
                self.adapter.parents(node)
                if getattr(parent, 'tree', pstatsloader.TREE_CALLS) == tree
            ]
            if parents:
                parents.sort(lambda a, b: cmp(self.adapter.value(node, a),
                                              self.adapter.value(node, b)))
                class event:
                    node = parents[-1]
                self.OnNodeActivated(event)
            else:
                self.SetStatusText(_('No parents for the currently selected node: %(node_name)s')
                                   % dict(node_name=self.adapter.label(node)))
        else:
            self.SetStatusText(_('No currently selected node'))

    def OnBackView(self, event):
        """Request to move backward in the history"""
        self.historyIndex -= 1
        try:
            self.RestoreHistory(self.history[self.historyIndex])
        except IndexError, err:
            self.SetStatusText(_('No further history available'))

    def OnRootView(self, event):
        """Reset view to the root of the tree"""
        self.adapter, tree, rows = self.RootNode()
        self.squareMap.SetModel(tree, self.adapter)
        self.RecordHistory()

    def OnNodeActivated(self, event):
        """Double-click or enter on a node in some control..."""
        self.activated_node = self.selected_node = event.node
        self.squareMap.SetModel(event.node, self.adapter)
        if editor:
            if self.SourceShowFile(event.node):
                if hasattr(event.node,'lineno'):
                    self.sourceCodeControl.GotoLine(event.node.lineno)
        self.RecordHistory()

    def SourceShowFile(self, node):
        """Show the given file in the source-code view (attempt it anyway)"""
        if not node.directory:
            # TODO: any cases other than built-ins?
            return None
        if node.filename == '~':
            # TODO: look up C/Cython/whatever source???
            return None
        path = os.path.join(node.directory, node.filename)
        if self.sourceFileShown != path:
            try:
                data = open(path).read()
            except Exception, err:
                # TODO: load from zips/eggs? What about .pyc issues?
                return None
            else:
                self.sourceCodeControl.SetText(data)
        return path

    def OnSquareHighlightedMap(self, event):
        self.SetStatusText(self.adapter.label(event.node))
        self.listControl.SetIndicated(event.node)
        text = self.squareMap.adapter.label(event.node)
        self.squareMap.SetToolTipString(text)
        self.SetStatusText(text)

    def OnSquareHighlightedList(self, event):
        self.SetStatusText(self.adapter.label(event.node))
        self.squareMap.SetHighlight(event.node, propagate=False)

    def OnSquareSelectedList(self, event):
        self.SetStatusText(self.adapter.label(event.node))
        self.squareMap.SetSelected(event.node)
        self.OnSquareSelected(event)
        self.RecordHistory()

    def OnSquareSelectedMap(self, event):
        self.listControl.SetSelected(event.node)
        self.OnSquareSelected(event)
        self.RecordHistory()

    def OnSquareSelected(self, event):
        """Update all views to show selection children/parents"""
        self.selected_node = event.node
        self.calleeListControl.integrateRecords(event.node.children)
        self.callerListControl.integrateRecords(event.node.parents)
        self.allCalleeListControl.integrateRecords(event.node.descendants())
        self.allCallerListControl.integrateRecords(event.node.ancestors())

    restoringHistory = False

    def RecordHistory(self):
        """Add the given node to the history-set"""
        if not self.restoringHistory:
            record = self.activated_node
            if self.historyIndex < -1:
                try:
                    del self.history[self.historyIndex+1:]
                except AttributeError, err:
                    pass
            if (not self.history) or record != self.history[-1]:
                self.history.append(record)
            del self.history[:-200]
            self.historyIndex = -1

    def RestoreHistory(self, record):
        self.restoringHistory = True
        try:
            activated = record
            class activated_event:
                node = activated

            if activated:
                self.OnNodeActivated(activated_event)
                self.squareMap.SetSelected(activated_event.node)
                self.listControl.SetSelected(activated_event.node)
        finally:
            self.restoringHistory = False

    def load(self, *filenames):
        """Load our hotshot dataset (iteratively)"""
        try:
            self.SetModel(pstatsloader.PStatsLoader(*filenames))
            self.SetTitle(_("Run Snake Run: %(filenames)s")
                          % {'filenames': ', '.join(filenames)[:120]})
        except (IOError, OSError, ValueError), err:
            self.SetStatusText(
                _('Failure during load of %(filenames)s: %(err)s'
            ) % dict(
                filenames=" ".join([repr(x) for x in filenames]),
                err=err
            ))

    def SetModel(self, loader):
        """Set our overall model (a loader object) and populate sub-controls"""
        self.loader = loader
        self.adapter, tree, rows = self.RootNode()
        self.listControl.integrateRecords(rows.values())
        self.activated_node = tree
        self.squareMap.SetModel(tree, self.adapter)
        self.RecordHistory()

    def RootNode(self):
        """Return our current root node and appropriate adapter for it"""
        if self.directoryView:
            adapter = DirectoryViewAdapter()
            tree = self.loader.location_tree
            rows = self.loader.location_rows
        else:
            adapter = PStatsAdapter()
            tree = self.loader.tree
            rows = self.loader.rows
        adapter.SetPercentage(self.percentageView, self.loader.tree.cummulative)
        return adapter, tree, rows


class RunSnakeRunApp(wx.App):
    """Basic application for holding the viewing Frame"""

    def OnInit(self, file=None):
        """Initialise the application"""
        wx.InitAllImageHandlers()
        frame = MainFrame()
        frame.Show(True)
        self.SetTopWindow(frame)
        if file is not None:
            wx.CallAfter(frame.load, file)
        elif sys.argv[1:]:
            wx.CallAfter(frame.load, *sys.argv[1:])
        return True


usage = """runsnake.py profilefile

profilefile -- a file generated by a HotShot profile run from Python
"""

def main():
    """Mainloop for the application"""
    app = RunSnakeRunApp(0)
    #app.OnInit(r'C:\b3\some.profile')
    app.MainLoop()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()

########NEW FILE########
__FILENAME__ = squaremap
#! /usr/bin/env python
import wx, sys, os, logging
import wx.lib.newevent
log = logging.getLogger( 'squaremap' )
#log.setLevel( logging.DEBUG )

SquareHighlightEvent, EVT_SQUARE_HIGHLIGHTED = wx.lib.newevent.NewEvent()
SquareSelectionEvent, EVT_SQUARE_SELECTED = wx.lib.newevent.NewEvent()
SquareActivationEvent, EVT_SQUARE_ACTIVATED = wx.lib.newevent.NewEvent()


class HotMapNavigator(object):
    ''' Utility class for navigating the hot map and finding nodes. '''

    @classmethod
    def findNode(class_, hot_map, targetNode, parentNode=None):
        ''' Find the target node in the hot_map. '''
        for index, (rect, node, children) in enumerate(hot_map):
            if node == targetNode:
                return parentNode, hot_map, index
            result = class_.findNode(children, targetNode, node)
            if result:
                return result
        return None

    @classmethod
    def findNodeAtPosition(class_, hot_map, position, parent=None):
        ''' Retrieve the node at the given position. '''
        for rect, node, children in hot_map:
            if rect.Contains(position):
                return class_.findNodeAtPosition(children, position, node)
        return parent

    @staticmethod
    def firstChild(hot_map, index):
        ''' Return the first child of the node indicated by index. '''
        children = hot_map[index][2]
        if children:
            return children[0][1]
        else:
            return hot_map[index][1] # No children, return the node itself
        
    @staticmethod
    def nextChild(hotmap, index):
        ''' Return the next sibling of the node indicated by index. '''
        nextChildIndex = min(index + 1, len(hotmap) - 1)
        return hotmap[nextChildIndex][1]
    
    @staticmethod
    def previousChild(hotmap, index):
        ''' Return the previous sibling of the node indicated by index. '''
        previousChildIndex = max(0, index - 1)
        return hotmap[previousChildIndex][1]

    @staticmethod
    def firstNode(hot_map):
        ''' Return the very first node in the hot_map. '''
        return hot_map[0][1]
    
    @classmethod
    def lastNode(class_, hot_map):
        ''' Return the very last node (recursively) in the hot map. '''
        children = hot_map[-1][2]
        if children:
            return class_.lastNode(children)
        else:
            return hot_map[-1][1] # Return the last node
    
    
class SquareMap( wx.Panel ):
    """Construct a nested-box trees structure view"""

    BackgroundColor = wx.Color( 128,128,128 )
    max_depth = None
    max_depth_seen = None
    
    def __init__( 
        self,  parent=None, id=-1, pos=wx.DefaultPosition, 
        size=wx.DefaultSize, 
        style=wx.TAB_TRAVERSAL|wx.NO_BORDER|wx.FULL_REPAINT_ON_RESIZE, 
        name='SquareMap', model = None,
        adapter = None,
        labels = True, # set to True to draw textual labels within the boxes
        highlight = True, # set to False to turn of highlighting
        padding = 2, # amount to reduce the children's box from the parent's box
    ):
        super( SquareMap, self ).__init__(
            parent, id, pos, size, style, name
        )
        self.model = model
        self.padding = padding
        self.labels = labels
        self.highlight = highlight
        self.selectedNode = None
        self.highlightedNode = None
        self.Bind( wx.EVT_PAINT, self.OnPaint)
        self.Bind( wx.EVT_SIZE, self.OnSize )
        if highlight:
            self.Bind( wx.EVT_MOTION, self.OnMouse )
        self.Bind( wx.EVT_LEFT_UP, self.OnClickRelease )
        self.Bind( wx.EVT_LEFT_DCLICK, self.OnDoubleClick )
        self.Bind( wx.EVT_KEY_UP, self.OnKeyUp )
        self.hot_map = []
        self.adapter = adapter or DefaultAdapter()
        self.DEFAULT_PEN = wx.Pen( wx.BLACK, 1, wx.SOLID )
        self.SELECTED_PEN = wx.Pen( wx.WHITE, 2, wx.SOLID )
        self.OnSize(None)
        
    def OnMouse( self, event ):
        """Handle mouse-move event by selecting a given element"""
        node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition())
        self.SetHighlight( node, event.GetPosition() )

    def OnClickRelease( self, event ):
        """Release over a given square in the map"""
        node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition())
        self.SetSelected( node, event.GetPosition() )
        
    def OnDoubleClick(self, event):
        """Double click on a given square in the map"""
        node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition())
        if node:
            wx.PostEvent( self, SquareActivationEvent( node=node, point=event.GetPosition(), map=self ) )
    
    def OnKeyUp(self, event):
        event.Skip()
        if not self.selectedNode or not self.hot_map:
            return
        
        if event.KeyCode == wx.WXK_HOME:
            self.SetSelected(HotMapNavigator.firstNode(self.hot_map))
            return
        elif event.KeyCode == wx.WXK_END:
            self.SetSelected(HotMapNavigator.lastNode(self.hot_map))
            return
        
        parent, children, index = HotMapNavigator.findNode(self.hot_map, self.selectedNode)
        if event.KeyCode == wx.WXK_DOWN:
            self.SetSelected(HotMapNavigator.nextChild(children, index))
        elif event.KeyCode == wx.WXK_UP:
            self.SetSelected(HotMapNavigator.previousChild(children, index))
        elif event.KeyCode == wx.WXK_RIGHT:
            self.SetSelected(HotMapNavigator.firstChild(children, index))
        elif event.KeyCode == wx.WXK_LEFT and parent:
            self.SetSelected(parent)
        elif event.KeyCode == wx.WXK_RETURN:
            wx.PostEvent(self, SquareActivationEvent(node=self.selectedNode,
                                                     map=self))
            
    def GetSelected(self):
        return self.selectedNode
            
    def SetSelected( self, node, point=None, propagate=True ):
        """Set the given node selected in the square-map"""
        if node == self.selectedNode:
            return
        self.selectedNode = node 
        self.Refresh()
        if node:
            wx.PostEvent( self, SquareSelectionEvent( node=node, point=point, map=self ) )

    def SetHighlight( self, node, point=None, propagate=True ):
        """Set the currently-highlighted node"""
        if node == self.highlightedNode:
            return
        self.highlightedNode = node 
        self.Refresh()
        if node and propagate:
            wx.PostEvent( self, SquareHighlightEvent( node=node, point=point, map=self ) )

    def SetModel( self, model, adapter=None ):
        """Set our model object (root of the tree)"""
        self.model = model
        if adapter is not None:
            self.adapter = adapter
        self.Refresh()
        
    def Refresh(self):
        self.UpdateDrawing()
    
    def OnPaint(self, event):
        dc = wx.BufferedPaintDC(self, self._buffer)

    def OnSize(self, event):
        # The buffer is initialized in here, so that the buffer is always
        # the same size as the Window.
        width, height = self.GetClientSizeTuple()
        # Make new off-screen bitmap: this bitmap will always have the
        # current drawing in it, so it can be used to save the image to
        # a file, or whatever.
        if width and height:
            # Macs can generate events with 0-size values
            self._buffer = wx.EmptyBitmap(width, height)
            self.UpdateDrawing()

    def UpdateDrawing(self):
        dc = wx.BufferedDC(wx.ClientDC(self), self._buffer)
        self.Draw(dc)
        
    def Draw(self, dc):
        ''' Draw the tree map on the device context. '''
        self.hot_map = []
        dc.BeginDrawing()
        brush = wx.Brush( self.BackgroundColor  )
        dc.SetBackground( brush )
        dc.Clear()
        if self.model:
            self.max_depth_seen = 0
            dc.SetFont(self.FontForLabels(dc))
            w, h = dc.GetSize()
            self.DrawBox( dc, self.model, 0,0,w,h, hot_map = self.hot_map )
        dc.EndDrawing()
        
    def FontForLabels(self, dc):
        ''' Return the default GUI font, scaled for printing if necessary. '''
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        scale = dc.GetPPI()[0] / wx.ScreenDC().GetPPI()[0]
        font.SetPointSize(scale*font.GetPointSize())
        return font
    
    def BrushForNode( self, node, depth=0 ):
        """Create brush to use to display the given node"""
        if node == self.selectedNode:
            color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        elif node == self.highlightedNode:
            color = wx.Color( red=0, green=255, blue=0 )
        else:
            color = self.adapter.background_color(node, depth)
            if not color:
                red = (depth * 10)%255
                green = 255-((depth * 5)%255)
                blue = (depth * 25)%255
                color = wx.Color( red, green, blue )
        return wx.Brush( color  )
    
    def PenForNode( self, node, depth=0 ):
        """Determine the pen to use to display the given node"""
        if node == self.selectedNode:
            return self.SELECTED_PEN
        return self.DEFAULT_PEN

    def TextForegroundForNode(self, node, depth=0):
        """Determine the text foreground color to use to display the label of
           the given node"""
        if node == self.selectedNode:
            fg_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
        else:
            fg_color = self.adapter.foreground_color(node, depth)
            if not fg_color:
                fg_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        return fg_color
    
    def DrawBox( self, dc, node, x,y,w,h, hot_map, depth=0 ):
        """Draw a model-node's box and all children nodes"""
        log.debug( 'Draw: %s to (%s,%s,%s,%s) depth %s',
            node, x,y,w,h, depth,
        )
        if self.max_depth and depth > self.max_depth:
            return
        self.max_depth_seen = max( (self.max_depth_seen,depth))
        dc.SetBrush( self.BrushForNode( node, depth ) )
        dc.SetPen( self.PenForNode( node, depth ) )
        if sys.platform == 'darwin':
            # Macs don't like drawing small rounded rects...
            if w < self.padding*2 or h < self.padding*2:
                dc.DrawRectangle( x,y,w,h)
            else:
                dc.DrawRoundedRectangle( x,y,w,h, self.padding )
        else:
            dc.DrawRoundedRectangle( x,y,w,h, self.padding*3 )
#        self.DrawIconAndLabel(dc, node, x, y, w, h, depth)
        children_hot_map = []
        hot_map.append( (wx.Rect( int(x),int(y),int(w),int(h)), node, children_hot_map ) )
        x += self.padding
        y += self.padding
        w -= self.padding*2
        h -= self.padding*2
        
        empty = self.adapter.empty( node )
        icon_drawn = False
        if self.max_depth and depth == self.max_depth:
            self.DrawIconAndLabel(dc, node, x, y, w, h, depth)
            icon_drawn = True
        elif empty:
            # is a fraction of the space which is empty...
            log.debug( '  empty space fraction: %s', empty )
            new_h = h * (1.0-empty)
            self.DrawIconAndLabel(dc, node, x, y, w, h-new_h, depth)
            icon_drawn = True
            y += (h-new_h)
            h = new_h
            
        if w >self.padding*2 and h> self.padding*2:
            children = self.adapter.children( node )
            if children:
                log.debug( '  children: %s', children )
                self.LayoutChildren( dc, children, node, x,y,w,h, children_hot_map, depth+1 )
            else:
                log.debug( '  no children' )
                if not icon_drawn:
                    self.DrawIconAndLabel(dc, node, x, y, w, h, depth)
        else:
            log.debug( '  not enough space: children skipped' )
                
    def DrawIconAndLabel(self, dc, node, x, y, w, h, depth):
        ''' Draw the icon, if any, and the label, if any, of the node. '''
        dc.SetClippingRegion(x+1, y+1, w-2, h-2) # Don't draw outside the box
        icon = self.adapter.icon(node, node==self.selectedNode)
        if icon and h >= icon.GetHeight() and w >= icon.GetWidth():
            iconWidth = icon.GetWidth() + 2
            dc.DrawIcon(icon, x+2, y+2) 
        else:
            iconWidth = 0
        if self.labels and h >= dc.GetTextExtent('ABC')[1]:
            dc.SetTextForeground(self.TextForegroundForNode(node, depth))
            dc.DrawText(self.adapter.label(node), x + iconWidth + 2, y+2)
        dc.DestroyClippingRegion()
        
    def LayoutChildren( self, dc, children, parent, x,y,w,h, hot_map, depth=0 ):
        """Layout the set of children in the given rectangle"""
        nodes = [ (self.adapter.value(node,parent),node) for node in children ]
        nodes.sort()
        total = self.adapter.children_sum( children,parent )
        if total:
            (firstSize,firstNode) = nodes[-1]
            rest = [node for (size,node) in nodes[:-1]]
            fraction = firstSize/float(total)
            if w >= h:
                new_w = int(w*fraction)
                if new_w:
                    self.DrawBox( dc, firstNode, x,y, new_w, h, hot_map, depth+1 )
                else:
                    return # no other node will show up as non-0 either
                w = w-new_w
                x += new_w 
            else:
                new_h = int(h*fraction)
                if new_h:
                    self.DrawBox( dc, firstNode, x,y, w, new_h, hot_map, depth + 1 )
                else:
                    return # no other node will show up as non-0 either
                h = h-new_h
                y += new_h 
            if rest and (h > self.padding*2) and (w > self.padding*2):
                self.LayoutChildren( dc, rest, parent, x,y,w,h, hot_map, depth )


class DefaultAdapter( object ):
    """Default adapter class for adapting node-trees to SquareMap API"""
    def children( self, node ):
        """Retrieve the set of nodes which are children of this node"""
        return node.children
    def value( self, node, parent=None ):
        """Return value used to compare size of this node"""
        return node.size
    def label( self, node ):
        """Return textual description of this node"""
        return node.path
    def overall( self, node ):
        """Calculate overall size of the node including children and empty space"""
        return sum( [self.value(value,node) for value in self.children(node)] )
    def children_sum( self, children,node ):
        """Calculate children's total sum"""
        return sum( [self.value(value,node) for value in children] )
    def empty( self, node ):
        """Calculate empty space as a fraction of total space"""
        overall = self.overall( node )
        if overall:
            return (overall - self.children_sum( self.children(node), node))/float(overall)
        return 0
    def background_color(self, node, depth):
        ''' The color to use as background color of the node. '''
        return None
    def foreground_color(self, node, depth):
        ''' The color to use for the label. '''
        return None
    def icon(self, node, isSelected):
        ''' The icon to display in the node. '''
        return None
    def parents( self, node ):
        """Retrieve/calculate the set of parents for the given node"""
        return []


class TestApp(wx.App):
    """Basic application for holding the viewing Frame"""
    def OnInit(self):
        """Initialise the application"""
        wx.InitAllImageHandlers()
        self.frame = frame = wx.Frame( None,
        )
        frame.CreateStatusBar()
        
        model = model = self.get_model( sys.argv[1]) 
        self.sq = SquareMap( frame, model=model)
        EVT_SQUARE_HIGHLIGHTED( self.sq, self.OnSquareSelected )
        frame.Show(True)
        self.SetTopWindow(frame)
        return True
    def get_model( self, path ):
        nodes = []
        for f in os.listdir( path ):
            full = os.path.join( path,f )
            if not os.path.islink( full ):
                if os.path.isfile( full ):
                    nodes.append( Node( full, os.stat( full ).st_size, () ) )
                elif os.path.isdir( full ):
                    nodes.append( self.get_model( full ))
        return Node( path, sum([x.size for x in nodes]), nodes )
    def OnSquareSelected( self, event ):
        text = self.sq.adapter.label( event.node )
        self.frame.SetToolTipString( text )

class Node( object ):
    """Really dumb file-system node object"""
    def __init__( self, path, size, children ):
        self.path = path
        self.size = size
        self.children = children 
    def __repr__( self ):
        return '%s( %r, %r, %r )'%( self.__class__.__name__, self.path, self.size, self.children )
        

usage = 'squaremap.py somedirectory'
        
def main():
    """Mainloop for the application"""
    if not sys.argv[1:]:
        print usage
    else:
        app = TestApp(0)
        app.MainLoop()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = SourceLog
#!/usr/bin/python
# -*- coding: utf-8 -*-

#------------------------------------------------------------------------------
# SourceLog - Python class for parsing logs of Source Dedicated Servers
# Copyright (c) 2010 Andreas Klauer <Andreas.Klauer@metamorpher.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#------------------------------------------------------------------------------

# TODO:  Support games other than Team Fortress 2

"""http://developer.valvesoftware.com/wiki/HL_Log_Standard"""

import re
import socket
import asyncore

PACKETSIZE=1400

# --- Regular Expressions: ---

TOKEN = {
    'address': '(?P<ip>[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})(|:(?P<port>[0-9]+))',
    'attacker': '(?P<attacker_name>.*?)<(?P<attacker_uid>[0-9]*)><(?P<attacker_steamid>(Console|BOT|STEAM_[01]:[01]:[0-9]{1,12}))><(?P<attacker_team>[^<>"]*)>',
    'class': '(?P<class>[^"]+)',
    'command': '(?P<command>.*)',
    'key': '(?P<key>[^"]+)',
    'map': '(?P<map>[^"]+)',
    'message': '(?P<message>.*)',
    'name': '(?P<name>.*)',
    'numplayers': '(?P<numplayers>[0-9]+)',
    'player': '(?P<player_name>.*?)<(?P<player_uid>[0-9]*)><(?P<player_steamid>(Console|BOT|STEAM_[01]:[01]:[0-9]{1,12}))><(?P<player_team>[^<>"]*)>',
    'position': '^(?P<x>-?[0-9]+) (?P<y>-?[0-9]+) (?P<z>-?[0-9]+)',
    'property': ' \((?P<property_key>[^() ]+) "(?P<property_value>[^"]*)"\)',
    'propertybug': '(?P<rest>.*" disconnected) \((?P<property_key>reason) "(?P<proprety_value>[^"]*)',
    'reason': '(?P<reason>.*)',
    'rest': '(?P<rest>.*)',
    'score': '(?P<score>-?[0-9]+)',
    'team': '(?P<team>[^"]+)',
    'timestamp': '(?P<month>[0-9]{2})/(?P<day>[0-9]{2})/(?P<year>[0-9]{4}) - (?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}):(?P<second>[0-9]{2}): ',
    'trigger': '(?P<trigger>[^"]+)',
    'type': '(?P<type>RL|L) ',
    'value': '(?P<value>.*)',
    'victim': '(?P<victim_name>.*?)<(?P<victim_uid>[0-9]*)><(?P<victim_steamid>(Console|BOT|STEAM_[01]:[01]:[0-9]{1,12}))><(?P<victim_team>[^<>"]*)>',
    'weapon': '(?P<weapon>[^"]+)',
}

REHEADER = re.compile('^'+TOKEN['type']+TOKEN['timestamp']+TOKEN['rest']+'$', re.U)
REPROPERTY = re.compile('^'+TOKEN['rest']+TOKEN['property']+'$', re.U)
REPROPERTYBUG = re.compile('^'+TOKEN['propertybug']+'$', re.U)
RERULES = re.compile('^"'+TOKEN['key']+'" = "'+TOKEN['value']+'"$', re.U)

RELOG = [
    ['change_name', re.compile('^"'+TOKEN['player']+'" changed name to "'+TOKEN['name']+'"$', re.U)],
    ['class', re.compile('^"'+TOKEN['player']+'" changed role to "'+TOKEN['class']+'"$', re.U)],
    ['connect', re.compile('^"'+TOKEN['player']+'" connected, address "(none|'+TOKEN['address']+')"$', re.U)],
    ['disconnect', re.compile('^"'+TOKEN['player']+'" disconnected$', re.U)],
    ['enter', re.compile('^"'+TOKEN['player']+'" entered the game$', re.U)],
    ['kill', re.compile('^"'+TOKEN['attacker']+'" killed "'+TOKEN['victim']+'" with "'+TOKEN['weapon']+'"$', re.U)],
    ['log_start', re.compile('^Log file started$', re.U)],
    ['log_stop', re.compile('^Log file closed$', re.U)],
    ['map_load', re.compile('^Loading map "'+TOKEN['map']+'"$', re.U)],
    ['map_start', re.compile('^Started map "'+TOKEN['map']+'"$', re.U)],
    ['position_report', re.compile('^"'+TOKEN['player']+'" position_report$', re.U)],
    ['rcon', re.compile('^rcon from "'+TOKEN['address']+'": command "'+TOKEN['command']+'"$', re.U)],
    ['rcon_badpw', re.compile('^rcon from "'+TOKEN['address']+'": Bad Password$', re.U)],
    ['say', re.compile('^"'+TOKEN['player']+'" say "'+TOKEN['message']+'"$', re.U)],
    ['say_team', re.compile('^"'+TOKEN['player']+'" say_team "'+TOKEN['message']+'"$', re.U)],
    ['score', re.compile('^Team "'+TOKEN['team']+'" current score "'+TOKEN['score']+'" with "'+TOKEN['numplayers']+'" players$', re.U)],
    ['score_final', re.compile('^Team "'+TOKEN['team']+'" final score "'+TOKEN['score']+'" with "'+TOKEN['numplayers']+'" players$', re.U)],
    ['server_cvar', re.compile('^server_cvar: "'+TOKEN['key']+'" "'+TOKEN['value']+'"$', re.U)],
    ['server_message', re.compile('^server_message: "'+TOKEN['message']+'"$', re.U)],
    ['suicide', re.compile('^"'+TOKEN['player']+'" committed suicide with "'+TOKEN['weapon']+'"$', re.U)],
    ['team', re.compile('^"'+TOKEN['player']+'" joined team "'+TOKEN['team']+'"$', re.U)],
    ['trigger', re.compile('^"'+TOKEN['player']+'" triggered "'+TOKEN['trigger']+'"$', re.U)],
    ['trigger_attack', re.compile('^"'+TOKEN['attacker']+'" triggered "'+TOKEN['trigger']+'" against "'+TOKEN['victim']+'"$', re.U)],
    ['trigger_attack_weapon', re.compile('^"'+TOKEN['attacker']+'" triggered "'+TOKEN['trigger']+'" against "'+TOKEN['victim']+'" with "'+TOKEN['weapon']+'"$', re.U)],
    ['trigger_team', re.compile('^Team "'+TOKEN['team']+'" triggered "'+TOKEN['trigger']+'"$', re.U)],
    ['trigger_world', re.compile('^World triggered "'+TOKEN['trigger']+'"$', re.U)],
    ['trigger_world_reason', re.compile('^World triggered "'+TOKEN['trigger']+'" reason "'+TOKEN['reason']+'"$', re.U)],
    ['update', re.compile('^Your server will be restarted on map change\\.$', re.U)],
    ['valid', re.compile('^"'+TOKEN['player']+'" STEAM USERID validated$', re.U)],
]

REVALUE = [
    ['player', re.compile('^'+TOKEN['player']+'$', re.U)],
    ['position', re.compile('^'+TOKEN['position']+'$', re.U)],
]

class SourceLogParser(object):
    def __init__(self):
        self.rules = False

    def parse_value(self, key, value):
        for k, v in REVALUE:
            match = v.match(value)

            if match:
                r = match.groupdict()
                r['type'] = k
                return r

        return value

    def action(self, remote, timestamp, key, value, properties):
        pass

    def parse(self, line):
        line = line.strip('\x00\xff\r\n\t ')

        # parse header (type and date)
        match = REHEADER.match(line)

        if not match:
            # invalid log entry
            return

        line = match.group('rest')

        remote = False
        if match.group('type') == 'RL':
            remote = True

        timestamp = map(int, match.group('year', 'month', 'day', 'hour', 'minute', 'second'))

        # parse properties (key "value"), optional
        properties = {}

        while 1:
            match = REPROPERTY.match(line)

            if not match:
                break

            line = match.group('rest')
            key = match.group('property_key')
            value = match.group('property_value')
            value = self.parse_value(key, value)
            properties[key] = value

        # TF2 Bug - should be a property, but ") is missing
        match = REPROPERTYBUG.match(line)

        if match:
            line = match.group('rest')
            key = match.group('property_key')
            value = match.group('property_value')
            value = self.parse_value(key, value)
            properties[key] = value

        # parse the log entry
        for k, v in RELOG:
            match = v.match(line)

            if match:
                self.action(remote, timestamp, k, match.groupdict(), properties)
                return

        # special case: cvarlist / gamerules
        if line == 'server cvars start':
            self.rules = {}
            return

        if self.rules is not False:
            if line == 'server cvars end':
                rules = self.rules
                self.rules = False
                self.action(remote, timestamp, 'rules', rules, properties)
                return

            match = RERULES.match(line)

            if match:
                key = match.group('key')
                value = match.group('value')
                self.rules[key] = value
                return

        # not sure what else to do here, could be plugin output
        self.action(remote, timestamp, 'unknown', line, properties)

    def parse_file(self, filename):
        f = open(filename, 'r')

        for line in f:
            self.parse(line)

class SourceLogListenerError(Exception):
    pass

class SourceLogListener(asyncore.dispatcher):
    def __init__(self, local, remote, parser):
        asyncore.dispatcher.__init__(self)
        self.parser = parser
        self.create_socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.bind(local)
        self.connect(remote)

    def handle_connect(self):
        pass

    def handle_close(self):
        self.close()

    def handle_read(self):
        data = self.recv(PACKETSIZE)

        if data.startswith('\xff\xff\xff\xff') and data.endswith('\n\x00'):
            self.parser.parse(data)

        else:
            raise SourceLogListenerError("Received invalid packet.")

    def writable(self):
        return False

    def handle_write(self):
        pass

########NEW FILE########
__FILENAME__ = SourceQuery
#!/usr/bin/python
# -*- coding: utf-8 -*-

#------------------------------------------------------------------------------
# SourceQuery - Python class for querying info from Source Dedicated Servers
# Copyright (c) 2010 Andreas Klauer <Andreas.Klauer@metamorpher.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#------------------------------------------------------------------------------

"""http://developer.valvesoftware.com/wiki/Server_Queries"""

# TODO:  code cleanup

# TODO:  according to spec, packets may be bzip2 compressed.
# TODO:: not implemented yet because I couldn't find a server that does this.

import socket, struct, sys, time
import StringIO

PACKETSIZE=1400

WHOLE=-1
SPLIT=-2

# REMOVED.  DEPRECATED QUERY!

# A2A_PING
# A2A_PING = ord('i')
# A2A_PING_REPLY = ord('j')
# A2A_PING_REPLY_STRING = '00000000000000'

# A2S_INFO
A2S_INFO = ord('T')
A2S_INFO_STRING = 'Source Engine Query'
A2S_INFO_REPLY = ord('I')

# A2S_PLAYER
A2S_PLAYER = ord('U')
A2S_PLAYER_REPLY = ord('D')

# A2S_RULES
A2S_RULES = ord('V')
A2S_RULES_REPLY = ord('E')

# S2C_CHALLENGE
CHALLENGE = -1
S2C_CHALLENGE = ord('A')

class SourceQueryPacket(StringIO.StringIO):
    # putting and getting values
    def putByte(self, val):
        self.write(struct.pack('<B', val))

    def getByte(self):
        return struct.unpack('<B', self.read(1))[0]

    def putShort(self, val):
        self.write(struct.pack('<h', val))

    def getShort(self):
        return struct.unpack('<h', self.read(2))[0]

    def putLong(self, val):
        self.write(struct.pack('<l', val))

    def getLong(self):
        return struct.unpack('<l', self.read(4))[0]

    def getLongLong(self):
        return struct.unpack('<Q', self.read(8))[0]

    def putFloat(self, val):
        self.write(struct.pack('<f', val))

    def getFloat(self):
        return struct.unpack('<f', self.read(4))[0]

    def putString(self, val):
        self.write(val + '\x00')

    def getString(self):
        val = self.getvalue()
        start = self.tell()
        end = val.index('\0', start)
        val = val[start:end]
        self.seek(end+1)
        return val

class SourceQueryError(Exception):
    pass

class SourceQuery(object):
    """Example usage:

       import SourceQuery
       server = SourceQuery.SourceQuery('1.2.3.4', 27015)
       print server.ping()
       print server.info()
       print server.player()
       print server.rules()
    """

    def __init__(self, host, port=27015, timeout=1.0):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.udp = False

    def disconnect(self):
        if self.udp:
            self.udp.close()
            self.udp = False

    def connect(self, challenge=False):
        self.disconnect()
        self.udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp.settimeout(self.timeout)
        self.udp.connect((self.host, self.port))

        if challenge:
            return self.challenge()

    def receive(self):
        packet = SourceQueryPacket(self.udp.recv(PACKETSIZE))
        typ = packet.getLong()

        if typ == WHOLE:
            return packet

        elif typ == SPLIT:
            # handle split packets
            reqid = packet.getLong()
            total = packet.getByte()
            num = packet.getByte()
            splitsize = packet.getShort()
            result = [0 for x in xrange(total)]

            result[num] = packet.read()

            # fetch all remaining splits
            while 0 in result:
                packet = SourceQueryPacket(self.udp.recv(PACKETSIZE))

                if packet.getLong() == SPLIT and packet.getLong() == reqid:
                    total = packet.getByte()
                    num = packet.getByte()
                    splitsize = packet.getShort()
                    result[num] = packet.read()

                else:
                    raise SourceQueryError('Invalid split packet')

            packet = SourceQueryPacket("".join(result))

            if packet.getLong() == WHOLE:
                return packet

            else:
                raise SourceQueryError('Invalid split packet')

        else:
            raise SourceQueryError("Received invalid packet type %d" % (typ,))

    def challenge(self):
        # use A2S_PLAYER to obtain a challenge
        packet = SourceQueryPacket()
        packet.putLong(WHOLE)
        packet.putByte(A2S_PLAYER)
        packet.putLong(CHALLENGE)

        self.udp.send(packet.getvalue())
        packet = self.receive()

        # this is our challenge packet
        if packet.getByte() == S2C_CHALLENGE:
            challenge = packet.getLong()
            return challenge

    def ping(self):
        """Deprecated. Use info()['ping'] instead."""
        return self.info()['ping']

    def info(self):
        """Return a dict with server info and ping."""
        self.connect()

        packet = SourceQueryPacket()
        packet.putLong(WHOLE)
        packet.putByte(A2S_INFO)
        packet.putString(A2S_INFO_STRING)

        before = time.time()

        self.udp.send(packet.getvalue())
        packet = self.receive()

        after = time.time()

        if packet.getByte() == A2S_INFO_REPLY:
            result = {}

            result['ping'] = after - before

            result['network_version'] = packet.getByte()
            result['hostname'] = packet.getString()
            result['map'] = packet.getString()
            result['gamedir'] = packet.getString()
            result['gamedesc'] = packet.getString()
            result['appid'] = packet.getShort()
            result['numplayers'] = packet.getByte()
            result['maxplayers'] = packet.getByte()
            result['numbots'] = packet.getByte()
            result['dedicated'] = chr(packet.getByte())
            result['os'] = chr(packet.getByte())
            result['passworded'] = packet.getByte()
            result['secure'] = packet.getByte()
            result['version'] = packet.getString()

            # edf may or may not be present
            # contents undefined (see wiki page)
            # this protocol is horrible
            try:
                edf = packet.getByte()
                result['edf'] = edf

                if edf & 0x80:
                    result['port'] = packet.getShort()
                if edf & 0x10:
                    result['steamid'] = packet.getLongLong()
                if edf & 0x40:
                    result['specport'] = packet.getShort()
                    result['specname'] = packet.getString()
                if edf & 0x20:
                    result['tag'] = packet.getString()
            except:
                # let's just ignore all errors...
                pass

            return result

    def player(self):
        challenge = self.connect(True)

        # now obtain the actual player info
        packet = SourceQueryPacket()
        packet.putLong(WHOLE)
        packet.putByte(A2S_PLAYER)
        packet.putLong(challenge)

        self.udp.send(packet.getvalue())
        packet = self.receive()

        # this is our player info
        if packet.getByte() == A2S_PLAYER_REPLY:
            numplayers = packet.getByte()

            result = []

            # TF2 32player servers may send an incomplete reply
            try:
                for x in xrange(numplayers):
                    player = {}
                    player['index'] = packet.getByte()
                    player['name'] = packet.getString()
                    player['kills'] = packet.getLong()
                    player['time'] = packet.getFloat()
                    result.append(player)

            except:
                pass

            return result

    def rules(self):
        challenge = self.connect(True)

        # now obtain the actual rules
        packet = SourceQueryPacket()
        packet.putLong(WHOLE)
        packet.putByte(A2S_RULES)
        packet.putLong(challenge)

        self.udp.send(packet.getvalue())
        packet = self.receive()

        # this is our rules
        if packet.getByte() == A2S_RULES_REPLY:
            rules = {}
            numrules = packet.getShort()

            # TF2 sends incomplete packets, so we have to ignore numrules
            while 1:
                try:
                    key = packet.getString()
                    rules[key] = packet.getString()
                except:
                    break

            return rules

########NEW FILE########
__FILENAME__ = SourceRcon
#!/usr/bin/python
# -*- coding: utf-8 -*-

#------------------------------------------------------------------------------
# SourceRcon - Python class for executing commands on Source Dedicated Servers
# Copyright (c) 2010 Andreas Klauer <Andreas.Klauer@metamorpher.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#------------------------------------------------------------------------------

"""http://developer.valvesoftware.com/wiki/Source_RCON_Protocol"""

import select, socket, struct

SERVERDATA_AUTH = 3
SERVERDATA_AUTH_RESPONSE = 2

SERVERDATA_EXECCOMMAND = 2
SERVERDATA_RESPONSE_VALUE = 0

MAX_COMMAND_LENGTH=510 # found by trial & error

MIN_MESSAGE_LENGTH=4+4+1+1 # command (4), id (4), string1 (1), string2 (1)
MAX_MESSAGE_LENGTH=4+4+4096+1 # command (4), id (4), string (4096), string2 (1)

# there is no indication if a packet was split, and they are split by lines
# instead of bytes, so even the size of split packets is somewhat random.
# Allowing for a line length of up to 400 characters, risk waiting for an
# extra packet that may never come if the previous packet was this large.
PROBABLY_SPLIT_IF_LARGER_THAN = MAX_MESSAGE_LENGTH - 400

class SourceRconError(Exception):
    pass

class SourceRcon(object):
    """Example usage:

       import SourceRcon
       server = SourceRcon.SourceRcon('1.2.3.4', 27015, 'secret')
       print server.rcon('cvarlist')
    """
    def __init__(self, host, port=27015, password='', timeout=1.0):
        self.host = host
        self.port = port
        self.password = password
        self.timeout = timeout
        self.tcp = False
        self.reqid = 0

    def disconnect(self):
        """Disconnect from the server."""
        if self.tcp:
            self.tcp.close()

    def connect(self):
        """Connect to the server. Should only be used internally."""
        self.tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp.settimeout(self.timeout)
        self.tcp.connect((self.host, self.port))

    def send(self, cmd, message):
        """Send command and message to the server. Should only be used internally."""
        if len(message) > MAX_COMMAND_LENGTH:
            raise SourceRconError('RCON message too large to send')

        self.reqid += 1
        data = struct.pack('<l', self.reqid) + struct.pack('<l', cmd) + message + '\x00\x00'
        self.tcp.send(struct.pack('<l', len(data)) + data)

    def receive(self):
        """Receive a reply from the server. Should only be used internally."""
        packetsize = False
        requestid = False
        response = False
        message = ''
        message2 = ''

        # response may be split into multiple packets, we don't know how many
        # so we loop until we decide to finish
        while 1:
            # read the size of this packet
            buf = ''

            while len(buf) < 4:
                try:
                    recv = self.tcp.recv(4 - len(buf))
                    if not len(recv):
                        raise SourceRconError('RCON connection unexpectedly closed by remote host')
                    buf += recv
                except SourceRconError:
                    raise
                except:
                    break

            if len(buf) != 4:
                # we waited for a packet but there isn't anything
                break

            packetsize = struct.unpack('<l', buf)[0]

            if packetsize < MIN_MESSAGE_LENGTH or packetsize > MAX_MESSAGE_LENGTH:
                raise SourceRconError('RCON packet claims to have illegal size: %d bytes' % (packetsize,))

            # read the whole packet
            buf = ''

            while len(buf) < packetsize:
                try:
                    recv = self.tcp.recv(packetsize - len(buf))
                    if not len(recv):
                        raise SourceRconError('RCON connection unexpectedly closed by remote host')
                    buf += recv
                except SourceRconError:
                    raise
                except:
                    break

            if len(buf) != packetsize:
                raise SourceRconError('Received RCON packet with bad length (%d of %d bytes)' % (len(buf),packetsize,))

            # parse the packet
            requestid = struct.unpack('<l', buf[:4])[0]

            if requestid == -1:
                self.disconnect()
                raise SourceRconError('Bad RCON password')

            elif requestid != self.reqid:
                raise SourceRconError('RCON request id error: %d, expected %d' % (requestid,self.reqid,))

            response = struct.unpack('<l', buf[4:8])[0]

            if response == SERVERDATA_AUTH_RESPONSE:
                # This response says we're successfully authed.
                return True

            elif response != SERVERDATA_RESPONSE_VALUE:
                raise SourceRconError('Invalid RCON command response: %d' % (response,))

            # extract the two strings using index magic
            str1 = buf[8:]
            pos1 = str1.index('\x00')
            str2 = str1[pos1+1:]
            pos2 = str2.index('\x00')
            crap = str2[pos2+1:]

            if crap:
                raise SourceRconError('RCON response contains %d superfluous bytes' % (len(crap),))

            # add the strings to the full message result
            message += str1[:pos1]
            message2 += str2[:pos2]

            # unconditionally poll for more packets
            poll = select.select([self.tcp], [], [], 0)

            if not len(poll[0]) and packetsize < PROBABLY_SPLIT_IF_LARGER_THAN:
                # no packets waiting, previous packet wasn't large: let's stop here.
                break

        if response is False:
            raise SourceRconError('Timed out while waiting for reply')

        elif message2:
            raise SourceRconError('Invalid response message: %s' % (repr(message2),))

        return message

    def rcon(self, command):
        """Send RCON command to the server. Connect and auth if necessary,
           handle dropped connections, send command and return reply."""
        # special treatment for sending whole scripts
        if '\n' in command:
            commands = command.split('\n')
            def f(x): y = x.strip(); return len(y) and not y.startswith("//")
            commands = filter(f, commands)
            results = map(self.rcon, commands)
            return "".join(results)

        # send a single command. connect and auth if necessary.
        try:
            self.send(SERVERDATA_EXECCOMMAND, command)
            return self.receive()
        except:
            # timeout? invalid? we don't care. try one more time.
            self.disconnect()
            self.connect()
            self.send(SERVERDATA_AUTH, self.password)

            auth = self.receive()
            # the first packet may be a "you have been banned" or empty string.
            # in the latter case, fetch the second packet
            if auth == '':
                auth = self.receive()

            if auth is not True:
                self.disconnect()
                raise SourceRconError('RCON authentication failure: %s' % (repr(auth),))

            self.send(SERVERDATA_EXECCOMMAND, command)
            return self.receive()

########NEW FILE########
__FILENAME__ = anova
if 1:
    import numpy as N
    from statlib import pstat, stats
    from pstat import *
    from stats import *
    from numpy import linalg as LA
    import operator, math

    def aanova(data,effects=['A','B','C','D','E','F','G','H','I','J','K']):
        """
    Prints the results of single-variable between- and within-subject ANOVA
    designs.  The function can only handle univariate ANOVAs with a single
    random factor.  The random factor is coded in column 0 of the input
    list/array (see below) and the measured variable is coded in the last
    column of the input list/array. The following were used as references
    when writing the code:

    Maxwell, SE, Delaney HD (1990)  Designing Experiments and Analyzing
        Data, Wadsworth: Belmont, CA.
    Lindman, HR (1992) Analysis of Variance in Experimental Design,
        Springer-Verlag: New York.

    TO DO:  Increase Current Max Of 10 Levels Per W/I-Subject Factor
            Consolidate Between-Subj Analyses For Between And Within/Between
            Front-end for different input data-array shapes/organization
            Axe mess of 'global' statements (particularly for Drestrict fcns)

    Usage:   anova(data,                         data = |Stat format
                   effects=['A','B','C','D','E','F','G','H','I','J','K'])

    Note: |Stat format is as follows ... one datum per row, first element of
    row is the subject identifier, followed by all within/between subject
    variable designators, and the measured data point as the last element in the
    row.  Thus, [1, 'short', 'drugY', 2, 14.7] represents subject 1 when measured
    in the short / drugY / 2 condition, and subject 1 gave a measured value of
    14.7 in this combination of conditions.  Thus, all input lists are '2D'
    lists-of-lists.
    """
        global alluniqueslist, Nlevels, Nfactors, Nsubjects, Nblevels, Nallsources
        global Bscols, Bbetweens, SSlist, SSsources, DM, DN, Bwonly_sources, D
        global Bwithins, alleffects, alleffsources
        outputlist = []
        SSbtw = []
        SSbtwsources = []
        SSwb = []
        SSwbsources = []
        alleffects = []
        alleffsources = []
        SSlist = []
        SSsources = []

        print
        variables = 1       # this function only handles one measured variable

        if type(data)!=type([]):
            data = data.tolist()

## Create a list of all unique values in each column, and a list of these Ns
        alluniqueslist = [0]*(len(data[0])-variables) # all cols but data cols
        Nlevels = [0]*(len(data[0])-variables)        # (as above)
        for column in range(len(Nlevels)):
            alluniqueslist[column] = pstat.unique(pstat.colex(data,column))
            Nlevels[column] = len(alluniqueslist[column])

        Ncells = N.multiply.reduce(Nlevels[1:]) # total num cells (w/i AND btw)
        Nfactors = len(Nlevels[1:])             # total num factors
        Nallsources = 2**(Nfactors+1)  # total no. possible sources (factor-combos)
        Nsubjects = len(alluniqueslist[0])  # total # subj in study (# of diff. subj numbers in column 0)

## Within-subj factors defined as those where there are fewer subj than
## scores in the first level of a factor (quick and dirty; findwithin() below)
        Bwithins = findwithin(data)         # binary w/i subj factors (excl. col 0)
        Bbetweens = ~Bwithins & (Nallsources-1) - 1

        Wcolumns = makelist(Bwithins,Nfactors+1)  # get list of cols of w/i factors
        Wscols = [0] + Wcolumns                   # w/i subj columns INCL col 0
        Bscols = makelist(Bbetweens+1,Nfactors+1) #list of btw-subj cols,INCL col 0
        Nwifactors = len(Wscols) - 1 # WAS len(Wcolumns)
        Nwlevels = N.take(N.array(Nlevels),Wscols) # no.lvls for each w/i subj fact
        Nbtwfactors = len(Bscols) - 1 # WASNfactors - Nwifactors + 1
        Nblevels = N.take(N.array(Nlevels),Bscols)

        Nwsources = 2**Nwifactors - 1 # num within-subject factor-combos
        Nbsources = Nallsources - Nwsources

        #
        # CALC M-VARIABLE (LIST) and Marray/Narray VARIABLES (ARRAY OF CELL MNS/NS)
        #
        # Eliminate replications for the same subject in same condition as well as
        # within-subject repetitions, keep as list
        M = pstat.collapse(data,Bscols,-1,None,None,mean)
        # Create an arrays of Nblevels shape (excl. subj dim)
        Marray = N.zeros(Nblevels[1:],'f')
        Narray = N.zeros(Nblevels[1:],'f')
        # Fill arrays by looping through all scores in the (collapsed) M
        for row in M:
            idx = []
            for i in range(len(row[:-1])):
                idx.append(alluniqueslist[Bscols[i]].index(row[i]))
            idx = idx[1:]
            Marray[idx] = Marray[idx] + row[-1]
            Narray[idx] = Narray[idx] + 1
        Marray = Marray / Narray

        #
        # CREATE DATA ARRAY, DA, FROM ORIGINAL INPUT DATA
        # (this is an unbelievably bad, wasteful data structure, but it makes lots
        # of tasks much easier; should nevertheless be fixed someday)

        # This limits the within-subject level count to 10!
        coefflist =[[[1]],
                    [[-1,1]],
                    [[-1,0,1],[1,-2,1]],
                    [[-3,-1,1,3],[1,-1,-1,1],[-1,3,-3,1]],
                    [[-2,-1,0,1,2],[2,-1,-2,-1,2],[-1,2,0,-2,1],[1,-4,6,-4,1]],
                    [[-5,-3,-1,1,3,5],[5,-1,-4,-4,-1,5],[-5,7,4,-4,-7,5],
                     [1,-3,2,2,-3,1],[-1,5,-10,10,-5,1]],
                    [[-3,-2,-1,0,1,2,3],[5,0,-3,-4,-3,0,5],[-1,1,1,0,-1,-1,1],
                     [3,-7,1,6,1,-7,3],[-1,4,-5,0,5,-4,1],[1,-6,15,-20,15,-6,1]],
                    [[-7,-5,-3,-1,1,3,5,7],[7,1,-3,-5,-5,-3,1,7],
                     [-7,5,7,3,-3,-7,-5,7],[7,-13,-3,9,9,-3,-13,7],
                     [-7,23,-17,-15,15,17,-23,7],[1,-5,9,-5,-5,9,-5,1],
                     [-1,7,-21,35,-35,21,-7,1]],
                    [[-4,-3,-2,-1,0,1,2,3,4],[28,7,-8,-17,-20,-17,-8,7,28],
                     [-14,7,13,9,0,-9,-13,-7,14],[14,-21,-11,9,18,9,-11,-21,14],
                     [-4,11,-4,-9,0,9,4,-11,4],[4,-17,22,1,-20,1,22,-17,4],
                     [-1,6,-14,14,0,-14,14,-6,1],[1,-8,28,-56,70,-56,28,-8,1]],
                    [[-9,-7,-5,-3,-1,1,3,5,7,9],[6,2,-1,-3,-4,-4,-3,-1,2,6],
                     [-42,14,35,31,12,-12,-31,-35,-14,42],
                     [18,-22,-17,3,18,18,3,-17,-22,18],
                     [-6,14,-1,-11,-6,6,11,1,-14,6],[3,-11,10,6,-8,-8,6,10,-11,3],
                     [9,-47,86,-42,-56,56,42,-86,47,-9],
                     [1,-7,20,-28,14,14,-28,20,-7,1],
                     [-1,9,-36,84,-126,126,-84,36,-9,1]]]

        dindex = 0
        # Prepare a list to be filled with arrays of D-variables, array per within-
        # subject combo (i.e., for 2 w/i subj factors E and F ... E, F, ExF)
        NDs = [0]* Nwsources
        for source in range(Nwsources):
            if subset(source,Bwithins):
                NDs[dindex] = numlevels(source,Nlevels)
                dindex = dindex + 1

        # Collapse multiple repetitions on the same subject and same condition
        cdata = pstat.collapse(data,range(Nfactors+1),-1,None,None,mean)

        # Find a value that's not a data score with which to fill the array DA
        dummyval = -1
        datavals = pstat.colex(data,-1)
        while dummyval in datavals:  # find a value that's not a data score
            dummyval = dummyval - 1
        DA = N.ones(Nlevels,'f')*dummyval # create plenty of data-slots to fill

        if len(Bscols) == 1: # ie., if no btw-subj factors
            # 1 (below) needed because we need 2D array even w/ only 1 group of subjects
            subjslots = N.ones((Nsubjects,1))
        else: # create array to hold 1s (subj present) and 0s (subj absent)
            subjslots = N.zeros(Nblevels)
        for i in range(len(data)): # for every datapoint given as input
            idx = []
            for j in range(Nfactors+1): # get n-D bin idx for this datapoint
                new = alluniqueslist[j].index(data[i][j])
                idx.append(new)
            DA[idx] = data[i][-1] # put this data point in proper place in DA
            btwidx = N.take(idx,N.array(Bscols))
            subjslots[btwidx] = 1
        # DONE CREATING DATA ARRAY, DA ... #dims = numfactors+1, dim 0=subjects
        # dim -1=measured values, dummyval = values used to fill empty slots in DA

        # PREPARE FOR MAIN LOOP
        dcount = -1     # prepare for pre-increment of D-variable pointer
        Bwsources = []  # binary #s, each=source containing w/i subj factors
        Bwonly_sources = [] # binary #s, each=source of w/i-subj-ONLY factors
        D = N.zeros(Nwsources,N.PyObject) # one slot for each Dx,2**Nwifactors
        DM = [0] *Nwsources # Holds arrays of cell-means
        DN = [0] *Nwsources # Holds arrays of cell-ns

        # BEGIN MAIN LOOP!!!!!
        # BEGIN MAIN LOOP!!!!!
        # BEGIN MAIN LOOP!!!!!
        for source in range(3,Nallsources,2): # all sources that incl. subjects
            if ((source-1) & Bwithins) != 0: # 1 or more w/i subj sources?
                Bwsources.append(source-1)   # add it to a list
            #
            # WITHIN-SUBJECT-ONLY TERM?  IF SO ... NEED TO CALCULATE NEW D-VARIABLE
            # (per Maxwell & Delaney pp.622-4)
            if subset((source-1),Bwithins):
                # Keep track of which D-var set we're working with (De, Df, Def, etc.)
                dcount = dcount + 1
                Bwonly_sources.append(source-1) #add source, minus subj,to list
                dwsc = 1.0 * DA       # get COPY of w/i-subj data array
                # Find all non-source columns, note ~source alone (below) -> negative number
                Bnonsource = (Nallsources-1) & ~source
                Bwscols = makebin(Wscols) # make a binary version of Wscols
                # Figure out which cols from the ORIGINAL (input) data matrix are both non-
                # source and also within-subj vars (excluding subjects col)
                Bwithinnonsource = Bnonsource & Bwscols

                # Next, make a list of the above.  The list is a list of dimensions in DA
                # because DA has the same number of dimensions as there are factors
                # (including subjects), but with extra dummyval='-1' values the original
                # data array (assuming between-subj vars exist)
                Lwithinnonsource = makelist(Bwithinnonsource,Nfactors+1)

                # Collapse all non-source, w/i subj dims, FROM THE END (otherwise the
                # dim-numbers change as you collapse).  THIS WORKS BECAUSE WE'RE
                # COLLAPSING ACROSS W/I SUBJECT DIMENSIONS, WHICH WILL ALL HAVE THE
                # SAME SUBJ IN THE SAME ARRAY LOCATIONS (i.e., dummyvals will still exist
                # but should remain the same value through the amean() function
                for i in range(len(Lwithinnonsource)-1,-1,-1):
                    dwsc = amean(dwsc,Lwithinnonsource[i])
                mns = dwsc

                # NOW, ACTUALLY COMPUTE THE D-VARIABLE ENTRIES FROM DA
                # CREATE LIST OF COEFF-COMBINATIONS TO DO (len=e-1, f-1, (e-1)*(f-1), etc...)
                #
                # Figure out which cols are both source and within-subjects, including col 0
                Bwithinsource = source & Bwscols
                # Make a list of within-subj cols, incl subjects col (0)
                Lwithinsourcecol = makelist(Bwithinsource, Nfactors+1)
                # Make a list of cols that are source within-subj OR btw-subj
                Lsourceandbtws = makelist(source | Bbetweens, Nfactors+1)
                if Lwithinnonsource <> []:
                    Lwithinsourcecol = map(Lsourceandbtws.index,Lwithinsourcecol)
                    # Now indxlist should hold a list of indices into the list of possible
                    # coefficients, one row per combo of coefficient. Next line PRESERVES dummyval
                dvarshape = N.array(N.take(mns.shape,Lwithinsourcecol[1:])) -1
                idxarray = N.indices(dvarshape)
                newshape = N.array([idxarray.shape[0],
                                    N.multiply.reduce(idxarray.shape[1:])])
                indxlist = N.swapaxes(N.reshape(idxarray,newshape),0,1)

                # The following is what makes the D-vars 2D.  It takes an n-dim array
                # and retains the first (num of factors) dim while making the 2nd dim
                # equal to the total number of source within-subject cells.

                #
                # CREATE ALL D-VARIABLES FOR THIS COMBINATION OF FACTORS
                #
                for i in range(len(indxlist)):
                    #
                    # FILL UP COEFFMATRIX (OF SHAPE = MNS) WITH CORRECT COEFFS FOR 1 D-VAR
                    #
                    coeffmatrix = N.ones(mns.shape,N.Float) # fewer dims than DA (!!)
                    # Make a list of dim #s that are both in source AND w/i subj fact, incl subj
                    Wsourcecol = makelist(Bwscols&source,Nfactors+1)
                    # Fill coeffmatrix with a complete set of coeffs (1 per w/i-source factor)
                    for wfactor in range(len(Lwithinsourcecol[1:])):
                        #put correct coeff. axis as first axis, or "swap it up"
                        coeffmatrix = N.swapaxes(coeffmatrix,0,
                                                 Lwithinsourcecol[wfactor+1])
                        # Find appropriate ROW of (static) coefflist we need
                        nlevels = coeffmatrix.shape[0]
                        # Get the next coeff in that row
                        try:
                            nextcoeff = coefflist[nlevels-1][indxlist[i,wfactor]]
                        except IndexError:
                            raise IndexError, "anova() can only handle up to 10 levels on a within-subject factors"
                        for j in range(nlevels):
                            coeffmatrix[j] = coeffmatrix[j] * nextcoeff[j]
                        # Swap it back to where it came from
                        coeffmatrix = N.swapaxes(coeffmatrix,0,
                                                 Lwithinsourcecol[wfactor+1])

                    # CALCULATE D VARIABLE
                    scratch = coeffmatrix * mns
                    # Collapse all dimensions EXCEPT subjects dim (dim 0)
                    for j in range(len(coeffmatrix.shape[1:])):
                        scratch = N.add.reduce(scratch,1)
                    if len(scratch.shape) == 1:
                        scratch.shape = list(scratch.shape)+[1]
                    try:
                        # Tack this column onto existing ones
                        tmp = D[dcount].shape
                        D[dcount] = pstat.aabut(D[dcount],scratch)
                    except AttributeError: # i.e., D[dcount]=integer/float
                        # If this is the first, plug it in
                        D[dcount] = scratch


                # Big long thing to create DMarray (list of DM variables) for this source
                variables = D[dcount].shape[1] # Num variables for this source
                tidx = range(1,len(subjslots.shape)) + [0] # [0] = Ss dim
                tsubjslots = N.transpose(subjslots,tidx) # put Ss in last dim
                DMarray = N.zeros(list(tsubjslots.shape[0:-1]) +
                                  [variables],'f') # btw-subj dims, then vars
                DNarray = N.zeros(list(tsubjslots.shape[0:-1]) +
                                  [variables],'f') # btw-subj dims, then vars
                idx = [0] *len(tsubjslots.shape[0:-1])
                idx[0] = -1
                loopcap = N.array(tsubjslots.shape[0:-1]) -1
                while incr(idx,loopcap) <> -1:
                    DNarray[idx] = float(asum(tsubjslots[idx]))
                    thismean =  (N.add.reduce(tsubjslots[idx] * # 1=subj dim
                                              N.transpose(D[dcount]),1) /
                                 DNarray[idx])
                    thismean = N.array(thismean,N.PyObject)
                    DMarray[idx] = thismean
                DM[dcount] = DMarray
                DN[dcount] = DNarray

            #
            # DONE CREATING M AND D VARIABLES ... TIME FOR SOME SS WORK
            # DONE CREATING M AND D VARIABLES ... TIME FOR SOME SS WORK
            #
            if Bscols[1:] <> []:
                BNs = pstat.colex([Nlevels],Bscols[1:])
            else:
                BNs = [1]
                #
                # FIGURE OUT WHICH VARS TO RESTRICT, see p.680 (Maxwell&Delaney)
                #
                # BETWEEN-SUBJECTS VARIABLES ONLY, use M variable for analysis
                #
            if ((source-1) & Bwithins) == 0:  # btw-subjects vars only?
                sourcecols = makelist(source-1,Nfactors+1)

                # Determine cols (from input list) required for n-way interaction
                Lsource = makelist((Nallsources-1)&Bbetweens,Nfactors+1)
                # NOW convert this list of between-subject column numbers to a list of
                # DIMENSIONS in M, since M has fewer dims than the original data array
                # (assuming within-subj vars exist); Bscols has list of between-subj cols
                # from input list, the indices of which correspond to that var's loc'n in M
                btwcols = map(Bscols.index,Lsource)
                # Obviously-needed loop to get cell means is embedded in the collapse fcn, -1
                # represents last (measured-variable) column, None=std, 1=retain Ns

                hn = aharmonicmean(Narray,-1) # -1=unravel first

                # CALCULATE SSw ... SUBTRACT APPROPRIATE CELL MEAN FROM EACH SUBJ SCORE
                SSw = 0.0
                idxlist = pstat.unique(pstat.colex(M,btwcols))
                for row in M:
                    idx = []
                    for i in range(len(row[:-1])):
                        idx.append(alluniqueslist[Bscols[i]].index(row[i]))
                    idx = idx[1:]   # Strop off Ss col/dim
                    newval = row[-1] - Marray[idx]
                    SSw = SSw + (newval)**2

                # Determine which cols from input are required for this source
                Lsource = makelist(source-1,Nfactors+1)
                # NOW convert this list of between-subject column numbers to a list of
                # DIMENSIONS in M, since M has fewer dims than the original data array
                # (assuming within-subj vars exist); Bscols has list of between-subj cols
                # from input list, the indices of which correspond to that var's loc'n in M
                btwsourcecols = (N.array(map(Bscols.index,Lsource))-1).tolist()

                # Average Marray and get harmonic means of Narray OVER NON-SOURCE DIMS
                Bbtwnonsourcedims = ~source & Bbetweens
                Lbtwnonsourcedims = makelist(Bbtwnonsourcedims,Nfactors+1)
                btwnonsourcedims = (N.array(map(Bscols.index,Lbtwnonsourcedims))-1).tolist()

        ## Average Marray over non-source dimensions (1=keep squashed dims)
                sourceMarray = amean(Marray,btwnonsourcedims,1)

        ## Calculate harmonic means for each level in source
                sourceNarray = aharmonicmean(Narray,btwnonsourcedims,1)

        ## Calc grand average (ga), used for ALL effects
                ga = asum((sourceMarray*sourceNarray)/
                                asum(sourceNarray))
                ga = N.reshape(ga,N.ones(len(Marray.shape)))

        ## If GRAND interaction, use harmonic mean of ALL cell Ns
                if source == Nallsources-1:
                    sourceNarray = aharmonicmean(Narray)

        ## Calc all SUBSOURCES to be subtracted from sourceMarray (M&D p.320)
                sub_effects = 1.0 * ga # start with grand mean
                for subsource in range(3,source,2):
            ## Make a list of the non-subsource dimensions
                    if subset(subsource-1,source-1):
                        sub_effects = (sub_effects +
                                       alleffects[alleffsources.index(subsource)])
            ## Calc this effect (a(j)'s, b(k)'s, ab(j,k)'s, whatever)
                effect = sourceMarray - sub_effects

            ## Save it so you don't have to calculate it again next time
                alleffects.append(effect)
                alleffsources.append(source)

        ## Calc and save sums of squares for this source
                SS = asum((effect**2 *sourceNarray) *
                          N.multiply.reduce(N.take(Marray.shape,btwnonsourcedims)))
            ## Save it so you don't have to calculate it again next time
                SSlist.append(SS)
                SSsources.append(source)

                collapsed = pstat.collapse(M,btwcols,-1,None,len,mean)
                # Obviously needed for-loop to get source cell-means embedded in collapse fcns
                contrastmns = pstat.collapse(collapsed,btwsourcecols,-2,sterr,len,mean)
                # Collapse again, this time SUMMING instead of averaging (to get cell Ns)
                contrastns = pstat.collapse(collapsed,btwsourcecols,-1,None,None,
                                            N.sum)
                # Collapse again, this time calculating harmonicmeans (for hns)
                contrasthns = pstat.collapse(collapsed,btwsourcecols,-1,None,None,
                                             harmonicmean)
                # CALCULATE *BTW-SUBJ* dfnum, dfden
                sourceNs = pstat.colex([Nlevels],makelist(source-1,Nfactors+1))
                dfnum = N.multiply.reduce(N.ravel(N.array(sourceNs)-1))
                dfden = Nsubjects - N.multiply.reduce(N.ravel(BNs))

                # CALCULATE MS, MSw, F AND PROB FOR ALL-BETWEEN-SUBJ SOURCES ONLY
                MS = SS / dfnum
                MSw = SSw / dfden
                if MSw <> 0:
                    f = MS / MSw
                else:
                    f = 0  # i.e., absolutely NO error in the full model

                if f >= 0:
                    prob = fprob(dfnum, dfden, f)
                else:
                    prob = 1.0
        # Now this falls thru to output stage

        #
        # SOME WITHIN-SUBJECTS FACTORS TO DEAL WITH ... use appropriate D variable
        #
            else:  # Source has some w/i subj factors
                # FIGURE OUT WHICH D-VAR TO USE BASED ON WHICH W/I-SUBJ FACTORS ARE IN SOURCE
                # Determine which w/i-subj factors are in this source
                sourcewithins = (source-1) & Bwithins
                # Use D-var that was created for that w/i subj combo (the position of that
                # source within Bwsources determines the index of that D-var in D)
                workD = D[Bwonly_sources.index(sourcewithins)]

                # CALCULATE Er, Ef
        ## Set up workD and subjslots for upcoming calcs
                if len(workD.shape)==1:
                    workD = workD[:,N.NewAxis]
                if len(subjslots.shape)==1:
                    subjslots = subjslots[:,N.NewAxis]

        ## Calculate full-model sums of squares
                ef = Dfull_model(workD,subjslots) # Uses cell-means model

                #
                # **ONLY** WITHIN-SUBJECT VARIABLES TO CONSIDER
                #
                if subset((source-1),Bwithins):
                    # restrict grand mean, as per M&D p.680
                    er = Drestrict_mean(workD,subjslots)
            #
            # **BOTH** WITHIN- AND BETWEEN-SUBJECTS VARIABLES TO CONSIDER
            #
                else:
                    er = Drestrict_source(workD,subjslots,source) + ef
                SSw = LA.determinant(ef)
                SS = LA.determinant(er) - SSw

            # CALCULATE *W/I-SUBJ* dfnum, dfden
                sourceNs = pstat.colex([Nlevels],makelist(source,Nfactors+1))
                # Calculation of dfnum is straightforward regardless
                dfnum = N.multiply.reduce(N.ravel(N.array(sourceNs)-1)[1:])
                # If only within-subject factors are involved, dfden is straightforward
                if subset(source-1,Bwithins):
                    dfden = Nsubjects -N.multiply.reduce(N.ravel(BNs))-dfnum +1
                    MS = SS / dfnum
                    MSw = SSw / dfden
                    if MSw <> 0:
                        f = MS / MSw
                    else:
                        f = 0  # i.e., absolutely NO error in full model

                    if f >= 0:
                        prob = fprob(dfnum, dfden, f)
                    else:
                        prob = 1.0

                # If combined within-between source, must use Rao's approximation for dfden
                # from Tatsuoka, MM (1988) Multivariate Analysis (2nd Ed), MacMillan: NY p93
                else: # it's a within-between combo source
                    try:
                        p = workD.shape[1]
                    except IndexError:
                        p = 1
                    k = N.multiply.reduce(N.ravel(BNs))
                    m = Nsubjects -1 -(p+k)/2.0
                    d_en = float(p**2 + (k-1)**2 - 5)
                    if d_en == 0.0:
                        s = 1.0
                    else:
                        s = math.sqrt(((p*(k-1))**2-4) / d_en)
                    dfden = m*s - dfnum/2.0 + 1

                    # Given a within-between combined source, Wilk's Lambda is appropriate
                    if LA.determinant(er) <> 0:
                        lmbda = LA.determinant(ef) / LA.determinant(er)
                        W = math.pow(lmbda,(1.0/s))
                        f = ((1.0-W)/W) * (dfden/dfnum)
                    else:
                        f = 0  # i.e., absolutely NO error in restricted model

                    if f >= 0:
                        prob = fprob(dfnum,dfden,f)
                    else:
                        prob = 1.0

            #
            # CREATE STRING-LIST FOR RESULTS FROM THIS PARTICULAR SOURCE
            #
            suffix = ''                       # for *s after the p-value
            if  prob < 0.001:  suffix = '***'
            elif prob < 0.01:  suffix = '**'
            elif prob < 0.05:  suffix = '*'
            adjsourcecols = N.array(makelist(source-1,Nfactors+1)) -1
            thiseffect = ''
            for col in adjsourcecols:
                if len(adjsourcecols) > 1:
                    thiseffect = thiseffect + effects[col][0]
                else:
                    thiseffect = thiseffect + (effects[col])
            outputlist = (outputlist
            # These terms are for the numerator of the current effect/source
                          + [[thiseffect, round4(SS),dfnum,
                              round4(SS/float(dfnum)),round4(f),
                              round4(prob),suffix]]
            # These terms are for the denominator for the current effect/source
                          + [[thiseffect+'/w', round4(SSw),dfden,
                              round4(SSw/float(dfden)),'','','']]
                          + [['\n']])

            #
            # PRINT OUT ALL MEANS AND Ns FOR THIS SOURCE (i.e., this combo of factors)
            #
            Lsource = makelist(source-1,Nfactors+1)
            collapsed = pstat.collapse(cdata,Lsource,-1,sterr,len,mean)

            # First, get the list of level-combos for source cells
            prefixcols = range(len(collapsed[0][:-3]))
            outlist = pstat.colex(collapsed,prefixcols)
            # Start w/ factor names (A,B,C, or ones input to anova())
            eff = []
            for col in Lsource:
                eff.append(effects[col-1])
            # Add in the mean and N labels for printout
            for item in ['MEAN','STERR','N']:
                eff.append(item)
            # To the list of level-combos, abut the corresp. means and Ns
            outlist = pstat.abut(outlist,
                                 map(round4,pstat.colex(collapsed,-3)),
                                 map(round4,pstat.colex(collapsed,-2)),
                                 map(round4,pstat.colex(collapsed,-1)))
            outlist = [eff] + outlist # add titles to the top of the list
            pstat.printcc(outlist)    # print it in customized columns
            print


###
### OUTPUT FINAL RESULTS (ALL SOURCES TOGETHER)
### Note: All 3 types of source-calcs fall through to here
###
        print
        title = [['FACTORS: ','RANDOM'] + effects[:Nfactors]]
        title = title + [['LEVELS:  ']+Nlevels]
        facttypes = ['BETWEEN']*Nfactors
        for i in range(len(Wscols[1:])):
            facttypes[Wscols[i+1]-1] = 'WITHIN'
        title = title + [['TYPE:    ','RANDOM']+facttypes]
        pstat.printcc(title)
        print

        title = [['Effect','SS','DF','MS','F','p','sig']] + ['dashes']
        outputlist = title + outputlist
        pstat.printcc(outputlist)
        return


    def Dfull_model(workd,subjslots):
        """
        RESTRICTS NOTHING (i.e., FULL MODEL CALCULATION).  Subtracts D-variable
   cell-mean for each between-subj group and then calculates the SS array.
        """
        workd = subtr_cellmeans(workd,subjslots)
        sserr = multivar_SScalc(workd)
        return sserr


    def Drestrict_mean(workd,subjslots):
        """
        RESTRICTS GRAND MEAN.  Subtracts D-variable cell-mean for each between-
   subj group, and then adds back each D-variable's grand mean.
        """
        # subtract D-variable cell-mean for each (btw-subj) group
        errors = subtr_cellmeans(workd,subjslots)

        # add back in appropriate grand mean from individual scores
        grandDmeans = amean(workd,0,1)
        errors = errors + N.transpose(grandDmeans) # errors has reversed dims!!
        # SS for mean-restricted model is calculated below.  Note: already put
        # subj as last dim because later code expects this code here to leave
        # workd that way
        sserr = multivar_SScalc(errors)
        return sserr


    def Drestrict_source(workd,subjslots,source):
        """
   Calculates error for a given model on array workd.  Subjslots is an
   array of 1s and 0s corresponding to whether or not the subject is a
   member of that between-subjects variable combo.  source is the code
   for the type of model to calculate.  source=-1 means no restriction;
   source=0 means to restrict workd's grand mean; source>0 means to
   restrict the columns of the main data array, DA, specified (in binary)
   by the source-value.

   Usage:   Derrorcalc(workd,subjslots,source)  source:-1=nothing, 0=mean
   Returns: SS array for multivariate F calculation
   """
###
### RESTRICT COLUMNS/DIMENSIONS SPECIFIED IN source (BINARY)
### (i.e., is the value of source not equal to 0 or -1?)
###
        if source > 0:
            sourcewithins = (source-1) & Bwithins
            sourcebetweens = (source-1) & Bbetweens
            dindex = Bwonly_sources.index(sourcewithins)
            all_cellmeans = N.transpose(DM[dindex],[-1]+range(0,len(DM[dindex].shape)-1))
            all_cellns = N.transpose(DN[dindex],[-1]+range(0,len(DN[dindex].shape)-1))
            hn = aharmonicmean(all_cellns)

            levels = D[dindex].shape[1]  # GENERAL, 'cause each workd is always 2D
            SSm = N.zeros((levels,levels),'f') #called RCm=SCm in Lindman,p.317-8
            tworkd = N.transpose(D[dindex])

        ## Calculate SSw, within-subj variance (Lindman approach)
            RSw = N.zeros((levels,levels),'f')
            RSinter = N.zeros((levels,levels),N.PyObject)
            for i in range(levels):
                for j in range(i,levels):
                    RSw[i,j] = RSw[j,i] = N.sum(tworkd[i]*tworkd[j])
                    cross = all_cellmeans[i] * all_cellmeans[j]
                    multfirst = asum(cross*all_cellns[i])
                    RSinter[i,j] = RSinter[j,i] = N.asarray(multfirst)
                    SSm[i,j] = SSm[j,i] = (amean(all_cellmeans[i]) *
                                           amean(all_cellmeans[j]) *
                                           len(all_cellmeans[i]) *hn)
            SSw = RSw - RSinter

### HERE BEGINS THE MAXWELL & DELANEY APPROACH TO CALCULATING SS
            Lsource = makelist(sourcebetweens,Nfactors+1)
            btwsourcecols = (N.array(map(Bscols.index,Lsource))-1).tolist()
            Bbtwnonsourcedims = ~source & Bbetweens
            Lbtwnonsourcedims = makelist(Bbtwnonsourcedims,Nfactors+1)
            btwnonsourcedims = (N.array(map(Bscols.index,Lbtwnonsourcedims))-1).tolist()

          ## Average Marray over non-source dimensions
            sourceDMarray = DM[dindex] *1.0
            for dim in btwnonsourcedims: # collapse all non-source dims
                if dim == len(DM[dindex].shape)-1:
                    raise ValueError, "Crashing ... shouldn't ever collapse ACROSS variables"
                sourceDMarray = amean(sourceDMarray,dim,1)

          ## Calculate harmonic means for each level in source
            sourceDNarray = aharmonicmean(DN[dindex],btwnonsourcedims,1)

          ## Calc grand average (ga), used for ALL effects
            variableNs = asum(sourceDNarray,
                              range(len(sourceDMarray.shape)-1))
            ga = asum((sourceDMarray*sourceDNarray) /
                      variableNs,
                      range(len(sourceDMarray.shape)-1),1)

          ## If GRAND interaction, use harmonic mean of ALL cell Ns
            if source == Nallsources-1:
                sourceDNarray = aharmonicmean(DN[dindex],
                                              range(len(sourceDMarray.shape)-1))

          ## Calc all SUBSOURCES to be subtracted from sourceMarray (M&D p.320)
            sub_effects = ga *1.0   # start with grand mean
            for subsource in range(3,source-2,2):
          ## Make a list of the non-subsource dimensions
                subsourcebtw = (subsource-1) & Bbetweens
                if (propersubset(subsource-1,source-1) and
                    (subsource-1)&Bwithins == (source-1)&Bwithins and
                    (subsource-1) <> (source-1)&Bwithins):
                    sub_effects = (sub_effects +
                                   alleffects[alleffsources.index(subsource)])

          ## Calc this effect (a(j)'s, b(k)'s, ab(j,k)'s, whatever)
            effect = sourceDMarray - sub_effects

          ## Save it so you don't have to calculate it again next time
            alleffects.append(effect)
            alleffsources.append(source)

          ## Calc and save sums of squares for this source
            SS = N.zeros((levels,levels),'f')
            SS = asum((effect**2 *sourceDNarray) *
                      N.multiply.reduce(N.take(DM[dindex].shape,btwnonsourcedims)),
                            range(len(sourceDMarray.shape)-1))
          ## Save it so you don't have to calculate it again next time
            SSlist.append(SS)
            SSsources.append(source)

            return SS


    def multivar_SScalc(workd):
###
### DO SS CALCS ON THE OUTPUT FROM THE SOURCE=0 AND SOURCE=-1 CASES
###
        # this section expects workd to have subj. in LAST dimension!!!!!!
        if len(workd.shape) == 1:
            levels = 1
        else:
            levels = workd.shape[0] # works because workd is always 2D

        sserr = N.zeros((levels,levels),'f')
        for i in range(levels):
            for j in range(i,levels):
                ssval = N.add.reduce(workd[i]*workd[j])
                sserr[i,j] = ssval
                sserr[j,i] = ssval
        return sserr


    def subtr_cellmeans(workd,subjslots):
        """
   Subtract all cell means when within-subjects factors are present ...
   i.e., calculate full-model using a D-variable.
   """
        # Get a list of all dims that are source and between-subj
        sourcedims = makelist(Bbetweens,Nfactors+1)

        # Now, fix this list by mapping the dims from the original source
        # to dims for a between-subjects variable (namely, subjslots)
        transidx = range(len(subjslots.shape))[1:] + [0] # put subj dim at end
        tsubjslots = N.transpose(subjslots,transidx) # get all Ss for this idx
        tworkd = N.transpose(workd) # swap subj. and variable dims
        errors = 1.0 * tworkd

        if len(sourcedims) == 0:
            idx = [-1]
            loopcap = [0]
        if len(sourcedims) <> 0:
            btwsourcedims = map(Bscols.index,sourcedims)
            idx = [0] * len(btwsourcedims)
            idx[0] = -1 # compensate for pre-increment of 1st slot in incr()

            # Get a list of the maximum values each factor can handle
            loopcap = N.take(N.array(Nlevels),sourcedims)-1

### WHILE STILL MORE GROUPS, CALCULATE GROUP MEAN FOR EACH D-VAR
        while incr(idx,loopcap) <> -1:  # loop through source btw level-combos
            mask = tsubjslots[idx]
            thisgroup = tworkd*mask[N.NewAxis,:]
            groupmns = amean(N.compress(mask,thisgroup),1)

### THEN SUBTRACT THEM FROM APPROPRIATE SUBJECTS
            errors = errors - N.multiply.outer(groupmns,mask)
        return errors


    def F_value_wilks_lambda(ER, EF, dfnum, dfden, a, b):
        """
   Calculation of Wilks lambda F-statistic for multivarite data, per
   Maxwell & Delaney p.657.

   Usage:   F_value_wilks_lambda(ER,EF,dfnum,dfden,a,b)
   """
        if type(ER) in [IntType, FloatType]:
            ER = N.array([[ER]])
        if type(EF) in [IntType, FloatType]:
            EF = N.array([[EF]])
        lmbda = LA.determinant(EF) / LA.determinant(ER)
        if (a-1)**2 + (b-1)**2 == 5:
            q = 1
        else:
            q = math.sqrt( ((a-1)**2*(b-1)**2 - 2) / ((a-1)**2 + (b-1)**2 -5) )
        n_um = (1 - lmbda**(1.0/q))*(a-1)*(b-1)
        d_en = lmbda**(1.0/q) / (m*q - 0.5*(a-1)*(b-1) + 1)
        return n_um / d_en

    def member(factor,source):
        return (1 << factor) & source != 0

    def setsize(source):
        size = 0
        for bit in source:
            if bit == 1:
                size = size + 1
        return size

    def subset (a,b):
        return (a&b)==a

    def propersubset (a,b):
        sub = ((a&b)==a)
        if a==b:
            sub = 0
        return sub

    def numlevels(source,Nlevels):
        for i in range(30): # find the biggest i such that 2**i >= source
            if 1<<i >= source:
                break
        levelcount = 1
        for j in range(i): # loop up through each bit
            if subset(1<<j,source):
                levelcount = levelcount * Nlevels[j] - 1
        return levelcount

    def numbitson(a):
        numon = 0
        while a>0:
            numon = numon + a%2
            a = a>>1
        return numon

    def makebin(sourcelist):
        outbin = 0
        for item in sourcelist:
            outbin = outbin + 2**item
        return outbin

    def makelist(source,ncols):
        levellist = []
        for j in range(ncols):
            if subset(1<<j,source):
                levellist.append(j)
        return levellist

    def round4(num):
        try:
            return round(num,4)
        except:
            return 'N/A'

########NEW FILE########
__FILENAME__ = io
# Copyright (c) Gary Strangman.  All rights reserved
#
# Disclaimer
#
# This software is provided "as-is".  There are no expressed or implied
# warranties of any kind, including, but not limited to, the warranties
# of merchantability and fittness for a given application.  In no event
# shall Gary Strangman be liable for any direct, indirect, incidental,
# special, exemplary or consequential damages (including, but not limited
# to, loss of use, data or profits, or business interruption) however
# caused and on any theory of liability, whether in contract, strict
# liability or tort (including negligence or otherwise) arising in any way
# out of the use of this software, even if advised of the possibility of
# such damage.
#
# Comments and/or additions are welcome (send e-mail to:
# strang@nmr.mgh.harvard.edu).
#
"""
Defines a number of functions for pseudo-command-line OS functionality.

    cd(directory)
    pwd                 <-- can be used WITHOUT parens
    ls(d='.')
    rename(from,to)
    get(namepatterns,verbose=1)
    getstrings(namepatterns,verbose=1)
    put(outlist,filename,writetype='w')
    aget(namepatterns,verbose=1)
    aput(outarray,filename,writetype='w')
    bget(filename,numslices=1,xsize=64,ysize=64)
    braw(filename,btype)
    bput(outarray,filename,writeheader=0,packstring='h',writetype='wb')
    mrget(filename)
    find_dirs(sourcedir)
"""

## CHANGES:
## =======
## 02-11-20 ... added binget(), binput(), array2afni(), version 0.5
## 02-10-20 ... added find_dirs() function, changed version to 0.4
## 01-11-15 ... changed aput() and put() to accept a delimiter
## 01-04-19 ... added oneperline option to put() function
## 99-11-07 ... added DAs quick flat-text-file loaders, load() and fload()
## 99-11-01 ... added version number (0.1) for distribution
## 99-08-30 ... Put quickload in here
## 99-06-27 ... Changed bget thing back ... confused ...
## 99-06-24 ... exchanged xsize and ysize in bget for non-square images (NT??)
##              modified bget to raise an IOError when file not found
## 99-06-12 ... added load() and save() aliases for aget() and aput() (resp.)
## 99-04-13 ... changed aget() to ignore (!!!!) lines beginning with # or %
## 99-01-17 ... changed get() so ints come in as ints (not floats)
##



try:
    import mmapfile
except:
    pass

import pstat
import glob, re, string, types, os, numpy, struct, copy, time, tempfile, sys
from types import *
N = numpy

__version__ = 0.5

def wrap(f):
    """
Wraps a function so that if it's entered *by itself*
in the interpreter without ()'s, it gets called anyway
"""
    class W:
        def __init__(self, f):
            self.f = f
        def __repr__(self):
            x =apply(self.f)
            if x:
                return repr(x)
            else:
                return ''
    return W(f)


def cd (directory):
    """
Changes the working python directory for the interpreter.

Usage:   cd(directory)      where 'directory' is a string
"""
    os.chdir(directory)
    return


def pwd():
    """
Changes the working python directory for the interpreter.

Usage:   pwd       (no parens needed)
"""
    return os.getcwd()
pwd = wrap(pwd)


def ls(d='.'):
    """
Produces a directory listing.  Default is the current directory.

Usage:   ls(d='.')
"""
    os.system('ls '+d)
    return None


def rename(source, dest):
    """
Renames files specified by UNIX inpattern to those specified by UNIX
outpattern.  Can only handle a single '*' in the two patterns!!!

Usage:   rename (source, dest)     e.g., rename('*.txt', '*.c')
"""

    infiles = glob.glob(source)
    outfiles = []
    incutindex = string.index(source,'*')
    outcutindex = string.index(source,'*')
    findpattern1 = source[0:incutindex]
    findpattern2 = source[incutindex+1:]
    replpattern1 = dest[0:incutindex]
    replpattern2 = dest[incutindex+1:]
    for fname in infiles:
        if incutindex > 0:
            newname = re.sub(findpattern1,replpattern1,fname,1)
        if outcutindex < len(dest)-1:
            if incutindex > 0:
                lastone = string.rfind(newname,replpattern2)
                newname = newname[0:lastone] + re.sub(findpattern2,replpattern2,fname[lastone:],1)
            else:
                lastone = string.rfind(fname,findpattern2)
                if lastone <> -1:
                    newname = fname[0:lastone]
                    newname = newname + re.sub(findpattern2,replpattern2,fname[lastone:],1)
        os.rename(fname,newname)
    return


def get (namepatterns,verbose=1):
    """
Loads a list of lists from text files (specified by a UNIX-style
wildcard filename pattern) and converts all numeric values to floats.
Uses the glob module for filename pattern conversion.  Loaded filename
is printed if verbose=1.

Usage:   get (namepatterns,verbose=1)
Returns: a 1D or 2D list of lists from whitespace delimited text files
         specified by namepatterns; numbers that can be converted to floats
         are so converted
"""
    fnames = []
    if type(namepatterns) in [ListType,TupleType]:
        for item in namepatterns:
            fnames = fnames + glob.glob(item)
    else:
        fnames = glob.glob(namepatterns)

    if len(fnames) == 0:
        if verbose:
            print 'NO FILENAMES MATCH ('+namepatterns+') !!'
        return None

    if verbose:
        print fnames             # so user knows what has been loaded
    elements = []
    for i in range(len(fnames)):
        file = open(fnames[i])
        newelements = map(string.split,file.readlines())
        for i in range(len(newelements)):
            for j in range(len(newelements[i])):
                try:
                    newelements[i][j] = string.atoi(newelements[i][j])
                except ValueError:
                    try:
                        newelements[i][j] = string.atof(newelements[i][j])
                    except:
                        pass
        elements = elements + newelements
    if len(elements)==1:  elements = elements[0]
    return elements


def getstrings (namepattern,verbose=1):
    """
Loads a (set of) text file(s), with all elements left as string type.
Uses UNIX-style wildcards (i.e., function uses glob).  Loaded filename
is printed if verbose=1.

Usage:   getstrings (namepattern, verbose=1)
Returns: a list of strings, one per line in each text file specified by
         namepattern
"""
    fnames = glob.glob(namepattern)
    if len(fnames) == 0:
        if verbose:
            print 'NO FILENAMES MATCH ('+namepattern+') !!'
        return None
    if verbose:
        print fnames
    elements = []
    for filename in fnames:
        file = open(filename)
        newelements = map(string.split,file.readlines())
        elements = elements + newelements
    return elements


def put (outlist,fname,writetype='w',oneperline=0,delimit=' '):
    """
Writes a passed mixed-type list (str and/or numbers) to an output
file, and then closes the file.  Default is overwrite the destination
file.

Usage:   put (outlist,fname,writetype='w',oneperline=0,delimit=' ')
Returns: None
"""
    if type(outlist) in [N.ArrayType]:
        aput(outlist,fname,writetype)
        return
    if type(outlist[0]) not in [ListType,TupleType]:  # 1D list
        outfile = open(fname,writetype)
        if not oneperline:
            outlist = pstat.list2string(outlist,delimit)
            outfile.write(outlist)
            outfile.write('\n')
        else:  # they want one element from the list on each file line
            for item in outlist:
                outfile.write(str(item)+'\n')
        outfile.close()
    else:                                             # 2D list (list-of-lists)
        outfile = open(fname,writetype)
        for row in outlist:
            outfile.write(pstat.list2string(row,delimit))
            outfile.write('\n')
        outfile.close()
    return None


def isstring(x):
    if type(x)==StringType:
        return 1
    else:
        return 0



def aget (namepattern,verbose=1):
    """
Loads an array from 2D text files (specified by a UNIX-style wildcard
filename pattern).  ONLY 'GET' FILES WITH EQUAL NUMBERS OF COLUMNS
ON EVERY ROW (otherwise returned array will be zero-dimensional).

Usage:   aget (namepattern)
Returns: an array of integers, floats or objects (type='O'), depending on the
         contents of the files specified by namepattern
"""
    fnames = glob.glob(namepattern)
    if len(fnames) == 0:
        if verbose:
            print 'NO FILENAMES MATCH ('+namepattern+') !!'
            return None
    if verbose:
        print fnames
    elements = []
    for filename in fnames:
        file = open(filename)
        newelements = file.readlines()
        del_list = []
        for row in range(len(newelements)):
            if (newelements[row][0]=='%' or newelements[row][0]=='#'
                or len(newelements[row])==1):
                del_list.append(row)
        del_list.reverse()
        for i in del_list:
            newelements.pop(i)
        newelements = map(string.split,newelements)
        for i in range(len(newelements)):
            for j in range(len(newelements[i])):
                try:
                    newelements[i][j] = string.atof(newelements[i][j])
                except:
                    pass
        elements = elements + newelements
    for row in range(len(elements)):
        if N.add.reduce(N.array(map(isstring,elements[row])))==len(elements[row]):
            print "A row of strings was found.  Returning a LIST."
            return elements
    try:
        elements = N.array(elements)
    except TypeError:
        elements = N.array(elements,'O')
    return elements


def aput (outarray,fname,writetype='w',delimit=' '):
    """
Sends passed 1D or 2D array to an output file and closes the file.

Usage:   aput (outarray,fname,writetype='w',delimit=' ')
Returns: None
"""
    outfile = open(fname,writetype)
    if len(outarray.shape) == 1:
        outarray = outarray[N.NewAxis,:]
    if len(outarray.shape) > 2:
        raise TypeError, "put() and aput() require 1D or 2D arrays.  Otherwise use some kind of pickling."
    else: # must be a 2D array
        for row in outarray:
            outfile.write(string.join(map(str,row),delimit))
            outfile.write('\n')
        outfile.close()
    return None


def bget(imfile,shp=None,unpackstr=N.int16,bytesperpixel=2.0,sliceinit=0):
    """
Reads in a binary file, typically with a .bshort or .bfloat extension.
If so, the last 3 parameters are set appropriately.  If not, the last 3
parameters default to reading .bshort files (2-byte integers in big-endian
binary format).

Usage:   bget(imfile,shp=None,unpackstr=N.int16,bytesperpixel=2.0,sliceinit=0)
"""
    if imfile[:3] == 'COR':
        return CORget(imfile)
    if imfile[-2:] == 'MR':
        return mrget(imfile,unpackstr)
    if imfile[-4:] == 'BRIK':
        return brikget(imfile,unpackstr,shp)
    if imfile[-3:] in ['mnc','MNC']:
        return mincget(imfile,unpackstr,shp)
    if imfile[-3:] == 'img':
        return mghbget(imfile,unpackstr,shp)
    if imfile[-6:] == 'bshort' or imfile[-6:] == 'bfloat':
        if shp == None:
            return mghbget(imfile,unpackstr=unpackstr,bytesperpixel=bytesperpixel,sliceinit=sliceinit)
        else:
            return mghbget(imfile,shp[0],shp[1],shp[2],unpackstr,bytesperpixel,sliceinit)


def CORget(infile):
    """
Reads a binary COR-nnn file (flattening file).

Usage:   CORget(imfile)
Returns: 2D array of 16-bit ints
"""
    d=braw(infile,N.Int8)
    d.shape = (256,256)
    d = N.where(N.greater_equal(d,0),d,256+d)
    return d


def mincget(imfile,unpackstr=N.int16,shp=None):
    """
Loads in a .MNC file.

Usage:  mincget(imfile,unpackstr=N.int16,shp=None)  default shp = -1,20,64,64
"""
    if shp == None:
        shp = (-1,20,64,64)
    os.system('mincextract -short -range 0 4095 -image_range 0 4095 ' +
              imfile+' > minctemp.bshort')
    try:
        d = braw('minctemp.bshort',unpackstr)
    except:
        print "Couldn't find file:  "+imfile
        raise IOError, "Couldn't find file in mincget()"

    print shp, d.shape
    d.shape = shp
    os.system('rm minctemp.bshort')
    return d


def brikget(imfile,unpackstr=N.int16,shp=None):
    """
Gets an AFNI BRIK file.

Usage:  brikget(imfile,unpackstr=N.int16,shp=None)  default shp: (-1,48,61,51)
"""
    if shp == None:
        shp = (-1,48,61,51)
    try:
        file = open(imfile, "rb")
    except:
        print "Couldn't find file:  "+imfile
        raise IOError, "Couldn't find file in brikget()"
    try:
        header = imfile[0:-4]+'HEAD'
        lines = open(header).readlines()
        for i in range(len(lines)):
            if string.find(lines[i],'DATASET_DIMENSIONS') <> -1:
                dims = string.split(lines[i+2][0:string.find(lines[i+2],' 0')])
                dims = map(string.atoi,dims)
            if string.find(lines[i],'BRICK_FLOAT_FACS') <> -1:
                count = string.atoi(string.split(lines[i+1])[2])
                mults = []
                for j in range(int(N.ceil(count/5.))):
                    mults += map(string.atof,string.split(lines[i+2+j]))
                mults = N.array(mults)
        dims.reverse()
        shp = [-1]+dims
    except IOError:
        print "No header file.  Continuing ..."
    lines = None

    print shp
    print 'Using unpackstr:',unpackstr  #,', bytesperpixel=',bytesperpixel

    file = open(imfile, "rb")
    bdata = file.read()

    # the > forces big-endian (for or from Sun/SGI)
    bdata = N.fromstring(bdata,unpackstr)
    littleEndian = ( struct.pack('i',1)==struct.pack('<i',1) )
    if (littleEndian and os.uname()[0]<>'Linux') or (max(bdata)>1e30):
        bdata = bdata.byteswapped()
    try:
        bdata.shape = shp
    except:
        print 'Incorrect shape ...',shp,len(bdata)
        raise ValueError, 'Incorrect shape for file size'
    if len(bdata) == 1:
        bdata = bdata[0]

    if N.sum(mults) == 0:
        return bdata
    try:
        multshape = [1]*len(bdata.shape)
        for i in range(len(bdata.shape)):
            if len(mults) == bdata.shape[i]:
                multshape[i] = len(mults)
                break
        mults.shape = multshape
        return bdata*mults
    except:
        return bdata

def mghbget(imfile,numslices=-1,xsize=64,ysize=64,
           unpackstr=N.int16,bytesperpixel=2.0,sliceinit=0):
    """
Reads in a binary file, typically with a .bshort or .bfloat extension.
If so, the last 3 parameters are set appropriately.  If not, the last 3
parameters default to reading .bshort files (2-byte integers in big-endian
binary format).

Usage:   mghbget(imfile, numslices=-1, xsize=64, ysize=64,
                unpackstr=N.int16, bytesperpixel=2.0, sliceinit=0)
"""
    try:
        file = open(imfile, "rb")
    except:
        print "Couldn't find file:  "+imfile
        raise IOError, "Couldn't find file in bget()"
    try:
        header = imfile[0:-6]+'hdr'
        vals = get(header,0)  # '0' means no missing-file warning msg
        if type(vals[0]) == ListType:  # it's an extended header
            xsize = int(vals[0][0])
            ysize = int(vals[0][1])
            numslices = int(vals[0][2])
        else:
            xsize = int(vals[0])
            ysize = int(vals[1])
            numslices = int(vals[2])
    except:
        print "No header file.  Continuing ..."

    suffix = imfile[-6:]
    if suffix == 'bshort':
        pass
    elif suffix[-3:] == 'img':
        pass
    elif suffix == 'bfloat':
        unpackstr = N.Float32
        bytesperpixel = 4.0
        sliceinit = 0.0
    else:
        print 'Not a bshort, bfloat or img file.'
        print 'Using unpackstr:',unpackstr,', bytesperpixel=',bytesperpixel

    imsize = xsize*ysize
    file = open(imfile, "rb")
    bdata = file.read()

    numpixels = len(bdata) / bytesperpixel
    if numpixels%1 != 0:
        raise ValueError, "Incorrect file size in fmri.bget()"
    else:  # the > forces big-endian (for or from Sun/SGI)
        bdata = N.fromstring(bdata,unpackstr)
        littleEndian = ( struct.pack('i',1)==struct.pack('<i',1) )
#        if littleEndian:
#            bdata = bdata.byteswapped()
        if (littleEndian and os.uname()[0]<>'Linux') or (max(bdata)>1e30):
            bdata = bdata.byteswapped()
    if suffix[-3:] == 'img':
        if numslices == -1:
            numslices = len(bdata)/8200  # 8200=(64*64*2)+8 bytes per image
            xsize = 64
            ysize = 128
        slices = N.zeros((numslices,xsize,ysize),N.Int)
        for i in range(numslices):
            istart = i*8 + i*xsize*ysize
            iend = i*8 + (i+1)*xsize*ysize
            print i, istart,iend
            slices[i] = N.reshape(N.array(bdata[istart:iend]),(xsize,ysize))
    else:
        if numslices == 1:
            slices = N.reshape(N.array(bdata),[xsize,ysize])
        else:
            slices = N.reshape(N.array(bdata),[numslices,xsize,ysize])
    if len(slices) == 1:
        slices = slices[0]
    return slices


def braw(fname,btype,shp=None):
    """
Opens a binary file, unpacks it, and returns a flat array of the
type specified.  Use Numeric types ... N.Float32, N.Int64, etc.

Usage:   braw(fname,btype,shp=None)
Returns: flat array of floats, or ints (if btype=N.int16)
"""
    file = open(fname,'rb')
    bdata = file.read()
    bdata = N.fromstring(bdata,btype)
    littleEndian = ( struct.pack('i',1)==struct.pack('<i',1) )
#    if littleEndian:
#        bdata = bdata.byteswapped()  # didn't used to need this with '>' above
    if (littleEndian and os.uname()[0]<>'Linux') or (max(bdata)>1e30):
        bdata = bdata.byteswapped()
    if shp:
        try:
            bdata.shape = shp
            return bdata
        except:
            pass
    return N.array(bdata)


def glget(fname,btype):
    """
Load in a file containing pixels from glReadPixels dump.

Usage:   glget(fname,btype)
Returns: array of 'btype elements with shape 'shape', suitable for im.ashow()
"""
    d = braw(fname,btype)
    d = d[8:]
    f = open(fname,'rb')
    shp = f.read(8)
    f.close()
    shp = N.fromstring(shp,N.Int)
    shp[0],shp[1] = shp[1],shp[0]
    try:
        carray = N.reshape(d,shp)
        return
    except:
        pass
    try:
        r = d[0::3]+0
        g = d[1::3]+0
        b = d[2::3]+0
        r.shape = shp
        g.shape = shp
        b.shape = shp
        carray = N.array([r,g,b])
    except:
        outstr = "glget: shape not correct for data of length "+str(len(d))
        raise ValueError, outstr
    return carray


def mget(fname,btype):
    """
Load in a file that was saved from matlab

Usage:   mget(fname,btype)
"""
    d = braw(fname,btype)
    try:
        header = fname[0:-6]+'hdr'
        vals = get(header,0)  # '0' means no missing-file warning msg
        if type(vals[0]) == ListType:  # it's an extended header
            xsize = int(vals[0][0])
            ysize = int(vals[0][1])
            numslices = int(vals[0][2])
        else:
            xsize = int(vals[0])
            ysize = int(vals[1])
            numslices = int(vals[2])
        print xsize,ysize,numslices, d.shape
    except:
        print "No header file.  Continuing ..."
    if numslices == 1:
        d.shape = [ysize,xsize]
        return N.transpose(d)*1
    else:
        d.shape = [numslices,ysize,xsize]
        return N.transpose(d)*1


def mput(outarray,fname,writeheader=0,btype=N.int16):
    """
Save a file for use in matlab.
"""
    outarray = N.transpose(outarray)
    outdata = N.ravel(outarray).astype(btype)
    outdata = outdata.tostring()
    outfile = open(fname,'wb')
    outfile.write(outdata)
    outfile.close()
    if writeheader == 1:
        try:
            suffixindex = string.rfind(fname,'.')
            hdrname = fname[0:suffixindex]
        except ValueError:
            hdrname = fname
        if len(outarray.shape) == 2:
            hdr = [outarray.shape[1],outarray.shape[0], 1, 0]
        else:
            hdr = [outarray.shape[2],outarray.shape[1],outarray.shape[0], 0,'\n']
        print hdrname+'.hdr'
        outfile = open(hdrname+'.hdr','w')
        outfile.write(pstat.list2string(hdr))
        outfile.close()
    return None


def bput(outarray,fname,writeheader=0,packtype=N.int16,writetype='wb'):
    """
Writes the passed array to a binary output file, and then closes
the file.  Default is overwrite the destination file.

Usage:   bput (outarray,filename,writeheader=0,packtype=N.int16,writetype='wb')
"""
    suffix = fname[-6:]
    if suffix == 'bshort':
        packtype = N.int16
    elif suffix == 'bfloat':
        packtype = N.Float32
    else:
        print 'Not a bshort or bfloat file.  Using packtype=',packtype

    outdata = N.ravel(outarray).astype(packtype)
    littleEndian = ( struct.pack('i',1)==struct.pack('<i',1) )
    if littleEndian and os.uname()[0]<>'Linux':
        outdata = outdata.byteswapped()
    outdata = outdata.tostring()
    outfile = open(fname,writetype)
    outfile.write(outdata)
    outfile.close()
    if writeheader == 1:
        try:
            suffixindex = string.rfind(fname,'.')
            hdrname = fname[0:suffixindex]
        except ValueError:
            hdrname = fname
        if len(outarray.shape) == 2:
            hdr = [outarray.shape[0],outarray.shape[1], 1, 0]
        else:
            hdr = [outarray.shape[1],outarray.shape[2],outarray.shape[0], 0,'\n']
        print hdrname+'.hdr'
        outfile = open(hdrname+'.hdr','w')
        outfile.write(pstat.list2string(hdr))
        outfile.close()
    return None


def mrget(fname,datatype=N.int16):
    """
Opens a binary .MR file and clips off the tail data portion of it, returning
the result as an array.

Usage:   mrget(fname,datatype=N.int16)
"""
    d = braw(fname,datatype)
    if len(d) > 512*512:
        return N.reshape(d[-512*512:],(512,512))
    elif len(d) > 256*256:
        return N.reshape(d[-256*256:],(256,256))
    elif len(d) > 128*128:
        return N.reshape(d[-128*128:],(128,128))
    elif len(d) > 64*64:
        return N.reshape(d[-64*64:],(64,64))
    else:
        return N.reshape(d[-32*32:],(32,32))


def quickload(fname,linestocut=4):
    """
Quickly loads in a long text file, chopping off first n 'linestocut'.

Usage:   quickload(fname,linestocut=4)
Returns: array filled with data in fname
"""
    f = open(fname,'r')
    d = f.readlines()
    f.close()
    print fname,'read in.'
    d = d[linestocut:]
    d = map(string.split,d)
    print 'Done with string.split on lines.'
    for i in range(len(d)):
        d[i] = map(string.atoi,d[i])
    print 'Conversion to ints done.'
    return N.array(d)

def writedelimited (listoflists, delimiter, file, writetype='w'):
    """
Writes a list of lists in columns, separated by character(s) delimiter
to specified file.  File-overwrite is the default.

Usage:   writedelimited (listoflists,delimiter,filename,writetype='w')
Returns: None
"""
    if type(listoflists[0]) not in [ListType,TupleType]:
        listoflists = [listoflists]
    outfile = open(file,writetype)
    rowstokill = []
    list2print = copy.deepcopy(listoflists)
    for i in range(len(listoflists)):
        if listoflists[i] == ['\n'] or listoflists[i]=='\n' or listoflists[i]=='dashes':
            rowstokill = rowstokill + [i]
    rowstokill.reverse()
    for row in rowstokill:
        del list2print[row]
    maxsize = [0]*len(list2print[0])
    for row in listoflists:
        if row == ['\n'] or row == '\n':
            outfile.write('\n')
        elif row == ['dashes'] or row == 'dashes':
            dashes = [0]*len(maxsize)
            for j in range(len(maxsize)):
                dashes[j] = '------'
            outfile.write(pstat.linedelimited(dashes,delimiter))
        else:
            outfile.write(pstat.linedelimited(row,delimiter))
        outfile.write('\n')
    outfile.close()
    return None

def writecc (listoflists,file,writetype='w',extra=2):
    """
Writes a list of lists to a file in columns, customized by the max
size of items within the columns (max size of items in col, +2 characters)
to specified file.  File-overwrite is the default.

Usage:   writecc (listoflists,file,writetype='w',extra=2)
Returns: None
"""
    if type(listoflists[0]) not in [ListType,TupleType]:
        listoflists = [listoflists]
    outfile = open(file,writetype)
    rowstokill = []
    list2print = copy.deepcopy(listoflists)
    for i in range(len(listoflists)):
        if listoflists[i] == ['\n'] or listoflists[i]=='\n' or listoflists[i]=='dashes':
            rowstokill = rowstokill + [i]
    rowstokill.reverse()
    for row in rowstokill:
        del list2print[row]
    maxsize = [0]*len(list2print[0])
    for col in range(len(list2print[0])):
        items = pstat.colex(list2print,col)
        items = map(pstat.makestr,items)
        maxsize[col] = max(map(len,items)) + extra
    for row in listoflists:
        if row == ['\n'] or row == '\n':
            outfile.write('\n')
        elif row == ['dashes'] or row == 'dashes':
            dashes = [0]*len(maxsize)
            for j in range(len(maxsize)):
                dashes[j] = '-'*(maxsize[j]-2)
            outfile.write(pstat.lineincustcols(dashes,maxsize))
        else:
            outfile.write(pstat.lineincustcols(row,maxsize))
        outfile.write('\n')
    outfile.close()
    return None


def writefc (listoflists,colsize,file,writetype='w'):
    """
Writes a list of lists to a file in columns of fixed size.  File-overwrite
is the default.

Usage:   writefc (listoflists,colsize,file,writetype='w')
Returns: None
"""
    if type(listoflists) == N.ArrayType:
        listoflists = listoflists.tolist()
    if type(listoflists[0]) not in [ListType,TupleType]:
        listoflists = [listoflists]
    outfile = open(file,writetype)
    rowstokill = []
    list2print = copy.deepcopy(listoflists)
    for i in range(len(listoflists)):
        if listoflists[i] == ['\n'] or listoflists[i]=='\n' or listoflists[i]=='dashes':
            rowstokill = rowstokill + [i]
    rowstokill.reverse()
    for row in rowstokill:
        del list2print[row]
    n = [0]*len(list2print[0])
    for row in listoflists:
        if row == ['\n'] or row == '\n':
            outfile.write('\n')
        elif row == ['dashes'] or row == 'dashes':
            dashes = [0]*colsize
            for j in range(len(n)):
                dashes[j] = '-'*(colsize)
            outfile.write(pstat.lineincols(dashes,colsize))
        else:
            outfile.write(pstat.lineincols(row,colsize))
        outfile.write('\n')
    outfile.close()
    return None


def load(fname,lines_to_ignore=4,type='i'):
    """
Load in huge, flat, 2D text files.  Can handle differing line-lengths AND
can strip #/% on UNIX (or with a better NT grep).  Requires wc, grep, and
mmapfile.lib/.pyd. Type can be 'i', 'f' or 'd', for ints, floats or doubles,
respectively.  Lines_to_ignore determines how many lines at the start of the
file to ignore (required for non-working grep).

Usage:   load(fname,lines_to_ignore=4,type='i')
Returns: numpy array of specified type
"""
    start = time.time()      ## START TIMER
    if type == 'i':
        intype = int
    elif type in ['f','d']:
        intype = float
    else:
        raise ValueError, "type can be 'i', 'f' or 'd' in load()"

    ## STRIP OUT % AND # LINES
    tmpname = tempfile.mktemp()
    if sys.platform == 'win32':
        # NT VERSION OF GREP DOESN'T DO THE STRIPPING ... SIGH
        cmd = "grep.exe -v \'%\' "+fname+" > "+tmpname
        print cmd
        os.system(cmd)
    else:
        # UNIX SIDE SHOULD WORK
        cmd = "cat "+fname+" | grep -v \'%\' |grep -v \'#\' > "+tmpname
        print cmd
        os.system(cmd)

    ## GET NUMBER OF ROWS, COLUMNS AND LINE-LENGTH, USING WC
    wc = string.split(os.popen("wc "+tmpname).read())
    numlines = int(wc[0]) - lines_to_ignore
    tfp = open(tmpname)
    if lines_to_ignore <> 0:
        for i in range(lines_to_ignore):
            junk = tfp.readline()
    numcols = len(string.split(tfp.readline())) #int(float(wc[1])/numlines)
    tfp.close()

    ## PREPARE INPUT SPACE
    a = N.zeros((numlines*numcols), type)
    block = 65536  # chunk to read, in bytes
    data = mmapfile.mmapfile(tmpname, '', 0)
    if lines_to_ignore <> 0 and sys.platform == 'win32':
        for i in range(lines_to_ignore):
            junk = data.readline()
    i = 0
    d = ' '
    carryover = ''
    while len(d) <> 0:
        d = carryover + data.read(block)
        cutindex = string.rfind(d,'\n')
        carryover = d[cutindex+1:]
        d = d[:cutindex+1]
        d = map(intype,string.split(d))
        a[i:i+len(d)] = d
        i = i + len(d)
    end = time.time()
    print "%d sec" % round(end-start,2)
    data.close()
    os.remove(tmpname)
    return N.reshape(a,[numlines,numcols])


def find_dirs(sourcedir):
    """Finds and returns all directories in sourcedir

Usage:   find_dirs(sourcedir)
Returns: list of directory names (potentially empty)
"""
    files = os.listdir(sourcedir)
    dirs = []
    for fname in files:
        if os.path.isdir(os.path.join(sourcedir,fname)):
            dirs.append(fname)
    return dirs


# ALIASES ...
save = aput



def binget(fname,btype=None):
    """
Loads a binary file from disk. Assumes associated hdr file is in same
location. You can force an unpacking type, or else it tries to figure
it out from the filename (4th-to-last character). Hence, readable file
formats are ...

1bin=Int8, sbin=int16, ibin=Int32, fbin=Float32, dbin=Float64, etc.

Usage:   binget(fname,btype=None)
Returns: data in file fname of type btype
"""
    file = open(fname,'rb')
    bdata = file.read()
    file.close()

    # if none given, assume character preceeding 'bin' is the unpacktype
    if not btype:
        btype = fname[-4]
    try:
        bdata = N.fromstring(bdata,btype)
    except:
        raise ValueError, "Bad unpacking type."

    # force the data on disk to be LittleEndian (for more efficient PC/Linux use)
    if not N.LittleEndian:
        bdata = bdata.byteswapped()

    try:
        header = fname[:-3]+'hdr'
        vals = get(header,0)  # '0' means no missing-file warning msg
        print vals
        if type(vals[0]) == ListType:  # it's an extended header
            xsize = int(vals[0][0])
            ysize = int(vals[0][1])
            numslices = int(vals[0][2])
        else:
            bdata.shape = vals
    except:
        print "No (or bad) header file. Returning unshaped array."
    return N.array(bdata)



def binput(outarray,fname,packtype=None,writetype='wb'):
    """
Unravels outarray and writes the data to a file, always in LittleEndian
format, along with a header file containing the original data shape. Default
is overwrite the destination file. Tries to figure out packtype from
4th-to-last character in filename. Thus, the routine understands these
file formats ...

1bin=Int8, sbin=int16, ibin=Int32, fbin=Float32, dbin=Float64, etc.

Usage:  binput(outarray,filename,packtype=None,writetype='wb')
"""
    if not packtype:
        packtype = fname[-4]

    # a speck of error checking
    if packtype == N.int16 and outarray.typecode() == 'f':
        # check to see if there's data loss
        if max(N.ravel(outarray)) > 32767 or min(N.ravel(outarray))<-32768:
            print "*** WARNING: CONVERTING FLOAT DATA TO OUT-OF RANGE int16 DATA"
    outdata = N.ravel(outarray).astype(packtype)

    # force the data on disk to be LittleEndian (for more efficient PC/Linux use)
    if not N.LittleEndian:
        outdata = outdata.byteswapped()
    outdata = outdata.tostring()
    outfile = open(fname,writetype)
    outfile.write(outdata)
    outfile.close()

    # Now, write the header file
    try:
        suffixindex = string.rfind(fname,'.')
        hdrname = fname[0:suffixindex+2]+'hdr'  # include .s or .f or .1 or whatever
    except ValueError:
        hdrname = fname
    hdr = outarray.shape
    print hdrname
    outfile = open(hdrname,'w')
    outfile.write(pstat.list2string(hdr))
    outfile.close()
    return None

def array2afni(d,brikprefix,voltype=None,TR=2.0,sliceorder='seqplus',geomparent=None,view=None):
    """
Converts an array 'd' to an AFNI BRIK/HEAD combo via putbin and to3d. Tries to
guess the AFNI volume type

voltype = {'-anat','-epan','-fim'}
geomparent = filename of the afni BRIK file with the same geometry
view = {'tlrc', 'acpc' or 'orig'}

Usage:   array2afni(d,brikprefix,voltype=None,TR=2.0,
                    sliceorder='seqplus',geomparent=None,view=None)
Returns: None
"""
    # converts Numeric typecode()s into appropriate strings for to3d command line
    typecodemapping = {'c':'b',  # character
                       'b':'b',  # UnsignedInt8
                       'f':'f',  # Float0, Float8, Float16, Float32
                       'd':'f',  # Float64
                       '1':'b',  # Int0, Int8
                       's':'',  # int16
                       'i':'i',  # Int32
                       'l':'i'}  # Int

    # Verify that the data is proper size (3- or 4-D)
    if len(d.shape) not in [3,4]:
        raise ValueError, "A 3D or 4D array is required for array2afni() ... %s" %d.shape

    # Save out the array to a binary file, homebrew style
    if d.typecode() == N.Float64:
        outcode = 'f'
    else:
        outcode = d.typecode()
    tmpoutname = 'afnitmp.%sbin' % outcode
    binput(d.astype(outcode),tmpoutname)
    if not voltype:
        if len(d.shape) == 3:  # either anatomy or functional
            if d.typecode() in ['s','i','l']:  # if floats, assume functional
                voltype = '-anat'
            else:
                voltype = '-fim'
        else:  # 4D dataset, must be anatomical timeseries (epan)
            voltype = '-anat'
    if len(d.shape) == 3:  # either anatomy or functional
        timepts = 1
        slices = d.shape[0]
        timestr = ''
    elif len(d.shape) == 4:
        timepts = d.shape[0]
        slices = d.shape[1]
        timestr = '-time:zt %d %d %0.3f %s ' % (slices,timepts,TR,sliceorder)

    cmd = 'to3d %s -prefix %s -session . ' % (voltype, brikprefix)
    if view:
        cmd += '-view %s ' % view
    if geomparent:
        cmd += '-geomparent %s ' % geomparent
    cmd += timestr
    cmd += '3D%s:0:0:%d:%d:%d:%s' % (typecodemapping[d.typecode()],d.shape[-1],d.shape[-2],slices*timepts,tmpoutname)
    print cmd
    os.system(cmd)
    os.remove(tmpoutname)
    os.remove(tmpoutname[:-3]+'hdr')

########NEW FILE########
__FILENAME__ = matfunc
'''Basic Table, Matrix and Vector functions for Python 2.2
   License:  Public Domain     Author:   Raymond Hettinger email:  python@rcn.com
   Updates and documentation:  http://users.rcn.com/python/download/python.htm
   Revision In Use:  'File %n, Ver %v, Date %f'                             '''
Version = 'File MATFUNC.PY, Ver 183, Date 12-Dec-2002,14:33:42'

import operator, math, random
NPRE, NPOST = 0, 0                    # Disables pre and post condition checks

def iszero(z):  return abs(z) < .000001
def getreal(z):
    try:
        return z.real
    except AttributeError:
        return z
def getimag(z):
    try:
        return z.imag
    except AttributeError:
        return 0
def getconj(z):
    try:
        return z.conjugate()
    except AttributeError:
        return z


separator = [ '', '\t', '\n', '\n----------\n', '\n===========\n' ]

class Table(list):
    dim = 1
    concat = list.__add__      # A substitute for the overridden __add__ method
    def __getslice__( self, i, j ):
        return self.__class__( list.__getslice__(self,i,j) )
    def __init__( self, elems ):
        list.__init__( self, elems )
        if len(elems) and hasattr(elems[0], 'dim'): self.dim = elems[0].dim + 1
    def __str__( self ):
        return separator[self.dim].join( map(str, self) )
    def map( self, op, rhs=None ):
        '''Apply a unary operator to every element in the matrix or a binary operator to corresponding
        elements in two arrays.  If the dimensions are different, broadcast the smaller dimension over
        the larger (i.e. match a scalar to every element in a vector or a vector to a matrix).'''
        if rhs is None:                                                 # Unary case
            return self.dim==1 and self.__class__( map(op, self) ) or self.__class__( [elem.map(op) for elem in self] )
        elif not hasattr(rhs,'dim'):                                    # List / Scalar op
            return self.__class__( [op(e,rhs) for e in self] )
        elif self.dim == rhs.dim:                                       # Same level Vec / Vec or Matrix / Matrix
            assert NPRE or len(self) == len(rhs), 'Table operation requires len sizes to agree'
            return self.__class__( map(op, self, rhs) )
        elif self.dim < rhs.dim:                                        # Vec / Matrix
            return self.__class__( [op(self,e) for e in rhs]  )
        return self.__class__( [op(e,rhs) for e in self] )         # Matrix / Vec
    def __mul__( self, rhs ):  return self.map( operator.mul, rhs )
    def __div__( self, rhs ):  return self.map( operator.div, rhs )
    def __sub__( self, rhs ):  return self.map( operator.sub, rhs )
    def __add__( self, rhs ):  return self.map( operator.add, rhs )
    def __rmul__( self, lhs ):  return self*lhs
    def __rdiv__( self, lhs ):  return self*(1.0/lhs)
    def __rsub__( self, lhs ):  return -(self-lhs)
    def __radd__( self, lhs ):  return self+lhs
    def __abs__( self ): return self.map( abs )
    def __neg__( self ): return self.map( operator.neg )
    def conjugate( self ): return self.map( getconj )
    def real( self ): return self.map( getreal  )
    def imag( self ): return self.map( getimag )
    def flatten( self ):
        if self.dim == 1: return self
        return reduce( lambda cum, e: e.flatten().concat(cum), self, [] )
    def prod( self ):  return reduce(operator.mul, self.flatten(), 1.0)
    def sum( self ):  return reduce(operator.add, self.flatten(), 0.0)
    def exists( self, predicate ):
        for elem in self.flatten():
            if predicate(elem):
                return 1
        return 0
    def forall( self, predicate ):
        for elem in self.flatten():
            if not predicate(elem):
                return 0
        return 1
    def __eq__( self, rhs ):  return (self - rhs).forall( iszero )

class Vec(Table):
    def dot( self, otherVec ):  return reduce(operator.add, map(operator.mul, self, otherVec), 0.0)
    def norm( self ):  return math.sqrt(abs( self.dot(self.conjugate()) ))
    def normalize( self ):  return self / self.norm()
    def outer( self, otherVec ):  return Mat([otherVec*x for x in self])
    def cross( self, otherVec ):
        'Compute a Vector or Cross Product with another vector'
        assert len(self) == len(otherVec) == 3, 'Cross product only defined for 3-D vectors'
        u, v = self, otherVec
        return Vec([ u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0] ])
    def house( self, index ):
        'Compute a Householder vector which zeroes all but the index element after a reflection'
        v = Vec( Table([0]*index).concat(self[index:]) ).normalize()
        t = v[index]
        sigma = 1.0 - t**2
        if sigma != 0.0:
            t = v[index] = t<=0 and t-1.0 or -sigma / (t + 1.0)
            v /= t
        return v, 2.0 * t**2 / (sigma + t**2)
    def polyval( self, x ):
        'Vec([6,3,4]).polyval(5) evaluates to 6*x**2 + 3*x + 4 at x=5'
        return reduce( lambda cum,c: cum*x+c, self, 0.0 )
    def ratval( self, x ):
        'Vec([10,20,30,40,50]).ratfit(5) evaluates to (10*x**2 + 20*x + 30) / (40*x**2 + 50*x + 1) at x=5.'
        degree = len(self) / 2
        num, den = self[:degree+1], self[degree+1:] + [1]
        return num.polyval(x) / den.polyval(x)

class Matrix(Table):
    __slots__ = ['size', 'rows', 'cols']
    def __init__( self, elems ):
        'Form a matrix from a list of lists or a list of Vecs'
        Table.__init__( self, hasattr(elems[0], 'dot') and elems or map(Vec,map(tuple,elems)) )
        self.size = self.rows, self.cols = len(elems), len(elems[0])
    def tr( self ):
        'Tranpose elements so that Transposed[i][j] = Original[j][i]'
        return Mat(zip(*self))
    def star( self ):
        'Return the Hermetian adjoint so that Star[i][j] = Original[j][i].conjugate()'
        return self.tr().conjugate()
    def diag( self ):
        'Return a vector composed of elements on the matrix diagonal'
        return Vec( [self[i][i] for i in range(min(self.size))] )
    def trace( self ): return self.diag().sum()
    def mmul( self, other ):
        'Matrix multiply by another matrix or a column vector '
        if other.dim==2: return Mat( map(self.mmul, other.tr()) ).tr()
        assert NPRE or self.cols == len(other)
        return Vec( map(other.dot, self) )
    def augment( self, otherMat ):
        'Make a new matrix with the two original matrices laid side by side'
        assert self.rows == otherMat.rows, 'Size mismatch: %s * %s' % (`self.size`, `otherMat.size`)
        return Mat( map(Table.concat, self, otherMat) )
    def qr( self, ROnly=0 ):
        'QR decomposition using Householder reflections: Q*R==self, Q.tr()*Q==I(n), R upper triangular'
        R = self
        m, n = R.size
        for i in range(min(m,n)):
            v, beta = R.tr()[i].house(i)
            R -= v.outer( R.tr().mmul(v)*beta )
        for i in range(1,min(n,m)): R[i][:i] = [0] * i
        R = Mat(R[:n])
        if ROnly: return R
        Q = R.tr().solve(self.tr()).tr()       # Rt Qt = At    nn  nm  = nm
        self.qr = lambda r=0, c=`self`: not r and c==`self` and (Q,R) or Matrix.qr(self,r) #Cache result
        assert NPOST or m>=n and Q.size==(m,n) and isinstance(R,UpperTri) or m<n and Q.size==(m,m) and R.size==(m,n)
        assert NPOST or Q.mmul(R)==self and Q.tr().mmul(Q)==eye(min(m,n))
        return Q, R
    def _solve( self, b ):
        '''General matrices (incuding) are solved using the QR composition.
        For inconsistent cases, returns the least squares solution'''
        Q, R = self.qr()
        return R.solve( Q.tr().mmul(b) )
    def solve( self, b ):
        'Divide matrix into a column vector or matrix and iterate to improve the solution'
        if b.dim==2: return Mat( map(self.solve, b.tr()) ).tr()
        assert NPRE or self.rows == len(b), 'Matrix row count %d must match vector length %d' % (self.rows, len(b))
        x = self._solve( b )
        diff = b - self.mmul(x)
        maxdiff = diff.dot(diff)
        for i in range(10):
            xnew = x + self._solve( diff )
            diffnew = b - self.mmul(xnew)
            maxdiffnew = diffnew.dot(diffnew)
            if maxdiffnew >= maxdiff:  break
            x, diff, maxdiff = xnew, diffnew, maxdiffnew
            #print >> sys.stderr, i+1, maxdiff
        assert NPOST or self.rows!=self.cols or self.mmul(x) == b
        return x
    def rank( self ):  return Vec([ not row.forall(iszero) for row in self.qr(ROnly=1) ]).sum()

class Square(Matrix):
    def lu( self ):
        'Factor a square matrix into lower and upper triangular form such that L.mmul(U)==A'
        n = self.rows
        L, U = eye(n), Mat(self[:])
        for i in range(n):
            for j in range(i+1,U.rows):
                assert U[i][i] != 0.0, 'LU requires non-zero elements on the diagonal'
                L[j][i] = m = 1.0 * U[j][i] / U[i][i]
                U[j] -= U[i] * m
        assert NPOST or isinstance(L,LowerTri) and isinstance(U,UpperTri) and L*U==self
        return L, U
    def __pow__( self, exp ):
        'Raise a square matrix to an integer power (i.e. A**3 is the same as A.mmul(A.mmul(A))'
        assert NPRE or exp==int(exp) and exp>0, 'Matrix powers only defined for positive integers not %s' % exp
        if exp == 1: return self
        if exp&1: return self.mmul(self ** (exp-1))
        sqrme = self ** (exp/2)
        return sqrme.mmul(sqrme)
    def det( self ):  return self.qr( ROnly=1 ).det()
    def inverse( self ):  return self.solve( eye(self.rows) )
    def hessenberg( self ):
        '''Householder reduction to Hessenberg Form (zeroes below the diagonal)
        while keeping the same eigenvalues as self.'''
        for i in range(self.cols-2):
            v, beta = self.tr()[i].house(i+1)
            self -= v.outer( self.tr().mmul(v)*beta )
            self -= self.mmul(v).outer(v*beta)
        return self
    def eigs( self ):
        'Estimate principal eigenvalues using the QR with shifts method'
        origTrace, origDet = self.trace(), self.det()
        self = self.hessenberg()
        eigvals = Vec([])
        for i in range(self.rows-1,0,-1):
            while not self[i][:i].forall(iszero):
                shift = eye(i+1) * self[i][i]
                q, r = (self - shift).qr()
                self = r.mmul(q) + shift
            eigvals.append( self[i][i] )
            self = Mat( [self[r][:i] for r in range(i)] )
        eigvals.append( self[0][0] )
        assert NPOST or iszero( (abs(origDet) - abs(eigvals.prod())) / 1000.0 )
        assert NPOST or iszero( origTrace - eigvals.sum() )
        return Vec(eigvals)

class Triangular(Square):
    def eigs( self ):  return self.diag()
    def det( self ):  return self.diag().prod()

class UpperTri(Triangular):
    def _solve( self, b ):
        'Solve an upper triangular matrix using backward substitution'
        x = Vec([])
        for i in range(self.rows-1, -1, -1):
            assert NPRE or self[i][i], 'Backsub requires non-zero elements on the diagonal'
            x.insert(0, (b[i] - x.dot(self[i][i+1:])) / self[i][i] )
        return x

class LowerTri(Triangular):
    def _solve( self, b ):
        'Solve a lower triangular matrix using forward substitution'
        x = Vec([])
        for i in range(self.rows):
            assert NPRE or self[i][i], 'Forward sub requires non-zero elements on the diagonal'
            x.append( (b[i] - x.dot(self[i][:i])) / self[i][i] )
        return x

def Mat( elems ):
    'Factory function to create a new matrix.'
    m, n = len(elems), len(elems[0])
    if m != n: return Matrix(elems)
    if n <= 1: return Square(elems)
    for i in range(1, len(elems)):
        if not iszero( max(map(abs, elems[i][:i])) ):
            break
    else: return UpperTri(elems)
    for i in range(0, len(elems)-1):
        if not iszero( max(map(abs, elems[i][i+1:])) ):
            return Square(elems)
    return LowerTri(elems)


def funToVec( tgtfun, low=-1, high=1, steps=40, EqualSpacing=0 ):
    '''Compute x,y points from evaluating a target function over an interval (low to high)
    at evenly spaces points or with Chebyshev abscissa spacing (default) '''
    if EqualSpacing:
        h = (0.0+high-low)/steps
        xvec = [low+h/2.0+h*i for i in range(steps)]
    else:
        scale, base = (0.0+high-low)/2.0, (0.0+high+low)/2.0
        xvec = [base+scale*math.cos(((2*steps-1-2*i)*math.pi)/(2*steps)) for i in range(steps)]
    yvec = map(tgtfun, xvec)
    return Mat( [xvec, yvec] )

def funfit( (xvec, yvec), basisfuns ):
    'Solves design matrix for approximating to basis functions'
    return Mat([ map(form,xvec) for form in basisfuns ]).tr().solve(Vec(yvec))

def polyfit( (xvec, yvec), degree=2 ):
    'Solves Vandermonde design matrix for approximating polynomial coefficients'
    return Mat([ [x**n for n in range(degree,-1,-1)] for x in xvec ]).solve(Vec(yvec))

def ratfit( (xvec, yvec), degree=2 ):
    'Solves design matrix for approximating rational polynomial coefficients (a*x**2 + b*x + c)/(d*x**2 + e*x + 1)'
    return Mat([[x**n for n in range(degree,-1,-1)]+[-y*x**n for n in range(degree,0,-1)] for x,y in zip(xvec,yvec)]).solve(Vec(yvec))

def genmat(m, n, func):
    if not n: n=m
    return Mat([ [func(i,j) for i in range(n)] for j in range(m) ])

def zeroes(m=1, n=None):
    'Zero matrix with side length m-by-m or m-by-n.'
    return genmat(m,n, lambda i,j: 0)

def eye(m=1, n=None):
    'Identity matrix with side length m-by-m or m-by-n'
    return genmat(m,n, lambda i,j: i==j)

def hilb(m=1, n=None):
    'Hilbert matrix with side length m-by-m or m-by-n.  Elem[i][j]=1/(i+j+1)'
    return genmat(m,n, lambda i,j: 1.0/(i+j+1.0))

def rand(m=1, n=None):
    'Random matrix with side length m-by-m or m-by-n'
    return genmat(m,n, lambda i,j: random.random())

if __name__ == '__main__':
    import cmath
    a = Table([1+2j,2,3,4])
    b = Table([5,6,7,8])
    C = Table([a,b])
    print 'a+b', a+b
    print '2+a', 2+a
    print 'a/5.0', a/5.0
    print '2*a+3*b', 2*a+3*b
    print 'a+C', a+C
    print '3+C', 3+C
    print 'C+b', C+b
    print 'C.sum()', C.sum()
    print 'C.map(math.cos)', C.map(cmath.cos)
    print 'C.conjugate()', C.conjugate()
    print 'C.real()', C.real()

    print zeroes(3)
    print eye(4)
    print hilb(3,5)

    C = Mat( [[1,2,3], [4,5,1,], [7,8,9]] )
    print C.mmul( C.tr()), '\n'
    print C ** 5, '\n'
    print C + C.tr(), '\n'

    A = C.tr().augment( Mat([[10,11,13]]).tr() ).tr()
    q, r = A.qr()
    assert q.mmul(r) == A
    assert q.tr().mmul(q)==eye(3)
    print 'q:\n', q, '\nr:\n', r, '\nQ.tr()&Q:\n', q.tr().mmul(q), '\nQ*R\n', q.mmul(r), '\n'
    b = Vec([50, 100, 220, 321])
    x = A.solve(b)
    print 'x:  ', x
    print 'b:  ', b
    print 'Ax: ', A.mmul(x)

    inv = C.inverse()
    print '\ninverse C:\n', inv, '\nC * inv(C):\n', C.mmul(inv)
    assert C.mmul(inv) == eye(3)

    points = (xvec,yvec) = funToVec(lambda x: math.sin(x)+2*math.cos(.7*x+.1), low=0, high=3, EqualSpacing=1)
    basis = [lambda x: math.sin(x), lambda x: math.exp(x), lambda x: x**2]
    print 'Func coeffs:', funfit( points, basis )
    print 'Poly coeffs:', polyfit( points, degree=5 )
    points = (xvec,yvec) = funToVec(lambda x: math.sin(x)+2*math.cos(.7*x+.1), low=0, high=3)
    print 'Rational coeffs:', ratfit( points )

    print polyfit(([1,2,3,4], [1,4,9,16]), 2)

    mtable = Vec([1,2,3]).outer(Vec([1,2]))
    print mtable, mtable.size

    A = Mat([ [2,0,3], [1,5,1], [18,0,6] ])
    print 'A:'
    print A
    print 'eigs:'
    print A.eigs()
    print 'Should be:', Vec([11.6158, 5.0000, -3.6158])
    print 'det(A)'
    print A.det()

    c = Mat( [[1,2,30],[4,5,10],[10,80,9]] )     # Failed example from Konrad Hinsen
    print 'C:\n', c
    print c.eigs()
    print 'Should be:', Vec([-8.9554, 43.2497, -19.2943])

    A = Mat([ [1,2,3,4], [4,5,6,7], [2,1,5,0], [4,2,1,0] ] )    # Kincaid and Cheney p.326
    print 'A:\n', A
    print A.eigs()
    print 'Should be:', Vec([3.5736, 0.1765, 11.1055, -3.8556])

    A = rand(3)
    q,r = A.qr()
    s,t = A.qr()
    print q is s                # Test caching
    print r is t
    A[1][1] = 1.1               # Invalidate the cache
    u,v = A.qr()
    print q is u                # Verify old result not used
    print r is v
    print u.mmul(v) == A        # Verify new result

    print 'Test qr on 3x5 matrix'
    a = rand(3,5)
    q,r = a.qr()
    print q.mmul(r) == a
    print q.tr().mmul(q) == eye(3)


########NEW FILE########
__FILENAME__ = pstat
# Copyright (c) 1999-2007 Gary Strangman; All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# Comments and/or additions are welcome (send e-mail to:
# strang@nmr.mgh.harvard.edu).
# 
"""
pstat.py module

#################################################
#######  Written by:  Gary Strangman  ###########
#######  Last modified:  Dec 18, 2007 ###########
#################################################

This module provides some useful list and array manipulation routines
modeled after those found in the |Stat package by Gary Perlman, plus a
number of other useful list/file manipulation functions.  The list-based
functions include:

      abut (source,*args)
      simpleabut (source, addon)
      colex (listoflists,cnums)
      collapse (listoflists,keepcols,collapsecols,fcn1=None,fcn2=None,cfcn=None)
      dm (listoflists,criterion)
      flat (l)
      linexand (listoflists,columnlist,valuelist)
      linexor (listoflists,columnlist,valuelist)
      linedelimited (inlist,delimiter)
      lineincols (inlist,colsize) 
      lineincustcols (inlist,colsizes)
      list2string (inlist)
      makelol(inlist)
      makestr(x)
      printcc (lst,extra=2)
      printincols (listoflists,colsize)
      pl (listoflists)
      printl(listoflists)
      replace (lst,oldval,newval)
      recode (inlist,listmap,cols='all')
      remap (listoflists,criterion)
      roundlist (inlist,num_digits_to_round_floats_to)
      sortby(listoflists,sortcols)
      unique (inlist)
      duplicates(inlist)
      writedelimited (listoflists, delimiter, file, writetype='w')

Some of these functions have alternate versions which are defined only if
Numeric (NumPy) can be imported.  These functions are generally named as
above, with an 'a' prefix.

      aabut (source, *args)
      acolex (a,indices,axis=1)
      acollapse (a,keepcols,collapsecols,sterr=0,ns=0)
      adm (a,criterion)
      alinexand (a,columnlist,valuelist)
      alinexor (a,columnlist,valuelist)
      areplace (a,oldval,newval)
      arecode (a,listmap,col='all')
      arowcompare (row1, row2)
      arowsame (row1, row2)
      asortrows(a,axis=0)
      aunique(inarray)
      aduplicates(inarray)

Currently, the code is all but completely un-optimized.  In many cases, the
array versions of functions amount simply to aliases to built-in array
functions/methods.  Their inclusion here is for function name consistency.
"""

## CHANGE LOG:
## ==========
## 07-11-26 ... edited to work with numpy
## 01-11-15 ... changed list2string() to accept a delimiter
## 01-06-29 ... converted exec()'s to eval()'s to make compatible with Py2.1
## 01-05-31 ... added duplicates() and aduplicates() functions
## 00-12-28 ... license made GPL, docstring and import requirements
## 99-11-01 ... changed version to 0.3
## 99-08-30 ... removed get, getstrings, put, aget, aput (into io.py)
## 03/27/99 ... added areplace function, made replace fcn recursive
## 12/31/98 ... added writefc function for ouput to fixed column sizes
## 12/07/98 ... fixed import problem (failed on collapse() fcn)
##              added __version__ variable (now 0.2)
## 12/05/98 ... updated doc-strings
##              added features to collapse() function
##              added flat() function for lists
##              fixed a broken asortrows() 
## 11/16/98 ... fixed minor bug in aput for 1D arrays
##
## 11/08/98 ... fixed aput to output large arrays correctly

import stats  # required 3rd party module
import string, copy
from types import *

__version__ = 0.4

###===========================  LIST FUNCTIONS  ==========================
###
### Here are the list functions, DEFINED FOR ALL SYSTEMS.
### Array functions (for NumPy-enabled computers) appear below.
###

def abut (source,*args):
    """
Like the |Stat abut command.  It concatenates two lists side-by-side
and returns the result.  '2D' lists are also accomodated for either argument
(source or addon).  CAUTION:  If one list is shorter, it will be repeated
until it is as long as the longest list.  If this behavior is not desired,
use pstat.simpleabut().

Usage:   abut(source, args)   where args=any # of lists
Returns: a list of lists as long as the LONGEST list past, source on the
         'left', lists in <args> attached consecutively on the 'right'
"""

    if type(source) not in [ListType,TupleType]:
        source = [source]
    for addon in args:
        if type(addon) not in [ListType,TupleType]:
            addon = [addon]
        if len(addon) < len(source):                # is source list longer?
            if len(source) % len(addon) == 0:        # are they integer multiples?
                repeats = len(source)/len(addon)    # repeat addon n times
                origadd = copy.deepcopy(addon)
                for i in range(repeats-1):
                    addon = addon + origadd
            else:
                repeats = len(source)/len(addon)+1  # repeat addon x times,
                origadd = copy.deepcopy(addon)      #    x is NOT an integer
                for i in range(repeats-1):
                    addon = addon + origadd
                    addon = addon[0:len(source)]
        elif len(source) < len(addon):                # is addon list longer?
            if len(addon) % len(source) == 0:        # are they integer multiples?
                repeats = len(addon)/len(source)    # repeat source n times
                origsour = copy.deepcopy(source)
                for i in range(repeats-1):
                    source = source + origsour
            else:
                repeats = len(addon)/len(source)+1  # repeat source x times,
                origsour = copy.deepcopy(source)    #   x is NOT an integer
                for i in range(repeats-1):
                    source = source + origsour
                source = source[0:len(addon)]

        source = simpleabut(source,addon)
    return source


def simpleabut (source, addon):
    """
Concatenates two lists as columns and returns the result.  '2D' lists
are also accomodated for either argument (source or addon).  This DOES NOT
repeat either list to make the 2 lists of equal length.  Beware of list pairs
with different lengths ... the resulting list will be the length of the
FIRST list passed.

Usage:   simpleabut(source,addon)  where source, addon=list (or list-of-lists)
Returns: a list of lists as long as source, with source on the 'left' and
                 addon on the 'right'
"""
    if type(source) not in [ListType,TupleType]:
        source = [source]
    if type(addon) not in [ListType,TupleType]:
        addon = [addon]
    minlen = min(len(source),len(addon))
    list = copy.deepcopy(source)                # start abut process
    if type(source[0]) not in [ListType,TupleType]:
        if type(addon[0]) not in [ListType,TupleType]:
            for i in range(minlen):
                list[i] = [source[i]] + [addon[i]]        # source/addon = column
        else:
            for i in range(minlen):
                list[i] = [source[i]] + addon[i]        # addon=list-of-lists
    else:
        if type(addon[0]) not in [ListType,TupleType]:
            for i in range(minlen):
                list[i] = source[i] + [addon[i]]        # source=list-of-lists
        else:
            for i in range(minlen):
                list[i] = source[i] + addon[i]        # source/addon = list-of-lists
    source = list
    return source


def colex (listoflists,cnums):
    """
Extracts from listoflists the columns specified in the list 'cnums'
(cnums can be an integer, a sequence of integers, or a string-expression that
corresponds to a slice operation on the variable x ... e.g., 'x[3:]' will colex
columns 3 onward from the listoflists).

Usage:   colex (listoflists,cnums)
Returns: a list-of-lists corresponding to the columns from listoflists
         specified by cnums, in the order the column numbers appear in cnums
"""
    global index
    column = 0
    if type(cnums) in [ListType,TupleType]:   # if multiple columns to get
        index = cnums[0]
        column = map(lambda x: x[index], listoflists)
        for col in cnums[1:]:
            index = col
            column = abut(column,map(lambda x: x[index], listoflists))
    elif type(cnums) == StringType:              # if an 'x[3:]' type expr.
        evalstring = 'map(lambda x: x'+cnums+', listoflists)'
        column = eval(evalstring)
    else:                                     # else it's just 1 col to get
        index = cnums
        column = map(lambda x: x[index], listoflists)
    return column


def collapse (listoflists,keepcols,collapsecols,fcn1=None,fcn2=None,cfcn=None):
    """
Averages data in collapsecol, keeping all unique items in keepcols
(using unique, which keeps unique LISTS of column numbers), retaining the
unique sets of values in keepcols, the mean for each.  Setting fcn1
and/or fcn2 to point to a function rather than None (e.g., stats.sterr, len)
will append those results (e.g., the sterr, N) after each calculated mean.
cfcn is the collapse function to apply (defaults to mean, defined here in the
pstat module to avoid circular imports with stats.py, but harmonicmean or
others could be passed).

Usage:    collapse (listoflists,keepcols,collapsecols,fcn1=None,fcn2=None,cfcn=None)
Returns: a list of lists with all unique permutations of entries appearing in
    columns ("conditions") specified by keepcols, abutted with the result of
    cfcn (if cfcn=None, defaults to the mean) of each column specified by
    collapsecols.
"""
    def collmean (inlist):
        s = 0
        for item in inlist:
            s = s + item
        return s/float(len(inlist))

    if type(keepcols) not in [ListType,TupleType]:
        keepcols = [keepcols]
    if type(collapsecols) not in [ListType,TupleType]:
        collapsecols = [collapsecols]
    if cfcn == None:
        cfcn = collmean
    if keepcols == []:
        means = [0]*len(collapsecols)
        for i in range(len(collapsecols)):
            avgcol = colex(listoflists,collapsecols[i])
            means[i] = cfcn(avgcol)
            if fcn1:
                try:
                    test = fcn1(avgcol)
                except:
                    test = 'N/A'
                    means[i] = [means[i], test]
            if fcn2:
                try:
                    test = fcn2(avgcol)
                except:
                    test = 'N/A'
                try:
                    means[i] = means[i] + [len(avgcol)]
                except TypeError:
                    means[i] = [means[i],len(avgcol)]
        return means
    else:
        values = colex(listoflists,keepcols)
        uniques = unique(values)
        uniques.sort()
        newlist = []
        if type(keepcols) not in [ListType,TupleType]:  keepcols = [keepcols]
        for item in uniques:
            if type(item) not in [ListType,TupleType]:  item =[item]
            tmprows = linexand(listoflists,keepcols,item)
            for col in collapsecols:
                avgcol = colex(tmprows,col)
                item.append(cfcn(avgcol))
                if fcn1 <> None:
                    try:
                        test = fcn1(avgcol)
                    except:
                        test = 'N/A'
                    item.append(test)
                if fcn2 <> None:
                    try:
                        test = fcn2(avgcol)
                    except:
                        test = 'N/A'
                    item.append(test)
                newlist.append(item)
        return newlist


def dm (listoflists,criterion):
    """
Returns rows from the passed list of lists that meet the criteria in
the passed criterion expression (a string as a function of x; e.g., 'x[3]>=9'
will return all rows where the 4th column>=9 and "x[2]=='N'" will return rows
with column 2 equal to the string 'N').

Usage:   dm (listoflists, criterion)
Returns: rows from listoflists that meet the specified criterion.
"""
    function = 'filter(lambda x: '+criterion+',listoflists)'
    lines = eval(function)
    return lines


def flat(l):
    """
Returns the flattened version of a '2D' list.  List-correlate to the a.ravel()()
method of NumPy arrays.

Usage:    flat(l)
"""
    newl = []
    for i in range(len(l)):
        for j in range(len(l[i])):
            newl.append(l[i][j])
    return newl


def linexand (listoflists,columnlist,valuelist):
    """
Returns the rows of a list of lists where col (from columnlist) = val
(from valuelist) for EVERY pair of values (columnlist[i],valuelists[i]).
len(columnlist) must equal len(valuelist).

Usage:   linexand (listoflists,columnlist,valuelist)
Returns: the rows of listoflists where columnlist[i]=valuelist[i] for ALL i
"""
    if type(columnlist) not in [ListType,TupleType]:
        columnlist = [columnlist]
    if type(valuelist) not in [ListType,TupleType]:
        valuelist = [valuelist]
    criterion = ''
    for i in range(len(columnlist)):
        if type(valuelist[i])==StringType:
            critval = '\'' + valuelist[i] + '\''
        else:
            critval = str(valuelist[i])
        criterion = criterion + ' x['+str(columnlist[i])+']=='+critval+' and'
    criterion = criterion[0:-3]         # remove the "and" after the last crit
    function = 'filter(lambda x: '+criterion+',listoflists)'
    lines = eval(function)
    return lines


def linexor (listoflists,columnlist,valuelist):
    """
Returns the rows of a list of lists where col (from columnlist) = val
(from valuelist) for ANY pair of values (colunmlist[i],valuelist[i[).
One value is required for each column in columnlist.  If only one value
exists for columnlist but multiple values appear in valuelist, the
valuelist values are all assumed to pertain to the same column.

Usage:   linexor (listoflists,columnlist,valuelist)
Returns: the rows of listoflists where columnlist[i]=valuelist[i] for ANY i
"""
    if type(columnlist) not in [ListType,TupleType]:
        columnlist = [columnlist]
    if type(valuelist) not in [ListType,TupleType]:
        valuelist = [valuelist]
    criterion = ''
    if len(columnlist) == 1 and len(valuelist) > 1:
        columnlist = columnlist*len(valuelist)
    for i in range(len(columnlist)):          # build an exec string
        if type(valuelist[i])==StringType:
            critval = '\'' + valuelist[i] + '\''
        else:
            critval = str(valuelist[i])
        criterion = criterion + ' x['+str(columnlist[i])+']=='+critval+' or'
    criterion = criterion[0:-2]         # remove the "or" after the last crit
    function = 'filter(lambda x: '+criterion+',listoflists)'
    lines = eval(function)
    return lines


def linedelimited (inlist,delimiter):
    """
Returns a string composed of elements in inlist, with each element
separated by 'delimiter.'  Used by function writedelimited.  Use '\t'
for tab-delimiting.

Usage:   linedelimited (inlist,delimiter)
"""
    outstr = ''
    for item in inlist:
        if type(item) <> StringType:
            item = str(item)
        outstr = outstr + item + delimiter
    outstr = outstr[0:-1]
    return outstr


def lineincols (inlist,colsize):
    """
Returns a string composed of elements in inlist, with each element
right-aligned in columns of (fixed) colsize.

Usage:   lineincols (inlist,colsize)   where colsize is an integer
"""
    outstr = ''
    for item in inlist:
        if type(item) <> StringType:
            item = str(item)
        size = len(item)
        if size <= colsize:
            for i in range(colsize-size):
                outstr = outstr + ' '
            outstr = outstr + item
        else:
            outstr = outstr + item[0:colsize+1]
    return outstr


def lineincustcols (inlist,colsizes):
    """
Returns a string composed of elements in inlist, with each element
right-aligned in a column of width specified by a sequence colsizes.  The
length of colsizes must be greater than or equal to the number of columns
in inlist.

Usage:   lineincustcols (inlist,colsizes)
Returns: formatted string created from inlist
"""
    outstr = ''
    for i in range(len(inlist)):
        if type(inlist[i]) <> StringType:
            item = str(inlist[i])
        else:
            item = inlist[i]
        size = len(item)
        if size <= colsizes[i]:
            for j in range(colsizes[i]-size):
                outstr = outstr + ' '
            outstr = outstr + item
        else:
            outstr = outstr + item[0:colsizes[i]+1]
    return outstr


def list2string (inlist,delimit=' '):
    """
Converts a 1D list to a single long string for file output, using
the string.join function.

Usage:   list2string (inlist,delimit=' ')
Returns: the string created from inlist
"""
    stringlist = map(makestr,inlist)
    return string.join(stringlist,delimit)


def makelol(inlist):
    """
Converts a 1D list to a 2D list (i.e., a list-of-lists).  Useful when you
want to use put() to write a 1D list one item per line in the file.

Usage:   makelol(inlist)
Returns: if l = [1,2,'hi'] then returns [[1],[2],['hi']] etc.
"""
    x = []
    for item in inlist:
        x.append([item])
    return x


def makestr (x):
    if type(x) <> StringType:
        x = str(x)
    return x


def printcc (lst,extra=2):
    """
Prints a list of lists in columns, customized by the max size of items
within the columns (max size of items in col, plus 'extra' number of spaces).
Use 'dashes' or '\\n' in the list-of-lists to print dashes or blank lines,
respectively.

Usage:   printcc (lst,extra=2)
Returns: None
"""
    if type(lst[0]) not in [ListType,TupleType]:
        lst = [lst]
    rowstokill = []
    list2print = copy.deepcopy(lst)
    for i in range(len(lst)):
        if lst[i] == ['\n'] or lst[i]=='\n' or lst[i]=='dashes' or lst[i]=='' or lst[i]==['']:
            rowstokill = rowstokill + [i]
    rowstokill.reverse()   # delete blank rows from the end
    for row in rowstokill:
        del list2print[row]
    maxsize = [0]*len(list2print[0])
    for col in range(len(list2print[0])):
        items = colex(list2print,col)
        items = map(makestr,items)
        maxsize[col] = max(map(len,items)) + extra
    for row in lst:
        if row == ['\n'] or row == '\n' or row == '' or row == ['']:
            print
        elif row == ['dashes'] or row == 'dashes':
            dashes = [0]*len(maxsize)
            for j in range(len(maxsize)):
                dashes[j] = '-'*(maxsize[j]-2)
            print lineincustcols(dashes,maxsize)
        else:
            print lineincustcols(row,maxsize)
    return None


def printincols (listoflists,colsize):
    """
Prints a list of lists in columns of (fixed) colsize width, where
colsize is an integer.

Usage:   printincols (listoflists,colsize)
Returns: None
"""
    for row in listoflists:
        print lineincols(row,colsize)
    return None


def pl (listoflists):
    """
Prints a list of lists, 1 list (row) at a time.

Usage:   pl(listoflists)
Returns: None
"""
    for row in listoflists:
        if row[-1] == '\n':
            print row,
        else:
            print row
    return None


def printl(listoflists):
    """Alias for pl."""
    pl(listoflists)
    return


def replace (inlst,oldval,newval):
    """
Replaces all occurrences of 'oldval' with 'newval', recursively.

Usage:   replace (inlst,oldval,newval)
"""
    lst = inlst*1
    for i in range(len(lst)):
        if type(lst[i]) not in [ListType,TupleType]:
            if lst[i]==oldval: lst[i]=newval
        else:
            lst[i] = replace(lst[i],oldval,newval)
    return lst


def recode (inlist,listmap,cols=None):
    """
Changes the values in a list to a new set of values (useful when
you need to recode data from (e.g.) strings to numbers.  cols defaults
to None (meaning all columns are recoded).

Usage:   recode (inlist,listmap,cols=None)  cols=recode cols, listmap=2D list
Returns: inlist with the appropriate values replaced with new ones
"""
    lst = copy.deepcopy(inlist)
    if cols != None:
        if type(cols) not in [ListType,TupleType]:
            cols = [cols]
        for col in cols:
            for row in range(len(lst)):
                try:
                    idx = colex(listmap,0).index(lst[row][col])
                    lst[row][col] = listmap[idx][1]
                except ValueError:
                    pass
    else:
        for row in range(len(lst)):
            for col in range(len(lst)):
                try:
                    idx = colex(listmap,0).index(lst[row][col])
                    lst[row][col] = listmap[idx][1]
                except ValueError:
                    pass
    return lst


def remap (listoflists,criterion):
    """
Remaps values in a given column of a 2D list (listoflists).  This requires
a criterion as a function of 'x' so that the result of the following is
returned ... map(lambda x: 'criterion',listoflists).  

Usage:   remap(listoflists,criterion)    criterion=string
Returns: remapped version of listoflists
"""
    function = 'map(lambda x: '+criterion+',listoflists)'
    lines = eval(function)
    return lines


def roundlist (inlist,digits):
    """
Goes through each element in a 1D or 2D inlist, and applies the following
function to all elements of FloatType ... round(element,digits).

Usage:   roundlist(inlist,digits)
Returns: list with rounded floats
"""
    if type(inlist[0]) in [IntType, FloatType]:
        inlist = [inlist]
    l = inlist*1
    for i in range(len(l)):
        for j in range(len(l[i])):
            if type(l[i][j])==FloatType:
                l[i][j] = round(l[i][j],digits)
    return l


def sortby(listoflists,sortcols):
    """
Sorts a list of lists on the column(s) specified in the sequence
sortcols.

Usage:   sortby(listoflists,sortcols)
Returns: sorted list, unchanged column ordering
"""
    newlist = abut(colex(listoflists,sortcols),listoflists)
    newlist.sort()
    try:
        numcols = len(sortcols)
    except TypeError:
        numcols = 1
    crit = '[' + str(numcols) + ':]'
    newlist = colex(newlist,crit)
    return newlist


def unique (inlist):
    """
Returns all unique items in the passed list.  If the a list-of-lists
is passed, unique LISTS are found (i.e., items in the first dimension are
compared).

Usage:   unique (inlist)
Returns: the unique elements (or rows) in inlist
"""
    uniques = []
    for item in inlist:
        if item not in uniques:
            uniques.append(item)
    return uniques

def duplicates(inlist):
    """
Returns duplicate items in the FIRST dimension of the passed list.

Usage:   duplicates (inlist)
"""
    dups = []
    for i in range(len(inlist)):
        if inlist[i] in inlist[i+1:]:
            dups.append(inlist[i])
    return dups


def nonrepeats(inlist):
    """
Returns items that are NOT duplicated in the first dim of the passed list.

Usage:   nonrepeats (inlist)
"""
    nonrepeats = []
    for i in range(len(inlist)):
        if inlist.count(inlist[i]) == 1:
            nonrepeats.append(inlist[i])
    return nonrepeats


#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================
#===================   PSTAT ARRAY FUNCTIONS  =====================

try:                         # DEFINE THESE *ONLY* IF numpy IS AVAILABLE
    import numpy as N
   
    def aabut (source, *args):
        """
    Like the |Stat abut command.  It concatenates two arrays column-wise
    and returns the result.  CAUTION:  If one array is shorter, it will be
    repeated until it is as long as the other.
    
    Usage:   aabut (source, args)    where args=any # of arrays
    Returns: an array as long as the LONGEST array past, source appearing on the
             'left', arrays in <args> attached on the 'right'.
    """
        if len(source.shape)==1:
            width = 1
            source = N.resize(source,[source.shape[0],width])
        else:
            width = source.shape[1]
        for addon in args:
            if len(addon.shape)==1:
                width = 1
                addon = N.resize(addon,[source.shape[0],width])
            else:
                width = source.shape[1]
            if len(addon) < len(source):
                addon = N.resize(addon,[source.shape[0],addon.shape[1]])
            elif len(source) < len(addon):
                source = N.resize(source,[addon.shape[0],source.shape[1]])
            source = N.concatenate((source,addon),1)
        return source
    
    
    def acolex (a,indices,axis=1):
        """
    Extracts specified indices (a list) from passed array, along passed
    axis (column extraction is default).  BEWARE: A 1D array is presumed to be a
    column-array (and that the whole array will be returned as a column).
    
    Usage:   acolex (a,indices,axis=1)
    Returns: the columns of a specified by indices
    """
        if type(indices) not in [ListType,TupleType,N.ndarray]:
            indices = [indices]
        if len(N.shape(a)) == 1:
            cols = N.resize(a,[a.shape[0],1])
        else:
            cols = N.take(a,indices,axis)
        return cols
    
    
    def acollapse (a,keepcols,collapsecols,fcn1=None,fcn2=None,cfcn=None):
        """
    Averages data in collapsecol, keeping all unique items in keepcols
    (using unique, which keeps unique LISTS of column numbers), retaining
    the unique sets of values in keepcols, the mean for each.  If stderror or
    N of the mean are desired, set either or both parameters to 1.
    
    Usage:   acollapse (a,keepcols,collapsecols,fcn1=None,fcn2=None,cfcn=None)
    Returns: unique 'conditions' specified by the contents of columns specified
             by keepcols, abutted with the mean(s) of column(s) specified by
             collapsecols
    """
        def acollmean (inarray):
            return N.sum(N.ravel(inarray))
    
        if type(keepcols) not in [ListType,TupleType,N.ndarray]:
            keepcols = [keepcols]
        if type(collapsecols) not in [ListType,TupleType,N.ndarray]:
            collapsecols = [collapsecols]
    
        if cfcn == None:
            cfcn = acollmean
        if keepcols == []:
            avgcol = acolex(a,collapsecols)
            means = N.sum(avgcol)/float(len(avgcol))
            if fcn1<>None:
                try:
                    test = fcn1(avgcol)
                except:
                    test = N.array(['N/A']*len(means))
                means = aabut(means,test)
            if fcn2<>None:
                try:
                    test = fcn2(avgcol)
                except:
                    test = N.array(['N/A']*len(means))
                means = aabut(means,test)
            return means
        else:
            if type(keepcols) not in [ListType,TupleType,N.ndarray]:
                keepcols = [keepcols]
            values = colex(a,keepcols)   # so that "item" can be appended (below)
            uniques = unique(values)  # get a LIST, so .sort keeps rows intact
            uniques.sort()
            newlist = []
            for item in uniques:
                if type(item) not in [ListType,TupleType,N.ndarray]:
                    item =[item]
                tmprows = alinexand(a,keepcols,item)
                for col in collapsecols:
                    avgcol = acolex(tmprows,col)
                    item.append(acollmean(avgcol))
                    if fcn1<>None:
                        try:
                            test = fcn1(avgcol)
                        except:
                            test = 'N/A'
                        item.append(test)
                    if fcn2<>None:
                        try:
                            test = fcn2(avgcol)
                        except:
                            test = 'N/A'
                        item.append(test)
                    newlist.append(item)
            try:
                new_a = N.array(newlist)
            except TypeError:
                new_a = N.array(newlist,'O')
            return new_a
    
    
    def adm (a,criterion):
        """
    Returns rows from the passed list of lists that meet the criteria in
    the passed criterion expression (a string as a function of x).
    
    Usage:   adm (a,criterion)   where criterion is like 'x[2]==37'
    """
        function = 'filter(lambda x: '+criterion+',a)'
        lines = eval(function)
        try:
            lines = N.array(lines)
        except:
            lines = N.array(lines,dtype='O')
        return lines
    
    
    def isstring(x):
        if type(x)==StringType:
            return 1
        else:
            return 0
    
    
    def alinexand (a,columnlist,valuelist):
        """
    Returns the rows of an array where col (from columnlist) = val
    (from valuelist).  One value is required for each column in columnlist.
    
    Usage:   alinexand (a,columnlist,valuelist)
    Returns: the rows of a where columnlist[i]=valuelist[i] for ALL i
    """
        if type(columnlist) not in [ListType,TupleType,N.ndarray]:
            columnlist = [columnlist]
        if type(valuelist) not in [ListType,TupleType,N.ndarray]:
            valuelist = [valuelist]
        criterion = ''
        for i in range(len(columnlist)):
            if type(valuelist[i])==StringType:
                critval = '\'' + valuelist[i] + '\''
            else:
                critval = str(valuelist[i])
            criterion = criterion + ' x['+str(columnlist[i])+']=='+critval+' and'
        criterion = criterion[0:-3]         # remove the "and" after the last crit
        return adm(a,criterion)
    
    
    def alinexor (a,columnlist,valuelist):
        """
    Returns the rows of an array where col (from columnlist) = val (from
    valuelist).  One value is required for each column in columnlist.
    The exception is if either columnlist or valuelist has only 1 value,
    in which case that item will be expanded to match the length of the
    other list.
    
    Usage:   alinexor (a,columnlist,valuelist)
    Returns: the rows of a where columnlist[i]=valuelist[i] for ANY i
    """
        if type(columnlist) not in [ListType,TupleType,N.ndarray]:
            columnlist = [columnlist]
        if type(valuelist) not in [ListType,TupleType,N.ndarray]:
            valuelist = [valuelist]
        criterion = ''
        if len(columnlist) == 1 and len(valuelist) > 1:
            columnlist = columnlist*len(valuelist)
        elif len(valuelist) == 1 and len(columnlist) > 1:
            valuelist = valuelist*len(columnlist)
        for i in range(len(columnlist)):
            if type(valuelist[i])==StringType:
                critval = '\'' + valuelist[i] + '\''
            else:
                critval = str(valuelist[i])
            criterion = criterion + ' x['+str(columnlist[i])+']=='+critval+' or'
        criterion = criterion[0:-2]         # remove the "or" after the last crit
        return adm(a,criterion)
    
    
    def areplace (a,oldval,newval):
        """
    Replaces all occurrences of oldval with newval in array a.
    
    Usage:   areplace(a,oldval,newval)
    """
        return N.where(a==oldval,newval,a)
    
    
    def arecode (a,listmap,col='all'):
        """
    Remaps the values in an array to a new set of values (useful when
    you need to recode data from (e.g.) strings to numbers as most stats
    packages require.  Can work on SINGLE columns, or 'all' columns at once.
    @@@BROKEN 2007-11-26
    
    Usage:   arecode (a,listmap,col='all')
    Returns: a version of array a where listmap[i][0] = (instead) listmap[i][1]
    """
        ashape = a.shape
        if col == 'all':
            work = a.ravel()
        else:
            work = acolex(a,col)
            work = work.ravel()
        for pair in listmap:
            if type(pair[1]) == StringType or work.dtype.char=='O' or a.dtype.char=='O':
                work = N.array(work,dtype='O')
                a = N.array(a,dtype='O')
                for i in range(len(work)):
                    if work[i]==pair[0]:
                        work[i] = pair[1]
                if col == 'all':
                    return N.reshape(work,ashape)
                else:
                    return N.concatenate([a[:,0:col],work[:,N.newaxis],a[:,col+1:]],1)
            else:   # must be a non-Object type array and replacement
                work = N.where(work==pair[0],pair[1],work)
                return N.concatenate([a[:,0:col],work[:,N.newaxis],a[:,col+1:]],1)
    
    
    def arowcompare(row1, row2):
        """
    Compares two rows from an array, regardless of whether it is an
    array of numbers or of python objects (which requires the cmp function).
    @@@PURPOSE? 2007-11-26
    
    Usage:   arowcompare(row1,row2)
    Returns: an array of equal length containing 1s where the two rows had
             identical elements and 0 otherwise
    """
        return 
        if row1.dtype.char=='O' or row2.dtype=='O':
            cmpvect = N.logical_not(abs(N.array(map(cmp,row1,row2)))) # cmp fcn gives -1,0,1
        else:
            cmpvect = N.equal(row1,row2)
        return cmpvect
    
    
    def arowsame(row1, row2):
        """
    Compares two rows from an array, regardless of whether it is an
    array of numbers or of python objects (which requires the cmp function).
    
    Usage:   arowsame(row1,row2)
    Returns: 1 if the two rows are identical, 0 otherwise.
    """
        cmpval = N.alltrue(arowcompare(row1,row2))
        return cmpval
    
    
    def asortrows(a,axis=0):
        """
    Sorts an array "by rows".  This differs from the Numeric.sort() function,
    which sorts elements WITHIN the given axis.  Instead, this function keeps
    the elements along the given axis intact, but shifts them 'up or down'
    relative to one another.
    
    Usage:   asortrows(a,axis=0)
    Returns: sorted version of a
    """
        return N.sort(a,axis=axis,kind='mergesort')
    
    
    def aunique(inarray):
        """
    Returns unique items in the FIRST dimension of the passed array. Only
    works on arrays NOT including string items.
    
    Usage:   aunique (inarray)
    """
        uniques = N.array([inarray[0]])
        if len(uniques.shape) == 1:            # IF IT'S A 1D ARRAY
            for item in inarray[1:]:
                if N.add.reduce(N.equal(uniques,item).ravel()) == 0:
                    try:
                        uniques = N.concatenate([uniques,N.array[N.newaxis,:]])
                    except TypeError:
                        uniques = N.concatenate([uniques,N.array([item])])
        else:                                  # IT MUST BE A 2+D ARRAY
            if inarray.dtype.char != 'O':  # not an Object array
                for item in inarray[1:]:
                    if not N.sum(N.alltrue(N.equal(uniques,item),1)):
                        try:
                            uniques = N.concatenate( [uniques,item[N.newaxis,:]] )
                        except TypeError:    # the item to add isn't a list
                            uniques = N.concatenate([uniques,N.array([item])])
                    else:
                        pass  # this item is already in the uniques array
            else:   # must be an Object array, alltrue/equal functions don't work
                for item in inarray[1:]:
                    newflag = 1
                    for unq in uniques:  # NOTE: cmp --> 0=same, -1=<, 1=>
                        test = N.sum(abs(N.array(map(cmp,item,unq))))
                        if test == 0:   # if item identical to any 1 row in uniques
                            newflag = 0 # then not a novel item to add
                            break
                    if newflag == 1:
                        try:
                            uniques = N.concatenate( [uniques,item[N.newaxis,:]] )
                        except TypeError:    # the item to add isn't a list
                            uniques = N.concatenate([uniques,N.array([item])])
        return uniques
    
    
    def aduplicates(inarray):
        """
    Returns duplicate items in the FIRST dimension of the passed array. Only
    works on arrays NOT including string items.
    
    Usage:   aunique (inarray)
    """
        inarray = N.array(inarray)
        if len(inarray.shape) == 1:            # IF IT'S A 1D ARRAY
            dups = []
            inarray = inarray.tolist()
            for i in range(len(inarray)):
                if inarray[i] in inarray[i+1:]:
                    dups.append(inarray[i])
            dups = aunique(dups)
        else:                                  # IT MUST BE A 2+D ARRAY
            dups = []
            aslist = inarray.tolist()
            for i in range(len(aslist)):
                if aslist[i] in aslist[i+1:]:
                    dups.append(aslist[i])
            dups = unique(dups)
            dups = N.array(dups)
        return dups
    
except ImportError:    # IF NUMERIC ISN'T AVAILABLE, SKIP ALL arrayfuncs
    pass

########NEW FILE########
__FILENAME__ = stats
"""
Module stats.py
===============

A collection of basic statistical functions for python.  

B{Important:}  There are really B{3} sets of functions.  The first set has an C{l}
prefix, which can be used with list or tuple arguments.  The second set has
an C{a} prefix, which can accept U{numpy <http://numpy.scipy.org>} array arguments.  These latter
functions are defined only when C{numpy} is available on the system.  The third
type has NO prefix (i.e., has the name that appears below).  Functions of
this set are members of a L{Dispatch} class, c/o David Ascher.  This class
allows different functions to be called depending on the type of the passed
arguments.  Thus, L{stats.mean} is a member of the L{Dispatch} class and
C{stats.mean(range(20))} will call L{stats.lmean} while
C{stats.mean(numpy.arange(20))} will call L{stats.amean}.

This is a handy way to keep consistent function names when different
argument types require different functions to be called. Having
implementated the L{Dispatch} class, however, means that to get info on
a given function, you must use the REAL function name ... that is
C{print stats.lmean.__doc__} or C{print stats.amean.__doc__} work fine,
while C{print stats.mean.__doc__} will print the doc for the L{Dispatch}
class.  U{Numpy <http://numpy.scipy.org>} functions (C{a} prefix) 
generally have more argument options but 
should otherwise be consistent with the corresponding list functions.

Function List
=============

Central Tendency
----------------
    - geometricmean
    - harmonicmean
    - mean
    - median
    - medianscore
    - mode

Moments
-------
    - moment
    - variation
    - skew
    - kurtosis
    - skewtest   (for Numpy arrays only)
    - kurtosistest (for Numpy arrays only)
    - normaltest (for Numpy arrays only)

Altered Versions
----------------
    - tmean  (for Numpy arrays only)
    - tvar   (for Numpy arrays only)
    - tmin   (for Numpy arrays only)
    - tmax   (for Numpy arrays only)
    - tstdev (for Numpy arrays only)
    - tsem   (for Numpy arrays only)
    - describe

Frequency Stats
---------------
    - itemfreq
    - scoreatpercentile
    - percentileofscore
    - histogram
    - cumfreq
    - relfreq

Variability
-----------
    - obrientransform
    - samplevar
    - samplestdev
    - signaltonoise (for Numpy arrays only)
    - var
    - stdev
    - sterr
    - sem
    - z
    - zs
    - zmap (for Numpy arrays only)

Trimming Fcns
-------------
    - threshold (for Numpy arrays only)
    - trimboth
    - trim1
    - round (round all vals to 'n' decimals; Numpy only)

Correlation Fcns
----------------
    - covariance  (for Numpy arrays only)
    - correlation (for Numpy arrays only)
    - paired
    - pearsonr
    - spearmanr
    - pointbiserialr
    - kendalltau
    - linregress

Inferential Stats
-----------------
    - ttest_1samp
    - ttest_ind
    - ttest_rel
    - chisquare
    - ks_2samp
    - mannwhitneyu
    - ranksums
    - wilcoxont
    - kruskalwallish
    - friedmanchisquare

Probability Calcs
-----------------
    - chisqprob
    - erfcc
    - zprob
    - ksprob
    - fprob
    - betacf
    - gammln 
    - betai

Anova Functions
---------------
    - F_oneway
    - F_value

Support Functions
-----------------
    - writecc
    - incr
    - sign  (for Numpy arrays only)
    - sum
    - cumsum
    - ss
    - summult
    - sumdiffsquared
    - square_of_sums
    - shellsort
    - rankdata
    - outputpairedstats
    - findwithin

B{Disclaimer:}  The function list is obviously incomplete and, worse, the
functions are not optimized.  All functions have been tested (some more
so than others), but they are far from bulletproof.  Thus, as with any
free software, no warranty or guarantee is expressed or implied. :-)  A
few extra functions that don't appear in the list below can be found by
interested treasure-hunters.  These functions don't necessarily have
both list and array versions but were deemed useful. 

For further references see the U{python-statlib homepage 
<http://python-statlib.googlecode.com>}

@author: Gary Strangman
@copyright: (c) 1999-2007 Gary Strangman; All Rights Reserved.
@license: MIT license
"""
#################################################
#######  Written by:  Gary Strangman  ###########
#######  Last modified:  Dec 18, 2007 ###########
#################################################
# Copyright (c) 1999-2007 Gary Strangman; All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# Comments and/or additions are welcome (send e-mail to:
# strang@nmr.mgh.harvard.edu).
# 

## CHANGE LOG:
## ===========
## 07-11.26 ... conversion for numpy started
## 07-05-16 ... added Lin's Concordance Correlation Coefficient (alincc) and acov
## 05-08-21 ... added "Dice's coefficient"
## 04-10-26 ... added ap2t(), an ugly fcn for converting p-vals to T-vals
## 04-04-03 ... added amasslinregress() function to do regression on N-D arrays
## 03-01-03 ... CHANGED VERSION TO 0.6
##              fixed atsem() to properly handle limits=None case
##              improved histogram and median functions (estbinwidth) and
##                   fixed atvar() function (wrong answers for neg numbers?!?)
## 02-11-19 ... fixed attest_ind and attest_rel for div-by-zero Overflows
## 02-05-10 ... fixed lchisqprob indentation (failed when df=even)
## 00-12-28 ... removed aanova() to separate module, fixed licensing to
##                   match Python License, fixed doc string & imports
## 00-04-13 ... pulled all "global" statements, except from aanova()
##              added/fixed lots of documentation, removed io.py dependency
##              changed to version 0.5
## 99-11-13 ... added asign() function
## 99-11-01 ... changed version to 0.4 ... enough incremental changes now
## 99-10-25 ... added acovariance and acorrelation functions
## 99-10-10 ... fixed askew/akurtosis to avoid divide-by-zero errors
##              added aglm function (crude, but will be improved)
## 99-10-04 ... upgraded acumsum, ass, asummult, asamplevar, avar, etc. to
##                   all handle lists of 'dimension's and keepdims
##              REMOVED ar0, ar2, ar3, ar4 and replaced them with around
##              reinserted fixes for abetai to avoid math overflows
## 99-09-05 ... rewrote achisqprob/aerfcc/aksprob/afprob/abetacf/abetai to
##                   handle multi-dimensional arrays (whew!)
## 99-08-30 ... fixed l/amoment, l/askew, l/akurtosis per D'Agostino (1990)
##              added anormaltest per same reference
##              re-wrote azprob to calc arrays of probs all at once
## 99-08-22 ... edited attest_ind printing section so arrays could be rounded
## 99-08-19 ... fixed amean and aharmonicmean for non-error(!) overflow on
##                   short/byte arrays (mean of #s btw 100-300 = -150??)
## 99-08-09 ... fixed asum so that the None case works for Byte arrays
## 99-08-08 ... fixed 7/3 'improvement' to handle t-calcs on N-D arrays
## 99-07-03 ... improved attest_ind, attest_rel (zero-division errortrap)
## 99-06-24 ... fixed bug(?) in attest_ind (n1=a.shape[0])
## 04/11/99 ... added asignaltonoise, athreshold functions, changed all
##                   max/min in array section to N.maximum/N.minimum,
##                   fixed square_of_sums to prevent integer overflow
## 04/10/99 ... !!! Changed function name ... sumsquared ==> square_of_sums
## 03/18/99 ... Added ar0, ar2, ar3 and ar4 rounding functions
## 02/28/99 ... Fixed aobrientransform to return an array rather than a list
## 01/15/99 ... Essentially ceased updating list-versions of functions (!!!)
## 01/13/99 ... CHANGED TO VERSION 0.3
##              fixed bug in a/lmannwhitneyu p-value calculation
## 12/31/98 ... fixed variable-name bug in ldescribe
## 12/19/98 ... fixed bug in findwithin (fcns needed pstat. prefix)
## 12/16/98 ... changed amedianscore to return float (not array) for 1 score
## 12/14/98 ... added atmin and atmax functions
##              removed umath from import line (not needed)
##              l/ageometricmean modified to reduce chance of overflows (take
##                   nth root first, then multiply)
## 12/07/98 ... added __version__variable (now 0.2)
##              removed all 'stats.' from anova() fcn
## 12/06/98 ... changed those functions (except shellsort) that altered
##                   arguments in-place ... cumsum, ranksort, ...
##              updated (and fixed some) doc-strings
## 12/01/98 ... added anova() function (requires NumPy)
##              incorporated Dispatch class
## 11/12/98 ... added functionality to amean, aharmonicmean, ageometricmean
##              added 'asum' function (added functionality to N.add.reduce)
##              fixed both moment and amoment (two errors)
##              changed name of skewness and askewness to skew and askew
##              fixed (a)histogram (which sometimes counted points <lowerlimit)

import pstat               # required 3rd party module
import math, string, copy  # required python modules
from types import *

__version__ = 0.6

############# DISPATCH CODE ##############


class Dispatch:
    """
    The Dispatch class, care of David Ascher, allows different functions to
    be called depending on the argument types.  This way, there can be one
    function name regardless of the argument type.  To access function doc
    in stats.py module, prefix the function with an 'l' or 'a' for list or
    array arguments, respectively.  That is, print stats.lmean.__doc__ or
    print stats.amean.__doc__ or whatever.
    """

    def __init__(self, *tuples):
        self._dispatch = {}
        for func, types in tuples:
            for t in types:
                if t in self._dispatch.keys():
                    raise ValueError, "can't have two dispatches on "+str(t)
                self._dispatch[t] = func
        self._types = self._dispatch.keys()

    def __call__(self, arg1, *args, **kw):
        if type(arg1) not in self._types:
            raise TypeError, "don't know how to dispatch %s arguments" %  type(arg1)
        return apply(self._dispatch[type(arg1)], (arg1,) + args, kw)


##########################################################################
########################   LIST-BASED FUNCTIONS   ########################
##########################################################################

### Define these regardless

####################################
#######  CENTRAL TENDENCY  #########
####################################

def lgeometricmean (inlist):
    """
    Calculates the geometric mean of the values in the passed list.
    That is:  n-th root of (x1 * x2 * ... * xn).  Assumes a '1D' list.

    Usage:   lgeometricmean(inlist)
    """
    mult = 1.0
    one_over_n = 1.0/len(inlist)
    for item in inlist:
        mult = mult * pow(item,one_over_n)
    return mult


def lharmonicmean (inlist):
    """
    The harmonic mean is defined as:  C{n / (1/x1 + 1/x2 + ... + 1/xn)}.  
    @parameter inlist: assumes a '1D' list.
    @return: the harmonic mean of the values in the passed list.
    """
    sum = 0
    for item in inlist:
        sum = sum + 1.0/item
    return len(inlist) / sum


def lmean (inlist):
    """
    Returns the arithematic mean of the values in the passed list.
    Assumes a '1D' list, but will function on the 1st dim of an array(!).

    Usage:   lmean(inlist)
    """
    sum = 0
    for item in inlist:
        sum = sum + item
    return sum/float(len(inlist))


def lmedian (inlist,numbins=1000):
    """
    Returns the computed median value of a list of numbers, given the
    number of bins to use for the histogram (more bins brings the computed value
    closer to the median score, default number of bins = 1000).  See G.W.
    Heiman's Basic Stats (1st Edition), or CRC Probability & Statistics.

    Usage:   lmedian (inlist, numbins=1000)
    """
    (hist, smallest, binsize, extras) = histogram(inlist,numbins,[min(inlist),max(inlist)]) # make histog
    cumhist = cumsum(hist)              # make cumulative histogram
    for i in range(len(cumhist)):        # get 1st(!) index holding 50%ile score
        if cumhist[i]>=len(inlist)/2.0:
            cfbin = i
            break
    LRL = smallest + binsize*cfbin        # get lower read limit of that bin
    cfbelow = cumhist[cfbin-1]
    freq = float(hist[cfbin])                # frequency IN the 50%ile bin
    median = LRL + ((len(inlist)/2.0 - cfbelow)/float(freq))*binsize  # median formula
    return median


def lmedianscore (inlist):
    """
    Returns the 'middle' score of the passed list.  If there is an even
    number of scores, the mean of the 2 middle scores is returned.

    Usage:   lmedianscore(inlist)
    """

    newlist = copy.deepcopy(inlist)
    newlist.sort()
    if len(newlist) % 2 == 0:   # if even number of scores, average middle 2
        index = len(newlist)/2  # integer division correct
        median = float(newlist[index] + newlist[index-1]) /2
    else:
        index = len(newlist)/2  # int divsion gives mid value when count from 0
        median = newlist[index]
    return median


def lmode(inlist):
    """
    Returns a list of the modal (most common) score(s) in the passed
    list.  If there is more than one such score, all are returned.  The
    bin-count for the mode(s) is also returned.

    Usage:   lmode(inlist)
    Returns: bin-count for mode(s), a list of modal value(s)
    """

    scores = pstat.unique(inlist)
    scores.sort()
    freq = []
    for item in scores:
        freq.append(inlist.count(item))
    maxfreq = max(freq)
    mode = []
    stillmore = 1
    while stillmore:
        try:
            indx = freq.index(maxfreq)
            mode.append(scores[indx])
            del freq[indx]
            del scores[indx]
        except ValueError:
            stillmore=0
    return maxfreq, mode


####################################
############  MOMENTS  #############
####################################

def lmoment(inlist,moment=1):
    """
    Calculates the nth moment about the mean for a sample (defaults to
    the 1st moment).  Used to calculate coefficients of skewness and kurtosis.

    Usage:   lmoment(inlist,moment=1)
    Returns: appropriate moment (r) from ... 1/n * SUM((inlist(i)-mean)**r)
    """
    if moment == 1:
        return 0.0
    else:
        mn = mean(inlist)
        n = len(inlist)
        s = 0
        for x in inlist:
            s = s + (x-mn)**moment
        return s/float(n)


def lvariation(inlist):
    """
    Returns the coefficient of variation, as defined in CRC Standard
    Probability and Statistics, p.6.

    Usage:   lvariation(inlist)
    """
    return 100.0*samplestdev(inlist)/float(mean(inlist))


def lskew(inlist):
    """
    Returns the skewness of a distribution, as defined in Numerical
    Recipies (alternate defn in CRC Standard Probability and Statistics, p.6.)

    Usage:   lskew(inlist)
    """
    return moment(inlist,3)/pow(moment(inlist,2),1.5)


def lkurtosis(inlist):
    """
    Returns the kurtosis of a distribution, as defined in Numerical
    Recipies (alternate defn in CRC Standard Probability and Statistics, p.6.)

    Usage:   lkurtosis(inlist)
    """
    return moment(inlist,4)/pow(moment(inlist,2),2.0)


def ldescribe(inlist):
    """
    Returns some descriptive statistics of the passed list (assumed to be 1D).

    Usage:   ldescribe(inlist)
    Returns: n, mean, standard deviation, skew, kurtosis
    """
    n = len(inlist)
    mm = (min(inlist),max(inlist))
    m = mean(inlist)
    sd = stdev(inlist)
    sk = skew(inlist)
    kurt = kurtosis(inlist)
    return n, mm, m, sd, sk, kurt


####################################
#######  FREQUENCY STATS  ##########
####################################

def litemfreq(inlist):
    """
    Returns a list of pairs.  Each pair consists of one of the scores in inlist
    and it's frequency count.  Assumes a 1D list is passed.

    Usage:   litemfreq(inlist)
    Returns: a 2D frequency table (col [0:n-1]=scores, col n=frequencies)
    """
    scores = pstat.unique(inlist)
    scores.sort()
    freq = []
    for item in scores:
        freq.append(inlist.count(item))
    return pstat.abut(scores, freq)


def lscoreatpercentile (inlist, percent):
    """
    Returns the score at a given percentile relative to the distribution
    given by inlist.

    Usage:   lscoreatpercentile(inlist,percent)
    """
    if percent > 1:
        print "\nDividing percent>1 by 100 in lscoreatpercentile().\n"
        percent = percent / 100.0
    targetcf = percent*len(inlist)
    h, lrl, binsize, extras = histogram(inlist)
    cumhist = cumsum(copy.deepcopy(h))
    for i in range(len(cumhist)):
        if cumhist[i] >= targetcf:
            break
    score = binsize * ((targetcf - cumhist[i-1]) / float(h[i])) + (lrl+binsize*i)
    return score


def lpercentileofscore (inlist, score,histbins=10,defaultlimits=None):
    """
    Returns the percentile value of a score relative to the distribution
    given by inlist.  Formula depends on the values used to histogram the data(!).

    Usage:   lpercentileofscore(inlist,score,histbins=10,defaultlimits=None)
    """

    h, lrl, binsize, extras = histogram(inlist,histbins,defaultlimits)
    cumhist = cumsum(copy.deepcopy(h))
    i = int((score - lrl)/float(binsize))
    pct = (cumhist[i-1]+((score-(lrl+binsize*i))/float(binsize))*h[i])/float(len(inlist)) * 100
    return pct


def lhistogram (inlist,numbins=10,defaultreallimits=None,printextras=0):
    """
    Returns (i) a list of histogram bin counts, (ii) the smallest value
    of the histogram binning, and (iii) the bin width (the last 2 are not
    necessarily integers).  Default number of bins is 10.  If no sequence object
    is given for defaultreallimits, the routine picks (usually non-pretty) bins
    spanning all the numbers in the inlist.

    Usage:   lhistogram (inlist, numbins=10, defaultreallimits=None,suppressoutput=0)
    Returns: list of bin values, lowerreallimit, binsize, extrapoints
    """
    if (defaultreallimits <> None):
        if type(defaultreallimits) not in [ListType,TupleType] or len(defaultreallimits)==1: # only one limit given, assumed to be lower one & upper is calc'd
            lowerreallimit = defaultreallimits
            upperreallimit = 1.000001 * max(inlist)
        else: # assume both limits given
            lowerreallimit = defaultreallimits[0]
            upperreallimit = defaultreallimits[1]
        binsize = (upperreallimit-lowerreallimit)/float(numbins)
    else:     # no limits given for histogram, both must be calc'd
        estbinwidth=(max(inlist)-min(inlist))/float(numbins) +1e-6 #1=>cover all
        binsize = ((max(inlist)-min(inlist)+estbinwidth))/float(numbins)
        lowerreallimit = min(inlist) - binsize/2 #lower real limit,1st bin
    bins = [0]*(numbins)
    extrapoints = 0
    for num in inlist:
        try:
            if (num-lowerreallimit) < 0:
                extrapoints = extrapoints + 1
            else:
                bintoincrement = int((num-lowerreallimit)/float(binsize))
                bins[bintoincrement] = bins[bintoincrement] + 1
        except:
            extrapoints = extrapoints + 1
    if (extrapoints > 0 and printextras == 1):
        print '\nPoints outside given histogram range =',extrapoints
    return (bins, lowerreallimit, binsize, extrapoints)


def lcumfreq(inlist,numbins=10,defaultreallimits=None):
    """
    Returns a cumulative frequency histogram, using the histogram function.

    Usage:   lcumfreq(inlist,numbins=10,defaultreallimits=None)
    Returns: list of cumfreq bin values, lowerreallimit, binsize, extrapoints
    """
    h,l,b,e = histogram(inlist,numbins,defaultreallimits)
    cumhist = cumsum(copy.deepcopy(h))
    return cumhist,l,b,e


def lrelfreq(inlist,numbins=10,defaultreallimits=None):
    """
    Returns a relative frequency histogram, using the histogram function.

    Usage:   lrelfreq(inlist,numbins=10,defaultreallimits=None)
    Returns: list of cumfreq bin values, lowerreallimit, binsize, extrapoints
    """
    h,l,b,e = histogram(inlist,numbins,defaultreallimits)
    for i in range(len(h)):
        h[i] = h[i]/float(len(inlist))
    return h,l,b,e


####################################
#####  VARIABILITY FUNCTIONS  ######
####################################

def lobrientransform(*args):
    """
    Computes a transform on input data (any number of columns).  Used to
    test for homogeneity of variance prior to running one-way stats.  From
    Maxwell and Delaney, p.112.

    Usage:   lobrientransform(*args)
    Returns: transformed data for use in an ANOVA
    """
    TINY = 1e-10
    k = len(args)
    n = [0.0]*k
    v = [0.0]*k
    m = [0.0]*k
    nargs = []
    for i in range(k):
        nargs.append(copy.deepcopy(args[i]))
        n[i] = float(len(nargs[i]))
        v[i] = var(nargs[i])
        m[i] = mean(nargs[i])
    for j in range(k):
        for i in range(n[j]):
            t1 = (n[j]-1.5)*n[j]*(nargs[j][i]-m[j])**2
            t2 = 0.5*v[j]*(n[j]-1.0)
            t3 = (n[j]-1.0)*(n[j]-2.0)
            nargs[j][i] = (t1-t2) / float(t3)
    check = 1
    for j in range(k):
        if v[j] - mean(nargs[j]) > TINY:
            check = 0
    if check <> 1:
        raise ValueError, 'Problem in obrientransform.'
    else:
        return nargs


def lsamplevar (inlist):
    """
    Returns the variance of the values in the passed list using
    N for the denominator (i.e., DESCRIBES the sample variance only).

    Usage:   lsamplevar(inlist)
    """
    n = len(inlist)
    mn = mean(inlist)
    deviations = []
    for item in inlist:
        deviations.append(item-mn)
    return ss(deviations)/float(n)


def lsamplestdev (inlist):
    """
    Returns the standard deviation of the values in the passed list using
    N for the denominator (i.e., DESCRIBES the sample stdev only).

    Usage:   lsamplestdev(inlist)
    """
    return math.sqrt(samplevar(inlist))


def lcov (x,y, keepdims=0):
    """
    Returns the estimated covariance of the values in the passed
    array (i.e., N-1).  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions).  Set keepdims=1 to return an array with the
    same number of dimensions as inarray.

    Usage:   lcov(x,y,keepdims=0)
    """

    n = len(x)
    xmn = mean(x)
    ymn = mean(y)
    xdeviations = [0]*len(x)
    ydeviations = [0]*len(y)
    for i in range(len(x)):
        xdeviations[i] = x[i] - xmn
        ydeviations[i] = y[i] - ymn
    ss = 0.0
    for i in range(len(xdeviations)):
        ss = ss + xdeviations[i]*ydeviations[i]
    return ss/float(n-1)


def lvar (inlist):
    """
    Returns the variance of the values in the passed list using N-1
    for the denominator (i.e., for estimating population variance).

    Usage:   lvar(inlist)
    """
    n = len(inlist)
    mn = mean(inlist)
    deviations = [0]*len(inlist)
    for i in range(len(inlist)):
        deviations[i] = inlist[i] - mn
    return ss(deviations)/float(n-1)


def lstdev (inlist):
    """
    Returns the standard deviation of the values in the passed list
    using N-1 in the denominator (i.e., to estimate population stdev).

    Usage:   lstdev(inlist)
    """
    return math.sqrt(var(inlist))


def lsterr(inlist):
    """
    Returns the standard error of the values in the passed list using N-1
    in the denominator (i.e., to estimate population standard error).

    Usage:   lsterr(inlist)
    """
    return stdev(inlist) / float(math.sqrt(len(inlist)))


def lsem (inlist):
    """
    Returns the estimated standard error of the mean (sx-bar) of the
    values in the passed list.  sem = stdev / sqrt(n)

    Usage:   lsem(inlist)
    """
    sd = stdev(inlist)
    n = len(inlist)
    return sd/math.sqrt(n)


def lz (inlist, score):
    """
    Returns the z-score for a given input score, given that score and the
    list from which that score came.  Not appropriate for population calculations.

    Usage:   lz(inlist, score)
    """
    z = (score-mean(inlist))/samplestdev(inlist)
    return z


def lzs (inlist):
    """
    Returns a list of z-scores, one for each score in the passed list.

    Usage:   lzs(inlist)
    """
    zscores = []
    for item in inlist:
        zscores.append(z(inlist,item))
    return zscores


####################################
#######  TRIMMING FUNCTIONS  #######
####################################

def ltrimboth (l,proportiontocut):
    """
    Slices off the passed proportion of items from BOTH ends of the passed
    list (i.e., with proportiontocut=0.1, slices 'leftmost' 10% AND 'rightmost'
    10% of scores.  Assumes list is sorted by magnitude.  Slices off LESS if
    proportion results in a non-integer slice index (i.e., conservatively
    slices off proportiontocut).

    Usage:   ltrimboth (l,proportiontocut)
    Returns: trimmed version of list l
    """
    lowercut = int(proportiontocut*len(l))
    uppercut = len(l) - lowercut
    return l[lowercut:uppercut]


def ltrim1 (l,proportiontocut,tail='right'):
    """
    Slices off the passed proportion of items from ONE end of the passed
    list (i.e., if proportiontocut=0.1, slices off 'leftmost' or 'rightmost'
    10% of scores).  Slices off LESS if proportion results in a non-integer
    slice index (i.e., conservatively slices off proportiontocut).

    Usage:   ltrim1 (l,proportiontocut,tail='right')  or set tail='left'
    Returns: trimmed version of list l
    """
    if tail == 'right':
        lowercut = 0
        uppercut = len(l) - int(proportiontocut*len(l))
    elif tail == 'left':
        lowercut = int(proportiontocut*len(l))
        uppercut = len(l)
    return l[lowercut:uppercut]


####################################
#####  CORRELATION FUNCTIONS  ######
####################################

def lpaired(x,y):
    """
    Interactively determines the type of data and then runs the
    appropriated statistic for paired group data.

    Usage:   lpaired(x,y)
    Returns: appropriate statistic name, value, and probability
    """
    samples = ''
    while samples not in ['i','r','I','R','c','C']:
        print '\nIndependent or related samples, or correlation (i,r,c): ',
        samples = raw_input()

    if samples in ['i','I','r','R']:
        print '\nComparing variances ...',
        # USE O'BRIEN'S TEST FOR HOMOGENEITY OF VARIANCE, Maxwell & delaney, p.112
        r = obrientransform(x,y)
        f,p = F_oneway(pstat.colex(r,0),pstat.colex(r,1))
        if p<0.05:
            vartype='unequal, p='+str(round(p,4))
        else:
            vartype='equal'
        print vartype
        if samples in ['i','I']:
            if vartype[0]=='e':
                t,p = ttest_ind(x,y,0)
                print '\nIndependent samples t-test:  ', round(t,4),round(p,4)
            else:
                if len(x)>20 or len(y)>20:
                    z,p = ranksums(x,y)
                    print '\nRank Sums test (NONparametric, n>20):  ', round(z,4),round(p,4)
                else:
                    u,p = mannwhitneyu(x,y)
                    print '\nMann-Whitney U-test (NONparametric, ns<20):  ', round(u,4),round(p,4)

        else:  # RELATED SAMPLES
            if vartype[0]=='e':
                t,p = ttest_rel(x,y,0)
                print '\nRelated samples t-test:  ', round(t,4),round(p,4)
            else:
                t,p = ranksums(x,y)
                print '\nWilcoxon T-test (NONparametric):  ', round(t,4),round(p,4)
    else:  # CORRELATION ANALYSIS
        corrtype = ''
        while corrtype not in ['c','C','r','R','d','D']:
            print '\nIs the data Continuous, Ranked, or Dichotomous (c,r,d): ',
            corrtype = raw_input()
        if corrtype in ['c','C']:
            m,b,r,p,see = linregress(x,y)
            print '\nLinear regression for continuous variables ...'
            lol = [['Slope','Intercept','r','Prob','SEestimate'],[round(m,4),round(b,4),round(r,4),round(p,4),round(see,4)]]
            pstat.printcc(lol)
        elif corrtype in ['r','R']:
            r,p = spearmanr(x,y)
            print '\nCorrelation for ranked variables ...'
            print "Spearman's r: ",round(r,4),round(p,4)
        else: # DICHOTOMOUS
            r,p = pointbiserialr(x,y)
            print '\nAssuming x contains a dichotomous variable ...'
            print 'Point Biserial r: ',round(r,4),round(p,4)
    print '\n\n'
    return None


def lpearsonr(x,y):
    """
    Calculates a Pearson correlation coefficient and the associated
    probability value.  Taken from Heiman's Basic Statistics for the Behav.
    Sci (2nd), p.195.

    Usage:   lpearsonr(x,y)      where x and y are equal-length lists
    Returns: Pearson's r value, two-tailed p-value
    """
    TINY = 1.0e-30
    if len(x) <> len(y):
        raise ValueError, 'Input values not paired in pearsonr.  Aborting.'
    n = len(x)
    x = map(float,x)
    y = map(float,y)
    xmean = mean(x)
    ymean = mean(y)
    r_num = n*(summult(x,y)) - sum(x)*sum(y)
    r_den = math.sqrt((n*ss(x) - square_of_sums(x))*(n*ss(y)-square_of_sums(y)))
    r = (r_num / r_den)  # denominator already a float
    df = n-2
    t = r*math.sqrt(df/((1.0-r+TINY)*(1.0+r+TINY)))
    prob = betai(0.5*df,0.5,df/float(df+t*t))
    return r, prob


def llincc(x,y):
    """
    Calculates Lin's concordance correlation coefficient.

    Usage:   alincc(x,y)    where x, y are equal-length arrays
    Returns: Lin's CC
    """
    covar = lcov(x,y)*(len(x)-1)/float(len(x))  # correct denom to n
    xvar = lvar(x)*(len(x)-1)/float(len(x))  # correct denom to n
    yvar = lvar(y)*(len(y)-1)/float(len(y))  # correct denom to n
    lincc = (2 * covar) / ((xvar+yvar) +((amean(x)-amean(y))**2))
    return lincc


def lspearmanr(x,y):
    """
    Calculates a Spearman rank-order correlation coefficient.  Taken
    from Heiman's Basic Statistics for the Behav. Sci (1st), p.192.

    Usage:   lspearmanr(x,y)      where x and y are equal-length lists
    Returns: Spearman's r, two-tailed p-value
    """
    TINY = 1e-30
    if len(x) <> len(y):
        raise ValueError, 'Input values not paired in spearmanr.  Aborting.'
    n = len(x)
    rankx = rankdata(x)
    ranky = rankdata(y)
    dsq = sumdiffsquared(rankx,ranky)
    rs = 1 - 6*dsq / float(n*(n**2-1))
    t = rs * math.sqrt((n-2) / ((rs+1.0)*(1.0-rs)))
    df = n-2
    probrs = betai(0.5*df,0.5,df/(df+t*t))  # t already a float
    # probability values for rs are from part 2 of the spearman function in
    # Numerical Recipes, p.510.  They are close to tables, but not exact. (?)
    return rs, probrs


def lpointbiserialr(x,y):
    """
    Calculates a point-biserial correlation coefficient and the associated
    probability value.  Taken from Heiman's Basic Statistics for the Behav.
    Sci (1st), p.194.

    Usage:   lpointbiserialr(x,y)      where x,y are equal-length lists
    Returns: Point-biserial r, two-tailed p-value
    """
    TINY = 1e-30
    if len(x) <> len(y):
        raise ValueError, 'INPUT VALUES NOT PAIRED IN pointbiserialr.  ABORTING.'
    data = pstat.abut(x,y)
    categories = pstat.unique(x)
    if len(categories) <> 2:
        raise ValueError, "Exactly 2 categories required for pointbiserialr()."
    else:   # there are 2 categories, continue
        codemap = pstat.abut(categories,range(2))
        recoded = pstat.recode(data,codemap,0)
        x = pstat.linexand(data,0,categories[0])
        y = pstat.linexand(data,0,categories[1])
        xmean = mean(pstat.colex(x,1))
        ymean = mean(pstat.colex(y,1))
        n = len(data)
        adjust = math.sqrt((len(x)/float(n))*(len(y)/float(n)))
        rpb = (ymean - xmean)/samplestdev(pstat.colex(data,1))*adjust
        df = n-2
        t = rpb*math.sqrt(df/((1.0-rpb+TINY)*(1.0+rpb+TINY)))
        prob = betai(0.5*df,0.5,df/(df+t*t))  # t already a float
        return rpb, prob


def lkendalltau(x,y):
    """
    Calculates Kendall's tau ... correlation of ordinal data.  Adapted
    from function kendl1 in Numerical Recipes.  Needs good test-routine.@@@

    Usage:   lkendalltau(x,y)
    Returns: Kendall's tau, two-tailed p-value
    """
    n1 = 0
    n2 = 0
    iss = 0
    for j in range(len(x)-1):
        for k in range(j,len(y)):
            a1 = x[j] - x[k]
            a2 = y[j] - y[k]
            aa = a1 * a2
            if (aa):             # neither list has a tie
                n1 = n1 + 1
                n2 = n2 + 1
                if aa > 0:
                    iss = iss + 1
                else:
                    iss = iss -1
            else:
                if (a1):
                    n1 = n1 + 1
                else:
                    n2 = n2 + 1
    tau = iss / math.sqrt(n1*n2)
    svar = (4.0*len(x)+10.0) / (9.0*len(x)*(len(x)-1))
    z = tau / math.sqrt(svar)
    prob = erfcc(abs(z)/1.4142136)
    return tau, prob


def llinregress(x,y):
    """
    Calculates a regression line on x,y pairs.  

    Usage:   llinregress(x,y)      x,y are equal-length lists of x-y coordinates
    Returns: slope, intercept, r, two-tailed prob, sterr-of-estimate
    """
    TINY = 1.0e-20
    if len(x) <> len(y):
        raise ValueError, 'Input values not paired in linregress.  Aborting.'
    n = len(x)
    x = map(float,x)
    y = map(float,y)
    xmean = mean(x)
    ymean = mean(y)
    r_num = float(n*(summult(x,y)) - sum(x)*sum(y))
    r_den = math.sqrt((n*ss(x) - square_of_sums(x))*(n*ss(y)-square_of_sums(y)))
    r = r_num / r_den
    z = 0.5*math.log((1.0+r+TINY)/(1.0-r+TINY))
    df = n-2
    t = r*math.sqrt(df/((1.0-r+TINY)*(1.0+r+TINY)))
    prob = betai(0.5*df,0.5,df/(df+t*t))
    slope = r_num / float(n*ss(x) - square_of_sums(x))
    intercept = ymean - slope*xmean
    sterrest = math.sqrt(1-r*r)*samplestdev(y)
    return slope, intercept, r, prob, sterrest


####################################
#####  INFERENTIAL STATISTICS  #####
####################################

def lttest_1samp(a,popmean,printit=0,name='Sample',writemode='a'):
    """
    Calculates the t-obtained for the independent samples T-test on ONE group
    of scores a, given a population mean.  If printit=1, results are printed
    to the screen.  If printit='filename', the results are output to 'filename'
    using the given writemode (default=append).  Returns t-value, and prob.

    Usage:   lttest_1samp(a,popmean,Name='Sample',printit=0,writemode='a')
    Returns: t-value, two-tailed prob
    """
    x = mean(a)
    v = var(a)
    n = len(a)
    df = n-1
    svar = ((n-1)*v)/float(df)
    t = (x-popmean)/math.sqrt(svar*(1.0/n))
    prob = betai(0.5*df,0.5,float(df)/(df+t*t))

    if printit <> 0:
        statname = 'Single-sample T-test.'
        outputpairedstats(printit,writemode,
                          'Population','--',popmean,0,0,0,
                          name,n,x,v,min(a),max(a),
                          statname,t,prob)
    return t,prob


def lttest_ind (a, b, printit=0, name1='Samp1', name2='Samp2', writemode='a'):
    """
    Calculates the t-obtained T-test on TWO INDEPENDENT samples of
    scores a, and b.  From Numerical Recipes, p.483.  If printit=1, results
    are printed to the screen.  If printit='filename', the results are output
    to 'filename' using the given writemode (default=append).  Returns t-value,
    and prob.

    Usage:   lttest_ind(a,b,printit=0,name1='Samp1',name2='Samp2',writemode='a')
    Returns: t-value, two-tailed prob
    """
    x1 = mean(a)
    x2 = mean(b)
    v1 = stdev(a)**2
    v2 = stdev(b)**2
    n1 = len(a)
    n2 = len(b)
    df = n1+n2-2
    svar = ((n1-1)*v1+(n2-1)*v2)/float(df)
    t = (x1-x2)/math.sqrt(svar*(1.0/n1 + 1.0/n2))
    prob = betai(0.5*df,0.5,df/(df+t*t))

    if printit <> 0:
        statname = 'Independent samples T-test.'
        outputpairedstats(printit,writemode,
                          name1,n1,x1,v1,min(a),max(a),
                          name2,n2,x2,v2,min(b),max(b),
                          statname,t,prob)
    return t,prob


def lttest_rel (a,b,printit=0,name1='Sample1',name2='Sample2',writemode='a'):
    """
    Calculates the t-obtained T-test on TWO RELATED samples of scores,
    a and b.  From Numerical Recipes, p.483.  If printit=1, results are
    printed to the screen.  If printit='filename', the results are output to
    'filename' using the given writemode (default=append).  Returns t-value,
    and prob.

    Usage:   lttest_rel(a,b,printit=0,name1='Sample1',name2='Sample2',writemode='a')
    Returns: t-value, two-tailed prob
    """
    if len(a)<>len(b):
        raise ValueError, 'Unequal length lists in ttest_rel.'
    x1 = mean(a)
    x2 = mean(b)
    v1 = var(a)
    v2 = var(b)
    n = len(a)
    cov = 0
    for i in range(len(a)):
        cov = cov + (a[i]-x1) * (b[i]-x2)
    df = n-1
    cov = cov / float(df)
    sd = math.sqrt((v1+v2 - 2.0*cov)/float(n))
    t = (x1-x2)/sd
    prob = betai(0.5*df,0.5,df/(df+t*t))

    if printit <> 0:
        statname = 'Related samples T-test.'
        outputpairedstats(printit,writemode,
                          name1,n,x1,v1,min(a),max(a),
                          name2,n,x2,v2,min(b),max(b),
                          statname,t,prob)
    return t, prob


def lchisquare(f_obs,f_exp=None):
    """
    Calculates a one-way chi square for list of observed frequencies and returns
    the result.  If no expected frequencies are given, the total N is assumed to
    be equally distributed across all groups.

    Usage:   lchisquare(f_obs, f_exp=None)   f_obs = list of observed cell freq.
    Returns: chisquare-statistic, associated p-value
    """
    k = len(f_obs)                 # number of groups
    if f_exp == None:
        f_exp = [sum(f_obs)/float(k)] * len(f_obs) # create k bins with = freq.
    chisq = 0
    for i in range(len(f_obs)):
        chisq = chisq + (f_obs[i]-f_exp[i])**2 / float(f_exp[i])
    return chisq, chisqprob(chisq, k-1)


def lks_2samp (data1,data2):
    """
    Computes the Kolmogorov-Smirnof statistic on 2 samples.  From
    Numerical Recipes in C, page 493.

    Usage:   lks_2samp(data1,data2)   data1&2 are lists of values for 2 conditions
    Returns: KS D-value, associated p-value
    """
    j1 = 0
    j2 = 0
    fn1 = 0.0
    fn2 = 0.0
    n1 = len(data1)
    n2 = len(data2)
    en1 = n1
    en2 = n2
    d = 0.0
    data1.sort()
    data2.sort()
    while j1 < n1 and j2 < n2:
        d1=data1[j1]
        d2=data2[j2]
        if d1 <= d2:
            fn1 = (j1)/float(en1)
            j1 = j1 + 1
        if d2 <= d1:
            fn2 = (j2)/float(en2)
            j2 = j2 + 1
        dt = (fn2-fn1)
        if math.fabs(dt) > math.fabs(d):
            d = dt
    try:
        en = math.sqrt(en1*en2/float(en1+en2))
        prob = ksprob((en+0.12+0.11/en)*abs(d))
    except:
        prob = 1.0
    return d, prob


def lmannwhitneyu(x,y):
    """
    Calculates a Mann-Whitney U statistic on the provided scores and
    returns the result.  Use only when the n in each condition is < 20 and
    you have 2 independent samples of ranks.  NOTE: Mann-Whitney U is
    significant if the u-obtained is LESS THAN or equal to the critical
    value of U found in the tables.  Equivalent to Kruskal-Wallis H with
    just 2 groups.

    Usage:   lmannwhitneyu(data)
    Returns: u-statistic, one-tailed p-value (i.e., p(z(U)))
    """
    n1 = len(x)
    n2 = len(y)
    ranked = rankdata(x+y)
    rankx = ranked[0:n1]       # get the x-ranks
    ranky = ranked[n1:]        # the rest are y-ranks
    u1 = n1*n2 + (n1*(n1+1))/2.0 - sum(rankx)  # calc U for x
    u2 = n1*n2 - u1                            # remainder is U for y
    bigu = max(u1,u2)
    smallu = min(u1,u2)
    T = math.sqrt(tiecorrect(ranked))  # correction factor for tied scores
    if T == 0:
        raise ValueError, 'All numbers are identical in lmannwhitneyu'
    sd = math.sqrt(T*n1*n2*(n1+n2+1)/12.0)
    z = abs((bigu-n1*n2/2.0) / sd)  # normal approximation for prob calc
    return smallu, 1.0 - zprob(z)


def ltiecorrect(rankvals):
    """
    Corrects for ties in Mann Whitney U and Kruskal Wallis H tests.  See
    Siegel, S. (1956) Nonparametric Statistics for the Behavioral Sciences.
    New York: McGraw-Hill.  Code adapted from |Stat rankind.c code.

    Usage:   ltiecorrect(rankvals)
    Returns: T correction factor for U or H
    """
    sorted,posn = shellsort(rankvals)
    n = len(sorted)
    T = 0.0
    i = 0
    while (i<n-1):
        if sorted[i] == sorted[i+1]:
            nties = 1
            while (i<n-1) and (sorted[i] == sorted[i+1]):
                nties = nties +1
                i = i +1
            T = T + nties**3 - nties
        i = i+1
    T = T / float(n**3-n)
    return 1.0 - T


def lranksums(x,y):
    """
    Calculates the rank sums statistic on the provided scores and
    returns the result.  Use only when the n in each condition is > 20 and you
    have 2 independent samples of ranks.

    Usage:   lranksums(x,y)
    Returns: a z-statistic, two-tailed p-value
    """
    n1 = len(x)
    n2 = len(y)
    alldata = x+y
    ranked = rankdata(alldata)
    x = ranked[:n1]
    y = ranked[n1:]
    s = sum(x)
    expected = n1*(n1+n2+1) / 2.0
    z = (s - expected) / math.sqrt(n1*n2*(n1+n2+1)/12.0)
    prob = 2*(1.0 -zprob(abs(z)))
    return z, prob


def lwilcoxont(x,y):
    """
    Calculates the Wilcoxon T-test for related samples and returns the
    result.  A non-parametric T-test.

    Usage:   lwilcoxont(x,y)
    Returns: a t-statistic, two-tail probability estimate
    """
    if len(x) <> len(y):
        raise ValueError, 'Unequal N in wilcoxont.  Aborting.'
    d=[]
    for i in range(len(x)):
        diff = x[i] - y[i]
        if diff <> 0:
            d.append(diff)
    count = len(d)
    absd = map(abs,d)
    absranked = rankdata(absd)
    r_plus = 0.0
    r_minus = 0.0
    for i in range(len(absd)):
        if d[i] < 0:
            r_minus = r_minus + absranked[i]
        else:
            r_plus = r_plus + absranked[i]
    wt = min(r_plus, r_minus)
    mn = count * (count+1) * 0.25
    se =  math.sqrt(count*(count+1)*(2.0*count+1.0)/24.0)
    z = math.fabs(wt-mn) / se
    prob = 2*(1.0 -zprob(abs(z)))
    return wt, prob


def lkruskalwallish(*args):
    """
    The Kruskal-Wallis H-test is a non-parametric ANOVA for 3 or more
    groups, requiring at least 5 subjects in each group.  This function
    calculates the Kruskal-Wallis H-test for 3 or more independent samples
    and returns the result.  

    Usage:   lkruskalwallish(*args)
    Returns: H-statistic (corrected for ties), associated p-value
    """
    args = list(args)
    n = [0]*len(args)
    all = []
    n = map(len,args)
    for i in range(len(args)):
        all = all + args[i]
    ranked = rankdata(all)
    T = tiecorrect(ranked)
    for i in range(len(args)):
        args[i] = ranked[0:n[i]]
        del ranked[0:n[i]]
    rsums = []
    for i in range(len(args)):
        rsums.append(sum(args[i])**2)
        rsums[i] = rsums[i] / float(n[i])
    ssbn = sum(rsums)
    totaln = sum(n)
    h = 12.0 / (totaln*(totaln+1)) * ssbn - 3*(totaln+1)
    df = len(args) - 1
    if T == 0:
        raise ValueError, 'All numbers are identical in lkruskalwallish'
    h = h / float(T)
    return h, chisqprob(h,df)


def lfriedmanchisquare(*args):
    """
    Friedman Chi-Square is a non-parametric, one-way within-subjects
    ANOVA.  This function calculates the Friedman Chi-square test for repeated
    measures and returns the result, along with the associated probability
    value.  It assumes 3 or more repeated measures.  Only 3 levels requires a
    minimum of 10 subjects in the study.  Four levels requires 5 subjects per
    level(??).

    Usage:   lfriedmanchisquare(*args)
    Returns: chi-square statistic, associated p-value
    """
    k = len(args)
    if k < 3:
        raise ValueError, 'Less than 3 levels.  Friedman test not appropriate.'
    n = len(args[0])
    data = apply(pstat.abut,tuple(args))
    for i in range(len(data)):
        data[i] = rankdata(data[i])
    ssbn = 0
    for i in range(k):
        ssbn = ssbn + sum(args[i])**2
    chisq = 12.0 / (k*n*(k+1)) * ssbn - 3*n*(k+1)
    return chisq, chisqprob(chisq,k-1)


####################################
####  PROBABILITY CALCULATIONS  ####
####################################

def lchisqprob(chisq,df):
    """
    Returns the (1-tailed) probability value associated with the provided
    chi-square value and df.  Adapted from chisq.c in Gary Perlman's |Stat.

    Usage:   lchisqprob(chisq,df)
    """
    BIG = 20.0
    def ex(x):
        BIG = 20.0
        if x < -BIG:
            return 0.0
        else:
            return math.exp(x)

    if chisq <=0 or df < 1:
        return 1.0
    a = 0.5 * chisq
    if df%2 == 0:
        even = 1
    else:
        even = 0
    if df > 1:
        y = ex(-a)
    if even:
        s = y
    else:
        s = 2.0 * zprob(-math.sqrt(chisq))
    if (df > 2):
        chisq = 0.5 * (df - 1.0)
        if even:
            z = 1.0
        else:
            z = 0.5
        if a > BIG:
            if even:
                e = 0.0
            else:
                e = math.log(math.sqrt(math.pi))
            c = math.log(a)
            while (z <= chisq):
                e = math.log(z) + e
                s = s + ex(c*z-a-e)
                z = z + 1.0
            return s
        else:
            if even:
                e = 1.0
            else:
                e = 1.0 / math.sqrt(math.pi) / math.sqrt(a)
            c = 0.0
            while (z <= chisq):
                e = e * (a/float(z))
                c = c + e
                z = z + 1.0
            return (c*y+s)
    else:
        return s


def lerfcc(x):
    """
    Returns the complementary error function erfc(x) with fractional
    error everywhere less than 1.2e-7.  Adapted from Numerical Recipes.

    Usage:   lerfcc(x)
    """
    z = abs(x)
    t = 1.0 / (1.0+0.5*z)
    ans = t * math.exp(-z*z-1.26551223 + t*(1.00002368+t*(0.37409196+t*(0.09678418+t*(-0.18628806+t*(0.27886807+t*(-1.13520398+t*(1.48851587+t*(-0.82215223+t*0.17087277)))))))))
    if x >= 0:
        return ans
    else:
        return 2.0 - ans


def lzprob(z):
    """
    Returns the area under the normal curve 'to the left of' the given z value.
    Thus, 
        - for z<0, zprob(z) = 1-tail probability
        - for z>0, 1.0-zprob(z) = 1-tail probability
        - for any z, 2.0*(1.0-zprob(abs(z))) = 2-tail probability
    Adapted from z.c in Gary Perlman's |Stat.

    Usage:   lzprob(z)
    """
    Z_MAX = 6.0    # maximum meaningful z-value
    if z == 0.0:
        x = 0.0
    else:
        y = 0.5 * math.fabs(z)
        if y >= (Z_MAX*0.5):
            x = 1.0
        elif (y < 1.0):
            w = y*y
            x = ((((((((0.000124818987 * w
                        -0.001075204047) * w +0.005198775019) * w
                      -0.019198292004) * w +0.059054035642) * w
                    -0.151968751364) * w +0.319152932694) * w
                  -0.531923007300) * w +0.797884560593) * y * 2.0
        else:
            y = y - 2.0
            x = (((((((((((((-0.000045255659 * y
                             +0.000152529290) * y -0.000019538132) * y
                           -0.000676904986) * y +0.001390604284) * y
                         -0.000794620820) * y -0.002034254874) * y
                       +0.006549791214) * y -0.010557625006) * y
                     +0.011630447319) * y -0.009279453341) * y
                   +0.005353579108) * y -0.002141268741) * y
                 +0.000535310849) * y +0.999936657524
    if z > 0.0:
        prob = ((x+1.0)*0.5)
    else:
        prob = ((1.0-x)*0.5)
    return prob


def lksprob(alam):
    """
    Computes a Kolmolgorov-Smirnov t-test significance level.  Adapted from
    Numerical Recipes.

    Usage:   lksprob(alam)
    """
    fac = 2.0
    sum = 0.0
    termbf = 0.0
    a2 = -2.0*alam*alam
    for j in range(1,201):
        term = fac*math.exp(a2*j*j)
        sum = sum + term
        if math.fabs(term) <= (0.001*termbf) or math.fabs(term) < (1.0e-8*sum):
            return sum
        fac = -fac
        termbf = math.fabs(term)
    return 1.0             # Get here only if fails to converge; was 0.0!!


def lfprob (dfnum, dfden, F):
    """
    Returns the (1-tailed) significance level (p-value) of an F
    statistic given the degrees of freedom for the numerator (dfR-dfF) and
    the degrees of freedom for the denominator (dfF).

    Usage:   lfprob(dfnum, dfden, F)   where usually dfnum=dfbn, dfden=dfwn
    """
    p = betai(0.5*dfden, 0.5*dfnum, dfden/float(dfden+dfnum*F))
    return p


def lbetacf(a,b,x):
    """
    This function evaluates the continued fraction form of the incomplete
    Beta function, betai.  (Adapted from: Numerical Recipes in C.)

    Usage:   lbetacf(a,b,x)
    """
    ITMAX = 200
    EPS = 3.0e-7

    bm = az = am = 1.0
    qab = a+b
    qap = a+1.0
    qam = a-1.0
    bz = 1.0-qab*x/qap
    for i in range(ITMAX+1):
        em = float(i+1)
        tem = em + em
        d = em*(b-em)*x/((qam+tem)*(a+tem))
        ap = az + d*am
        bp = bz+d*bm
        d = -(a+em)*(qab+em)*x/((qap+tem)*(a+tem))
        app = ap+d*az
        bpp = bp+d*bz
        aold = az
        am = ap/bpp
        bm = bp/bpp
        az = app/bpp
        bz = 1.0
        if (abs(az-aold)<(EPS*abs(az))):
            return az
    print 'a or b too big, or ITMAX too small in Betacf.'


def lgammln(xx):
    """
    Returns the gamma function of xx.
    Gamma(z) = Integral(0,infinity) of t^(z-1)exp(-t) dt.
    (Adapted from: Numerical Recipes in C.)

    Usage:   lgammln(xx)
    """

    coeff = [76.18009173, -86.50532033, 24.01409822, -1.231739516,
             0.120858003e-2, -0.536382e-5]
    x = xx - 1.0
    tmp = x + 5.5
    tmp = tmp - (x+0.5)*math.log(tmp)
    ser = 1.0
    for j in range(len(coeff)):
        x = x + 1
        ser = ser + coeff[j]/x
    return -tmp + math.log(2.50662827465*ser)


def lbetai(a,b,x):
    """
    Returns the incomplete beta function:

    I-sub-x(a,b) = 1/B(a,b)*(Integral(0,x) of t^(a-1)(1-t)^(b-1) dt)

    where a,b>0 and B(a,b) = G(a)*G(b)/(G(a+b)) where G(a) is the gamma
    function of a.  The continued fraction formulation is implemented here,
    using the betacf function.  (Adapted from: Numerical Recipes in C.)

    Usage:   lbetai(a,b,x)
    """
    if (x<0.0 or x>1.0):
        raise ValueError, 'Bad x in lbetai'
    if (x==0.0 or x==1.0):
        bt = 0.0
    else:
        bt = math.exp(gammln(a+b)-gammln(a)-gammln(b)+a*math.log(x)+b*
                      math.log(1.0-x))
    if (x<(a+1.0)/(a+b+2.0)):
        return bt*betacf(a,b,x)/float(a)
    else:
        return 1.0-bt*betacf(b,a,1.0-x)/float(b)


####################################
#######  ANOVA CALCULATIONS  #######
####################################

def lF_oneway(*lists):
    """
    Performs a 1-way ANOVA, returning an F-value and probability given
    any number of groups.  From Heiman, pp.394-7.

    Usage:   F_oneway(*lists)    where *lists is any number of lists, one per treatment group
    Returns: F value, one-tailed p-value
    """
    a = len(lists)           # ANOVA on 'a' groups, each in it's own list
    means = [0]*a
    vars = [0]*a
    ns = [0]*a
    alldata = []
    tmp = map(N.array,lists)
    means = map(amean,tmp)
    vars = map(avar,tmp)
    ns = map(len,lists)
    for i in range(len(lists)):
        alldata = alldata + lists[i]
    alldata = N.array(alldata)
    bign = len(alldata)
    sstot = ass(alldata)-(asquare_of_sums(alldata)/float(bign))
    ssbn = 0
    for list in lists:
        ssbn = ssbn + asquare_of_sums(N.array(list))/float(len(list))
    ssbn = ssbn - (asquare_of_sums(alldata)/float(bign))
    sswn = sstot-ssbn
    dfbn = a-1
    dfwn = bign - a
    msb = ssbn/float(dfbn)
    msw = sswn/float(dfwn)
    f = msb/msw
    prob = fprob(dfbn,dfwn,f)
    return f, prob


def lF_value (ER,EF,dfnum,dfden):
    """
    Returns an F-statistic given the following:
    ER  = error associated with the null hypothesis (the Restricted model)
    EF  = error associated with the alternate hypothesis (the Full model)
    dfR-dfF = degrees of freedom of the numerator
    dfF = degrees of freedom associated with the denominator/Full model

    Usage:   lF_value(ER,EF,dfnum,dfden)
    """
    return ((ER-EF)/float(dfnum) / (EF/float(dfden)))


####################################
########  SUPPORT FUNCTIONS  #######
####################################

def writecc (listoflists,file,writetype='w',extra=2):
    """
    Writes a list of lists to a file in columns, customized by the max
    size of items within the columns (max size of items in col, +2 characters)
    to specified file.  File-overwrite is the default.

    Usage:   writecc (listoflists,file,writetype='w',extra=2)
    Returns: None
    """
    if type(listoflists[0]) not in [ListType,TupleType]:
        listoflists = [listoflists]
    outfile = open(file,writetype)
    rowstokill = []
    list2print = copy.deepcopy(listoflists)
    for i in range(len(listoflists)):
        if listoflists[i] == ['\n'] or listoflists[i]=='\n' or listoflists[i]=='dashes':
            rowstokill = rowstokill + [i]
    rowstokill.reverse()
    for row in rowstokill:
        del list2print[row]
    maxsize = [0]*len(list2print[0])
    for col in range(len(list2print[0])):
        items = pstat.colex(list2print,col)
        items = map(pstat.makestr,items)
        maxsize[col] = max(map(len,items)) + extra
    for row in listoflists:
        if row == ['\n'] or row == '\n':
            outfile.write('\n')
        elif row == ['dashes'] or row == 'dashes':
            dashes = [0]*len(maxsize)
            for j in range(len(maxsize)):
                dashes[j] = '-'*(maxsize[j]-2)
            outfile.write(pstat.lineincustcols(dashes,maxsize))
        else:
            outfile.write(pstat.lineincustcols(row,maxsize))
        outfile.write('\n')
    outfile.close()
    return None


def lincr(l,cap):        # to increment a list up to a max-list of 'cap'
    """
    Simulate a counting system from an n-dimensional list.

    Usage:   lincr(l,cap)   l=list to increment, cap=max values for each list pos'n
    Returns: next set of values for list l, OR -1 (if overflow)
    """
    l[0] = l[0] + 1     # e.g., [0,0,0] --> [2,4,3] (=cap)
    for i in range(len(l)):
        if l[i] > cap[i] and i < len(l)-1: # if carryover AND not done
            l[i] = 0
            l[i+1] = l[i+1] + 1
        elif l[i] > cap[i] and i == len(l)-1: # overflow past last column, must be finished
            l = -1
    return l


def lsum (inlist):
    """
    Returns the sum of the items in the passed list.

    Usage:   lsum(inlist)
    """
    s = 0
    for item in inlist:
        s = s + item
    return s


def lcumsum (inlist):
    """
    Returns a list consisting of the cumulative sum of the items in the
    passed list.

    Usage:   lcumsum(inlist)
    """
    newlist = copy.deepcopy(inlist)
    for i in range(1,len(newlist)):
        newlist[i] = newlist[i] + newlist[i-1]
    return newlist


def lss(inlist):
    """
    Squares each value in the passed list, adds up these squares and
    returns the result.

    Usage:   lss(inlist)
    """
    ss = 0
    for item in inlist:
        ss = ss + item*item
    return ss


def lsummult (list1,list2):
    """
    Multiplies elements in list1 and list2, element by element, and
    returns the sum of all resulting multiplications.  Must provide equal
    length lists.

    Usage:   lsummult(list1,list2)
    """
    if len(list1) <> len(list2):
        raise ValueError, "Lists not equal length in summult."
    s = 0
    for item1,item2 in pstat.abut(list1,list2):
        s = s + item1*item2
    return s


def lsumdiffsquared(x,y):
    """
    Takes pairwise differences of the values in lists x and y, squares
    these differences, and returns the sum of these squares.

    Usage:   lsumdiffsquared(x,y)
    Returns: sum[(x[i]-y[i])**2]
    """
    sds = 0
    for i in range(len(x)):
        sds = sds + (x[i]-y[i])**2
    return sds


def lsquare_of_sums(inlist):
    """
    Adds the values in the passed list, squares the sum, and returns
    the result.

    Usage:   lsquare_of_sums(inlist)
    Returns: sum(inlist[i])**2
    """
    s = sum(inlist)
    return float(s)*s


def lshellsort(inlist):
    """
    Shellsort algorithm.  Sorts a 1D-list.

    Usage:   lshellsort(inlist)
    Returns: sorted-inlist, sorting-index-vector (for original list)
    """
    n = len(inlist)
    svec = copy.deepcopy(inlist)
    ivec = range(n)
    gap = n/2   # integer division needed
    while gap >0:
        for i in range(gap,n):
            for j in range(i-gap,-1,-gap):
                while j>=0 and svec[j]>svec[j+gap]:
                    temp        = svec[j]
                    svec[j]     = svec[j+gap]
                    svec[j+gap] = temp
                    itemp       = ivec[j]
                    ivec[j]     = ivec[j+gap]
                    ivec[j+gap] = itemp
        gap = gap / 2  # integer division needed
    # svec is now sorted inlist, and ivec has the order svec[i] = vec[ivec[i]]
    return svec, ivec

def lrankdata(inlist):
    """
    Ranks the data in inlist, dealing with ties appropritely.  Assumes
    a 1D inlist.  Adapted from Gary Perlman's |Stat ranksort.

    Usage:   lrankdata(inlist)
    Returns: a list of length equal to inlist, containing rank scores
    """
    n = len(inlist)
    svec, ivec = shellsort(inlist)
    sumranks = 0
    dupcount = 0
    newlist = [0]*n
    for i in range(n):
        sumranks = sumranks + i
        dupcount = dupcount + 1
        if i==n-1 or svec[i] <> svec[i+1]:
            averank = sumranks / float(dupcount) + 1
            for j in range(i-dupcount+1,i+1):
                newlist[ivec[j]] = averank
            sumranks = 0
            dupcount = 0
    return newlist


def outputpairedstats(fname,writemode,name1,n1,m1,se1,min1,max1,name2,n2,m2,se2,min2,max2,statname,stat,prob):
    """
    Prints or write to a file stats for two groups, using the name, n,
    mean, sterr, min and max for each group, as well as the statistic name,
    its value, and the associated p-value.

    Usage:   outputpairedstats(fname,writemode, name1,n1,mean1,stderr1,min1,max1, name2,n2,mean2,stderr2,min2,max2,statname,stat,prob)
    Returns: None
    """
    suffix = ''                       # for *s after the p-value
    try:
        x = prob.shape
        prob = prob[0]
    except:
        pass
    if  prob < 0.001:  suffix = '  ***'
    elif prob < 0.01:  suffix = '  **'
    elif prob < 0.05:  suffix = '  *'
    title = [['Name','N','Mean','SD','Min','Max']]
    lofl = title+[[name1,n1,round(m1,3),round(math.sqrt(se1),3),min1,max1],
                  [name2,n2,round(m2,3),round(math.sqrt(se2),3),min2,max2]]
    if type(fname)<>StringType or len(fname)==0:
        print
        print statname
        print
        pstat.printcc(lofl)
        print
        try:
            if stat.shape == ():
                stat = stat[0]
            if prob.shape == ():
                prob = prob[0]
        except:
            pass
        print 'Test statistic = ',round(stat,3),'   p = ',round(prob,3),suffix
        print
    else:
        file = open(fname,writemode)
        file.write('\n'+statname+'\n\n')
        file.close()
        writecc(lofl,fname,'a')
        file = open(fname,'a')
        try:
            if stat.shape == ():
                stat = stat[0]
            if prob.shape == ():
                prob = prob[0]
        except:
            pass
        file.write(pstat.list2string(['\nTest statistic = ',round(stat,4),'   p = ',round(prob,4),suffix,'\n\n']))
        file.close()
    return None


def lfindwithin (data):
    """
    Returns an integer representing a binary vector, where 1=within-
    subject factor, 0=between.  Input equals the entire data 2D list (i.e.,
    column 0=random factor, column -1=measured values (those two are skipped).
    Note: input data is in |Stat format ... a list of lists ("2D list") with 
    one row per measured value, first column=subject identifier, last column=
    score, one in-between column per factor (these columns contain level
    designations on each factor).  See also stats.anova.__doc__.

    Usage:   lfindwithin(data)     data in |Stat format
    """

    numfact = len(data[0])-1
    withinvec = 0
    for col in range(1,numfact):
        examplelevel = pstat.unique(pstat.colex(data,col))[0]
        rows = pstat.linexand(data,col,examplelevel)  # get 1 level of this factor
        factsubjs = pstat.unique(pstat.colex(rows,0))
        allsubjs = pstat.unique(pstat.colex(data,0))
        if len(factsubjs) == len(allsubjs):  # fewer Ss than scores on this factor?
            withinvec = withinvec + (1 << col)
    return withinvec


#########################################################
#########################################################
####### DISPATCH LISTS AND TUPLES TO ABOVE FCNS #########
#########################################################
#########################################################

## CENTRAL TENDENCY:
geometricmean = Dispatch ( (lgeometricmean, (ListType, TupleType)), )
harmonicmean = Dispatch ( (lharmonicmean, (ListType, TupleType)), )
mean = Dispatch ( (lmean, (ListType, TupleType)), )
median = Dispatch ( (lmedian, (ListType, TupleType)), )
medianscore = Dispatch ( (lmedianscore, (ListType, TupleType)), )
mode = Dispatch ( (lmode, (ListType, TupleType)), )

## MOMENTS:
moment = Dispatch ( (lmoment, (ListType, TupleType)), )
variation = Dispatch ( (lvariation, (ListType, TupleType)), )
skew = Dispatch ( (lskew, (ListType, TupleType)), )
kurtosis = Dispatch ( (lkurtosis, (ListType, TupleType)), )
describe = Dispatch ( (ldescribe, (ListType, TupleType)), )

## FREQUENCY STATISTICS:
itemfreq = Dispatch ( (litemfreq, (ListType, TupleType)), )
scoreatpercentile = Dispatch ( (lscoreatpercentile, (ListType, TupleType)), )
percentileofscore = Dispatch ( (lpercentileofscore, (ListType, TupleType)), )
histogram = Dispatch ( (lhistogram, (ListType, TupleType)), )
cumfreq = Dispatch ( (lcumfreq, (ListType, TupleType)), )
relfreq = Dispatch ( (lrelfreq, (ListType, TupleType)), )

## VARIABILITY:
obrientransform = Dispatch ( (lobrientransform, (ListType, TupleType)), )
samplevar = Dispatch ( (lsamplevar, (ListType, TupleType)), )
samplestdev = Dispatch ( (lsamplestdev, (ListType, TupleType)), )
var = Dispatch ( (lvar, (ListType, TupleType)), )
stdev = Dispatch ( (lstdev, (ListType, TupleType)), )
sterr = Dispatch ( (lsterr, (ListType, TupleType)), )
sem = Dispatch ( (lsem, (ListType, TupleType)), )
z = Dispatch ( (lz, (ListType, TupleType)), )
zs = Dispatch ( (lzs, (ListType, TupleType)), )

## TRIMMING FCNS:
trimboth = Dispatch ( (ltrimboth, (ListType, TupleType)), )
trim1 = Dispatch ( (ltrim1, (ListType, TupleType)), )

## CORRELATION FCNS:
paired = Dispatch ( (lpaired, (ListType, TupleType)), )
pearsonr = Dispatch ( (lpearsonr, (ListType, TupleType)), )
spearmanr = Dispatch ( (lspearmanr, (ListType, TupleType)), )
pointbiserialr = Dispatch ( (lpointbiserialr, (ListType, TupleType)), )
kendalltau = Dispatch ( (lkendalltau, (ListType, TupleType)), )
linregress = Dispatch ( (llinregress, (ListType, TupleType)), )

## INFERENTIAL STATS:
ttest_1samp = Dispatch ( (lttest_1samp, (ListType, TupleType)), )
ttest_ind = Dispatch ( (lttest_ind, (ListType, TupleType)), )
ttest_rel = Dispatch ( (lttest_rel, (ListType, TupleType)), )
chisquare = Dispatch ( (lchisquare, (ListType, TupleType)), )
ks_2samp = Dispatch ( (lks_2samp, (ListType, TupleType)), )
mannwhitneyu = Dispatch ( (lmannwhitneyu, (ListType, TupleType)), )
ranksums = Dispatch ( (lranksums, (ListType, TupleType)), )
tiecorrect = Dispatch ( (ltiecorrect, (ListType, TupleType)), )
wilcoxont = Dispatch ( (lwilcoxont, (ListType, TupleType)), )
kruskalwallish = Dispatch ( (lkruskalwallish, (ListType, TupleType)), )
friedmanchisquare = Dispatch ( (lfriedmanchisquare, (ListType, TupleType)), )

## PROBABILITY CALCS:
chisqprob = Dispatch ( (lchisqprob, (IntType, FloatType)), )
zprob = Dispatch ( (lzprob, (IntType, FloatType)), )
ksprob = Dispatch ( (lksprob, (IntType, FloatType)), )
fprob = Dispatch ( (lfprob, (IntType, FloatType)), )
betacf = Dispatch ( (lbetacf, (IntType, FloatType)), )
betai = Dispatch ( (lbetai, (IntType, FloatType)), )
erfcc = Dispatch ( (lerfcc, (IntType, FloatType)), )
gammln = Dispatch ( (lgammln, (IntType, FloatType)), )

## ANOVA FUNCTIONS:
F_oneway = Dispatch ( (lF_oneway, (ListType, TupleType)), )
F_value = Dispatch ( (lF_value, (ListType, TupleType)), )

## SUPPORT FUNCTIONS:
incr = Dispatch ( (lincr, (ListType, TupleType)), )
sum = Dispatch ( (lsum, (ListType, TupleType)), )
cumsum = Dispatch ( (lcumsum, (ListType, TupleType)), )
ss = Dispatch ( (lss, (ListType, TupleType)), )
summult = Dispatch ( (lsummult, (ListType, TupleType)), )
square_of_sums = Dispatch ( (lsquare_of_sums, (ListType, TupleType)), )
sumdiffsquared = Dispatch ( (lsumdiffsquared, (ListType, TupleType)), )
shellsort = Dispatch ( (lshellsort, (ListType, TupleType)), )
rankdata = Dispatch ( (lrankdata, (ListType, TupleType)), )
findwithin = Dispatch ( (lfindwithin, (ListType, TupleType)), )


#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============
#=============  THE ARRAY-VERSION OF THE STATS FUNCTIONS  ===============


   
#####################################
########  ACENTRAL TENDENCY  ########
#####################################

def ageometricmean (inarray,dimension=None,keepdims=0):
    """
    Calculates the geometric mean of the values in the passed array.
    That is:  n-th root of (x1 * x2 * ... * xn).  Defaults to ALL values in
    the passed array.  Use dimension=None to flatten array first.  REMEMBER: if
    dimension=0, it collapses over dimension 0 ('rows' in a 2D array) only, and
    if dimension is a sequence, it collapses over all specified dimensions.  If
    keepdims is set to 1, the resulting array will have as many dimensions as
    inarray, with only 1 'level' per dim that was collapsed over.
    
    Usage:   ageometricmean(inarray,dimension=None,keepdims=0)
    Returns: geometric mean computed over dim(s) listed in dimension
    """
    inarray = N.array(inarray,N.float_)
    if dimension == None:
        inarray = N.ravel(inarray)
        size = len(inarray)
        mult = N.power(inarray,1.0/size)
        mult = N.multiply.reduce(mult)
    elif type(dimension) in [IntType,FloatType]:
        size = inarray.shape[dimension]
        mult = N.power(inarray,1.0/size)
        mult = N.multiply.reduce(mult,dimension)
        if keepdims == 1:
            shp = list(inarray.shape)
            shp[dimension] = 1
            sum = N.reshape(sum,shp)
    else: # must be a SEQUENCE of dims to average over
        dims = list(dimension)
        dims.sort()
        dims.reverse()
        size = N.array(N.multiply.reduce(N.take(inarray.shape,dims)),N.float_)
        mult = N.power(inarray,1.0/size)
        for dim in dims:
            mult = N.multiply.reduce(mult,dim)
        if keepdims == 1:
            shp = list(inarray.shape)
            for dim in dims:
                shp[dim] = 1
            mult = N.reshape(mult,shp)
    return mult


def aharmonicmean (inarray,dimension=None,keepdims=0):
    """
    Calculates the harmonic mean of the values in the passed array.
    That is:  n / (1/x1 + 1/x2 + ... + 1/xn).  Defaults to ALL values in
    the passed array.  Use dimension=None to flatten array first.  REMEMBER: if
    dimension=0, it collapses over dimension 0 ('rows' in a 2D array) only, and
    if dimension is a sequence, it collapses over all specified dimensions.  If
    keepdims is set to 1, the resulting array will have as many dimensions as
    inarray, with only 1 'level' per dim that was collapsed over.
    
    Usage:   aharmonicmean(inarray,dimension=None,keepdims=0)
    Returns: harmonic mean computed over dim(s) in dimension
    """
    inarray = inarray.astype(N.float_)
    if dimension == None:
        inarray = N.ravel(inarray)
        size = len(inarray)
        s = N.add.reduce(1.0 / inarray)
    elif type(dimension) in [IntType,FloatType]:
        size = float(inarray.shape[dimension])
        s = N.add.reduce(1.0/inarray, dimension)
        if keepdims == 1:
            shp = list(inarray.shape)
            shp[dimension] = 1
            s = N.reshape(s,shp)
    else: # must be a SEQUENCE of dims to average over
        dims = list(dimension)
        dims.sort()
        nondims = []
        for i in range(len(inarray.shape)):
            if i not in dims:
                nondims.append(i)
        tinarray = N.transpose(inarray,nondims+dims) # put keep-dims first
        idx = [0] *len(nondims)
        if idx == []:
            size = len(N.ravel(inarray))
            s = asum(1.0 / inarray)
            if keepdims == 1:
                s = N.reshape([s],N.ones(len(inarray.shape)))
        else:
            idx[0] = -1
            loopcap = N.array(tinarray.shape[0:len(nondims)]) -1
            s = N.zeros(loopcap+1,N.float_)
            while incr(idx,loopcap) <> -1:
                s[idx] = asum(1.0/tinarray[idx])
            size = N.multiply.reduce(N.take(inarray.shape,dims))
            if keepdims == 1:
                shp = list(inarray.shape)
                for dim in dims:
                    shp[dim] = 1
                s = N.reshape(s,shp)
    return size / s


def amean (inarray,dimension=None,keepdims=0):
    """
    Calculates the arithmatic mean of the values in the passed array.
    That is:  1/n * (x1 + x2 + ... + xn).  Defaults to ALL values in the
    passed array.  Use dimension=None to flatten array first.  REMEMBER: if
    dimension=0, it collapses over dimension 0 ('rows' in a 2D array) only, and
    if dimension is a sequence, it collapses over all specified dimensions.  If
    keepdims is set to 1, the resulting array will have as many dimensions as
    inarray, with only 1 'level' per dim that was collapsed over.
    
    Usage:   amean(inarray,dimension=None,keepdims=0)
    Returns: arithematic mean calculated over dim(s) in dimension
    """
    if inarray.dtype in [N.int_, N.short,N.ubyte]:
        inarray = inarray.astype(N.float_)
    if dimension == None:
        inarray = N.ravel(inarray)
        sum = N.add.reduce(inarray)
        denom = float(len(inarray))
    elif type(dimension) in [IntType,FloatType]:
        sum = asum(inarray,dimension)
        denom = float(inarray.shape[dimension])
        if keepdims == 1:
            shp = list(inarray.shape)
            shp[dimension] = 1
            sum = N.reshape(sum,shp)
    else: # must be a TUPLE of dims to average over
        dims = list(dimension)
        dims.sort()
        dims.reverse()
        sum = inarray *1.0
        for dim in dims:
            sum = N.add.reduce(sum,dim)
        denom = N.array(N.multiply.reduce(N.take(inarray.shape,dims)),N.float_)
        if keepdims == 1:
            shp = list(inarray.shape)
            for dim in dims:
                shp[dim] = 1
            sum = N.reshape(sum,shp)
    return sum/denom


def amedian (inarray,numbins=1000):
    """
    Calculates the COMPUTED median value of an array of numbers, given the
    number of bins to use for the histogram (more bins approaches finding the
    precise median value of the array; default number of bins = 1000).  From
    G.W. Heiman's Basic Stats, or CRC Probability & Statistics.
    NOTE:  THIS ROUTINE ALWAYS uses the entire passed array (flattens it first).
    
    Usage:   amedian(inarray,numbins=1000)
    Returns: median calculated over ALL values in inarray
    """
    inarray = N.ravel(inarray)
    (hist, smallest, binsize, extras) = ahistogram(inarray,numbins,[min(inarray),max(inarray)])
    cumhist = N.cumsum(hist)            # make cumulative histogram
    otherbins = N.greater_equal(cumhist,len(inarray)/2.0)
    otherbins = list(otherbins)         # list of 0/1s, 1s start at median bin
    cfbin = otherbins.index(1)                # get 1st(!) index holding 50%ile score
    LRL = smallest + binsize*cfbin        # get lower read limit of that bin
    cfbelow = N.add.reduce(hist[0:cfbin])        # cum. freq. below bin
    freq = hist[cfbin]                        # frequency IN the 50%ile bin
    median = LRL + ((len(inarray)/2.0-cfbelow)/float(freq))*binsize # MEDIAN
    return median


def amedianscore (inarray,dimension=None):
    """
    Returns the 'middle' score of the passed array.  If there is an even
    number of scores, the mean of the 2 middle scores is returned.  Can function
    with 1D arrays, or on the FIRST dimension of 2D arrays (i.e., dimension can
    be None, to pre-flatten the array, or else dimension must equal 0).
    
    Usage:   amedianscore(inarray,dimension=None)
    Returns: 'middle' score of the array, or the mean of the 2 middle scores
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    inarray = N.sort(inarray,dimension)
    if inarray.shape[dimension] % 2 == 0:   # if even number of elements
        indx = inarray.shape[dimension]/2   # integer division correct
        median = N.asarray(inarray[indx]+inarray[indx-1]) / 2.0
    else:
        indx = inarray.shape[dimension] / 2 # integer division correct
        median = N.take(inarray,[indx],dimension)
        if median.shape == (1,):
            median = median[0]
    return median


def amode(a, dimension=None):
    """
    Returns an array of the modal (most common) score in the passed array.
    If there is more than one such score, ONLY THE FIRST is returned.
    The bin-count for the modal values is also returned.  Operates on whole
    array (dimension=None), or on a given dimension.
    
    Usage:   amode(a, dimension=None)
    Returns: array of bin-counts for mode(s), array of corresponding modal values
    """

    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    scores = pstat.aunique(N.ravel(a))       # get ALL unique values
    testshape = list(a.shape)
    testshape[dimension] = 1
    oldmostfreq = N.zeros(testshape)
    oldcounts = N.zeros(testshape)
    for score in scores:
        template = N.equal(a,score)
        counts = asum(template,dimension,1)
        mostfrequent = N.where(counts>oldcounts,score,oldmostfreq)
        oldcounts = N.where(counts>oldcounts,counts,oldcounts)
        oldmostfreq = mostfrequent
    return oldcounts, mostfrequent


def atmean(a,limits=None,inclusive=(1,1)):
    """
   Returns the arithmetic mean of all values in an array, ignoring values
   strictly outside the sequence passed to 'limits'.   Note: either limit
   in the sequence, or the value of limits itself, can be set to None.  The
   inclusive list/tuple determines whether the lower and upper limiting bounds
   (respectively) are open/exclusive (0) or closed/inclusive (1).
   
   Usage:   atmean(a,limits=None,inclusive=(1,1))
   """
    if a.dtype in [N.int_, N.short,N.ubyte]:
        a = a.astype(N.float_)
    if limits == None:
        return mean(a)
    assert type(limits) in [ListType,TupleType,N.ndarray], "Wrong type for limits in atmean"
    if inclusive[0]:         lowerfcn = N.greater_equal
    else:               lowerfcn = N.greater
    if inclusive[1]:         upperfcn = N.less_equal
    else:               upperfcn = N.less
    if limits[0] > N.maximum.reduce(N.ravel(a)) or limits[1] < N.minimum.reduce(N.ravel(a)):
        raise ValueError, "No array values within given limits (atmean)."
    elif limits[0]==None and limits[1]<>None:
        mask = upperfcn(a,limits[1])
    elif limits[0]<>None and limits[1]==None:
        mask = lowerfcn(a,limits[0])
    elif limits[0]<>None and limits[1]<>None:
        mask = lowerfcn(a,limits[0])*upperfcn(a,limits[1])
    s = float(N.add.reduce(N.ravel(a*mask)))
    n = float(N.add.reduce(N.ravel(mask)))
    return s/n


def atvar(a,limits=None,inclusive=(1,1)):
    """
   Returns the sample variance of values in an array, (i.e., using N-1),
   ignoring values strictly outside the sequence passed to 'limits'.  
   Note: either limit in the sequence, or the value of limits itself,
   can be set to None.  The inclusive list/tuple determines whether the lower
   and upper limiting bounds (respectively) are open/exclusive (0) or
   closed/inclusive (1). ASSUMES A FLAT ARRAY (OR ELSE PREFLATTENS).
   
   Usage:   atvar(a,limits=None,inclusive=(1,1))
   """
    a = a.astype(N.float_)
    if limits == None or limits == [None,None]:
        return avar(a)
    assert type(limits) in [ListType,TupleType,N.ndarray], "Wrong type for limits in atvar"
    if inclusive[0]:    lowerfcn = N.greater_equal
    else:               lowerfcn = N.greater
    if inclusive[1]:    upperfcn = N.less_equal
    else:               upperfcn = N.less
    if limits[0] > N.maximum.reduce(N.ravel(a)) or limits[1] < N.minimum.reduce(N.ravel(a)):
        raise ValueError, "No array values within given limits (atvar)."
    elif limits[0]==None and limits[1]<>None:
        mask = upperfcn(a,limits[1])
    elif limits[0]<>None and limits[1]==None:
        mask = lowerfcn(a,limits[0])
    elif limits[0]<>None and limits[1]<>None:
        mask = lowerfcn(a,limits[0])*upperfcn(a,limits[1])

    a = N.compress(mask,a)  # squish out excluded values
    return avar(a)


def atmin(a,lowerlimit=None,dimension=None,inclusive=1):
    """
   Returns the minimum value of a, along dimension, including only values less
   than (or equal to, if inclusive=1) lowerlimit.  If the limit is set to None,
   all values in the array are used.
   
   Usage:   atmin(a,lowerlimit=None,dimension=None,inclusive=1)
   """
    if inclusive:         lowerfcn = N.greater
    else:               lowerfcn = N.greater_equal
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    if lowerlimit == None:
        lowerlimit = N.minimum.reduce(N.ravel(a))-11
    biggest = N.maximum.reduce(N.ravel(a))
    ta = N.where(lowerfcn(a,lowerlimit),a,biggest)
    return N.minimum.reduce(ta,dimension)


def atmax(a,upperlimit,dimension=None,inclusive=1):
    """
   Returns the maximum value of a, along dimension, including only values greater
   than (or equal to, if inclusive=1) upperlimit.  If the limit is set to None,
   a limit larger than the max value in the array is used.
   
   Usage:   atmax(a,upperlimit,dimension=None,inclusive=1)
   """
    if inclusive:         upperfcn = N.less
    else:               upperfcn = N.less_equal
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    if upperlimit == None:
        upperlimit = N.maximum.reduce(N.ravel(a))+1
    smallest = N.minimum.reduce(N.ravel(a))
    ta = N.where(upperfcn(a,upperlimit),a,smallest)
    return N.maximum.reduce(ta,dimension)


def atstdev(a,limits=None,inclusive=(1,1)):
    """
   Returns the standard deviation of all values in an array, ignoring values
   strictly outside the sequence passed to 'limits'.   Note: either limit
   in the sequence, or the value of limits itself, can be set to None.  The
   inclusive list/tuple determines whether the lower and upper limiting bounds
   (respectively) are open/exclusive (0) or closed/inclusive (1).
   
   Usage:   atstdev(a,limits=None,inclusive=(1,1))
   """
    return N.sqrt(tvar(a,limits,inclusive))


def atsem(a,limits=None,inclusive=(1,1)):
    """
   Returns the standard error of the mean for the values in an array,
   (i.e., using N for the denominator), ignoring values strictly outside
   the sequence passed to 'limits'.   Note: either limit in the sequence,
   or the value of limits itself, can be set to None.  The inclusive list/tuple
   determines whether the lower and upper limiting bounds (respectively) are
   open/exclusive (0) or closed/inclusive (1).
   
   Usage:   atsem(a,limits=None,inclusive=(1,1))
   """
    sd = tstdev(a,limits,inclusive)
    if limits == None or limits == [None,None]:
        n = float(len(N.ravel(a)))
        limits = [min(a)-1, max(a)+1]
    assert type(limits) in [ListType,TupleType,N.ndarray], "Wrong type for limits in atsem"
    if inclusive[0]:         lowerfcn = N.greater_equal
    else:               lowerfcn = N.greater
    if inclusive[1]:         upperfcn = N.less_equal
    else:               upperfcn = N.less
    if limits[0] > N.maximum.reduce(N.ravel(a)) or limits[1] < N.minimum.reduce(N.ravel(a)):
        raise ValueError, "No array values within given limits (atsem)."
    elif limits[0]==None and limits[1]<>None:
        mask = upperfcn(a,limits[1])
    elif limits[0]<>None and limits[1]==None:
        mask = lowerfcn(a,limits[0])
    elif limits[0]<>None and limits[1]<>None:
        mask = lowerfcn(a,limits[0])*upperfcn(a,limits[1])
    term1 = N.add.reduce(N.ravel(a*a*mask))
    n = float(N.add.reduce(N.ravel(mask)))
    return sd/math.sqrt(n)

#####################################
############  AMOMENTS  #############
#####################################

def amoment(a,moment=1,dimension=None):
    """
    Calculates the nth moment about the mean for a sample (defaults to the
    1st moment).  Generally used to calculate coefficients of skewness and
    kurtosis.  Dimension can equal None (ravel array first), an integer
    (the dimension over which to operate), or a sequence (operate over
    multiple dimensions).
    
    Usage:   amoment(a,moment=1,dimension=None)
    Returns: appropriate moment along given dimension
    """
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    if moment == 1:
        return 0.0
    else:
        mn = amean(a,dimension,1)  # 1=keepdims
        s = N.power((a-mn),moment)
        return amean(s,dimension)


def avariation(a,dimension=None):
    """
    Returns the coefficient of variation, as defined in CRC Standard
    Probability and Statistics, p.6. Dimension can equal None (ravel array
    first), an integer (the dimension over which to operate), or a
    sequence (operate over multiple dimensions).
    
    Usage:   avariation(a,dimension=None)
    """
    return 100.0*asamplestdev(a,dimension)/amean(a,dimension)


def askew(a,dimension=None): 
    """ 
    Returns the skewness of a distribution (normal ==> 0.0; >0 means extra
    weight in left tail).  Use askewtest() to see if it's close enough.
    Dimension can equal None (ravel array first), an integer (the
    dimension over which to operate), or a sequence (operate over multiple
    dimensions).
    
    Usage:   askew(a, dimension=None)
    Returns: skew of vals in a along dimension, returning ZERO where all vals equal
    """
    denom = N.power(amoment(a,2,dimension),1.5)
    zero = N.equal(denom,0)
    if type(denom) == N.ndarray and asum(zero) <> 0:
        print "Number of zeros in askew: ",asum(zero)
    denom = denom + zero  # prevent divide-by-zero
    return N.where(zero, 0, amoment(a,3,dimension)/denom)


def akurtosis(a,dimension=None):
    """
    Returns the kurtosis of a distribution (normal ==> 3.0; >3 means
    heavier in the tails, and usually more peaked).  Use akurtosistest()
    to see if it's close enough.  Dimension can equal None (ravel array
    first), an integer (the dimension over which to operate), or a
    sequence (operate over multiple dimensions).
    
    Usage:   akurtosis(a,dimension=None)
    Returns: kurtosis of values in a along dimension, and ZERO where all vals equal
    """
    denom = N.power(amoment(a,2,dimension),2)
    zero = N.equal(denom,0)
    if type(denom) == N.ndarray and asum(zero) <> 0:
        print "Number of zeros in akurtosis: ",asum(zero)
    denom = denom + zero  # prevent divide-by-zero
    return N.where(zero,0,amoment(a,4,dimension)/denom)


def adescribe(inarray,dimension=None):
    """
   Returns several descriptive statistics of the passed array.  Dimension
   can equal None (ravel array first), an integer (the dimension over
   which to operate), or a sequence (operate over multiple dimensions).
   
   Usage:   adescribe(inarray,dimension=None)
   Returns: n, (min,max), mean, standard deviation, skew, kurtosis
   """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    n = inarray.shape[dimension]
    mm = (N.minimum.reduce(inarray),N.maximum.reduce(inarray))
    m = amean(inarray,dimension)
    sd = astdev(inarray,dimension)
    skew = askew(inarray,dimension)
    kurt = akurtosis(inarray,dimension)
    return n, mm, m, sd, skew, kurt


#####################################
########  NORMALITY TESTS  ##########
#####################################

def askewtest(a,dimension=None):
    """
    Tests whether the skew is significantly different from a normal
    distribution.  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions).
    
    Usage:   askewtest(a,dimension=None)
    Returns: z-score and 2-tail z-probability
    """
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    b2 = askew(a,dimension)
    n = float(a.shape[dimension])
    y = b2 * N.sqrt(((n+1)*(n+3)) / (6.0*(n-2)) )
    beta2 = ( 3.0*(n*n+27*n-70)*(n+1)*(n+3) ) / ( (n-2.0)*(n+5)*(n+7)*(n+9) )
    W2 = -1 + N.sqrt(2*(beta2-1))
    delta = 1/N.sqrt(N.log(N.sqrt(W2)))
    alpha = N.sqrt(2/(W2-1))
    y = N.where(y==0,1,y)
    Z = delta*N.log(y/alpha + N.sqrt((y/alpha)**2+1))
    return Z, (1.0-zprob(Z))*2


def akurtosistest(a,dimension=None):
    """
    Tests whether a dataset has normal kurtosis (i.e.,
    kurtosis=3(n-1)/(n+1)) Valid only for n>20.  Dimension can equal None
    (ravel array first), an integer (the dimension over which to operate),
    or a sequence (operate over multiple dimensions).
    
    Usage:   akurtosistest(a,dimension=None)
    Returns: z-score and 2-tail z-probability, returns 0 for bad pixels
    """
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    n = float(a.shape[dimension])
    if n<20:
        print "akurtosistest only valid for n>=20 ... continuing anyway, n=",n
    b2 = akurtosis(a,dimension)
    E = 3.0*(n-1) /(n+1)
    varb2 = 24.0*n*(n-2)*(n-3) / ((n+1)*(n+1)*(n+3)*(n+5))
    x = (b2-E)/N.sqrt(varb2)
    sqrtbeta1 = 6.0*(n*n-5*n+2)/((n+7)*(n+9)) * N.sqrt((6.0*(n+3)*(n+5))/
                                                       (n*(n-2)*(n-3)))
    A = 6.0 + 8.0/sqrtbeta1 *(2.0/sqrtbeta1 + N.sqrt(1+4.0/(sqrtbeta1**2)))
    term1 = 1 -2/(9.0*A)
    denom = 1 +x*N.sqrt(2/(A-4.0))
    denom = N.where(N.less(denom,0), 99, denom)
    term2 = N.where(N.equal(denom,0), term1, N.power((1-2.0/A)/denom,1/3.0))
    Z = ( term1 - term2 ) / N.sqrt(2/(9.0*A))
    Z = N.where(N.equal(denom,99), 0, Z)
    return Z, (1.0-zprob(Z))*2


def anormaltest(a,dimension=None):
    """
    Tests whether skew and/OR kurtosis of dataset differs from normal
    curve.  Can operate over multiple dimensions.  Dimension can equal
    None (ravel array first), an integer (the dimension over which to
    operate), or a sequence (operate over multiple dimensions).
    
    Usage:   anormaltest(a,dimension=None)
    Returns: z-score and 2-tail probability
    """
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    s,p = askewtest(a,dimension)
    k,p = akurtosistest(a,dimension)
    k2 = N.power(s,2) + N.power(k,2)
    return k2, achisqprob(k2,2)

#####################################
######  AFREQUENCY FUNCTIONS  #######
#####################################

def aitemfreq(a):
    """
    Returns a 2D array of item frequencies.  Column 1 contains item values,
    column 2 contains their respective counts.  Assumes a 1D array is passed.
    (sorting OK?)
    
    Usage:   aitemfreq(a)
    Returns: a 2D frequency table (col [0:n-1]=scores, col n=frequencies)
    """
    scores = pstat.aunique(a)
    scores = N.sort(scores)
    freq = N.zeros(len(scores))
    for i in range(len(scores)):
        freq[i] = N.add.reduce(N.equal(a,scores[i]))
    return N.array(pstat.aabut(scores, freq))


def ascoreatpercentile (inarray, percent):
    """
    Usage:   ascoreatpercentile(inarray,percent)   0<percent<100
    Returns: score at given percentile, relative to inarray distribution
    """
    percent = percent / 100.0
    targetcf = percent*len(inarray)
    h, lrl, binsize, extras = histogram(inarray)
    cumhist = cumsum(h*1)
    for i in range(len(cumhist)):
        if cumhist[i] >= targetcf:
            break
    score = binsize * ((targetcf - cumhist[i-1]) / float(h[i])) + (lrl+binsize*i)
    return score


def apercentileofscore (inarray,score,histbins=10,defaultlimits=None):
    """
    Note: result of this function depends on the values used to histogram
    the data(!).
    
    Usage:   apercentileofscore(inarray,score,histbins=10,defaultlimits=None)
    Returns: percentile-position of score (0-100) relative to inarray
    """
    h, lrl, binsize, extras = histogram(inarray,histbins,defaultlimits)
    cumhist = cumsum(h*1)
    i = int((score - lrl)/float(binsize))
    pct = (cumhist[i-1]+((score-(lrl+binsize*i))/float(binsize))*h[i])/float(len(inarray)) * 100
    return pct


def ahistogram (inarray,numbins=10,defaultlimits=None,printextras=1):
    """
    Returns (i) an array of histogram bin counts, (ii) the smallest value
    of the histogram binning, and (iii) the bin width (the last 2 are not
    necessarily integers).  Default number of bins is 10.  Defaultlimits
    can be None (the routine picks bins spanning all the numbers in the
    inarray) or a 2-sequence (lowerlimit, upperlimit).  Returns all of the
    following: array of bin values, lowerreallimit, binsize, extrapoints.
    
    Usage:   ahistogram(inarray,numbins=10,defaultlimits=None,printextras=1)
    Returns: (array of bin counts, bin-minimum, min-width, #-points-outside-range)
    """
    inarray = N.ravel(inarray)               # flatten any >1D arrays
    if (defaultlimits <> None):
        lowerreallimit = defaultlimits[0]
        upperreallimit = defaultlimits[1]
        binsize = (upperreallimit-lowerreallimit) / float(numbins)
    else:
        Min = N.minimum.reduce(inarray)
        Max = N.maximum.reduce(inarray)
        estbinwidth = float(Max - Min)/float(numbins) + 1e-6
        binsize = (Max-Min+estbinwidth)/float(numbins)
        lowerreallimit = Min - binsize/2.0  #lower real limit,1st bin
    bins = N.zeros(numbins)
    extrapoints = 0
    for num in inarray:
        try:
            if (num-lowerreallimit) < 0:
                extrapoints = extrapoints + 1
            else:
                bintoincrement = int((num-lowerreallimit) / float(binsize))
                bins[bintoincrement] = bins[bintoincrement] + 1
        except:                           # point outside lower/upper limits
            extrapoints = extrapoints + 1
    if (extrapoints > 0 and printextras == 1):
        print '\nPoints outside given histogram range =',extrapoints
    return (bins, lowerreallimit, binsize, extrapoints)


def acumfreq(a,numbins=10,defaultreallimits=None):
    """
    Returns a cumulative frequency histogram, using the histogram function.
    Defaultreallimits can be None (use all data), or a 2-sequence containing
    lower and upper limits on values to include.
    
    Usage:   acumfreq(a,numbins=10,defaultreallimits=None)
    Returns: array of cumfreq bin values, lowerreallimit, binsize, extrapoints
    """
    h,l,b,e = histogram(a,numbins,defaultreallimits)
    cumhist = cumsum(h*1)
    return cumhist,l,b,e


def arelfreq(a,numbins=10,defaultreallimits=None):
    """
    Returns a relative frequency histogram, using the histogram function.
    Defaultreallimits can be None (use all data), or a 2-sequence containing
    lower and upper limits on values to include.
    
    Usage:   arelfreq(a,numbins=10,defaultreallimits=None)
    Returns: array of cumfreq bin values, lowerreallimit, binsize, extrapoints
    """
    h,l,b,e = histogram(a,numbins,defaultreallimits)
    h = N.array(h/float(a.shape[0]))
    return h,l,b,e


#####################################
######  AVARIABILITY FUNCTIONS  #####
#####################################

def aobrientransform(*args):
    """
    Computes a transform on input data (any number of columns).  Used to
    test for homogeneity of variance prior to running one-way stats.  Each
    array in *args is one level of a factor.  If an F_oneway() run on the
    transformed data and found significant, variances are unequal.   From
    Maxwell and Delaney, p.112.
    
    Usage:   aobrientransform(*args)    *args = 1D arrays, one per level of factor
    Returns: transformed data for use in an ANOVA
    """
    TINY = 1e-10
    k = len(args)
    n = N.zeros(k,N.float_)
    v = N.zeros(k,N.float_)
    m = N.zeros(k,N.float_)
    nargs = []
    for i in range(k):
        nargs.append(args[i].astype(N.float_))
        n[i] = float(len(nargs[i]))
        v[i] = var(nargs[i])
        m[i] = mean(nargs[i])
    for j in range(k):
        for i in range(n[j]):
            t1 = (n[j]-1.5)*n[j]*(nargs[j][i]-m[j])**2
            t2 = 0.5*v[j]*(n[j]-1.0)
            t3 = (n[j]-1.0)*(n[j]-2.0)
            nargs[j][i] = (t1-t2) / float(t3)
    check = 1
    for j in range(k):
        if v[j] - mean(nargs[j]) > TINY:
            check = 0
    if check <> 1:
        raise ValueError, 'Lack of convergence in obrientransform.'
    else:
        return N.array(nargs)


def asamplevar (inarray,dimension=None,keepdims=0):
    """
    Returns the sample standard deviation of the values in the passed
    array (i.e., using N).  Dimension can equal None (ravel array first),
    an integer (the dimension over which to operate), or a sequence
    (operate over multiple dimensions).  Set keepdims=1 to return an array
    with the same number of dimensions as inarray.
    
    Usage:   asamplevar(inarray,dimension=None,keepdims=0)
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    if dimension == 1:
        mn = amean(inarray,dimension)[:,N.NewAxis]
    else:
        mn = amean(inarray,dimension,keepdims=1)
    deviations = inarray - mn 
    if type(dimension) == ListType:
        n = 1
        for d in dimension:
            n = n*inarray.shape[d]
    else:
        n = inarray.shape[dimension]
    svar = ass(deviations,dimension,keepdims) / float(n)
    return svar


def asamplestdev (inarray, dimension=None, keepdims=0):
    """
    Returns the sample standard deviation of the values in the passed
    array (i.e., using N).  Dimension can equal None (ravel array first),
    an integer (the dimension over which to operate), or a sequence
    (operate over multiple dimensions).  Set keepdims=1 to return an array
    with the same number of dimensions as inarray.
    
    Usage:   asamplestdev(inarray,dimension=None,keepdims=0)
    """
    return N.sqrt(asamplevar(inarray,dimension,keepdims))


def asignaltonoise(instack,dimension=0):
    """
    Calculates signal-to-noise.  Dimension can equal None (ravel array
    first), an integer (the dimension over which to operate), or a
    sequence (operate over multiple dimensions).
    
    Usage:   asignaltonoise(instack,dimension=0):
    Returns: array containing the value of (mean/stdev) along dimension, or 0 when stdev=0
    """
    m = mean(instack,dimension)
    sd = stdev(instack,dimension)
    return N.where(sd==0,0,m/sd)


def acov (x,y, dimension=None,keepdims=0):
    """
    Returns the estimated covariance of the values in the passed
    array (i.e., N-1).  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions).  Set keepdims=1 to return an array with the
    same number of dimensions as inarray.
    
    Usage:   acov(x,y,dimension=None,keepdims=0)
    """
    if dimension == None:
        x = N.ravel(x)
        y = N.ravel(y)
        dimension = 0
    xmn = amean(x,dimension,1)  # keepdims
    xdeviations = x - xmn
    ymn = amean(y,dimension,1)  # keepdims
    ydeviations = y - ymn
    if type(dimension) == ListType:
        n = 1
        for d in dimension:
            n = n*x.shape[d]
    else:
        n = x.shape[dimension]
    covar = N.sum(xdeviations*ydeviations)/float(n-1)
    return covar


def avar (inarray, dimension=None,keepdims=0):
    """
    Returns the estimated population variance of the values in the passed
    array (i.e., N-1).  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions).  Set keepdims=1 to return an array with the
    same number of dimensions as inarray.
    
    Usage:   avar(inarray,dimension=None,keepdims=0)
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    mn = amean(inarray,dimension,1)
    deviations = inarray - mn
    if type(dimension) == ListType:
        n = 1
        for d in dimension:
            n = n*inarray.shape[d]
    else:
        n = inarray.shape[dimension]
    var = ass(deviations,dimension,keepdims)/float(n-1)
    return var


def astdev (inarray, dimension=None, keepdims=0):
    """
    Returns the estimated population standard deviation of the values in
    the passed array (i.e., N-1).  Dimension can equal None (ravel array
    first), an integer (the dimension over which to operate), or a
    sequence (operate over multiple dimensions).  Set keepdims=1 to return
    an array with the same number of dimensions as inarray.
    
    Usage:   astdev(inarray,dimension=None,keepdims=0)
    """
    return N.sqrt(avar(inarray,dimension,keepdims))


def asterr (inarray, dimension=None, keepdims=0):
    """
    Returns the estimated population standard error of the values in the
    passed array (i.e., N-1).  Dimension can equal None (ravel array
    first), an integer (the dimension over which to operate), or a
    sequence (operate over multiple dimensions).  Set keepdims=1 to return
    an array with the same number of dimensions as inarray.
    
    Usage:   asterr(inarray,dimension=None,keepdims=0)
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    return astdev(inarray,dimension,keepdims) / float(N.sqrt(inarray.shape[dimension]))


def asem (inarray, dimension=None, keepdims=0):
    """
    Returns the standard error of the mean (i.e., using N) of the values
    in the passed array.  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions).  Set keepdims=1 to return an array with the
    same number of dimensions as inarray.
    
    Usage:   asem(inarray,dimension=None, keepdims=0)
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    if type(dimension) == ListType:
        n = 1
        for d in dimension:
            n = n*inarray.shape[d]
    else:
        n = inarray.shape[dimension]
    s = asamplestdev(inarray,dimension,keepdims) / N.sqrt(n-1)
    return s


def az (a, score):
    """
    Returns the z-score of a given input score, given thearray from which
    that score came.  Not appropriate for population calculations, nor for
    arrays > 1D.
    
    Usage:   az(a, score)
    """
    z = (score-amean(a)) / asamplestdev(a)
    return z


def azs (a):
    """
    Returns a 1D array of z-scores, one for each score in the passed array,
    computed relative to the passed array.
    
    Usage:   azs(a)
    """
    zscores = []
    for item in a:
        zscores.append(z(a,item))
    return N.array(zscores)


def azmap (scores, compare, dimension=0):
    """
    Returns an array of z-scores the shape of scores (e.g., [x,y]), compared to
    array passed to compare (e.g., [time,x,y]).  Assumes collapsing over dim 0
    of the compare array.
    
    Usage:   azs(scores, compare, dimension=0)
    """
    mns = amean(compare,dimension)
    sstd = asamplestdev(compare,0)
    return (scores - mns) / sstd


#####################################
#######  ATRIMMING FUNCTIONS  #######
#####################################

## deleted around() as it's in numpy now

def athreshold(a,threshmin=None,threshmax=None,newval=0):
    """
    Like Numeric.clip() except that values <threshmid or >threshmax are replaced
    by newval instead of by threshmin/threshmax (respectively).
    
    Usage:   athreshold(a,threshmin=None,threshmax=None,newval=0)
    Returns: a, with values <threshmin or >threshmax replaced with newval
    """
    mask = N.zeros(a.shape)
    if threshmin <> None:
        mask = mask + N.where(a<threshmin,1,0)
    if threshmax <> None:
        mask = mask + N.where(a>threshmax,1,0)
    mask = N.clip(mask,0,1)
    return N.where(mask,newval,a)


def atrimboth (a,proportiontocut):
    """
    Slices off the passed proportion of items from BOTH ends of the passed
    array (i.e., with proportiontocut=0.1, slices 'leftmost' 10% AND
    'rightmost' 10% of scores.  You must pre-sort the array if you want
    "proper" trimming.  Slices off LESS if proportion results in a
    non-integer slice index (i.e., conservatively slices off
    proportiontocut).
    
    Usage:   atrimboth (a,proportiontocut)
    Returns: trimmed version of array a
    """
    lowercut = int(proportiontocut*len(a))
    uppercut = len(a) - lowercut
    return a[lowercut:uppercut]


def atrim1 (a,proportiontocut,tail='right'):
    """
    Slices off the passed proportion of items from ONE end of the passed
    array (i.e., if proportiontocut=0.1, slices off 'leftmost' or 'rightmost'
    10% of scores).  Slices off LESS if proportion results in a non-integer
    slice index (i.e., conservatively slices off proportiontocut).
    
    Usage:   atrim1(a,proportiontocut,tail='right')  or set tail='left'
    Returns: trimmed version of array a
    """
    if string.lower(tail) == 'right':
        lowercut = 0
        uppercut = len(a) - int(proportiontocut*len(a))
    elif string.lower(tail) == 'left':
        lowercut = int(proportiontocut*len(a))
        uppercut = len(a)
    return a[lowercut:uppercut]


#####################################
#####  ACORRELATION FUNCTIONS  ######
#####################################

def acovariance(X):
    """
    Computes the covariance matrix of a matrix X.  Requires a 2D matrix input.
    
    Usage:   acovariance(X)
    Returns: covariance matrix of X
    """
    if len(X.shape) <> 2:
        raise TypeError, "acovariance requires 2D matrices"
    n = X.shape[0]
    mX = amean(X,0)
    return N.dot(N.transpose(X),X) / float(n) - N.multiply.outer(mX,mX)


def acorrelation(X):
    """
    Computes the correlation matrix of a matrix X.  Requires a 2D matrix input.
    
    Usage:   acorrelation(X)
    Returns: correlation matrix of X
    """
    C = acovariance(X)
    V = N.diagonal(C)
    return C / N.sqrt(N.multiply.outer(V,V))


def apaired(x,y):
    """
    Interactively determines the type of data in x and y, and then runs the
    appropriated statistic for paired group data.
    
    Usage:   apaired(x,y)     x,y = the two arrays of values to be compared
    Returns: appropriate statistic name, value, and probability
    """
    samples = ''
    while samples not in ['i','r','I','R','c','C']:
        print '\nIndependent or related samples, or correlation (i,r,c): ',
        samples = raw_input()

    if samples in ['i','I','r','R']:
        print '\nComparing variances ...',
        # USE O'BRIEN'S TEST FOR HOMOGENEITY OF VARIANCE, Maxwell & delaney, p.112
        r = obrientransform(x,y)
        f,p = F_oneway(pstat.colex(r,0),pstat.colex(r,1))
        if p<0.05:
            vartype='unequal, p='+str(round(p,4))
        else:
            vartype='equal'
        print vartype
        if samples in ['i','I']:
            if vartype[0]=='e':
                t,p = ttest_ind(x,y,None,0)
                print '\nIndependent samples t-test:  ', round(t,4),round(p,4)
            else:
                if len(x)>20 or len(y)>20:
                    z,p = ranksums(x,y)
                    print '\nRank Sums test (NONparametric, n>20):  ', round(z,4),round(p,4)
                else:
                    u,p = mannwhitneyu(x,y)
                    print '\nMann-Whitney U-test (NONparametric, ns<20):  ', round(u,4),round(p,4)

        else:  # RELATED SAMPLES
            if vartype[0]=='e':
                t,p = ttest_rel(x,y,0)
                print '\nRelated samples t-test:  ', round(t,4),round(p,4)
            else:
                t,p = ranksums(x,y)
                print '\nWilcoxon T-test (NONparametric):  ', round(t,4),round(p,4)
    else:  # CORRELATION ANALYSIS
        corrtype = ''
        while corrtype not in ['c','C','r','R','d','D']:
            print '\nIs the data Continuous, Ranked, or Dichotomous (c,r,d): ',
            corrtype = raw_input()
        if corrtype in ['c','C']:
            m,b,r,p,see = linregress(x,y)
            print '\nLinear regression for continuous variables ...'
            lol = [['Slope','Intercept','r','Prob','SEestimate'],[round(m,4),round(b,4),round(r,4),round(p,4),round(see,4)]]
            pstat.printcc(lol)
        elif corrtype in ['r','R']:
            r,p = spearmanr(x,y)
            print '\nCorrelation for ranked variables ...'
            print "Spearman's r: ",round(r,4),round(p,4)
        else: # DICHOTOMOUS
            r,p = pointbiserialr(x,y)
            print '\nAssuming x contains a dichotomous variable ...'
            print 'Point Biserial r: ',round(r,4),round(p,4)
    print '\n\n'
    return None


def dices(x,y):
    """
    Calculates Dice's coefficient ... (2*number of common terms)/(number of terms in x +
    number of terms in y). Returns a value between 0 (orthogonal) and 1.
    
    Usage:  dices(x,y)
    """
    # sets is deprecated as of v2.6, replaced by the built-in set
    try:
        set
    except NameError:
        from sets import Set as set
    x = set(x)
    y = set(y)
    common = len(x.intersection(y))
    total = float(len(x) + len(y))
    return 2*common/total


def icc(x,y=None,verbose=0):
    """
    Calculates intraclass correlation coefficients using simple, Type I sums of squares.
    If only one variable is passed, assumed it's an Nx2 matrix
    
    Usage:   icc(x,y=None,verbose=0)
    Returns: icc rho, prob ####PROB IS A GUESS BASED ON PEARSON
    """
    TINY = 1.0e-20
    if y:
        all = N.concatenate([x,y],0)
    else:
        all = x+0
        x = all[:,0]
        y = all[:,1]
    totalss = ass(all-mean(all))
    pairmeans = (x+y)/2.
    withinss = ass(x-pairmeans) + ass(y-pairmeans)
    withindf = float(len(x))
    betwdf = float(len(x)-1)
    withinms = withinss / withindf
    betweenms = (totalss-withinss) / betwdf
    rho = (betweenms-withinms)/(withinms+betweenms)
    t = rho*math.sqrt(betwdf/((1.0-rho+TINY)*(1.0+rho+TINY)))
    prob = abetai(0.5*betwdf,0.5,betwdf/(betwdf+t*t),verbose)
    return rho, prob


def alincc(x,y):
    """
    Calculates Lin's concordance correlation coefficient.
    
    Usage:   alincc(x,y)    where x, y are equal-length arrays
    Returns: Lin's CC
    """
    x = N.ravel(x)
    y = N.ravel(y)
    covar = acov(x,y)*(len(x)-1)/float(len(x))  # correct denom to n
    xvar = avar(x)*(len(x)-1)/float(len(x))  # correct denom to n
    yvar = avar(y)*(len(y)-1)/float(len(y))  # correct denom to n
    lincc = (2 * covar) / ((xvar+yvar) +((amean(x)-amean(y))**2))
    return lincc


def apearsonr(x,y,verbose=1):
    """
    Calculates a Pearson correlation coefficient and returns p.  Taken
    from Heiman's Basic Statistics for the Behav. Sci (2nd), p.195.
    
    Usage:   apearsonr(x,y,verbose=1)      where x,y are equal length arrays
    Returns: Pearson's r, two-tailed p-value
    """
    TINY = 1.0e-20
    n = len(x)
    xmean = amean(x)
    ymean = amean(y)
    r_num = n*(N.add.reduce(x*y)) - N.add.reduce(x)*N.add.reduce(y)
    r_den = math.sqrt((n*ass(x) - asquare_of_sums(x))*(n*ass(y)-asquare_of_sums(y)))
    r = (r_num / r_den)
    df = n-2
    t = r*math.sqrt(df/((1.0-r+TINY)*(1.0+r+TINY)))
    prob = abetai(0.5*df,0.5,df/(df+t*t),verbose)
    return r,prob


def aspearmanr(x,y):
    """
    Calculates a Spearman rank-order correlation coefficient.  Taken
    from Heiman's Basic Statistics for the Behav. Sci (1st), p.192.
    
    Usage:   aspearmanr(x,y)      where x,y are equal-length arrays
    Returns: Spearman's r, two-tailed p-value
    """
    TINY = 1e-30
    n = len(x)
    rankx = rankdata(x)
    ranky = rankdata(y)
    dsq = N.add.reduce((rankx-ranky)**2)
    rs = 1 - 6*dsq / float(n*(n**2-1))
    t = rs * math.sqrt((n-2) / ((rs+1.0)*(1.0-rs)))
    df = n-2
    probrs = abetai(0.5*df,0.5,df/(df+t*t))
    # probability values for rs are from part 2 of the spearman function in
    # Numerical Recipes, p.510.  They close to tables, but not exact.(?)
    return rs, probrs


def apointbiserialr(x,y):
    """
    Calculates a point-biserial correlation coefficient and the associated
    probability value.  Taken from Heiman's Basic Statistics for the Behav.
    Sci (1st), p.194.
    
    Usage:   apointbiserialr(x,y)      where x,y are equal length arrays
    Returns: Point-biserial r, two-tailed p-value
    """
    TINY = 1e-30
    categories = pstat.aunique(x)
    data = pstat.aabut(x,y)
    if len(categories) <> 2:
        raise ValueError, "Exactly 2 categories required (in x) for pointbiserialr()."
    else:   # there are 2 categories, continue
        codemap = pstat.aabut(categories,N.arange(2))
        recoded = pstat.arecode(data,codemap,0)
        x = pstat.alinexand(data,0,categories[0])
        y = pstat.alinexand(data,0,categories[1])
        xmean = amean(pstat.acolex(x,1))
        ymean = amean(pstat.acolex(y,1))
        n = len(data)
        adjust = math.sqrt((len(x)/float(n))*(len(y)/float(n)))
        rpb = (ymean - xmean)/asamplestdev(pstat.acolex(data,1))*adjust
        df = n-2
        t = rpb*math.sqrt(df/((1.0-rpb+TINY)*(1.0+rpb+TINY)))
        prob = abetai(0.5*df,0.5,df/(df+t*t))
        return rpb, prob


def akendalltau(x,y):
    """
    Calculates Kendall's tau ... correlation of ordinal data.  Adapted
    from function kendl1 in Numerical Recipes.  Needs good test-cases.@@@
    
    Usage:   akendalltau(x,y)
    Returns: Kendall's tau, two-tailed p-value
    """
    n1 = 0
    n2 = 0
    iss = 0
    for j in range(len(x)-1):
        for k in range(j,len(y)):
            a1 = x[j] - x[k]
            a2 = y[j] - y[k]
            aa = a1 * a2
            if (aa):             # neither array has a tie
                n1 = n1 + 1
                n2 = n2 + 1
                if aa > 0:
                    iss = iss + 1
                else:
                    iss = iss -1
            else:
                if (a1):
                    n1 = n1 + 1
                else:
                    n2 = n2 + 1
    tau = iss / math.sqrt(n1*n2)
    svar = (4.0*len(x)+10.0) / (9.0*len(x)*(len(x)-1))
    z = tau / math.sqrt(svar)
    prob = erfcc(abs(z)/1.4142136)
    return tau, prob


def alinregress(*args):
    """
    Calculates a regression line on two arrays, x and y, corresponding to x,y
    pairs.  If a single 2D array is passed, alinregress finds dim with 2 levels
    and splits data into x,y pairs along that dim.
    
    Usage:   alinregress(*args)    args=2 equal-length arrays, or one 2D array
    Returns: slope, intercept, r, two-tailed prob, sterr-of-the-estimate, n
    """
    TINY = 1.0e-20
    if len(args) == 1:  # more than 1D array?
        args = args[0]
        if len(args) == 2:
            x = args[0]
            y = args[1]
        else:
            x = args[:,0]
            y = args[:,1]
    else:
        x = args[0]
        y = args[1]
    n = len(x)
    xmean = amean(x)
    ymean = amean(y)
    r_num = n*(N.add.reduce(x*y)) - N.add.reduce(x)*N.add.reduce(y)
    r_den = math.sqrt((n*ass(x) - asquare_of_sums(x))*(n*ass(y)-asquare_of_sums(y)))
    r = r_num / r_den
    z = 0.5*math.log((1.0+r+TINY)/(1.0-r+TINY))
    df = n-2
    t = r*math.sqrt(df/((1.0-r+TINY)*(1.0+r+TINY)))
    prob = abetai(0.5*df,0.5,df/(df+t*t))
    slope = r_num / (float(n)*ass(x) - asquare_of_sums(x))
    intercept = ymean - slope*xmean
    sterrest = math.sqrt(1-r*r)*asamplestdev(y)
    return slope, intercept, r, prob, sterrest, n

def amasslinregress(*args):
    """
    Calculates a regression line on one 1D array (x) and one N-D array (y).
    
    Returns: slope, intercept, r, two-tailed prob, sterr-of-the-estimate, n
    """
    TINY = 1.0e-20
    if len(args) == 1:  # more than 1D array?
        args = args[0]
        if len(args) == 2:
            x = N.ravel(args[0])
            y = args[1]
        else:
            x = N.ravel(args[:,0])
            y = args[:,1]
    else:
        x = args[0]
        y = args[1]
    x = x.astype(N.float_)
    y = y.astype(N.float_)
    n = len(x)
    xmean = amean(x)
    ymean = amean(y,0)
    shp = N.ones(len(y.shape))
    shp[0] = len(x)
    x.shape = shp
    print x.shape, y.shape
    r_num = n*(N.add.reduce(x*y,0)) - N.add.reduce(x)*N.add.reduce(y,0)
    r_den = N.sqrt((n*ass(x) - asquare_of_sums(x))*(n*ass(y,0)-asquare_of_sums(y,0)))
    zerodivproblem = N.equal(r_den,0)
    r_den = N.where(zerodivproblem,1,r_den)  # avoid zero-division in 1st place
    r = r_num / r_den  # need to do this nicely for matrix division
    r = N.where(zerodivproblem,0.0,r)
    z = 0.5*N.log((1.0+r+TINY)/(1.0-r+TINY))
    df = n-2
    t = r*N.sqrt(df/((1.0-r+TINY)*(1.0+r+TINY)))
    prob = abetai(0.5*df,0.5,df/(df+t*t))

    ss = float(n)*ass(x)-asquare_of_sums(x)
    s_den = N.where(ss==0,1,ss)  # avoid zero-division in 1st place
    slope = r_num / s_den
    intercept = ymean - slope*xmean
    sterrest = N.sqrt(1-r*r)*asamplestdev(y,0)
    return slope, intercept, r, prob, sterrest, n

#####################################
#####  AINFERENTIAL STATISTICS  #####
#####################################

def attest_1samp(a,popmean,printit=0,name='Sample',writemode='a'):
    """
    Calculates the t-obtained for the independent samples T-test on ONE group
    of scores a, given a population mean.  If printit=1, results are printed
    to the screen.  If printit='filename', the results are output to 'filename'
    using the given writemode (default=append).  Returns t-value, and prob.
    
    Usage:   attest_1samp(a,popmean,Name='Sample',printit=0,writemode='a')
    Returns: t-value, two-tailed prob
    """
    if type(a) != N.ndarray:
        a = N.array(a)
    x = amean(a)
    v = avar(a)
    n = len(a)
    df = n-1
    svar = ((n-1)*v) / float(df)
    t = (x-popmean)/math.sqrt(svar*(1.0/n))
    prob = abetai(0.5*df,0.5,df/(df+t*t))

    if printit <> 0:
        statname = 'Single-sample T-test.'
        outputpairedstats(printit,writemode,
                          'Population','--',popmean,0,0,0,
                          name,n,x,v,N.minimum.reduce(N.ravel(a)),
                          N.maximum.reduce(N.ravel(a)),
                          statname,t,prob)
    return t,prob


def attest_ind (a, b, dimension=None, printit=0, name1='Samp1', name2='Samp2',writemode='a'):
    """
    Calculates the t-obtained T-test on TWO INDEPENDENT samples of scores
    a, and b.  From Numerical Recipes, p.483.  If printit=1, results are
    printed to the screen.  If printit='filename', the results are output
    to 'filename' using the given writemode (default=append).  Dimension
    can equal None (ravel array first), or an integer (the dimension over
    which to operate on a and b).
    
    Usage:   attest_ind (a,b,dimension=None,printit=0, Name1='Samp1',Name2='Samp2',writemode='a')
    Returns: t-value, two-tailed p-value
    """
    if dimension == None:
        a = N.ravel(a)
        b = N.ravel(b)
        dimension = 0
    x1 = amean(a,dimension)
    x2 = amean(b,dimension)
    v1 = avar(a,dimension)
    v2 = avar(b,dimension)
    n1 = a.shape[dimension]
    n2 = b.shape[dimension]
    df = n1+n2-2
    svar = ((n1-1)*v1+(n2-1)*v2) / float(df)
    zerodivproblem = N.equal(svar,0)
    svar = N.where(zerodivproblem,1,svar)  # avoid zero-division in 1st place
    t = (x1-x2)/N.sqrt(svar*(1.0/n1 + 1.0/n2))  # N-D COMPUTATION HERE!!!!!!
    t = N.where(zerodivproblem,1.0,t)     # replace NaN/wrong t-values with 1.0
    probs = abetai(0.5*df,0.5,float(df)/(df+t*t))

    if type(t) == N.ndarray:
        probs = N.reshape(probs,t.shape)
    if probs.shape == (1,):
        probs = probs[0]
        
    if printit <> 0:
        if type(t) == N.ndarray:
            t = t[0]
        if type(probs) == N.ndarray:
            probs = probs[0]
        statname = 'Independent samples T-test.'
        outputpairedstats(printit,writemode,
                          name1,n1,x1,v1,N.minimum.reduce(N.ravel(a)),
                          N.maximum.reduce(N.ravel(a)),
                          name2,n2,x2,v2,N.minimum.reduce(N.ravel(b)),
                          N.maximum.reduce(N.ravel(b)),
                          statname,t,probs)
        return
    return t, probs

def ap2t(pval,df):
    """
    Tries to compute a t-value from a p-value (or pval array) and associated df.
    SLOW for large numbers of elements(!) as it re-computes p-values 20 times
    (smaller step-sizes) at which point it decides it's done. Keeps the signs
    of the input array. Returns 1000 (or -1000) if t>100.
    
    Usage:  ap2t(pval,df)
    Returns: an array of t-values with the shape of pval
    """
    pval = N.array(pval)
    signs = N.sign(pval)
    pval = abs(pval)
    t = N.ones(pval.shape,N.float_)*50
    step = N.ones(pval.shape,N.float_)*25
    print "Initial ap2t() prob calc"
    prob = abetai(0.5*df,0.5,float(df)/(df+t*t))
    print 'ap2t() iter: ',
    for i in range(10):
        print i,' ',
        t = N.where(pval<prob,t+step,t-step)
        prob = abetai(0.5*df,0.5,float(df)/(df+t*t))
        step = step/2
    print
    # since this is an ugly hack, we get ugly boundaries
    t = N.where(t>99.9,1000,t)      # hit upper-boundary
    t = t+signs
    return t #, prob, pval


def attest_rel (a,b,dimension=None,printit=0,name1='Samp1',name2='Samp2',writemode='a'):
    """
    Calculates the t-obtained T-test on TWO RELATED samples of scores, a
    and b.  From Numerical Recipes, p.483.  If printit=1, results are
    printed to the screen.  If printit='filename', the results are output
    to 'filename' using the given writemode (default=append).  Dimension
    can equal None (ravel array first), or an integer (the dimension over
    which to operate on a and b).
    
    Usage:   attest_rel(a,b,dimension=None,printit=0, name1='Samp1',name2='Samp2',writemode='a')
    Returns: t-value, two-tailed p-value
    """
    if dimension == None:
        a = N.ravel(a)
        b = N.ravel(b)
        dimension = 0
    if len(a)<>len(b):
        raise ValueError, 'Unequal length arrays.'
    x1 = amean(a,dimension)
    x2 = amean(b,dimension)
    v1 = avar(a,dimension)
    v2 = avar(b,dimension)
    n = a.shape[dimension]
    df = float(n-1)
    d = (a-b).astype('d')

    denom = N.sqrt((n*N.add.reduce(d*d,dimension) - N.add.reduce(d,dimension)**2) /df)
    zerodivproblem = N.equal(denom,0)
    denom = N.where(zerodivproblem,1,denom)  # avoid zero-division in 1st place
    t = N.add.reduce(d,dimension) / denom      # N-D COMPUTATION HERE!!!!!!
    t = N.where(zerodivproblem,1.0,t)     # replace NaN/wrong t-values with 1.0
    probs = abetai(0.5*df,0.5,float(df)/(df+t*t))
    if type(t) == N.ndarray:
        probs = N.reshape(probs,t.shape)
    if probs.shape == (1,):
        probs = probs[0]

    if printit <> 0:
        statname = 'Related samples T-test.'
        outputpairedstats(printit,writemode,
                          name1,n,x1,v1,N.minimum.reduce(N.ravel(a)),
                          N.maximum.reduce(N.ravel(a)),
                          name2,n,x2,v2,N.minimum.reduce(N.ravel(b)),
                          N.maximum.reduce(N.ravel(b)),
                          statname,t,probs)
        return
    return t, probs


def achisquare(f_obs,f_exp=None):
    """
    Calculates a one-way chi square for array of observed frequencies and returns
    the result.  If no expected frequencies are given, the total N is assumed to
    be equally distributed across all groups (NOT RIGHT??)
    
    Usage:   achisquare(f_obs, f_exp=None)   f_obs = array of observed cell freq.
    Returns: chisquare-statistic, associated p-value
    """

    k = len(f_obs)
    if f_exp == None:
        f_exp = N.array([sum(f_obs)/float(k)] * len(f_obs),N.float_)
    f_exp = f_exp.astype(N.float_)
    chisq = N.add.reduce((f_obs-f_exp)**2 / f_exp)
    return chisq, achisqprob(chisq, k-1)


def aks_2samp (data1,data2):
    """
    Computes the Kolmogorov-Smirnof statistic on 2 samples.  Modified from
    Numerical Recipes in C, page 493.  Returns KS D-value, prob.  Not ufunc-
    like.
    
    Usage:   aks_2samp(data1,data2)  where data1 and data2 are 1D arrays
    Returns: KS D-value, p-value
    """
    j1 = 0    # N.zeros(data1.shape[1:]) TRIED TO MAKE THIS UFUNC-LIKE
    j2 = 0    # N.zeros(data2.shape[1:])
    fn1 = 0.0 # N.zeros(data1.shape[1:],N.float_)
    fn2 = 0.0 # N.zeros(data2.shape[1:],N.float_)
    n1 = data1.shape[0]
    n2 = data2.shape[0]
    en1 = n1*1
    en2 = n2*1
    d = N.zeros(data1.shape[1:],N.float_)
    data1 = N.sort(data1,0)
    data2 = N.sort(data2,0)
    while j1 < n1 and j2 < n2:
        d1=data1[j1]
        d2=data2[j2]
        if d1 <= d2:
            fn1 = (j1)/float(en1)
            j1 = j1 + 1
        if d2 <= d1:
            fn2 = (j2)/float(en2)
            j2 = j2 + 1
        dt = (fn2-fn1)
        if abs(dt) > abs(d):
            d = dt
    #    try:
    en = math.sqrt(en1*en2/float(en1+en2))
    prob = aksprob((en+0.12+0.11/en)*N.fabs(d))
    #    except:
    #        prob = 1.0
    return d, prob


def amannwhitneyu(x,y):
    """
    Calculates a Mann-Whitney U statistic on the provided scores and
    returns the result.  Use only when the n in each condition is < 20 and
    you have 2 independent samples of ranks.  REMEMBER: Mann-Whitney U is
    significant if the u-obtained is LESS THAN or equal to the critical
    value of U.
    
    Usage:   amannwhitneyu(x,y)     where x,y are arrays of values for 2 conditions
    Returns: u-statistic, one-tailed p-value (i.e., p(z(U)))
    """
    n1 = len(x)
    n2 = len(y)
    ranked = rankdata(N.concatenate((x,y)))
    rankx = ranked[0:n1]       # get the x-ranks
    ranky = ranked[n1:]        # the rest are y-ranks
    u1 = n1*n2 + (n1*(n1+1))/2.0 - sum(rankx)  # calc U for x
    u2 = n1*n2 - u1                            # remainder is U for y
    bigu = max(u1,u2)
    smallu = min(u1,u2)
    T = math.sqrt(tiecorrect(ranked))  # correction factor for tied scores
    if T == 0:
        raise ValueError, 'All numbers are identical in amannwhitneyu'
    sd = math.sqrt(T*n1*n2*(n1+n2+1)/12.0)
    z = abs((bigu-n1*n2/2.0) / sd)  # normal approximation for prob calc
    return smallu, 1.0 - azprob(z)


def atiecorrect(rankvals):
    """
    Tie-corrector for ties in Mann Whitney U and Kruskal Wallis H tests.
    See Siegel, S. (1956) Nonparametric Statistics for the Behavioral
    Sciences.  New York: McGraw-Hill.  Code adapted from |Stat rankind.c
    code.
    
    Usage:   atiecorrect(rankvals)
    Returns: T correction factor for U or H
    """
    sorted,posn = ashellsort(N.array(rankvals))
    n = len(sorted)
    T = 0.0
    i = 0
    while (i<n-1):
        if sorted[i] == sorted[i+1]:
            nties = 1
            while (i<n-1) and (sorted[i] == sorted[i+1]):
                nties = nties +1
                i = i +1
            T = T + nties**3 - nties
        i = i+1
    T = T / float(n**3-n)
    return 1.0 - T


def aranksums(x,y):
    """
    Calculates the rank sums statistic on the provided scores and returns
    the result.
    
    Usage:   aranksums(x,y)     where x,y are arrays of values for 2 conditions
    Returns: z-statistic, two-tailed p-value
    """
    n1 = len(x)
    n2 = len(y)
    alldata = N.concatenate((x,y))
    ranked = arankdata(alldata)
    x = ranked[:n1]
    y = ranked[n1:]
    s = sum(x)
    expected = n1*(n1+n2+1) / 2.0
    z = (s - expected) / math.sqrt(n1*n2*(n1+n2+1)/12.0)
    prob = 2*(1.0 - azprob(abs(z)))
    return z, prob


def awilcoxont(x,y):
    """
    Calculates the Wilcoxon T-test for related samples and returns the
    result.  A non-parametric T-test.
    
    Usage:   awilcoxont(x,y)     where x,y are equal-length arrays for 2 conditions
    Returns: t-statistic, two-tailed p-value
    """
    if len(x) <> len(y):
        raise ValueError, 'Unequal N in awilcoxont.  Aborting.'
    d = x-y
    d = N.compress(N.not_equal(d,0),d) # Keep all non-zero differences
    count = len(d)
    absd = abs(d)
    absranked = arankdata(absd)
    r_plus = 0.0
    r_minus = 0.0
    for i in range(len(absd)):
        if d[i] < 0:
            r_minus = r_minus + absranked[i]
        else:
            r_plus = r_plus + absranked[i]
    wt = min(r_plus, r_minus)
    mn = count * (count+1) * 0.25
    se =  math.sqrt(count*(count+1)*(2.0*count+1.0)/24.0)
    z = math.fabs(wt-mn) / se
    z = math.fabs(wt-mn) / se
    prob = 2*(1.0 -zprob(abs(z)))
    return wt, prob


def akruskalwallish(*args):
    """
    The Kruskal-Wallis H-test is a non-parametric ANOVA for 3 or more
    groups, requiring at least 5 subjects in each group.  This function
    calculates the Kruskal-Wallis H and associated p-value for 3 or more
    independent samples.
    
    Usage:   akruskalwallish(*args)     args are separate arrays for 3+ conditions
    Returns: H-statistic (corrected for ties), associated p-value
    """
    assert len(args) == 3, "Need at least 3 groups in stats.akruskalwallish()"
    args = list(args)
    n = [0]*len(args)
    n = map(len,args)
    all = []
    for i in range(len(args)):
        all = all + args[i].tolist()
    ranked = rankdata(all)
    T = tiecorrect(ranked)
    for i in range(len(args)):
        args[i] = ranked[0:n[i]]
        del ranked[0:n[i]]
    rsums = []
    for i in range(len(args)):
        rsums.append(sum(args[i])**2)
        rsums[i] = rsums[i] / float(n[i])
    ssbn = sum(rsums)
    totaln = sum(n)
    h = 12.0 / (totaln*(totaln+1)) * ssbn - 3*(totaln+1)
    df = len(args) - 1
    if T == 0:
        raise ValueError, 'All numbers are identical in akruskalwallish'
    h = h / float(T)
    return h, chisqprob(h,df)


def afriedmanchisquare(*args):
    """
    Friedman Chi-Square is a non-parametric, one-way within-subjects
    ANOVA.  This function calculates the Friedman Chi-square test for
    repeated measures and returns the result, along with the associated
    probability value.  It assumes 3 or more repeated measures.  Only 3
    levels requires a minimum of 10 subjects in the study.  Four levels
    requires 5 subjects per level(??).
    
    Usage:   afriedmanchisquare(*args)   args are separate arrays for 2+ conditions
    Returns: chi-square statistic, associated p-value
    """
    k = len(args)
    if k < 3:
        raise ValueError, '\nLess than 3 levels.  Friedman test not appropriate.\n'
    n = len(args[0])
    data = apply(pstat.aabut,args)
    data = data.astype(N.float_)
    for i in range(len(data)):
        data[i] = arankdata(data[i])
    ssbn = asum(asum(args,1)**2)
    chisq = 12.0 / (k*n*(k+1)) * ssbn - 3*n*(k+1)
    return chisq, achisqprob(chisq,k-1)

#####################################
####  APROBABILITY CALCULATIONS  ####
#####################################

def achisqprob(chisq,df):
    """
    Returns the (1-tail) probability value associated with the provided chi-square
    value and df.  Heavily modified from chisq.c in Gary Perlman's |Stat.  Can
    handle multiple dimensions.
    
    Usage:   achisqprob(chisq,df)    chisq=chisquare stat., df=degrees of freedom
    """
    BIG = 200.0
    def ex(x):
        BIG = 200.0
        exponents = N.where(N.less(x,-BIG),-BIG,x)
        return N.exp(exponents)

    if type(chisq) == N.ndarray:
        arrayflag = 1
    else:
        arrayflag = 0
        chisq = N.array([chisq])
    if df < 1:
        return N.ones(chisq.shape,N.float)
    probs = N.zeros(chisq.shape,N.float_)
    probs = N.where(N.less_equal(chisq,0),1.0,probs)  # set prob=1 for chisq<0
    a = 0.5 * chisq
    if df > 1:
        y = ex(-a)
    if df%2 == 0:
        even = 1
        s = y*1
        s2 = s*1
    else:
        even = 0
        s = 2.0 * azprob(-N.sqrt(chisq))
        s2 = s*1
    if (df > 2):
        chisq = 0.5 * (df - 1.0)
        if even:
            z = N.ones(probs.shape,N.float_)
        else:
            z = 0.5 *N.ones(probs.shape,N.float_)
        if even:
            e = N.zeros(probs.shape,N.float_)
        else:
            e = N.log(N.sqrt(N.pi)) *N.ones(probs.shape,N.float_)
        c = N.log(a)
        mask = N.zeros(probs.shape)
        a_big = N.greater(a,BIG)
        a_big_frozen = -1 *N.ones(probs.shape,N.float_)
        totalelements = N.multiply.reduce(N.array(probs.shape))
        while asum(mask)<>totalelements:
            e = N.log(z) + e
            s = s + ex(c*z-a-e)
            z = z + 1.0
    #            print z, e, s
            newmask = N.greater(z,chisq)
            a_big_frozen = N.where(newmask*N.equal(mask,0)*a_big, s, a_big_frozen)
            mask = N.clip(newmask+mask,0,1)
        if even:
            z = N.ones(probs.shape,N.float_)
            e = N.ones(probs.shape,N.float_)
        else:
            z = 0.5 *N.ones(probs.shape,N.float_)
            e = 1.0 / N.sqrt(N.pi) / N.sqrt(a) * N.ones(probs.shape,N.float_)
        c = 0.0
        mask = N.zeros(probs.shape)
        a_notbig_frozen = -1 *N.ones(probs.shape,N.float_)
        while asum(mask)<>totalelements:
            e = e * (a/z.astype(N.float_))
            c = c + e
            z = z + 1.0
    #            print '#2', z, e, c, s, c*y+s2
            newmask = N.greater(z,chisq)
            a_notbig_frozen = N.where(newmask*N.equal(mask,0)*(1-a_big),
                                      c*y+s2, a_notbig_frozen)
            mask = N.clip(newmask+mask,0,1)
        probs = N.where(N.equal(probs,1),1,
                        N.where(N.greater(a,BIG),a_big_frozen,a_notbig_frozen))
        return probs
    else:
        return s


def aerfcc(x):
    """
    Returns the complementary error function erfc(x) with fractional error
    everywhere less than 1.2e-7.  Adapted from Numerical Recipes.  Can
    handle multiple dimensions.
    
    Usage:   aerfcc(x)
    """
    z = abs(x)
    t = 1.0 / (1.0+0.5*z)
    ans = t * N.exp(-z*z-1.26551223 + t*(1.00002368+t*(0.37409196+t*(0.09678418+t*(-0.18628806+t*(0.27886807+t*(-1.13520398+t*(1.48851587+t*(-0.82215223+t*0.17087277)))))))))
    return N.where(N.greater_equal(x,0), ans, 2.0-ans)


def azprob(z):
    """
    Returns the area under the normal curve 'to the left of' the given z value.
    Thus, 
        - for z < 0, zprob(z) = 1-tail probability
        - for z > 0, 1.0-zprob(z) = 1-tail probability
        - for any z, 2.0*(1.0-zprob(abs(z))) = 2 - tail probability
    Adapted from z.c in Gary Perlman's |Stat.  Can handle multiple dimensions.
    
    Usage:   azprob(z)    where z is a z-value
    """
    def yfunc(y):
        x = (((((((((((((-0.000045255659 * y
                         +0.000152529290) * y -0.000019538132) * y
                       -0.000676904986) * y +0.001390604284) * y
                     -0.000794620820) * y -0.002034254874) * y
                   +0.006549791214) * y -0.010557625006) * y
                 +0.011630447319) * y -0.009279453341) * y
               +0.005353579108) * y -0.002141268741) * y
             +0.000535310849) * y +0.999936657524
        return x

    def wfunc(w):
        x = ((((((((0.000124818987 * w
                    -0.001075204047) * w +0.005198775019) * w
                  -0.019198292004) * w +0.059054035642) * w
                -0.151968751364) * w +0.319152932694) * w
              -0.531923007300) * w +0.797884560593) * N.sqrt(w) * 2.0
        return x

    Z_MAX = 6.0    # maximum meaningful z-value
    x = N.zeros(z.shape,N.float_) # initialize
    y = 0.5 * N.fabs(z)
    x = N.where(N.less(y,1.0),wfunc(y*y),yfunc(y-2.0)) # get x's
    x = N.where(N.greater(y,Z_MAX*0.5),1.0,x)          # kill those with big Z
    prob = N.where(N.greater(z,0),(x+1)*0.5,(1-x)*0.5)
    return prob


def aksprob(alam):
    """
   Returns the probability value for a K-S statistic computed via ks_2samp.
   Adapted from Numerical Recipes.  Can handle multiple dimensions.
   
   Usage:   aksprob(alam)
   """
    if type(alam) == N.ndarray:
        frozen = -1 *N.ones(alam.shape,N.float64)
        alam = alam.astype(N.float64)
        arrayflag = 1
    else:
        frozen = N.array(-1.)
        alam = N.array(alam,N.float64)
        arrayflag = 1
    mask = N.zeros(alam.shape)
    fac = 2.0 *N.ones(alam.shape,N.float_)
    sum = N.zeros(alam.shape,N.float_)
    termbf = N.zeros(alam.shape,N.float_)
    a2 = N.array(-2.0*alam*alam,N.float64)
    totalelements = N.multiply.reduce(N.array(mask.shape))
    for j in range(1,201):
        if asum(mask) == totalelements:
            break
        exponents = (a2*j*j)
        overflowmask = N.less(exponents,-746)
        frozen = N.where(overflowmask,0,frozen)
        mask = mask+overflowmask
        term = fac*N.exp(exponents)
        sum = sum + term
        newmask = N.where(N.less_equal(abs(term),(0.001*termbf)) +
                          N.less(abs(term),1.0e-8*sum), 1, 0)
        frozen = N.where(newmask*N.equal(mask,0), sum, frozen)
        mask = N.clip(mask+newmask,0,1)
        fac = -fac
        termbf = abs(term)
    if arrayflag:
        return N.where(N.equal(frozen,-1), 1.0, frozen)  # 1.0 if doesn't converge
    else:
        return N.where(N.equal(frozen,-1), 1.0, frozen)[0]  # 1.0 if doesn't converge


def afprob (dfnum, dfden, F):
    """
    Returns the 1-tailed significance level (p-value) of an F statistic
    given the degrees of freedom for the numerator (dfR-dfF) and the degrees
    of freedom for the denominator (dfF).  Can handle multiple dims for F.
    
    Usage:   afprob(dfnum, dfden, F)   where usually dfnum=dfbn, dfden=dfwn
    """
    if type(F) == N.ndarray:
        return abetai(0.5*dfden, 0.5*dfnum, dfden/(1.0*dfden+dfnum*F))
    else:
        return abetai(0.5*dfden, 0.5*dfnum, dfden/float(dfden+dfnum*F))


def abetacf(a,b,x,verbose=1):
    """
    Evaluates the continued fraction form of the incomplete Beta function,
    betai.  (Adapted from: Numerical Recipes in C.)  Can handle multiple
    dimensions for x.
    
    Usage:   abetacf(a,b,x,verbose=1)
    """
    ITMAX = 200
    EPS = 3.0e-7

    arrayflag = 1
    if type(x) == N.ndarray:
        frozen = N.ones(x.shape,N.float_) *-1  #start out w/ -1s, should replace all
    else:
        arrayflag = 0
        frozen = N.array([-1])
        x = N.array([x])
    mask = N.zeros(x.shape)
    bm = az = am = 1.0
    qab = a+b
    qap = a+1.0
    qam = a-1.0
    bz = 1.0-qab*x/qap
    for i in range(ITMAX+1):
        if N.sum(N.ravel(N.equal(frozen,-1)))==0:
            break
        em = float(i+1)
        tem = em + em
        d = em*(b-em)*x/((qam+tem)*(a+tem))
        ap = az + d*am
        bp = bz+d*bm
        d = -(a+em)*(qab+em)*x/((qap+tem)*(a+tem))
        app = ap+d*az
        bpp = bp+d*bz
        aold = az*1
        am = ap/bpp
        bm = bp/bpp
        az = app/bpp
        bz = 1.0
        newmask = N.less(abs(az-aold),EPS*abs(az))
        frozen = N.where(newmask*N.equal(mask,0), az, frozen)
        mask = N.clip(mask+newmask,0,1)
    noconverge = asum(N.equal(frozen,-1))
    if noconverge <> 0 and verbose:
        print 'a or b too big, or ITMAX too small in Betacf for ',noconverge,' elements'
    if arrayflag:
        return frozen
    else:
        return frozen[0]


def agammln(xx):
    """
    Returns the gamma function of xx.
    Gamma(z) = Integral(0,infinity) of t^(z-1)exp(-t) dt.
    
    Adapted from: Numerical Recipes in C.  Can handle multiple dims ... but
    probably doesn't normally have to.
    
    Usage:   agammln(xx)
    """
    coeff = [76.18009173, -86.50532033, 24.01409822, -1.231739516,
             0.120858003e-2, -0.536382e-5]
    x = xx - 1.0
    tmp = x + 5.5
    tmp = tmp - (x+0.5)*N.log(tmp)
    ser = 1.0
    for j in range(len(coeff)):
        x = x + 1
        ser = ser + coeff[j]/x
    return -tmp + N.log(2.50662827465*ser)


def abetai(a,b,x,verbose=1):
    """
    Returns the incomplete beta function:
    
    I-sub-x(a,b) = 1/B(a,b)*(Integral(0,x) of t^(a-1)(1-t)^(b-1) dt)
    
    where a,b>0 and B(a,b) = G(a)*G(b)/(G(a+b)) where G(a) is the gamma
    function of a.  The continued fraction formulation is implemented
    here, using the betacf function.  (Adapted from: Numerical Recipes in
    C.)  Can handle multiple dimensions.
    
    Usage:   abetai(a,b,x,verbose=1)
    """
    TINY = 1e-15
    if type(a) == N.ndarray:
        if asum(N.less(x,0)+N.greater(x,1)) <> 0:
            raise ValueError, 'Bad x in abetai'
    x = N.where(N.equal(x,0),TINY,x)
    x = N.where(N.equal(x,1.0),1-TINY,x)

    bt = N.where(N.equal(x,0)+N.equal(x,1), 0, -1)
    exponents = ( gammln(a+b)-gammln(a)-gammln(b)+a*N.log(x)+b*
                  N.log(1.0-x) )
    # 746 (below) is the MAX POSSIBLE BEFORE OVERFLOW
    exponents = N.where(N.less(exponents,-740),-740,exponents)
    bt = N.exp(exponents)
    if type(x) == N.ndarray:
        ans = N.where(N.less(x,(a+1)/(a+b+2.0)),
                      bt*abetacf(a,b,x,verbose)/float(a),
                      1.0-bt*abetacf(b,a,1.0-x,verbose)/float(b))
    else:
        if x<(a+1)/(a+b+2.0):
            ans = bt*abetacf(a,b,x,verbose)/float(a)
        else:
            ans = 1.0-bt*abetacf(b,a,1.0-x,verbose)/float(b)
    return ans

#####################################
#######  AANOVA CALCULATIONS  #######
#####################################

def aglm(data,para):
    """
    Calculates a linear model fit ... anova/ancova/lin-regress/t-test/etc. Taken
    from:
    
    Peterson et al. Statistical limitations in functional neuroimaging
    I. Non-inferential methods and statistical models.  Phil Trans Royal Soc
    Lond B 354: 1239-1260.
    
    Usage:   aglm(data,para)
    Returns: statistic, p-value ???
    """
    if len(para) <> len(data):
        print "data and para must be same length in aglm"
        return
    n = len(para)
    p = pstat.aunique(para)
    x = N.zeros((n,len(p)))  # design matrix
    for l in range(len(p)):
        x[:,l] = N.equal(para,p[l])
    b = N.dot(N.dot(LA.inv(N.dot(N.transpose(x),x)),  # i.e., b=inv(X'X)X'Y
                    N.transpose(x)),
              data)
    diffs = (data - N.dot(x,b))
    s_sq = 1./(n-len(p)) * N.dot(N.transpose(diffs), diffs)

    if len(p) == 2:  # ttest_ind
        c = N.array([1,-1])
        df = n-2
        fact = asum(1.0/asum(x,0))  # i.e., 1/n1 + 1/n2 + 1/n3 ...
        t = N.dot(c,b) / N.sqrt(s_sq*fact)
        probs = abetai(0.5*df,0.5,float(df)/(df+t*t))
        return t, probs


def aF_oneway(*args):
    """
    Performs a 1-way ANOVA, returning an F-value and probability given
    any number of groups.  From Heiman, pp.394-7.
    
    Usage:   aF_oneway (*args)    where *args is 2 or more arrays, one per treatment group
    Returns: f-value, probability
    """
    na = len(args)            # ANOVA on 'na' groups, each in it's own array
    means = [0]*na
    vars = [0]*na
    ns = [0]*na
    alldata = []
    tmp = map(N.array,args)
    means = map(amean,tmp)
    vars = map(avar,tmp)
    ns = map(len,args)
    alldata = N.concatenate(args)
    bign = len(alldata)
    sstot = ass(alldata)-(asquare_of_sums(alldata)/float(bign))
    ssbn = 0
    for a in args:
        ssbn = ssbn + asquare_of_sums(N.array(a))/float(len(a))
    ssbn = ssbn - (asquare_of_sums(alldata)/float(bign))
    sswn = sstot-ssbn
    dfbn = na-1
    dfwn = bign - na
    msb = ssbn/float(dfbn)
    msw = sswn/float(dfwn)
    f = msb/msw
    prob = fprob(dfbn,dfwn,f)
    return f, prob


def aF_value (ER,EF,dfR,dfF):
    """
    Returns an F-statistic given the following:
    ER  = error associated with the null hypothesis (the Restricted model)
    EF  = error associated with the alternate hypothesis (the Full model)
    dfR = degrees of freedom the Restricted model
    dfF = degrees of freedom associated with the Restricted model
    """
    return ((ER-EF)/float(dfR-dfF) / (EF/float(dfF)))

def outputfstats(Enum, Eden, dfnum, dfden, f, prob):
    Enum = round(Enum,3)
    Eden = round(Eden,3)
    dfnum = round(Enum,3)
    dfden = round(dfden,3)
    f = round(f,3)
    prob = round(prob,3)
    suffix = ''                       # for *s after the p-value
    if  prob < 0.001:  suffix = '  ***'
    elif prob < 0.01:  suffix = '  **'
    elif prob < 0.05:  suffix = '  *'
    title = [['EF/ER','DF','Mean Square','F-value','prob','']]
    lofl = title+[[Enum, dfnum, round(Enum/float(dfnum),3), f, prob, suffix],
                  [Eden, dfden, round(Eden/float(dfden),3),'','','']]
    pstat.printcc(lofl)
    return


def F_value_multivariate(ER, EF, dfnum, dfden):
    """
    Returns an F-statistic given the following:
    ER  = error associated with the null hypothesis (the Restricted model)
    EF  = error associated with the alternate hypothesis (the Full model)
    dfR = degrees of freedom the Restricted model
    dfF = degrees of freedom associated with the Restricted model
    where ER and EF are matrices from a multivariate F calculation.
    """
    if type(ER) in [IntType, FloatType]:
        ER = N.array([[ER]])
    if type(EF) in [IntType, FloatType]:
        EF = N.array([[EF]])
    n_um = (LA.det(ER) - LA.det(EF)) / float(dfnum)
    d_en = LA.det(EF) / float(dfden)
    return n_um / d_en

#####################################
#######  ASUPPORT FUNCTIONS  ########
#####################################

def asign(a):
    """
    Usage:   asign(a)
    Returns: array shape of a, with -1 where a<0 and +1 where a>=0
    """
    a = N.asarray(a)
    if ((type(a) == type(1.4)) or (type(a) == type(1))):
        return a-a-N.less(a,0)+N.greater(a,0)
    else:
        return N.zeros(N.shape(a))-N.less(a,0)+N.greater(a,0)


def asum (a, dimension=None,keepdims=0):
    """
   An alternative to the Numeric.add.reduce function, which allows one to
   (1) collapse over multiple dimensions at once, and/or (2) to retain
   all dimensions in the original array (squashing one down to size.
   Dimension can equal None (ravel array first), an integer (the
   dimension over which to operate), or a sequence (operate over multiple
   dimensions).  If keepdims=1, the resulting array will have as many
   dimensions as the input array.
   
   Usage:   asum(a, dimension=None, keepdims=0)
   Returns: array summed along 'dimension'(s), same _number_ of dims if keepdims=1
   """
    if type(a) == N.ndarray and a.dtype in [N.int_, N.short, N.ubyte]:
        a = a.astype(N.float_)
    if dimension == None:
        s = N.sum(N.ravel(a))
    elif type(dimension) in [IntType,FloatType]:
        s = N.add.reduce(a, dimension)
        if keepdims == 1:
            shp = list(a.shape)
            shp[dimension] = 1
            s = N.reshape(s,shp)
    else: # must be a SEQUENCE of dims to sum over
        dims = list(dimension)
        dims.sort()
        dims.reverse()
        s = a *1.0
        for dim in dims:
            s = N.add.reduce(s,dim)
        if keepdims == 1:
            shp = list(a.shape)
            for dim in dims:
                shp[dim] = 1
            s = N.reshape(s,shp)
    return s


def acumsum (a,dimension=None):
    """
    Returns an array consisting of the cumulative sum of the items in the
    passed array.  Dimension can equal None (ravel array first), an
    integer (the dimension over which to operate), or a sequence (operate
    over multiple dimensions, but this last one just barely makes sense).
    
    Usage:   acumsum(a,dimension=None)
    """
    if dimension == None:
        a = N.ravel(a)
        dimension = 0
    if type(dimension) in [ListType, TupleType, N.ndarray]:
        dimension = list(dimension)
        dimension.sort()
        dimension.reverse()
        for d in dimension:
            a = N.add.accumulate(a,d)
        return a
    else:
        return N.add.accumulate(a,dimension)


def ass(inarray, dimension=None, keepdims=0):
    """
    Squares each value in the passed array, adds these squares & returns
    the result.  Unfortunate function name. :-) Defaults to ALL values in
    the array.  Dimension can equal None (ravel array first), an integer
    (the dimension over which to operate), or a sequence (operate over
    multiple dimensions).  Set keepdims=1 to maintain the original number
    of dimensions.
    
    Usage:   ass(inarray, dimension=None, keepdims=0)
    Returns: sum-along-'dimension' for (inarray*inarray)
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    return asum(inarray*inarray,dimension,keepdims)


def asummult (array1,array2,dimension=None,keepdims=0):
    """
    Multiplies elements in array1 and array2, element by element, and
    returns the sum (along 'dimension') of all resulting multiplications.
    Dimension can equal None (ravel array first), an integer (the
    dimension over which to operate), or a sequence (operate over multiple
    dimensions).  A trivial function, but included for completeness.
    
    Usage:   asummult(array1,array2,dimension=None,keepdims=0)
    """
    if dimension == None:
        array1 = N.ravel(array1)
        array2 = N.ravel(array2)
        dimension = 0
    return asum(array1*array2,dimension,keepdims)


def asquare_of_sums(inarray, dimension=None, keepdims=0):
    """
    Adds the values in the passed array, squares that sum, and returns the
    result.  Dimension can equal None (ravel array first), an integer (the
    dimension over which to operate), or a sequence (operate over multiple
    dimensions).  If keepdims=1, the returned array will have the same
    NUMBER of dimensions as the original.
    
    Usage:   asquare_of_sums(inarray, dimension=None, keepdims=0)
    Returns: the square of the sum over dim(s) in dimension
    """
    if dimension == None:
        inarray = N.ravel(inarray)
        dimension = 0
    s = asum(inarray,dimension,keepdims)
    if type(s) == N.ndarray:
        return s.astype(N.float_)*s
    else:
        return float(s)*s


def asumdiffsquared(a,b, dimension=None, keepdims=0):
    """
    Takes pairwise differences of the values in arrays a and b, squares
    these differences, and returns the sum of these squares.  Dimension
    can equal None (ravel array first), an integer (the dimension over
    which to operate), or a sequence (operate over multiple dimensions).
    keepdims=1 means the return shape = len(a.shape) = len(b.shape)
    
    Usage:   asumdiffsquared(a,b)
    Returns: sum[ravel(a-b)**2]
    """
    if dimension == None:
        inarray = N.ravel(a)
        dimension = 0
    return asum((a-b)**2,dimension,keepdims)


def ashellsort(inarray):
    """
    Shellsort algorithm.  Sorts a 1D-array.
    
    Usage:   ashellsort(inarray)
    Returns: sorted-inarray, sorting-index-vector (for original array)
    """
    n = len(inarray)
    svec = inarray *1.0
    ivec = range(n)
    gap = n/2   # integer division needed
    while gap >0:
        for i in range(gap,n):
            for j in range(i-gap,-1,-gap):
                while j>=0 and svec[j]>svec[j+gap]:
                    temp        = svec[j]
                    svec[j]     = svec[j+gap]
                    svec[j+gap] = temp
                    itemp       = ivec[j]
                    ivec[j]     = ivec[j+gap]
                    ivec[j+gap] = itemp
        gap = gap / 2  # integer division needed
    # svec is now sorted input vector, ivec has the order svec[i] = vec[ivec[i]]
    return svec, ivec


def arankdata(inarray):
    """
    Ranks the data in inarray, dealing with ties appropritely.  Assumes
    a 1D inarray.  Adapted from Gary Perlman's |Stat ranksort.
    
    Usage:   arankdata(inarray)
    Returns: array of length equal to inarray, containing rank scores
    """
    n = len(inarray)
    svec, ivec = ashellsort(inarray)
    sumranks = 0
    dupcount = 0
    newarray = N.zeros(n,N.float_)
    for i in range(n):
        sumranks = sumranks + i
        dupcount = dupcount + 1
        if i==n-1 or svec[i] <> svec[i+1]:
            averank = sumranks / float(dupcount) + 1
            for j in range(i-dupcount+1,i+1):
                newarray[ivec[j]] = averank
            sumranks = 0
            dupcount = 0
    return newarray


def afindwithin(data):
    """
    Returns a binary vector, 1=within-subject factor, 0=between.  Input
    equals the entire data array (i.e., column 1=random factor, last
    column = measured values.
    
    Usage:   afindwithin(data)     data in |Stat format
    """
    numfact = len(data[0])-2
    withinvec = [0]*numfact
    for col in range(1,numfact+1):
        rows = pstat.linexand(data,col,pstat.unique(pstat.colex(data,1))[0])  # get 1 level of this factor
        if len(pstat.unique(pstat.colex(rows,0))) < len(rows):   # if fewer subjects than scores on this factor
            withinvec[col-1] = 1
    return withinvec


try: 
    # DEFINE THESE *ONLY* IF NUMERIC IS AVAILABLE
    import numpy as N
    import numpy.linalg as LA    
    import operator
    #########################################################
    #########################################################
    ######  RE-DEFINE DISPATCHES TO INCLUDE ARRAYS  #########
    #########################################################
    #########################################################
   
    ## CENTRAL TENDENCY:
    geometricmean = Dispatch ( (lgeometricmean, (ListType, TupleType)),
                               (ageometricmean, (N.ndarray,)) )
    harmonicmean = Dispatch ( (lharmonicmean, (ListType, TupleType)),
                              (aharmonicmean, (N.ndarray,)) )
    mean = Dispatch ( (lmean, (ListType, TupleType)),
                      (amean, (N.ndarray,)) )
    median = Dispatch ( (lmedian, (ListType, TupleType)),
                        (amedian, (N.ndarray,)) )
    medianscore = Dispatch ( (lmedianscore, (ListType, TupleType)),
                             (amedianscore, (N.ndarray,)) )
    mode = Dispatch ( (lmode, (ListType, TupleType)),
                      (amode, (N.ndarray,)) )
    tmean = Dispatch ( (atmean, (N.ndarray,)) )
    tvar = Dispatch ( (atvar, (N.ndarray,)) )
    tstdev = Dispatch ( (atstdev, (N.ndarray,)) )
    tsem = Dispatch ( (atsem, (N.ndarray,)) )
   
    ## VARIATION:
    moment = Dispatch ( (lmoment, (ListType, TupleType)),
                        (amoment, (N.ndarray,)) )
    variation = Dispatch ( (lvariation, (ListType, TupleType)),
                           (avariation, (N.ndarray,)) )
    skew = Dispatch ( (lskew, (ListType, TupleType)),
                      (askew, (N.ndarray,)) )
    kurtosis = Dispatch ( (lkurtosis, (ListType, TupleType)),
                          (akurtosis, (N.ndarray,)) )
    describe = Dispatch ( (ldescribe, (ListType, TupleType)),
                          (adescribe, (N.ndarray,)) )
   
    ## DISTRIBUTION TESTS

    skewtest = Dispatch ( (askewtest, (ListType, TupleType)),
                          (askewtest, (N.ndarray,)) )
    kurtosistest = Dispatch ( (akurtosistest, (ListType, TupleType)),
                              (akurtosistest, (N.ndarray,)) )
    normaltest = Dispatch ( (anormaltest, (ListType, TupleType)),
                            (anormaltest, (N.ndarray,)) )
   
    ## FREQUENCY STATS:
    itemfreq = Dispatch ( (litemfreq, (ListType, TupleType)),
                          (aitemfreq, (N.ndarray,)) )
    scoreatpercentile = Dispatch ( (lscoreatpercentile, (ListType, TupleType)),
                                   (ascoreatpercentile, (N.ndarray,)) )
    percentileofscore = Dispatch ( (lpercentileofscore, (ListType, TupleType)),
                                    (apercentileofscore, (N.ndarray,)) )
    histogram = Dispatch ( (lhistogram, (ListType, TupleType)),
                           (ahistogram, (N.ndarray,)) )
    cumfreq = Dispatch ( (lcumfreq, (ListType, TupleType)),
                         (acumfreq, (N.ndarray,)) )
    relfreq = Dispatch ( (lrelfreq, (ListType, TupleType)),
                         (arelfreq, (N.ndarray,)) )
    
    ## VARIABILITY:
    obrientransform = Dispatch ( (lobrientransform, (ListType, TupleType)),
                                 (aobrientransform, (N.ndarray,)) )
    samplevar = Dispatch ( (lsamplevar, (ListType, TupleType)),
                           (asamplevar, (N.ndarray,)) )
    samplestdev = Dispatch ( (lsamplestdev, (ListType, TupleType)),
                             (asamplestdev, (N.ndarray,)) )
    signaltonoise = Dispatch( (asignaltonoise, (N.ndarray,)),)
    var = Dispatch ( (lvar, (ListType, TupleType)),
                     (avar, (N.ndarray,)) )
    stdev = Dispatch ( (lstdev, (ListType, TupleType)),
                       (astdev, (N.ndarray,)) )
    sterr = Dispatch ( (lsterr, (ListType, TupleType)),
                       (asterr, (N.ndarray,)) )
    sem = Dispatch ( (lsem, (ListType, TupleType)),
                     (asem, (N.ndarray,)) )
    z = Dispatch ( (lz, (ListType, TupleType)),
                   (az, (N.ndarray,)) )
    zs = Dispatch ( (lzs, (ListType, TupleType)),
                    (azs, (N.ndarray,)) )
    
    ## TRIMMING FCNS:
    threshold = Dispatch( (athreshold, (N.ndarray,)),)
    trimboth = Dispatch ( (ltrimboth, (ListType, TupleType)),
                          (atrimboth, (N.ndarray,)) )
    trim1 = Dispatch ( (ltrim1, (ListType, TupleType)),
                       (atrim1, (N.ndarray,)) )
    
    ## CORRELATION FCNS:
    paired = Dispatch ( (lpaired, (ListType, TupleType)),
                        (apaired, (N.ndarray,)) )
    lincc = Dispatch ( (llincc, (ListType, TupleType)),
                          (alincc, (N.ndarray,)) )
    pearsonr = Dispatch ( (lpearsonr, (ListType, TupleType)),
                          (apearsonr, (N.ndarray,)) )
    spearmanr = Dispatch ( (lspearmanr, (ListType, TupleType)),
                           (aspearmanr, (N.ndarray,)) )
    pointbiserialr = Dispatch ( (lpointbiserialr, (ListType, TupleType)),
                                (apointbiserialr, (N.ndarray,)) )
    kendalltau = Dispatch ( (lkendalltau, (ListType, TupleType)),
                            (akendalltau, (N.ndarray,)) )
    linregress = Dispatch ( (llinregress, (ListType, TupleType)),
                            (alinregress, (N.ndarray,)) )
    
    ## INFERENTIAL STATS:
    ttest_1samp = Dispatch ( (lttest_1samp, (ListType, TupleType)),
                             (attest_1samp, (N.ndarray,)) )
    ttest_ind = Dispatch ( (lttest_ind, (ListType, TupleType)),
                           (attest_ind, (N.ndarray,)) )
    ttest_rel = Dispatch ( (lttest_rel, (ListType, TupleType)),
                           (attest_rel, (N.ndarray,)) )
    chisquare = Dispatch ( (lchisquare, (ListType, TupleType)),
                           (achisquare, (N.ndarray,)) )
    ks_2samp = Dispatch ( (lks_2samp, (ListType, TupleType)),
                          (aks_2samp, (N.ndarray,)) )
    mannwhitneyu = Dispatch ( (lmannwhitneyu, (ListType, TupleType)),
                              (amannwhitneyu, (N.ndarray,)) )
    tiecorrect = Dispatch ( (ltiecorrect, (ListType, TupleType)),
                            (atiecorrect, (N.ndarray,)) )
    ranksums = Dispatch ( (lranksums, (ListType, TupleType)),
                          (aranksums, (N.ndarray,)) )
    wilcoxont = Dispatch ( (lwilcoxont, (ListType, TupleType)),
                           (awilcoxont, (N.ndarray,)) )
    kruskalwallish = Dispatch ( (lkruskalwallish, (ListType, TupleType)),
                                (akruskalwallish, (N.ndarray,)) )
    friedmanchisquare = Dispatch ( (lfriedmanchisquare, (ListType, TupleType)),
                                   (afriedmanchisquare, (N.ndarray,)) )
    
    ## PROBABILITY CALCS:
    chisqprob = Dispatch ( (lchisqprob, (IntType, FloatType)),
                           (achisqprob, (N.ndarray,)) )
    zprob = Dispatch ( (lzprob, (IntType, FloatType)),
                       (azprob, (N.ndarray,)) )
    ksprob = Dispatch ( (lksprob, (IntType, FloatType)),
                        (aksprob, (N.ndarray,)) )
    fprob = Dispatch ( (lfprob, (IntType, FloatType)),
                       (afprob, (N.ndarray,)) )
    betacf = Dispatch ( (lbetacf, (IntType, FloatType)),
                        (abetacf, (N.ndarray,)) )
    betai = Dispatch ( (lbetai, (IntType, FloatType)),
                       (abetai, (N.ndarray,)) )
    erfcc = Dispatch ( (lerfcc, (IntType, FloatType)),
                       (aerfcc, (N.ndarray,)) )
    gammln = Dispatch ( (lgammln, (IntType, FloatType)),
                        (agammln, (N.ndarray,)) )
    
    ## ANOVA FUNCTIONS:
    F_oneway = Dispatch ( (lF_oneway, (ListType, TupleType)),
                          (aF_oneway, (N.ndarray,)) )
    F_value = Dispatch ( (lF_value, (ListType, TupleType)),
                         (aF_value, (N.ndarray,)) )
   
    ## SUPPORT FUNCTIONS:
    incr = Dispatch ( (lincr, (ListType, TupleType, N.ndarray)), )
    sum = Dispatch ( (lsum, (ListType, TupleType)),
                     (asum, (N.ndarray,)) )
    cumsum = Dispatch ( (lcumsum, (ListType, TupleType)),
                        (acumsum, (N.ndarray,)) )
    ss = Dispatch ( (lss, (ListType, TupleType)),
                    (ass, (N.ndarray,)) )
    summult = Dispatch ( (lsummult, (ListType, TupleType)),
                         (asummult, (N.ndarray,)) )
    square_of_sums = Dispatch ( (lsquare_of_sums, (ListType, TupleType)),
                                (asquare_of_sums, (N.ndarray,)) )
    sumdiffsquared = Dispatch ( (lsumdiffsquared, (ListType, TupleType)),
                                (asumdiffsquared, (N.ndarray,)) )
    shellsort = Dispatch ( (lshellsort, (ListType, TupleType)),
                           (ashellsort, (N.ndarray,)) )
    rankdata = Dispatch ( (lrankdata, (ListType, TupleType)),
                          (arankdata, (N.ndarray,)) )
    findwithin = Dispatch ( (lfindwithin, (ListType, TupleType)),
                            (afindwithin, (N.ndarray,)) )
   
######################  END OF NUMERIC FUNCTION BLOCK  #####################

######################  END OF STATISTICAL FUNCTIONS  ######################

except ImportError, exc:
    #print exc
    pass

########NEW FILE########
__FILENAME__ = composer

__all__ = ['Composer', 'ComposerError']

from error import MarkedYAMLError
from events import *
from nodes import *

class ComposerError(MarkedYAMLError):
    pass

class Composer(object):

    def __init__(self):
        self.anchors = {}

    def check_node(self):
        # Drop the STREAM-START event.
        if self.check_event(StreamStartEvent):
            self.get_event()

        # If there are more documents available?
        return not self.check_event(StreamEndEvent)

    def get_node(self):
        # Get the root node of the next document.
        if not self.check_event(StreamEndEvent):
            return self.compose_document()

    def get_single_node(self):
        # Drop the STREAM-START event.
        self.get_event()

        # Compose a document if the stream is not empty.
        document = None
        if not self.check_event(StreamEndEvent):
            document = self.compose_document()

        # Ensure that the stream contains no more documents.
        if not self.check_event(StreamEndEvent):
            event = self.get_event()
            raise ComposerError("expected a single document in the stream",
                    document.start_mark, "but found another document",
                    event.start_mark)

        # Drop the STREAM-END event.
        self.get_event()

        return document

    def compose_document(self):
        # Drop the DOCUMENT-START event.
        self.get_event()

        # Compose the root node.
        node = self.compose_node(None, None)

        # Drop the DOCUMENT-END event.
        self.get_event()

        self.anchors = {}
        return node

    def compose_node(self, parent, index):
        if self.check_event(AliasEvent):
            event = self.get_event()
            anchor = event.anchor
            if anchor not in self.anchors:
                raise ComposerError(None, None, "found undefined alias %r"
                        % anchor.encode('utf-8'), event.start_mark)
            return self.anchors[anchor]
        event = self.peek_event()
        anchor = event.anchor
        if anchor is not None:
            if anchor in self.anchors:
                raise ComposerError("found duplicate anchor %r; first occurence"
                        % anchor.encode('utf-8'), self.anchors[anchor].start_mark,
                        "second occurence", event.start_mark)
        self.descend_resolver(parent, index)
        if self.check_event(ScalarEvent):
            node = self.compose_scalar_node(anchor)
        elif self.check_event(SequenceStartEvent):
            node = self.compose_sequence_node(anchor)
        elif self.check_event(MappingStartEvent):
            node = self.compose_mapping_node(anchor)
        self.ascend_resolver()
        return node

    def compose_scalar_node(self, anchor):
        event = self.get_event()
        tag = event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(ScalarNode, event.value, event.implicit)
        node = ScalarNode(tag, event.value,
                event.start_mark, event.end_mark, style=event.style)
        if anchor is not None:
            self.anchors[anchor] = node
        return node

    def compose_sequence_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(SequenceNode, None, start_event.implicit)
        node = SequenceNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        index = 0
        while not self.check_event(SequenceEndEvent):
            node.value.append(self.compose_node(node, index))
            index += 1
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node

    def compose_mapping_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(MappingNode, None, start_event.implicit)
        node = MappingNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        while not self.check_event(MappingEndEvent):
            #key_event = self.peek_event()
            item_key = self.compose_node(node, None)
            #if item_key in node.value:
            #    raise ComposerError("while composing a mapping", start_event.start_mark,
            #            "found duplicate key", key_event.start_mark)
            item_value = self.compose_node(node, item_key)
            #node.value[item_key] = item_value
            node.value.append((item_key, item_value))
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node


########NEW FILE########
__FILENAME__ = constructor

__all__ = ['BaseConstructor', 'SafeConstructor', 'Constructor',
    'ConstructorError']

from error import *
from nodes import *

import datetime

try:
    set
except NameError:
    from sets import Set as set

import binascii, re, sys, types

class ConstructorError(MarkedYAMLError):
    pass

class BaseConstructor(object):

    yaml_constructors = {}
    yaml_multi_constructors = {}

    def __init__(self):
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.state_generators = []
        self.deep_construct = False

    def check_data(self):
        # If there are more documents available?
        return self.check_node()

    def get_data(self):
        # Construct and return the next document.
        if self.check_node():
            return self.construct_document(self.get_node())

    def get_single_data(self):
        # Ensure that the stream contains a single document and construct it.
        node = self.get_single_node()
        if node is not None:
            return self.construct_document(node)
        return None

    def construct_document(self, node):
        data = self.construct_object(node)
        while self.state_generators:
            state_generators = self.state_generators
            self.state_generators = []
            for generator in state_generators:
                for dummy in generator:
                    pass
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.deep_construct = False
        return data

    def construct_object(self, node, deep=False):
        if deep:
            old_deep = self.deep_construct
            self.deep_construct = True
        if node in self.constructed_objects:
            return self.constructed_objects[node]
        if node in self.recursive_objects:
            raise ConstructorError(None, None,
                    "found unconstructable recursive node", node.start_mark)
        self.recursive_objects[node] = None
        constructor = None
        tag_suffix = None
        if node.tag in self.yaml_constructors:
            constructor = self.yaml_constructors[node.tag]
        else:
            for tag_prefix in self.yaml_multi_constructors:
                if node.tag.startswith(tag_prefix):
                    tag_suffix = node.tag[len(tag_prefix):]
                    constructor = self.yaml_multi_constructors[tag_prefix]
                    break
            else:
                if None in self.yaml_multi_constructors:
                    tag_suffix = node.tag
                    constructor = self.yaml_multi_constructors[None]
                elif None in self.yaml_constructors:
                    constructor = self.yaml_constructors[None]
                elif isinstance(node, ScalarNode):
                    constructor = self.__class__.construct_scalar
                elif isinstance(node, SequenceNode):
                    constructor = self.__class__.construct_sequence
                elif isinstance(node, MappingNode):
                    constructor = self.__class__.construct_mapping
        if tag_suffix is None:
            data = constructor(self, node)
        else:
            data = constructor(self, tag_suffix, node)
        if isinstance(data, types.GeneratorType):
            generator = data
            data = generator.next()
            if self.deep_construct:
                for dummy in generator:
                    pass
            else:
                self.state_generators.append(generator)
        self.constructed_objects[node] = data
        del self.recursive_objects[node]
        if deep:
            self.deep_construct = old_deep
        return data

    def construct_scalar(self, node):
        if not isinstance(node, ScalarNode):
            raise ConstructorError(None, None,
                    "expected a scalar node, but found %s" % node.id,
                    node.start_mark)
        return node.value

    def construct_sequence(self, node, deep=False):
        if not isinstance(node, SequenceNode):
            raise ConstructorError(None, None,
                    "expected a sequence node, but found %s" % node.id,
                    node.start_mark)
        return [self.construct_object(child, deep=deep)
                for child in node.value]

    def construct_mapping(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        mapping = {}
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            try:
                hash(key)
            except TypeError, exc:
                raise ConstructorError("while constructing a mapping", node.start_mark,
                        "found unacceptable key (%s)" % exc, key_node.start_mark)
            value = self.construct_object(value_node, deep=deep)
            mapping[key] = value
        return mapping

    def construct_pairs(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        pairs = []
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            value = self.construct_object(value_node, deep=deep)
            pairs.append((key, value))
        return pairs

    def add_constructor(cls, tag, constructor):
        if not 'yaml_constructors' in cls.__dict__:
            cls.yaml_constructors = cls.yaml_constructors.copy()
        cls.yaml_constructors[tag] = constructor
    add_constructor = classmethod(add_constructor)

    def add_multi_constructor(cls, tag_prefix, multi_constructor):
        if not 'yaml_multi_constructors' in cls.__dict__:
            cls.yaml_multi_constructors = cls.yaml_multi_constructors.copy()
        cls.yaml_multi_constructors[tag_prefix] = multi_constructor
    add_multi_constructor = classmethod(add_multi_constructor)

class SafeConstructor(BaseConstructor):

    def construct_scalar(self, node):
        if isinstance(node, MappingNode):
            for key_node, value_node in node.value:
                if key_node.tag == u'tag:yaml.org,2002:value':
                    return self.construct_scalar(value_node)
        return BaseConstructor.construct_scalar(self, node)

    def flatten_mapping(self, node):
        merge = []
        index = 0
        while index < len(node.value):
            key_node, value_node = node.value[index]
            if key_node.tag == u'tag:yaml.org,2002:merge':
                del node.value[index]
                if isinstance(value_node, MappingNode):
                    self.flatten_mapping(value_node)
                    merge.extend(value_node.value)
                elif isinstance(value_node, SequenceNode):
                    submerge = []
                    for subnode in value_node.value:
                        if not isinstance(subnode, MappingNode):
                            raise ConstructorError("while constructing a mapping",
                                    node.start_mark,
                                    "expected a mapping for merging, but found %s"
                                    % subnode.id, subnode.start_mark)
                        self.flatten_mapping(subnode)
                        submerge.append(subnode.value)
                    submerge.reverse()
                    for value in submerge:
                        merge.extend(value)
                else:
                    raise ConstructorError("while constructing a mapping", node.start_mark,
                            "expected a mapping or list of mappings for merging, but found %s"
                            % value_node.id, value_node.start_mark)
            elif key_node.tag == u'tag:yaml.org,2002:value':
                key_node.tag = u'tag:yaml.org,2002:str'
                index += 1
            else:
                index += 1
        if merge:
            node.value = merge + node.value

    def construct_mapping(self, node, deep=False):
        if isinstance(node, MappingNode):
            self.flatten_mapping(node)
        return BaseConstructor.construct_mapping(self, node, deep=deep)

    def construct_yaml_null(self, node):
        self.construct_scalar(node)
        return None

    bool_values = {
        u'yes':     True,
        u'no':      False,
        u'true':    True,
        u'false':   False,
        u'on':      True,
        u'off':     False,
    }

    def construct_yaml_bool(self, node):
        value = self.construct_scalar(node)
        return self.bool_values[value.lower()]

    def construct_yaml_int(self, node):
        value = str(self.construct_scalar(node))
        value = value.replace('_', '')
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '0':
            return 0
        elif value.startswith('0b'):
            return sign*int(value[2:], 2)
        elif value.startswith('0x'):
            return sign*int(value[2:], 16)
        elif value[0] == '0':
            return sign*int(value, 8)
        elif ':' in value:
            digits = [int(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*int(value)

    inf_value = 1e300
    while inf_value != inf_value*inf_value:
        inf_value *= inf_value
    nan_value = -inf_value/inf_value   # Trying to make a quiet NaN (like C99).

    def construct_yaml_float(self, node):
        value = str(self.construct_scalar(node))
        value = value.replace('_', '').lower()
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '.inf':
            return sign*self.inf_value
        elif value == '.nan':
            return self.nan_value
        elif ':' in value:
            digits = [float(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0.0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*float(value)

    def construct_yaml_binary(self, node):
        value = self.construct_scalar(node)
        try:
            return str(value).decode('base64')
        except (binascii.Error, UnicodeEncodeError), exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark) 

    timestamp_regexp = re.compile(
            ur'''^(?P<year>[0-9][0-9][0-9][0-9])
                -(?P<month>[0-9][0-9]?)
                -(?P<day>[0-9][0-9]?)
                (?:(?:[Tt]|[ \t]+)
                (?P<hour>[0-9][0-9]?)
                :(?P<minute>[0-9][0-9])
                :(?P<second>[0-9][0-9])
                (?:\.(?P<fraction>[0-9]*))?
                (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
                (?::(?P<tz_minute>[0-9][0-9]))?))?)?$''', re.X)

    def construct_yaml_timestamp(self, node):
        value = self.construct_scalar(node)
        match = self.timestamp_regexp.match(node.value)
        values = match.groupdict()
        year = int(values['year'])
        month = int(values['month'])
        day = int(values['day'])
        if not values['hour']:
            return datetime.date(year, month, day)
        hour = int(values['hour'])
        minute = int(values['minute'])
        second = int(values['second'])
        fraction = 0
        if values['fraction']:
            fraction = values['fraction'][:6]
            while len(fraction) < 6:
                fraction += '0'
            fraction = int(fraction)
        delta = None
        if values['tz_sign']:
            tz_hour = int(values['tz_hour'])
            tz_minute = int(values['tz_minute'] or 0)
            delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)
            if values['tz_sign'] == '-':
                delta = -delta
        data = datetime.datetime(year, month, day, hour, minute, second, fraction)
        if delta:
            data -= delta
        return data

    def construct_yaml_omap(self, node):
        # Note: we do not check for duplicate keys, because it's too
        # CPU-expensive.
        omap = []
        yield omap
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing an ordered map", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            omap.append((key, value))

    def construct_yaml_pairs(self, node):
        # Note: the same code as `construct_yaml_omap`.
        pairs = []
        yield pairs
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing pairs", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            pairs.append((key, value))

    def construct_yaml_set(self, node):
        data = set()
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_str(self, node):
        value = self.construct_scalar(node)
        try:
            return value.encode('ascii')
        except UnicodeEncodeError:
            return value

    def construct_yaml_seq(self, node):
        data = []
        yield data
        data.extend(self.construct_sequence(node))

    def construct_yaml_map(self, node):
        data = {}
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_object(self, node, cls):
        data = cls.__new__(cls)
        yield data
        if hasattr(data, '__setstate__'):
            state = self.construct_mapping(node, deep=True)
            data.__setstate__(state)
        else:
            state = self.construct_mapping(node)
            data.__dict__.update(state)

    def construct_undefined(self, node):
        raise ConstructorError(None, None,
                "could not determine a constructor for the tag %r" % node.tag.encode('utf-8'),
                node.start_mark)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:null',
        SafeConstructor.construct_yaml_null)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:bool',
        SafeConstructor.construct_yaml_bool)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:int',
        SafeConstructor.construct_yaml_int)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:float',
        SafeConstructor.construct_yaml_float)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:binary',
        SafeConstructor.construct_yaml_binary)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:timestamp',
        SafeConstructor.construct_yaml_timestamp)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:omap',
        SafeConstructor.construct_yaml_omap)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:pairs',
        SafeConstructor.construct_yaml_pairs)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:set',
        SafeConstructor.construct_yaml_set)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:str',
        SafeConstructor.construct_yaml_str)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:seq',
        SafeConstructor.construct_yaml_seq)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:map',
        SafeConstructor.construct_yaml_map)

SafeConstructor.add_constructor(None,
        SafeConstructor.construct_undefined)

class Constructor(SafeConstructor):

    def construct_python_str(self, node):
        return self.construct_scalar(node).encode('utf-8')

    def construct_python_unicode(self, node):
        return self.construct_scalar(node)

    def construct_python_long(self, node):
        return long(self.construct_yaml_int(node))

    def construct_python_complex(self, node):
       return complex(self.construct_scalar(node))

    def construct_python_tuple(self, node):
        return tuple(self.construct_sequence(node))

    def find_python_module(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python module", mark,
                    "expected non-empty name appended to the tag", mark)
        try:
            __import__(name)
        except ImportError, exc:
            raise ConstructorError("while constructing a Python module", mark,
                    "cannot find module %r (%s)" % (name.encode('utf-8'), exc), mark)
        return sys.modules[name]

    def find_python_name(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python object", mark,
                    "expected non-empty name appended to the tag", mark)
        if u'.' in name:
            # Python 2.4 only
            #module_name, object_name = name.rsplit('.', 1)
            items = name.split('.')
            object_name = items.pop()
            module_name = '.'.join(items)
        else:
            module_name = '__builtin__'
            object_name = name
        try:
            __import__(module_name)
        except ImportError, exc:
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find module %r (%s)" % (module_name.encode('utf-8'), exc), mark)
        module = sys.modules[module_name]
        if not hasattr(module, object_name):
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find %r in the module %r" % (object_name.encode('utf-8'),
                        module.__name__), mark)
        return getattr(module, object_name)

    def construct_python_name(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python name", node.start_mark,
                    "expected the empty value, but found %r" % value.encode('utf-8'),
                    node.start_mark)
        return self.find_python_name(suffix, node.start_mark)

    def construct_python_module(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python module", node.start_mark,
                    "expected the empty value, but found %r" % value.encode('utf-8'),
                    node.start_mark)
        return self.find_python_module(suffix, node.start_mark)

    class classobj: pass

    def make_python_instance(self, suffix, node,
            args=None, kwds=None, newobj=False):
        if not args:
            args = []
        if not kwds:
            kwds = {}
        cls = self.find_python_name(suffix, node.start_mark)
        if newobj and isinstance(cls, type(self.classobj))  \
                and not args and not kwds:
            instance = self.classobj()
            instance.__class__ = cls
            return instance
        elif newobj and isinstance(cls, type):
            return cls.__new__(cls, *args, **kwds)
        else:
            return cls(*args, **kwds)

    def set_python_instance_state(self, instance, state):
        if hasattr(instance, '__setstate__'):
            instance.__setstate__(state)
        else:
            slotstate = {}
            if isinstance(state, tuple) and len(state) == 2:
                state, slotstate = state
            if hasattr(instance, '__dict__'):
                instance.__dict__.update(state)
            elif state:
                slotstate.update(state)
            for key, value in slotstate.items():
                setattr(object, key, value)

    def construct_python_object(self, suffix, node):
        # Format:
        #   !!python/object:module.name { ... state ... }
        instance = self.make_python_instance(suffix, node, newobj=True)
        yield instance
        deep = hasattr(instance, '__setstate__')
        state = self.construct_mapping(node, deep=deep)
        self.set_python_instance_state(instance, state)

    def construct_python_object_apply(self, suffix, node, newobj=False):
        # Format:
        #   !!python/object/apply       # (or !!python/object/new)
        #   args: [ ... arguments ... ]
        #   kwds: { ... keywords ... }
        #   state: ... state ...
        #   listitems: [ ... listitems ... ]
        #   dictitems: { ... dictitems ... }
        # or short format:
        #   !!python/object/apply [ ... arguments ... ]
        # The difference between !!python/object/apply and !!python/object/new
        # is how an object is created, check make_python_instance for details.
        if isinstance(node, SequenceNode):
            args = self.construct_sequence(node, deep=True)
            kwds = {}
            state = {}
            listitems = []
            dictitems = {}
        else:
            value = self.construct_mapping(node, deep=True)
            args = value.get('args', [])
            kwds = value.get('kwds', {})
            state = value.get('state', {})
            listitems = value.get('listitems', [])
            dictitems = value.get('dictitems', {})
        instance = self.make_python_instance(suffix, node, args, kwds, newobj)
        if state:
            self.set_python_instance_state(instance, state)
        if listitems:
            instance.extend(listitems)
        if dictitems:
            for key in dictitems:
                instance[key] = dictitems[key]
        return instance

    def construct_python_object_new(self, suffix, node):
        return self.construct_python_object_apply(suffix, node, newobj=True)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/none',
    Constructor.construct_yaml_null)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/bool',
    Constructor.construct_yaml_bool)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/str',
    Constructor.construct_python_str)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/unicode',
    Constructor.construct_python_unicode)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/int',
    Constructor.construct_yaml_int)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/long',
    Constructor.construct_python_long)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/float',
    Constructor.construct_yaml_float)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/complex',
    Constructor.construct_python_complex)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/list',
    Constructor.construct_yaml_seq)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/tuple',
    Constructor.construct_python_tuple)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/dict',
    Constructor.construct_yaml_map)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/name:',
    Constructor.construct_python_name)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/module:',
    Constructor.construct_python_module)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object:',
    Constructor.construct_python_object)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object/apply:',
    Constructor.construct_python_object_apply)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object/new:',
    Constructor.construct_python_object_new)


########NEW FILE########
__FILENAME__ = cyaml

__all__ = ['CBaseLoader', 'CSafeLoader', 'CLoader',
        'CBaseDumper', 'CSafeDumper', 'CDumper']

from _yaml import CParser, CEmitter

from constructor import *

from serializer import *
from representer import *

from resolver import *

class CBaseLoader(CParser, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class CSafeLoader(CParser, SafeConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class CLoader(CParser, Constructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        Constructor.__init__(self)
        Resolver.__init__(self)

class CBaseDumper(CEmitter, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CSafeDumper(CEmitter, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CDumper(CEmitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = dumper

__all__ = ['BaseDumper', 'SafeDumper', 'Dumper']

from emitter import *
from serializer import *
from representer import *
from resolver import *

class BaseDumper(Emitter, Serializer, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class SafeDumper(Emitter, Serializer, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class Dumper(Emitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = emitter

# Emitter expects events obeying the following grammar:
# stream ::= STREAM-START document* STREAM-END
# document ::= DOCUMENT-START node DOCUMENT-END
# node ::= SCALAR | sequence | mapping
# sequence ::= SEQUENCE-START node* SEQUENCE-END
# mapping ::= MAPPING-START (node node)* MAPPING-END

__all__ = ['Emitter', 'EmitterError']

from error import YAMLError
from events import *

class EmitterError(YAMLError):
    pass

class ScalarAnalysis(object):
    def __init__(self, scalar, empty, multiline,
            allow_flow_plain, allow_block_plain,
            allow_single_quoted, allow_double_quoted,
            allow_block):
        self.scalar = scalar
        self.empty = empty
        self.multiline = multiline
        self.allow_flow_plain = allow_flow_plain
        self.allow_block_plain = allow_block_plain
        self.allow_single_quoted = allow_single_quoted
        self.allow_double_quoted = allow_double_quoted
        self.allow_block = allow_block

class Emitter(object):

    DEFAULT_TAG_PREFIXES = {
        u'!' : u'!',
        u'tag:yaml.org,2002:' : u'!!',
    }

    def __init__(self, stream, canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None):

        # The stream should have the methods `write` and possibly `flush`.
        self.stream = stream

        # Encoding can be overriden by STREAM-START.
        self.encoding = None

        # Emitter is a state machine with a stack of states to handle nested
        # structures.
        self.states = []
        self.state = self.expect_stream_start

        # Current event and the event queue.
        self.events = []
        self.event = None

        # The current indentation level and the stack of previous indents.
        self.indents = []
        self.indent = None

        # Flow level.
        self.flow_level = 0

        # Contexts.
        self.root_context = False
        self.sequence_context = False
        self.mapping_context = False
        self.simple_key_context = False

        # Characteristics of the last emitted character:
        #  - current position.
        #  - is it a whitespace?
        #  - is it an indention character
        #    (indentation space, '-', '?', or ':')?
        self.line = 0
        self.column = 0
        self.whitespace = True
        self.indention = True

        # Whether the document requires an explicit document indicator
        self.open_ended = False

        # Formatting details.
        self.canonical = canonical
        self.allow_unicode = allow_unicode
        self.best_indent = 2
        if indent and 1 < indent < 10:
            self.best_indent = indent
        self.best_width = 80
        if width and width > self.best_indent*2:
            self.best_width = width
        self.best_line_break = u'\n'
        if line_break in [u'\r', u'\n', u'\r\n']:
            self.best_line_break = line_break

        # Tag prefixes.
        self.tag_prefixes = None

        # Prepared anchor and tag.
        self.prepared_anchor = None
        self.prepared_tag = None

        # Scalar analysis and style.
        self.analysis = None
        self.style = None

    def emit(self, event):
        self.events.append(event)
        while not self.need_more_events():
            self.event = self.events.pop(0)
            self.state()
            self.event = None

    # In some cases, we wait for a few next events before emitting.

    def need_more_events(self):
        if not self.events:
            return True
        event = self.events[0]
        if isinstance(event, DocumentStartEvent):
            return self.need_events(1)
        elif isinstance(event, SequenceStartEvent):
            return self.need_events(2)
        elif isinstance(event, MappingStartEvent):
            return self.need_events(3)
        else:
            return False

    def need_events(self, count):
        level = 0
        for event in self.events[1:]:
            if isinstance(event, (DocumentStartEvent, CollectionStartEvent)):
                level += 1
            elif isinstance(event, (DocumentEndEvent, CollectionEndEvent)):
                level -= 1
            elif isinstance(event, StreamEndEvent):
                level = -1
            if level < 0:
                return False
        return (len(self.events) < count+1)

    def increase_indent(self, flow=False, indentless=False):
        self.indents.append(self.indent)
        if self.indent is None:
            if flow:
                self.indent = self.best_indent
            else:
                self.indent = 0
        elif not indentless:
            self.indent += self.best_indent

    # States.

    # Stream handlers.

    def expect_stream_start(self):
        if isinstance(self.event, StreamStartEvent):
            if self.event.encoding and not getattr(self.stream, 'encoding', None):
                self.encoding = self.event.encoding
            self.write_stream_start()
            self.state = self.expect_first_document_start
        else:
            raise EmitterError("expected StreamStartEvent, but got %s"
                    % self.event)

    def expect_nothing(self):
        raise EmitterError("expected nothing, but got %s" % self.event)

    # Document handlers.

    def expect_first_document_start(self):
        return self.expect_document_start(first=True)

    def expect_document_start(self, first=False):
        if isinstance(self.event, DocumentStartEvent):
            if (self.event.version or self.event.tags) and self.open_ended:
                self.write_indicator(u'...', True)
                self.write_indent()
            if self.event.version:
                version_text = self.prepare_version(self.event.version)
                self.write_version_directive(version_text)
            self.tag_prefixes = self.DEFAULT_TAG_PREFIXES.copy()
            if self.event.tags:
                handles = self.event.tags.keys()
                handles.sort()
                for handle in handles:
                    prefix = self.event.tags[handle]
                    self.tag_prefixes[prefix] = handle
                    handle_text = self.prepare_tag_handle(handle)
                    prefix_text = self.prepare_tag_prefix(prefix)
                    self.write_tag_directive(handle_text, prefix_text)
            implicit = (first and not self.event.explicit and not self.canonical
                    and not self.event.version and not self.event.tags
                    and not self.check_empty_document())
            if not implicit:
                self.write_indent()
                self.write_indicator(u'---', True)
                if self.canonical:
                    self.write_indent()
            self.state = self.expect_document_root
        elif isinstance(self.event, StreamEndEvent):
            if self.open_ended:
                self.write_indicator(u'...', True)
                self.write_indent()
            self.write_stream_end()
            self.state = self.expect_nothing
        else:
            raise EmitterError("expected DocumentStartEvent, but got %s"
                    % self.event)

    def expect_document_end(self):
        if isinstance(self.event, DocumentEndEvent):
            self.write_indent()
            if self.event.explicit:
                self.write_indicator(u'...', True)
                self.write_indent()
            self.flush_stream()
            self.state = self.expect_document_start
        else:
            raise EmitterError("expected DocumentEndEvent, but got %s"
                    % self.event)

    def expect_document_root(self):
        self.states.append(self.expect_document_end)
        self.expect_node(root=True)

    # Node handlers.

    def expect_node(self, root=False, sequence=False, mapping=False,
            simple_key=False):
        self.root_context = root
        self.sequence_context = sequence
        self.mapping_context = mapping
        self.simple_key_context = simple_key
        if isinstance(self.event, AliasEvent):
            self.expect_alias()
        elif isinstance(self.event, (ScalarEvent, CollectionStartEvent)):
            self.process_anchor(u'&')
            self.process_tag()
            if isinstance(self.event, ScalarEvent):
                self.expect_scalar()
            elif isinstance(self.event, SequenceStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_sequence():
                    self.expect_flow_sequence()
                else:
                    self.expect_block_sequence()
            elif isinstance(self.event, MappingStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_mapping():
                    self.expect_flow_mapping()
                else:
                    self.expect_block_mapping()
        else:
            raise EmitterError("expected NodeEvent, but got %s" % self.event)

    def expect_alias(self):
        if self.event.anchor is None:
            raise EmitterError("anchor is not specified for alias")
        self.process_anchor(u'*')
        self.state = self.states.pop()

    def expect_scalar(self):
        self.increase_indent(flow=True)
        self.process_scalar()
        self.indent = self.indents.pop()
        self.state = self.states.pop()

    # Flow sequence handlers.

    def expect_flow_sequence(self):
        self.write_indicator(u'[', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_sequence_item

    def expect_first_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(u']', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    def expect_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(u',', False)
                self.write_indent()
            self.write_indicator(u']', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(u',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    # Flow mapping handlers.

    def expect_flow_mapping(self):
        self.write_indicator(u'{', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_mapping_key

    def expect_first_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(u'}', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(u',', False)
                self.write_indent()
            self.write_indicator(u'}', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(u',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_simple_value(self):
        self.write_indicator(u':', False)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    def expect_flow_mapping_value(self):
        if self.canonical or self.column > self.best_width:
            self.write_indent()
        self.write_indicator(u':', True)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    # Block sequence handlers.

    def expect_block_sequence(self):
        indentless = (self.mapping_context and not self.indention)
        self.increase_indent(flow=False, indentless=indentless)
        self.state = self.expect_first_block_sequence_item

    def expect_first_block_sequence_item(self):
        return self.expect_block_sequence_item(first=True)

    def expect_block_sequence_item(self, first=False):
        if not first and isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            self.write_indicator(u'-', True, indention=True)
            self.states.append(self.expect_block_sequence_item)
            self.expect_node(sequence=True)

    # Block mapping handlers.

    def expect_block_mapping(self):
        self.increase_indent(flow=False)
        self.state = self.expect_first_block_mapping_key

    def expect_first_block_mapping_key(self):
        return self.expect_block_mapping_key(first=True)

    def expect_block_mapping_key(self, first=False):
        if not first and isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            if self.check_simple_key():
                self.states.append(self.expect_block_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True, indention=True)
                self.states.append(self.expect_block_mapping_value)
                self.expect_node(mapping=True)

    def expect_block_mapping_simple_value(self):
        self.write_indicator(u':', False)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    def expect_block_mapping_value(self):
        self.write_indent()
        self.write_indicator(u':', True, indention=True)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    # Checkers.

    def check_empty_sequence(self):
        return (isinstance(self.event, SequenceStartEvent) and self.events
                and isinstance(self.events[0], SequenceEndEvent))

    def check_empty_mapping(self):
        return (isinstance(self.event, MappingStartEvent) and self.events
                and isinstance(self.events[0], MappingEndEvent))

    def check_empty_document(self):
        if not isinstance(self.event, DocumentStartEvent) or not self.events:
            return False
        event = self.events[0]
        return (isinstance(event, ScalarEvent) and event.anchor is None
                and event.tag is None and event.implicit and event.value == u'')

    def check_simple_key(self):
        length = 0
        if isinstance(self.event, NodeEvent) and self.event.anchor is not None:
            if self.prepared_anchor is None:
                self.prepared_anchor = self.prepare_anchor(self.event.anchor)
            length += len(self.prepared_anchor)
        if isinstance(self.event, (ScalarEvent, CollectionStartEvent))  \
                and self.event.tag is not None:
            if self.prepared_tag is None:
                self.prepared_tag = self.prepare_tag(self.event.tag)
            length += len(self.prepared_tag)
        if isinstance(self.event, ScalarEvent):
            if self.analysis is None:
                self.analysis = self.analyze_scalar(self.event.value)
            length += len(self.analysis.scalar)
        return (length < 128 and (isinstance(self.event, AliasEvent)
            or (isinstance(self.event, ScalarEvent)
                    and not self.analysis.empty and not self.analysis.multiline)
            or self.check_empty_sequence() or self.check_empty_mapping()))

    # Anchor, Tag, and Scalar processors.

    def process_anchor(self, indicator):
        if self.event.anchor is None:
            self.prepared_anchor = None
            return
        if self.prepared_anchor is None:
            self.prepared_anchor = self.prepare_anchor(self.event.anchor)
        if self.prepared_anchor:
            self.write_indicator(indicator+self.prepared_anchor, True)
        self.prepared_anchor = None

    def process_tag(self):
        tag = self.event.tag
        if isinstance(self.event, ScalarEvent):
            if self.style is None:
                self.style = self.choose_scalar_style()
            if ((not self.canonical or tag is None) and
                ((self.style == '' and self.event.implicit[0])
                        or (self.style != '' and self.event.implicit[1]))):
                self.prepared_tag = None
                return
            if self.event.implicit[0] and tag is None:
                tag = u'!'
                self.prepared_tag = None
        else:
            if (not self.canonical or tag is None) and self.event.implicit:
                self.prepared_tag = None
                return
        if tag is None:
            raise EmitterError("tag is not specified")
        if self.prepared_tag is None:
            self.prepared_tag = self.prepare_tag(tag)
        if self.prepared_tag:
            self.write_indicator(self.prepared_tag, True)
        self.prepared_tag = None

    def choose_scalar_style(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.event.style == '"' or self.canonical:
            return '"'
        if not self.event.style and self.event.implicit[0]:
            if (not (self.simple_key_context and
                    (self.analysis.empty or self.analysis.multiline))
                and (self.flow_level and self.analysis.allow_flow_plain
                    or (not self.flow_level and self.analysis.allow_block_plain))):
                return ''
        if self.event.style and self.event.style in '|>':
            if (not self.flow_level and not self.simple_key_context
                    and self.analysis.allow_block):
                return self.event.style
        if not self.event.style or self.event.style == '\'':
            if (self.analysis.allow_single_quoted and
                    not (self.simple_key_context and self.analysis.multiline)):
                return '\''
        return '"'

    def process_scalar(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.style is None:
            self.style = self.choose_scalar_style()
        split = (not self.simple_key_context)
        #if self.analysis.multiline and split    \
        #        and (not self.style or self.style in '\'\"'):
        #    self.write_indent()
        if self.style == '"':
            self.write_double_quoted(self.analysis.scalar, split)
        elif self.style == '\'':
            self.write_single_quoted(self.analysis.scalar, split)
        elif self.style == '>':
            self.write_folded(self.analysis.scalar)
        elif self.style == '|':
            self.write_literal(self.analysis.scalar)
        else:
            self.write_plain(self.analysis.scalar, split)
        self.analysis = None
        self.style = None

    # Analyzers.

    def prepare_version(self, version):
        major, minor = version
        if major != 1:
            raise EmitterError("unsupported YAML version: %d.%d" % (major, minor))
        return u'%d.%d' % (major, minor)

    def prepare_tag_handle(self, handle):
        if not handle:
            raise EmitterError("tag handle must not be empty")
        if handle[0] != u'!' or handle[-1] != u'!':
            raise EmitterError("tag handle must start and end with '!': %r"
                    % (handle.encode('utf-8')))
        for ch in handle[1:-1]:
            if not (u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'  \
                    or ch in u'-_'):
                raise EmitterError("invalid character %r in the tag handle: %r"
                        % (ch.encode('utf-8'), handle.encode('utf-8')))
        return handle

    def prepare_tag_prefix(self, prefix):
        if not prefix:
            raise EmitterError("tag prefix must not be empty")
        chunks = []
        start = end = 0
        if prefix[0] == u'!':
            end = 1
        while end < len(prefix):
            ch = prefix[end]
            if u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'   \
                    or ch in u'-;/?!:@&=+$,_.~*\'()[]':
                end += 1
            else:
                if start < end:
                    chunks.append(prefix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append(u'%%%02X' % ord(ch))
        if start < end:
            chunks.append(prefix[start:end])
        return u''.join(chunks)

    def prepare_tag(self, tag):
        if not tag:
            raise EmitterError("tag must not be empty")
        if tag == u'!':
            return tag
        handle = None
        suffix = tag
        prefixes = self.tag_prefixes.keys()
        prefixes.sort()
        for prefix in prefixes:
            if tag.startswith(prefix)   \
                    and (prefix == u'!' or len(prefix) < len(tag)):
                handle = self.tag_prefixes[prefix]
                suffix = tag[len(prefix):]
        chunks = []
        start = end = 0
        while end < len(suffix):
            ch = suffix[end]
            if u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'   \
                    or ch in u'-;/?:@&=+$,_.~*\'()[]'   \
                    or (ch == u'!' and handle != u'!'):
                end += 1
            else:
                if start < end:
                    chunks.append(suffix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append(u'%%%02X' % ord(ch))
        if start < end:
            chunks.append(suffix[start:end])
        suffix_text = u''.join(chunks)
        if handle:
            return u'%s%s' % (handle, suffix_text)
        else:
            return u'!<%s>' % suffix_text

    def prepare_anchor(self, anchor):
        if not anchor:
            raise EmitterError("anchor must not be empty")
        for ch in anchor:
            if not (u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'  \
                    or ch in u'-_'):
                raise EmitterError("invalid character %r in the anchor: %r"
                        % (ch.encode('utf-8'), anchor.encode('utf-8')))
        return anchor

    def analyze_scalar(self, scalar):

        # Empty scalar is a special case.
        if not scalar:
            return ScalarAnalysis(scalar=scalar, empty=True, multiline=False,
                    allow_flow_plain=False, allow_block_plain=True,
                    allow_single_quoted=True, allow_double_quoted=True,
                    allow_block=False)

        # Indicators and special characters.
        block_indicators = False
        flow_indicators = False
        line_breaks = False
        special_characters = False

        # Important whitespace combinations.
        leading_space = False
        leading_break = False
        trailing_space = False
        trailing_break = False
        break_space = False
        space_break = False

        # Check document indicators.
        if scalar.startswith(u'---') or scalar.startswith(u'...'):
            block_indicators = True
            flow_indicators = True

        # First character or preceded by a whitespace.
        preceeded_by_whitespace = True

        # Last character or followed by a whitespace.
        followed_by_whitespace = (len(scalar) == 1 or
                scalar[1] in u'\0 \t\r\n\x85\u2028\u2029')

        # The previous character is a space.
        previous_space = False

        # The previous character is a break.
        previous_break = False

        index = 0
        while index < len(scalar):
            ch = scalar[index]

            # Check for indicators.
            if index == 0:
                # Leading indicators are special characters.
                if ch in u'#,[]{}&*!|>\'\"%@`': 
                    flow_indicators = True
                    block_indicators = True
                if ch in u'?:':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == u'-' and followed_by_whitespace:
                    flow_indicators = True
                    block_indicators = True
            else:
                # Some indicators cannot appear within a scalar as well.
                if ch in u',?[]{}':
                    flow_indicators = True
                if ch == u':':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == u'#' and preceeded_by_whitespace:
                    flow_indicators = True
                    block_indicators = True

            # Check for line breaks, special, and unicode characters.
            if ch in u'\n\x85\u2028\u2029':
                line_breaks = True
            if not (ch == u'\n' or u'\x20' <= ch <= u'\x7E'):
                if (ch == u'\x85' or u'\xA0' <= ch <= u'\uD7FF'
                        or u'\uE000' <= ch <= u'\uFFFD') and ch != u'\uFEFF':
                    unicode_characters = True
                    if not self.allow_unicode:
                        special_characters = True
                else:
                    special_characters = True

            # Detect important whitespace combinations.
            if ch == u' ':
                if index == 0:
                    leading_space = True
                if index == len(scalar)-1:
                    trailing_space = True
                if previous_break:
                    break_space = True
                previous_space = True
                previous_break = False
            elif ch in u'\n\x85\u2028\u2029':
                if index == 0:
                    leading_break = True
                if index == len(scalar)-1:
                    trailing_break = True
                if previous_space:
                    space_break = True
                previous_space = False
                previous_break = True
            else:
                previous_space = False
                previous_break = False

            # Prepare for the next character.
            index += 1
            preceeded_by_whitespace = (ch in u'\0 \t\r\n\x85\u2028\u2029')
            followed_by_whitespace = (index+1 >= len(scalar) or
                    scalar[index+1] in u'\0 \t\r\n\x85\u2028\u2029')

        # Let's decide what styles are allowed.
        allow_flow_plain = True
        allow_block_plain = True
        allow_single_quoted = True
        allow_double_quoted = True
        allow_block = True

        # Leading and trailing whitespaces are bad for plain scalars.
        if (leading_space or leading_break
                or trailing_space or trailing_break):
            allow_flow_plain = allow_block_plain = False

        # We do not permit trailing spaces for block scalars.
        if trailing_space:
            allow_block = False

        # Spaces at the beginning of a new line are only acceptable for block
        # scalars.
        if break_space:
            allow_flow_plain = allow_block_plain = allow_single_quoted = False

        # Spaces followed by breaks, as well as special character are only
        # allowed for double quoted scalars.
        if space_break or special_characters:
            allow_flow_plain = allow_block_plain =  \
            allow_single_quoted = allow_block = False

        # Although the plain scalar writer supports breaks, we never emit
        # multiline plain scalars.
        if line_breaks:
            allow_flow_plain = allow_block_plain = False

        # Flow indicators are forbidden for flow plain scalars.
        if flow_indicators:
            allow_flow_plain = False

        # Block indicators are forbidden for block plain scalars.
        if block_indicators:
            allow_block_plain = False

        return ScalarAnalysis(scalar=scalar,
                empty=False, multiline=line_breaks,
                allow_flow_plain=allow_flow_plain,
                allow_block_plain=allow_block_plain,
                allow_single_quoted=allow_single_quoted,
                allow_double_quoted=allow_double_quoted,
                allow_block=allow_block)

    # Writers.

    def flush_stream(self):
        if hasattr(self.stream, 'flush'):
            self.stream.flush()

    def write_stream_start(self):
        # Write BOM if needed.
        if self.encoding and self.encoding.startswith('utf-16'):
            self.stream.write(u'\uFEFF'.encode(self.encoding))

    def write_stream_end(self):
        self.flush_stream()

    def write_indicator(self, indicator, need_whitespace,
            whitespace=False, indention=False):
        if self.whitespace or not need_whitespace:
            data = indicator
        else:
            data = u' '+indicator
        self.whitespace = whitespace
        self.indention = self.indention and indention
        self.column += len(data)
        self.open_ended = False
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_indent(self):
        indent = self.indent or 0
        if not self.indention or self.column > indent   \
                or (self.column == indent and not self.whitespace):
            self.write_line_break()
        if self.column < indent:
            self.whitespace = True
            data = u' '*(indent-self.column)
            self.column = indent
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)

    def write_line_break(self, data=None):
        if data is None:
            data = self.best_line_break
        self.whitespace = True
        self.indention = True
        self.line += 1
        self.column = 0
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_version_directive(self, version_text):
        data = u'%%YAML %s' % version_text
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    def write_tag_directive(self, handle_text, prefix_text):
        data = u'%%TAG %s %s' % (handle_text, prefix_text)
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    # Scalar streams.

    def write_single_quoted(self, text, split=True):
        self.write_indicator(u'\'', True)
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch is None or ch != u' ':
                    if start+1 == end and self.column > self.best_width and split   \
                            and start != 0 and end != len(text):
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    if text[start] == u'\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029' or ch == u'\'':
                    if start < end:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                        start = end
            if ch == u'\'':
                data = u'\'\''
                self.column += 2
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                start = end + 1
            if ch is not None:
                spaces = (ch == u' ')
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1
        self.write_indicator(u'\'', False)

    ESCAPE_REPLACEMENTS = {
        u'\0':      u'0',
        u'\x07':    u'a',
        u'\x08':    u'b',
        u'\x09':    u't',
        u'\x0A':    u'n',
        u'\x0B':    u'v',
        u'\x0C':    u'f',
        u'\x0D':    u'r',
        u'\x1B':    u'e',
        u'\"':      u'\"',
        u'\\':      u'\\',
        u'\x85':    u'N',
        u'\xA0':    u'_',
        u'\u2028':  u'L',
        u'\u2029':  u'P',
    }

    def write_double_quoted(self, text, split=True):
        self.write_indicator(u'"', True)
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if ch is None or ch in u'"\\\x85\u2028\u2029\uFEFF' \
                    or not (u'\x20' <= ch <= u'\x7E'
                        or (self.allow_unicode
                            and (u'\xA0' <= ch <= u'\uD7FF'
                                or u'\uE000' <= ch <= u'\uFFFD'))):
                if start < end:
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
                if ch is not None:
                    if ch in self.ESCAPE_REPLACEMENTS:
                        data = u'\\'+self.ESCAPE_REPLACEMENTS[ch]
                    elif ch <= u'\xFF':
                        data = u'\\x%02X' % ord(ch)
                    elif ch <= u'\uFFFF':
                        data = u'\\u%04X' % ord(ch)
                    else:
                        data = u'\\U%08X' % ord(ch)
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end+1
            if 0 < end < len(text)-1 and (ch == u' ' or start >= end)   \
                    and self.column+(end-start) > self.best_width and split:
                data = text[start:end]+u'\\'
                if start < end:
                    start = end
                self.column += len(data)
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                self.write_indent()
                self.whitespace = False
                self.indention = False
                if text[start] == u' ':
                    data = u'\\'
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
            end += 1
        self.write_indicator(u'"', False)

    def determine_block_hints(self, text):
        hints = u''
        if text:
            if text[0] in u' \n\x85\u2028\u2029':
                hints += unicode(self.best_indent)
            if text[-1] not in u'\n\x85\u2028\u2029':
                hints += u'-'
            elif len(text) == 1 or text[-2] in u'\n\x85\u2028\u2029':
                hints += u'+'
        return hints

    def write_folded(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator(u'>'+hints, True)
        if hints[-1:] == u'+':
            self.open_ended = True
        self.write_line_break()
        leading_space = True
        spaces = False
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    if not leading_space and ch is not None and ch != u' '  \
                            and text[start] == u'\n':
                        self.write_line_break()
                    leading_space = (ch == u' ')
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            elif spaces:
                if ch != u' ':
                    if start+1 == end and self.column > self.best_width:
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in u'\n\x85\u2028\u2029')
                spaces = (ch == u' ')
            end += 1

    def write_literal(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator(u'|'+hints, True)
        if hints[-1:] == u'+':
            self.open_ended = True
        self.write_line_break()
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            else:
                if ch is None or ch in u'\n\x85\u2028\u2029':
                    data = text[start:end]
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1

    def write_plain(self, text, split=True):
        if self.root_context:
            self.open_ended = True
        if not text:
            return
        if not self.whitespace:
            data = u' '
            self.column += len(data)
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)
        self.whitespace = False
        self.indention = False
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch != u' ':
                    if start+1 == end and self.column > self.best_width and split:
                        self.write_indent()
                        self.whitespace = False
                        self.indention = False
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch not in u'\n\x85\u2028\u2029':
                    if text[start] == u'\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    self.whitespace = False
                    self.indention = False
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
            if ch is not None:
                spaces = (ch == u' ')
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1


########NEW FILE########
__FILENAME__ = error

__all__ = ['Mark', 'YAMLError', 'MarkedYAMLError']

class Mark(object):

    def __init__(self, name, index, line, column, buffer, pointer):
        self.name = name
        self.index = index
        self.line = line
        self.column = column
        self.buffer = buffer
        self.pointer = pointer

    def get_snippet(self, indent=4, max_length=75):
        if self.buffer is None:
            return None
        head = ''
        start = self.pointer
        while start > 0 and self.buffer[start-1] not in u'\0\r\n\x85\u2028\u2029':
            start -= 1
            if self.pointer-start > max_length/2-1:
                head = ' ... '
                start += 5
                break
        tail = ''
        end = self.pointer
        while end < len(self.buffer) and self.buffer[end] not in u'\0\r\n\x85\u2028\u2029':
            end += 1
            if end-self.pointer > max_length/2-1:
                tail = ' ... '
                end -= 5
                break
        snippet = self.buffer[start:end].encode('utf-8')
        return ' '*indent + head + snippet + tail + '\n'  \
                + ' '*(indent+self.pointer-start+len(head)) + '^'

    def __str__(self):
        snippet = self.get_snippet()
        where = "  in \"%s\", line %d, column %d"   \
                % (self.name, self.line+1, self.column+1)
        if snippet is not None:
            where += ":\n"+snippet
        return where

class YAMLError(Exception):
    pass

class MarkedYAMLError(YAMLError):

    def __init__(self, context=None, context_mark=None,
            problem=None, problem_mark=None, note=None):
        self.context = context
        self.context_mark = context_mark
        self.problem = problem
        self.problem_mark = problem_mark
        self.note = note

    def __str__(self):
        lines = []
        if self.context is not None:
            lines.append(self.context)
        if self.context_mark is not None  \
            and (self.problem is None or self.problem_mark is None
                    or self.context_mark.name != self.problem_mark.name
                    or self.context_mark.line != self.problem_mark.line
                    or self.context_mark.column != self.problem_mark.column):
            lines.append(str(self.context_mark))
        if self.problem is not None:
            lines.append(self.problem)
        if self.problem_mark is not None:
            lines.append(str(self.problem_mark))
        if self.note is not None:
            lines.append(self.note)
        return '\n'.join(lines)


########NEW FILE########
__FILENAME__ = events

# Abstract classes.

class Event(object):
    def __init__(self, start_mark=None, end_mark=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in ['anchor', 'tag', 'implicit', 'value']
                if hasattr(self, key)]
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

class NodeEvent(Event):
    def __init__(self, anchor, start_mark=None, end_mark=None):
        self.anchor = anchor
        self.start_mark = start_mark
        self.end_mark = end_mark

class CollectionStartEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, start_mark=None, end_mark=None,
            flow_style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class CollectionEndEvent(Event):
    pass

# Implementations.

class StreamStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None, encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndEvent(Event):
    pass

class DocumentStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None, version=None, tags=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit
        self.version = version
        self.tags = tags

class DocumentEndEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit

class AliasEvent(NodeEvent):
    pass

class ScalarEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, value,
            start_mark=None, end_mark=None, style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class SequenceStartEvent(CollectionStartEvent):
    pass

class SequenceEndEvent(CollectionEndEvent):
    pass

class MappingStartEvent(CollectionStartEvent):
    pass

class MappingEndEvent(CollectionEndEvent):
    pass


########NEW FILE########
__FILENAME__ = loader

__all__ = ['BaseLoader', 'SafeLoader', 'Loader']

from reader import *
from scanner import *
from parser import *
from composer import *
from constructor import *
from resolver import *

class BaseLoader(Reader, Scanner, Parser, Composer, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class SafeLoader(Reader, Scanner, Parser, Composer, SafeConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class Loader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = nodes

class Node(object):
    def __init__(self, tag, value, start_mark, end_mark):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        value = self.value
        #if isinstance(value, list):
        #    if len(value) == 0:
        #        value = '<empty>'
        #    elif len(value) == 1:
        #        value = '<1 item>'
        #    else:
        #        value = '<%d items>' % len(value)
        #else:
        #    if len(value) > 75:
        #        value = repr(value[:70]+u' ... ')
        #    else:
        #        value = repr(value)
        value = repr(value)
        return '%s(tag=%r, value=%s)' % (self.__class__.__name__, self.tag, value)

class ScalarNode(Node):
    id = 'scalar'
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class CollectionNode(Node):
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, flow_style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class SequenceNode(CollectionNode):
    id = 'sequence'

class MappingNode(CollectionNode):
    id = 'mapping'


########NEW FILE########
__FILENAME__ = parser

# The following YAML grammar is LL(1) and is parsed by a recursive descent
# parser.
#
# stream            ::= STREAM-START implicit_document? explicit_document* STREAM-END
# implicit_document ::= block_node DOCUMENT-END*
# explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
# block_node_or_indentless_sequence ::=
#                       ALIAS
#                       | properties (block_content | indentless_block_sequence)?
#                       | block_content
#                       | indentless_block_sequence
# block_node        ::= ALIAS
#                       | properties block_content?
#                       | block_content
# flow_node         ::= ALIAS
#                       | properties flow_content?
#                       | flow_content
# properties        ::= TAG ANCHOR? | ANCHOR TAG?
# block_content     ::= block_collection | flow_collection | SCALAR
# flow_content      ::= flow_collection | SCALAR
# block_collection  ::= block_sequence | block_mapping
# flow_collection   ::= flow_sequence | flow_mapping
# block_sequence    ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
# indentless_sequence   ::= (BLOCK-ENTRY block_node?)+
# block_mapping     ::= BLOCK-MAPPING_START
#                       ((KEY block_node_or_indentless_sequence?)?
#                       (VALUE block_node_or_indentless_sequence?)?)*
#                       BLOCK-END
# flow_sequence     ::= FLOW-SEQUENCE-START
#                       (flow_sequence_entry FLOW-ENTRY)*
#                       flow_sequence_entry?
#                       FLOW-SEQUENCE-END
# flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
# flow_mapping      ::= FLOW-MAPPING-START
#                       (flow_mapping_entry FLOW-ENTRY)*
#                       flow_mapping_entry?
#                       FLOW-MAPPING-END
# flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?
#
# FIRST sets:
#
# stream: { STREAM-START }
# explicit_document: { DIRECTIVE DOCUMENT-START }
# implicit_document: FIRST(block_node)
# block_node: { ALIAS TAG ANCHOR SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_node: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_content: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# flow_content: { FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# block_collection: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_sequence: { BLOCK-SEQUENCE-START }
# block_mapping: { BLOCK-MAPPING-START }
# block_node_or_indentless_sequence: { ALIAS ANCHOR TAG SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START BLOCK-ENTRY }
# indentless_sequence: { ENTRY }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_sequence: { FLOW-SEQUENCE-START }
# flow_mapping: { FLOW-MAPPING-START }
# flow_sequence_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }
# flow_mapping_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }

__all__ = ['Parser', 'ParserError']

from error import MarkedYAMLError
from tokens import *
from events import *
from scanner import *

class ParserError(MarkedYAMLError):
    pass

class Parser(object):
    # Since writing a recursive-descendant parser is a straightforward task, we
    # do not give many comments here.

    DEFAULT_TAGS = {
        u'!':   u'!',
        u'!!':  u'tag:yaml.org,2002:',
    }

    def __init__(self):
        self.current_event = None
        self.yaml_version = None
        self.tag_handles = {}
        self.states = []
        self.marks = []
        self.state = self.parse_stream_start

    def check_event(self, *choices):
        # Check the type of the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        if self.current_event is not None:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.current_event, choice):
                    return True
        return False

    def peek_event(self):
        # Get the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        return self.current_event

    def get_event(self):
        # Get the next event and proceed further.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        value = self.current_event
        self.current_event = None
        return value

    # stream    ::= STREAM-START implicit_document? explicit_document* STREAM-END
    # implicit_document ::= block_node DOCUMENT-END*
    # explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*

    def parse_stream_start(self):

        # Parse the stream start.
        token = self.get_token()
        event = StreamStartEvent(token.start_mark, token.end_mark,
                encoding=token.encoding)

        # Prepare the next state.
        self.state = self.parse_implicit_document_start

        return event

    def parse_implicit_document_start(self):

        # Parse an implicit document.
        if not self.check_token(DirectiveToken, DocumentStartToken,
                StreamEndToken):
            self.tag_handles = self.DEFAULT_TAGS
            token = self.peek_token()
            start_mark = end_mark = token.start_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=False)

            # Prepare the next state.
            self.states.append(self.parse_document_end)
            self.state = self.parse_block_node

            return event

        else:
            return self.parse_document_start()

    def parse_document_start(self):

        # Parse any extra document end indicators.
        while self.check_token(DocumentEndToken):
            self.get_token()

        # Parse an explicit document.
        if not self.check_token(StreamEndToken):
            token = self.peek_token()
            start_mark = token.start_mark
            version, tags = self.process_directives()
            if not self.check_token(DocumentStartToken):
                raise ParserError(None, None,
                        "expected '<document start>', but found %r"
                        % self.peek_token().id,
                        self.peek_token().start_mark)
            token = self.get_token()
            end_mark = token.end_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=True, version=version, tags=tags)
            self.states.append(self.parse_document_end)
            self.state = self.parse_document_content
        else:
            # Parse the end of the stream.
            token = self.get_token()
            event = StreamEndEvent(token.start_mark, token.end_mark)
            assert not self.states
            assert not self.marks
            self.state = None
        return event

    def parse_document_end(self):

        # Parse the document end.
        token = self.peek_token()
        start_mark = end_mark = token.start_mark
        explicit = False
        if self.check_token(DocumentEndToken):
            token = self.get_token()
            end_mark = token.end_mark
            explicit = True
        event = DocumentEndEvent(start_mark, end_mark,
                explicit=explicit)

        # Prepare the next state.
        self.state = self.parse_document_start

        return event

    def parse_document_content(self):
        if self.check_token(DirectiveToken,
                DocumentStartToken, DocumentEndToken, StreamEndToken):
            event = self.process_empty_scalar(self.peek_token().start_mark)
            self.state = self.states.pop()
            return event
        else:
            return self.parse_block_node()

    def process_directives(self):
        self.yaml_version = None
        self.tag_handles = {}
        while self.check_token(DirectiveToken):
            token = self.get_token()
            if token.name == u'YAML':
                if self.yaml_version is not None:
                    raise ParserError(None, None,
                            "found duplicate YAML directive", token.start_mark)
                major, minor = token.value
                if major != 1:
                    raise ParserError(None, None,
                            "found incompatible YAML document (version 1.* is required)",
                            token.start_mark)
                self.yaml_version = token.value
            elif token.name == u'TAG':
                handle, prefix = token.value
                if handle in self.tag_handles:
                    raise ParserError(None, None,
                            "duplicate tag handle %r" % handle.encode('utf-8'),
                            token.start_mark)
                self.tag_handles[handle] = prefix
        if self.tag_handles:
            value = self.yaml_version, self.tag_handles.copy()
        else:
            value = self.yaml_version, None
        for key in self.DEFAULT_TAGS:
            if key not in self.tag_handles:
                self.tag_handles[key] = self.DEFAULT_TAGS[key]
        return value

    # block_node_or_indentless_sequence ::= ALIAS
    #               | properties (block_content | indentless_block_sequence)?
    #               | block_content
    #               | indentless_block_sequence
    # block_node    ::= ALIAS
    #                   | properties block_content?
    #                   | block_content
    # flow_node     ::= ALIAS
    #                   | properties flow_content?
    #                   | flow_content
    # properties    ::= TAG ANCHOR? | ANCHOR TAG?
    # block_content     ::= block_collection | flow_collection | SCALAR
    # flow_content      ::= flow_collection | SCALAR
    # block_collection  ::= block_sequence | block_mapping
    # flow_collection   ::= flow_sequence | flow_mapping

    def parse_block_node(self):
        return self.parse_node(block=True)

    def parse_flow_node(self):
        return self.parse_node()

    def parse_block_node_or_indentless_sequence(self):
        return self.parse_node(block=True, indentless_sequence=True)

    def parse_node(self, block=False, indentless_sequence=False):
        if self.check_token(AliasToken):
            token = self.get_token()
            event = AliasEvent(token.value, token.start_mark, token.end_mark)
            self.state = self.states.pop()
        else:
            anchor = None
            tag = None
            start_mark = end_mark = tag_mark = None
            if self.check_token(AnchorToken):
                token = self.get_token()
                start_mark = token.start_mark
                end_mark = token.end_mark
                anchor = token.value
                if self.check_token(TagToken):
                    token = self.get_token()
                    tag_mark = token.start_mark
                    end_mark = token.end_mark
                    tag = token.value
            elif self.check_token(TagToken):
                token = self.get_token()
                start_mark = tag_mark = token.start_mark
                end_mark = token.end_mark
                tag = token.value
                if self.check_token(AnchorToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    anchor = token.value
            if tag is not None:
                handle, suffix = tag
                if handle is not None:
                    if handle not in self.tag_handles:
                        raise ParserError("while parsing a node", start_mark,
                                "found undefined tag handle %r" % handle.encode('utf-8'),
                                tag_mark)
                    tag = self.tag_handles[handle]+suffix
                else:
                    tag = suffix
            #if tag == u'!':
            #    raise ParserError("while parsing a node", start_mark,
            #            "found non-specific tag '!'", tag_mark,
            #            "Please check 'http://pyyaml.org/wiki/YAMLNonSpecificTag' and share your opinion.")
            if start_mark is None:
                start_mark = end_mark = self.peek_token().start_mark
            event = None
            implicit = (tag is None or tag == u'!')
            if indentless_sequence and self.check_token(BlockEntryToken):
                end_mark = self.peek_token().end_mark
                event = SequenceStartEvent(anchor, tag, implicit,
                        start_mark, end_mark)
                self.state = self.parse_indentless_sequence_entry
            else:
                if self.check_token(ScalarToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    if (token.plain and tag is None) or tag == u'!':
                        implicit = (True, False)
                    elif tag is None:
                        implicit = (False, True)
                    else:
                        implicit = (False, False)
                    event = ScalarEvent(anchor, tag, implicit, token.value,
                            start_mark, end_mark, style=token.style)
                    self.state = self.states.pop()
                elif self.check_token(FlowSequenceStartToken):
                    end_mark = self.peek_token().end_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_sequence_first_entry
                elif self.check_token(FlowMappingStartToken):
                    end_mark = self.peek_token().end_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_mapping_first_key
                elif block and self.check_token(BlockSequenceStartToken):
                    end_mark = self.peek_token().start_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_sequence_first_entry
                elif block and self.check_token(BlockMappingStartToken):
                    end_mark = self.peek_token().start_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_mapping_first_key
                elif anchor is not None or tag is not None:
                    # Empty scalars are allowed even if a tag or an anchor is
                    # specified.
                    event = ScalarEvent(anchor, tag, (implicit, False), u'',
                            start_mark, end_mark)
                    self.state = self.states.pop()
                else:
                    if block:
                        node = 'block'
                    else:
                        node = 'flow'
                    token = self.peek_token()
                    raise ParserError("while parsing a %s node" % node, start_mark,
                            "expected the node content, but found %r" % token.id,
                            token.start_mark)
        return event

    # block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END

    def parse_block_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_sequence_entry()

    def parse_block_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken, BlockEndToken):
                self.states.append(self.parse_block_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_block_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block collection", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    # indentless_sequence ::= (BLOCK-ENTRY block_node?)+

    def parse_indentless_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken,
                    KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_indentless_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_indentless_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        token = self.peek_token()
        event = SequenceEndEvent(token.start_mark, token.start_mark)
        self.state = self.states.pop()
        return event

    # block_mapping     ::= BLOCK-MAPPING_START
    #                       ((KEY block_node_or_indentless_sequence?)?
    #                       (VALUE block_node_or_indentless_sequence?)?)*
    #                       BLOCK-END

    def parse_block_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_mapping_key()

    def parse_block_mapping_key(self):
        if self.check_token(KeyToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_value)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_value
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block mapping", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_block_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_key)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_block_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    # flow_sequence     ::= FLOW-SEQUENCE-START
    #                       (flow_sequence_entry FLOW-ENTRY)*
    #                       flow_sequence_entry?
    #                       FLOW-SEQUENCE-END
    # flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
    #
    # Note that while production rules for both flow_sequence_entry and
    # flow_mapping_entry are equal, their interpretations are different.
    # For `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`
    # generate an inline mapping (set syntax).

    def parse_flow_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_sequence_entry(first=True)

    def parse_flow_sequence_entry(self, first=False):
        if not self.check_token(FlowSequenceEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow sequence", self.marks[-1],
                            "expected ',' or ']', but got %r" % token.id, token.start_mark)
            
            if self.check_token(KeyToken):
                token = self.peek_token()
                event = MappingStartEvent(None, None, True,
                        token.start_mark, token.end_mark,
                        flow_style=True)
                self.state = self.parse_flow_sequence_entry_mapping_key
                return event
            elif not self.check_token(FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry)
                return self.parse_flow_node()
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_sequence_entry_mapping_key(self):
        token = self.get_token()
        if not self.check_token(ValueToken,
                FlowEntryToken, FlowSequenceEndToken):
            self.states.append(self.parse_flow_sequence_entry_mapping_value)
            return self.parse_flow_node()
        else:
            self.state = self.parse_flow_sequence_entry_mapping_value
            return self.process_empty_scalar(token.end_mark)

    def parse_flow_sequence_entry_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry_mapping_end)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_sequence_entry_mapping_end
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_sequence_entry_mapping_end
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_sequence_entry_mapping_end(self):
        self.state = self.parse_flow_sequence_entry
        token = self.peek_token()
        return MappingEndEvent(token.start_mark, token.start_mark)

    # flow_mapping  ::= FLOW-MAPPING-START
    #                   (flow_mapping_entry FLOW-ENTRY)*
    #                   flow_mapping_entry?
    #                   FLOW-MAPPING-END
    # flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?

    def parse_flow_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_mapping_key(first=True)

    def parse_flow_mapping_key(self, first=False):
        if not self.check_token(FlowMappingEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow mapping", self.marks[-1],
                            "expected ',' or '}', but got %r" % token.id, token.start_mark)
            if self.check_token(KeyToken):
                token = self.get_token()
                if not self.check_token(ValueToken,
                        FlowEntryToken, FlowMappingEndToken):
                    self.states.append(self.parse_flow_mapping_value)
                    return self.parse_flow_node()
                else:
                    self.state = self.parse_flow_mapping_value
                    return self.process_empty_scalar(token.end_mark)
            elif not self.check_token(FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_empty_value)
                return self.parse_flow_node()
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_key)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_mapping_empty_value(self):
        self.state = self.parse_flow_mapping_key
        return self.process_empty_scalar(self.peek_token().start_mark)

    def process_empty_scalar(self, mark):
        return ScalarEvent(None, None, (True, False), u'', mark, mark)


########NEW FILE########
__FILENAME__ = reader
# This module contains abstractions for the input stream. You don't have to
# looks further, there are no pretty code.
#
# We define two classes here.
#
#   Mark(source, line, column)
# It's just a record and its only use is producing nice error messages.
# Parser does not use it for any other purposes.
#
#   Reader(source, data)
# Reader determines the encoding of `data` and converts it to unicode.
# Reader provides the following methods and attributes:
#   reader.peek(length=1) - return the next `length` characters
#   reader.forward(length=1) - move the current position to `length` characters.
#   reader.index - the number of the current character.
#   reader.line, stream.column - the line and the column of the current character.

__all__ = ['Reader', 'ReaderError']

from error import YAMLError, Mark

import codecs, re

# Unfortunately, codec functions in Python 2.3 does not support the `finish`
# arguments, so we have to write our own wrappers.

try:
    codecs.utf_8_decode('', 'strict', False)
    from codecs import utf_8_decode, utf_16_le_decode, utf_16_be_decode

except TypeError:

    def utf_16_le_decode(data, errors, finish=False):
        if not finish and len(data) % 2 == 1:
            data = data[:-1]
        return codecs.utf_16_le_decode(data, errors)

    def utf_16_be_decode(data, errors, finish=False):
        if not finish and len(data) % 2 == 1:
            data = data[:-1]
        return codecs.utf_16_be_decode(data, errors)

    def utf_8_decode(data, errors, finish=False):
        if not finish:
            # We are trying to remove a possible incomplete multibyte character
            # from the suffix of the data.
            # The first byte of a multi-byte sequence is in the range 0xc0 to 0xfd.
            # All further bytes are in the range 0x80 to 0xbf.
            # UTF-8 encoded UCS characters may be up to six bytes long.
            count = 0
            while count < 5 and count < len(data)   \
                    and '\x80' <= data[-count-1] <= '\xBF':
                count -= 1
            if count < 5 and count < len(data)  \
                    and '\xC0' <= data[-count-1] <= '\xFD':
                data = data[:-count-1]
        return codecs.utf_8_decode(data, errors)

class ReaderError(YAMLError):

    def __init__(self, name, position, character, encoding, reason):
        self.name = name
        self.character = character
        self.position = position
        self.encoding = encoding
        self.reason = reason

    def __str__(self):
        if isinstance(self.character, str):
            return "'%s' codec can't decode byte #x%02x: %s\n"  \
                    "  in \"%s\", position %d"    \
                    % (self.encoding, ord(self.character), self.reason,
                            self.name, self.position)
        else:
            return "unacceptable character #x%04x: %s\n"    \
                    "  in \"%s\", position %d"    \
                    % (self.character, self.reason,
                            self.name, self.position)

class Reader(object):
    # Reader:
    # - determines the data encoding and converts it to unicode,
    # - checks if characters are in allowed range,
    # - adds '\0' to the end.

    # Reader accepts
    #  - a `str` object,
    #  - a `unicode` object,
    #  - a file-like object with its `read` method returning `str`,
    #  - a file-like object with its `read` method returning `unicode`.

    # Yeah, it's ugly and slow.

    def __init__(self, stream):
        self.name = None
        self.stream = None
        self.stream_pointer = 0
        self.eof = True
        self.buffer = u''
        self.pointer = 0
        self.raw_buffer = None
        self.raw_decode = None
        self.encoding = None
        self.index = 0
        self.line = 0
        self.column = 0
        if isinstance(stream, unicode):
            self.name = "<unicode string>"
            self.check_printable(stream)
            self.buffer = stream+u'\0'
        elif isinstance(stream, str):
            self.name = "<string>"
            self.raw_buffer = stream
            self.determine_encoding()
        else:
            self.stream = stream
            self.name = getattr(stream, 'name', "<file>")
            self.eof = False
            self.raw_buffer = ''
            self.determine_encoding()

    def peek(self, index=0):
        try:
            return self.buffer[self.pointer+index]
        except IndexError:
            self.update(index+1)
            return self.buffer[self.pointer+index]

    def prefix(self, length=1):
        if self.pointer+length >= len(self.buffer):
            self.update(length)
        return self.buffer[self.pointer:self.pointer+length]

    def forward(self, length=1):
        if self.pointer+length+1 >= len(self.buffer):
            self.update(length+1)
        while length:
            ch = self.buffer[self.pointer]
            self.pointer += 1
            self.index += 1
            if ch in u'\n\x85\u2028\u2029'  \
                    or (ch == u'\r' and self.buffer[self.pointer] != u'\n'):
                self.line += 1
                self.column = 0
            elif ch != u'\uFEFF':
                self.column += 1
            length -= 1

    def get_mark(self):
        if self.stream is None:
            return Mark(self.name, self.index, self.line, self.column,
                    self.buffer, self.pointer)
        else:
            return Mark(self.name, self.index, self.line, self.column,
                    None, None)

    def determine_encoding(self):
        while not self.eof and len(self.raw_buffer) < 2:
            self.update_raw()
        if not isinstance(self.raw_buffer, unicode):
            if self.raw_buffer.startswith(codecs.BOM_UTF16_LE):
                self.raw_decode = utf_16_le_decode
                self.encoding = 'utf-16-le'
            elif self.raw_buffer.startswith(codecs.BOM_UTF16_BE):
                self.raw_decode = utf_16_be_decode
                self.encoding = 'utf-16-be'
            else:
                self.raw_decode = utf_8_decode
                self.encoding = 'utf-8'
        self.update(1)

    NON_PRINTABLE = re.compile(u'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]')
    def check_printable(self, data):
        match = self.NON_PRINTABLE.search(data)
        if match:
            character = match.group()
            position = self.index+(len(self.buffer)-self.pointer)+match.start()
            raise ReaderError(self.name, position, ord(character),
                    'unicode', "special characters are not allowed")

    def update(self, length):
        if self.raw_buffer is None:
            return
        self.buffer = self.buffer[self.pointer:]
        self.pointer = 0
        while len(self.buffer) < length:
            if not self.eof:
                self.update_raw()
            if self.raw_decode is not None:
                try:
                    data, converted = self.raw_decode(self.raw_buffer,
                            'strict', self.eof)
                except UnicodeDecodeError, exc:
                    character = exc.object[exc.start]
                    if self.stream is not None:
                        position = self.stream_pointer-len(self.raw_buffer)+exc.start
                    else:
                        position = exc.start
                    raise ReaderError(self.name, position, character,
                            exc.encoding, exc.reason)
            else:
                data = self.raw_buffer
                converted = len(data)
            self.check_printable(data)
            self.buffer += data
            self.raw_buffer = self.raw_buffer[converted:]
            if self.eof:
                self.buffer += u'\0'
                self.raw_buffer = None
                break

    def update_raw(self, size=1024):
        data = self.stream.read(size)
        if data:
            self.raw_buffer += data
            self.stream_pointer += len(data)
        else:
            self.eof = True

#try:
#    import psyco
#    psyco.bind(Reader)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = representer

__all__ = ['BaseRepresenter', 'SafeRepresenter', 'Representer',
    'RepresenterError']

from error import *
from nodes import *

import datetime

try:
    set
except NameError:
    from sets import Set as set

import sys, copy_reg, types

class RepresenterError(YAMLError):
    pass

class BaseRepresenter(object):

    yaml_representers = {}
    yaml_multi_representers = {}

    def __init__(self, default_style=None, default_flow_style=None):
        self.default_style = default_style
        self.default_flow_style = default_flow_style
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent(self, data):
        node = self.represent_data(data)
        self.serialize(node)
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def get_classobj_bases(self, cls):
        bases = [cls]
        for base in cls.__bases__:
            bases.extend(self.get_classobj_bases(base))
        return bases

    def represent_data(self, data):
        if self.ignore_aliases(data):
            self.alias_key = None
        else:
            self.alias_key = id(data)
        if self.alias_key is not None:
            if self.alias_key in self.represented_objects:
                node = self.represented_objects[self.alias_key]
                #if node is None:
                #    raise RepresenterError("recursive objects are not allowed: %r" % data)
                return node
            #self.represented_objects[alias_key] = None
            self.object_keeper.append(data)
        data_types = type(data).__mro__
        if type(data) is types.InstanceType:
            data_types = self.get_classobj_bases(data.__class__)+list(data_types)
        if data_types[0] in self.yaml_representers:
            node = self.yaml_representers[data_types[0]](self, data)
        else:
            for data_type in data_types:
                if data_type in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[data_type](self, data)
                    break
            else:
                if None in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[None](self, data)
                elif None in self.yaml_representers:
                    node = self.yaml_representers[None](self, data)
                else:
                    node = ScalarNode(None, unicode(data))
        #if alias_key is not None:
        #    self.represented_objects[alias_key] = node
        return node

    def add_representer(cls, data_type, representer):
        if not 'yaml_representers' in cls.__dict__:
            cls.yaml_representers = cls.yaml_representers.copy()
        cls.yaml_representers[data_type] = representer
    add_representer = classmethod(add_representer)

    def add_multi_representer(cls, data_type, representer):
        if not 'yaml_multi_representers' in cls.__dict__:
            cls.yaml_multi_representers = cls.yaml_multi_representers.copy()
        cls.yaml_multi_representers[data_type] = representer
    add_multi_representer = classmethod(add_multi_representer)

    def represent_scalar(self, tag, value, style=None):
        if style is None:
            style = self.default_style
        node = ScalarNode(tag, value, style=style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        return node

    def represent_sequence(self, tag, sequence, flow_style=None):
        value = []
        node = SequenceNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        for item in sequence:
            node_item = self.represent_data(item)
            if not (isinstance(node_item, ScalarNode) and not node_item.style):
                best_style = False
            value.append(node_item)
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def represent_mapping(self, tag, mapping, flow_style=None):
        value = []
        node = MappingNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        if hasattr(mapping, 'items'):
            mapping = mapping.items()
            mapping.sort()
        for item_key, item_value in mapping:
            node_key = self.represent_data(item_key)
            node_value = self.represent_data(item_value)
            if not (isinstance(node_key, ScalarNode) and not node_key.style):
                best_style = False
            if not (isinstance(node_value, ScalarNode) and not node_value.style):
                best_style = False
            value.append((node_key, node_value))
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def ignore_aliases(self, data):
        return False

class SafeRepresenter(BaseRepresenter):

    def ignore_aliases(self, data):
        if data in [None, ()]:
            return True
        if isinstance(data, (str, unicode, bool, int, float)):
            return True

    def represent_none(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:null',
                u'null')

    def represent_str(self, data):
        tag = None
        style = None
        try:
            data = unicode(data, 'ascii')
            tag = u'tag:yaml.org,2002:str'
        except UnicodeDecodeError:
            try:
                data = unicode(data, 'utf-8')
                tag = u'tag:yaml.org,2002:str'
            except UnicodeDecodeError:
                data = data.encode('base64')
                tag = u'tag:yaml.org,2002:binary'
                style = '|'
        return self.represent_scalar(tag, data, style=style)

    def represent_unicode(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:str', data)

    def represent_bool(self, data):
        if data:
            value = u'true'
        else:
            value = u'false'
        return self.represent_scalar(u'tag:yaml.org,2002:bool', value)

    def represent_int(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:int', unicode(data))

    def represent_long(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:int', unicode(data))

    inf_value = 1e300
    while repr(inf_value) != repr(inf_value*inf_value):
        inf_value *= inf_value

    def represent_float(self, data):
        if data != data or (data == 0.0 and data == 1.0):
            value = u'.nan'
        elif data == self.inf_value:
            value = u'.inf'
        elif data == -self.inf_value:
            value = u'-.inf'
        else:
            value = unicode(repr(data)).lower()
            # Note that in some cases `repr(data)` represents a float number
            # without the decimal parts.  For instance:
            #   >>> repr(1e17)
            #   '1e17'
            # Unfortunately, this is not a valid float representation according
            # to the definition of the `!!float` tag.  We fix this by adding
            # '.0' before the 'e' symbol.
            if u'.' not in value and u'e' in value:
                value = value.replace(u'e', u'.0e', 1)
        return self.represent_scalar(u'tag:yaml.org,2002:float', value)

    def represent_list(self, data):
        #pairs = (len(data) > 0 and isinstance(data, list))
        #if pairs:
        #    for item in data:
        #        if not isinstance(item, tuple) or len(item) != 2:
        #            pairs = False
        #            break
        #if not pairs:
            return self.represent_sequence(u'tag:yaml.org,2002:seq', data)
        #value = []
        #for item_key, item_value in data:
        #    value.append(self.represent_mapping(u'tag:yaml.org,2002:map',
        #        [(item_key, item_value)]))
        #return SequenceNode(u'tag:yaml.org,2002:pairs', value)

    def represent_dict(self, data):
        return self.represent_mapping(u'tag:yaml.org,2002:map', data)

    def represent_set(self, data):
        value = {}
        for key in data:
            value[key] = None
        return self.represent_mapping(u'tag:yaml.org,2002:set', value)

    def represent_date(self, data):
        value = unicode(data.isoformat())
        return self.represent_scalar(u'tag:yaml.org,2002:timestamp', value)

    def represent_datetime(self, data):
        value = unicode(data.isoformat(' '))
        return self.represent_scalar(u'tag:yaml.org,2002:timestamp', value)

    def represent_yaml_object(self, tag, data, cls, flow_style=None):
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__.copy()
        return self.represent_mapping(tag, state, flow_style=flow_style)

    def represent_undefined(self, data):
        raise RepresenterError("cannot represent an object: %s" % data)

SafeRepresenter.add_representer(type(None),
        SafeRepresenter.represent_none)

SafeRepresenter.add_representer(str,
        SafeRepresenter.represent_str)

SafeRepresenter.add_representer(unicode,
        SafeRepresenter.represent_unicode)

SafeRepresenter.add_representer(bool,
        SafeRepresenter.represent_bool)

SafeRepresenter.add_representer(int,
        SafeRepresenter.represent_int)

SafeRepresenter.add_representer(long,
        SafeRepresenter.represent_long)

SafeRepresenter.add_representer(float,
        SafeRepresenter.represent_float)

SafeRepresenter.add_representer(list,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(tuple,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(dict,
        SafeRepresenter.represent_dict)

SafeRepresenter.add_representer(set,
        SafeRepresenter.represent_set)

SafeRepresenter.add_representer(datetime.date,
        SafeRepresenter.represent_date)

SafeRepresenter.add_representer(datetime.datetime,
        SafeRepresenter.represent_datetime)

SafeRepresenter.add_representer(None,
        SafeRepresenter.represent_undefined)

class Representer(SafeRepresenter):

    def represent_str(self, data):
        tag = None
        style = None
        try:
            data = unicode(data, 'ascii')
            tag = u'tag:yaml.org,2002:str'
        except UnicodeDecodeError:
            try:
                data = unicode(data, 'utf-8')
                tag = u'tag:yaml.org,2002:python/str'
            except UnicodeDecodeError:
                data = data.encode('base64')
                tag = u'tag:yaml.org,2002:binary'
                style = '|'
        return self.represent_scalar(tag, data, style=style)

    def represent_unicode(self, data):
        tag = None
        try:
            data.encode('ascii')
            tag = u'tag:yaml.org,2002:python/unicode'
        except UnicodeEncodeError:
            tag = u'tag:yaml.org,2002:str'
        return self.represent_scalar(tag, data)

    def represent_long(self, data):
        tag = u'tag:yaml.org,2002:int'
        if int(data) is not data:
            tag = u'tag:yaml.org,2002:python/long'
        return self.represent_scalar(tag, unicode(data))

    def represent_complex(self, data):
        if data.imag == 0.0:
            data = u'%r' % data.real
        elif data.real == 0.0:
            data = u'%rj' % data.imag
        elif data.imag > 0:
            data = u'%r+%rj' % (data.real, data.imag)
        else:
            data = u'%r%rj' % (data.real, data.imag)
        return self.represent_scalar(u'tag:yaml.org,2002:python/complex', data)

    def represent_tuple(self, data):
        return self.represent_sequence(u'tag:yaml.org,2002:python/tuple', data)

    def represent_name(self, data):
        name = u'%s.%s' % (data.__module__, data.__name__)
        return self.represent_scalar(u'tag:yaml.org,2002:python/name:'+name, u'')

    def represent_module(self, data):
        return self.represent_scalar(
                u'tag:yaml.org,2002:python/module:'+data.__name__, u'')

    def represent_instance(self, data):
        # For instances of classic classes, we use __getinitargs__ and
        # __getstate__ to serialize the data.

        # If data.__getinitargs__ exists, the object must be reconstructed by
        # calling cls(**args), where args is a tuple returned by
        # __getinitargs__. Otherwise, the cls.__init__ method should never be
        # called and the class instance is created by instantiating a trivial
        # class and assigning to the instance's __class__ variable.

        # If data.__getstate__ exists, it returns the state of the object.
        # Otherwise, the state of the object is data.__dict__.

        # We produce either a !!python/object or !!python/object/new node.
        # If data.__getinitargs__ does not exist and state is a dictionary, we
        # produce a !!python/object node . Otherwise we produce a
        # !!python/object/new node.

        cls = data.__class__
        class_name = u'%s.%s' % (cls.__module__, cls.__name__)
        args = None
        state = None
        if hasattr(data, '__getinitargs__'):
            args = list(data.__getinitargs__())
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__
        if args is None and isinstance(state, dict):
            return self.represent_mapping(
                    u'tag:yaml.org,2002:python/object:'+class_name, state)
        if isinstance(state, dict) and not state:
            return self.represent_sequence(
                    u'tag:yaml.org,2002:python/object/new:'+class_name, args)
        value = {}
        if args:
            value['args'] = args
        value['state'] = state
        return self.represent_mapping(
                u'tag:yaml.org,2002:python/object/new:'+class_name, value)

    def represent_object(self, data):
        # We use __reduce__ API to save the data. data.__reduce__ returns
        # a tuple of length 2-5:
        #   (function, args, state, listitems, dictitems)

        # For reconstructing, we calls function(*args), then set its state,
        # listitems, and dictitems if they are not None.

        # A special case is when function.__name__ == '__newobj__'. In this
        # case we create the object with args[0].__new__(*args).

        # Another special case is when __reduce__ returns a string - we don't
        # support it.

        # We produce a !!python/object, !!python/object/new or
        # !!python/object/apply node.

        cls = type(data)
        if cls in copy_reg.dispatch_table:
            reduce = copy_reg.dispatch_table[cls](data)
        elif hasattr(data, '__reduce_ex__'):
            reduce = data.__reduce_ex__(2)
        elif hasattr(data, '__reduce__'):
            reduce = data.__reduce__()
        else:
            raise RepresenterError("cannot represent object: %r" % data)
        reduce = (list(reduce)+[None]*5)[:5]
        function, args, state, listitems, dictitems = reduce
        args = list(args)
        if state is None:
            state = {}
        if listitems is not None:
            listitems = list(listitems)
        if dictitems is not None:
            dictitems = dict(dictitems)
        if function.__name__ == '__newobj__':
            function = args[0]
            args = args[1:]
            tag = u'tag:yaml.org,2002:python/object/new:'
            newobj = True
        else:
            tag = u'tag:yaml.org,2002:python/object/apply:'
            newobj = False
        function_name = u'%s.%s' % (function.__module__, function.__name__)
        if not args and not listitems and not dictitems \
                and isinstance(state, dict) and newobj:
            return self.represent_mapping(
                    u'tag:yaml.org,2002:python/object:'+function_name, state)
        if not listitems and not dictitems  \
                and isinstance(state, dict) and not state:
            return self.represent_sequence(tag+function_name, args)
        value = {}
        if args:
            value['args'] = args
        if state or not isinstance(state, dict):
            value['state'] = state
        if listitems:
            value['listitems'] = listitems
        if dictitems:
            value['dictitems'] = dictitems
        return self.represent_mapping(tag+function_name, value)

Representer.add_representer(str,
        Representer.represent_str)

Representer.add_representer(unicode,
        Representer.represent_unicode)

Representer.add_representer(long,
        Representer.represent_long)

Representer.add_representer(complex,
        Representer.represent_complex)

Representer.add_representer(tuple,
        Representer.represent_tuple)

Representer.add_representer(type,
        Representer.represent_name)

Representer.add_representer(types.ClassType,
        Representer.represent_name)

Representer.add_representer(types.FunctionType,
        Representer.represent_name)

Representer.add_representer(types.BuiltinFunctionType,
        Representer.represent_name)

Representer.add_representer(types.ModuleType,
        Representer.represent_module)

Representer.add_multi_representer(types.InstanceType,
        Representer.represent_instance)

Representer.add_multi_representer(object,
        Representer.represent_object)


########NEW FILE########
__FILENAME__ = resolver

__all__ = ['BaseResolver', 'Resolver']

from error import *
from nodes import *

import re

class ResolverError(YAMLError):
    pass

class BaseResolver(object):

    DEFAULT_SCALAR_TAG = u'tag:yaml.org,2002:str'
    DEFAULT_SEQUENCE_TAG = u'tag:yaml.org,2002:seq'
    DEFAULT_MAPPING_TAG = u'tag:yaml.org,2002:map'

    yaml_implicit_resolvers = {}
    yaml_path_resolvers = {}

    def __init__(self):
        self.resolver_exact_paths = []
        self.resolver_prefix_paths = []

    def add_implicit_resolver(cls, tag, regexp, first):
        if not 'yaml_implicit_resolvers' in cls.__dict__:
            cls.yaml_implicit_resolvers = cls.yaml_implicit_resolvers.copy()
        if first is None:
            first = [None]
        for ch in first:
            cls.yaml_implicit_resolvers.setdefault(ch, []).append((tag, regexp))
    add_implicit_resolver = classmethod(add_implicit_resolver)

    def add_path_resolver(cls, tag, path, kind=None):
        # Note: `add_path_resolver` is experimental.  The API could be changed.
        # `new_path` is a pattern that is matched against the path from the
        # root to the node that is being considered.  `node_path` elements are
        # tuples `(node_check, index_check)`.  `node_check` is a node class:
        # `ScalarNode`, `SequenceNode`, `MappingNode` or `None`.  `None`
        # matches any kind of a node.  `index_check` could be `None`, a boolean
        # value, a string value, or a number.  `None` and `False` match against
        # any _value_ of sequence and mapping nodes.  `True` matches against
        # any _key_ of a mapping node.  A string `index_check` matches against
        # a mapping value that corresponds to a scalar key which content is
        # equal to the `index_check` value.  An integer `index_check` matches
        # against a sequence value with the index equal to `index_check`.
        if not 'yaml_path_resolvers' in cls.__dict__:
            cls.yaml_path_resolvers = cls.yaml_path_resolvers.copy()
        new_path = []
        for element in path:
            if isinstance(element, (list, tuple)):
                if len(element) == 2:
                    node_check, index_check = element
                elif len(element) == 1:
                    node_check = element[0]
                    index_check = True
                else:
                    raise ResolverError("Invalid path element: %s" % element)
            else:
                node_check = None
                index_check = element
            if node_check is str:
                node_check = ScalarNode
            elif node_check is list:
                node_check = SequenceNode
            elif node_check is dict:
                node_check = MappingNode
            elif node_check not in [ScalarNode, SequenceNode, MappingNode]  \
                    and not isinstance(node_check, basestring)  \
                    and node_check is not None:
                raise ResolverError("Invalid node checker: %s" % node_check)
            if not isinstance(index_check, (basestring, int))   \
                    and index_check is not None:
                raise ResolverError("Invalid index checker: %s" % index_check)
            new_path.append((node_check, index_check))
        if kind is str:
            kind = ScalarNode
        elif kind is list:
            kind = SequenceNode
        elif kind is dict:
            kind = MappingNode
        elif kind not in [ScalarNode, SequenceNode, MappingNode]    \
                and kind is not None:
            raise ResolverError("Invalid node kind: %s" % kind)
        cls.yaml_path_resolvers[tuple(new_path), kind] = tag
    add_path_resolver = classmethod(add_path_resolver)

    def descend_resolver(self, current_node, current_index):
        if not self.yaml_path_resolvers:
            return
        exact_paths = {}
        prefix_paths = []
        if current_node:
            depth = len(self.resolver_prefix_paths)
            for path, kind in self.resolver_prefix_paths[-1]:
                if self.check_resolver_prefix(depth, path, kind,
                        current_node, current_index):
                    if len(path) > depth:
                        prefix_paths.append((path, kind))
                    else:
                        exact_paths[kind] = self.yaml_path_resolvers[path, kind]
        else:
            for path, kind in self.yaml_path_resolvers:
                if not path:
                    exact_paths[kind] = self.yaml_path_resolvers[path, kind]
                else:
                    prefix_paths.append((path, kind))
        self.resolver_exact_paths.append(exact_paths)
        self.resolver_prefix_paths.append(prefix_paths)

    def ascend_resolver(self):
        if not self.yaml_path_resolvers:
            return
        self.resolver_exact_paths.pop()
        self.resolver_prefix_paths.pop()

    def check_resolver_prefix(self, depth, path, kind,
            current_node, current_index):
        node_check, index_check = path[depth-1]
        if isinstance(node_check, basestring):
            if current_node.tag != node_check:
                return
        elif node_check is not None:
            if not isinstance(current_node, node_check):
                return
        if index_check is True and current_index is not None:
            return
        if (index_check is False or index_check is None)    \
                and current_index is None:
            return
        if isinstance(index_check, basestring):
            if not (isinstance(current_index, ScalarNode)
                    and index_check == current_index.value):
                return
        elif isinstance(index_check, int) and not isinstance(index_check, bool):
            if index_check != current_index:
                return
        return True

    def resolve(self, kind, value, implicit):
        if kind is ScalarNode and implicit[0]:
            if value == u'':
                resolvers = self.yaml_implicit_resolvers.get(u'', [])
            else:
                resolvers = self.yaml_implicit_resolvers.get(value[0], [])
            resolvers += self.yaml_implicit_resolvers.get(None, [])
            for tag, regexp in resolvers:
                if regexp.match(value):
                    return tag
            implicit = implicit[1]
        if self.yaml_path_resolvers:
            exact_paths = self.resolver_exact_paths[-1]
            if kind in exact_paths:
                return exact_paths[kind]
            if None in exact_paths:
                return exact_paths[None]
        if kind is ScalarNode:
            return self.DEFAULT_SCALAR_TAG
        elif kind is SequenceNode:
            return self.DEFAULT_SEQUENCE_TAG
        elif kind is MappingNode:
            return self.DEFAULT_MAPPING_TAG

class Resolver(BaseResolver):
    pass

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:bool',
        re.compile(ur'''^(?:yes|Yes|YES|no|No|NO
                    |true|True|TRUE|false|False|FALSE
                    |on|On|ON|off|Off|OFF)$''', re.X),
        list(u'yYnNtTfFoO'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:float',
        re.compile(ur'''^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?
                    |\.[0-9_]+(?:[eE][-+][0-9]+)?
                    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*
                    |[-+]?\.(?:inf|Inf|INF)
                    |\.(?:nan|NaN|NAN))$''', re.X),
        list(u'-+0123456789.'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:int',
        re.compile(ur'''^(?:[-+]?0b[0-1_]+
                    |[-+]?0[0-7_]+
                    |[-+]?(?:0|[1-9][0-9_]*)
                    |[-+]?0x[0-9a-fA-F_]+
                    |[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$''', re.X),
        list(u'-+0123456789'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:merge',
        re.compile(ur'^(?:<<)$'),
        [u'<'])

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:null',
        re.compile(ur'''^(?: ~
                    |null|Null|NULL
                    | )$''', re.X),
        [u'~', u'n', u'N', u''])

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:timestamp',
        re.compile(ur'''^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]
                    |[0-9][0-9][0-9][0-9] -[0-9][0-9]? -[0-9][0-9]?
                     (?:[Tt]|[ \t]+)[0-9][0-9]?
                     :[0-9][0-9] :[0-9][0-9] (?:\.[0-9]*)?
                     (?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$''', re.X),
        list(u'0123456789'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:value',
        re.compile(ur'^(?:=)$'),
        [u'='])

# The following resolver is only for documentation purposes. It cannot work
# because plain scalars cannot start with '!', '&', or '*'.
Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:yaml',
        re.compile(ur'^(?:!|&|\*)$'),
        list(u'!&*'))


########NEW FILE########
__FILENAME__ = scanner

# Scanner produces tokens of the following types:
# STREAM-START
# STREAM-END
# DIRECTIVE(name, value)
# DOCUMENT-START
# DOCUMENT-END
# BLOCK-SEQUENCE-START
# BLOCK-MAPPING-START
# BLOCK-END
# FLOW-SEQUENCE-START
# FLOW-MAPPING-START
# FLOW-SEQUENCE-END
# FLOW-MAPPING-END
# BLOCK-ENTRY
# FLOW-ENTRY
# KEY
# VALUE
# ALIAS(value)
# ANCHOR(value)
# TAG(value)
# SCALAR(value, plain, style)
#
# Read comments in the Scanner code for more details.
#

__all__ = ['Scanner', 'ScannerError']

from error import MarkedYAMLError
from tokens import *

class ScannerError(MarkedYAMLError):
    pass

class SimpleKey(object):
    # See below simple keys treatment.

    def __init__(self, token_number, required, index, line, column, mark):
        self.token_number = token_number
        self.required = required
        self.index = index
        self.line = line
        self.column = column
        self.mark = mark

class Scanner(object):

    def __init__(self):
        """Initialize the scanner."""
        # It is assumed that Scanner and Reader will have a common descendant.
        # Reader do the dirty work of checking for BOM and converting the
        # input data to Unicode. It also adds NUL to the end.
        #
        # Reader supports the following methods
        #   self.peek(i=0)       # peek the next i-th character
        #   self.prefix(l=1)     # peek the next l characters
        #   self.forward(l=1)    # read the next l characters and move the pointer.

        # Had we reached the end of the stream?
        self.done = False

        # The number of unclosed '{' and '['. `flow_level == 0` means block
        # context.
        self.flow_level = 0

        # List of processed tokens that are not yet emitted.
        self.tokens = []

        # Add the STREAM-START token.
        self.fetch_stream_start()

        # Number of tokens that were emitted through the `get_token` method.
        self.tokens_taken = 0

        # The current indentation level.
        self.indent = -1

        # Past indentation levels.
        self.indents = []

        # Variables related to simple keys treatment.

        # A simple key is a key that is not denoted by the '?' indicator.
        # Example of simple keys:
        #   ---
        #   block simple key: value
        #   ? not a simple key:
        #   : { flow simple key: value }
        # We emit the KEY token before all keys, so when we find a potential
        # simple key, we try to locate the corresponding ':' indicator.
        # Simple keys should be limited to a single line and 1024 characters.

        # Can a simple key start at the current position? A simple key may
        # start:
        # - at the beginning of the line, not counting indentation spaces
        #       (in block context),
        # - after '{', '[', ',' (in the flow context),
        # - after '?', ':', '-' (in the block context).
        # In the block context, this flag also signifies if a block collection
        # may start at the current position.
        self.allow_simple_key = True

        # Keep track of possible simple keys. This is a dictionary. The key
        # is `flow_level`; there can be no more that one possible simple key
        # for each level. The value is a SimpleKey record:
        #   (token_number, required, index, line, column, mark)
        # A simple key may start with ALIAS, ANCHOR, TAG, SCALAR(flow),
        # '[', or '{' tokens.
        self.possible_simple_keys = {}

    # Public methods.

    def check_token(self, *choices):
        # Check if the next token is one of the given types.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.tokens[0], choice):
                    return True
        return False

    def peek_token(self):
        # Return the next token, but do not delete if from the queue.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            return self.tokens[0]

    def get_token(self):
        # Return the next token.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            self.tokens_taken += 1
            return self.tokens.pop(0)

    # Private methods.

    def need_more_tokens(self):
        if self.done:
            return False
        if not self.tokens:
            return True
        # The current token may be a potential simple key, so we
        # need to look further.
        self.stale_possible_simple_keys()
        if self.next_possible_simple_key() == self.tokens_taken:
            return True

    def fetch_more_tokens(self):

        # Eat whitespaces and comments until we reach the next token.
        self.scan_to_next_token()

        # Remove obsolete possible simple keys.
        self.stale_possible_simple_keys()

        # Compare the current indentation and column. It may add some tokens
        # and decrease the current indentation level.
        self.unwind_indent(self.column)

        # Peek the next character.
        ch = self.peek()

        # Is it the end of stream?
        if ch == u'\0':
            return self.fetch_stream_end()

        # Is it a directive?
        if ch == u'%' and self.check_directive():
            return self.fetch_directive()

        # Is it the document start?
        if ch == u'-' and self.check_document_start():
            return self.fetch_document_start()

        # Is it the document end?
        if ch == u'.' and self.check_document_end():
            return self.fetch_document_end()

        # TODO: support for BOM within a stream.
        #if ch == u'\uFEFF':
        #    return self.fetch_bom()    <-- issue BOMToken

        # Note: the order of the following checks is NOT significant.

        # Is it the flow sequence start indicator?
        if ch == u'[':
            return self.fetch_flow_sequence_start()

        # Is it the flow mapping start indicator?
        if ch == u'{':
            return self.fetch_flow_mapping_start()

        # Is it the flow sequence end indicator?
        if ch == u']':
            return self.fetch_flow_sequence_end()

        # Is it the flow mapping end indicator?
        if ch == u'}':
            return self.fetch_flow_mapping_end()

        # Is it the flow entry indicator?
        if ch == u',':
            return self.fetch_flow_entry()

        # Is it the block entry indicator?
        if ch == u'-' and self.check_block_entry():
            return self.fetch_block_entry()

        # Is it the key indicator?
        if ch == u'?' and self.check_key():
            return self.fetch_key()

        # Is it the value indicator?
        if ch == u':' and self.check_value():
            return self.fetch_value()

        # Is it an alias?
        if ch == u'*':
            return self.fetch_alias()

        # Is it an anchor?
        if ch == u'&':
            return self.fetch_anchor()

        # Is it a tag?
        if ch == u'!':
            return self.fetch_tag()

        # Is it a literal scalar?
        if ch == u'|' and not self.flow_level:
            return self.fetch_literal()

        # Is it a folded scalar?
        if ch == u'>' and not self.flow_level:
            return self.fetch_folded()

        # Is it a single quoted scalar?
        if ch == u'\'':
            return self.fetch_single()

        # Is it a double quoted scalar?
        if ch == u'\"':
            return self.fetch_double()

        # It must be a plain scalar then.
        if self.check_plain():
            return self.fetch_plain()

        # No? It's an error. Let's produce a nice error message.
        raise ScannerError("while scanning for the next token", None,
                "found character %r that cannot start any token"
                % ch.encode('utf-8'), self.get_mark())

    # Simple keys treatment.

    def next_possible_simple_key(self):
        # Return the number of the nearest possible simple key. Actually we
        # don't need to loop through the whole dictionary. We may replace it
        # with the following code:
        #   if not self.possible_simple_keys:
        #       return None
        #   return self.possible_simple_keys[
        #           min(self.possible_simple_keys.keys())].token_number
        min_token_number = None
        for level in self.possible_simple_keys:
            key = self.possible_simple_keys[level]
            if min_token_number is None or key.token_number < min_token_number:
                min_token_number = key.token_number
        return min_token_number

    def stale_possible_simple_keys(self):
        # Remove entries that are no longer possible simple keys. According to
        # the YAML specification, simple keys
        # - should be limited to a single line,
        # - should be no longer than 1024 characters.
        # Disabling this procedure will allow simple keys of any length and
        # height (may cause problems if indentation is broken though).
        for level in self.possible_simple_keys.keys():
            key = self.possible_simple_keys[level]
            if key.line != self.line  \
                    or self.index-key.index > 1024:
                if key.required:
                    raise ScannerError("while scanning a simple key", key.mark,
                            "could not found expected ':'", self.get_mark())
                del self.possible_simple_keys[level]

    def save_possible_simple_key(self):
        # The next token may start a simple key. We check if it's possible
        # and save its position. This function is called for
        #   ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.

        # Check if a simple key is required at the current position.
        required = not self.flow_level and self.indent == self.column

        # A simple key is required only if it is the first token in the current
        # line. Therefore it is always allowed.
        assert self.allow_simple_key or not required

        # The next token might be a simple key. Let's save it's number and
        # position.
        if self.allow_simple_key:
            self.remove_possible_simple_key()
            token_number = self.tokens_taken+len(self.tokens)
            key = SimpleKey(token_number, required,
                    self.index, self.line, self.column, self.get_mark())
            self.possible_simple_keys[self.flow_level] = key

    def remove_possible_simple_key(self):
        # Remove the saved possible key position at the current flow level.
        if self.flow_level in self.possible_simple_keys:
            key = self.possible_simple_keys[self.flow_level]
            
            if key.required:
                raise ScannerError("while scanning a simple key", key.mark,
                        "could not found expected ':'", self.get_mark())

            del self.possible_simple_keys[self.flow_level]

    # Indentation functions.

    def unwind_indent(self, column):

        ## In flow context, tokens should respect indentation.
        ## Actually the condition should be `self.indent >= column` according to
        ## the spec. But this condition will prohibit intuitively correct
        ## constructions such as
        ## key : {
        ## }
        #if self.flow_level and self.indent > column:
        #    raise ScannerError(None, None,
        #            "invalid intendation or unclosed '[' or '{'",
        #            self.get_mark())

        # In the flow context, indentation is ignored. We make the scanner less
        # restrictive then specification requires.
        if self.flow_level:
            return

        # In block context, we may need to issue the BLOCK-END tokens.
        while self.indent > column:
            mark = self.get_mark()
            self.indent = self.indents.pop()
            self.tokens.append(BlockEndToken(mark, mark))

    def add_indent(self, column):
        # Check if we need to increase indentation.
        if self.indent < column:
            self.indents.append(self.indent)
            self.indent = column
            return True
        return False

    # Fetchers.

    def fetch_stream_start(self):
        # We always add STREAM-START as the first token and STREAM-END as the
        # last token.

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-START.
        self.tokens.append(StreamStartToken(mark, mark,
            encoding=self.encoding))
        

    def fetch_stream_end(self):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False
        self.possible_simple_keys = {}

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-END.
        self.tokens.append(StreamEndToken(mark, mark))

        # The steam is finished.
        self.done = True

    def fetch_directive(self):
        
        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Scan and add DIRECTIVE.
        self.tokens.append(self.scan_directive())

    def fetch_document_start(self):
        self.fetch_document_indicator(DocumentStartToken)

    def fetch_document_end(self):
        self.fetch_document_indicator(DocumentEndToken)

    def fetch_document_indicator(self, TokenClass):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys. Note that there could not be a block collection
        # after '---'.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Add DOCUMENT-START or DOCUMENT-END.
        start_mark = self.get_mark()
        self.forward(3)
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_start(self):
        self.fetch_flow_collection_start(FlowSequenceStartToken)

    def fetch_flow_mapping_start(self):
        self.fetch_flow_collection_start(FlowMappingStartToken)

    def fetch_flow_collection_start(self, TokenClass):

        # '[' and '{' may start a simple key.
        self.save_possible_simple_key()

        # Increase the flow level.
        self.flow_level += 1

        # Simple keys are allowed after '[' and '{'.
        self.allow_simple_key = True

        # Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_end(self):
        self.fetch_flow_collection_end(FlowSequenceEndToken)

    def fetch_flow_mapping_end(self):
        self.fetch_flow_collection_end(FlowMappingEndToken)

    def fetch_flow_collection_end(self, TokenClass):

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Decrease the flow level.
        self.flow_level -= 1

        # No simple keys after ']' or '}'.
        self.allow_simple_key = False

        # Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_entry(self):

        # Simple keys are allowed after ','.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add FLOW-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(FlowEntryToken(start_mark, end_mark))

    def fetch_block_entry(self):

        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a new entry?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "sequence entries are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-SEQUENCE-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockSequenceStartToken(mark, mark))

        # It's an error for the block entry to occur in the flow context,
        # but we let the parser detect this.
        else:
            pass

        # Simple keys are allowed after '-'.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add BLOCK-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(BlockEntryToken(start_mark, end_mark))

    def fetch_key(self):
        
        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a key (not nessesary a simple)?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "mapping keys are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-MAPPING-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockMappingStartToken(mark, mark))

        # Simple keys are allowed after '?' in the block context.
        self.allow_simple_key = not self.flow_level

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add KEY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(KeyToken(start_mark, end_mark))

    def fetch_value(self):

        # Do we determine a simple key?
        if self.flow_level in self.possible_simple_keys:

            # Add KEY.
            key = self.possible_simple_keys[self.flow_level]
            del self.possible_simple_keys[self.flow_level]
            self.tokens.insert(key.token_number-self.tokens_taken,
                    KeyToken(key.mark, key.mark))

            # If this key starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.
            if not self.flow_level:
                if self.add_indent(key.column):
                    self.tokens.insert(key.token_number-self.tokens_taken,
                            BlockMappingStartToken(key.mark, key.mark))

            # There cannot be two simple keys one after another.
            self.allow_simple_key = False

        # It must be a part of a complex key.
        else:
            
            # Block context needs additional checks.
            # (Do we really need them? They will be catched by the parser
            # anyway.)
            if not self.flow_level:

                # We are allowed to start a complex value if and only if
                # we can start a simple key.
                if not self.allow_simple_key:
                    raise ScannerError(None, None,
                            "mapping values are not allowed here",
                            self.get_mark())

            # If this value starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.  It will be detected as an error later by
            # the parser.
            if not self.flow_level:
                if self.add_indent(self.column):
                    mark = self.get_mark()
                    self.tokens.append(BlockMappingStartToken(mark, mark))

            # Simple keys are allowed after ':' in the block context.
            self.allow_simple_key = not self.flow_level

            # Reset possible simple key on the current level.
            self.remove_possible_simple_key()

        # Add VALUE.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(ValueToken(start_mark, end_mark))

    def fetch_alias(self):

        # ALIAS could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after ALIAS.
        self.allow_simple_key = False

        # Scan and add ALIAS.
        self.tokens.append(self.scan_anchor(AliasToken))

    def fetch_anchor(self):

        # ANCHOR could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after ANCHOR.
        self.allow_simple_key = False

        # Scan and add ANCHOR.
        self.tokens.append(self.scan_anchor(AnchorToken))

    def fetch_tag(self):

        # TAG could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after TAG.
        self.allow_simple_key = False

        # Scan and add TAG.
        self.tokens.append(self.scan_tag())

    def fetch_literal(self):
        self.fetch_block_scalar(style='|')

    def fetch_folded(self):
        self.fetch_block_scalar(style='>')

    def fetch_block_scalar(self, style):

        # A simple key may follow a block scalar.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Scan and add SCALAR.
        self.tokens.append(self.scan_block_scalar(style))

    def fetch_single(self):
        self.fetch_flow_scalar(style='\'')

    def fetch_double(self):
        self.fetch_flow_scalar(style='"')

    def fetch_flow_scalar(self, style):

        # A flow scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after flow scalars.
        self.allow_simple_key = False

        # Scan and add SCALAR.
        self.tokens.append(self.scan_flow_scalar(style))

    def fetch_plain(self):

        # A plain scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after plain scalars. But note that `scan_plain` will
        # change this flag if the scan is finished at the beginning of the
        # line.
        self.allow_simple_key = False

        # Scan and add SCALAR. May change `allow_simple_key`.
        self.tokens.append(self.scan_plain())

    # Checkers.

    def check_directive(self):

        # DIRECTIVE:        ^ '%' ...
        # The '%' indicator is already checked.
        if self.column == 0:
            return True

    def check_document_start(self):

        # DOCUMENT-START:   ^ '---' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == u'---'  \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_document_end(self):

        # DOCUMENT-END:     ^ '...' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == u'...'  \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_block_entry(self):

        # BLOCK-ENTRY:      '-' (' '|'\n')
        return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_key(self):

        # KEY(flow context):    '?'
        if self.flow_level:
            return True

        # KEY(block context):   '?' (' '|'\n')
        else:
            return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_value(self):

        # VALUE(flow context):  ':'
        if self.flow_level:
            return True

        # VALUE(block context): ':' (' '|'\n')
        else:
            return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_plain(self):

        # A plain scalar may start with any non-space character except:
        #   '-', '?', ':', ',', '[', ']', '{', '}',
        #   '#', '&', '*', '!', '|', '>', '\'', '\"',
        #   '%', '@', '`'.
        #
        # It may also start with
        #   '-', '?', ':'
        # if it is followed by a non-space character.
        #
        # Note that we limit the last rule to the block context (except the
        # '-' character) because we want the flow context to be space
        # independent.
        ch = self.peek()
        return ch not in u'\0 \t\r\n\x85\u2028\u2029-?:,[]{}#&*!|>\'\"%@`'  \
                or (self.peek(1) not in u'\0 \t\r\n\x85\u2028\u2029'
                        and (ch == u'-' or (not self.flow_level and ch in u'?:')))

    # Scanners.

    def scan_to_next_token(self):
        # We ignore spaces, line breaks and comments.
        # If we find a line break in the block context, we set the flag
        # `allow_simple_key` on.
        # The byte order mark is stripped if it's the first character in the
        # stream. We do not yet support BOM inside the stream as the
        # specification requires. Any such mark will be considered as a part
        # of the document.
        #
        # TODO: We need to make tab handling rules more sane. A good rule is
        #   Tabs cannot precede tokens
        #   BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,
        #   KEY(block), VALUE(block), BLOCK-ENTRY
        # So the checking code is
        #   if <TAB>:
        #       self.allow_simple_keys = False
        # We also need to add the check for `allow_simple_keys == True` to
        # `unwind_indent` before issuing BLOCK-END.
        # Scanners for block, flow, and plain scalars need to be modified.

        if self.index == 0 and self.peek() == u'\uFEFF':
            self.forward()
        found = False
        while not found:
            while self.peek() == u' ':
                self.forward()
            if self.peek() == u'#':
                while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                    self.forward()
            if self.scan_line_break():
                if not self.flow_level:
                    self.allow_simple_key = True
            else:
                found = True

    def scan_directive(self):
        # See the specification for details.
        start_mark = self.get_mark()
        self.forward()
        name = self.scan_directive_name(start_mark)
        value = None
        if name == u'YAML':
            value = self.scan_yaml_directive_value(start_mark)
            end_mark = self.get_mark()
        elif name == u'TAG':
            value = self.scan_tag_directive_value(start_mark)
            end_mark = self.get_mark()
        else:
            end_mark = self.get_mark()
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        self.scan_directive_ignored_line(start_mark)
        return DirectiveToken(name, value, start_mark, end_mark)

    def scan_directive_name(self, start_mark):
        # See the specification for details.
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        return value

    def scan_yaml_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        major = self.scan_yaml_directive_number(start_mark)
        if self.peek() != '.':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or '.', but found %r"
                    % self.peek().encode('utf-8'),
                    self.get_mark())
        self.forward()
        minor = self.scan_yaml_directive_number(start_mark)
        if self.peek() not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or ' ', but found %r"
                    % self.peek().encode('utf-8'),
                    self.get_mark())
        return (major, minor)

    def scan_yaml_directive_number(self, start_mark):
        # See the specification for details.
        ch = self.peek()
        if not (u'0' <= ch <= u'9'):
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit, but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        length = 0
        while u'0' <= self.peek(length) <= u'9':
            length += 1
        value = int(self.prefix(length))
        self.forward(length)
        return value

    def scan_tag_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        handle = self.scan_tag_directive_handle(start_mark)
        while self.peek() == u' ':
            self.forward()
        prefix = self.scan_tag_directive_prefix(start_mark)
        return (handle, prefix)

    def scan_tag_directive_handle(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_handle('directive', start_mark)
        ch = self.peek()
        if ch != u' ':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return value

    def scan_tag_directive_prefix(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_uri('directive', start_mark)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return value

    def scan_directive_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        if self.peek() == u'#':
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in u'\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        self.scan_line_break()

    def scan_anchor(self, TokenClass):
        # The specification does not restrict characters for anchors and
        # aliases. This may lead to problems, for instance, the document:
        #   [ *alias, value ]
        # can be interpteted in two ways, as
        #   [ "value" ]
        # and
        #   [ *alias , "value" ]
        # Therefore we restrict aliases to numbers and ASCII letters.
        start_mark = self.get_mark()
        indicator = self.peek()
        if indicator == u'*':
            name = 'alias'
        else:
            name = 'anchor'
        self.forward()
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in u'\0 \t\r\n\x85\u2028\u2029?:,]}%@`':
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        end_mark = self.get_mark()
        return TokenClass(value, start_mark, end_mark)

    def scan_tag(self):
        # See the specification for details.
        start_mark = self.get_mark()
        ch = self.peek(1)
        if ch == u'<':
            handle = None
            self.forward(2)
            suffix = self.scan_tag_uri('tag', start_mark)
            if self.peek() != u'>':
                raise ScannerError("while parsing a tag", start_mark,
                        "expected '>', but found %r" % self.peek().encode('utf-8'),
                        self.get_mark())
            self.forward()
        elif ch in u'\0 \t\r\n\x85\u2028\u2029':
            handle = None
            suffix = u'!'
            self.forward()
        else:
            length = 1
            use_handle = False
            while ch not in u'\0 \r\n\x85\u2028\u2029':
                if ch == u'!':
                    use_handle = True
                    break
                length += 1
                ch = self.peek(length)
            handle = u'!'
            if use_handle:
                handle = self.scan_tag_handle('tag', start_mark)
            else:
                handle = u'!'
                self.forward()
            suffix = self.scan_tag_uri('tag', start_mark)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a tag", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        value = (handle, suffix)
        end_mark = self.get_mark()
        return TagToken(value, start_mark, end_mark)

    def scan_block_scalar(self, style):
        # See the specification for details.

        if style == '>':
            folded = True
        else:
            folded = False

        chunks = []
        start_mark = self.get_mark()

        # Scan the header.
        self.forward()
        chomping, increment = self.scan_block_scalar_indicators(start_mark)
        self.scan_block_scalar_ignored_line(start_mark)

        # Determine the indentation level and go to the first non-empty line.
        min_indent = self.indent+1
        if min_indent < 1:
            min_indent = 1
        if increment is None:
            breaks, max_indent, end_mark = self.scan_block_scalar_indentation()
            indent = max(min_indent, max_indent)
        else:
            indent = min_indent+increment-1
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
        line_break = u''

        # Scan the inner part of the block scalar.
        while self.column == indent and self.peek() != u'\0':
            chunks.extend(breaks)
            leading_non_space = self.peek() not in u' \t'
            length = 0
            while self.peek(length) not in u'\0\r\n\x85\u2028\u2029':
                length += 1
            chunks.append(self.prefix(length))
            self.forward(length)
            line_break = self.scan_line_break()
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
            if self.column == indent and self.peek() != u'\0':

                # Unfortunately, folding rules are ambiguous.
                #
                # This is the folding according to the specification:
                
                if folded and line_break == u'\n'   \
                        and leading_non_space and self.peek() not in u' \t':
                    if not breaks:
                        chunks.append(u' ')
                else:
                    chunks.append(line_break)
                
                # This is Clark Evans's interpretation (also in the spec
                # examples):
                #
                #if folded and line_break == u'\n':
                #    if not breaks:
                #        if self.peek() not in ' \t':
                #            chunks.append(u' ')
                #        else:
                #            chunks.append(line_break)
                #else:
                #    chunks.append(line_break)
            else:
                break

        # Chomp the tail.
        if chomping is not False:
            chunks.append(line_break)
        if chomping is True:
            chunks.extend(breaks)

        # We are done.
        return ScalarToken(u''.join(chunks), False, start_mark, end_mark,
                style)

    def scan_block_scalar_indicators(self, start_mark):
        # See the specification for details.
        chomping = None
        increment = None
        ch = self.peek()
        if ch in u'+-':
            if ch == '+':
                chomping = True
            else:
                chomping = False
            self.forward()
            ch = self.peek()
            if ch in u'0123456789':
                increment = int(ch)
                if increment == 0:
                    raise ScannerError("while scanning a block scalar", start_mark,
                            "expected indentation indicator in the range 1-9, but found 0",
                            self.get_mark())
                self.forward()
        elif ch in u'0123456789':
            increment = int(ch)
            if increment == 0:
                raise ScannerError("while scanning a block scalar", start_mark,
                        "expected indentation indicator in the range 1-9, but found 0",
                        self.get_mark())
            self.forward()
            ch = self.peek()
            if ch in u'+-':
                if ch == '+':
                    chomping = True
                else:
                    chomping = False
                self.forward()
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected chomping or indentation indicators, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        return chomping, increment

    def scan_block_scalar_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        if self.peek() == u'#':
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in u'\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        self.scan_line_break()

    def scan_block_scalar_indentation(self):
        # See the specification for details.
        chunks = []
        max_indent = 0
        end_mark = self.get_mark()
        while self.peek() in u' \r\n\x85\u2028\u2029':
            if self.peek() != u' ':
                chunks.append(self.scan_line_break())
                end_mark = self.get_mark()
            else:
                self.forward()
                if self.column > max_indent:
                    max_indent = self.column
        return chunks, max_indent, end_mark

    def scan_block_scalar_breaks(self, indent):
        # See the specification for details.
        chunks = []
        end_mark = self.get_mark()
        while self.column < indent and self.peek() == u' ':
            self.forward()
        while self.peek() in u'\r\n\x85\u2028\u2029':
            chunks.append(self.scan_line_break())
            end_mark = self.get_mark()
            while self.column < indent and self.peek() == u' ':
                self.forward()
        return chunks, end_mark

    def scan_flow_scalar(self, style):
        # See the specification for details.
        # Note that we loose indentation rules for quoted scalars. Quoted
        # scalars don't need to adhere indentation because " and ' clearly
        # mark the beginning and the end of them. Therefore we are less
        # restrictive then the specification requires. We only need to check
        # that document separators are not included in scalars.
        if style == '"':
            double = True
        else:
            double = False
        chunks = []
        start_mark = self.get_mark()
        quote = self.peek()
        self.forward()
        chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        while self.peek() != quote:
            chunks.extend(self.scan_flow_scalar_spaces(double, start_mark))
            chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        self.forward()
        end_mark = self.get_mark()
        return ScalarToken(u''.join(chunks), False, start_mark, end_mark,
                style)

    ESCAPE_REPLACEMENTS = {
        u'0':   u'\0',
        u'a':   u'\x07',
        u'b':   u'\x08',
        u't':   u'\x09',
        u'\t':  u'\x09',
        u'n':   u'\x0A',
        u'v':   u'\x0B',
        u'f':   u'\x0C',
        u'r':   u'\x0D',
        u'e':   u'\x1B',
        u' ':   u'\x20',
        u'\"':  u'\"',
        u'\\':  u'\\',
        u'N':   u'\x85',
        u'_':   u'\xA0',
        u'L':   u'\u2028',
        u'P':   u'\u2029',
    }

    ESCAPE_CODES = {
        u'x':   2,
        u'u':   4,
        u'U':   8,
    }

    def scan_flow_scalar_non_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            length = 0
            while self.peek(length) not in u'\'\"\\\0 \t\r\n\x85\u2028\u2029':
                length += 1
            if length:
                chunks.append(self.prefix(length))
                self.forward(length)
            ch = self.peek()
            if not double and ch == u'\'' and self.peek(1) == u'\'':
                chunks.append(u'\'')
                self.forward(2)
            elif (double and ch == u'\'') or (not double and ch in u'\"\\'):
                chunks.append(ch)
                self.forward()
            elif double and ch == u'\\':
                self.forward()
                ch = self.peek()
                if ch in self.ESCAPE_REPLACEMENTS:
                    chunks.append(self.ESCAPE_REPLACEMENTS[ch])
                    self.forward()
                elif ch in self.ESCAPE_CODES:
                    length = self.ESCAPE_CODES[ch]
                    self.forward()
                    for k in range(length):
                        if self.peek(k) not in u'0123456789ABCDEFabcdef':
                            raise ScannerError("while scanning a double-quoted scalar", start_mark,
                                    "expected escape sequence of %d hexdecimal numbers, but found %r" %
                                        (length, self.peek(k).encode('utf-8')), self.get_mark())
                    code = int(self.prefix(length), 16)
                    chunks.append(unichr(code))
                    self.forward(length)
                elif ch in u'\r\n\x85\u2028\u2029':
                    self.scan_line_break()
                    chunks.extend(self.scan_flow_scalar_breaks(double, start_mark))
                else:
                    raise ScannerError("while scanning a double-quoted scalar", start_mark,
                            "found unknown escape character %r" % ch.encode('utf-8'), self.get_mark())
            else:
                return chunks

    def scan_flow_scalar_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        length = 0
        while self.peek(length) in u' \t':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch == u'\0':
            raise ScannerError("while scanning a quoted scalar", start_mark,
                    "found unexpected end of stream", self.get_mark())
        elif ch in u'\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            breaks = self.scan_flow_scalar_breaks(double, start_mark)
            if line_break != u'\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(u' ')
            chunks.extend(breaks)
        else:
            chunks.append(whitespaces)
        return chunks

    def scan_flow_scalar_breaks(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            # Instead of checking indentation, we check for document
            # separators.
            prefix = self.prefix(3)
            if (prefix == u'---' or prefix == u'...')   \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                raise ScannerError("while scanning a quoted scalar", start_mark,
                        "found unexpected document separator", self.get_mark())
            while self.peek() in u' \t':
                self.forward()
            if self.peek() in u'\r\n\x85\u2028\u2029':
                chunks.append(self.scan_line_break())
            else:
                return chunks

    def scan_plain(self):
        # See the specification for details.
        # We add an additional restriction for the flow context:
        #   plain scalars in the flow context cannot contain ',', ':' and '?'.
        # We also keep track of the `allow_simple_key` flag here.
        # Indentation rules are loosed for the flow context.
        chunks = []
        start_mark = self.get_mark()
        end_mark = start_mark
        indent = self.indent+1
        # We allow zero indentation for scalars, but then we need to check for
        # document separators at the beginning of the line.
        #if indent == 0:
        #    indent = 1
        spaces = []
        while True:
            length = 0
            if self.peek() == u'#':
                break
            while True:
                ch = self.peek(length)
                if ch in u'\0 \t\r\n\x85\u2028\u2029'   \
                        or (not self.flow_level and ch == u':' and
                                self.peek(length+1) in u'\0 \t\r\n\x85\u2028\u2029') \
                        or (self.flow_level and ch in u',:?[]{}'):
                    break
                length += 1
            # It's not clear what we should do with ':' in the flow context.
            if (self.flow_level and ch == u':'
                    and self.peek(length+1) not in u'\0 \t\r\n\x85\u2028\u2029,[]{}'):
                self.forward(length)
                raise ScannerError("while scanning a plain scalar", start_mark,
                    "found unexpected ':'", self.get_mark(),
                    "Please check http://pyyaml.org/wiki/YAMLColonInFlowContext for details.")
            if length == 0:
                break
            self.allow_simple_key = False
            chunks.extend(spaces)
            chunks.append(self.prefix(length))
            self.forward(length)
            end_mark = self.get_mark()
            spaces = self.scan_plain_spaces(indent, start_mark)
            if not spaces or self.peek() == u'#' \
                    or (not self.flow_level and self.column < indent):
                break
        return ScalarToken(u''.join(chunks), True, start_mark, end_mark)

    def scan_plain_spaces(self, indent, start_mark):
        # See the specification for details.
        # The specification is really confusing about tabs in plain scalars.
        # We just forbid them completely. Do not use tabs in YAML!
        chunks = []
        length = 0
        while self.peek(length) in u' ':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch in u'\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            self.allow_simple_key = True
            prefix = self.prefix(3)
            if (prefix == u'---' or prefix == u'...')   \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return
            breaks = []
            while self.peek() in u' \r\n\x85\u2028\u2029':
                if self.peek() == ' ':
                    self.forward()
                else:
                    breaks.append(self.scan_line_break())
                    prefix = self.prefix(3)
                    if (prefix == u'---' or prefix == u'...')   \
                            and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                        return
            if line_break != u'\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(u' ')
            chunks.extend(breaks)
        elif whitespaces:
            chunks.append(whitespaces)
        return chunks

    def scan_tag_handle(self, name, start_mark):
        # See the specification for details.
        # For some strange reasons, the specification does not allow '_' in
        # tag handles. I have allowed it anyway.
        ch = self.peek()
        if ch != u'!':
            raise ScannerError("while scanning a %s" % name, start_mark,
                    "expected '!', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        length = 1
        ch = self.peek(length)
        if ch != u' ':
            while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                    or ch in u'-_':
                length += 1
                ch = self.peek(length)
            if ch != u'!':
                self.forward(length)
                raise ScannerError("while scanning a %s" % name, start_mark,
                        "expected '!', but found %r" % ch.encode('utf-8'),
                        self.get_mark())
            length += 1
        value = self.prefix(length)
        self.forward(length)
        return value

    def scan_tag_uri(self, name, start_mark):
        # See the specification for details.
        # Note: we do not check if URI is well-formed.
        chunks = []
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-;/?:@&=+$,_.!~*\'()[]%':
            if ch == u'%':
                chunks.append(self.prefix(length))
                self.forward(length)
                length = 0
                chunks.append(self.scan_uri_escapes(name, start_mark))
            else:
                length += 1
            ch = self.peek(length)
        if length:
            chunks.append(self.prefix(length))
            self.forward(length)
            length = 0
        if not chunks:
            raise ScannerError("while parsing a %s" % name, start_mark,
                    "expected URI, but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return u''.join(chunks)

    def scan_uri_escapes(self, name, start_mark):
        # See the specification for details.
        bytes = []
        mark = self.get_mark()
        while self.peek() == u'%':
            self.forward()
            for k in range(2):
                if self.peek(k) not in u'0123456789ABCDEFabcdef':
                    raise ScannerError("while scanning a %s" % name, start_mark,
                            "expected URI escape sequence of 2 hexdecimal numbers, but found %r" %
                                (self.peek(k).encode('utf-8')), self.get_mark())
            bytes.append(chr(int(self.prefix(2), 16)))
            self.forward(2)
        try:
            value = unicode(''.join(bytes), 'utf-8')
        except UnicodeDecodeError, exc:
            raise ScannerError("while scanning a %s" % name, start_mark, str(exc), mark)
        return value

    def scan_line_break(self):
        # Transforms:
        #   '\r\n'      :   '\n'
        #   '\r'        :   '\n'
        #   '\n'        :   '\n'
        #   '\x85'      :   '\n'
        #   '\u2028'    :   '\u2028'
        #   '\u2029     :   '\u2029'
        #   default     :   ''
        ch = self.peek()
        if ch in u'\r\n\x85':
            if self.prefix(2) == u'\r\n':
                self.forward(2)
            else:
                self.forward()
            return u'\n'
        elif ch in u'\u2028\u2029':
            self.forward()
            return ch
        return u''

#try:
#    import psyco
#    psyco.bind(Scanner)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = serializer

__all__ = ['Serializer', 'SerializerError']

from error import YAMLError
from events import *
from nodes import *

class SerializerError(YAMLError):
    pass

class Serializer(object):

    ANCHOR_TEMPLATE = u'id%03d'

    def __init__(self, encoding=None,
            explicit_start=None, explicit_end=None, version=None, tags=None):
        self.use_encoding = encoding
        self.use_explicit_start = explicit_start
        self.use_explicit_end = explicit_end
        self.use_version = version
        self.use_tags = tags
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0
        self.closed = None

    def open(self):
        if self.closed is None:
            self.emit(StreamStartEvent(encoding=self.use_encoding))
            self.closed = False
        elif self.closed:
            raise SerializerError("serializer is closed")
        else:
            raise SerializerError("serializer is already opened")

    def close(self):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif not self.closed:
            self.emit(StreamEndEvent())
            self.closed = True

    #def __del__(self):
    #    self.close()

    def serialize(self, node):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif self.closed:
            raise SerializerError("serializer is closed")
        self.emit(DocumentStartEvent(explicit=self.use_explicit_start,
            version=self.use_version, tags=self.use_tags))
        self.anchor_node(node)
        self.serialize_node(node, None, None)
        self.emit(DocumentEndEvent(explicit=self.use_explicit_end))
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0

    def anchor_node(self, node):
        if node in self.anchors:
            if self.anchors[node] is None:
                self.anchors[node] = self.generate_anchor(node)
        else:
            self.anchors[node] = None
            if isinstance(node, SequenceNode):
                for item in node.value:
                    self.anchor_node(item)
            elif isinstance(node, MappingNode):
                for key, value in node.value:
                    self.anchor_node(key)
                    self.anchor_node(value)

    def generate_anchor(self, node):
        self.last_anchor_id += 1
        return self.ANCHOR_TEMPLATE % self.last_anchor_id

    def serialize_node(self, node, parent, index):
        alias = self.anchors[node]
        if node in self.serialized_nodes:
            self.emit(AliasEvent(alias))
        else:
            self.serialized_nodes[node] = True
            self.descend_resolver(parent, index)
            if isinstance(node, ScalarNode):
                detected_tag = self.resolve(ScalarNode, node.value, (True, False))
                default_tag = self.resolve(ScalarNode, node.value, (False, True))
                implicit = (node.tag == detected_tag), (node.tag == default_tag)
                self.emit(ScalarEvent(alias, node.tag, implicit, node.value,
                    style=node.style))
            elif isinstance(node, SequenceNode):
                implicit = (node.tag
                            == self.resolve(SequenceNode, node.value, True))
                self.emit(SequenceStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                index = 0
                for item in node.value:
                    self.serialize_node(item, node, index)
                    index += 1
                self.emit(SequenceEndEvent())
            elif isinstance(node, MappingNode):
                implicit = (node.tag
                            == self.resolve(MappingNode, node.value, True))
                self.emit(MappingStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                for key, value in node.value:
                    self.serialize_node(key, node, None)
                    self.serialize_node(value, node, key)
                self.emit(MappingEndEvent())
            self.ascend_resolver()


########NEW FILE########
__FILENAME__ = tokens

class Token(object):
    def __init__(self, start_mark, end_mark):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in self.__dict__
                if not key.endswith('_mark')]
        attributes.sort()
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

#class BOMToken(Token):
#    id = '<byte order mark>'

class DirectiveToken(Token):
    id = '<directive>'
    def __init__(self, name, value, start_mark, end_mark):
        self.name = name
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class DocumentStartToken(Token):
    id = '<document start>'

class DocumentEndToken(Token):
    id = '<document end>'

class StreamStartToken(Token):
    id = '<stream start>'
    def __init__(self, start_mark=None, end_mark=None,
            encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndToken(Token):
    id = '<stream end>'

class BlockSequenceStartToken(Token):
    id = '<block sequence start>'

class BlockMappingStartToken(Token):
    id = '<block mapping start>'

class BlockEndToken(Token):
    id = '<block end>'

class FlowSequenceStartToken(Token):
    id = '['

class FlowMappingStartToken(Token):
    id = '{'

class FlowSequenceEndToken(Token):
    id = ']'

class FlowMappingEndToken(Token):
    id = '}'

class KeyToken(Token):
    id = '?'

class ValueToken(Token):
    id = ':'

class BlockEntryToken(Token):
    id = '-'

class FlowEntryToken(Token):
    id = ','

class AliasToken(Token):
    id = '<alias>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class AnchorToken(Token):
    id = '<anchor>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class TagToken(Token):
    id = '<tag>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class ScalarToken(Token):
    id = '<scalar>'
    def __init__(self, value, plain, start_mark, end_mark, style=None):
        self.value = value
        self.plain = plain
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style


########NEW FILE########
__FILENAME__ = output
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
# 17/11/2009 - 1.4.0 - Courgette
#    * add an option to create an instance of the logger that will write to 
#      stderr instead
# 22/10/2010 - 1.5.0 - xlr8or
#    * add an option to write to both logfile and stderr 
# 08/04/2011 - 1.6.0 - Courgette
#    * make the console logger write to stdout and repeat errors on 
#      stderr
# 20/04/2011 - 1.6.1 - Courgette
#    * should get rid of UnicodeDecodeError
# 20/04/2011 - 1.6.2 - Courgette
#    * again getting rid of UnicodeDecodeError
#
__author__  = 'ThorN'
__version__ = '1.6.2'

import sys
import logging
from logging import handlers

CONSOLE = 22
BOT = 21
VERBOSE = 9
VERBOSE2 = 8

logging.addLevelName(CONSOLE, 'CONSOLE')
logging.addLevelName(BOT, 'BOT    ')
logging.addLevelName(VERBOSE, 'VERBOSE')
logging.addLevelName(VERBOSE2, 'VERBOS2')

# this has to be done to prevent callstack checking in the logging
# has been causing problems with threaded applications logging
logging._srcfile = None

#--------------------------------------------------------------------------------------------------
class OutputHandler(logging.Logger):
    def __init__(self, name, level=logging.NOTSET):
        logging.Logger.__init__(self, name, level)

    def critical(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'CRITICAL' and exit.
        """
        kwargs['exc_info'] = True
        logging.Logger.critical(self, msg, *args, **kwargs)
        sys.exit(220)

    def console(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'CONSOLE'.
        """
        self.log(CONSOLE, msg, *args, **kwargs) 

    def bot(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'BOT'.
        """
        self.log(BOT, msg, *args, **kwargs) 

    def verbose(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'VERBOSE'.
        """
        self.log(VERBOSE, msg, *args, **kwargs) 

    def verbose2(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'VERBOSE2'.
        """
        self.log(VERBOSE2, msg, *args, **kwargs) 

    def raiseError(self, raiseError, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'ERROR'. And raises
        the exception.
        """
        self.log(logging.ERROR, msg, *args, **kwargs) 
        raise raiseError, msg % args

class stdoutLogger:
    def __init__(self, logger):
        self.logger = logger

    def write(self, msg):
        self.logger.info('STDOUT %r' % msg)
        
class stderrLogger:
    def __init__(self, logger):
        self.logger = logger

    def write(self, msg):
        self.logger.error('STDERR %r' % msg)

#--------------------------------------------------------------------------------------------------
logging.setLoggerClass(OutputHandler)



#handler = logging.StreamHandler(sys.stdout)

#handler = handlers.RotatingFileHandler(__main__.cp.config.get('b3', 'logfile'), 'a', 10485760, 5)
#handler.setFormatter(logging.Formatter('%(asctime)s\t%(levelname)s\t%(message)s', '%y%m%d %H:%I:%S'))
#output.addHandler(handler)
#output.setLevel(__main__.cp.config.get('b3', 'log_level'))

__output = None

def getInstance(logfile='b3.log', loglevel=21, log2console=False):
    """NOTE: log2console is mostly useful for developers. This will make the bot
    log everything to stderr additionally of into the usual logfile.
    """
    global __output

    if __output == None:
        __output = logging.getLogger('output')

        handler = handlers.RotatingFileHandler(logfile, 'a', 10485760, 5, encoding="UTF-8")
        handler.doRollover()
        handler.setFormatter(logging.Formatter('%(asctime)s\t%(levelname)s\t%(message)r', '%y%m%d %H:%M:%S'))
        __output.addHandler(handler)
        
        if log2console:
            consoleFormatter = logging.Formatter('%(asctime)s\t%(levelname)s\t%(message)r', '%M:%S')
            handler2 = logging.StreamHandler(sys.stdout)
            handler2.setFormatter(consoleFormatter)
            __output.addHandler(handler2)
            handlerError = logging.StreamHandler(sys.stderr)
            handlerError.setFormatter(consoleFormatter)
            handlerError.setLevel(logging.ERROR)
            __output.addHandler(handlerError)
           
        __output.setLevel(loglevel)
    return __output

if __name__ == '__main__':
    # test output handler
    log = getInstance('test.log', 1, True)
    log.error('Test error')
    log.debug('Test debug')
    log.console('Test console')
    log.bot('Test bot')
    log.verbose('Test verbose')
    log.verbose2('Test verbose')
    log.warning('Test warning')
    log.info('Test info')

    try:
        raise Exception('error test')
    except:
        log.exception('Test exception')
        log.error('Test error with exc_info',  exc_info=True)
        
    try:
        log.raiseError(Exception, 'Test raiseError')
    except Exception, e:
        # expected behavior
        log.debug('Got expected Exception %s', e)
    else:
        # unexpected behavior
        raise Exception('raiseError should have raised an exception')

    # critical will exit
    log.critical('Test info')
    raise Exception('log.critical should have exited')
    
########NEW FILE########
__FILENAME__ = parser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
#   2012/10/19 - 1.31 - courgette
#   * add method getNextMap() to the list of method all B3 parsers should implement
#   2012/09/14 - 1.30.1 - courgette
#   * fix variable substitution in default message templates
#   2012/08/27 - 1.30 - courgette
#   * better feedback when an error occurs while setting up Rcon
#   * add getEventKey method
#   2012/08/12 - 1.29 - courgette
#   * gracefully fallback on default message templates if missing from main config file
#   2012/08/11 - 1.28 - courgette
#   * add two methods : getGroup and getGroupLevel meant to ease the reading of a valid group or group level from
#     a config file. Conveniently raises KeyError if level or group keyword provided does not match any existing group.
#   2012/07/20 - 1.27.5 - courgette
#   * better error message when expected self.input attribute is missing
#   2012/06/17 - 1.27.4 - courgette
#   * log traceback when an exception occurs while loading a plugin
#   * detect missing 'name' attribute in plugin element from the plugins section of the config file
#   2012/06/17 - 1.27.3 - courgette
#   * more explicit error message when failing to load a plugin from a specified path
#   2012/06/17 - 1.27.2 - courgette
#   * syntax and code cleanup
#   2012/05/06 - 1.27.1 - courgette
#   * increases default b3 event queue size to 50
#   2011/06/05 - 1.27 - xlr8or
#   * implementation of game server encoding/decoding
#   2011/09/12 - 1.26.2 - Courgette
#   * start the admin plugin first as many plugins relie on it (does not affect
#     plugin priority in regard to B3 events dispatching)
#   2011/06/05 - 1.26.1 - Courgette
#   * fix periodic events stats dumping blocking B3 restart/shutdown
#   2011/05/03 - 1.24.8 - Courgette
#   * event queue size can be set in b3.xml in section 'b3/event_queue_size'
#   2011/05/03 - 1.24.7 - Courgette
#   * add periodic events stats dumping to detect slow plugins
#   2011/05/03 - 1.24.6 - Courgette
#   * do not run update sql queries on startup
#   2011/05/03 - 1.24.5 - Courgette
#   * fix bug regarding rcon_ip introduced in 1.24.4
#   2011/04/31 - 1.24.4 - Courgette
#   * add missing b3.timezones import
#   2011/04/30 - 1.24.3 - Courgette
#   * move the B3 start announcement that is broadcasted on the game server after
#     the parser startup() method has been called to give a change to parsers to
#     set up their rcon before it is used.
#   * rcon_ip, rcon_password not mandatory anymore to suport games that have rcon
#     working through files
#   2011/04/27 - 1.24.2 - 82ndab-Bravo17
#   * Auto assign of unique local games_mp log file
#   2011/04/20 - 1.24.1 - Courgette
#   * fix auto detection of locale timezone offset
#   2011/03/30 - 1.24 - Courgette
#   * remove output option log2both and changed the behavior of log2console so
#     that the console log steam is not replacing the stream going to the log file
#   2011/02/03 - 1.23 - Bravo17
#   * allow local log to be appended to instead of overwritten for games with remote logs
#   2010/11/25 - 1.22 - Courgette
#   * at start, can load a plugin in 'disabled' state. Use the 'disabled' as follow :
#         <plugin name="adv" config="@conf/plugin_adv.xml" disabled="Yes"/>
#   2010/11/18 - 1.21 - Courgette
#   * do not resolve eventual domain name found in public_ip
#   2010/11/07 - 1.20.2 - GrosBedo
#   * edited default values of lines_per_second and delay
#   2010/11/07 - 1.20.1 - GrosBedo
#   * added a new dynamical function getMessageVariables to parse messages
#   2010/10/28 - 1.20.0 - Courgette
#   * support an new optional syntax for loading plugins in b3.xml which enable
#     to specify a directory where to find the plugin with the 'path' attribute.
#     This overrides the default and extplugins folders. Example :
#     <plugin name="pluginname" config="@conf/plugin.xml" path="C:\Users\me\myPlugin\"/>
#   2010/10/22 - 1.19.4 - xlr8or
#   * output option log2both writes to logfile AND stderr simultaneously
#   2010/10/06 - 1.19.3 - xlr8or
#   * reintroduced rcontesting on startup, but for q3a based only (rconTest var in parser)
#   2010/09/04 - 1.19.2 - GrosBedo
#   * fixed some typos
#   * moved delay and lines_per_second settings to server category
#   2010/09/04 - 1.19.1 - Grosbedo
#   * added b3/local_game_log option for several remote log reading at once
#   * added http remote log support
#   * delay2 -> lines_per_second
#   2010/09/01 - 1.19 - Grosbedo
#   * reduce disk access costs by reading multiple lines at once from the game log file
#   2010/09/01 - 1.18 - Grosbedo
#   * detect game log file rotation
#   2010/09/01 - 1.17 - Courgette
#   * add beta support for sftp protocol for reading remote game log file
#   2010/08/14 - 1.16.1 - Courgette
#   * fallback on UTC timezone in case the timezone name is not valid
#   2010/04/17 - 1.16 - Courgette
#   * plugin priority is defined by their order in the b3.xml file 
#   * fix bug in getEventName()
#   2010/04/10 - 1.15.1 - Courgette
#   * write the parser version to log file
#   2010/04/10 - 1.15 - Courgette
#   * public_ip and rcon_ip can now be domain names
#   2010/04/10 - 1.14.3 - Bakes
#   * added saybig() to method stubs for inheriting classes.
#   2010/03/23 - 1.14.2 - Bakes
#   * add message_delay for better BFBC2 interoperability.
#   2010/03/22 - 1.14.1 - Courgette
#   * change maprotate() to rotateMap()
#   2010/03/21 - 1.14 - Courgette
#    * create method stubs for inheriting classes to implement
#   10/03/2010 - v1.13 - Courgette
#    * add rconPort for games which have a different rcon port than the game port
#    * server.game_log option is not mandatory anymore. This makes B3 able to work
#      with game servers having no game log file
#    * do not test rcon anymore as the test process differs depending on the game
#   12/12/2009 - v1.12.3 - Courgette
#    * when working in remote mode, does not download the remote log file.
#   06/12/2009 - v1.12.2 - Courgette
#    * write() can specify a custom maxRetries value
#   22/11/2009 - v1.12.1 - Courgette
#    * b3.xml can have option ('server','rcon_timeout') to specify a custom delay
#      (in secondes) to use for the rcon socket
#   17/11/2009 - v1.12.0 - Courgette
#    * b3.xml can now have an optional section named 'devmode'
#    * move 'replay' option to section 'devmode'
#    * move 'delay' option to section 'b3'
#    * add option 'log2console' to section 'devmode'. This will make the bot
#      write to stderr instead of b3.log (useful if using eclipse or such IDE)
#    * fix replay mode when bot detected time reset from game log
#   09/10/2009 - v1.11.2 - xlr8or
#    * Saved original sys.stdout to console.screen to aid communications to b3 screen
#   12/09/2009 - v1.11.1 - xlr8or
#    * Added few functions and prevent spamming b3.log on pause
#   28/08/2009 - v1.11.0 - Bakes
#    * adds Remote B3 thru FTP functionality.
#   19/08/2009 - v1.10.0 - courgette
#    * adds the inflictCustomPenalty() that allows to define game specific penalties.
#      requires admin.py v1.4+
#   10/7/2009 - added code to load publist by default - xlr8or
#   29/4/2009 - fixed ignored exit code (for restarts/shutdowns) - arbscht
#   10/20/2008 - 1.9.1b0 - mindriot
#    * fixed slight typo of b3.events.EVT_UNKOWN to b3.events.EVT_UNKNOWN
#   11/29/2005 - 1.7.0 - ThorN
#    Added atexit handlers
#    Added warning, info, exception, and critical log handlers

__author__  = 'ThorN, Courgette, xlr8or, Bakes'
__version__ = '1.30.1'

# system modules
import os, sys, re, time, thread, traceback, Queue, imp, atexit, socket

import b3
import b3.storage
import b3.events
import b3.output

import b3.game
import b3.cron
import b3.parsers.q3a.rcon
from b3.clients import Clients, Group
import b3.timezones
from ConfigParser import NoOptionError
from b3.functions import getModule, vars2printf
from b3.decorators import memoize
from b3.lib.elementtree import ElementTree

class Parser(object):
    _lineFormat = re.compile('^([a-z ]+): (.*?)', re.IGNORECASE)

    _handlers = {}
    _plugins  = {}
    _pluginOrder = []
    _paused = False
    _pauseNotice = False
    _events = {}
    _eventNames = {}
    _commands = {}

    _messages = {} # message template cache
    # default messages in case one is missing from config file
    _messages_default = {
        "kicked_by": "$clientname^7 was kicked by $adminname^7 $reason",
        "kicked": "$clientname^7 was kicked $reason",
        "banned_by": "$clientname^7 was banned by $adminname^7 $reason",
        "banned": "$clientname^7 was banned $reason",
        "temp_banned_by": "$clientname^7 was temp banned by $adminname^7 for $banduration^7 $reason",
        "temp_banned": "$clientname^7 was temp banned for $banduration^7 $reason",
        "unbanned_by": "$clientname^7 was un-banned by $adminname^7 $reason",
        "unbanned": "$clientname^7 was un-banned $reason",
    }

    _timeStart = None

    encoding = 'latin-1'
    clients  = None
    delay = 0.33 # to apply between each game log lines fetching (max time before a command is detected by the bot + (delay2*nb_of_lines) )
    delay2 = 0.02 # to apply between each game log line processing (max number of lines processed in one second)
    game = None
    gameName = None
    type = None
    working = True
    queue = None
    config = None
    storage = None
    _debug = True
    output = None
    log = None
    replay = False
    remoteLog = False
    screen = None
    rconTest = False
    privateMsg = False

    # Time in seconds of epoch of game log
    logTime = 0

    # Default outputclass set to the q3a rcon class
    OutputClass = b3.parsers.q3a.rcon.Rcon

    _settings = {
        'line_length': 65,
        'min_wrap_length': 100,
        'message_delay': 0
    }

    _reColor = re.compile(r'\^[0-9a-z]')
    _cron = None

    name = 'b3'
    prefix = '^2%s:^3'
    msgPrefix = ''

    _publicIp = ''
    _rconIp = ''
    _rconPort = None
    _port = 0
    _rconPassword = ''

    info = None

    """\
    === Exiting ===

    The parser runs two threads: main and handler.  The main thread is
    responsible for the main loop parsing and queuing events, and process
    termination. The handler thread is responsible for processing queued events
    including raising ``SystemExit'' when a user-requested exit is needed.

    The ``SystemExit'' exception bubbles up only as far as the top of the handler
    thread -- the ``handleEvents'' method.  To expose the exit status to the
    ``run'' method in the main thread, we store the value in ``exitcode''.

    Since the teardown steps in ``run'' and ``handleEvents'' would occur in
    parallel, we use a lock (``exiting'') to ensure that ``run'' waits for
    ``handleEvents'' to finish before proceeding.

    How exiting works, in detail:

      - the parallel loops in run() and handleEvents() are terminated only when
          working==False.

      - die() or restart() invokes shutdown() from the handler thread.

      - the exiting lock is acquired by shutdown() in the handler thread before
          it sets working=False to end both loops.

      - die() or restart() raises SystemExit in the handler thread after
          shutdown() and a few seconds delay.

      - when SystemExit is caught by handleEvents(), its exit status is pushed to
          the main context via exitcode.

      - handleEvents() ensures the exiting lock is released when it finishes.

      - run() waits to acquire the lock in the main thread before proceeding
          with teardown, repeating sys.exit(exitcode) from the main thread if set.

      In the case of an abnormal exception in the handler thread, ``exitcode''
      will be None and the ``exiting'' lock will be released when``handleEvents''
      finishes so the main thread can still continue.

      Exits occurring in the main thread do not need to be synchronised.

    """
    exiting = thread.allocate_lock()
    exitcode = None

    def __init__(self, config):
        self._timeStart = self.time()

        if not self.loadConfig(config):
            print('CRITICAL ERROR : COULD NOT LOAD CONFIG')
            raise SystemExit(220)

        # set game server encoding
        if self.config.has_option('server', 'encoding'):
            self.encoding = self.config.get('server', 'encoding')

        # set up logging
        logfile = self.config.getpath('b3', 'logfile')
        log2console = self.config.has_option('devmode', 'log2console') and self.config.getboolean('devmode', 'log2console')
        self.log = b3.output.getInstance(logfile, self.config.getint('b3', 'log_level'), log2console)

        # save screen output to self.screen
        self.screen = sys.stdout
        print('Activating log   : %s' % logfile)
        sys.stdout = b3.output.stdoutLogger(self.log)
        sys.stderr = b3.output.stderrLogger(self.log)

        # setup ip addresses
        if self.gameName in ('bf3'):
            # for some games we do not need any game ip:port
            self._publicIp = self.config.get('server', 'public_ip') if self.config.has_option('server', 'public_ip') else ''
            self._port = self.config.getint('server', 'port') if self.config.has_option('server', 'port') else ''
        else:
            self._publicIp = self.config.get('server', 'public_ip')
            self._port = self.config.getint('server', 'port')
        self._rconPort = self._port # if rcon port is the same as the game port, rcon_port can be ommited
        self._rconIp = self._publicIp # if rcon ip is the same as the game port, rcon_ip can be ommited
        if self.config.has_option('server', 'rcon_ip'):
            self._rconIp = self.config.get('server', 'rcon_ip')
        if self.config.has_option('server', 'rcon_port'):
            self._rconPort = self.config.getint('server', 'rcon_port')
        if self.config.has_option('server', 'rcon_password'):
            self._rconPassword = self.config.get('server', 'rcon_password')


        if self._publicIp and self._publicIp[0:1] in ('~', '/'):
            # load ip from a file
            f = file(self.getAbsolutePath(self._publicIp))
            self._publicIp = f.read().strip()
            f.close()

        if self._rconIp[0:1] in ('~', '/'):
            # load ip from a file
            f = file(self.getAbsolutePath(self._rconIp))
            self._rconIp = f.read().strip()
            f.close()

        try:
            # resolve domain names
            self._rconIp = socket.gethostbyname(self._rconIp)
        except:
            pass

        self.bot('%s', b3.getB3versionString())
        self.bot('Python: %s', sys.version)
        self.bot('Default encoding: %s', sys.getdefaultencoding())
        self.bot('Starting %s v%s for server %s:%s', self.__class__.__name__, getattr(getModule(self.__module__), '__version__', ' Unknown'), self._rconIp, self._port)

        # get events
        self.Events = b3.events.eventManager
        self._eventsStats = b3.events.EventsStats(self)
        

        self.bot('--------------------------------------------')

        # setup bot
        bot_name = self.config.get('b3', 'bot_name')
        if bot_name:
            self.name = bot_name

        bot_prefix = self.config.get('b3', 'bot_prefix')
        if bot_prefix:
            self.prefix = bot_prefix
        else:
            self.prefix = ''

        self.msgPrefix = self.prefix

        # delay between log reads
        if self.config.has_option('server', 'delay'):
            delay = self.config.getfloat('server', 'delay')
            if self.delay > 0:
                self.delay = delay

        # delay between each log's line processing
        if self.config.has_option('server', 'lines_per_second'):
            delay2 = self.config.getfloat('server', 'lines_per_second')
            if delay2 > 0:
                self.delay2 = 1/delay2

        # demo mode: use log time
        if self.config.has_option('devmode', 'replay'):
            self.replay = self.config.getboolean('devmode', 'replay')
            if self.replay:
                self._timeStart = 0
                self.bot('Replay mode enabled')

        self.storage = b3.storage.getStorage('database', self.config.get('b3', 'database'), self)

        if self.config.has_option('server','game_log'):
            # open log file
            game_log = self.config.get('server','game_log')
            if game_log[0:6] == 'ftp://' or game_log[0:7] == 'sftp://' or game_log[0:7] == 'http://':
                self.remoteLog = True
                self.bot('Working in Remote-Log-Mode : %s' % game_log)
                
                if self.config.has_option('server', 'local_game_log'):
                    f = self.config.getpath('server', 'local_game_log')
                else:
                    logext = str(self._rconIp.replace('.', '_'))
                    logext = 'games_mp_' + logext + '_' + str(self._port) + '.log'
                    f = os.path.normpath(os.path.expanduser(logext))

                if self.config.has_option('server', 'log_append'):
                    if not (self.config.getboolean('server', 'log_append') and os.path.isfile(f)):
                        self.screen.write('Creating Gamelog : %s\n' % f)
                        ftptempfile = open(f, "w")
                        ftptempfile.close()
                    else:
                        self.screen.write('Append to Gamelog: %s\n' % f)
                else:
                    self.screen.write('Creating Gamelog : %s\n' % f)
                    ftptempfile = open(f, "w")
                    ftptempfile.close()
                    
            else:
                self.bot('Game log %s', game_log)
                f = self.config.getpath('server', 'game_log')
            self.bot('Starting bot reading file %s', f)
            self.screen.write('Using Gamelog    : %s\n' % f)

            if os.path.isfile(f):
                self.input  = file(f, 'r')
    
                # seek to point in log file?
                if self.replay:
                    pass
                elif self.config.has_option('server', 'seek'):
                    seek = self.config.getboolean('server', 'seek')
                    if seek:
                        self.input.seek(0, os.SEEK_END)
                else:
                    self.input.seek(0, os.SEEK_END)
            else:
                self.error('Error reading file %s', f)
                raise SystemExit('Error reading file %s\n' % f)

        # setup rcon
        try:
            self.output = self.OutputClass(self, (self._rconIp, self._rconPort), self._rconPassword)
        except Exception, err:
            self.screen.write(">>> Cannot setup RCON. %s" % err)
            self.screen.flush()
            self.critical("Cannot setup RCON. %s" % err, exc_info=err)
        
        if self.config.has_option('server','rcon_timeout'):
            custom_socket_timeout = self.config.getfloat('server','rcon_timeout')
            self.output.socket_timeout = custom_socket_timeout
            self.bot('Setting Rcon socket timeout to %0.3f sec' % custom_socket_timeout)
        
        # testing rcon
        if self.rconTest:
            res = self.output.write('status')
            self.output.flush()
            self.screen.write('Testing RCON     : ')
            self.screen.flush()
            _badRconReplies = ['Bad rconpassword.', 'Invalid password.']
            if res in _badRconReplies:
                self.screen.write('>>> Oops: Bad RCON password\n>>> Hint: This will lead to errors and render B3 without any power to interact!\n')
                self.screen.flush()
                time.sleep(2)
            elif res == '':
                self.screen.write('>>> Oops: No response\n>>> Could be something wrong with the rcon connection to the server!\n>>> Hint 1: The server is not running or it is changing maps.\n>>> Hint 2: Check your server-ip and port.\n')
                self.screen.flush()
                time.sleep(2)
            else:
                self.screen.write('OK\n')

        self.loadEvents()
        self.screen.write('Loading Events   : %s events loaded\n' % len(self._events))
        self.clients  = Clients(self)
        self.loadPlugins()
        self.loadArbPlugins()

        self.game = b3.game.Game(self, self.gameName)
        
        try:
            queuesize = self.config.getint('b3', 'event_queue_size')
        except NoOptionError:
            queuesize = 50
        except Exception, err:
            self.warning(err)
            queuesize = 50
        self.debug("creating the event queue with size %s", queuesize)
        self.queue = Queue.Queue(queuesize)    # event queue

        atexit.register(self.shutdown)



    def getAbsolutePath(self, path):
        """Return an absolute path name and expand the user prefix (~)"""
        return b3.getAbsolutePath(path)

    def _dumpEventsStats(self):
        self._eventsStats.dumpStats()

    def start(self):
        """Start B3"""
        self.bot("Starting parser")
        self.startup()
        self.say('%s ^2[ONLINE]' % b3.version)
        self.bot("Starting plugins")
        self.startPlugins()
        self._eventsStats_cronTab = b3.cron.CronTab(self._dumpEventsStats)
        self.cron + self._eventsStats_cronTab
        self.bot("all plugins started")
        self.pluginsStarted()
        self.bot("starting event dispatching thread")
        thread.start_new_thread(self.handleEvents, ())
        self.bot("start reading game events")
        self.run()

    def die(self):
        """Stop B3 with the die exit status (222)"""
        self.shutdown()

        time.sleep(5)

        sys.exit(222)

    def restart(self):
        """Stop B3 with the restart exit statis (221)"""
        self.shutdown()

        time.sleep(5)

        self.bot('Restarting...')
        sys.exit(221)

    def upTime(self):
        """Amount of time B3 has been running"""
        return self.time() - self._timeStart

    def loadConfig(self, config):
        """Set the config file to load"""

        if not config:
            return False

        self.config = config

        return True

    def saveConfig(self):
        """Save configration changes"""
        self.bot('Saving config %s', self.config.fileName)
        return self.config.save()

    def startup(self):
        """\
        Called after the parser is created before run(). Overwrite this
        for anything you need to initialize you parser with.
        """
        pass

    def pluginsStarted(self):
        """\
        Called after the parser loaded and started all plugins. 
        Overwrite this in parsers to take actions once plugins are ready
        """
        pass

    def pause(self):
        """Pause B3 log parsing"""
        self.bot('PAUSING')
        self._paused = True

    def unpause(self):
        """Unpause B3 log parsing"""
        self._paused = False
        self._pauseNotice = False
        self.input.seek(0, os.SEEK_END)

    def loadEvents(self):
        """Load events from event manager"""
        self._events = self.Events.events

    def createEvent(self, key, name=None):
        """Create a new event"""
        self.Events.createEvent(key, name)
        self._events = self.Events.events
        return self._events[key]

    def getEventID(self, key):
        """Get the numeric ID of an event key"""
        return self.Events.getId(key)

    def getEvent(self, key, data=None, client=None, target=None):
        """Return a new Event object for an event name"""
        return b3.events.Event(self.Events.getId(key), data, client, target)

    def getEventName(self, key):
        """Get the name of an event by its key"""
        return self.Events.getName(key)

    def getEventKey(self, event_id):
        """Get the key of a given event ID"""
        return self.Events.getKey(event_id)

    def getPlugin(self, plugin):
        """Get a reference to a loaded plugin"""
        try:
            return self._plugins[plugin]
        except KeyError:
            return None

    def reloadConfigs(self):
        """Reload all config files"""
        # reload main config
        self.config.load(self.config.fileName)

        for k in self._pluginOrder:
            p = self._plugins[k]
            self.bot('Reload plugin config for %s', k)
            p.loadConfig()
            
        self.updateDocumentation()

    def loadPlugins(self):
        """Load plugins specified in the config"""
        self.screen.write('Loading Plugins  : ')
        self.screen.flush()
        
        extplugins_dir = self.config.getpath('plugins', 'external_dir')
        self.bot('Loading Plugins (external plugin directory: %s)' % extplugins_dir)
        
        plugins = {}
        pluginSort = []

        priority = 1
        for p in self.config.get('plugins/plugin'):
            name = p.get('name')
            if not name:
                self.critical("Config Error in the plugins section. No plugin name found in [%s]" % ElementTree.tostring(p).strip())
                raise SystemExit(220)
            conf = p.get('config')
            if conf is None:
                conf = '@b3/conf/plugin_%s.xml' % name
            disabledconf = p.get('disabled')
            plugins[priority] = {'name': name,
                                 'conf': self.getAbsolutePath(conf),
                                 'path': p.get('path'),
                                 'disabled': disabledconf is not None and disabledconf.lower() in ('yes', '1', 'on', 'true')}
            pluginSort.append(priority)
            priority += 1

        pluginSort.sort()

        self._pluginOrder = []
        for s in pluginSort:
            plugin_name = plugins[s]['name']
            plugin_conf = plugins[s]['conf']
            self._pluginOrder.append(plugin_name)
            self.bot('Loading Plugin #%s %s [%s]', s, plugin_name, plugin_conf)
            try:
                pluginModule = self.pluginImport(plugin_name, plugins[s]['path'])
                self._plugins[plugin_name] = getattr(pluginModule, '%sPlugin' % plugin_name.title())(self, plugin_conf)
                if plugins[s]['disabled']:
                    self.info("disabling plugin %s" % plugin_name)
                    self._plugins[plugin_name].disable()
            except Exception, err:
                self.error('Error loading plugin %s' % plugin_name, exc_info=err)
            else:
                version = getattr(pluginModule, '__version__', 'Unknown Version')
                author  = getattr(pluginModule, '__author__', 'Unknown Author')
                self.bot('Plugin %s (%s - %s) loaded', plugin_name, version, author)
                self.screen.write('.')
                self.screen.flush()

    def loadArbPlugins(self):
        """Load must have plugins and check for admin plugin"""

        def loadPlugin(parser, plugin_id):
            parser.bot('Loading Plugin %s', plugin_id)
            pluginModule = parser.pluginImport(plugin_id)
            parser._plugins[plugin_id] = getattr(pluginModule, '%sPlugin' % plugin_id.title()) (parser)
            parser._pluginOrder.append(plugin_id)
            version = getattr(pluginModule, '__version__', 'Unknown Version')
            author  = getattr(pluginModule, '__author__', 'Unknown Author')
            parser.bot('Plugin %s (%s - %s) loaded', plugin_id, version, author)
            parser.screen.write('.')
            parser.screen.flush()

        if 'publist' not in self._pluginOrder:
            #self.debug('publist not found!')
            try:
                loadPlugin(self, 'publist')
            except Exception, err:
                self.verbose('Error loading plugin publist', exc_info=err)
        if self.config.has_option('server','game_log') \
            and self.config.get('server','game_log')[0:6] == 'ftp://' :
            try:
                loadPlugin(self, 'ftpytail')
            except Exception, err:
                self.critical('Error loading plugin ftpytail', exc_info=err)
                raise SystemExit('error while loading ftpytail')
        if self.config.has_option('server','game_log') \
            and self.config.get('server','game_log')[0:7] == 'sftp://' :
            try:
                loadPlugin(self, 'sftpytail')
            except Exception, err:
                self.critical('Error loading plugin sftpytail', exc_info=err)
                raise SystemExit('error while loading sftpytail')
        if self.config.has_option('server','game_log') \
            and self.config.get('server','game_log')[0:7] == 'http://' :
            try:
                loadPlugin(self, 'httpytail')
            except Exception, err:
                self.critical('Error loading plugin httpytail', exc_info=err)
                raise SystemExit('error while loading httpytail')
        if 'admin' not in self._pluginOrder:
            # critical will exit, admin plugin must be loaded!
            self.critical('AdminPlugin is essential and MUST be loaded! Cannot continue without admin plugin.')
        self.screen.write(' (%s)\n' % len(self._pluginOrder))
        self.screen.flush()

    def pluginImport(self, name, path=None):
        """Import a single plugin"""
        if path is not None:
            try:
                self.info('loading plugin from specified path : %s', path)
                fp, pathname, description = imp.find_module(name, [path])
                try:
                    return imp.load_module(name, fp, pathname, description)
                finally:
                    if fp:
                        fp.close()
            except ImportError, err:
                self.error(err)
        try:
            module = 'b3.plugins.%s' % name
            mod = __import__(module)
            components = module.split('.')
            for comp in components[1:]:
                mod = getattr(mod, comp)
            return mod
        except ImportError, m:
            self.info('%s is not a built-in plugin (%s)', name, m)
            self.info('trying external plugin directory : %s', self.config.getpath('plugins', 'external_dir'))
            fp, pathname, description = imp.find_module(name, [self.config.getpath('plugins', 'external_dir')])
            try:
                return imp.load_module(name, fp, pathname, description)
            finally:
                if fp:
                    fp.close()

    def startPlugins(self):
        """Start all loaded plugins"""
        self.screen.write('Starting Plugins : ')
        self.screen.flush()

        def start_plugin(plugin_name):
            p = self._plugins[plugin_name]
            self.bot('Starting Plugin %s', plugin_name)
            p.onStartup()
            p.start()
            #time.sleep(1)    # give plugin time to crash, er...start
            self.screen.write('.')
            self.screen.flush()

        # handle admin plugin first as many plugins rely on it
        if 'admin' in self._pluginOrder:
            start_plugin('admin')
            self._pluginOrder.remove('admin')

        # start other plugins
        for plugin_name in self._pluginOrder:
            if plugin_name not in self._plugins:
                self.warning("Not starting plugin %s as it was not loaded" % plugin_name)
            else:
                try:
                    start_plugin(plugin_name)
                except Exception, err:
                    self.error("Could not start plugin %s" % plugin_name, exc_info=err)

        self.screen.write(' (%s)\n' % (len(self._pluginOrder)+1))

    def disablePlugins(self):
        """Disable all plugins except for publist, ftpytail and admin"""
        for k in self._pluginOrder:
            if k not in ('admin', 'publist', 'ftpytail'):
                p = self._plugins[k]
                self.bot('Disabling Plugin %s', k)
                p.disable()

    def enablePlugins(self):
        """Enable all plugins except for publist, ftpytail and admin"""
        for k in self._pluginOrder:
            if k not in ('admin', 'publist', 'ftpytail'):
                p = self._plugins[k]
                self.bot('Enabling Plugin %s', k)
                p.enable()

    def getMessage(self, msg, *args):
        """Return a message from the config file"""
        try:
            msg = self._messages[msg]
        except KeyError:
            try:
                msg = self._messages[msg] = self.config.getTextTemplate('messages', msg)
            except Exception, err:
                self.warning("Falling back on default message for '%s'. %s" % (msg, err))
                msg = vars2printf(self._messages_default.get(msg, '')).strip()

        if len(args):
            if type(args[0]) == dict:
                return msg % args[0]
            else:
                return msg % args
        else:
            return msg

    def getMessageVariables(self, *args, **kwargs):
        """Dynamically generate a dictionnary of fields available for messages in config file"""
        variables = {}
        for obj in args:
            if obj is None:
                continue
            if type(obj).__name__ in ('str','unicode'):
                if variables.has_key(obj) is False:
                    variables[obj] = obj
            else:
                for attr in vars(obj):
                    pattern = re.compile('[\W_]+')
                    cleanattr = pattern.sub('', attr) # trim any underscore or any non alphanumeric character
                    variables[cleanattr] = getattr(obj, attr)
        for key, obj in kwargs.iteritems():
            #self.debug('Type of kwarg %s: %s' % (key, type(obj).__name__))
            if obj is None:
                continue
            if type(obj).__name__ in ('str','unicode'):
                if variables.has_key(key) is False:
                    variables[key] = obj
            #elif type(obj).__name__ == 'instance':
                #self.debug('Classname of object %s: %s' % (key, obj.__class__.__name__))
            else:
                for attr in vars(obj):
                    pattern = re.compile('[\W_]+')
                    cleanattr = pattern.sub('', attr) # trim any underscore or any non alphanumeric character
                    currkey = ''.join([key,cleanattr])
                    variables[currkey] = getattr(obj, attr)
        ''' For debug purposes, uncomment to see in the log a list of the available fields
        allkeys = variables.keys()
        allkeys.sort()
        for key in allkeys:
            self.debug('%s has value %s' % (key, variables[key]))
        '''
        return variables

    def getCommand(self, cmd, **kwargs):
        """Return a reference to a loaded command"""
        try:
            cmd = self._commands[cmd]
        except KeyError:
            return None

        return cmd % kwargs

    @memoize
    def getGroup(self, data):
        """
        Return a valid Group from storage.
        <data> can be either a group keyword or a group level.
        Raises KeyError if group is not found.
        """
        if type(data) is int or isinstance(data, basestring) and data.isdigit():
            g = Group(level=data)
        else:
            g = Group(keyword=data)
        return self.storage.getGroup(g)

    def getGroupLevel(self, data):
        """
        Return a valid Group level.
        <data> can be either a group keyword or a group level.
        Raises KeyError if group is not found.
        """
        group = self.getGroup(data)
        return group.level


    def getTzOffsetFromName(self, tzName):
        try:
            tzOffset = b3.timezones.timezones[tzName] * 3600
        except KeyError:
            try:
                self.warning("Unknown timezone name [%s]. Valid timezone codes can be found on http://wiki.bigbrotherbot.net/doku.php/usage:available_timezones" % tzName)
                tzOffset = time.timezone
                if tzOffset < 0:
                    tzName = 'UTC%s' % (tzOffset/3600)
                else:
                    tzName = 'UTC+%s' % (tzOffset/3600)
                self.info("using system offset [%s]", tzOffset)
            except KeyError:
                self.error("Unknown timezone name [%s]. Valid timezone codes can be found on http://wiki.bigbrotherbot.net/doku.php/usage:available_timezones" % tzName)
                tzName = 'UTC'
                tzOffset = 0
        return tzOffset, tzName

    def formatTime(self, gmttime, tzName=None):
        """Return a time string formated to local time in the b3 config time_format"""
        if tzName:
            tzName = str(tzName).strip().upper()
            try:
                tzOffset = float(tzName) * 3600
            except ValueError:
                tzOffset, tzName = self.getTzOffsetFromName(tzName)
        else:
            tzName = self.config.get('b3', 'time_zone').upper()
            tzOffset, tzName = self.getTzOffsetFromName(tzName)

        timeFormat = self.config.get('b3', 'time_format').replace('%Z', tzName).replace('%z', tzName)
        self.debug('formatting time with timezone [%s], tzOffset : %s' % (tzName, tzOffset))
        return time.strftime(timeFormat, time.gmtime(gmttime + tzOffset))

    def run(self):
        """Main worker thread for B3"""
        self.screen.write('Startup Complete : B3 is running! Let\'s get to work!\n\n')
        self.screen.write('(If you run into problems, check %s in the B3 root directory for detailed log info)\n' % self.config.getpath('b3', 'logfile'))
        #self.screen.flush()

        self.updateDocumentation()

        logTimeStart = None
        logTimeLast = 0
        while self.working:
            if self._paused:
                if not self._pauseNotice:
                    self.bot('PAUSED - Not parsing any lines, B3 will be out of sync.')
                    self._pauseNotice = True
            else:
                lines = self.read()

                if lines:
                    for line in lines:
                        line = str(line).strip()
                        if line:
                            # Track the log file time changes. This is mostly for
                            # parsing old log files for testing and to have time increase
                            # predictably
                            m = self._lineTime.match(line)
                            if m:
                                logTimeCurrent = (int(m.group('minutes')) * 60) + int(m.group('seconds'))
                                if logTimeStart and logTimeCurrent - logTimeStart < logTimeLast:
                                    # Time in log has reset
                                    logTimeStart = logTimeCurrent
                                    logTimeLast = 0
                                    self.debug('Log time reset %d' % logTimeCurrent)
                                elif not logTimeStart:
                                    logTimeStart = logTimeCurrent

                                # Remove starting offset, we want the first line to be at 0 seconds
                                logTimeCurrent -= logTimeStart
                                self.logTime += logTimeCurrent - logTimeLast
                                logTimeLast = logTimeCurrent

                            if self.replay:                    
                                self.debug('Log time %d' % self.logTime)

                            self.console(line)

                            try:
                                self.parseLine(line)
                            except SystemExit:
                                raise
                            except Exception, msg:
                                self.error('could not parse line %s: %s', msg, traceback.extract_tb(sys.exc_info()[2]))
                            
                            time.sleep(self.delay2)

            time.sleep(self.delay)

        self.bot('Stop reading.')

        with self.exiting:
            self.input.close()
            self.output.close()

            if self.exitcode:
                sys.exit(self.exitcode)


    def parseLine(self, line):
        """Parse a single line from the log file"""
        m = re.match(self._lineFormat, line)
        if m:
            self.queueEvent(b3.events.Event(
                    b3.events.EVT_UNKNOWN,
                    m.group(2)[:1]
                ))

    def registerHandler(self, eventName, eventHandler):
        """Register an event handler"""
        self.debug('Register Event: %s: %s', self.Events.getName(eventName), eventHandler.__class__.__name__)

        if not self._handlers.has_key(eventName):
            self._handlers[eventName] = []
        self._handlers[eventName].append(eventHandler)

    def queueEvent(self, event, expire=10):
        """Queue an event for processing"""
        if not hasattr(event, 'type'):
            return False
        elif self._handlers.has_key(event.type):    # queue only if there are handlers to listen for this event
            self.verbose('Queueing event %s %s', self.Events.getName(event.type), event.data)
            try:
                time.sleep(0.001) # wait a bit so event doesnt get jumbled
                self.queue.put((self.time(), self.time() + expire, event), True, 2)
                return True
            except Queue.Full, msg:
                self.error('**** Event queue was full (%s)', self.queue.qsize())
                return False

        return False

    def handleEvents(self):
        """Event handler thread"""
        while self.working:
            added, expire, event = self.queue.get(True)
            if event.type == b3.events.EVT_EXIT or event.type == b3.events.EVT_STOP:
                self.working = False

            eventName = self.Events.getName(event.type)
            self._eventsStats.add_event_wait((self.time() - added)*1000)
            if self.time() >= expire:    # events can only sit in the queue until expire time
                self.error('**** Event sat in queue too long: %s %s', eventName, self.time() - expire)
            else:
                nomore = False
                for hfunc in self._handlers[event.type]:
                    if not hfunc.isEnabled():
                        continue
                    elif nomore:
                        break

                    self.verbose('Parsing Event: %s: %s', eventName, hfunc.__class__.__name__)
                    timer_plugin_begin = time.clock()
                    try:
                        hfunc.parseEvent(event)
                        time.sleep(0.001)
                    except b3.events.VetoEvent:
                        # plugin called for event hault, do not continue processing
                        self.bot('Event %s vetoed by %s', eventName, str(hfunc))
                        nomore = True
                    except SystemExit, e:
                        self.exitcode = e.code
                    except Exception, msg:
                        self.error('handler %s could not handle event %s: %s: %s %s', hfunc.__class__.__name__, eventName, msg.__class__.__name__, msg, traceback.extract_tb(sys.exc_info()[2]))
                    finally:
                        elapsed = time.clock() - timer_plugin_begin
                        self._eventsStats.add_event_handled(hfunc.__class__.__name__, eventName, elapsed*1000)
                    
        self.bot('Shutting down event handler')

        # releasing lock if it was set by self.shutdown() for instance
        if self.exiting.locked():
            self.exiting.release()

    def write(self, msg, maxRetries=None):
        """Write a message to Rcon/Console"""
        if self.replay:
            self.bot('Sent rcon message: %s' % msg)
        elif self.output is None:
            pass
        else:
            res = self.output.write(msg, maxRetries=maxRetries)
            self.output.flush()
            return res

    def writelines(self, msg):
        """Write a sequence of messages to Rcon/Console. Optimized for speed"""
        if self.replay:
            self.bot('Sent rcon message: %s' % msg)
        elif self.output is None:
            pass
        else:
            res = self.output.writelines(msg)
            self.output.flush()
            return res

    def read(self):
        """read from game server log file"""
        if not hasattr(self, 'input'):
            self.critical("cannot read game log file. Check that you have a correct value for the 'game_log' setting in your main config file.")
            raise SystemExit(220)
        # Getting the stats of the game log (we are looking for the size)
        filestats = os.fstat(self.input.fileno())
        # Compare the current cursor position against the current file size,
        # if the cursor is at a number higher than the game log size, then
        # there's a problem
        if self.input.tell() > filestats.st_size:   
            self.debug('Parser: Game log is suddenly smaller than it was before (%s bytes, now %s), the log was probably either rotated or emptied. B3 will now re-adjust to the new size of the log.' % (str(self.input.tell()), str(filestats.st_size)) )  
            self.input.seek(0, os.SEEK_END)  
        return self.input.readlines() 

    def shutdown(self):
        """Shutdown B3"""
        try:
            if self.working and self.exiting.acquire():
                self.bot('Shutting down...')
                self.working = False
                for k,plugin in self._plugins.items():
                    plugin.parseEvent(b3.events.Event(b3.events.EVT_STOP, ''))
                if self._cron:
                    self._cron.stop()

                self.bot('Shutting down database connections...')
                self.storage.shutdown()
        except Exception, e:
            self.error(e)

    def getWrap(self, text, length=80, minWrapLen=150):
        """Returns a sequence of lines for text that fits within the limits"""
        if not text:
            return []

        length = int(length)
        text = text.replace('//', '/ /')

        if len(text) <= minWrapLen:
            return [text]
        #if len(re.sub(REG, '', text)) <= minWrapLen:
        #    return [text]

        text = re.split(r'\s+', text)

        lines = []
        color = '^7'

        line = text[0]
        for t in text[1:]:
            if len(re.sub(self._reColor, '', line)) + len(re.sub(self._reColor, '', t)) + 2 <= length:
                line = '%s %s' % (line, t)
            else:
                if len(lines) > 0:
                    lines.append('^3>%s%s' % (color, line))
                else:
                    lines.append('%s%s' % (color, line))

                m = re.findall(self._reColor, line)
                if m:
                    color = m[-1]

                line = t

        if len(line):
            if len(lines) > 0:
                lines.append('^3>%s%s' % (color, line))
            else:
                lines.append('%s%s' % (color, line))

        return lines

    def error(self, msg, *args, **kwargs):
        """Log an error"""
        self.log.error(msg, *args, **kwargs)

    def debug(self, msg, *args, **kwargs):
        """Log a debug message"""
        self.log.debug(msg, *args, **kwargs)

    def bot(self, msg, *args, **kwargs):
        """Log a bot message"""
        self.log.bot(msg, *args, **kwargs)

    def verbose(self, msg, *args, **kwargs):
        """Log a verbose message"""
        self.log.verbose(msg, *args, **kwargs)

    def verbose2(self, msg, *args, **kwargs):
        """Log an extra verbose message"""
        self.log.verbose2(msg, *args, **kwargs)

    def console(self, msg, *args, **kwargs):
        """Log a message from the console"""
        self.log.console(msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """Log a message from the console"""
        self.log.warning(msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        """Log a message from the console"""
        self.log.info(msg, *args, **kwargs)

    def exception(self, msg, *args, **kwargs):
        """Log a message from the console"""
        self.log.exception(msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        """Log a message from the console"""
        self.log.critical(msg, *args, **kwargs)

    def time(self):
        """Return the current time in GMT/UTC"""
        if self.replay:
            return self.logTime

        return int(time.time())

    def _get_cron(self):
        """Instantiate the main Cron object"""
        if not self._cron:
            self._cron = b3.cron.Cron(self)
            self._cron.start()
        return self._cron

    cron = property(_get_cron)


    def stripColors(self, text):
        return re.sub(self._reColor, '', text).strip()

    def updateDocumentation(self):
        """Create a documentation for all available commands"""
        if self.config.has_section('autodoc'):
            try:
                from b3.tools.documentationBuilder import DocBuilder
                docbuilder = DocBuilder(self)
                docbuilder.save()
            except Exception, err:
                self.error("Failed to generate user documentation")
                self.exception(err)

        else:
            self.info('No user documentation generated. To enable update your configuration file.')


    ###############################################################################
    ##                                                                           ##
    ##     Inheriting classes must implements the following methods.             ##
    ##     Plugins that are game independant assume those methods exist          ##
    ##                                                                           ##
    ###############################################################################

    def getPlayerList(self):
        """\
        Query the game server for connected players.
        return a dict having players' id for keys and players' data as another dict for values
        """
        raise NotImplementedError

    def authorizeClients(self):
        """\
        For all connected players, fill the client object with properties allowing to find 
        the user in the database (usualy guid, or punkbuster id, ip) and call the 
        Client.auth() method 
        """
        raise NotImplementedError
    
    def sync(self):
        """\
        For all connected players returned by self.getPlayerList(), get the matching Client
        object from self.clients (with self.clients.getByCID(cid) or similar methods) and
        look for inconsistencies. If required call the client.disconnect() method to remove
        a client from self.clients.
        This is mainly useful for games where clients are identified by the slot number they
        occupy. On map change, a player A on slot 1 can leave making room for player B who
        connects on slot 1.
        """
        raise NotImplementedError
    
    def say(self, msg):
        """\
        broadcast a message to all players
        """
        raise NotImplementedError

    def saybig(self, msg):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        raise NotImplementedError

    def message(self, client, text):
        """\
        display a message to a given player
        """
        raise NotImplementedError

    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        kick a given player
        """
        raise NotImplementedError

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        ban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN', data={'reason': reason, 
        'admin': admin}, client=target)
        """
        raise NotImplementedError

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        unban a given player on the game server
        """
        raise NotImplementedError

    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        """\
        tempban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN_TEMP', data={'reason': reason, 
        'duration': duration, 'admin': admin}, client=target)
        """
        raise NotImplementedError

    def getMap(self):
        """\
        return the current map/level name
        """
        raise NotImplementedError

    def getNextMap(self):
        """\
        return the next map/level name to be played
        """
        raise NotImplementedError

    def getMaps(self):
        """\
        return the available maps/levels name
        """
        raise NotImplementedError

    def rotateMap(self):
        """\
        load the next map/level
        """
        raise NotImplementedError
        
    def changeMap(self, map_name):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        raise NotImplementedError

    def getPlayerPings(self):
        """\
        returns a dict having players' id for keys and players' ping for values
        """
        raise NotImplementedError

    def getPlayerScores(self):
        """\
        returns a dict having players' id for keys and players' scores for values
        """
        raise NotImplementedError
        
    def inflictCustomPenalty(self, type, client, reason=None, duration=None, admin=None, data=None):
        """
        Called if b3.admin.penalizeClient() does not know a given penalty type. 
        Overwrite this to add customized penalties for your game like 'slap', 'nuke', 
        'mute', 'kill' or anything you want.
        /!\ This method must return True if the penalty was inflicted.
        """
        pass


if __name__ == '__main__':
    import config
    
    parser = Parser(config.load('conf/b3.xml'))
    print parser
    print parser.start()

########NEW FILE########
__FILENAME__ = altitude
# encoding: utf-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 2011-05-01 - 1.0 - Courgette
# * first release. Need work regarding teams and teamkills
# 2011-05-01 - 1.1 - Courgette
# * fix unban
# * add 3 new B3 events : EVT_CLIENT_CONSOLE_COMMAND, EVT_CLIENT_CALL_VOTE and 
#   EVT_CLIENT_VOTE
# * try to fight back when ppl call kick vote against admins
# * unban admins who got kicked to pass by the default 2m tempban on kicks
# * more team ID found. Still need to figure out the game mod that are team based
#   to properly assign B3 team IDs
# 2011-06-05 - 1.2 - Courgette
# * change data format for EVT_CLIENT_BAN_TEMP and EVT_CLIENT_BAN events
#
from b3.events import EVT_CUSTOM
from b3.parser import Parser
import b3
import json
import re
import time

__author__  = 'Courgette'
__version__ = '1.2'


"""
 TIPS FOR CONTRIBUTORS :
 =======================

  * In your main config file, set log level down to 8 to see log message of
    type VERBOS2.  <set name="log_level">8</set>

  * You can add the section below in your b3.xml in order to display the log
    file on your console :
        <settings name="devmode">
            <set name="log2console">true</set>
        </settings>

"""


class AltitudeParser(Parser):
    """B3 parser for the Altitude game. See http://altitudegame.com"""
    
    ## parser code name to use in b3.xml
    gameName = 'altitude'
    
    ## extract the time off a log line
    _lineTime  = re.compile(r'^{"port":[0-9]+, "time":(?P<seconds>[0-9]+),.*')
    
    ## Direct event mapping between Altitude events type and B3 event types.
    ## B3 event will be created with their data parameter set to the full
    ## altitude event object
    _eventMap = {
        'serverStart' : EVT_CUSTOM,
        'mapLoading' : EVT_CUSTOM,
    }
    
    # store the last ping values received for all players in a dict where
    # keys are player slot IDs and values their ping
    _last_ping_report = {}
    
    # store the last stats received for all players in a dict where
    # keys are player slot IDs and values their score
    _last_endround_report = {}


    def startup(self):
        self._initialize_rcon()
        self.clients.newClient(-1, name="WORLD", hide=True)
        # add specific events
        self.Events.createEvent('EVT_CLIENT_CONSOLE_COMMAND', 'Client exec a console command')
        self.Events.createEvent('EVT_CLIENT_CALL_VOTE', 'Client call vote')
        self.Events.createEvent('EVT_CLIENT_VOTE', 'Client vote')
        # listen to some events
        self.registerHandler("EVT_CLIENT_CALL_VOTE", self._OnClientCallVote)

    def _initialize_rcon(self):
        """We need a way to send rcon commands to the gale server. In
        Altitude, this is done by writing commands to be run on a new line
        of the command.txt file"""
        
        # check that the command file is provided in the b3.xml config file
        if not self.config.has_option('server', 'command_file'):
            self.critical("The B3 config file for Altitude must provide the location of the command file")
            self.die()
        
        # open the command file
        commandfile_name = self.config.getpath('server', 'command_file')
        self.output = AltitudeRcon(console=self, commandfile=commandfile_name)

    def parseLine(self, line):
        """method call for each line of the game log file that must return
        a B3 event"""
        ## conveniently, Altitude log lines are encoded in JSON
        ''' Examples of log lines :
{"port":27276,"time":103197,"name":"Courgette test Server","type":"serverInit","maxPlayerCount":14}
{"port":27276,"time":103344,"map":"ball_cave","type":"mapLoading"}
{"port":27276,"time":103682,"type":"serverStart"}
{"port":27276,"demo":false,"time":103691,"level":1,"player":0,"nickname":"Bot 1","aceRank":0,"vaporId":"00000000-0000-0000-0000-000000000000","type":"clientAdd","ip":"0.0.0.0:100001"}
{"port":27276,"demo":false,"time":12108767,"level":9,"player":2,"nickname":"Courgette","aceRank":0,"vaporId":"d8123456-18a4-124e-a45b-155641685161","type":"clientAdd","ip":"192.168.10.1:27272"}
{"port":27276,"time":12110927,"type":"pingSummary","pingByPlayer":{"2":0}}
{"port":27276,"time":12123445,"player":2,"team":2,"type":"teamChange"}
{"port":27276,"time":12124957,"plane":"Loopy","player":1,"perkRed":"Tracker","perkGreen":"Rubberized Hull","team":4,"type":"spawn","perkBlue":"Turbocharger","skin":"Flame Skin"}
{"port":27276,"time":15048305,"streak":0,"source":"turret","player":-1,"victim":1,"multi":0,"xp":10,"type":"kill"}
        '''
        altitude_event = json.loads(line)
        
        if altitude_event['port'] != self._port:
            # One Altitude log file can contain info from multiple servers
            return
        
        ## we will route the handling of that altitude_event to a method dedicated 
        ## to an alititude event type. The method will be name after the event type
        ## capitalized name prefixed by 'OnAltitude'.
        ## I.E.: type 'clientAdd' would route to 'OnAltitudeClientAdd' method
        type = altitude_event['type']
        method_name = "OnAltitude%s%s" % (type[:1].upper(), type[1:])
        event = None
        if not hasattr(self, method_name):
            if type in self._eventMap:
                event = b3.events.Event(self._eventMap[type], data=altitude_event)
            else:
                # no handling method for such event :(
                # we fallback on creating a B3 event of type EVT_UNKNOWN
                self.verbose2("create method %s to handle event %r", method_name, altitude_event)
                event = self.getEvent('EVT_UNKNOWN', data=altitude_event)
        else:
            func = getattr(self, method_name)
            event = func(altitude_event)
        
        # if we came up with a B3 event, then queue it up so it can be dispatched
        # to the listening plugins
        if event:
            self.verbose2("event fired : %s", event)
            self.queueEvent(event)



    # ================================================
    # handle Game events.
    #
    # those methods are called by parseLine() and 
    # may return a B3 Event object
    # ================================================

    def OnAltitudeServerInit(self, altitude_event):
        """ handle log lines of type serverInit
        example :
        {'maxPlayerCount': 14, 
        'type': 'serverInit', 'port': 27276, 
        'name': u'Courgette test Server', 'time': 493}
        """
        ## this events is triggered when the Altitude server starts up
        self.game.sv_hostname = altitude_event['name']
        self.game.sv_maxclients = int(altitude_event['maxPlayerCount'])


    def OnAltitudeClientAdd(self, altitude_event):
        """ handle log lines of type clientAdd
        example :
        {"port":27276,"demo":false,"time":12108767,"level":9,"player":2,"nickname":"Courgette","aceRank":0,"vaporId":"a8654321-123a-414e-c71a-123123123131","type":"clientAdd","ip":"192.168.10.1:27272"}
        """
        ## self.clients is B3 currently connected player store. We tell the client store we got a new one.
        vaporId = altitude_event['vaporId']
        if vaporId == "00000000-0000-0000-0000-000000000000":
            ## we do not want bots to get authenticated
            vaporId = None
        client = self.newClient(altitude_event['player'], guid=vaporId, 
                               name=altitude_event['nickname'], team=b3.TEAM_UNKNOWN, 
                               ip=altitude_event['ip'].split(':')[0])
        client.data = {'level': altitude_event['level'],
                       'aceRank': altitude_event['aceRank']}


    def OnAltitudeClientRemove(self, altitude_event):
        """ handle log lines of type clientRemove
        example :
            {"port":27276, "message":"left", "time":17317434, 
            "player":2, "reason":"Client left.", 
            "nickname":"Courgette", "vaporId":"d6545616-17a3-4044-a74b-121231321321",
            "type":"clientRemove", "ip":"192.168.10.1:27272"}
            
            {"port":27276, "message":"banned for 2 minutes", "time":3300620,
            "player":2, "reason":"Kicked by vote.", "nickname":"Courgette",
            "vaporId":"d6545616-17a3-4044-a74b-121231321321", "type":"clientRemove",
            "ip":"192.168.10.1:27272"}
        """
        c = self.clients.getByGUID(altitude_event['vaporId'])
        if c:
            if altitude_event["reason"] == "Client left.":
                pass
            elif altitude_event["reason"] == "Kicked by vote.":
                ## default Altitude kick is a 2 minute ban, we don't want
                ## moderators and admins to have to wait 2 minutes
                if c.maxLevel > 2:
                    self.write("removeBan %(vaporId)s" % {'vaporId': c.guid})
            else:
                self.verbose2("unknown clientRemove reason : %s", altitude_event['reason'])
            c.disconnect()


    def OnAltitudeChat(self, altitude_event):
        """ handle log lines of type clientRemove
        example :
        {"port":27276,"message":"test","time":326172,"player":2,"server":false,"type":"chat"}

        Unfortunately, there is no distinction between a normal chat and team chat
        {"port":27276,"message":"test team chat","time":1167491,"player":3,"server":false,"type":"chat"}
        """
        c = self.clients.getByCID(altitude_event['player'])
        if c:
            if altitude_event['server'] == False:
                return self.getEvent('EVT_CLIENT_SAY', data=altitude_event['message'], client=c)
            else:
                return self.getEvent('EVT_CUSTOM', data=altitude_event, client=c)


    def OnAltitudeKill(self, altitude_event):
        """ handle log lines of type kill
        example :
        {u'streak': 0, u'multi': 0, u'player': -1, u'source': u'plane', u'victim': 0, u'time': 3571497, u'xp': 10, u'type': u'kill', u'port': 27276}
        """
        '''
        NOTE: there is no team kill in that game
        '''
        attacker = self.clients.getByCID(altitude_event['player'])
        if not attacker:
            self.debug('No attacker!')
            return
        if 'xp' in altitude_event: attacker.currentXP = int(altitude_event['xp'])
        if 'currentStreak' in altitude_event: attacker.currentStreak = altitude_event['currentStreak']

        victim = self.clients.getByCID(altitude_event['victim'])
        if not victim:
            self.debug('No victim!')
            return

        weapon = altitude_event['source']
        if not weapon:
            self.debug('No weapon')
            return

        event = 'EVT_CLIENT_KILL'

        if attacker == victim:
            event = 'EVT_CLIENT_SUICIDE'

        return self.getEvent(event, (100, weapon, None), attacker, victim)
    
    
    def OnAltitudeAssist(self, altitude_event):
        """ handle log lines of type assist
        example :
        {u'player': 2, u'victim': 1, u'time': 10836645, u'xp': 8, u'type': u'assist', u'port': 27276}
        """
        attacker = self.clients.getByCID(altitude_event['player'])
        if not attacker:
            self.debug('No attacker!')
            return
        if 'xp' in altitude_event: attacker.currentXP = int(altitude_event['xp'])
        victim = self.clients.getByCID(altitude_event['victim'])
        if not victim:
            self.debug('No victim!')
            return
        return self.getEvent("EVT_CLIENT_ACTION", data="assist", client=attacker, target=victim)


    def OnAltitudeTeamChange(self, altitude_event):
        """ handle log lines of type teamChange
        example :
        {"port":27276,"time":4768143,"player":2,"team":2,"type":"teamChange"}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            client.team = self.getTeam(altitude_event['team'])
        ## NOTE : the Client.team setter with fire the EVT_CLIENT_TEAM_CHANGE


    def OnAltitudeSpawn(self, altitude_event):
        """ handle log lines of type spawn
        example :
        {u'perkBlue': u'Reverse Thrust', u'team': 8, u'perkGreen': u'Heavy Armor', u'player': 1, u'plane': u'Biplane', u'perkRed': u'Heavy Cannon', u'time': 4454401, u'skin': u'No Skin', u'type': u'spawn', u'port': 27276}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if not client:
            client = self.newClient(altitude_event['player'])
        if client:
            client.data = {"perkBlue": altitude_event["perkBlue"],
                            "perkGreen": altitude_event["perkGreen"],
                            "perkRed": altitude_event["perkRed"],
                            "plane": altitude_event["plane"],
                            "skin": altitude_event["skin"]}
            client.team = self.getTeam(altitude_event['team'])
            return self.getEvent("EVT_CLIENT_JOIN", data=altitude_event, client=client)

    
    def OnAltitudeRoundEnd(self, altitude_event):
        """ handle log lines of type roundEnd
        example :
        {"port":27276,"time":4833834,"participantStatsByName":{"Crashes":[2,4,0,0,0],"Goals Scored":[0,0,0,0,0],"Kills":[22,12,2,0,31],"Damage Received":[1680,4090,100,2570,1540],"Assists":[8,0,1,1,4],"Multikill":[2,0,0,0,2],"Ball Possession Time":[0,0,0,0,0],"Experience":[267,190,24,12,346],"Longest Life":[207,46,61,41,307],"Goals Assisted":[0,0,0,0,0],"Damage Dealt to Enemy Buildings":[0,0,0,0,0],"Deaths":[8,35,0,24,6],"Damage Dealt":[1950,1170,80,250,2540],"Kill Streak":[14,3,2,0,21]},"winnerByAward":{"Best Multikill":0,"Longest Life":10,"Best Kill Streak":10,"Most Deadly":10,"Most Helpful":0},"type":"roundEnd","participants":[0,1,2,7,10]}
        """
        ## don't know yet if saving _last_ping_report will be of any use...
        self._last_endround_report = {"time": altitude_event['time'],
                                      "participantStatsByName": altitude_event['participantStatsByName'], 
                                      "winnerByAward": altitude_event['participantStatsByName'], 
                                      "participants": altitude_event['participants'],
                                      }
        stats = altitude_event['participantStatsByName']
        ## for each player, save his stats in client.lastStats and the number
        ## of kills in client.kills
        for i in range(len(altitude_event['participants'])):
            cid = altitude_event['participants'][i]
            client = self.clients.getByCID(cid)
            if not client: continue
            client.lastStats = {}
            for statname in stats:
                client.lastStats[statname] = stats[statname][i]
            client.kills = client.lastStats['Kills']
        return self.getEvent("EVT_GAME_ROUND_END", data=altitude_event)


    def OnAltitudeMapChange(self, altitude_event):
        """ handle log lines of type mapChange
        example :
        {"port":27276,"time":4847790,"map":"ball_grotto","type":"mapChange","mode":"ball"}
        """
        self.game.mapName = altitude_event['map']
        self.game.mapType = altitude_event['mode']
        return self.getEvent("EVT_GAME_WARMUP", data=altitude_event)


    def OnAltitudePowerupPickup(self, altitude_event):
        """ handle log lines of type powerupPickup
        example :
        {"port":27276,"time":4549268,"powerup":"Homing Missile","player":10,"positionX":3572.41,"positionY":639.57,"type":"powerupPickup"}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            client.lastPosition = (altitude_event['positionX'], altitude_event['positionY'])
            return self.getEvent("EVT_CLIENT_ITEM_PICKUP", data=altitude_event["powerup"], client=client)

    
    def OnAltitudePowerupAutoUse(self, altitude_event):
        """ handle log lines of type powerupAutoUse
        example :
        {"port":27276,"time":4551678,"powerup":"Health","player":10,"positionX":2898,"positionY":285,"type":"powerupAutoUse"}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            client.lastPosition = (altitude_event['positionX'], altitude_event['positionY'])
            return self.getEvent("EVT_CLIENT_ITEM_PICKUP", data=altitude_event["powerup"], client=client)

    
    def OnAltitudePowerupUse(self, altitude_event):
        """ handle log lines of type powerupUse
        example :
        {"port":27276,"velocityX":-8.62,"time":5166541,"powerup":"Homing Missile","player":0,"positionX":2060.43,"velocityY":0.75,"positionY":726.69,"type":"powerupUse"}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            client.lastPosition = (altitude_event['positionX'], altitude_event['positionY'])
            return self.getEvent("EVT_CUSTOM", data=altitude_event, client=client)

    
    def OnAltitudePowerupDefuse(self, altitude_event):
        """ handle log lines of type powerupDefuse
        example :
        {u'positionX': 1416.9, u'powerup': u'Bomb', u'player': 2, u'positionY': 522.83, u'time': 12243874, u'xp': 10, u'type': u'powerupDefuse', u'port': 27276}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            client.lastPosition = (altitude_event['positionX'], altitude_event['positionY'])
            if 'xp' in altitude_event: client.currentXP = int(altitude_event['xp'])
            return self.getEvent("EVT_CLIENT_ACTION", data='defuse', client=client)


    def OnAltitudeGoal(self, altitude_event):
        """ handle log lines of type goal
        example :
        {"port":27276,"time":4927227,"player":1,"xp":50,"type":"goal","assister":-1}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            if 'xp' in altitude_event: client.currentXP = int(altitude_event['xp'])
            return self.getEvent("EVT_CLIENT_ACTION", data="goal", client=client)

    
    def OnAltitudeStructureDamage(self, altitude_event):
        """ handle log lines of type structureDamage
        example :
        {u'target': u'base', u'player': 3, u'time': 11048551, u'xp': 31, u'type': u'structureDamage', u'port': 27276}
        """
        attacker = self.clients.getByCID(altitude_event['player'])
        if not attacker:
            self.debug('No attacker!')
            return
        if 'xp' in altitude_event: attacker.currentXP = int(altitude_event['xp'])
        return self.getEvent("EVT_CLIENT_ACTION", data="structureDamage", client=attacker, target=altitude_event['target'])


    def OnAltitudeStructureDestroy(self, altitude_event):
        """ handle log lines of type structureDestroy
        example :
        {u'target': u'turret', u'player': 3, u'time': 13534409, u'xp': 10, u'type': u'structureDestroy', u'port': 27276}
        """
        client = self.clients.getByCID(altitude_event['player'])
        if client:
            if 'xp' in altitude_event: client.currentXP = int(altitude_event['xp'])
            return self.getEvent("EVT_CLIENT_ACTION", data="structureDestroy", client=client, target=altitude_event['target'])


    def OnAltitudePingSummary(self, altitude_event):
        """ handle log lines of type pingSummary
        example :
        {u'pingByPlayer': {u'10': 138, u'7': 153, u'6': 0}, u'type': u'pingSummary', u'port': 27276, u'time': 4188098}
        """
        self._last_ping_report = altitude_event['pingByPlayer']


    def OnAltitudeConsoleCommandExecute(self, altitude_event):
        """ handle log lines of type consoleCommandExecute
        example :
            {"port":27276, "time":3250286, "arguments":["kick","Courgette"],
            "source":"c0aaf37d-e56d-4431-aa1e-69d5e18be5e6", "command":"vote",
            "group":"Anonymous", "type":"consoleCommandExecute"}
        """
        ## we only handle commands from players and ignore those from server
        if altitude_event['source'] == "00000000-0000-0000-0000-000000000000":
            return
        client = self.clients.getByGUID(altitude_event['source'])
        if not client:
            self.debug("client not found for %s" % altitude_event['source'])
            return
        ## depending on the command, we try to route the handling of that event
        ## to a specific method
        command = altitude_event['command']
        method_name = "OnAltitudeCommand%s%s" % (command[:1].upper(), command[1:])
        event = None
        if not hasattr(self, method_name):
            # no handling method for such command
            # we fallback on creating a generic EVT_CLIENT_CONSOLE_COMMAND event
            self.verbose2("create method %s to handle command %r", method_name, altitude_event)
            event = self.getEvent('EVT_CLIENT_CONSOLE_COMMAND', data=altitude_event, client=client)
        else:
            func = getattr(self, method_name)
            event = func(altitude_event)
        
        return event



    # ==================================================================
    # handle Game events for console commands.
    #
    # those methods are called by OnAltitudeConsoleCommandExecute() and 
    # may return a B3 Event object
    # ==================================================================

    def OnAltitudeCommandVote(self, altitude_event):
        """ handle vote console commands
        example :
            {"port":27276, "time":3250286, "arguments":["kick","Courgette"],
            "source":"c0aaf37d-e56d-4431-aa1e-69d5e18be5e6", "command":"vote",
            "group":"Anonymous", "type":"consoleCommandExecute"}
        """ 
        c = self.clients.getByGUID(altitude_event["vaporId"])
        return self.getEvent("EVT_CLIENT_CALL_VOTE", data=altitude_event, client=c)


    def OnAltitudeCommandCastBallot(self, altitude_event):
        """ handle castBallot console commands
        example :
            {"port":27276,"time":3252183, "arguments":["1"],
            "source":"86e487de-0190-43ff-8e9e-70a14a1751a2",
            "command":"castBallot", "group":"Anonymous",
            "type":"consoleCommandExecute"}
        """ 
        c = self.clients.getByGUID(altitude_event["source"])
        return self.getEvent("EVT_CLIENT_VOTE", data=altitude_event, client=c)



    # =======================================
    # implement parser interface
    # =======================================
    
    def getPlayerList(self):
        """\
        Query the game server for connected players.
        return a dict having players' id for keys and players' data as another dict for values
        """
        ## In most games this does not returns client object as values but here we'll do
        ## Also, we have no way to query the exact list of currently connected
        ## players, so we use the last ping report as they are quite frequent
        players = {}
        for cid in self._last_ping_report.keys():
            client = self.clients.getByCID(cid)
            if client:
                players[cid] = client
        return players

    def authorizeClients(self):
        """\
        For all connected players, fill the client object with properties allowing to find 
        the user in the database (usualy guid, or punkbuster id, ip) and call the 
        Client.auth() method 
        """
        # we don't need anything special to auth clients as the VaporId is supplied
        # on the clientAdd event
        pass
    
    def sync(self):
        """\
        For all connected players returned by self.getPlayerList(), get the matching Client
        object from self.clients (with self.clients.getByCID(cid) or similar methods) and
        look for inconsistencies. If required call the client.disconnect() method to remove
        a client from self.clients.
        This is mainly useful for games where clients are identified by the slot number they
        occupy. On map change, a player A on slot 1 can leave making room for player B who
        connects on slot 1.
        """
        # cannot be implemented as we have no means of retrieving the current player list
        connected_clients = self.getPlayerList()
        for c in self.clients.getList():
            if c.cid not in connected_clients:
                c.disconnect()
        return connected_clients
    
    def say(self, msg):
        """\
        broadcast a message to all players
        """
        self.write('serverMessage %s' % self.stripColors(msg))

    def saybig(self, msg):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        self.say(msg)

    def message(self, client, msg):
        """\
        display a message to a given player
        """
        self.write('serverWhisper %s %s' % (client.name, self.stripColors(msg)))

    def kick(self, clientOrCid, reason='', admin=None, silent=False, *kwargs):
        """\
        kick a given player
        """
        if not isinstance(clientOrCid, b3.clients.Client):
            ## in this game we cannot kick by cid
            return
        else:
            client = clientOrCid
        fullreason = ''
        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)
        if not silent and fullreason != '':
            self.say(fullreason)
        self.write("kick %s" % client.name)
        self.queueEvent(self.getEvent('EVT_CLIENT_KICK', data=reason, client=client))

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        ban a given player
        """
        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)
        if not silent and fullreason != '':
            self.say(fullreason)
        self.write("addBan %(vaporId)s %(duration)s %(timeunit)s %(reason)s" % {
                            'vaporId': client.guid, 
                            'duration': 1, 
                            'timeunit':'forever', 
                            'reason': reason})
        self.write("kick %s" % client.name)
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN', data={'reason': reason, 'admin': admin}, client=client))

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        unban a given player
        """
        self.write("removeBan %(vaporId)s" % {'vaporId': client.guid})
        if admin: admin.message('Unbanned: Removed %s from banlist' %client.name)
        self.queueEvent(self.getEvent('EVT_CLIENT_UNBAN', data=reason, client=client))

    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        """\
        tempban a given player
        """
        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)
        if not silent and fullreason != '':
            self.say(fullreason)
        self.write("addBan %(vaporId)s %(duration)s %(timeunit)s %(reason)s" % {
                            'vaporId': client.guid, 
                            'duration': int(duration), 
                            'timeunit':'minute', 
                            'reason': reason})
        self.write("kick %s" % client.name)
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN_TEMP', data={'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}, client=client))

    def getMap(self):
        """\
        return the current map/level name
        """
        raise NotImplementedError

    def getMaps(self):
        """\
        return the available maps/levels name
        """
        raise NotImplementedError

    def rotateMap(self):
        """\
        load the next map/level
        """
        raise NotImplementedError
        
    def changeMap(self, map):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        self.write("changeMap %s" % map)

    def getPlayerPings(self):
        """\
        returns a dict having players' id for keys and players' ping for values
        """
        return self._last_ping_report

    def getPlayerScores(self):
        """\
        returns a dict having players' id for keys and players' scores for values
        """
        scores = {} 
        for cid, client in self.getPlayerList().items():
            scores[cid] = client.kills
        return scores
        
    def inflictCustomPenalty(self, type, **kwargs):
        """
        Called if b3.admin.penalizeClient() does not know a given penalty type. 
        Overwrite this to add customized penalties for your game like 'slap', 'nuke', 
        'mute' or anything you want.
        /!\ This method must return True if the penalty was inflicted.
        """
        # no other penalty than kick, tempban, ban that I'm aware of
        pass

    
    #===========================================================================
    # a few event listeners
    #===========================================================================

    def _OnClientCallVote(self, b3event):
        """ This game allows anyone to call a kick vote agains an admin.
        Here we keep an eye on every kick vote and if we found someone calling
        a kick vote on a player of higher level, then we kick him """
        ''' example of altitude call vote event :
            {"port":27276, "time":3250286, "arguments":["kick","Courgette"],
            "source":"c0aaf37d-e56d-4431-aa1e-69d5e18be5e6", "command":"vote",
            "group":"Anonymous", "type":"consoleCommandExecute"}
        '''
        altitude_event = b3event.data
        kick_target = self.clients.getByName(altitude_event['arguments'][1])
        vote_caller = b3event.client
        if vote_caller and kick_target:
            if kick_target.maxLevel > vote_caller.maxLevel:
                vote_caller.message("Do not call kick vote against admins")
                time.sleep(2)
                vote_caller.tempban(duration="2m", reason="call vote against higher level admin", data=altitude_event)
                
    
    #===========================================================================
    # overwriting some Parser methods
    #===========================================================================

    def shutdown(self):
        """Shutdown B3"""
        try:
            ## erase Altitude command file content so the Altitude
            ## server wron't try to redo those commands on restart
            self.output.clear()
        except Exception, e:
            self.error(e)
        finally:
            ## call original shutdown()
            Parser.shutdown(self)


    #===========================================================================
    # other methods
    #===========================================================================

    def getTeam(self, teamAltitudeId):
        """convert an Altitude team ID into a B3 team ID
        doc: http://altitudegame.com/forums/showpost.php?p=82191&postcount=30
        """
        if teamAltitudeId == 2:
            return b3.TEAM_SPEC
        elif teamAltitudeId == 3:
            # red
            return b3.TEAM_FREE
        elif teamAltitudeId == 4:
            # blue
            return b3.TEAM_FREE
        elif teamAltitudeId == 5:
            # green
            return b3.TEAM_FREE
        elif teamAltitudeId == 6:
            # yellow
            return b3.TEAM_FREE
        elif teamAltitudeId == 7:
            # orange
            return b3.TEAM_FREE
        elif teamAltitudeId == 8:
            # purple
            return b3.TEAM_FREE
        elif teamAltitudeId == 9:
            # Azure
            return b3.TEAM_FREE
        elif teamAltitudeId == 10:
            # brown/pink ?
            return b3.TEAM_FREE
        elif teamAltitudeId == 11:
            # brown/pink ?
            return b3.TEAM_FREE
        else:
            return b3.TEAM_UNKNOWN

    
    def newClient(self, cid, **kwargs):
        """ create a new client and initialize some Altitude specific 
        attributes"""
        client = self.clients.newClient(cid, **kwargs)
        client.data = {}
        client.lastPosition = None # (x, y) coordinates
        client.kills = None
        client.currentXP = None
        client.currentStreak = None
        client.lastStats = None
        return client


class AltitudeRcon():
    """Object that opens the Altitude command file and allows B3 to write
    commands in it"""
    def __init__(self, console, commandfile):
        self.console = console
        self._commandfile_name = commandfile
        self._fh = open(commandfile, 'a')
        
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        """To send a command to the server, the format to respect is :
        [server port],[command type],[data]
        """
        self.console.verbose(u'RCON :\t %s' % cmd)
        self._fh.write("%s,console,%s\n" % (self.console._port, cmd))
        
    def flush(self):
        try: self._fh.flush()
        except Exception: pass

    def close(self):
        self._fh.close()
        
    def _get_encoding(self):
        return self._fh.encoding
    encoding = property(_get_encoding)
        
    def clear(self):
        """ delete all content off the command file """
        self.close()
        self._fh = open(self._commandfile_name, 'w')
        
########NEW FILE########
__FILENAME__ = arma2
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# CHANGELOG


__author__  = '82ndab-Bravo17'
__version__ = '0.2'

from b3.parsers.battleye.abstractParser import AbstractParser
import b3
import b3.events

class Arma2Parser(AbstractParser):
    gameName = 'arma2'

    def startup(self):
        AbstractParser.startup(self)
        
########NEW FILE########
__FILENAME__ = abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas LEVEIL
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 07/28/2012    0.1     Initial release
# 08/31/2012    0.12    Various fixes and cleanups
# 09/01/2012    0.13    Check for non-verified GUIDs in Player List from server
# 09/01/2012    0.14    Allow for non-ascii names by replacing clients.Client.auth method
# 09/05/2012    0.15    change the way events EVT_CLIENT_CONNECT and EVT_CLIENT_AUTH work
#                       fix EVT_CLIENT_DISCONNECT
# 09/10/2012    0.16    Fix UTF-8 encoding issues
# 09/15/2012    0.17
#   - reduce code size by moving some network code to the protocol module
#   - take advantage of new BattleyeServer.command() behaviour which is synchronous since protocol.py v1.1. This makes the parser much easier to write/read
#   - move all UTF-8 encoding/decoding related code to the protocol module. In the B3 parser code, there is no need to worry about those issues.
#   - remove unused or unnecessary code
#   - fix ban (by cid)
#   - add prefix to say/saybig/message methods
#   - implements getPlayerPings()
#   - add method getBanlist()
# 09/20/1012    0.18
#   - Make restart method work correctly when called from a plugin
# 09/25/2012    0.19
#   - Allow clients with un-verified GUIDs to auth if IP's match the one in the batabase
#   - or optionally allow clients to always auth using the nonVerified GUID's

import sys, re, traceback, time, Queue, threading
from logging import Formatter
from b3.output import VERBOSE2, VERBOSE
import b3.parser
from b3.parsers.battleye.rcon import Rcon as BattleyeRcon
from b3.parsers.battleye.protocol import BattleyeServer, CommandFailedError, CommandError, BattleyeError, NetworkError
import b3.events
import b3.cvar
from b3.clients import Clients

__author__  = '82ndab-Bravo17, Courgette'
__version__ = '0.19'


# disable the authorizing timer that come by default with the b3.clients.Clients class
Clients.authorizeClients = lambda *args, **kwargs: None


# how long should the bot try to connect to the Battleye server before giving out (in second)
GAMESERVER_CONNECTION_WAIT_TIMEOUT = 600


class AbstractParser(b3.parser.Parser):
    """
    An base class to help with developing battleye parsers
    """

    gameName = None

    # hard limit for rcon command admin.say
    SAY_LINE_MAX_LENGTH = 128

    OutputClass = BattleyeRcon
    _serverConnection = None
    _nbConsecutiveConnFailure = 0

    battleye_event_queue = Queue.Queue(400)
    sayqueue = Queue.Queue(100)
    sayqueuelistener = None

    # battleye engine does not support color code, so we need this property
    # in order to get stripColors working
    _reColor = re.compile(r'(\^[0-9])')
    _reSafename = re.compile(r"('|\\)")

    _settings = {
        'line_length': 128,
        'min_wrap_length': 128,
        'message_delay': .8,
        }

    _gameServerVars = () # list available cvar

    _commands = {
        'message': ('say', '%(cid)s', '%(message)s'),
        'say': ('say -1' , '%(message)s'),
        'kick': ('kick', '%(cid)s', '%(reason)s'),
        'ban': ('ban', '%(cid)s', '0', '%(reason)s'),
        'banByGUID': ('addBan', '%(guid)s', '0', '%(reason)s'),
        'unban': ('removeBan', '%(ban_no)s'),
        'tempban': ('ban', '%(cid)s', '%(duration)d', '%(reason)s'),
        'tempbanByGUID': ('addBan', '%(guid)s', '%(duration)d', '%(reason)s'),
        'shutdown': ('#shutdown', ),
        }

    _eventMap = {
    }

    _regPlayer = re.compile(r'^(?P<cid>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9]+)\s+(?P<ping>[0-9-]+)\s+(?P<guid>[0-9a-f]+)\((?P<verified>[A-Z\?]+)\)\s+(?P<name>.*?)$', re.I)
    _regPlayer_lobby = re.compile(r'^(?P<cid>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9]+)\s+(?P<ping>[0-9-]+)\s+(?P<guid>[0-9a-f]+)\((?P<verified>[A-Z\?]+)\)\s+(?P<name>.*?)\s+(?P<lobby>\(Lobby\))$', re.I)
    re_playerlist = re.compile(r'''^\s*(?P<cid>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9]+)\s+(?P<ping>[0-9-]+)\s+(?P<guid>[0-9a-f]+)\((?P<verified>[A-Z\?]+)\)\s+(?P<name>.*?)(?:\s+(?P<lobby>\(Lobby\)))?$''', re.I|re.MULTILINE)
    _useunverifiedguid = False


    # flag to find out if we need to fire a EVT_GAME_ROUND_START event.
    _waiting_for_round_start = True

    def run(self):
        """Main worker thread for B3"""
        self.bot('Start listening ...')
        self.screen.write('Startup Complete : B3 is running! Let\'s get to work!\n\n')
        self.screen.write('(If you run into problems, check %s for detailed log info)\n' % self.config.getpath('b3', 'logfile'))
        #self.screen.flush()

        self.updateDocumentation()

        try:
            b3_log_level = self.config.getint('b3', 'log_level')
        except:
            b3_log_level = VERBOSE

        server_logging = self.load_protocol_logging()

        formatter = Formatter('"%(asctime)s %(name)-15s [%(thread)-6d] %(threadName)-20s %(levelname)-8s %(message)r"')
        ## the block below can activate additional logging for the BattleyeServer class
        if server_logging or b3_log_level == VERBOSE2:
            import logging
            battleyeServerLogger = logging.getLogger("BattleyeServer")
            for handler in logging.getLogger('output').handlers:
                handler.setFormatter(formatter)
                battleyeServerLogger.addHandler(handler)
            battleyeServerLogger.setLevel(logging.INFO)

            if server_logging:
                ## This block will send the logging info to a separate file

                hdlr = logging.FileHandler(server_logging)
                hdlr.setFormatter(formatter)
                battleyeServerLogger.addHandler(hdlr)
                battleyeServerLogger.setLevel(logging.DEBUG)

        while self.working:
            if not self._serverConnection or not self._serverConnection.connected:
                try:
                    self.setup_battleye_connection()
                except CommandError, err:
                    self.error(err.message)
                except IOError, err:
                    self.error("IOError %s"% err)
                except Exception, err:
                    self.error(err)
                    self.exitcode = 220
                    break

            try:
                added, expire, event = self.battleye_event_queue.get(timeout=5)
                self.routeBattleyeEvent(event)
            except Queue.Empty:
                self.verbose2("no game server event to treat in the last 5s")
            except CommandError, err:
                # it does not matter from the parser perspective if Battleye command failed
                # (timeout or bad reply)
                self.warning(err)
            except BattleyeError, e:
                # the connection to the battleye server is lost
                self.warning(e)
                self.close_battleye_connection()
            except Exception, e:
                self.error("unexpected error, please report this on the B3 forums")
                self.error(e)
                # unexpected exception, better close the battleye connection
                self.close_battleye_connection()

        # The Battleye connection is running its own thread to communicate with the game server. We need to tell
        # this thread to stop.
        self.close_battleye_connection()
        self.info("Stop listening for Battleye events")
        self.output.battleye_server = None
        
        # exiting B3
        with self.exiting:
            # If !die or !restart was called, then  we have the lock only after parser.handleevent Thread releases it
            # and set self.working = False and this is one way to get this code is executed.
            # Else there was an unhandled exception above and we end up here. We get the lock instantly.


            # If !die was called, exitcode have been set to 222
            # If !restart was called, exitcode have been set to 221
            # In both cases, the SystemExit exception that triggered exitcode to be filled with an exit value was
            # caught. Now that we are sure that everything was gracefully stopped, we can re-raise the SystemExit
            # exception.
            self.debug('Exiting with exitcode of %s' % self.exitcode)
            time.sleep(5)
            if self.exitcode:
                sys.exit(self.exitcode)


    def setup_battleye_connection(self):
        """
        Setup the Connection to the Battleye server
        """
        self.info('Connecting to battleye server  on %s:%s...' % (self._rconIp, self._rconPort))
        if self._serverConnection:
            self.close_battleye_connection()

        self._serverConnection = BattleyeServer(self._rconIp, self._rconPort, self._rconPassword)
        self.info("Server Connection is %s" % repr(self._serverConnection))
        timeout = GAMESERVER_CONNECTION_WAIT_TIMEOUT + time.time()
        while time.time() < timeout and not self._serverConnection.connected:
            self.info("retrying to connect to game server...")
            time.sleep(2)
            self.close_battleye_connection()
            self._serverConnection = BattleyeServer(self._rconIp, self._rconPort, self._rconPassword)

        if self._serverConnection is None or not self._serverConnection.connected:
            self.error("Could not connect to Battleye server")
            self.close_battleye_connection()
            self.shutdown()
            raise SystemExit()

        # listen for incoming game server events
        self._serverConnection.subscribe(self.OnBattleyeEvent)

        # setup Rcon
        self.output.set_battleye_server(self._serverConnection)

        self.queueEvent(b3.events.Event(b3.events.EVT_GAMESERVER_CONNECT, None))

        self.say('%s ^2[ONLINE]' % b3.version)
        #self.getServerInfo()
        #self.getServerVars()
        self.clients.sync()


    def close_battleye_connection(self):
        try:
            self._serverConnection.stop()
        except Exception:
            pass
        self._serverConnection = None


    def OnBattleyeEvent(self, event):
        if not self.working:
            try:
                self.verbose("dropping Battleye event %r" % event)
            except:
                pass
        self.console(repr(event))
        try:
            self.battleye_event_queue.put((self.time(), self.time() + 10, event), timeout=2)
            self.info('Battleye Event Queue: %s' % repr(self.battleye_event_queue))
        except Queue.Full:
            self.error("Battleye event queue full, dropping event %r" % event)

            
#'RCon admin #0 (76.108.91.78:62382) logged in'
#'Player #0 Bravo17 (76.108.91.78:2304) connected'
#'Player #0 Bravo17 - GUID: 80a5885ebe2420bab5e158a310fcbc7d (unverified)'
#'Verified GUID (80a5885ebe2420bab5e158a310fcbc7d) of player #0 Bravo17'
#'Player #2 NZ (04b81a0bd914e7ba610ef3c0ffd66a1a) has been kicked by BattlEye: Script Restriction #107'
#'Player #4 Kauldron disconnected'
#(Lobby) Bravo17: hello b3'
#(Global) Bravo17: global channel
#Players on server:\n
#[#] [IP Address]:[Port] [Ping] [GUID] [Name]\n
#--------------------------------------------------\n
#0   76.108.91.78:2304     63   80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17\n
#(1 players in total)'

    
#Players on server:\n
#[#] [IP Address]:[Port] [Ping] [GUID] [Name]\n--------------------------------------------------\n
#0   76.108.91.78:2304     63   80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17\n
#(1 players in total)'
    


    def routeBattleyeEvent(self, message):
        """
        Decide what to do with the event received from the BattlEye server
        """

        if message is None:
            self.warning('cannot route empty event')

        self.info('Server Message is %s' % message)

        if message.startswith('RCon admin #'):
            func = self.OnServerMessage
            eventData = message[12:]
        elif message.startswith('Player #'):
            if message.endswith(' disconnected'):
                func = self.OnPlayerLeave
                eventData = message[8:len(message)-13]
            elif message.endswith(' connected'):
                func = self.OnPlayerConnected
                eventData = message[8:len(message)-10]
            elif message.endswith('(unverified)'):
                func = self.OnUnverifiedGUID
                eventData = message[8:len(message)-13]
            elif message.find(' has been kicked by BattlEye: '):
                func = self.OnBattleyeKick
                eventData = message[8:]
            else:
                self.debug('Unhandled server message %s' % message)
                eventData = None
                func = self.OnUnknownEvent
        elif message.startswith('Verified GUID'):
            func = self.OnVerifiedGUID
            eventData = message[15:]
        elif message.startswith('(Lobby)'):
            func = self.OnPlayerChat
            eventData = message[8:] + ' (Lobby)'
        elif message.startswith('(Global)'):
            func = self.OnPlayerChat
            eventData = message[9:] + ' (Global)'
        elif message.startswith('(Direct)'):
            func = self.OnPlayerChat
            eventData = message[9:] + ' (Direct)'
        elif message.startswith('(Vehicle)'):
            func = self.OnPlayerChat
            eventData = message[10:] + ' (Vehicle)'
        elif message.startswith('(Group)'):
            func = self.OnPlayerChat
            eventData = message[8:] + ' (Group)'
        elif message.startswith('(Side)'):
            func = self.OnPlayerChat
            eventData = message[7:] + ' (Side)'
        elif message.startswith('(Command)'):
            func = self.OnPlayerChat
            eventData = message[10:] + ' (Command)'

        else:
            self.debug('Unhandled server message %s' % message)
            eventData = None
            func = self.OnUnknownEvent

        event = func(eventData)
        #self.debug('event : %s' % event)
        if event:
            self.queueEvent(event)


    def startup(self):

        # add specific events
        self.Events.createEvent('EVT_GAMESERVER_CONNECT', 'connected to game server')
        self.Events.createEvent('EVT_CLIENT_SPAWN', 'Client Spawn')
        self.Events.createEvent('EVT_PLAYER_SYNC_COMPLETED', 'Players syncing finished')

        self.load_conf_max_say_line_length()
        self.load_config_message_delay()
        self.load_use_unverified_guid()

        self.start_sayqueue_worker()
        # start crontab to trigger playerlist events
        self.cron + b3.cron.CronTab(self.clients.sync, minute='*/1')
        self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN, squad=None)


    def pluginsStarted(self):
        # self.patch_b3_admin_plugin()
        return


    def sayqueuelistener_worker(self):
        self.info("sayqueuelistener job started")
        while self.working:
            try:
                self._say(self.sayqueue.get(timeout=40))
            except Queue.Empty:
                self.verbose2("sayqueuelistener: had nothing to do in the last 40 sec")
            except Exception, err:
                self.info("sayqueuelistener Error", exc_info=err)
        self.info("sayqueuelistener job ended")


    def _say(self, msg):
        for line in self.getWrap(self.stripColors(self.msgPrefix + ' ' + msg), self._settings['line_length'], self._settings['min_wrap_length']):
            self.write(self.getCommand('say', message=line))
            time.sleep(self._settings['message_delay'])


    def start_sayqueue_worker(self):
        self.sayqueuelistener = threading.Thread(target=self.sayqueuelistener_worker)
        self.sayqueuelistener.setDaemon(True)
        self.sayqueuelistener.start()


    def getCommand(self, cmd, **kwargs):
        """Return a reference to a loaded command"""
        try:
            cmd = self._commands[cmd]
        except KeyError:
            return None

        preparedcmd = []
        for a in cmd:
            try:
                preparedcmd.append(a % kwargs)
            except KeyError:
                pass
        
        result = tuple(preparedcmd)
        self.debug('getCommand: %s', result)
        return result


    def write(self, msg, *args, **kwargs):
        """Write a message to Rcon/Console
        Unfortunately this has been abused all over B3
        and B3 plugins to broadcast text :(
        """
        if isinstance(msg, basestring):
            # console abuse to broadcast text
            self.say(msg)
        else:
            # Then we got a command, so unpack it
            cmd = ' '.join(msg).strip()
            if self.replay:
                self.bot('Sent rcon message: %s' % cmd)
            elif self.output:
                return self.output.write(cmd)


    
    ###############################################################################################
    #
    #    Battleye events handlers
    #    
    ###############################################################################################

    
    def OnPlayerChat(self, data):
        """
        #(Lobby) Bravo17: hello b3'
        #(Global) Bravo17: global channel

        Player has sent a message to other players
        """
        name, sep, message = data.partition(': ')
        self.debug('Name = %s, Message = %s Name length = %s' % (name, message, len(name)))
        
        self.debug('Looking for client [%s]' % name)
        client = self.getClient(name.lower(), auth=False)

        if client is None:
            self.warning("Could not get client :( %s" % traceback.extract_tb(sys.exc_info()[2]))
            return
        if client.cid == 'Server':
            # ignore chat events for Server
            return
        text = message

        # existing commands can be prefixed with a '/' instead of usual prefixes
        cmdPrefix = '!'
        cmd_prefixes = (cmdPrefix, '@', '&')
        admin_plugin = self.getPlugin('admin')
        if admin_plugin:
            cmdPrefix = admin_plugin.cmdPrefix
            cmd_prefixes = (cmdPrefix, admin_plugin.cmdPrefixLoud, admin_plugin.cmdPrefixBig)
        cmd_name = text[1:].split(' ', 1)[0].lower()
        if len(text) >= 2 and text[0] == '/':
            if text[1] in cmd_prefixes:
                text = text[1:]
            elif cmd_name in admin_plugin._commands:
                text = cmdPrefix + text[1:]
            
        if len(text) >= 2:
            cmd_name = text[1:].split(' ', 1)[0]
            if cmd_name in admin_plugin._commands:
                # Remove chat source from end of line
                text = text.rpartition(' ')[0]

        event_type = b3.events.EVT_CLIENT_SAY
        return b3.events.Event(event_type, text, client)
        

    def OnPlayerLeave(self, data):
        """
        #Player #4 Kauldron disconnected
        Player has left the server
        """
        parts = data.split(' ', 1)
        name = parts[1]
        client = self.getClient(name=name, cid=parts[0])
        if client: 
            client.disconnect() # this triggers the EVT_CLIENT_DISCONNECT event
        return None


    def OnPlayerConnected(self, data):
        """
        # Player #0 Bravo17 (76.108.91.78:2304)
        Initial player connect message received
        """

        data = data.rpartition(')')[0]
        data, sep, ip = data.rpartition('(')
        ip = ip.partition(':')[0]
        cid, sep, name = data.partition(' ')
        self.getClient(cid=cid, name=name, ip=ip) # fires EVT_CLIENT_CONNECTED


    def OnUnverifiedGUID(self, data):
        """
        #Player #0 Bravo17 - GUID: 80a5885ebe2420bab5e158a310fcbc7d (unverified)
        Players GUID has been found but not verified, no action to take
        """

        if not self._useunverifiedguid:
            return
        cid, sep, data = data.partition(' ')
        name, sep, guid = data.rpartition(' - GUID: ')
        name = name.strip()
        self.debug('CID: %s Name %s Guid %s' % (cid, name, guid))

        client = self.getClient(name=name, cid=cid, guid=guid)
        if client:
            # update client data
            client.guid = guid
            client.name = name
            client.cid = cid
            # make sure client is now authenticated as we know its guid
            client.auth()
        else:
            self.warning("could not create client")
        

    def OnVerifiedGUID(self, data):
        """
        #Verified GUID  (80a5885ebe2420bab5e158a310fcbc7d) of player #0 Bravo17
        Players GUID has been verified, auth player
        """
        if self._useunverifiedguid:
            return
        guid = data.partition(')')[0]
        data = data .partition('#')[2]
        cid, sep, name = data.partition(' ')

        client = self.getClient(name=name, cid=cid, guid=guid)
        if client:
            # update client data
            client.guid = guid
            client.name = name
            client.cid = cid
            # make sure client is now authenticated as we know its guid
            client.auth()
        else:
            self.warning("could not create client")


    def OnServerMessage(self, data):
        """
        Request: Message from Server
        Effect: None, no messages from server are relevant
        """
        self.debug("Server Message")
        event_type = b3.events.EVT_CLIENT_SAY
        evt = b3.events.Event(event_type, None, None)
        #pass
        return
        

    def OnBattleyeKick(self, data):
        """
        #Player #2 NZ (04b81a0bd914e7ba610ef3c0ffd66a1a) has been kicked by BattlEye: Script Restriction #107'
        Player has been kicked by Battleye
        """

        player, msg, reason = data.partition(') has been kicked by BattlEye: ')
        cid = player.partition(' ')[0]
        guid = player.rpartition('(')[2]
        name = data[len(cid)+1:-len(guid)-len(reason)-33]
        self.debug('Looking for client %s with GUID %s' % (name, guid))
        client = self.getClient(name, guid=guid, auth=False)
        if client: 
            client.disconnect() # this triggers the EVT_CLIENT_DISCONNECT event


    def OnUnknownEvent(self, data):
        return False


    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #    
    ###############################################################################################


    def getClient(self, name, guid=None, cid=None, ip='', auth=True):
        """Get a connected client from storage or create it
        B3 CID   <--> cid
        B3 GUID  <--> guid
        """
        client = None
        if guid:
            # try to get the client from the storage of already authed clients by guid
            client = self.clients.getByGUID(guid)
        if not client:
            # try to get the client from the storage of already authed clients by name
            client = self.clients.getByName(name)
        if auth and not client and cid and name:
            if cid == 'Server':
                return self.clients.newClient('Server', guid='Server', name='Server', hide=True)
            client = self.clients.newClient(cid, guid=guid, name=name, ip=ip)
        return client
    

    
    
    def getPlayerList(self, maxRetries=None):
        """return a dict which keys are cid and values a dict of player properties
        as returned by admin.listPlayers.
        Does not return client objects"""
        #Players on server:\n
        #[#] [IP Address]:[Port] [Ping] [GUID] [Name]\n--------------------------------------------------\n
        #0   76.108.91.78:2304     63   80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17\n
        #0   192.168.0.100:2316    0    80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17 (Lobby)\n
        #(1 players in total)'
        player_list = self.output.write("players").splitlines()
        self.debug('Playerlist is %s' % player_list)
        self.debug('Playerlist is %s long' % (len(player_list)-4))
        players = {}
        for i in range(3, len(player_list)-1):
            p = re.match(self._regPlayer_lobby, player_list[i])
            if p:
                pl = p.groupdict()
                if pl['verified'] =='OK':
                    self.debug('Player: %s' % pl)
                    pl['lobby'] = True
                    players[pl['cid']] = pl
                elif pl['verified'] =='?':
                        self.debug('Player in Lobby GUID not yet verified: %s' % pl)
                        pl['lobby'] = True
                        players[pl['cid']] = pl
                else:
                        self.debug('Player in Lobby GUID status unknown: %s' % pl)
            else:
                p = re.match(self._regPlayer, player_list[i])
                if p:
                    pl = p.groupdict()
                    if pl['verified'] =='OK':
                        self.debug('Player: %s' % pl)
                        pl['lobby'] = False
                        players[pl['cid']] = pl
                    elif pl['verified'] =='?':
                        self.debug('Player GUID not yet verified: %s' % pl)
                        pl['lobby'] = False
                        players[pl['cid']] = pl
                    else:
                        self.debug('Player GUID status unknown: %s' % pl)
                else:
                    self.debug('Not Matched: %s ' % player_list[i])

        self.debug('Players on server: %s' % players)
        return players


    def authorizeClients(self):
        """
        Authorise clients from player list
        """
        pass # no need in this game as we always know player guid and verified status


    def sync(self):
        """
        Sync clients with player list
        """
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            c_guid = c.get('guid', None)
            if client:
                if c_guid == client.guid:
                    self.debug('Client found on server %s' % client.name)
                    mlist[cid] = client
                    self.debug ('Lobby is %s ' % c['lobby'])
                    if c['lobby'] and client.team != self.getTeam('lobby'):
                        self.debug('Putting in Lobby')
                        client.team = self.getTeam('lobby')
                    elif client.team == self.getTeam('lobby') and not c['lobby']:
                        self.debug('Removing from Lobby')
                        client.team = self.getTeam('unknown')
                else:
                    # Wrong client in slot
                    self.debug('Removing %s from list' % client.name)
                    client.disconnect()
            else:
                self.debug('Look for client in storage')
                cl = None
                if c_guid:
                    c_verified = c.get('verified', None)
                    c_ip = c.get('ip', None)
                    if c_verified == 'OK' or self._useunverifiedguid:
                        cl = self.getClient(c['name'], guid=c_guid, cid=c['cid'], ip=c_ip)
                    elif c_ip:
                        # case where guid is not verified but as we have an IP we can try to verify it ourselve
                        client_matches = self.storage.getClientsMatching({'guid': c_guid, 'ip': c_ip})
                        if len(client_matches) == 1:
                            # assume that guid is OK as it matches a known client entry in database with that same IP
                            cl = self.getClient(c['name'], guid=c_guid, cid=c['cid'], ip=c_ip)
                        else:
                            cl = self.getClient(c['name'], guid=None, cid=c['cid'], ip=c_ip)
                    else:
                        cl = self.getClient(c['name'], guid=None, cid=c['cid'], ip=c_ip)
                if cl:
                    mlist[cid] = cl
                    
        # Now we need to remove any players that have left
        if self.clients:
            client_cid_list = []

            for cl in plist.values():
                client_cid_list.append(cl['cid'])

            for client in self.clients.getList():

                if client.cid not in client_cid_list:
                    self.debug('Removing %s from list' % client.name)
                    client.disconnect()
        self.queueEvent(b3.events.Event(b3.events.EVT_PLAYER_SYNC_COMPLETED, None, None))
        
        return mlist


    def say(self, msg):
        self.sayqueue.put(msg)


    def saybig(self, msg):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        self.say(msg)


    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        #'kick': ('kick ', '%(cid)s', '%(reason)s'),

        self.debug('kick reason: [%s]' % reason)
        if isinstance(client, str):
            self.write(self.getCommand('kick', cid=client, reason=reason[:80]))
            return
        
        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))

        if not silent and fullreason != '':
            self.say(fullreason)


    def message(self, client, text):
        if client:
            for line in self.getWrap(self.stripColors(self.msgPrefix + ' ' + text), self._settings['line_length'], self._settings['min_wrap_length']):
                self.write(self.getCommand('message', cid=client.cid, message=line))


    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """Permanent ban"""
        #'ban': ('ban ', '%(cid)s', '0', '%(reason)s'),
        #'banByGUID': ('ban ', '%(guid)s', '0', '%(reason)s'),

        self.debug('BAN : client: %s, reason: %s', client, reason)

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if client.cid is None:
            # ban by guid, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByGUID', guid=client.guid, reason=reason[:80]))
            try:
                self.write(self.getCommand('banByGUID', guid=client.guid, reason=reason[:80]))
                self.write(('writeBans',))
                if admin:
                    admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))
            except CommandFailedError, err:
                self.error(err)
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', cid=client.cid, reason=reason[:80]))
            try:
                self.write(self.getCommand('ban', cid=client.cid, reason=reason[:80]))
                self.write(('writeBans',))
                if admin:
                    admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))
            except CommandFailedError, err:
                self.error(err)

        
        if not silent and fullreason != '':
            self.say(fullreason)
        
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))


    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        if not client or not client.guid:
            return
        bans = self.getBanlist()
        if not client.guid in bans:
            if admin:
                admin.message("%s guid not found in banlist" % client.guid)
            return

        ban_entry = bans[client.guid]
        self.debug('UNBAN: ban index: %s, Name: %s, Guid: %s' %(ban_entry['ban_index'], client.name, client.guid))
        try:
            self.write(self.getCommand('unban', ban_no=ban_entry['ban_index'], reason=reason))
            self.write(('writeBans',))
            #self.verbose(response)
            self.verbose('UNBAN: Removed ban (%s) guid from banlist' % ban_entry['ban_index'])
            if admin:
                admin.message('Unbanned: Removed %s guid from banlist' % client.exactName)
        except CommandFailedError, err:
            if "NotInList" in err.message:
                if admin:
                    admin.message("ban not found in banlist")
            else:
                raise


    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        #'tempban': ('ban ', '%(cid)s', '%(duration)d', '%(reason)s'),
        #'tempbanByGUID': ('ban ', '%(guid)s', '%(duration)d', '%(reason)s'),
        duration = b3.functions.time2minutes(duration)
        if duration < 1:
            # Ban with length of zero will permban a player with Battleye, so do not activate the ban
            return

        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if client.cid is None:
            # ban by guid, this happens when we !tempban @xx a player that is not connected
            try:
                self.write(self.getCommand('tempbanByGUID', guid=client.guid, duration=duration, reason=reason[:80]))
                self.write(('writeBans',))
            except CommandFailedError, err:
                if admin:
                    admin.message("server replied with error %s" % err.message[0])
                else:
                    self.error(err)
        else:
            try:
                self.write(self.getCommand('tempban', cid=client.cid, duration=duration, reason=reason[:80]))
                self.write(('writeBans',))
            except CommandFailedError, err:
                if admin:
                    admin.message("server replied with error %s" % err.message[0])
                else:
                    self.error(err)

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                        , client))

 
    def getMap(self):
        """Return the current level name (not easy map name)"""
        pass


    def getMaps(self):
        """Return the map list for the current rotation. (as easy map names)
        This does not return all available maps
        """
        pass


    def rotateMap(self):
        """\
        load the next map/level
        """
        pass

    def changeMap(self, map_name, gamemode_id=None):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        pass

        
    def getPlayerPings(self):
        """Ask the server for all clients' pings"""
        #Players on server:
        #[#] [IP Address]:[Port] [Ping] [GUID] [Name]\n--------------------------------------------------
        #0   76.108.91.78:2304     63   80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17
        #0   192.168.0.100:2316    0    80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17 (Lobby)
        #(1 players in total)
        pings = {}
        player_list = self.output.write("players")
        for m in re.finditer(self.re_playerlist, player_list):
            if not m.group('lobby'):
                try:
                    pings[m.group('cid')] = int(m.group('ping'))
                except ValueError:
                    pass
        return pings


    def getPlayerScores(self):
        """Ask the server for a given client's team
        """
        scores = {}
        pass

    def getTeam(self, team):
        if team == '0':
            result = b3.TEAM_RED
        elif team == '1':
            result = b3.TEAM_BLUE
        elif team == 'lobby':
            result = b3.TEAM_SPEC
        elif team == 'unknown':
            result = b3.TEAM_UNKNOWN
        else:
            result = b3.TEAM_UNKNOWN
        return result
        

    ###############################################################################################
    #
    #    Other methods
    #    
    ###############################################################################################

    def getBanlist(self):
        #GUID Bans:
        #[#] [GUID] [Minutes left] [Reason]
        #----------------------------------------
        #0  b57cb4973da76f4588936416aae2de05 perm Script Detection: Gerk
        #1  8ac69e7189ecd2ff4235142feff0bd26 perm Script Detection: setVehicleInit DoThis;
        bans = {}
        raw_bans = self.output.write("bans")
        for m in re.finditer(r'''^\s*(?P<ban_index>\d+)\s+(?P<guid>[a-fA-F0-9]+)\s+(?P<min_left>\S+)\s+(?P<reason>.*)$''', raw_bans, re.MULTILINE):
            bans[m.group('guid')] = m.groupdict()
        return bans



    def load_conf_max_say_line_length(self):
        if self.config.has_option(self.gameName, 'max_say_line_length'):
            try:
                maxlength = self.config.getint(self.gameName, 'max_say_line_length')
                if maxlength > self.SAY_LINE_MAX_LENGTH:
                    self.warning('max_say_line_length cannot be greater than %s' % self.SAY_LINE_MAX_LENGTH)
                    maxlength = self.SAY_LINE_MAX_LENGTH
                if maxlength < 20:
                    self.warning('max_say_line_length is way too short. using minimum value 20')
                    maxlength = 20
                self._settings['line_length'] = maxlength
                self._settings['min_wrap_length'] = maxlength
            except Exception, err:
                self.error('failed to read max_say_line_length setting "%s" : %s' % (
                    self.config.get(self.gameName, 'max_say_line_length'), err))
        self.debug('line_length: %s' % self._settings['line_length'])


    def load_config_message_delay(self):
        if self.config.has_option(self.gameName, 'message_delay'):
            try:
                delay_sec = self.config.getfloat(self.gameName, 'message_delay')
                if delay_sec > 3:
                    self.warning('message_delay cannot be greater than 3')
                    delay_sec = 3
                if delay_sec < .5:
                    self.warning('message_delay cannot be less than 0.5 second.')
                    delay_sec = .5
                self._settings['message_delay'] = delay_sec
            except Exception, err:
                self.error(
                    'failed to read message_delay setting "%s" : %s' % (self.config.get(self.gameName, 'message_delay'), err))
        self.debug('message_delay: %s' % self._settings['message_delay'])
        
        
    def load_protocol_logging(self):
        """
        Allow extra logging from protocol.py to be activaed
        """
        if self.config.has_option('b3', 'protocol_log'):
            logfile = self.config.getpath('b3', 'protocol_log')
            return logfile
        else:
            return None
        
    def load_use_unverified_guid(self):
        if self.config.has_option('b3', 'use_unverified_guid'):
            self._useunverifiedguid = self.config.getboolean('b3', 'use_unverified_guid')

        self.debug('Use unverified GUID %s' % self._useunverifiedguid)
        
    def shutdown(self):
        """Shutdown B3"""
        try:
            if self.working and self.exiting.acquire():
                self.bot('Shutting down...')
                self.queueEvent(b3.events.Event(b3.events.EVT_STOP, None))
                for k,plugin in self._plugins.items():
                    self.debug('Stop event running for plugin %s' % plugin)
                    plugin.parseEvent(b3.events.Event(b3.events.EVT_STOP, ''))
                self.bot('Stopping any cron jobs still running....')
                if self._cron:
                    self._cron.stop()

                self.bot('Shutting down database connections...')
                self.storage.shutdown()
        except Exception, e:
            self.error(e)

            
    def restart(self):
        """Stop B3 with the restart exit status (221)"""
        # Need to set this so that if restart is called from within a plugin, and there is no event, exitcode is correctly set
        self.exitcode = 221
        self.shutdown()

        time.sleep(5)

        self.bot('Restarting...')

        sys.exit(221)

    def getWrap(self, text, length=None, minWrapLen=None):
        """Returns a sequence of lines for text that fits within the limits
        """
        if not text:
            return []

        if length is None:
            length = self._settings['line_length']

        maxLength = int(length)

        if len(text) <= maxLength:
            return [text]
        else:
            wrappoint = text[:maxLength].rfind(" ")
            if wrappoint == 0:
                wrappoint = maxLength
            lines = [text[:wrappoint]]
            remaining = text[wrappoint:]
            while len(remaining) > 0:
                if len(remaining) <= maxLength:
                    lines.append(remaining)
                    remaining = ""
                else:
                    wrappoint = remaining[:maxLength].rfind(" ")
                    if wrappoint == 0:
                        wrappoint = maxLength
                    lines.append(remaining[0:wrappoint])
                    remaining = remaining[wrappoint:]
            return lines





########NEW FILE########
__FILENAME__ = protocol
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# Changelog
# ---------
# 1.0.x - 82ndab-Bravo17
#   * implement BattlEye network protocol
#   * fully functional module that can connects to a BattlEye server, send commands, receive packets
#   * external function can subscribe to get notified of received packets (event, command full response or commands response parts)
# 1.1 - Courgette
#   * make sending command synchronous (does not block receiving events though)
#   * external functions subscribing will only be notified of BattlEye events (and won't receive command response packets)
#   * CommandTimeoutError will be raised if a command does not get any response in a timely manner
# 1.1.1 - 82ndab-Bravo17
#   * correct race condition
#
import sys
import logging
import time
import socket
from threading import Thread, Event, Lock
import binascii
import select
import Queue
from collections import deque

__author__ = '82ndab-Bravo17, Courgette'
__version__ = '1.11'

#####################################################################################
#
# USAGE :
#
"""
    def handle_event(data):
        print "EVENT RECEIVED: %s" % data

    conn = BattleyeServer("11.22.33.44", 2304, "*****")

    try:
        # register a function that will get notified of BattlEye events
        conn.subscribe(handle_event)

        # try a one command
        try:
            for line in conn.command('players').split('\n'):
                print "players response : " + line
        except CommandError, err:
            print "command failed : %s" % err

        # let it bake for some time so we can see eventual events being received
        time.sleep(60)
    finally:
        # stop the connection
        conn.stop()
"""
#
#   See fully functional program at the end of this module. To try it out, just run :
#      > c:\python27\python.exe battleye\protocol.py
#
#   and you will be prompted for the BattlEye server ip, port and password.
#
#####################################################################################


# tuple of BattlEye command for which we should not expect any response
COMMANDS_WITH_NO_RESPONSE = ('say', )

class BattleyeError(Exception): pass
class NetworkError(BattleyeError): pass
class CommandError(BattleyeError): pass
class CommandTimeoutError(CommandError): pass
class CommandFailedError(CommandError): pass


class BattleyeServer(Thread):

    def __init__(self, host, port, password):
        Thread.__init__(self, name="BattleyeServerThread")
        #self.logger = logging.getLogger(__name__)
        #hdlr = logging.FileHandler('G:/b3-182/arma/logs/battleye.log')
        #formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
        #hdlr.setFormatter(formatter)
        #self.logger.addHandler(hdlr)
        #self.logger.setLevel(logging.DEBUG)
        self.host = host
        self.port = port
        self.password = password

        self.read_queue = Queue.Queue([]) # get here packets received
        self.write_queue = deque([]) # put here packets to be sent
        self.command_queue = Queue.Queue([]) # put here commands to be sent

        self.sent_data_seq = []
        self._multi_packet_response = {} # some responses comes in multiple parts which are hold in this dict

        self._command_lock = Lock() # only one command than be managed at once. The lock will be set when sending the command and released when a response is received or timeout
        self.pending_command = None # holds the current command we are waitting a response for
        self.pending_command_response = None # holds the current command full response once received
        self.__command_reply_event = Event() # thread event used to notify the thread waitting for a response that the response is available (saves CPU)
        self.command_timeout = 3 # after how long should the thread waitting for the command response decides that no response will ever come

        self.observers = set() # functions to call when a BattleEye event is received
        self._stopEvent = Event() # can make the threads stop


        self.server_thread = Thread(target=self.polling_thread, name="BE_polling")
        self.server_thread.setDaemon(True)
        self.server_thread.start()
        time.sleep(.5)

        self.getLogger().info("start running BattleyeServer")
        self.start()
        time.sleep(1)


    def polling_thread(self):
        """Starts a thread for reading/writing to the Battleye server."""
        self.getLogger().info("connecting to BattlEye server at %s:%s" % (self.host, self.port))
        self._isconnected = False
        self.server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server.connect((self.host, self.port))

        while not self.isStopped():
            #self.getLogger().debug("Is socket ready")
            readable, writable, exception = select.select([self.server],[self.server],[self.server], .5)
            
            if not exception:
                if readable:
                    try:
                        data, addr = self.server.recvfrom(8192)
                        self.read_queue.put(data)
                        self.getLogger().debug("Read data: %s" % repr(data))
                    except socket.error, (value,message): 
                        self.getLogger().error("Socket error %s %s" % (value, message))
                        self.stop()
                if writable:
                    if len(self.write_queue):
                        data = self.write_queue.popleft()
                        self.getLogger().debug("Data to send: %s" % repr(data))
                        try:
                            self.server.send(data)
                        except Exception, err:
                            self.getLogger().error("Data send error, trying again. %s" % err, exc_info=err)
                            self.write_queue.appendleft(data)
                        else:
                            #store seq_no, type, data
                            if data[7:8] == chr(1):
                                seq = ord(data[8:9])
                                self.getLogger().debug("Sent sequence was %s" % seq)
                                self.sent_data_seq.append(seq)
                time.sleep(.05)
            else:
                self.stop()
        self.getLogger().debug("Ending Polling Thread")



    def run(self):
        self.crc_error_count = 0
        self._isconnected = self.login()

        if self._isconnected:

            self.read_thread = Thread(target=self.reading_thread, name="BE_read")
            self.read_thread.setDaemon(True)
            self.read_thread.start()

            self.write_thread = Thread(target=self.writing_thread, name="BE_write")
            self.write_thread.setDaemon(True)
            self.write_thread.start()

        while self._isconnected and not self.isStopped():
            if self.crc_error_count > 10 or len(self.sent_data_seq) > 10:
                self.getLogger().debug('CRC Errors %s   Commands not replied to %s' % (self.crc_error_count, self.sent_data_seq))
                # 10 + consecutive crc errors or 10 commands not replied to
                self.stop()
            time.sleep(10)
        self.getLogger().debug("Ending Server Thread")


    def reading_thread(self):
        self.getLogger().info("Starting Reading Thread")
        while self._isconnected and not self.isStopped():
            try:
                packet = self.read_queue.get(timeout=2)
                type, sequence, data = self.decode_server_packet(packet)
                if type == 2:
                    # Acknowledge server message receipt
                    packet = self.encode_packet(2, sequence, None)
                    self.getLogger().debug("Server Message sequence was %s" % sequence)
                    self.write_queue.append(packet)
                    self._on_event(data.decode('UTF-8', 'replace'))
                elif type == 1:
                    #self.getLogger().debug('Command Response : %s' % repr(data))
                    try:
                        self.sent_data_seq.remove(sequence)
                    except ValueError:
                        pass
                    self.crc_error_count = 0
                    if data[0:1] == chr(0):
                        data = self._handle_multipacket_part(ord(data[1]), ord(data[2]), data[3:])
                    if data:
                        self._on_command_response(data.decode('UTF-8', 'replace'))
                elif type == 255:
                    #CRC Error
                    self.crc_error_count += 1
            except Queue.Empty:
                pass
            except Exception, err:
                self.getLogger().error("error in reading_thread", exc_info=err)
                
        self.getLogger().info("Ending Reading Thread")


    def writing_thread(self):
        self.getLogger().info("Starting Writing Thread")

        self.write_seq = 0
        self.last_write_time = time.time()

        def enqueue_packet(data):
            self.write_queue.append(self.encode_packet(1, self.write_seq, data))
            self.last_write_time = time.time()
            self.write_seq += 1
            if self.write_seq > 255:
                self.write_seq -= 256

        while self._isconnected and not self.isStopped():
            try:
                enqueue_packet(self.command_queue.get(timeout=2))
            except Queue.Empty:
                if self.last_write_time + 30 < time.time():
                    enqueue_packet(None) # keep connection alive
            except Exception, err:
                self.getLogger().error("error in writing_thread", exc_info=err)
        self.getLogger().info("Ending Writing Thread")


    def login(self):
        """authenticate on the Battleye server with given password"""
        self.getLogger().info("Starting Login")
        request =  self.encode_packet(0, None, self.password)
#        self.getLogger().debug(self.write_queue)
        self.write_queue.append(request)
#        self.getLogger().debug(self.write_queue)
        login_response = False
        t = time.time()
        logged_in = None
        while time.time() < t+3 and not login_response:
            try:
                packet = self.read_queue.get(timeout = 0.1)
                type, logged_in, data =  self.decode_server_packet(packet)
                self.getLogger().debug("login response was %s %s %s" % (type, logged_in, data))
                if type == chr(255):
                    self.getLogger().warning('Invalid packet')
                elif type == 0:
                    login_response = True
            except Queue.Empty:
                pass

        if login_response:
            if logged_in == 1:
                self.getLogger().info("Login Successful")
                return True
        else:
            self.getLogger().warning("Login Failed")
            return False


    def _disconnect(self):
        self.getLogger().info("Disconnecting")
        if self._isconnected:
            try:
                self.server.close()
            except:
                pass
            self._isconnected = False


    def command(self, cmd, timeout=None):
        if not cmd:
            return
        if not self._isconnected:
            raise NetworkError("not connected to BattlEye server")
        if self.isStopped():
            raise BattleyeError("BattlEyeServer stopped")


        self._command_lock.acquire() # this will eventually wait for the lock to be released
        try:
            if timeout or not any(filter(lambda x: cmd.startswith(x + ' '), COMMANDS_WITH_NO_RESPONSE)):
                return self._command_and_wait(cmd, timeout)
            else:
                return self._command_no_wait(cmd)
        except CommandTimeoutError:
            raise
        except BattleyeError:
            raise
        except Exception, err:
            type, value, traceback = sys.exc_info()
            raise CommandFailedError, ("command \"%s\" failed: %s" % (cmd, err), type, value), traceback
        finally:
            self._command_lock.release() # release the lock so another command can be sent


    def _command_no_wait(self, cmd):
        """send a command and do not expect any response"""
        self.command_queue.put(cmd)


    def _command_and_wait(self, cmd, timeout=None):
        """send command to the BattlEye server in a synchronous way.
        Calling this method will block until we receive the command response from the
        game server or until we reach the timeout.
        """
        self.pending_command = cmd
        self.pending_command_response = None
        self._command_no_wait(cmd)
        response = self._wait_for_response(timeout)
        if response == "Unknown command":
            raise CommandFailedError("Unknown command: %s" % cmd)
        return response


    def _wait_for_response(self, timeout):
        """block until response to for the current command has been received or until timeout is reached."""
        if self.isStopped():
            return

        if timeout is None:
            timeout = self.command_timeout

        self.getLogger().debug("waiting response for command: %s " % self.pending_command)
        self.__command_reply_event.clear()
        self.__command_reply_event.wait(timeout) # will wait until either the __command_reply_event is set or command_timeout is reached

        cmd = self.pending_command
        self.pending_command = None

        response = self.pending_command_response
        self.pending_command_response = None

        if not response:
            # then we stopped waitting because the timeout is reached
            raise CommandTimeoutError("no response for command : %s" % cmd)
        else:
            # we have our response \o/
            return response


    def compute_crc(self, data):
        buf = buffer(data)
        crc = binascii.crc32(buf) & 0xffffffff
        crc32 = '0x%08x' % crc
        # self.getLogger().debug("crc32 = %s" % crc)
        return int(crc32[8:10], 16), int(crc32[6:8], 16), int(crc32[4:6], 16), int(crc32[2:4], 16)


    def decode_server_packet(self, packet):
        if packet[0:2] != b'BE':
            return 255, '', ''

        packet_crc = packet[2:6]
        #self.getLogger().debug("Packet crc: %s" % repr(packet_crc))
        crc1, crc2, crc3, crc4 =  self.compute_crc(packet[6:])
        computed_crc = chr(crc1) + chr(crc2) + chr(crc3) + chr(crc4)
        # self.getLogger().debug("Computed crc: %s" % repr(computed_crc))
        if packet_crc != computed_crc:
            self.getLogger().debug('Invalid crc')
            return 255, '', ''

        type = ord(packet[7:8])
        sequence_no = ord(packet[8:9])
        data = packet[9:]
        return type, sequence_no, data


    def encode_packet(self, packet_type, seq, data):
        data_to_send = bytearray()

        #self.getLogger().debug('Encoded data is %s' % data)
        #data_to_send = data_to_send + chr(255) + packet_type + bytearray(data, 'Latin-1', 'ignore')
        data_to_send.append(255)
        data_to_send.append(packet_type)
        if seq is not None:
            data_to_send.append(seq)
        if data:
            data_to_send.extend(unicode(data).encode('UTF-8', 'replace'))
        crc1, crc2, crc3, crc4 = self.compute_crc(data_to_send)
        # request =  "B" + "E" + chr(crc1) + chr(crc2) + chr(crc3) + chr(crc4) + data_to_send
        request = bytearray(b'BE')
        request.append(crc1)
        request.append(crc2)
        request.append(crc3)
        request.append(crc4)
        request.extend(data_to_send)
        #self.getLogger().debug("Request is type : %s" % type(request))
        return request


    def _handle_multipacket_part(self, total_num_packets, current_packet_index, data):
        """Command responses can be received over multiple packest"""
        self._multi_packet_response[current_packet_index] = data
        if current_packet_index == total_num_packets - 1:
            # we got all the packets that make a full command response
            data = ''
            for p in range(0, total_num_packets):
                if len(self._multi_packet_response[p]):
                    data = data + self._multi_packet_response[p]
                else:
                    self.debug('Part of Multi packet response is missing')
                    for pp in range(0, total_num_packets-1):
                        self._multi_packet_response[pp] = ''
                    return

            # Packet reconstituted, so delete segments
            for pp in range(0, total_num_packets-1):
                del self._multi_packet_response[pp]

            return data
        else:
            return


    def _on_event(self, message):
        """We received a full Server message packet (type 2 BattlEye packet)"""
        self.getLogger().debug("received BattlEye event : %s" % message)
        for func in self.observers:
            func(message)


    def _on_command_response(self, message):
        """We received a full Command response message (one or more type 1 BattlEye packets)"""
        self.getLogger().debug("received BattlEye command response : %s" % message)
        self.pending_command_response = message
        self.__command_reply_event.set() # notify the waitting thread that a response is ready


    def __getattr__(self, name):
        if name == 'connected':
            return self._isconnected
        else:
            return self.name


    def getLogger(self):
        return logging.getLogger("BattleyeServer")


    def subscribe(self, func):
        """Add func from Battleye events listeners."""
        self.getLogger().info("func %s subscribed to BattlEye events" % func)
        self.observers.add(func)


    def unsubscribe(self, func):
        """Remove func from Battleye events listeners."""
        self.getLogger().info("func %s unsubscribed to BattlEye events" % func)
        self.observers.remove(func)


    def stop(self):
        self.getLogger().debug("stopping Threads...")
        self._stopEvent.set()
        self._disconnect()


    def isStopped(self):
        return self._stopEvent.is_set()


########################################################################################################################
# Example program
if __name__ == '__main__':

    import sys, os
    from ConfigParser import SafeConfigParser
    from random import sample, random

    print "Remote administration event listener for BattlEye"

    host = port = pw = None

    # load previous config
    test_config_file = os.path.join(os.path.dirname(__file__), 'test_rcon.ini')
    if os.path.isfile(test_config_file):
        try:
            conf = SafeConfigParser()
            conf.read(test_config_file)
            host = conf.get("server", "host")
            port = int(conf.get("server", "port"))
            pw = conf.get("server", "password")
        except:
            pass

    # prompt user if missing config info
    if not host and not port and not pw:
        if len(sys.argv) != 4:
            host = raw_input('Enter game server host IP/name: ')
            port = int(raw_input('Enter host port: '))
            pw = raw_input('Enter password: ')
        else:
            host = sys.argv[1]
            port = int(sys.argv[2])
            pw = sys.argv[3]

    # save config
    with open(test_config_file, "w") as f:
        conf = SafeConfigParser()
        conf.add_section('server')
        conf.set("server", "host", host)
        conf.set("server", "port", str(port))
        conf.set("server", "password", pw)
        conf.write(f)


    # prepare a class that will be able to spam commands randomly
    class CommandRequester(Thread):
        """Thread that spams commands"""
        _stop = Event()
        nb_instances = 0
        def __init__(self, battleye_server, commands=('status',), delay=5):
            self.__class__.nb_instances += 1
            Thread.__init__(self, name="CommandRequester%s" % self.__class__.nb_instances)
            self.battleye_server = battleye_server
            self.commands = commands
            self.delay = delay

        def getLogger(self):
            return logging.getLogger("CommandRequester")

        def run(self):
            self.getLogger().info("starting spamming commands")
            while not self.__class__._stop.is_set():
                cmd = sample(self.commands, 1)[0]
                self.getLogger().info("###\trequesting \t%s" % repr(cmd))
                try:
                    response = self.battleye_server.command(cmd)
                    self.getLogger().info("###\treceived \t%s" % repr(response))
                except CommandError, err:
                    self.getLogger().info("###\tcommand failed \t%s" % repr(err.message))
                time.sleep(self.delay + random())
            self.getLogger().info("stopped spamming commands")

        @classmethod
        def stopAll(cls):
            cls._stop.set()



    # setup logging
    logging.basicConfig(level=logging.INFO, format="%(name)-20s [%(thread)-4d] %(threadName)-15s %(levelname)-8s %(message)s")
    logging.info("here we go")


    # prepare a function that will subscribe to BattleEye events
    def battleyeEventListener(event):
        print "BATTLEYE EVENT: %s" % event


    # connect to the BattlEye server
    t_conn = BattleyeServer(host, port, pw)

    try:
        t_conn.subscribe(battleyeEventListener)

        # 1st try just one command
        for line in t_conn.command('players').split('\n'):
            print "players response : " + line

        time.sleep(1)
        # unleash the command spammers !
        CommandRequester(t_conn, ('bans', 'missions', 'players', 'f00', 'say -1 hello', u'say -1 ---- b ----')).start()
        time.sleep(.5)
        CommandRequester(t_conn, ('bans', 'missions', 'players', 'f00', 'say -1 hello', u'say -1 ---- b ----')).start()
        time.sleep(.5)
        CommandRequester(t_conn, ('bans', 'missions', 'players', 'f00', 'say -1 hello', u'say -1 ---- b ----')).start()

        # let it bake for some time
        time.sleep(20)

    finally:
        # clean our mess
        t_conn.stop()
        CommandRequester.stopAll()
        logging.info("here we die")


########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas LEVEIL
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#


"""
dummy rcon module for Battleye to satisfy B3 parser. 

Ideally, B3 parser should be changed to allow games to 
not require a separated socket connection for rcon commands

To use that Rcon class, instantiate and use the set_battleye_server() method. 
Then you can expect this class to work like the other Rcon classes
"""
from b3.parsers.battleye.protocol import CommandError, CommandTimeoutError

__author__  = 'Courgette'
__version__ = '1.1'

#--------------------------------------------------------------------------------------------------
class Rcon:
    def __init__(self, console, *args):
        self.console = console
        self.battleye_server = None
        
    def set_battleye_server(self, battleye_server):
        self.battleye_server = battleye_server
    
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        if not self.battleye_server or not self.battleye_server.connected:
            return
        self.console.bot(u'RCON > %s' % repr(cmd))
        response = None
        try:
            response = self.battleye_server.command(cmd)
            self.console.bot(u'RCON < %s' % repr(response))
        except CommandTimeoutError, err:
            self.console.error("RCON # %s" % err)
        except CommandError, err:
            self.console.error("RCON ERROR : %s" % err, exc_info=err)
        return response
        
    def flush(self):
        pass

    def close(self):
        pass

########NEW FILE########
__FILENAME__ = bf3
#
# Battlefield 3 Parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 Thomas LEVEIL <courgette@bigbrotherbot.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# versions that only reflect changes to AbstractParser :
# 1.0.1 -> 1.0.3
# 1.1.1 -> 1.1.6
# 1.2.1 -> 1.2.1
# 1.4.1, 1.6
#
# CHANGELOG
#
# 0.1
#  functional parser but BF3 admin protocol is not fully implemented on the BF3 side. See TODOs
# 1.0
#  update parser for BF3 R20
# 1.1
#  reflects changes in AbstractParser and refactor the class by moving some of the code to AbstractParser
# 1.2
#  reflects changes in AbstractParser due to BF3 server R21 release
# 1.3
#  BF3 server R24 changes
# 1.4
#  add available gamemodes by map
#  check minimum required BF3 server version on startup
#  fix issue from 1.3 that made impossible to use commands related to Close Quarter maps
# 1.5
#  add new maps and gamemode from DLC "Armored Kill"
# 1.7
#  add new maps and gamemode from DLC "Aftermath"
# 1.8
#  add GUNMASTER_WEAPONS_PRESET_BY_INDEX and GUNMASTER_WEAPONS_PRESET_BY_NAME constants
# 1.8.1
#  add new maps and gamemodes from DLC "End Game"
#  implement getPlayerPings
#
from b3.parsers.frostbite2.abstractParser import AbstractParser
from b3.parsers.frostbite2.util import PlayerInfoBlock
import b3
import b3.events
__author__  = 'Courgette'
__version__ = '1.8.1'

BF3_REQUIRED_VERSION = 1149977

SQUAD_NOSQUAD = 0
SQUAD_ALPHA = 1
SQUAD_BRAVO = 2
SQUAD_CHARLIE = 3
SQUAD_DELTA = 4
SQUAD_ECHO = 5
SQUAD_FOXTROT = 6
SQUAD_GOLF = 7
SQUAD_HOTEL = 8
SQUAD_INDIA = 9
SQUAD_JULIET = 10
SQUAD_KILO = 11
SQUAD_LIMA = 12
SQUAD_MIKE = 13
SQUAD_NOVEMBER = 14
SQUAD_OSCAR = 15
SQUAD_PAPA = 16
SQUAD_QUEBEC = 17
SQUAD_ROMEO = 18
SQUAD_SIERRA = 19
SQUAD_TANGO = 20
SQUAD_UNIFORM = 21
SQUAD_VICTOR = 22
SQUAD_WHISKEY = 23
SQUAD_XRAY = 24
SQUAD_YANKEE = 25
SQUAD_ZULU = 26
SQUAD_HAGGARD = 27
SQUAD_SWEETWATER = 28
SQUAD_PRESTON = 29
SQUAD_REDFORD = 30
SQUAD_FAITH = 31
SQUAD_CELESTE  = 32

SQUAD_NAMES = {
    SQUAD_ALPHA: "Alpha",
    SQUAD_BRAVO: "Bravo",
    SQUAD_CHARLIE: "Charlie",
    SQUAD_DELTA: "Delta",
    SQUAD_ECHO: "Echo",
    SQUAD_FOXTROT: "Foxtrot",
    SQUAD_GOLF: "Golf",
    SQUAD_HOTEL: "Hotel",
    SQUAD_INDIA: "India",
    SQUAD_JULIET: "Juliet",
    SQUAD_KILO: "Kilo",
    SQUAD_LIMA: "Lima",
    SQUAD_MIKE: "Mike",
    SQUAD_NOVEMBER: "November",
    SQUAD_OSCAR: "Oscar",
    SQUAD_PAPA: "Papa",
    SQUAD_QUEBEC: "Quebec",
    SQUAD_ROMEO: "Romeo",
    SQUAD_SIERRA: "Sierra",
    SQUAD_TANGO: "Tango",
    SQUAD_UNIFORM: "Uniform",
    SQUAD_VICTOR: "Victor",
    SQUAD_WHISKEY: "Whiskey",
    SQUAD_XRAY: "Xray",
    SQUAD_YANKEE: "Yankee",
    SQUAD_ZULU: "Zulu",
    SQUAD_HAGGARD: "Haggard",
    SQUAD_SWEETWATER: "Sweetwater",
    SQUAD_PRESTON: "Preston",
    SQUAD_REDFORD: "Redford",
    SQUAD_FAITH: "Faith",
    SQUAD_CELESTE: "Celeste"
}

GAME_MODES_NAMES = {
    "ConquestLarge0": "Conquest64",
    "ConquestSmall0": "Conquest",
    "ConquestAssaultLarge0": "Conquest Assault64",
    "ConquestAssaultSmall0": "Conquest Assault",
    "ConquestAssaultSmall1": "Conquest Assault alt.2",
    "RushLarge0": "Rush",
    "SquadRush0": "Squad Rush",
    "SquadDeathMatch0": "Squad Deathmatch",
    "TeamDeathMatch0": "Team Deathmatch",
    "Domination0": "Conquest Domination",
    "GunMaster0": "Gun master",
    "TeamDeathMatchC0": "TDM Close Quarters",
    "TankSuperiority0": "Tank Superiority",
    "Scavenger0": "Scavenger",
    "AirSuperiority0": "Air Superiority",
    "CaptureTheFlag0": "Capture the Flag",
}

GAMEMODES_IDS_BY_NAME = dict()
for _id, name in GAME_MODES_NAMES.items():
    GAMEMODES_IDS_BY_NAME[name.lower()] = _id

MAP_NAME_BY_ID = {
    'MP_001': 'Grand Bazaar',
    'MP_003': 'Tehran Highway',
    'MP_007': 'Caspian Border',
    'MP_011': 'Seine Crossing',
    'MP_012': 'Operation Firestorm',
    'MP_013': 'Damavand Peak',
    'MP_017': 'Noshahar Canals',
    'MP_018': 'Kharg Island',
    'MP_Subway': 'Operation Metro',
    'XP1_001': 'Strike At Karkand',
    'XP1_002': 'Gulf of Oman',
    'XP1_003': 'Sharqi Peninsula',
    'XP1_004': 'Wake Island',
    "XP2_Factory": "Scrapmetal",
    "XP2_Office": "Operation 925",
    "XP2_Palace": "Donya Fortress",
    "XP2_Skybar": "Ziba Tower",
    "XP3_Desert": "Bandar Desert",
    "XP3_Alborz": "Alborz Mountains",
    "XP3_Shield": "Armored Shield",
    "XP3_Valley": "Death Valley",
    "XP4_Quake": "Epicenter",
    "XP4_FD": "Markaz Monolith",
    "XP4_Parl": "Azadi Palace",
    "XP4_Rubble": "Talah market",
    "XP5_001": "Operation Riverside",
    "XP5_002": "Nebandan Flats",
    "XP5_003": "Kiasar Railroad",
    "XP5_004": "Sabalan Pipeline",
}

MAP_ID_BY_NAME = dict()
for _id, name in MAP_NAME_BY_ID.items():
    MAP_ID_BY_NAME[name.lower()] = _id

GAME_MODES_BY_MAP_ID = {
    "MP_001": ("ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_003": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_007": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_011": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_012": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_013": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_017": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_018": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "MP_Subway": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP1_001": (
        "ConquestAssaultLarge0", "ConquestAssaultSmall0", "ConquestAssaultSmall1", "RushLarge0", "SquadRush0",
        "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP1_002": ("ConquestLarge0", "ConquestSmall0", "ConquestAssaultSmall0", "RushLarge0", "SquadRush0",
                "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP1_003": ("ConquestAssaultLarge0", "ConquestAssaultSmall0", "ConquestAssaultSmall1", "RushLarge0", "SquadRush0",
                "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP1_004": ("ConquestAssaultLarge0", "ConquestAssaultSmall0", "ConquestAssaultSmall1", "RushLarge0", "SquadRush0",
                "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP2_Factory": ("TeamDeathMatchC0", "GunMaster0", "Domination0", "SquadDeathMatch0"),
    "XP2_Office": ("TeamDeathMatchC0", "GunMaster0", "Domination0", "SquadDeathMatch0"),
    "XP2_Palace": ("TeamDeathMatchC0", "GunMaster0", "Domination0", "SquadDeathMatch0"),
    "XP2_Skybar": ("TeamDeathMatchC0", "GunMaster0", "Domination0", "SquadDeathMatch0"),
    "XP3_Desert": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "TankSuperiority0"),
    "XP3_Alborz": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "TankSuperiority0"),
    "XP3_Shield": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "TankSuperiority0"),
    "XP3_Valley": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "TankSuperiority0"),
    "XP4_Quake": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "GunMaster0", "Scavenger0"),
    "XP4_FD": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "GunMaster0", "Scavenger0"),
    "XP4_Parl": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "GunMaster0", "Scavenger0"),
    "XP4_Rubble": (
        "ConquestLarge0", "ConquestSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0",
        "GunMaster0", "Scavenger0"),
    "XP5_001": (
        "CaptureTheFlag0", "AirSuperiority0", "ConquestLarge0", "ConquestAssaultLarge0", "ConquestSmall0",
        "ConquestAssaultSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP5_002": (
        "CaptureTheFlag0", "AirSuperiority0", "ConquestLarge0", "ConquestAssaultLarge0", "ConquestSmall0",
        "ConquestAssaultSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP5_003": (
        "CaptureTheFlag0", "AirSuperiority0", "ConquestLarge0", "ConquestAssaultLarge0", "ConquestSmall0",
        "ConquestAssaultSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),
    "XP5_004": (
        "CaptureTheFlag0", "AirSuperiority0", "ConquestLarge0", "ConquestAssaultLarge0", "ConquestSmall0",
        "ConquestAssaultSmall0", "RushLarge0", "SquadRush0", "SquadDeathMatch0", "TeamDeathMatch0"),

}

GUNMASTER_WEAPONS_PRESET_BY_INDEX = [
    ["Standard Weapon list", ["MP443", "M93", "T44", "PP-19", "P90", "SPAS-12", "MK3A1 Flechette", "ACW-R", "MTAR", "AUG", "SCAR-L", "LSAT", "L86", "M417", "JNG-90", "M320 LVG", "Knife"]],
    ["Standard Weapon list REVERSED", ["JNG-90", "M417", "L86", "LSAT", "SCAR-L", "AUG", "MTAR", "ACW-R", "MK3A1 Flechette", "SPAS-12", "P90", "PP-19", "T44", "M93", "MP443", "M320 LVG, Knife"]],
    ["Light Weight", ["M9", "Glock17", "M93", "870", "Saiga12", "Spas-12", "Dao-12", "M1014", "PP2000", "M5K", "P90", "MP7", "ASVal", "PP-19", "UMP45", "M320 GL", "Knife"]],
    ["Heavy Gear", ["MP412Rex", "T44", "SPAS-12 Slugs", "MK3A3 slugs", "AK47M", "F2000", "G3A3", "FAMAS", "SCAR-L", "SteyrAug", "M249", "M60", "QBB-95", "MG36", "LSAT, C4, Knife"]],
    ["Pistol run!", ["M9", "MP443", "G17c", "M9 Suppressed", "G17 Suppressed", "M1911", "Glock18", "M93", "MP12rex", "Taurus44", "Knife"]],
    ["Snipers Heaven", ["M9 Suppressor", "Glock17 Suppressor", "M1911 Suppressor", "SVD", "SKS", "MK11", "QBU-88", "M417", "M40A5", "SV98", "L96", "JNG90", "M98B", "Crossbow Bolt, Knife"]],
    ["US arms race", ["M9", "M1911", "M870", "PDW-R", "M4A1", "M16", "M249", "M240", "MK11", "M40A5", "SMAW", "Knife"]],
    ["RU arms race", ["MP443", ".412 rex", "Saiga 12k", "PP-2000", "PP-19", "AS Val", "AKS-74u", "AK74M", "RPK-74", "SVD", "RPG-7", "Knife"]],
    ["EU arms race", ["G17", "M93R", "SPAS-12", "MP7", "UMP", "G36", "M416", "L85", "MG36", "M417", "M320 GL", "Knife"]],
    ]

GUNMASTER_WEAPONS_PRESET_BY_NAME = dict(GUNMASTER_WEAPONS_PRESET_BY_INDEX)


class Bf3Parser(AbstractParser):
    gameName = 'bf3'

    _gameServerVars = (
        '3dSpotting',
        '3pCam',
        'autoBalance',
        'bannerUrl',
        'bulletDamage',
        'friendlyFire',
        'gameModeCounter',
        'gamePassword',
        'hud',
        'idleBanRounds',
        'idleTimeout',
        'killCam',
        'killRotation',
        'maxPlayers',
        'minimap',
        'minimapSpotting',
        'nameTag',
        'onlySquadLeaderSpawn',
        'playerManDownTime',
        'playerRespawnTime',
        'ranked',
        'regenerateHealth',
        'roundLockdownCountdown',
        'roundRestartPlayerCount',
        'roundStartPlayerCount',
        'roundsPerMap',
        'serverDescription',
        'serverMessage',
        'serverName',
        'soldierHealth',
        'teamKillCountForKick',
        'teamKillKickForBan',
        'teamKillValueDecreasePerSecond',
        'teamKillValueForKick',
        'teamKillValueIncrease',
        'unlockMode',
        'vehicleSpawnAllowed',
        'vehicleSpawnDelay',
        'premiumStatus',
        'gunMasterWeaponsPreset'
    )


    def startup(self):
        AbstractParser.startup(self)

        # create the 'Server' client
        self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN, squad=None)

        self.verbose('GameType: %s, Map: %s' %(self.game.gameType, self.game.mapName))


    def pluginsStarted(self):
        AbstractParser.pluginsStarted(self)
        self.info('connecting all players...')
        plist = self.getPlayerList()
        for cid, p in plist.iteritems():
            client = self.clients.getByCID(cid)
            if not client:
                #self.clients.newClient(playerdata['cid'], guid=playerdata['guid'], name=playerdata['name'], team=playerdata['team'], squad=playerdata['squad'])
                name = p['name']
                self.debug('client %s found on the server' % cid)
                client = self.clients.newClient(cid, guid=p['name'], name=name, team=p['teamId'], squad=p['squadId'], data=p)
                self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))




    ###############################################################################################
    #
    #    Frostbite2 events handlers
    #    
    ###############################################################################################

    def OnPlayerTeamchange(self, action, data):
        """
        player.onTeamChange <soldier name: player name> <team: Team ID> <squad: Squad ID>
        Effect: Player might have changed team
        """
        # ['player.switchTeam', 'Cucurbitaceae', '1', '0']
        client = self.getClient(data[0])
        if client:
            client.squad = int(data[2])
            client.teamId = int(data[1])
            client.team = self.getTeam(data[1]) # .team setter will send team change event


    def OnPlayerSquadchange(self, action, data):
        """
        player.onSquadChange <soldier name: player name> <team: Team ID> <squad: Squad ID>    
        
        Effect: Player might have changed squad
        NOTE: this event also happens after a player left the game
        """
        client = self.clients.getByCID(data[0])
        if client:
            previous_squad = client.squad
            client.squad = int(data[2])
            client.teamId = int(data[1])
            client.team = self.getTeam(data[1]) # .team setter will send team change event
            if client.squad != previous_squad:
                return b3.events.Event(b3.events.EVT_CLIENT_SQUAD_CHANGE, data[1:], client)


    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #    
    ###############################################################################################

    def getPlayerPings(self):
        """Ask the server for a given client's pings
        """
        pings = {}
        for c in self.clients.getList():
            try:
                words = self.write(("player.ping", c.cid))
                pings[c.cid] = int(words[0])
            except ValueError:
                pass
            except Exception, err:
                self.error("could not get ping info for player %s: %s" % (c, err), exc_info=err)
        return pings

    ###############################################################################################
    #
    #    Other methods
    #    
    ###############################################################################################

    def checkVersion(self):
        version = self.output.write('version')
        self.info('server version : %s' % version)
        if version[0] != 'BF3':
            raise Exception("the BF3 parser can only work with Battlefield 3")
        if int(version[1]) < BF3_REQUIRED_VERSION:
            raise Exception("the BF3 parser can only work with Battlefield 3 server version %s and above. You are tr"
                            "ying to connect to %s v%s" % (BF3_REQUIRED_VERSION, version[0], version[1]))

    def getClient(self, cid, guid=None):
        """Get a connected client from storage or create it
        B3 CID   <--> character name
        B3 GUID  <--> EA_guid
        """
        client = None
        if guid:
            # try to get the client from the storage of already authed clients by guid
            client = self.clients.getByGUID(guid)
        if not client:
            # try to get the client from the storage of already authed clients by name
            client = self.clients.getByCID(cid)
        if not client:
            if cid == 'Server':
                return self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN, teamId=None, squadId=None)
            if guid:
                client = self.clients.newClient(cid, guid=guid, name=cid, team=b3.TEAM_UNKNOWN, teamId=None, squad=None)
            else:
                # must be the first time we see this client
                # query client info
                words = self.write(('admin.listPlayers', 'player', cid))
                pib = PlayerInfoBlock(words)
                if not len(pib):
                    self.debug('no such client found')
                    return None
                p = pib[0]
                if 'guid' in p:
                    cid = p['name']
                    name = p['name']
                    guid = p['guid']
                    teamId = p['teamId']
                    squadId = p['squadId']
                    client = self.clients.newClient(cid, guid=guid, name=name, team=self.getTeam(teamId), teamId=int(teamId), squad=squadId, data=p)
                    self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))
        return client


    def getHardName(self, mapname):
        """ Change real name to level name """
        mapname = mapname.lower()
        try:
            return MAP_ID_BY_NAME[mapname]
        except KeyError:
            self.warning('unknown level name \'%s\'. Please make sure you have entered a valid mapname' % mapname)
            return mapname


    def getEasyName(self, mapname):
        """ Change levelname to real name """
        try:
            return MAP_NAME_BY_ID[mapname]
        except KeyError:
            self.warning('unknown level name \'%s\'. Please report this on B3 forums' % mapname)
            return mapname


    def getGameMode(self, gamemode_id):
        """ Convert game mode ID into human friendly name """
        if gamemode_id in GAME_MODES_NAMES:
            return GAME_MODES_NAMES[gamemode_id]
        else:
            self.warning("unknown gamemode \"%s\"" % gamemode_id)
            # fallback by sending gamemode id
            return gamemode_id


    def getGameModeId(self, gamemode_name):
        """ Get gamemode id by name """
        name = gamemode_name.lower()
        if name in GAMEMODES_IDS_BY_NAME:
            return GAMEMODES_IDS_BY_NAME[name]
        else:
            self.warning("unknown gamemode name \"%s\"" % gamemode_name)
            # fallback by sending gamemode id
            return gamemode_name

    def getSupportedMapIds(self):
        """return a list of supported levels for the current game mod"""
        # TODO : remove this method once the method on from AbstractParser is working
        return MAP_NAME_BY_ID.keys()

    def getSupportedGameModesByMapId(self, map_id):
        """return a list of supported game modes for the given map id"""
        return GAME_MODES_BY_MAP_ID[map_id]

    def getServerVars(self):
        """Update the game property from server fresh data"""
        def getCvar(cvar):
            try:
                return self.getCvar(cvar).getString()
            except Exception:
                pass
        def getCvarBool(cvar):
            try:
                return self.getCvar(cvar).getBoolean()
            except Exception:
                pass
        def getCvarInt(cvar):
            try:
                return self.getCvar(cvar).getInt()
            except Exception:
                pass
        def getCvarFloat(cvar):
            try:
                return self.getCvar(cvar).getFloat()
            except Exception:
                pass
        self.game['3dSpotting'] = getCvarBool('3dSpotting')
        self.game['3pCam'] = getCvarBool('3pCam')
        self.game['autoBalance'] = getCvarBool('autoBalance')
        self.game['bannerUrl'] = getCvar('bannerUrl')
        self.game['bulletDamage'] = getCvarInt('bulletDamage')
        self.game['friendlyFire'] = getCvarBool('friendlyFire')
        self.game['gameModeCounter'] = getCvarInt('gameModeCounter')
        self.game['gamePassword'] = getCvar('gamePassword')
        self.game['hud'] = getCvarBool('hud')
        self.game['idleBanRounds'] = getCvarInt('idleBanRounds')
        self.game['idleTimeout'] = getCvarInt('idleTimeout')
        self.game['killCam'] = getCvarBool('killCam')
        self.game['killRotation'] = getCvarBool('killRotation')
        self.game['maxPlayers'] = getCvarInt('maxPlayers')
        self.game['minimap'] = getCvarBool('minimap')
        self.game['minimapSpotting'] = getCvarBool('minimapSpotting')
        self.game['nameTag'] = getCvarBool('nameTag')
        self.game['onlySquadLeaderSpawn'] = getCvarBool('onlySquadLeaderSpawn')
        self.game['playerManDownTime'] = getCvarInt('playerManDownTime')
        self.game['playerRespawnTime'] = getCvarInt('playerRespawnTime')
        self.game['ranked'] = getCvarBool('ranked')
        self.game['regenerateHealth'] = getCvarBool('regenerateHealth')
        self.game['roundLockdownCountdown'] = getCvarInt('roundLockdownCountdown')
        self.game['roundRestartPlayerCount'] = getCvarInt('roundRestartPlayerCount')
        self.game['roundStartPlayerCount'] = getCvarInt('roundStartPlayerCount')
        self.game['roundsPerMap'] = getCvarInt('roundsPerMap')
        self.game['serverDescription'] = getCvar('serverDescription')
        self.game['serverMessage'] = getCvar('serverMessage')
        self.game['serverName'] = getCvar('serverName')
        self.game['soldierHealth'] = getCvarInt('soldierHealth')
        self.game['teamKillCountForKick'] = getCvarInt('teamKillCountForKick')
        self.game['teamKillKickForBan'] = getCvarInt('teamKillKickForBan')
        self.game['teamKillValueDecreasePerSecond'] = getCvarFloat('teamKillValueDecreasePerSecond')
        self.game['teamKillValueForKick'] = getCvarFloat('teamKillValueForKick')
        self.game['teamKillValueIncrease'] = getCvarFloat('teamKillValueIncrease')
        self.game['unlockMode'] = getCvar('unlockMode')
        self.game['vehicleSpawnAllowed'] = getCvarBool('vehicleSpawnAllowed')
        self.game['vehicleSpawnDelay'] = getCvarInt('vehicleSpawnDelay')
        self.game['premiumStatus'] = getCvarBool('premiumStatus')
        self.game['gunMasterWeaponsPreset'] = getCvarInt('gunMasterWeaponsPreset')
        self.game.timeLimit = self.game.gameModeCounter
        self.game.fragLimit = self.game.gameModeCounter
        self.game.captureLimit = self.game.gameModeCounter


    def getServerInfo(self):
        """query server info, update self.game and return query results
        Response: OK,serverName,numPlayers,maxPlayers,level,gamemode,[teamscores],isRanked,hasPunkbuster,hasPassword,serverUptime,roundTime
        The first number in the [teamscore] component I listed is numTeams, followed by the score or ticket count for each team (0-4 items), 
        then the targetScore. (e.g. in TDM/SQDM this is the number of kills to win)
        So when you start a Squad Deathmatch round with 50 kills needed to win, it will look like this:
        4,0,0,0,0,50
        
        """
        data = self.write(('serverInfo',))
        data2 = Bf3Parser.decodeServerinfo(data)
        self.debug("decoded server info : %r" % data2)
        self.game.sv_hostname = data2['serverName']
        self.game.sv_maxclients = int(data2['maxPlayers'])
        self.game.mapName = data2['level']
        self.game.gameType = data2['gamemode']
        if 'gameIpAndPort' in data2 and data2['gameIpAndPort']:
            try:
                self._publicIp, self._gamePort = data2['gameIpAndPort'].split(':')
            except ValueError:
                pass
        self.game.serverinfo = data2
        return data

    def getTeam(self, team):
        """convert team numbers to B3 team numbers"""
        team = int(team)
        if team == 1:
            return b3.TEAM_RED
        elif team == 2:
            return b3.TEAM_BLUE
        elif team == 3:
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN

    @staticmethod
    def decodeServerinfo(data):
        """
        <serverName: string> <current playercount: integer> <max playercount: integer> <current gamemode: string>
        <current map: string> <roundsPlayed: integer> <roundsTotal: string> <scores: team scores>
        <onlineState: online state> <ranked: boolean> <punkBuster: boolean> <hasGamePassword: boolean>
        <serverUpTime: seconds> <roundTime: seconds>

        ['BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '2', '300', '300', '0', '', 'true', 'true', 'false', '5148', '455']

        """
        numOfTeams = 0
        if data[7] != '':
            numOfTeams = int(data[7])

        response = {
            'serverName': data[0],
            'numPlayers': data[1],
            'maxPlayers': data[2],
            'gamemode': data[3],
            'level': data[4],
            'roundsPlayed': data[5],
            'roundsTotal': data[6],
            'numTeams': data[7],
            # depending on numTeams, there might be between 0 and 4 team scores here
            'team1score': None,
            'team2score': None,
            'team3score': None,
            'team4score': None,
            'targetScore': data[7+numOfTeams + 1],
            'onlineState': data[7+numOfTeams + 2],
            'isRanked': data[7+numOfTeams + 3],
            'hasPunkbuster': data[7+numOfTeams + 4],
            'hasPassword': data[7+numOfTeams + 5],
            'serverUptime': data[7+numOfTeams + 6],
            'roundTime': data[7+numOfTeams + 7],
            'gameIpAndPort': None,
            'punkBusterVersion': None,
            'joinQueueEnabled': None,
            'region': None,
            'closestPingSite': None,
            'country': None,
        }
        if numOfTeams >= 1:
            response['team1score'] = data[8]
        if numOfTeams >= 2:
            response['team2score'] = data[9]
        if numOfTeams >= 3:
            response['team3score'] = data[10]
        if numOfTeams == 4:
            response['team4score'] = data[11]

        # since BF3 R9
        new_info = 'gameIpAndPort', 'punkBusterVersion', 'joinQueueEnabled', 'region', 'closestPingSite', 'country'
        start_index = 7 + numOfTeams + 8
        for index, name in zip(range(start_index, start_index + len(new_info)), new_info):
            try:
                response[name] = data[index]
            except IndexError:
                pass

        return response


########NEW FILE########
__FILENAME__ = bfbc2
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# ====================== CHANGELOG ========================
# 2010/03/09 - 0.1 - Courgette
# * parser is able to connect to a distant BFBC2 server through TCP
#   and listens for BFBC2 events.
# * BFBC2 events are routed to create matching B3 events
# 2010/03/12 - 0.2 - Courgette
# * the bot recognize players, commands and can respond
# 2010/03/14 - 0.3 - Courgette
# * better handling of 'connection reset by peer' issue
# 2010/03/14 - 0.4 - Courgette
# * save clantag as part of the name
# * save Punkbuster ID when client disconnects (when we get notified by PB)
# * save client IP on client connects (when we get notified by PB)
# 2010/03/14 - 0.5 - Courgette
# * add EVT_CLIENT_CONNECT
# * recognize kill/suicide/teamkill
# * add kick, tempban, unban, ban
# 2010/03/14 - 0.5.1 - Courgette
# * fix bug in OnPlayerKill
# 2010/03/14 - 0.5.2 - Courgette
# * remove junk
# 2010/03/14 - 0.5.2 - Courgette
# * fix EVT_CLIENT_SUICIDE parameters
# 2010/03/16 - 0.5.3 - SpacepiG
# * added maps, nextmap, getEasyName for translating map name.
# 2010/03/16 - 0.6 - Courgette
# * set client.team whenever we got the info from the BFBC2 server
# 2010/03/16 - 0.6.1 - Courgette
# * fix getCvar
# 2010/03/21 - 0.7 - Bakes
# * sync each 5 sec. to detect team changes 
# 2010/03/21 - 0.7.1 - Courgette
# * fix bug in getCvar when result is an empty list
# 2010/03/21 - 0.7.2 - Bakes
# * rotateMap() function added for !maprotate functionality.
# 2010/03/21 - 0.7.3 - Bakes
# * message_delay added so that self.say doesn't spew out spam.
# 2010/03/21 - 0.7.4 - Bakes
# * say messages are now queued instead of hanging the bot.
# 2010/03/21 - 0.7.5 - Bakes
# * fixes the 'multiple say event' problem that causes plenty of spam warnings.
# 2010/03/24 - 0.7.6 - Courgette
# * interrupt sayqueuelistener if the bot is paused
# * review all Punkbuster related code
# 2010/03/26 - 0.8 - Courgette
# * refactor the way clients' messages are queued too ensure consecutive
#   messages are displayed at a peaceful rate. Previously this was done
#   in a very similar way in the b3/clients.py file. But it is better
#   to make those changes only for BFBC2 at the moment
# 2010/03/27 - 0.8.1 - Bakes
# * teamkill event fixed - EVT_CLIENT_KILL_TEAM not EVT_CLIENT_TEAMKILL
# 2010/03/27 - 0.8.2 - Courgette
# * getEasyName return the level name is no easyname is found.
# * getEasyName return correct name for maps in SQDM mode
# 2010/03/30 - 0.8.3 - Courgette
# * fix self.Punkbuster
# * add Squad constants
# 2010/04/01 - 0.8.4 - Bakes
# * self.game.* is now updated correctly every 15 seconds.
# 2010/04/05 - 1.0 - Courgette
# * update parser to follow BFBC2 R9 protocol changes
# 2010/04/07 - 1.1 - Courgette
# * fix OnPlayerTeamchange
# * fix OnPlayerSquadchange
# * fix OnServerLoadinglevel
# * fix OnServerLevelstarted
# * introduced a mechanisms that ensure the server loade a target map. This
#   ensure changeMap and mapRotate actually change maps and not just change 
#   map sides (as admin.runNextLevel does natively)
# * make used of the soundex/levenshteinDistance algorithm to get map name from
#   user commands
# 2010/04/08 - 1.2 - Courgette
# * change the way map change was ensured as R9 build 527791 makes things easier
# * ignore chat events when the player who speaks is 'Server'
# * fix client.squad value type
# * on map load, update self.game.<whatever we can> so other plugins can find more data
# * handle gracefully cases where the mapList is empty
# * fix typo in 'africa harbor'
# 2010/04/10 - 1.2.1 - Courgette
# * you can now specify in b3.xml what custom maximum line length you want to 
#   see in the chat zone. 
# * make sure the BFBC2 server is R9 or later
# 2010/04/11 - 1.2.2 - Courgette, Bakes
# * make this module compatible with python 2.4
# * saybig() function is now available for use by plugins.
# 2010/04/11 - 1.2.3 - Bakes
# * fixed arica harbor typo
# 2010/04/11 - 1.2.4 - Bakes
# * client.messagebig() is now available for use by plugins.
# * getHardName is added from poweradminbfbc2, reverse of getEasyname
# 2010/04/12 - 1.2.5 - Courgette
# * make sure client.squad and client.team are of type int. 
# 2010/04/12 - 1.2.6 - Courgette
# Fix client.team inconsistency
# * add client.teamId property which is the exact team id as understood by the BFBC2 
#   (while client.team follow the B3 team numbering scheme : b3.TEAM_BLUE, b3.TEAM_SPEC, etc)
# 2010/05/19 - 1.2.7 - Bakes
# * fixed issue between this and clients.py by overwriting the clients.py method. Will need to
#   be fixed more comprehensively at a later date, this is a quick fix and nothing more!
# 2010/05/21 - 1.2.8 - xlr8or
# * delegated getByCID override to clients.py and fix it there
# 2010/05/22 - 1.2.9 - nicholasperkins (inserted by Bakes)
# * new method for getWrap that doesn't split strings in the middle of words.
# 2010/07/20 - 1.3.0 - xlr8or
# * modified OnPlayerKill to work with R15+
# * fixed infinite loop in a python socket thread in receivePacket() (in protocol.py) on gameserver restart
# * fixed (statusplugin crontab) error when polling for playerscores and -pings while server is unreachable
# 2010/07/26 - 1.3.1 - xlr8or
# * make sure we don't create a new client without a guid and;
# * pass guid to getClient() in OnPlayerAuthenticated() for a better chance on a guid
# 2010/07/28 - 1.3.1 - Durzo
# * merge onPlayerSpawn event with latest xlr8or code base
# 2010/07/29 - 1.3.2 - xlr8or
# * Added EVT_PUNKBUSTER_NEW_CONNECTION when IP address is published by PB
#  (to aid IP and GeoIP based plugins)
# * Removed obsolete code in OnPBLostConection() that generated a consistent error.
# * Fixed unban()
# * Added needConfirmation var to write() so we can test on the confirmationtype ("OK", "NotFound") sent by the server on rcon.
# 2010-07-30 - 1.3.3 - xlr8or
# * Added joinClient() to OnServerLevelstarted() so rounds are counted for playerstats
# 2010-07-30 - 1.3.4 - xlr8or
# * Quick mapretrieval on startup
# 2010-07-30 - 1.3.5 - xlr8or
# * Fixed self.game.rounds
# 2010-08-15 - 1.3.6 - xlr8or
# * Fix PB handling when the PB server was renamed to something else than 'PunkBuster Server'
# * Added OnPBVersion() for testing purposes 
# 2010-09-02 - 1.3.7 - xlr8or
# * Fix memory leak due to never ending threads in messagequeue workers
# 2010-09-02 - 1.3.8 - xlr8or
# * Better thread handling in messagequeue workers
# * Fix bug on exit preventing --restart to function properly
# 2010-09-02 - 1.3.9 - xlr8or
# * Debugged messagequeue workers
# 2010-09-02 - 1.3.10 - xlr8or
# * More debugging messagequeue workers
# 2010-09-25 - 1.4 - Bakes
# * Refactored into Frostbite and Bfbc2 for MoH support.
# 2010-10-23 - 2.0 - Courgette
# * Refactored with inheritence from a frostbite specific abstract parser
# 2010-11-21 - 2.1 - Courgette
# * import rotateMap and changeMap from abstractParser 
# 2010-11-21 - 2.1.1 - Durzo
# * adjust mapnames from mappack 7 and vietnam expansion 
# 2011-06-04 - 2.2 - Courgette
# makes use of the new pluginsStarted parser hook
# 2011-12-15 - 2.3 - Courgette
# makes sure EVT_CLIENT_TEAM_CHANGE gets fired after updating the squad info
# 2012-10-60 - 2.4 - Courgette
# reflect changes in abstract parser 1.6
#
# ===== B3 EVENTS AVAILABLE TO PLUGIN DEVELOPERS USING THIS PARSER ======
# -- standard B3 events  -- 
# EVT_UNKNOWN
# EVT_CLIENT_JOIN
# EVT_CLIENT_KICK
# EVT_CLIENT_SAY
# EVT_CLIENT_TEAM_SAY
# EVT_CLIENT_PRIVATE_SAY
# EVT_CLIENT_CONNECT
# EVT_CLIENT_DISCONNECT
# EVT_CLIENT_SUICIDE
# EVT_CLIENT_KILL_TEAM
# EVT_CLIENT_KILL
# EVT_GAME_WARMUP
# EVT_GAME_ROUND_START
# EVT_CLIENT_BAN_TEMP
# EVT_CLIENT_BAN
#
# -- BFBC2 specific B3 events --
# EVT_CLIENT_SPAWN
# EVT_CLIENT_SQUAD_CHANGE
# EVT_PUNKBUSTER_LOST_PLAYER
# EVT_PUNKBUSTER_SCHEDULED_TASK
# EVT_PUNKBUSTER_NEW_CONNECTION
# 
# -- B3 events triggered natively by B3 core --
# EVT_CLIENT_NAME_CHANGE
# EVT_CLIENT_TEAM_CHANGE
# EVT_CLIENT_AUTH
# EVT_CLIENT_DISCONNECT
#

__author__  = 'Courgette, SpacepiG, Bakes'
__version__ = '2.4'

import time, threading, Queue
import b3.events
from b3.parsers.frostbite.abstractParser import AbstractParser
from b3.parsers.frostbite.util import PlayerInfoBlock

SAY_LINE_MAX_LENGTH = 100

GAMETYPE_SQDM = 'SQDM' # Squad Deathmatch. no team, but up to 4 squad fighting each others
GAMETYPE_CONQUEST = 'CONQUEST'
GAMETYPE_RUSH = 'RUSH'
GAMETYPE_SQRUSH = 'SQRUSH' # Squad Rush

SQUAD_NOSQUAD = 0
SQUAD_ALPHA = 1
SQUAD_BRAVO = 2
SQUAD_CHARLIE = 3
SQUAD_DELTA = 4
SQUAD_ECHO = 5
SQUAD_FOXTROT = 6
SQUAD_GOLF = 7
SQUAD_HOTEL = 8
SQUAD_NEUTRAL = 24

BUILD_NUMBER_R9 = 527791
BUILD_NUMBER_R16 = 556157
BUILD_NUMBER_R17 = 560541

#----------------------------------------------------------------------------------------------------------------------------------------------
class Bfbc2Parser(AbstractParser):
    gameName = 'bfbc2'

    _gameServerVars = (
        '3dSpotting',
        'adminPassword',
        'bannerUrl',
        'crossHair',
        'currentPlayerLimit',
        'friendlyFire',
        'gamePassword',
        'hardCore',
        'killCam',
        'maxPlayerLimit',
        'miniMap',
        'miniMapSpotting',
        'playerLimit',
        'punkBuster',
        'rankLimit',
        'ranked',
        'serverDescription',
        'teamBalance',
        'thirdPersonVehicleCameras'
    )

    saybigqueue = Queue.Queue()
    saybigqueuelistener = None


    def startup(self):
        AbstractParser.startup(self)

        self.saybigqueuelistener = threading.Thread(target=self.saybigqueuelistener)
        self.saybigqueuelistener.setDaemon(True)
        self.saybigqueuelistener.start()

        # add BFBC2 specific commands
        self._commands['messagebig'] = ('admin.yell', '%(message)s', '%(duration)s', 'player', '%(cid)s')
        self._commands['saybig'] = ('admin.yell', '%(message)s', '%(duration)s', 'all')


        # create the 'Server' client
        self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN, squad=SQUAD_NEUTRAL)
        

        if self.config.has_option('bfbc2', 'max_say_line_length'):
            try:
                maxlength = self.config.getint('bfbc2', 'max_say_line_length')
                if maxlength > SAY_LINE_MAX_LENGTH:
                    self.warning('max_say_line_length cannot be greater than %s' % SAY_LINE_MAX_LENGTH)
                    maxlength = SAY_LINE_MAX_LENGTH
                if maxlength < 20:
                    self.warning('max_say_line_length is way too short. using default')
                    maxlength = self._settings['line_length']
                self._settings['line_length'] = maxlength
                self._settings['min_wrap_length'] = maxlength
            except Exception, err:
                self.error('failed to read max_say_line_length setting "%s" : %s' % (self.config.get('bfbc2', 'max_say_line_length'), err))
        self.debug('line_length: %s' % self._settings['line_length'])
            
        self.verbose('GameType: %s, Map: %s' %(self.game.gameType, self.game.mapName))
        

    def pluginsStarted(self):
        self.info('connecting all players...')
        plist = self.getPlayerList()
        for cid, p in plist.iteritems():
            client = self.clients.getByCID(cid)
            if not client:
                #self.clients.newClient(playerdata['cid'], guid=playerdata['guid'], name=playerdata['name'], team=playerdata['team'], squad=playerdata['squad'])
                name = p['name']
                if 'clanTag' in p and len(p['clanTag']) > 0:
                    name = "[" + p['clanTag'] + "] " + p['name']
                self.debug('client %s found on the server' % cid)
                client = self.clients.newClient(cid, guid=p['guid'], name=name, team=p['teamId'], squad=p['squadId'], data=p)
                self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))


    def saybigqueuelistener(self):
        while self.working:
            msg = self.saybigqueue.get()
            for line in self.getWrap(self.stripColors(self.msgPrefix + ' ' + msg), self._settings['line_length'], self._settings['min_wrap_length']):
                self.write(self.getCommand('saybig', message=line, duration=2400))
                time.sleep(self._settings['message_delay'])
 
 
    def checkVersion(self):
        version = self.output.write('version')
        self.info('server version : %s' % version)
        if version[0] != 'BFBC2':
            raise Exception("the bfbc2 parser can only work with BattleField Bad Company 2")
        if int(version[1]) < BUILD_NUMBER_R9:
            raise SystemExit("this bfbc2 parser requires a BFBC2 server R9 or later") 

    #----------------------------------
    

    def OnPlayerTeamchange(self, action, data):
        """
        player.onTeamChange <soldier name: player name> <team: Team ID> <squad: Squad ID>
        Effect: Player might have changed team
        """
        client = self.getClient(data[0])
        if client:
            client.teamId = int(data[1])
            client.squad = int(data[2])
            client.team = self.getTeam(data[1]) # .team setter will send team change event


    def OnPlayerSquadchange(self, action, data):
        """
        player.onSquadChange <soldier name: player name> <team: Team ID> <squad: Squad ID>    
        
        Effect: Player might have changed squad
        """
        client = self.getClient(data[0])
        if client:
            previous_squad = client.squad
            client.squad = int(data[2])
            client.teamId = int(data[1])
            client.team = self.getTeam(data[1]) # .team setter will send team change event
            if client.squad != previous_squad:
                return b3.events.Event(b3.events.EVT_CLIENT_SQUAD_CHANGE, data[1:], client)

    def getEasyName(self, mapname):
        """ Change levelname to real name """
        if mapname.startswith('Levels/MP_001'):
            return 'Panama Canal'
            
        elif mapname.startswith('Levels/MP_002'):
            return 'Valparaiso'

        elif mapname.startswith('Levels/MP_003'):
            return 'Laguna Alta'

        elif mapname.startswith('Levels/MP_004'):
            return 'Isla Inocentes'

        elif mapname.startswith('Levels/MP_005'):
            return 'Atacama Desert'

        elif mapname.startswith('Levels/MP_006'):
            return 'Arica Harbor'

        elif mapname.startswith('Levels/MP_007'):
            return 'White Pass'

        elif mapname.startswith('Levels/MP_008'):
            return 'Nelson Bay'

        elif mapname.startswith('Levels/MP_009'):
            return 'Laguna Preza'

        elif mapname.startswith('Levels/MP_012'):
            return 'Port Valdez'

        elif mapname.startswith('Levels/BC1_Oasis'):
            return 'Oasis'

        elif mapname.startswith('Levels/BC1_Harvest_Day'):
            return 'Harvest Day'

        elif mapname.startswith('Levels/MP_SP_002'):
            return 'Cold War'

        elif mapname.startswith('Levels/MP_SP_005'):
            return 'Heavy Metal'

        elif mapname.startswith('Levels/nam_mp_002'):
            return 'Vantage Point'

        elif mapname.startswith('Levels/nam_mp_003'):
            return 'Hill 137'

        elif mapname.startswith('Levels/nam_mp_005'):
            return 'Cao Son Temple'

        elif mapname.startswith('Levels/nam_mp_006'):
            return 'Phu Bai Valley'

        else:
            self.warning('unknown level name \'%s\'. Please report this on B3 forums' % mapname)
            return mapname
            
            
    def getHardName(self, mapname):
        """ Change real name to level name """
        mapname = mapname.lower()
        if mapname.startswith('panama canal'):
            return 'Levels/MP_001'
            
        elif mapname.startswith('val paraiso'):
            return 'Levels/MP_002'

        elif mapname.startswith('laguna alta'):
            return 'Levels/MP_003'

        elif mapname.startswith('isla inocentes'):
            return 'Levels/MP_004'

        elif mapname.startswith('atacama desert'):
            return 'Levels/MP_005'

        elif mapname.startswith('arica harbor'):
            return 'Levels/MP_006'

        elif mapname.startswith('white pass'):
            return 'Levels/MP_007'

        elif mapname.startswith('nelson bay'):
            return 'Levels/MP_008'

        elif mapname.startswith('laguna preza'):
            return 'Levels/MP_009'

        elif mapname.startswith('port valdez'):
            return 'Levels/MP_012'

        elif mapname.startswith('oasis'):
            return 'Levels/BC1_Oasis'

        elif mapname.startswith('harvest day'):
            return 'Levels/BC1_Harvest_Day'

        elif mapname.startswith('cold war'):
            return 'Levels/MP_SP_002'

        elif mapname.startswith('heavy metal'):
            return 'Levels/MP_SP_005'

        elif mapname.startswith('vantage point'):
            return 'levels/nam_mp_002'

        elif mapname.startswith('hill 137'):
            return 'levels/nam_mp_003'

        elif mapname.startswith('cao son temple'):
            return 'levels/nam_mp_005'

        elif mapname.startswith('phu bai valley'):
            return 'levels/nam_mp_006'        

        else:
            self.warning('unknown level name \'%s\'. Please make sure you have entered a valid mapname' % mapname)
            return mapname

        
    def getTeam(self, team):
        """convert BFBC2 team numbers to B3 team numbers"""
        team = int(team)
        if team == 1:
            return b3.TEAM_RED
        elif team == 2:
            return b3.TEAM_BLUE
        elif team == 3:
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN
        
        
    def getClient(self, cid, _guid=None):
        """Get a connected client from storage or create it
        B3 CID   <--> ingame character name
        B3 GUID  <--> EA_guid
        """
        
        # try to get the client from the storage of already authed clients
        client = self.clients.getByCID(cid)
        if not client:
            if cid == 'Server':
                return self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN, squad=SQUAD_NEUTRAL)
            # must be the first time we see this client
            words = self.write(('admin.listPlayers', 'player', cid))
            pib = PlayerInfoBlock(words)
            if len(pib) == 0:
                self.debug('no such client found')
                return None
            p = pib[0]
            cid = p['name']
            name = p['name']

            # Let's see if we have a guid, either from the PlayerInfoBlock, or passed to us by OnPlayerAuthenticated()
            if p['guid']:
                guid = p['guid']
            elif _guid:
                guid = _guid
            else:
                # If we still don't have a guid, we cannot create a newclient without the guid!
                self.debug('No guid for %s, waiting for next event.' %name)
                return None

            if 'clanTag' in p and len(p['clanTag']) > 0:
                name = "[" + p['clanTag'] + "] " + p['name']
            client = self.clients.newClient(cid, guid=guid, name=name, team=self.getTeam(p['teamId']), teamId=int(p['teamId']), squad=p['squadId'], data=p)
            self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))
        
        return client


    def getServerVars(self):
        """Update the game property from server fresh data"""
        try: self.game.is3dSpotting = self.getCvar('3dSpotting').getBoolean()
        except: pass
        try: self.game.bannerUrl = self.getCvar('bannerUrl').getString()
        except: pass
        try: self.game.crossHair = self.getCvar('crossHair').getBoolean()
        except: pass
        try: self.game.currentPlayerLimit = self.getCvar('currentPlayerLimit').getInt()
        except: pass
        try: self.game.friendlyFire = self.getCvar('friendlyFire').getBoolean()
        except: pass
        try: self.game.hardCore = self.getCvar('hardCore').getBoolean()
        except: pass
        try: self.game.killCam = self.getCvar('killCam').getBoolean()
        except: pass
        try: self.game.maxPlayerLimit = self.getCvar('maxPlayerLimit').getInt()
        except: pass
        try: self.game.miniMap = self.getCvar('miniMap').getBoolean()
        except: pass
        try: self.game.miniMapSpotting = self.getCvar('miniMapSpotting').getBoolean()
        except: pass
        try: self.game.playerLimit = self.getCvar('playerLimit').getInt()
        except: pass
        try: self.game.punkBuster = self.getCvar('punkBuster').getBoolean()
        except: pass
        try: self.game.rankLimit = self.getCvar('rankLimit').getInt()
        except: pass
        try: self.game.ranked = self.getCvar('ranked').getBoolean()
        except: pass
        try: self.game.serverDescription = self.getCvar('serverDescription').getString()
        except: pass
        try: self.game.teamBalance = self.getCvar('teamBalance').getBoolean()
        except: pass
        try: self.game.thirdPersonVehicleCameras = self.getCvar('thirdPersonVehicleCameras').getBoolean()
        except: pass


    def messagebig(self, client, text):
        try:
            if client == None:
                self.saybig(text)
            elif client.cid == None:
                pass
            else:
                self.write(self.getCommand('messagebig', message=text, cid=client.cid, duration=2400))
        except:
            pass
        
        
    def saybig(self, msg):
        self.saybigqueue.put(msg)


    def rotateMap(self):
        """Load the next map (not level). If the current game mod plays each level twice
        to get teams the chance to play both sides, then this rotate a second
        time to really switch to the next map"""
        nextIndex = self.getNextMapIndex()
        if nextIndex == -1:
            # No map in map rotation list, just call admin.runNextLevel
            self.write(('admin.runNextLevel',))
        else:
            self.write(('mapList.nextLevelIndex', nextIndex))
            self.write(('admin.runNextLevel',))
    
    
    def changeMap(self, map):
        """Change to the given map
        
        1) determine the level name
            If map is of the form 'Levels/MP_001' and 'Levels/MP_001' is a supported
            level for the current game mod, then this level is loaded.
            
            In other cases, this method assumes it is given a 'easy map name' (like
            'Port Valdez') and it will do its best to find the level name that seems
            to be for 'Port Valdez' within the supported levels.
        
            If no match is found, then instead of loading the map, this method 
            returns a list of candidate map names
            
        2) if we got a level name
            if the level is not in the current rotation list, then add it to 
            the map list and load it
        """        
        supportedMaps = self.getSupportedMaps()
        if map not in supportedMaps:
            match = self.getMapsSoundingLike(map)
            if len(match) == 1:
                map = match[0]
            else:
                return match
            
        if map in supportedMaps:
            levelnames = self.write(('mapList.list',))
            if map not in levelnames:
                # add the map to the map list
                nextIndex = self.getNextMapIndex()
                if nextIndex == -1:
                    self.write(('mapList.append', map))
                    nextIndex = 0
                else:
                    if nextIndex == 0:
                        # case where the map list contains only 1 map
                        nextIndex = 1
                    self.write(('mapList.insert', nextIndex, map))
            else:
                nextIndex = 0
                while nextIndex < len(levelnames) and levelnames[nextIndex] != map:
                    nextIndex += 1
            
            self.say('Changing map to %s' % map)
            time.sleep(1)
            self.write(('mapList.nextLevelIndex', nextIndex))
            self.write(('admin.runNextLevel', ))



#############################################################
# Below is the code that change a bit the b3.clients.Client
# class at runtime. What the point of coding in python if we
# cannot play with its dynamic nature ;)
#
# why ?
# because doing so make sure we're not broking any other 
# working and long tested parser. The change we make here
# are only applied when the Bfbc2 parser is loaded.
#############################################################

## add a new method to the Client class
def frostbiteClientMessageBigQueueWorker(self):
    """
    This takes a line off the queue and displays it
    in the middle of the screen then pause for
    'message_delay' seconds
    """
    while not self.messagebigqueue.empty():
        msg = self.messagebigqueue.get()
        if msg:
            self.console.messagebig(self, msg)
            time.sleep(float(self.console._settings['message_delay']))
b3.clients.Client.messagebigqueueworker = frostbiteClientMessageBigQueueWorker

## add the Client.messagebig() method at runtime
def frostbiteClientMessageBigMethod(self, msg):
    if msg and len(msg.strip())>0:
        # do we have a queue?
        if not hasattr(self, 'messagebigqueue'):
            self.messagebigqueue = Queue.Queue()
        # fill the queue
        text = self.console.stripColors(self.console.msgPrefix + ' [pm] ' + msg)
        for line in self.console.getWrap(text):
            self.messagebigqueue.put(line)
        # create a thread that executes the worker and pushes out the queue
        if not hasattr(self, 'messagebighandler') or not self.messagebighandler.isAlive():
            self.messagebighandler = threading.Thread(target=self.messagebigqueueworker)
            self.messagebighandler.setDaemon(True)
            self.messagebighandler.start()
        else:
            self.console.verbose('messagebighandler for %s isAlive' %self.name)
b3.clients.Client.messagebig = frostbiteClientMessageBigMethod

########NEW FILE########
__FILENAME__ = cod
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 7/23/2005 - 1.1.0
#    * Added damage type to Damage and Kill event data
# 27/6/2009 - 1.3.1 - xlr8or - Added Action Mechanism (event) for version 1.1.5 
# 28/8/2009 - 1.3.2 - Bakes - added regexp for CoD4 suicides
# 17/1/2010 - 1.3.3 - xlr8or - moved sync to InitGame (30 second delay)
# 25/1/2010 - 1.4.0 - xlr8or - refactored cod parser series
# 26/1/2010 - 1.4.1 - xlr8or
#    * Added authorizeClients() for IpsOnly
#    * minor bugfixes after initial tests
# 26/1/2010 - 1.4.2 - xlr8or - Added mapEnd() on Exitlevel
# 27/1/2010 - 1.4.3 - xlr8or - Minor bugfix in sync() for IpsOnly
# 28/1/2010 - 1.4.4 - xlr8or - Make sure cid is entering Authentication queue only once. 
# 29/1/2010 - 1.4.5 - xlr8or - Minor rewrite of Auth queue check 
# 31/1/2010 - 1.4.6 - xlr8or
#    * Added unban for non pb servers
#    * Fixed bug: rcon command banid replaced by banclient
# 28/3/2010 - 1.4.7 - xlr8or - Added PunkBuster activity check on startup
# 18/4/2010 - 1.4.8 - xlr8or - Trying to prevent key errors in newPlayer()
# 18/4/2010 - 1.4.9 - xlr8or - Forcing g_logsync to make server write unbuffered gamelogs
# 01/5/2010 - 1.4.10 - xlr8or - delegate guid length checking to cod parser
# 24/5/2010 - 1.4.11 - xlr8or - check if guids match on existing client objects when joining after a mapchange
# 30/5/2010 - 1.4.12 - xlr8or - adding dummy setVersionExceptions() to enable overriding of variables based on the shortversion 
# 10/8/2010 - 1.4.13 - xlr8or - fixed a bug where clients would be disconnected after mapchange.  
# 10/9/2010 - 1.4.14 - xlr8or - don't save client.name on say and sayteam when name is the same (sanitization problem)
# 24/10/2010 - 1.4.15 - xlr8or - some documentation on line formats
# 07/11/2010 - 1.4.16 - GrosBedo - messages now support named $variables instead of %s
# 08/11/2010 - 1.4.17 - GrosBedo - messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# 02/02/2011 - 1.4.18 - xlr8or - add cod7 suicide _lineformat
# 16/03/2011 - 1.4.19 - xlr8or - improve PunkBuster check
# 28/03/2011 - 1.4.20 - Bravo17 - CoD5 JT regexp fix
# 09/04/2011 - 1.4.21 - Courgette - reflect that cid are not converted to int anymore in the clients module
# 16/07/2011 - 1.4.22 - Freelander - Minor bugfix to flag disconnecting client properly if found in authentication queue 
# 03/07/2011 - 1.4.23 - 82ndab.Bravo17 - adjust sync() timing for high slot count servers and login plugin
#                       Sync now occurs 60 seconds after ExitLevel (map change) rather than 30 seconds after every round start
# 11/09/2011 - 1.4.24 - 82ndab.Bravo17 - New client will now join Auth queue if slot shows as 'Disconnected' in Auth queue
# 10/30/2011 - 1.4.25 - xlr8or - Add decoding to data in say, sayTeam and Tell methods
# 01/28/2012 - 1.4.26 - 82ndab.Bravo17 - Add special case COD7 suicide regex where attacker team and name appear to be swapped in the console output
# 10/03/2012 - 1.4.27 - 82ndab.Bravo17 - pbid now empty string instead of None if pb disabled
# 07/07/2012 - 1.4.28 - Courgette - ensures the config file has option 'game_log' in section 'server'
# 12/31/2012 - 1.4.29 - Courgette - accepts rcon status responses having negative port numbers
# 01/02/2013 - 1.4.30 - Courgette - improve parsing rcon status status responses that are missing characters

__author__ = 'ThorN, xlr8or'
__version__ = '1.4.29'

import re, string, threading
import b3
import b3.events
from b3.parsers.q3a.abstractParser import AbstractParser
import b3.parsers.punkbuster

class CodParser(AbstractParser):
    gameName = 'cod'
    IpsOnly = False
    _guidLength = 6 # (minimum) length of the guid
    _pbRegExp = re.compile(r'^[0-9a-f]{32}$', re.IGNORECASE) # RegExp to match a PunkBuster ID
    _logSync = 3 # Value for unbuffered game logging (append mode)
    _counter = {}
    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 120

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banclient %(cid)s'
    _commands['unban'] = 'unbanuser %(name)s' # remove players from game engine's ban.txt
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup': b3.events.EVT_GAME_WARMUP,
        'restartgame': b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 InitGame: \g_gametype\dm\gamename\Call of Duty
    _lineFormats = (
        # server events
        re.compile(r'^(?P<action>[a-z]+):\s?(?P<data>.*)$', re.IGNORECASE),

        # world kills
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9-]{1,2});(?P<team>[a-z]+);(?P<name>[^;]+);(?P<aguid>[^;]*);(?P<acid>-1);(?P<ateam>world);(?P<aname>[^;]*);(?P<aweap>[a-z0-9_-]+);(?P<damage>[0-9.]+);(?P<dtype>[A-Z_]+);(?P<dlocation>[a-z_]+))$'
            , re.IGNORECASE),
        # player kills/damage
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]*);(?P<name>[^;]+);(?P<aguid>[^;]+);(?P<acid>[0-9]{1,2});(?P<ateam>[a-z]*);(?P<aname>[^;]+);(?P<aweap>[a-z0-9_-]+);(?P<damage>[0-9.]+);(?P<dtype>[A-Z_]+);(?P<dlocation>[a-z_]+))$'
            , re.IGNORECASE),
        # suicides (cod4/cod5)
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]*);(?P<name>[^;]+);(?P<aguid>[^;]*);(?P<acid>-1);(?P<ateam>[a-z]*);(?P<aname>[^;]+);(?P<aweap>[a-z0-9_-]+);(?P<damage>[0-9.]+);(?P<dtype>[A-Z_]+);(?P<dlocation>[a-z_]+))$'
            , re.IGNORECASE),
        # suicides (cod7)
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]*);(?P<name>[^;]+);(?P<aguid>[^;]*);(?P<acid>[0-9]{1,2});(?P<ateam>[a-z]*);(?P<aname>[^;]+);(?P<aweap>[a-z0-9_-]+);(?P<damage>[0-9.]+);(?P<dtype>[A-Z_]+);(?P<dlocation>[a-z_]+))$'
            , re.IGNORECASE),
        # For this one they appear to have swapped the attacker team and name in the output, hence the specific entry for attacker name as it is a unique case
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]*);(?P<name>[^;]+);(?P<aguid>[^;]*);(?P<acid>[0-9]{1,2});(?P<aname>world);(?P<ateam>);(?P<aweap>none);(?P<damage>[0-9.]+);(?P<dtype>[A-Z_]+);(?P<dlocation>[a-z_]+))$'
            , re.IGNORECASE),


        #team actions
        re.compile(
            r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]+);(?P<name>[^;]+);(?P<type>[a-z_]+))$'
            , re.IGNORECASE),

        # Join Team (cod5)
        re.compile(r'^(?P<action>JT);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<team>[a-z]+);(?P<name>[^;]+);)$',
                   re.IGNORECASE),

        # tell like events
        re.compile(
            r'^(?P<action>[a-z]+);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<name>[^;]+);(?P<aguid>[^;]+);(?P<acid>[0-9]{1,2});(?P<aname>[^;]+);(?P<text>.*))$'
            , re.IGNORECASE),
        # say like events
        re.compile(r'^(?P<action>[a-z]+);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<name>[^;]+);(?P<text>.*))$',
                   re.IGNORECASE),

        # all other events
        re.compile(r'^(?P<action>[A-Z]);(?P<data>(?P<guid>[^;]+);(?P<cid>[0-9]{1,2});(?P<name>[^;]+))$', re.IGNORECASE)
        )
    # All Log Line Formats see bottom of File

    #num score ping guid   name            lastmsg address               qport rate
    #--- ----- ---- ------ --------------- ------- --------------------- ----- -----
    #2     0   29 465030 <-{^4AS^7}-^3ThorN^7->^7       50 68.63.6.62:-32085      6597  5000
    _regPlayer = re.compile(r"""
^\s*
  (?P<slot>[0-9]+)
\s+
  (?P<score>[0-9-]+)
\s+
  (?P<ping>[0-9]+)
\s+
  (?P<guid>[0-9]+)
\s+
  (?P<name>.*?)
\s+
  (?P<last>[0-9]+?)
\s*
  (?P<ip>(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))
:?
  (?P<port>-?[0-9]{1,5})
\s*
  (?P<qport>-?[0-9]{1,5})
\s+
  (?P<rate>[0-9]+)
$
""", re.IGNORECASE | re.VERBOSE)

    PunkBuster = None

    def startup(self):
        if not self.config.has_option('server','game_log'):
            self.critical("your main config file is missing the 'game_log' setting in section 'server'")
            raise SystemExit(220)

        if self.IpsOnly:
            self.debug('Authentication Method: Using Ip\'s instead of GUID\'s!')
            # add the world client
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')

        if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
            # test if PunkBuster is active
            result = self.write('PB_SV_Ver')
            if result != '' and result[:7] != 'Unknown':
                self.info('PunkBuster Active: %s' % result)
                self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)
            else:
                self.warning(
                    'PunkBuster test FAILED, Check your game server setup and B3 config! Disabling PB support!')

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s' % self.game.mapName)

        # Force g_logsync
        self.debug('Forcing server cvar g_logsync to %s' % self._logSync)
        self.write('set g_logsync %s' % self._logSync)

        # get gamepaths/vars
        try:
            self.game.fs_game = self.getCvar('fs_game').getString()
        except:
            self.game.fs_game = None
            self.warning('Could not query server for fs_game')

        try:
            self.game.fs_basepath = self.getCvar('fs_basepath').getString().rstrip('/')
            self.debug('fs_basepath: %s' % self.game.fs_basepath)
        except:
            self.game.fs_basepath = None
            self.warning('Could not query server for fs_basepath')

        try:
            self.game.fs_homepath = self.getCvar('fs_homepath').getString().rstrip('/')
            self.debug('fs_homepath: %s' % self.game.fs_homepath)
        except:
            self.game.fs_homepath = None
            self.warning('Could not query server for fs_homepath')
        try:
            self.game.shortversion = self.getCvar('shortversion').getString()
            self.debug('shortversion: %s' % self.game.shortversion)
        except:
            self.game.shortversion = None
            self.warning('Could not query server for shortversion')

        self.setVersionExceptions()
        self.debug('Parser started.')

    def setVersionExceptions(self):
        """\
        Dummy to enable shortversionexceptions for cod2.
        Use this function in inheriting parsers to override certain vars based on ie. shortversion
        """
        pass

    # kill
    def OnK(self, action, data, match=None):
        victim = self.getClient(victim=match)
        if not victim:
            self.debug('No victim')
            self.OnJ(action, data, match)
            return None

        attacker = self.getClient(attacker=match)
        if not attacker:
            self.debug('No attacker')
            return None

        attacker.team = self.getTeam(match.group('ateam'))
        attacker.name = match.group('aname')
        victim.team = self.getTeam(match.group('team'))
        victim.name = match.group('name')

        event = b3.events.EVT_CLIENT_KILL

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        victim.state = b3.STATE_DEAD
        return b3.events.Event(event,
            (float(match.group('damage')), match.group('aweap'), match.group('dlocation'), match.group('dtype')),
                               attacker, victim)

    # damage
    def OnD(self, action, data, match=None):
        victim = self.getClient(victim=match)
        if not victim:
            self.debug('No victim - attempt join')
            self.OnJ(action, data, match)
            return None

        attacker = self.getClient(attacker=match)
        if not attacker:
            self.debug('No attacker')
            return None

        attacker.team = self.getTeam(match.group('ateam'))
        attacker.name = match.group('aname')
        victim.team = self.getTeam(match.group('team'))
        victim.name = match.group('name')

        event = b3.events.EVT_CLIENT_DAMAGE
        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_DAMAGE_SELF
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_DAMAGE_TEAM

        return b3.events.Event(event,
            (float(match.group('damage')), match.group('aweap'), match.group('dlocation'), match.group('dtype')),
                               attacker, victim)

    # disconnect
    def OnQ(self, action, data, match=None):
        client = self.getClient(match)
        if client:
            client.disconnect()
        else:
            # Check if we're in the authentication queue
            if match.group('cid') in self._counter:
                # Flag it to remove from the queue
                cid = match.group('cid')
                self._counter[cid] = 'Disconnected'
                self.debug(
                    'slot %s has disconnected or was forwarded to our http download location, removing from authentication queue...' % cid)
        return None

    # join
    def OnJ(self, action, data, match=None):
        codguid = match.group('guid')
        cid = match.group('cid')
        name = match.group('name')

        if len(codguid) < self._guidLength:
            # invalid guid
            self.verbose2('Invalid GUID: %s' % codguid)
            codguid = None

        client = self.getClient(match)

        if client:
            self.verbose2('ClientObject already exists')
            # lets see if the name/guids match for this client, prevent player mixups after mapchange (not with PunkBuster enabled)
            if not self.PunkBuster:
                if self.IpsOnly:
                    # this needs testing since the name cleanup code may interfere with this next condition
                    if name != client.name:
                        self.debug('This is not the correct client (%s <> %s), disconnecting' % (name, client.name))
                        client.disconnect()
                        return None
                    else:
                        self.verbose2('client.name in sync: %s == %s' % (name, client.name))
                else:
                    if codguid != client.guid:
                        self.debug('This is not the correct client (%s <> %s), disconnecting' % (codguid, client.guid))
                        client.disconnect()
                        return None
                    else:
                        self.verbose2('client.guid in sync: %s == %s' % (codguid, client.guid))
                # update existing client
            client.state = b3.STATE_ALIVE
            # possible name changed
            client.name = name
            # Join-event for mapcount reasons and so forth
            return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)
        else:
            if self._counter.get(cid) and self._counter.get(cid) != 'Disconnected':
                self.verbose('cid: %s already in authentication queue. Aborting Join.' % cid)
                return None
            self._counter[cid] = 1
            t = threading.Timer(2, self.newPlayer, (cid, codguid, name))
            t.start()
            self.debug('%s connected, waiting for Authentication...' % name)
            self.debug('Our Authentication queue: %s' % self._counter)


    # action
    def OnA(self, action, data, match=None):
        #A;136528;6;allies;{^6AS^7}^6Honey;re_pickup
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)

            client = self.getClient(match)

            if not client:
                return None

        client.name = match.group('name')
        actiontype = match.group('type')
        self.verbose('OnAction: %s: %s' % (client.name, actiontype))
        return b3.events.Event(b3.events.EVT_CLIENT_ACTION, actiontype, client)

    def OnSay(self, action, data, match=None):
        #3:12 say: <-{AS}-ThorN->: sfs
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)

            client = self.getClient(match)

            if not client:
                return None

        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        # decode the server data
        if self.encoding:
            try:
                data = data.decode(self.encoding)
            except Exception, msg:
                self.warning('ERROR Decoding data: %r', msg)

        if client.name != match.group('name'):
            client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_SAY, data, client)

    def OnSayteam(self, action, data, match=None):
        #3:12 sayteam: <-{AS}-ThorN->: sfs
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)

            client = self.getClient(match)

            if not client:
                return None

        data = match.group('text')
        # sometimes there is a weird character in the message
        # remove if it is there
        if data and ord(data[:1]) == 21:
            data = data[1:]

        # decode the server data
        if self.encoding:
            try:
                data = data.decode(self.encoding)
            except Exception, msg:
                self.warning('ERROR Decoding data: %r', msg)

        if client.name != match.group('name'):
            client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, data, client)

    def OnTell(self, action, data, match=None):
        #4197:48tell;465030;2;ThorN;465030;2;ThorN;testing
        client = self.getClient(match)
        tclient = self.getClient(attacker=match)

        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)

            client = self.getClient(match)

            if not client:
                return None

        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        # decode the server data
        if self.encoding:
            try:
                data = data.decode(self.encoding)
            except Exception, msg:
                self.warning('ERROR Decoding data: %r', msg)

        client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, data, client, tclient)

    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = o[1]
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()


        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    def OnExitlevel(self, action, data, match=None):
        t = threading.Timer(60, self.clients.sync)
        t.start()
        self.game.mapEnd()
        return b3.events.Event(b3.events.EVT_GAME_EXIT, data)

    def OnItem(self, action, data, match=None):
        guid, cid, name, item = string.split(data, ';', 3)
        client = self.clients.getByCID(cid)
        if client:
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, item, client)
        return None

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        if self.PunkBuster:
            if client.pbid:
                result = self.PunkBuster.unBanGUID(client)

                if result:
                    admin.message('^3Unbanned^7: %s^7: %s' % (client.exactName, result))

                if admin:
                    fullreason = self.getMessage('unbanned_by',
                                                 self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))

                if not silent and fullreason != '':
                    self.say(fullreason)
            elif admin:
                admin.message('%s^7 unbanned but has no punkbuster id' % client.exactName)
        else:
            _name = self.stripColors(client.exactName)
            result = self.write(self.getCommand('unban', name=_name, reason=reason))
            if admin:
                admin.message(result)

    def getTeam(self, team):
        if team == 'allies':
            return b3.TEAM_BLUE
        elif team == 'axis':
            return b3.TEAM_RED
        else:
            return b3.TEAM_UNKNOWN

    _reMap = re.compile(r'map ([a-z0-9_-]+)', re.I)

    def getMaps(self):
        maps = self.getCvar('sv_mapRotation')

        nmaps = []
        if maps:
            maps = re.findall(self._reMap, maps[0])

            for m in maps:
                if m[:3] == 'mp_':
                    m = m[3:]

                nmaps.append(m.title())

        return nmaps

    def getNextMap(self):
        if not self.game.mapName: return None

        maps = self.getCvar('sv_mapRotation')

        if maps:
            maps = re.findall(self._reMap, maps[0])

            gmap = self.game.mapName.strip().lower()

            found = False
            for nmap in maps:
                nmap = nmap.strip().lower()
                if found:
                    found = nmap
                    break
                elif nmap == gmap:
                    # current map, break on next map
                    found = True

            if found == True:
                # map is first map in rotation
                nmap = maps[0].strip().lower()

            if found:
                if nmap[:3] == 'mp_': nmap = nmap[3:]
                return nmap.title()

            return None
        else:
            return None

    def sync(self):
        self.debug('Synchronising Clients.')
        plist = self.getPlayerList(maxRetries=4)
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                if client.guid and c.has_key('guid') and not self.IpsOnly:
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')

        return mlist

    def connectClient(self, ccid):
        players = self.getPlayerList()
        self.verbose('connectClient() = %s' % players)

        for cid, p in players.iteritems():
            #self.debug('cid: %s, ccid: %s, p: %s' %(cid, ccid, p))
            if int(cid) == int(ccid):
                self.debug('%s found in status/playerList' % p['name'])
                return p

    def newPlayer(self, cid, codguid, name):
        if not self._counter.get(cid):
            self.verbose('newPlayer thread no longer needed, Key no longer available')
            return None
        if self._counter.get(cid) == 'Disconnected':
            self.debug('%s disconnected, removing from authentication queue' % name)
            self._counter.pop(cid)
            return None
        self.debug('newClient: %s, %s, %s' % (cid, codguid, name))
        sp = self.connectClient(cid)
        # PunkBuster is enabled, using PB guid
        if sp and self.PunkBuster:
            self.debug('sp: %s' % sp)
            # test if pbid is valid, otherwise break off and wait for another cycle to authenticate
            if not re.match(self._pbRegExp, sp['pbid']):
                self.debug('PB-id is not valid! Giving it another try.')
                self._counter[cid] += 1
                t = threading.Timer(4, self.newPlayer, (cid, codguid, name))
                t.start()
                return None
            if self.IpsOnly:
                guid = sp['ip']
                pbid = sp['pbid']
            else:
                guid = sp['pbid']
                pbid = guid # save pbid in both fields to be consistent with other pb enabled databases
            ip = sp['ip']
            if self._counter.get(cid):
                self._counter.pop(cid)
            else:
                return None
        # PunkBuster is not enabled, using codguid
        elif sp:
            if self.IpsOnly:
                codguid = sp['ip']
            if not codguid:
                self.warning('Missing or wrong CodGuid and PunkBuster is disabled... cannot authenticate!')
                if self._counter.get(cid):
                    self._counter.pop(cid)
                return None
            else:
                guid = codguid
                pbid = ''
                ip = sp['ip']
                if self._counter.get(cid):
                    self._counter.pop(cid)
                else:
                    return None
        elif self._counter.get(cid) > 10:
            self.debug('Couldn\'t Auth %s, giving up...' % name)
            if self._counter.get(cid):
                self._counter.pop(cid)
            return None
        # Player is not in the status response (yet), retry
        else:
            if self._counter.get(cid):
                self.debug('%s not yet fully connected, retrying...#:%s' % (name, self._counter.get(cid)))
                self._counter[cid] += 1
                t = threading.Timer(4, self.newPlayer, (cid, codguid, name))
                t.start()
            else:
                #Falling trough
                self.warning('All authentication attempts failed.')
            return None

        client = self.clients.newClient(cid, name=name, ip=ip, state=b3.STATE_ALIVE, guid=guid, pbid=pbid,
                                        data={'codguid': codguid})
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client))

    def authorizeClients(self):
        players = self.getPlayerList(maxRetries=4)
        self.verbose('authorizeClients() = %s' % players)

        for cid, p in players.iteritems():
            sp = self.clients.getByCID(cid)
            if sp:
                # Only set provided data, otherwise use the currently set data
                sp.ip = p.get('ip', sp.ip)
                sp.pbid = p.get('pbid', sp.pbid)
                if self.IpsOnly:
                    sp.guid = p.get('ip', sp.guid)
                else:
                    sp.guid = p.get('guid', sp.guid)
                sp.data = p
                sp.auth()

#--LogLineFormats---------------------------------------------------------------

#===============================================================================
# 
# *** CoD:
# Join:               J;160913;10;PlayerName
# Quit:               Q;160913;10;PlayerName
# Damage by world:    D;160913;14;axis;PlayerName;;-1;world;;none;6;MOD_FALLING;none
# Damage by opponent: D;160913;19;allies;PlayerName;248102;10;axis;OpponentName;mp44_mp;27;MOD_PISTOL_BULLET;right_foot
# Kill:               K;160913;4;axis;PlayerName;578287;0;axis;OpponentName;kar98k_mp;180;MOD_HEAD_SHOT;head
# Weapon/ammo pickup: Weapon;160913;8;PlayerName;m1garand_mp
# Action:             A;160913;16;axis;PlayerName;htf_scored
# Say to All:         say;160913;8;PlayerName;^Ubye
# Say to Team:        sayteam;160913;8;PlayerName;^Ulol
# Private message:    tell;160913;12;PlayerName1;1322833;8;PlayerName2;what message?
# Winners:            W;axis;160913;PlayerName1;258015;PlayerName2
# Losers:             L;allies;160913;PlayerName1;763816;PlayerName2
# 
# ExitLevel:          ExitLevel: executed
# Shutdown Engine:    ShutdownGame:
# Seperator:          ------------------------------------------------------------
# InitGame:           InitGame: \_Admin\xlr8or\_b3\B3 v1.2.1b [posix]\_Email\admin@xlr8or.com\_Host\[SNT]
#                    \_Location\Twente University - The Netherlands\_URL\http://games.snt.utwente.nl/\fs_game\xlr1.7
#                    \g_antilag\1\g_gametype\tdm\gamename\Call of Duty 2\mapname\mp_toujane\protocol\115
#                    \scr_friendlyfire\3\scr_killcam\1\shortversion\1.0\sv_allowAnonymous\0\sv_floodProtect\1
#                    \sv_hostname\^5[SNT] #3 ^7Tactical Gaming ^9(^7B3^9) (^1v1.0^9)\sv_maxclients\24\sv_maxPing\220
#                    \sv_maxRate\20000\sv_minPing\0\sv_privateClients\8\sv_pure\1\sv_voice\1
# 
# 
# *** CoD5 specific lines:
# JoinTeam:           JT;283895439;17;axis;PlayerName;
#                    AD;564;allies;580090035;6;axis;PlayerName;stg44_mp;30;MOD_RIFLE_BULLET;right_arm_lower
#===============================================================================

########NEW FILE########
__FILENAME__ = cod2
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# CHANGELOG
# 31/01/2010 - 1.2.2 - xlr8or - Removed commandsdict, inherit from codparser
# 18/04/2010 - 1.2.3 - xlr8or - Forcing g_logsync to make server write unbuffered gamelogs
# 30/05/2010 - 1.2.4 - xlr8or - Setting exception for 31 char PBid in shortversion v1.2
# 17/10/2010 - 1.2.5 - xlr8or - Don't let version exceptions be inherited by later parsers
# 14/06/2011 - 1.3.0 - courgette - remove cvar specifics as the cvar regexp and code is 
#                                  now working good on the q3a AbstractParser


__author__  = 'ThorN, ttlogic, xlr8or'
__version__ = '1.3.0'

import b3.parsers.cod
import re

class Cod2Parser(b3.parsers.cod.CodParser):
    gameName = 'cod2'
    IpsOnly = False
    _logSync = 1 # Value for unbuffered game logging


    # set exceptions for this specific version of cod2
    def setVersionExceptions(self):
        # this shouldn't be inherited by later parsers, so restrict to this game only
        if self.gameName == 'cod2':
            if self.game.shortversion == '1.0' and not self.IpsOnly:
                self.warning('CoD2 version 1.0 has known limitations on Authentication! B3 will not work properly!')
            if self.game.shortversion == '1.2':
                # cod2 v1.2 has a bug so PBid's are 31 characters long, instead of 32, override the regexp for testing PBid's
                self.debug('Overriding pbid length for cod2 v1.2 with PB!')
                self._pbRegExp = re.compile(r'^[0-9a-f]{30,32}$', re.IGNORECASE) # RegExp to match a PunkBuster ID
            else:
                pass
        else:
            pass

########NEW FILE########
__FILENAME__ = cod4
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# v1.1.2  : xlr8or - Alternate approach on the <32 character guid issue
# v1.1.3  : xlr8or - Improved approach for non PB servers
#         : Tighter regexp for playernames. _reColor strips ascii <33, 47 and >127
#           This includes spaces and also the / is removed. 
# v1.1.4  : xlr8or - Removed bug for non PB servers
# v1.1.5  : Bakes - Improved suicide code, now works with weapon suicides, not falling.
# v1.1.6  : xlr8or - Minor bugfix regarding unassigned pbid on non pb servers.
# v1.2.0  : xlr8or - Big CoD4 MakeOver 
# 17/1/2010 - 1.2.1 - xlr8or
#  * Moved OnInitgame and OnExitlevel to codparser!
# 25/1/2010 - 1.3.0 - xlr8or - refactored cod parser series
# 27/1/2010 - 1.3.1 - xlr8or
#  * Added authorizeClients() for IpsOnly
#  * Minor bugfix in sync() for IpsOnly
# 31/1/2010 - 1.3.2 - xlr8or
#  * Modified unban to remove bans from game's ban list
# 1/5/2010 - 1.3.2 - xlr8or - delegate guid length checking to cod parser
# 7/11/2010 - 1.3.3 - GrosBedo
#    * messages now support named $variables instead of %s
# 8/11/2010 - 1.3.4 - GrosBedo
#    * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# 22/1/2012 - 1.3.5 -92ndab-Bravo17
#    * Add JT method for some COD4 mods
# 7/3/2012 - 1.3.6 - 82ndab-Bravo17
#    * Change Client Auth method so it updates empty pbids
# 2012/11/18 - 1.3.7 - Courgette
#    * fix: player not authenticated (without punkbuster) when qport or port is a negative number
# 2013/01/02 - 1.3.8 - Courgette
#    * improve parsing rcon status status responses that are missing characters
# 2013/01/12 - 1.3.9 - Courgette
#    * fix bug when cod4ClientAuthMethod handles an unexpected error
#

__author__  = 'ThorN, xlr8or'
__version__ = '1.3.9'

import b3.parsers.cod2
import b3.functions
import re, threading
from b3 import functions

class Cod4Parser(b3.parsers.cod2.Cod2Parser):
    gameName = 'cod4'
    IpsOnly = False
    _guidLength = 32

    #num score ping guid                             name            lastmsg address               qport rate
    #--- ----- ---- -------------------------------- --------------- ------- --------------------- ----- -----
    #  0     0   14 1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab player1^7               0 11.22.33.44:-6187 -1609 25000
    #  1     0   12 1ccccccccccccccccccccccccccccccc player2^7               0 22.33.44.55:-10803-23569 25000
    #  3   486  185 ecc77e3400a38cc71b3849207e20e1b0 GO_NINJA^7              0 111.222.111.111:-15535-2655 25000
    #  4     0   23 blablablabfa218d4be29e7168c637be ^1XLR^78^9or[^7^7               0 135.94.165.296:63564  25313 25000
    #  5    92  509 0123456789abcdef0123456789abcdef 7ajimaki^7            100 11.222.111.44:28960   -27329 25000
    #  6     0  206 0123456789a654654646545789abcdef [NRNS]ArmedGuy^7        0 11.22.111.44:28960    -21813 25000
    #  7    30  229 012343213211313213321313131bcdef Franco^7                0 111.22.111.111:23144  22922 25000
    _regPlayer = re.compile(r"""
^\s*
  (?P<slot>[0-9]+)
\s+
  (?P<score>[0-9-]+)
\s+
  (?P<ping>[0-9]+)
\s+
  (?P<guid>[0-9a-f]+)
\s+
  (?P<name>.*?)
\s+
  (?P<last>[0-9]+?)
\s*
  (?P<ip>(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))
:?
  (?P<port>-?[0-9]{1,5})
\s*
  (?P<qport>-?[0-9]{1,5})
\s+
  (?P<rate>[0-9]+)
$
""", re.IGNORECASE | re.VERBOSE)


    # join team (Some mods eg OW use JT)
    def OnJt(self, action, data, match=None):
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)
            client = self.getClient(match)
            if not client:
                return None
        client.team = self.getTeam(match.group('team'))
        self.debug('%s has just changed team to %s' % (client.name, client.team))
        
    
    # kill
    def OnK(self, action, data, match=None):
        victim = self.getClient(victim=match)
        if not victim:
            self.debug('No victim %s' % match.groupdict())
            self.OnJ(action, data, match)
            return None

        attacker = self.getClient(attacker=match)
        if not attacker:
            self.debug('No attacker %s' % match.groupdict())
            return None

        # COD4 doesn't report the team on kill, only use it if it's set
        # Hopefully the team has been set on another event
        if match.group('ateam'):
            attacker.team = self.getTeam(match.group('ateam'))

        if match.group('team'):
            victim.team = self.getTeam(match.group('team'))

        attacker.name = match.group('aname')
        victim.name = match.group('name')

        event = b3.events.EVT_CLIENT_KILL
        
        if attacker.cid == victim.cid or attacker.cid == '-1':
            self.verbose2('Suicide Detected')
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and \
             attacker.team and \
             victim.team and \
             attacker.team == victim.team and \
             match.group('aweap') != 'briefcase_bomb_mp':
            self.verbose2('Teamkill Detected')
            event = b3.events.EVT_CLIENT_KILL_TEAM

        victim.state = b3.STATE_DEAD
        return b3.events.Event(event, (float(match.group('damage')), match.group('aweap'), match.group('dlocation'), match.group('dtype')), attacker, victim)

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        if self.PunkBuster:
            if client.pbid:
                result = self.PunkBuster.unBanGUID(client)

                if result:                    
                    admin.message('^3Unbanned^7: %s^7: %s' % (client.exactName, result))

                if admin:
                    fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))

                if not silent and fullreason != '':
                    self.say(fullreason)
            elif admin:
                admin.message('%s^7 unbanned but has no punkbuster id' % client.exactName)
        else:
            _name = self.stripColors(client.exactName[:15])
            result = self.write(self.getCommand('unban', name=_name, reason=reason))
            if admin:
                admin.message(result)

    def sync(self):
        self.debug('Synchronising Clients')
        plist = self.getPlayerList(maxRetries=4)
        self.verbose2('plist: %s' % plist)
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                self.verbose2('Client found: %s' % client.name)
                if client.guid and c.has_key('guid') and not self.IpsOnly:
                    if functions.fuzzyGuidMatch(client.guid, c['guid']):
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
            else:
                self.verbose2('No client found for cid: %s' % cid)
        
        return mlist

    def authorizeClients(self):
        players = self.getPlayerList()
        self.verbose('authorizeClients() = %s' % players)

        for cid, p in players.iteritems():
            if self.PunkBuster:
                # Use guid since we already get the guid in the log file
                sp = self.clients.getByGUID(p['guid'])

                # Don't use invalid guid/pbid
                if len(p['guid']) < 32:
                    del p['guid']

                if len(p['pbid']) < 32:
                    del p['pbid']
            else:
                sp = self.clients.getByCID(cid)

            if sp:
                # Only set provided data, otherwise use the currently set data
                sp.ip   = p.get('ip', sp.ip)
                sp.pbid = p.get('pbid', sp.pbid)
                if self.IpsOnly:
                    sp.guid = p.get('ip', sp.guid)
                else:
                    sp.guid = p.get('guid', sp.guid)
                sp.data = p
                sp.auth()


#############################################################
# Below is the code that change a bit the b3.clients.Client
# class at runtime. What the point of coding in python if we
# cannot play with its dynamic nature ;)
#
# why ?
# because doing so make sure we're not broking any other 
# working and long tested parser. The changes we make here
# are only applied when the frostbite parser is loaded.
#############################################################
  

def cod4ClientAuthMethod(self):
    if not self.authed and self.guid and not self.authorizing:
        self.authorizing = True

        name = self.name
        ip = self.ip
        pbid = self.pbid
        try:
            inStorage = self.console.storage.getClient(self)
        except KeyError, msg:
            self.console.debug('User not found %s: %s', self.guid, msg)
            inStorage = False
        except Exception, e:
            self.console.error('auth self.console.storage.getClient(client) - %s' % self, exc_info=e)
            self.authorizing = False
            return False

        #lastVisit = None
        if inStorage:
            self.console.bot('Client found in storage %s, welcome back %s', str(self.id), self.name)
            self.lastVisit = self.timeEdit
            if self.pbid == '':
                self.pbid = pbid
        else:
            self.console.bot('Client not found in the storage %s, create new', str(self.guid))

        self.connections = int(self.connections) + 1
        self.name = name
        self.ip = ip
        self.save()
        self.authed = True

        self.console.debug('Client Authorized: [%s] %s - %s', self.cid, self.name, self.guid)

        # check for bans
        if self.numBans > 0:
            ban = self.lastBan
            if ban:
                self.reBan(ban)
                self.authorizing = False
                return False

        self.refreshLevel()

        self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_AUTH,
            self,
            self))

        self.authorizing = False

        return self.authed
    else:
        return False
            
b3.clients.Client.auth = cod4ClientAuthMethod

########NEW FILE########
__FILENAME__ = cod5
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# 2/27/2009 - 1.0.1 - xlr8or
#  Added connection counter to prevent infinite newPlayer() loop.
#  Changed check on length of guid.
#  Break off authentication if no codguid and no PB is available to prevent error flooding
# 3/3/2009 - 1.0.2 - xlr8or
#  Fixed typo causing Exception in newPlayer()
# 19/5/2009 - 1.0.3 - xlr8or
#  Changed authentication queue to remove an Exception raised when the Key was no longer available
# 31/10/2009 - 1.0.4 - xlr8or
#  Fixed suicides
# 6/1/2010 - 1.0.5 - xlr8or
#  Fixed unassigned pbid bug for non-pb servers
# 9/1/2010 - 1.0.6 - xlr8or
#  Moved sync to a thread 30 secs after InitGame
# 17/1/2010 - 1.0.7 - xlr8or
#  Moved OnInitgame and OnExitlevel to codparser!
# 25/1/2010 - 1.2.0 - xlr8or - refactored cod parser series
# 1/5/2010 - 1.2.1 - xlr8or - delegate guid length checking to cod parser
# 24/10/2010 - 1.3 - xlr8or 
#  ActionMapping added
#  Add JoinTeam event processing
# 14/11/2010 - 1.3.1 - xlr8or 
#  fix bug in onJT() and translateAction()
# 9/7/2011 - 1.3.2 - 82ndab.Bravo17
#  Add fuzzy guid search in sync() from COD4 series

__author__  = 'xlr8or'
__version__ = '1.3.2'

import b3.parsers.cod2
import b3.functions
import re
import threading
import string
from b3 import functions

class Cod5Parser(b3.parsers.cod2.Cod2Parser):
    gameName = 'cod5'
    IpsOnly = False
    _guidLength = 9

    """\
    Next actions need translation to the EVT_CLIENT_ACTION (Treyarch has a different approach on actions)
    While IW put all EVT_CLIENT_ACTION in the A; action, Treyarch creates a different action for each EVT_CLIENT_ACTION.
    """
    _actionMap = (
        'ad', # Actor Damage (dogs)
        'vd', # Vehicle Damage
        'bd', # Bomb Defused
        'bp', # Bomb Planted
        'fc', # Flag Captured
        'fr', # Flag Returned
        'ft', # Flag Taken
        'rc', # Radio Captured
        'rd'  # Radio Destroyed
    )

    def parseLine(self, line):           
        m = self.getLineParts(line)
        if not m:
            return False

        match, action, data, client, target = m

        func = 'On%s' % string.capwords(action).replace(' ','')
        
        #self.debug("-==== FUNC!!: " + func)
        
        if hasattr(self, func):
            func = getattr(self, func)
            event = func(action, data, match)

            if event:
                self.queueEvent(event)
        elif action in self._eventMap:
            self.queueEvent(b3.events.Event(
                    self._eventMap[action],
                    data,
                    client,
                    target
                ))

        # Addition for cod5 actionMapping
        elif action in self._actionMap:
            self.translateAction(action, data, match)

        else:
            self.queueEvent(b3.events.Event(
                    b3.events.EVT_UNKNOWN,
                    str(action) + ': ' + str(data),
                    client,
                    target
                ))

    def translateAction(self, action, data, match=None):
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)
            client = self.getClient(match)
            if not client:
                return None
        self.debug('Queueing Action (translated) for %s: %s' % (client.name, action) )
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_ACTION, action, client))

    # kill
    def OnK(self, action, data, match=None):
        victim = self.getClient(victim=match)
        if not victim:
            self.debug('No victim %s' % match.groupdict())
            self.OnJ(action, data, match)
            return None

        attacker = self.getClient(attacker=match)
        if not attacker:
            self.debug('No attacker %s' % match.groupdict())
            return None

        # COD5 first version doesn't report the team on kill, only use it if it's set
        # Hopefully the team has been set on another event
        if match.group('ateam'):
            attacker.team = self.getTeam(match.group('ateam'))

        if match.group('team'):
            victim.team = self.getTeam(match.group('team'))

        attacker.name = match.group('aname')
        victim.name = match.group('name')

        event = b3.events.EVT_CLIENT_KILL
        
        if attacker.cid == victim.cid or attacker.cid == '-1':
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and \
             attacker.team and \
             victim.team and \
             attacker.team == victim.team and \
             match.group('aweap') != 'briefcase_bomb_mp':
            event = b3.events.EVT_CLIENT_KILL_TEAM

        victim.state = b3.STATE_DEAD
        return b3.events.Event(event, (float(match.group('damage')), match.group('aweap'), match.group('dlocation'), match.group('dtype')), attacker, victim)

    # join team
    def OnJt(self, action, data, match=None):
        client = self.getClient(match)
        if not client:
            self.debug('No client - attempt join')
            self.OnJ(action, data, match)
            client = self.getClient(match)
            if not client:
                return None
        client.team = self.getTeam(match.group('team'))
        
    # sync
    def sync(self):
        self.debug('Synchronising Clients')
        plist = self.getPlayerList(maxRetries=4)
        mlist = {}

        for cid, c in plist.iteritems():
            cid = str(cid)
            client = self.clients.getByCID(cid)
            if client:
                if client.guid and c.has_key('guid') and not self.IpsOnly:
                    if functions.fuzzyGuidMatch(client.guid, c['guid']):
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist

########NEW FILE########
__FILENAME__ = cod6
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 25/04/2011 - v0.6 - xlr8or
#  * action logging - get client by name.
# 24/04/2011 - v0.5 - xlr8or
#  * disable action logging - game engine bug.
# 18/03/2011 - v0.4 - Freelander
#  * Fixed a typo causing permanent bans fail
# 24/01/2010 - v0.3 - xlr8or
#  * replaced _commands dict to fix broken ban command 
# 09/10/2010 - v0.2 - jerbob92 
#  * set sv_hostname at statup
# 02/10/2010 - v0.1 - NTAuthority (http://alteriw.net/)



__author__  = 'NTAuthority'
__version__ = '0.6'

import b3.parsers.cod4
import re

class Cod6Parser(b3.parsers.cod4.Cod4Parser):
    gameName = 'cod6'
    _guidLength = 16

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'clientkick %(cid)s'
    _commands['unban'] = 'unbanuser %(name)s' # remove players from game engine's ban.txt
    _commands['tempban'] = 'clientkick %(cid)s'

    _regPlayer = re.compile(r'(?P<slot>[0-9]+)[\s\0]+(?P<score>[0-9-]+)[\s\0]+(?P<ping>[0-9]+)[\s\0]+(?P<guid>[a-z0-9]+)[\s\0]+(?P<name>.*?)[\s\0]+(?P<last>[0-9]+)[\s\0]+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)', re.I)

    def startup(self):
        b3.parsers.cod4.Cod4Parser.startup(self)
        try:
            self.game.sv_hostname = self.getCvar('sv_hostname').getString().rstrip('/')
            self.debug('sv_hostname: %s' % self.game.sv_hostname)
        except:
            self.game.sv_hostname = None
            self.warning('Could not query server for sv_hostname')

    # action
    def OnA(self, action, data, match=None):
        #bugged: cid and guid both 0
        #10420 19:24:38   CONSOLE   67:19 A;0;0;allies;clubdegamers12;hq_destroyed
        #can only get client by name...
        client = self.clients.getByName(name)
        if not client:
            return None

        actiontype = match.group('type')
        self.verbose('OnAction: %s: %s' % (client.name, actiontype) )
        return b3.events.Event(b3.events.EVT_CLIENT_ACTION, actiontype, client)

########NEW FILE########
__FILENAME__ = cod7
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 15.01.2011 - 1.0.0 - Freelander, Courgette
#   * Initial release
# 22.01.2011 - 1.0.1 - Freelander
#   * Do not try to authenticate [3arc]democlient
#   * Inherits from cod5 parser now to handle actions
# 01.02.2011 - 1.0.2 - Freelander
#   * Force glogsync to 1 on every round start as it may be lost after a 
#     server restart/crash 
# 01.02.2011 - 1.0.3 - Just a baka
#   * Pre-Match Logic
# 08.02.2011 - 1.0.4 - Just a baka
#   * Reworked Pre-Match logic to reflect latest changes to cod7http
# 02.03.2011 - 1.0.5 -Bravo17
#   * Added test to make sure cod7http still running
#   * Tidied up startup console output
# 02.04.2011 - 1.0.6 - Freelander
#   * onK: Fix for suicide events to be handled correctly by XLRstats
#   * Set playercount to 4 in pre-match logic
# 09.04.2011 - 1.0.7 - Courgette
#   * reflect that cid are not converted to int anymore in the clients module
# 14.04.2011 - 1.0.8 - Freelander
#   * Fixed rcon set command that was changed as setadmindvar in CoD7
# 25.05.2011 - 1.1 - Courgette
#   * kick commands now sends reason
# 30.12.2011 - 1.2 - Bravo17
#   * New client will now join Auth queue if slot shows as 'Disconnected' in Auth queue
# 25.07.2012 - 1.2.1 - Courgette
#   * Make sure the cod7http plugin is loaded
#

## @file
#  CoD7 Parser

__author__  = 'Freelander, Courgette, Just a baka, Bravo17'
__version__ = '1.2.1'

import re
import string
import threading
import b3.parsers.cod7_rcon as rcon
import b3.parsers.cod5
import os

class Cod7Parser(b3.parsers.cod5.Cod5Parser):
    gameName = 'cod7'
    IpsOnly = False
    _guidLength = 5
    OutputClass = rcon.Cod7Rcon

    _usePreMatchLogic = True
    _preMatch = False
    _elFound = True
    _igBlockFound = False
    _sgFound = False
    _logTimer = 0
    _logTimerOld = 0
    _cod7httpplugin = None

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'setadmindvar %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s "%(reason)s"'
    _commands['ban'] = 'banclient %(cid)s'
    _commands['unban'] = 'unbanuser "%(name)s"'
    _commands['tempban'] = 'clientkick %(cid)s "%(reason)s"'

    """\
    Next actions need translation to the EVT_CLIENT_ACTION (Treyarch has a different approach on actions)
    While IW put all EVT_CLIENT_ACTION in the A; action, Treyarch creates a different action for each EVT_CLIENT_ACTION.
    """
    _actionMap = (
        'AD', # Actor Damage (dogs)
        'VD'  # Vehicle Damage
    )

    #num score ping guid                             name            lastmsg address               qport rate
    #--- ----- ---- -------------------------------- --------------- ------- --------------------- ----- -----
    #  4     0   23 blablablabfa218d4be29e7168c637be ^1XLR^78^9or[^7^7               0 135.94.165.296:63564  25313 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<guid>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)(?P<qportsep>[-\s]+)(?P<qport>[0-9-]+)\s+(?P<rate>[0-9]+)$', re.I)
    _regPlayerWithDemoclient = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<guid>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+|unknown):?(?P<port>[0-9-]+)?(?P<qportsep>[-\s]+)(?P<qport>[0-9-]+)\s+(?P<rate>[0-9]+)$', re.I)

    def startup(self):
        """Implements some necessary tasks on initial B3 start."""

        # add the world client
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')

        self._cod7httpplugin = self.getPlugin('cod7http')
        if self._cod7httpplugin is None:
            self.critical("cannot found cod7http plugin")
            raise SystemExit(220)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)

        if self.config.has_option('server', 'use_prematch_logic'):
            self._usePreMatchLogic = self.config.getboolean('server', 'use_prematch_logic')

        # Pre-Match Logic part 1
        if self._usePreMatchLogic:
            self._regPlayer, self._regPlayerWithDemoclient = self._regPlayerWithDemoclient, self._regPlayer
            playerList = self.getPlayerList()
            self._regPlayer, self._regPlayerWithDemoclient = self._regPlayerWithDemoclient, self._regPlayer
        
            if len(playerList) >= 4:
                self.verbose('PREMATCH OFF: PlayerCount >=4: not a Pre-Match')
                self._preMatch = False
            elif '0' in playerList and playerList['0']['guid'] == '0':
                self.verbose('PREMATCH OFF: Got a democlient presence: not a Pre-Match')
                self._preMatch = False
            else:
                self.verbose('PREMATCH ON: PlayerCount < 4, got no democlient presence. Defaulting to a pre-match.')
                self._preMatch = True
        else:
            self._preMatch = False

        # Force g_logsync
        self.debug('Forcing server cvar g_logsync to %s and turning UNIX timestamp log timers off.' % self._logSync)
        self.write('g_logsync %s' % self._logSync)
        self.write('g_logTimeStampInSeconds 0')

        self.setVersionExceptions()
        self.debug('Parser started.')

    def parseLine(self, line):
        """Called from parseLine method in Parser class to introduce pre-match logic
        and action mapping
        """

        m = self.getLineParts(line)
        if not m:
            return False

        match, action, data, client, target = m

        func = 'On%s' % string.capwords(action).replace(' ','')

        # Timer (in seconds) that always reflects the current event's timestamp
        t = re.match(self._lineTime, line)
        if t:
            self._logTimerOld = self._logTimer
            self._logTimer = int(t.group('minutes')) * 60 + int(t.group('seconds'))

        # Pre-Match Logic part 2
        # Ignore Pre-Match K/D-events
        if self._preMatch and (func == 'OnD' or func == 'OnK' or func == 'OnAd' or func == 'OnVd'):
            self.verbose('PRE-MATCH: Ignoring kill/damage.')
            return False

        # Prevent OnInitgame from being called twice due to server-side initGame doubling
        elif func == 'OnInitgame':
            if not self._igBlockFound:
                self._igBlockFound = True
                self.verbose('Found 1st InitGame from block')
            elif self._logTimerOld <= self._logTimer:
                self.verbose('Found 2nd InitGame from block, ignoring')
                return False

        # ExitLevel means there will be Pre-Match right after the mapload
        elif self._usePreMatchLogic and func == 'OnExitlevel':
            self._preMatch = True
            self.debug('PRE-MATCH ON: found ExitLevel')
            self._elFound = True
            self._igBlockFound = False

        # If we track ShutdownGame events, we could detect sudden server restarts and re-matches
        elif func == 'OnShutdowngame':
            self._sgFound = True
            self._igBlockFound = False

        # Round switch (InitGame after ShutdownGame, but there was no ExitLevel):
        if self._preMatch and not self._elFound and self._igBlockFound and self._sgFound and self._logTimerOld <= self._logTimer:
            self.preMatch = False
            self.debug('PRE-MATCH OFF: found a round change.')
            self._igBlockFound = False
            self._sgFound = False

        # Timer reset
        elif self._logTimerOld > self._logTimer:
            self.debug('Old timer: %s / New timer: %s' % (self._logTimerOld, self._logTimer))
            if self._usePreMatchLogic:
                self._preMatch = True
                self.debug('PRE-MATCH ON: Server crash/restart detected.')
            else:
                self.debug('Server crash/restart detected.')
            self._elFound = False
            self._igBlockFound = False
            self._sgFound = False

            # Payload
            self.write('setadmindvar g_logsync %s' % self._logSync)
            self.write('setadmindvar g_logTimeStampInSeconds 0')

        # Initgame after ExitLevel
        else:
            self._elFound = False
            self._sgFound = False

        #self.debug("-==== FUNC!!: " + func)

        if hasattr(self, func):
            func = getattr(self, func)
            event = func(action, data, match)

            if event:
                self.queueEvent(event)
        elif action in self._eventMap:
            self.queueEvent(b3.events.Event(
                    self._eventMap[action],
                    data,
                    client,
                    target
                ))

        # Addition for cod7 actionMapping
        elif action in self._actionMap:
            self.translateAction(action, data, match)

        else:
            self.queueEvent(b3.events.Event(
                    b3.events.EVT_UNKNOWN,
                    str(action) + ': ' + str(data),
                    client,
                    target
                ))

    def OnJ(self, action, data, match=None):
        """Client join"""

        codguid = match.group('guid')
        cid = match.group('cid')
        name = match.group('name')

        if codguid == '0' and cid == '0' and name == '[3arc]democlient':
            self.verbose('Authentication not required for [3arc]democlient. Aborting Join.')
            self._preMatch = 0
            return None
        
        if len(codguid) < self._guidLength:
            # invalid guid
            self.verbose2('Invalid GUID: %s' %codguid)
            codguid = None

        client = self.getClient(match)

        if client:
            self.verbose2('ClientObject already exists')
            # lets see if the name/guids match for this client, prevent player mixups after mapchange (not with PunkBuster enabled)
            if not self.PunkBuster:
                if self.IpsOnly:
                    # this needs testing since the name cleanup code may interfere with this next condition
                    if name != client.name:
                        self.debug('This is not the correct client (%s <> %s), disconnecting' %(name, client.name))
                        client.disconnect()
                        return None
                    else:
                        self.verbose2('client.name in sync: %s == %s' %(name, client.name))
                else:
                    if codguid != client.guid:
                        self.debug('This is not the correct client (%s <> %s), disconnecting' %(codguid, client.guid))
                        client.disconnect()
                        return None
                    else:
                        self.verbose2('client.guid in sync: %s == %s' %(codguid, client.guid))
            # update existing client
            client.state = b3.STATE_ALIVE
            # possible name changed
            client.name = name
            # Join-event for mapcount reasons and so forth
            return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)
        else:
            if self._counter.get(cid) and self._counter.get(cid) != 'Disconnected':
                self.verbose('cid: %s already in authentication queue. Aborting Join.' %cid)
                return None
            self._counter[cid] = 1
            t = threading.Timer(2, self.newPlayer, (cid, codguid, name))
            t.start()
            self.debug('%s connected, waiting for Authentication...' %name)
            self.debug('Our Authentication queue: %s' % self._counter)

    # kill
    def OnK(self, action, data, match=None):
        victim = self.clients.getByGUID(match.group('guid'))
        if not victim:
            self.debug('No victim %s' % match.groupdict())
            self.OnJ(action, data, match)
            return None

        attacker = self.clients.getByGUID(match.group('aguid'))
        if not attacker:
            if match.group('acid') == '-1' or match.group('aname') == 'world':
                self.verbose('World kill')
                attacker = self.getClient(attacker=match)
            else:
                self.debug('No attacker %s' % match.groupdict())
                return None

        # COD5 first version doesn't report the team on kill, only use it if it's set
        # Hopefully the team has been set on another event
        if match.group('ateam'):
            attacker.team = self.getTeam(match.group('ateam'))

        if match.group('team'):
            victim.team = self.getTeam(match.group('team'))

        event = b3.events.EVT_CLIENT_KILL

        if attacker == victim or attacker.cid == '-1':
            self.verbose('Suicide Detected, attacker.cid: %s, victim.cid: %s' % (attacker.cid, victim.cid))
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team and victim.team and attacker.team == victim.team:
            self.verbose('Team kill detected, %s team killed %s' % (attacker.name, victim.name))
            event = b3.events.EVT_CLIENT_KILL_TEAM

        victim.state = b3.STATE_DEAD
        return b3.events.Event(event, (float(match.group('damage')), match.group('aweap'), match.group('dlocation'), match.group('dtype')), attacker, victim)

    def read(self):
        """read from game server log file"""
        # Getting the stats of the game log (we are looking for the size)
        filestats = os.fstat(self.input.fileno())

        thread_alive = self._cod7httpplugin.httpThreadalive()
        if not thread_alive:
            self.verbose('Cod7Http Plugin has stopped working, restarting')
            self.restart()

        # Compare the current cursor position against the current file size,
        # if the cursor is at a number higher than the game log size, then
        # there's a problem


        if self.input.tell() > filestats.st_size:
            self.debug('Parser: Game log is suddenly smaller than it was before (%s bytes, now %s), the log was probably either rotated or emptied. B3 will now re-adjust to the new size of the log.' % (str(self.input.tell()), str(filestats.st_size)) )
            self.input.seek(0, os.SEEK_END)
        return self.input.readlines()

###################################################################
# ALTER THE WAY parser.py work for game logs starting with http://
###################################################################

from b3.parser import Parser

# backup original loadArbPlugins
originalLoadArbPlugins = Parser.loadArbPlugins

def newLoadArbPlugins(self):
    """Call original loadArbPlugin method from the Parser class
    then unload the httpytail plugin
    then load the cod7http plugin instead"""
    print "running newLoadArbPlugins "
    
    ## first, run usual loadArbPlugins
    originalLoadArbPlugins(self)
    
    if self.config.has_option('server','game_log') \
        and self.config.get('server','game_log')[0:7] == 'http://' :
        
        # undo httpytail load
        self.screen.write('Unloading        : http Plugin\n')
        self._pluginOrder.remove('httpytail')
        del self._plugins['httpytail']

        # load cod7http        
        p = 'cod7http'
        self.bot('Loading %s', p)
        try:
            pluginModule = self.pluginImport(p)
            self._plugins[p] = getattr(pluginModule, '%sPlugin' % p.title()) (self)
            self._pluginOrder.append(p)
            version = getattr(pluginModule, '__version__', 'Unknown Version')
            author  = getattr(pluginModule, '__author__', 'Unknown Author')
            self.bot('Plugin %s (%s - %s) loaded', p, version, author)
            self.screen.write('Loading          : COD7 http Plugin\n')
            self.screen.flush()
        except Exception, msg:
            self.critical('Error loading plugin: %s', msg)
            raise SystemExit('error while loading %s' % p)

# make newLoadArbPlugins the default
Parser.loadArbPlugins = newLoadArbPlugins
########NEW FILE########
__FILENAME__ = cod7_rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Changelog :

# 2011/02/01 -1.1.0 - Bravo17
# * Support for cod7 rcon format added 
# 
#
 
__author__ = 'Bravo17'
__version__ = '1.1.0'
 
import socket, sys, select, re, time, thread, threading, Queue
import b3
import b3.parsers.q3a.rcon

#--------------------------------------------------------------------------------------------------
class Cod7Rcon(b3.parsers.q3a.rcon.Rcon):
    rconsendstring = '\xff\xff\xff\xff\x00%s %s\00'
    rconreplystring = '\xff\xff\xff\xff\x01print\n'

########NEW FILE########
__FILENAME__ = cod8
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 08/01/2012 - v0.1 - NTAuthority (http://fourdeltaone.net/)



__author__  = 'NTAuthority'
__version__ = '0.1'

import b3.parsers.cod6
import re

class Cod8Parser(b3.parsers.cod6.Cod6Parser):
    gameName = 'cod8'
    _guidLength = 16

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'dropclient %(cid)s "%(reason)s"'
    _commands['ban'] = 'banclient %(cid)s'
    _commands['unban'] = 'unban \"%(name)s\"' # remove players from game engine's permanent.ban
    _commands['tempban'] = 'tempbanclient %(cid)s "%(reason)s"'

    _regPlayer = re.compile(r'(?P<slot>[0-9]+)[\s\0]+(?P<score>[0-9-]+)[\s\0]+(?P<ping>[0-9]+)[\s\0]+(?P<guid>[a-z0-9]+)[\s\0]+(?P<name>.*?)[\s\0]+(?P<last>[0-9]+)[\s\0]+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)', re.I)

    def startup(self):
        b3.parsers.cod6.Cod6Parser.startup(self)
        


########NEW FILE########
__FILENAME__ = csgo
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 <courgette@bigbrotherbot.net>
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
#
# 2012-08-28 - 0.4 - Courgette
#   * fix sync()
# 2012-08-28 - 0.5 - Courgette
#   * fix SourceRconError: RCON message too large to send
#   * should fix UnicodeDecodeError in Rcon class when sending a command
#   * refactors the regular expressions for game events to make them easier to read
#   * add method parseProperties which helps extracting extended game log format
#   * add SourceMod SuperLogs CS:S specific events : EVT_SUPERLOGS_WEAPONSTATS and EVT_SUPERLOGS_WEAPONSTATS2
# 2012-08-29 - 0.6 - Courgette
#   * fix Courgette/big-brother-bot#84 - SourceRconError: RCON message too large to send
#   * fix Courgette/big-brother-bot#85 - rcon write() does is missing the maxRetries parameter
#   * fix Courgette/big-brother-bot#86 - UnicodeDecodeError
#   * add kill location as a 5th element to data for events EVT_CLIENT_KILL EVT_CLIENT_SUICIDE EVT_CLIENT_KILL_TEAM
#     if the SourceMod SuperLogs plugin is active and provides kill locations.
#   * fire EVT_CLIENT_ACTION events for game events Got_The_Bomb, Dropped_The_Bomb, Planted_The_Bomb,
#     Begin_Bomb_Defuse_Without_Kit, Defused_The_Bomb, headshot, round_mvp
# 2012-09-11 - 0.7 Courgette
#   * tweak say lines max length
# 2012-09-11 - 0.8 Courgette
#   * full unicode support
# 2012-09-13 - 1.0 Courgette
#   * split long messages into lines and add B3 prefixes to them
# 2012-09-13 - 1.1 Courgette
#   * add support for SourceMod plugin "B3 Say"
# 2012-09-17 - 1.2 Courgette
#   * fix say event when player has no team
#   * fix ban/tempban/unban
#   * add event EVT_SERVER_REQUIRES_RESTART which is triggered when the server requires a restart. This can be useful
#     for a plugin could act upon such event by send an email to admin, restarting the server, ...
#   * implement rotateMap() => the admin plugin !mapcycle command now works
#   * the admin plugin !map command is now able to provide suggestions if map name is incorrect
# 2012-09-19 - 1.3 Courgette
#   * fix issue #88 (https://github.com/courgette/big-brother-bot/issues/88) regarding clan name appearing in some of
#     the game log lines in place of the player team.
# 2012-10-08 - 1.4 Courgette
#   * better detection of EVT_SERVER_REQUIRES_RESTART
#   * now detect client action Begin_Bomb_Defuse_With_Kit
#   * fix #90 - check that SourceMod is installed at startup
# 2012-10-19 - 1.4.1 Courgette
#   * fix ban that was queuing a EVT_CLIENT_BAN_TEMP event instead of EVT_CLIENT_BAN
#
#
import re
import time
from b3.clients import Client, Clients
from b3.functions import minutesStr, time2minutes, getStuffSoundingLike
from b3.parser import Parser
from b3 import TEAM_UNKNOWN, TEAM_BLUE, TEAM_SPEC, TEAM_RED
from b3.game_event_router import Game_event_router
from b3.parsers.source.rcon import Rcon

__author__  = 'Courgette'
__version__ = '1.4.1'


"""
GAME SETUP
==========

In order to have a consistent name for the game log file, you need to start the game server with '-condebug' as a
command line parameter. The game server log file can then be found in the csgo folder under the name 'console.log'.

You must have SourceMod installed on the game server. See http://www.sourcemod.net/

Make sure to avoid conflict with in-game commands between B3 and SourceMod by choosing different command prefixes.
See PublicChatTrigger and SilentChatTrigger in addons/sourcemod/configs/core.cfg


SourceMod recommended plugins
-----------------------------

### B3 Say
If you have the SourceMod plugin B3 Say installed (http://forum.bigbrotherbot.net/counter-strike-global-offensive/sourcemod-plugins-for-b3/)
then the messages sent by B3 will better displayed on screen.

### SuperLogs:CS:S
If you have the SourceMod plugin SuperLogs:CS:S installed (http://forums.alliedmods.net/showthread.php?p=897271) then
kill stats will be more accurate.


"""


"""
TODO
====

# from https://developer.valvesoftware.com/wiki/HL_Log_Standard

- find out if a player can rename himself in-game, and if yes, what kind of event we have in the game log : "Name<uid><wonid><team>" changed name to "Name"
- find out if we can have injury game log line : "Name<uid><wonid><team>" attacked "Name<uid><wonid><team>" with "weapon" (damage "damage")
- find out if we can have Player-Player Actions : "Name<uid><wonid><team>" triggered "action" against "Name<uid><wonid><team>"





"""

# disable the authorizing timer that come by default with the b3.clients.Clients class
Clients.authorizeClients = lambda *args, **kwargs: None

# Regular expression recognizing a HalfLife game engine log line as described at https://developer.valvesoftware.com/wiki/HL_Log_Standard
RE_HL_LOG_LINE = r'''^L [01]\d/[0-3]\d/\d+ - [0-2]\d:[0-5]\d:[0-5]\d:\s*(?P<data>.*)'''

# Regular expression able to extract properties from HalfLife game engine log line as described at
# https://developer.valvesoftware.com/wiki/HL_Log_Standard#Notes
RE_HL_LOG_PROPERTY = re.compile('''\((?P<key>[^\s\(\)]+)(?P<data>| "(?P<value>[^"]*)")\)''')

# Regular expression to parse cvar queries responses
RE_CVAR = re.compile(r'''^"(?P<cvar>\S+?)" = "(?P<value>.*?)" \( def. "(?P<default>.*?)".*$''', re.MULTILINE)


ger = Game_event_router()

class CsgoParser(Parser):
    """
    The 'Counter-Strike: Global Offensive' B3 parser class
    """
    gameName = "csgo"
    privateMsg = True
    OutputClass = Rcon
    PunkBuster = None

    # extract the time from game log line
    _lineTime  = re.compile(r"""^L [01]\d/[0-3]\d/\d+ - [0-2]\d:(?P<minutes>[0-5]\d):(?P<seconds>[0-5]\d):\s*""")


    # game engine does not support color code, so we need this property
    # in order to get stripColors working
    _reColor = re.compile(r'(\^[0-9])')


    _settings = {'line_length': 200,
                 'min_wrap_length': 200}


    ###############################################################################################
    #
    #    B3 parser initialisation steps
    #
    ###############################################################################################

    def startup(self):

        if not self.is_sourcemod_installed():
            self.critical("You need to have SourceMod installed on your game server")
            raise SystemExit(220)

        # add game specific events
        self.createEvent("EVT_SUPERLOGS_WEAPONSTATS", "SourceMod SuperLogs weaponstats")
        self.createEvent("EVT_SUPERLOGS_WEAPONSTATS2", "SourceMod SuperLogs weaponstats2")
        self.createEvent("EVT_SERVER_REQUIRES_RESTART", "Source server requires restart")

        # create the 'Server' client
        # todo self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN)

        self.game.cvar = {}
        self.queryServerInfo()

        # load SM plugins list
        self.sm_plugins = self.get_loaded_sm_plugins()

        # keeps the last properties from a killlocation game event
        self.last_killlocation_properties = None


    def pluginsStarted(self):
        """
        Called once all plugins were started.
        Handy if some of them must be monkey-patched.
        """
        pass



    ###############################################################################################
    #
    #    Game events handlers
    #
    #    Read HL Log Standard documentation at https://developer.valvesoftware.com/wiki/HL_Log_Standard
    #
    ###############################################################################################

    @ger.gameEvent(
        r'''^//''', # comment log line
        r'''^server cvars start''',
        r'''^server cvars end''',
        r'''^\[basechat\.smx\] .*''',
        r'''^\[META\] Loaded \d+ plugins \(\d+ already loaded\)$''',
        r'''^Log file closed.$''',
        r'''^\[META\] Loaded \d+ plugin.$''',
    )
    def ignored_line(self):
        # L 09/24/2001 - 18:44:50: // This is a comment in the log file. It should not be parsed.
        # L 08/26/2012 - 05:29:47: server cvars start
        # L 08/26/2012 - 05:29:47: server cvars end
        # L 08/27/2012 - 23:57:45: [basechat.smx] "Console<0><Console><Console>" triggered sm_say (text "courgette put in group User")
        # L 08/30/2012 - 00:43:10: Log file closed.
        # L 08/30/2012 - 00:45:42: [META] Loaded 1 plugin.
        pass


    @ger.gameEvent(r'''"(?P<a_name>.+)<(?P<a_cid>\d+)><(?P<a_guid>.+)><(?P<a_team>.*)>" killed "(?P<v_name>.+)<(?P<v_cid>\d+)><(?P<v_guid>.+)><(?P<v_team>.*)>" with "(?P<weapon>\S*)"(?P<properties>.*)$''')
    def on_kill(self, a_name, a_cid, a_guid, a_team, v_name, v_cid, v_guid, v_team, weapon, properties):
        # L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Ringo<17><BOT><CT>" with "glock" (headshot)
        # L 08/26/2012 - 03:46:46: "Shark<19><BOT><CT>" killed "Pheonix<22><BOT><TERRORIST>" with "hkp2000"
        # L 08/26/2012 - 03:47:40: "Stone<18><BOT><TERRORIST>" killed "Steel<13><BOT><CT>" with "glock"
        # L 08/26/2012 - 05:08:56: "Kurt<76><BOT><TERRORIST>" killed "courgette<2><STEAM_1:0:1487018><CT>" with "galilar"'
        attacker = self.getClientOrCreate(a_cid, a_guid, a_name, a_team)
        victim = self.getClientOrCreate(v_cid, v_guid, v_name, v_team)
        # victim.state = b3.STATE_DEAD ## do we need that ? is this info used ?

        props = self.parseProperties(properties)
        headshot = props.get('headshot', False)

        event_type = "EVT_CLIENT_KILL"
        if attacker.cid == victim.cid:
            event_type = "EVT_CLIENT_SUICIDE"
        elif attacker.team in (TEAM_BLUE, TEAM_RED) and attacker.team == victim.team:
            event_type = "EVT_CLIENT_KILL_TEAM"

        damage_pct = 100
        damage_type = None
        hit_location = "head" if headshot else "body"
        data = [damage_pct, weapon, hit_location, damage_type]

        if self.last_killlocation_properties:
            data.append(self.parseProperties(self.last_killlocation_properties))
            self.last_killlocation_properties = None

        return self.getEvent(event_type, client=attacker, target=victim, data=tuple(data))


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" committed suicide with "(?P<weapon>\S*)"$''')
    def on_suicide(self, name, cid, guid, team, weapon):
        # L 08/26/2012 - 03:38:04: "Pheonix<22><BOT><TERRORIST>" committed suicide with "world"
        client = self.getClientOrCreate(cid, guid, name, team)
        # victim.state = b3.STATE_DEAD ## do we need that ? is this info used ?
        damage_pct = 100
        damage_type = None
        return self.getEvent("EVT_CLIENT_SUICIDE", client=client, target=client, data=(damage_pct, weapon, "body", damage_type))


    @ger.gameEvent(
        r'''^"(?P<cvar_name>\S+)" = "(?P<cvar_value>\S*)"$''',
        r'''^server_cvar: "(?P<cvar_name>\S+)" "(?P<cvar_value>\S*)"$'''
    )
    def on_cvar(self, cvar_name, cvar_value):
        # L 08/26/2012 - 03:49:56: "r_JeepViewZHeight" = "10.0"
        # L 08/26/2012 - 03:49:56: "tv_password" = ""
        # L 08/26/2012 - 03:49:56: "sv_specspeed" = "3"
        self.game.cvar[cvar_name] = cvar_value


    @ger.gameEvent(r'''^-------- Mapchange to (?P<new_map>\S+) --------$''')
    def on_map_change(self, new_map):
        # L 08/27/2012 - 23:57:14: -------- Mapchange to de_dust --------
        self.game.mapName = new_map


    @ger.gameEvent(r'''^Loading map "(?P<new_map>\S+)"$''')
    def on_started_map(self, new_map):
        # L 08/26/2012 - 03:49:56: Loading map "de_nuke"
        self.game.mapName = new_map


    @ger.gameEvent(r'''^Started map "(?P<new_map>\S+)" \(CRC "-?\d+"\)$''')
    def on_started_map(self, new_map):
        # L 08/26/2012 - 03:22:35: Started map "de_dust" (CRC "1592693790")
        # L 08/26/2012 - 03:49:58: Started map "de_nuke" (CRC "-568155013")
        self.game.mapName = new_map
        self.game.startMap()


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>\S*)><(?P<team>\S*)>" STEAM USERID validated$''')
    def on_userid_validated(self, name, cid, guid, team):
        # L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><>" STEAM USERID validated
        self.getClientOrCreate(cid, guid, name, team)


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" connected, address "(?P<ip>.+)"$''')
    def on_client_connected(self, name, cid, guid, team, ip):
        # L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><>" connected, address "11.222.111.222:27005"
        # L 08/26/2012 - 03:22:36: "Moe<3><BOT><>" connected, address "none"
        client = self.getClientOrCreate(cid, guid, name, team)
        client.ip = ip if ip != "none" else ""


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" disconnected \(reason "(?P<reason>.*)"\)$''')
    def on_client_disconnected(self, name, cid, guid, team, reason):
        # L 08/26/2012 - 04:45:04: "Kyle<63><BOT><CT>" disconnected (reason "Kicked by Console")
        client = self.getClient(cid)
        event = None
        if client:
            if reason == "Kicked by Console":
                event = self.getEvent("EVT_CLIENT_KICK", client=client, data=reason)
            client.disconnect()
        if event:
            return event


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" entered the game$''')
    def on_client_entered(self, name, cid, guid, team):
        # L 08/26/2012 - 05:29:48: "Rip<93><BOT><>" entered the game
        # L 08/26/2012 - 05:38:36: "GrUmPY<105><STEAM_1:0:22222222><>" entered the game
        # L 08/26/2012 - 05:43:29: "Ein 1337er M!L[H<106><STEAM_1:0:5555555><>" entered the game
        client = self.getClientOrCreate(cid, guid, name, team)
        return self.getEvent("EVT_CLIENT_JOIN", client=client)


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<old_team>\S+)>" joined team "(?P<new_team>\S+)"$''')
    def on_client_join_team(self, name, cid, guid, old_team, new_team):
        # L 08/26/2012 - 03:22:36: "Pheonix<11><BOT><Unassigned>" joined team "TERRORIST"
        # L 08/26/2012 - 03:22:36: "Wolf<12><BOT><Unassigned>" joined team "CT"
        client = self.getClientOrCreate(cid, guid, name, old_team)
        client.team = self.getTeam(new_team)


    @ger.gameEvent(r'''^World triggered "(?P<event_name>\S*)"(?P<properties>.*)$''')
    def on_world_action(self, event_name, properties):
        # L 08/26/2012 - 03:22:36: World triggered "Round_Start"
        # L 08/26/2012 - 03:22:36: World triggered "Game_Commencing"
        # L 08/26/2012 - 03:22:36: World triggered "Round_End"
        # L 08/29/2012 - 22:26:59: World triggered "killlocation" (attacker_position "-282 749 -21") (victim_position "68 528 64")
        if event_name == "Round_Start":
            self.game.startRound()
        elif event_name == "Round_End":
            return self.getEvent("EVT_GAME_ROUND_END")
        elif event_name in ("Game_Commencing"):
            pass
        elif event_name == "killlocation":
            # killlocation log lines are generated by the SourceMod SuperLogs plugin right before a kill event
            # save the properties for the next kill event to use
            self.last_killlocation_properties = properties
        else:
            self.warning("unexpected world event : '%s'. Please report this on the B3 forums" % event_name)


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" triggered "(?P<event_name>\S+)"(?P<properties>.*)$''')
    def on_player_action(self, name, cid, guid, team, event_name, properties):
        client = self.getClientOrCreate(cid, guid, name, team)
        props = self.parseProperties(properties)
        if event_name in ("Got_The_Bomb", "Dropped_The_Bomb", "Planted_The_Bomb", "Begin_Bomb_Defuse_Without_Kit",
                          "Begin_Bomb_Defuse_With_Kit", "Defused_The_Bomb", "headshot", "round_mvp"):
            # L 08/26/2012 - 03:22:37: "Pheonix<11><BOT><TERRORIST>" triggered "Got_The_Bomb"
            # L 08/26/2012 - 03:46:46: "Pheonix<22><BOT><TERRORIST>" triggered "Dropped_The_Bomb"
            # L 08/26/2012 - 03:51:41: "Gunner<29><BOT><CT>" triggered "Begin_Bomb_Defuse_Without_Kit"
            # L 09/25/2012 - 22:14:09: "Grant<24><BOT><CT>" triggered "Begin_Bomb_Defuse_With_Kit"
            # L 08/26/2012 - 05:04:55: "Steel<80><BOT><TERRORIST>" triggered "Planted_The_Bomb"
            # L 08/29/2012 - 22:27:01: "Zach<5><BOT><CT>" triggered "headshot"
            # L 08/29/2012 - 22:31:50: "Pheonix<4><BOT><TERRORIST>" triggered "round_mvp"
            return self.getEvent("EVT_CLIENT_ACTION", client=client, data=event_name)

        elif event_name == "clantag":
            # L 08/26/2012 - 05:43:31: "Ein 1337er M!L[H<106><STEAM_1:0:5280197><Unassigned>" triggered "clantag" (value "")
            # L 09/18/2012 - 18:26:21: "Spoon<3><STEAM_1:0:11111111><EHD Gaming>" triggered "clantag" (value "EHD")
            client.clantag = props.get("value", "")

        elif event_name == "weaponstats":
            # L 08/28/2012 - 14:58:55: "Gunner<48><BOT><CT>" triggered "weaponstats" (weapon "m4a1") (shots "13") (hits "2") (kills "0") (headshots "0") (tks "0") (damage "42") (deaths "0")
            return self.getEvent("EVT_SUPERLOGS_WEAPONSTATS", client=client, data=props)

        elif event_name == "weaponstats2":
            # L 08/28/2012 - 14:58:55: "Vitaliy<51><BOT><CT>" triggered "weaponstats2" (weapon "famas") (head "0") (chest "0") (stomach "1") (leftarm "0") (rightarm "0") (leftleg "0") (rightleg "0")
            return self.getEvent("EVT_SUPERLOGS_WEAPONSTATS2", client=client, data=props)

        else:
            self.warning("unknown client event : '%s'. Please report this on the B3 forums" % event_name)


    @ger.gameEvent(r'''^Team "(?P<team>\S+)" triggered "(?P<event_name>[^"]+)"(?P<properties>.*)$''')
    def on_team_action(self, team, event_name, properties):
        # L 08/26/2012 - 03:48:09: Team "CT" triggered "SFUI_Notice_Target_Saved" (CT "3") (T "5")
        # L 08/26/2012 - 03:51:50: Team "TERRORIST" triggered "SFUI_Notice_Target_Bombed" (CT "1") (T "1")
        if event_name in ("SFUI_Notice_Target_Saved", "SFUI_Notice_Target_Bombed", "SFUI_Notice_Terrorists_Win",
            "SFUI_Notice_CTs_Win", "SFUI_Notice_Bomb_Defused"):
            pass # TODO should we do anything with that info ?
        else:
            self.warning("unexpected team event : '%s'. Please report this on the B3 forums" % event_name)


    @ger.gameEvent(r'''^Team "(?P<team>\S+)" scored "(?P<points>\d+)" with "(?P<num_players>\d+)" players$''')
    def on_team_score(self, team, points, num_players):
        # L 08/26/2012 - 03:48:09: Team "CT" scored "3" with "5" players
        # L 08/26/2012 - 03:48:09: Team "TERRORIST" scored "5" with "5" players
        pass # TODO should we do anything with that info ?


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*?)>" say "(?P<text>.*)"$''')
    def on_client_say(self, name, cid, guid, team, text):
        # L 08/26/2012 - 05:09:55: "courgette<2><STEAM_1:0:1487018><CT>" say "!iamgod"
        # L 09/16/2012 - 04:55:17: "Spoon<2><STEAM_1:0:11111111><>" say "!h"
        client = self.getClientOrCreate(cid, guid, name, team)
        return self.getEvent("EVT_CLIENT_SAY", client=client, data=text)


    @ger.gameEvent(r'''^"(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*?)>" say_team "(?P<text>.*)"$''')
    def on_client_teamsay(self, name, cid, guid, team, text):
        # L 08/26/2012 - 05:04:44: "courgette<2><STEAM_1:0:1487018><CT>" say_team "team say"
        client = self.getClientOrCreate(cid, guid, name, team)
        return self.getEvent("EVT_CLIENT_TEAM_SAY", client=client, data=text)


    @ger.gameEvent(r'''^rcon from "(?P<ip>.+):(?P<port>\d+)":\sBad Password$''')
    def on_bad_rcon_password(self, ip, port):
        # L 08/26/2012 - 05:21:23: rcon from "78.207.134.100:15073": Bad Password
        self.error("Bad RCON password, check your b3.xml file")


    @ger.gameEvent(r'''^Molotov projectile spawned at (?P<coord>-?[\d.]+ -?[\d.]+ -?[\d.]+), velocity (?P<velocity>-?[\d.]+ -?[\d.]+ -?[\d.]+)$''')
    def on_molotov_spawed(self, coord, velocity):
        # L 08/26/2012 - 05:21:24: Molotov projectile spawned at 132.012238 -2071.752197 -347.858246, velocity 487.665253 106.295044 121.257591
        pass # Do we care ?


    @ger.gameEvent(r'''^rcon from "(?P<ip>.+):(?P<port>\d+)": command "(?P<cmd>.*)"$''')
    def on_rcon(self, ip, port, cmd):
        # L 08/26/2012 - 05:37:56: rcon from "11.222.111.122:15349": command "say test"
        pass


    @ger.gameEvent(r'''^Banid: "(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>" was banned "for (?P<duration>.+)" by "(?P<admin>.*)"$''')
    def on_banid(self, name, cid, guid, team, duration, admin):
        # L 08/28/2012 - 00:03:01: Banid: "courgette<91><STEAM_1:0:1111111><>" was banned "for 1.00 minutes" by "Console"
        client = self.storage.getClient(Client(guid=guid))
        if client:
            return self.getEvent("EVT_CLIENT_BAN_TEMP", {"duration": duration, "admin": admin, 'reason': None}, client)


    @ger.gameEvent(r'''^\[basecommands.smx\] ".+<\d+><.+><.*>" kicked "(?P<name>.+)<(?P<cid>\d+)><(?P<guid>.+)><(?P<team>.*)>"(?P<properties>.*)$''')
    def on_kicked(self, name, cid, guid, team, properties):
        # L 08/28/2012 - 00:12:07: [basecommands.smx] "Console<0><Console><Console>" kicked "courgette<91><STEAM_1:0:1111111><>" (reason "f00")
        client = self.storage.getClient(Client(guid=guid))
        if client:
            p = self.parseProperties(properties)
            return self.getEvent("EVT_CLIENT_KICK", p.get('reason', ''), client)


    @ger.gameEvent(r'''^server_message: "(?P<msg>.*)"(?P<properties>.*)$''')
    def on_server_message(self, msg, properties):
        # L 08/30/2012 - 00:43:10: server_message: "quit"
        # L 08/30/2012 - 00:43:10: server_message: "restart"
        if msg in ("quit", "restart"):
            pass
        else:
            self.warning("unexpected server_message : '%s'. Please report this on the B3 forums" % msg)


    @ger.gameEvent(r'''^Log file started (?P<properties>.*)$''')
    def on_server_message(self, properties):
        # Log file started (file "logs/L000_000_000_000_0_201208300045_000.log") (game "/home/steam/steamcmd/cs_go/csgo") (version "5038")
        pass


    @ger.gameEvent(
        r'''^(?P<data>Your server needs to be restarted.*)$''',
        r'''^(?P<data>Your server is out of date.*)$'''
    )
    def on_server_restart_request(self, data):
        # L 09/17/2012 - 23:26:45: Your server needs to be restarted in order to receive the latest update.
        # L 09/17/2012 - 23:26:45: Your server is out of date.  Please update and restart.
        return self.getEvent('EVT_SERVER_REQUIRES_RESTART', data)


    # -------------- /!\  this one must be the last /!\ --------------
    @ger.gameEvent(r'''^(?P<data>.+)$''')
    def on_unknown_line(self, data):
        """
        catch all lines that were not handled
        """
        self.warning("unhandled log line : %s. Please report this on the B3 forums" % data)




    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #
    ###############################################################################################

    def getPlayerList(self):
        """\
        Query the game server for connected players.
        return a dict having players' id for keys and players' data as another dict for values
        """
        return self.queryServerInfo()


    def authorizeClients(self):
        """\
        For all connected players, fill the client object with properties allowing to find
        the user in the database (usualy guid, or punkbuster id, ip) and call the
        Client.auth() method
        """
        pass # no need as all game log lines have the client guid


    def sync(self):
        """\
        For all connected players returned by self.getPlayerList(), get the matching Client
        object from self.clients (with self.clients.getByCID(cid) or similar methods) and
        look for inconsistencies. If required call the client.disconnect() method to remove
        a client from self.clients.
        This is mainly useful for games where clients are identified by the slot number they
        occupy. On map change, a player A on slot 1 can leave making room for player B who
        connects on slot 1.
        """
        plist = self.getPlayerList()
        mlist = {}
        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                mlist[cid] = client
        return mlist


    def say(self, msg):
        """\
        broadcast a message to all players
        """
        if msg and len(msg.strip()):
            template = 'sm_say %s'
            if "B3 Say" in self.sm_plugins:
                template = 'b3_say %s'
            else:
                msg = self.msgPrefix + ' ' + msg
            for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
                self.output.write(template % line)


    def saybig(self, msg):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        if msg and len(msg.strip()):
            template = 'sm_hsay %s'
            if "B3 Say" in self.sm_plugins:
                template = 'b3_hsay %s'
            else:
                msg = self.msgPrefix + ' ' + msg
            for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
                self.output.write(template % line)


    def message(self, client, msg):
        """\
        display a message to a given player
        """
        if not client.hide: # do not talk to bots
            if msg and len(msg.strip()):
                template = 'sm_psay #%(guid)s "%(msg)s"'
                if "B3 Say" in self.sm_plugins:
                    template = 'b3_psay #%(guid)s "%(msg)s"'
                else:
                    msg = self.msgPrefix + ' ' + msg
                for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
                    self.output.write(template % {'guid': client.guid, 'msg': line})


    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        kick a given player
        """

        self.debug('kick reason: [%s]' % reason)
        if isinstance(client, basestring):
            clients = self.clients.getByMagic(client)
            if len(clients) != 1:
                return
            else:
                client = client[0]

        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        self.do_kick(client, reason)

        if not silent and fullreason != '':
            self.say(fullreason)


    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        ban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN', data={'reason': reason,
        'admin': admin}, client=target)
        """
        if client.hide: # exclude bots
            return

        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, basestring):
            clients = self.clients.getByMagic(client)
            if len(clients) != 1:
                return
            else:
                client = client[0]

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        self.do_ban(client, reason)
        if admin:
            admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(self.getEvent("EVT_CLIENT_BAN", {'reason': reason, 'admin': admin}, client))


    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        unban a given player on the game server
        """
        if client.hide: # exclude bots
            return

        self.debug('UNBAN: Name: %s, Ip: %s, Guid: %s' % (client.name, client.ip, client.guid))
        if client.ip:
            self.do_unban_by_ip(client)
            self.verbose('UNBAN: Removed ip (%s) from banlist' % client.ip)
            if admin:
                admin.message('Unbanned: %s. His last ip (%s) has been removed from banlist.' % (client.exactName, client.ip))
            if admin:
                fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
            else:
                fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))
            if not silent and fullreason != '':
                self.say(fullreason)

        self.do_unban_by_steamid(client)
        self.verbose('UNBAN: Removed guid (%s) from banlist' %client.guid)
        if admin:
            admin.message('Unbanned: Removed %s guid from banlist' % client.exactName)


    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        """\
        tempban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN_TEMP', data={'reason': reason,
        'duration': duration, 'admin': admin}, client=target)
        """
        if client.hide: # exclude bots
            return

        self.debug('TEMPBAN : client: %s, duration: %s, reason: %s', client, duration, reason)
        if isinstance(client, basestring):
            clients = self.clients.getByMagic(client)
            if len(clients) != 1:
                return
            else:
                client = client[0]

        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        self.do_tempban(client, duration, reason)

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(self.getEvent("EVT_CLIENT_BAN_TEMP", {'reason': reason, 'duration': duration, 'admin': admin}, client))


    def getMap(self):
        """\
        return the current map/level name
        """
        self.queryServerInfo()
        return self.game.mapName


    def getMaps(self):
        """\
        return the available maps/levels name
        """
        rv = self.output.write('listmaps')
        if rv:
            return [x for x in rv.split('\n') if x and x != "Map Cycle:" and not x.startswith('L ')]


    def rotateMap(self):
        """\
        load the next map/level
        """
        next_map = self.getNextMap()
        if next_map:
            self.saybig('Changing to next map : %s' % next_map)
            time.sleep(1)
            self.output.write('map %s' % next_map)



    def changeMap(self, map_name):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        rv = self.getMapsSoundingLike(map_name)
        if isinstance(rv, basestring):
            self.output.write('sm_map %s' % map_name)
        else:
            return rv


    def getPlayerPings(self):
        """\
        returns a dict having players' id for keys and players' ping for values
        """
        clients = self.queryServerInfo()
        pings = {}
        for cid, client in clients.iteritems():
            pings[cid] = client.ping
        return pings


    def getPlayerScores(self):
        """\
        returns a dict having players' id for keys and players' scores for values
        """
        # TODO getPlayerScores if doable
        return {}


    def inflictCustomPenalty(self, type, client, reason=None, duration=None, admin=None, data=None):
        """
        Called if b3.admin.penalizeClient() does not know a given penalty type.
        Overwrite this to add customized penalties for your game like 'slap', 'nuke',
        'mute', 'kill' or anything you want.
        /!\ This method must return True if the penalty was inflicted.
        """
        pass
        # TODO inflictCustomPenalty (sm_slap sm_slay sm_votekick sm_voteban sm_voteburn sm_voteslay sm_gag sm_mute sm_silence)


    def getNextMap(self):
        """
        return the next map in the map rotation list
        """
        next_map = self.getCvar("sm_nextmap")
        return next_map


    ###############################################################################################
    #
    #    Other methods
    #
    ###############################################################################################

    def getWrap(self, text, length=80, minWrapLen=150):
        """Returns a sequence of lines for text that fits within the limits"""
        if not text:
            return []

        length = int(length)
        clean_text = self.stripColors(text.strip())


        if len(clean_text) <= minWrapLen:
            return [clean_text]

        text = re.split(r'\s+', clean_text)

        lines = []

        line = text[0]
        for t in text[1:]:
            if len(line) + len(t) + 2 <= length:
                line = '%s %s' % (line, t)
            else:
                if len(lines) > 0:
                    lines.append(u' %s' % line)
                else:
                    lines.append(line)
                line = t

        if len(line):
            if len(lines) > 0:
                lines.append(u' %s' % line)
            else:
                lines.append(line)

        return lines


    def parseLine(self, line):
        if line is None:
            return
        if line.startswith("mp\x08 \x08\x08 \x08"):
            line = line[8:]
        m = re.match(RE_HL_LOG_LINE, line.decode('UTF-8', 'replace'))
        if m:
            data = m.group('data')
            if data:
                hfunc, param_dict = ger.getHandler(data)
                if hfunc:
                    self.verbose2("calling %s%r" % (hfunc.func_name, param_dict))
                    event = hfunc(self, **param_dict)
                    if event:
                        self.queueEvent(event)


    def parseProperties(self, properties):
        """
        parse HL log properties as described at https://developer.valvesoftware.com/wiki/HL_Log_Standard#Notes
        :param properties: string representing HL log properties
        :return: a dict representing all the property key:value parsed
        """
        rv = {}
        if properties:
            for match in re.finditer(RE_HL_LOG_PROPERTY, properties):
                if match.group('data') == '':
                    rv[match.group('key')] = True # Parenthised properties with no explicit value indicate a boolean true value
                else:
                    rv[match.group('key')] = match.group('value')
        return rv


    def getClient(self, cid):
        """
        return an already connected client by searching the clients cid index.

        May return None
        """
        client = self.clients.getByCID(cid)
        if client:
            return client
        return None


    def getClientOrCreate(self, cid, guid, name, team=None):
        """
        return an already connected client by searching the clients cid index
        or create a new client.
        
        May return None
        """
        if guid == "BOT":
            guid += "_" + cid
        client = self.clients.getByCID(cid)
        if client is None:
            client = self.clients.newClient(cid, guid=guid, name=name, team=TEAM_UNKNOWN)
            client.last_update_time = time.time()
            if guid.startswith("BOT_"):
                client.hide = True
        else:
            if name:
                client.name = name
        if team:
            parsed_team = self.getTeam(team)
            if parsed_team and parsed_team != TEAM_UNKNOWN:
                client.team = parsed_team
        return client


    def getTeam(self, team):
        """
        convert team CS:GO id to B3 team numbers
        """
        if not team or team == "Unassigned":
            return TEAM_UNKNOWN
        elif team == "TERRORIST":
            return TEAM_BLUE
        elif team == "CT":
            return TEAM_RED
#        elif team = "???": # TODO find out what the spec team is
#            return TEAM_SPEC
        else:
            self.debug("unexpected team id : %s" % team)
            return TEAM_UNKNOWN


    def queryServerInfo(self):
        """
        query the server for its status and refresh local data :
         self.game.sv_hostname
         self.game.mapName
        furthermore, discover connected players, refresh their ping and ip info
        finally return a dict of <cid, client>
        """
        rv = self.output.write("status")
        clients = {}
        if rv:
            re_player = re.compile(r'''^#\s*(?P<cid>\d+) (?:\d+) "(?P<name>.+)" (?P<guid>\S+) (?P<duration>\d+:\d+) (?P<ping>\d+) (?P<loss>\S+) (?P<state>\S+) (?P<rate>\d+) (?P<ip>\d+\.\d+\.\d+\.\d+):(?P<port>\d+)$''')
            for line in rv.split('\n'):
                if not line or line.startswith('L '):
                    continue
                if line.startswith('hostname:'):
                    self.game.sv_hostname = line[10:]
                elif line.startswith('map     :'):
                    self.game.mapName = line[10:]
                else:
                    m = re.match(re_player, line)
                    if m:
                        client = self.getClientOrCreate(m.group('cid'), m.group('guid'), m.group('name'))
                        client.ping = m.group('ping')
                        client.ip = m.group('ip')
                        clients[client.cid] = client
            return clients


    def getAvailableMaps(self):
        """
        return the available maps on the server, even if not in the map rotation list
        """
        re_maps = re.compile(r"^PENDING:\s+\(fs\)\s+(?P<map_name>.+)\.bsp$")
        response = []
        for line in self.output.write("maps *").split('\n'):
            m = re.match(re_maps, line)
            if m:
                response.append(m.group('map_name'))
        return response


    def getCvar(self, cvar_name):
        if not cvar_name:
            self.warning('trying to query empty cvar %r' % cvar_name)
            return None
        rv = self.output.write(cvar_name)
        m = re.search(RE_CVAR, rv)
        if m:
            return m.group('value')


    def setCvar(self, cvarName, value):
        """
        set a cvar on the game server
        """
        if re.match('^[a-z0-9_.]+$', cvarName, re.I):
            self.debug('Set cvar %s = [%s]', cvarName, value)
            self.write(self.getCommand('set', name=cvarName, value=value))
        else:
            self.error('%s is not a valid cvar name', cvarName)


    def do_kick(self, client, reason=None):
        if not client.cid:
            self.warning("Trying to kick %s which has no slot id" % client)
        else:
            if reason:
                self.output.write('sm_kick #%s %s' % (client.cid, reason))
            else:
                self.output.write("sm_kick #%s" % client.cid)


    def do_ban(self, client, reason=None):
        # sm_addban <time> <steamid> [reason]
        if reason:
            self.output.write('sm_addban %s "%s" %s' % (0, client.guid, reason))
        else:
            self.output.write('sm_addban %s "%s"' % (0, client.guid))
        self.do_kick(client, reason)


    def do_tempban(self, client, duration=2, reason=None):
        # sm_addban <time> <steamid> [reason]
        if reason:
            self.output.write('sm_addban %s "%s" %s' % (int(time2minutes(duration)), client.guid, reason))
        else:
            self.output.write('sm_addban %s "%s"' % (int(time2minutes(duration)), client.guid))
        self.do_kick(client, reason)


    def do_unban_by_steamid(self, client):
        # sm_unban <steamid|ip>
        self.output.write('sm_unban "%s"' % client.guid)


    def do_unban_by_ip(self, client):
        # sm_unban <steamid|ip>
        self.output.write('sm_unban %s' % client.ip)


    def is_sourcemod_installed(self):
        """
        return a True if Source Mod is installed on the game server
        """
        data = self.output.write("sm version")
        if data:
            if data.startswith("Unknown command"):
                return False
            for m in data.splitlines():
                self.info(m.strip())
            return True
        else:
            return False


    def get_loaded_sm_plugins(self):
        """
        return a dict with SourceMod plugins' name as keys and value is a tuple (index, version, author)
        """
        re_sm_plugin = re.compile(r'''^(?P<index>.+) "(?P<name>.+)" \((?P<version>.+)\) by (?P<author>.+)$''', re.MULTILINE)
        response = {}
        data = self.output.write("sm plugins list")
        if data:
            for m in re.finditer(re_sm_plugin, data):
                response[m.group('name')] = (m.group('index'), m.group('version'), m.group('author'))
        return response


    def getMapsSoundingLike(self, mapname):
        """ return a valid mapname.
        If no exact match is found, then return close candidates as a list
        """
        supportedMaps = [m.lower() for m in self.getAvailableMaps()]
        wanted_map = mapname.lower()
        if wanted_map in supportedMaps:
            return wanted_map

        matches = getStuffSoundingLike(wanted_map, supportedMaps)
        if len(matches) == 1:
            # one match, get the map id
            return matches[0]
        else:
            # multiple matches, provide suggestions
            return matches
########NEW FILE########
__FILENAME__ = et
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

__author__  = 'ThorN'
__version__ = '0.0.1'

import re, string
import b3
from b3.parsers.q3a.abstractParser import AbstractParser
import PunkBuster

class EtParser(AbstractParser):
    gameName = 'et'
    privateMsg = False
    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 90

    _commands = {}
    _commands['message'] = 'qsay %s %s ^8[pm]^7 %s'
    _commands['say'] = 'qsay %s %s'
    _commands['set'] = 'set %s %s'
    _commands['kick'] = 'clientkick %s %s'
    _commands['ban'] = 'banid %s %s'
    _commands['tempban'] = 'clientkick %s %s'

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'restartgame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:.]+\s?)?')

    _lineFormats = (
        #1579:03ConnectInfo: 0: E24F9B2702B9E4A1223E905BF597FA92: ^w[^2AS^w]^2Lead: 3: 3: 24.153.180.106:2794
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        #1536:17sayc: 0: ^w[^2AS^w]^2Lead:  sorry...
        #1536:34sayteamc: 17: ^1[^7DP^1]^4Timekiller: ^4ammo ^2here !!!!!
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>.*)$', re.IGNORECASE)
    )

    PunkBuster = None

    def startup(self):
        # add the world client
        client = self.clients.newBaseClient()
        client.name = 'World'
        client.cid  = -1
        client.guid = self.gameName + ':WORLD'
        client.maxLevel = -1
        client.hide = True

        self.clients.update(client)

        self.PunkBuster = PunkBuster.PunkBuster(self)

    def message(self, client, text):
        try:
            if client == None:
                self.say(text)
            elif client.cid == None:
                pass
            else:
                lines = []
                for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                    lines.append('qsay %s ^8[%s^8]^7 %s' % (self.msgPrefix, client.exactName, line))

                self.writelines(lines)
        except:
            pass

    # join
    #1579:03ConnectInfo: 0: E24F9B2702B9E4A1223E905BF597FA92: ^w[^2AS^w]^2Lead: 3: 3: 24.153.180.106:2794
    def OnConnectinfo(self, action, data, match=None):
        guid = match.group('pbid')
        client = self.clients.getByCID(match.group('cid'))

        if client:
            if client.guid == guid:
                # this is the same player

                if client.exactName != match.group('name'):
                    client.exactName = match.group('name')
                    client.setName(self.stripColors(client.exactName))
                return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)
            else:
                # disconnect the existing client
                self.verbose('disconnect the existing client %s %s => %s %s', match.group('cid'), guid, client.cid, client)
                client.disconnect()

        client = self.clients.newBaseClient()
        client.cid  = match.group('cid')

        #if match.group('guid') == '0':
        #    client.guid = None
        #else:
        client.pbid = client.guid = self.gameName + ':' + guid
        client.ip = match.group('ip')

        client.exactName = match.group('name')
        client.name = self.stripColors(client.exactName)
        self.clients.update(client)

    #1579:03ClientUserinfoChangedGUID: 0 E24F9B2702B9E4A1223E905BF597FA92 n\^w[^2AS^w]^2Lead\t\3\c\3\r\0\m\0000000\s\0000000\dn\\dr\0\w\3\lw\3\sw\7\mu\0\ref\0
    def OnClientuserinfochangedguid(self, action, data, match=None):
        client = self.clients.getByCID(match.group('cid'))
        cid, pbid, data = string.split(data, ' ', 2)
        bclient = self.parseUserInfo(cid + ' ' + data)
        if bclient:
            self.clients.update(bclient, client)

    def OnGib(self, action, data, match=None):
        #1538:42Gib: 5 10 1: ^0Apache Death gibbed ^,^t^9^8that ^2guy by MOD_MACHINEGUN
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnJ(action, data, match)
            return None

        attacker = self.clients.getByCID(match.group('acid'))
        if not attacker:
            self.debug('No attacker')
            return None

        event = b3.events.EVT_CLIENT_GIB

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_GIB_SELF
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_GIB_TEAM

        return b3.events.Event(event, (100, match.group('aweap'), ''), attacker, victim)

    def OnKill(self, action, data, match=None):
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnJ(action, data, match)
            return None

        attacker = self.clients.getByCID(match.group('acid'))
        if not attacker:
            self.debug('No attacker')
            return None

        event = b3.events.EVT_CLIENT_KILL

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        return b3.events.Event(event, (100, match.group('aweap'), ''), attacker, victim)

    def OnSayteamc(self, action, data, match=None):
        #1536:34sayteamc: 17: ^1[^7DP^1]^4Timekiller: ^4ammo ^2here !!!!!
        client = self.clients.getByCID(match.group('cid'))
        if not client:
            self.debug('No client - attempt join')
            #self.OnJ(action, data, match)
            #client = self.clients.getByCID(match.group('cid'))
            #if not client:
            return None

        return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, match.group('text'), client)

    def OnSayc(self, action, data, match=None):
        #1536:17sayc: 0: ^w[^2AS^w]^2Lead:  sorry...
        client = self.clients.getByCID(match.group('cid'))
        if not client:
            self.debug('No client - attempt join')
            #self.OnJ(action, data, match)
            #client = self.clients.getByCID(match.group('cid'))
            #if not client:
            return None

        return b3.events.Event(b3.events.EVT_CLIENT_SAY, match.group('text'), client)
########NEW FILE########
__FILENAME__ = etpro
# Enemy Territory ETPro parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2009 ailmanki
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA    02110-1301    USA
#
# CHANGELOG
# 05/04/2009: 0.0.1: Updating so that it works for etpro
# 31/01/2010 - 0.0.2 - Courgette
# * getMap() is now inherited from q3a
# 09/04/2011 - 0.0.3 - Courgette
# * reflect that cid are not converted to int anymore in the clients module
#
#
# CREDITS
# Based on the version 0.0.1, thanks ThorN.
# Copied alot from wop.py, thanks xlr8or.
# Thanks for B3.
#
# NOTES
# ETPro has not bots.
# ETPro 3.2.6 - no additional LUA or QMM scripts used
#
#etpro:
# - qsay (chat window,
# - cpmsay (left popup area) available since 3.0.15+
# - cp (center print)
# - bp (banner print area, top of screen)
# - say (chat window, with "console: " in front)


__author__    = 'xlr8or, ailmanki'
__version__ = '0.0.3'

import re, string
import b3
import b3.events
from b3.parsers.q3a.abstractParser import AbstractParser
import b3.parsers.punkbuster

class EtproParser(AbstractParser):
    gameName = 'etpro'
    IpsOnly = False    # Setting True will use ip's only for identification.
    IpCombi = False    # Setting True will replace last part of the guid with 2 segments of the ip.

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _empty_name_default = 'EmptyNameDefault'

    _commands = {}
    _commands['message'] = 'm %(name)s %(prefix)s^7 %(message)s'
    _commands['deadsay'] = 'm %(name)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'cpmsay %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banid %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'restartgame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:.]+\s?)?')

    _lineFormats = (
        #-------ET Lines----------------------------------------------------------------------------
        #1579:03 ConnectInfo: 0: E24F9B2702B9E4A1223E905BF597FA92: ^w[^2AS^w]^2Lead: 3: 3: 24.153.180.106:2794
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        #
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        #
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),
        #
        # 5:41 Medic_Revive: 3 8
        re.compile(r'^(?P<action>[a-z_]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>.*))$', re.IGNORECASE),
        #
        # 5:41 Dynamite_Plant: 3
        re.compile(r'^(?P<action>[a-z_]+):\s*(?P<data>(?P<cid>[0-9]+))$', re.IGNORECASE),
        #
        # Falling through?
        re.compile(r'^(?P<action>[a-z_]+):\s*(?P<data>.*)$', re.IGNORECASE),
        #
        #------ Addon / Mod Lines ------------------------------------------------------------------
        #[QMM] lines:
        #[QMM] Successfully hooked g_log file
        re.compile(r'^\[(?P<action>[a-z]+)]\s(?P<data>.*)$', re.IGNORECASE),
        # etpro lines:
        # 16:33.29 etpro privmsg: xlr8or[*] to xlr8or: hi
        re.compile(r'^(?P<action>[a-z]+)\s(?P<data>(?P<command>[a-z]+):\s(?P<origin>.*)\sto\s(?P<target>.*):\s(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+)\s(?P<data>(?P<command>[a-z]+):\s(?P<origin>.*)\sto\s(?P<target>.*):)$', re.IGNORECASE), # in case there is no privmsg text entered
        re.compile(r'^(?P<action>[a-z]+)\s(?P<data>(?P<command>[a-z]+):\s(?P<text>.*))$', re.IGNORECASE)
    )

    #15:11:15 map: goldrush
    # num score ping name            lastmsg address               qport rate
    # --- ----- ---- --------------- ------- --------------------- ----- -----
    #   2     0   45 xlr8or[*]             0 145.99.135.227:27960  39678 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None

    ## kill mode constants: modNames[meansOfDeath]
    MOD_UNKNOWN='0'
    MOD_MACHINEGUN='1'
    MOD_BROWNING='2'
    MOD_MG42='3'
    MOD_GRENADE='4'
    MOD_ROCKET='5'
    MOD_KNIFE='6'
    MOD_LUGER='7'
    MOD_COLT='8'
    MOD_MP40='9'
    MOD_THOMPSON='10'
    MOD_STEN='11'
    MOD_GARAND='12'
    MOD_SNOOPERSCOPE='13'
    MOD_SILENCER='14'
    MOD_FG42='15'
    MOD_FG42SCOPE='16'
    MOD_PANZERFAUST='17'
    MOD_GRENADE_LAUNCHER='18'
    MOD_FLAMETHROWER='19'
    MOD_GRENADE_PINEAPPLE='20'
    MOD_CROSS='21'
    MOD_MAPMORTAR='22'
    MOD_MAPMORTAR_SPLASH='23'
    MOD_KICKED='24'
    MOD_GRABBER='25'
    MOD_DYNAMITE='26'
    MOD_AIRSTRIKE='27'
    MOD_SYRINGE='28'
    MOD_AMMO='29'
    MOD_ARTY='30'
    MOD_WATER='31'
    MOD_SLIME='32'
    MOD_LAVA='33'
    MOD_CRUSH='34'
    MOD_TELEFRAG='35'
    MOD_FALLING='36'
    MOD_SUICIDE='37'
    MOD_TARGET_LASER='38'
    MOD_TRIGGER_HURT='39'
    MOD_EXPLOSIVE='40'
    MOD_CARBINE='41'
    MOD_KAR98='42'
    MOD_GPG40='43'
    MOD_M7='44'
    MOD_LANDMINE='45'
    MOD_SATCHEL='46'
    MOD_TRIPMINE='47'
    MOD_SMOKEBOMB='48'
    MOD_MOBILE_MG42='49'
    MOD_SILENCED_COLT='50'
    MOD_GARAND_SCOPE='51'
    MOD_CRUSH_CONSTRUCTION='52'
    MOD_CRUSH_CONSTRUCTIONDEATH='53'
    MOD_CRUSH_CONSTRUCTIONDEATH_NOATTACKER='54'
    MOD_K43='55'
    MOD_K43_SCOPE='56'
    MOD_MORTAR='57'
    MOD_AKIMBO_COLT='58'
    MOD_AKIMBO_LUGER='59'
    MOD_AKIMBO_SILENCEDCOLT='60'
    MOD_AKIMBO_SILENCEDLUGER='61'
    MOD_SMOKEGRENADE='62'
    MOD_SWAP_PLACES='63'
    MOD_SWITCHTEAM='64'

    ## meansOfDeath to be considered suicides
    Suicides = (
        MOD_WATER,
        MOD_SLIME,
        MOD_LAVA,
        MOD_CRUSH,
        MOD_TELEFRAG,
        MOD_FALLING,
        MOD_SUICIDE,
        MOD_TARGET_LASER,
        MOD_TRIGGER_HURT,
        MOD_LANDMINE,
        MOD_TRIPMINE
    )

#---------------------------------------------------------------------------------------------------

    def startup(self):
        # add the world client
        
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')
        #if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
        #    self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)

#---------------------------------------------------------------------------------------------------

    # Added for debugging and identifying/catching log lineparts
    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('XLR--------> line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return (m, m.group('action').lower(), m.group('data').strip(), client, target)
        elif '------' not in line:
            self.verbose('XLR--------> line did not match format: %s' % line)

#---------------------------------------------------------------------------------------------------

    def OnClientconnect(self, action, data, match=None):
        self._clientConnectID = data
        client = self.clients.getByCID(data)
        return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)

    # Parse Userinfo
    def OnClientuserinfo(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                #make a new client
                if bclient.has_key('cl_guid'):
                    guid = bclient['cl_guid']
                else:
                    guid = 'unknown' 
                
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if not bclient.has_key('ip') and guid == 'unknown':
                    # happens when a client is (temp)banned and got kicked so client was destroyed, but
                    # infoline was still waiting to be parsed.
                    self.debug('Client disconnected. Ignoring.')
                    return None
                
                nguid = ''
                # overide the guid... use ip's only if self.console.IpsOnly is set True.
                if self.IpsOnly:
                    nguid = bclient['ip']
                # replace last part of the guid with two segments of the ip
                elif self.IpCombi:
                    i = bclient['ip'].split('.')
                    d = len(i[0])+len(i[1])
                    nguid = guid[:-d]+i[0]+i[1]
                # Fallback for clients that don't have a cl_guid, we'll use ip instead
                elif guid == 'unknown':
                    nguid = bclient['ip']

                if nguid != '':
                    guid = nguid

                client = self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid })

        return None

    # disconnect
    def OnKill(self, action, data, match=None):
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))
        
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in self.Suicides:
            # those kills should be considered suicides
            self.debug('OnKill: Fixed attacker, suicide detected: %s' %match.group('text'))
            attacker = victim
        else:
            attacker = self.clients.getByCID(match.group('acid'))
        ## end fix attacker
          
        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            if weapon == self.MOD_SWITCHTEAM:
                """
                Do not pass a teamchange event here. That event is passed
                shortly after the kill (in clients.py by adjusting the client object).
                """
                self.verbose('Team Change Event Caught, exiting')
                return None
            else:
                event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not defined we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    def OnClientbegin(self, action, data, match=None):
        return None

    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    # startgame
    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()

        self.debug('Synchronizing client info')
        self.clients.sync()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    def OnQmm(self, action, data, match=None):
        #self.verbose('OnQmm: data: %s' %data)
        return None

    def OnEtpro(self, action, data, match=None):
        #self.verbose('OnEtpro: data: %s' %data)
        #self.verbose('OnEtpro: command = %s' %(match.group('command')))
        try:
            command = match.group('command')
        except:
            self.debug('Etpro info line: %s' % match.group('data') )
            return None

        if command == 'privmsg':
            try:
                text = match.group('text')
            except:
                self.verbose('No message entered in privmsg!')
                return None
            self.OnPrivMsg(match.group('origin'), match.group('target'), text)
        # an example on how to catch other etpro events:
        elif command == 'event':
            self.verbose('event: %s' %(match.group('text')))
        else:
            self.verbose('%s: %s' %(command, match.group('text')))

        return None

    def OnPrivMsg(self, origin, target, text):
        client = self.clients.getByExactName(origin)
        tclient = self.clients.getClientLikeName(target)

        if not client:
            #self.verbose('No Client Found')
            return None

        if not tclient:
            client.message('Please be more specific providing the target, can\'t find it with given input!')
            return None

        if text and ord(text[:1]) == 21:
            text = text[1:]

        #client.name = match.group('name')
        self.verbose('text: %s, client: %s - %s, tclient: %s - %s' %(text, client.name, client.id, tclient.name, tclient.id))
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, text, client, tclient))

#---------------------------------------------------------------------------------------------------

    def parseUserInfo(self, info):
        #2 n\peyote\t\3\c\0\r\0\m\0000000\s\0000000\dn\\dr\0\w\0\lw\0\sw\0\mu\0\ref\0\p\0\ss\0\sc\0\tv\0\lc\0
        #0 \g_password\none\cl_guid\0A337702493AF67BB0B0F8565CE8BC6C\cl_wwwDownload\1\name\thorn\rate\25000\snaps\20\cl_anonymous\0\cl_punkbuster\1\password\test\protocol\83\qport\16735\challenge\-79719899\ip\69.85.205.66:27960
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        # split port from ip field
        if data.has_key('ip'):
            tip = string.split(data['ip'], ':', 1)
            data['ip'] = tip[0]
            data['port'] = tip[1]

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)
        if data.has_key('cl_guid'):
            data['cl_guid'] = data['cl_guid'].lower()

        if data.has_key('pbid'):
            data['pbid'] = data['pbid'].lower()

        if data.has_key('cl_guid') and not data.has_key('pbid'):
            data['pbid'] = data['cl_guid']
        
        return data

    def message(self, client, text):
        try:
            if client == None:
                self.say(text)
            elif client.cid == None:
                pass
            else:
                lines = []
                for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                    lines.append(self.getCommand('message', name=client.name, prefix=self.msgPrefix, message=line))

                self.writelines(lines)
        except:
            pass

    def sayDead(self, msg):
        wrapped = self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length'])
        lines = []
        for client in self.clients.getClientsByState(b3.STATE_DEAD):
            if client.cid:                
                for line in wrapped:
                    lines.append(self.getCommand('deadsay', name=client.name, prefix=self.msgPrefix, message=line))

        if len(lines):        
            self.writelines(lines)

    def getTeam(self, team):
        if team == 'red': team = 1
        if team == 'blue': team = 2
        team = int(team)
        if team == 1:
            #self.verbose('Team is Red')
            return b3.TEAM_RED
        elif team == 2:
            #self.verbose('Team is Blue')
            return b3.TEAM_BLUE
        elif team == 3:
            #self.verbose('Team is Spec')
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN

    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == '0':
            _gameType = 'sp'        # Single Player
        elif gameTypeInt == '1':
            _gameType = 'cp'        # Co-Op
        elif gameTypeInt == '2':
            _gameType = 'smo'       # Single Map Objective
        elif gameTypeInt == '3':
            _gameType = 'sw'        # Stopwatch
        elif gameTypeInt == '4':
            _gameType = 'ca'        # Campaign
        elif gameTypeInt == '5':
            _gameType = 'lms'       # Last Man Standing
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType


    def getMaps(self):
        m=[]
        m.append('Command not supported!')
        return m

    def getNextMap(self):
        return 'Command not supported!'

    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                if client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s (cid: %s - slotid: %s)', client.guid, c['guid'], client.cid, c['cid'] )
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s (disconnecting %s from slot %s)', client.guid, c['guid'], client.name, client.cid)
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s (cid: %s == slotid: %s)', client.ip, c['ip'], client.cid, c['cid'] )
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s (disconnecting %s from slot %s)', client.ip, c['ip'], client.name, client.cid)
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist


#---- Documentation --------------------------------------------------------------------------------
"""

//infos clienuserinfochanged
//0 = player_ID
//n = name
//t = team
//c = class
//r = rank
//m = medals
//s = skills
//dn = disguised name
//dr = disguised rank
//w = weapon
//lw = weapon last used
//sw = 2nd weapon (not sure)
//mu = muted
//ref = referee
//lw = latched weapon (weapon on next spawn)
//sw = latched secondary weapon (secondary weapon on next spawn)
//p = privilege level (peon = 0, referee (vote), referee (password), semiadmin, rconauth) (etpro only)
//ss = stats restored by stat saver (etpro only)
//sc = shoutcaster status (etpro only)
//tv = ETTV slave (etpro only)

"""
########NEW FILE########
__FILENAME__ = protocol
# -*- coding: cp1252 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
#
#
import asyncore
from sys import version_info
from hashlib import md5

import re
import socket
import time
"""
module implementing the Frontline protocol. Provide the Client class which
creates a connection to a Frontline gameserver
"""

__author__  = 'Courgette'
__version__ = '1.1'

RE_CHALLENGE = re.compile(r'WELCOME! Frontlines: Fuel of War \(RCON\) VER=\d+ CHALLENGE=(?P<challenge>.+)')
CMD_TERMINATOR = '\x04'

class FrontlineConnectionError(Exception): pass

class Client(asyncore.dispatcher_with_send):

    def __init__(self, console, host, port, username, password, keepalive=False):
        asyncore.dispatcher_with_send.__init__(self)
        self.console = console
        self._host = host
        self._port = port
        self._username = username
        self._password = password
        self.keepalive = keepalive
        self._buffer_in = ''
        self.authed = False
        self._handlers = set()
        self._auth_failures = 0
        self.lastResponseTime = None
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect( (self._host, self._port) )
        
    def handle_connect(self):
        self.console.info('Now connected to Frontline gameserver, waiting for challenge')
        self.authed = False

    def handle_close(self):
        self.console.info('Connection to Frontline gameserver closed')
        self._auth_failures += 1
        self.close()
        self.authed = False
        if self.keepalive:
            if self._auth_failures > 500:
                self.console.error("Too many failures. Could not connect to Frontline server")
                self.keepalive = False
            else:
                self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
                self.connect((self._host, self._port))

    def handle_read(self):
        data = self.recv(1024)
        if len(data):
            #self.console.verbose2('read %s char from Frontline gameserver %r' % (len(data), data))
            self._buffer_in += data
            p = self._readPacket()
            while p is not None:
                for handler_func in self._handlers:
                    try:
                        handler_func(p)
                    except Exception, err:
                        self.console.exception(err)
                p = self._readPacket()

    def add_listener(self, handler_func):
        self._handlers.add(handler_func)
        return self
    
    def remove_listener(self, handler_func):
        try:
            self._handlers.remove(handler_func)
        except:
            raise ValueError("Handler is not handling this event, so cannot unhandle it.")
        return self            
            
    def login(self, challenge):
        """authenticate to the server
        from Frontline documentation : 
        
            Open a TCP/IP streaming socket to the remote console port of the server
            
            All commands sent and received are separated with new line characters '\n' or 0x04
            
            The server will send back a string (without the quotes):
            "WELCOME! Frontlines: Fuel of War (RCON) VER=2 CHALLENGE=38D384D07C"
            
            Note: Challenge string length is not fixed and will vary
            
            To generate a response use the MD5 algorithm to hash an ansi string:
            ResponseString = MD5Hash( ChallengeStringFromServer + Password );
            
            The client will send this string to the server to login:
            "RESPONSE UserNameHere ResponseString"
            
            If the login was successful the client will receive:
            "Login Success!"
            
            If the login failed, the client will be disconnected immediately
            
            Once the client is logged in commands can be sent to be run and responses can come back

        """
        self.console.info("Logging to Frontline server with username %r" % self._username)
        hashed_password = md5.new("%s%s" % (challenge, self._password)).hexdigest()
        try:
            self.send('RESPONSE %s %s' % (self._username, hashed_password))
        except socket.error, e:
            self.console.error(repr(e))

    def ping(self):
        """used to keep the connection alive. After 10 seconds of inactivity
        the server will drop the connection"""
        self.command("ECHONET PING")
    
    def command(self, text):
        """send command to server"""
        if not self.connected:
            return
        if not self.authed:
            self.console.warning("not authenticated, cannot send command")
            return
        #self.console.verbose("sending RCON %s" % text)
        packet = "%s%s" % (text.strip(), CMD_TERMINATOR)
        try:
            self.send(packet)
        except socket.error, e:
            self.console.error(repr(e))
        
    def _readPacket(self):
        if CMD_TERMINATOR in self._buffer_in:
            p = self._buffer_in.split(CMD_TERMINATOR, 1)[0]
            self._buffer_in = self._buffer_in[len(p)+1:]
            self._inspect_packet(p)
            return p

    def _inspect_packet(self, p):
        self.lastResponseTime = time.time()
        if not self.authed:
            if p.startswith('Login SUCCESS!'):
                self.authed = True
                self._auth_failures = 0
                return
            match = RE_CHALLENGE.match(p)
            if match:
                self.login(match.group('challenge'))
            
            
            
###################################################################################
# Example program

if __name__ == '__main__':
    import sys, logging
    from b3.output import OutputHandler
    
#    if len(sys.argv) != 5:
#        host = raw_input('Enter game server host IP/name: ')
#        port = int(raw_input('Enter host port: '))
#        user = raw_input('Enter username: ')
#        pw = raw_input('Enter password: ')
#    else:
#        host = sys.argv[1]
#        port = int(sys.argv[2])
#        user = sys.argv[3]
#        pw = sys.argv[4]
   
    host = '127.0.0.1'
    port = 14507
    user = 'admin'
    pw = 'pass'
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(levelname)s\t%(message)s")
    handler.setFormatter(formatter)
    
    myConsole = OutputHandler('console')
    myConsole.addHandler(handler)
    myConsole.setLevel(8)
    
    
    def packetListener(packet):
        myConsole.console(">>> %s" % packet)    
    
    myConsole.info('start client')
    frontlineClient = Client(myConsole, host, port, user, pw, keepalive=True)
    frontlineClient.add_listener(packetListener)
    
    try:
        while frontlineClient.connected or not frontlineClient.authed:
            frontlineClient.command("PLAYERLIST")
            asyncore.loop(timeout=3, count=1)
    except EOFError, KeyboardInterrupt:
        frontlineClient.close()
    
    myConsole.info('end')
    
    

########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 2011-04-17 - 1.0 - Courgette
# * add logging of sent commands

"""
dummy rcon module for Frontline to satisfy B3 parser. 

Ideally, B3 parser should be changed to allow games such as homefront to 
not require a separated socket connection for rcon commands

To use that Rcon class, instanciate and use the set_homefront_client() method. 
Then you can expect this class to work like the other Rcon classes
"""

__author__  = 'Courgette'
__version__ = '1.0'


#--------------------------------------------------------------------------------------------------
class Rcon:
    def __init__(self, console, *args):
        self.console = console
        self.frontline_client = None
        
    def set_frontline_client(self, frontline_client):
        self.frontline_client = frontline_client
    
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        if not self.frontline_client:
            return
        self.console.verbose(u'RCON :\t %s' % cmd)
        self.frontline_client.command(cmd)
        
    def flush(self):
        pass

    def close(self):
        pass
            
            
if __name__ == '__main__':
    """
    To run tests : 
    cd c:\whereever\is\b3
    c:\python26\python.exe b3/parsers/homefront/rcon.py <rcon_ip> <rcon_port> <rcon_password>
    """
    import sys, time, asyncore, thread, threading
    from b3.fake import fakeConsole
    from protocol import Client as FrontlineClient

#    if len(sys.argv) != 5:
#        host = raw_input('Enter game server host IP/name: ')
#        port = int(raw_input('Enter host port: '))
#        user = raw_input('Enter username: ')
#        pw = raw_input('Enter password: ')
#    else:
#        host = sys.argv[1]
#        port = int(sys.argv[2])
#        user = sys.argv[3]
#        pw = sys.argv[4]
   
    host = '127.0.0.1'
    port = 14507
    user = 'admin'
    pw = 'pass'
    
    
    def packetListener(packet):
        print(">>> received : %s" % packet)
    
    
    frontline_client = FrontlineClient(fakeConsole, host, port, user, pw, keepalive=True)
    frontline_client.add_listener(packetListener)
    working = True
    
    def run_hf_client(frontline_client):
        print('start client')
        try:
            while working and (frontline_client.connected or not frontline_client.authed):
                asyncore.loop(timeout=3, count=1)
        except EOFError, KeyboardInterrupt:
            frontline_client.close()
        print('end client')
    
    thread.start_new_thread(run_hf_client, (frontline_client,))
    
    time.sleep(3)
    
    r = Rcon(fakeConsole, ("what", 1337), "ever")
    r.set_frontline_client(frontline_client)
    
    def close_hf_connection():
        try:
            frontline_client.close()
        except:
            pass
    t = threading.Timer(10.0, frontline_client.close)
    t.start()
    
    for cmd in ('PLAYERLIST',
                'KICK',
                'PLAYERSAY',
                'SAY hello everybody',
                'CHATLOGGING TRUE',
                'MAPLIST',
                'GetCurrentMap',
                'GetNextMap',
                ):
        print('-----------------------------> test command : %r' % cmd)
        r.write(cmd) 
        time.sleep(1)
    
    for i in range(30):
        frontline_client.ping()
        time.sleep(.5)
    
    working = False
    
    print(".")

########NEW FILE########
__FILENAME__ = abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 2010-10-23 - 1.1 - Courgette
#    * remove bfbc2 names
# 2010-11-07 - 1.1.1 - GrosBedo
#    * messages now support named $variables instead of %s
# 2010-11-08 - 1.1.2 - GrosBedo
#    * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# 2010-11-02 - 1.2 - Courgette
#    * call getEasyName() in OnServerLoadinglevel
#    * fix getSupportedMaps()
#    * OnServerLoadinglevel() now fills game.rounds and game.sv_maxrounds 
# 2010-11-21 - 1.3 - Courgette
#    * remove rotateMap and changeMap as their implementation differs for MoH 
# 2011-05-22 - 1.4 - Courgette
# * create specific events : EVT_GAME_ROUND_PLAYER_SCORES and EVT_GAME_ROUND_TEAM_SCORES
# * handle Frostbite events : OnServerRoundover, OnServerRoundoverplayers and OnServerRoundoverteamscores
# 2011-05-24 - 1.4.1 - Courgette
# * fix getSupportedMaps() so it uses the maplist set for the next round instead of current
# 2011-05-25 - 1.4.2 - Courgette
# * fix bug introduced in 1.4.1
# 2011-06-05 - 1.5.0 - Courgette
# * change data format for EVT_CLIENT_BAN_TEMP and EVT_CLIENT_BAN events
# 2011-11-05 - 1.5.1 - Courgette
# * make sure to release the self.exiting lock
# 2012-10-06 - 1.6 - Courgette
# * isolate the patching code in a module function
# 2013-01-20 - 1.6.1 - Courgette
# * improve punkbuster event parsing
#
__author__  = 'Courgette'
__version__ = '1.6.1'


import sys, re, traceback, time, string, Queue, threading
import b3.parser
import b3.parsers.frostbite.rcon as rcon
from b3.parsers.frostbite.connection import FrostbiteConnection, FrostbiteException, FrostbiteCommandFailedError
from b3.parsers.frostbite.util import PlayerInfoBlock
import b3.events
#from b3.parsers.frostbite.punkbuster import PunkBuster as Bfbc2PunkBuster
import b3.cvar
from b3.functions import soundex, levenshteinDistance

SAY_LINE_MAX_LENGTH = 100

class AbstractParser(b3.parser.Parser):
    '''
    An abstract base class to help with developing frostbite parsers 
    '''
    gameName = None
    privateMsg = True
    OutputClass = rcon.Rcon
    _serverConnection = None
    _nbConsecutiveConnFailure = 0
    
    sayqueue = Queue.Queue()
    sayqueuelistener = None

    # frostbite engine does not support color code, so we need this property
    # in order to get stripColors working
    _reColor = re.compile(r'(\^[0-9])') 
    
    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 65
    _settings['message_delay'] = 2

    _gameServerVars = () # list available cvar

    _commands = {}
    _commands['message'] = ('admin.say', '%(message)s', 'player', '%(cid)s')
    _commands['say'] = ('admin.say', '%(message)s', 'all')
    _commands['kick'] = ('admin.kickPlayer', '%(cid)s', '%(reason)s')
    _commands['ban'] = ('banList.add', 'guid', '%(guid)s', 'perm', '%(reason)s')
    _commands['banByIp'] = ('banList.add', 'ip', '%(ip)s', 'perm', '%(reason)s')
    _commands['unban'] = ('banList.remove', 'guid', '%(guid)s')
    _commands['unbanByIp'] = ('banList.remove', 'ip', '%(ip)s')
    _commands['tempban'] = ('banList.add', 'guid', '%(guid)s', 'seconds', '%(duration)d', '%(reason)s')

    _eventMap = {
        'player.onKicked': b3.events.EVT_CLIENT_KICK,
    }
    
    _punkbusterMessageFormats = (
        (re.compile(r'^.*: PunkBuster Server for BC2 \((?P<version>.+)\)\sEnabl.*$'), 'OnPBVersion'),
        (re.compile(r'^.*: Running PB Scheduled Task \(slot #(?P<slot>\d+)\)\s+(?P<task>.*)$'), 'OnPBScheduledTask'),
        (re.compile(r'^.*: Lost Connection \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+) (?P<pbuid>[^\s]+)\(-\)\s(?P<name>.+)$'), 'OnPBLostConnection'),
        (re.compile(r'^.*: Master Query Sent to \((?P<pbmaster>[^\s]+)\) (?P<ip>[^:]+)$'), 'OnPBMasterQuerySent'),
        (re.compile(r'^.*: Player GUID Computed (?P<pbid>[0-9a-fA-F]+)\(-\) \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+)\s(?P<name>.+)$'), 'OnPBPlayerGuid'),
        (re.compile(r'^.*: New Connection \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+) \[(?P<something>[^\s]+)\]\s"(?P<name>.+)".*$'), 'OnPBNewConnection')
     )

    PunkBuster = None


    def __new__(cls, *args, **kwargs):
        patch_b3_clients()
        return b3.parser.Parser.__new__(cls)
           
           
    def run(self):
        """Main worker thread for B3"""
        self.bot('Start listening ...')
        self.screen.write('Startup Complete : B3 is running! Let\'s get to work!\n\n')
        self.screen.write('(If you run into problems, check %s for detailed log info)\n' % self.config.getpath('b3', 'logfile'))
        #self.screen.flush()

        self.updateDocumentation()

        while self.working:
            """
            While we are working, connect to the frostbite server
            """
            if self._paused:
                if self._pauseNotice == False:
                    self.bot('PAUSED - Not parsing any lines, B3 will be out of sync.')
                    self._pauseNotice = True
            else:
                
                try:                
                    if self._serverConnection is None:
                        self.verbose('Connecting to frostbite server ...')
                        self._serverConnection = FrostbiteConnection(self, self._rconIp, self._rconPort, self._rconPassword)

                    self._serverConnection.subscribeToEvents()
                    self.clients.sync()
                    self._nbConsecutiveConnFailure = 0
                        
                    nbConsecutiveReadFailure = 0
                    while self.working:
                        """
                        While we are working and connected, read a packet
                        """
                        if not self._paused:
                            try:
                                packet = self._serverConnection.readEvent()
                                self.console("%s" % packet)
                                try:
                                    self.routeFrostbitePacket(packet)
                                except SystemExit:
                                    raise
                                except Exception, msg:
                                    self.error('%s: %s', msg, traceback.extract_tb(sys.exc_info()[2]))
                            except FrostbiteException, e:
                                #self.debug(e)
                                nbConsecutiveReadFailure += 1
                                if nbConsecutiveReadFailure > 5:
                                    raise e
                except FrostbiteException, e:
                    self.debug(e)
                    self._nbConsecutiveConnFailure += 1
                    self._serverConnection.close()
                    if self._nbConsecutiveConnFailure <= 20:
                        self.debug('sleeping 0.5 sec...')
                        time.sleep(0.5)
                    elif self._nbConsecutiveConnFailure <= 60:
                        self.debug('sleeping 2 sec...')
                        time.sleep(2)
                    else:
                        self.debug('sleeping 30 sec...')
                        time.sleep(30)
                    
        self.bot('Stop listening.')

        with self.exiting:
            #self.input.close()
            self.output.close()

            if self.exitcode:
                sys.exit(self.exitcode)


    def routeFrostbitePacket(self, packet):
        if packet is None:
            self.warning('cannot route empty packet : %s' % traceback.extract_tb(sys.exc_info()[2]))
        
        eventType = packet[0]
        eventData = packet[1:]
        
        match = re.search(r"^(?P<actor>[^.]+)\.on(?P<event>.+)$", eventType)
        if match:
            func = 'On%s%s' % (string.capitalize(match.group('actor')), \
                               string.capitalize(match.group('event')))
            #self.debug("-==== FUNC!!: " + func)
            
        if match and hasattr(self, func):
            #self.debug('routing ----> %s' % func)
            func = getattr(self, func)
            event = func(eventType, eventData)
            #self.debug('event : %s' % event)
            if event:
                self.queueEvent(event)
            
        elif eventType in self._eventMap:
            self.queueEvent(b3.events.Event(
                    self._eventMap[eventType],
                    eventData))
        else:
            if func:
                data = func + ' '
            data += str(eventType) + ': ' + str(eventData)
            self.debug('TODO: %r' % packet)
            self.queueEvent(b3.events.Event(b3.events.EVT_UNKNOWN, data))


    def startup(self):
        self.checkVersion()
        
        # add specific events
        self.Events.createEvent('EVT_CLIENT_SQUAD_CHANGE', 'Client Squad Change')
        self.Events.createEvent('EVT_PUNKBUSTER_SCHEDULED_TASK', 'PunkBuster scheduled task')
        self.Events.createEvent('EVT_PUNKBUSTER_LOST_PLAYER', 'PunkBuster client connection lost')
        self.Events.createEvent('EVT_PUNKBUSTER_NEW_CONNECTION', 'PunkBuster client received IP')
        self.Events.createEvent('EVT_CLIENT_SPAWN', 'Client Spawn')
        self.Events.createEvent('EVT_GAME_ROUND_PLAYER_SCORES', 'round player scores')
        self.Events.createEvent('EVT_GAME_ROUND_TEAM_SCORES', 'round team scores')
                
        self.getServerVars()
        self.getServerInfo()
        
        if self.config.has_option('server', 'punkbuster') and self.config.getboolean('server', 'punkbuster'):
            self.info('kick/ban by punkbuster is unsupported yet')
            #self.debug('punkbuster enabled in config')
            #self.PunkBuster = Bfbc2PunkBuster(self)
        
        self.sayqueuelistener = threading.Thread(target=self.sayqueuelistener)
        self.sayqueuelistener.setDaemon(True)
        self.sayqueuelistener.start()

    
    def sayqueuelistener(self):
        while self.working:
            msg = self.sayqueue.get()
            for line in self.getWrap(self.stripColors(self.msgPrefix + ' ' + msg), self._settings['line_length'], self._settings['min_wrap_length']):
                self.write(self.getCommand('say', message=line))
                time.sleep(self._settings['message_delay'])
                

    def joinPlayers(self):
        self.info('Joining players...')
        plist = self.getPlayerList()
        for cid, p in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                self.debug(' - Joining %s' % cid)
                self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))
        return None
    
    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                mlist[cid] = client
                newTeam = c.get('teamId', None)
                if newTeam is not None:
                    client.team = self.getTeam(newTeam)
                client.teamId = int(newTeam)
        return mlist

    def getCommand(self, cmd, **kwargs):
        """Return a reference to a loaded command"""
        try:
            cmd = self._commands[cmd]
        except KeyError:
            return None

        preparedcmd = []
        for a in cmd:
            try:
                preparedcmd.append(a % kwargs)
            except KeyError:
                pass
        
        result = tuple(preparedcmd)
        self.debug('getCommand: %s', result)
        return result
    
    def write(self, msg, maxRetries=1, needConfirmation=False):
        """Write a message to Rcon/Console
        Unfortunaltely this has been abused all over B3 
        and B3 plugins to broadcast text :(
        """
        if type(msg) == str:
            # console abuse to broadcast text
            self.say(msg)
        else:
            # Then we got a command
            if self.replay:
                self.bot('Sent rcon message: %s' % msg)
            elif self.output == None:
                pass
            else:
                res = self.output.write(msg, maxRetries=maxRetries, needConfirmation=needConfirmation)
                self.output.flush()
                return res
            
    def getWrap(self, text, length=SAY_LINE_MAX_LENGTH, minWrapLen=SAY_LINE_MAX_LENGTH):
        """Returns a sequence of lines for text that fits within the limits
        """
        if not text:
            return []
    
        maxLength = int(length)
        
        if len(text) <= maxLength:
            return [text]
        else:
            wrappoint = text[:maxLength].rfind(" ")
            if wrappoint == 0:
                wrappoint = maxLength
            lines = [text[:wrappoint]]
            remaining = text[wrappoint:]
            while len(remaining) > 0:
                if len(remaining) <= maxLength:
                    lines.append(remaining)
                    remaining = ""
                else:
                    wrappoint = remaining[:maxLength].rfind(" ")
                    if wrappoint == 0:
                        wrappoint = maxLength
                    lines.append(remaining[0:wrappoint])
                    remaining = remaining[wrappoint:]
            return lines
        
    ##########################################################################
 
    def checkVersion(self):
        raise NotImplemented('checkVersion must be implemented in concrete classes')
        
    def getServerVars(self):
        raise NotImplemented('getServerVars must be implemented in concrete classes')

    def getClient(self, cid, _guid=None):
        """Get a connected client from storage or create it
        B3 CID   <--> ingame character name
        B3 GUID  <--> EA_guid
        """
        raise NotImplemented('getClient must be implemented in concrete classes')
    
    def getTeam(self, team):
        """convert frostbite team numbers to B3 team numbers"""
        raise NotImplemented('getTeam must be implemented in concrete classes')
        
    def getServerInfo(self):
        """query server info, update self.game and return query results
        Response: OK <pb prefix: string> <current playercount: integer> <max playercount: integer>
        <current gamemode: string> <current map: string> <roundsPlayed: integer> 
        <roundsTotal: string> <scores: team scores> <onlineState: online state>
        """
        data = self.write(('serverInfo',))
        self.game.sv_hostname = data[0]
        self.game.sv_maxclients = int(data[2])
        self.game.gameType = data[3]
        if not self.game.mapName:
            self.game.mapName = data[4]
        self.game.rounds = int(data[5])
        self.game.g_maxrounds = int(data[6])
        return data

    def getPlayerList(self, maxRetries=None):
        """return a dict which keys are cid and values a dict of player properties
        as returned by admin.listPlayers.
        Does not return client objects"""
        data = self.write(('admin.listPlayers', 'all'))
        if not data:
            return {}
        players = {}
        pib = PlayerInfoBlock(data)
        for p in pib:
            players[p['name']] = p
        return players
        
    def getPlayerScores(self):
        """Ask the server for a given client's team
        """
        scores = {}
        try:
            pib = PlayerInfoBlock(self.write(('admin.listPlayers', 'all')))
            for p in pib:
                scores[p['name']] = int(p['score'])
        except:
            self.debug('Unable to retrieve scores from playerlist')
        return scores
    
    def getPlayerPings(self):
        """Ask the server for a given client's pings
        """
        pings = {}
        try:
            pib = PlayerInfoBlock(self.write(('admin.listPlayers', 'all')))
            for p in pib:
                pings[p['name']] = int(p['ping'])
        except:
            self.debug('Unable to retrieve pings from playerlist')
        return pings
        
    def getNextMap(self):
        """Return the name of the next map
        """
        nextLevelIndex = self.getNextMapIndex()
        if nextLevelIndex == -1:
            return 'none'
        levelnames = self.write(('mapList.list',))
        return self.getEasyName(levelnames[nextLevelIndex])
    
    def getNextMapIndex(self):
        [nextLevelIndex] = self.write(('mapList.nextLevelIndex',))
        nextLevelIndex = int(nextLevelIndex)
        if nextLevelIndex == -1:
            return -1
        levelnames = self.write(('mapList.list',))
        if levelnames[nextLevelIndex] == self.getMap():
            nextLevelIndex = (nextLevelIndex+1)%len(levelnames)
        return nextLevelIndex
    
    def getMaps(self):
        """Return the map list for the current rotation. (as easy map names)
        This does not return all available maps
        """
        levelnames = self.write(('mapList.list',))
        mapList = []
        for l in levelnames:
            mapList.append(self.getEasyName(l))
        return mapList

    def getMap(self):
        """Return the current level name (not easy map name)"""
        self.getServerInfo()
        return self.game.mapName
    

    def getSupportedMaps(self):
        """return a list of supported levels for the current game mod"""
        [currentMode] = self.write(('admin.getPlaylist',))
        supportedMaps = self.write(('admin.supportedMaps', currentMode))
        return supportedMaps

    def getMapsSoundingLike(self, mapname):
        """found matching level names for the given mapname (which can either
        be a level name or map name)
        If no exact match is found, then return close candidates using soundex
        and then LevenshteinDistance algoritms
        """
        supportedMaps = self.getSupportedMaps()
        supportedEasyNames = {}
        for m in supportedMaps:
            supportedEasyNames[self.getEasyName(m)] = m
            
        data = mapname.strip()
        soundex1 = soundex(data)
        #self.debug('soundex %s : %s' % (data, soundex1))
        
        match = []
        if data in supportedMaps:
            match = [data]
        elif data in supportedEasyNames:
            match = [supportedEasyNames[data]]
        else:
            for m in supportedEasyNames:
                s = soundex(m)
                #self.debug('soundex %s : %s' % (m, s))
                if s == soundex1:
                    #self.debug('probable map : %s', m)
                    match.append(supportedEasyNames[m])
        
        if len(match) == 0:
            # suggest closest spellings
            shortmaplist = []
            for m in supportedEasyNames:
                if m.find(data) != -1:
                    shortmaplist.append(m)
            if len(shortmaplist) > 0:
                shortmaplist.sort(key=lambda map: levenshteinDistance(data, string.replace(map.strip())))
                self.debug("shortmaplist sorted by distance : %s" % shortmaplist)
                match = shortmaplist[:3]
            else:
                easyNames = supportedEasyNames.keys()
                easyNames.sort(key=lambda map: levenshteinDistance(data, map.strip()))
                self.debug("maplist sorted by distance : %s" % easyNames)
                match = easyNames[:3]
        return match
    
    
    ###########################################################################
    
    def OnPlayerChat(self, action, data):
        """
        player.onChat <source soldier name: string> <text: string> <target group: player subset>
        
        Effect: Player with name <source soldier name> (or the server, or the 
        server admin) has sent chat message <text> to some people
        
        Comment: The chat text is as represented before the profanity filtering 
        If <source soldier name> is 'Server', then the message was sent from the 
        server rather than from an actual player If sending to a specific player, 
        and the player doesn't exist, then the target group will be 'player' ''
        """
        #['envex', 'gg', 'team', 1]
        #['envex', 'gg', 'all']
        #['envex', 'gg', 'squad' 2]
        #['envex', 'gg', 'player', 'Courgette']
        client = self.getClient(data[0])
        if client is None:
            self.warning("Could not get client :( %s" % traceback.extract_tb(sys.exc_info()[2]))
            return
        if client.cid == 'Server':
            # ignore chat events for Server
            return
        if data[2] == 'all':
            return b3.events.Event(b3.events.EVT_CLIENT_SAY, data[1].lstrip('/'), client, 'all')
        elif data[2] == 'team' or data[2] == 'squad':
            return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, data[1].lstrip('/'), client, data[2] + ' ' + data[3])
        elif data[2] == 'player':
            target = self.getClient(data[3])
            return b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, data[1].lstrip('/'), client, target)
        

    def OnPlayerLeave(self, action, data):
        #player.onLeave: ['GunnDawg']
        client = self.getClient(data[0])
        if client: 
            client.endMessageThreads = True
            client.disconnect() # this triggers the EVT_CLIENT_DISCONNECT event
        return None

    def OnPlayerJoin(self, action, data):
        """
        we don't have guid at this point. Wait for player.onAuthenticated
        """
        pass
        

    def OnPlayerAuthenticated(self, action, data):
        """
        player.onAuthenticated <soldier name: string> <player GUID: guid>
        
        Effect: Player with name <soldier name> has been authenticated, and has the given GUID
        """
        #player.onJoin: ['OrasiK']
        client = self.getClient(data[0], data[1])
        # No need to queue a client join event, that is done by clients.newClient() already
        # return b3.events.Event(b3.events.EVT_CLIENT_CONNECT, data, client)


    def OnPlayerSpawn(self, action, data):
        """
        Request: player.onSpawn <spawning soldier name: string> <kit type: string> <gadget: string> <pistol: string> <primary weapon: string> <specialization 1: string> <specialization 2: string> <specialization 3: string>
        """
        if len(data) < 2:
            return None

        spawner = self.getClient(data[0])
        kit = data[1]
        gadget = data[2]
        pistol = data[3]
        weapon = data[4]
        spec1 = data[5]
        spec2 = data[6]
        spec3 = data[7]

        event = b3.events.EVT_CLIENT_SPAWN
        return b3.events.Event(event, (kit, gadget, pistol, weapon, spec1, spec2, spec3), spawner)


    def OnPlayerKill(self, action, data):
        """
        Request: player.onKill <killing soldier name: string> <killed soldier name: string> <weapon: string> <headshot: boolean> <killer location: 3 x integer> <killed location: 3 x integes>

        Effect: Player with name <killing soldier name> has killed <killed soldier name> Suicide is indicated with the same soldier name for killer and victim. If the server kills the player (through admin.killPlayer), it is indicated by showing the killing soldier name as Server. The locations of the killer and the killed have a random error of up to 10 meters in each direction.
        """
        #R15: player.onKill: ['Brou88', 'kubulina', 'S20K', 'true', '-77', '68', '-195', '-76', '62', '-209']
        if len(data) < 2:
            return None

        attacker = self.getClient(data[0])
        if not attacker:
            self.debug('No attacker')
            return None

        victim = self.getClient(data[1])
        if not victim:
            self.debug('No victim')
            return None
        
        if data[2]:
            weapon = data[2]
        else:
            # to accomodate pre R15 servers
            weapon = None

        if data[3]:
            if data[3] == 'true':
                hitloc = 'head'
            else:
                hitloc = 'torso'
        else:
            # to accomodate pre R15 servers
            hitloc = None

        attackerloc = []
        victimloc = []
        if data[4] and data[9]:
            attackerloc.append(data[4])
            attackerloc.append(data[5])
            attackerloc.append(data[6])
            victimloc.append(data[7])
            victimloc.append(data[8])
            victimloc.append(data[9])
        else:
            # to accomodate pre R15 servers
            attackerloc.append('None')
            victimloc.append('None')

        event = b3.events.EVT_CLIENT_KILL
        if victim == attacker:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team == victim.team and attacker.team != b3.TEAM_UNKNOWN and attacker.team != b3.TEAM_SPEC:
            event = b3.events.EVT_CLIENT_KILL_TEAM
        return b3.events.Event(event, (100, weapon, hitloc, attackerloc, victimloc), attacker, victim)



    def OnServerLoadinglevel(self, action, data):
        """
        server.onLoadingLevel <level name: string> <roundsPlayed: int> <roundsTotal: int>
        
        Effect: Level is loading
        """
        #['server.onLoadingLevel', 'levels/mp_04', '0', '2']
        self.debug("OnServerLoadinglevel: %s" % data)
        if not self.game.mapName:
            self.game.mapName = data[0]
        if self.game.mapName != data[0]:
            # map change detected
            self.game.startMap()
        self.game.mapName = data[0]
        self.game.rounds = int(data[1])
        self.game.g_maxrounds = int(data[2])
        self.getServerInfo()
        # to debug getEasyName()
        self.info('Loading %s [%s]'  % (self.getEasyName(self.game.mapName), self.game.gameType))
        return b3.events.Event(b3.events.EVT_GAME_WARMUP, data[0])

    def OnServerLevelstarted(self, action, data):
        """
        server.onLevelStarted
        
        Effect: Level is started"""
        # next function call will increase roundcount by one, this is not wanted
        # as the game server provides us the exact round number in OnServerLoadinglevel()
        # hence we need to deduct one to compensate?
        # we'll still leave the call here since it provides us self.game.roundTime()
        self.game.startRound()
        self.game.rounds -= 1
        
        #Players need to be joined (EVT_CLIENT_JOIN) for stats to count rounds
        self.joinPlayers()
        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)
            
        
    def OnServerRoundover(self, action, data):
        """
        server.onRoundOver <winning team: Team ID>
        
        Effect: The round has just ended, and <winning team> won
        """
        #['server.onRoundOver', '2']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_END, data[0])
        
        
    def OnServerRoundoverplayers(self, action, data):
        """
        server.onRoundOverPlayers <end-of-round soldier info : player info block>
        
        Effect: The round has just ended, and <end-of-round soldier info> is the final detailed player stats
        """
        #['server.onRoundOverPlayers', '8', 'clanTag', 'name', 'guid', 'teamId', 'kills', 'deaths', 'score', 'ping', '17', 'RAID', 'mavzee', 'EA_4444444444444444555555555555C023', '2', '20', '17', '310', '147', 'RAID', 'NUeeE', 'EA_1111111111111555555555555554245A', '2', '30', '18', '445', '146', '', 'Strzaerl', 'EA_88888888888888888888888888869F30', '1', '12', '7', '180', '115', '10tr', 'russsssssssker', 'EA_E123456789461416564796848C26D0CD', '2', '12', '12', '210', '141', '', 'Daezch', 'EA_54567891356479846516496842E17F4D', '1', '25', '14', '1035', '129', '', 'Oldqsdnlesss', 'EA_B78945613465798645134659F3079E5A', '1', '8', '12', '120', '256', '', 'TTETqdfs', 'EA_1321654656546544645798641BB6D563', '1', '11', '16', '180', '209', '', 'bozer', 'EA_E3987979878946546546565465464144', '1', '22', '14', '475', '152', '', 'Asdf 1977', 'EA_C65465413213216656546546546029D6', '2', '13', '16', '180', '212', '', 'adfdasse', 'EA_4F313565464654646446446644664572', '1', '4', '25', '45', '162', 'SG1', 'De56546ess', 'EA_123132165465465465464654C2FC2FBB', '2', '5', '8', '75', '159', 'bsG', 'N06540RZ', 'EA_787897944546565656546546446C9467', '2', '8', '14', '100', '115', '', 'Psfds', 'EA_25654321321321000006546464654B81', '2', '15', '15', '245', '140', '', 'Chezear', 'EA_1FD89876543216548796130EB83E411F', '1', '9', '14', '160', '185', '', 'IxSqsdfOKxI', 'EA_481321313132131313213212313112CE', '1', '21', '12', '625', '236', '', 'Ledfg07', 'EA_1D578987994651615166516516136450', '1', '5', '6', '85', '146', '', '5 56 mm', 'EA_90488E6543216549876543216549877B', '2', '0', '0', '0', '192']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_PLAYER_SCORES, PlayerInfoBlock(data))
        
        
    def OnServerRoundoverteamscores(self, action, data):
        """
        server.onRoundOverTeamScores <end-of-round scores: team scores>
        
        Effect: The round has just ended, and <end-of-round scores> is the final ticket/kill/life count for each team
        """
        #['server.onRoundOverTeamScores', '2', '1180', '1200', '1200']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_TEAM_SCORES, data[1])

    def OnPunkbusterMessage(self, action, data):
        """handles all punkbuster related events and 
        route them to the appropriate method depending
        on the type of PB message.
        """
        #self.debug("PB> %s" % data)
        if data and data[0]:
            for regexp, funcName in self._punkbusterMessageFormats:
                match = re.match(regexp, str(data[0]).strip())
                if match:
                    break
            if match and hasattr(self, funcName):
                func = getattr(self, funcName)
                event = func(match, data[0])
                if event:
                    self.queueEvent(event)     
            else:
                return b3.events.Event(b3.events.EVT_UNKNOWN, data)
                
    def OnPBVersion(self, match,data):
        """PB notifies us of the version numbers
        version = match.group('version')"""
        #self.debug('PunkBuster Server version: %s' %( match.group('version') ) )
        pass

    def OnPBNewConnection(self, match, data):
        """PunkBuster tells us a new player identified. The player is
        normally already connected and authenticated by B3 by ea_guid
        
        This is our first moment where we receive the clients IP address
        so we also fire the custom event EVT_PUNKBUSTER_NEW_CONNECTION here"""
        name = match.group('name')
        client = self.getClient(name)
        if client:
            #slot = match.group('slot')
            ip = match.group('ip')
            port = match.group('port')
            #something = match.group('something')
            client.ip = ip
            client.port = port
            client.save()
            self.debug('OnPBNewConnection: client updated with %s' % data)
            # This is our first moment where we get a clients IP. Fire this event to accomodate geoIP based plugins like Countryfilter.
            return b3.events.Event(b3.events.EVT_PUNKBUSTER_NEW_CONNECTION, data, client)
        else:
            self.warning('OnPBNewConnection: we\'ve been unable to get the client')

    def OnPBLostConnection(self, match, data):
        """PB notifies us it lost track of a player. This is the only change
        we have to save the ip of clients.
        This event is triggered after the OnPlayerLeave, so normaly the client
        is not connected. Anyway our task here is to save data into db not to 
        connect/disconnect the client.
        
        Part of this code is obsolete since R15, IP is saved to DB on OnPBNewConnection()
        """
        name = match.group('name')
        dict = {
            'slot': match.group('slot'),
            'ip': match.group('ip'),
            'port': match.group('port'),
            'pbuid': match.group('pbuid'),
            'name': name
        }
        """ Code Obsolete since R15:
        client = self.clients.getByCID(dict['name'])
        if not client:
            matchingClients = self.storage.getClientsMatching( {'pbid': match.group('pbuid')} )
            if matchingClients and len(matchingClients) == 0:
                client = matchingClients[0]
        if not client:
            self.error('unable to find client %s. weird' %name )
        else:
            # update client data with PB id and IP
            client.pbid = dict['pbuid']
            client.ip = dict['ip']
            client.save()
        """
        self.verbose('PB lost connection: %s' %dict)
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_LOST_PLAYER, dict)

    def OnPBScheduledTask(self, match, data):
        """We get notified the server ran a PB scheduled task
        Nothing much to do but it can be interresting to have
        this information logged
        """
        slot = match.group('slot')
        task = match.group('task')
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_SCHEDULED_TASK, {'slot': slot, 'task': task})

    def OnPBMasterQuerySent(self, match, data):
        """We get notified that the server sent a ping to the PB masters"""
        #pbmaster = match.group('pbmaster')
        #ip = match.group('ip')
        pass

    def OnPBPlayerGuid(self, match, data):
        """We get notified of a player punkbuster GUID"""
        pbid = match.group('pbid')
        #slot = match.group('slot')
        ip = match.group('ip')
        #port = match.group('port')
        name = match.group('name')
        client = self.getClient(name)
        client.ip = ip
        client.pbid = pbid
        client.save()
        
        
    ###########################################################################
    

    def message(self, client, text):
        try:
            if client == None:
                self.say(text)
            elif client.cid == None:
                pass
            else:
                self.write(self.getCommand('message', message=text, cid=client.cid))
        except:
            pass


    def say(self, msg):
        self.sayqueue.put(msg)
        

    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('kick reason: [%s]' % reason)
        if isinstance(client, str):
            self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))
            return
        
        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.PunkBuster:
            self.PunkBuster.kick(client, 0.5, reason)
        
        self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))

        if not silent and fullreason != '':
            self.say(fullreason)
            
            
    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        duration = b3.functions.time2minutes(duration)

        if isinstance(client, str):
            self.write(self.getCommand('tempban', guid=client.guid, duration=duration*60, reason=reason[:80]))
            return
        
        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.PunkBuster:
            # punkbuster acts odd if you ban for more than a day
            # tempban for a day here and let b3 re-ban if the player
            # comes back
            if duration > 1440:
                duration = 1440

            self.PunkBuster.kick(client, duration, reason)
        
        self.write(self.getCommand('tempban', guid=client.guid, duration=duration*60, reason=reason[:80]))
        
        
        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                        , client))


    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('UNBAN: Name: %s, Ip: %s, Guid: %s' %(client.name, client.ip, client.guid))
        if client.ip:
            response = self.write(self.getCommand('unbanByIp', ip=client.ip, reason=reason), needConfirmation=True)
            #self.verbose(response)
            if response == "OK":
                self.verbose('UNBAN: Removed ip (%s) from banlist' %client.ip)
                if admin:
                    admin.message('Unbanned: %s. His last ip (%s) has been removed from banlist.' % (client.exactName, client.ip))
                if admin:
                    fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))
                if not silent and fullreason != '':
                    self.say(fullreason)
        
        response = self.write(self.getCommand('unban', guid=client.guid, reason=reason), needConfirmation=True)
        #self.verbose(response)
        if response == "OK":
            self.verbose('UNBAN: Removed guid (%s) from banlist' %client.guid)
            if admin:
                admin.message('Unbanned: Removed %s guid from banlist' % (client.exactName))
        
        if self.PunkBuster:
            self.PunkBuster.unBanGUID(client)
        

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """Permanent ban"""
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, b3.clients.Client):
            self.write(self.getCommand('ban', guid=client.guid, reason=reason[:80]))
            return

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if client.cid is None:
            # ban by ip, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByIp', ip=client.ip, reason=reason[:80]))
            self.write(self.getCommand('banByIp', ip=client.ip, reason=reason[:80]))
            if admin:
                admin.message('banned: %s (@%s). His last ip (%s) has been added to banlist'%(client.exactName, client.id, client.ip))
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', guid=client.guid, reason=reason[:80]))
            self.write(self.getCommand('ban', cid=client.cid, reason=reason[:80]))
            if admin:
                admin.message('banned: %s (@%s) has been added to banlist'%(client.exactName, client.id))

        if self.PunkBuster:
            self.PunkBuster.banGUID(client, reason)
        
        if not silent and fullreason != '':
            self.say(fullreason)
        
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))


    def authorizeClients(self):
        players = self.getPlayerList()
        self.verbose('authorizeClients() = %s' % players)

        for cid, p in players.iteritems():
            sp = self.clients.getByCID(cid)
            if sp:
                # Only set provided data, otherwise use the currently set data
                sp.ip   = p.get('ip', sp.ip)
                sp.pbid = p.get('pbid', sp.pbid)
                sp.guid = p.get('guid', sp.guid)
                sp.data = p
                newTeam = p.get('teamId', None)
                if newTeam is not None:
                    sp.team = self.getTeam(newTeam)
                sp.teamId = int(newTeam)
                sp.auth()


    def getCvar(self, cvarName):
        """Read a server var"""
        if cvarName not in self._gameServerVars:
            self.warning('unknown cvar \'%s\'' % cvarName)
            return None
        
        try:
            words = self.write(('vars.%s' % cvarName,))
        except FrostbiteCommandFailedError, err:
            self.error(err)
            return
        self.debug('Get cvar %s = %s', cvarName, words)
        
        if words:
            if len(words) == 0:
                return b3.cvar.Cvar(cvarName, value=None)
            else:
                return b3.cvar.Cvar(cvarName, value=words[0])
        return None


    def setCvar(self, cvarName, value):
        """Set a server var"""
        if cvarName not in self._gameServerVars:
            self.warning('cannot set unknown cvar \'%s\'' % cvarName)
            return
        self.debug('Set cvar %s = \'%s\'', cvarName, value)
        try:
            self.write(('vars.%s' % cvarName, value))
        except FrostbiteCommandFailedError, err:
            self.error(err)


def patch_b3_clients():
    #############################################################
    # Below is the code that change a bit the b3.clients.Client
    # class at runtime. What the point of coding in python if we
    # cannot play with its dynamic nature ;)
    #
    # why ?
    # because doing so make sure we're not broking any other
    # working and long tested parser. The change we make here
    # are only applied when the frostbite parser is loaded.
    #############################################################

    ## add a new method to the Client class
    def frostbiteClientMessageQueueWorker(self):
        """
        This take a line off the queue and displays it
        then pause for 'message_delay' seconds
        """
        while not self.messagequeue.empty():
            msg = self.messagequeue.get()
            if msg:
                self.console.message(self, msg)
                time.sleep(float(self.console._settings.get('message_delay', 1)))
    b3.clients.Client.messagequeueworker = frostbiteClientMessageQueueWorker

    ## override the Client.message() method at runtime
    def frostbiteClientMessageMethod(self, msg):
        if msg and len(msg.strip())>0:
            # do we have a queue?
            if not hasattr(self, 'messagequeue'):
                self.messagequeue = Queue.Queue()
            # fill the queue
            text = self.console.stripColors(self.console.msgPrefix + ' [pm] ' + msg)
            for line in self.console.getWrap(text, self.console._settings['line_length'], self.console._settings['min_wrap_length']):
                self.messagequeue.put(line)
            # create a thread that executes the worker and pushes out the queue
            if not hasattr(self, 'messagehandler') or not self.messagehandler.isAlive():
                self.messagehandler = threading.Thread(target=self.messagequeueworker)
                self.messagehandler.setDaemon(True)
                self.messagehandler.start()
            else:
                self.console.verbose('messagehandler for %s isAlive' %self.name)
    b3.clients.Client.message = frostbiteClientMessageMethod

########NEW FILE########
__FILENAME__ = connection
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 2010/03/09 - 0.5 - Courgette
# * open a TCP connection to a BFBC2 server, auth with provided password
# * can either be used to send commands or enter the listening mode (which
#   waits for BFBC2 events)
# 2010/03/14 - 0.6 - Courgette
# * raise a FrostbiteNetworkException whenever something goes wrong on the 
#   network while using sendRequest()
# 2010/03/16 - 0.7 - Courgette
# * FrostbiteCommandFailedError now also contains the BFBC2 response
# 2010/03/19 - 0.8 - Courgette
# * fix bug listening to event when we have an incomplete packet
# 2010/03/23 - 0.9 - Courgette
# * bugfix: when start listening and only a partial packet is available
# 2010/03/25 - 0.10 - Courgette
# * updated to use latest protocol.py
# * sendRequest and readEvent now detect a lost connection and reconnect in such cases
# 2010/03/25 - 0.10.1 - Courgette
# * Exception message more explicit
# * fix the socket time out message when listening to events
# 2010/03/30 - 0.11 - Courgette
# * use console to print messages
# * when listening to event, do not set the socket into blocking mode. This should
#   make the bot recover from a connection loss
# 2010/04/11 - 1.0 - Courgette
# * fix a bug which occurred in the rare case we receive from the server a packet from another sequence
# * make this version 1.0 as it seems to be stable enough now
# 2010/04/18 - 1.1 - Courgette
# * harden readEvent in cases where a network error occurs while replying OK to an event (Thanks to Merph's report)
# 2010/04/18 - 1.2 - Courgette
# * try to make sure readEvent does not hang on a dead connection
# 2010/04/20 - 1.2.1 - Courgette
# * harden 1.2
# 2010/10/11 - 1.2.2 - xlr8or
# * Output to log changed: BFBC2 -> Frostbite (cosmetic only!)
# 2010/10/23 - 2.0 - Courgette
# * refactor to make this module generic for all frostbite games

__author__  = 'Courgette'
__version__ = '2.0'

debug = True

import socket
import b3.parsers.frostbite.protocol as protocol
 
    

class FrostbiteException(Exception): pass
class FrostbiteNetworkException(FrostbiteException): pass
class FrostbiteBadPasswordException(FrostbiteException): pass

class FrostbiteCommandFailedError(Exception): pass

class FrostbiteConnection(object):
    
    console = None
    _serverSocket = None
    _receiveBuffer = None
    _host = None
    _port = None
    _password = None

    def __init__(self, console, host, port, password):
        self.console = console
        self._host = host
        self._port = port
        self._password = password
        
        try:
            self._connect()
            self._auth()
        except socket.error, detail:
            raise FrostbiteNetworkException('Cannot create FrostbiteConnection: %s'% detail)
   
    def __del__(self):
        self.close()
   
    def _connect(self):
        try:
            self.console.debug('opening FrostbiteConnection socket')
            self._receiveBuffer = ''
            self._serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._serverSocket.connect( ( self._host, self._port ) )
        except Exception, err:
            raise FrostbiteException(err)
    
    def close(self):
        if self._serverSocket is not None:
            self.console.debug('closing FrostbiteConnection socket')
            try:
                self.sendRequest('quit')
            except: pass
            self._serverSocket.close()
            self._serverSocket = None

    def sendRequest(self, *command):
        if command is None:
            return None
        if self._serverSocket is None:
            self.console.info("sendRequest: reconnecting...")
            self._connect()
            self._auth()
            
        if len(command) == 1 and type(command[0]) == tuple:
            words = command[0]
        else:
            words = command
        request = protocol.EncodeClientRequest(words)
        self.printPacket(protocol.DecodePacket(request))
        try:
            self._serverSocket.sendall(request)
            [response, self._receiveBuffer] = protocol.receivePacket(self._serverSocket, self._receiveBuffer)
        except socket.error, detail:
            raise FrostbiteNetworkException(detail)
        
        if response is None:
            return None
        decodedResponse = protocol.DecodePacket(response)
        self.printPacket(decodedResponse)
        #[isFromServer, isResponse, sequence, words] = decodedResponse
        return decodedResponse[3]
        
    def _auth(self):
        self.console.debug('authing to Frostbite server')
        if self._serverSocket is None:
            raise FrostbiteConnection("cannot auth, need to be connected")
            
        # Retrieve this connection's 'salt' (magic value used when encoding password) from server
        words = self.sendRequest("login.hashed")

        # if the server doesn't understand "login.hashed" command, abort
        if words[0] != "OK":
            raise FrostbiteException("Could not retrieve salt")

        # Given the salt and the password, combine them and compute hash value
        salt = words[1].decode("hex")
        passwordHash = protocol.generatePasswordHash(salt, self._password)
        passwordHashHexString = protocol.string.upper(passwordHash.encode("hex"))

        # Send password hash to server
        loginResponse = self.sendRequest("login.hashed", passwordHashHexString)

        # if the server didn't like our password, abort
        if loginResponse[0] != "OK":
            raise FrostbiteBadPasswordException("The Frostbite server refused our password")

            
    def subscribeToEvents(self):
        """
        tell the frostbite server to send us events
        """
        self.console.debug('subscribing to Frostbite events')
        response = self.sendRequest("eventsEnabled", "true")

        # if the server didn't know about the command, abort
        if response[0] != "OK":
            raise FrostbiteCommandFailedError(response)

        
    def readEvent(self):
        # Wait for event from server
        packet = None
        timeout_counter = 0
        while packet is None:
            try:
                if self._serverSocket is None:
                    self.console.info("readEvent: reconnecting...")
                    self._connect()
                    self._auth()
                    self.subscribeToEvents()
                [tmppacket, self._receiveBuffer] = protocol.receivePacket(self._serverSocket, self._receiveBuffer)
                [isFromServer, isResponse, sequence, words] = protocol.DecodePacket(tmppacket)
                if isFromServer and not isResponse:
                    packet = tmppacket
                else:
                    self.console.verbose2('received a packet which is not an event: %s' % [isFromServer, isResponse, sequence, words,])
            except socket.timeout:
                timeout_counter += 1
                self.console.verbose2('timeout %s' % timeout_counter)
                if timeout_counter >= 5:
                    self.console.verbose2('checking connection...')
                    request = protocol.EncodeClientRequest(['eventsEnabled','true'])
                    self.printPacket(protocol.DecodePacket(request))
                    self._serverSocket.sendall(request)
                    timeout_counter = 0
            except socket.error, detail:
                raise FrostbiteNetworkException('readEvent: %r'% detail)

        try:
            [isFromServer, isResponse, sequence, words] = protocol.DecodePacket(packet)
            self.printPacket(protocol.DecodePacket(packet))
        except:
            raise FrostbiteException('readEvent: failed to decodePacket {%s}' % packet)
        
        # If this was a command from the server, we should respond to it
        # For now, we always respond with an "OK"
        if isResponse:
            self.console.debug('Received an unexpected response packet from server, ignoring: %r' % packet)
            return self.readEvent()
        else:
            response = protocol.EncodePacket(True, True, sequence, ["OK"])
            self.printPacket(protocol.DecodePacket(response))
            
            try:
                self._serverSocket.sendall(response)
            except socket.error, detail:
                self.console.warning("in readEvent while sending response OK to server : %s" % detail)
                
            return words
            
    def printPacket(self, packet):
        """Display contents of packet in user-friendly format, useful for debugging purposes"""
        if debug:
            isFromServer = packet[0]
            isResponse = packet[1]
            msg = ""
            if isFromServer and isResponse:
                msg += "<-R-"
            elif isFromServer and not isResponse:
                msg += "-Q->"
            elif not isFromServer and isResponse:
                msg += "-R->"
            elif not isFromServer and not isResponse:
                msg += "<-Q-"
        
            msg += " (%s)" %  packet[2]
        
            if packet[3]:
                msg += " :"
                for word in packet[3]:
                    msg += " \"" + word + "\""
        
            self.console.verbose2(msg)
        

        

###################################################################################
# Example program

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) != 4:
        host = raw_input('Enter game server host IP/name: ')
        port = int(raw_input('Enter host port: '))
        pw = raw_input('Enter password: ')
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
        pw = sys.argv[3]
    
    class MyConsole:
        def debug(self, msg):
            print "   DEBUG: " + msg
        def info(self, msg):
            print "    INFO: " + msg
        def verbose2(self, msg):
            print "VERBOSE2: " + msg
        def warning(self, msg):
            print "WARNING : " + msg
    myConsole = MyConsole()
    
    bc2server = FrostbiteConnection(myConsole, host, port, pw)
    print "connected"
    
    reponse = bc2server.sendRequest(('version',))
    print reponse[1]
    
    reponse = bc2server.sendRequest(('help',))
    for command in reponse[1:]:
        print '\t' + command
    
    bc2server.close()
    print "closed"
    
    bc2server.readEvent()
    
    
    

########NEW FILE########
__FILENAME__ = protocol
#!/usr/local/bin/python

# Changelog
# 2010/07/23 - xlr8or - v1.0.1
# * fixed infinite loop in a python socket thread in receivePacket() on gameserver restart

__version__ = '1.0.1'

from struct import *
import socket
import sys
import shlex
import string
import threading
import os
try:
    from hashlib import md5 as newmd5
except ImportError:
    # for Python versions < 2.5
    from md5 import new as newmd5

def EncodeHeader(isFromServer, isResponse, sequence):
    header = sequence & 0x3fffffff
    if isFromServer:
        header += 0x80000000
    if isResponse:
        header += 0x40000000
    return pack('<I', header)

def DecodeHeader(data):
    [header] = unpack('<I', data[0 : 4])
    return [header & 0x80000000, header & 0x40000000, header & 0x3fffffff]

def EncodeInt32(size):
    return pack('<I', size)

def DecodeInt32(data):
    return unpack('<I', data[0 : 4])[0]
    
    
def EncodeWords(words):
    size = 0
    encodedWords = ''
    for word in words:
        strWord = str(word)
        encodedWords += EncodeInt32(len(strWord))
        encodedWords += strWord
        encodedWords += '\x00'
        size += len(strWord) + 5
    
    return size, encodedWords
    
def DecodeWords(size, data):
    numWords = DecodeInt32(data[0:])
    words = []
    offset = 0
    while offset < size:
        wordLen = DecodeInt32(data[offset : offset + 4])        
        word = data[offset + 4 : offset + 4 + wordLen]
        words.append(word)
        offset += wordLen + 5

    return words

def EncodePacket(isFromServer, isResponse, sequence, words):
    encodedHeader = EncodeHeader(isFromServer, isResponse, sequence)
    encodedNumWords = EncodeInt32(len(words))
    [wordsSize, encodedWords] = EncodeWords(words)
    encodedSize = EncodeInt32(wordsSize + 12)
    return encodedHeader + encodedSize + encodedNumWords + encodedWords

# Decode a request or response packet
# Return format is:
# [isFromServer, isResponse, sequence, words]
# where
# isFromServer = the command in this command/response packet pair originated on the server
#     isResponse = True if this is a response, False otherwise
#     sequence = sequence number
#     words = list of words
    
def DecodePacket(data):
    [isFromServer, isResponse, sequence] = DecodeHeader(data)
    wordsSize = DecodeInt32(data[4:8]) - 12
    words = DecodeWords(wordsSize, data[12:])
    return [isFromServer, isResponse, sequence, words]

###############################################################################

clientSequenceNr = 0

# Encode a request packet

def EncodeClientRequest(words):
    global clientSequenceNr
    packet = EncodePacket(False, False, clientSequenceNr, words)
    clientSequenceNr = (clientSequenceNr + 1) & 0x3fffffff
    return packet

# Encode a response packet
    
def EncodeClientResponse(sequence, words):
    return EncodePacket(True, True, sequence, words)


###################################################################################
# Display contents of packet in user-friendly format, useful for debugging purposes
    
def printPacket(packet):

    if (packet[0]):
        print "IsFromServer, ",
    else:
        print "IsFromClient, ",
    
    if (packet[1]):
        print "Response, ",
    else:
        print "Request, ",

    print "Sequence: " + str(packet[2]),

    if packet[3]:
        print " Words:",
        for word in packet[3]:
            print "\"" + word + "\"",

    print ""

###################################################################################

def generatePasswordHash(salt, password):
    m = newmd5()
    m.update(salt)
    m.update(password)
    return m.digest()
    
###################################################################################

def containsCompletePacket(data):
    if len(data) < 8:
        return False
    if len(data) < DecodeInt32(data[4:8]):
        return False
    return True

# Wait until the local receive buffer contains a full packet (appending data from the network socket),
# then split receive buffer into first packet and remaining buffer data
    
def receivePacket(_socket, receiveBuffer):

    while not containsCompletePacket(receiveBuffer):
        data = _socket.recv(4096) #was 16384
        #Make sure we raise a socket error when the socket is hanging on a loose end (receiving no data after server restart) 
        if not data:
            raise socket.error('No data received - Remote end unexpectedly closed socket')
        receiveBuffer += data;

    packetSize = DecodeInt32(receiveBuffer[4:8])

    packet = receiveBuffer[0:packetSize]
    receiveBuffer = receiveBuffer[packetSize:len(receiveBuffer)]

    return [packet, receiveBuffer]

        
        
###################################################################################
# Example program

if __name__ == '__main__':
    from getopt import getopt
    import sys

    print "Remote administration event listener for BFBC2"
# history_file = os.path.join( os.environ["HOME"], ".bfbc2_rcon_history" )

    host = None
    port = None
    pw = None
    serverSocket = None

    opts, args = getopt(sys.argv[1:], 'h:p:e:a:')
    for k, v in opts:
        if k == '-h':
            host = v
        elif k == '-p':
            port = int(v)
        elif k == '-a':
            pw = v
    
    if not host:
        host = raw_input('Enter game server host IP/name: ')
    if not port:
        port = int(raw_input('Enter host port: '))
    if not pw:
        pw = raw_input('Enter password: ')

    try:
        serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        print 'Connecting to port: %s:%d...' % ( host, port )
        serverSocket.connect( ( host, port ) )
        serverSocket.setblocking(1)
        receiveBuffer = ''

        print 'Logging in - 1: retrieving salt...'

        # Retrieve this connection's 'salt' (magic value used when encoding password) from server
        getPasswordSaltRequest = EncodeClientRequest( [ "login.hashed" ] )
        serverSocket.send(getPasswordSaltRequest)

        [getPasswordSaltResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
        printPacket(DecodePacket(getPasswordSaltResponse))

        [isFromServer, isResponse, sequence, words] = DecodePacket(getPasswordSaltResponse)

        # if the server doesn't understand "login.hashed" command, abort
        if words[0] != "OK":
            sys.exit(0);

        print 'Received salt: ' + words[1]

        # Given the salt and the password, combine them and compute hash value
        salt = words[1].decode("hex")
        passwordHash = generatePasswordHash(salt, pw)
        passwordHashHexString = string.upper(passwordHash.encode("hex"))

        print 'Computed password hash: ' + passwordHashHexString
        
        # Send password hash to server
        print 'Logging in - 2: sending hash...'

        loginRequest = EncodeClientRequest( [ "login.hashed", passwordHashHexString ] )
        serverSocket.send(loginRequest)

        [loginResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)

        printPacket(DecodePacket(loginResponse))

        [isFromServer, isResponse, sequence, words] = DecodePacket(loginResponse)

        # if the server didn't like our password, abort
        if words[0] != "OK":
            sys.exit(0);

        print 'Logged in.'
        
        print 'Enabling events...'
    
        enableEventsRequest = EncodeClientRequest( [ "eventsEnabled", "true" ] )
        serverSocket.send(enableEventsRequest)

        [enableEventsResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
        printPacket(DecodePacket(enableEventsResponse))

        [isFromServer, isResponse, sequence, words] = DecodePacket(enableEventsResponse)

        # if the server didn't know about the command, abort
        if words[0] != "OK":
            sys.exit(0);
        
        print 'Now waiting for events.'

        while True:
            # Wait for packet from server
            [packet, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)

            [isFromServer, isResponse, sequence, words] = DecodePacket(packet)

            # If this was a command from the server, we should respond to it
            # For now, we always respond with an "OK"
            if not isResponse:
                response = EncodeClientResponse(sequence, ["OK"])
                serverSocket.send(response)
            else:
                print 'Received an unexpected response packet from server, ignoring:'

            printPacket(DecodePacket(packet))


    except socket.error, detail:
        print 'Network error:', detail[1]

    except EOFError, KeyboardInterrupt:
        pass

    except:
        raise

########NEW FILE########
__FILENAME__ = punkbuster
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 2010/03/24 - 1.1 - Courgette
#   * make sure to fallback on the parsers' getPlayerList() method as in the BFBC2 
#     the PB_SV_PList command is asynchronous and cannot be used as expected
#     with other B3 parsers
#   * make sure not to ban with slot id as this is not reliable
#
#

__author__  = 'Courgette'
__version__ = '1.1'

import re
import b3.parsers.punkbuster

#--------------------------------------------------------------------------------------------------
class PunkBuster(b3.parsers.punkbuster.PunkBuster):

    def send(self, command):
        return self.console.write(('punkBuster.pb_sv_command', command))

    def getPlayerList(self):
        return self.console.getPlayerList()

    def ban(self, client, reason='', private=''):
        # in BFBC2 we do not have reliable slot id for connected players.
        # fallback on banning by GUID instead
        return self.banGUID(client, reason)
            
########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Changelog :
# 2010/03/09 - 0.1 - Courgette
# * alpha, need test server to validate
# 2010/03/09 - 0.2 - courgette
# * tested, seems to work for most cases
# 2010/03/14 - 0.3 - Courgette
# * write() can retry in case of failure
# 2010/03/27 - 0.3.1 - Courgette
# * fix maxRetries limitation 
# * make this class thread safe
# 2010/04/03 - 0.3.2 - courgette
# * fix import FrostbiteException
# 2010/04/11 - 1.0 Courgette
# * just make it v1.0 as it is now part of a public release and works rather good
# 2010/04/15 - 1.0.1 Bakes
# * If the response of the rcon command does not start with 'OK', trigger FrostbiteCommandFailedError
# 2010/07/29 - 1.0.2 xlr8or
# * The response may also be "NotFound" ie. when a guid or ip address is not found in the banslist.
# * Added needConfirmation var to write() so we can use the confirmationtype ("OK", "NotFound") to test on.
# 2010/10/23 - 2.0 - Courgette
# * refactor BFBC2 -> frostbite

 
__author__ = 'Courgette'
__version__ = '2.0'
 
import thread
from b3.parsers.frostbite.connection import FrostbiteConnection, FrostbiteException, FrostbiteCommandFailedError

#--------------------------------------------------------------------------------------------------
class Rcon:
    _lock = thread.allocate_lock()
    console = None
    _frostbiteConnection = None
    
    _rconIp = None
    _rconPort = None
    _rconPassword = None
    

    def __init__(self, console, host, password):
        self.console = console
        self._rconIp, self._rconPort = host
        self._rconPassword = password
        
    def _connect(self):
        if self._frostbiteConnection:
            return
        self.console.verbose('RCON: Connecting to Frostbite server ...')
        self._frostbiteConnection = FrostbiteConnection(self.console, self._rconIp, self._rconPort, self._rconPassword)

    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, maxRetries=1, needConfirmation=False):
        self._lock.acquire()
        try:
            if self._frostbiteConnection is None:
                self._connect()
            tries = 0
            while tries < maxRetries:
                try:
                    tries += 1
                    self.console.verbose('RCON (%s/%s) %s' % (tries, maxRetries, cmd))
                    response = self._frostbiteConnection.sendRequest(cmd)
                    if response[0] != "OK" and response[0] != "NotFound":
                        raise FrostbiteCommandFailedError(response)
                    if needConfirmation:
                        return response[0]
                    else:
                        return response[1:]
                except FrostbiteException, err:
                    self.console.warning('RCON: sending \'%s\', %s' % (cmd, err))
            self.console.error('RCON: failed to send \'%s\'', cmd)
            try:
                # we close the connection to make sure to have a brand new one 
                # on the next write
                self.close()
            except: pass
        finally:
            self._lock.release()

    def flush(self):
        pass

    def close(self):
        self.console.info('RCON: disconnecting from BFBC2 server')
        self._frostbiteConnection.close()

            
            
if __name__ == '__main__':
    """
    To run tests : python b3/parsers/bfbc2/rcon.py <rcon_ip> <rcon_port> <rcon_password>
    """
    import sys
    if len(sys.argv) != 4:
        host = raw_input('Enter game server host IP/name: ')
        port = int(raw_input('Enter host port: '))
        pw = raw_input('Enter password: ')
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
        pw = sys.argv[3]
    
    from b3.fake import fakeConsole
    
    import b3.parsers.frostbite.connection as fbConnection
    fbConnection.debug = True


    r = Rcon(fakeConsole, (host, port), pw)   
    r.write(('admin.yell', 'test', 1400, 'player', 'Courgette'))  
    
    
    for cmd in ['version', 'serverInfo', 'help', 'version', 'admin.currentLevel', ('admin.listPlayers', 'all')]:
        fakeConsole.info('Writing %s', cmd)
        data = r.write(cmd)
        fakeConsole.info('Recieved %s', data)
    
    print '----------------------------'
    
    varlist = (
        '3dSpotting',
        'bannerUrl',
        'crossHair',
        'currentPlayerLimit',
        'friendlyFire',
        'gamePassword',
        'hardCore',
        'killCam',
        'maxPlayerLimit',
        'miniMap',
        'miniMapSpotting',
        'playerLimit',
        'punkBuster',
        'rankLimit',
        'ranked',
        'serverDescription',
        'teamBalance',
        'thirdPersonVehicleCameras'
    )
    #for var in varlist:
        #time.sleep(0.5)
        #print r.write('vars.%s' % var)[0]
        
    print '----------------------------'
        
    for c in r.write(('help',)):
        print c
#    import time
#    for var in varlist:
#        time.sleep(0.5)
#        val = r.write('vars.%s' % var)[0]
#        print "------------original %s value : '%s' -------------" % (var, val)
#    
#        if val == 'true':
#            newval = 'false'
#        elif val == 'false':
#            newval = 'true'
#        else:
#            try:
#                int(val)
#                newval = 2
#            except ValueError:
#                newval = 'test qsdf'
#        
#        print "\t > changing to '%s'" % newval
#        time.sleep(0.5)
#        r.write(('vars.%s' % var, newval))
#        
#        time.sleep(0.5)
#        val2 = r.write('vars.%s' % var)[0]
#        print "\t\tnow : '%s'" % val2
#        
#        print "\t > changing back to '%s'" % val
#        time.sleep(0.5)
#        r.write(('vars.%s' % var, val))
#        
#        time.sleep(0.5)
#        val3 = r.write('vars.%s' % var)[0]
#        print "\t\tnow : '%s'" % val3
#        
#        time.sleep(0.5)
#        if val == val2 or val != val3:
#            print "\t FAILED !!!!"
#        else:
#            print "\t PASS"
        
########NEW FILE########
__FILENAME__ = util
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# --------------------------------------------------------------------------
#
# CHANGELOG :
# 1.1 - 2010/11/03 - Courgette
#    * add __repr__
#    * fix minor bug in BanlistContent
#    * add automated tests

"""\
This module provides different utilities specific to the Frostbite engine
"""
 
__author__  = 'Courgette'
__version__ = '1.1'



class BanlistContent:
    """
    help extract banlist info from a frostbite banList.list response
    
    usage :
        words = [2, 
            'name', 'Courgette', 'perm', , 'test',  
            'name', 'Courgette', 'seconds', 3600 , 'test2'] 
        bansInfo = BanlistContent(words)
        print "num of bans : %s" % len(bansInfo)
        print "first ban : %s" % bansInfo[0]
        print "second ban : %s" % bansInfo[1]
        print "the first 2 bans : %s" % bansInfo[0:2]
        for b in bansInfo:
            print b
    """
    numOfBans = None
    bansData = []
    
    def __init__(self, data):
        """Represent a frostbite banList.list response
        Request: banList.list 
        Response: OK <player ban entries> 
        Response: InvalidArguments 
        Effect: Return list of banned players/IPs/GUIDs. 
        Comment: The list starts with a number telling how many bans the list is holding. 
                 After that, 5 words (Id-type, id, ban-type, time and reason) are received for every ban in the list.
        """
        self.numOfBans = data[0]
        self.bansData = data[1:]
    
    def __len__(self):
        return int(self.numOfBans)
    
    def __getitem__(self, key):
        """Returns the ban data, for provided key (int or slice)"""
        if isinstance(key, slice):
            indices = key.indices(len(self))
            return [self.getData(i) for i in range(*indices) ]
        else:
            return self.getData(key)

    def getData(self, index):
        if index >= self.numOfBans:
            raise IndexError
        tmp = self.bansData[index*5:(index+1)*5]
        return {
            'idType': tmp[0], # name | ip | guid
            'id': tmp[1],
            'banType': tmp[2], # perm | round | seconds
            'time': tmp[3],
            'reason': tmp[4], # 80 chars max
        }

    def __repr__(self):
        txt = "BanlistContent["
        for p in self:
            txt += "%r" % p
        txt += "]"
        return txt        
        
        
        
class PlayerInfoBlock:
    """
    help extract player info from a frostbite Player Info Block which we obtain
    from admin.listPlayers
    
    usage :
        words = [3, 'name', 'guid', 'ping', 2, 
            'Courgette', 'A32132e', 130, 
            'SpacepiG', '6546545665465', 120,
            'Bakes', '6ae54ae54ae5', 50]
        playersInfo = PlayerInfoBlock(words)
        print "num of players : %s" % len(playersInfo)
        print "first player : %s" % playersInfo[0]
        print "second player : %s" % playersInfo[1]
        print "the first 2 players : %s" % playersInfo[0:2]
        for p in playersInfo:
            print p
    """
    playersData = []
    numOfParameters= 0
    numOfPlayers = 0
    parameterTypes = []
    
    def __init__(self, data):
        """Represent a frostbite Player info block
        The standard set of info for a group of players contains a lot of different 
        fields. To reduce the risk of having to do backwards-incompatible changes to
        the protocol, the player info block includes some formatting information.
            
        <number of parameters>       - number of parameters for each player 
        N x <parameter type: string> - the parameter types that will be sent below 
        <number of players>          - number of players following 
        M x N x <parameter value>    - all parameter values for player 0, then all 
                                    parameter values for player 1, etc
                                    
        Current parameters:
          name     string     - player name 
          guid     GUID       - player GUID, or '' if GUID is not yet known 
          teamId   Team ID    - player's current team 
          squadId  Squad ID   - player's current squad 
          kills    integer    - number of kills, as shown in the in-game scoreboard
          deaths   integer    - number of deaths, as shown in the in-game scoreboard
          score    integer    - score, as shown in the in-game scoreboard 
          ping     integer    - ping (ms), as shown in the in-game scoreboard
        """
        self.numOfParameters = int(data[0])
        self.parameterTypes = data[1:1+self.numOfParameters]
        self.numOfPlayers = int(data[1+self.numOfParameters])
        self.playersData = data[1+self.numOfParameters+1:]
    
    def __len__(self):
        return self.numOfPlayers
    
    def __getitem__(self, key):
        """Returns the player data, for provided key (int or slice)"""
        if isinstance(key, slice):
            indices = key.indices(len(self))
            return [self.getPlayerData(i) for i in range(*indices) ]
        else:
            return self.getPlayerData(key)

    def getPlayerData(self, index):
        if index >= self.numOfPlayers:
            raise IndexError
        data = {}
        playerData = self.playersData[index*self.numOfParameters:(index+1)*self.numOfParameters]
        for i in range(self.numOfParameters):
            data[self.parameterTypes[i]] = playerData[i]
        return data 

    def __repr__(self):
        txt = "PlayerInfoBlock["
        for p in self:
            txt += "%r" % p
        txt += "]"
        return txt
    

########NEW FILE########
__FILENAME__ = abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas LEVEIL
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 1.0
#  update parser for BF3 R20
# 1.1
#  add event EVT_GAMESERVER_CONNECT which is triggered every time B3 connects to the game server
# 1.1.1
#  fix and refactor admin.yell
# 1.2
#  introduce new setting 'big_b3_private_responses'
# 1.3
#  introduce new setting 'big_msg_duration'
#  refactor the code that reads the config file
# 1.4
#  commands can now start with just the '/' character if the user wants to hide the command from other players instead
#  of having to type '/!'
# 1.4.1
#  add a space between the bot name and the message in saybig()
# 1.4.2
#  fixes bug regarding round count on round change events
# 1.4.3 - 1.4.5
#  improves handling of commands prefixed only with '/' instead of usual command prefixes. Leading '/' is removed if
#  followed by an existing command name or if followed by a command prefix.
# 1.5
#  parser can now create EVT_CLIENT_TEAM_SAY events (requires BF3 server R21)
# 1.5.1
#  fixes issue with BF3 failing to provide EA_GUID https://github.com/courgette/big-brother-bot/issues/69
# 1.5.2
#  fixes issue that made B3 fail to ban/tempban a client with empty guid
# 1.6
#  replace admin plugin !map command with a Frostbite2 specific implementation. Now can call !map <map>, <gamemode>
#  refactor getMapsSoundingLike
#  add getGamemodeSoundingLike
# 1.7
#  replace admin plugin !map command with a Frostbite2 specific implementation. Now can call !map <map>[, <gamemode>[, <num of rounds>]]
#  when returning map info, provide : map name (gamemode) # rounds
# 1.8
#  isolate the patching code in a module function
# 1.8.1
#  improve punkbuster event parsing
#

__author__  = 'Courgette'
__version__ = '1.8.1'


import sys, re, traceback, time, string, Queue, threading, new
import b3.parser
from b3.parsers.frostbite2.rcon import Rcon as FrostbiteRcon
from b3.parsers.frostbite2.protocol import FrostbiteServer, CommandFailedError, CommandError, NetworkError
from b3.parsers.frostbite2.util import PlayerInfoBlock, MapListBlock, BanlistContent
import b3.events
import b3.cvar
from b3.functions import getStuffSoundingLike


# how long should the bot try to connect to the Frostbite server before giving out (in second)
GAMESERVER_CONNECTION_WAIT_TIMEOUT = 600

class AbstractParser(b3.parser.Parser):
    """
    An abstract base class to help with developing frostbite2 parsers
    """

    gameName = None
    privateMsg = True

    # hard limit for rcon command admin.say
    SAY_LINE_MAX_LENGTH = 128

    OutputClass = FrostbiteRcon
    _serverConnection = None
    _nbConsecutiveConnFailure = 0

    frostbite_event_queue = Queue.Queue(400)
    sayqueue = Queue.Queue(100)
    sayqueue_get_timeout = 2
    sayqueuelistener = None

    # frostbite2 engine does not support color code, so we need this property
    # in order to get stripColors working
    _reColor = re.compile(r'(\^[0-9])')

    _settings = {
        'line_length': 128,
        'min_wrap_length': 128,
        'message_delay': .8,
        'big_msg_duration': 4,
        'big_b3_private_responses': False,
        }

    _gameServerVars = () # list available cvar

    _commands = {
        'message': ('admin.say', '%(message)s', 'player', '%(cid)s'),
        'saySquad': ('admin.say', '%(message)s', 'squad', '%(teamId)s', '%(squadId)s'),
        'sayTeam': ('admin.say', '%(message)s', 'team', '%(teamId)s'),
        'say': ('admin.say', '%(message)s', 'all'),
        'bigmessage': ('admin.yell', '%(message)s', '%(big_msg_duration)i', 'player', '%(cid)s'),
        'yellSquad': ('admin.yell', '%(message)s', '%(big_msg_duration)i', 'squad', '%(teamId)s', '%(squadId)s'),
        'yellTeam': ('admin.yell', '%(message)s', '%(big_msg_duration)i', 'team', '%(teamId)s'),
        'yell': ('admin.yell', '%(message)s', '%(big_msg_duration)i'),
        'kick': ('admin.kickPlayer', '%(cid)s', '%(reason)s'),
        'ban': ('banList.add', 'guid', '%(guid)s', 'perm', '%(reason)s'),
        'banByName': ('banList.add', 'name', '%(name)s', 'perm', '%(reason)s'),
        'banByIp': ('banList.add', 'ip', '%(ip)s', 'perm', '%(reason)s'),
        'unban': ('banList.remove', 'guid', '%(guid)s'),
        'unbanByIp': ('banList.remove', 'ip', '%(ip)s'),
        'tempban': ('banList.add', 'guid', '%(guid)s', 'seconds', '%(duration)d', '%(reason)s'),
        'tempbanByName': ('banList.add', 'name', '%(name)s', 'seconds', '%(duration)d', '%(reason)s'),
        }

    _eventMap = {
    }

    _punkbusterMessageFormats = (
        (re.compile(r'^.*: PunkBuster Server for .+ \((?P<version>.+)\)\sEnabl.*$'), 'OnPBVersion'),
        (re.compile(r'^.*: Running PB Scheduled Task \(slot #(?P<slot>\d+)\)\s+(?P<task>.*)$'), 'OnPBScheduledTask'),
        (re.compile(r'^.*: Lost Connection \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+) (?P<pbuid>[^\s]+)\(-\)\s(?P<name>.+)$'), 'OnPBLostConnection'),
        (re.compile(r'^.*: Master Query Sent to \((?P<pbmaster>[^\s]+)\) (?P<ip>[^:]+)$'), 'OnPBMasterQuerySent'),
        (re.compile(r'^.*: Player GUID Computed (?P<pbid>[0-9a-fA-F]+)\(-\) \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+)\s(?P<name>.+)$'), 'OnPBPlayerGuid'),
        (re.compile(r'^.*: New Connection \(slot #(?P<slot>\d+)\) (?P<ip>[^:]+):(?P<port>\d+) \[(?P<something>[^\s]+)\]\s"(?P<name>.+)".*$'), 'OnPBNewConnection'),
        (re.compile(r'^.*:\s+(?P<index>\d+)\s+(?P<pbid>[0-9a-fA-F]+) {(?P<min_elapsed>\d+)/(?P<duration>\d+)}\s+"(?P<name>[^"]+)"\s+"(?P<ip>[^:]+):(?P<port>\d+)"\s+"?(?P<reason>.*)"\s+"(?P<private_reason>.*)"$'), None), # banlist item
        (re.compile(r'^.*: Guid=(?P<search>.*) Not Found in the Ban List$'), None),
        (re.compile(r'^.*: End of Ban List \(\d+ of \d+ displayed\)$'), None),
        (re.compile(r'^.*: Guid (?P<pbid>[0-9a-fA-F]+) has been Unbanned$'), None),
        (re.compile(r'^.*: PB UCON "(?P<from>.+)"@(?P<ip>[\d.]+):(?P<port>\d+) \[(?P<cmd>.*)\]$'), 'OnPBUCON'),
        (re.compile(r'^.*: Player List: \[Slot #\] \[GUID\] \[Address\] \[Status\] \[Power\] \[Auth Rate\] \[Recent SS\] \[O/S\] \[Name\]$'), None),
        (re.compile(r'^.*: (?P<slot>\d+)\s+(?P<pbid>[0-9a-fA-F]+)\(-\) (?P<ip>[^:]+):(?P<port>\d+) (?P<status>.+)\s+(?P<power>\d+)\s+(?P<authrate>\d+\.\d+)\s+(?P<recentSS>\d+)\s+\((?P<os>.+)\)\s+"(?P<name>.+)".*$'), 'OnPBPlistItem'),
        (re.compile(r'^.*: End of Player List \(\d+ Players\)$'), None),
        (re.compile(r'^.*: Invalid Player Specified: (?P<data>.*)$'), None),
        (re.compile(r'^.*: Received Download File: (?P<file>.*)$'), None),
        (re.compile(r'^.*: Matched: (?P<name>.*) \(slot #(?P<slot>\d+)\)$'), None),
        (re.compile(r'^.*: (?P<num>\d+) Ban Records Updated in (?P<filename>.*)$'), None),
        (re.compile(r'^.*: Ban Added to Ban List$'), None),
        (re.compile(r'^.*: Ban Failed$'), None),
        (re.compile(r'^.*: Received Master Security Information$'), None),
        (re.compile(r'^.*: Auto Screenshot\s+(?P<ssid>\d+)\s+Requested from (?P<slot>\d+) (?P<name>.+)$'), None),
        (re.compile(r'^.*: Screenshot (?P<imgpath>.+)\s+successfully received \(MD5=(?P<md5>[0-9A-F]+)\) from (?P<slot>\d+) (?P<name>.+) \[(?P<pbid>[0-9a-fA-F]+)\(-\) (?P<ip>[^:]+):(?P<port>\d+)\]$'), 'OnPBScreenshotReceived'),
    )

    # if Punkbuster is set, then it will be used to kick/ban/unban
    PunkBuster = None
    # if ban_with_server is True, then the Frostbite server will be used for ban
    ban_with_server = True

    # flag to find out if we need to fire a EVT_GAME_ROUND_START event.
    _waiting_for_round_start = True


    def __new__(cls, *args, **kwargs):
        AbstractParser.patch_b3_Clients_getByMagic()
        patch_b3_clients()
        return b3.parser.Parser.__new__(cls)

    @staticmethod
    def patch_b3_Clients_getByMagic():
        """
        The b3.clients.Client.getByMagic method does not behave as intended for Frostbive server when id is a string
        composed of digits exclusively. In such case it behave as if id was a slot number as for Quake3 servers.
        This method patches the self.clients object so that it getByMagic method behaves as expected for Frostbite servers.
        """
        def new_clients_getByMagic(self, id):
            id = id.strip()

            if re.match(r'^@([0-9]+)$', id):
                return self.getByDB(id)
            elif id[:1] == '\\':
                c = self.getByName(id[1:])
                if c and not c.hide:
                    return [c]
                else:
                    return []
            else:
                return self.getClientsByName(id)
        b3.clients.Clients.getByMagic = new_clients_getByMagic


    def patch_b3_admin_plugin(self):
        """
        Monkey patches the admin plugin
        """

        def parse_map_parameters(self, data, client):
            """
            Method that parses a command parameters of extract map, gamemode and number of rounds.
            Expecting one, two or three parameters separated by a comma.
            <map> [, gamemode [, num of rounds]]
            """
            gamemode_data = num_rounds = None

            if ',' in data:
                parts = [x.strip() for x in data.split(',')]
                if len(parts) > 3:
                    client.message("Invalid parameters. At max 3 parameters are expected")
                    return
                elif len(parts) == 3:
                    gamemode_data = parts[1]
                    num_rounds = parts[2]
                elif len(parts) == 2:
                    if re.match('\d+', parts[1]):
                        # 2nd param is the number of rounds
                        num_rounds = parts[1]
                    else:
                        gamemode_data = parts[1]
                map_data = parts[0]
            else:
                map_data = data.strip()

            if gamemode_data is None:
                gamemode_data = self.console.game.gameType

            if num_rounds is None:
                # get the number of round from the current map
                try:
                    num_rounds = int(self.console.game.serverinfo['roundsTotal'])
                except Exception, err:
                    self.warning("could not get current number of rounds", exc_info=err)
                    client.message("please specify the number of rounds you want")
                    return
            else:
                # validate given number of rounds
                try:
                    num_rounds = int(num_rounds)
                except Exception, err:
                    self.warning("could not read the number of rounds of '%s'" % num_rounds, exc_info=err)
                    client.message("could not read the number of rounds of '%s'" % num_rounds)
                    return

            map_id = self.console.getMapIdByName(map_data)
            if type(map_id) is list:
                client.message('do you mean : %s ?' % ', '.join(map_id))
                return

            gamemode_id = self.console.getGamemodeSoundingLike(map_id, gamemode_data)
            if type(gamemode_id) is list:
                client.message('do you mean : %s ?' % ', '.join(gamemode_id))
                return

            return map_id, gamemode_id, num_rounds


        """
        Monkey path the cmd_map method of the loaded AdminPlugin instance to accept optional 2nd and 3rd parameters
        which are the game mode and number of rounds
        """
        def new_cmd_map(self, data, client, cmd=None):
            """\
            <map> [, gamemode [, num of rounds]] - switch current map. Optionally specify a gamemode and # of rounds by separating them from the map name with a commas
            """
            if not data:
                client.message('Invalid parameters, type !help map')
                return

            parsed_data = self.parse_map_parameters(data, client)
            if not parsed_data:
                return

            map_id, gamemode_id, num_rounds = parsed_data
            try:
                suggestions = self.console.changeMap(map_id, gamemode_id=gamemode_id, number_of_rounds=num_rounds)
            except CommandFailedError, err:
                if err.message == ['InvalidGameModeOnMap']:
                    client.message("%s cannot be played with gamemode %s" % self.console.getEasyName(map_id), self.console.getGameMode(gamemode_id))
                    client.message("supported gamemodes are : " + ', '.join([self.console.getGameMode(mode_id) for mode_id in self.console.getSupportedGameModesByMapId(map_id)]))
                    return
                elif err.message == ['InvalidRoundsPerMap']:
                    client.message("number of rounds must be 1 or greater")
                    return
                elif err.message == ['Full']:
                    client.message("Map list maximum size has been reached")
                    return
                else:
                    raise
            else:
                if type(suggestions) == list:
                    client.message('do you mean : %s ?' % ', '.join(map_id))
                    return

        adminPlugin = self.getPlugin('admin')

        adminPlugin.parse_map_parameters = new.instancemethod(parse_map_parameters, adminPlugin)

        cmd = adminPlugin._commands['map']
        cmd.func = new.instancemethod(new_cmd_map, adminPlugin)
        cmd.help = new_cmd_map.__doc__.strip()



    def run(self):
        """Main worker thread for B3"""
        self.bot('Start listening ...')
        self.screen.write('Startup Complete : B3 is running! Let\'s get to work!\n\n')
        self.screen.write('(If you run into problems, check %s for detailed log info)\n' % self.config.getpath('b3', 'logfile'))
        #self.screen.flush()

        self.updateDocumentation()

        ## the block below can activate additional logging for the FrostbiteServer class
#        import logging
#        frostbiteServerLogger = logging.getLogger("FrostbiteServer")
#        for handler in logging.getLogger('output').handlers:
#            frostbiteServerLogger.addHandler(handler)
#        frostbiteServerLogger.setLevel(logging.getLogger('output').level)

        while self.working:
            if not self._serverConnection or not self._serverConnection.connected:
                try:
                    self.setup_frostbite_connection()
                except CommandError, err:
                    if err.message[0] == 'InvalidPasswordHash':
                        self.error("your rcon password is incorrect. Check setting 'rcon_password' in your main config file.")
                        self.exitcode = 220
                        break
                    else:
                        self.error(err.message)
                except IOError, err:
                    self.error("IOError %s"% err)
                except Exception, err:
                    self.error(err)
                    self.exitcode = 220
                    break

            try:
                added, expire, packet = self.frostbite_event_queue.get(timeout=5)
                self.routeFrostbitePacket(packet)
            except Queue.Empty:
                self.verbose2("no game server event to treat in the last 5s")
            except CommandError, err:
                # it does not matter from the parser perspective if Frostbite command failed
                # (timeout or bad reply)
                self.warning(err)
            except NetworkError, e:
                # the connection to the frostbite server is lost
                self.warning(e)
                self.close_frostbite_connection()
            except Exception, e:
                self.error("unexpected error, please report this on the B3 forums")
                self.error(e)
                self.error('%s: %s', e, traceback.extract_tb(sys.exc_info()[2]))
                # unexpected exception, better close the frostbite connection
                self.close_frostbite_connection()


        self.info("Stop listening for Frostbite2 events")
        # exiting B3
        with self.exiting:
            # If !die or !restart was called, then  we have the lock only after parser.handleevent Thread releases it
            # and set self.working = False and this is one way to get this code is executed.
            # Else there was an unhandled exception above and we end up here. We get the lock instantly.

            self.output.frostbite_server = None

            # The Frostbite connection is running its own thread to communicate with the game server. We need to tell
            # this thread to stop.
            self.close_frostbite_connection()

            # wait for threads to finish
            self.wait_for_threads()

            # If !die was called, exitcode have been set to 222
            # If !restart was called, exitcode have been set to 221
            # In both cases, the SystemExit exception that triggered exitcode to be filled with an exit value was
            # caught. Now that we are sure that everything was gracefully stopped, we can re-raise the SystemExit
            # exception.
            if self.exitcode:
                sys.exit(self.exitcode)

    def setup_frostbite_connection(self):
        self.info('Connecting to frostbite2 server ...')
        if self._serverConnection:
            self.close_frostbite_connection()
        self._serverConnection = FrostbiteServer(self._rconIp, self._rconPort, self._rconPassword)

        timeout = GAMESERVER_CONNECTION_WAIT_TIMEOUT + time.time()
        while time.time() < timeout and not self._serverConnection.connected:
            self.info("retrying to connect to game server...")
            time.sleep(2)
            self.close_frostbite_connection()
            self._serverConnection = FrostbiteServer(self._rconIp, self._rconPort, self._rconPassword)

        if self._serverConnection is None or not self._serverConnection.connected:
            self.error("Could not connect to Frostbite2 server")
            self.close_frostbite_connection()
            self.shutdown()
            raise SystemExit()

        # listen for incoming game server events
        self._serverConnection.subscribe(self.OnFrosbiteEvent)

        self._serverConnection.auth()
        self._serverConnection.command('admin.eventsEnabled', 'true')

        # setup Rcon
        self.output.set_frostbite_server(self._serverConnection)

        self.queueEvent(b3.events.Event(b3.events.EVT_GAMESERVER_CONNECT, None))

        self.checkVersion()
        self.say('%s ^2[ONLINE]' % b3.version)
        self.getServerInfo()
        self.getServerVars()
        self.clients.sync()

        # checkout punkbuster support
        try:
            result = self._serverConnection.command('punkBuster.isActive')
        except CommandError, e:
            self.error("could not get punkbuster status : %r" % e)
            self.PunkBuster = None
            self.ban_with_server = True
        else:
            if result and result[0] == 'true':
                self.write(('punkBuster.pb_sv_command', 'pb_sv_plist')) # will make punkbuster send IP address of currently connected players
            elif not self.ban_with_server:
                self.ban_with_server = True
                self.warning("Forcing ban agent to 'server' as we failed to verify that punkbuster is active on the server")

    def close_frostbite_connection(self):
        try:
            self._serverConnection.stop()
        except Exception:
            pass
        self._serverConnection = None

    def OnFrosbiteEvent(self, packet):
        if not self.working:
            self.verbose("dropping Frostbite event %r" % packet)
        self.console(repr(packet))
        try:
            self.frostbite_event_queue.put((self.time(), self.time() + 10, packet), timeout=2)
        except Queue.Full:
            self.error("Frostbite event queue full, dropping event %r" % packet)

    def routeFrostbitePacket(self, packet):
        if packet is None:
            self.warning('cannot route empty packet : %s' % traceback.extract_tb(sys.exc_info()[2]))
        eventType = packet[0]
        eventData = packet[1:]
        
        match = re.search(r"^(?P<actor>[^.]+)\.(on)?(?P<event>.+)$", eventType)
        func = None
        if match:
            func = 'On%s%s' % (string.capitalize(match.group('actor')), \
                               string.capitalize(match.group('event')))
            self.verbose2("looking for event handling method called : " + func)
            
        if match and hasattr(self, func):
            #self.verbose2('routing ----> %s(%r)' % (func,eventData))
            func = getattr(self, func)
            event = func(eventType, eventData)
            #self.debug('event : %s' % event)
            if event:
                self.queueEvent(event)
            
        elif eventType in self._eventMap:
            self.queueEvent(b3.events.Event(
                    self._eventMap[eventType],
                    eventData))
        else:
            data = ''
            if func:
                data = func + ' '
            data += str(eventType) + ': ' + str(eventData)
            self.warning('TODO : handle \'%r\' frostbite2 events' % packet)
            self.queueEvent(b3.events.Event(b3.events.EVT_UNKNOWN, data))


    def startup(self):
       
        # add specific events
        self.Events.createEvent('EVT_GAMESERVER_CONNECT', 'connected to game server')
        self.Events.createEvent('EVT_CLIENT_SQUAD_CHANGE', 'Client Squad Change')
        self.Events.createEvent('EVT_CLIENT_SPAWN', 'Client Spawn')
        self.Events.createEvent('EVT_GAME_ROUND_PLAYER_SCORES', 'round player scores')
        self.Events.createEvent('EVT_GAME_ROUND_TEAM_SCORES', 'round team scores')
        self.Events.createEvent('EVT_PUNKBUSTER_UNKNOWN', 'PunkBuster unknown')
        self.Events.createEvent('EVT_PUNKBUSTER_MISC', 'PunkBuster misc')
        self.Events.createEvent('EVT_PUNKBUSTER_SCHEDULED_TASK', 'PunkBuster scheduled task')
        self.Events.createEvent('EVT_PUNKBUSTER_LOST_PLAYER', 'PunkBuster client connection lost')
        self.Events.createEvent('EVT_PUNKBUSTER_NEW_CONNECTION', 'PunkBuster client received IP')
        self.Events.createEvent('EVT_PUNKBUSTER_UCON', 'PunkBuster UCON')
        self.Events.createEvent('EVT_PUNKBUSTER_SCREENSHOT_RECEIVED', 'PunkBuster Screenshot received')

        self.load_conf_max_say_line_length()
        self.load_config_message_delay()
        self.load_conf_ban_agent()
        self.load_conf_big_b3_private_responses()
        self.load_conf_big_msg_duration()

        self.start_sayqueue_worker()

        # start crontab to trigger playerlist events
        self.cron + b3.cron.CronTab(self.clients.sync, minute='*/5')


    def pluginsStarted(self):
        self.patch_b3_admin_plugin()

    def sayqueuelistener_worker(self):
        self.info("sayqueuelistener job started")
        while self.working:
            try:
                msg = self.sayqueue.get(timeout=self.sayqueue_get_timeout)
                for line in self.getWrap(self.stripColors(self.msgPrefix + ' ' + msg), self._settings['line_length'], self._settings['min_wrap_length']):
                    self.write(self.getCommand('say', message=line))
                    if self.working:
                        time.sleep(self._settings['message_delay'])
                self.sayqueue.task_done()
            except Queue.Empty:
                #self.verbose2("sayqueuelistener: had nothing to do in the last %s sec" % self.sayqueue_get_timeout)
                pass
            except Exception, err:
                self.error(err)
        self.info("sayqueuelistener job ended")

    def start_sayqueue_worker(self):
        self.sayqueuelistener = threading.Thread(target=self.sayqueuelistener_worker, name="sayqueuelistener")
        self.sayqueuelistener.setDaemon(True)
        self.sayqueuelistener.start()

    def wait_for_threads(self):
        if hasattr(self, 'sayqueuelistener') and self.sayqueuelistener:
            self.sayqueuelistener.join()

    def getCommand(self, cmd, **kwargs):
        """Return a reference to a loaded command"""
        try:
            cmd = self._commands[cmd]
        except KeyError:
            return None

        preparedcmd = []
        for a in cmd:
            try:
                preparedcmd.append(a % kwargs)
            except KeyError:
                pass
        
        result = tuple(preparedcmd)
        self.debug('getCommand: %s', result)
        return result
    
    def write(self, msg, maxRetries=1, needConfirmation=False):
        """Write a message to Rcon/Console
        Unfortunaltely this has been abused all over B3 
        and B3 plugins to broadcast text :(
        """
        if type(msg) == str:
            # console abuse to broadcast text
            self.say(msg)
        else:
            # Then we got a command
            if self.replay:
                self.bot('Sent rcon message: %s' % msg)
            elif self.output is None:
                pass
            else:
                res = self.output.write(msg, maxRetries=maxRetries, needConfirmation=needConfirmation)
                self.output.flush()
                return res
            
    def getWrap(self, text, length=None, minWrapLen=None):
        """Returns a sequence of lines for text that fits within the limits
        """
        if not text:
            return []

        if length is None:
            length = self._settings['line_length']

        maxLength = int(length)
        
        if len(text) <= maxLength:
            return [text]
        else:
            wrappoint = text[:maxLength].rfind(" ")
            if wrappoint == 0:
                wrappoint = maxLength
            lines = [text[:wrappoint]]
            remaining = text[wrappoint:]
            while len(remaining) > 0:
                if len(remaining) <= maxLength:
                    lines.append(remaining)
                    remaining = ""
                else:
                    wrappoint = remaining[:maxLength].rfind(" ")
                    if wrappoint == 0:
                        wrappoint = maxLength
                    lines.append(remaining[0:wrappoint])
                    remaining = remaining[wrappoint:]
            return lines

    
    ###############################################################################################
    #
    #    Frostbite2 events handlers
    #    
    ###############################################################################################

    
    def OnPlayerChat(self, action, data):
        """
        player.onChat <source soldier name: string> <text: string> <target players: player subset>
        
        Effect: Player with name <source soldier name> (or the server, or the 
            server admin) has sent chat message <text> to <target players>
        
        Comment: If <source soldier name> is "Server", then the message was sent 
            from the server rather than from an actual player
        """
        client = self.getClient(data[0])
        if client is None:
            self.warning("Could not get client :( %s" % traceback.extract_tb(sys.exc_info()[2]))
            return
        if client.cid == 'Server':
            # ignore chat events for Server
            return
        text = data[1]

        # existing commands can be prefixed with a '/' instead of usual prefixes
        cmdPrefix = '!'
        cmd_prefixes = (cmdPrefix, '@', '&')
        admin_plugin = self.getPlugin('admin')
        if admin_plugin:
            cmdPrefix = admin_plugin.cmdPrefix
            cmd_prefixes = (cmdPrefix, admin_plugin.cmdPrefixLoud, admin_plugin.cmdPrefixBig)
        cmd_name = text[1:].split(' ', 1)[0].lower()
        if len(text) >= 2 and text[0] == '/':
            if text[1] in cmd_prefixes:
                text = text[1:]
            elif cmd_name in admin_plugin._commands:
                text = cmdPrefix + text[1:]

        if data[2] in ('team', 'squad'):
            event_type = b3.events.EVT_CLIENT_TEAM_SAY
        else:
            event_type = b3.events.EVT_CLIENT_SAY
        return b3.events.Event(event_type, text, client)
        

    def OnPlayerLeave(self, action, data):
        #player.onLeave: ['GunnDawg']
        client = self.getClient(data[0])
        if client: 
            client.endMessageThreads = True
            client.disconnect() # this triggers the EVT_CLIENT_DISCONNECT event
        return None

    def OnPlayerJoin(self, action, data):
        """
        player.onJoin <soldier name: string> <id : EAID>
        """
        # we receive this event very early and even before the game client starts to connect to the game server.
        # In some occasions, the game client fails to properly connect and the game server then fails to send
        # us a player.onLeave event resulting in B3 thinking the player is connected while it is not.
        # The fix is to ignore this event. If the game client successfully connect, then we'll receive other
        # events like player.onTeamChange or even a event from punkbuster which will create the Client object.
        pass

    def OnPlayerAuthenticated(self, action, data):
        """
        player.authenticated <soldier name: string> <EA_GUID: string>
        
        Effect: Player with name <soldier name> has been authenticated
        """
        try:
            _guid = data[1]
        except IndexError:
            _guid = None
        self.getClient(data[0], guid=_guid)


    def OnPlayerSpawn(self, action, data):
        """
        Request: player.onSpawn <spawning soldier name: string> <team: int>
        """
        if len(data) < 2:
            return None
        spawner = self.getClient(data[0])
        spawner.team = self.getTeam(data[1])

        self._OnServerLevelstarted(action=None, data=None)

        return b3.events.Event(b3.events.EVT_CLIENT_SPAWN, (), spawner)


    def OnPlayerKill(self, action, data):
        """
        Request: player.onKill <killing soldier name: string> 
            <killed soldier name: string> <weapon: string> <headshot: boolean>

        Effect: Player with name <killing soldier name> has killed 
            <killed soldier name> Suicide indication is unknown at this moment. 
            If the server kills the player (through admin.killPlayer), the result is unknown. 
        """
        # example suicide : ['Cucurbitaceae', 'Cucurbitaceae', 'M67', 'false']
        # example killed by fire : ['', 'Cucurbitaceae', 'DamageArea', 'false']
        if data[0] == '':
            data[0] = 'Server'
        attacker = self.getClient(data[0])
        if not attacker:
            self.debug('No attacker')
            return None

        victim = self.getClient(data[1])
        if not victim:
            self.debug('No victim')
            return None
        
        weapon = data[2]

        if data[3] == 'true':
            hitloc = 'head'
        else:
            hitloc = 'torso'

        event = b3.events.EVT_CLIENT_KILL
        if victim == attacker:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team == victim.team and attacker.team != b3.TEAM_UNKNOWN and attacker.team != b3.TEAM_SPEC:
            event = b3.events.EVT_CLIENT_KILL_TEAM
        return b3.events.Event(event, (100, weapon, hitloc), attacker, victim)


    def OnPlayerKicked(self, action, data):
        """
        Request: player.onKicked <soldier name: string> <reason: string>
        Effect: Player with name <soldier name> has been kicked
        """
        if len(data) < 2:
            return None
        client = self.getClient(data[0])
        reason = data[1]
        return b3.events.Event(b3.events.EVT_CLIENT_KICK, data=reason, client=client)


    def OnServerLevelloaded(self, action, data):
        """
        server.onLevelLoaded <level name: string> <gamemode: string> <roundsPlayed: int> <roundsTotal: int>

        Effect: Level has completed loading, and will start in a bit

        example: ['server.onLevelLoaded', 'MP_001', 'ConquestLarge0', '1', '2']
        """
        self.debug("OnServerLevelLoaded: %s" % data)
        if not self.game.mapName:
            self.game.mapName = data[0]
        if self.game.mapName != data[0]:
            # map change detected
            self.game.startMap()
        self.game.mapName = data[0]
        self.game.gameType = data[1]
        self.game.rounds = int(data[2]) + 1 # round index starts at 0
        self.game.g_maxrounds = int(data[3])
        self.getServerInfo()
        # to debug getEasyName()
        self.info('Loading %s [%s]'  % (self.getEasyName(self.game.mapName), self.game.gameType))
        self._waiting_for_round_start = True

        return b3.events.Event(b3.events.EVT_GAME_WARMUP, data[0])

    def _OnServerLevelstarted(self, action, data):
        """
        Event server.onLevelStarted was used to be sent in Frostbite1. Unfortunately it does not exists anymore
        in Frostbite2.
        Instead we call this method from OnPlayerSpawn and maintain a flag which tells if we need to fire the
        EVT_GAME_ROUND_START event
        """
        if self._waiting_for_round_start:
            self._waiting_for_round_start = False

            # as the game server provides us the exact round number in OnServerLoadinglevel()
            # hence we need to deduct one to compensate?
            # we'll still leave the call here since it provides us self.game.roundTime()
            # next function call will increase roundcount by one, this is not wanted
            correct_rounds_value = self.game.rounds
            self.game.startRound()
            self.game.rounds = correct_rounds_value
            self.queueEvent(b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game))

        
    def OnServerRoundover(self, action, data):
        """
        server.onRoundOver <winning team: Team ID>
        
        Effect: The round has just ended, and <winning team> won
        """
        #['server.onRoundOver', '2']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_END, data[0])
        
        
    def OnServerRoundoverplayers(self, action, data):
        """
        server.onRoundOverPlayers <end-of-round soldier info : player info block>
        
        Effect: The round has just ended, and <end-of-round soldier info> is the final detailed player stats
        """
        #['server.onRoundOverPlayers', '8', 'clanTag', 'name', 'guid', 'teamId', 'kills', 'deaths', 'score', 'ping', '17', 'RAID', 'mavzee', 'EA_4444444444444444555555555555C023', '2', '20', '17', '310', '147', 'RAID', 'NUeeE', 'EA_1111111111111555555555555554245A', '2', '30', '18', '445', '146', '', 'Strzaerl', 'EA_88888888888888888888888888869F30', '1', '12', '7', '180', '115', '10tr', 'russsssssssker', 'EA_E123456789461416564796848C26D0CD', '2', '12', '12', '210', '141', '', 'Daezch', 'EA_54567891356479846516496842E17F4D', '1', '25', '14', '1035', '129', '', 'Oldqsdnlesss', 'EA_B78945613465798645134659F3079E5A', '1', '8', '12', '120', '256', '', 'TTETqdfs', 'EA_1321654656546544645798641BB6D563', '1', '11', '16', '180', '209', '', 'bozer', 'EA_E3987979878946546546565465464144', '1', '22', '14', '475', '152', '', 'Asdf 1977', 'EA_C65465413213216656546546546029D6', '2', '13', '16', '180', '212', '', 'adfdasse', 'EA_4F313565464654646446446644664572', '1', '4', '25', '45', '162', 'SG1', 'De56546ess', 'EA_123132165465465465464654C2FC2FBB', '2', '5', '8', '75', '159', 'bsG', 'N06540RZ', 'EA_787897944546565656546546446C9467', '2', '8', '14', '100', '115', '', 'Psfds', 'EA_25654321321321000006546464654B81', '2', '15', '15', '245', '140', '', 'Chezear', 'EA_1FD89876543216548796130EB83E411F', '1', '9', '14', '160', '185', '', 'IxSqsdfOKxI', 'EA_481321313132131313213212313112CE', '1', '21', '12', '625', '236', '', 'Ledfg07', 'EA_1D578987994651615166516516136450', '1', '5', '6', '85', '146', '', '5 56 mm', 'EA_90488E6543216549876543216549877B', '2', '0', '0', '0', '192']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_PLAYER_SCORES, PlayerInfoBlock(data))
        
        
    def OnServerRoundoverteamscores(self, action, data):
        """
        server.onRoundOverTeamScores <end-of-round scores: team scores>
        
        Effect: The round has just ended, and <end-of-round scores> is the final ticket/kill/life count for each team
        """
        #['server.onRoundOverTeamScores', '2', '1180', '1200', '1200']
        return b3.events.Event(b3.events.EVT_GAME_ROUND_TEAM_SCORES, data[1])

    def OnPunkbusterMessage(self, action, data):
        """handles all punkbuster related events and 
        route them to the appropriate method depending
        on the type of PB message.
        
        Request: punkBuster.onMessage <message: string>
        Effect: PunkBuster server has output a message
        Comment: The entire message is sent as a raw string. It may contain newlines and whatnot.
        """
        #self.debug("PB> %s" % data)
        if data and data[0]:
            match = funcName = None
            for regexp, funcName in self._punkbusterMessageFormats:
                match = re.match(regexp, str(data[0]).strip())
                if match:
                    break
            if match:
                if funcName is None:
                    return b3.events.Event(b3.events.EVT_PUNKBUSTER_MISC, match)
                if hasattr(self, funcName):
                    func = getattr(self, funcName)
                    return func(match, data[0])
                else:
                    self.warning("func %s not found, defaulting to EVT_PUNKBUSTER_UNKNOWN" % funcName)
                    return b3.events.Event(b3.events.EVT_PUNKBUSTER_UNKNOWN, data)
            else:
                self.debug("no pattern matching \"%s\", defaulting to EVT_PUNKBUSTER_UNKNOWN" % str(data[0]).strip())
                return b3.events.Event(b3.events.EVT_PUNKBUSTER_UNKNOWN, data)
                
    def OnPBVersion(self, match,data):
        """PB notifies us of the version numbers
        version = match.group('version')"""
        #self.debug('PunkBuster server named: %s' % match.group('servername') )
        #self.debug('PunkBuster Server version: %s' %( match.group('version') ) )
        pass

    def OnPBNewConnection(self, match, data):
        """PunkBuster tells us a new player identified. The player is
        normally already connected and authenticated by B3 by ea_guid
        
        This is our first moment where we receive the clients IP address
        so we also fire the custom event EVT_PUNKBUSTER_NEW_CONNECTION here"""
        name = match.group('name')
        client = self.getClient(name)
        if client:
            #slot = match.group('slot')
            ip = match.group('ip')
            port = match.group('port')
            #something = match.group('something')
            client.ip = ip
            client.port = port
            client.save()
            self.debug('OnPBNewConnection: client updated with %s' % data)
            # This is our first moment where we get a clients IP. Fire this event to accomodate geoIP based plugins like Countryfilter.
            return b3.events.Event(b3.events.EVT_PUNKBUSTER_NEW_CONNECTION, data, client)
        else:
            self.warning('OnPBNewConnection: we\'ve been unable to get the client')

    def OnPBLostConnection(self, match, data):
        """PB notifies us it lost track of a player.
        This event is triggered after the OnPlayerLeave, so normaly the client
        is not connected. Anyway our task here is to raise an event not to
        connect/disconnect the client.
        """
        name = match.group('name')
        dict = {
            'slot': match.group('slot'),
            'ip': match.group('ip'),
            'port': match.group('port'),
            'pbuid': match.group('pbuid'),
            'name': name
        }
        self.verbose('PB lost connection: %s' %dict)
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_LOST_PLAYER, dict)

    def OnPBScheduledTask(self, match, data):
        """We get notified the server ran a PB scheduled task
        Nothing much to do but it can be interresting to have
        this information logged
        """
        slot = match.group('slot')
        task = match.group('task')
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_SCHEDULED_TASK, {'slot': slot, 'task': task})

    def OnPBMasterQuerySent(self, match, data):
        """We get notified that the server sent a ping to the PB masters"""
        #pbmaster = match.group('pbmaster')
        #ip = match.group('ip')
        pass

    def OnPBPlayerGuid(self, match, data):
        """We get notified of a player punkbuster GUID"""
        pbid = match.group('pbid')
        #slot = match.group('slot')
        ip = match.group('ip')
        #port = match.group('port')
        name = match.group('name')
        client = self.getClient(name)
        if client:
            client.ip = ip
            client.pbid = pbid
            if not client.guid:
                # a bug in the BF3 server can make admin.listPlayers response reply with players having an
                # empty string as guid. What we can do here is to try to get the guid from the pbid in the
                # B3 database.
                self.debug("Frostbite2 bug : we have no guid for %s. Trying to find client in B3 storage by pbid" % name)
                try:
                    matching_clients = self.storage.getClientsMatching({'pbid': pbid})
                    if len(matching_clients) == 0:
                        self.debug("no client found by pbid")
                    elif len(matching_clients) > 1:
                        self.debug("too many clients found by pbid")
                    else:
                        client.guid = matching_clients[0].guid
                        client.auth()
                except Exception, err:
                    self.warning("failed to try to auth %s by pbid. %r" % (name, err))
            if not client.guid:
                self.error("Game server failed to provide a EA_guid for player %s. Cannot auth player." % name)
            else:
                client.save()

    def OnPBPlistItem(self, match, data):
        """we received one of the line containing details about one player"""
        self.OnPBPlayerGuid(match, data)

    def OnPBUCON(self, match, data):
        """We get notified of a UCON command
        match groups : from, ip, port, cmd
        """
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_UCON, match.groupdict())

    def OnPBScreenshotReceived(self, match, data):
        """We get notified that a screenshot was successfully received by the server"""
        return b3.events.Event(b3.events.EVT_PUNKBUSTER_SCREENSHOT_RECEIVED, match.groupdict())


    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #    
    ###############################################################################################

    def getPlayerList(self, maxRetries=None):
        """return a dict which keys are cid and values a dict of player properties
        as returned by admin.listPlayers.
        Does not return client objects"""
        data = self.write(('admin.listPlayers', 'all'))
        if not data:
            return {}
        players = {}
        pib = PlayerInfoBlock(data)
        for p in pib:
            players[p['name']] = p
        return players


    def authorizeClients(self):
        players = self.getPlayerList()
        self.verbose('authorizeClients() = %s' % players)

        for cid, p in players.iteritems():
            sp = self.clients.getByCID(cid)
            if sp:
                # Only set provided data, otherwise use the currently set data
                sp.ip   = p.get('ip', sp.ip)
                sp.pbid = p.get('pbid', sp.pbid)
                sp.guid = p.get('guid', sp.guid)
                sp.data = p
                newTeam = p.get('teamId', None)
                if newTeam is not None:
                    sp.team = self.getTeam(newTeam)
                sp.teamId = int(newTeam)
                sp.auth()


    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                mlist[cid] = client
                newTeam = c.get('teamId', None)
                if newTeam is not None:
                    client.team = self.getTeam(newTeam)
                client.teamId = int(newTeam)
        return mlist


    def say(self, msg):
        self.sayqueue.put(msg)

    def saybig(self, msg):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        if msg and len(msg.strip())>0:
            text = self.stripColors(self.msgPrefix + ' ' + msg)
            for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                self.write(self.getCommand('yell', message=line, big_msg_duration=int(float(self._settings['big_msg_duration']))))


    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('kick reason: [%s]' % reason)
        if isinstance(client, str):
            self.write(self.getCommand('kick', cid=client, reason=reason[:80]))
            return
        
        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.PunkBuster:
            self.PunkBuster.kick(client, 0.5, reason)

        self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))

        if not silent and fullreason != '':
            self.say(fullreason)


    def message(self, client, text):
        try:
            if client is None:
                self.say(text)
            elif client.cid is None:
                pass
            else:
                cmd_name = 'bigmessage' if self._settings['big_b3_private_responses'] else 'message'
                self.write(self.getCommand(cmd_name, message=text, cid=client.cid, big_msg_duration=int(float(self._settings['big_msg_duration']))))
        except Exception, err:
            self.warning(err)


    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """Permanent ban"""
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, basestring):
            traceback.print_stack() # TODO: remove this stack trace when we figured out when tempban is called with a str as client
            self.write(self.getCommand('banByName', name=client, reason=reason[:80]))
            return

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.ban_with_server:
            if client.cid is None:
                # ban by ip, this happens when we !permban @xx a player that is not connected
                self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', guid=client.guid, reason=reason[:80]))
                try:
                    self.write(self.getCommand('ban', guid=client.guid, reason=reason[:80]))
                    self.write(('banList.save',))
                    if admin:
                        admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))
                except CommandFailedError, err:
                    self.error(err)
            elif not client.guid:
                # ban by name
                self.debug('EFFECTIVE BAN : %s',self.getCommand('banByName', name=client.name, reason=reason[:80]))
                try:
                    self.write(self.getCommand('banByName', name=client.name, reason=reason[:80]))
                    self.write(('banList.save',))
                    if admin:
                        admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))
                except CommandFailedError, err:
                    self.error(err)
            else:
                # ban by guid
                self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', guid=client.guid, reason=reason[:80]))
                try:
                    self.write(self.getCommand('ban', guid=client.guid, reason=reason[:80]))
                    self.write(('banList.save',))
                    if admin:
                        admin.message('banned: %s (@%s) has been added to banlist' % (client.exactName, client.id))
                except CommandFailedError, err:
                    self.error(err)

        if self.PunkBuster:
            self.PunkBuster.banGUID(client, reason)
            # Also issue a server kick in case we do not ban with the server and punkbuster fails
            if client.cid: # only if client is currently connected
                self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))
        
        if not silent and fullreason != '':
            self.say(fullreason)
        
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))


    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('UNBAN: Name: %s, Ip: %s, Guid: %s' %(client.name, client.ip, client.guid))
        if client.ip:
            try:
                response = self.write(self.getCommand('unbanByIp', ip=client.ip, reason=reason), needConfirmation=True)
                self.write(('banList.save',))
                #self.verbose(response)
                self.verbose('UNBAN: Removed ip (%s) from banlist' %client.ip)
                if admin:
                    admin.message('Unbanned: %s. His last ip (%s) has been removed from banlist.' % (client.exactName, client.ip))
                if admin:
                    fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))
                if not silent and fullreason != '':
                    self.say(fullreason)
            except CommandFailedError, err:
                if "NotInList" in err.message:
                    pass
                else:
                    raise

        try:
            response = self.write(self.getCommand('unban', guid=client.guid, reason=reason), needConfirmation=True)
            self.write(('banList.save',))
            #self.verbose(response)
            self.verbose('UNBAN: Removed guid (%s) from banlist' %client.guid)
            if admin:
                admin.message('Unbanned: Removed %s guid from banlist' % client.exactName)
        except CommandFailedError, err:
            if "NotInList" in err.message:
                pass
            else:
                raise

        if self.PunkBuster:
            self.PunkBuster.unBanGUID(client)


    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        duration = b3.functions.time2minutes(duration)

        if isinstance(client, basestring):
            traceback.print_stack() # TODO: remove this stack trace when we figured out when tempban is called with a str as client
            self.write(self.getCommand('tempbanByName', name=client, duration=duration*60, reason=reason[:80]))
            return
        
        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.PunkBuster:
            if client.cid is not None: # only if player is currently on the server
                # punkbuster acts odd if you ban for more than a day
                # tempban for a day here and let b3 re-ban if the player
                # comes back
                if duration > 1440:
                    duration = 1440
                self.PunkBuster.kick(client, duration, reason)
                # Also issue a server kick in case we do not ban with the server and punkbuster fails
                self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))

        if self.ban_with_server:
            if client.cid is None:
                # ban by ip, this happens when we !tempban @xx a player that is not connected
                try:
                    self.write(self.getCommand('tempban', guid=client.guid, duration=duration*60, reason=reason[:80]))
                    self.write(('banList.save',))
                except CommandFailedError, err:
                    if admin:
                        admin.message("server replied with error %s" % err.message[0])
                    else:
                        self.error(err)
            elif not client.guid:
                try:
                    self.write(self.getCommand('tempbanByName', name=client.name, duration=duration*60, reason=reason[:80]))
                    self.write(('banList.save',))
                except CommandFailedError, err:
                    if admin:
                        admin.message("server replied with error %s" % err.message[0])
                    else:
                        self.error(err)
            else:
                try:
                    self.write(self.getCommand('tempban', guid=client.guid, duration=duration*60, reason=reason[:80]))
                    self.write(('banList.save',))
                except CommandFailedError, err:
                    if admin:
                        admin.message("server replied with error %s" % err.message[0])
                    else:
                        self.error(err)

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                        , client))

 
    def getMap(self):
        """Return the current level name (not easy map name)"""
        self.getServerInfo()
        return self.game.mapName


    def getMaps(self):
        """Return the map list for the current rotation. (as easy map names)
        This does not return all available maps
        """
        response = []
        for map_list in self.getFullMapRotationList():
            map_id = map_list['name']
            gamemode_id = map_list['gamemode']
            number_of_rounds = map_list['num_of_rounds']
            data = '%s (%s) %s round%s' % (self.getEasyName(map_id), self.getGameMode(gamemode_id), number_of_rounds, 's' if number_of_rounds>1 else '')
            response.append(data)
        return response


    def rotateMap(self):
        """\
        load the next map/level
        """
        maplist = self.getFullMapRotationList()
        if not len(maplist):
            # maplist is empty, fix this situation by loading save mapList from disk
            try:
                self.write(('mapList.load',))
            except Exception, err:
                self.warning(err)
            maplist = self.getFullMapRotationList()
            if not len(maplist):
                # maplist is still empty, fix this situation by adding current map to map list
                current_max_rounds = self.write(('mapList.getRounds',))[1]
                self.write(('mapList.add', self.game.mapName, self.game.gameType, current_max_rounds, 0))
        mapIndices = self.write(('mapList.getMapIndices', ))
        self.write(('mapList.setNextMapIndex', mapIndices[1]))
        self.write(('mapList.runNextRound',))
        # we create a EVT_GAME_ROUND_END event as the game server won't make one.
        # https://github.com/courgette/big-brother-bot/issues/52
        self.queueEvent(b3.events.Event(b3.events.EVT_GAME_ROUND_END, data=None))


    def changeMap(self, map_name, gamemode_id=None, number_of_rounds=2):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        
        1) determine the level name
            If map is of the form 'Levels/MP_001' and 'Levels/MP_001' is a supported
            level for the current game mod, then this level is loaded.
            
            In other cases, this method assumes it is given a 'easy map name' (like
            'Port Valdez') and it will do its best to find the level name that seems
            to be for 'Port Valdez' within the supported levels.
        
            If no match is found, then instead of loading the map, this method 
            returns a list of candidate map names
            
        2) if we got a level name
            if the level is not in the current rotation list, then add it to 
            the map list and load it
        """
        map_id = self.getMapIdByName(map_name)
        mapList = self.getFullMapRotationList()
        target_gamemode_id = gamemode_id if gamemode_id else self.game.gameType

        # we want to find the next index to set for mapList
        nextMapListIndex = None

        # simple case : mapList is empty. Then just add our map at index 0 and load it
        if not len(mapList):
            nextMapListIndex = 0
            self.write(('mapList.add', map_id, target_gamemode_id, number_of_rounds, nextMapListIndex))
        else:
            # the wanted map could already be in the rotation list (if gamemode specified)
            if gamemode_id is not None:
                maps_for_current_gamemode = mapList.getByNameAndGamemode(map_id, gamemode_id)
                if len(maps_for_current_gamemode):
                    nextMapListIndex = maps_for_current_gamemode.keys()[0]

            # or it could be in map rotation list for another gamemode
            if nextMapListIndex is None:
                filtered_mapList = mapList.getByName(map_id)
                if len(filtered_mapList):
                    nextMapListIndex = filtered_mapList.keys()[0]

            # or map is not found in mapList and we need to insert it after the index of the current map
            current_index = self.write(('mapList.getMapIndices',))[0]
            nextMapListIndex = int(current_index) + 1
            self.write(('mapList.add', map_id, target_gamemode_id, number_of_rounds, nextMapListIndex))

        # now we have a nextMapListIndex correctly set to the wanted map
        self.write(('mapList.setNextMapIndex', nextMapListIndex))
        self.say('Changing map to %s (%s) %s round%s' % (self.getEasyName(map_id), self.getGameMode(target_gamemode_id), number_of_rounds, 's' if number_of_rounds>1 else ''))
        time.sleep(1)
        self.write(('mapList.runNextRound',))

        
    def getPlayerPings(self):
        """Ask the server for a given client's pings
        """
        raise NotImplementedError


    def getPlayerScores(self):
        """Ask the server for a given client's team
        """
        scores = {}
        try:
            pib = PlayerInfoBlock(self.write(('admin.listPlayers', 'all')))
            for p in pib:
                scores[p['name']] = int(p['score'])
        except Exception, e:
            self.debug('Unable to retrieve scores from playerlist (%r)' % e)
        return scores


    ###############################################################################################
    #
    #    Other methods
    #    
    ###############################################################################################

    def getMapIdByName(self, map_name):
        """accepts partial name and tries its best to get the one map id. If confusion, return
        suggestions as a list"""
        supportedMaps = self.getSupportedMapIds()
        if map_name not in supportedMaps:
            return self.getMapsSoundingLike(map_name)
        else:
            return map_name


    def yell(self, client, text):
        """yell text to a given client"""
        try:
            if client is None:
                self.saybig(text)
            elif client.cid is None:
                pass
            else:
                self.write(self.getCommand('bigmessage', message=text, cid=client.cid, big_msg_duration=int(float(self._settings['big_msg_duration']))))
        except Exception, err:
            self.warning(err)

    def getFullMapRotationList(self):
        """query the Frostbite2 game server and return a MapListBlock containing all maps of the current
         map rotation list.
        """
        response = MapListBlock()
        offset = 0
        tmp = self.write(('mapList.list', offset))
        tmp_num_maps = len(MapListBlock(tmp))
        while tmp_num_maps:
            response.append(tmp)
            tmp = self.write(('mapList.list', len(response)))
            tmp_num_maps = len(MapListBlock(tmp))
        return response

    def getFullBanList(self):
        """query the Frostbite2 game server and return a BanlistContent object containing all bans stored on the game
        server memory.
        """
        response = BanlistContent()
        offset = 0
        tmp = self.write(('banList.list', offset))
        tmp_num_bans = len(BanlistContent(tmp))
        while tmp_num_bans:
            response.append(tmp)
            tmp = self.write(('banList.list', len(response)))
            tmp_num_bans = len(BanlistContent(tmp))
        return response

    def getHardName(self, mapname):
        """ Change human map name to map id """
        raise NotImplementedError('getHardName must be implemented in concrete classes')

    def getEasyName(self, mapname):
        """ Change map id to map human name """
        raise NotImplementedError('getEasyName must be implemented in concrete classes')

    def getGameMode(self, gamemode):
        """ Get gamemode name by id"""
        raise NotImplementedError('getGameMode must be implemented in concrete classes')

    def getGameModeId(self, gamemode_name):
        """ Get gamemode id by name """
        raise NotImplementedError('getGameModeId must be implemented in concrete classes')

    def getCvar(self, cvarName):
        """Read a server var"""
        if cvarName not in self._gameServerVars:
            self.warning('unknown cvar \'%s\'' % cvarName)
            return None
        
        try:
            words = self.write(('vars.%s' % cvarName,))
        except CommandFailedError, err:
            self.warning(err)
            return
        self.debug('Get cvar %s = %s', cvarName, words)
        
        if words:
            if len(words) == 0:
                return b3.cvar.Cvar(cvarName, value=None)
            else:
                return b3.cvar.Cvar(cvarName, value=words[0])
        return None


    def setCvar(self, cvarName, value):
        """Set a server var"""
        if cvarName not in self._gameServerVars:
            self.warning('cannot set unknown cvar \'%s\'' % cvarName)
            return
        self.debug('Set cvar %s = \'%s\'', cvarName, value)
        try:
            self.write(('vars.%s' % cvarName, value))
        except CommandFailedError, err:
            self.warning(err)

    def checkVersion(self):
        raise NotImplementedError('checkVersion must be implemented in concrete classes')
        
    def getServerVars(self):
        raise NotImplementedError('getServerVars must be implemented in concrete classes')

    def getClient(self, cid, guid=None):
        """Get a connected client from storage or create it
        B3 CID   <--> ingame character name
        B3 GUID  <--> EA_guid
        """
        raise NotImplementedError('getClient must be implemented in concrete classes')
    
    def getTeam(self, team):
        """convert frostbite team numbers to B3 team numbers"""
        raise NotImplementedError('getTeam must be implemented in concrete classes')
        
    def getServerInfo(self):
        """query server info, update self.game and return query results
        """
        raise NotImplementedError('getServerInfo must be implemented in concrete classes')

        
    def getNextMap(self):
        """Return the name of the next map and gamemode"""
        maps = self.getFullMapRotationList()
        if not len(maps):
            next_map_name = self.game.mapName
            next_map_gamemode = self.game.gameType
            number_of_rounds = int(self.game.serverinfo['roundsTotal'])
        else:
            mapIndices = self.write(('mapList.getMapIndices', ))
            next_map_info = maps[int(mapIndices[1])]
            next_map_name = next_map_info['name']
            next_map_gamemode = next_map_info['gamemode']
            number_of_rounds = next_map_info['num_of_rounds']
        return '%s (%s) %s round%s' % (self.getEasyName(next_map_name), self.getGameMode(next_map_gamemode), number_of_rounds, 's' if number_of_rounds>1 else '')

    def getSupportedMapIds(self):
        """return a list of supported levels"""
        # TODO : test this once the command work in BF3
        # TODO : to test this latter, remove getSupportedMapIds from bf3.py
        return self.write(('mapList.availableMaps',))

    def getSupportedGameModesByMapId(self, map_id):
        """return a list of supported game modes for the given map id"""
        raise NotImplementedError('getServerInfo must be implemented in concrete classes')

    def getMapsSoundingLike(self, mapname):
        """found matching level names for the given mapname (which can either
        be a level name or map name)
        If no exact match is found, then return close candidates as a list
        """
        supportedMaps = self.getSupportedMapIds()
        clean_map_name = mapname.strip().lower()

        supportedEasyNames = {}
        for m in supportedMaps:
            supportedEasyNames[self.getEasyName(m).lower()] = m

        if clean_map_name in supportedEasyNames:
            return self.getHardName(clean_map_name)

        matches = getStuffSoundingLike(mapname, supportedEasyNames.keys())
        if len(matches) == 1:
            # one match, get the map id
            return supportedEasyNames[matches[0]]
        else:
            # multiple matches, provide human friendly suggestions
            return matches[:3]


    def getGamemodeSoundingLike(self,  map_id, gamemode_name):
        """found the gamemode id for the given gamemode name (which can either
        be a gamemode id or name)
        If no exact match is found, then return close candidates gamemode names
        """
        supported_gamemode_ids = self.getSupportedGameModesByMapId(map_id)
        clean_gamemode_name = gamemode_name.strip().lower()

        # try to find exact matches
        for _id in supported_gamemode_ids:
            if clean_gamemode_name == _id.lower():
                return _id
            elif clean_gamemode_name == self.getGameMode(_id).lower():
                return _id

        supported_gamemode_names = map(self.getGameMode, supported_gamemode_ids)

        shortnames = {
            'cq': 'conquest',
            'cq64': 'conquest64',
            'tdm': 'team deathmatch',
            'sqdm': 'squad deathmatch',
            'ctf': 'capture the flag'
        }
        clean_gamemode_name = shortnames.get(clean_gamemode_name, clean_gamemode_name)

        matches = getStuffSoundingLike(clean_gamemode_name, supported_gamemode_names)
        if len(matches) == 1:
            # one match, get the gamemode id
            return self.getGameModeId(matches[0])
        else:
            # multiple matches, provide human friendly suggestions
            return matches[:3]


    def load_conf_ban_agent(self):
        """setting up ban agent"""
        self.PunkBuster = None
        self.ban_with_server = True
        if self.config.has_option('server', 'ban_agent'):
            ban_agent = self.config.get('server', 'ban_agent')
            if ban_agent is None or ban_agent.lower() not in ('server', 'punkbuster', 'both'):
                self.warning("unexpected value '%s' for ban_agent config option. Expecting one of 'server', 'punkbuster', 'both'." % ban_agent)
            else:
                if ban_agent.lower() == 'server':
                    self.PunkBuster = None
                    self.ban_with_server = True
                    self.info("ban_agent is 'server' -> B3 will ban using the game server banlist")
                elif ban_agent.lower() == 'punkbuster':
                    from b3.parsers.frostbite2.punkbuster import PunkBuster
                    self.PunkBuster = PunkBuster(console=self)
                    self.ban_with_server = False
                    self.info("ban_agent is 'punkbuster' -> B3 will ban using the punkbuster banlist")
                elif ban_agent.lower() == 'both':
                    from b3.parsers.frostbite2.punkbuster import PunkBuster
                    self.PunkBuster = PunkBuster(console=self)
                    self.ban_with_server = True
                    self.info("ban_agent is 'both' -> B3 will ban using both the game server banlist and punkbuster")
                else:
                    self.error("unexpected value '%s' for ban_agent" % ban_agent)
        self.info("ban agent 'server' : %s" % ('activated' if self.ban_with_server else 'deactivated'))
        self.info("ban agent 'punkbuster' : %s" % ('activated' if self.PunkBuster else 'deactivated'))


    def load_conf_big_b3_private_responses(self):
        """load setting big_b3_private_responses from config"""
        default_value = False
        if self.config.has_option(self.gameName, 'big_b3_private_responses'):
            try:
                self._settings['big_b3_private_responses'] = self.config.getboolean(self.gameName, 'big_b3_private_responses')
                self.info("value for setting %s.big_b3_private_responses is " % self.gameName + (
                    'ON' if self._settings['big_b3_private_responses'] else 'OFF'))
            except ValueError, err:
                self._settings['big_b3_private_responses'] = default_value
                self.warning("Invalid value. %s. Using default value '%s'" % (err, default_value))
        else:
            self._settings['big_b3_private_responses'] = default_value


    def load_conf_big_msg_duration(self):
        """load setting big_msg_duration from config"""
        default_value = 4
        if self.config.has_option(self.gameName, 'big_msg_duration'):
            try:
                self._settings['big_msg_duration'] = self.config.getint(self.gameName, 'big_msg_duration')
                self.info("value for setting %s.big_msg_duration is %s" % (self.gameName, self._settings['big_msg_duration']))
            except ValueError, err:
                self._settings['big_msg_duration'] = default_value
                self.warning("Invalid value. %s. Using default value '%s'" % (err, default_value))
        else:
            self._settings['big_msg_duration'] = default_value


    def load_config_message_delay(self):
        if self.config.has_option(self.gameName, 'message_delay'):
            try:
                delay_sec = self.config.getfloat(self.gameName, 'message_delay')
                if delay_sec > 3:
                    self.warning('message_delay cannot be greater than 3')
                    delay_sec = 3
                if delay_sec < .5:
                    self.warning('message_delay cannot be less than 0.5 second.')
                    delay_sec = .5
                self._settings['message_delay'] = delay_sec
            except Exception, err:
                self.error(
                    'failed to read message_delay setting "%s" : %s' % (self.config.get(self.gameName, 'message_delay'), err))
        self.debug('message_delay: %s' % self._settings['message_delay'])


    def load_conf_max_say_line_length(self):
        if self.config.has_option(self.gameName, 'max_say_line_length'):
            try:
                maxlength = self.config.getint(self.gameName, 'max_say_line_length')
                if maxlength > self.SAY_LINE_MAX_LENGTH:
                    self.warning('max_say_line_length cannot be greater than %s' % self.SAY_LINE_MAX_LENGTH)
                    maxlength = self.SAY_LINE_MAX_LENGTH
                if maxlength < 20:
                    self.warning('max_say_line_length is way too short. using minimum value 20')
                    maxlength = 20
                self._settings['line_length'] = maxlength
                self._settings['min_wrap_length'] = maxlength
            except Exception, err:
                self.error('failed to read max_say_line_length setting "%s" : %s' % (
                    self.config.get(self.gameName, 'max_say_line_length'), err))
        self.debug('line_length: %s' % self._settings['line_length'])


def patch_b3_clients():
    #############################################################
    # Below is the code that change a bit the b3.clients.Client
    # class at runtime. What the point of coding in python if we
    # cannot play with its dynamic nature ;)
    #
    # why ?
    # because doing so make sure we're not broking any other
    # working and long tested parser. The changes we make here
    # are only applied when the frostbite parser is loaded.
    #############################################################

    ## add a new method to the Client class
    def frostbiteClientMessageQueueWorker(self):
        """
        This take a line off the queue and displays it
        then pause for 'message_delay' seconds
        """
        while self.messagequeue and not self.messagequeue.empty():
            if not self.connected:
                break
            msg = self.messagequeue.get()
            if msg:
                self.console.message(self, msg)
                if self.connected:
                    time.sleep(float(self.console._settings.get('message_delay', 1)))
    b3.clients.Client.messagequeueworker = frostbiteClientMessageQueueWorker

    ## override the Client.message() method at runtime
    def frostbiteClientMessageMethod(self, msg):
        if msg and len(msg.strip())>0:
            # do we have a queue?
            if not hasattr(self, 'messagequeue'):
                self.messagequeue = Queue.Queue()
            # fill the queue
            text = self.console.stripColors(self.console.msgPrefix + ' [pm] ' + msg)
            for line in self.console.getWrap(text, self.console._settings['line_length'], self.console._settings['min_wrap_length']):
                self.messagequeue.put(line)
            # create a thread that executes the worker and pushes out the queue
            if not hasattr(self, 'messagehandler') or not self.messagehandler.isAlive():
                self.messagehandler = threading.Thread(target=self.messagequeueworker, name="%s_messagehandler" % self)
                self.messagehandler.setDaemon(True)
                self.messagehandler.start()
            else:
                self.console.verbose('messagehandler for %s isAlive' %self.name)
    b3.clients.Client.message = frostbiteClientMessageMethod

    original_client_disconnect_method = b3.clients.Client.disconnect
    def frostbiteClientDisconnect(self):
        original_client_disconnect_method(self)
        if hasattr(self, 'messagequeue'):
            self.messagequeue = None
        if hasattr(self, 'messagehandler') and self.messagehandler:
            self.console.debug("waiting for %s.messageQueueWorker thread to finish" % self)
            self.messagehandler.join()
            self.console.debug("%s.messageQueueWorker thread finished" % self)

    b3.clients.Client.disconnect = frostbiteClientDisconnect

    ## override the Client.yell() method at runtime
    def frostbiteClientYellMethod(self, msg):
        if msg and len(msg.strip())>0:
            text = self.console.stripColors(self.console.msgPrefix + ' [pm] ' + msg)
            for line in self.console.getWrap(text, self.console._settings['line_length'], self.console._settings['min_wrap_length']):
                self.console.write(self.console.getCommand('bigmessage', message=line, cid=self.cid, big_msg_duration=int(float(self.console._settings['big_msg_duration']))))
    b3.clients.Client.yell = frostbiteClientYellMethod


########NEW FILE########
__FILENAME__ = protocol
#!/usr/local/bin/python

# Changelog
# 2010/07/23 - xlr8or - v1.0.1
# * fixed infinite loop in a python socket thread in receivePacket() on gameserver restart

__version__ = '1.0.1'

import logging
from struct import pack, unpack
import time
import asyncore
import socket
import threading
import hashlib

def EncodeHeader(isFromServer, isResponse, sequence):
    header = sequence & 0x3fffffff
    if isFromServer:
        header += 0x80000000
    if isResponse:
        header += 0x40000000
    return pack('<I', header)

def DecodeHeader(data):
    [header] = unpack('<I', data[0 : 4])
    return [header & 0x80000000, header & 0x40000000, header & 0x3fffffff]

def EncodeInt32(size):
    return pack('<I', size)

def DecodeInt32(data):
    return unpack('<I', data[0 : 4])[0]
    
    
def EncodeWords(words):
    size = 0
    encodedWords = ''
    for word in words:
        strWord = str(word)
        encodedWords += EncodeInt32(len(strWord))
        encodedWords += strWord
        encodedWords += '\x00'
        size += len(strWord) + 5
    
    return size, encodedWords
    
def DecodeWords(size, data):
    numWords = DecodeInt32(data[0:])
    words = []
    offset = 0
    while offset < size:
        wordLen = DecodeInt32(data[offset : offset + 4])        
        word = data[offset + 4 : offset + 4 + wordLen]
        words.append(word)
        offset += wordLen + 5

    return words

def EncodePacket(isFromServer, isResponse, sequence, words):
    encodedHeader = EncodeHeader(isFromServer, isResponse, sequence)
    encodedNumWords = EncodeInt32(len(words))
    [wordsSize, encodedWords] = EncodeWords(words)
    encodedSize = EncodeInt32(wordsSize + 12)
    return encodedHeader + encodedSize + encodedNumWords + encodedWords

# Decode a request or response packet
# Return format is:
# [isFromServer, isResponse, sequence, words]
# where
# isFromServer = the command in this command/response packet pair originated on the server
#     isResponse = True if this is a response, False otherwise
#     sequence = sequence number
#     words = list of words
    
def DecodePacket(data):
    [isFromServer, isResponse, sequence] = DecodeHeader(data)
    wordsSize = DecodeInt32(data[4:8]) - 12
    words = DecodeWords(wordsSize, data[12:])
    return [isFromServer, isResponse, sequence, words]

###############################################################################

clientSequenceNr = 0

# Encode a request packet

def EncodeClientRequest(words):
    global clientSequenceNr
    packet = EncodePacket(False, False, clientSequenceNr, words)
    clientSequenceNr = (clientSequenceNr + 1) & 0x3fffffff
    return packet

# Encode a response packet
    
def EncodeClientResponse(sequence, words):
    return EncodePacket(True, True, sequence, words)


###################################################################################
# Display contents of packet in user-friendly format, useful for debugging purposes
    
def printPacket(packet):

    if packet[0]:
        print "IsFromServer, ",
    else:
        print "IsFromClient, ",
    
    if packet[1]:
        print "Response, ",
    else:
        print "Request, ",

    print "Sequence: " + str(packet[2]),

    if packet[3]:
        print " Words:",
        for word in packet[3]:
            print "\"" + word + "\"",

    print ""

###################################################################################

def generatePasswordHash(salt, password):
    m = hashlib.new('md5')
    m.update(salt)
    m.update(password)
    return m.digest()
    
###################################################################################

def containsCompletePacket(data):
    if len(data) < 8:
        return False
    if len(data) < DecodeInt32(data[4:8]):
        return False
    return True

# Wait until the local receive buffer contains a full packet (appending data from the network socket),
# then split receive buffer into first packet and remaining buffer data
    
def receivePacket(_socket, receiveBuffer):

    while not containsCompletePacket(receiveBuffer):
        data = _socket.recv(4096) #was 16384
        #Make sure we raise a socket error when the socket is hanging on a loose end (receiving no data after server restart) 
        if not data:
            raise socket.error('No data received - Remote end unexpectedly closed socket')
        receiveBuffer += data

    packetSize = DecodeInt32(receiveBuffer[4:8])

    packet = receiveBuffer[0:packetSize]
    receiveBuffer = receiveBuffer[packetSize:len(receiveBuffer)]

    return [packet, receiveBuffer]

#####################################################################################
class FrostbiteError(Exception): pass

class CommandError(FrostbiteError): pass
class CommandTimeoutError(CommandError): pass
class CommandFailedError(CommandError): pass

class NetworkError(FrostbiteError): pass

class FrostbiteDispatcher(asyncore.dispatcher_with_send):

    def __init__(self, host, port):
        asyncore.dispatcher_with_send.__init__(self)
        self._buffer_in = ''
        self.getLogger().info("connecting")
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        asyncore.dispatcher_with_send.connect(self, (host, port))
        self._frostbite_event_handler = None
        self._frostbite_command_response_handler = None

    #===============================================================================
    # 
    #        Public API
    #    
    #===============================================================================

    def set_frostbite_event_hander(self, func):
        """register a function that will be called when the Frosbite server
        sends us a game event."""
        self._frostbite_event_handler = func

    def set_frostbite_command_response_handler(self, func):
        """register a function that will be called when the Frosbite server
        sends us a command reply."""
        self._frostbite_command_response_handler = func
        
    def send_command(self, *command):
        """Send a command to the Frosbite server and return the command id
        which can be used to find the matching reply later on."""
        self.getLogger().info("command : %s " % repr(command))
        if len(command) == 1 and type(command[0]) == tuple:
            words = command[0]
        else:
            words = command
        request = EncodeClientRequest(words)
        [sequence, words] = DecodePacket(request)[2:]

        self.getLogger().debug("sending command request #%i: %s " % (sequence, words))
        asyncore.dispatcher_with_send.send(self, request)

        return sequence

    #===========================================================================
    # 
    # Other methods
    # 
    #===========================================================================

    def getLogger(self):
        return logging.getLogger("FrostbiteDispatcher")
    
    def handle_connect(self):
        self.getLogger().debug("handle_connect")
    
    def handle_close(self):
        """Called when the socket is closed."""
        self.getLogger().debug("handle_close")
        self.close()

    def handle_read(self):
        """Called when the asynchronous loop detects that a read() call on the channel's socket will succeed."""
        # received raw data
        data = self.recv(8192)
        self._buffer_in += data
        self.getLogger().debug('read %s char from Frostbite2 gameserver' % len(data))

        # cook it into Frosbite packets
        while containsCompletePacket(self._buffer_in):
            packetSize = DecodeInt32(self._buffer_in[4:8])
            packet = self._buffer_in[0:packetSize]
            self._buffer_in = self._buffer_in[packetSize:len(self._buffer_in)]
            self.handle_packet(packet)
            
    def handle_packet(self, packet):
        """Called when a full Frosbite packet has been received."""
        [originServer, isResponse, sequence, words] = DecodePacket(packet)
        self.getLogger().info("handle_packet(%s)" % repr([originServer, isResponse, sequence, words]))
        if not isResponse:
            # acknowledge the server
            self.send(EncodePacket(originServer, True, sequence, ("OK",)))
        if originServer:
            if isResponse:
                self.getLogger().warn("received a bad packet from frosbite server pretending being a response for a server request. %s" % repr(packet))
            else:
                self.handle_frostbite_event(words)
        else:
            if isResponse:
                self.handle_frostbite_command_response(sequence, words)
            else:
                self.getLogger().warn("received a bad packet from frosbite server pretending being a request from us. %s" % repr(DecodePacket(packet)))

    def handle_frostbite_event(self, words):
        self.getLogger().debug("received a game event from frosbite server. %s" % repr(words))
        if self._frostbite_event_handler is not None:
            self._frostbite_event_handler(words)

    def handle_frostbite_command_response(self, command_id, words):
        self.getLogger().debug("received a response for command #%i from frosbite server. %s" % (command_id, repr(words)))
        if self._frostbite_command_response_handler is not None:
            self._frostbite_command_response_handler(command_id, words)
    
    

class FrostbiteServer(threading.Thread):
    """thread opening a connection to a Frostbite game server and providing
    means of observing Frostbite events and sending commands"""
    def __init__(self, host, port, password=None, command_timeout=5.0):
        threading.Thread.__init__(self, name="FrosbiteServerThread")
        self.frostbite_dispatcher = FrostbiteDispatcher(host, port)
        self._stopEvent = threading.Event()
        self.password = password
        self.command_timeout = command_timeout
        self.frostbite_dispatcher.set_frostbite_event_hander(self._on_event)
        self.frostbite_dispatcher.set_frostbite_command_response_handler(self._on_command_response)
        self.pending_commands = {}
        self.__command_reply_event = threading.Event()
        self.observers = set()
        # test connection
        sock = socket.create_connection((host, port), timeout=2)
        sock.close()
        # ok start working
        self.start()
        time.sleep(1.5)

    #===============================================================================
    # 
    #    Public API
    #
    #===============================================================================

    def subscribe(self, func):
        """Add func from Frosbite events listeners."""
        self.observers.add(func)
        
    def unsubscribe(self, func):
        """Remove func from Frosbite events listeners."""
        self.observers.remove(func)

    def command(self, *command):
        """send command to the Frostbite server in a synchronous way.
        Calling this method will block until we receive the reply packet from the
        game server or until we reach the timeout.
        """
        if not self.connected:
            raise NetworkError("not connected")
        
        self.getLogger().info("command : %s " % repr(command))
        if command is None:
            return None

        command_id = self.frostbite_dispatcher.send_command(*command)
        self.pending_commands[command_id] = None
        self.getLogger().debug("command #%i sent. %s " % (command_id, repr(command)))
        
        response = self._wait_for_response(command_id)
        if response[0] != "OK":
            raise CommandFailedError(response)
        else:
            return response[1:]

    def auth(self):
        """authenticate on the Frosbite server with given password"""
        self.getLogger().info("starting authentication")
        hash_token = self.command('login.hashed')
        # Given the salt and the password, combine them and compute hash value
        salt = hash_token[0].decode("hex")
        passwordHash = generatePasswordHash(salt, self.password)
        passwordHashHexString = passwordHash.encode("hex").upper()
        # Send password hash to server
        self.command("login.hashed", passwordHashHexString)
        self.getLogger().info("authentication done")

    def close(self):
        self.frostbite_dispatcher.close()

    def stop(self):
        self._stopEvent.set()
        self.close()
    
    #===============================================================================
    # 
    # Other methods
    #
    #===============================================================================

    def __getattr__(self, name):
        if name == 'connected':
            return self.frostbite_dispatcher.connected
        else:
            raise AttributeError

    def getLogger(self):
        return logging.getLogger("FrostbiteServer")

    def isStopped(self):
        return self._stopEvent.is_set()

    def run(self):
        """Threaded code"""
        self.getLogger().info('start loop')
        try:
            while not self.isStopped():
                asyncore.loop(count=1, timeout=1)
        except KeyboardInterrupt:
            pass
        finally:
            self.frostbite_dispatcher.close()
        self.getLogger().info('end loop')

    def _on_event(self, words):
        self.getLogger().debug("received Frostbite event : %s" % repr(words))
        for func in self.observers:
            func(words)

    def _on_command_response(self, command_id, words):
        self.getLogger().debug("received Frostbite command #%i response : %s" % (command_id, repr(words)))
        if command_id not in self.pending_commands:
            self.getLogger().warn("dropping Frostbite command #%i response as we are not waiting for it anymore" % command_id)
        else:
            self.pending_commands[command_id] = words
            self.__command_reply_event.set()


    def _wait_for_response(self, command_id):
        """block until response to for given command_id has been received or until timeout is reached."""
        expire_time = time.time() + self.command_timeout
        while not self.isStopped() and command_id in self.pending_commands and self.pending_commands[command_id] is None:
            if not self.connected:
                raise NetworkError("Lost connection to Frostbite2 server")
            if time.time() >= expire_time:
                del self.pending_commands[command_id]
                raise CommandTimeoutError("Did not receive any response for sequence #%i." % command_id)
            self.getLogger().debug("waiting for some command reply #%i : %r " % (command_id, self.pending_commands))
            self.__command_reply_event.clear()
            self.__command_reply_event.wait(self.command_timeout)
        try:
            response = self.pending_commands[command_id]
            del self.pending_commands[command_id]
            return response
        except KeyError:
            raise CommandTimeoutError("Did not receive any response for sequence #%i." % command_id)



###################################################################################
# Example program

if __name__ == '__main__':
    from getopt import getopt
    import sys

    print "Remote administration event listener for Frosbite"
    # history_file = os.path.join( os.environ["HOME"], ".bfbc2_rcon_history" )

    host = None
    port = None
    pw = None
    serverSocket = None

    opts, args = getopt(sys.argv[1:], 'h:p:e:a:')
    for k, v in opts:
        if k == '-h':
            host = v
        elif k == '-p':
            port = int(v)
        elif k == '-a':
            pw = v
    
    if not host:
        host = raw_input('Enter game server host IP/name: ')
    if not port:
        port = int(raw_input('Enter host port: '))
    if not pw:
        pw = raw_input('Enter password: ')


    def run_low_level():
        try:
            serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
            print 'Connecting to port: %s:%d...' % ( host, port )
            serverSocket.connect( ( host, port ) )
            serverSocket.setblocking(1)
            receiveBuffer = ''
    
            print 'Logging in - 1: retrieving salt...'
    
            # Retrieve this connection's 'salt' (magic value used when encoding password) from server
            getPasswordSaltRequest = EncodeClientRequest( [ "login.hashed" ] )
            serverSocket.send(getPasswordSaltRequest)
    
            [getPasswordSaltResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
            printPacket(DecodePacket(getPasswordSaltResponse))
    
            [isResponse, sequence, words] = DecodePacket(getPasswordSaltResponse)[1:]
    
            # if the server doesn't understand "login.hashed" command, abort
            if words[0] != "OK":
                sys.exit(0)
    
            print 'Received salt: ' + words[1]
    
            # Given the salt and the password, combine them and compute hash value
            salt = words[1].decode("hex")
            passwordHash = generatePasswordHash(salt, pw)
            passwordHashHexString = passwordHash.encode("hex").upper()
    
            print 'Computed password hash: ' + passwordHashHexString
            
            # Send password hash to server
            print 'Logging in - 2: sending hash...'
    
            loginRequest = EncodeClientRequest( [ "login.hashed", passwordHashHexString ] )
            serverSocket.send(loginRequest)
    
            [loginResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
    
            printPacket(DecodePacket(loginResponse))
    
            [isResponse, sequence, words] = DecodePacket(loginResponse)[1:]
    
            # if the server didn't like our password, abort
            if words[0] != "OK":
                sys.exit(0)
    
            print 'Logged in.'
            
            print 'Enabling events...'
        
            enableEventsRequest = EncodeClientRequest(("admin.eventsEnabled", "true"))
            serverSocket.send(enableEventsRequest)
    
            [enableEventsResponse, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
            printPacket(DecodePacket(enableEventsResponse))
    
            [isResponse, sequence, words] = DecodePacket(enableEventsResponse)[1:]
    
            # if the server didn't know about the command, abort
            if words[0] != "OK":
                sys.exit(0)
            
            print 'Now waiting for events.'
    
            while True:
                # Wait for packet from server
                [packet, receiveBuffer] = receivePacket(serverSocket, receiveBuffer)
    
                [isResponse, sequence, words] = DecodePacket(packet)[1:]
    
                # If this was a command from the server, we should respond to it
                # For now, we always respond with an "OK"
                if not isResponse:
                    response = EncodeClientResponse(sequence, ["OK"])
                    serverSocket.send(response)
                else:
                    print 'Received an unexpected response packet from server, ignoring:'
    
                printPacket(DecodePacket(packet))
    
    
        except socket.error, detail:
            print 'Network error:', detail[1]
    
        except (EOFError, KeyboardInterrupt):
            pass
    
        except:
            raise


    def run_FrosbiteServer():
        from b3.output import OutputHandler
        
        FORMAT = "%(name)-20s [%(thread)-4d] %(threadName)-15s %(levelname)-8s %(message)s"
        handler = logging.StreamHandler()
        formatter = logging.Formatter(FORMAT)
        handler.setFormatter(formatter)
        
        myConsole = OutputHandler('console')
        myConsole.addHandler(handler)
        myConsole.setLevel(logging.NOTSET)
        
        #logging.getLogger('FrostbiteServer').addHandler(handler)
        #logging.getLogger('FrostbiteDispatcher').addHandler(handler)

        def frosbiteEventListener(words):
            myConsole.console(">>> %s" % words)    
                

        from random import sample, random
        class CommandRequester(threading.Thread):
            _stop = threading.Event()
            nb_instances = 0
            def __init__(self, frostbite_server, commands=('serverInfo',), delay=5):
                self.__class__.nb_instances += 1
                threading.Thread.__init__(self, name="CommandRequester%s" % self.__class__.nb_instances)
                self.frostbite_server = frostbite_server
                self.commands = commands
                self.delay = delay

            def getLogger(self):
                return logging.getLogger("CommandRequester")
            
            def run(self):
                self.getLogger().info("starting spamming commands")
                while not self.__class__._stop.is_set():
                    cmd = sample(self.commands, 1)[0]
                    self.getLogger().info("###\trequesting \t%s" % repr(cmd))
                    try:
                        response = self.frostbite_server.command(cmd)
                        self.getLogger().info("###\treceived \t%s" % repr(response))
                    except CommandFailedError, err:
                        self.getLogger().info("###\treceived \t%s" % repr(err.message))
                    time.sleep(self.delay + random())
                self.getLogger().info("stopped spamming commands")

            @classmethod
            def stopAll(cls):
                cls._stop.set()

        logging.basicConfig(level=logging.NOTSET, format=FORMAT)
        logging.info("here we go")
                    
        t_conn = FrostbiteServer(host, port, pw)
        t_conn.subscribe(frosbiteEventListener)

#        try:
#            t_conn.command('logout')
#        except CommandError, err:
#            logging.error(err)
        try:
            t_conn.auth()
            t_conn.command('admin.eventsEnabled', 'true')
        except FrostbiteError, err:
            logging.error(err)

        time.sleep(1)
        CommandRequester(t_conn).start()
        time.sleep(.5)
        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, (('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, (('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, ('version', ('listPlayers', 'all'), 'serverInfo', ('login.plainText', 'faux password'), 'login.plainText')).start()
#        time.sleep(.5)
#        CommandRequester(t_conn, (('login.plainText', 'faux password'), 'login.plainText')).start()
        
        time.sleep(5)
        t_conn.stop()
        CommandRequester.stopAll()
        logging.info("here we die")

    #run_low_level()
    run_FrosbiteServer()
    
########NEW FILE########
__FILENAME__ = punkbuster
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
__author__  = 'Courgette'
__version__ = '1.2'

import b3.parsers.punkbuster

#--------------------------------------------------------------------------------------------------
class PunkBuster(b3.parsers.punkbuster.PunkBuster):

    def send(self, command):
        return self.console.write(('punkBuster.pb_sv_command', command))

    def getPlayerList(self):
        return self.console.getPlayerList()

    def ban(self, client, reason='', private=''):
        # in BF3 we do not have reliable slot id for connected players.
        # fallback on banning by GUID instead
        self.banGUID(client, reason)
        self.send('pb_sv_updbanfile')

    def kick(self, client, minutes=1, reason='', private=''):
        """
        PB_SV_Kick [name or slot #] [minutes] [displayed_reason] | [optional_private_reason]
        Removes a player from the game and won't let the player rejoin until specified [minutes]
        has passed or until the server is restarted, whichever comes first - kicks are not written
        to the pbbans.dat file but they are logged and will show up in the output from the pb_sv_banlist command
        """
        if client and client.connected:
            self.send('PB_SV_Kick "%s" "%s" "%s" "%s"' % (client.cid, minutes, reason, private))
            self.send('pb_sv_updbanfile')

    def banGUID(self, client, reason=''):
        """
        PB_SV_BanGuid [guid] [player_name] [IP_Address] [reason]
        Adds a guid directly to PB's permanent ban list; if the player_name or IP_Address
        are not known, we recommend using "???"
        """
        if client.pbid:
            name = client.name if client.name else '?'
            ip = client.ip if client.ip else '?'
            self.send('PB_SV_BanGuid %s "%s" "%s" "%s"' % (client.pbid, name, ip, reason))

    def unBanGUID(self, client):
        """
        PB_SV_UnBanGuid [guid]
        Unbans a guid from the ban list stored in memory; use pb_sv_updbanfile to update the
        permanent ban file after using this command
        """
        if client.pbid:
            self.send('PB_SV_UnBanGuid %s' % client.pbid)
            self.send('pb_sv_updbanfile')
########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas LEVEIL
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Changelog :


"""
dummy rcon module for Frostbite to satisfy B3 parser. 

Ideally, B3 parser should be changed to allow games to 
not require a separated socket connection for rcon commands

To use that Rcon class, instantiate and use the set_frostbite_server() method. 
Then you can expect this class to work like the other Rcon classes
"""

__author__  = 'Courgette'
__version__ = '1.0'

#--------------------------------------------------------------------------------------------------
class Rcon:
    def __init__(self, console, *args):
        self.console = console
        self.frostbite_server = None
        
    def set_frostbite_server(self, frostbite_server):
        self.frostbite_server = frostbite_server
    
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        if not self.frostbite_server:
            return
        self.console.verbose(u'RCON :\t %s' % repr(cmd))
        response = self.frostbite_server.command(cmd)
        self.console.verbose(u'RCON response:\t %s' % repr(response))
        return response
        
    def flush(self):
        pass

    def close(self):
        pass

########NEW FILE########
__FILENAME__ = util
# # -*- coding: utf-8 -*-
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# --------------------------------------------------------------------------
#
# CHANGELOG :
# 1.1 - 2010/11/03 - Courgette
#    * add __repr__
#    * fix minor bug in BanlistContent
#    * add automated tests
# 1.2 - 2012/01/21 - Courgette
#    * add a append() method to BanlistContent and MapListBlock classes
# 1.3 - 2012/01/21 - Courgette
#    * add method getByNameGamemodeAndRounds() to class MapListBlock
#

"""\
This module provides different utilities specific to the Frostbite engine
"""

__author__  = 'Courgette'
__version__ = '1.3'


class BanlistContentError(Exception):
    pass

class BanlistContent(object):
    """
    help extract banlist info from a frostbite banList.list response
    
    usage :
        words = [
            'name', 'Courgette', 'perm',         , 'test',
            'name', 'Courgette', 'seconds', 3600 , 'test2'] 
        bansInfo = BanlistContent(words)
        print "num of bans : %s" % len(bansInfo)
        print "first ban : %s" % bansInfo[0]
        print "second ban : %s" % bansInfo[1]
        print "the first 2 bans : %s" % bansInfo[0:2]
        for b in bansInfo:
            print b
    """

    def __init__(self, data=None):
        """Represent a frostbite banList.list response
        Request: banList.list 
        Response: OK <player ban entries> 
        Response: InvalidArguments 
        Effect: Return list of banned players/IPs/GUIDs. 
        Comment: 6 words (Id-type, id, ban-type, seconds left, rounds left, and reason) are received for every ban in
        the list.
        If no startOffset is supplied, it is assumed to be 0.
        At most 100 entries will be returned by the command. To retrieve the full list, perform several banList.list
        calls with increasing offset until the server returns 0 entries.
        (There is an unsolved synchronization problem hidden there: if a ban expires during this process, then one other
        entry will be skipped during retrieval. There is no known workaround for this.)
        """
        self.numOfBans = 0
        self.bansData = []
        if data is not None:
            self.append(data)


    def append(self, data):
        """Parses and appends the maps from raw_data.
        data : words as received from the Frostbite2 mapList.list command
        """
        # validation
        if type(data) not in (tuple, list):
            raise BanlistContentError("invalid data. Expecting data as a tuple or as a list. Received '%s' instead" % type(data))

        if len(data) == 0:
            # banList.list returns nothing when the banlist contains no ban.
            return

        if len(data) % 6 != 0:
            raise BanlistContentError("invalid data. The total number of elements is not divisible by 6 (%s)" % len(data))

        # append data
        self.bansData += data
        self.numOfBans += len(data) / 6


    def __len__(self):
        return int(self.numOfBans)

    def __getitem__(self, key):
        """Returns the ban data, for provided key (int or slice)"""
        if isinstance(key, slice):
            indices = key.indices(len(self))
            return [self.getData(i) for i in range(*indices) ]
        else:
            return self.getData(key)

    def getData(self, index):
        if index >= self.numOfBans:
            raise IndexError
        tmp = self.bansData[index*6:(index+1)*6]
        return {
            'idType': tmp[0], # name | ip | guid
            'id': tmp[1],
            'banType': tmp[2], # perm | round | seconds
            'seconds_left': tmp[3],
            'rounds_left': tmp[4],
            'reason': tmp[5], # 80 chars max
        }

    def __repr__(self):
        return "BanlistContent[%s]" % ', '.join([repr(x) for x in self])



class PlayerInfoBlock:
    """
    help extract player info from a frostbite Player Info Block which we obtain
    from admin.listPlayers
    
    usage :
        words = [3, 'name', 'guid', 'teamId', 2, 
            'Courgette', 'A32132e', 0, 
            'SpacepiG', '6546545665465', 1]
        playersInfo = PlayerInfoBlock(words)
        print "num of players : %s" % len(playersInfo)
        print "first player : %s" % playersInfo[0]
        print "second player : %s" % playersInfo[1]
        print "the first 2 players : %s" % playersInfo[0:2]
        for p in playersInfo:
            print p
    """

    def __init__(self, data):
        """Represent a frostbite Player info block
        The standard set of info for a group of players contains a lot of different 
        fields. To reduce the risk of having to do backwards-incompatible changes to
        the protocol, the player info block includes some formatting information.
            
        The standard set of info for a group of players contains a lot of different 
        fields. To reduce the risk of having to do backwards-incompatible changes to 
        the protocol, the player info block includes some formatting information.
        
            <number of parameters> - number of parameters for each player 
            N x <parameter type: string> - the parameter types that will be sent below 
            <number of players> - number of players following 
            M x N x <parameter value> - all parameter values for player 0, then all parameter values for player 1, etc.

        Current parameters: 
            name string - player name 
            guid string - players unique ID 
            teamId Team ID - players current team 
            squadId Squad ID - players current squad 
            kills integer - number of kills, as shown in the in-game scoreboard 
            deaths integer - number of deaths, as shown in the in-game scoreboard 
            score integer - score, as shown in the in-game scoreboard
        """
        self._num_parameters = int(data[0])
        self._parameter_types = data[1:1+self._num_parameters]
        self._num_players = int(data[1+self._num_parameters])
        self._players_data = data[2+self._num_parameters:]

    def __len__(self):
        return self._num_players

    def __getitem__(self, key):
        """Returns the player data, for provided key (int or slice)"""
        if isinstance(key, slice):
            indices = key.indices(len(self))
            return [self._getPlayerData(i) for i in range(*indices) ]
        else:
            return self._getPlayerData(key)

    def _getPlayerData(self, index):
        if index >= self._num_players:
            raise IndexError
        data = {}
        playerData = self._players_data[index*self._num_parameters:(index+1)*self._num_parameters]
        for i in range(self._num_parameters):
            data[self._parameter_types[i]] = playerData[i]
        return data

    def __repr__(self):
        txt = "PlayerInfoBlock["
        for p in self:
            txt += "%r" % p
        txt += "]"
        return txt


class TeamScoresBlock:
    """
    help extract team scores info from frostbite data obtain from game events
    
    usage :
        teamScores = TeamScoresBlock([2, 130, 245, 1000])
        print "num of teams : %s" % len(teamScores)
        print "first team's score : %s" % teamScores[0]
        print "second team's : %s" % teamScores[1]
        print "the first 2 teams' scores : %s" % teamScores[0:2]
        print "target score : %s " % teamScores.get_target_score()
        for p in teamScores:
            print p
    """

    def __init__(self, data):
        """Represent a frostbite Team Scores block
            
        This describes the number of tickets, or kills, for each team in the current round.
        
            <number of entries: integer> - number of team scores that follow 
            N x <score: integer> - score for all teams 
            <target score: integer> - when any team reaches this score, the match ends 
        """
        self._num_teams = int(data[0])
        self._scores = tuple([int(x) for x in data[1:1+self._num_teams]])
        self._target_score = int(data[1+self._num_teams])

    def __len__(self):
        return self._num_teams

    def __getitem__(self, key):
        """Returns the team score data, for provided key (int or slice)"""
        return self._scores[key]

    def get_target_score(self):
        return self._target_score

    def __repr__(self):
        txt = "TeamScoresBlock["
        txt += ", ".join([repr(x) for x in self._scores])
        txt += "], target: %s" % self._target_score
        return txt


class MapListBlockError(Exception):
    pass

class MapListBlock:
    """
    help extract map list from frostbite data
    
    usage :
        mapList = MapListBlock([2, 3, "MP_001", "ConquestLarge0", 2, "MP_011", "Rush", 3])
        print "num of maps : %s" % len(mapList)
        print "first map name : %s" % mapList[0]['name']
        print "second map gamemode : %s" % mapList[1]['gamemode']
        print "the first 2 maps data : %s" % mapList[0:2]
        print "the first 2 maps num_of_rounds : %s" % [x['num_of_rounds'] for x in mapList[0:2]]
        for p in mapList:
            print p
    """

    def __init__(self, data=None):
        """This describes the set of maps which the server rotates through. 

        Format is as follows: 
            <number of maps: integer> - number of maps that follow
            <number of words per map: integer> - number of words per map 
            <map name: string> - name of map 
            <gamemode name: string> - name of gamemode 
            <number of rounds: integer> - number of rounds to play on map before switching

        The reason for the <number of words per map> specification is future proofing; 
        in the future, DICE might add extra words per map after the first three. However, 
        the first three words are very likely to remain the same. 
        """
        self._num_maps = 0
        self._num_words = None
        self._map_data = tuple()
        if data is not None:
            self.append(data)

    def append(self, data):
        """Parses and appends the maps from raw_data.
        data : words as received from the Frostbite2 mapList.list command
        """
        # validation
        if type(data) not in (tuple, list):
            raise MapListBlockError("invalid data. Expecting data as a tuple or as a list. Received '%s' instead" % type(data))

        if len(data) < 2:
            raise MapListBlockError("invalid data. Data should have at least 2 elements. %r", data)

        try:
            num_maps = int(data[0])
        except ValueError, err:
            raise MapListBlockError("invalid data. First element should be a integer, got %r" % data[0], err)

        try:
            num_words = int(data[1])
        except ValueError, err:
            raise MapListBlockError("invalid data. Second element should be a integer, got %r" % data[1], err)

        if len(data) != (2 + (num_maps * num_words)):
            raise MapListBlockError("invalid data. The total number of elements is not coherent with the number of maps declared. %s != (2 + %s * %s)" % (len(data), num_maps, num_words))

        if num_words < 3:
            raise MapListBlockError("invalid data. Expecting at least 3 words of data per map")

        if self._num_words is not None and self._num_words != num_words:
            raise MapListBlockError("cannot append data. nums_words are different from existing data.")

        # parse data
        map_data = []
        for i in range(num_maps):
            base_index = 2 + (i * num_words)
            try:
                num_rounds = int(data[base_index+2])
            except ValueError:
                raise MapListBlockError("invalid data. %sth element should be a integer, got %r" % (base_index + 2, data[base_index + 2]))
            map_data.append({'name': data[base_index+0], 'gamemode': data[base_index+1], 'num_of_rounds': num_rounds})

        # append data
        self._map_data += tuple(map_data)
        self._num_maps = len(self._map_data)
        if self._num_words is None:
            self._num_words = num_words

    def __len__(self):
        return self._num_maps

    def __getitem__(self, key):
        """Returns the map data, for provided key (int or slice)"""
        return self._map_data[key]

    def __repr__(self):
        txt = "MapListBlock["
        map_info_repr = []
        for p in self:
            map_info_repr.append("%(name)s:%(gamemode)s:%(num_of_rounds)s" % p)
        txt += ", ".join(map_info_repr)
        txt += "]"
        return txt

    def getByName(self, map_name):
        """Returns a dict with map indexes as keys and map info as values for all maps of given name"""
        response = {}
        i = 0
        while i < self._num_maps:
            map_info = self[i]
            if map_info['name'] == map_name:
                response[i] = map_info
            i += 1
        return response

    def getByNameAndGamemode(self, map_name, gamemode):
        """Returns a dict with map indexes as keys and map info as values for all maps of given name and given gamemode"""
        response = {}
        i = 0
        while i < self._num_maps:
            map_info = self[i]
            if map_info['name'] == map_name and map_info['gamemode'] == gamemode:
                response[i] = map_info
            i += 1
        return response

    def getByNameGamemodeAndRounds(self, map_name, gamemode, num_of_rounds):
        """Returns a dict with map indexes as keys and map info as values for all maps of given name, gamemode and number of rounds"""
        response = {}
        i = 0
        while i < self._num_maps:
            map_info = self[i]
            if map_info['name'] == map_name and map_info['gamemode'] == gamemode and str(map_info['num_of_rounds']) == str(num_of_rounds):
                response[i] = map_info
            i += 1
        return response

########NEW FILE########
__FILENAME__ = protocol
# -*- coding: cp1252 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
#
# 2011/03/23 - Courgette 
#    working so far : packet codec, login(), ping()
#    todo : handle incoming data (split by homefront packet)
# 2011/03/24 - 0.2 - Courgette 
#    can maintain a connection, receive packets, send packets
# 2011/03/31 - 0.3 - Courgette
#    do not crash when send() raises a socket.error
#

"""
module implementing the Homefront protocol. Provide the Client class which
creates a connection to a Homefront gameserver
"""

__author__  = 'Courgette'
__version__ = '0.3'


import asyncore, socket, time
from struct import pack, unpack
from hashlib import sha1



class MessageType:
    CONNECT = 'CC'
    CLIENT_TRANSMISSION = 'CT'
    CLIENT_DISCONNECT = 'CD'
    CLIENT_PING = 'CP'
    SERVER_ANNOUNCE = 'SA'
    SERVER_RESPONSE = 'SR'
    SERVER_DISCONNECT = 'SD'
    SERVER_TRANSMISSION = 'ST'
    
    @staticmethod
    def type2str(type):
        names = {
                 MessageType.CONNECT: "CONNECT",
                 MessageType.CLIENT_TRANSMISSION: "CLIENT_TRANSMISSION",
                 MessageType.CLIENT_DISCONNECT: "CLIENT_DISCONNECT",
                 MessageType.CLIENT_PING: "CLIENT_PING",
                 MessageType.SERVER_ANNOUNCE: "SERVER_ANNOUNCE",
                 MessageType.SERVER_RESPONSE: "SERVER_RESPONSE",
                 MessageType.SERVER_DISCONNECT: "SERVER_DISCONNECT",
                 MessageType.SERVER_TRANSMISSION: "SERVER_TRANSMISSION",
                 }
        try:
            return names[type]
        except KeyError:
            return "unkown(%s)" % type

class ChannelType:
    BROADCAST = 0
    NORMAL = 1
    CHATTER = 2
    GAMEPLAY = 3
    SERVER = 4
    
    @staticmethod
    def type2str(type):
        names = {
                 ChannelType.BROADCAST: "BROADCAST",
                 ChannelType.NORMAL: "NORMAL",
                 ChannelType.CHATTER: "CHATTER",
                 ChannelType.GAMEPLAY: "GAMEPLAY",
                 ChannelType.SERVER: "SERVER",
                 }
        try:
            return names[type]
        except KeyError:
            return "unkown(%s)" % type



class Packet(object):
    message = None
    channel = None
    data = None
    
    def encode(self):
        ## Message Type
        ## type: 8-bit char[]
        ## byte length : 2
        str = self.message[0:2]
        ## Data length
        ## type: 32-bit signed int (big-endian)
        ## byte 4
        str += pack('>i', len(self.data))
        ## Data
        ## type: 8-bit char[N]
        ## byte length : N
        str += self.data.encode('utf-8')
        return str
    
    def decode(self, packet):
        if len(packet) <= 7:
            raise ValueError, "too few data to extract a packet"
        
        ## Message Type
        ## type: 8-bit char[]
        ## byte length : 2
        self.message = packet[0:2]
        ## Message Type
        ## type: 8-bit byte
        ## byte length : 1
        (self.channel,) = unpack('>B', packet[2])
        ## Data length
        ## type: 32-bit signed int (big-endian)
        ## byte 4
        datalength = Packet.decodeIncomingPacketSize(packet)
        ## Data
        ## type: 8-bit char[N]
        ## byte length : N
        str = packet[7:7+datalength]
        self.data = str.decode('utf-8')
        
    @staticmethod
    def decodeIncomingPacketSize(packet):
        ## Data length
        ## type: 32-bit signed int (big-endian)
        ## byte 4
        return unpack('>i', packet[3:7])[0]
    
    def getMessageTypeAsStr(self):
        return MessageType.type2str(self.message)
    
    def getChannelTypeAsStr(self):
        return ChannelType.type2str(self.channel)
    
    def __str__(self):
        return "[Message: %s], [Channel: %s], [Data: %s]" % (self.getMessageTypeAsStr(), self.getChannelTypeAsStr(), self.data)



class Client(asyncore.dispatcher_with_send):

    def __init__(self, console, host, port, password, keepalive=False):
        asyncore.dispatcher_with_send.__init__(self)
        self.console = console
        self._host = host
        self._port = port
        self._password = password
        self.keepalive = keepalive
        self._buffer_in = ''
        self.authed = False
        self.server_version = None
        self.last_pong_time = self.last_ping_time = time.time()
        self._handlers = set()
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect( (self._host, self._port) )
        
    def handle_connect(self):
        self.console.verbose('Now connected to Homefront gameserver')
        self.login()
        self.ping()
        pass

    def handle_close(self):
        self.console.verbose('Connection to Homefront gameserver closed')
        self.close()
        self.authed = False
        if self.keepalive:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connect((self._host, self._port))

    def handle_read(self):
        data = self.recv(8192)
        self.console.verbose2('read %s char from Homefront gameserver' % len(data))
        self._buffer_in += data
        p = self._readPacket()
        while p is not None:
            for handler in self._handlers:
                try:
                    handler(p)
                except Exception, err:
                    self.console.exception(err)
            p = self._readPacket()

    def add_listener(self, handler):
        self._handlers.add(handler)
        return self
    
    def remove_listener(self, handler):
        try:
            self._handlers.remove(handler)
        except:
            raise ValueError("Handler is not handling this event, so cannot unhandle it.")
        return self            
            
    def login(self):
        """authenticate to the server
        
        Message Type: ClientTransmission
        Format : PASS: "[string: SHA1Hash]"
        SHA1Hash: A 60 byte ASCII string with a 40-bit SHA1 Hash converted to 
            uppercase hexadecimal text and spaces inserted between each pair.
        """
        def twobytwo(str):
            i = 0
            while i < len(str):
                yield str[i:i+2]
                i+=2
        sha1_pass_bytes = sha1(self._password).hexdigest()
        self.command('PASS: "%s"' % ' '.join(twobytwo(sha1_pass_bytes.upper())))

    def ping(self):
        """used to keep the connection alive. After 10 seconds of inactivity
        the server will drop the connection"""
        packet = Packet()
        packet.message = MessageType.CLIENT_PING
        packet.data = "PING"
        try:
            self.send(packet.encode())
            self.last_ping_time = time.time()
        except socket.error, e:
            self.console.error(repr(e))
    
    def command(self, text):
        """send command to server"""
        packet = Packet()
        packet.message = MessageType.CLIENT_TRANSMISSION
        packet.data = text
        try:
            self.send(packet.encode())
        except socket.error, e:
            self.console.error(repr(e))
        
    def _readPacket(self):
        if len(self._buffer_in) > 7:
            packetlength = Packet.decodeIncomingPacketSize(self._buffer_in)
            if len(self._buffer_in) >= 7 + packetlength:
                p = Packet()
                p.decode(self._buffer_in)
                self._buffer_in = self._buffer_in[7 + packetlength:]
                self._inspect_packet(p)
                return p

    def _inspect_packet(self, p):
        if p.data == "PONG":
            self.last_pong_time = time.time()
        elif p.channel == ChannelType.SERVER and p.data == "AUTH: true":
            self.authed = True
        elif p.channel == ChannelType.SERVER and p.data.startswith("HELLO: "):
            self.server_version = p.data[7:]
            
            
            
###################################################################################
# Example program

if __name__ == '__main__':
    import sys, logging
    from b3.output import OutputHandler
    
    if len(sys.argv) != 4:
        host = raw_input('Enter game server host IP/name: ')
        port = int(raw_input('Enter host port: '))
        pw = raw_input('Enter password: ')
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
        pw = sys.argv[3]
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(levelname)s\t%(message)s")
    handler.setFormatter(formatter)
    
    myConsole = OutputHandler('console')
    myConsole.addHandler(handler)
    myConsole.setLevel(logging.NOTSET)
    
    
    def packetListener(packet):
        myConsole.console(">>> %s" % packet)    
    
    myConsole.info('start client')
    hfclient = Client(myConsole, host, port, pw, keepalive=True)
    hfclient.add_listener(packetListener)
    
    try:
        while hfclient.connected or not hfclient.authed:
            #print("\t%s" % (time.time() - hfclient.last_pong_time))
            if time.time() - hfclient.last_pong_time > 6 and hfclient.last_ping_time < hfclient.last_pong_time:
                hfclient.ping()
                hfclient.command("RETRIEVE PLAYERLIST")
            asyncore.loop(timeout=3, count=1)
    except EOFError, KeyboardInterrupt:
        hfclient.close()
    
    myConsole.info('end')
    
    

########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 2011-04-17 - 1.0 - Courgette
# * add logging of sent commands

"""
dummy rcon module for Homefront to satisfy B3 parser. 

Ideally, B3 parser should be changed to allow games such as homefront to 
not require a separated socket connection for rcon commands

To use that Rcon class, instanciate and use the set_homefront_client() method. 
Then you can expect this class to work like the other Rcon classes
"""

__author__  = 'Courgette'
__version__ = '1.0'


#--------------------------------------------------------------------------------------------------
class Rcon:
    def __init__(self, console, *args):
        self.console = console
        self.hfclient = None
        
    def set_homefront_client(self, hfclient):
        self.hfclient = hfclient
    
    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        if not self.hfclient:
            return
        self.console.verbose(u'RCON :\t %s' % cmd)
        self.hfclient.command(cmd)
        
    def flush(self):
        pass

    def close(self):
        pass
            
            
if __name__ == '__main__':
    """
    To run tests : 
    cd c:\whereever\is\b3
    c:\python26\python.exe b3/parsers/homefront/rcon.py <rcon_ip> <rcon_port> <rcon_password>
    """
    import sys, time, asyncore, thread, threading
    from b3.fake import fakeConsole
    from protocol import Client as HomefrontClient

    if len(sys.argv) != 4:
        host = raw_input('Enter game server host IP/name: ')
        port = int(raw_input('Enter host port: '))
        pw = raw_input('Enter password: ')
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
        pw = sys.argv[3]
    
    
    def packetListener(packet):
        print(">>> received : %s" % packet)
    
    
    hfclient = HomefrontClient(fakeConsole, host, port, pw, keepalive=True)
    hfclient.add_listener(packetListener)
    working = True
    
    def run_hf_client(hfclient):
        print('start client')
        try:
            while working and (hfclient.connected or not hfclient.authed):
                #print("\t%s" % (time.time() - hfclient.last_pong_time))
                if time.time() - hfclient.last_pong_time > 6 and hfclient.last_ping_time < hfclient.last_pong_time:
                    hfclient.ping()
                asyncore.loop(timeout=3, count=1)
        except EOFError, KeyboardInterrupt:
            hfclient.close()
        print('end client')
    
    thread.start_new_thread(run_hf_client, (hfclient,))
    
    time.sleep(3)
    
    r = Rcon(fakeConsole, ("what", 1337), "ever")
    r.set_homefront_client(hfclient)
    
    def close_hf_connection():
        try:
            hfclient.close()
        except:
            pass
    t = threading.Timer(10.0, hfclient.close)
    t.start()
    
    print('-----------------------------> test command : say "B3 test"')
    r.write('say "B3 test"')  
    
    for i in range(30):
        hfclient.ping()
        time.sleep(.5)
    
    working = False
    
    print(".")

########NEW FILE########
__FILENAME__ = iourt41
#
# ioUrT Parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2008 Mark Weirath (xlr8or@xlr8or.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# v1.0.3 - Courgette added support for banlist.txt
#          xlr8or added parsing Damage (OnHit)
# v1.0.4 - xlr8or added EVT_CLIENT_TEAM_CHANGE in OnKill
# v1.0.5 - xlr8or added hitloc and damageType info to accomodate XLRstats
# v1.0.6 - Fixed a bug where the parser wouldn't parse the shutdowngame and warmup functions
# v1.0.7 - Better synchronizing and identification of connecting players and zombies
# v1.0.8 - Better Zombie handling (Zombies being a result of: sv_zombietime (default 2 seconds))
#          (Zombie time is the time after a disconnect that the slot cannot be used and thus is in Zombie state)
#          Added functionality to use ip's only, not using the guid at all (experimental)
# v1.0.9 - Try to get the map name at start
#           Provide getPlayerScores method
# v1.0.10 - Modified _reColor so name sanitation is the same as UrT. Here it does more than just remove color.
# v1.0.11 - Courgette - Add getScores  # NOTE: this won't work properly if the server has private slots. see http://forums.urbanterror.net/index.php/topic,9356.0.html
# v1.0.12 - Courgette - Fix regex that failed to parse chat lines when player's name ends with ':'
# v1.0.13 - xlr8or - support for !maps and !nextmap command
# v1.0.14 - xlr8or - better understanding of mapcycle.txt
# v1.0.15 - mindriot - 01-Nov-2008
# * client with empty name ("") resulted in error and B3 not registering client - now given _empty_name_default
# v1.0.16 - xlr8or - added IpCombi. Setting True will replace the last part of the guid with two segments of the ip
#                    Increases security on admins who have cl_guidServerUniq set to 0 in client config (No cloning).
# v1.0.17 - mindriot - 02-Nov-2008
# * _empty_name_default now only given upon client connect, due to possibility of no name specified in ClientUserinfo at any time
# v1.0.19 - xlr8or - Disabled PunkBuster default settings due to recent supportrequests in the forums with missing PB line in b3.xml
#
# v1.1.0 - xlr8or - Added Action Mechanism (event) for B3 v1.1.5+
# v1.1.1 - courgette
# * Debugged Action Mechanism (event) for B3 v1.1.5+
# v1.2.0 - 19/08/2009 - Courgette
# * adds slap, nuke, mute new custom penalty types (can be used in censor or admin plugin)
# * requires admin plugin v1.4+ and parser.py v1.10+
# v1.3.0 - 20/10/2009 - Courgette
# * upon bot start, already connected players are correctly recognized
# v1.4.0 - 26/10/2009 - Courgette
# * when no client is found by cid, try to join the player using /rcon dumpuser <cid>
# v1.5.0 - 11/11/2009 - Courgette
#    * create a new event: EVT_GAME_FLAG_RETURNED which is fired when the flag return because of time
#    * code refactoring
# v1.5.1 - 17/11/2009 - Courgette
#    * harden getNextMap by :
#      o wrapping initial getCvar queries with try:except bloc
#      o requerying required cvar if missing
#      o forcing map list refresh on server reload or round end
# v1.5.2 - 26/11/2009 - Courgette
#    * fix a bug that prevented kills by slap or nuke from firing kill events
# v1.6.1 - 30/11/2009 - Courgette
#    * separate parsing of lines ClientUserInfo and ClientUserInfoChanged to better translate 
#    ClientUserInfoChanged data. Also OnClientUserInfoChanged does not create new client if 
#    cid is unknown.
# v1.6.2 - 05/12/2009 - Courgette
#    * fix _rePlayerScore regexp
#    * on startup, also try to get players' team (which is not given by dumpuser)
# v1.6.3 - 06/12/2009 - Courgette
#    * harden queryClientUserInfoByCid making sure we got a positive response. (Never trust input data...)
#    * fix _rePlayerScore regexp again
# v1.6.4 - 06/12/2009 - Courgette
#    * sync() will retries to get player list up to 4 for times before giving up as
#      sync() after map change too often fail 2 times.
# v1.6.5 - 09/12/2009 - Courgette
#    * different handling of 'name' in OnClientuserinfo. Now log looks less worrying
#    * prevent exception on the rare case where a say line shows no text after cid (hence no regexp match)
# v1.7 - 21/12/2009 - Courgette
#    * add new UrT specific event : EVT_CLIENT_GEAR_CHANGE
# v1.7.1 - 30/12/2009 - Courgette
#    * Say, Sayteam and Saytell lines do not trigger name change anymore and detect the UrT bug described
#      in http://www.bigbrotherbot.net/forums/urt/b3-bot-sometimes-mix-up-client-id%27s/ . Hopefully this
#      definitely fixes the wrong aliases issue.
# v1.7.2 - 30/12/2009 - Courgette
#    * improve say lines slot bug detection for cases where no player exists on slot 0. 
#      Refactor detection code to follow the KISS rule (keep it simple and stupid)
# v1.7.3 - 31/12/2009 - Courgette
#    * fix bug getting client by name when UrT slot 0 bug 
#    * requires clients.py 1.2.8+
# v1.7.4 - 02/01/2010 - Courgette
#    * improve Urt slot bug workaround as it appears it can occur with slot num different than 0
# v1.7.5 - 05/01/2010 - Courgette
#    * fix minor bug in saytell
# v1.7.6 - 16/01/2010 - xlr8or
#    * removed maxRetries=4 keyword from getPlayerList()
# v1.7.7 - 16/01/2010 - Courgette
#    * put back maxRetries=4 keyword from getPlayerList(). @xlr8or: make sure you have the latest
#      q3a.py file (v1.3.1+) for maxRetries to work.
# v1.7.8 - 18/01/2010 - Courgette
#    * update getPlayerList and sync so that connecting players (CNCT) are not ignored.
#      This will allow to use commands like !ci or !kick on hanging players.
# v1.7.9 - 26/01/2010 - xlr8or
#    * moved getMap() to q3a.py
# v1.7.10 - 10/04/2010 - Bakes
#    * bigsay() function can be used by plugins.
# v1.7.11 - 15/04/2010 - Courgette
#    * add debugging info for getNextMap()
# v1.7.12 - 28/05/2010 - xlr8or
#    * connect bots
# v1.7.13 - 07/11/2010 - GrosBedo
#    * messages now support named $variables instead of %s
# v1.7.14 - 08/11/2010 - GrosBedo
#    * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# v1.7.15 - 21/12/2010 - SGT
#    * fix CNCT ping error in getPlayersPings
#    * fix incorrect game type for ffa
#    * move getMapList after game initialization
# v1.7.16 - 09/04/2011 - Courgette
#    * reflect that cid are not converted to int anymore in the clients module
# v1.7.17 - 03/05/2011 - Courgette
#     * reflect changes in inflictCustomPenalty method signature
# v1.8.0 - 31/05/2011 - Courgette
#     * Damage event now carry correct damage points
#     * Damage event weapon code is now the same as the one used for Kill events
# v1.8.1 / 1.8.2 - 01/06/2011 - Courgette
#     * fix Damage points
#     * when game log provides hit info, Kill event will use last damage points instead of 100
# v1.9.0 - 2011-06-04 - Courgette
#     * makes use of the new pluginsStarted parser hook
# v1.10.0 - 2011-06-05 - Courgette
#     * change data format for EVT_CLIENT_BAN events
# 14/06/2011 - 1.11.0 - Courgette
#     * cvar code moved to q3a AbstractParser
# 12/09/2011 - 1.11.1 - Courgette
#     * EVT_CLIENT_JOIN event is now triggered when player actually join a team
#     * the call to self.clients.sync() that was made each round is now made on game init and in its own thread
# 29/09/2011 - 1.11.2 - Courgette
#     * fix MOD_TELEFRAG attacker on kill event to prevent people from being considered
#       as tkers in such cases.
# 15/10/2011 - 1.11.3 - Courgette
#     * better team recognition of existing players at B3 start
# 15/11/2011 - 1.11.4 - Courgette
#     * players's team get refreshed after unpausing the bot (useful when used with FTP and B3 lose the connection for a while)
# 03/03/2012 - 1.11.5 - SGT
#     * Create Survivor Winner Event
#     * Create Unban event
#     * fix issue with OnSay when something like this come and the match couldn't find the name group, say: 7 -crespino-:
# 08/04/2012 - 1.12 - Courgette
#     * fixes rotatemap() - thanks to Beber888
#     * refactor unban()
#     * changeMap() can now provide suggestions
# 05/05/2012 - 1.13 - Courgette
#     * fixes issue xlr8or/big-brother-bot#87 - missing ip when trying to auth a client crashes the bot
# 19/05/2012 - 1.13.1 - Courgette
#     * fixes issue with kill events when killed by UT_MOD_SLAPPED, UT_MOD_NUKED, MOD_TELEFRAG
# 07/07/2012 - 1.13.2 - Courgette
#     * ensures the config file has option 'game_log' in section 'server'
# 12/08/2012 - 1.13.3 - Courgette
#     * fix !nextmap bug when the mapcycle file contains empty lines
# 19/10/2012 - 1.14 - Courgette
#     * improve finding the exact map in getMapsSoundingLike. Also improves changeMap() behavior as a consequence
# 26/11/2012 - 1.15 - Courgette
#     * protect some of the Client object property
#
__author__  = 'xlr8or, Courgette'
__version__ = '1.15'

import re, string, time, os, thread
from b3.parsers.q3a.abstractParser import AbstractParser
from b3.functions import soundex, levenshteinDistance, getStuffSoundingLike
import b3
import b3.events

#----------------------------------------------------------------------------------------------------------------------------------------------
class Iourt41Parser(AbstractParser):
    gameName = 'iourt41'
    IpsOnly = False
    IpCombi = False
    _maplist = None

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _empty_name_default = 'EmptyNameDefault'

    _commands = {}
    _commands['broadcast'] = '%(prefix)s^7 %(message)s'
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['saybig'] = 'bigtext "%(prefix)s %(message)s"'

    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'addip %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'
    _commands['banByIp'] = 'addip %(ip)s'
    _commands['unbanByIp'] = 'removeip %(ip)s'
    _commands['slap'] = 'slap %(cid)s'
    _commands['nuke'] = 'nuke %(cid)s'
    _commands['mute'] = 'mute %(cid)s %(seconds)s'

    _eventMap = {
        #'warmup' : b3.events.EVT_GAME_WARMUP,
        #'shutdowngame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 ClientUserinfo: 0:

    _lineFormats = (
        #Generated with ioUrbanTerror v4.1:
        #Hit: 12 7 1 19: BSTHanzo[FR] hit ercan in the Helmet
        #Hit: 13 10 0 8: Grover hit jacobdk92 in the Head
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<hitloc>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>.*))$', re.IGNORECASE),
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<hitloc>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>(?P<aname>[^:])\shit\s(?P<name>[^:])\sin\sthe(?P<locname>.*)))$', re.IGNORECASE),

        #6:37 Kill: 0 1 16: XLR8or killed =lvl1=Cheetah by UT_MOD_SPAS
        #2:56 Kill: 14 4 21: Qst killed Leftovercrack by UT_MOD_PSG1
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>.*))$', re.IGNORECASE),
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>(?P<aname>[^:])\skilled\s(?P<name>[^:])\sby\s(?P<modname>.*)))$', re.IGNORECASE),

        #Processing chats and tell events...
        #5:39 saytell: 15 16 repelSteeltje: nno
        #5:39 saytell: 15 15 repelSteeltje: nno
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<name>[^ ]+):\s+(?P<text>.*))$', re.IGNORECASE),

        # We're not using tell in this form so this one is disabled
        #5:39 tell: repelSteeltje to B!K!n1: nno
        #re.compile(r'^(?P<action>[a-z]+):\s+(?P<data>(?P<name>[^:]+)\s+to\s+(?P<aname>[^:]+):\s+(?P<text>.*))$', re.IGNORECASE),

        #3:53 say: 8 denzel: lol
        #15:37 say: 9 .:MS-T:.BstPL: this name is quite a challenge
        #2:28 sayteam: 12 New_UrT_Player_v4.1: woekele
        #16:33 Flag: 2 0: team_CTF_redflag
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<name>[^ ]+):\s+(?P<text>.*))$', re.IGNORECASE),
        # SGT: fix issue with OnSay when something like this come and the match could'nt find the name group
        # say: 7 -crespino-:
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<name>[^ ]+):\s*(?P<text>.*))$', re.IGNORECASE),

        #15:42 Flag Return: RED
        #15:42 Flag Return: BLUE
        re.compile(r'^(?P<action>Flag Return):\s(?P<data>(?P<color>.+))$', re.IGNORECASE),

        #Bombmode actions:
        #3:06 Bombholder is 2
        re.compile(r'^(?P<action>Bombholder)(?P<data>\sis\s(?P<cid>[0-9]))$', re.IGNORECASE),
        #was planted, was defused, was tossed, has been collected (doh, how gramatically correct!)
        #2:13 Bomb was tossed by 2
        #2:32 Bomb was planted by 2
        #3:01 Bomb was defused by 3!
        #2:17 Bomb has been collected by 2
        re.compile(r'^(?P<action>Bomb)\s(?P<data>(was|has been)\s(?P<subaction>[a-z]+)\sby\s(?P<cid>[0-9]+).*)$', re.IGNORECASE),

        #Falling thru? Item stuff and so forth
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>.*)$', re.IGNORECASE),
        #Shutdowngame and Warmup... the one word lines
        re.compile(r'^(?P<action>[a-z]+):$', re.IGNORECASE)
    )

    # map: ut4_casa
    # num score ping name            lastmsg address               qport rate
    # --- ----- ---- --------------- ------- --------------------- ----- -----
    #   2     0   19 ^1XLR^78^8^9or^7        0 145.99.135.227:27960  41893  8000  # player with a live ping
    #   4     0 CNCT Dz!k^7                450 83.175.191.27:64459   50308 20000  # connecting player (or inbetween rounds)
    #   9     0 ZMBI ^7                   1900 81.178.80.68:27960    10801  8000  # zombies (need to be disconnected!)
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+|CNCT|ZMBI)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    # Map: ut4_algiers
    # Players: 8
    # Scores: R:97 B:98
    # 0:  FREE k:0 d:0 ping:0
    # 4: yene RED k:16 d:8 ping:50 92.104.110.192:63496
    _reTeamScores = re.compile(r'^Scores:\s+R:(?P<RedScore>.+)\s+B:(?P<BlueScore>.+)$', re.I)
    _rePlayerScore = re.compile(r'^(?P<slot>[0-9]+): (?P<name>.*) (?P<team>RED|BLUE|SPECTATOR|FREE) k:(?P<kill>[0-9]+) d:(?P<death>[0-9]+) ping:(?P<ping>[0-9]+|CNCT|ZMBI)( (?P<ip>[0-9.]+):(?P<port>[0-9-]+))?$', re.I) # NOTE: this won't work properly if the server has private slots. see http://forums.urbanterror.net/index.php/topic,9356.0.html


    PunkBuster = None

    ## kill modes
    MOD_WATER='1'
    MOD_LAVA='3'
    MOD_TELEFRAG='5'
    MOD_FALLING='6'
    MOD_SUICIDE='7'
    MOD_TRIGGER_HURT='9'
    MOD_CHANGE_TEAM='10'
    UT_MOD_KNIFE='12'
    UT_MOD_KNIFE_THROWN='13'
    UT_MOD_BERETTA='14'
    UT_MOD_DEAGLE='15'
    UT_MOD_SPAS='16'
    UT_MOD_UMP45='17'
    UT_MOD_MP5K='18'
    UT_MOD_LR300='19'
    UT_MOD_G36='20'
    UT_MOD_PSG1='21'
    UT_MOD_HK69='22'
    UT_MOD_BLED='23'
    UT_MOD_KICKED='24'
    UT_MOD_HEGRENADE='25'
    UT_MOD_SR8='28'
    UT_MOD_AK103='30'
    UT_MOD_SPLODED='31'
    UT_MOD_SLAPPED='32'
    UT_MOD_BOMBED='33'
    UT_MOD_NUKED='34'
    UT_MOD_NEGEV='35'
    UT_MOD_HK69_HIT='37'
    UT_MOD_M4='38'
    UT_MOD_FLAG='39'
    UT_MOD_GOOMBA='40'
    
    ## weapons id on Hit: lines are different than the one
    ## on the Kill: lines. Here the translation table
    hitweapon2killweapon = {
        1: UT_MOD_KNIFE,
        2: UT_MOD_BERETTA,
        3: UT_MOD_DEAGLE,
        4: UT_MOD_SPAS,
        5: UT_MOD_MP5K,
        6: UT_MOD_UMP45,
        8: UT_MOD_LR300,
        9: UT_MOD_G36,
        10: UT_MOD_PSG1,
        14: UT_MOD_SR8,
        15: UT_MOD_AK103,
        17: UT_MOD_NEGEV,
        19: UT_MOD_M4,
        21: UT_MOD_HEGRENADE,
        22: UT_MOD_KNIFE_THROWN,
    }

    """ From data provided by Garreth http://bit.ly/jf4QXc on http://bit.ly/krwBCv :

                                Head(0) Helmet(1)     Torso(2)     Kevlar(3)     Arms(4)    Legs(5)    Body(6)    Killed
    MOD_TELEFRAG='5'             0        0             0             0             0         0         0         0
    UT_MOD_KNIFE='12'           100      60            44            35            20        20        44        100
    UT_MOD_KNIFE_THROWN='13'    100      60            44            35            20        20        44        100
    UT_MOD_BERETTA='14'         100      34            30            20            11        11        30        100
    UT_MOD_DEAGLE='15'          100      66            57            38            22        22        57        100
    UT_MOD_SPAS='16'            25       25            25            25            25        25        25        100
    UT_MOD_UMP45='17'           100      51            44            29            17        17        44        100
    UT_MOD_MP5K='18'            50       34            30            20            11        11        30        100
    UT_MOD_LR300='19'           100      51            44            29            17        17        44        100
    UT_MOD_G36='20'             100      51            44            29            17        17        44        100
    UT_MOD_PSG1='21'            100      63            97            63            36        36        97        100
    UT_MOD_HK69='22'            50       50            50            50            50        50        50        100
    UT_MOD_BLED='23'            15       15            15            15            15        15        15        15
    UT_MOD_KICKED='24'          20       20            20            20            20        20        20        100
    UT_MOD_HEGRENADE='25'       50       50            50            50            50        50        50        100
    UT_MOD_SR8='28'             100      100           100           100           50        50        100       100
    UT_MOD_AK103='30'           100      58            51            34            19        19        51        100
    UT_MOD_NEGEV='35'           50       34            30            20            11        11        30        100
    UT_MOD_HK69_HIT='37'        20       20            20            20            20        20        20        100
    UT_MOD_M4='38'              100      51            44            29            17        17        44        100
    UT_MOD_GOOMBA='40'          100      100           100           100           100       100       100       100
    """
    damage = {
        MOD_TELEFRAG: [0, 0, 0, 0, 0, 0, 0, 0],
        UT_MOD_KNIFE: [100, 60, 44, 35, 20, 20, 44, 100],
        UT_MOD_KNIFE_THROWN: [100, 60, 44, 35, 20, 20, 44, 100],
        UT_MOD_BERETTA: [100, 34, 30, 20, 11, 11, 30, 100],
        UT_MOD_DEAGLE: [100, 66, 57, 38, 22, 22, 57, 100],
        UT_MOD_SPAS: [25, 25, 25, 25, 25, 25, 25, 100],
        UT_MOD_UMP45: [100, 51, 44, 29, 17, 17, 44, 100],
        UT_MOD_MP5K: [50, 34, 30, 20, 11, 11, 30, 100],
        UT_MOD_LR300: [100, 51, 44, 29, 17, 17, 44, 100],
        UT_MOD_G36: [100, 51, 44, 29, 17, 17, 44, 100],
        UT_MOD_PSG1: [100, 63, 97, 63, 36, 36, 97, 100],
        UT_MOD_HK69: [50, 50, 50, 50, 50, 50, 50, 100],
        UT_MOD_BLED: [15, 15, 15, 15, 15, 15, 15, 15],
        UT_MOD_KICKED: [20, 20, 20, 20, 20, 20, 20, 100],
        UT_MOD_HEGRENADE: [50, 50, 50, 50, 50, 50, 50, 100],
        UT_MOD_SR8: [100, 100, 100, 100, 50, 50, 100, 100],
        UT_MOD_AK103: [100, 58, 51, 34, 19, 19, 51, 100],
        UT_MOD_NEGEV: [50, 34, 30, 20, 11, 11, 30, 100],
        UT_MOD_HK69_HIT: [20, 20, 20, 20, 20, 20, 20, 100],
        UT_MOD_M4: [100, 51, 44, 29, 17, 17, 44, 100],
        UT_MOD_GOOMBA: [100, 100, 100, 100, 100, 100, 100, 100],
     }

    def startup(self):
        if not self.config.has_option('server','game_log'):
            self.critical("your main config file is missing the 'game_log' setting in section 'server'")
            raise SystemExit(220)

        # add UrT specific events
        self.Events.createEvent('EVT_GAME_FLAG_RETURNED', 'Flag returned')
        self.Events.createEvent('EVT_CLIENT_GEAR_CHANGE', 'Client gear change')
        self.Events.createEvent('EVT_SURVIVOR_WIN', 'Survivor Winner')
        
        # add the world client
        self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')

        # PunkBuster for iourt is not supported!
        #if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
        #    self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map_name = self.getMap()
        if map_name:
            self.game.mapName = map_name
            self.info('map is: %s'%self.game.mapName)

        # get gamepaths/vars
        try:
            self.game.fs_game = self.getCvar('fs_game').getString()
        except:
            self.game.fs_game = None
            self.warning("Could not query server for fs_game")

        try:
            self.game.fs_basepath = self.getCvar('fs_basepath').getString().rstrip('/')
            self.debug('fs_basepath: %s' % self.game.fs_basepath)
        except:
            self.game.fs_basepath = None
            self.warning("Could not query server for fs_basepath")

        try:
            self.game.fs_homepath = self.getCvar('fs_homepath').getString().rstrip('/')
            self.debug('fs_homepath: %s' % self.game.fs_homepath)
        except:
            self.game.fs_homepath = None
            self.warning("Could not query server for fs_homepath")

        self._maplist = self.getMaps()

    def pluginsStarted(self):
        # initialize connected clients
        plist = self.getPlayerList()
        for cid in plist.keys():
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)
        
        player_teams = {}
        tries = 0
        while tries < 3:
            try:
                tries += 1
                player_teams = self.getPlayerTeams()
                break
            except Exception as err:
                if tries < 3:
                    self.warning(err)
                else:
                    self.error("cannot fix players teams : %s" % err) 
        for cid in plist.keys():
            client = self.clients.getByCID(cid)
            if client and client.cid in player_teams:
                newteam = player_teams[client.cid]
                if newteam != client.team:
                    self.debug('Fixing client team for %s : %s is now %s' % (client.name, client.team, newteam))
                    setattr(client, 'team', newteam)
            
    def unpause(self):
        self.pluginsStarted() # so we get teams refreshed
        self.clients.sync()
        b3.parser.Parser.unpause(self)

    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            try:
                data = m.group('data').strip()
            except:
                data = None
            return (m, m.group('action').lower(), data, client, target)
        elif '------' not in line:
            self.verbose('line did not match format: %s' % line)

    def parseUserInfo(self, info):
        """Just extract the cid and pairs of key/value without any treatment"""
        #2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65
        #7 n\[SNT]^1XLR^78or\t\3\r\2\tl\0\f0\\f1\\f2\\a0\0\a1\0\a2\0
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID
        return data


    def getTeam(self, team):
        if str(team).lower() == 'red':
            team = 1
        elif str(team).lower() == 'blue':
            team = 2
        elif str(team).lower() == 'spectator':
            team = 3
        elif str(team).lower() == 'free':
            team = -1 # will fall back to b3.TEAM_UNKNOWN
        
        team = int(team)
        if team == 1:
            result = b3.TEAM_RED
        elif team == 2:
            result = b3.TEAM_BLUE
        elif team == 3:
            result = b3.TEAM_SPEC
        else:
            result = b3.TEAM_UNKNOWN
            
        #self.debug('getTeam(%s) -> %s' % (team, result))
        return result

    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)

        if gameTypeInt == '0':
            _gameType = 'ffa'
        elif gameTypeInt == '1':   # Dunno what this one is
            _gameType = 'dm'
        elif gameTypeInt == '2':   # Dunno either
            _gameType = 'dm'
        elif gameTypeInt == '3':
            _gameType = 'tdm'
        elif gameTypeInt == '4':
            _gameType = 'ts'
        elif gameTypeInt == '5':
            _gameType = 'ftl'
        elif gameTypeInt == '6':
            _gameType = 'cah'
        elif gameTypeInt == '7':
            _gameType = 'ctf'
        elif gameTypeInt == '8':
            _gameType = 'bm'

        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    # self.console.broadcast, a variant on self.console.say in UrT. This will print to upper left, the server message area.
    def broadcast(self, msg):
        lines = []
        for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
            lines.append(self.getCommand('broadcast', prefix=self.msgPrefix, message=line))

        if len(lines):
            self.writelines(lines)

    def inflictCustomPenalty(self, type, client, reason=None, duration=None, admin=None, data=None):
        if type == 'slap' and client:
            cmd = self.getCommand('slap', cid=client.cid)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        elif type == 'nuke' and client:
            cmd = self.getCommand('nuke', cid=client.cid)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        elif type == 'mute' and client:
            if duration is None:
                seconds = 60
            else:
                seconds = round(float(b3.functions.time2minutes(duration) * 60), 0)

            # make sure to unmute first
            cmd = self.getCommand('mute', cid=client.cid, seconds=0)
            self.write(cmd)
            # then mute
            cmd = self.getCommand('mute', cid=client.cid, seconds=seconds)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        # elif type == 'morron' and client:
            # client.message('you morron')
            # return True



    ###############################################################################################
    #
    #    Events handlers
    #
    ###############################################################################################

    # Connect/Join
    def OnClientconnect(self, action, data, match=None):
        self.debug('Client Connected - ready to parse Userinfoline')
        #client = self.clients.getByCID(data)
        #return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)

    def OnClientbegin(self, action, data, match=None):
        # we get user info in two parts:
        # 19:42.36 ClientBegin: 4
        client = self.getByCidOrJoinPlayer(data)
        if client:
            return b3.events.Event(b3.events.EVT_CLIENT_JOIN, data=data, client=client)

    # Parse Userinfo
    def OnClientuserinfo(self, action, data, match=None):
        #2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65
        #conecting bot:
        #0 \gear\GMIORAA\team\blue\skill\5.000000\characterfile\bots/ut_chicken_c.c\color\4\sex\male\race\2\snaps\20\rate\25000\name\InviteYourFriends!
        bclient = self.parseUserInfo(data)
        
        if not bclient.has_key('cl_guid') and bclient.has_key('skill'):
            # must be a bot connecting
            self.bot('Bot Connecting!')
            bclient['ip'] = '0.0.0.0'
            bclient['cl_guid'] = 'BOT' + str(bclient['cid'])

        if bclient.has_key('name'):
            # remove spaces from name
            bclient['name'] = bclient['name'].replace(' ','')


        # split port from ip field
        if bclient.has_key('ip'):
            ipPortData = string.split(bclient['ip'], ':', 1)
            bclient['ip'] = ipPortData[0]
            if len(ipPortData) > 1:
                bclient['port'] = ipPortData[1] 

        if bclient.has_key('team'):
            bclient['team'] = self.getTeam(bclient['team'])

        if bclient.has_key('cl_guid') and not bclient.has_key('pbid') and self.PunkBuster:
            bclient['pbid'] = bclient['cl_guid']

        self.verbose('Parsed user info %s' % bclient)
        
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    if hasattr(client, 'gear') and k == 'gear' and client.gear != v:
                        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_GEAR_CHANGE, v, client))
                    if not k.startswith('_') and k not in ('login', 'password', 'groupBits', 'maskLevel', 'autoLogin', 'greeting'):
                        setattr(client, k, v)
            else:
                #make a new client
                if self.PunkBuster:
                    # we will use punkbuster's guid
                    guid = None
                else:
                    # use io guid
                    if bclient.has_key('cl_guid'):
                        guid = bclient['cl_guid']
                    else:
                        guid = 'unknown'

                # v1.0.17 - mindriot - 02-Nov-2008
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if not bclient.has_key('ip'):
                    if guid == 'unknown':
                        # happens when a client is (temp)banned and got kicked so client was destroyed, but
                        # infoline was still waiting to be parsed.
                        self.debug('Client disconnected. Ignoring.')
                        return None
                    else:
                        # see issue xlr8or/big-brother-bot#87 - ip can be missing
                        try:
                            self.debug("missing IP, trying to get ip with 'status'")
                            plist = self.getPlayerList()
                            client_data = plist[bclient['cid']]
                            bclient['ip'] = client_data['ip']
                        except Exception, err:
                            bclient['ip'] = ''
                            self.warning("Failed to get client %s ip address." % bclient['cid'], err)



                nguid = ''
                # overide the guid... use ip's only if self.console.IpsOnly is set True.
                if self.IpsOnly:
                    nguid = bclient['ip']
                # replace last part of the guid with two segments of the ip
                elif self.IpCombi:
                    i = bclient['ip'].split('.')
                    d = len(i[0])+len(i[1])
                    nguid = guid[:-d]+i[0]+i[1]
                # Quake clients don't have a cl_guid, we'll use ip instead
                elif guid == 'unknown':
                    nguid = bclient['ip']

                if nguid != '':
                    guid = nguid

                client = self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid })

        return None

    # when userinfo changes
    def OnClientuserinfochanged(self, action, data, match=None):
        #7 n\[SNT]^1XLR^78or\t\3\r\2\tl\0\f0\\f1\\f2\\a0\0\a1\0\a2\0
        parseddata = self.parseUserInfo(data)

        if parseddata:
            client = self.clients.getByCID(parseddata['cid'])

            if client:
                # update existing client
                if parseddata.has_key('n'):
                    setattr(client, 'name', parseddata['n'])
                
                if parseddata.has_key('t'):
                    team = self.getTeam(parseddata['t'])
                    setattr(client, 'team', team)
                
                    if parseddata.has_key('r'):
                        if team == b3.TEAM_BLUE:
                            setattr(client, 'raceblue', parseddata['r'])
                        elif team == b3.TEAM_RED:
                            setattr(client, 'racered', parseddata['r'])
                    if parseddata.has_key('f0') and parseddata['f0'] is not None \
                            and parseddata.has_key('f1') and parseddata['f1'] is not None \
                            and parseddata.has_key('f2') and parseddata['f2'] is not None :
                        data = "%s,%s,%s" % (parseddata['f0'], parseddata['f1'], parseddata['f2'])
                        if team == b3.TEAM_BLUE:
                            setattr(client, 'funblue', data)
                        elif team == b3.TEAM_RED:
                            setattr(client, 'funred', data)
                        
                if parseddata.has_key('a0') and parseddata.has_key('a1') and parseddata.has_key('a2'):
                    setattr(client, 'cg_rgb', "%s %s %s" % (parseddata['a0'], parseddata['a1'], parseddata['a2']))
                    
        return None

    # damage
    #Hit: 13 10 0 8: Grover hit jacobdk92 in the Head
    #Hit: cid acid hitloc aweap: text
    def OnHit(self, action, data, match=None):
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        attacker = self.clients.getByCID(match.group('acid'))
        if not attacker:
            self.debug('No attacker')
            return None

        event = b3.events.EVT_CLIENT_DAMAGE

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_DAMAGE_SELF
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_DAMAGE_TEAM

        hitloc = match.group('hitloc')
        weapon = self._convertHitWeaponToKillWeapon(match.group('aweap'))
        points = self._getDamagePoints(weapon, hitloc)
        event_data = (points, weapon, hitloc)
        victim.data['lastDamageTaken'] = event_data
        #victim.state = b3.STATE_ALIVE
        # need to pass some amount of damage for the teamkill plugin - 15 seems okay
        return self.getEvent(event, event_data, attacker, victim)

    # kill
    #6:37 Kill: 0 1 16: XLR8or killed =lvl1=Cheetah by UT_MOD_SPAS
    #6:37 Kill: 7 7 10: Mike_PL killed Mike_PL by MOD_CHANGE_TEAM
    #kill: acid cid aweap: <text>
    def OnKill(self, action, data, match=None):
        # kill modes caracteristics :
        """
        1:      MOD_WATER === exclusive attackers : , 1022(<world>), 0(<non-client>)
        3:      MOD_LAVA === exclusive attackers : , 1022(<world>), 0(<non-client>)
        5:      MOD_TELEFRAG --- normal kill line
        6:      MOD_FALLING === exclusive attackers : , 1022(<world>), 0(<non-client>)
        7:      MOD_SUICIDE ===> attacker is always the victim
        9:      MOD_TRIGGER_HURT === exclusive attackers : , 1022(<world>)
        10:     MOD_CHANGE_TEAM ===> attacker is always the victim
        12:     UT_MOD_KNIFE --- normal kill line
        13:     UT_MOD_KNIFE_THROWN --- normal kill line
        14:     UT_MOD_BERETTA --- normal kill line
        15:     UT_MOD_DEAGLE --- normal kill line
        16:     UT_MOD_SPAS --- normal kill line
        17:     UT_MOD_UMP45 --- normal kill line
        18:     UT_MOD_MP5K --- normal kill line
        19:     UT_MOD_LR300 --- normal kill line
        20:     UT_MOD_G36 --- normal kill line
        21:     UT_MOD_PSG1 --- normal kill line
        22:     UT_MOD_HK69 --- normal kill line
        23:     UT_MOD_BLED --- normal kill line
        24:     UT_MOD_KICKED --- normal kill line
        25:     UT_MOD_HEGRENADE --- normal kill line
        28:     UT_MOD_SR8 --- normal kill line
        30:     UT_MOD_AK103 --- normal kill line
        31:     UT_MOD_SPLODED ===> attacker is always the victim
        32:     UT_MOD_SLAPPED ===> attacker is always the victim
        33:     UT_MOD_BOMBED --- normal kill line
        34:     UT_MOD_NUKED --- normal kill line
        35:     UT_MOD_NEGEV --- normal kill line
        37:     UT_MOD_HK69_HIT --- normal kill line
        38:     UT_MOD_M4 --- normal kill line
        39:     UT_MOD_FLAG === exclusive attackers : , 0(<non-client>)
        40:     UT_MOD_GOOMBA --- normal kill line
        """
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))

        victim = self.getByCidOrJoinPlayer(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in (self.UT_MOD_SLAPPED, self.UT_MOD_NUKED, self.MOD_TELEFRAG):
            self.debug('OnKill: slap/nuke => attacker should be None')
            attacker = self.clients.getByCID('-1') # make the attacker 'World'
        elif match.group('aweap') in (self.MOD_WATER,self.MOD_LAVA,self.MOD_FALLING,self.MOD_TRIGGER_HURT,self.UT_MOD_BOMBED,self.UT_MOD_FLAG):
            # those kills should be considered suicides
            self.debug('OnKill: water/lava/falling/trigger_hurt/bombed/flag should be suicides')
            attacker = victim
        else:
            attacker = self.getByCidOrJoinPlayer(match.group('acid'))
        ## end fix attacker

        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            if weapon == self.MOD_CHANGE_TEAM:
                """
                Do not pass a teamchange event here. That event is passed
                shortly after the kill.
                """
                self.verbose('Team Change Event Caught, exiting')
                return None
            else:
                event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not logging damage we need a general hitloc (for xlrstats)
        if 'lastDamageTaken' in victim.data:
            lastDamageData = victim.data['lastDamageTaken']
            del victim.data['lastDamageTaken']
        else:
            lastDamageData = (100, weapon, 'body')

        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return self.getEvent(event, (lastDamageData[0], weapon, lastDamageData[2], dType), attacker, victim)

    # disconnect
    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

#--- Action Mechanism (new in B3 version 1.1.5) --------------------------------
    def OnFlag(self, action, data, match=None):
        #Flag: 1 2: team_CTF_blueflag
        #Flag: <_cid> <_subtype:0/1/2>: <text>
        _cid = match.group('cid')
        _subtype = int(match.group('name'))
        data = match.group('text')

        if _subtype == 0:
            _actiontype = 'flag_dropped'
        elif _subtype == 1:
            _actiontype = 'flag_returned'
        elif _subtype == 2:
            _actiontype = 'flag_captured'
        else:
            return None
        return self.OnAction(_cid, _actiontype, data)

    def OnFlagReturn(self, action, data, match=None):
        #Flag Return: RED
        #Flag Return: BLUE
        #Flag Return: <color>
        color = match.group('color')
        return b3.events.Event(b3.events.EVT_GAME_FLAG_RETURNED, color)

    def OnBomb(self, action, data, match=None):
        _cid = match.group('cid')
        _subaction = match.group('subaction')
        if _subaction == 'planted':
            _actiontype = 'bomb_planted'
        elif _subaction == 'defused':
            _actiontype = 'bomb_defused'
        elif _subaction == 'tossed':
            _actiontype = 'bomb_tossed'
        elif _subaction == 'collected':
            _actiontype = 'bomb_collected'
        else:
            return None
        return self.OnAction(_cid, _actiontype, data)

    def OnBombholder(self, action, data, match=None):
        _cid = match.group('cid')
        _actiontype = 'bomb_holder_spawn'
        return self.OnAction(_cid, _actiontype, data)

    # Action
    def OnAction(self, cid, actiontype, data, match=None):
        #Need example
        client = self.clients.getByCID(cid)
        if not client:
            self.debug('No client found')
            return None
        self.verbose('OnAction: %s: %s %s' % (client.name, actiontype, data) )
        return b3.events.Event(b3.events.EVT_CLIENT_ACTION, actiontype, client)

    # item
    def OnItem(self, action, data, match=None):
        #Item: 3 ut_item_helmet
        #Item: 0 team_CTF_redflag
        cid, item = string.split(data, ' ', 1)
        client = self.getByCidOrJoinPlayer(cid)
        if client:
            #correct flag/bomb-pickups
            if 'flag' in item or 'bomb' in item:
                self.verbose('Itempickup corrected to action: %s' %item)
                return self.OnAction(cid, item, data)
            #self.verbose('OnItem: %s picked up %s' % (client.name, item) )
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, item, client)
        return None

    # survivor winner
    def OnSurvivorwinner(self, action, data, match=None):
        #SurvivorWinner: Blue
        #SurvivorWinner: Red
        self.debug('EVENT: OnSurvivorwinner')
        return b3.events.Event(b3.events.EVT_SURVIVOR_WIN, data)  
        
#-------------------------------------------------------------------------------
    # say
    def OnSay(self, action, data, match=None):
        #3:53 say: 8 denzel: lol
        
        if match is None:
            return
        
        name = self.stripColors(match.group('name'))
        cid = int(match.group('cid'))
        client = self.getByCidOrJoinPlayer(match.group('cid'))

        if not client or client.name != name:
            self.debug('UrT bug spotted. Trying to get client by name')
            client = self.clients.getByName(name)

        if not client:
            self.verbose('No Client Found!')
            return None
                
        self.verbose('Client Found: %s on slot %s' % (client.name, client.cid))
        
        data = match.group('text')

        #removal of weird characters
        if data and ord(data[:1]) == 21:
            data = data[1:]

        return b3.events.Event(b3.events.EVT_CLIENT_SAY, data, client)


    # sayteam
    def OnSayteam(self, action, data, match=None):
        #2:28 sayteam: 12 New_UrT_Player_v4.1: wokele
        if match is None:
            return
        
        name = self.stripColors(match.group('name'))
        cid = int(match.group('cid'))
        client = self.getByCidOrJoinPlayer(match.group('cid'))

        if not client or client.name != name:
            self.debug('UrT bug spotted. Trying to get client by name')
            client = self.clients.getByName(name)

        if not client:
            self.verbose('No Client Found!')
            return None
                
        self.verbose('Client Found: %s on slot %s' % (client.name, client.cid))
        
        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, data, client, client.team)


    # saytell
    def OnSaytell(self, action, data, match=None):
        #5:39 saytell: 15 16 repelSteeltje: nno
        #5:39 saytell: 15 15 repelSteeltje: nno

        #data = match.group('text')
        #if not len(data) >= 2 and not (data[:1] == '!' or data[:1] == '@') and match.group('cid') == match.group('acid'):
        #    return None

        if match is None:
            return
        
        name = self.stripColors(match.group('name'))
        cid = int(match.group('cid'))
        client = self.getByCidOrJoinPlayer(match.group('cid'))
        tclient = self.clients.getByCID(match.group('acid'))

        if not client or client.name != name:
            self.debug('UrT bug spotted. Trying to get client by name')
            client = self.clients.getByName(name)

        if not client:
            self.verbose('No Client Found!')
            return None
                
        self.verbose('Client Found: %s on slot %s' % (client.name, client.cid))

        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        return b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, data, client, tclient)



    # tell
    def OnTell(self, action, data, match=None):
        #5:27 tell: woekele to XLR8or: test
        #We'll use saytell instead
        return None
        """-------------------------------------------------------------------------------
        client = self.clients.getByExactName(match.group('name'))
        tclient = self.clients.getByExactName(match.group('aname'))

        if not client:
            self.verbose('No Client Found')
            return None

        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, data, client, tclient)
        -------------------------------------------------------------------------------"""

    # endmap/shutdown
    def OnShutdowngame(self, action, data=None, match=None):
        self.debug('EVENT: OnShutdowngame')
        self.game.mapEnd()
        # self.clients.sync()
        # self.debug('Synchronizing client info')
        self._maplist = None # when UrT server reloads, newly uploaded maps get available: force refresh
        return b3.events.Event(b3.events.EVT_GAME_EXIT, data)

    # Startgame
    def OnInitgame(self, action, data, match=None):
        self.debug('EVENT: OnInitgame')
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        # capturelimit / fraglimit / timelimit
        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            elif o[0] == 'capturelimit':
                self.game.captureLimit = o[1]
            elif o[0] == 'fraglimit':
                self.game.fragLimit = o[1]
            elif o[0] == 'timelimit':
                self.game.timeLimit = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startMap()
        self.game.rounds = 0
        thread.start_new_thread(self.clients.sync, ())
        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)


    # Warmup
    def OnWarmup(self, action, data=None, match=None):
        self.debug('EVENT: OnWarmup')
        self.game.rounds = 0
        return b3.events.Event(b3.events.EVT_GAME_WARMUP, data)

    # Start Round
    def OnInitround(self, action, data, match=None):
        self.debug('EVENT: OnInitround')
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        # capturelimit / fraglimit / timelimit
        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            elif o[0] == 'capturelimit':
                self.game.captureLimit = o[1]
            elif o[0] == 'fraglimit':
                self.game.fragLimit = o[1]
            elif o[0] == 'timelimit':
                self.game.timeLimit = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)


    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #
    ###############################################################################################

    def saybig(self, msg):
        lines = []
        for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
            lines.append(self.getCommand('saybig', prefix=self.msgPrefix, message=line))

        if len(lines):
            self.writelines(lines)

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, b3.clients.Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('ban', cid=client, reason=reason))
            return
        elif not client.id:
            # no client id, database must be down, do tempban
            self.error('Q3AParser.ban(): no client id, database must be down, doing tempban')
            return self.tempban(client, reason, '1d', admin, silent)

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))

        if client.cid is None:
            # ban by ip, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByIp', ip=client.ip, reason=reason))
            self.write(self.getCommand('banByIp', ip=client.ip, reason=reason))
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', cid=client.cid, reason=reason))
            self.write(self.getCommand('ban', cid=client.cid, reason=reason))

        if not silent and fullreason != '':
            self.say(fullreason)

        if admin:
            admin.message('^3banned^7: ^1%s^7 (^2@%s^7). His last ip (^1%s^7) has been added to banlist'%(client.exactName, client.id, client.ip))

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))
        client.disconnect()

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('EFFECTIVE UNBAN : %s',self.getCommand('unbanByIp', ip=client.ip, reason=reason))
        cmd = self.getCommand('unbanByIp', ip=client.ip, reason=reason)
        # UrT adds multiple instances to banlist.txt Make sure we remove up to 5 duplicates in a separate thread
        self.writelines([cmd, cmd, cmd, cmd, cmd])
        if admin:
            admin.message('^3Unbanned^7: ^1%s^7 (^2@%s^7). His last ip (^1%s^7) has been removed from banlist. Trying to remove duplicates...' % (client.exactName, client.id, client.ip))
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_UNBAN, admin, client))

    def getPlayerPings(self):
        data = self.write('status')
        if not data:
            return {}

        players = {}
        for line in data.split('\n'):
            m = re.match(self._regPlayer, line.strip())
            if m:
                if m.group('ping') == 'ZMBI':
                    # ignore them, let them not bother us with errors
                    pass
                else:
                    try:
                        players[str(m.group('slot'))] = int(m.group('ping'))
                    except:
                        players[str(m.group('slot'))] = 999
        return players

    def sync(self):
        self.debug('Synchronizing client info')
        plist = self.getPlayerList(maxRetries=4)
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.getByCidOrJoinPlayer(cid)
            if client:
                # Disconnect the zombies first
                if c['ping'] == 'ZMBI':
                    self.debug('slot is in state zombie: %s - ignoring', c['ip'])
                    # client.disconnect()
                elif client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')

        return mlist

    def rotateMap(self):
        self.say('^7Changing to next map')
        time.sleep(1)
        self.write('cyclemap')

    def changeMap(self, map_name):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        rv = self.getMapsSoundingLike(map_name)
        if isinstance(rv, basestring):
            self.say('^7Changing map to %s' % rv)
            time.sleep(1)
            self.write('map %s' % rv)
        else:
            return rv

    def getMaps(self):
        if self._maplist is not None:
            return self._maplist

        data = self.write('fdir *.bsp')
        if not data:
            return []

        mapregex = re.compile(r'^maps/(?P<map>.+)\.bsp$', re.I)
        maps = []
        for line in data.split('\n'):
            m = re.match(mapregex, line.strip())
            if m:
                if m.group('map'):
                    maps.append(m.group('map'))

        return maps


    ###############################################################################################
    #
    #    Other methods
    #
    ###############################################################################################

    def getNextMap(self):
        # let's first check if a vote passed for the next map
        nmap = self.getCvar('g_nextmap').getString()
        self.debug('g_nextmap: %s' % nmap)
        if nmap != "":
            if nmap[:4] == 'ut4_': nmap = nmap[4:]
            elif nmap[:3] == 'ut_': nmap = nmap[3:]
            return nmap.title()

        # seek the next map from the mapcyle file
        if not self.game.mapName: return None

        mapcycle = self.getCvar('g_mapcycle').getString()
        if self.game.fs_game is None:
            try:
                self.game.fs_game = self.getCvar('fs_game').getString().rstrip('/')
            except:
                self.game.fs_game = None
                self.warning("Could not query server for fs_game")
        if self.game.fs_basepath is None:
            try:
                self.game.fs_basepath = self.getCvar('fs_basepath').getString().rstrip('/')
            except:
                self.game.fs_basepath = None
                self.warning("Could not query server for fs_basepath")
        mapfile = self.game.fs_basepath + '/' + self.game.fs_game + '/' + mapcycle
        if not os.path.isfile(mapfile):
            self.debug('could not read mapcycle file at %s' % mapfile)
            if self.game.fs_homepath is None:
                try:
                    self.game.fs_homepath = self.getCvar('fs_homepath').getString().rstrip('/')
                except:
                    self.game.fs_homepath = None
                    self.warning("Could not query server for fs_homepath")
            mapfile = self.game.fs_homepath + '/' + self.game.fs_game + '/' + mapcycle
        if not os.path.isfile(mapfile):
            self.debug('could not read mapcycle file at %s' % mapfile)
            self.error("Unable to find mapcycle file %s" % mapcycle)
            return None

        cyclemapfile = open(mapfile, 'r')

        re_comment_line = re.compile(r"""^\s*(//.*)?$""")
        lines = filter(lambda x: not re_comment_line.match(x), cyclemapfile.readlines())
        #self.debug(lines)
        if not len(lines):
            return None

        # get maps
        maps = []
        try:
            while True:
                tmp = lines.pop(0).strip()
                if tmp[0] == '{':
                    while tmp[0] != '}':
                        tmp = lines.pop(0).strip()
                    tmp = lines.pop(0).strip()
                maps.append(tmp)
        except IndexError:
            pass

        #self.debug(maps)

        if len(maps) == 0:
            return None

        firstmap = maps[0]

        # find current map
        #currentmap = self.game.mapName.strip().lower() # this fails after a cyclemap
        currentmap = self.getCvar('mapname').value
        try:
            tmp = maps.pop(0)
            while currentmap != tmp:
                tmp = maps.pop(0)
            if currentmap == tmp:
                #self.debug('found current map %s' % currentmap)
                #self.debug(maps)
                if len(maps) > 0:
                    return maps.pop(0)
                else:
                    return firstmap
        except IndexError:
            return firstmap

    def getMapsSoundingLike(self, mapname):
        """ return a valid mapname.
        If no exact match is found, then return close candidates as a list
        """
        wanted_map = mapname.lower()
        supportedMaps = self.getMaps()
        if wanted_map in supportedMaps:
            return wanted_map

        cleaned_supportedMaps = {}
        for map_name in supportedMaps:
            cleaned_supportedMaps[re.sub("^ut4?_", '', map_name, count=1)] = map_name

        if wanted_map in cleaned_supportedMaps:
            return cleaned_supportedMaps[wanted_map]

        cleaned_wanted_map = re.sub("^ut4?_", '', wanted_map, count=1)

        matches = [cleaned_supportedMaps[match] for match in getStuffSoundingLike(cleaned_wanted_map, cleaned_supportedMaps.keys())]
        if len(matches) == 1:
            # one match, get the map id
            return matches[0]
        else:
            # multiple matches, provide suggestions
            return matches


    def getTeamScores(self):
        data = self.write('players')
        if not data:
            return None

        line = data.split('\n')[2]

        m = re.match(self._reTeamScores, line.strip())
        if m:
            return [int(m.group('RedScore')), int(m.group('BlueScore'))]

        return None

    def getScores(self):
        """
        NOTE: this won't work properly if the server has private slots. see http://forums.urbanterror.net/index.php/topic,9356.0.html
        """
        data = self.write('players')
        if not data:
            return None


        scores = {'red':None, 'blue':None, 'players':{}}

        line = data.split('\n')[2]
        m = re.match(self._reTeamScores, line.strip())
        if m:
            scores['red'] = int(m.group('RedScore'))
            scores['blue'] = int(m.group('BlueScore'))

        for line in data.split('\n')[3:]:
            m = re.match(self._rePlayerScore, line.strip())
            if m:
                scores['players'][int(m.group('slot'))] = {'kills':int(m.group('kill')), 'deaths':int(m.group('death'))}

        return scores


    def queryClientUserInfoByCid(self, cid):
        """
        : dumpuser 5
        Player 5 is not on the server
        
        : dumpuser 3
        userinfo
        --------
        ip                  62.235.246.103:27960
        name                Shinki
        racered             2
        raceblue            2
        rate                8000
        ut_timenudge        0
        cg_rgb              255 0 255
        cg_predictitems     0
        cg_physics          1
        gear                GLJAXUA
        cl_anonymous        0
        sex                 male
        handicap            100
        color2              5
        color1              4
        team_headmodel      *james
        team_model          james
        headmodel           sarge
        model               sarge
        snaps               20
        teamtask            0
        cl_guid             8982B13A8DCEE4C77A32E6AC4DD7EEDF
        weapmodes           00000110220000020002

        """
        data = self.write('dumpuser %s' % cid)
        if not data:
            return None
        
        if data.split('\n')[0] != "userinfo":
            self.debug("dumpuser %s returned : %s" % (cid, data))
            self.debug('client %s probably disconnected, but its character is still hanging in game...' % cid)
            return None

        datatransformed = "%s " % cid
        for line in data.split('\n'):
            if line.strip() == "userinfo" or line.strip() == "--------":
                continue

            var = line[:20].strip()
            val = line[20:].strip()
            datatransformed += "\\%s\\%s" % (var, val)

        return datatransformed

    def getByCidOrJoinPlayer(self, cid):
        client = self.clients.getByCID(cid)
        if client:
            return client
        else:
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)
            return self.clients.getByCID(cid)

    def getPlayerTeams(self):
        """return a dict having cid as keys and a B3 team as value for
        as many slots as we can get a team for.
        
        /rcon players
        Map: ut4_heroic_beta1
        Players: 16
        Scores: R:51 B:92
        0:  FREE k:0 d:0 ping:0
        0:  FREE k:0 d:0 ping:0
        2: Anibal BLUE k:24 d:11 ping:69 90.47.240.44:27960
        3: kasper01 RED k:6 d:28 ping:56 93.22.173.133:27960
        4: notorcan RED k:16 d:10 ping:51 86.206.51.250:27960
        5: laCourge SPECTATOR k:0 d:0 ping:48 81.56.143.41:27960
        6: fundy_kill BLUE k:6 d:9 ping:50 92.129.99.62:27960
        7: brillko BLUE k:25 d:11 ping:56 85.224.201.172:27960
        8: -Tuxmania- BLUE k:16 d:7 ping:48 81.231.39.32:27960
        9: j.i.goe RED k:1 d:4 ping:51 86.218.69.81:27960
        10: EasyRider RED k:10 d:12 ping:53 85.176.137.142:27960
        11: Ferd75 BLUE k:4 d:8 ping:48 90.3.171.84:27960
        12: frag4#Gost0r RED k:11 d:16 ping:74 79.229.27.54:27960
        13: {'OuT'}ToinetoX RED k:6 d:13 ping:67 81.48.189.135:27960
        14: GibsonSG BLUE k:-1 d:2 ping:37 84.60.3.67:27960
        15: Kjeldor BLUE k:16 d:9 ping:80 85.246.3.196:50851

        NOTE: this won't work fully if the server has private slots. see http://forums.urbanterror.net/index.php/topic,9356.0.html
        """
        player_teams = {}
        letters2slots = {'A': '0', 'C': '2', 'B': '1', 'E': '4', 'D': '3', 'G': '6', 'F': '5', 'I': '8', 'H': '7', 'K': '10', 'J': '9', 'M': '12', 'L': '11', 'O': '14', 'N': '13', 'Q': '16', 'P': '15', 'S': '18', 'R': '17', 'U': '20', 'T': '19', 'W': '22', 'V': '21', 'Y': '24', 'X': '23', 'Z': '25'}
        
        players_data = self.write('players')
        for line in players_data.split('\n')[3:]:
            self.debug(line.strip())
            m = re.match(self._rePlayerScore, line.strip())
            if m and line.strip() != '0:  FREE k:0 d:0 ping:0':
                cid = m.group('slot')
                team = self.getTeam(m.group('team'))
                player_teams[cid] = team

        g_blueteamlist = self.getCvar('g_blueteamlist')
        if g_blueteamlist:
            for letter in g_blueteamlist.getString():
                player_teams[letters2slots[letter]] = b3.TEAM_BLUE

        g_redteamlist = self.getCvar('g_redteamlist')
        if g_redteamlist:
            for letter in g_redteamlist.getString():
                player_teams[letters2slots[letter]] = b3.TEAM_RED
        return player_teams

    def _getDamagePoints(self, weapon, hitloc):
        try:
            points = self.damage[weapon][int(hitloc)]
            self.debug("_getDamagePoints(%s, %s) -> %s" % (weapon, hitloc, points))
            return points
        except KeyError, err:
            self.warning("_getDamagePoints(%s, %s) cannot find value : %s" % (weapon, hitloc, err))
            return 15
        
    def _convertHitWeaponToKillWeapon(self, hitweapon_id):
        """on Hit: lines identifiers for weapons are different than
        the one on Kill: lines"""
        try:
            return self.hitweapon2killweapon[int(hitweapon_id)]
        except KeyError, err:
            self.warning("unknown weapon id on Hit line: %s", err)
            return None


"""
#----- Actions -----------------------------------------------------------------
Item: 0 team_CTF_redflag -> Flag Taken/picked up
Flag: 0 0: team_CTF_blueflag -> Flag Dropped
Flag: 0 1: team_CTF_blueflag -> Flag Returned
Flag: 0 2: team_CTF_blueflag -> Flag Captured

Bombholder is 5 -> Spawn with the bomb
Bomb was planted by 5
Bomb was defused by 6!
Bomb was tossed by 4 -> either manually or by being killed
Bomb has been collected by 6 -> Picking up a tossed bomb

#----- Connection Info ---------------------------------------------------------
A little documentation on the ClientSlot states in relation to ping positions in the status response

UrT ClientSlot states:
CS_FREE,     // can be reused for a new connection
CS_ZOMBIE,   // client has been disconnected, but don't reuse
             // connection for a couple seconds
CS_CONNECTED // has been assigned to a client_t, but no gamestate yet
CS_PRIMED,   // gamestate has been sent, but client hasn't sent a usercmd
CS_ACTIVE    // client is fully in game

Snippet 1:
if (cl->state == CS_CONNECTED)
            Com_Printf ("CNCT ");
        else if (cl->state == CS_ZOMBIE)
            Com_Printf ("ZMBI ");
        else
        {
            ping = cl->ping < 9999 ? cl->ping : 9999;
            Com_Printf ("%4i ", ping);
        }

Snippet 2:
if (cl->state == CS_ZOMBIE && cl->lastPacketTime < zombiepoint) {
  // using the client id cause the cl->name is empty at this point
  Com_DPrintf( "Going from CS_ZOMBIE to CS_FREE for client %d\n", i );
  cl->state = CS_FREE; // can now be reused
}

#----- Available variables defined on Init -------------------------------------
081027 14:53:22 DEBUG   EVENT: OnInitgame
081027 14:53:22 VERBOSE ...self.console.game.sv_allowdownload: 0
081027 14:53:22 VERBOSE ...self.console.game.g_matchmode: 0
081027 14:53:22 VERBOSE ...self.console.game.sv_maxclients: 16
081027 14:53:22 VERBOSE ...self.console.game.sv_floodprotect: 1
081027 14:53:22 VERBOSE ...self.console.game.g_warmup: 15
081027 14:53:22 VERBOSE ...self.console.game.captureLimit: 0
081027 14:53:22 VERBOSE ...self.console.game.sv_hostname:   ^1[SNT]^7 TDM #4 Dungeon (B3)
081027 14:53:22 VERBOSE ...self.console.game.g_followstrict: 1
081027 14:53:22 VERBOSE ...self.console.game.fragLimit: 0
081027 14:53:22 VERBOSE ...self.console.game.timeLimit: 15
081027 14:53:22 VERBOSE ...self.console.game.g_cahtime: 60
081027 14:53:22 VERBOSE ...self.console.game.g_swaproles: 0
081027 14:53:22 VERBOSE ...self.console.game.g_roundtime: 3
081027 14:53:22 VERBOSE ...self.console.game.g_bombexplodetime: 40
081027 14:53:22 VERBOSE ...self.console.game.g_bombdefusetime: 10
081027 14:53:22 VERBOSE ...self.console.game.g_hotpotato: 2
081027 14:53:22 VERBOSE ...self.console.game.g_waverespawns: 0
081027 14:53:22 VERBOSE ...self.console.game.g_redwave: 15
081027 14:53:22 VERBOSE ...self.console.game.g_bluewave: 15
081027 14:53:22 VERBOSE ...self.console.game.g_respawndelay: 3
081027 14:53:22 VERBOSE ...self.console.game.g_suddendeath: 1
081027 14:53:22 VERBOSE ...self.console.game.g_maxrounds: 0
081027 14:53:22 VERBOSE ...self.console.game.g_friendlyfire: 1
081027 14:53:22 VERBOSE ...self.console.game.g_allowvote: 536870920
081027 14:53:22 VERBOSE ...self.console.game.g_armbands: 0
081027 14:53:22 VERBOSE ...self.console.game.g_survivorrule: 0
081027 14:53:22 VERBOSE ...self.console.game.g_gear: 0
081027 14:53:22 VERBOSE ...self.console.game.g_deadchat: 1
081027 14:53:22 VERBOSE ...self.console.game.g_maxGameClients: 0
081027 14:53:22 VERBOSE ...self.console.game.sv_dlURL: sweetopia.snt.utwente.nl/xlr
081027 14:53:22 VERBOSE ...self.console.game.sv_maxPing: 250
081027 14:53:22 VERBOSE ...self.console.game.sv_minPing: 0
081027 14:53:22 VERBOSE ...self.console.game.sv_maxRate: 0
081027 14:53:22 VERBOSE ...self.console.game.sv_minRate: 0
081027 14:53:22 VERBOSE ...self.console.game.dmflags: 0
081027 14:53:22 VERBOSE ...self.console.game.version: ioq3 1.35urt linux-i386 Dec 20 2007
081027 14:53:22 VERBOSE ...self.console.game.protocol: 68
081027 14:53:22 VERBOSE ...self.console.game.mapName: ut4_turnpike
081027 14:53:22 VERBOSE ...self.console.game.sv_privateClients: 4
081027 14:53:22 VERBOSE ...self.console.game. Admin:  XLR8or
081027 14:53:22 VERBOSE ...self.console.game. Email: admin@xlr8or.com
081027 14:53:22 VERBOSE ...self.console.game.gamename: q3ut4
081027 14:53:22 VERBOSE ...self.console.game.g_needpass: 1
081027 14:53:22 VERBOSE ...self.console.game.g_enableDust: 0
081027 14:53:22 VERBOSE ...self.console.game.g_enableBreath: 0
081027 14:53:22 VERBOSE ...self.console.game.g_antilagvis: 0
081027 14:53:22 VERBOSE ...self.console.game.g_survivor: 0
081027 14:53:22 VERBOSE ...self.console.game.g_enablePrecip: 2
081027 14:53:22 VERBOSE ...self.console.game.g_modversion: 4.1
081027 14:53:22 VERBOSE ...self.console.game.gameType: tdm

"""

########NEW FILE########
__FILENAME__ = iourt42
#
# ioUrT 4.2 Parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Thomas LEVEIL <courgette@bigbrotherbot.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 2012/07/24 - 0.0 - Courgette
#  * parser created
# 2012/08/08 - 1.0 - Courgette
#  * new authentication system using the Frozen Sand Account if available
# 2012/08/08 - 1.1 - Courgette
#  * fix error when computing Hit damage. Until we got real value, the default value : 15 is returned for all
#    weapons and all hit locations.
# 2012/08/09 - 1.2 - Courgette
#  * make sure the game is UrT 4.2 or fail to start
# 2012/08/09 - 1.2.1 - Courgette
#  * disabling authentication using the /rcon auth-whois command response
# 2012/08/12 - 1.3 - Courgette
#  * patches the Spamcontrol plugin to make it aware of radio spam
# 2012/09/14 - 1.4 - Courgette
#  * change kick and tempban commands so them give the reason
# 2012/10/04 - 1.5 - Courgette
#  * update for UrT 4.2.002 new auth system with Frozen Sand Account and auth-key
# 2012/10/04 - 1.5.1 - Courgette
#  * fix kick and tempban when used with a reason
# 2012/10/10 - 1.5.2 - Courgette
#  * support names with blank characters
# 2012/10/24 - 1.6 - Courgette
#  * new: settings to ban with the Frozen Sand auth system
# 2012/11/09 - 1.7 - Courgette
#  * new: support new jump game type with code 9
# 2012/11/15 - 1.7.1 - Courgette
#  * fix: banning with the Frozen Sand auth system now works with servers set to auth private or notoriety mode
# 26/11/2012 - 1.8 - Courgette
#     * protect some of the Client object property
# 26/11/2012 - 1.9 - Courgette
#     * fix authentication for connecting player Frosen Sand Account is uniquely known in the B3 database
# 07/12/2012 - 1.10 - Courgette
#     * add new events : EVT_CLIENT_JUMP_TIMER_START, EVT_CLIENT_JUMP_TIMER_STOP, EVT_CLIENT_POS_SAVE,
#       EVT_CLIENT_POS_LOAD and EVT_CLIENT_SURVIVOR_WINNERwhich can be used by plugins
# 08/12/2012 - 1.10.1 - Courgette
#     * fix EVT_CLIENT_JUMP_TIMER_START and EVT_CLIENT_JUMP_TIMER_STOP events when no location name is provided
# 22/12/2012 - 1.11 - Courgette
#     * update for UrT 4.2.009 release. adds UT_MOD_SMITED, UT_MOD_GLOCK and fix constants values for some of the
#       UT_MOD_* constants.
# 08/01/2013 - 1.11.1 - Courgette
#     * fix EVT_SURVIVOR_WIN event
#
import re, new
import time
from b3.functions import time2minutes
from b3.parsers.iourt41 import Iourt41Parser
import b3
from b3.clients import Client
from b3.events import Event
from b3.plugins.spamcontrol import SpamcontrolPlugin

__author__  = 'Courgette'
__version__ = '1.11.1'

class Iourt42Client(Client):

    def auth_by_guid(self):
        try:
            return self.console.storage.getClient(self)
        except KeyError, msg:
            self.console.debug('User not found %s: %s', self.guid, msg)
            return False

    def auth_by_pbid(self):
        clients_matching_pbid = self.console.storage.getClientsMatching({ 'pbid' : self.pbid })
        if len(clients_matching_pbid) > 1:
            self.console.error("DATA ERROR: found %s client having Frozen Sand Account '%s'" % (len(clients_matching_pbid), self.pbid))
            return self.auth_by_pbid_and_guid()
        elif len(clients_matching_pbid) == 1:
            self.id = clients_matching_pbid[0].id
            # we may have a second client entry in database with current guid. We want to update our current
            # client guid only if it is not the case.
            try:
                client_by_guid = self.console.storage.getClient(Client(guid=self.guid))
            except KeyError:
                client_by_guid = None
            if client_by_guid and client_by_guid.id != self.id:
                self._guid = None # so storage.getClient is able to overwrite the value which will make it remain unchanged in database when .save() will be called later on
            return self.console.storage.getClient(self)
        else:
            self.console.debug('Frozen Sand Account [%s] unknown in database', self.pbid)
            return False

    def auth_by_pbid_and_guid(self):
        clients_matching_pbid = self.console.storage.getClientsMatching({ 'pbid': self.pbid, 'guid': self.guid })
        if len(clients_matching_pbid):
            self.id = clients_matching_pbid[0].id
            return self.console.storage.getClient(self)
        else:
            self.console.debug("Frozen Sand Account [%s] with guid '%s' unknown in database" % (self.pbid, self.guid))
            return False

    """
    The b3.clients.Client.auth method needs to be changed to fit the UrT4.2 authentication scheme.
    In UrT4.2 :
     * all connected players have a cl_guid
     * some have a Frozen Sand Account (FSA)

    The FSA is a worldwide identifier while the cl_guid only identify a player on a given game server.

    See http://forum.bigbrotherbot.net/urban-terror-4-2/urt-4-2-discussion/
    """
    def auth(self):
        if not self.authed and self.guid and not self.authorizing:
            self.authorizing = True

            name = self.name
            ip = self.ip
            pbid = self.pbid

            if not pbid and self.cid:
                fsa_info = self.console.queryClientFrozenSandAccount(self.cid)
                self.pbid = pbid = fsa_info.get('login', None)

            # Frozen Sand Account related info
            if not hasattr(self, 'notoriety'):
                self.notoriety = None

            # FSA will be found in pbid
            if not self.pbid:
                # auth with cl_guid only
                try:
                    inStorage = self.auth_by_guid()
                except Exception, e:
                    self.console.error("auth by guid failed", exc_info=e)
                    self.authorizing = False
                    return False
            else:
                # auth with FSA
                try:
                    inStorage = self.auth_by_pbid()
                except Exception, e:
                    self.console.error("auth by FSA failed", exc_info=e)
                    self.authorizing = False
                    return False

                if not inStorage:
                    # fallback on auth with cl_guid only
                    try:
                        inStorage = self.auth_by_guid()
                    except Exception, e:
                        self.console.error("auth by guid failed (when no known FSA)", exc_info=e)
                        self.authorizing = False
                        return False

            #lastVisit = None
            if inStorage:
                self.console.bot('Client found in storage @%s, welcome back %s (FSA: %s)', str(self.id), self.name, self.pbid)
                self.lastVisit = self.timeEdit
            else:
                self.console.bot('Client not found in the storage %s (FSA: %s), create new', str(self.guid), self.pbid)

            self.connections = int(self.connections) + 1
            self.name = name
            self.ip = ip
            if pbid:
                self.pbid = pbid
            self.save()
            self.authed = True

            self.console.debug('Client Authorized: @%s "%s" [%s] (FSA: %s)', self.cid, self.name, self.guid, self.pbid)

            # check for bans
            if self.numBans > 0:
                ban = self.lastBan
                if ban:
                    self.reBan(ban)
                    self.authorizing = False
                    return False

            self.refreshLevel()

            self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_AUTH,
                self,
                self))

            self.authorizing = False

            return self.authed
        else:
            return False

    def __str__(self):
        return "Client42<@%s:%s|%s:\"%s\":%s>" % (self.id, self.guid, self.pbid, self.name, self.cid)

class Iourt42Parser(Iourt41Parser):
    gameName = 'iourt42'


    _commands = {
        'broadcast': '%(prefix)s^7 %(message)s',
        'message': 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s',
        'deadsay': 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s',
        'say': 'say %(prefix)s %(message)s',
        'saybig': 'bigtext "%(prefix)s %(message)s"',
        'set': 'set %(name)s "%(value)s"',
        'kick': 'kick %(cid)s "%(reason)s"',
        'ban': 'addip %(cid)s',
        'tempban': 'kick %(cid)s "%(reason)s"',
        'banByIp': 'addip %(ip)s',
        'unbanByIp': 'removeip %(ip)s',
        'auth-permban': 'auth-ban %(cid)s 0 0 0',
        'auth-tempban': 'auth-ban %(cid)s %(days)s %(hours)s %(minutes)s',
        'slap': 'slap %(cid)s',
        'nuke': 'nuke %(cid)s',
        'mute': 'mute %(cid)s %(seconds)s',
        'kill': 'smite %(cid)s',
    }

    _eventMap = {
        #'warmup' : b3.events.EVT_GAME_HOTPOTATO,
        #'shutdowngame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 ClientUserinfo: 0:

    _lineFormats = (
        #Radio: 0 - 7 - 2 - "New Alley" - "I'm going for the flag"
        re.compile(r'''^(?P<action>Radio): (?P<data>(?P<cid>[0-9]+) - (?P<msg_group>[0-9]+) - (?P<msg_id>[0-9]+) - "(?P<location>.+)" - "(?P<text>.*)")$'''),

        #Radio: 0 - 7 - 2 - "New Alley" - "I'm going for the flag"
        re.compile(r'''^(?P<action>Radio): (?P<data>(?P<cid>[0-9]+) - (?P<msg_group>[0-9]+) - (?P<msg_id>[0-9]+) - "(?P<location>.+)" - "(?P<text>.*)")$'''),

        #Callvote: 1 - "map dressingroom"
        re.compile(r'''^(?P<action>Callvote): (?P<data>(?P<cid>[0-9]+) - "(?P<vote_string>.*)")$'''),

        #Vote: 0 - 2
        re.compile(r'''^(?P<action>Vote): (?P<data>(?P<cid>[0-9]+) - (?P<value>.*))$'''),

        #13:34 ClientJumpTimerStarted: 0 - way: 2 (Easy Way)
        re.compile(r'^(?P<action>ClientJumpTimerStarted):\s(?P<cid>\d+)\s-\s(?P<data>way: (?P<way_id>\d+)(?:\s\((?P<way_label>.+)\))?)$', re.IGNORECASE),
        #13:34 ClientJumpTimerStopped: 0 - 5 seconds - way: 1 (Hard Way)
        re.compile(r'^(?P<action>ClientJumpTimerStopped):\s(?P<cid>\d+)\s-\s(?P<data>(?P<duration>.+)\s-\sway: (?P<way_id>\d+)(?:\s\((?P<way_label>.+)\))?)$', re.IGNORECASE),

        #13:34 ClientSavePosition: 0 - 335.384887 - 67.469154 - -23.875000 - "unknown"
        #13:34 ClientLoadPosition: 0 - 335.384887 - 67.469154 - -23.875000 - "unknown"
        re.compile(r'^(?P<action>Client(Save|Load)Position):\s(?P<cid>\d+)\s-\s(?P<data>(?P<x>-?\d+(?:\.\d+)?)\s-\s(?P<y>-?\d+(?:\.\d+)?)\s-\s(?P<z>-?\d+(?:\.\d+)?)\s-\s"(?P<name>.*)")$', re.IGNORECASE),

        #Generated with ioUrbanTerror v4.1:
        #Hit: 12 7 1 19: BSTHanzo[FR] hit ercan in the Helmet
        #Hit: 13 10 0 8: Grover hit jacobdk92 in the Head
        re.compile(r'^(?P<action>Hit):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<hitloc>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>.*))$', re.IGNORECASE),
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<hitloc>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>(?P<aname>[^:])\shit\s(?P<name>[^:])\sin\sthe(?P<locname>.*)))$', re.IGNORECASE),

        #6:37 Kill: 0 1 16: XLR8or killed =lvl1=Cheetah by UT_MOD_SPAS
        #2:56 Kill: 14 4 21: Qst killed Leftovercrack by UT_MOD_PSG1
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>.*))$', re.IGNORECASE),
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>(?P<aname>[^:])\skilled\s(?P<name>[^:])\sby\s(?P<modname>.*)))$', re.IGNORECASE),

        #Processing chats and tell events...
        #5:39 saytell: 15 16 repelSteeltje: nno
        #5:39 saytell: 15 15 repelSteeltje: nno
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<name>.+?):\s+(?P<text>.*))$', re.IGNORECASE),

        # We're not using tell in this form so this one is disabled
        #5:39 tell: repelSteeltje to B!K!n1: nno
        #re.compile(r'^(?P<action>[a-z]+):\s+(?P<data>(?P<name>[^:]+)\s+to\s+(?P<aname>[^:]+):\s+(?P<text>.*))$', re.IGNORECASE),

        #3:53 say: 8 denzel: lol
        #15:37 say: 9 .:MS-T:.BstPL: this name is quite a challenge
        #2:28 sayteam: 12 New_UrT_Player_v4.1: woekele
        #16:33 Flag: 2 0: team_CTF_redflag
        #re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<name>[^ ]+):\s+(?P<text>.*))$', re.IGNORECASE),
        # SGT: fix issue with OnSay when something like this come and the match could'nt find the name group
        # say: 7 -crespino-:
        # say: 6 ^5Marcel ^2[^6CZARMY^2]: !help
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<name>.+?):\s*(?P<text>.*))$', re.IGNORECASE),

        #15:42 Flag Return: RED
        #15:42 Flag Return: BLUE
        re.compile(r'^(?P<action>Flag Return):\s(?P<data>(?P<color>.+))$', re.IGNORECASE),

        #Bombmode actions:
        #3:06 Bombholder is 2
        re.compile(r'^(?P<action>Bombholder)(?P<data>\sis\s(?P<cid>[0-9]))$', re.IGNORECASE),
        #was planted, was defused, was tossed, has been collected (doh, how gramatically correct!)
        #2:13 Bomb was tossed by 2
        #2:32 Bomb was planted by 2
        #3:01 Bomb was defused by 3!
        #2:17 Bomb has been collected by 2
        re.compile(r'^(?P<action>Bomb)\s(?P<data>(was|has been)\s(?P<subaction>[a-z]+)\sby\s(?P<cid>[0-9]+).*)$', re.IGNORECASE),

        #Falling thru? Item stuff and so forth
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>.*)$', re.IGNORECASE),
        #Shutdowngame and Warmup... the one word lines
        re.compile(r'^(?P<action>[a-z]+):$', re.IGNORECASE)
    )

    # map: ut4_casa
    # num score ping name            lastmsg address               qport rate
    # --- ----- ---- --------------- ------- --------------------- ----- -----
    #   2     0   19 ^1XLR^78^8^9or^7        0 145.99.135.227:27960  41893  8000  # player with a live ping
    #   4     0 CNCT Dz!k^7                450 83.175.191.27:64459   50308 20000  # connecting player (or inbetween rounds)
    #   9     0 ZMBI ^7                   1900 81.178.80.68:27960    10801  8000  # zombies (need to be disconnected!)
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+|CNCT|ZMBI)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    # Map: ut4_algiers
    # Players: 8
    # Scores: R:97 B:98
    # 0:  FREE k:0 d:0 ping:0
    # 4: yene RED k:16 d:8 ping:50 92.104.110.192:63496
    _reTeamScores = re.compile(r'^Scores:\s+R:(?P<RedScore>.+)\s+B:(?P<BlueScore>.+)$', re.I)
    _rePlayerScore = re.compile(r'^(?P<slot>[0-9]+): (?P<name>.*) (?P<team>RED|BLUE|SPECTATOR|FREE) k:(?P<kill>[0-9]+) d:(?P<death>[0-9]+) ping:(?P<ping>[0-9]+|CNCT|ZMBI)( (?P<ip>[0-9.]+):(?P<port>[0-9-]+))?$', re.I) # NOTE: this won't work properly if the server has private slots. see http://forums.urbanterror.net/index.php/topic,9356.0.html

    # /rcon auth-whois replies patterns
    _re_authwhois = re.compile(r"""^auth: id: (?P<cid>\d+) - name: \^7(?P<name>.+?) - login: (?P<login>.*?) - notoriety: (?P<notoriety>.+?) - level: (?P<level>-?\d+?)(?:\s+- (?P<extra>.*))?$""", re.MULTILINE)


    _permban_with_frozensand = False
    _tempban_with_frozensand = False

    ## kill modes
    MOD_WATER='1'
    MOD_LAVA='3'
    MOD_TELEFRAG='5'
    MOD_FALLING='6'
    MOD_SUICIDE='7'
    MOD_TRIGGER_HURT='9'
    MOD_CHANGE_TEAM='10'
    UT_MOD_KNIFE='12'
    UT_MOD_KNIFE_THROWN='13'
    UT_MOD_BERETTA='14'
    UT_MOD_DEAGLE='15'
    UT_MOD_SPAS='16'
    UT_MOD_UMP45='17'
    UT_MOD_MP5K='18'
    UT_MOD_LR300='19'
    UT_MOD_G36='20'
    UT_MOD_PSG1='21'
    UT_MOD_HK69='22'
    UT_MOD_BLED='23'
    UT_MOD_KICKED='24' # not exising in 4.2 ?
    UT_MOD_HEGRENADE='25'
    UT_MOD_SR8='27'
    UT_MOD_AK103='29'
    UT_MOD_SPLODED='30'
    UT_MOD_SLAPPED='31'
    UT_MOD_SMITED = '32'
    UT_MOD_BOMBED='33'
    UT_MOD_NUKED='34'
    UT_MOD_NEGEV='35'
    UT_MOD_HK69_HIT='36'
    UT_MOD_M4='37'
    UT_MOD_GLOCK='38'
    UT_MOD_FLAG='39'
    UT_MOD_GOOMBA='40'

    ## weapons id on Hit: lines are different than the one
    ## on the Kill: lines. Here the translation table
    hitweapon2killweapon = {
        1: UT_MOD_KNIFE,
        2: UT_MOD_BERETTA,
        3: UT_MOD_DEAGLE,
        4: UT_MOD_SPAS,
        5: UT_MOD_MP5K,
        6: UT_MOD_UMP45,
        8: UT_MOD_LR300,
        9: UT_MOD_G36,
        10: UT_MOD_PSG1,
        14: UT_MOD_SR8,
        15: UT_MOD_AK103,
        17: UT_MOD_NEGEV,
        19: UT_MOD_M4,
        20: UT_MOD_GLOCK,
        23: UT_MOD_KNIFE_THROWN,
    }


    def __new__(cls, *args, **kwargs):
        Iourt42Parser.patch_Clients()
        return Iourt41Parser.__new__(cls)


    def startup(self):
        try:
            gamename = self.getCvar('gamename').getString()
            if gamename != 'q3urt42':
                self.error("the iourt42 B3 parser cannot be used with a game server other than Urban Terror 4.2")
                raise SystemExit(220)
        except Exception, e:
            self.warning("Could not query server for gamename.", exc_info=e)

        Iourt41Parser.startup(self)

        # add UrT 4.2 specific events
        self.EVT_CLIENT_RADIO = self.Events.createEvent('EVT_CLIENT_RADIO', 'Event client radio')
        self.EVT_GAME_FLAG_HOTPOTATO = self.Events.createEvent('EVT_GAME_FLAG_HOTPOTATO', 'Event game hotpotato')
        self._eventMap['hotpotato'] = self.EVT_GAME_FLAG_HOTPOTATO
        self.EVT_CLIENT_CALLVOTE = self.Events.createEvent('EVT_CLIENT_CALLVOTE', 'Event client call vote')
        self.EVT_CLIENT_VOTE = self.Events.createEvent('EVT_CLIENT_VOTE', 'Event client vote')
        self.EVT_CLIENT_JUMP_TIMER_START = self.Events.createEvent('EVT_CLIENT_JUMP_TIMER_START', 'Event client jump timer started')
        self.EVT_CLIENT_JUMP_TIMER_STOP = self.Events.createEvent('EVT_CLIENT_JUMP_TIMER_STOP', 'Event client jump timer stopped')
        self.EVT_CLIENT_POS_SAVE = self.Events.createEvent('EVT_CLIENT_POS_SAVE', 'Event client position saved')
        self.EVT_CLIENT_POS_LOAD = self.Events.createEvent('EVT_CLIENT_POS_LOAD', 'Event client position loaded')
        self.EVT_CLIENT_SURVIVOR_WINNER = self.Events.createEvent('EVT_CLIENT_SURVIVOR_WINNER', 'Event client survivor winner')

        self.load_conf_frozensand_ban_settings()


    def pluginsStarted(self):
        """ called when all plugins are started """
        self.spamcontrolPlugin = self.getPlugin("spamcontrol")
        if self.spamcontrolPlugin:
            self.patch_spamcontrolPlugin()



    ###############################################################################################
    #
    #    Config loaders
    #
    ###############################################################################################

    def load_conf_frozensand_ban_settings(self):
        try:
            frozensand_auth_available = self.is_frozensand_auth_available()
        except Exception, e:
            self.warning("Could not query server for cvar auth.", exc_info=e)
            frozensand_auth_available = False
        self.info("Frozen Sand auth system enabled : %s" % ('yes' if frozensand_auth_available else 'no'))

        try:
            frozensand_auth_owners = self.getCvar('auth_owners').getString()
        except Exception, e:
            self.warning("Could not query server for cvar auth_owners.", exc_info=e)
            frozensand_auth_owners = ""
        self.info("Frozen Sand auth_owners set : %s" % (('yes - %s' % frozensand_auth_available) if frozensand_auth_owners else 'no'))

        if frozensand_auth_available and frozensand_auth_owners:
            self.load_conf_permban_with_frozensand()
            self.load_conf_tempban_with_frozensand()
            if self._permban_with_frozensand or self._tempban_with_frozensand:
                self.info("NOTE: when banning with the Frozen Sand auth system, B3 cannot remove the bans on the urbanterror.info website. To unban a player you will have to first unban him on B3 and then also unban him on the official Frozen Sand website : http://www.urbanterror.info/groups/list/all/?search=%s" % frozensand_auth_owners)

        else:
            self.info("ignoring settings about banning with Frozen Sand auth system as the auth system is not enabled or auth_owners not set")



    def load_conf_permban_with_frozensand(self):
        self._permban_with_frozensand = False
        try:
            self._permban_with_frozensand = self.config.getboolean('server', 'permban_with_frozensand')
        except Exception, err:
            self.warning(err)
        self.info("Send permbans to Frozen Sand : %s" % ('yes' if self._permban_with_frozensand else 'no'))


    def load_conf_tempban_with_frozensand(self):
        self._tempban_with_frozensand = False
        try:
            self._tempban_with_frozensand = self.config.getboolean('server', 'tempban_with_frozensand')
        except Exception, err:
            self.warning(err)
        self.info("Send temporary bans to Frozen Sand : %s" % ('yes' if self._tempban_with_frozensand else 'no'))



    ###############################################################################################
    #
    #    Events handlers
    #
    ###############################################################################################

    def OnRadio(self, action, data, match=None):
        cid = match.group('cid')
        msg_group = match.group('msg_group')
        msg_id = match.group('msg_id')
        location = match.group('location')
        text = match.group('text')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_RADIO, client=client, data={
            'msg_group': msg_group,
            'msg_id': msg_id,
            'location': location,
            'text': text
        })

    def OnCallvote(self, action, data, match=None):
        cid = match.group('cid')
        vote_string = match.group('vote_string')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_CALLVOTE, client=client, data=vote_string)

    def OnVote(self, action, data, match=None):
        cid = match.group('cid')
        value = match.group('value')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_VOTE, client=client, data=value)

    def OnClientjumptimerstarted(self, action, data, match=None):
        cid = match.group('cid')
        way_id = match.group('way_id')
        way_label = match.group('way_label')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_JUMP_TIMER_START, client=client, data={'way_id': way_id, 'way_label': way_label})

    def OnClientjumptimerstopped(self, action, data, match=None):
        cid = match.group('cid')
        way_id = match.group('way_id')
        way_label = match.group('way_label')
        duration = match.group('duration')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_JUMP_TIMER_STOP, client=client, data={'way_id': way_id, 'way_label': way_label, 'duration': duration})

    def OnClientsaveposition(self, action, data, match=None):
        cid = match.group('cid')
        position = float(match.group('x')), float(match.group('y')), float(match.group('z'))
        name = match.group('name')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_POS_SAVE, client=client, data={'position': position, 'name': name})

    def OnClientloadposition(self, action, data, match=None):
        cid = match.group('cid')
        position = float(match.group('x')), float(match.group('y')), float(match.group('z'))
        name = match.group('name')
        client = self.getByCidOrJoinPlayer(cid)
        if not client:
            self.debug('No client found')
            return None
        return Event(self.EVT_CLIENT_POS_LOAD, client=client, data={'position': position, 'name': name})

    def OnSurvivorwinner(self, action, data, match=None):
        #SurvivorWinner: Blue
        #SurvivorWinner: Red
        #SurvivorWinner: 0
        if data in ('Blue', 'Red'):
            return b3.events.Event(b3.events.EVT_SURVIVOR_WIN, data)
        else:
            client = self.getByCidOrJoinPlayer(data)
            if not client:
                self.debug('No client found')
                return None
            return Event(self.EVT_CLIENT_SURVIVOR_WINNER, client=client, data=None)



    ###############################################################################################
    #
    #    B3 Parser interface implementation
    #
    ###############################################################################################

    def authorizeClients(self):
        pass


    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('ban', cid=client, reason=reason))
            return
        elif not client.id:
            # no client id, database must be down, do tempban
            self.error('Q3AParser.ban(): no client id, database must be down, doing tempban')
            return self.tempban(client, reason, '1d', admin, silent)

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))

        if client.cid is None:
            # ban by ip, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByIp', ip=client.ip, reason=reason))
            self.write(self.getCommand('banByIp', ip=client.ip, reason=reason))
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', cid=client.cid, reason=reason))

            if self._permban_with_frozensand:
                cmd = self.getCommand('auth-permban', cid=client.cid)
                self.info('sending ban to Frozen Sand : %s' % cmd)
                rv = self.write(cmd)
                if rv:
                    if rv == "Auth services disabled" or rv.startswith("auth: not banlist available."):
                        self.warning(rv)
                    elif rv.startswith("auth: sending ban"):
                        self.info(rv)
                        time.sleep(.250)
                    else:
                        self.warning(rv)
                        time.sleep(.250)

            if client.connected:
                cmd = self.getCommand('ban', cid=client.cid, reason=reason)
                self.info('sending ban to server : %s' % cmd)
                rv = self.write(cmd)
                if rv:
                    self.info(rv)

        if not silent and fullreason != '':
            self.say(fullreason)

        if admin:
            admin.message('^3banned^7: ^1%s^7 (^2@%s^7). His last ip (^1%s^7) has been added to banlist'%(client.exactName, client.id, client.ip))

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))
        client.disconnect()



    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        duration = time2minutes(duration)

        if isinstance(client, Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('tempban', cid=client, reason=reason))
            return
        elif admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))

        if self._tempban_with_frozensand:
            minutes = duration
            days = hours = 0
            while minutes >= 60:
                hours += 1
                minutes -= 60
            while hours >= 24:
                days += 1
                hours -= 24

            cmd = self.getCommand('auth-tempban', cid=client.cid, days=days, hours=hours, minutes=int(minutes))
            self.info('sending ban to Frozen Sand : %s' % cmd)
            rv = self.write(cmd)
            if rv:
                if rv == "Auth services disabled" or rv.startswith("auth: not banlist available."):
                    self.warning(rv)
                elif rv.startswith("auth: sending ban"):
                    self.info(rv)
                    time.sleep(.250)
                else:
                    self.warning(rv)
                    time.sleep(.250)

        if client.connected:
            cmd = self.getCommand('tempban', cid=client.cid, reason=reason)
            self.info('sending ban to server : %s' % cmd)
            rv = self.write(cmd)
            if rv:
                self.info(rv)

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason,
                                                                        'duration': duration,
                                                                        'admin': admin}
            , client))
        client.disconnect()



    def inflictCustomPenalty(self, type, client, reason=None, duration=None, admin=None, data=None):
        if type == 'slap' and client:
            cmd = self.getCommand('slap', cid=client.cid)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        elif type == 'nuke' and client:
            cmd = self.getCommand('nuke', cid=client.cid)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        elif type == 'mute' and client:
            if duration is None:
                seconds = 60
            else:
                seconds = round(float(time2minutes(duration) * 60), 0)

            # make sure to unmute first
            cmd = self.getCommand('mute', cid=client.cid, seconds=0)
            self.write(cmd)
            # then mute
            cmd = self.getCommand('mute', cid=client.cid, seconds=seconds)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True

        elif type == 'kill' and client:
            cmd = self.getCommand('kill', cid=client.cid)
            self.write(cmd)
            if reason:
                client.message("%s" % reason)
            return True


    ###############################################################################################
    #
    #    Other methods
    #
    ###############################################################################################

    def queryClientFrozenSandAccount(self, cid):
        """
        : auth-whois 0
        auth: id: 0 - name: ^7laCourge - login:  - notoriety: 0 - level: 0  - ^7no account

        : auth-whois 0
        auth: id: 0 - name: ^7laCourge - login: courgette - notoriety: serious - level: -1

        : auth-whois 3
        Client 3 is not active.
        """
        data = self.write('auth-whois %s' % cid)
        if not data:
            return {}

        if data == "Client %s is not active." % cid:
            return {}

        m = self._re_authwhois.match(data)
        if m:
            return m.groupdict()
        else:
            return {}


    def queryAllFrozenSandAccount(self, maxRetries=None):
        data = self.write('auth-whois all', maxRetries=maxRetries)
        if not data:
            return {}
        players = {}
        for m in re.finditer(self._re_authwhois, data):
            players[m.group('cid')] = m.groupdict()
        return players


    def is_frozensand_auth_available(self):
        auth = self.getCvar('auth').getInt()
        return auth != 0


    # Parse Userinfo
    def OnClientuserinfo(self, action, data, match=None):
        #2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65
        #conecting bot:
        #0 \gear\GMIORAA\team\blue\skill\5.000000\characterfile\bots/ut_chicken_c.c\color\4\sex\male\race\2\snaps\20\rate\25000\name\InviteYourFriends!
        bclient = self.parseUserInfo(data)

        if not bclient.has_key('cl_guid') and bclient.has_key('skill'):
            # must be a bot connecting
            self.bot('Bot Connecting!')
            bclient['ip'] = '0.0.0.0'
            bclient['cl_guid'] = 'BOT' + str(bclient['cid'])

        if bclient.has_key('name'):
            # remove spaces from name
            bclient['name'] = bclient['name'].replace(' ','')


        # split port from ip field
        if bclient.has_key('ip'):
            ipPortData = bclient['ip'].split(':', 1)
            bclient['ip'] = ipPortData[0]
            if len(ipPortData) > 1:
                bclient['port'] = ipPortData[1]

        if bclient.has_key('team'):
            bclient['team'] = self.getTeam(bclient['team'])

        self.verbose('Parsed user info %s' % bclient)

        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    if hasattr(client, 'gear') and k == 'gear' and client.gear != v:
                        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_GEAR_CHANGE, v, client))
                    if not k.startswith('_') and k not in ('login', 'password', 'groupBits', 'maskLevel', 'autoLogin', 'greeting'):
                        setattr(client, k, v)
            else:
                #make a new client
                # use cl_guid
                if bclient.has_key('cl_guid'):
                    guid = bclient['cl_guid']
                else:
                    guid = 'unknown'

                # query FrozenSand Account
                auth_info = self.queryClientFrozenSandAccount(bclient['cid'])
                fsa = auth_info.get('login', None)

                # v1.0.17 - mindriot - 02-Nov-2008
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if not bclient.has_key('ip'):
                    if guid == 'unknown':
                        # happens when a client is (temp)banned and got kicked so client was destroyed, but
                        # infoline was still waiting to be parsed.
                        self.debug('Client disconnected. Ignoring.')
                        return None
                    else:
                        # see issue xlr8or/big-brother-bot#87 - ip can be missing
                        try:
                            self.debug("missing IP, trying to get ip with 'status'")
                            plist = self.getPlayerList()
                            client_data = plist[bclient['cid']]
                            bclient['ip'] = client_data['ip']
                        except Exception, err:
                            bclient['ip'] = ''
                            self.warning("Failed to get client %s ip address." % bclient['cid'], err)



                nguid = ''
                # overide the guid... use ip's only if self.console.IpsOnly is set True.
                if self.IpsOnly:
                    nguid = bclient['ip']
                # replace last part of the guid with two segments of the ip
                elif self.IpCombi:
                    i = bclient['ip'].split('.')
                    d = len(i[0])+len(i[1])
                    nguid = guid[:-d]+i[0]+i[1]
                # Quake clients don't have a cl_guid, we'll use ip instead
                elif guid == 'unknown':
                    nguid = bclient['ip']

                if nguid != '':
                    guid = nguid

                self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE,
                    guid=guid, pbid=fsa, data=auth_info)

        return None


    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)

        if gameTypeInt == '0':
            _gameType = 'ffa'
        elif gameTypeInt == '1': # Last Man Standing
            _gameType = 'lms'
        elif gameTypeInt == '2':   # Dunno either
            _gameType = 'dm'
        elif gameTypeInt == '3':
            _gameType = 'tdm'
        elif gameTypeInt == '4':
            _gameType = 'ts'
        elif gameTypeInt == '5':
            _gameType = 'ftl'
        elif gameTypeInt == '6':
            _gameType = 'cah'
        elif gameTypeInt == '7':
            _gameType = 'ctf'
        elif gameTypeInt == '8':
            _gameType = 'bm'
        elif gameTypeInt == '9':
            _gameType = 'jump'

        #self.debug('_gameType: %s' % _gameType)
        return _gameType


    def _getDamagePoints(self, weapon, hitloc):
        """
        provide the estimated number of damage points inflicted by a hit of a given weapon to a given body location.
        """
        '''
        try:
            points = self.damage[weapon][int(hitloc)]
            self.debug("_getDamagePoints(%s, %s) -> %s" % (weapon, hitloc, points))
            return points
        except KeyError, err:
            self.warning("_getDamagePoints(%s, %s) cannot find value : %s" % (weapon, hitloc, err))
            return 15
        '''
        # until we got real values, we return the default value
        return 15


    def patch_spamcontrolPlugin(self):
        """ This method alters the Spamcontrol plugin after it started to make it aware of RADIO spam """
        self.info("Patching Spamcontrol plugin")
        # teach the Spamcontrol plugin how to react on such events
        def onRadio(this, event):
            new_event = Event(type=event.type, client=event.client, target=event.target, data=repr(event.data))
            this.onChat(new_event)
        self.spamcontrolPlugin.onRadio = new.instancemethod(onRadio, self.spamcontrolPlugin, SpamcontrolPlugin)
        self.spamcontrolPlugin.eventHanlders[self.EVT_CLIENT_RADIO] = self.spamcontrolPlugin.onRadio
        self.spamcontrolPlugin.registerEvent(self.EVT_CLIENT_RADIO)



    @staticmethod
    def patch_Clients():
        def newClient(self, cid, **kwargs):
            client = Iourt42Client(console=self.console, cid=cid, timeAdd=self.console.time(), **kwargs)
            self[client.cid] = client
            self.resetIndex()

            self.console.debug('Urt42 Client Connected: [%s] %s - %s (%s)', self[client.cid].cid, self[client.cid].name, self[client.cid].guid, self[client.cid].data)

            self.console.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_CONNECT,
                client,
                client))

            if client.guid:
                client.auth()
            elif not client.authed:
                self.authorizeClients()
            return client
        b3.clients.Clients.newClient = newClient

########NEW FILE########
__FILENAME__ = moh
#
# Medal of Honor Parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 James 'Bakes' Baker (bakes@bigbrotherbot.net)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 2010/11/07 - 0.10 - Courgette
# * add new maps info
# 2010/11/08 - 0.9.2 - GrosBedo
# * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# 2010/10/27 - 0.9.1 - GrosBedo
# * messages now support named $variables instead of %s
# 2010/10/27 - 0.9 - Courgette
# * when banning, also kick to take over MoH engine failure to enforce bans. This
#   will need more test to determine how to make the MoH engine enforce temp bans.
# 2010/10/24 - 0.8 - Courgette
# * fix OnServerRoundover and OnServerRoundoverplayers
# 2010/10/24 - 0.7 - Courgette
# * add missing getTeam() method
# 2010/10/24 - 0.6 - Courgette
# * minor fixes
# 2010/10/23 - 0.5 - Courgette
# * create specific events : EVT_GAME_ROUND_PLAYER_SCORES and EVT_GAME_ROUND_TEAM_SCORES
# * now fires native B3 event EVT_GAME_ROUND_END
# * manage team changed event correctly
# 2010/10/23 - 0.4 - Courgette
# * refactor inheriting from frostbite AbstratParser 
# * change available server var list
# 2010/10/10 - 0.3 - Bakes
# * getEasyName is now implemented and working, getHardName is implemented
#   but not working.
# 2010/10/07 - 0.2 - Courgette
# * add gameName property. Fix SAY_LINE_MAX_LENGTH
# 2010/09/25 - 0.1 - Bakes
# * Initial version of MoH parser - hasn't been tested with OnKill events yet
#   but basic commands seem to work.
# 2010-11-21 - 1.0 - Courgette
# * add rotateMap and changeMap to fix !maprotate and !map#
# 2011-02-01 - 1.1 - xlr8or
# * adapted to server R9 version 615937 - fixed onPlayerSpawn and vars.noCrosshairs errors
# 2011-03-05 - 1.2 - xlr8or
# * admin.kickPlayer after ban now in try/except to avoid error msg when player is already gone
# 2011-04-09 - 1.2.1 - Courgette
# * import missing time module
# 2011-05-22 - 1.2.2 - Courgette
# * move events EVT_GAME_ROUND_PLAYER_SCORES and EVT_GAME_ROUND_TEAM_SCORES to abstract Frostbite parser 
#   as they also exist in BFBC2
# 2011-06-04 - 1.3.0 - Courgette
# makes use of the new pluginsStarted parser hook
# 2011-06-05 - 1.4.0 - Courgette
# * change data format for EVT_CLIENT_BAN_TEMP and EVT_CLIENT_BAN events
# 2012-10-60 - 1.5 - Courgette
# reflect changes in abstract parser 1.6
#
__author__  = 'Bakes, Courgette'
__version__ = '1.5'

import time
import b3.events
from b3.parsers.frostbite.abstractParser import AbstractParser
from b3.parsers.frostbite.util import PlayerInfoBlock
import b3.functions

SAY_LINE_MAX_LENGTH = 100

class MohParser(AbstractParser):
    gameName = 'moh'
    
    _gameServerVars = (
        'serverName', # vars.serverName [name] Set the server name 
        'gamePassword', # vars.gamePassword [password] Set the game password for the server 
        'punkBuster', # vars.punkBuster [enabled] Set if the server will use PunkBuster or not 
        'hardCore', # vars.hardCore[enabled] Set hardcore mode 
        'ranked', # vars.ranked [enabled] Set ranked or not 
        'skillLimit', # vars.skillLimit [lower, upper] Set the skill limits allowed on to the server 
        'noUnlocks', # vars.noUnlocks [enabled] Set if unlocks should be disabled 
        'noAmmoPickups', # vars.noAmmoPickups [enabled] Set if pickups should be disabled 
        'realisticHealth', # vars.realisticHealth [enabled] Set if health should be realistic 
        'supportAction', # vars.supportAction [enabled] Set if support action should be enabled 
        'preRoundLimit', # vars.preRoundLimit [upper, lower] Set pre round limits. Setting both to zero means the game uses whatever settings are used on the specific levels. On ranked servers, the lowest values allowed are lower = 2 and upper = 4.
        'roundStartTimerPlayersLimit', # vars.roundStartTimerPlayersLimit [limit] Get/Set the number of players that need to spawn on each team for the round start timer to start counting down.
        'roundStartTimerDelay', # vars.roundStartTimerDelay [delay] If set to other than -1, this value overrides the round start delay set on the individual levels.
        'tdmScoreCounterMaxScore', # vars.tdmScoreCounterMaxScore [score] If set to other than -1, this value overrides the score needed to win a round of Team Assault, Sector Control or Hot Zone. 
        'clanTeams', # vars.clanTeams [enabled] Set if clan teams should be used 
        'friendlyFire', # vars.friendlyFire [enabled] Set if the server should allow team damage 
        'currentPlayerLimit', # vars.currentPlayerLimit Retrieve the current maximum number of players 
        'maxPlayerLimit', # vars.maxPlayerLimit Retrieve the server-enforced maximum number of players 
        'playerLimit', # vars.playerLimit [nr of players] Set desired maximum number of players 
        'bannerUrl', # vars.bannerUrl [url] Set banner url 
        'serverDescription', # vars.serverDescription [description] Set server description 
        'noCrosshairs', # vars.noCrosshairs [enabled] Set if crosshairs for all weapons is hidden
        'noSpotting', # vars.noSpotting [enabled] Set if spotted targets are disabled in the 3d-world 
        'teamKillCountForKick', # vars.teamKillCountForKick [count] Set number of teamkills allowed during a round 
        'teamKillValueForKick', # vars.teamKillValueForKick [count] Set max kill-value allowed for a player before he/she is kicked 
        'teamKillValueIncrease', # vars.teamKillValueIncrease [count] Set kill-value increase for a teamkill 
        'teamKillValueDecreasePerSecond', # vars.teamKillValueDecreasePerSecond [count] Set kill-value decrease per second
        'idleTimeout', # vars.idleTimeout [time] Set idle timeout vars.profanityFilter [enabled] Set if profanity filter is enabled
    )
    
    def startup(self):
        AbstractParser.startup(self)
        
        # create the 'Server' client
        self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN)

        if self.config.has_option('moh', 'max_say_line_length'):
            try:
                maxlength = self.config.getint('moh', 'max_say_line_length')
                if maxlength > SAY_LINE_MAX_LENGTH:
                    self.warning('max_say_line_length cannot be greater than %s' % SAY_LINE_MAX_LENGTH)
                    maxlength = SAY_LINE_MAX_LENGTH
                if maxlength < 20:
                    self.warning('max_say_line_length is way too short. using default')
                    maxlength = self._settings['line_length']
                self._settings['line_length'] = maxlength
                self._settings['min_wrap_length'] = maxlength
            except Exception, err:
                self.error('failed to read max_say_line_length setting "%s" : %s' % (self.config.get('moh', 'max_say_line_length'), err))
        self.debug('line_length: %s' % self._settings['line_length'])
            
            
        self.verbose('GameType: %s, Map: %s' %(self.game.gameType, self.game.mapName))
        

    def pluginsStarted(self):
        self.info('connecting all players...')
        plist = self.getPlayerList()
        for cid, p in plist.iteritems():
            client = self.clients.getByCID(cid)
            if not client:
                #self.clients.newClient(playerdata['cid'], guid=playerdata['guid'], name=playerdata['name'], team=playerdata['team'], squad=playerdata['squad'])
                name = p['name']
                if 'clanTag' in p and len(p['clanTag']) > 0:
                    name = "[" + p['clanTag'] + "] " + p['name']
                self.debug('client %s found on the server' % cid)
                client = self.clients.newClient(cid, guid=p['guid'], name=name, team=p['teamId'], data=p)
                self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))
                
        
        
    def checkVersion(self):
        version = self.output.write('version')
        self.info('server version : %s' % version)
        if version[0] != 'MOH':
            raise Exception("the moh parser can only work with Medal of Honor")

    def getClient(self, cid, _guid=None):
        """Get a connected client from storage or create it
        B3 CID   <--> MoH character name
        B3 GUID  <--> MoH EA_guid
        """
        # try to get the client from the storage of already authed clients
        client = self.clients.getByCID(cid)
        if not client:
            if cid == 'Server':
                return self.clients.newClient('Server', guid='Server', name='Server', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN)
            # must be the first time we see this client
            words = self.write(('admin.listPlayers', 'player', cid))
            pib = PlayerInfoBlock(words)
            if len(pib) == 0:
                self.debug('no such client found')
                return None
            p = pib[0]
            cid = p['name']
            name = p['name']

            # Let's see if we have a guid, either from the PlayerInfoBlock, or passed to us by OnPlayerAuthenticated()
            if p['guid']:
                guid = p['guid']
            elif _guid:
                guid = _guid
            else:
                # If we still don't have a guid, we cannot create a newclient without the guid!
                self.debug('No guid for %s, waiting for next event.' %name)
                return None

            if 'clanTag' in p and len(p['clanTag']) > 0:
                name = "[" + p['clanTag'] + "] " + p['name']
            client = self.clients.newClient(cid, guid=guid, name=name, team=self.getTeam(p['teamId']), teamId=int(p['teamId']), data=p)
            self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, p, client))
        
        return client

    def getHardName(self, mapname):
        """ Change real name to level name """
        mapname = mapname.lower()
        if mapname.startswith('mazar-i-sharif airfield'):
            return 'levels/mp_01'
        
        elif mapname.startswith('bagram hanger'):
            return 'levels/mp_01_elimination'
            
        elif mapname.startswith('shah-i-knot mountains'):
            return 'levels/mp_02'
        
        elif mapname.startswith('hindu kush pass'):
            return 'levels/mp_02_koth'
        
        elif mapname.startswith('khyber caves'):
            return 'levels/mp_03'
            #return 'levels/mp_03_elimination'

        elif mapname.startswith('helmand valley'):
            return 'levels/mp_04'
        
        elif mapname.startswith('helmand river hill'):
            return 'levels/mp_04_koth'

        elif mapname.startswith('kandahar marketplace'):
            return 'levels/mp_05'

        elif mapname.startswith('diwagal camp'):
            return 'levels/mp_06'
            #return 'mp_06_elimination'
        
        elif mapname.startswith('korengal outpost'):
            return 'levels/mp_07_koth'

        elif mapname.startswith('kunar base'):
            return 'levels/mp_08'

        elif mapname.startswith('kabul city ruins'):
            return 'levels/mp_09'
            #return 'levels/mp_09_elimination'

        elif mapname.startswith('garmzir town'):
            return 'levels/mp_10'

        else:
            self.warning('unknown level name \'%s\'. Please make sure you have entered a valid mapname' % mapname)
            return mapname

    def getEasyName(self, mapname):
        """ Change levelname to real name """
        if mapname.startswith('levels/mp_01_elimination'):
            return 'Bagram Hanger'
        
        elif mapname.startswith('levels/mp_01'):
            return 'Mazar-i-Sharif Airfield'
            
        elif mapname.startswith('levels/mp_02_koth'):
            return 'Hindu Kush Pass'
        
        elif mapname.startswith('levels/mp_02'):
            return 'Shah-i-Knot Mountains'

        elif mapname.startswith('levels/mp_03'):
            return 'Khyber Caves'

        elif mapname.startswith('levels/mp_04_koth'):
            return 'Helmand River Hill'

        elif mapname.startswith('levels/mp_04'):
            return 'Helmand Valley'

        elif mapname.startswith('levels/mp_05'):
            return 'Kandahar Marketplace'

        elif mapname.startswith('levels/mp_06'):
            return 'Diwagal Camp'

        elif mapname.startswith('levels/mp_07_koth'):
            return 'Korengal Outpost'

        elif mapname.startswith('levels/mp_08'):
            return 'Kunar Base'

        elif mapname.startswith('levels/mp_09'):
            return 'Kabul City Ruins'

        elif mapname.startswith('levels/mp_10'):
            return 'Garmzir Town'
        
        else:
            self.warning('unknown level name \'%s\'. Please report this on B3 forums' % mapname)
            return mapname

    def getServerVars(self):
        """Update the game property from server fresh data"""
        try: self.game.serverName = self.getCvar('serverName').getBoolean()
        except: pass
        try: self.game.gamePassword = self.getCvar('gamePassword').getBoolean()
        except: pass
        try: self.game.punkBuster = self.getCvar('punkBuster').getBoolean()
        except: pass
        try: self.game.hardCore = self.getCvar('hardCore').getBoolean()
        except: pass
        try: self.game.ranked = self.getCvar('ranked').getBoolean()
        except: pass
        try: self.game.skillLimit = self.getCvar('skillLimit').getBoolean()
        except: pass
        try: self.game.noUnlocks = self.getCvar('noUnlocks').getBoolean()
        except: pass
        try: self.game.noAmmoPickups = self.getCvar('noAmmoPickups').getBoolean()
        except: pass
        try: self.game.realisticHealth = self.getCvar('realisticHealth').getBoolean()
        except: pass
        try: self.game.supportAction = self.getCvar('supportAction').getBoolean()
        except: pass
        try: self.game.preRoundLimit = self.getCvar('preRoundLimit').getBoolean()
        except: pass
        try: self.game.roundStartTimerPlayersLimit = self.getCvar('roundStartTimerPlayersLimit').getBoolean()
        except: pass
        try: self.game.roundStartTimerDelay = self.getCvar('roundStartTimerDelay').getBoolean()
        except: pass
        try: self.game.tdmScoreCounterMaxScore = self.getCvar('tdmScoreCounterMaxScore').getBoolean()
        except: pass
        try: self.game.clanTeams = self.getCvar('clanTeams').getBoolean()
        except: pass
        try: self.game.friendlyFire = self.getCvar('friendlyFire').getBoolean()
        except: pass
        try: self.game.currentPlayerLimit = self.getCvar('currentPlayerLimit').getBoolean()
        except: pass
        try: self.game.maxPlayerLimit = self.getCvar('maxPlayerLimit').getBoolean()
        except: pass
        try: self.game.playerLimit = self.getCvar('playerLimit').getBoolean()
        except: pass
        try: self.game.bannerUrl = self.getCvar('bannerUrl').getBoolean()
        except: pass
        try: self.game.serverDescription = self.getCvar('serverDescription').getBoolean()
        except: pass
        try: self.game.noCrosshair = self.getCvar('noCrosshair').getBoolean()
        except: pass
        try: self.game.noSpotting = self.getCvar('noSpotting').getBoolean()
        except: pass
        try: self.game.teamKillCountForKick = self.getCvar('teamKillCountForKick').getBoolean()
        except: pass
        try: self.game.teamKillValueForKick = self.getCvar('teamKillValueForKick').getBoolean()
        except: pass
        try: self.game.teamKillValueIncrease = self.getCvar('teamKillValueIncrease').getBoolean()
        except: pass
        try: self.game.teamKillValueDecreasePerSecond = self.getCvar('teamKillValueDecreasePerSecond').getBoolean()
        except: pass
        try: self.game.idleTimeout = self.getCvar('idleTimeout').getBoolean()
        except: pass
        
        
    def getTeam(self, team):
        """convert MOH team numbers to B3 team numbers"""
        team = int(team)
        if team == 1:
            return b3.TEAM_RED
        elif team == 2:
            return b3.TEAM_BLUE
        elif team == 3:
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN
        
        
    def OnPlayerSpawn(self, action, data):
        """
        Request:  player.onSpawn <soldier name: string> <kit: string> <weapon: string> <specializations: 3 x string>
        """
        if len(data) < 2:
            return None

        spawner = self.getClient(data[0])
        kit = data[1]
        weapon = data[2]
        spec1 = data[3]
        spec2 = data[4]
        spec3 = data[5]

        event = b3.events.EVT_CLIENT_SPAWN
        return b3.events.Event(event, (kit, weapon, spec1, spec2, spec3), spawner)


    def OnPlayerTeamchange(self, action, data):
        """
        player.onTeamChange <soldier name: player name> <team: Team ID>
        Effect: Player might have changed team
        """
        #['player.onTeamChange', 'Dalich', '2']
        client = self.getClient(data[0])
        if client:
            client.team = self.getTeam(data[1]) # .team setter will send team change event
            client.teamId = int(data[1])


    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        duration = b3.functions.time2minutes(duration)

        if isinstance(client, str):
            self.write(self.getCommand('kick', cid=client, reason=reason[:80]))
            return
        elif admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripColors(fullreason)
        reason = self.stripColors(reason)

        if self.PunkBuster:
            # punkbuster acts odd if you ban for more than a day
            # tempban for a day here and let b3 re-ban if the player
            # comes back
            if duration > 1440:
                duration = 1440

            self.PunkBuster.kick(client, duration, reason)
        self.write(('banList.list',))
        self.write(self.getCommand('tempban', guid=client.guid, duration=duration*60, reason=reason[:80]))
        self.write(('banList.list',))
        ## also kick as the MoH server seems not to enforce all bans correctly
        self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))
        
        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                        , client))


    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """Permanent ban"""
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, b3.clients.Client):
            self.write(self.getCommand('ban', guid=client.guid, reason=reason[:80]))
            try:
                self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))
            except:
                pass
            return

        if admin:
            reason = self.getMessage('banned_by', client.exactName, admin.exactName, reason)
        else:
            reason = self.getMessage('banned', client.exactName, reason)
        reason = self.stripColors(reason)

        if client.cid is None:
            # ban by ip, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByIp', ip=client.ip, reason=reason[:80]))
            self.write(self.getCommand('banByIp', ip=client.ip, reason=reason[:80]))
            if admin:
                admin.message('banned: %s (@%s). His last ip (%s) has been added to banlist'%(client.exactName, client.id, client.ip))
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', guid=client.guid, reason=reason[:80]))
            self.write(('banList.list',))
            self.write(self.getCommand('ban', cid=client.cid, reason=reason[:80]))
            self.write(('banList.list',))
            self.write(self.getCommand('kick', cid=client.cid, reason=reason[:80]))
            if admin:
                admin.message('banned: %s (@%s) has been added to banlist'%(client.exactName, client.id))

        if self.PunkBuster:
            self.PunkBuster.banGUID(client, reason)
        
        if not silent:
            self.say(reason)
        
        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))


    def rotateMap(self):
        """Load the next map (not level). If the current game mod plays each level twice
        to get teams the chance to play both sides, then this rotate a second
        time to really switch to the next map"""
        nextIndex = self.getNextMapIndex()
        if nextIndex == -1:
            # No map in map rotation list, just call admin.runNextLevel
            self.write(('admin.runNextRound',))
        else:
            self.write(('mapList.nextLevelIndex', nextIndex))
            self.write(('admin.runNextRound',))
    
    
    def changeMap(self, map):
        """Change to the given map
        
        1) determine the level name
            If map is of the form 'mp_001' and 'Kaboul' is a supported
            level for the current game mod, then this level is loaded.
            
            In other cases, this method assumes it is given a 'easy map name' (like
            'Port Valdez') and it will do its best to find the level name that seems
            to be for 'Port Valdez' within the supported levels.
        
            If no match is found, then instead of loading the map, this method 
            returns a list of candidate map names
            
        2) if we got a level name
            if the level is not in the current rotation list, then add it to 
            the map list and load it
        """

        supportedMaps = self.getSupportedMaps()
        if 'levels/%s'%map in supportedMaps:
            map = 'levels/%s'%map

        if map not in supportedMaps:
            match = self.getMapsSoundingLike(map)
            if len(match) == 1:
                map = match[0]
            else:
                return match

        if map in supportedMaps:
            levelnames = self.write(('mapList.list',))
            if map not in levelnames:
                # add the map to the map list
                nextIndex = self.getNextMapIndex()
                if nextIndex == -1:
                    self.write(('mapList.append', map))
                    nextIndex = 0
                else:
                    if nextIndex == 0:
                        # case where the map list contains only 1 map
                        nextIndex = 1
                    self.write(('mapList.insert', nextIndex, map))
            else:
                nextIndex = 0
                while nextIndex < len(levelnames) and levelnames[nextIndex] != map:
                    nextIndex += 1
            
            self.say('Changing map to %s' % map)
            time.sleep(1)
            self.write(('mapList.nextLevelIndex', nextIndex))
            self.write(('admin.runNextRound', ))
            
            

########NEW FILE########
__FILENAME__ = oa081
# OpenArena 0.8.1 parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 Courgette & GrosBedo
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA    02110-1301    USA
#
# CHANGELOG
# 08/08/2010 - 0.1 - Courgette
# * creation based on smg11 parser
# 09/08/2010 - 0.2 - Courgette
# * implement rotatemap()
# 09/08/2010 - 0.3 - Courgette & GrosBedo
# * bot now recognize /tell commands correctly
# 10/08/2010 - 0.4 - Courgette
# * recognizes MOD_SUICIDE as suicide
# * get rid of PunkBuster related code
# * should \rcon dumpuser in cases the ClientUserInfoChanged line does not have
#   guid while player is not a bot. (untested, cannot reproduce)
# 11/08/2010 - 0.5 - GrosBedo
# * minor fix for the /rcon dumpuser when no guid
# * added !nextmap (with recursive detection !)
# 11/08/2010 - 0.6 - GrosBedo
# * fixed the permanent ban command (banClient -> banaddr)
# 12/08/2010 - 0.7 - GrosBedo
# * added weapons and means of death. Define what means of death are suicides
# 17/08/2010 - 0.7.1 - GrosBedo
# * added say_team recognition
# 20/08/2010 - 0.7.5 - GrosBedo
# * added many more regexp to detect ctf events, cvars and awards
# * implement permban by ip and unbanbyip
# * implement team recognition
# 20/08/2010 - 0.8 - Courgette
# * clean regexp (Item, CTF, Award, fallback)
# * clean OnItem
# * remove OnDamage
# * add OnCtf and OnAward
# 27/08/2010 - 0.8.1 - GrosBedo
# * fixed findnextmap underscore bug (maps and vstr cvars with an underscore are now correctly parsed)
# 28/08/2010 - 0.8.2 - Courgette
# * fix another findnextmap underscore bug
# 28/08/2010 - 0.8.3 - Courgette
# * fix issue with the regexp that match 'Award:' lines
# 04/09/2010 - 0.8.4 - GrosBedo
# * fix issue with CTF flag capture events
# 17/09/2010 - 0.8.5 - GrosBedo
# * fix crash issue when a player has disconnected at the very time the bot check for the list of players
# 20/10/2010 - 0.9 - GrosBedo
# * fix a BIG issue when detecting teams (were always unknown)
# 20/10/2010 - 0.9.1 - GrosBedo
# * fix tk issue with DM and other team free gametypes
# 20/10/2010 - 0.9.2 - GrosBedo
# * added EVT_GAME_FLAG_RETURNED (move it to q3a or a generic ioquake3 parser?)
# 23/10/2010 - 0.9.3 - GrosBedo
# * detect gametype and modname at startup
# * added flag_taken action
# * fix a small bug when triggering the flag return event
# 07/11/2010 - 0.9.4 - GrosBedo
# * ban and unban messages are now more generic and can be configured from b3.xml
# * messages now support named $variables instead of %s
# 08/11/2010 - 0.9.5 - GrosBedo
# * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
# 09/04/2011 - 0.9.6 - Courgette
# * reflect that cid are not converted to int anymore in the clients module
# 06/06/2011 - 0.10.0 - Courgette
# * change data format for EVT_CLIENT_BAN events
# 14/06/2011 - 0.11.0 - Courgette
# * cvar code moved to q3a AbstractParser
#
__author__  = 'Courgette, GrosBedo'
__version__ = '0.11.0'

import re, string, thread, time, threading
import b3
import b3.events
from b3.parsers.q3a.abstractParser import AbstractParser

class Oa081Parser(AbstractParser):
    gameName = 'oa081'
    _connectingSlots = []
    _maplist = None
    
    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _empty_name_default = 'EmptyNameDefault'

    _commands = {}
    #_commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    #_commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['message'] = 'say %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'say %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banaddr %(cid)s' #addip for q3a
    _commands['tempban'] = 'clientkick %(cid)s'
    _commands['banByIp'] = 'banaddr %(ip)s'
    _commands['unbanByIp'] = 'bandel %(cid)s' #removeip for q3a
    _commands['banlist'] = 'listbans' #g_banips for q3a

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'restartgame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:.]+\s?)?')

    _lineFormats = (
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        
        # 1:25 CTF: 1 2 2: Sarge returned the BLUE flag!
        # 1:16 CTF: 1 1 3: Sarge fragged RED's flag carrier!
        # 6:55 CTF: 2 1 2: Burpman returned the RED flag!
        # 7:02 CTF: 2 2 1: Burpman captured the BLUE flag!
        re.compile(r'^(?P<action>CTF):\s+(?P<cid>[0-9]+)\s+(?P<fid>[0-9]+)\s+(?P<type>[0-9]+):\s+(?P<data>.*(?P<color>RED|BLUE).*)$', re.IGNORECASE),
        
        #47:05 Kill: 2 4 11: Sarge killed ^6Jondah by MOD_LIGHTNING
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        
        # 7:02 Award: 2 4: Burpman gained the CAPTURE award!
        # 7:02 Award: 2 5: Burpman gained the ASSIST award!
        # 7:30 Award: 2 3: Burpman gained the DEFENCE award!
        # 29:15 Award: 2 2: SalaManderDragneL gained the IMPRESSIVE award!
        # 32:08 Award: 2 1: SalaManderDragneL gained the EXCELLENT award!
        # 8:36 Award: 10 1: Karamel is a fake gained the EXCELLENT award!
        re.compile(r'^(?P<action>Award):\s+(?P<cid>[0-9]+)\s+(?P<awardtype>[0-9]+):\s+(?P<data>(?P<name>.+) gained the (?P<awardname>\w+) award!)$', re.IGNORECASE),

        #
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),

        # 81:16 tell: grosbedo to courgette: !help
        # 81:16 say: grosbedo: !help
        re.compile(r'^(?P<action>tell):\s(?P<data>(?P<name>.+) to (?P<aname>.+): (?P<text>.*))$', re.IGNORECASE),
        
        # 19:33 sayteam: UnnamedPlayer: ahahaha
        re.compile(r'^(?P<action>sayteam):\s(?P<data>(?P<name>.+): (?P<text>.*))$', re.IGNORECASE),

        # 46:37 Item: 4 team_CTF_redflag
        # 54:52 Item: 2 weapon_plasmagun
        re.compile(r'^(?P<action>Item):\s+(?P<cid>[0-9]+)\s+(?P<data>.*)$', re.IGNORECASE),

        #
        # Falling through?
        # 1:05 ClientConnect: 3
        # 1:05 ClientUserinfoChanged: 3 guid\CAB616192CB5652375401264987A23D0\n\xlr8or\t\0\model\wq_male2/red\g_redteam\\g_blueteam\\hc\100\w\0\l\0\tt\0\tl\0
        re.compile(r'^(?P<action>[a-z_]\w*):\s*(?P<data>.*)$', re.IGNORECASE)
    )

    #map: dm_fort
    #num score ping name            lastmsg address               qport rate
    #--- ----- ---- --------------- ------- --------------------- ----- -----
    #  1     1    0 TheMexican^7          100 bot                       0 16384
    #  2     1    0 Sentenza^7             50 bot                       0 16384
    #  3     3   37 xlr8or^7                0 145.99.135.227:27960   3598 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    # 7:44 Exit: Capturelimit hit.
    # 7:44 red:8  blue:0
    # 7:44 score: 63  ping: 81  client: 2 ^2^^0Pha^7nt^2om^7^^0Boo
    # 7:44 score: 0  ping: 0  client: 1 Sarge
    _reTeamScores = re.compile(r'^red:(?P<RedScore>.+)\s+blue:(?P<BlueScore>.+)$', re.I)
    _rePlayerScore = re.compile(r'^score:\s+(?P<score>[0-9]+)\s+ping:\s+(?P<ping>[0-9]+|CNCT|ZMBI)\s+client:\s+(?P<slot>[0-9]+)\s+(?P<name>.*)$', re.I)

    
    # Ban #1: 200.200.200.200/32
    _reBanList = re.compile(r'^Ban #(?P<cid>[0-9]+):\s+(?P<ip>[0-9]+.[0-9]+.[0-9]+.[0-9]+)/(?P<range>[0-9]+)$', re.I)

    PunkBuster = None


    ##  means of death
    #===========================================================================
    MOD_UNKNOWN = 0
    MOD_SHOTGUN = 1
    MOD_GAUNTLET = 2
    MOD_MACHINEGUN = 3
    MOD_GRENADE = 4
    MOD_GRENADE_SPLASH = 5
    MOD_ROCKET = 6
    MOD_ROCKET_SPLASH = 7
    MOD_PLASMA = 8
    MOD_PLASMA_SPLASH = 9
    MOD_RAILGUN = 10
    MOD_LIGHTNING = 11
    MOD_BFG = 12
    MOD_BFG_SPLASH = 13
    MOD_WATER = 14
    MOD_SLIME = 15
    MOD_LAVA = 16
    MOD_CRUSH = 17
    MOD_TELEFRAG = 18
    MOD_FALLING = 19
    MOD_SUICIDE = 20
    MOD_TARGET_LASER = 21
    MOD_TRIGGER_HURT = 22
    # #ifdef MISSIONPACK
    MOD_NAIL = 23
    MOD_CHAINGUN = 24
    MOD_PROXIMITY_MINE = 25
    MOD_KAMIKAZE = 26
    MOD_JUICED = 27
    # #endif
    MOD_GRAPPLE = 28
    #===========================================================================

    
    ## meansOfDeath to be considered suicides
    Suicides = (
        MOD_WATER,
        MOD_SLIME,
        MOD_LAVA,
        MOD_CRUSH,
        MOD_FALLING,
        MOD_SUICIDE,
        MOD_TRIGGER_HURT,
    )
#---------------------------------------------------------------------------------------------------

    def startup(self):
    
        # registering a ioquake3 specific event
        self.Events.createEvent('EVT_GAME_FLAG_RETURNED', 'Flag returned')

        # add the world client
        self.clients.newClient('1022', guid='WORLD', name='World', hide=True, pbid='WORLD')

        # get map from the status rcon command
        map_name = self.getMap()
        if map_name:
            self.game.mapName = map_name
            self.info('map is: %s'%self.game.mapName)

        # get gamepaths/vars
        try:
            fs_game = self.getCvar('fs_game').getString()
            if fs_game == '':
                fs_game = 'baseoa'
            self.game.fs_game = fs_game
            self.game.modName = fs_game
            self.debug('fs_game: %s' % self.game.fs_game)
        except:
            self.game.fs_game = None
            self.game.modName = None
            self.warning("Could not query server for fs_game")

        try:
            self.game.fs_basepath = self.getCvar('fs_basepath').getString().rstrip('/')
            self.debug('fs_basepath: %s' % self.game.fs_basepath)
        except:
            self.game.fs_basepath = None
            self.warning("Could not query server for fs_basepath")

        try:
            self.game.fs_homepath = self.getCvar('fs_homepath').getString().rstrip('/')
            self.debug('fs_homepath: %s' % self.game.fs_homepath)
        except:
            self.game.fs_homepath = None
            self.warning("Could not query server for fs_homepath")

        try:
            self.game.gameType = self.defineGameType(self.getCvar('g_gametype').getString())
            self.debug('g_gametype: %s' % self.game.gameType)
        except:
            self.game.gameType = None
            self.warning("Could not query server for g_gametype")

        # initialize connected clients
        self.info('discover connected clients')
        plist = self.getPlayerList()
        for cid, c in plist.iteritems():
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfochanged(None, userinfostring)
        
            
#---------------------------------------------------------------------------------------------------

    # Added for debugging and identifying/catching log lineparts
    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                self.debug('XLR--------> line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            
            try:
                action =  m.group('action').lower()
            except IndexError:
                # special case for damage lines where no action group can be set
                action = 'damage'
            
            return (m, action, m.group('data').strip(), client, target)
        elif '------' not in line:
            self.verbose('XLR--------> line did not match format: %s' % line)

#---------------------------------------------------------------------------------------------------
       
        
    def OnClientconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        self.debug('OnClientConnect: %s, %s' % (data, client))
        return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)

    # Parse Userinfo
    def OnClientuserinfochanged(self, action, data, match=None):
        if data is None: # if the client disconnected and we are trying to force the server to give us an id, we end up with an empty data object, so we just return and everything should be fine (the slot should already be removed ln 336)
            return
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            cid = bclient['cid']
            
            if cid in self._connectingSlots:
                self.debug('client on slot %s is already being connected' % cid)
                return
            
            self._connectingSlots.append(cid)
            client = self.clients.getByCID(cid)

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if bclient.has_key('guid'):
                    guid = bclient['guid']
                else:
                    if bclient.has_key('skill'):
                        guid = 'BOT-' + str(cid)
                        self.verbose('BOT connected!')
                        self.clients.newClient(cid, name=bclient['name'], ip='0.0.0.0', state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid }, team=bclient['team'], money=20)
                        self._connectingSlots.remove(cid)
                        return None
                    else:
                        self.info('we are missing the guid but this is not a bot either, dumpuser')
                        self._connectingSlots.remove(cid)
                        self.OnClientuserinfochanged(None, self.queryClientUserInfoByCid(cid))
                        return
                
                if not bclient.has_key('ip'):
                    infoclient = self.parseUserInfo(self.queryClientUserInfoByCid(cid))
                    if 'ip' in infoclient:
                        bclient['ip'] = infoclient['ip']
                    else:
                        self.warning('failed to get client ip')
                
                if bclient.has_key('ip'):
                    self.clients.newClient(cid, name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid }, team=bclient['team'], money=20)
                else:
                    self.warning('failed to get connect client')
                    
            self._connectingSlots.remove(cid)
                
        return None

    # disconnect
    def OnKill(self, action, data, match=None):
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))
        
        victim = self.getByCidOrJoinPlayer(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfochanged(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in self.Suicides:
            # those kills should be considered suicides
            self.debug('OnKill: Fixed attacker, suicide detected: %s' %match.group('text'))
            attacker = victim
        else:
            attacker = self.getByCidOrJoinPlayer(match.group('acid'))
        ## end fix attacker
          
        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team != b3.TEAM_FREE and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not defined we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    # startgame
    def OnInitgame(self, action, data, match=None):
        self.debug('OnInitgame: %s' % data)
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                #self.debug('%s = %s' % (o[0],o[1]))
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()

        self.debug('Synchronizing client info')
        self.clients.sync()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)


    def OnSayteam(self, action, data, match=None):
        # Teaminfo does not exist in the sayteam logline, so we can't know in which team the user is in. So we set him in a -1 void team.
        client = self.clients.getByExactName(match.group('name'))

        if not client:
            self.verbose('No Client Found')
            return None

        data = match.group('text')
        client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, data, client, -1)


    def OnTell(self, action, data, match=None):
        #5:27 tell: woekele to XLR8or: test

        client = self.clients.getByExactName(match.group('name'))
        tclient = self.clients.getByExactName(match.group('aname'))

        if not client:
            self.verbose('No Client Found')
            return None

        data = match.group('text')
        if data and ord(data[:1]) == 21:
            data = data[1:]

        client.name = match.group('name')
        return b3.events.Event(b3.events.EVT_CLIENT_PRIVATE_SAY, data, client, tclient)

    # Action
    def OnAction(self, cid, actiontype, data, match=None):
        #Need example
        client = self.clients.getByCID(cid)
        if not client:
            self.debug('No client found')
            return None
        self.verbose('OnAction: %s: %s %s' % (client.name, actiontype, data) )
        return b3.events.Event(b3.events.EVT_CLIENT_ACTION, actiontype, client)

    def OnItem(self, action, data, match=None):
        client = self.getByCidOrJoinPlayer(match.group('cid'))
        if client:
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, match.group('data'), client)
        return None

    def OnCtf(self, action, data, match=None):
        # 1:25 CTF: 1 2 2: Sarge returned the BLUE flag!
        # 1:16 CTF: 1 1 3: Sarge fragged RED's flag carrier!
        # 6:55 CTF: 2 1 2: Burpman returned the RED flag!
        # 7:02 CTF: 2 2 1: Burpman captured the BLUE flag!
        # 2:12 CTF: 3 1 0: Tanisha got the RED flag!
        # 2:12 CTF: 3 2 0: Tanisha got the BLUE flag!

        cid = match.group('cid')
        client = self.getByCidOrJoinPlayer(match.group('cid'))
        flagteam = self.getTeam(match.group('fid'))
        flagcolor = match.group('color')
        action_types = {
            '0': 'flag_taken',
            '1': 'flag_captured',
            '2': 'flag_returned',
            '3': 'flag_carrier_kill',
        }
        try:
            action_id = action_types[match.group('type')]
        except KeyError:
            action_id = 'flag_action_' + match.group('type')
            self.debug('unknown CTF action type: %s (%s)' % (match.group('type'), match.group('data')))
        self.debug('CTF Event: %s from team %s %s by %s' %(action_id, flagcolor, flagteam, client.name))
        if action_id == 'flag_returned':
            return b3.events.Event(b3.events.EVT_GAME_FLAG_RETURNED, flagcolor)
        else:
            return self.OnAction(cid, action_id, data)
            #return b3.events.Event(b3.events.EVT_CLIENT_ACTION, action_id, client)

    def OnAward(self, action, data, match=None):
        ## Award: <cid> <awardtype>: <name> gained the <awardname> award!
        # 7:02 Award: 2 4: Burpman gained the CAPTURE award!
        # 7:02 Award: 2 5: Burpman gained the ASSIST award!
        # 7:30 Award: 2 3: Burpman gained the DEFENCE award!
        # 29:15 Award: 2 2: SalaManderDragneL gained the IMPRESSIVE award!
        # 32:08 Award: 2 1: SalaManderDragneL gained the EXCELLENT award!
        # 8:36 Award: 10 1: Karamel is a fake gained the EXCELLENT award!
        client = self.getByCidOrJoinPlayer(match.group('cid'))
        action_type = 'award_%s' % match.group('awardname')
        return b3.events.Event(b3.events.EVT_CLIENT_ACTION, action_type, client)


#---------------------------------------------------------------------------------------------------

    def parseUserInfo(self, info):
        #ClientUserinfoChanged: 0 n\Courgette\t\0\model\sarge/classic\hmodel\sarge/classic\g_redteam\\g_blueteam\\c1\2\c2\7\hc\100\w\0\l\0\tt\0\tl\0\id\201AB4BBC40B4EC7445B49CE82D209EC
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        t = -1
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)
        
        
        if data.has_key('id'):
            data['guid'] = data['id']
            del data['id']
        if data.has_key('cl_guid'):
            data['guid'] = data['cl_guid']
        
        return data


    def getTeam(self, team):
        team = str(team).lower() # We convert to a string and lower the case because there is a problem when trying to detect numbers if it's not a string (weird)
        if team == 'free' or team == '0':
            #self.debug('Team is Free (no team)')
            result = b3.TEAM_FREE
        elif team == 'red' or team == '1':
            #self.debug('Team is Red')
            result = b3.TEAM_RED
        elif team == 'blue' or team == '2':
            #self.debug('Team is Blue')
            result = b3.TEAM_BLUE
        elif team == 'spectator' or team == '3':
            #self.debug('Team is Spectator')
            result = b3.TEAM_SPEC
        else:
            #self.debug('Team is Unknown')
            result = b3.TEAM_UNKNOWN
        
        #self.debug('getTeam(%s) -> %s' % (team, result))
        return result

    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == '0':
            _gameType = 'dm'        # Free for all
        elif gameTypeInt == '1':
            _gameType = 'du'        # Tourney
        elif gameTypeInt == '3':
            _gameType = 'tdm'       # Team Deathmatch
        elif gameTypeInt == '4':
            _gameType = 'ctf'        # Capture The Flag
        elif gameTypeInt == '8':
            _gameType = 'el'        # Elimination
        elif gameTypeInt == '9':
            _gameType = 'ctfel'        # CTF Elimination
        elif gameTypeInt == '10':
            _gameType = 'lms'        # Last Man Standing
        elif gameTypeInt == '11':
            _gameType = 'del'        # Double Domination
        elif gameTypeInt == '12':
            _gameType = 'dom'        # Domination
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    def getMaps(self):
        if self._maplist is not None:
            return self._maplist

        data = self.write('fdir *.bsp')
        if not data:
            return []

        mapregex = re.compile(r'^maps/(?P<map>.+)\.bsp$', re.I)
        maps = []
        for line in data.split('\n'):
            m = re.match(mapregex, line.strip())
            if m:
                if m.group('map'):
                    maps.append(m.group('map'))

        return maps

    def getNextMap(self):
        data = self.write('nextmap')
        nextmap = self.findNextMap(data)
        if nextmap:
            return nextmap
        else:
            return 'no nextmap set or it is in an unrecognized format !'

    def findNextMap(self, data):
        # "nextmap" is: "vstr next4; echo test; vstr aupo3; map oasago2"
        # the last command in the line is the one that decides what is the next map
        # in a case like : map oasago2; echo test; vstr nextmap6; vstr nextmap3
        # the parser will recursively look each last vstr var, and if it can't find a map, fallback to the last map command
        self.debug('Extracting nextmap name from: %s' % (data))
        nextmapregex = re.compile(r'.*("|;)\s*((?P<vstr>vstr (?P<vstrnextmap>[a-z0-9_]+))|(?P<map>map (?P<mapnextmap>[a-z0-9_]+)))', re.IGNORECASE)
        m = re.match(nextmapregex, data)
        if m:
            if m.group('map'):
                self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                return m.group('mapnextmap')
            elif m.group('vstr'):
                self.debug('Nextmap is redirecting to var: %s' % (m.group('vstrnextmap')))
                data = self.write(m.group('vstrnextmap'))
                result = self.findNextMap(data) # recursively dig into the vstr vars to find the last map called
                if result: # if a result was found in a deeper level, then we return it to the upper level, until we get back to the root level
                    return result
                else: # if none could be found, then try to find a map command in the current string
                    nextmapregex = re.compile(r'.*("|;)\s*(?P<map>map (?P<mapnextmap>[a-z0-9_]+))"', re.IGNORECASE)
                    m = re.match(nextmapregex, data)
                    if m.group('map'):
                        self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                        return m.group('mapnextmap')
                    else: # if none could be found, we go up a level by returning None (remember this is done recursively)
                        self.debug('No nextmap found in this string !')
                        return None
        else:
            self.debug('No nextmap found in this string !')
            return None

    def rotateMap(self):
        """\
        load the next map/level
        """
        self.write('vstr nextmap')

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        self.debug('BAN : client: %s, reason: %s', client, reason)
        if isinstance(client, b3.clients.Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('ban', cid=client, reason=reason))
            return
        elif not client.id:
            # no client id, database must be down, do tempban
            self.error('Q3AParser.ban(): no client id, database must be down, doing tempban')
            return self.tempban(client, reason, '1d', admin, silent)

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))

        if client.cid is None:
            # ban by ip, this happens when we !permban @xx a player that is not connected
            self.debug('EFFECTIVE BAN : %s',self.getCommand('banByIp', ip=client.ip, reason=reason))
            self.write(self.getCommand('banByIp', ip=client.ip, reason=reason))
        else:
            # ban by cid
            self.debug('EFFECTIVE BAN : %s',self.getCommand('ban', cid=client.cid, reason=reason))
            self.write(self.getCommand('ban', cid=client.cid, reason=reason))

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))
        client.disconnect()

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        data = self.write(self.getCommand('banlist', cid=-1))
        if not data:
            self.debug('Error : unban cannot be done, no ban list returned')
        else:
            for line in data.split('\n'):
                m = re.match(self._reBanList, line.strip())
                if m:
                    if m.group('ip') == client.ip:
                        self.write(self.getCommand('unbanByIp', cid=m.group('cid'), reason=reason))
                        self.debug('EFFECTIVE UNBAN : %s',self.getCommand('unbanByIp', cid=m.group('cid')))

                if admin:
                    fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))

                if not silent and fullreason != '':
                    self.say(fullreason)

    def getPlayerPings(self):
        data = self.write('status')
        if not data:
            return {}

        players = {}
        for line in data.split('\n'):
            m = re.match(self._regPlayer, line.strip())
            if m:
                if m.group('ping') == 'ZMBI':
                    # ignore them, let them not bother us with errors
                    pass
                else:
                    players[str(m.group('slot'))] = int(m.group('ping'))

        return players

    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.getByCidOrJoinPlayer(cid)
            if client:
                if client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist

    def connectClient(self, ccid):
        players = self.getPlayerList()
        self.verbose('connectClient() = %s' % players)

        for cid, p in players.iteritems():
            #self.debug('cid: %s, ccid: %s, p: %s' %(cid, ccid, p))
            if int(cid) == int(ccid):
                self.debug('Client found in status/playerList')
                return p
    
    
    def getByCidOrJoinPlayer(self, cid):
        client = self.clients.getByCID(cid)
        if client:
            return client
        else:
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfochanged(None, userinfostring)
            return self.clients.getByCID(cid)
        
        
    def queryClientUserInfoByCid(self, cid):
        """
        : dumpuser 5
        Player 5 is not on the server
        
        ]\rcon dumpuser 0
        userinfo
        --------
        ip                  81.56.143.41
        cg_cmdTimeNudge     0
        cg_delag            0
        cg_scorePlums       1
        cl_voip             0
        cg_predictItems     1
        cl_anonymous        0
        sex                 male
        handicap            100
        color2              7
        color1              2
        team_headmodel      sarge/classic
        team_model          sarge/classic
        headmodel           sarge/classic
        model               sarge/classic
        snaps               20
        rate                25000
        name                Courgette
        teamtask            0
        cl_guid             201AB4BBC40B4EC7445B49CE82D209EC
        teamoverlay         0
        """
        data = self.write('dumpuser %s' % cid)
        if not data:
            return None
        
        if data.split('\n')[0] != "userinfo":
            self.debug("dumpuser %s returned : %s" % (cid, data))
            return None

        datatransformed = "%s " % cid
        for line in data.split('\n'):
            if line.strip() == "userinfo" or line.strip() == "--------":
                continue

            var = line[:20].strip()
            val = line[20:].strip()
            datatransformed += "\\%s\\%s" % (var, val)

        return datatransformed


########NEW FILE########
__FILENAME__ = punkbuster
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

#   CHANGELOG
#   18/10/2011 - 1.0.3 - Bravo17
#    Check slot number go up in order in getplayerlist to weed out data errors
#   22/12/2012 - 1.1 - Courgette
#    fix regex for parsing PB_SV_PList results for cases where a player has no power
#   23/12/2012 - 1.2 - Courgette
#    getPlayerList now only returns info cid, pbid, guid and ip for each connected player. PB is infamously known for
#    missing a character randomly in its PB_SV_PList response, we should succeed if that missing char is in an unimportant
#    part of the response.
#   25/12/2012 - 1.2.1 - Courgette
#    improve reliability of the regular expression for parsing PB_SV_PList response
#   2013-01-20 - 1.2.3 - Courgette
#    improve punkbuster event parsing by accepting whatever punkbuster prefix from the pb responses
#
__author__  = 'ThorN'
__version__ = '1.2.3'

import re

#--------------------------------------------------------------------------------------------------
class PunkBuster(object):
    console = None

#    : Player List: [Slot #] [GUID] [Address] [Status] [Power] [Auth Rate] [Recent SS] [O/S] [Name]
#    : 4  27b26543216546163546513465135135(-) 111.11.1.11:28960 OK   1 3.0 0 (W) "ShyRat"
#    : 5 387852749658574858598854913cdf11(-) 222.222.222.222:28960 OK   1 10.0 0 (W) "shatgun"
#    : 6 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
    regPlayer = re.compile(r"""
        ^.*?                                        # a new line start with junk (ungreedy mode)
        (.*?):?\s*                                  # end of PB response prefix (potentially missing one char)
          (?P<slot>[1-9][0-9]??)                    # slot number between 1 and 99 (ungreedy mode)
        (?:\s+|)                                    # blank character(s) or nothing
          (?P<pbid>[a-f0-9]{30,32})                 # PB id (at least 30 char long, max 32)
        [^a-f0-9].*?                                # anything but a pbid char and eventually some junk (ungreedy mode)
          (?P<ip>(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])) # a valid IP number
        .+?                                         # junk
        (?:\)\s*"|\)\s*|\s+")                       # detect start of name
          (?P<name>.*?)"?                           # name
        \s*$                                        # end of line
        """, re.IGNORECASE|re.VERBOSE)


    def __init__(self, console):
        self.console = console

    def send(self, command):
        return self.console.write(command)

    def badName(self, grace, filter):
        """
        PB_SV_BadName [grace_seconds] [text_filter]
        Adds a bad name to the list of bad names for the server to disallow in player names
        """
        return self.send('PB_SV_BadName "%s" "%s"' % (grace, filter))


    def badNameDel(self, slot):
        """
        PB_SV_BadNameDel [slot #]
        Deletes a bad name from the list of bad names 
        """
        return self.send('PB_SV_BadNameDel "%s"' % slot)

    def ban(self, client, reason='', private=''):
        """
        PB_SV_Ban [name or slot #] [displayed_reason] | [optional_private_reason]
        Removes a player from the game and permanently bans that player from the server based
        on the player's guid (based on the cdkey); the ban is logged and also written to the
        pbbans.dat file in the pb folder 
        """

        if client.cid and client.connected:
            return self.send('PB_SV_Ban "%s" "%s" "%s"' % (int(client.cid) + 1, reason, private))
        else:
            return self.banGUID(client, reason)

    def banGUID(self, client, reason=''):
        """
        PB_SV_BanGuid [guid] [player_name] [IP_Address] [reason]
        Adds a guid directly to PB's permanent ban list; if the player_name or IP_Address
        are not known, we recommend using "???" 
        """

        if not client.pbid:
            return False

        return self.send('PB_SV_BanGuid "%s" "%s" "%s" "%s"' % (client.pbid, client.name, client.ip, reason))

    def kick(self, client, minutes=1, reason='', private=''):
        """
        PB_SV_Kick [name or slot #] [minutes] [displayed_reason] | [optional_private_reason]
        Removes a player from the game and won't let the player rejoin until specified [minutes] 
        has passed or until the server is restarted, whichever comes first - kicks are not written
        to the pbbans.dat file but they are logged and will show up in the output from the pb_sv_banlist command 
        """

        if not client.cid or not client.connected:
            return False

        return self.send('PB_SV_Kick "%s" "%s" "%s" "%s"' % (int(client.cid) + 1, minutes, reason, private))

    def getSs(self, client):
        """
        Sends a request to all applicable connected players asking for a screen shot to be captured and sent to the PB Server; to specify a player name or substring (as opposed to slot #), surround the text with double-quote marks 
        """
        
        if not client.cid or not client.connected:
            return False

        return self.send('PB_SV_GetSs "%s"' % (int(client.cid) + 1))

    def pList(self):
        """
        PB_SV_PList
        Displays a list of connected players and their current status 
        """
        return self.send('PB_SV_PList')

    def unBan(self, slot):
        """
        PB_SV_UnBan [slot #]
        Unbans a player from the ban list stored in memory; use pb_sv_updbanfile to update the
        permanent ban file after using this command 
        """
        return self.send('PB_SV_UnBan "%s"' % slot)

    def unBanGUID(self, client):
        """
        PB_SV_UnBanGuid [guid]
        Unbans a guid from the ban list stored in memory; use pb_sv_updbanfile to update the
        permanent ban file after using this command 
        """

        if not client.pbid:
            return False

        result = self.send('PB_SV_UnBanGuid "%s"' % client.pbid)
        if result:
            self.send('pb_sv_updbanfile')
            return result

        return False

    def getPlayerList(self):
        """
        Extract cid, pbid, ip for all connected players.
        :return: a dict having slot numbers (minus 1) as keys and an other dict as values. This later dict has keys :
        cid, pbid, guid and ip
        """
        data = self.pList()
        if not data:
            return {}

        players = {}
        lastslot = 0
        for line in data.split('\n'):
            m = re.match(self.regPlayer, line)
            if m:
                d = m.groupdict()
                if int(m.group('slot')) > lastslot:
                    d['guid'] = d['pbid']
                    lastslot = int(m.group('slot'))
                    players[str(lastslot - 1)] = d
                    
                else:
                    self.console.debug('Duplicate or Incorrect PB slot number - client ignored %s lastslot %s' % (m.group('slot'), lastslot))
            elif 'Player List:' not in line:
                self.console.verbose2("PB player info cannot be extracted of %r" % line)
        return players

    def __setattr__(self, key, value):
        self.__dict__[key] = value

        if key != 'console':
            self.send('PB_SV_%s %s' % (key.title(), value))

    def __getattr__(self, key):
        try:        
            return self.__dict__[key]
        except:
            return self.send('PB_SV_%s' % key.title())

########NEW FILE########
__FILENAME__ = abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# $Id: q3a.py 103 2006-04-14 16:23:10Z thorn $
# $Id: q3a/abstractParser.py 103 2010-11-01 10:10:10Z xlr8or $
#
# CHANGELOG
#    2012/07/07 - 1.13.2 - Courgette
#    * ensures the config file has option 'game_log' in section 'server'
#    2012/06/17 - 1.7.2 - Courgette
#    * syntax
#    18/10/2011 - 1.7.1 - 82ndab-Bravo17
#    Check slot number go up in order in getplayerlist to weed out data errors
#    14/06/2011 - 1.7.0 - Courgette
#    * cvar code changed to han
#    2011/06/05 - 1.6.0 - Courgette
#    * change data format for EVT_CLIENT_BAN_TEMP and EVT_CLIENT_BAN events
#    2011/04/09 - 1.5.3 - Courgette
#    * reflect that cid are not converted to int anymore in the clients module
#    2010/11/08 - 1.5.2 - GrosBedo
#    * messages can now be empty (no message broadcasted on kick/tempban/ban/unban)
#    2010/11/07 - 1.5.1 - GrosBedo
#    * added moveToTeam default command
#    * fixed getTeam (missed team_free and would crash with q3a and oa081 because of int conversion of strings)
#    * messages now support named $variables instead of %s
#    2010/11/01 - 1.5.0 - xlr8or
#    * Refactored to an abstract parser class
#    2010/10/06 - 1.4.4 - xlr8or
#    * reintroduced rcontesting on startup, but for q3a based only (rconTest var in parser)
#    2010/08/08 - 1.4.3 - Courgette
#    * fix minor bug with saybig()
#    2010/04/10 - 1.4.2 - Bakes
#    * saybig() function can now be used by plugins. Since basic q3 games (such as CoD)
#      cannot print to the centre of the screen, it performs the same function as the scream
#      command.
#    2010/03/22 - 1.4.1 - Courgette
#    * fix conflict between 1.3.4 and 1.4. 
#    2010/03/21 - 1.4 - Courgette
#    * now implements methods maprotate and changeMap
#    21/03/2010 - 1.3.4 - Bakes
#    * rotateMap() function added to make the admin plugin more BFBC2-compatible.
#    31/01/2010 - 1.3.3 -  xlr8or
#    * Fixed a few  typos
#    26/01/2010 - 1.3.2 -  xlr8or
#    * added maxRetries=4 to authorizeClients()
#    * getMap() was moved from iourt to q3a
#    12/06/2009 - 1.3.1 - Courgette
#    * getPlayerList can be called with a custom maxRetries value. This can be
#    useful when a map just changed and the gameserver hangs for a while.
#    11/11/2009 - 1.3.0 - Courgette
#    * New feature: Allow action names to contain spaces. In that case the action
#      method is built following a CamelCase syntax. IE: action "Flag return" will
#      call the method named "OnFlagReturn"
#    2/27/2009 - 1.2.3 - xlr8or
#    Removed error message for getPlayerList(), getPlayerPings() and getPlayerScores()
#    5/6/2008 - 1.2.2 - Anubis
#    Added OnShutdowngame()
#    5/6/2008 - 1.2.1 - xlr8or
#    Modified _reColor to strip Ascii > 127 also
#    12/2/2005 - 1.1.0 - ThorN
#    Fixed getCvar() regular expression
#    11/29/2005 - 1.1.0 - ThorN
#    Added setCvar() and fixed getCvar()
#    7/23/2005 - 1.0.1 - ThorN
#    Added log message for when ban() decides to do a tempban



__author__  = 'ThorN, xlr8or'
__version__ = '1.7.3'

import re, string, time
import b3
import b3.events
from b3.parsers.punkbuster import PunkBuster
import b3.parsers.q3a.rcon as rcon
import b3.parser
import b3.cvar

#----------------------------------------------------------------------------------------------------------------------------------------------
class AbstractParser(b3.parser.Parser):
    '''
    An abstract base class to help with developing q3a parsers 
    '''
    gameName = None
    privateMsg = True
    rconTest = True
    OutputClass = rcon.Rcon

    _settings = {
        'line_length': 65,
        'min_wrap_length': 100,
    }

    _commands = {
        'message': 'tell %s %s ^8[pm]^7 %s',
        'deadsay': 'tell %s %s [DEAD]^7 %s',
        'say': 'say %s %s',
        'set': 'set %s %s',
        'kick': 'clientkick %s %s',
        'ban': 'banid %s %s',
        'tempban': 'clientkick %s %s',
        'moveToTeam': 'forceteam %s %s',
    }

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'shutdowngame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    _lineTime  = re.compile(r'^(?P<minutes>[0-9]+):(?P<seconds>[0-9]+).*')

    _lineFormats = (
        #1579:03ConnectInfo: 0: E24F9B2702B9E4A1223E905BF597FA92: ^w[^2AS^w]^2Lead: 3: 3: 24.153.180.106:2794
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        #1536:17sayc: 0: ^w[^2AS^w]^2Lead:  sorry...
        #1536:34sayteamc: 17: ^1[^7DP^1]^4Timekiller: ^4ammo ^2here !!!!!
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<acid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>.*)$', re.IGNORECASE)
    )
    
    #num score ping guid   name            lastmsg address               qport rate
    #--- ----- ---- ------ --------------- ------- --------------------- ----- -----
    #2     0   29 465030 <-{^4AS^7}-^3ThorN^7->^7       50 68.63.6.62:-32085      6597  5000
    #_regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<guid>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<guid>[0-9a-zA-Z]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)

    _regPlayerShort = re.compile(r'\s+(?P<slot>[0-9]+)\s+(?P<score>[0-9]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*)\^7\s+', re.I)
    _reColor = re.compile(r'(\^[0-9a-z])|[\x80-\xff]')
    _reCvarName = re.compile(r'^[a-z0-9_.]+$', re.I)
    _reCvar = (
        #"sv_maxclients" is:"16^7" default:"8^7"
        #latched: "12"
        re.compile(r'^"(?P<cvar>[a-z0-9_.]+)"\s+is:\s*"(?P<value>.*?)(\^7)?"\s+default:\s*"(?P<default>.*?)(\^7)?"$', re.I | re.M),
        #"g_maxGameClients" is:"0^7", the default
        #latched: "1"
        re.compile(r'^"(?P<cvar>[a-z0-9_.]+)"\s+is:\s*"(?P<default>(?P<value>.*?))(\^7)?",\s+the\sdefault$', re.I | re.M),
        #"mapname" is:"ut4_abbey^7"
        re.compile(r'^"(?P<cvar>[a-z0-9_.]+)"\s+is:\s*"(?P<value>.*?)(\^7)?"$', re.I | re.M),
    )
    _reMapNameFromStatus = re.compile(r'^map:\s+(?P<map>.+)$', re.I)

    PunkBuster = None

    def startup(self):
        if not self.config.has_option('server','game_log'):
            self.critical("your main config file is missing the 'game_log' setting in section 'server'")
            raise SystemExit(220)

        # add the world client
        client = self.clients.newClient('1022', guid='WORLD', name='World', hide=True, pbid='WORLD')

        if self.config.has_option('server', 'punkbuster') and self.config.getboolean('server', 'punkbuster'):
            self.PunkBuster = PunkBuster(self)

    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        m = None
        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return m, m.group('action').lower(), m.group('data').strip(), client, target
        elif '------' not in line:
            self.verbose('line did not match format: %s' % line)

    def parseLine(self, line):           
        m = self.getLineParts(line)
        if not m:
            return False

        match, action, data, client, target = m

        func = 'On%s' % string.capwords(action).replace(' ','')
        
        #self.debug("-==== FUNC!!: " + func)
        
        if hasattr(self, func):
            func = getattr(self, func)
            event = func(action, data, match)

            if event:
                self.queueEvent(event)
        elif action in self._eventMap:
            self.queueEvent(b3.events.Event(
                    self._eventMap[action],
                    data,
                    client,
                    target
                ))
        else:
            self.queueEvent(b3.events.Event(
                    b3.events.EVT_UNKNOWN,
                    str(action) + ': ' + str(data),
                    client,
                    target
                ))

    def getClient(self, match=None, attacker=None, victim=None):
        """Get a client object using the best availible data"""
        if attacker:
            return self.clients.getByCID(attacker.group('acid'))
        elif victim:
            return self.clients.getByCID(victim.group('cid'))
        elif match:
            return self.clients.getByCID(match.group('cid'))

    #----------------------------------
    def OnSay(self, action, data, match=None):
        """\
        if self.type == b3.COMMAND:
            # we really need the second line
            text = self.read()
            if text:
                msg = string.split(text[:-1], '^7: ', 1)
                if not len(msg) == 2:
                    return None
        else:
        """
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByExactName(msg[0])

        return b3.events.Event(b3.events.EVT_CLIENT_SAY, msg[1], client)

    def OnShutdowngame(self, action, data, match=None):
        #self.game.mapEnd()
        #self.clients.sync()
        return b3.events.Event(b3.events.EVT_GAME_ROUND_END, data)

    def OnClientdisconnect(self, action, data, match=None):
        client = self.getClient(match)
        if client: client.disconnect()
        return None

    def OnSayteam(self, action, data, match=None):
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByName(msg[0])

        if client:
            return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, msg[1], client, client.team)
        else:
            return None

    def OnExit(self, action, data, match=None):
        self.game.mapEnd()
        return b3.events.Event(b3.events.EVT_GAME_EXIT, None)

    def OnItem(self, action, data, match=None):
        client = self.getClient(match)
        if client:
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, match.group('text'), client)
        return None

    def OnClientbegin(self, action, data, match=None):
        # we get user info in two parts:
        # 19:42.36 ClientBegin: 4
        # 19:42.36 Userinfo: \cg_etVersion\ET Pro, ET 2.56\cg_u
        # we need to store the ClientConnect ID for the next call to userinfo

        self._clientConnectID = data

        return None

    def OnClientconnect(self, action, data, match=None):
        # we get user info in two parts:
        # 19:42.36 ClientConnect: 4
        # 19:42.36 Userinfo: \cg_etVersion\ET Pro, ET 2.56\cg_u
        # we need to store the ClientConnect ID for the next call to userinfo

        self._clientConnectID = data

        return None

    def OnClientuserinfo(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                client = self.clients.newClient(bclient['cid'], **bclient)

        return None

    def OnClientuserinfochanged(self, action, data, match=None):
        return self.OnClientuserinfo(action, data, match)

    def OnUserinfo(self, action, data, match=None):
        #f = re.findall(r'\\name\\([^\\]+)', data)

        #if f:
        #    client = self.clients.getByExactName(f[0])
        #    if client:

        try:
            id = self._clientConnectID
        except Exception:
            id = None

        self._clientConnectID = None

        if not id:
            self.error('OnUserinfo called without a ClientConnect ID')
            return None

        return self.OnClientuserinfo(action, '%s %s' % (id, data), match)

    def OnKill(self, action, data, match=None):
        #Kill: 1022 0 6: <world> killed <-NoX-ThorN-> by MOD_FALLING
        #20:26.59 Kill: 3 2 9: ^9n^2@^9ps killed [^0BsD^7:^0Und^7erKo^0ver^7] by MOD_MP40
        #m = re.match(r'^([0-9]+)\s([0-9]+)\s([0-9]+): (.*?) killed (.*?) by ([A-Z_]+)$', data)

        attacker = self.getClient(attacker=match)
        if not attacker:
            self.bot('No attacker')
            return None

        victim = self.getClient(victim=match)
        if not victim:
            self.bot('No victim')
            return None

        return b3.events.Event(b3.events.EVT_CLIENT_KILL, (100, match.group('aweap'), None), attacker, victim)

    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = o[1]
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.game.startRound()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    #----------------------------------
    def parseUserInfo(self, info):
        #0 \g_password\none\cl_guid\0A337702493AF67BB0B0F8565CE8BC6C\cl_wwwDownload\1\name\thorn\rate\25000\snaps\20\cl_anonymous\0\cl_punkbuster\1\password\test\protocol\83\qport\16735\challenge\-79719899\ip\69.85.205.66:27960
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        if data.has_key('n'):
            data['name'] = data['n']

        t = None
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)

        if data.has_key('cl_guid') and not data.has_key('pbid'):
            data['pbid'] = data['cl_guid']

        return data

    def getTeam(self, team):
        team = str(team).lower() # We convert to a string and lower the case because there is a problem when trying to detect numbers if it's not a string (weird)
        if team == 'free' or team == '0':
            result = b3.TEAM_FREE
        elif team == 'red' or team == '1':
            result = b3.TEAM_RED
        elif team == 'blue' or team == '2':
            result = b3.TEAM_BLUE
        elif team == 'spectator' or team == '3':
            result = b3.TEAM_SPEC
        else:
            result = b3.TEAM_UNKNOWN
        return result


    def message(self, client, text):
        try:
            if client is None:
                self.say(text)
            elif client.cid is None:
                pass
            else:
                lines = []
                for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                    lines.append(self.getCommand('message', cid=client.cid, prefix=self.msgPrefix, message=line))

                self.writelines(lines)
        except Exception:
            pass

    def say(self, msg):
        lines = []
        for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
            lines.append(self.getCommand('say', prefix=self.msgPrefix, message=line))

        if len(lines):        
            self.writelines(lines)
    
    def saybig(self, msg):
        for c in range(1,6):
            self.say('^%i%s' % (c, msg))

    def smartSay(self, client, msg):
        if client and (client.state == b3.STATE_DEAD or client.team == b3.TEAM_SPEC):
            self.verbose('say dead state: %s, team %s', client.state, client.team)
            self.sayDead(msg)
        else:
            self.verbose('say all')
            self.say(msg)

    def sayDead(self, msg):
        wrapped = self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length'])
        lines = []
        for client in self.clients.getClientsByState(b3.STATE_DEAD):
            if client.cid:                
                for line in wrapped:
                    lines.append(self.getCommand('deadsay', cid=client.cid, prefix=self.msgPrefix, message=line))

        if len(lines):        
            self.writelines(lines)

    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        if isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('kick', cid=client, reason=reason))
            return

        if self.PunkBuster:
            self.PunkBuster.kick(client, 0.5, reason)
        else:
            self.write(self.getCommand('kick', cid=client.cid, reason=reason))

        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_KICK, reason, client))
        client.disconnect()

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        if isinstance(client, b3.clients.Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('ban', cid=client, reason=reason))
            return
        elif not client.id:
            # no client id, database must be down, do tempban
            self.error('Q3AParser.ban(): no client id, database must be down, doing tempban')
            return self.tempban(client, reason, '1d', admin, silent)

        if self.PunkBuster:
            self.PunkBuster.ban(client, reason)
            # bans will only last 7 days, this is a failsafe incase a ban cant
            # be removed from punkbuster
            #self.PunkBuster.kick(client, 1440 * 7, reason)
        else:
            self.write(self.getCommand('ban', cid=client.cid, reason=reason))

        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN, {'reason': reason, 'admin': admin}, client))
        client.disconnect()

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        if self.PunkBuster:
            if client.pbid:
                result = self.PunkBuster.unBanGUID(client)

                if result:                    
                    admin.message('^3Unbanned^7: %s^7: %s' % (client.exactName, result))
                
                if admin:
                    fullreason = self.getMessage('unbanned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
                else:
                    fullreason = self.getMessage('unbanned', self.getMessageVariables(client=client, reason=reason))

                if not silent and fullreason != '':
                    self.say(fullreason)
            elif admin:
                admin.message('%s^7 unbanned but has no punkbuster id' % client.exactName)
        elif admin:
            admin.message('^3Unbanned^7: %s^7. You may need to manually remove the user from the game\'s ban file.' % client.exactName)

    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        duration = b3.functions.time2minutes(duration)

        if isinstance(client, b3.clients.Client) and not client.guid:
            # client has no guid, kick instead
            return self.kick(client, reason, admin, silent)
        elif isinstance(client, str) and re.match('^[0-9]+$', client):
            self.write(self.getCommand('tempban', cid=client, reason=reason))
            return
        elif admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))

        if self.PunkBuster:
            # punkbuster acts odd if you ban for more than a day
            # tempban for a day here and let b3 re-ban if the player
            # comes back
            if duration > 1440:
                duration = 1440

            self.PunkBuster.kick(client, duration, reason)
        else:
            self.write(self.getCommand('tempban', cid=client.cid, reason=reason))

        if not silent and fullreason != '':
            self.say(fullreason)

        self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_BAN_TEMP, {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                        , client))
        client.disconnect()

    def rotateMap(self):
        self.say('^7Changing map to next map')
        time.sleep(1)
        self.write('map_rotate 0')
        
    def changeMap(self, map):
        self.say('^7Changing map to %s' % map)
        time.sleep(1)
        self.write('map %s' % map)

    def getPlayerPings(self):
        data = self.write('status')
        if not data:
            return {}

        players = {}
        for line in data.split('\n'):
            #self.debug('Line: ' + line + "-")
            m = re.match(self._regPlayerShort, line)
            if not m:
                m = re.match(self._regPlayer, line.strip())
            
            if m:
                players[str(m.group('slot'))] = int(m.group('ping'))
            #elif '------' not in line and 'map: ' not in line and 'num score ping' not in line:
                #self.verbose('getPlayerScores() = Line did not match format: %s' % line)
        
        return players
        
    def getPlayerScores(self):
        data = self.write('status')
        if not data:
            return {}

        players = {}
        for line in data.split('\n'):
            #self.debug('Line: ' + line + "-")
            m = re.match(self._regPlayerShort, line)
            if not m:
                m = re.match(self._regPlayer, line.strip())
            
            if m:  
                players[str(m.group('slot'))] = int(m.group('score'))
            #elif '------' not in line and 'map: ' not in line and 'num score ping' not in line:
                #self.verbose('getPlayerScores() = Line did not match format: %s' % line)
        
        return players
        
    def getPlayerScoressssss(self):
        plist = self.getPlayerListRcon()
        scorelist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                scorelist[str(cid)] = c['score']
        return scorelist
        
    def getPlayerList(self, maxRetries=None):
        if self.PunkBuster:
            return self.PunkBuster.getPlayerList()
        else:
            data = self.write('status', maxRetries=maxRetries)
            if not data:
                return {}

            players = {}
            lastslot = -1
            for line in data.split('\n')[3:]:
                m = re.match(self._regPlayer, line.strip())
                if m:
                    d = m.groupdict()
                    if int(m.group('slot')) > lastslot:
                        lastslot = int(m.group('slot'))
                        d['pbid'] = None
                        players[str(m.group('slot'))] = d
                        
                    else:
                        self.debug('Duplicate or Incorrect slot number - client ignored %s lastslot %s' % (m.group('slot'), lastslot))

        return players


    def getCvar(self, cvarName):
        if self._reCvarName.match(cvarName):
            #"g_password" is:"^7" default:"scrim^7"
            val = self.write(cvarName)
            self.debug('Get cvar %s = [%s]', cvarName, val)
            #sv_mapRotation is:gametype sd map mp_brecourt map mp_carentan map mp_dawnville map mp_depot map mp_harbor map mp_hurtgen map mp_neuville map mp_pavlov map mp_powcamp map mp_railyard map mp_rocket map mp_stalingrad^7 default:^7

            m = None
            for f in self._reCvar:
                m = re.match(f, val)
                if m:
                    #self.debug('line matched %s' % f.pattern)
                    break

            if m:
                #self.debug('m.lastindex %s' % m.lastindex)
                if m.group('cvar').lower() == cvarName.lower():
                    try:
                        default_value = m.group('default')
                    except IndexError:
                        default_value = None
                    return b3.cvar.Cvar(m.group('cvar'), value=m.group('value'), default=default_value)
            else:
                return None

    def set(self, cvarName, value):
        self.warning('Parser.set() is depreciated, use Parser.setCvar() instead')
        self.setCvar(cvarName, value)

    def setCvar(self, cvarName, value):
        if re.match('^[a-z0-9_.]+$', cvarName, re.I):
            self.debug('Set cvar %s = [%s]', cvarName, value)
            self.write(self.getCommand('set', name=cvarName, value=value))
        else:
            self.error('%s is not a valid cvar name', cvarName)

    def getMap(self):
        data = self.write('status')
        if not data:
            return None

        line = data.split('\n')[0]
        #self.debug('[%s]'%line.strip())

        m = re.match(self._reMapNameFromStatus, line.strip())
        if m:
            return str(m.group('map'))

        return None

    def getMaps(self):
        return None

    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                if client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist

    def authorizeClients(self):
        players = self.getPlayerList(maxRetries=4)
        self.verbose('authorizeClients() = %s' % players)

        for cid, p in players.iteritems():
            sp = self.clients.getByCID(cid)
            if sp:
                # Only set provided data, otherwise use the currently set data
                sp.ip   = p.get('ip', sp.ip)
                sp.pbid = p.get('pbid', sp.pbid)
                sp.guid = p.get('guid', sp.guid)
                sp.data = p
                sp.auth()

########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Changelog :
# 2009/12/06 - 1.3.5 - Courgette
# * make default socket_timeout 800 ms
# * custom socket_timeout and maxRetries can be specified on a per
# call basis
# 2009/12/11 - 1.3.6 - Courgette
# * make errors warnings until maxRetries is not reached
# 2011/2/1 - 1.3.7 - Bravo17
# * added variables for rcon & qserver send & reply strings
# 2011/04/02 - 1.3.8 - Just a baka
# * Quit command should never be retried
# 2011/04/13 - 1.3.9 - Courgette
# * hopefully filter out non ascii characters
# 2011/04/13 - 1.3.10 - Courgette
# * should get rid of UnicodeDecodeError
# 2011/04/20 - 1.4 - Courgette
# * now sent data is encoded as UTF-8
# 2011/10/30 - 1.5 - xlr8or, 82ndab-Bravo17
# * Add encoding to QSERVER and RCON snd methods
# 2012/04/04 - 1.5.1 - courgette
# * remove 2 confusing debug msg
# 2012/06/17 - 1.6 - courgette
# * rewrite method writelines so it does not lock until all lines have been sent. This allows other commands made by another
#   thread to be sent in between commands sent via writelines (and B3 won't appear to be unresponsive)
# 2012/07/18 - 1.6.1 - courgette
# * fix the 'RCON: too much tries' error message when using commands sending multiple lines of text
# 2012/11/27 - 1.7 - courgette
# * rollback changes made in 1.6 as it does not solve much (at least with UrT) and break some rcon commands with at least cod6
# 2012/12/22 - 1.8 - courgette
# * do not strip data in game server responses
#
__author__ = 'ThorN'
__version__ = '1.8'

import socket
import sys
import select
import re
import time
import thread
import threading
import Queue
from b3.lib.beaker.cache import CacheManager
from b3.lib.beaker.util import parse_cache_config_options

#--------------------------------------------------------------------------------------------------
class Rcon:
    host = ()
    password = None
    lock = thread.allocate_lock()
    socket = None
    queue = None
    console = None
    socket_timeout = 0.80
    rconsendstring = '\377\377\377\377rcon "%s" %s\n'
    rconreplystring = '\377\377\377\377print\n'
    qserversendstring = '\377\377\377\377%s\n'

    #caching options
    cache_opts = {
        'cache.data_dir': 'b3/cache/data',
        'cache.lock_dir': 'b3/cache/lock',
        }
    #create cache
    cache = CacheManager(**parse_cache_config_options(cache_opts))
    #default expiretime for the status cache in seconds and cache type
    statusCacheExpireTime = 2
    statusCacheType = 'memory'

    def __init__(self, console, host, password):
        self.console = console
        self.queue = Queue.Queue()

        if self.console.config.has_option('caching', 'status_cache_type'):
            self.statusCacheType = self.console.config.get('caching', 'status_cache_type').lower()
            if self.statusCacheType not in ['file', 'memory']:
                self.statusCacheType = 'memory'
        if self.console.config.has_option('caching', 'status_cache_expire'):
            self.statusCacheExpireTime = abs(self.console.config.getint('caching', 'status_cache_expire'))
            if self.statusCacheExpireTime > 5:
                self.statusCacheExpireTime = 5
        self.console.bot(
            'rcon status Cache Expire Time: [%s sec] Type: [%s]' % (self.statusCacheExpireTime, self.statusCacheType))

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.host = host
        self.password = password
        self.socket.settimeout(2)
        self.socket.connect(self.host)

        self._stopEvent = threading.Event()
        thread.start_new_thread(self._writelines, ())

    def encode_data(self, data, source):
        try:
            if isinstance(data, str):
                data=unicode(data, errors='ignore')
            data=data.encode(self.console.encoding, 'replace')
        except Exception, msg:
            self.console.warning('%s: ERROR encoding data: %r', source, msg)
            data = 'Encoding error'
            
        return data
        
    def send(self, data, maxRetries=None, socketTimeout=None):
        if socketTimeout is None:
            socketTimeout = self.socket_timeout
        if maxRetries is None:
            maxRetries = 2

        data = data.strip()
        # encode the data
        if self.console.encoding:
            data = self.encode_data(data, 'QSERVER')

        self.console.verbose('QSERVER sending (%s:%s) %r', self.host[0], self.host[1], data)
        startTime = time.time()

        retries = 0
        while time.time() - startTime < 5:
            readables, writeables, errors = select.select([], [self.socket], [self.socket], socketTimeout)

            if len(errors) > 0:
                self.console.warning('QSERVER: %r', errors)
            elif len(writeables) > 0:
                try:
                    writeables[0].send(self.qserversendstring % data)
                except Exception, msg:
                    self.console.warning('QSERVER: ERROR sending: %r', msg)
                else:
                    try:
                        data = self.readSocket(self.socket, socketTimeout=socketTimeout)
                        self.console.verbose2('QSERVER: Received %r' % data)
                        return data
                    except Exception, msg:
                        self.console.warning('QSERVER: ERROR reading: %r', msg)

            else:
                self.console.verbose('QSERVER: no writeable socket')

            time.sleep(0.05)

            retries += 1

            if retries >= maxRetries:
                self.console.error('QSERVER: too much tries. Abording (%r)', data.strip())
                break

            self.console.verbose('QSERVER: retry sending %r (%s/%s)...', data.strip(), retries, maxRetries)

        self.console.debug('QSERVER: Did not send any data')
        return ''

    def sendRcon(self, data, maxRetries=None, socketTimeout=None):
        if socketTimeout is None:
            socketTimeout = self.socket_timeout
        if maxRetries is None:
            maxRetries = 2

        data = data.strip()
        # encode the data
        if self.console.encoding:
            data = self.encode_data(data, 'RCON')

        self.console.verbose('RCON sending (%s:%s) %r', self.host[0], self.host[1], data)
        startTime = time.time()

        retries = 0
        while time.time() - startTime < 5:
            readables, writeables, errors = select.select([], [self.socket], [self.socket], socketTimeout)

            if len(errors) > 0:
                self.console.warning('RCON: %s', str(errors))
            elif len(writeables) > 0:
                try:
                    writeables[0].send(self.rconsendstring % (self.password, data))
                except Exception, msg:
                    self.console.warning('RCON: ERROR sending: %r', msg)
                else:
                    try:
                        data = self.readSocket(self.socket, socketTimeout=socketTimeout)
                        self.console.verbose2('RCON: Received %r' % data)
                        return data
                    except Exception, msg:
                        self.console.warning('RCON: ERROR reading: %r', msg)

                if re.match(r'^quit|map(_rotate)?.*', data):
                    # do not retry quits and map changes since they prevent the server from responding
                    self.console.verbose2('RCON: no retry for %r', data)
                    return ''

            else:
                self.console.verbose('RCON: no writeable socket')

            time.sleep(0.05)

            retries += 1

            if retries >= maxRetries:
                self.console.error('RCON: too much tries. Abording (%r)', data.strip())
                break
            self.console.verbose('RCON: retry sending %r (%s/%s)...', data.strip(), retries, maxRetries)

        self.console.debug('RCON: Did not send any data')
        return ''

    def stop(self):
        """Stop the rcon writelines queue"""
        self._stopEvent.set()

    def _writelines(self):
        while not self._stopEvent.isSet():
            lines = self.queue.get(True)
            for cmd in lines:
                if not cmd:
                    continue
                with self.lock:
                    self.sendRcon(cmd, maxRetries=1)

    def writelines(self, lines):
        self.queue.put(lines)

    def write(self, cmd, maxRetries=None, socketTimeout=None, Cached=True):
        #intercept status request for caching construct
        if cmd == 'status' and Cached:
            status_cache = self.cache.get_cache('status', type=self.statusCacheType, expire=self.statusCacheExpireTime)
            data = status_cache.get(key='status', createfunc=self._requestStatusCached)
            return data

        with self.lock:
            data = self.sendRcon(cmd, maxRetries=maxRetries)
        if data:
            return data
        else:
            return ''

    def _requestStatusCached(self):
        with self.lock:
            data = self.sendRcon('status', maxRetries=5)
        if data:
            return data
        else:
            return ''


    def flush(self):
        pass

    def readNonBlocking(self, sock):
        sock.settimeout(2)

        startTime = time.time()

        data = ''
        while time.time() - startTime < 1:
            try:
                d = str(sock.recv(4096))
            except socket.error, detail:
                self.console.debug('RCON: ERROR reading: %s' % detail)
                break
            else:
                if d:
                    # remove rcon header
                    data += d.replace(self.rconreplystring, '')
                elif len(data) > 0 and ord(data[-1:]) == 10:
                    break

        return data.strip()

    def readSocket(self, sock, size=4096, socketTimeout=None):
        if socketTimeout is None:
            socketTimeout = self.socket_timeout

        data = ''

        readables, writeables, errors = select.select([sock], [], [sock], socketTimeout)

        if not len(readables):
            self.console.verbose('No readable socket')
            return ''

        while len(readables):
            d = str(sock.recv(size))

            if d:
                # remove rcon header
                data += d.replace(self.rconreplystring, '')

            readables, writeables, errors = select.select([sock], [], [sock], socketTimeout)

            if len(readables):
                self.console.verbose('RCON: More data to read in socket')

        return data

    def close(self):
        pass

    def getRules(self):
        self.lock.acquire()
        try:
            data = self.send('getstatus')
        finally:
            self.lock.release()

        if data:
            return data
        else:
            return ''

    def getInfo(self):
        self.lock.acquire()
        try:
            data = self.send('getinfo')
        finally:
            self.lock.release()

        if data:
            return data
        else:
            return ''

if __name__ == '__main__':
    """
To run tests : python b3/parsers/q3a_rcon.py <rcon_ip> <rcon_port> <rcon_password>
"""

    from b3.fake import fakeConsole

    r = Rcon(fakeConsole, (sys.argv[1], int(sys.argv[2])), sys.argv[3])

    for cmd in ['say "test1"', 'say "test2"', 'say "test3"', 'say "test4"', 'say "test5"']:
        fakeConsole.info('Writing %s', cmd)
        data = r.write(cmd)
        fakeConsole.info('Recieved %s', data)

    print '----------------------------------------'
    for cmd in ['say "test1"', 'say "test2"', 'say "test3"', 'say "test4"', 'say "test5"']:
        fakeConsole.info('Writing %s', cmd)
        data = r.write(cmd, socketTimeout=0.45)
        fakeConsole.info('Recieved %s', data)

    print '----------------------------------------'
    for cmd in ['.B3', '.Administrator', '.Admin', 'status', 'sv_mapRotation', 'players']:
        fakeConsole.info('Writing %s', cmd)
        data = r.write(cmd)
        fakeConsole.info('Recieved %s', data)

    print '----------------------------------------'
    for cmd in ['.B3', '.Administrator', '.Admin', 'status', 'sv_mapRotation', 'players']:
        fakeConsole.info('Writing %s', cmd)
        data = r.write(cmd, socketTimeout=0.55)
        fakeConsole.info('Recieved %s', data)

    print '----------------------------------------'
    fakeConsole.info('getRules')
    data = r.getRules()
    fakeConsole.info('Recieved %s', data)

    print '----------------------------------------'
    fakeConsole.info('getInfo')
    data = r.getInfo()
    fakeConsole.info('Recieved %s', data)

########NEW FILE########
__FILENAME__ = ravaged_rcon
# coding=UTF-8
#
# Rcon client for Ravaged game server
# Copyright (C) 2012 Thomas LEVEIL
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 1.1 - 2012/09/29
#   * updated for RavagedServer beta build [201209271447]
# 1.2 - 2012/10/17
#   * updated for RavagedServer beta build [201210140713]
#
from Queue import Queue, Empty
import logging
import asyncore
from socket import AF_INET, SOCK_STREAM
import re
from hashlib import sha1
from threading import Thread, Event, Lock
import time

__author__ = 'Thomas Leveil'
__version__ = '1.1'


class RavagedServerError(Exception):
    pass

class RavagedServerNetworkError(RavagedServerError):
    pass

class RavagedServerBlacklisted(RavagedServerNetworkError):
    pass

class RavagedServerCommandError(RavagedServerError):
    pass

class RavagedServerCommandTimeout(RavagedServerCommandError):
    pass

class RavagedServer(Thread):
    """thread opening a connection to a Ravaged game server and providing
    means of observing messages received and sending commands"""

    def __init__(self, host, port=13550, password='', user=None, command_timeout=1.0):
        Thread.__init__(self, name="RavagedServerThread")
        self.password = password
        self.command_timeout = command_timeout
        self.user = user if user else 'Admin'

        self._stopEvent = Event() # used to notify the thread to stop
        self.__command_reply_event = Event() # used to notify when we received a command response
        self.__command_lock = Lock() # used to make sure no 2nd command is sent while waiting for the response of a 1st command

        self._received_packets = Queue(maxsize=500)
        self.command_response = None # future command response to be received
        self.observers = set()
        self.log = logging.getLogger("RavagedServer")

        self.dispatcher = RavagedDispatcher(host, port, self._received_packets)
        self.packet_handler_thread = RavagedServerPacketHandler(self.log, self._received_packets, self._on_event, self._on_command_response)

        self.start()
        time.sleep(.2)

    #===============================================================================
    #
    #    Public API
    #
    #===============================================================================

    def subscribe(self, func):
        """Add func from Frosbite events listeners."""
        self.observers.add(func)

    def unsubscribe(self, func):
        """Remove func from Frosbite events listeners."""
        self.observers.remove(func)

    def auth(self):
        self.log.info("authenticating %s" % self.user)
        try:
            response = self.command("LOGIN=%s" % self.user)
            self.log.debug("login response : %r" % response)
            if response.startswith('Suspicious activity detected'):
                raise RavagedServerBlacklisted(response)
        except RavagedServerCommandTimeout:
            pass
        response = self.command("PASS=" + sha1(self.password).hexdigest().upper())
        if response.startswith('Login success as '):
            self.log.info(response)
            # test we can send commands
            try:
                rv = self.command("testrcon")
                if rv != "Command not found, or invalid parameters given.":
                    raise RavagedServerNetworkError("not properly connected (%s)" % rv)
            except RavagedServerCommandTimeout:
                raise RavagedServerNetworkError("not properly connected")
            return
        elif response.startswith('Login failed'):
            self.log.warning(response)
            raise RavagedServerError(response)
        else:
            RavagedServerCommandError("unexpected response. %r" % response)


    def command(self, command):
        """send command to the server in a synchronous way.
        Calling this method will block until we receive the reply packet from the
        game server or until we reach the timeout.
        """
        if not self.connected:
            raise RavagedServerNetworkError("not connected")

        self.log.debug("command : %s " % repr(command))
        if not command or not len(command.strip()):
            return None

        with self.__command_lock:
            self.dispatcher.send_command(command)
            response = self._wait_for_response(command)
            return response


    def stop(self):
        self._stopEvent.set()
        self.dispatcher.close()

    #===============================================================================
    #
    # Other methods
    #
    #===============================================================================

    @property
    def connected(self):
        return self.dispatcher.connected


    def getLogger(self):
        return self.log


    def isStopped(self):
        return self._stopEvent.is_set()


    def run(self):
        """Threaded code"""
        self.packet_handler_thread.start()
        self.log.info('start server loop')
        try:
            while not self.isStopped():
                asyncore.loop(count=1, timeout=1)
        except KeyboardInterrupt:
            pass
        finally:
            self.dispatcher.close()
        self.log.info('end server loop')
        self.packet_handler_thread.stop()


    def _on_event(self, message):
        self.log.debug("received server event : %r" % message)
        for func in self.observers:
            func(message)


    def _on_command_response(self, command, response):
        self.log.debug("received server command %r response : %r" % (command, response))
        self.command_response = (command, response)
        self.__command_reply_event.set()


    def _wait_for_response(self, command):
        """block until response to for given command has been received or until timeout is reached."""
        l_command = command.lower()
        if l_command.startswith("login="):
            command_name = 'login'
        elif l_command.startswith("pass="):
            command_name = 'pass'
        else:
            command_name = command.split(' ', 1)[0].lower() # remove command parameters
        expire_time = time.time() + self.command_timeout
        while not self.isStopped() and self.dispatcher.connected:
            if not self.connected:
                raise RavagedServerNetworkError("lost connection to server")
            if time.time() >= expire_time:
                raise RavagedServerCommandTimeout("did not receive any response for %r" % command)
            self.log.debug("waiting for command %r response" % command)
            self.__command_reply_event.clear()
            self.__command_reply_event.wait(self.command_timeout)
            rv = self.command_response
            self.command_response = None
            if rv:
                cmd, response = rv
                if cmd and cmd.lower() != command_name:
                    self.log.debug("discarding command response %s:%s" % (cmd, response))
                    continue
                return response



class RavagedServerPacketHandler(Thread):
    """
    Thread that handles received packets found in received_packets_queue and call the event_handler or
    command_response_handler depending on the nature of the packets.
    """

    def __init__(self, logger, received_packets_queue, event_handler, command_response_handler):
        Thread.__init__(self, name="RavagedServerPacketHandlerThread")
        self.log = logger
        self._stopEvent = Event() # used to notify the thread to stop
        self._received_packets = received_packets_queue
        self.__event_handler = event_handler
        self.__command_response_handler = command_response_handler
        self.__stop_token = object()


    def run(self):
        self.log.info('start server packet handler loop')
        try:
            while not self.isStopped():
                try:
                    packet = self._received_packets.get(timeout=10)
                    if packet is self.__stop_token:
                        break
                    self.handle_packet(packet)
                    self._received_packets.task_done()
                except Empty:
                    pass
        finally:
            pass
        self.log.info('end server packet handler loop')


    def stop(self):
        self._stopEvent.set()
        self._received_packets.put(self.__stop_token)



    def isStopped(self):
        return self._stopEvent.is_set()


    def handle_packet(self, packet):
        """Called when a full packet has been received."""
        if packet[0] == '(' and packet[-1] == ')':
            self.handle_event(packet)
        elif packet.startswith('RCon:('):
            self.handle_event(packet)
        elif packet == 'You must be a superuser to run this command.':
            self.handle_command_response(None, packet)
        else:
            m = re.match(RE_COMMAND_RESPONSE, packet)
            if not m:
                self.handle_event(packet)
            else:
                self.handle_command_response(m.group('command'), m.group('response'))


    def handle_event(self, message):
        if self.__event_handler is not None:
            self.__event_handler(message)


    def handle_command_response(self, command, response):
        if self.__command_response_handler is not None:
            self.__command_response_handler(command, response)






MIN_MESSAGE_LENGTH = 4 # minimal response is "(1):"
RE_COMMAND_RESPONSE = re.compile(r'''^(?P<command>[\S^:]+):(?P<response>.*)$''', re.DOTALL)

class RavagedDispatcher(asyncore.dispatcher_with_send):
    """
    This asyncore dispatcher provides the send_command method to write to the socket
    and exposes a Queue.Queue that stores the received full packets.
    """

    def __init__(self, host, port, packet_queue=None):
        asyncore.dispatcher_with_send.__init__(self)
        self.log = logging.getLogger("RavagedDispatcher")
        self._buffer_in = ''
        self.packet_queue = packet_queue if packet_queue else Queue()
        self.log.info("connecting")
        self.create_socket(AF_INET, SOCK_STREAM)
        self.connect((host, port))

    #===============================================================================
    #
    #        Public API
    #
    #===============================================================================

    def send_command(self, command):
        """Send a command to the server."""
        self.log.debug("send_command : %s " % repr(command))
        self.send(unicode(command + "\n").encode('UTF-8'))

    def get_packet_queue(self):
        return self.packet_queue

    #===========================================================================
    #
    # asyncore handlers (low level)
    #
    #===========================================================================

    def handle_connect(self):
        self.log.debug("handle_connect")


    def handle_close(self):
        """Called when the socket is closed."""
        self.log.debug("handle_close")
        self.close()


    def handle_read(self):
        """Called when the asynchronous loop detects that a read() call on the channel's socket will succeed."""
        # received raw data
        data = self.recv(8192)
        self._buffer_in += data
        self.log.debug('read %s char from server' % len(data))

        # cook meaningful packets
        map(self.handle_packet, self.full_packets())


    def handle_packet(self, packet):
        """Called when a full packet has been received."""
        self.log.debug("handle_packet(%r)" % packet)
        self.packet_queue.put(packet)

    #===========================================================================
    #
    # Other methods
    #
    #===========================================================================

    def getLogger(self):
        return self.log


    def full_packets(self):
        """
        generator producing full packets from the data found in self._buffer_in
        :return: packet data (everything but the packet size header)
        """
        while len(self._buffer_in) >= MIN_MESSAGE_LENGTH:
            # read the size of this packet
            # 1st byte should be '('
            start_header_index = self._buffer_in.find('(')
            if start_header_index == -1:
                return

            # discard junk data before header
            self._buffer_in = self._buffer_in[start_header_index:]

            # packet header ends with ')'
            end_header_index = self._buffer_in.find(')')
            if end_header_index == -1:
                # we don't have a full header yet
                return

            data_size = int(self._buffer_in[1:end_header_index])
            start_data_index = end_header_index + 1
            end_data_index = start_data_index + data_size

            if len(self._buffer_in) < end_data_index:
                # we do not have enough data to make a full packer
                return

            packet_data = self._buffer_in[start_data_index:end_data_index]
            self._buffer_in = self._buffer_in[end_data_index:]

            unicode_data = packet_data.decode('UTF-8')
            yield unicode_data




if __name__ == '__main__':
    import logging, sys, os, argparse
    from ConfigParser import SafeConfigParser

    rcon_config_file = os.path.join(os.path.dirname(__file__), 'ravaged_rcon.ini')

    parser = argparse.ArgumentParser(description='Ravaged game server rcon client')
    parser.add_argument('host', type=str, nargs='?', default=None, help='Ravaged gameserver hostname or IP')
    parser.add_argument('port', type=int, nargs='?', default=None, help='Ravaged gameserver rcon port')
    parser.add_argument('password', type=str, nargs='?', default=None, help='Ravaged gameserver rcon password')
    parser.add_argument('--log', dest='loglevel', choices=('DEBUG', 'INFO', 'WARNING', 'ERROR'), default='ERROR', help='if you want additional log output')
    parser.add_argument('--user', type=str, help='optional Ravaged gameserver rcon user (default superadmin)')
    client_conf = parser.parse_args()

    if not all((client_conf.host, client_conf.port, client_conf.password)):
        if os.path.isfile(rcon_config_file):
            # load previous config
            try:
                conf = SafeConfigParser()
                conf.read(rcon_config_file)
                if not client_conf.host:
                    client_conf.host = conf.get("server", "host")
                if not client_conf.port:
                    client_conf.port = int(conf.get("server", "port"))
                if not client_conf.password:
                    client_conf.password = conf.get("server", "password")
                print "Server config loaded from %s" % rcon_config_file
            except:
                pass

    # prompt user if missing config info
    if not all((client_conf.host, client_conf.port, client_conf.password)):
        parser.print_help()

        client_conf.host = raw_input('Enter game server host IP/name: ')
        if not client_conf.host:
            print "incorrect host %r" % client_conf.host
            sys.exit(1)

        try:
            client_conf.port = int(raw_input('Enter host port: '))
        except ValueError:
            print "port must be a number"
            sys.exit(1)

        client_conf.password = raw_input('Enter password: ')
        if not client_conf.password:
            print "incorrect password"
            sys.exit(1)


    # save config
    with open(rcon_config_file, "w") as f:
        conf = SafeConfigParser()
        conf.add_section('server')
        conf.set("server", "host", client_conf.host)
        conf.set("server", "port", str(client_conf.port))
        conf.set("server", "password", client_conf.password)
        conf.write(f)
        print "Server config saved to %s" % rcon_config_file


    # set up logging
    logging.basicConfig(level=client_conf.loglevel.upper(), format="\t%(name)-20s [%(thread)-4d] %(threadName)-15s %(levelname)-8s %(message)s", stream=sys.stdout)
    logging.getLogger("RavagedDispatcher").setLevel(logging.WARNING)
    logging.getLogger("RavagedServer").setLevel(client_conf.loglevel.upper())


    def prompt_command():
        """
        python generator that prompt user for a command on the console until the command typed is either 'quit' or 'bye'
        """
        print "Type your commands below. To exit, type the command 'quit' or 'bye'."
        print "--------------------------------------------------------------------"
        rv = raw_input("$ ")
        while 1:
            if rv.lower() in ("quit", "bye"):
                return
            else:
                yield rv.decode(sys.stdin.encoding)
                try:
                    rv = raw_input("$ ")
                except KeyboardInterrupt:
                    return


    def serverevent_handler(message):
        """
        handles events received from the Ravaged server
        """
        print ">>> %s" % message


    # connect to Ravaged server
    try:
        t_conn = RavagedServer(client_conf.host, client_conf.port, client_conf.password, client_conf.user)
        t_conn.subscribe(serverevent_handler)

        # auth to Ravaged server
        t_conn.auth()

        # send user commands to Ravaged server
        for cmd in prompt_command():
            try:
                rv = t_conn.command(cmd)
                if rv:
                    print "%s" % rv
            except RavagedServerCommandTimeout, err:
                logging.warning(err)
            except RavagedServerCommandError, err:
                logging.error(err, exc_info=err)

    except RavagedServerBlacklisted, err:
        print "############## %s" % err
    except RavagedServerError, err:
        print err

    print "disconnecting..."
    t_conn.stop()
    logging.info("disconnected")



########NEW FILE########
__FILENAME__ = rcon
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas LEVEIL
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#


"""
dummy rcon module for Ravaged to satisfy B3 parser API.

Ideally, B3 parser should be changed to allow games to 
not require a separated socket connection for rcon commands

To use that Rcon class, instantiate and use the set_server_connection() method.
Then you can expect this class to work like the other Rcon classes
"""

__author__  = 'Courgette'
__version__ = '1.0'

#--------------------------------------------------------------------------------------------------
class Rcon:
    def __init__(self, console, *args):
        self.console = console
        self.server_conn = None

    def set_server_connection(self, server_conn):
        self.server_conn = server_conn

    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def write(self, cmd, *args, **kwargs):
        if not self.server_conn:
            return
        self.console.verbose(u'RCON :\t %s' % repr(cmd))
        response = self.server_conn.command(cmd)
        self.console.verbose(u'RCON response:\t %s' % repr(response))
        return response

    def flush(self):
        pass

    def close(self):
        pass

########NEW FILE########
__FILENAME__ = ro2
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 2011-03-30 : 0.1
# * first alpha test
# 2011-09-28 : 0.2
# * First commit to repo
# 2011-09-29 : 0.3
# * Added !maps, found !map functionality broken in Web Admin 
# 2011-09-30 : 0.4
# * Made webconnect a method and added comments to new methods
# 2011-10-03 : 0.5
# * Seperate out Team and Global chat - squad chat is totally missing from log and web admin
# * Make sure IP's get logged
# * Remove rcon references and rcon.py
# 2011-10-06 : 0.6
# * Kick client if on server when banned
# * Keep running on map change
# * Allow for username in xml file
# 2011-10-8 : 0.7
# * Correct error in ban-kick
# * Rewrite player names logic for extended characters
#   2011-10-16 : 0.8
# * !map working
# * Player with funny accented i character now show in !list
#   2011-11-01 : 1.0
# * Some re-writes and corrections
# * Implement !nextmap
#   2011-11-02 : 1.1
# * Allow use of # instead of @ for client id nos (@ brings up console on some keyboard layouts and cannot go into chat)
#   2011-12-19 : 1.2
#   Don't process B3 messages as chat
#   Auth client if not already authed when chat used
#   2011-12-28 : 1.3
#   Allow Q3 Color Codes in names, since game doesn't filter them out
#   2012-01-27 : 1.4
#   Track team changes for eg teamspeak plugin
#   2012-12-01 : 1.41
#   Incorporate chat changes for server/game v 1.1.0.8
#
#
from b3 import functions
from b3.parser import Parser
from ftplib import FTP
import b3
import b3.cron
import ftplib
import os
import re
import string
import sys
import time
import urllib
import urllib2
import cookielib
import hashlib


__author__  = 'Courgette, xlr8or, Freelander, 82ndab-Bravo17'
__version__ = '1.41'


class Ro2Parser(b3.parser.Parser):
    """
    The Ref Orchestra 2 B3 parser class
    """
    gameName = "redorchestra2"
    privateMsg = True
    PunkBuster = None 
    # RO2 engine does not support color code, so we need this property
    # in order to get stripColors working
    _reColor = re.compile(r'(\^[0-9])')
    _reSteamId64 = re.compile(r'^[0-9]{17}$')
    ftpconfig = None
    _ftplib_debug_level = 0 # 0: no debug, 1: normal debug, 2: extended debug
    _ftpconnectionTimeout = 30
    _playerlistInterval = 30
    _server_banlist = {}
    _read_write_delay=1
    _write_queue=[]
    _read_queue=[]
    _ini_file = False
    url=''
    login_page=''
    site=''
    user_agent=''
    username=''
    password=''
    password_hash=''
    cj=None
    headers = {}
    opener=None
    map_cycles = {}
    map_cycle_no = 0
    active_map_cycle = 0
    _gametypes = {"TE" : "ROGame.ROGameInfoTerritories", "CD" : "ROGame.ROGameInfoCountdown", "FF" : "ROGame.ROGameInfoFirefight" }
    _maps = {"TE" : ['TE-Apartments', 'TE-Barracks', 'TE-CommisarsHouse', 'TE-FallenFighters', 'TE-GrainElevator', 'TE-Gumrak', 'TE-PavlovsHouse', 'TE-RedOctoberFactory', 'TE-Spartanovka', 'TE-Station'],
            "CD" : ['CD-Apartments', 'CD-Barracks', 'CD-CommisarsHouse', 'CD-FallenFighters', 'CD-GrainElevator', 'CD-Gumrak', 'CD-PavlovsHouse', 'CD-RedOctoberFactory', 'CD-Spartanovka', 'CD-Station'],
            "FF" : ['FF-Apartments', 'FF-Barracks', 'FF-GrainElevator', 'FF-Station']
            }

    _commands = {}
    _commands['message'] = '%(prefix)s %(message)s'
    _commands['say'] = ('%(prefix)s %(message)s')
    _commands['kick'] = ('adminkick+%(playerid)s')
    _commands['ban'] = ('adminkickban+%(playerid)s')
    _commands['tempban'] = ('adminkick+%(playerid)s')
    
    _settings = {'line_length': 90, 
                 'min_wrap_length': 100}
    
    prefix = '%s: '
    
    def startup(self):
        self.debug("startup()")
        
        # create the 'Admin' client
        self.clients.newClient('Admin', guid='Server', name='Admin', hide=True, pbid='Server', team=b3.TEAM_UNKNOWN)
        if self.config.has_option('server','ro2admin'):
            self.username = self.config.get('server', 'ro2admin')
        else:
            self.username="Admin"
        
        
        if self.config.has_option('server','inifile'):
            # open ini file
            ini_file = self.config.get('server','inifile')
            if ini_file[0:6] == 'ftp://':
                    self.ftpconfig = functions.splitDSN(ini_file)
                    self._ini_file = 'ftp'
                    self.bot('ftp supported')
            elif ini_file[0:7] == 'sftp://':
                self.bot('sftp currently not supported')
            else:
                self.bot('Getting configs from %s', ini_file)
                f = self.config.getpath('server', 'inifile')
                if os.path.isfile(f):
                    self.input  = file(f, 'r')
                    self._ini_file = f

        if not self._ini_file:
            self.debug('Incorrect ini file or no ini file specified, map commands other than nextmap not available')
        
        
        self.cron + b3.cron.CronTab(self.retrievePlayerList, second='*/%s' % self._playerlistInterval)
    
        self.user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
        self.headers = {'User-Agent' : self.user_agent, "Accept": "ext/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language" : "en-us,en;q =0.5", "Content-type": "application/x-www-form-urlencoded", "Accept-Charset" : "ISO-8859-1,utf-8;q=0.7,*;q=0.7", "Referer" : ''}
        self.site=self._publicIp + ':' + str(self._rconPort)
        self.login_page="ServerAdmin"
        self.password=self._rconPassword
        
        self.password_hash = "$sha1$%s" % hashlib.sha1("%s%s" % (self.password, self.username)).hexdigest()

        self.url = "http://%s/%s" % (self.site, self.login_page)
        
    def handle_chat(self, data):
        """Handle the chat from players"""
        if string.capitalize(data['div_class']) == 'Chatnotice':
            return
        func = 'onChat_type%s' % (string.capitalize(data['div_class']))

        if hasattr(self, func):
            self.debug('routing ----> %s' % func)
            func = getattr(self, func)
            event = func(data)
            if event:
                if event != 'Unable to Auth client':
                    self.queueEvent(event)
                else:
                    return
            else:
                self.warning('TODO handle: %s(%s)' % (func, data))
        else:
            self.warning('TODO handle packet : %s' % packet)
            self.queueEvent(self.getEvent('EVT_UNKNOWN', packet))
                    
        
    def run(self):
        """Main worker thread for B3"""
        self.bot('Start listening ...')
        self.screen.write('Startup Complete : B3 is running! Let\'s get to work!\n\n')
        self.screen.write('(If you run into problems, check %s for detailed log info)\n' % self.config.getpath('b3', 'logfile'))

        self.updateDocumentation()
        
        #Connect to RO2 web server
        
        web_auth = self.webconnect()
        if web_auth:
            self.bot('Authenticated on Web Server')
            
        self.working=True

        while self.working:
            #While we are working, connect to the RO2 server
            self._paused=False
            if self._paused:
                if not self._pauseNotice:
                    self.bot('PAUSED - Not parsing any lines, B3 will be out of sync.')
                    self._pauseNotice = True
            else:
                self._pauseNotice = False
                counter = 0
                while len(self._write_queue) == 0 and counter < 5:
                    time.sleep(.2)
                    counter +=1
                
                if not len(self._write_queue):
                    self.readwriteajax()
                else:
                    self.debug('Go to ajax')
                    message = self._write_queue.pop(0)
                    self.debug(self._write_queue)
                    self.readwriteajax(message)
                    
                while len(self._read_queue):
                    chat_data = self._read_queue.pop(0)
                    self.handle_chat(chat_data)
                
                counter = 0
                time.sleep(.5)
        self.bot('Stop listening.')

        if self.exiting.acquire(1) and self.exitcode:
            sys.exit(self.exitcode)
                
    def readwriteweb(self, data= None, referer=None, addurl=None):
        """Handles Reading and Writing to the web interface"""
        data_url = self.url + addurl
        if not referer:
            referer = data_url
        else:
            referer = self.url + referer
            
        self.headers['Referer'] = referer
        
        try:
            request_console = urllib2.Request(data_url, data, self.headers)
            console_read = self.opener.open(request_console)
            console_data = console_read.read()
            return console_data
            
        except Exception:
            self.debug('Failed to open URL')
            self.webconnect()
            return 

    def webconnect(self):
        """Login and make initial connection to the web interface"""
        remember=-1        
        password=''
        login_url = self.url + '/'
        headers = {'Content-type' : 'application/x-www-form-urlencoded', 'User-Agent' : self.user_agent}
        self.cj = cookielib.LWPCookieJar()
        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cj))
        urllib2.install_opener(self.opener)
        findpage_attempt = 0
        self._paused = True
        response = ""
        while findpage_attempt < 11:
            try:
                request = urllib2.Request(login_url, None, headers)
                page = urllib2.urlopen(request)
                response = page.read()
                break
            except Exception:
                findpage_attempt += 1
                if findpage_attempt > 10:
                    self.debug('Failed to find web page - wait 10 seconds')
                    time.sleep(10)
                    findpage_attempt = 1
                else:
                    time.sleep(1)
                    self.debug('Failed to find Web page %s - Wait 1 second' % findpage_attempt)
                    
        #<input type="hidden" name="token" value="3309899D" />
        token_start = response.partition('<input type="hidden" name="token" value="')
        token = token_start[2]
        token_value = token[0:8]

        login_url = self.url + '/'
        referer = login_url
        data = urllib.urlencode({ 'token' : token_value, 'password_hash' : self.password_hash, 'username' : self.username, 'password' : password, 'remember' : remember })
        self.headers['Referer'] = referer
        
        login_attempt = 1
        while login_attempt < 11:
            try:
                self.debug('Login attempt %s' % login_attempt)
                request_console = urllib2.Request(login_url, data, self.headers)
                console_read = self.opener.open(request_console)
                self._paused = False
                return True
            except Exception:
                self.debug('Failed to login %s' % login_attempt)
                self._paused = True
                login_attempt += 1
                if login_attempt > 11:
                    raise
                time.sleep(1)
        
        
    def readwriteajax(self, message = None):
        """Read and Write to the Ajax interface"""
        if message:
            message_text = self.addplus(message)
        else:
            message_text=''
    
        #<div class="chatmessage">
        #<span class="teamcolor" style="background: #8FB9B0;">&#160;</span>
        #<span class="username">&lt;82ndAB&gt;1LT.Bravo17 </span>:
        #<span class="message">test message from game</span>
        #</div>
        
        #<div class="chatmessage">
        #<span class="teamcolor" style="background: #8FB9B0;">&#160;</span>
        #<span class="teamnotice" style="color: #8FB9B0;">(Team)</span>
        #<span class="username" title="Axis">&lt;82ndAB&gt;1LT.Bravo17 </span>:
        #<span class="message">Team chat</span>
        #</div>
        
        #<div class="chatnotice">
        #<span class="noticesymbol">***</span> [<span class="username"></span>]
        #<span class="message">82ndAB ADMIN: No offensive names.</span>
        #</div>
        
        chatdata_url = '/current/chat/data'
        #data = 'ajax=1&message=message+from+b3&teamsay=-1'
        data = 'ajax=1' + message_text
        referer = '/current/chat'
        chat_data = self.readwriteweb(data, referer, chatdata_url)

        if chat_data:
            if len(chat_data) > 0:
                self.decode_chat_data(chat_data)
 
        return
        

    def addplus(self, message):
        """Replace spaces with plusses ready for sending to the Ajax interface
        also replaces other characters that mess up html"""
        #ajax=1&message=test+chat&teamsay=-1
        message = message.replace(' ', '+')
        message = message.replace('?','%3F')
        message = '&message=' + message + '&teamsay=-1'
        self.debug(message)
        return message
        
    def decode_chat_data(self, data):
        """Decode the data reeived from the web interface and extract the chat data"""
        data = data.partition('div class="')[2]
        while data != '':
            chat_decoded = {}
            data_split = data.partition('">')
            chat_decoded['div_class'] = data_split[0]
            data = data_split[2]
            while data.partition('<span class="')[2] != '':
                data = data.partition('<span class="')[2]
                data_split = data.partition('"')
                span_class = data_split[0]
                data_split = data.partition('">')
                data = data_split[2]
                data_split = data.partition('</span>')
                chat_decoded[span_class] = data_split[0]
                data = data_split[2]
                
            data = data.partition('div class="')[2]
            #Ignore what B3 just wrote
            chat_decoded['username'] = self.getUsername(chat_decoded['username'])
            if chat_decoded['username'] == self.username:
                return
            #Ignore new format for server messages 
            if chat_decoded['username'] == '' and chat_decoded['noticesymbol'] == '***':
                return
                
            if chat_decoded['message'].find('#G') != -1:
                chat_decoded['message'] = chat_decoded['message'].rpartition('#G')[0]
                
            self._read_queue.append(chat_decoded)
        
    def onChat_typeChatnotice(self,data):
        """Ignore Admin messages"""
        #Admin Chat ignore
        return None
        
        
        #<div class="chatmessage">
        #<span class="teamcolor" style="background: #8FB9B0;">&#160;</span>
        #<span class="username">&lt;82ndAB&gt;1LT.Bravo17 </span>:
        #<span class="message">test message from game</span>
        #</div>     
        
    def onChat_typeChatmessage(self, data):
        """Handle player chat"""
        name = self.getUsername(data['username'])
        text = data['message']
        # if a command and it contains #no convert to @no
        if text[0] == '!':
            match = re.search(r' #([0-9]+)\b', text)
            if match:
                start = match.start()
                text = (text[0:start+1] + '@' + text[start+2:])
                
        team = False
        if data.has_key('teamnotice'):
            team = True
            
        client = self.clients.getByName(name)
        if client is None:
            self.retrievePlayerList()
            self.debug("Trying to Auth client")
            client = self.clients.getByName(name)
            if client is None:
                self.debug("Unable to Auth client")
                return 'Unable to Auth client'

        if team:
            return self.getEvent('EVT_CLIENT_TEAM_SAY', text, client, client.team)
        else:
            return self.getEvent('EVT_CLIENT_SAY', text, client)

        
    def getUsername(self, name):
        """Retrieve the username and make it 'safe' """
        name = '%r' % name
        self.debug('namebefore = %s' % name)
        name = name.replace("\'", "")
        name = name.replace(r"\\", "\\")
        name = name.strip()

        name = self.stripColors(name)

        if name.find('&') != -1:
            name = name.replace('&lt;', '<')
            name = name.replace('&gt;', '>')
            
        self.debug('nameafter = %s' % name)            
        return name
 
    def decodeplayers(self, data):
        """Get the list of players from the web data"""
        players = {}
        data = data.partition('<table id="players" class="grid">')[2]
        data = data.partition('<tbody>')[2]
        data = data.partition('</tbody>')[0]
        while data.find('<tr class=') != -1:
            players_data = data.partition('</tr>')
            data = players_data[2]
            next_player = players_data[0]
            next_player_decoded = self.decode_nextplayer(next_player)
            players[str(next_player_decoded['playerid'])] = next_player_decoded

        return players
        
    def decode_nextplayer(self, data):
        """Get the next players details from the web data"""
        player={}
        data = data.partition('<td style=')[2]
        data = data.partition('>')[2]
        #left most character 0 axis 1 allies
        color = data.partition('</td>')[0]
        data = data.partition('<td>')[2]
        player['name'] = self.getUsername(data.partition('</td>')[0])
        data = data.partition('<td class="right">')[2]
        player['ping'] = data.partition('</td>')[0]
        data = data.partition('<td>')[2]
        player['ip'] = data.partition('</td>')[0]
        data = data.partition('<td>')[2]
        player['guid'] = data.partition('</td>')[0]
        data = data.partition('<td>')[2]
        player['steam_id'] = data.partition('</td>')[0]
        data = data.partition('<td class="center">')[2]
        player['admin'] = data.partition('</td>')[0]
        data = data.partition('<td class="center">')[2]
        spec = data.partition('</td>')[0]
        data = data.partition('<input type="hidden" name="playerid" value="')[2]
        player['playerid'] = data.partition('"')[0]
        data = data.partition('<input type="hidden" name="playerkey" value="')[2]
        player['playerkey'] = data.partition('"')[0]
        if spec.lower() == 'yes':
            player['team'] = self.getTeam('2')
        else:
            player['team'] = self.getTeam(color[0])
        
        return player
        
        
    def decodeBans(self, data):
        """Retrieve the list of Bans from the web data"""
        ban_list = {}
        if data.find('<!--<td><%ban.playername%></td>-->') == -1:
            self.debug('No bans in list')
            return ban_list

        while data.find('<!--<td><%ban.playername%></td>-->') != -1:
            data = data.partition('<!--<td><%ban.playername%></td>-->')[2]
            data = data.partition('<td>')[2]
            banid = data.partition('</td>')[0]
            data = data.partition('<input type="hidden" name="banid" value="')[2]
            ban_no = data.partition('"')[0]
            ban_list[str(banid)] = ban_no
            
        return ban_list
            
            
    # =======================================
    # implement parser interface
    # =======================================
    
    def getPlayerList(self):
        """\
        Returns a list of client objects
        """
        clients = self.clients.getList()
        return clients

    def write(self, msg, maxRetries=None):
        """Write a message to Console via Ajax"""
        if self.replay:
            self.bot('Sent rcon message: %s' % msg)
        elif self.output is None:
            pass
        else:
            msg = self.stripMsgColors(msg)
            self._write_queue.append(msg)
            return

    def writelines(self, msg):
        """Write a sequence of messages to Console via Ajax."""
        if self.replay:
            self.bot('Sent rcon message: %s' % msg)
        elif self.output is None:
            pass
        else:
            for line in msg:
                self.write(line)
                time.sleep(0.1)
            return
            
    def writeAdminCommand(self, cmd):
        """Write an Admin command via the Web interface console (Limited in what actually works)"""
        consoledata_url = self.url + '/console'
        data = 'command=' + cmd
        headers = {'User-Agent' : self.user_agent, "Accept": "ext/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language" : "en-us,en;q =0.5", "Content-type": "application/x-www-form-urlencoded", "Accept-Charset" : "ISO-8859-1,utf-8;q=0.7,*;q=0.7", "Referer" : consoledata_url}
        request_console = urllib2.Request(consoledata_url, data, headers)
        adminconsole_read = self.opener.open(request_console)
        console_data = adminconsole_read.read()
    
    
    def getServerPlayerList(self):
        """\
        Returns a list of client objects
        """
        self.verbose2('Retrieving Playerlist')
        playerlist_url = '/current/players'
        referer = '/current'
        data = None
        playerlist_data = self.readwriteweb(data, referer, playerlist_url)
        if playerlist_data.find('<em>There are no players</em>') != -1:
            self.debug('No players on server')
            clients = {}
        else:
            clients = self.decodeplayers(playerlist_data)
            self.debug (clients)
        
        return clients
            
    def authorizeClients(self):
        """\
        For all connected players, fill the client object with properties allowing to find 
        the user in the database (usualy guid, or punkbuster id, ip) and call the 
        Client.auth() method 
        """
        pass
    
    def findNewPlayers(self, c_client_list):
        """Gets a list of non-authed players on the server"""
        for c in c_client_list:
            cl = c_client_list[c]
            uid = cl['guid']
            if len(uid) != 18:
                self.warning(u"weird UID : [%s]" % uid)
            
            # try to get the client by guid
            client = self.clients.getByGUID(uid)
            if not client:

                self.debug('adding client')
                self.debug(cl)
                client = self.clients.newClient(cl['playerid'], guid=uid, name=cl['name'], team=b3.TEAM_UNKNOWN, ip=cl['ip'])
                # update client data
                client.name = cl['name']
                client.team = cl['team']
                client.cid = cl['playerid']
                client.ip = cl['ip']
            else:
                if client.team != cl['team']:
                    self.verbose2('Team change detected for %s' % client.name)
                    client.team = cl['team']
            self.verbose2('onServerPlayer: name: %s, team: %s' %( client.name, client.team ))

            
    def syncDeletions(self, connected_clients):
        """\
        Check Clients list against all connected players returned by self.getServerPlayerList() and 
        if required call the client.disconnect() method to remove a client from self.clients.
        """

        client_cid_list = []

        for cl in connected_clients.values():
            client_cid_list.append(cl['playerid'])

        for client in self.clients.getList():

            if client.cid not in client_cid_list:
                self.debug('Removing %s from list' % client.name)
                client.disconnect()
                

    def sync(self, connected_clients=None):
        """\
        if connected_clients is None :
            get dict of connected players from self.getPlayerList()
        else use connected_clients as the list of connected players 
        For all connected players, get the matching Client
        object from self.clients (with self.clients.getByCID(cid) or similar methods) and
        look for inconsistencies. If required call the client.disconnect() method to remove
        a client from self.clients.
        This is mainly useful for games where clients are identified by the slot number they
        occupy. On map change, a player A on slot 1 can leave making room for player B who
        connects on slot 1.
        """
        if connected_clients is None:
            connected_clients = self.getPlayerList()
            
        self.debug("synchronizing clients")
        mlist = {}

        for client in connected_clients:
            mlist[client.cid] = client

        return mlist

    def say(self, msg):
        """\
        broadcast a message to all players
        """
        msg = self.stripMsgColors(msg)
        for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
            line = self.stripMsgColors(line)
            self.write(self.getCommand('say',  prefix=self.msgPrefix, message=line))

    def message(self, client, text):
        """\
        display a message to a given player
        """
        # actually send private messages
        text = self.stripMsgColors(text)
        for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
            line = self.stripMsgColors(line)
            self.write(self.getCommand('message', uid=client.guid, prefix=self.msgPrefix, message=line))

    def kick(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        kick a given player
        """
        self.debug('KICK : client: %s, reason: %s', client.cid, reason)
        if admin:
            fullreason = self.getMessage('kicked_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('kicked', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripMsgColors(fullreason)
        reason = self.stripMsgColors(reason)

        if not silent and fullreason != '':
            self.say(fullreason)


        self.writeAdminCommand(self.getCommand('kick', playerid=client.cid))
        self.queueEvent(self.getEvent('EVT_CLIENT_KICK', reason, client))
        client.disconnect()

    def ban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        ban a given player
        """
        self.debug('BAN : client: %s, reason: %s', client.cid, reason)
        if admin:
            fullreason = self.getMessage('banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin))
        else:
            fullreason = self.getMessage('banned', self.getMessageVariables(client=client, reason=reason))
        fullreason = self.stripMsgColors(fullreason)
        reason = self.stripMsgColors(reason)

        if not silent and fullreason != '':
            self.say(fullreason)
        
        banid = client.guid
        
        bandata_url = '/policy/bans'
        data = 'action=add&uniqueid=' + banid
        referer = None
        self.debug('Ban data %s' % data)
        console_data = self.readwriteweb(data, referer, bandata_url)
        
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN', {'reason': reason, 'admin': admin}, client))
        
        #If client is on server kick them
        c = self.clients.getByGUID(banid)
        if c:
            self.writeAdminCommand(self.getCommand('kick', playerid=c.cid))
        
        client.disconnect()

    def unban(self, client, reason='', admin=None, silent=False, *kwargs):
        """\
        unban a given player
        """
        ban_list = self.retrieveBanlist()

        self.debug('using guid to unban')
        banid = client.guid
        ban_no = None
        try:
            ban_no = ban_list[banid]
        except Exception:
            if admin:
                admin.message(' %s not in server banlist' %client.name)

        if ban_no:
            ban_no = str(ban_no[8:])
        
            bandata_url = '/policy/bans'
            referer = None
            data = 'banid=plainid%3A' + ban_no + '&action=delete'
            banlist_data = self.readwriteweb(data, referer, bandata_url)
            if admin:
                admin.message('Removed %s from Server banlist' %client.name)
        
        if admin:
            admin.message('Removed %s from B3 banlist' %client.name)
            
        self.queueEvent(self.getEvent('EVT_CLIENT_UNBAN', reason, client))

    def tempban(self, client, reason='', duration=2, admin=None, silent=False, *kwargs):
        """\
        tempban a given player
        """
        self.debug('TEMPBAN : client: %s, reason: %s', client.cid, reason)
        if admin:
            fullreason = self.getMessage('temp_banned_by', self.getMessageVariables(client=client, reason=reason, admin=admin, banduration=b3.functions.minutesStr(duration)))
        else:
            fullreason = self.getMessage('temp_banned', self.getMessageVariables(client=client, reason=reason, banduration=b3.functions.minutesStr(duration)))
        fullreason = self.stripMsgColors(fullreason)
        reason = self.stripMsgColors(reason)

        if not silent and fullreason != '':
            self.say(fullreason)

        self.writeAdminCommand(self.getCommand('kick', playerid=client.cid))
        self.queueEvent(self.getEvent('EVT_CLIENT_BAN_TEMP', {'reason': reason, 
                                                              'duration': duration, 
                                                              'admin': admin}
                                      , client))
        client.disconnect()

        
    def getMaps(self):
        """\
        return the available maps/levels name
        """
        map_rotation = []
        self.map_cycles = {}
        self.map_cycle_no = 0
        self.active_map_cycle = -1
        if self._ini_file:
            if self._ini_file == 'ftp':
                self.getftpini()
            else:
                input = open(self._ini_file, 'r')
                for line in input:
                    if line[0:15] == 'ActiveMapCycle=':
                        self.active_map_cycle = int(line.partition('ActiveMapCycle=')[2])
                    if line[0:14] == 'GameMapCycles=':
                        self.map_cycles[str(self.map_cycle_no)] = line
                        self.map_cycle_no += 1
                        if self.active_map_cycle >= 0 and self.map_cycle_no > self.active_map_cycle:
                            break

                input.close()
                
            map_line = self.map_cycles[str(self.active_map_cycle)]
            map_line = map_line.partition('Maps=("')[2]
            map_line = map_line.partition('"),RoundLimits=')[0]
            map_rotation.append(map_line.partition('","')[0])
            while map_line.find('","') != -1:
                map_line= map_line.partition('","')[2]
                map_rotation.append(map_line.partition('","')[0])

        return map_rotation

    def changeMap(self, map):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        #gametype=ROGame.ROGameInfoTerritories&map=TE-Barracks&mutatorGroupCount=0&urlextra=&action=change
        gametype = map[0:2]
        if self._gametypes.has_key(gametype) and self._maps[gametype].count(map) > 0:
            mapchange_url = '/current/change'
            data = 'gametype=' + self._gametypes[gametype] + '&map=' + map + '&mutatorGroupCount=0&urlextra=&action=change'
            referer = None
            console_data = self.readwriteweb(data, referer, mapchange_url)
        else:
            self.write(self.getCommand('say',  prefix=self.msgPrefix, message='Incorrect Gametype-Map combination'))

            return
            
    def getMap(self):
        """\
        load the next map/level
        """
        #<dt>Map</dt>
        #<dd><code>mapname</code>
        current_url = '/current'
        referer = None
        data = None
        current_data = self.readwriteweb(data, referer, current_url)
        if current_data.find('<dt>Map</dt>') == -1:
            self.debug('Map error')
            return None
        current_data = current_data.partition('<dt>Map</dt>')[2]
        if current_data.find('<dd><code>') == -1:
            self.debug('Map error')
            return None
        current_data = current_data.partition('<dd><code>')[2]
        mapname = current_data.partition('</code>')[0]
        
        return mapname
    
    def getNextMap(self):
        """\
        load the next map/level
        """
        nextmap=''
        map_rotation = self.getMaps()
        no_maps = len(map_rotation)
        currentmap = self.getMap()
        if map_rotation.count(currentmap) == 1:
            i = map_rotation.index(currentmap)
            if i < no_maps-1:
                nextmap = map_rotation[i+1]
            else:
                nextmap = map_rotation[0]
                
        else:
            nextmap = 'Unknown'
        
        return nextmap
        
    def getPlayerPings(self):
        """\
        returns a dict having players' id for keys and players' ping for values
        """
        pings = {}
        clients = self.clients.getList()
        for c in clients:
            try:
                pings[c.name] = int(c.ping)
            except AttributeError:
                pass
        return pings
        
    def getPlayerScores(self):
        """\
        returns a dict having players' id for keys and players' scores for values
        """
        scores = {}
        clients = self.clients.getList()
        for c in clients:
            try:
                scores[c.name] = 0
            except AttributeError:
                pass
        return scores
    
    def getTeam(self, team):
        """Get the players team"""
        team = str(team).lower()
        if team == '0':
            result = b3.TEAM_RED
        elif team == '1':
            result = b3.TEAM_BLUE
        elif team == '2':
            result = b3.TEAM_SPEC
        elif team == '3':
            result = b3.TEAM_UNKNOWN
        else:
            result = b3.TEAM_UNKNOWN
        return result
    
    # =======================================
    # convenience methods
    # =======================================

    def getClient(self, name):
        """return a already connected client by searching the 
        clients cid index.

        This method can return None
        """
        client = self.clients.getByName(name)
        if client:
            return client
        return None
    
    def getClientByUidOrCreate(self, uid, name):
        """return a already connected client by searching the 
        clients guid index or create a new client
        
        This method can return None
        """
        client = self.clients.getByGUID(uid)
        if client is None and name:
            client = self.clients.newClient(name, guid=uid, name=name, team=b3.TEAM_UNKNOWN)
            client.last_update_time = time.time()
        return client
    
    def retrievePlayerList(self):
        """\
        Retrieve list of players on the server
        """
        if self._paused:
            return
        client_list = self.getServerPlayerList()
        self.findNewPlayers(client_list)
        self.syncDeletions(client_list)

    def retrieveBanlist(self):
        """\
        Returns a list of banned player from the server
        """
        self.verbose2('Retrieving Banlist')
        banlist_url = self.url + '/policy/bans'
        referer = self.url + '/policy/bans'
        headers = {'User-Agent' : self.user_agent, "Accept": "ext/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language" : "en-us,en;q =0.5", "Content-type": "application/x-www-form-urlencoded", "Accept-Charset" : "ISO-8859-1,utf-8;q=0.7,*;q=0.7", "Referer" : referer}
        request_banlist = urllib2.Request(banlist_url, None, headers)
        banlist_read = self.opener.open(request_banlist)
        banlist_data = banlist_read.read()
        ban_list = self.decodeBans(banlist_data)
        
        return ban_list

    def stripMsgColors(self, text):
        return re.sub(self._reColor, '', text).strip()

    def stripColors(self, text):
        return text.strip()


    def getftpini(self):
        def handleDownload(line):
            if line[0:15] == 'ActiveMapCycle=':
                self.active_map_cycle = int(line.partition('ActiveMapCycle=')[2])
            if line[0:14] == 'GameMapCycles=':
                self.map_cycles[str(self.map_cycle_no)] = line
                self.debug(line)
                self.map_cycle_no += 1



        ftp = None
        try:
            ftp = self.ftpconnect()
            self._nbConsecutiveConnFailure = 0
            remoteSize = ftp.size(os.path.basename(self.ftpconfig['path']))
            self.verbose("Connection successful. Remote file size is %s" % remoteSize)
            ftp.retrlines('RETR ' + os.path.basename(self.ftpconfig['path']), handleDownload)          

        except ftplib.all_errors, e:
            self.debug(str(e))
            try:
                ftp.close()
                self.debug('FTP Connection Closed')
            except Exception:
                pass
            ftp = None

        try:
            ftp.close()
        except Exception:
            pass


    def ftpconnect(self):
        #self.debug('Python Version %s.%s, so setting timeout of 10 seconds' % (versionsearch.group(2), versionsearch.group(3)))
        self.verbose('Connecting to %s:%s ...' % (self.ftpconfig["host"], self.ftpconfig["port"]))
        ftp = FTP()
        ftp.set_debuglevel(self._ftplib_debug_level)
        ftp.connect(self.ftpconfig['host'], self.ftpconfig['port'], self._ftpconnectionTimeout)
        ftp.login(self.ftpconfig['user'], self.ftpconfig['password'])
        ftp.voidcmd('TYPE I')
        dir = os.path.dirname(self.ftpconfig['path'])
        self.debug('trying to cwd to [%s]' % dir)
        ftp.cwd(dir)
        return ftp
    
    # =======================================
    # Not Implemented methods
    # =======================================
    
    def rotateMap(self):
        """\
        load the next map/level
        """
        self.say('Rotate Map not implemented')
    


########NEW FILE########
__FILENAME__ = smg
# Smokin' Guns parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2009 ailmanki
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA    02110-1301    USA
#
# CHANGELOG
# 31/01/2010 - 0.1 - Courgette
# * use the new /cp command to send private messages (requires SmokinGuns v1.1)
# 31/01/2010 - 0.1.1 - Courgette
# * getMap() is now inherited from q3a
# 06/02/2010 - 0.1.2 - Courgette
# * do not use cp/bigtext for private messaging to make this parser compatible with SG pior to v1.1
# * fix the ban command
# 15/09/2010 - 0.1.3 - GrosBedo
# * added !nextmap and !maps support
# 09/04/2011 - 0.1.4 - Courgette
# * reflect that cid are not converted to int anymore in the clients module

__author__  = 'xlr8or, Courgette'
__version__ = '0.1.4'

import re, string, threading
import b3
import b3.events
from b3.parsers.q3a.abstractParser import AbstractParser
import b3.parsers.punkbuster

class SmgParser(AbstractParser):
    gameName = 'smg'
    _counter = {}

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _empty_name_default = 'EmptyNameDefault'

    _commands = {}
    _commands['message'] = '%(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = '%(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banClient %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'restartgame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:.]+\s?)?')

    _lineFormats = (
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        #
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        #
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),
        #
        # Falling through?
        # 1:05 ClientConnect: 3
        # 1:05 ClientUserinfoChanged: 3 guid\CAB616192CB5652375401264987A23D0\n\xlr8or\t\0\model\wq_male2/red\g_redteam\\g_blueteam\\hc\100\w\0\l\0\tt\0\tl\0
        re.compile(r'^(?P<action>[a-z_]+):\s*(?P<data>.*)$', re.IGNORECASE)
    )

    #map: dm_fort
    #num score ping name            lastmsg address               qport rate
    #--- ----- ---- --------------- ------- --------------------- ----- -----
    #  1     1    0 TheMexican^7          100 bot                       0 16384
    #  2     1    0 Sentenza^7             50 bot                       0 16384
    #  3     3   37 xlr8or^7                0 145.99.135.227:27960   3598 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    #_regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.:-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None

    ## kill mode constants: modNames[meansOfDeath]
    MOD_UNKNOWN='0'
    #melee
    MOD_KNIFE='1'
    #pistols
    MOD_REM58='2'
    MOD_SCHOFIELD='3'
    MOD_PEACEMAKER='4'
    #rifles
    MOD_WINCHESTER66='5'
    MOD_LIGHTNING='6'
    MOD_SHARPS='7'
    #shotguns
    MOD_REMINGTON_GAUGE='8'
    MOD_SAWEDOFF='9'
    MOD_WINCH97='10'
    #automatics
    MOD_GATLING='11'
    #explosives
    MOD_DYNAMITE='12'
    MOD_MOLOTOV='13'
    #misc
    MOD_WATER='14'
    MOD_SLIME='15'
    MOD_LAVA='16'
    MOD_CRUSH='17'
    MOD_TELEFRAG='18'
    MOD_FALLING='19'
    MOD_SUICIDE='20'
    MOD_WORLD_DAMAGE='21'
    MOD_TRIGGER_HURT='22'
    MOD_NAIL='23'
    MOD_CHAINGUN='24'
    MOD_PROXIMITY_MINE='25'
    MOD_BOILER='26'

    ## meansOfDeath to be considered suicides
    Suicides = (
        MOD_WATER,
        MOD_SLIME,
        MOD_LAVA,
        MOD_CRUSH,
        MOD_TELEFRAG,
        MOD_FALLING,
        MOD_SUICIDE,
        MOD_TRIGGER_HURT,
        MOD_NAIL,
        MOD_CHAINGUN,
        MOD_PROXIMITY_MINE,
        MOD_BOILER
    )

#---------------------------------------------------------------------------------------------------

    def startup(self):
        # add the world client
        
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')
        #if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
        #    self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)

#---------------------------------------------------------------------------------------------------

    # Added for debugging and identifying/catching log lineparts
    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('XLR--------> line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return (m, m.group('action').lower(), m.group('data').strip(), client, target)
        elif '------' not in line:
            self.verbose('XLR--------> line did not match format: %s' % line)

#---------------------------------------------------------------------------------------------------

    def OnClientconnect(self, action, data, match=None):
        self._clientConnectID = data
        client = self.clients.getByCID(data)
        return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)

    # Parse Userinfo
    def OnClientuserinfo(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            cid = bclient['cid']
            client = self.clients.getByCID(cid)

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if bclient.has_key('guid'):
                    guid = bclient['guid']
                else:
                    #guid = 'BOT-' + str(bclient['name'])
                    guid = 'BOT-' + str(cid)
                    self.verbose('BOT connected!')
                    client = self.clients.newClient(cid, name=bclient['name'], ip='0.0.0.0', state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid })
                    return None

                self._counter[cid] = 1
                t = threading.Timer(2, self.newPlayer, (cid, guid, bclient['name']))
                t.start()
                self.debug('%s connected, waiting for Authentication...' %bclient['name'])
                self.debug('Our Authentication queue: %s' % self._counter)

        return None

    # disconnect
    def OnKill(self, action, data, match=None):
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))
        
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in self.Suicides:
            # those kills should be considered suicides
            self.debug('OnKill: Fixed attacker, suicide detected: %s' %match.group('text'))
            attacker = victim
        else:
            attacker = self.clients.getByCID(match.group('acid'))
        ## end fix attacker
          
        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not defined we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    # startgame
    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()

        self.debug('Synchronizing client info')
        self.clients.sync()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    def OnSayteam(self, action, data, match=None):
        # Teaminfo does not exist in the sayteam logline. Parse it as a normal say line
        return self.OnSay(action, data, match)

#---------------------------------------------------------------------------------------------------

    def parseUserInfo(self, info):
        #2 n\peyote\t\3\c\0\r\0\m\0000000\s\0000000\dn\\dr\0\w\0\lw\0\sw\0\mu\0\ref\0\p\0\ss\0\sc\0\tv\0\lc\0
        #0 \g_password\none\cl_guid\0A337702493AF67BB0B0F8565CE8BC6C\cl_wwwDownload\1\name\thorn\rate\25000\snaps\20\cl_anonymous\0\cl_punkbuster\1\password\test\protocol\83\qport\16735\challenge\-79719899\ip\69.85.205.66:27960
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        # split port from ip field
        if data.has_key('ip'):
            tip = string.split(data['ip'], ':', 1)
            data['ip'] = tip[0]
            data['port'] = tip[1]

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)
        if data.has_key('cl_guid'):
            data['cl_guid'] = data['cl_guid'].lower()

        if data.has_key('pbid'):
            data['pbid'] = data['pbid'].lower()

        if data.has_key('cl_guid') and not data.has_key('pbid'):
            data['pbid'] = data['cl_guid']
        
        return data


    def getTeam(self, team):
        if team == 'red': team = 1
        if team == 'blue': team = 2
        team = int(team)
        if team == 1:
            #self.verbose('Team is Red')
            return b3.TEAM_RED
        elif team == 2:
            #self.verbose('Team is Blue')
            return b3.TEAM_BLUE
        elif team == 3:
            #self.verbose('Team is Spec')
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN

    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == '0':
            _gameType = 'dm'        # Deathmatch
        elif gameTypeInt == '1':
            _gameType = 'du'        # Duel
        elif gameTypeInt == '3':
            _gameType = 'tdm'       # Team Death Match
        elif gameTypeInt == '4':
            _gameType = 'ts'        # Team Survivor (Round TDM)
        elif gameTypeInt == '5':
            _gameType = 'br'        # Bank Robbery
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    def getMaps(self):
        if self._maplist is not None:
            return self._maplist

        data = self.write('fdir *.bsp')
        if not data:
            return []

        mapregex = re.compile(r'^maps/(?P<map>.+)\.bsp$', re.I)
        maps = []
        for line in data.split('\n'):
            m = re.match(mapregex, line.strip())
            if m:
                if m.group('map'):
                    maps.append(m.group('map'))

        return maps

    def getNextMap(self):
        data = self.write('nextmap')
        nextmap = self.findNextMap(data)
        if nextmap:
            return nextmap
        else:
            return 'no nextmap set or it is in an unrecognized format !'

    def findNextMap(self, data):
        # "nextmap" is: "vstr next4; echo test; vstr aupo3; map oasago2"
        # the last command in the line is the one that decides what is the next map
        # in a case like : map oasago2; echo test; vstr nextmap6; vstr nextmap3
        # the parser will recursively look each last vstr var, and if it can't find a map, fallback to the last map command
        self.debug('Extracting nextmap name from: %s' % (data))
        nextmapregex = re.compile(r'.*("|;)\s*((?P<vstr>vstr (?P<vstrnextmap>[a-z0-9_]+))|(?P<map>map (?P<mapnextmap>[a-z0-9_]+)))', re.IGNORECASE)
        m = re.match(nextmapregex, data)
        if m:
            if m.group('map'):
                self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                return m.group('mapnextmap')
            elif m.group('vstr'):
                self.debug('Nextmap is redirecting to var: %s' % (m.group('vstrnextmap')))
                data = self.write(m.group('vstrnextmap'))
                result = self.findNextMap(data) # recursively dig into the vstr vars to find the last map called
                if result: # if a result was found in a deeper level, then we return it to the upper level, until we get back to the root level
                    return result
                else: # if none could be found, then try to find a map command in the current string
                    nextmapregex = re.compile(r'.*("|;)\s*(?P<map>map (?P<mapnextmap>[a-z0-9_]+))"', re.IGNORECASE)
                    m = re.match(nextmapregex, data)
                    if m.group('map'):
                        self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                        return m.group('mapnextmap')
                    else: # if none could be found, we go up a level by returning None (remember this is done recursively)
                        self.debug('No nextmap found in this string !')
                        return None
        else:
            self.debug('No nextmap found in this string !')
            return None

    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                if client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist

    def connectClient(self, ccid):
        if self.PunkBuster:
            self.debug('Getting the (PunkBuster) Playerlist')
        else:
            self.debug('Getting the (status) Playerlist')
        players = self.getPlayerList()
        self.verbose('connectClient() = %s' % players)

        for cid, p in players.iteritems():
            #self.debug('cid: %s, ccid: %s, p: %s' %(cid, ccid, p))
            if int(cid) == int(ccid):
                self.debug('Client found in status/playerList')
                return p

    def newPlayer(self, cid, guid, name):
        if not self._counter.get(cid):
            self.verbose('newPlayer thread no longer needed, Key no longer available')
            return None
        if self._counter.get(cid) == 'Disconnected':
            self.debug('%s disconnected, removing from authentication queue' %name)
            self._counter.pop(cid)
            return None

        self.debug('newClient: %s, %s, %s' %(cid, guid, name))
        sp = self.connectClient(cid)

        if sp:
            ip = sp['ip']
            self.verbose('ip = %s' %ip)
            self._counter.pop(cid)
        elif self._counter[cid] > 10:
            self.debug('Couldn\'t Auth %s, giving up...' % name)
            self._counter.pop(cid)
            return None
        # Player is not in the status response (yet), retry
        else:
            self.debug('%s not yet fully connected, retrying...#:%s' %(name, self._counter[cid]))
            self._counter[cid] +=1
            t = threading.Timer(4, self.newPlayer, (cid, guid, name))
            t.start()
            return None
            
        client = self.clients.newClient(cid, name=name, ip=ip, state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid })

#---- Documentation --------------------------------------------------------------------------------
"""

//infos clienuserinfochanged
//0 = player_ID
//n = name
//t = team
//c = class
//r = rank
//m = medals
//s = skills
//dn = disguised name
//dr = disguised rank
//w = weapon
//lw = weapon last used
//sw = 2nd weapon (not sure)
//mu = muted
//ref = referee
//lw = latched weapon (weapon on next spawn)
//sw = latched secondary weapon (secondary weapon on next spawn)
//p = privilege level (peon = 0, referee (vote), referee (password), semiadmin, rconauth) (etpro only)
//ss = stats restored by stat saver (etpro only)
//sc = shoutcaster status (etpro only)
//tv = ETTV slave (etpro only)

"""
########NEW FILE########
__FILENAME__ = smg11
# Smoking' Guns 1.1 parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA    02110-1301    USA
#
# CHANGELOG
# 31/01/2010 - 0.1 - Courgette
# * use the new /cp command to send private messages (requires SmokinGuns v1.1)
# 31/01/2010 - 0.1.1 - Courgette
# * getMap() is now inherited from q3a
# 01/02/2010 - 0.2 - Courgette
# * fix _regPlayer regex for SGv1.1b4
# * discover clients at bot start
# * make use of dumpuser to get a player's ip
# * don't lower() guid
# 06/02/2010 - 0.3 - Courgette
# * enable private messaging with the new /tell command
# * fix ban command
# 06/02/2010 - 0.4 - Courgette
# * parser recognizes damage lines (when enabled in SG config with : set g_debugDamage "1")
# 04/03/2010 - 0.5 - Courgette
# * OnClientuserinfo -> OnClientuserinfochanged 
# 06/03/2010 - 0.6 - Courgette
# * make sure bots are bots on client connection
# * auth client by making use of dumpuser whenever needed
# * add custom handling of OnItem action
# * add the money property to clients that holds the amount of money a player has
# 07/03/2010 - 0.7 - Courgette
# * when players buy stuff or pickup money, EVT_CLIENT_ITEM_PICKUP events are replaced by
#   two SG specific new events : EVT_CLIENT_GAIN_MONEY and EVT_CLIENT_SPEND_MONEY
#   Those events help keeping track of money flows and should give plugin developpers 
#   a lot of freedom
# 07/03/2010 - 0.8 - Courgette
# * fix bug introduced in 0.6 which messed up clients cid as soon as they are chatting...
# 08/03/2010 - 0.9 - Courgette
# * should fix the bot's team issue
# 15/09/2010 - 0.9.1 - GrosBedo
# * added !nextmap and !maps support
#


__author__  = 'xlr8or, Courgette'
__version__ = '0.9.1'

import re, string, thread, time, threading
import b3
import b3.events
from b3.parsers.q3a.abstractParser import AbstractParser
import b3.parsers.punkbuster

class Smg11Parser(AbstractParser):
    gameName = 'smg'
    _connectingSlots = []
    _maplist = None
    
    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _empty_name_default = 'EmptyNameDefault'

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'tell %(cid)s %(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s %(message)s'
    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banClient %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'restartgame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:.]+\s?)?')

    _lineFormats = (
        #468950: client:0 health:90 damage:21.6 where:arm from:MOD_SCHOFIELD by:2
        re.compile(r'^\d+:\s+(?P<data>client:(?P<cid>\d+)\s+health:(?P<health>\d+)\s+damage:(?P<damage>[.\d]+)\s+where:(?P<hitloc>[^\s]+)\s+from:(?P<aweap>[^\s]+)\s+by:(?P<acid>\d+))$', re.IGNORECASE),
        
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<pbid>[0-9A-Z]{32}):\s*(?P<name>[^:]+):\s*(?P<num1>[0-9]+):\s*(?P<num2>[0-9]+):\s*(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<name>.+):\s+(?P<text>.*))$', re.IGNORECASE),
        #
        #1536:37Kill: 1 18 9: ^1klaus killed ^1[pura]fox.nl by MOD_MP40
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        #
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<cid>[0-9]+)\s(?P<text>.*))$', re.IGNORECASE),
        #
        # Falling through?
        # 1:05 ClientConnect: 3
        # 1:05 ClientUserinfoChanged: 3 guid\CAB616192CB5652375401264987A23D0\n\xlr8or\t\0\model\wq_male2/red\g_redteam\\g_blueteam\\hc\100\w\0\l\0\tt\0\tl\0
        re.compile(r'^(?P<action>[a-z_]+):\s*(?P<data>.*)$', re.IGNORECASE)
    )

    #map: dm_fort
    #num score ping name            lastmsg address               qport rate
    #--- ----- ---- --------------- ------- --------------------- ----- -----
    #  1     1    0 TheMexican^7          100 bot                       0 16384
    #  2     1    0 Sentenza^7             50 bot                       0 16384
    #  3     3   37 xlr8or^7                0 145.99.135.227:27960   3598 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None

    ## kill mode constants: modNames[meansOfDeath]
    MOD_UNKNOWN='0'
    #melee
    MOD_KNIFE='1'
    #pistols
    MOD_REM58='2'
    MOD_SCHOFIELD='3'
    MOD_PEACEMAKER='4'
    #rifles
    MOD_WINCHESTER66='5'
    MOD_LIGHTNING='6'
    MOD_SHARPS='7'
    #shotguns
    MOD_REMINGTON_GAUGE='8'
    MOD_SAWEDOFF='9'
    MOD_WINCH97='10'
    #automatics
    MOD_GATLING='11'
    #explosives
    MOD_DYNAMITE='12'
    MOD_MOLOTOV='13'
    #misc
    MOD_WATER='14'
    MOD_SLIME='15'
    MOD_LAVA='16'
    MOD_CRUSH='17'
    MOD_TELEFRAG='18'
    MOD_FALLING='19'
    MOD_SUICIDE='20'
    MOD_WORLD_DAMAGE='21'
    MOD_TRIGGER_HURT='22'
    MOD_NAIL='23'
    MOD_CHAINGUN='24'
    MOD_PROXIMITY_MINE='25'
    MOD_BOILER='26'

    ## meansOfDeath to be considered suicides
    Suicides = (
        MOD_WATER,
        MOD_SLIME,
        MOD_LAVA,
        MOD_CRUSH,
        MOD_TELEFRAG,
        MOD_FALLING,
        MOD_SUICIDE,
        MOD_TRIGGER_HURT,
        MOD_NAIL,
        MOD_CHAINGUN,
        MOD_PROXIMITY_MINE,
        MOD_BOILER
    )

#---------------------------------------------------------------------------------------------------

    def startup(self):
    
        # add SG specific events
        self.Events.createEvent('EVT_CLIENT_GAIN_MONEY', 'Client gain money')
        self.Events.createEvent('EVT_CLIENT_SPEND_MONEY', 'Client spend money')

        # add the world client
        self.clients.newClient('1022', guid='WORLD', name='World', hide=True, pbid='WORLD')
        #if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
        #    self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)

        # initialize connected clients
        self.info('discover connected clients')
        plist = self.getPlayerList()
        for cid, c in plist.iteritems():
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfochanged(None, userinfostring)
        
            
#---------------------------------------------------------------------------------------------------

    # Added for debugging and identifying/catching log lineparts
    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                self.debug('XLR--------> line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            
            try:
                action =  m.group('action').lower()
            except IndexError:
                # special case for damage lines where no action group can be set
                action = 'damage'
            
            return (m, action, m.group('data').strip(), client, target)
        elif '------' not in line:
            self.verbose('XLR--------> line did not match format: %s' % line)

#---------------------------------------------------------------------------------------------------
       
        
    def OnClientconnect(self, action, data, match=None):
        self._clientConnectID = data
        client = self.clients.getByCID(data)
        self.debug('OnClientConnect: %s, %s' % (data, client))
        return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)

    # Parse Userinfo
    def OnClientuserinfochanged(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            cid = bclient['cid']
            
            if cid in self._connectingSlots:
                self.debug('client on slot %s is already being connected' % cid)
                return
            
            self._connectingSlots.append(cid)
            client = self.clients.getByCID(cid)

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if bclient.has_key('team'):
                    bclient['team'] = self.getTeam(bclient['team'])

                if bclient.has_key('guid'):
                    guid = bclient['guid']
                else:
                    if bclient.has_key('skill'):
                        guid = 'BOT-' + str(cid)
                        self.verbose('BOT connected!')
                        self.clients.newClient(cid, name=bclient['name'], ip='0.0.0.0', state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid }, money=20)
                    else:
                        self.warning('cannot connect player because he has no guid and is not a bot either')
                    self._connectingSlots.remove(cid)
                    return None
                
                if not bclient.has_key('ip'):
                    infoclient = self.parseUserInfo(self.queryClientUserInfoByCid(cid))
                    if 'ip' in infoclient:
                        bclient['ip'] = infoclient['ip']
                    else:
                        self.warning('failed to get client ip')
                
                if bclient.has_key('ip'):
                    self.clients.newClient(cid, name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid }, money=20)
                else:
                    self.warning('failed to get connect client')
                    
            self._connectingSlots.remove(cid)
                
        return None

    # disconnect
    def OnKill(self, action, data, match=None):
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))
        
        victim = self.getByCidOrJoinPlayer(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfochanged(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in self.Suicides:
            # those kills should be considered suicides
            self.debug('OnKill: Fixed attacker, suicide detected: %s' %match.group('text'))
            attacker = victim
        else:
            attacker = self.getByCidOrJoinPlayer(match.group('acid'))
        ## end fix attacker
          
        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not defined we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    # startgame
    def OnInitgame(self, action, data, match=None):
        self.debug('OnInitgame: %s' % data)
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                #self.debug('%s = %s' % (o[0],o[1]))
                setattr(self.game, o[0], o[1])

        self.verbose('...self.console.game.gameType: %s' % self.game.gameType)
        self.game.startRound()

        self.debug('Synchronizing client info')
        self.clients.sync()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    def OnSayteam(self, action, data, match=None):
        # Teaminfo does not exist in the sayteam logline. Parse it as a normal say line
        return self.OnSay(action, data, match)
    
    
    def OnItem(self, action, data, match=None):
        #Item: 0 pickup_money (5) picked up ($25)
        #Item: 0 weapon_schofield bought ($18/$20)
        #Item: 0 weapon_remington58 (7) picked up
        cid, item = string.split(data, ' ', 1)
        client = self.getByCidOrJoinPlayer(cid)
        if client:
            if 'pickup_money' in item:
                rePickup_money = re.compile(r"^pickup_money \((?P<amount>\d+)\) picked up \(\$(?P<totalmoney>\d+)\)$")
                m = rePickup_money.search(item)
                if m is not None:
                    amount = m.group('amount')
                    totalmoney = m.group('totalmoney')
                    setattr(client, 'money', int(totalmoney))
                    self.verbose('%s has now $%s' % (client.name, client.money))
                    return b3.events.Event(b3.events.EVT_CLIENT_GAIN_MONEY, {'amount': amount, 'totalmoney': totalmoney}, client)
            if 'bought' in item:
                reBought = re.compile(r"^(?P<item>.+) bought \(\$(?P<cost>\d+)/\$(?P<totalmoney>\d+)\)$")
                m = reBought.search(item)
                if m is not None:
                    what = m.group('item')
                    cost = m.group('cost')
                    totalmoney = m.group('totalmoney')
                    if cost is not None and totalmoney is not None:
                        setattr(client, 'money', int(totalmoney) - int(cost))
                        self.verbose('%s has now $%s' % (client.name, client.money))
                        return b3.events.Event(b3.events.EVT_CLIENT_SPEND_MONEY, {'item': what, 'cost': cost, 'totalmoney': client.money}, client)
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, item, client)
        return None
    

    # damage
    #468950: client:0 health:90 damage:21.6 where:arm from:MOD_SCHOFIELD by:2
    def OnDamage(self, action, data, match=None):
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            return None

        attacker = self.clients.getByCID(match.group('acid'))
        if not attacker:
            self.debug('No attacker')
            return None

        event = b3.events.EVT_CLIENT_DAMAGE

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_DAMAGE_SELF
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_DAMAGE_TEAM

        victim.hitloc = match.group('hitloc')
        damagepoints = round(float(match.group('damage')), 1)
        return b3.events.Event(event, (damagepoints, match.group('aweap'), victim.hitloc), attacker, victim)

#---------------------------------------------------------------------------------------------------

    def parseUserInfo(self, info):
        #ClientUserinfoChanged: 0 guid\0F4EE0CC25562B035AC58D081E517D8A\n\Courgette\t\3\model\wq_male1\g_redteam\Lawmen\g_blueteam\Outlaws\hc\100\w\0\l\0\tt\0\tl\0\v\1.1b4 20100116\md5\9F13F403F961CA6900C849D017F9E3E9
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)
        
        
        if data.has_key('cl_guid'):
            data['guid'] = data['cl_guid']
        if data.has_key('guid'):
            data['guid'] = data['guid']
        
        return data


    def getTeam(self, team):
        if team == 'red': team = 1
        if team == 'blue': team = 2
        team = int(team)
        if team == 1:
            #self.verbose('Team is Red')
            return b3.TEAM_RED
        elif team == 2:
            #self.verbose('Team is Blue')
            return b3.TEAM_BLUE
        elif team == 3:
            #self.verbose('Team is Spec')
            return b3.TEAM_SPEC
        else:
            return b3.TEAM_UNKNOWN

    # Translate the gameType to a readable format (also for teamkill plugin!)
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == '0':
            _gameType = 'dm'        # Deathmatch
        elif gameTypeInt == '1':
            _gameType = 'du'        # Duel
        elif gameTypeInt == '3':
            _gameType = 'tdm'       # Team Death Match
        elif gameTypeInt == '4':
            _gameType = 'ts'        # Team Survivor (Round TDM)
        elif gameTypeInt == '5':
            _gameType = 'br'        # Bank Robbery
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    def getMaps(self):
        if self._maplist is not None:
            return self._maplist

        data = self.write('fdir *.bsp')
        if not data:
            return []

        mapregex = re.compile(r'^maps/(?P<map>.+)\.bsp$', re.I)
        maps = []
        for line in data.split('\n'):
            m = re.match(mapregex, line.strip())
            if m:
                if m.group('map'):
                    maps.append(m.group('map'))

        return maps

    def getNextMap(self):
        data = self.write('nextmap')
        nextmap = self.findNextMap(data)
        if nextmap:
            return nextmap
        else:
            return 'no nextmap set or it is in an unrecognized format !'

    def findNextMap(self, data):
        # "nextmap" is: "vstr next4; echo test; vstr aupo3; map oasago2"
        # the last command in the line is the one that decides what is the next map
        # in a case like : map oasago2; echo test; vstr nextmap6; vstr nextmap3
        # the parser will recursively look each last vstr var, and if it can't find a map, fallback to the last map command
        self.debug('Extracting nextmap name from: %s' % (data))
        nextmapregex = re.compile(r'.*("|;)\s*((?P<vstr>vstr (?P<vstrnextmap>[a-z0-9_]+))|(?P<map>map (?P<mapnextmap>[a-z0-9_]+)))', re.IGNORECASE)
        m = re.match(nextmapregex, data)
        if m:
            if m.group('map'):
                self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                return m.group('mapnextmap')
            elif m.group('vstr'):
                self.debug('Nextmap is redirecting to var: %s' % (m.group('vstrnextmap')))
                data = self.write(m.group('vstrnextmap'))
                result = self.findNextMap(data) # recursively dig into the vstr vars to find the last map called
                if result: # if a result was found in a deeper level, then we return it to the upper level, until we get back to the root level
                    return result
                else: # if none could be found, then try to find a map command in the current string
                    nextmapregex = re.compile(r'.*("|;)\s*(?P<map>map (?P<mapnextmap>[a-z0-9_]+))"', re.IGNORECASE)
                    m = re.match(nextmapregex, data)
                    if m.group('map'):
                        self.debug('Found nextmap: %s' % (m.group('mapnextmap')))
                        return m.group('mapnextmap')
                    else: # if none could be found, we go up a level by returning None (remember this is done recursively)
                        self.debug('No nextmap found in this string !')
                        return None
        else:
            self.debug('No nextmap found in this string !')
            return None

    def sync(self):
        plist = self.getPlayerList()
        mlist = {}

        for cid, c in plist.iteritems():
            client = self.getByCidOrJoinPlayer(cid)
            if client:
                if client.guid and c.has_key('guid'):
                    if client.guid == c['guid']:
                        # player matches
                        self.debug('in-sync %s == %s', client.guid, c['guid'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.guid, c['guid'])
                        client.disconnect()
                elif client.ip and c.has_key('ip'):
                    if client.ip == c['ip']:
                        # player matches
                        self.debug('in-sync %s == %s', client.ip, c['ip'])
                        mlist[str(cid)] = client
                    else:
                        self.debug('no-sync %s <> %s', client.ip, c['ip'])
                        client.disconnect()
                else:
                    self.debug('no-sync: no guid or ip found.')
        
        return mlist

    def connectClient(self, ccid):
        if self.PunkBuster:
            self.debug('Getting the (PunkBuster) Playerlist')
        else:
            self.debug('Getting the (status) Playerlist')
        players = self.getPlayerList()
        self.verbose('connectClient() = %s' % players)

        for cid, p in players.iteritems():
            #self.debug('cid: %s, ccid: %s, p: %s' %(cid, ccid, p))
            if int(cid) == int(ccid):
                self.debug('Client found in status/playerList')
                return p
    
    
    def getByCidOrJoinPlayer(self, cid):
        client = self.clients.getByCID(cid)
        if client:
            return client
        else:
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfochanged(None, userinfostring)
            return self.clients.getByCID(cid)
        
        
    def queryClientUserInfoByCid(self, cid):
        """
        : dumpuser 5
        Player 5 is not on the server
        
       : dumpuser 0
        userinfo
        --------
        name                Courgette
        ip                  11.222.111.33
        rate                25000
        snaps               20
        model               wq_male3/red
        handicap            100
        sex                 male
        cg_predictItems     1
        team_model          wq_male1
        cl_voip             1
        cg_cmdTimeNudge     0
        cg_delag            1
        g_blueTeam          Outlaws
        g_redTeam           Lawmen
        team_headmodel      *james
        headmodel           sarge
        teamtask            0
        cl_version          1.1b4 20100116
        cl_md5              9F1646464ADFA64A654A6546546465E9
        sa_engine_check1    7B135FE5ACACACACAAC4656546546543
        cl_guid             0F4E000FFF0FFC00000ACCDE0000FF8A
        ui_singlePlayerActive0
        sa_engine_in_use    1
        teamoverlay         1
        cg_debugDelag       0
        cg_latentSnaps      0
        cg_latentCmds       0
        cg_plOut            0

        """
        data = self.write('dumpuser %s' % cid)
        if not data:
            return None
        
        if data.split('\n')[0] != "userinfo":
            self.debug("dumpuser %s returned : %s" % (cid, data))
            return None

        datatransformed = "%s " % cid
        for line in data.split('\n'):
            if line.strip() == "userinfo" or line.strip() == "--------":
                continue

            var = line[:20].strip()
            val = line[20:].strip()
            datatransformed += "\\%s\\%s" % (var, val)

        return datatransformed

#---- Documentation --------------------------------------------------------------------------------
"""

//infos clienuserinfochanged
//0 = player_ID
//n = name
//t = team
//c = class
//r = rank
//m = medals
//s = skills
//dn = disguised name
//dr = disguised rank
//w = weapon
//lw = weapon last used
//sw = 2nd weapon (not sure)
//mu = muted
//ref = referee
//lw = latched weapon (weapon on next spawn)
//sw = latched secondary weapon (secondary weapon on next spawn)
//p = privilege level (peon = 0, referee (vote), referee (password), semiadmin, rconauth) (etpro only)
//ss = stats restored by stat saver (etpro only)
//sc = shoutcaster status (etpro only)
//tv = ETTV slave (etpro only)

"""
########NEW FILE########
__FILENAME__ = sof2
#
# Soldier of Fortune 2 parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Mark Weirath (xlr8or@xlr8or.com)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG

__author__ = 'xlr8or, ~cGs*Pr3z, ~cGs*AQUARIUS'
__version__ = '1.0.0'

from b3.parsers.q3a.abstractParser import AbstractParser
import re, string
import b3
import b3.events

#----------------------------------------------------------------------------------------------------------------------------------------------
class Sof2Parser(AbstractParser):
    gameName = 'sof2'
    IpsOnly = False
    IpCombi = False
    privateMsg = False
    _empty_name_default = 'EmptyNameDefault'

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _commands = {}
    _commands['message'] = 'say %(prefix)s [^3%(name)s^7]: %(message)s'
    _commands['deadsay'] = 'say %(prefix)s^7 %(message)s'
    _commands['say'] = 'say %(prefix)s^7 %(message)s'

    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'addip %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup': b3.events.EVT_GAME_WARMUP,
        'shutdowngame': b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 ClientUserinfo: 0:

    _lineFormats = (
        #Generated with : SoF2 version: SOF2MP GOLD V1.03 win-x86 Nov  5 2002
        #Kill: 0 0 18: xlr8or killed xlr8or by MOD_SMOHG92_GRENADE
        #Kill: <killer> <victim> <meansofdeath>
        re.compile(
            r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$',
            re.IGNORECASE),

        #hit: 0 0 520 368 0: xlr8or hit xlr8or at location 520 for 368
		#hit: 0 1 8192 80 0: xlr8or hit sh.andrei at location 8192 for 80
        #hit: <acid> <cid> <location> <damage> <meansofdeath>: <aname> hit <name> at location <location> for <damage>
        re.compile(
            r'^(?P<action>[a-z]+):\s(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<hitloc>[0-9]+)\s(?P<damage>[0-9]+)\s(?P<aweap>[0-9]+):\s+(?P<text>.*))$'
            , re.IGNORECASE),

        #say: xlr8or: hello
        re.compile(r'^(?P<action>say):\s*(?P<data>(?P<name>[^:]+):\s*(?P<text>.*))$', re.IGNORECASE),

        #ClientConnect: <cid> - <ip>:<port> [<guid>]
        re.compile(
            r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s-\s(?P<ip>[0-9.]+):(?P<port>[-0-9]+)\s\[(?P<cl_guid>[0-9A-Z]{32})\])$',
            re.IGNORECASE),

        #Bot connecting
        #ClientConnect: 4 -  []
        re.compile(r'^(?P<action>ClientConnect):\s*(?P<data>(?P<bcid>[0-9]+)\s-\s\s\[\])$', re.IGNORECASE),

        #Falling thru?
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>.*)$', re.IGNORECASE)
        )

    #status
    #map: mp_shop
    #num score ping name            lastmsg address               qport rate
    #--- ----- ---- --------------- ------- --------------------- ----- -----
    #  0     0  103 xlr8or               50 145.99.135.000:-2820  64603  9000
    #  1    24  121 ~cGs*Pr3z~      0 178.202.104.000:20100 23805 25000
    #  2    20  108 ~cGs*Jonkie*     50 84.85.84.000:-268      18496 25000
    #  3    18  999 *DS*88  18200 188.157.129.000:20100  29389  9000
    #  4     3    0 Homer~Sexual         50 bot                   54183 16384
    #  7     6    0 Wet~Sponge           50 bot                       0 16384
    #  8     4    0 PaashaasSchaamhaarVerzamelaar     50 bot                       0 16384

    #_regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _regPlayer = re.compile(
        r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$'
        , re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None

    #kill modes (aweap, meansofdeath)
    MOD_UNKNOWN = '0'
    MOD_KNIFE = '1'
    MOD_M1911A1_PISTOL = '2'
    MOD_USSOCOM_PISTOL = '3'
    MOD_SILVER_TALON = '4'
    MOD_M590_SHOTGUN = '5'
    MOD_MICRO_UZI_SUBMACHINEGUN = '6'
    MOD_M3A1_SUBMACHINEGUN = '7'
    MOD_MP5 = '8'
    MOD_USAS_12_SHOTGUN = '9'
    MOD_M4_ASSAULT_RIFLE = '10'
    MOD_AK74_ASSAULT_RIFLE = '11'
    MOD_SIG551 = '12'
    MOD_MSG90A1_SNIPER_RIFLE = '13'
    MOD_M60_MACHINEGUN = '14'
    MOD_MM1_GRENADE_LAUNCHER = '15'
    MOD_RPG7_LAUNCHER = '16'
    MOD_M84_GRENADE = '17'
    MOD_SMOHG92_GRENADE = '18'
    MOD_ANM14_GRENADE = '19'
    MOD_M15_GRENADE = '20'
    MOD_WATER = '21'
    MOD_CRUSH = '22'
    MOD_TELEFRAG = '23'
    MOD_FALLING = '24'
    MOD_SUICIDE = '25'
    MOD_TEAMCHANGE = '26'
    MOD_TARGET_LASER = '27'
    MOD_TRIGGER_HURT = '28'
    MOD_TRIGGER_HURT_NOSUICIDE = '29'
    MOD_ADMIN_STRIKE = '30'
    MOD_ADMIN_SLAP = '31'
    MOD_ADMIN_FRY = '32'
    MOD_ADMIN_EXPLODE = '33'
    MOD_ADMIN_TELEFRAG = '34'
    MOD_KNIFE_ALT = '35'
    MOD_M1911A1_PISTOL_ALT = '36'
    MOD_USSOCOM_PISTOL_ALT = '37'
    MOD_SILVER_TALON_ALT = '38'
    MOD_M590_SHOTGUN_ALT = '39'
    MOD_M4_ASSAULT_RIFLE_ALT = '40'
    MOD_AK74_ASSAULT_RIFLE_ALT = '41'
    MOD_M84_GRENADE_ALT = '42'
    MOD_SMOHG92_GRENADE_ALT = '43'
    MOD_ANM14_GRENADE_ALT = '44'
    MOD_M15_GRENADE_ALT = '45'

    def startup(self):
        # add the world client
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')

        if self.privateMsg:
            self.warning('SoF2 will need a mod to enable private messaging!')

        if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
            self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s' % self.game.mapName)

        # initialize connected clients
        plist = self.getPlayerList()
        for cid, c in plist.iteritems():
            #self.debug(c)
            userinfostring = self.queryClientUserInfoByName(cid, c['name'])
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)


    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return (m, m.group('action').lower(), m.group('data').strip(), client, target)
        else:
            self.verbose('line did not match format: %s' % line)

    def parseUserInfo(self, info):
        #0 \ip\145.99.135.000:-12553\cl_guid\XXXXD914662572D3649B94B1EA5F921\cl_punkbuster\0\details\5\name\xlr8or\rate\9000\snaps\20\identity\NPC_Sam/sam_gladstone\cl_anonymous\0\cg_predictItems\1\cg_antiLag\1\cg_autoReload\1\cg_smoothClients\0\team_identity\shopguard1\outfitting\GACAA
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)

        if data.has_key('cl_guid') and not data.has_key('pbid'):
            data['pbid'] = data['cl_guid']

        return data

    # Need to override message format. Game does not support PM's
    def message(self, client, text):
        try:
            if client == None:
                self.say(text)
            elif client.cid == None:
                pass
            else:
                lines = []
                for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                    lines.append(self.getCommand('message', prefix=self.msgPrefix, name=client.name, message=line))

                self.writelines(lines)
        except:
            pass

    def OnClientconnect(self, action, data, match=None):
        # we get user info in two parts:
        # ClientConnect: 0 - 79.172.5.254:20100 [894E22B3636F8E9198C566C28AD87D0B]
        # ClientUserinfoChanged: 0 n\xlr8or\t\0\identity\NPC_Sam/sam_gladstone
        # we need to store the ClientConnect ID, the guid and IP for the next call to Clientuserinfochanged only on initial connection

        try:
            self._clientConnectID = match.group('cid') # Normal client connected
        except:
            try:
                self._clientConnectID = match.group('bcid') # Game Bot identifier
                self._clientConnectGuid = 'BOT' + str(match.group('bcid'))
                self._clientConnectIp = '0.0.0.0'
                self.bot('Bot Connected')
                return None
            except:
                self.error('Parser could not connect client')
                return None

        try:
            self._clientConnectGuid = match.group('cl_guid') # If we have no cl_guid we'll use the ip instead.
        except:
            self._clientConnectGuid = match.group('ip')

        self._clientConnectIp = match.group('ip')
        self.verbose('Client Connected cid: %s, guid: %s, ip: %s' % (
            self._clientConnectID, self._clientConnectGuid, self._clientConnectIp))

    # Parse Userinfo
    # Only called when bot is starting on a populated server
    def OnClientuserinfo(self, action, data, match=None):
        #0 \ip\145.99.135.000:-12553\cl_guid\XXXXD914662572D3649B94B1EA5F921\cl_punkbuster\0\details\5\name\xlr8or\rate\9000\snaps\20\identity\NPC_Sam/sam_gladstone\cl_anonymous\0\cg_predictItems\1\cg_antiLag\1\cg_autoReload\1\cg_smoothClients\0\team_identity\shopguard1\outfitting\GACAA
        bclient = self.parseUserInfo(data)

        if bclient.has_key('name'):
            # remove spaces from name
            bclient['name'] = bclient['name'].replace(' ','')

        # split port from ip field
        if bclient.has_key('ip'):
            if bclient['ip'] == 'bot':
                #not sure if this one works...
                self.bot('Bot Connected!')
                bclient['ip'] = '0.0.0.0'
                bclient['cl_guid'] = 'BOT' + str(bclient['cid'])
            else:
                ipPortData = string.split(bclient['ip'], ':', 1)
                bclient['ip'] = ipPortData[0]
                if len(ipPortData) > 1:
                    bclient['port'] = ipPortData[1]

        if bclient.has_key('team'):
            bclient['team'] = self.getTeam(bclient['team'])

        if bclient.has_key('cl_guid') and not bclient.has_key('pbid') and self.PunkBuster:
            bclient['pbid'] = bclient['cl_guid']

        self.verbose('Parsed user info %s' % bclient)

        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                #make a new client
                if self.PunkBuster:
                    # we will use punkbuster's guid
                    guid = None
                else:
                    # use io guid
                    if bclient.has_key('cl_guid'):
                        guid = bclient['cl_guid']
                    else:
                        guid = 'unknown'

                if not bclient.has_key('name'):
                    bclient['name'] = self._empty_name_default

                if not bclient.has_key('ip') and guid == 'unknown':
                    # happens when a client is (temp)banned and got kicked so client was destroyed, but
                    # infoline was still waiting to be parsed.
                    self.debug('Client disconnected. Ignoring.')
                    return None

                nguid = ''
                # overide the guid... use ip's only if self.console.IpsOnly is set True.
                if self.IpsOnly:
                    nguid = bclient['ip']
                # replace last part of the guid with two segments of the ip
                elif self.IpCombi:
                    i = bclient['ip'].split('.')
                    d = len(i[0])+len(i[1])
                    nguid = guid[:-d]+i[0]+i[1]
                # Some Quake clients don't have a cl_guid, we'll use ip instead, this is pure fallback!
                elif guid == 'unknown':
                    nguid = bclient['ip']

                if nguid != '':
                    guid = nguid

                client = self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=guid, data={ 'guid' : guid })

        return None

    def OnClientuserinfochanged(self, action, data, match=None):
        #ClientUserinfoChanged: 0 n\xlr8or\t\0\identity\NPC_Sam/sam_gladstone
        try:
            id = self._clientConnectID
        except:
            id = None # We've already connected before

        self._clientConnectID = None

        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if id:
                bclient['cl_guid'] = self._clientConnectGuid
                self._clientConnectGuid = None
                bclient['ip'] = self._clientConnectIp
                self._clientConnectIp = None

            if client:
                # update existing client
                bclient['cl_guid'] = client.guid
                bclient['ip'] = client.ip
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                #make a new client
                client = self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'],
                                                state=b3.STATE_ALIVE, guid=bclient['cl_guid'],
                                                data={'guid': bclient['cl_guid']})

        if id:
            return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)
        else:
            return None

    # disconnect
    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('Current gameType: %s' % self.game.gameType)
        self.game.startRound()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    # say
    def OnSay(self, action, data, match=None):
        #3:59 say: XLR8or: general chat
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByExactName(msg[0])

        if client:
            self.verbose('OnSay: Client Found: %s' % client.name)
            return b3.events.Event(b3.events.EVT_CLIENT_SAY, msg[1], client)
        else:
            self.verbose('OnSay: No Client Found!')
            return None

    # sayteam
    def OnSayteam(self, action, data, match=None):
        #4:06 sayteam: XLR8or: teamchat
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByExactName(msg[0])

        if client:
            self.verbose('OnSayTeam: Client Found: %s' % client.name)
            return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, msg[1], client, client.team)
        else:
            self.verbose('OnSayTeam: No Client Found!')
            return None

    # damage
    #hit: 0 0 520 368 0: xlr8or hit xlr8or at location 520 for 368
    #Hit: cid acid hitloc damage aweap: text
    def OnHit(self, action, data, match=None):
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        attacker = self.clients.getByCID(match.group('acid'))
        if not attacker:
            self.debug('No attacker')
            return None

        event = b3.events.EVT_CLIENT_DAMAGE

        if attacker.cid == victim.cid:
            event = b3.events.EVT_CLIENT_DAMAGE_SELF
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_DAMAGE_TEAM

        victim.hitloc = match.group('hitloc')
        #victim.state = b3.STATE_ALIVE
        return b3.events.Event(event, (match.group('damage'), match.group('aweap'), victim.hitloc), attacker, victim)

    # kill
    #kill: acid cid aweap: <text>
    def OnKill(self, action, data, match=None):
        # kill modes characteristics :
        """
        0:	MOD_UNKNOWN, UNKNOWN
        1:	MOD_KNIFE, Killed by KNIFE
        2:	MOD_M1911A1_PISTOL, Killed by M1911A1_PISTOL
        3:	MOD_USSOCOM_PISTOL, Killed by USSOCOM_PISTOL
        4:	MOD_SILVER_TALON, Killed by SILVER_TALON
        5:	MOD_M590_SHOTGUN, Killed by M590_SHOTGUN
        6:	MOD_MICRO_UZI_SUBMACHINEGUN, Killed by MICRO_UZI_SUBMACHINEGUN
        7:	MOD_M3A1_SUBMACHINEGUN, Killed by M3A1_SUBMACHINEGUN
        8:	MOD_MP5, Killed by MP5
        9:	MOD_USAS_12_SHOTGUN, Killed by USAS_12_SHOTGUN
        10:	MOD_M4_ASSAULT_RIFLE, Killed by M4_ASSAULT_RIFLE
        11:	MOD_AK74_ASSAULT_RIFLE, Killed by AK74_ASSAULT_RIFLE
        12:	MOD_SIG551, Killed by SIG551
        13:	MOD_MSG90A1_SNIPER_RIFLE, Killed by MSG90A1_SNIPER_RIFLE
        14:	MOD_M60_MACHINEGUN, Killed by M60_MACHINEGUN
        15:	MOD_MM1_GRENADE_LAUNCHER, Killed by MM1_GRENADE_LAUNCHER
        16:	MOD_RPG7_LAUNCHER, Killed by RPG7_LAUNCHER
        17:	MOD_M84_GRENADE, Killed by M84_GRENADE
        18:	MOD_SMOHG92_GRENADE, Killed by SMOHG92_GRENADE
        19:	MOD_ANM14_GRENADE, Killed by ANM14_GRENADE
        20:	MOD_M15_GRENADE, Killed by M15_GRENADE
        21:	MOD_WATER, Killed by WATER
        22:	MOD_CRUSH, Killed by Mover
        23:	MOD_TELEFRAG, Killed by TELEFRAG
        24:	MOD_FALLING, Killed by FALLING
        25:	MOD_SUICIDE, Killed by SUICIDE
        26:	MOD_TEAMCHANGE, Killed by TEAMCHANGE
        27:	MOD_TARGET_LASER, Killed by TARGET_LASER
        28:	MOD_TRIGGER_HURT, Killed by TRIGGER_HURT
        29:	MOD_TRIGGER_HURT_NOSUICIDE, Killed by TRIGGER_HURT_NOSUICIDE
        30:	MOD_ADMIN_STRIKE, Killed by ADMIN_STRIKE
        31:	MOD_ADMIN_SLAP, Killed by ADMIN_SLAP
        32:	MOD_ADMIN_FRY, Killed by ADMIN_FRY
        33:	MOD_ADMIN_EXPLODE, Killed by ADMIN_EXPLODE
        34:	MOD_ADMIN_TELEFRAG, Killed by ADMIN_TELEFRAG
        35:	MOD_KNIFE_ALT, Killed by KNIFE_ALT
        36:	MOD_M1911A1_PISTOL_ALT, Killed by M1911A1_PISTOL_ALT
        37:	MOD_USSOCOM_PISTOL_ALT, Killed by USSOCOM_PISTOL_ALT
        38:	MOD_SILVER_TALON_ALT, Killed by SILVER_TALON_ALT
        39:	MOD_M590_SHOTGUN_ALT, Killed by M590_SHOTGUN_ALT
        40:	MOD_M4_ASSAULT_RIFLE_ALT, Killed by M4_ASSAULT_RIFLE_ALT
        41:	MOD_AK74_ASSAULT_RIFLE, Killed by AK74_ASSAULT_RIFLE
        42:	MOD_M84_GRENADE_ALT, Killed by M84_GRENADE_ALT
        43:	MOD_SMOHG92_GRENADE_ALT, Killed by SMOHG92_GRENADE_ALT
        44:	MOD_ANM14_GRENADE_ALT, Killed by ANM14_GRENADE_ALT
        45:	MOD_M15_GRENADE_ALT, Killed by M15_GRENADE_ALT
        """
        self.debug('OnKill: %s (%s)' % (match.group('aweap'), match.group('text')))

        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in (
            self.MOD_MM1_GRENADE_LAUNCHER, self.MOD_RPG7_LAUNCHER, self.MOD_M84_GRENADE, self.MOD_SMOHG92_GRENADE,
            self.MOD_ANM14_GRENADE, self.MOD_M15_GRENADE, self.MOD_WATER, self.MOD_FALLING, self.MOD_SUICIDE,
            self.MOD_TRIGGER_HURT, self.MOD_M4_ASSAULT_RIFLE_ALT, self.MOD_M84_GRENADE_ALT, self.MOD_SMOHG92_GRENADE_ALT
            , self.MOD_ANM14_GRENADE_ALT, self.MOD_M15_GRENADE_ALT):
            # those kills should be considered suicides
            self.debug(
                'OnKill: mm1_grenade_launcher/rpg7_launcher/m84_grenade/smohg92_grenade/anm14/m15_grenade/water/suicide/trigger_hurt/m4_assault_rifle_alt/m84_grenade_alt/smohg92_grenade_alt/anm14_alt/m15_grenade_alt should be suicides')
            attacker = victim
        else:
            attacker = self.clients.getByCID(match.group('acid'))
            ## end fix attacker

        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            if weapon == self.MOD_TEAMCHANGE:
                """
                Do not pass a teamchange event here. That event is passed
                shortly after the kill.
                """
                self.verbose('Team Change Event Caught, exiting')
                return None
            else:
                event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not logging damage we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'

        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    # item
    def OnItem(self, action, data, match=None):
        #Item: 5 weapon_betty
        cid, item = string.split(data, ' ', 1)
        client = self.clients.getByCID(cid)
        if client:
            #self.verbose('OnItem: %s picked up %s' % (client.name, item) )
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, item, client)
        return None

    # Translate the gameType to a readable format
    def defineGameType(self, gameTypeInt):
        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)

        if gameTypeInt == '0':
            _gameType = 'ass'
        elif gameTypeInt == '1':
            _gameType = 'cnh'
        elif gameTypeInt == '2':
            _gameType = 'ctb'
        elif gameTypeInt == '3':
            _gameType = 'cctf'
        elif gameTypeInt == '4':
            _gameType = 'ctf'
        elif gameTypeInt == '5':
            _gameType = 'dem'
        elif gameTypeInt == '6':
            _gameType = 'dm'
        elif gameTypeInt == '7':
            _gameType = 'dom'
        elif gameTypeInt == '8':
            _gameType = 'elim'
        elif gameTypeInt == '9':
            _gameType = 'gold'
        elif gameTypeInt == '10':
            _gameType = 'inf'
        elif gameTypeInt == '11':
            _gameType = 'knockback'
        elif gameTypeInt == '12':
            _gameType = 'lms'
        elif gameTypeInt == '13':
            _gameType = 'rctf'
        elif gameTypeInt == '14':
            _gameType = 'stq'
        elif gameTypeInt == '15':
            _gameType = 'tctb'
        elif gameTypeInt == '16':
            _gameType = 'tdm'
        elif gameTypeInt == '17':
            _gameType = 'tstq'

        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    def joinPlayers(self):
        plist = self.getPlayerList()

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                self.debug('Joining %s' % client.name)
                self.queueEvent(b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client))

        return None

    def queryClientUserInfoByName(self, cid, name):
        """
        ]\dumpuser xlr8or
        Player xlr8or is not on the server

        ]\dumpuser xlr8or
        userinfo
        --------
        ip                  145.99.135.000:-12892
        cl_guid             XXXXD914662572D3649B94B1EA5F921
        cl_punkbuster       0
        details             5
        name                xlr8or
        rate                9000
        snaps               20
        identity            NPC_Sam/sam_gladstone
        cl_anonymous        0
        cg_predictItems     1
        cg_antiLag          1
        cg_autoReload       1
        cg_smoothClients    0
        team_identity       shopguard1
        outfitting          GACAA

        """
        data = self.write('dumpuser %s' % name)
        if not data:
            return None

        if data.split('\n')[0] != "userinfo":
            self.debug("dumpuser %s returned : %s" % (name, data))
            self.debug('client probably disconnected, but its character is still hanging in game...')
            return None

        datatransformed = "%s " % cid
        for line in data.split('\n'):
            if line.strip() == "userinfo" or line.strip() == "--------":
                continue

            var = line[:20].strip()
            val = line[20:].strip()
            datatransformed += "\\%s\\%s" % (var, val)

        #self.debug(datatransformed)
        return datatransformed

    def getByNameOrJoinPlayer(self, name):
        client = self.clients.getByExactName(name)
        if client:
            return client
        else:
            userinfostring = self.queryClientUserInfoByName(name)
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)
            return self.clients.getByExactName(name)




#HL_FOOT_RT
#HL_FOOT_LT
#HL_LEG_LOWER_RT
#HL_LEG_LOWER_LT
#HL_LEG_UPPER_RT
#HL_LEG_UPPER_LT
#HL_ARM_RT
#HL_ARM_LT
#HL_HAND_RT
#HL_HAND_LT
#HL_HEAD
#HL_NECK
#HL_WAIST
#HL_BACK
#HL_BACK_RT
#HL_BACK_LT
#HL_CHEST
#HL_CHEST_RT
#HL_CHEST_LT

#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (256, 'right arm');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (32768, 'right chest');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (0, 'Undetected Hits');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (1024, 'Head');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (4, 'upper right Leg');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (8, 'upper left Leg');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (16, 'lower right Leg');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (32, 'lower left Leg');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (262144, 'Neck');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (1, 'right Foot');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (2, 'left Foot');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (512, 'left lower hand');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (128, 'left hand');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (2048, 'Waist');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (131072, 'Chest');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (64, 'right hand');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (4096, 'back right');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (8192, 'back left');
#INSERT INTO `stats_hitlocations` (`ID`, `BODYPART`) VALUES (16384, 'back');

########NEW FILE########
__FILENAME__ = sof2pm
#
# Soldier of Fortune 2 parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Mark Weirath (xlr8or@xlr8or.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG

__author__ = 'xlr8or, ~cGs*Pr3z, ~cGs*AQUARIUS'
__version__ = '1.0.0'

from b3.parsers.sof2 import Sof2Parser

#----------------------------------------------------------------------------------------------------------------------------------------------
class Sof2PmParser(Sof2Parser):
    gameName = 'sof2pm'
    privateMsg = True

    _commands = {}
    _commands['message'] = 'tell %(cid)s %(prefix)s ^3[pm]^7 %(message)s'
    _commands['deadsay'] = 'say %(prefix)s^7 %(message)s'
    _commands['say'] = 'say %(prefix)s^7 %(message)s'

    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'addip %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    def message(self, client, text):
        try:
            if client == None:
                self.say(text)
            elif client.cid == None:
                pass
            else:
                lines = []
                for line in self.getWrap(text, self._settings['line_length'], self._settings['min_wrap_length']):
                    lines.append(self.getCommand('message', cid=client.cid, prefix=self.msgPrefix, message=line))

                self.writelines(lines)
        except:
            pass


########NEW FILE########
__FILENAME__ = rcon
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 <courgette@bigbrotherbot.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 1.1
# - patch SourceRcon to detect bad rcon password with CS:GO
# - can send unicode commands
# 1.2
# - fix write() method that failed when called with named parameter 'maxRetries'
#
from threading import Event, Lock
from socket import timeout
from Queue import Queue
from b3.lib.sourcelib.SourceRcon import SourceRcon, SERVERDATA_EXECCOMMAND, SERVERDATA_AUTH, SourceRconError

__version__ = '1.2'
__author__ = 'Courgette'



#####################################################################################################
# patch SourceRcon.receive class to detect bad rcon password

legacy_receive = SourceRcon.receive

def receive_wrapper(self):
    rv = legacy_receive(self)
    if isinstance(rv, basestring) and rv.strip().endswith(": Bad Password"):
        raise SourceRconError('Bad RCON password (patched SourceRcon)')
    else:
        return rv

SourceRcon.receive = receive_wrapper

#####################################################################################################



class Rcon(object):
    """
    Facade to expose the SourceRcon class with an API as expected by B3 parsers
    """
    lock = Lock()

    def __init__(self, console, host, password):
        self.console = console
        self.host, self.port = host
        self.password = password
        self.timeout = 1.0
        self.queue = Queue()
        self.stop_event = Event()
        self.server = SourceRcon(self.host, self.port, self.password, self.timeout)

        self.console.info("RCON: connecting to Source game server")
        try:
            self.server.connect()
        except timeout, err:
            self.console.error("RCON: timeout error while trying to connect to game server at %s:%s. "
                               "Make sure the rcon_ip and port are correct and that the game server is "
                               "running" % (self.host, self.port))


    ########################################################
    #
    #   expected B3 Rcon API
    #
    ########################################################

    def writelines(self, lines):
        """
        Sends multiple rcon commands and do not wait for responses (non blocking)
        """
        self.queue.put(lines)


    def write(self, cmd, *args, **kwargs):
        """
        Sends a rcon command and return the response (blocking until timeout)
        """
        with Rcon.lock:
            try:
                self.console.info("RCON SEND: %s" % cmd)
                raw_data = self.server.rcon(self.encode_data(cmd))
                if raw_data:
                    data = raw_data.decode('UTF-8', 'replace')
                    self.console.info("RCON RECEIVED: %s" % data)
                    return data
            except timeout:
                self.console.error("RCON: timeout error while trying to connect to game server at %s:%s. "
                                   "Make sure the rcon_ip and port are correct and that the game server is "
                                   "running" % (self.host, self.port))


    def flush(self):
        pass


    def close(self):
        if self.server:
            try:
                self.console.info("RCON disconnecting from Source game server")
                self.server.disconnect()
                self.console.verbose("RCON disconnected from Source game server")
            finally:
                self.server = None
                del self.server


    ########################################################
    #
    #   others
    #
    ########################################################

    def _writelines(self):
        while not self.stop_event.isSet():
            lines = self.queue.get(True)
            for cmd in lines:
                if not cmd:
                    continue
                with self.lock:
                    self.rconNoWait(cmd)


    def rconNoWait(self, cmd):
        """
        send a single command, do not wait for any response.
        connect and auth if necessary.
        """
        try:
            self.console.info("RCON SEND: %s" % cmd)
            self.server.send(SERVERDATA_EXECCOMMAND, self.encode_data(cmd))
        except Exception:
            # timeout? invalid? we don't care. try one more time.
            self.server.disconnect()
            self.server.connect()
            self.server.send(SERVERDATA_AUTH, self.password)

            auth = self.server.receive()
            # the first packet may be a "you have been banned" or empty string.
            # in the latter case, fetch the second packet
            if auth == '':
                auth = self.server.receive()

            if auth is not True:
                self.server.disconnect()
                raise SourceRconError('RCON authentication failure: %s' % (repr(auth),))

            self.server.send(SERVERDATA_EXECCOMMAND, self.encode_data(cmd))


    def encode_data(self, data):
        if not data:
            return data
        if type(data) is unicode:
            return data.encode('UTF-8')
        else:
            return data


if __name__ == '__main__':
    '''
    To run tests : python b3/parsers/source/rcon.py <rcon_ip> <rcon_port> <rcon_password>
    '''
    import sys, os, time

    host = port = pw = None

    from ConfigParser import SafeConfigParser
    test_config_file = os.path.join(os.path.dirname(__file__), 'test_rcon.ini')
    if os.path.isfile(test_config_file):
        try:
            conf = SafeConfigParser()
            conf.read(test_config_file)
            host = conf.get("server", "host")
            port = int(conf.get("server", "port"))
            pw = conf.get("server", "password")
        except:
            pass

    if not host and not port and not pw:
        if len(sys.argv) != 4:
            host = raw_input('Enter game server host IP/name: ')
            port = int(raw_input('Enter host port: '))
            pw = raw_input('Enter password: ')
        else:
            host = sys.argv[1]
            port = int(sys.argv[2])
            pw = sys.argv[3]

    with open(test_config_file, "w") as f:
        conf = SafeConfigParser()
        conf.add_section('server')
        conf.set("server", "host", host)
        conf.set("server", "port", str(port))
        conf.set("server", "password", pw)
        conf.write(f)

    from b3.fake import fakeConsole

    r = Rcon(fakeConsole, (host, port), pw)
    r.write('sm_say %s' % u"hello test")

########NEW FILE########
__FILENAME__ = wop
#
# World of Padman parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2008 Mark Weirath (xlr8or@xlr8or.com)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 11/30/2008: 1.0.1: OnKill, kill modes and XLRstats compatibility 
# 31/01/2010 - 1.0.2 - Courgette
# * getMap() is now inherited from q3a
# 09/04/2011 - 1.0.3 - Courgette
# * reflect that cid are not converted to int anymore in the clients module

__author__  = 'xlr8or'
__version__ = '1.0.3'

from b3.parsers.q3a.abstractParser import AbstractParser
import re, string
import b3
import b3.events

#----------------------------------------------------------------------------------------------------------------------------------------------
class WopParser(AbstractParser):
    gameName = 'wop'
    privateMsg = False

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _commands = {}
    _commands['message'] = '%(prefix)s^7 %(message)s'
    _commands['deadsay'] = '%(prefix)s [DEAD]^7 %(message)s'
    _commands['say'] = 'say %(prefix)s^7 %(message)s'

    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'addip %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'

    _eventMap = {
        'warmup' : b3.events.EVT_GAME_WARMUP,
        'shutdowngame' : b3.events.EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 ClientUserinfo: 0:

    _lineFormats = (
        #Generated with : WOP version 1.2
        #ClientConnect: 2 77F303414E4355E0860B483F2A07E4DF 151.16.71.226:27960
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<cl_guid>[0-9A-Z]{32})\s+(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        #Kill: 3 2 8: Beinchen killed linux suse 10.3 by MOD_PLASMA
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<cid>[0-9]+)\s(?P<aweap>[0-9]+):\s*(?P<text>.*))$', re.IGNORECASE),
        #ClientConnect: 2  151.16.71.226:27960
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9]+))$', re.IGNORECASE),
        #say: ^3Ghost^2Pirate: Saw red huh?
        re.compile(r'^(?P<action>say):\s*(?P<data>(?P<name>[^:]+):\s*(?P<text>.*))$', re.IGNORECASE),
        #Bot connecting
        #ClientConnect: 0
        re.compile(r'^(?P<action>ClientConnect):\s*(?P<data>(?P<bcid>[0-9]+))$', re.IGNORECASE),
        #Falling thru? Item stuff and so forth... still need some other actions from CTF and other gametypes to compare.  
        #Item: 3 ammo_spray_n
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>.*)$', re.IGNORECASE)
    )
    
    #status
    #map: wop_huette
    #num score ping name            lastmsg address               qport rate
    #--- ----- ---- --------------- ------- --------------------- ----- -----
    #  1    34    0 ^1B^2io^1P^2ad^7      100 bot                       0 16384
    #  2    29    0 ^5Pad^1Lilly^7         50 bot                      53 16384
    #  3     5  103 PadPlayer^7             0 77.41.107.169:27960   47612  5000
    #  4   154   50 WARR^7                 50 91.127.64.194:27960   39880 25000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+):(?P<port>[0-9-]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)
    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None

    #kill modes
    MOD_UNKNOWN='0'
    MOD_SHOTGUN='1'
    MOD_GAUNTLET='2'
    MOD_MACHINEGUN='3'
    MOD_GRENADE='4'
    MOD_GRENADE_SPLASH='5'
    MOD_ROCKET='6'
    MOD_ROCKET_SPLASH='7'
    MOD_PLASMA='8'
    MOD_PLASMA_SPLASH='9'
    MOD_RAILGUN='10'
    MOD_LIGHTNING='11'
    MOD_BFG='12'
    MOD_BFG_SPLASH='13'
    MOD_KILLERDUCKS='14'
    MOD_WATER='15'
    MOD_SLIME='16'
    MOD_LAVA='17'
    MOD_CRUSH='18'
    MOD_TELEFRAG='19'
    MOD_FALLING='20' # not used in wop
    MOD_SUICIDE='21'
    MOD_TARGET_LASER='22' # not used in wop
    MOD_TRIGGER_HURT='23'
    MOD_GRAPPLE='24' # not used in wop


    def startup(self):
        # add the world client
        client = self.clients.newClient('-1', guid='WORLD', name='World', hide=True, pbid='WORLD')

        if not self.config.has_option('server', 'punkbuster') or self.config.getboolean('server', 'punkbuster'):
            self.PunkBuster = b3.parsers.punkbuster.PunkBuster(self)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)

    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return (m, m.group('action').lower(), m.group('data').strip(), client, target)
        else:
            self.verbose('line did not match format: %s' % line)

    def parseUserInfo(self, info):
        #3 n\Dr.Schraube\t\0\model\padman/padsoldier_red\hmodel\padman/padsoldier_red\c1\4\c2\1\hc\100\w\0\l\0\tt\0\tl\0\sl\
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)

        if data.has_key('cl_guid') and not data.has_key('pbid'):
            data['pbid'] = data['cl_guid']

        return data

    def OnClientconnect(self, action, data, match=None):
        # we get user info in two parts:
        # ClientConnect: 2 77F303414E4355E0860B483F2A07E4DF 151.16.71.226:27960
        # ClientUserinfoChanged: 2 n\^3Ghost^2Pirate\t\0\model\piratpad/ghostpirate_red\hmodel\piratpad/ghostpirate_red\c1\4\c2\0\hc\70\w\0\l\0\skill\    2.00\tt\0\tl\0\sl\
        # we need to store the ClientConnect ID, the guid and IP for the next call to Clientuserinfochanged only on initial connection

        try:
            self._clientConnectID = match.group('cid') # Normal client connected
        except:
            try:
                self._clientConnectID = match.group('bcid') # Game Bot identifier
                self._clientConnectGuid = 'BOT' + str(match.group('bcid'))
                self._clientConnectIp = '0.0.0.0'
                self.bot('Bot Connected')
                return None
            except:
                self.error('Parser could not connect client')
                return None

        try:
            self._clientConnectGuid = match.group('cl_guid') # If we have no cl_guid we'll use the ip instead.
        except:
            self._clientConnectGuid = match.group('ip')

        self._clientConnectIp = match.group('ip')
        self.verbose('Client Connected cid: %s, guid: %s, ip: %s' % (self._clientConnectID, self._clientConnectGuid, self._clientConnectIp))

    def OnClientuserinfochanged(self, action, data, match=None):
        try:
            id = self._clientConnectID
        except:
            id = None # We've already connected before

        self._clientConnectID = None

        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if id:
                bclient['cl_guid'] = self._clientConnectGuid
                self._clientConnectGuid = None
                bclient['ip'] = self._clientConnectIp
                self._clientConnectIp = None
            
            if client:
                # update existing client
                bclient['cl_guid'] = client.guid 
                bclient['ip'] = client.ip
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                #make a new client
                client = self.clients.newClient(bclient['cid'], name=bclient['name'], ip=bclient['ip'], state=b3.STATE_ALIVE, guid=bclient['cl_guid'], data={ 'guid' : bclient['cl_guid'] })

        if id:
            return b3.events.Event(b3.events.EVT_CLIENT_JOIN, None, client)
        else:
            return None

    # disconnect
    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('Current gameType: %s' % self.game.gameType)
        self.game.startRound()

        return b3.events.Event(b3.events.EVT_GAME_ROUND_START, self.game)

    # say
    def OnSay(self, action, data, match=None):
        #3:59 say: XLR8or: general chat
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByExactName(msg[0])

        if client:
            self.verbose('Client Found: %s' % client.name)
            return b3.events.Event(b3.events.EVT_CLIENT_SAY, msg[1], client)
        else:
            self.verbose('No Client Found!')
            return None

    # sayteam
    def OnSayteam(self, action, data, match=None):
        #4:06 sayteam: XLR8or: teamchat
        msg = string.split(data, ': ', 1)
        if not len(msg) == 2:
            return None

        client = self.clients.getByExactName(msg[0])

        if client:
            self.verbose('Client Found: %s' % client.name)
            return b3.events.Event(b3.events.EVT_CLIENT_TEAM_SAY, msg[1], client, client.team)
        else:
            self.verbose('No Client Found!')
            return None

    # kill
    #kill: acid cid aweap: <text>
    def OnKill(self, action, data, match=None):
        # kill modes caracteristics :
        """
         0:   MOD_UNKNOWN, Unknown Means od Death, shouldn't occur at all
         1:   MOD_SHOTGUN, Pumper
         2:   MOD_GAUNTLET, Punchy
         3:   MOD_MACHINEGUN, Nipper
         4:   MOD_GRENADE, Balloony
         5:   MOD_GRENADE_SPLASH, Ballony Splashdamage
         6:   MOD_ROCKET, Betty
         7:   MOD_ROCKET_SPLASH, Betty Splashdamage
         8:   MOD_PLASMA, BubbleG
         9:   MOD_PLASMA_SPLASH, BubbleG Splashdamage
        10:   MOD_RAILGUN, Splasher
        11:   MOD_LIGHTNING, Boaster
        12:   MOD_BFG, Imperius
        13:   MOD_BFG_SPLASH, Imperius Splashdamage
        14:   MOD_KILLERDUCKS, Killerducks
        15:   MOD_WATER, Died in Water
        16:   MOD_SLIME, Died in Slime
        17:   MOD_LAVA, Died in Lava
        18:   MOD_CRUSH, Killed by a Mover
        19:   MOD_TELEFRAG, Killed by a Telefrag
        20:   MOD_FALLING, Died due to falling damage, but there is no falling damage in WoP
        21:   MOD_SUICIDE, Commited Suicide
        22:   MOD_TARGET_LASER, Killed by a laser, which don't exist in WoP
        23:   MOD_TRIGGER_HURT, Killed by a trigger_hurt
        24:   MOD_GRAPPLE, Killed by grapple, not used in WoP
        """
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('text')))
        
        victim = self.clients.getByCID(match.group('cid'))
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        ## Fix attacker
        if match.group('aweap') in (self.MOD_WATER,self.MOD_LAVA,self.MOD_FALLING,self.MOD_TRIGGER_HURT,):
            # those kills should be considered suicides
            self.debug('OnKill: water/lava/falling/trigger_hurt should be suicides')
            attacker = victim
        else:
            attacker = self.clients.getByCID(match.group('acid'))
        ## end fix attacker
          
        if not attacker:
            self.debug('No attacker')
            return None

        dType = match.group('text').split()[-1:][0]
        if not dType:
            self.debug('No damageType, weapon: %s' % weapon)
            return None

        event = b3.events.EVT_CLIENT_KILL

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            if weapon == self.MOD_CHANGE_TEAM:
                """
                Do not pass a teamchange event here. That event is passed
                shortly after the kill.
                """
                self.verbose('Team Change Event Caught, exiting')
                return None
            else:
                event = b3.events.EVT_CLIENT_SUICIDE
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team:
            event = b3.events.EVT_CLIENT_KILL_TEAM

        # if not logging damage we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return b3.events.Event(event, (100, weapon, victim.hitloc, dType), attacker, victim)

    # item
    def OnItem(self, action, data, match=None):
        #Item: 5 weapon_betty
        cid, item = string.split(data, ' ', 1)
        client = self.clients.getByCID(cid)
        if client:
            #self.verbose('OnItem: %s picked up %s' % (client.name, item) )
            return b3.events.Event(b3.events.EVT_CLIENT_ITEM_PICKUP, item, client)
        return None

    # Translate the gameType to a readable format
    # //WoP gametypes: 0=FFA / 1=1v1 / 2=SP / 3=SYC-FFA / 4=LPS / 5=TDM / 6=CTL / 7=SYC-TP / 8=BB
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        _gameType = str(gameTypeInt)
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == '0':
            _gameType = 'dm'
        elif gameTypeInt == '1':
            _gameType = 'lvl'
        elif gameTypeInt == '2':
            _gameType = 'sp'
        elif gameTypeInt == '3':
            _gameType = 'syc-ffa'
        elif gameTypeInt == '4':
            _gameType = 'lps'
        elif gameTypeInt == '5':
            _gameType = 'tdm'
        elif gameTypeInt == '6':
            _gameType = 'ctl'
        elif gameTypeInt == '7':
            _gameType = 'syc-tp'
        elif gameTypeInt == '8':
            _gameType = 'bb'
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType


########NEW FILE########
__FILENAME__ = wop15
#
# World of Padman parser for BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2008 Mark Weirath (xlr8or@xlr8or.com)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
# 2011-04-04 - 1.1.0 - Courgette
#  * remove inheritence from WopParser
#  * made changes introduced with Wop 1.5.2 beta
#  * auth() players at parser startup, making use of the dumpuser command
# 2011-04-07 - 1.2.0 - Courgette
#  * change rcon ban command to 'banaddr'
#  * remove attacker fixes for special death
#  * add EVT_CLIENT_PRIVATE_SAY
#  * ENTITYNUM_WORLD : now a known 'client' in B3
#  * don't fire teamkills/teamdamage events in gametypes with no teams (see TEAM_BASED_GAMETYPES)
#  * add a DEBUG_EVENT flag
#  * do not provides fake guid for bot, so they won't autheticate and won't make it to database
# 2011-04-07 - 1.2.1 - Courgette
#  * fix TEAM_BASED_GAMETYPES
# 2011-04-07 - 1.2.2 - Courgette
#  * fix Tell regexp when cid is -1
#  * reflect that cid are not converted to int anymore in the clients module
#  * do not try to fix attacket in OnKill
#  * fix MOD_SHOTGUN -> MOD_PUMPER
# 2011-04-10 - 1.2.3 - Courgette
#  * fix commands that should use quotation marks


__author__  = 'xlr8or, Courgette'
__version__ = '1.2.3'

from b3.parsers.q3a.abstractParser import AbstractParser
import re, string
import b3
import b3.events
from b3.events import EVT_GAME_WARMUP, EVT_GAME_ROUND_END

DEBUG_EVENTS=False

#kill modes
MOD_UNKNOWN='0'
MOD_PUMPER='1'
MOD_GAUNTLET='2'
MOD_MACHINEGUN='3'
MOD_GRENADE='4'
MOD_GRENADE_SPLASH='5'
MOD_ROCKET='6'
MOD_ROCKET_SPLASH='7'
MOD_PLASMA='8'
MOD_PLASMA_SPLASH='9'
MOD_RAILGUN='10'
MOD_LIGHTNING='11'
MOD_BFG='12'
MOD_BFG_SPLASH='13'
MOD_KILLERDUCKS='14'
MOD_WATER='15'
MOD_SLIME='16'
MOD_LAVA='17'
MOD_CRUSH='18'
MOD_TELEFRAG='19'
MOD_FALLING='20' # not used in wop
MOD_SUICIDE='21'
MOD_TARGET_LASER='22' # not used in wop
MOD_TRIGGER_HURT='23'
MOD_GRAPPLE='24' # not used in wop

# game types
GAMETYPE_FFA = '0'
GAMETYPE_1VS1 = '1'
GAMETYPE_SP = '2'
GAMETYPE_SYC = '3'
GAMETYPE_LPS = '4'
GAMETYPE_TFFA = '5'
GAMETYPE_CTL = '6'
GAMETYPE_TSYC = '7'
GAMETYPE_BB = '8'

TEAM_BASED_GAMETYPES = (GAMETYPE_TFFA, GAMETYPE_CTL, \
                        GAMETYPE_TSYC, GAMETYPE_BB)

#----------------------------------------------------------------------------------------------------------------------------------------------
class Wop15Parser(AbstractParser):
    gameName = 'wop15'

    _settings = {}
    _settings['line_length'] = 65
    _settings['min_wrap_length'] = 100

    _commands = {}
    _commands['message'] = 'stell %(cid)s "%(prefix)s ^3[pm]^7 %(message)s"'
    _commands['deadsay'] = 'stell %(cid)s "%(prefix)s [DEAD]^7 %(message)s"'
    _commands['say'] = 'ssay "%(prefix)s^7 %(message)s"'
    _commands['saybig'] = 'scp -1 "%(prefix)s^7 %(message)s"'

    _commands['set'] = 'set %(name)s "%(value)s"'
    _commands['kick'] = 'clientkick %(cid)s'
    _commands['ban'] = 'banAddr %(cid)s'
    _commands['tempban'] = 'clientkick %(cid)s'


    _eventMap = {
        'warmup' : EVT_GAME_WARMUP,
        'shutdowngame' : EVT_GAME_ROUND_END
    }

    # remove the time off of the line
    _lineClear = re.compile(r'^(?:[0-9:]+\s?)?')
    #0:00 ClientUserinfo: 0:

    _lineFormats = (
        #Generated with : WOP version 1.5
        #ClientConnect: 0 014D28A78B194CDA9CED1344D47B903B 84.167.190.158
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s(?P<cl_guid>[0-9a-z]{32})\s+(?P<ip>[0-9.]+))$', re.IGNORECASE),
        #ClientConnect: 2  151.16.71.226
        re.compile(r'^(?P<action>[a-z]+):\s(?P<data>(?P<cid>[0-9]+)\s+(?P<ip>[0-9.]+))$', re.IGNORECASE),
        #Tell: $cid $target-cid $text"
        #Tell: -1 $target-cid $text"
        re.compile(r'^(?P<action>Tell):\s*(?P<data>(?P<cid>[-]?[0-9]+)\s+(?P<tcid>[0-9]+)\s+(?P<text>.+))$', re.IGNORECASE),
        #Award: 2 gauntlet
        ## disabled because no cid
        #re.compile(r'^(?P<action>Award):\s*(?P<data>.+))$', re.IGNORECASE),
        #Bot connecting
        #ClientConnect: 0
        #re.compile(r'^(?P<action>ClientConnect):\s*(?P<data>(?P<bcid>[0-9]+))$', re.IGNORECASE),
        #Damage: 2 1022 2 50 7
        re.compile(r'^(?P<action>Damage):\s*(?P<data>(?P<cid>[0-9]+)\s+(?P<aweap>[0-9a-z_]+)\s+(?P<acid>[0-9]+)\s+(?P<damage>\d+)\s+(?P<meansofdeath>\d+))$', re.IGNORECASE),
        #Kill: $attacker-cid $means-of-death $target-cid
        #Kill: 2 MOD_INJECTOR 0
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>(?P<acid>[0-9]+)\s(?P<aweap>[0-9a-z_]+)\s(?P<cid>[0-9]+))$', re.IGNORECASE),
        #Say: 0 insta machen?
        #Item: 3 ammo_spray_n
        re.compile(r'^(?P<action>[a-z]+):\s*(?P<data>.*)$', re.IGNORECASE),
    )

    #status
    #map: wop_padcloisterctl
    #num score team ping name            lastmsg address               qport rate
    #--- ----- ---- ---- --------------- ------- --------------------- ----- -----
    #  0     0    2    0 ^0PAD^4MAN^7           50 bot                       0 16384
    #  1     0    3   43 PadPlayer^7           0 2001:41b8:9bf:fe04:f40c:d4ff:fe2b:6af9 45742 90000
    _regPlayer = re.compile(r'^(?P<slot>[0-9]+)\s+(?P<score>[0-9-]+)\s+(?P<team>[0-9]+)\s+(?P<ping>[0-9]+)\s+(?P<name>.*?)\s+(?P<last>[0-9]+)\s+(?P<ip>[0-9.]+)\s+(?P<qport>[0-9]+)\s+(?P<rate>[0-9]+)$', re.I)

    _reColor = re.compile(r'(\^.)|[\x00-\x20]|[\x7E-\xff]')

    PunkBuster = None



    def startup(self):
        # add the world client
        self.clients.newClient('-1', guid='WORLD', name='World', hide=True)
        self.world_client = self.clients.newClient('1022', guid='ENTITYNUM_WORLD', name='World', hide=True)

        # get map from the status rcon command
        map = self.getMap()
        if map:
            self.game.mapName = map
            self.info('map is: %s'%self.game.mapName)
        
        # initialize connected clients
        plist = self.getPlayerList()
        for cid, c in plist.iteritems():
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)


    # ##########################################################################
    #
    # Game event handling
    #
    # ##########################################################################

    def OnClientconnect(self, action, data, match=None):
        #ClientConnect: 2 77F303414E4355E0860B483F2A07E4DF 151.16.71.226:27960
        #ClientConnect: 2  151.16.71.226
        #ClientConnect: 0
        try:
            cid = match.group('cid') # Normal client connected
            client = self.getByCidOrJoinPlayer(cid)
            self.verbose('Client Connected cid: %s' % cid)
        except IndexError:
            pass
        

    def OnClientuserinfochanged(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        if bclient:
            client = self.clients.getByCID(bclient['cid'])

            if client:
                # update existing client
                bclient['ip'] = client.ip
                for k, v in bclient.iteritems():
                    setattr(client, k, v)

    # disconnect
    def OnClientdisconnect(self, action, data, match=None):
        client = self.clients.getByCID(data)
        if client: client.disconnect()
        return None

    def OnInitgame(self, action, data, match=None):
        options = re.findall(r'\\([^\\]+)\\([^\\]+)', data)

        for o in options:
            if o[0] == 'mapname':
                self.game.mapName = o[1]
            elif o[0] == 'g_gametype':
                self.game.gameType = self.defineGameType(o[1])
            elif o[0] == 'fs_game':
                self.game.modName = o[1]
            else:
                setattr(self.game, o[0], o[1])

        self.verbose('Current gameType: %s' % self.game.gameType)
        self.game.startRound()
        
        self.debug('Joining Players')
        self.joinPlayers()

        return self.getEvent('EVT_GAME_ROUND_START', self.game)

    # say
    def OnSay(self, action, data, match=None):
        #3:59 say: 1 general chat
        msg = string.split(data, ' ', 1)
        if not len(msg) == 2:
            return None

        if msg[0] == '-1':
            # server talking -> ignore
            return
        client = self.getByCidOrJoinPlayer(msg[0])

        if client:
            self.verbose('Client Found: %s' % client.name)
            return self.getEvent('EVT_CLIENT_SAY', msg[1], client)
        else:
            self.verbose('No Client Found!')
            return None

    # sayteam
    def OnSayteam(self, action, data, match=None):
        #4:06 sayteam: 1 teamchat
        msg = string.split(data, ' ', 1)
        if not len(msg) == 2:
            return None

        client = self.getByCidOrJoinPlayer(msg[0])

        if client:
            self.verbose('Client Found: %s' % client.name)
            return self.getEvent('EVT_CLIENT_TEAM_SAY', msg[1], client, client.team)
        else:
            self.verbose('No Client Found!')
            return None

    # private say
    def OnTell(self, action, data, match=None):
        # Tell: $cid $target-cid $text
        if match is None:
            return
        cid = match.group('cid')
        client = self.getByCidOrJoinPlayer(cid)
        target = self.getByCidOrJoinPlayer(match.group('tcid'))

        if client and cid != '-1':
            return self.getEvent('EVT_CLIENT_PRIVATE_SAY', match.group('text'), client, target)

    #Damage: 2 1022 2 50 7
    def OnDamage(self, action, data, match=None):
        # note : do not use getByCidOrJoinPlayer because cid in 
        # damage line is sometimes bugged (numbers over 64)
        cid = match.group('cid')
        if not -1 < int(cid) < 64:
            cid = '1022'
        victim = self.clients.getByCID(cid)
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        acid = match.group('acid')
        if not -1 < int(acid) < 64:
            acid = '1022'
        attacker = self.clients.getByCID(acid)
        if not attacker:
            self.debug('No attacker')
            return None

        # ignore kills involving no player (world killing world)
        if attacker.cid == victim.cid == '1022':
            self.debug("World damaging World -> ignoring")
            return

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None

        event = 'EVT_CLIENT_DAMAGE'

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            event = 'EVT_CLIENT_DAMAGE_SELF'
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team \
            and self.game.gameType in TEAM_BASED_GAMETYPES:
            event = 'EVT_CLIENT_DAMAGE_TEAM'

        # if not logging damage we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        damagepoints = float(match.group('damage'))
        return self.getEvent(event, (damagepoints, weapon, victim.hitloc), attacker, victim)
    
    # kill
    #kill: acid cid aweap
    def OnKill(self, action, data, match=None):
        # kill modes caracteristics :
        """
         0:   MOD_UNKNOWN, Unknown Means od Death, shouldn't occur at all
         1:   MOD_PUMPER, Pumper
         2:   MOD_GAUNTLET, Punchy
         3:   MOD_MACHINEGUN, Nipper
         4:   MOD_GRENADE, Balloony
         5:   MOD_GRENADE_SPLASH, Ballony Splashdamage
         6:   MOD_ROCKET, Betty
         7:   MOD_ROCKET_SPLASH, Betty Splashdamage
         8:   MOD_PLASMA, BubbleG
         9:   MOD_PLASMA_SPLASH, BubbleG Splashdamage
        10:   MOD_RAILGUN, Splasher
        11:   MOD_LIGHTNING, Boaster
        12:   MOD_BFG, Imperius
        13:   MOD_BFG_SPLASH, Imperius Splashdamage
        14:   MOD_KILLERDUCKS, Killerducks
        15:   MOD_WATER, Died in Water
        16:   MOD_SLIME, Died in Slime
        17:   MOD_LAVA, Died in Lava
        18:   MOD_CRUSH, Killed by a Mover
        19:   MOD_TELEFRAG, Killed by a Telefrag
        20:   MOD_FALLING, Died due to falling damage, but there is no falling damage in WoP
        21:   MOD_SUICIDE, Commited Suicide
        22:   MOD_TARGET_LASER, Killed by a laser, which don't exist in WoP
        23:   MOD_TRIGGER_HURT, Killed by a trigger_hurt
        24:   MOD_GRAPPLE, Killed by grapple, not used in WoP
        """
        self.debug('OnKill: %s (%s)'%(match.group('aweap'),match.group('data')))
        cid = match.group('cid')
        if not -1 < int(cid) < 64:
            cid = '1022'
        victim = self.clients.getByCID(cid)
        if not victim:
            self.debug('No victim')
            #self.OnClientuserinfo(action, data, match)
            return None

        acid = match.group('acid')
        if not -1 < int(acid) < 64:
            acid = '1022'
        attacker = self.clients.getByCID(acid)
        if not attacker:
            self.debug('No attacker')
            return None

        # ignore kills involving no player (world killing world)
        if attacker.cid == victim.cid == '1022':
            self.debug("World damaging World -> ignoring")
            return

        weapon = match.group('aweap')
        if not weapon:
            self.debug('No weapon')
            return None
        
        event = 'EVT_CLIENT_KILL'

        # fix event for team change and suicides and tk
        if attacker.cid == victim.cid:
            event = 'EVT_CLIENT_SUICIDE'
        elif attacker.team != b3.TEAM_UNKNOWN and attacker.team == victim.team \
            and self.game.gameType in TEAM_BASED_GAMETYPES:
            event = 'EVT_CLIENT_KILL_TEAM'

        # if not logging damage we need a general hitloc (for xlrstats)
        if not hasattr(victim, 'hitloc'):
            victim.hitloc = 'body'
        
        victim.state = b3.STATE_DEAD
        #self.verbose('OnKill Victim: %s, Attacker: %s, Weapon: %s, Hitloc: %s, dType: %s' % (victim.name, attacker.name, weapon, victim.hitloc, dType))
        # need to pass some amount of damage for the teamkill plugin - 100 is a kill
        return self.getEvent(event, (100, weapon, victim.hitloc), attacker, victim)

    # item
    def OnItem(self, action, data, match=None):
        #Item: 5 weapon_betty
        cid, item = string.split(data, ' ', 1)
        client = self.getByCidOrJoinPlayer(cid)
        if client:
            #self.verbose('OnItem: %s picked up %s' % (client.name, item) )
            return self.getEvent('EVT_CLIENT_ITEM_PICKUP', item, client)
        return None


    def OnClientuserinfo(self, action, data, match=None):
        bclient = self.parseUserInfo(data)
        self.verbose('Parsed user info %s' % bclient)
        
        if not bclient.has_key('cl_guid') and bclient.has_key('skill'):
            # must be a bot connecting
            self.bot('Bot Connecting!')
            bclient['ip'] = '0.0.0.0'
            
        if 'cl_guid' in bclient:
            bclient['guid'] = bclient['cl_guid']
        if bclient:
            client = self.clients.getByCID(bclient['cid'])
            if client:
                # update existing client
                for k, v in bclient.iteritems():
                    setattr(client, k, v)
            else:
                cid = bclient['cid']
                del bclient['cid']
                client = self.clients.newClient(cid, state=b3.STATE_ALIVE, **bclient)
                
            self.debug("client is now : %s" % client)
        return
    

    # ##########################################################################
    #
    # Parser API implementation
    #
    # ##########################################################################
    
    def say(self, msg):
        lines = []
        for line in self.getWrap(msg, self._settings['line_length'], self._settings['min_wrap_length']):
            lines.append(self.getCommand('say', prefix=self.msgPrefix, message=line))

        if len(lines):        
            self.writelines(lines)


    # ##########################################################################
    #
    # other
    #
    # ##########################################################################


    def getLineParts(self, line):
        line = re.sub(self._lineClear, '', line, 1)

        for f in self._lineFormats:
            m = re.match(f, line)
            if m:
                #self.debug('line matched %s' % f.pattern)
                break

        if m:
            client = None
            target = None
            return (m, m.group('action').lower(), m.group('data').strip(), client, target)
        else:
            self.verbose('line did not match format: %s' % line)

    def parseUserInfo(self, info):
        #3 n\Dr.Schraube\t\0\model\padman/padsoldier_red\hmodel\padman/padsoldier_red\c1\4\c2\1\hc\100\w\0\l\0\tt\0\tl\0\sl\
        playerID, info = string.split(info, ' ', 1)

        if info[:1] != '\\':
            info = '\\' + info

        options = re.findall(r'\\([^\\]+)\\([^\\]+)', info)

        data = {}
        for o in options:
            data[o[0]] = o[1]

        data['cid'] = playerID

        if data.has_key('n'):
            data['name'] = data['n']

        t = 0
        if data.has_key('team'):
            t = data['team']
        elif data.has_key('t'):
            t = data['t']

        data['team'] = self.getTeam(t)

        if data.has_key('cl_guid') and not data.has_key('guid'):
            data['guid'] = data['cl_guid']

        return data
    
    # Translate the gameType to a readable format
    # //WoP gametypes: 0=FFA / 1=1v1 / 2=SP / 3=SYC-FFA / 4=LPS / 5=TDM / 6=CTL / 7=SYC-TP / 8=BB
    def defineGameType(self, gameTypeInt):

        _gameType = ''
        #self.debug('gameTypeInt: %s' % gameTypeInt)
        
        if gameTypeInt == GAMETYPE_FFA:
            _gameType = 'FFA'
        elif gameTypeInt == GAMETYPE_1VS1:
            _gameType = 'lVSl'
        elif gameTypeInt == GAMETYPE_SP:
            _gameType = 'SP'
        elif gameTypeInt == GAMETYPE_SYC:
            _gameType = 'SYC'
        elif gameTypeInt == GAMETYPE_LPS:
            _gameType = 'LPS'
        elif gameTypeInt == GAMETYPE_TFFA:
            _gameType = 'TFFA'
        elif gameTypeInt == GAMETYPE_CTL:
            _gameType = 'CTL'
        elif gameTypeInt == GAMETYPE_TSYC:
            _gameType = 'TSYC'
        elif gameTypeInt == GAMETYPE_BB:
            _gameType = 'BB'
        
        #self.debug('_gameType: %s' % _gameType)
        return _gameType

    def joinPlayers(self):
        plist = self.getPlayerList()

        for cid, c in plist.iteritems():
            client = self.clients.getByCID(cid)
            if client:
                self.debug('Joining %s' % client.name)
                self.queueEvent(self.getEvent('EVT_CLIENT_JOIN', None, client))

        return None

    def queryClientUserInfoByCid(self, cid):
        """
        : dumpuser 2
        userinfo 2
        --------
        ip                   192.168.10.1
        syc_color            0
        cl_voip              1
        cg_predictItems      1
        sex                  male
        handicap             100
        team_headmodel       padman
        team_model           padman
        headmodel            padman
        model                padman
        snaps                40
        rate                 25000
        name                 PadPlayer
        cl_guid              98E40E6546546546546546546543D572
        teamoverlay          1
        cg_smoothClients     0
        
        : dumpuser 4
        Player 4 is not on the server

        """
        if not -1 < int(cid) < 64:
            return None
        data = self.write('dumpuser %s' % cid)
        if not data:
            return None
        
        if data.split('\n')[0] != "userinfo":
            self.debug("dumpuser %s returned : %s" % (cid, data))
            self.debug('client %s probably disconnected, but its character is still hanging in game...' % cid)
            return None

        datatransformed = "%s " % cid
        for line in data.split('\n'):
            if line.strip() == "userinfo" or line.strip() == "--------":
                continue

            var = line[:20].strip()
            val = line[20:].strip()
            datatransformed += "\\%s\\%s" % (var, val)

        return datatransformed

    def getByCidOrJoinPlayer(self, cid):
        if int(cid) > 63:
            self.debug("a client cid cannot be over 63 ! received : %s" % cid)
            return
        client = self.clients.getByCID(cid)
        if client is None:
            self.debug('cannot find client by cid %r' % cid)
            self.debug(repr(self.clients))
            userinfostring = self.queryClientUserInfoByCid(cid)
            if userinfostring:
                self.OnClientuserinfo(None, userinfostring)
            client = self.clients.getByCID(cid)
        return client

    def queueEvent(self, event, expire=10):
        try:
            if DEBUG_EVENTS:
                self.verbose2(event)
        finally:
            return b3.parser.Parser.queueEvent(self, event, expire)

"""
game log information provided by GedankenBlitz:

stell $cid $text
Serverside tell chat.

ssay $text
Serverside say chat.

sprint $cid $text
Print text to a client. Text will be printed to the upper left chat area.

New loglines;
DropItem: $cid $classname
Award: $cid $awardname
AddScore: $cid $score $reason
Vote: failed timeout
Vote: failed
Vote: passed
CvarChange: $cvar-name $cvar-value
AddTeamScore: $teamname $score $reason
Callvote: $cid $vote

Changed loglines;
Kill: $attacker-cid $means-of-death $target-cid
Teamscores: red $score-red blue $score-blue
Score: $cid $score
Say: $cid $text
SayTeam: $cid $text
Tell: $cid $target-cid $text

rcon status currently includes an extra column for the player team;
map: wop_padcloisterctl
num score team ping name            lastmsg address               qport rate
--- ----- ---- ---- --------------- ------- --------------------- ----- -----
  0     0    2    0 ^0PAD^4MAN^7           50 bot                       0 16384
  1     0    3   43 PadPlayer^7           0 2001:41b8:9bf:fe04:f40c:d4ff:fe2b:6af9 45742 90000

Awardnames are;
excellent
gauntlet
cap
impressive
defend
assist
denied
spraygod
spraykiller
unkown

Teamnames are;
FREE
RED
BLUE
SPECTATOR
This order matches the team numbers, which start with index 0.

Inbuilt score reasons include;
suicide
teamkill
kill
survive
spray
spray_wrongwall
target_score
frag_carrier
carrier_protect
defense
recovery
capture
capture_team
assist_return
assist_frag_carrier
flag
spraykiller
spraygod

Means of death have changed to
MOD_UNKNOWN = 0
MOD_PUMPER
MOD_PUNCHY
MOD_NIPPER
MOD_BALLOONY
MOD_BALLOONY_SPLASH
MOD_BETTY
MOD_BETTY_SPLASH
MOD_BUBBLEG
MOD_BUBBLEG_SPLASH // should be unused
MOD_SPLASHER
MOD_BOASTER
MOD_IMPERIUS
MOD_IMPERIUS_SPLASH
MOD_INJECTOR // new
MOD_KILLERDUCKS
MOD_WATER
MOD_SLIME
MOD_LAVA
MOD_CRUSH
MOD_TELEFRAG
MOD_FALLING   // should be unused
MOD_SUICIDE
MOD_TARGET_LASER
MOD_TRIGGER_HURT
MOD_GRAPPLE   // should be unused
MOD_BAMBAM // new
MOD_BOOMIES // new

Votes depend on the vote of course, an example is;
map wop_dinerbb; set nextmap "wop_padcrashctl"
"""
########NEW FILE########
__FILENAME__ = pkg_handler
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
# 05/01/2009 - 1.1.1 - Courgette
#    * make PkgResourcesStandIn.version('b3') work with py2exe build
# 20/03/2010 - 1.2 - Courgette
#    * make sure to read the version from the PKG-INFO file if found in the b3 module
#      even when setup_tools are installed on the system
# 21/10/2010 - 1.2.1 - Courgette
#    * fix an issue that broke the b3_run.exe when frozen on a machine that
#      have pkg_resources available

__author__  = 'ThorN'
__version__ = '1.2.1'

import os, sys, re
from b3.functions import main_is_frozen

__all__ = ['version', 'resource_directory']

# use this class if pkg_resources is installed
class PkgResources:
    def version(self, module):
        version = '<unknown>'
        try:
            if os.path.isfile(os.path.join(self.resource_directory(module), 'PKG-INFO')):
                ## we need this in the case the user installed B3 from sources (copying the b3.egg-in
                ## folder) and then updates just the b3 folder but still have setup_tools installed
                ## on his system 
                version = getVersionFromFile(os.path.join(self.resource_directory(module), 'PKG-INFO'))
            else:
                version = pkg_resources.get_distribution(module).version
        except pkg_resources.DistributionNotFound:
            # must not be installed as an egg
            pkg_handler = PkgResourcesStandIn()
            version = pkg_handler.version(module)

        return version

    def resource_directory(self, module):
        return pkg_resources.resource_filename(module, '')

# use this class if pkg_resources is NOT installed
class PkgResourcesStandIn:
    def version(self, module):
        # find package info
        version = '<unknown>'
        searchDirectories = ['PKG-INFO' ,
            os.path.join(self.resource_directory(module), 'PKG-INFO'), 
            os.path.join(self.resource_directory(module), '..', 'PKG-INFO'), 
            os.path.join(self.resource_directory(module), '..', 'b3.egg-info', 'PKG-INFO')
            ]
        if module == 'b3':
            searchDirectories.insert(0, os.path.join(self.getB3Path(), 'PKG-INFO')) 
            
        for p in searchDirectories:
            if os.path.isfile(p):            
                version = getVersionFromFile(p)

        return version

    def resource_directory(self, module):
        return os.path.dirname(sys.modules[module].__file__)
    
    def getB3Path(self):
        if main_is_frozen():
            # which happens when running from the py2exe build
            return os.path.dirname(sys.executable)
        return self.resource_directory('b3')

def getVersionFromFile(filename):
    version = None
    if os.path.isfile(filename):            
        f = file(filename, 'r')                
        for line in f:
            if line.lower().startswith('version:'):
                version = re.sub('[^A-Za-z0-9.]+', '-', line.split(':',1)[1].strip().replace(' ','.'))
                break
        f.close()
    return version


pkg_handler = None
if main_is_frozen():
    # avoid issues when frozen with py2exe on a windows machine
    # that have phg_resources importable.
    pkg_handler = PkgResourcesStandIn()
else:
    try:
        import pkg_resources
    except ImportError:
        # package tools is not intalled
        pkg_handler = PkgResourcesStandIn()
    else:
        # package tools is installed
        pkg_handler = PkgResources()

version = pkg_handler.version
resource_directory = pkg_handler.resource_directory
########NEW FILE########
__FILENAME__ = plugin
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# CHANGELOG
#    11/29/2005 - 1.3.0 - ThorN
#    Added warning, info, exception, and critical log handlers
#    14/11/2009 - 1.3.1 - Courgette
#    display a user friendly error message when a plugin config file as broken XML
#    29/11/2009 - 1.4.0 - Courgette
#    constructor now also accepts an instance of Config in place of a config file name
#    29/11/2009 - 1.4.1 - Courgette
#    the onLoadConfig callback is now always called after loadConfig() is called. This
#    aims to make sure onLoadConfig is called after the user use the !reconfig command
#
__author__  = 'ThorN'
__version__ = '1.4.1'

import os
import b3.config
import b3.events

class Plugin:
    _enabled = True
    console = None
    events = []
    config = None
    working = True
    requiresConfigFile = True

    _messages = {}

    def __init__(self, console, config=None):
        self.console = console
        
        if isinstance(config, b3.config.XmlConfigParser) \
            or isinstance(config, b3.config.CfgConfigParser):
            self.config = config
        else:
            try:
                self.loadConfig(config)
            except b3.config.ConfigFileNotValid, e:
                self.critical("The config file XML syntax is broken: %s" %e)
                self.critical("Use a XML editor to modify your config files, it makes easy to spot errors")
                raise 

        self.registerEvent(b3.events.EVT_STOP)
        self.registerEvent(b3.events.EVT_EXIT)

    def enable(self):
        self._enabled = True

    def disable(self):
        self._enabled = False

    def isEnabled(self):
        return self._enabled

    def getMessage(self, msg, *args):
        try:
            msg = self._messages[msg]
        except KeyError:
            self._messages[msg] = self.config.getTextTemplate('messages', msg)
            msg = self._messages[msg]

        if len(args) == 1:
            if type(args[0]) is dict:
                return msg % args[0]
            else:
                return msg % args
        else:
            return msg % args

    def loadConfig(self, fileName=None):
        if fileName:
            self.bot('Loading config %s for %s', fileName, self.__class__.__name__)
            try:
                self.config = b3.config.load(fileName)
            except b3.config.ConfigFileNotFound, e:
                if self.requiresConfigFile:
                    self.critical('Could not find config file %s' % fileName)
                    return False
                else:
                    self.bot('No config file found for %s. (was not required either)'%self.__class__.__name__)
                    return True
        elif self.config:
            self.bot('Loading config %s for %s', self.config.fileName, self.__class__.__name__)
            self.config = b3.config.load(self.config.fileName)
        else:
            if self.requiresConfigFile:
                self.error('Could not load config for %s', self.__class__.__name__)
                return False
            else:
                self.bot('No config file found for %s. (was not required either)'%self.__class__.__name__)
                return True
            
        # empty message cache
        self._messages = {}

        self.onLoadConfig()


    def onLoadConfig(self):
        """\
        This is called after loadConfig(). Any plugin private variables loaded
        from the config need to be reset here.
        """
        return True

    def saveConfig(self):
        self.bot('Saving config %s', self.config.fileName)
        return self.config.save()

    def registerEvent(self, eventName):
        self.events.append(eventName)
        self.console.registerHandler(eventName, self)

    def createEvent(self, key, name):
        self.console.createEvent(key, name)

    def startup(self):
        """\
        Depreciated. Use onStartup().
        """
        pass

    def onStartup(self):
        """\
        Called after the plugin is created before it is started. Overwrite this
        for anything you need to initialize you plugin with.
        """

        # support backwards compatability
        self.startup()

    def start(self):
        """\
        Called after Plugin.startup().
        """
        pass

    def parseEvent(self, event):
        self.onEvent(event)

        if event.type == b3.events.EVT_EXIT or event.type == b3.events.EVT_STOP:
            self.working = False

    def handle(self, event):
        """\
        Depreciated. Use onEvent().
        """
        self.verbose('Warning: No handle func for %s', self.__class__.__name__)

    def onEvent(self, event):
        """\
        Called by B3 when a registered event is encountered. You must overwrite
        this to intercept events.
        """

        # support backwards compatability
        self.handle(event)

    def error(self, msg, *args, **kwargs):
        """\
        Log an error message to the main log.
        """
        self.console.error('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def debug(self, msg, *args, **kwargs):
        """\
        Log a debug message to the main log.
        """
        self.console.debug('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def bot(self, msg, *args, **kwargs):
        """\
        Log a bot message to the main log.
        """
        self.console.bot('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def verbose(self, msg, *args, **kwargs):
        """\
        Log a verbose message to the main log. More "chatty" than a debug message.
        """
        self.console.verbose('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """\
        Log a warning message to the main log.
        """        
        self.console.warning('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        """\
        Log an info message to the main log.
        """        
        self.console.info('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def exception(self, msg, *args, **kwargs):
        """\
        Log an exception message to the main log.
        """        
        self.console.exception('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        """\
        Log a critical message to the main log.
        """
        self.console.critical('%s: %s' % (self.__class__.__name__, msg), *args, **kwargs)
########NEW FILE########
__FILENAME__ = admin
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#   2012/10/27 - 1.19 - Courgette
#   * change: !map command will give at most 5 suggestions
#   2012/10/03 - 1.18 - Courgette
#   * add command !lastbans
#   2012/09/29 - 1.17 - Courgette
#   * add command !regulars
#   2012/08/11 - 1.16 - Courgette
#   * config file can refer to group levels by their group keyword
#   2012/07/31 - 1.15.1 - Courgette
#   * fix command !maps when map rotation list is empty
#   2012/07/28 - 1.15 - Courgette
#   * add command !unreg (danger89's idea)
#   2012/07/14 - 1.14.1 - Courgette
#   * log more detail when failing to register a command
#   2012/07/07 - 1.14 - Courgette
#   * better error log messages when registering a command with incorrect level or group keyword
#   2012/07/05 - 1.13 - Courgette
#   * provides default values for warn_reason keywords 'default' and 'generic' if missing from config file
#   * refactors the loading and parsing of warn_reasons from the config file to provide meaningful messages when
#   * errors are detected
#   2012/07/02 - 1.12.2 - Courgette
#   * fix bug un cmd_mask when no player name was given
#   2012/06/17 - 1.12.1 - Courgette
#   * syntax
#   2012/04/15 - 1.12 - Courgette
#   * removes magic command shortcut that would transform the command '!1 blah' into '!say blah'
#   2011/11/15 - 1.11.4 - Courgette
#   * fix bug where command &rules was acting like !rules
#   2011/11/15 - 1.11.3 - Courgette
#   * fix bug xlr8or/big-brother-bot#54 - Plugin Admin: parseUserCommand issue
#   2011/11/15 - 1.11.2 - Courgette
#   * cmd_pause now uses console pause() and unpause() methods instead of sleep()
#   2011/11/05 - 1.11.1 - Courgette
#   * do not tell "There was an error processing your command" to the player if catch a SystemExit
#   2011/05/31 - 1.11.0 - Courgette
#   * refactoring
#   2011/04/30 - 1.10.3 - Courgette
#   * !help response won't include !register if already registered
#   2011/02/26 - 1.10.2 - Courgette
#   * fix doc for !spam command
#   2010/12/12 - 1.10.1 - Courgette
#   * registering a command can use group keywords instead of groups levels
#   2010/11/25 - 1.9.1 - Courgette
#   * calling a command of a disabled plugin now sends a message back to the user
#   2010/11/21 - 1.9 - Courgette
#   * cmd_map now suggests map names if provided by parser
#   2010/10/28 - 1.8.2 - Courgette
#   * make sure to disable the !iamgod command when used while there is already 
#     a superadmin in db.
#   2010/08/25 - 1.8.1 - Courgette
#   * do not fail if warn_command_abusers is missing in config
#   2010/08/24 - 1.8 - kikker916 & Courgette
#   * add warn_command_abusers setting what defines if player should get warned 
#     for trying to use non existing or privileged commands
#   * add documentation into the xml config file
#   * fix a few things with the config file
#   2010/08/14 - 1.7.1 - Courgette
#   * fix _parseUserCmdRE regexp for cases where the player's name start with a digit
#   2010/04/10 - 1.7 - Bakes
#   * new '&' command prefix can be used to say messages in the middle of the screen.
#     has the same settings as '@', this may change in the future.
#   2010/03/22 - 1.6.1 - Courgette
#   * resolve conflict regarding maprotate/rotateMap
#   2010/03/21 - 1.6 - Courgette
#    * make this plugin game independant by delegating the work to the parser for 
#      commands !map and !maprotate
#   2010/03/21 - 1.5 - Courgette
#    * removed commands : greeting, about, groups, cmdlevel, newgroup, delgroup, editgroup
#   3/21/2010 - 1.4.7 - Bakes
#    * moved the !ci command to the pingwatch plugin
#    * moved part of cmd_maprotate to the parser.
#   3/7/2010 - 1.4.6 - Courgette
#    * fix crash on bot startup when loading a plugin which does not requires any config
#      file but still registers commands
#   1/27/2010 - 1.4.5 - Courgette
#    * the iamgod check warns if the command is explicitly enabled by config file but
#      superadmins are found in database
#   1/27/2010 - 1.4.4 - xlr8or
#    * added some verbose info to startup()
#   9/1/2009 - 1.4.3 - xlr8or
#    * check database connection before checking groups
#   8/24/2009 - 1.4.2 - courgette
#    * warning messages are also sent by pm to the admin that give them
#   8/22/2009 - 1.4.1 - courgette
#    * warning messages are shown only to the warned player. This is to prevent the bot from spaming the console.
#   8/19/2009 - 1.4.0 - courgette
#    * penalizeClient() will try to delegate unknown penalty types to inflictCustomPenalty() of the current parser.
#      Requires parser.py v1.10+
#   7/22/2009 - 1.3.5 - xlr8or
#    Generate better documented error when groupstable is empty
#   10/05/2008 - 1.3.4b0 - mindriot
#      * Removed hard code of 1 day for long_tempban_level - now controlled with new setting 'long_tempban_max_duration'
#   8/29/2005 - 1.2.2 - ThorN
#    Moved pbss command to punkbuster plugin
#   8/13/2005 - 1.2.1 - ThorN
#    Added penalizeClient()
#    Moved greeting to welcome plugin
#   7/23/2005 - 1.1.0 - ThorN
#    Made it so registerCommand() will check a plugins config "commands" section for command level overrides
#    Added ci command
#    Added data field to warnClient(), warnKick(), and checkWarnKick()
#

__version__ = '1.19'
__author__  = 'ThorN, xlr8or, Courgette'

import re, time, threading, sys, traceback, thread, random
from ConfigParser import NoOptionError

from b3 import functions
from b3.clients import Client, Group
from b3.functions import minutesStr
import b3.plugin
import copy

#--------------------------------------------------------------------------------------------------
# pylint: disable-msg=E1103
class AdminPlugin(b3.plugin.Plugin):
    _commands = {}
    _parseUserCmdRE = re.compile(r"^(?P<cid>'[^']{2,}'|[0-9]+|[^\s]{2,}|@[0-9]+)(\s+(?P<parms>.*))?$")
    _long_tempban_max_duration = 1440 # 60m/h x 24h = 1440m = 1d
    _warn_command_abusers = None

    cmdPrefix = '!'
    cmdPrefixLoud = '@'
    cmdPrefixBig = '&'

    PENALTY_KICK = 'kick'
    PENALTY_TEMPBAN = 'tempban'
    PENALTY_WARNING = 'warning'
    PENALTY_BAN = 'ban'

    warn_reasons = {} # dict<warning keyword, tuple(warning duration in minute, warning reason)>

    _noreason_level = 80
    _long_tempban_level = 80
    _hidecmd_level = 80
    _admins_level = 20

    def onLoadConfig(self):
        self.load_config_warn_reasons()

        try:
            self._noreason_level = self.console.getGroupLevel(self.config.get('settings', 'noreason_level'))
        except (NoOptionError, KeyError), err:
            self.warning("Using default value %s for 'noreason_level'. %s" % (self._noreason_level, err))

        try:
            self._long_tempban_level = self.console.getGroupLevel(self.config.get('settings', 'long_tempban_level'))
        except (NoOptionError, KeyError), err:
            self.warning("Using default value %s for 'long_tempban_level'. %s" % (self._long_tempban_level, err))

        try:
            self._hidecmd_level = self.console.getGroupLevel(self.config.get('settings', 'hidecmd_level'))
        except (NoOptionError, KeyError), err:
            self.warning("Using default value %s for 'hidecmd_level'. %s" % (self._hidecmd_level, err))

        try:
            self._admins_level = self.console.getGroupLevel(self.config.get('settings', 'admins_level'))
        except (NoOptionError, KeyError), err:
            self.warning("Using default value %s for 'admins_level'. %s" % (self._admins_level, err))


    def onStartup(self):
        self.registerEvent(self.console.getEventID('EVT_CLIENT_SAY'))
        self.registerEvent(self.console.getEventID('EVT_CLIENT_PRIVATE_SAY'))
        self.createEvent('EVT_ADMIN_COMMAND', 'Admin Command')

        try:
            cmdPrefix = self.config.get('settings', 'command_prefix')
            if cmdPrefix:
                self.cmdPrefix = cmdPrefix
        except:
            self.warning('could not get command_prefix, using default')

        try:
            cmdPrefixLoud = self.config.get('settings', 'command_prefix_loud')
            if cmdPrefixLoud:
                self.cmdPrefixLoud = cmdPrefixLoud
        except:
            self.warning('could not get command_prefix_loud, using default')
    
        try:
            cmdPrefixBig = self.config.get('settings', 'command_prefix_big')
            if cmdPrefixBig:
                self.cmdPrefixBig = cmdPrefixBig
        except:
            self.warning('could not get command_prefix_big, using default')


        try:
            self._warn_command_abusers = self.config.getboolean('warn', 'warn_command_abusers')
        except NoOptionError:
            self.warning('conf warn\warn_command_abusers not found, using default : yes')
            self._warn_command_abusers = True
        except ValueError:
            self.warning('invalid value for conf warn\warn_command_abusers, using default : yes')
            self._warn_command_abusers = True


        if 'commands' in self.config.sections():
            for cmd in self.config.options('commands'):
                level = self.config.get('commands', cmd)
                sp = cmd.split('-')
                alias = None
                if len(sp) == 2:
                    cmd, alias = sp

                func = self.getCmd(cmd)
                if func:
                    self.registerCommand(self, cmd, level, func, alias)

        if not self.console.storage.db:
            self.error('There is no database connection! Cannot store or retrieve any information. Fix the database connection first!')
        else:
            try:
                superadmins = self.console.clients.lookupSuperAdmins()
                self.debug('%s superadmins found in database' % len(superadmins))
            except Exception, msg:
                # no proper groups available, cannot continue
                self.critical('Seems your groupstable in the database is empty. Please recreate your database using the proper sql syntax - use b3/docs/b3.sql - (%s)' %msg)
            
            if self._commands.has_key('iamgod') \
                and self._commands['iamgod'].level is not None \
                and self._commands['iamgod'].level[0] >= 0:
                ## here the config file for the admin plugin explicitly enables the iamgod command
                if len(superadmins) == 0:
                    self.verbose('!iamgod command enabled by config file. Be sure to disable it after typing !iamgod.')
                else:
                    self.warning('!iamgod command enabled by config file but %s superadmin are already registered. ' +
                        'Make sure to disable the iamgod command in the admin plugin', len(superadmins))
            elif len(superadmins) == 0:
                self.verbose('No SuperAdmins found, enabling !iamgod')
                # There are no superadmins, enable the !iamgod command
                self.registerCommand(self, 'iamgod', 0, self.getCmd('iamgod'))
            else:
                self.verbose('SuperAdmin(s) found, no need for !iamgod')

    def registerCommand(self, plugin, command, level, handler, alias=None, secretLevel=None):
        if not handler:
            self.error('Command "%s" registration failed, no handler' % command)
            return False

        if plugin.config and plugin != self and plugin.config.has_option('commands', command):
            # override default level with level in config
            level = plugin.config.get('commands', command)
    
        clean_level = self.getGroupLevel(level)
        if clean_level is False:
            groups = self.console.storage.getGroups()
            self.error("Cannot register command '%s'. Bad level/group : '%s'. Expecting a level (%s) or group keyword (%s)"
                % (command, level, ', '.join([str(x.level) for x in groups]), ', '.join([x.keyword for x in groups])))
            return
            
        if secretLevel is None:

            secretLevel = self._hidecmd_level

        try:
            self._commands[command] = Command(plugin, command, clean_level, handler, handler.__doc__, alias, secretLevel)

            if self._commands[command].alias:
                self._commands[self._commands[command].alias] = self._commands[command]

            self._commands[command].prefix = self.cmdPrefix
            self._commands[command].prefixLoud = self.cmdPrefixLoud

            self.debug('Command "%s (%s)" registered with %s for level %s' % (command, alias, self._commands[command].func.__name__, self._commands[command].level))
            return True
        except Exception, msg:
            self.error('Command "%s" registration failed. %s' % (command, msg))
            self.exception(msg)
            return False

    def handle(self, event):
        if event.type == self.console.getEventID('EVT_CLIENT_SAY'):
            self.OnSay(event)
        elif event.type == self.console.getEventID('EVT_CLIENT_PRIVATE_SAY') and event.target and event.client.id == event.target.id:
            self.OnSay(event, True)

    def aquireCmdLock(self, cmd, client, delay, all=True):
        if client.maxLevel >= 20:
            return True
        elif cmd.time + delay <= self.console.time():
            return True
        else:
            return False

    def OnSay(self, event, private=False):
        self.debug('OnSay handle %s:"%s"', event.type, event.data)

        if len(event.data) >= 3 and event.data[:1] == '#':
            if self.console.debug:
                if event.data[1:] == 'clients':
                    self.debug('Clients:')
                    for k, c in self.console.clients.items():
                        self.debug('client %s (#%i id: %s cid: %s level: %s group: %s) obj: %s', c.name, id(c), c.id, c.cid, c.maxLevel, c.groupBits, c)
                elif event.data[1:] == 'groups':
                    self.debug('Groups for %s:', event.client.name)
                    for g in event.client.groups:
                        self.debug('group (id: %s, name: %s, level: %s)', g.id, g.name, g.level)

                elif event.data[1:5] == 'vars':
                    try:
                        data = event.data[7:].strip()
                        if data:
                            sclient = self.findClientPrompt(data, event.client)
                            if not sclient: return
                        else:
                            sclient = event.client
                    except:
                        sclient = event.client

                    self.debug('Vars for %s:', sclient.name)

                    try:
                        for k,v in sclient._pluginData.items():
                            self.debug('\tplugin %s:', k)
                            for kk,vv in v.items():
                                self.debug('\t\t%s = %s', kk, str(vv.value))
                    except Exception, e:
                        self.debug('Error getting vars: %s', e)
                    self.debug('End of vars')
                elif event.data[1:7] == 'tkinfo':
                    try:
                        data = event.data[9:].strip()
                        if data:
                            sclient = self.findClientPrompt(data, event.client)
                            if not sclient: return
                        else:
                            sclient = event.client
                    except:
                        sclient = event.client

                    self.debug('Tkinfo for %s:', sclient.name)

                    try:
                        for k,v in sclient._pluginData.items():

                            for kk,vv in v.items():
                                if kk == 'tkinfo':
                                    self.debug('\tplugin %s:', k)
                                    tkinfo = vv.value
                                    self.debug('\t\tcid = %s', tkinfo.cid)
                                    self.debug('\t\tattackers = %s', str(tkinfo.attackers))
                                    self.debug('\t\tattacked = %s', str(tkinfo.attacked))
                                    self.debug('\t\tpoints = %s', tkinfo.points)
                                    self.debug('\t\t_grudged = %s', str(tkinfo._grudged))
                                    self.debug('\t\tlastAttacker = %s', tkinfo.lastAttacker)
                    except Exception, e:
                        self.debug('Error getting Tkinfo: %s', e)
                    self.debug('End of Tkinfo')

        elif len(event.data) >= 2 and (event.data[:1] == self.cmdPrefix or event.data[:1] == self.cmdPrefixLoud or event.data[:1] == self.cmdPrefixBig):
            # catch the confirm command for identification of the B3 devs
            if event.data[1:] == 'confirm':
                self.debug('checking confirmation...')
                self.console.say(functions.confirm(event.client))
                return
            else:
                self.debug('Handle command %s' % event.data)

            if event.data[1:2] == self.cmdPrefix or event.data[1:2] == self.cmdPrefixLoud or event.data[1:2] == self.cmdPrefixBig:
                # self.is the alias for say
                cmd = 'say'
                data = event.data[2:]
            else:
                cmd = event.data[1:].split(' ', 1)

                if len(cmd) == 2:
                    cmd, data = cmd
                else:
                    cmd  = cmd[0]
                    data = ''

            try:
                command = self._commands[cmd.lower()]
            except KeyError:
                if self._warn_command_abusers and event.client.authed and event.client.maxLevel < self._admins_level:
                    if event.client.var(self, 'fakeCommand').value:
                        event.client.var(self, 'fakeCommand').value += 1
                    else:
                        event.client.setvar(self, 'fakeCommand', 1)

                    if event.client.var(self, 'fakeCommand').toInt() >= 3:
                        event.client.setvar(self, 'fakeCommand', 0)
                        self.warnClient(event.client, 'fakecmd', None, False)
                        return
                if not self._warn_command_abusers and event.client.maxLevel < self._admins_level:
                    event.client.message(self.getMessage('unknown_command', cmd))
                elif event.client.maxLevel > self._admins_level:
                    event.client.message(self.getMessage('unknown_command', cmd))
                return

            cmd = cmd.lower()

            if not command.plugin.isEnabled():
                try:
                    event.client.message(self.getMessage('cmd_plugin_disabled'))
                except NoOptionError:
                    event.client.message("plugin disabled. Cannot execute command %s" % cmd)
                return

            elif not event.client.authed and command.level > 0:
                event.client.message('^7Please try your command after you have been authenticated')
                self.console.clients.authorizeClients()
                return

            elif private:
                # self.is a silent command
                if event.client.maxLevel < command.secretLevel:
                    event.client.message('^7You do not have sufficient access to do silent commands')
                    return False

            if command.canUse(event.client):
                try:
                    if event.data[:1] == self.cmdPrefixLoud and event.client.maxLevel >= 9:
                        results = command.executeLoud(data, event.client)
                    elif event.data[:1] == self.cmdPrefixBig and event.client.maxLevel >= 9:
                        results = command.executeBig(data, event.client)
                    else:
                        results = command.execute(data, event.client)
                except:
                    event.client.message('^7There was an error processing your command')
                    raise
                else:
                    self.console.queueEvent(self.console.getEvent('EVT_ADMIN_COMMAND', (command, data, results), event.client))
            else:
                if self._warn_command_abusers and event.client.maxLevel < self._admins_level:
                    if event.client.var(self, 'noCommand').value:
                        event.client.var(self, 'noCommand').value += 1
                    else:
                        event.client.setvar(self, 'noCommand', 1)

                    if event.client.var(self, 'noCommand').toInt() >= 3:
                        event.client.setvar(self, 'noCommand', 0)
                        self.warnClient(event.client, 'nocmd', None, False)
                        return
                
                if command.level == None:
                    event.client.message('^7%s%s command is disabled' % (self.cmdPrefix, cmd))
                elif self._warn_command_abusers:
                    event.client.message('^7You do not have sufficient access to use %s%s' % (self.cmdPrefix, cmd))

    def getCmd(self, cmd):
        cmd = 'cmd_%s' % cmd
        if hasattr(self, cmd):
            func = getattr(self, cmd)
            return func

        return None

    def getAdmins(self):
        return self.console.clients.getClientsByLevel(self._admins_level)

    def getRegulars(self):
        return self.console.clients.getClientsByLevel(min=2, max=2)

    def findClientPrompt(self, client_id, client=None):
        matches = self.console.clients.getByMagic(client_id)
        if matches:
            if len(matches) > 1:
                names = []
                for _p in matches:
                    names.append('^7%s [^2%s^7]' % (_p.name, _p.cid))

                if client:
                    client.message(self.getMessage('players_matched', client_id, ', '.join(names)))
                return False
            else:
                return matches[0]
        else:
            if client:
                client.message(self.getMessage('no_players', client_id))
            return None

    def parseUserCmd(self, cmd, req=False):
        """
        Return a tuple of two elements extracted from cmd :
         - a player identifier
         - optional parameters
        req: set to True if parameters is required.
        Return None if could cmd is not in the expected format
        """
        m = re.match(self._parseUserCmdRE, cmd)

        if m:
            cid = m.group('cid')
            parms = m.group('parms')

            if req and not (parms and len(parms)):
                return None

            if cid[:1] == "'" and cid[-1:] == "'":
                cid = cid[1:-1]

            return cid, parms
        else:
            return None

    def getGroupLevel(self, level):
        """
        return a group level from group keyword or group level
        understand level ranges (ie: 20-40 or mod-admin)
        """
        level = str(level)
        if level.lower() == 'none':
            return 'none'
        elif level.count('-') == 1:
            (levelmin, levelmax) = level.split('-', 1)
            try:
                levelmin = int(levelmin)
            except ValueError:
                try:
                    levelmin = self.console.getGroupLevel(levelmin)
                except KeyError:
                    self.error('unknown group %s' % levelmin)
                    return False
            try:
                levelmax = int(levelmax)
            except ValueError:
                try:
                    levelmax = self.console.getGroupLevel(levelmax)
                except KeyError:
                    self.error('unknown group %s' % levelmax)
                    return False
            level = '%s-%s' % (levelmin, levelmax)
        else:
            try:
                level = int(level)
            except ValueError:
                try:
                    level = self.console.getGroupLevel(level)
                except KeyError:
                    self.error('unknown group %s' % level)
                    return False
        return level

    def getReason(self, reason):
        if not reason:
            return ''

        r = self.getWarning(reason)
        if r:
            return r[1]
        else:
            return reason

    def getSpam(self, spam):
        if not spam:
            return ''

        try:
            s = self.config.getTextTemplate('spamages', spam)

            if s[:1] == '/':
                s = self.config.getTextTemplate('spamages', s[1:])
                if s[:1] == '/':
                    self.error('getSpam: Possible spam recursion %s, %s', spam, s)
                    return None
            
            return s
        except NoOptionError:
            return None
        except Exception, msg:
            self.error('getSpam: Could not get spam "%s": %s\n%s', spam, msg, traceback.extract_tb(sys.exc_info()[2]))
            return None

    def getWarning(self, warning):
        if not warning:
            warning = 'default'
        return self.warn_reasons.get(warning)

    def assert_commandData(self, data, client, cmd, *formatArgs):
        data = cmd.parseData(data, *formatArgs)
        if not data[0]:
            client.message(data[1])
            return False
        else:
            return data[0]

    #--------------------------------------------------------------------------------------------------
    def cmd_die(self, data, client, cmd=None):
        """\
        - shutdown b3
        """
        cmd.sayLoudOrPM(client, '^7Shutting down ^3%s' % data)
        self.console.die()

    def cmd_restart(self, data, client, cmd=None):
        """\
        - restart b3
        """
        cmd.sayLoudOrPM(client, '^7Shutting down for restart...')
        self.console.restart()

    def cmd_reconfig(self, data, client, cmd=None):
        """\
        - re-load all configs
        """
        self.console.reloadConfigs()
        cmd.sayLoudOrPM(client, '^7Re-loaded configs')

    def cmd_mask(self, data, client, cmd=None):
        """\
        <group> [<name>] - hide level
        """

        m = self.parseUserCmd(data)

        if not m:
            client.message('^7Invalid parameters')
            return False
        elif m[1] is None:
            groupName = m[0]
            sclient = client
        else:
            groupName = m[0]
            sclient = self.findClientPrompt(m[1], client)
            if not sclient:
                return False

        try:
            group = Group(keyword=groupName)
            group = self.console.storage.getGroup(group)
        except:
            client.message('^7Group %s does not exist' % groupName)
            return False

        sclient.maskLevel = group.id
        sclient._maskGroup = None
        sclient.save()

        if sclient != client:
            client.message('^7Masked %s as %s' % (sclient.name, group.name))
        sclient.message('^7Masked as %s' % group.name)

    def cmd_unmask(self, data, client, cmd=None):
        """\
        [<name>] - un-hide level
        """

        m = self.parseUserCmd(data)

        if not m:
            sclient = client
        else:
            sclient = self.findClientPrompt(m[0], client)

        if sclient:
            sclient.maskLevel = 0
            sclient._maskGroup = None
            sclient.save()

            if sclient != client:
                client.message('^7Un-Masked %s' % sclient.name)
            sclient.message('^7Un-Masked')



    def cmd_clear(self, data, client, cmd=None):
        """\
        [<player>] - clear all tk points and warnings
        """
        if data:
            sclient = self.findClientPrompt(data, client)

            if sclient:
                self.clearAll(sclient, client)
                self.console.say('%s^7 has cleared %s^7 of all tk-points and warnings' % (client.exactName, sclient.exactName))
        else:
            for cid,c in self.console.clients.items():
                self.clearAll(c, client)
            self.console.say('%s^7 has cleared everyones tk-points and warnings' % client.exactName)

    def clearAll(self, sclient, client=None):
        for w in sclient.warnings:
            admin = None
            try:
                admin = self.console.storage.getClient(Client(id=w.adminId))
                # client object needs console to get groups
                admin.console = self.console
            except:
                # warning given by the bot (censor, tk, etc) have adminId = 0 which match no client in storage
                pass
                
            if admin is None or admin.maxLevel <= client.maxLevel:
                w.inactive = 1
                self.console.storage.setClientPenalty(w)

        self._tkPlugin = self.console.getPlugin('tk')
        if self._tkPlugin:
            self._tkPlugin.forgiveAll(sclient.cid)

        sclient.save()

    def cmd_map(self, data, client, cmd=None):
        """\
        <map> - switch current map
        """
        if not data:
            client.message('^7You must supply a map to change to.')
            return
        suggestions = self.console.changeMap(data)
        if type(suggestions) == list:
            client.message('do you mean : %s ?' % ', '.join(suggestions[:5]))

    def cmd_maprotate(self, data, client, cmd=None):
        """\
        - switch to the next map in rotation
        """
        self.console.rotateMap()

    def cmd_b3(self, data, client, cmd=None):
        """\
        - say b3's version info
        """

        if len(data) > 0 and client.maxLevel >= self._admins_level:
            data = data.lower().strip()

            if data == 'poke':
                self.console.say('^7Do not poke b3 %s^7!' % client.exactName)
            elif data == 'expose':
                self.console.say('^7Do expose b3 to sunlight %s^7!' % client.exactName)
            elif data == 'stare':
                self.console.say('^7Do not stare at b3 %s^7!' % client.exactName)
            elif data == 'stab':
                self.console.say('^7b3 is invincible, %s^7 could not penetrate he hide of b3.' % client.exactName)
            elif data == 'bite':
                self.console.say('^7b3 breaks %s^7\'s teeth with its metalic frame.' % client.exactName)
            elif data == 'fuck':
                self.console.say('^7b3 doesn\'t need your hand me out %s^7.' % client.exactName)
            elif data == 'slap':
                self.console.say('^7%s^7 is not Rick James.' % client.exactName)
            elif data == 'fight':
                self.console.say('^7%s^7 is knocked out by b3.' % client.exactName)
            elif data == 'feed':
                self.console.say('^7b3 enjoys your nourishment %s^7.' % client.exactName)
            elif data == 'throw':
                self.console.say('^7b3 can fly %s^7, and you throw like a sissy.' % client.exactName)
            elif data == 'furniture':
                self.console.say('^7b3 does make a lovely lamp %s^7.' % client.exactName)
            elif data == 'indeed':
                self.console.say('^7You WOULD say that %s^7.' % client.exactName)
            elif data == 'flog':
                self.console.say('^7You are so kinky %s^7.' % client.exactName)
            elif data == 'sexor':
                self.console.say('^7Mmmmm %s^7.' % client.exactName)
            elif data == 'hate':
                self.console.say('^7Don\'t hate the player, %s^7, hate the game.' % client.exactName)
            elif data == 'smoke':
                self.console.say('^7b3 has been known to cause lung cancer when smoked %s^7.' % client.exactName)
            elif data == 'maul':
                self.console.say('^7b3 casts a spell of invisibility, you can\'t find  %s^7.' % client.exactName)
            elif data == 'procreate':
                self.console.say('^7b3 2.0 will soon be on the way %s^7.' % client.exactName)
            elif data == 'shoot':
                self.console.say('^7Your hit detection is off %s^7, b3 is unharmed.' % client.exactName)
            elif data == 'kick':
                client.kick('^7as requested', '', None)
            elif data == 'triangulate':
                self.console.say('^7b3 is at %s.' % self.console._publicIp)
        else:
            cmd.sayLoudOrPM(client, '%s ^7- uptime: [^2%s^7]' % (b3.version, functions.minutesStr(self.console.upTime() / 60.0)))

    def cmd_enable(self, data, client, cmd=None):
        """\
        <plugin> - enable a disabled plugin
        """
        data = data.strip().lower()

        if not data:
            client.message('^7You must supply a plugin name to enable.')
            return
        elif data == 'admin':
            client.message('^7You cannot disable/enable the admin plugin.')
            return

        plugin = self.console.getPlugin(data)
        if plugin:
            if plugin.isEnabled():
                client.message('^7Plugin %s is already enabled.' % data)
            else:
                plugin.enable()
                self.console.say('^7%s is now ^2ON' % plugin.__class__.__name__)
        else:
            client.message('^7No plugin named %s loaded.' % data)

    def cmd_disable(self, data, client, cmd=None):
        """\
        <plugin> - disable a plugin
        """
        data = data.strip().lower()

        if not data:
            client.message('^7You must supply a plugin name to disable.')
            return
        elif data == 'admin':
            client.message('^7You cannot disable/enable the admin plugin.')
            return

        plugin = self.console.getPlugin(data)
        if plugin:
            if not plugin.isEnabled():
                client.message('^7Plugin %s is already disable.' % data)
            else:
                plugin.disable()
                self.console.say('^7%s is now ^1OFF' % plugin.__class__.__name__)
        else:
            client.message('^7No plugin named %s loaded.' % data)

    def cmd_register(self, data, client, cmd=None):
        """\
        - register youself as a basic user
        """
        try:
            group = Group(keyword='user')
            group = self.console.storage.getGroup(group)
        except:
            return False

        if client.inGroup(group):
            client.message(self.getMessage('groups_already_in', client.exactName, group.name))
        elif client.maxLevel >= group.level:
            client.message('^7You are already in a higher level group')
        else:
            client.setGroup(group)
            client.save()

            self.console.say(self.getMessage('regme_annouce', client.exactName, group.name))
            return True

    def cmd_help(self, data, client, cmd=None):
        """\
        [<command|level>] - get info on how to use a command, you can use *<command> for partial matches
        """
        commands = []
        if re.match(r'^[0-9]+$', data):
            mlevel = int(data)
            for cmd in self._commands.values():
                if cmd.level is not None and cmd.level[0] == mlevel and cmd.canUse(client):
                    if cmd.command not in commands:
                        commands.append(cmd.command)
        elif data[:1] == '*':
            search = data[1:]
            for cmd in self._commands.values():
                if cmd.command.find(search) != -1 and cmd.canUse(client) and cmd.command not in commands:
                    if cmd.command not in commands:
                        commands.append(cmd.command)
        elif data:
            try:
                cmd = self._commands[data]
                if cmd.canUse(client):
                    cmd.sayLoudOrPM(client, self.getMessage('help_command', self.cmdPrefix, cmd.command, cmd.help))
            except KeyError:
                client.message(self.getMessage('help_no_command', data))
            return
        else:
            for c, cmd in self._commands.iteritems():
                if cmd.canUse(client):
                    if cmd.command not in commands:
                        commands.append(cmd.command)

        if not len(commands):
            cmd.sayLoudOrPM(client, self.getMessage('help_none'))
        else:
            # remove the !register command if already registered
            if 'register' in commands and int(client.maxLevel) > 0:
                commands.remove('register')
            commands.sort()
            cmd.sayLoudOrPM(client, self.getMessage('help_available', ', '.join(commands)))

    def cmd_list(self, data, client, cmd=None):
        """\
        - list all connected players
        """
        thread.start_new_thread(self.doList, (client, cmd))

    def doList(self, client, cmd):
        names = []
        for c in self.console.clients.getClientsByLevel():
            names.append(self.getMessage('player_id', c.name, c.cid))

        cmd.sayLoudOrPM(client, ', '.join(names))
        return True


    def cmd_regulars(self, data, client, cmd=None):
        """\
        - lists all the online regular players
        """
        clist = self.getRegulars()

        if len(clist) > 0:
            nlist = []
            for c in clist:
                nlist.append(c.exactName)
            cmd.sayLoudOrPM(client, self.getMessage('regulars', ', '.join([c.exactName for c in clist])))
        else:
            cmd.sayLoudOrPM(client, self.getMessage('no_regulars'))


    def cmd_admins(self, data, client, cmd=None):
        """\
        - lists all the online admins
        """
        self.debug('trying to get admins')
        clist = self.getAdmins()

        if len(clist) > 0:
            nlist = []
            for c in clist:
                if c.maskGroup:
                    nlist.append('%s^7 [^3%s^7]' % (c.exactName, c.maskGroup.level))
                else:
                    nlist.append('%s^7 [^3%s^7]' % (c.exactName, c.maxLevel))

            cmd.sayLoudOrPM(client, self.getMessage('admins', ', '.join(nlist)))
        else:
            self.debug('no admins found')
            cmd.sayLoudOrPM(client, 'There are no admins online')

    def cmd_rebuild(self, data, client, cmd=None):
        """\
        - sync up connected players
        """
        self.console.clients.sync()
        client.message('Synchronizing client info')

    def cmd_regtest(self, cid, client, cmd=None):
        """\
        - display your current user status
        """

        if client and client.maskGroup:
            cmd.sayLoudOrPM(client, self.getMessage('leveltest', client.exactName, client.id, client.maskGroup.name, client.maskGroup.level, self.console.formatTime(client.timeAdd)))
        elif client and client.maxGroup:
            cmd.sayLoudOrPM(client, self.getMessage('leveltest', client.exactName, client.id, client.maxGroup.name, client.maxLevel, self.console.formatTime(client.timeAdd)))
        else:
            cmd.sayLoudOrPM(client, self.getMessage('leveltest', client.exactName, client.id, 'no groups', 0, self.console.formatTime(client.timeAdd)))

        return True

    def cmd_admintest(self, cid, client, cmd=None):
        """\
        - display your current user status
        """
        return self.cmd_regtest(cid, client, cmd)

    def cmd_leveltest(self, data, client, cmd=None):
        """\
        [<name>] - display a user's status
        """
        m = self.parseUserCmd(data)
        if m:
            sclient = self.findClientPrompt(m[0], client)
        else:
            sclient = client
        if sclient:
            if m and sclient.maskGroup:
                cmd.sayLoudOrPM(client, self.getMessage('leveltest', sclient.exactName, sclient.id, sclient.maskGroup.name, sclient.maskGroup.level, self.console.formatTime(sclient.timeAdd)))
            elif not sclient.maxGroup:
                cmd.sayLoudOrPM(client, self.getMessage('leveltest_nogroups', sclient.exactName, sclient.id))
            else:
                cmd.sayLoudOrPM(client, self.getMessage('leveltest', sclient.exactName, sclient.id, sclient.maxGroup.name, sclient.maxLevel, self.console.formatTime(sclient.timeAdd)))
        return True


    def cmd_makereg(self, data, client, cmd=None):
        """\
        <name> - make a name a regular
        """

        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid = m[0]

        try:
            group = Group(keyword='reg')
            group = self.console.storage.getGroup(group)
        except:
            client.message('^7Group reg does not exist')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.inGroup(group):
                client.message(self.getMessage('groups_already_in', sclient.exactName, group.name))
            elif sclient.maxLevel >= group.level:
                client.message('^7%s ^7is already in a higher level group' % sclient.exactName)
            else:
                sclient.setGroup(group)
                sclient.save()

                cmd.sayLoudOrPM(client, self.getMessage('groups_put', sclient.exactName, group.name))
                return True

    def cmd_unreg(self, data, client, cmd=None):
        """\
        <name> - remove a player from the 'regular' group
        """

        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid = m[0]

        try:
            group_reg = self.console.storage.getGroup(Group(keyword='reg'))
        except Exception, err:
            self.debug(err)
            client.message("^7Group 'regular' does not exist")
            return

        try:
            group_user = self.console.storage.getGroup(Group(keyword='user'))
        except Exception, err:
            self.debug(err)
            client.message("^7Group 'user' does not exist")
            return

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.inGroup(group_reg):
                sclient.remGroup(group_reg)
                sclient.setGroup(group_user)
                sclient.save()
                cmd.sayLoudOrPM(client, '^7%s^7 removed from group %s' % (sclient.exactName, group_reg.name))
            else:
                client.message('^7%s^7 is not in group %s' % (sclient.exactName, group_reg.name))

    def cmd_putgroup(self, data, client, cmd=None):
        """\
        <client> <group> - add a client to a group
        """
        m = re.match('^(.{2,}) ([a-z0-9]+)$', data, re.I)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m.groups()

        try:
            group = Group(keyword=keyword)
            group = self.console.storage.getGroup(group)
        except:
            client.message('^7Group %s does not exist' % keyword)
            return False

        if group.level >= client.maxLevel and client.maxLevel < 100:
            client.message('^7Group %s is beyond your reach' % group.name)
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.inGroup(group):
                client.message(self.getMessage('groups_already_in', sclient.exactName, group.name))
            else:
                sclient.setGroup(group)
                sclient.save()

                cmd.sayLoudOrPM(client, self.getMessage('groups_put', sclient.exactName, group.name))
                return True

    def cmd_say(self, data, client, cmd=None):
        """\
        - say a message to all players
        """
        self.console.say(self.getMessage('say', client.exactName, data))
        return True

    def cmd_ungroup(self, cid, client, cmd=None):
        """\
        <client> <group> - remove a client from a group
        """
        m = re.match('^([^ ]{2,}) ([a-z]+)$', cid)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m.groups()

        try:
            group = Group(keyword=keyword)
            group = self.console.storage.getGroup(group)
        except KeyError:
            client.message('^7Group %s does not exist' % keyword)
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.inGroup(group):
                sclient.remGroup(group)
                sclient.save()

                cmd.sayLoudOrPM(client, '^7%s^7 removed from group %s' % (sclient.exactName, group.name))
                return True
            else:
                client.message('^7%s^7 is not in group %s' % (sclient.exactName, group.name))


    def cmd_iamgod(self, data, client, cmd=None):
        """\
        - register yourself as the super admin
        """
        superadmins = self.console.clients.lookupSuperAdmins()
        if len(superadmins) > 0:
            # There are already superadmins, disable this command
            self.warning('%s superadmin(s) found in db. Disabling command' % len(superadmins))
            if self._commands.has_key('iamgod'):
                self._commands.pop('iamgod')
            return

        try:
            group = Group(keyword='superadmin')
            group = self.console.storage.getGroup(group)
        except Exception, e:
            self.error('^7Could not get superadmin group: %s', e)
            return False

        try:
            command = self._commands['iamgod']
        except:
            self.error('iamgod command not found')
            return False
        else:
            command.level = 'none'

            if group in client.groups:
                client.message('^7You are already a %s' % group.exactName)
                return True

            client.setGroup(group)
            client.save()

            client.message('^7You are now a %s' % group.name)

            self.bot('^7Created %s %s - %s', group.name, client.name, client.guid)

            return True

    def cmd_time(self, data, client=None, cmd=None):
        """\
        [<timezone/offset>] - display the servers current time
        """
        cmd.sayLoudOrPM(client, self.getMessage('time', self.console.formatTime(time.time(), data)))

        return True

    def cmd_seen(self, data, client=None, cmd=None):
        """\
        <name> - when was a player last seen?
        """

        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        data = m[0]

        clients = self.console.clients.lookupByName(data)

        if len(clients) == 0:
            client.message(self.getMessage('no_players', data))
        else:
            for c in clients:
                cmd.sayLoudOrPM(client, self.getMessage('seen', c.exactName, self.console.formatTime(c.timeEdit)))

        return True

    def cmd_lookup(self, data, client=None, cmd=None):
        """\
        <name> - lookup a player in the database
        """

        if not self.console.storage.status():
            cmd.sayLoudOrPM(client, '^7Cannot lookup, database appears to be ^1DOWN')
            return

        m = re.match('^(.{1,})$', data)
        if not m:
            client.message('^7Invalid parameters')
            return False


        clients = self.console.clients.lookupByName(data)

        if len(clients) == 0:
            client.message(self.getMessage('no_players', data))
        else:
            for c in clients:
                cmd.sayLoudOrPM(client, self.getMessage('lookup_found', c.id, c.exactName, self.console.formatTime(c.timeEdit)))

        return True

    def cmd_status(self, data, client=None, cmd=None):
        """\
        - Report status of bot
        """
        if self.console.storage.status():
            cmd.sayLoudOrPM(client, '^7Database appears to be ^2UP')
        else:
            cmd.sayLoudOrPM(client, '^7Database appears to be ^1DOWN')

    def cmd_scream(self, data, client=None, cmd=None):
        """\
        <message> - yell a message to all player
        """
        thread.start_new_thread(self.sayMany, (data, 5, 1))

    def sayMany(self, msg, times=5, delay=1):
        for c in range(1,times + 1):
            self.console.say('^%i%s' % (c, msg))
            time.sleep(delay)

    def cmd_find(self, data, client=None, cmd=None):
        """\
        <name> - test to find a connected player
        """

        m = self.parseUserCmd(data)

        if not m:
            client.message('^7Invalid parameters')
            return False

        cid = m[0]
        sclient = self.findClientPrompt(cid, client)

        if sclient:
            cmd.sayLoudOrPM(client, '^7Found player matching %s [^2%s^7] %s' % (cid, sclient.cid, sclient.exactName))

    def cmd_clientinfo(self, data, client=None, cmd=None):
        """\
        <name> <field> - get info about a client
        """
        m = self.parseUserCmd(data, True)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, field = m

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            try:
                cmd.sayLoudOrPM(client, '%s^7: %s^7 is %s' % (sclient.exactName, field, getattr(sclient, field)))
            except:
                client.message('^7Unrecognized field %s' % field)

    def cmd_kick(self, data, client=None, cmd=None):
        """\
        <name> [<reason>] - kick a player
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.cid == client.cid:
                self.console.say(self.getMessage('kick_self', client.exactName))
                return True
            elif sclient.maxLevel >= client.maxLevel:
                if sclient.maskGroup:
                    client.message('^7%s ^7is a masked higher level player, can\'t kick' % sclient.exactName)
                else:
                    self.console.say(self.getMessage('kick_denied', sclient.exactName, client.exactName, sclient.exactName))
                return True
            else:
                sclient.kick(reason, keyword, client)
                return True
        elif re.match('^[0-9]+$', cid):
            # failsafe, do a manual client id ban
            self.console.kick(cid, reason, client)

    def cmd_kickall(self, data, client=None, cmd=None):
        """\
        <pattern> [<reason>] - kick all players matching <pattern>
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        matches = self.console.clients.getByMagic(cid)
        for sclient in matches:
            if sclient.cid == client.cid:
                continue
            elif sclient.maxLevel >= client.maxLevel:
                continue
            else:
                sclient.kick(reason, keyword, client)

    def cmd_spank(self, data, client=None, cmd=None):
        """\
        <name> [<reason>] - spank a player, naughty boy!
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.cid == client.cid:
                self.console.say(self.getMessage('kick_self', client.exactName))
                return True
            elif sclient.maxLevel >= client.maxLevel:
                if sclient.maskGroup:
                    client.message('^7%s ^7is a masked higher level player, can\'t spank' % sclient.exactName)
                else:
                    self.console.say(self.getMessage('kick_denied', sclient.exactName, client.exactName, sclient.exactName))
                return True
            else:
                if reason:
                    self.console.say(self.getMessage('spanked_reason', sclient.exactName, client.exactName, reason))
                else:
                    self.console.say(self.getMessage('spanked', sclient.exactName, client.exactName))
                sclient.kick(reason, keyword, client, silent=True)
                return True
        elif re.match('^[0-9]+$', cid):
            # failsafe, do a manual client id ban
            self.console.kick(cid, reason, client)

    def cmd_spankall(self, data, client=None, cmd=None):
        """\
        <pattern> [<reason>] - kick all players matching <pattern>
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        matches = self.console.clients.getByMagic(cid)
        for sclient in matches:
            if sclient.cid == client.cid:
                continue
            elif sclient.maxLevel >= client.maxLevel:
                continue
            else:
                if reason:
                    self.console.say(self.getMessage('spanked_reason', sclient.exactName, client.exactName, reason))
                else:
                    self.console.say(self.getMessage('spanked', sclient.exactName, client.exactName))
                sclient.kick(reason, keyword, client, silent=True)

    def cmd_permban(self, data, client=None, cmd=None):
        """\
        <name> [<reason>] - ban a player permanently
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.cid == client.cid:
                self.console.say(self.getMessage('ban_self', client.exactName))
                return True
            elif sclient.maxLevel >= client.maxLevel:
                if sclient.maskGroup:
                    client.message('^7%s ^7is a masked higher level player, can\'t ban' % sclient.exactName)
                else:
                    self.console.say(self.getMessage('ban_denied', client.exactName, sclient.exactName))
                return True
            else:
                sclient.groupBits = 0
                sclient.save()

                sclient.ban(reason, keyword, client)
                return True
        elif re.match('^[0-9]+$', cid):
            # failsafe, do a manual client id ban
            self.console.ban(cid, reason, client)

    def cmd_ban(self, data, client=None, cmd=None):
        """\
        <name> [<reason>] - ban a player
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.cid == client.cid:
                self.console.say(self.getMessage('ban_self', client.exactName))
                return True
            elif sclient.maxLevel >= client.maxLevel:
                if sclient.maskGroup:
                    client.message('^7%s ^7is a masked higher level player, can\'t ban' % client.exactName)
                else:
                    self.console.say(self.getMessage('ban_denied', client.exactName, sclient.exactName))
                return True
            else:
                sclient.groupBits = 0
                sclient.save()

                duration = self.config.getDuration('settings', 'ban_duration')
                sclient.tempban(reason, keyword, duration, client)
                return True
        elif re.match('^[0-9]+$', cid):
            # failsafe, do a manual client id ban
            duration = self.config.getDuration('settings', 'ban_duration')
            self.console.tempban(cid, reason, duration, client)

    def cmd_banall(self, data, client=None, cmd=None):
        """\
        <pattern> [<reason>] - ban all players matching <pattern>
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False

        duration = self.config.getDuration('settings', 'ban_duration')
        matches = self.console.clients.getByMagic(cid)
        for sclient in matches:
            if sclient.cid == client.cid:
                continue
            elif sclient.maxLevel >= client.maxLevel:
                continue
            else:
                sclient.tempban(reason, keyword, duration, client)

    def cmd_lastbans(self, data, client=None, cmd=None):
        """\
        list the 5 last bans
        """
        def format_ban(penalty):
            c = self.console.storage.getClient(Client(_id=penalty.clientId))
            txt = "^2@%s^7 %s^7" % (penalty.clientId, c.exactName)
            if penalty.type == 'Ban':
                txt += ' (Perm)'
            elif penalty.type == 'TempBan':
                txt += ' (%s remaining)' % minutesStr((penalty.timeExpire - self.console.time()) / 60.0)
            else:
                raise AssertionError("unexpected penalty type : %r" % penalty.type)
            if penalty.reason:
                txt += ' %s' % penalty.reason
            return txt

        bans = self.console.storage.getLastPenalties(types=('Ban', 'TempBan'), num=5)
        if len(bans):
            for line in map(format_ban, bans):
                cmd.sayLoudOrPM(client, line)
        else:
            cmd.sayLoudOrPM(client, '^7There are no active bans')

    def cmd_baninfo(self, data, client=None, cmd=None):
        """\
        <name> - display how many bans a user has
        """

        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        sclient = self.findClientPrompt(m[0], client)
        if sclient:
            bans = sclient.numBans
            if bans:
                cmd.sayLoudOrPM(client, '^7%s ^7has %s active bans' % (sclient.exactName, bans))
            else:
                cmd.sayLoudOrPM(client, '^7%s ^7has no active bans' % sclient.exactName)

    def cmd_runas(self, data, client=None, cmd=None):
        """\
        <name> <command> - run a command as a different user
        """

        m = self.parseUserCmd(data)
        if not m or m[1] == '':
            client.message('^7Invalid parameters')
            return False

        sclient = self.findClientPrompt(m[0], client)
        if sclient:
            self.OnSay(self.console.getEvent('EVT_CLIENT_SAY', m[1], sclient))

    def cmd_unban(self, data, client=None, cmd=None):
        """\
        <name> - un-ban a player
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, reason = m
        reason = self.getReason(reason)

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            for w in sclient.bans:
                if w.adminId:
                    try:
                        admin = self.console.storage.getClient(Client(id=w.adminId))
                        if admin.maxLevel > client.maxLevel:
                            client.message('^7You can not clear a ban from ' % admin.exactName)
                            return
                    except:
                        pass

            sclient.unban(reason, client)

    def cmd_aliases(self, data, client=None, cmd=None):
        """\
        <name> - list a players aliases
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid = m[0]

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.maskGroup:
                cmd.sayLoudOrPM(client, '^7%s^7 has no aliases' % sclient.exactName)
            else:
                myaliases = []
                for a in sclient.aliases:
                    myaliases.append('%s^7' % a.alias)
                    if len(myaliases) > 10:
                        myaliases.append('^7[^2and more^7]')
                        break

                if len(myaliases):
                    cmd.sayLoudOrPM(client, self.getMessage('aliases', sclient.exactName, ', '.join(myaliases)))
                else:
                    cmd.sayLoudOrPM(client, '^7%s^7 has no aliases' % sclient.exactName)

    def cmd_warns(self, data, client=None, cmd=None):
        """\
        - list warnings
        """
        client.message('^7Warnings: %s' % ', '.join(sorted([ x for x in self.warn_reasons.keys() if x not in ('default', 'generic')])))

    def cmd_notice(self, data, client=None, cmd=None):
        """\
        <name> <notice> - Add a good/bad behavior note for the player
        """
        m = self.parseUserCmd(data)
        if not m or m[0] == '' or m[1] == '':
            client.message('^7Invalid parameters')
            return False

        cid, notice = m
        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.maxLevel >= client.maxLevel:
                client.message('^7Can not add notice to higher level admin %s' % sclient.exactName)
            else:
                sclient.notice(notice, None, client)
                client.message('^7Notice %s added to %s' % (notice, sclient.exactName))

    def cmd_warn(self, data, client=None, cmd=None):
        """\
        <name> [<warning>] - warn user
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid, keyword = m
        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.id == client.id:
                client.message(self.getMessage('warn_self', client.exactName))
            elif sclient.maxLevel >= client.maxLevel:
                client.message(self.getMessage('warn_denied', client.exactName, sclient.exactName))
            else:
                if sclient.var(self, 'warnTime').toInt() > self.console.time() - self.config.getint('warn', 'warn_delay'):
                    client.message('^7Only one warning per %s seconds can be issued' % self.config.getint('warn', 'warn_delay'))
                    return False

                self.warnClient(sclient, keyword, client)

    def penalizeClient(self, type, client, reason, keyword=None, duration=0, admin=None, data=''):
        if reason == None:
            reason = self.getReason(keyword)

        duration = functions.time2minutes(duration)

        if type == self.PENALTY_KICK:
            client.kick(reason, keyword, admin, False, data)
        elif type == self.PENALTY_TEMPBAN:
            client.tempban(reason, keyword, duration, admin, False, data)
        elif type == self.PENALTY_BAN:
            client.ban(reason, keyword, admin, False, data)
        elif type == self.PENALTY_WARNING:
            self.warnClient(client, keyword, admin, True, data, duration)
        else:
            if self.console.inflictCustomPenalty(type, client=client, reason=reason, duration=duration, admin=admin, data=data) is not True:
                self.error('penalizeClient(): type %s not found', type)

    def warnClient(self, sclient, keyword, admin=None, timer=True, data='', newDuration=None):
        try:
            duration, warning = self.getWarning(keyword)
        except:
            duration, warning = self.getWarning('generic')
            warning = '%s %s' % (warning, keyword)

        if newDuration:
            duration = newDuration

        warnRecord = sclient.warn(duration, warning, keyword, admin, data)
        warning = sclient.exactName + '^7, ' + warning

        if timer:
            sclient.setvar(self, 'warnTime', self.console.time())

        warnings = sclient.numWarnings
        try:
            pmglobal = self.config.get('warn', 'pm_global')
        except NoOptionError:
            pmglobal = '0'
        if pmglobal == '1':
            msg = self.config.getTextTemplate('warn', 'message', warnings=warnings, reason=warning)
            sclient.message(msg)
            if admin:
                admin.message(msg)
        else:
            self.console.say(self.config.getTextTemplate('warn', 'message', warnings=warnings, reason=warning))
        if warnings >= self.config.getint('warn', 'instant_kick_num'):
            self.warnKick(sclient, admin)
        elif warnings >= self.config.getint('warn', 'alert_kick_num'):
            duration = functions.minutesStr(self.warnKickDuration(sclient))

            warn = sclient.lastWarning
            if warn:
                self.console.say(self.config.getTextTemplate('warn', 'alert', name=sclient.exactName, warnings=warnings, duration=duration, reason=warn.reason))
            else:
                self.console.say(self.config.getTextTemplate('warn', 'alert', name=sclient.exactName, warnings=warnings, duration=duration, reason='Too many warnings'))

            sclient.setvar(self, 'checkWarn', True)
            t = threading.Timer(25, self.checkWarnKick, (sclient, admin, data))
            t.start()

        return warnRecord


    def checkWarnKick(self, sclient, client=None, data=''):
        if not sclient.var(self, 'checkWarn').value:
            return

        sclient.setvar(self, 'checkWarn', False)

        kick_num = self.config.getint('warn', 'alert_kick_num')
        warnings = sclient.numWarnings
        if warnings >= kick_num:
            self.warnKick(sclient, client, data)

    def warnKickDuration(self, sclient):
        if sclient.numWarnings > self.config.getint('warn', 'tempban_num'):
            duration = self.config.getDuration('warn', 'tempban_duration')
        else:
            duration = 0
            for w in sclient.warnings:
                duration += w.duration * 60
            duration = (duration / self.config.getint('warn', 'duration_divider')) / 60

            maxDuration = self.config.getDuration('warn', 'max_duration')
            if duration > maxDuration:
                duration = maxDuration

        return duration

    def warnKick(self, sclient, client=None, data=''):
        msg = sclient.numWarnings
        keyword = ''
        warn = sclient.lastWarning
        if warn:
            msg = warn.reason
            keyword = warn.keyword

        duration = self.warnKickDuration(sclient)

        if duration > 0:
            if 300 <= duration <= 600:
                msg = '^3peeing ^7in the gene pool'

            sclient.tempban(self.config.getTextTemplate('warn', 'reason', reason=msg), keyword, duration, client, False, data)

    def cmd_warntest(self, data, client=None, cmd=None):
        """\
        <warning> - test a warning
        """
        try:
            duration, warning = self.getWarning(data)
        except:
            duration, warning = self.getWarning('generic')
            warning = '%s %s' % (warning, data)

        warning = warning % { 'name' : client.exactName }

        client.message('^2TEST: %s' % self.config.getTextTemplate('warn', 'message', warnings=1, reason=warning))

        return True

    def cmd_warnremove(self, data, client=None, cmd=None):
        """\
        <name> - remove a users last warning
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        sclient = self.findClientPrompt(m[0], client)
        if sclient:
            w = sclient.lastWarning
            if not sclient.numWarnings or not w:
                client.message('^7No warnings found for %s' % sclient.exactName)
                return

            if w.adminId:
                try:
                    admin = self.console.storage.getClient(Client(id=w.adminId))
                    if admin.maxLevel > client.maxLevel:
                        client.message('^7You can not clear a warning from %s' % admin.exactName)
                    return
                except:
                    pass

            w.inactive = 1
            self.console.storage.setClientPenalty(w)

            cmd.sayLoudOrPM(client, '%s ^7last warning cleared: ^3%s' % (sclient.exactName, w.reason))

    def cmd_warnclear(self, data, client=None, cmd=None):
        """\
        <name> - clear all of a users warnings
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        sclient = self.findClientPrompt(m[0], client)
        if sclient:
            if not sclient.numWarnings:
                client.message('^7No warnings found for %s' % sclient.exactName)
                return

            cleared = 0
            failed = 0
            for w in sclient.warnings:
                if w.adminId:
                    try:
                        admin = self.console.storage.getClient(Client(id=w.adminId))
                        if admin.maxLevel > client.maxLevel:
                            failed += 1
                        break
                    except:
                        pass

                cleared += 1
                w.inactive = 1
                self.console.storage.setClientPenalty(w)

            if failed and cleared:
                cmd.sayLoudOrPM(client, '^7Cleared ^3%s ^7warnings and left ^3%s ^7warnings for %s' % (failed, cleared, sclient.exactName))
            elif failed:
                client.message('^7Could not clear ^3%s ^7warnings for %s' % (failed, sclient.exactName))
            else:
                self.console.say('^7All warnings cleared for %s' % sclient.exactName)

    def cmd_warninfo(self, data, client=None, cmd=None):
        """\
        <name> - display how many warning points a user has
        """
        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        sclient = self.findClientPrompt(m[0], client)
        if sclient:
            warns = sclient.numWarnings

            if warns:
                msg = ''
                warn = sclient.firstWarning
                if warn:
                    expire = functions.minutesStr((warn.timeExpire - (self.console.time())) / 60)
                    msg = ', expires in ^2%s' % expire

                warn = sclient.lastWarning
                if warn:
                    msg += '^7: ^3%s' % warn.reason

                message = '^7%s ^7has ^1%s ^7active warnings%s' % (sclient.exactName, warns, msg)
            else:
                message = '^7%s ^7has no active warnings' % sclient.exactName

            cmd.sayLoudOrPM(client, message)

    def cmd_maps(self, data, client=None, cmd=None):
        """\
        - list the server's map rotation
        """
        if not self.aquireCmdLock(cmd, client, 60, True):
            client.message('^7Do not spam commands')
            return

        maps = self.console.getMaps()
        if maps is None:
            client.message('^7Error: could not get map list')
        elif len(maps):
            cmd.sayLoudOrPM(client, '^7Map Rotation: ^2%s' % '^7, ^2'.join(maps))
        else:
            cmd.sayLoudOrPM(client, '^7Map Rotation list is empty')

    def cmd_nextmap(self, data, client=None, cmd=None):
        """\
        - list the next map in rotation
        """
        if not self.aquireCmdLock(cmd, client, 60, True):
            client.message('^7Do not spam commands')
            return

        mapname = self.console.getNextMap()
        if mapname:
            cmd.sayLoudOrPM(client, '^7Next Map: ^2%s' % mapname)
        else:
            client.message('^7Error: could not get map list')

    def cmd_pause(self, data, client=None, cmd=None):
        """\
        <duration> - pause the bot from parsing
        """
        m = re.match('^([0-9]+[a-z]*)$', data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        duration = functions.time2minutes(data)

        self.console.say('^7Sleeping for %s' % functions.minutesStr(duration))
        unpause_task = threading.Timer(duration * 60, self.console.unpause)
        unpause_task.daemon = True # won't block the bot in case of shutdown
        self.console.pause()
        unpause_task.start()

    def cmd_spam(self, data, client=None, cmd=None):
        """\
        <message> - spam a predefined message
        """
        m = re.match('^([^ ]{2,})$', data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        keyword = m.group(1)
        s = self.getSpam(keyword)
        if s:
            self.console.say(s)
        else:
            client.message('^7Could not find spam message %s' % keyword)

    def cmd_rules(self, data, client=None, cmd=None):
        """\
        - say the rules
        """
        if not self.aquireCmdLock(cmd, client, 60, True):
            client.message('^7Do not spam commands')
            return

        m = self.parseUserCmd(data)
        if m:
            if client.maxLevel >= self._admins_level:
                sclient = self.findClientPrompt(m[0], client)
                if not sclient:
                    return

                if sclient.maxLevel >= client.maxLevel:
                    client.message('%s ^7already knows the rules' % sclient.exactName)
                    return
                else:
                    client.message('^7Sir, Yes Sir!, spamming rules to %s' % sclient.exactName)
            else:
                client.message('^7Stop trying to spam other players')
                return
        elif cmd.loud or cmd.big:
            thread.start_new_thread(self._sendRules, (), {'sclient':None, 'big':cmd.big})
            return
        else:
            sclient = client

        thread.start_new_thread(self._sendRules, (), {'sclient': sclient})

    def _sendRules(self, sclient, big=False):
        rules = []

        for i in range(1, 20):
            try:
                rule = self.config.getTextTemplate('spamages', 'rule%s' % i)
                rules.append(rule)
            except NoOptionError:
                break
            except Exception, err:
                self.error(err)
        try:
            if sclient:
                for rule in rules:
                    sclient.message(rule)
                    time.sleep(1)
            else:
                for rule in rules:
                    if big:
                        self.console.saybig(rule)
                    else:
                        self.console.say(rule)
                    time.sleep(1)
        except Exception, err:
            self.error(err)

    def cmd_spams(self, data, client=None, cmd=None):
        """\
        - list spam messages
        """
        ws = []
        for w in self.config.options('spamages'):
            ws.append(w)

        client.message('^7Spamages: %s' % ', '.join(ws))

    def cmd_tempban(self, data, client=None, cmd=None):
        """\
        <name> <duration> [<reason>] - temporarily ban a player
        """
        m = self.parseUserCmd(data)

        if not m or not m[1]:
            client.message('^7Invalid parameters')
            return False

        cid = m[0]
        m = re.match('^([0-9]+[dwhsm]*)(?:\s(.+))?$', m[1], re.I)
        if not m:
            client.message('^7Invalid parameters')
            return False

        duration, keyword = m.groups()
        duration = functions.time2minutes(duration)
        #    10/05/2008 - 1.3.4b0 - mindriot
        #      * Removed hard code of 1 day for long_tempban_level - now controlled with new setting 'long_tempban_max_duration'
        try:
            long_tempban_max_duration = self.config.getDuration('settings', 'long_tempban_max_duration')
        except NoOptionError:
            long_tempban_max_duration = self._long_tempban_max_duration
            self.debug('Using default value (%s) for long_tempban_max_duration', self._long_tempban_max_duration)

        if client.maxLevel < self._long_tempban_level and duration > long_tempban_max_duration:
            # temp ban for maximum specified in settings
            duration = long_tempban_max_duration

        
        reason = self.getReason(keyword)

        if not reason and client.maxLevel < self._noreason_level:
            client.message('^1ERROR: ^7You must supply a reason')
            return False
        elif not duration:
            client.message('^7You must supply a duration to ban for')
            return False

        sclient = self.findClientPrompt(cid, client)
        if sclient:
            if sclient.cid == client.cid:
                self.console.say(self.getMessage('temp_ban_self', client.exactName))
                return True
            elif sclient.maxLevel >= client.maxLevel:
                if sclient.maskGroup:
                    client.message('^7%s ^7is a masked higher level player, can\'t temp ban' % sclient.exactName)
                else:
                    self.console.say(self.getMessage('temp_ban_denied', client.exactName, sclient.exactName))
                return True
            else:
                sclient.tempban(reason, keyword, duration, client)
                return True
        elif re.match('^[0-9]+$', cid):
            # failsafe, do a manual client id ban
            self.console.tempban(cid, reason, duration, client)

    def cmd_poke(self, data, client=None, cmd=None):
        """\
        <player> - Notify a player that he needs to move
        """

        m = self.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters, you must supply a player name')
            return False

        if m[0] == 'b3':
            self.warnClient(client, 'Do not poke b3!', None, False, '', 1)
        else:
            sclient = self.findClientPrompt(m[0], client)
            if sclient:
                self.console.say('^7%s %s^7!' % (random.choice(('Wake up', '*poke*', 'Attention', 'Get up', 'Go', 'Move out')), sclient.exactName))


    def load_config_warn_reasons(self):
        """ load section 'warn_reasons' from config """

        re_valid_warn_reason_value_from_config = re.compile(r"""
                ^
                (?:
                    \s*
                    \d+[smhdw]?         # a duration with one of the optional allowed time suffixes
                    ,\s*                # followed by a comma

                    (?:                 # followed by either
                        (?=/spam\#)/spam\#[^/\s]+   # '/spam#' followed by a keyword
                    |                               # or
                        (?!/spam\#)[^\s].*          # not '/spam#' and anything
                    )
                |

                   /                    # anything that starts with '/'
                   (?!spam\#)           # but is not followed by 'spam#'
                   [^/\s]+              # followed by at least a non blank and non '/' character
                )
                $
                """, re.VERBOSE)

        def load_warn_reason(keyword, reason_from_config):
                if re.match(re_valid_warn_reason_value_from_config, reason_from_config) is None:
                    self.warning("""warn_reason '%s': invalid value "%s". Expected format is : "<duration>, <reason or /spam# """
                    """followed by a reference to a spamage keyword>" or '/' followed by a reference to another warn_reason"""
                    % (keyword, reason_from_config))
                    return

                if reason_from_config[:1] == '/':
                    try:
                        reason = self.config.getTextTemplate('warn_reasons', reason_from_config[1:])
                    except NoOptionError:
                        self.warning("warn_reason '%s' refers to '/%s' but warn_reason '%s' cannot be found" % (keyword, reason_from_config[1:], reason_from_config[1:]))
                        return
                    except Exception, err:
                        self.error("warn_reason '%s' refers to '/%s' but '%s' could not be read : %s" % (keyword, reason_from_config[1:], reason_from_config[1:], err), err)
                        return

                    if reason[:1] == '/':
                        self.warning("warn_reason '%s': Possible recursion %s, %s" % (keyword, reason, reason_from_config[1:]))
                        return
                else:
                    reason = reason_from_config

                expire, reason = reason.split(',', 1)
                reason = reason.strip()

                if reason[:6] == '/spam#':
                    spam_reason = self.getSpam(reason[6:])
                    if spam_reason is None:
                        self.warning("warn_reason '%s' refers to '/spam#%s' but spamage '%s' cannot be found" % (keyword, reason[6:], reason[6:]))
                        return
                    else:
                        reason = spam_reason

                return functions.time2minutes(expire.strip()), reason



        def load_mandatory_warn_reason(keyword, default_duration, default_reason):
            if self.config.has_option('warn_reasons', keyword):
                self.warn_reasons[keyword] = load_warn_reason(keyword, self.config.getTextTemplate('warn_reasons', keyword))
            if not keyword in self.warn_reasons or self.warn_reasons[keyword] is None:
                self.warning("No valid option '%s' in section 'warn_reasons'. Falling back on default value" % keyword)
                self.warn_reasons[keyword] = functions.time2minutes(default_duration), default_reason
            self.info("warn reason '%s' : %s" % (keyword, self.warn_reasons[keyword]))

        self.info("------ loading warn_reasons from config file ------")
        self.warn_reasons = {}
        load_mandatory_warn_reason('default', "1h", "^7behave yourself")
        load_mandatory_warn_reason('generic', "1h", "^7")
        if self.config.has_section('warn_reasons'):
            for keyword, value in self.config.items('warn_reasons'):
                rv = load_warn_reason(keyword, value)
                if rv is not None:
                    self.warn_reasons[keyword] = rv
        for keyword, (duration, reason) in self.warn_reasons.items():
            self.info("""{0:<10s} {1:<10s}\t"{2}" """.format(keyword, functions.minutesStr(duration), reason))
        self.info("-------------- warn_reasons loaded ----------------")




#--------------------------------------------------------------------------------------------------
#commandstxt = file('commands.txt', 'w')
class Command:
    command  = ''
    help     = ''
    level    = 0
    secretLevel = 0
    func     = None
    alias    = ''
    plugin = None
    time = 0
    prefix = '!'
    prefixLoud = '@'
    prefixBig = '&'

    PLAYER_DATA = re.compile(r'^([\w\d\s-]+|@\d+|\d+)$', re.I)
    _reType = type(re.compile('.*'))

    def __init__(self, plugin, cmd, level, func, help=None, alias=None, secretLevel=100):
        self.command = cmd.strip()
        self.func = func
        self.plugin = plugin
        self.loud = False
        self.big = False

        if help:
            self.help = help.strip()
        if alias:
            self.alias = alias.strip()

        level = str(level)
        if level.lower() == 'none':
            self.level = None
        elif level.count('-') == 1:
            level = level.split('-', 1)
            self.level = (int(level[0]), int(level[1]))
        else:
            self.level = (int(level), 100)

        if secretLevel is None:
            self.secretLevel = 100

        #global commandstxt
        #commandstxt.write('%s (%s) %s, levels %s - %s\n' % (self.command, self.alias, self.help, self.level[0], self.level[1]))
        #commandstxt.flush()

    def canUse(self, client):
        if self.level is None:
            return False
        else:
            return self.level[0] <= int(client.maxLevel) <= self.level[1]

    def execute(self, data, client):
        self.func(data, client, copy.copy(self))
        self.time = self.plugin.console.time()

    def executeLoud(self, data, client):
        cmd = copy.copy(self)
        cmd.loud = True
        self.func(data, client, cmd)
        self.time = self.plugin.console.time()
    
    def executeBig(self, data, client):
        cmd = copy.copy(self)
        cmd.big = True
        self.func(data, client, cmd)
        self.time = self.plugin.console.time()

    def sayLoudOrPM(self, client, message):
        if self.loud:
            self.plugin.console.say(message)
        elif self.big:
            self.plugin.console.saybig(message)
        else:
            client.message(message)

    def parseData(self, data, *args):
        _p = self.splitData(data)

        if not len(args):
            return _p

        params = {}

        i = 0
        for i in range(0, min(len(args), len(_p))):
            params[args[i][0]] = _p[i]

        if len(_p) > i:
            params[args[i][0]] = ' '.join(_p[i:])

        badfield = None
        valid = True
        for a in args:
            if (not params.has_key(a[0]) or len(params[a[0]]) == 0):
                if len(a) == 3:
                    # set the default
                    params[a[0]] = a[2]
                else:
                    badfield = a[0]
                    valid = False
                    break

            if len(a) > 1:
                if type(a[1]) == self._reType:
                    # see if it matches regexp
                    valid = re.match(a[1], params[a[0]])

                    if not valid:
                        badfield = a[0]
                else:
                    # see if it can be converted to type
                    try:
                        params[a[0]] = a[1](params[a[0]])
                    except:
                        badfield = a[0]
                        valid = False

        if valid:
            return (params, None)
        else:
            help = ['^1Input Error! ^7Example: ']
            if self.loud:
                help.append('%s%s' % (self.prefixLoud, self.command))
            else:
                help.append('%s%s' % (self.prefix, self.command))

            for a in args:
                if len(a) == 3:
                    #optional
                    parm = '[%s]' % a[0]
                else:
                    parm = '<%s>' % a[0]

                if a[0] == badfield:
                    parm = '^1%s^7' % parm

                help.append(parm)

            return (None, ' '.join(help))

    def splitData(self, data):
        params = []
        buf = ''
        inQuote  = False
        inDQuote = False
        for c in str(data).strip():
            if c == "'":
                if inDQuote:
                    buf += c
                elif inQuote:
                    params.append(buf)
                    buf = ''
                    inQuote = False
                elif len(buf):
                    buf += c
                else:
                    inQuote = True
                    buf = ''
            elif c == '"':
                if inDQuote:
                    params.append(buf)
                    buf = ''
                    inDQuote = False
                elif inQuote:
                    buf += c
                elif len(buf):
                    buf += c
                else:
                    inDQuote = True
                    buf = ''
            elif c.isspace():
                if len(buf):
                    if inDQuote or inQuote:
                        if not buf[-1].isspace():
                            buf += c
                    else:
                        params.append(buf)
                        buf = ''
            else:
                buf += c

        if len(buf):
            params.append(buf)

        return params

    def __repr__(self):
        return "Command<" + self.command + ">"
########NEW FILE########
__FILENAME__ = adv
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# CHANGELOG
# 29/09/2012 - 1.4 - Courgette
#    new message keyword @regulars will run the Admin plugin !regulars command
# 19/08/2012 - 1.3.3 - Courgette
#    give user feedback on command misuse
# 07/17/2011 - 1.3.2 - Freelander
#    prevent error if next map is not returned
# 04/18/2011 - 1.3.1 - Courgette
#    makes @admins show admins' level as well
# 04/18/2011 - 1.3.0 - Courgette
#    add the @admins keyword that displays the connected admins
#    when the ad is @topstats or @amdins but no message is to be shown, then 
#      try next ad
# 10/24/2010 - 1.2.2 - Courgette
#    Prevent crash when no feed is specified in config
# 08/20/2010 - 1.2.1 - xlr8or
#    Add @topstats for xlrstats
# 08/06/2010 - 1.2 - xlr8or
#    Add feedparser (@feed or @feed <nr>)
# 08/06/2010 - 1.1.5 - xlr8or
#    Remove save() errors and !advsave when XML adds are used
#    This needs to be re-enabled when saving to XML is supported
# 11/22/2009 - 1.1.4 - Courgette
#    fix bug when using external text ads file which is empty
# 2/27/2009 - 1.1.3 - xlr8or
#    Added Anubis suggestion @nextmap to ads and also @time to show time.
# 11/30/2005 - 1.1.2 - ThorN
#    Use PluginCronTab instead of CronTab
# 8/29/2005 - 1.1.0 - ThorN
#    Converted to use XML config

__author__ = 'ThorN'
__version__ = '1.4'

import b3
import os
import time
import b3.lib.feedparser as feedparser
import b3.plugin
import b3.cron


class MessageLoop:
    items = None

    def __init__(self):
        self.items = []
        self.index = 0

    def put(self, item):
        self.items.append(item)

    def getnext(self):
        try:
            item = self.items[self.index]
        except:
            self.index = 0
            return None

        self.index += 1

        if self.index >= len(self.items):
            self.index = 0

        return item

    def getitem(self, index):
        try:
            return self.items[index]
        except:
            return None

    def remove(self, index):
        # empty the list
        i = 0

        items = []
        for item in self.items:
            if i != index:
                items.append(item)

            i += 1

        self.items = items

    def clear(self):
        # empty the list
        self.items = []


#--------------------------------------------------------------------------------------------------
class AdvPlugin(b3.plugin.Plugin):
    _adminPlugin = None
    _cronTab = None
    _msg = None
    _fileName = None
    _rate = None
    _feed = 'http://forum.bigbrotherbot.net/news-2/?type=rss;action=.xml'
    _feedpre = u'News: '
    _feedmaxitems = 5
    _feeditemnr = 0
    _replay = 0

    def onStartup(self):
        if self._adminPlugin:
            self._adminPlugin.registerCommand(self, 'advadd', 100, self.cmd_advadd)
            self._adminPlugin.registerCommand(self, 'advrate', 100, self.cmd_advrate)
            self._adminPlugin.registerCommand(self, 'advlist', 100, self.cmd_advlist)
            self._adminPlugin.registerCommand(self, 'advload', 100, self.cmd_advload)
            self._adminPlugin.registerCommand(self, 'advrem', 100, self.cmd_advrem)
            if self._fileName:
                self._adminPlugin.registerCommand(self, 'advsave', 100, self.cmd_advsave)

        self._xlrstatsPlugin = self.console.getPlugin('xlrstats')
        if not self._xlrstatsPlugin:
            self.debug('XLRstats not installed, @topstats not available!')
        else:
            self.debug('XLRstats found, @topstats available!')

    def onLoadConfig(self):
        self._adminPlugin = self.console.getPlugin('admin')
        self._msg = MessageLoop()

        try:
            self._rate = self.config.get('settings', 'rate')
            self.info('adv rate is %s' % self._rate)
        except:
            self.error('config missing [settings].rate')
            return False

        if self.config.has_option('settings', 'ads'):
            self._fileName = self.console.getAbsolutePath(self.config.get('settings', 'ads'))
            self.loadFromFile(self._fileName)
        else:
            self._fileName = None
            self.loadFromConfig()

        try:
            self._feed = self.config.get('newsfeed', 'url')
        except:
            pass

        try:
            self._feedmaxitems = self.config.getint('newsfeed', 'items')
        except:
            pass
        #reduce feedmaxitems 1 point, since we're starting at item 0, this makes counting easier...
        self._feedmaxitems -= 1
        self.verbose('self._feedmaxitems: %s' % self._feedmaxitems)

        try:
            self._feedpre = self.config.get('newsfeed', 'pretext')
        except:
            pass

        #test if we have a proper feed
        if self._feed is not None:
            if self._feed.strip() == '':
                self._feed = None
            else:
                f = feedparser.parse(self._feed)

                if not f or f['bozo'] == 1:
                    self._feed = None
                    self.warning('Error reading feed at %s' % self._feed)
                    self.debug(f['bozo_exception'])

        if self._cronTab:
            # remove existing crontab
            self.console.cron - self._cronTab

        (min, sec) = self._getRateMinSec()
        self._cronTab = b3.cron.PluginCronTab(self, self.adv, second=sec, minute=min)
        self.console.cron + self._cronTab

    def save(self):
        if self._fileName:
            f = file(self._fileName, 'w')
            for msg in self._msg.items:
                if msg:
                    f.write(msg + "\n")
            f.close()
        else:
            self.verbose('Save to XML config not supported')
            raise Exception('Save to XML config not supported')

    def loadFromFile(self, fileName):
        if not os.path.isfile(fileName):
            self.error('Ad file %s does not exist', fileName)
            return False

        f = file(fileName, 'r')
        self.load(f.readlines())
        f.close()

    def loadFromConfig(self):
        items = []
        for e in self.config.get('ads/ad'):
            items.append(e.text)

        self.load(items)

    def load(self, items=[]):
        self._msg.clear()

        for w in items:
            w = w.strip()
            if len(w) > 1:
                if w[:6] == '/spam#':
                    w = self._adminPlugin.getSpam(w[6:])
                self._msg.put(w)

    def adv(self, firstTry=True):
        ad = self._msg.getnext()
        if ad:
            if ad == "@nextmap":
                if self.console.getNextMap():
                    ad = "^2Next map: ^3" + self.console.getNextMap()
                else:
                    self.debug('Cannot get map rotation')
                    ad = None
            elif ad == "@time":
                ad = "^2Time: ^3" + self.console.formatTime(time.time())
            elif ad[:5] == "@feed" and self._feed:
                ad = self.getFeed(ad)
                if not ad or ad == self._feedpre:
                    #we didn't get an item from the feedreader, move on to the next ad
                    self._replay += 1
                    #prevent endless loop if only feeditems are used as adds
                    if self._replay < 10:
                        self.adv()
                    else:
                        self.debug('Something wrong with the newsfeed, disabling it. Fix the feed and do !advload')
                        self._feed = None
                    return
            elif ad == "@topstats":
                if self._xlrstatsPlugin:
                    self._xlrstatsPlugin.cmd_xlrtopstats(data='3', client=None, cmd=None, ext=True)
                    if firstTry:
                        # try another ad
                        self.adv(firstTry=False)
                        return
                    else:
                        ad = None
                else:
                    self.error('XLRstats not installed! Cannot use @topstats in adv plugin!')
                    ad = '@topstats not available, XLRstats is not installed!'
            elif ad == "@admins":
                try:
                    command = self._adminPlugin._commands['admins']
                    command.executeLoud(data=None, client=None)
                    ad = None
                except Exception, err:
                    self.error("could not send adv message @admins", exc_info=err)
                    if firstTry:
                        # try another ad
                        self.adv(firstTry=False)
                        return
                    else:
                        ad = None
            elif ad == "@regulars":
                try:
                    command = self._adminPlugin._commands['regulars']
                    command.executeLoud(data=None, client=None)
                    ad = None
                except Exception, err:
                    self.error("could not send adv message @regulars", exc_info=err)
                    if firstTry:
                        # try another ad
                        self.adv(firstTry=False)
                        return
                    else:
                        ad = None

            if ad:
                self.console.say(ad)
            self._replay = 0

    def getFeed(self, ad):
        i = ad.split()
        if len(i) == 2 and type(i) == type(1):
            i = i[1]
            self._feeditemnr = i
        else:
            if self._feeditemnr > self._feedmaxitems:
                self._feeditemnr = 0
            i = self._feeditemnr
        try:
            f = feedparser.parse(self._feed)
        except:
            self.debug('Not able to retrieve feed')
            return None
        try:
            _item = f['entries'][i]['title']
            self._feeditemnr += 1
            return self._feedpre + _item
        except:
            self.debug('Feeditem %s out of range' % i)
            self._feeditemnr = 0
            return None

    def cmd_advadd(self, data, client=None, cmd=None):
        if not data:
            client.message('Invalid data, specify the message to add')
            return
        self._msg.put(data)
        client.message('^3Adv: ^7"%s^7" added' % data)
        if self._fileName:
            self.save()

    def cmd_advsave(self, data, client=None, cmd=None):
        try:
            self.save()
            client.message('^3Adv: ^7Saved %s messages' % len(self._msg.items))
        except Exception, e:
            client.message('^3Adv: ^7Error saving: %s' % e)

    def cmd_advload(self, data, client=None, cmd=None):
        self.onLoadConfig()
        client.message('^3Adv: ^7Loaded %s messages' % len(self._msg.items))

    def cmd_advrate(self, data, client=None, cmd=None):
        if not data:
            if self._rate[-1] == 's':
                client.message('Current rate is every %s seconds' % self._rate[:-1])
            else:
                client.message('Current rate is every %s minutes' % self._rate)
        else:
            self._rate = data
            (min, sec) = self._getRateMinSec()
            self._cronTab.minute = min
            self._cronTab.second = sec
            if self._rate[-1] == 's':
                client.message('^3Adv: ^7Rate set to %s seconds' % self._rate[:-1])
            else:
                client.message('^3Adv: ^7Rate set to %s minutes' % self._rate)

    def cmd_advrem(self, data, client=None, cmd=None):

        if not data:
            client.message("Invalid data, use the !advlist command to list valid items numbers")
            return

        try:
            item_index = int(data) - 1
        except ValueError:
            client.message("Invalid data, use the !advlist command to list valid items numbers")
            return

        if not 0 <= item_index < len(self._msg.items):
            client.message("Invalid data, use the !advlist command to list valid items numbers")
            return

        item = self._msg.getitem(item_index)

        if item:
            self._msg.remove(int(data) - 1)
            if self._fileName:
                self.save()
            client.message('^3Adv: ^7Removed item: %s' % item)
        else:
            client.message('^3Adv: ^7Item %s not found' % data)

    def cmd_advlist(self, data, client=None, cmd=None):
        if len(self._msg.items) > 0:
            i = 0
            for msg in self._msg.items:
                i += 1
                client.message('^3Adv: ^7[^2%s^7] %s' % (i, msg))
        else:
            client.message('^3Adv: ^7No ads loaded')

    def _getRateMinSec(self):
        """\
        allow to define the rate in second by adding 's' at the end
        """
        sec = 0
        min = '*'
        if self._rate[-1] == 's':
            # rate is in seconds
            s = self._rate[:-1]
            if int(s) > 59:
                s = 59
            sec = '*/%s' % s
        else:
            min = '*/%s' % self._rate
        self.debug('%s -> (%s,%s)' % (self._rate, min, sec))
        return min, sec


########NEW FILE########
__FILENAME__ = censor
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#    2012/07/03 - 3.1 - Courgette
#       Fixes a bug wich prevented regular expression "\sd[i!1*]ck\s" to match for word "d!ck"
#    2012/07/03 - 3.0.1 - Courgette
#       Gives meaningful log messages when loading the config file
#    2011/12/26 - 3.0 - Courgette
#       Refactor and make the checks on raw text before checks on cleaned text. Add tests
#    2/12/2011 - 2.2.2 - Bravo17
#       Fix for reason keyword not working
#    1/16/2010 - 2.2.1 - xlr8or
#       Plugin can now be disabled with !disable censor
#    1/16/2010 - 2.2.0 - xlr8or
#       Added ignore_length as an optional configurable option
#       Started debugging the badname checker
#    8/13/2005 - 2.0.0 - ThorN
#       Converted to use XML config
#       Allow custom penalties for words and names
#    7/23/2005 - 1.1.0 - ThorN
#       Added data column to penalties table
#       Put censored message/name in the warning data

__author__  = 'ThorN, xlr8or, Bravo17, Courgette'
__version__ = '3.1'

import b3, re, traceback, sys, threading
import b3.events
import b3.plugin
from b3.config import XmlConfigParser
from b3 import functions

class PenaltyData:
    def __init__(self, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

    type = None
    reason = None
    keyword = None
    duration = 0

    def __repr__(self):
        return """Penalty(type=%r, reason=%r, keyword=%r, duration=%r)""" % (self.type, self.reason, self.keyword, self.duration)

    def __str__(self):
        data = {"type": self.type, "reason": self.reason, "reasonkeyword": self.keyword, "duration": self.duration}
        return "<penalty " + ' '.join(['%s="%s"' % (k, v) for k, v in data.items() if v]) + " />"

class CensorData:
    def __init__(self, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

    name = None
    penalty = None
    regexp = None

    def __repr__(self):
        return """CensorData(name=%r, penalty=%r, regexp=%r)""" % (self.name, self.penalty, self.regexp)

#--------------------------------------------------------------------------------------------------
class CensorPlugin(b3.plugin.Plugin):
    _adminPlugin = None
    _reClean = re.compile(r'[^0-9a-z ]+', re.I)
    _defaultBadWordPenalty = PenaltyData(type="warning", keyword="cuss")
    _defaultBadNamePenalty = PenaltyData(type="warning", keyword="badname")
    _maxLevel = 0
    _ignoreLength = 3

    def onStartup(self):
        self._adminPlugin = self.console.getPlugin('admin')
        if not self._adminPlugin:
            return False

        self.registerEvent(b3.events.EVT_CLIENT_SAY)
        self.registerEvent(b3.events.EVT_CLIENT_TEAM_SAY)
        self.registerEvent(b3.events.EVT_CLIENT_NAME_CHANGE)
        self.registerEvent(b3.events.EVT_CLIENT_AUTH)


    def onLoadConfig(self):
        assert isinstance(self.config, XmlConfigParser)
        try:
            self._maxLevel = self.config.getint('settings', 'max_level')
        except Exception, err:
            self._maxLevel = 0
            self.warning(err)
            self.warning("using default value %s for settings:max_level" % self._maxLevel)
        try:
            self._ignoreLength = self.config.getint('settings', 'ignore_length')
        except Exception, err:
            self._ignoreLength = 3
            self.warning(err)
            self.warning("using default value %s for settings:ignore_length" % self._ignoreLength)

        default_badwords_penalty_nodes = self.config.get('badwords/penalty')
        if len(default_badwords_penalty_nodes):
            penalty = default_badwords_penalty_nodes[0]
            self._defaultBadWordPenalty = PenaltyData(type = penalty.get('type'),
                                reason = penalty.get('reason'),
                                keyword = penalty.get('reasonkeyword'),
                                duration = functions.time2minutes(penalty.get('duration')))
        else:
            self.warning("""no default badwords penalty found in config. Using default : %s""" % self._defaultBadNamePenalty)

        default_badnames_penalty_nodes = self.config.get('badnames/penalty')
        if len(default_badnames_penalty_nodes):
            penalty = default_badnames_penalty_nodes[0]
            self._defaultBadNamePenalty = PenaltyData(type = penalty.get('type'),
                            reason = penalty.get('reason'),
                            keyword = penalty.get('reasonkeyword'),
                            duration = functions.time2minutes(penalty.get('duration')))
        else:
            self.warning("""no default badnames penalty found in config. Using default : %s""" % self._defaultBadNamePenalty)

        # load bad words into memory
        self._badWords = []
        for e in self.config.get('badwords/badword'):
            penalty_node = e.find('penalty')
            word_node = e.find('word')
            regexp_node = e.find('regexp')
            self._add_bad_word(rulename=e.get('name'),
                penalty=penalty_node,
                word=word_node.text if word_node is not None else None,
                regexp=regexp_node.text if regexp_node is not None else None)

        # load bad names into memory
        self._badNames = []
        for e in self.config.get('badnames/badname'):
            penalty_node = e.find('penalty')
            word_node = e.find('word')
            regexp_node = e.find('regexp')
            self._add_bad_name(rulename=e.get('name'),
                penalty=penalty_node,
                word=word_node.text if word_node is not None else None,
                regexp=regexp_node.text if regexp_node is not None else None)


    def _add_bad_word(self, rulename, penalty=None, word=None, regexp=None):
        if word is regexp is None:
            self.warning("badword rule [%s] has no word and no regular expression to search for" % rulename)
        elif word is not None and regexp is not None:
            self.warning("badword rule [%s] cannot have both a word and regular expression to search for" % rulename)
        elif regexp is not None:
            # has a regular expression
            self._badWords.append(self._getCensorData(rulename, regexp.strip(), penalty, self._defaultBadWordPenalty))
            self.debug("badword rule '%s' loaded" % rulename)
        elif word is not None:
            # has a plain word
            self._badWords.append(self._getCensorData(rulename, '\\s' + word.strip() + '\\s', penalty, self._defaultBadWordPenalty))
            self.debug("badword rule '%s' loaded" % rulename)

    def _add_bad_name(self, rulename, penalty=None, word=None, regexp=None):
        if word is regexp is None:
            self.warning("badname rule [%s] has no word and no regular expression to search for" % rulename)
        elif word is not None and regexp is not None:
            self.warning("badname rule [%s] cannot have both a word and regular expression to search for" % rulename)
        elif regexp is not None:
            # has a regular expression
            self._badNames.append(self._getCensorData(rulename, regexp.strip(), penalty, self._defaultBadNamePenalty))
            self.debug("badname rule '%s' loaded" % rulename)
        elif word is not None:
            # has a plain word
            self._badNames.append(self._getCensorData(rulename, '\\s' + word.strip() + '\\s', penalty, self._defaultBadNamePenalty))
            self.debug("badname rule '%s' loaded" % rulename)

    def _getCensorData(self, name, regexp, penalty, defaultPenalty):
        try:
            regexp = re.compile(regexp, re.I)
        except re.error, e:
            self.error('Invalid regular expression: %s - %s' % (name, regexp))
            raise

        if penalty is not None:
            pd = PenaltyData(type = penalty.get('type'),
                            reason = penalty.get('reason'),
                            keyword = penalty.get('reasonkeyword'),
                            duration = functions.time2minutes(penalty.get('duration')))
        else:
            pd = defaultPenalty

        return CensorData(name=name, penalty=pd, regexp=regexp)


    def onEvent(self, event):
        try:
            if not self.isEnabled():
                return
            elif not event.client:
                return
            elif event.client.cid is None:
                return
            elif event.client.maxLevel > self._maxLevel:
                return
            elif not event.client.connected:
                return

            if event.type == b3.events.EVT_CLIENT_AUTH or event.type == b3.events.EVT_CLIENT_NAME_CHANGE:
                self.checkBadName(event.client)

            elif len(event.data) > self._ignoreLength:
                if event.type == b3.events.EVT_CLIENT_SAY or \
                   event.type == b3.events.EVT_CLIENT_TEAM_SAY:
                    self.checkBadWord(event.data, event.client)


        except b3.events.VetoEvent:
            raise
        except Exception, msg:
            self.error('Censor plugin error: %s - %s', msg, traceback.extract_tb(sys.exc_info()[2]))

    def penalizeClient(self, penalty, client, data=''):
        """\
        This is the default penalisation for using bad language in say and teamsay
        """
        #self.debug("%s"%((penalty.type, penalty.reason, penalty.keyword, penalty.duration),))
        # fix for reason keyword not working
        if penalty.keyword is None:
            penalty.keyword = penalty.reason
        self._adminPlugin.penalizeClient(penalty.type, client, penalty.reason, penalty.keyword, penalty.duration, None, data)

    def penalizeClientBadname(self, penalty, client, data=''):
        """\
        This is the penalisation for bad names
        """
        #self.debug("%s"%((penalty.type, penalty.reason, penalty.keyword, penalty.duration),))
        self._adminPlugin.penalizeClient(penalty.type, client, penalty.reason, penalty.keyword, penalty.duration, None, data)

    def checkBadName(self, client):
        if not client.connected:
            self.debug('Client not connected?')
            return

        cleaned_name = ' ' + self.clean(client.exactName) + ' '
        self.info("Checking '%s'=>'%s' for badname" % (client.exactName, cleaned_name))

        was_penalized = False

        for w in self._badNames:
            if w.regexp.search(client.exactName):
                self.debug("badname rule [%s] matches '%s'" % (w.name, client.exactName))
                self.penalizeClientBadname(w.penalty, client, '%s (rule %s)' % (client.exactName, w.name))
                was_penalized = True
                break
            if w.regexp.search(cleaned_name):
                self.debug("badname rule [%s] matches cleaned name '%s' for player '%s'" % (w.name, cleaned_name, client.exactName))
                self.penalizeClientBadname(w.penalty, client, '%s (rule %s)' % (client.exactName, w.name))
                was_penalized = True
                break

        if was_penalized:
            # check again in 1 minute
            t = threading.Timer(60, self.checkBadName, (client,))
            t.start()
            return

    def checkBadWord(self, text, client):
        cleaned = ' ' + self.clean(text) + ' '
        text = ' ' + text + ' '
        self.debug("cleaned text: [%s]" % cleaned)
        for w in self._badWords:
            if w.regexp.search(text):
                self.debug("badword rule [%s] matches '%s'" % (w.name, text))
                self.penalizeClient(w.penalty, client, text)
                raise b3.events.VetoEvent
            if w.regexp.search(cleaned):
                self.debug("badword rule [%s] matches cleaned text '%s'" % (w.name, cleaned))
                self.penalizeClient(w.penalty, client, '%s => %s' % (text, cleaned))
                raise b3.events.VetoEvent


    def clean(self, data):
        return re.sub(self._reClean, ' ', self.console.stripColors(data.lower()))
    

    
########NEW FILE########
__FILENAME__ = cod7http
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 15.01.2011 - 1.0.0 - Freelander
#   * Initial release
# 16.01.2011 - 1.0.1 - Freelander
#   * Added user-agent in the http header
#   * Added exceptions for socket timeout, IOError and URLError
# 17.01.2011 - 1.0.2 - Freelander
#   * Better handling of socket timeout error
# 17.01.2011 - 1.0.3 - Freelander
#   * Fixed local gamelog option
# 19.01.2011 - 1.0.4 - Freelander
#   * Increased sleep time to prevent HTTP 403 errors
#   * Timout value falls back to default 10 seconds if timeout value can't be
#     parsed from http://logs.gameservers.com/timeout
#   * Added option for manually setting timout value in b3.xml
# 21.01.2011 - 1.0.5 - Freelander
#   * Refactoring code for better timeout handling and get rid of redundant
#     getRemotelog function
# 31.01.2011 - 1.0.6 - Freelander
#   * Added range header to limit download size
# 02.02.2011 - 1.0.7 - Freelander
#   * Added error handling while closing remote file to prevent plugin crash
#   * Check Python version to be minimum 2.6
#   * Now checking last 3 lines instead of last single line
#   * Increase range header if last line is not found in the remote log chunk.
# 03.02.2011 - 1.0.8 - Freelander
#   * If still unable to find the last line after increasing range header,
#     restart downloading process. That happens if logs are rotated or server restarted.
#     In that case last line will never be found.
# 05.02.2011 - 1.0.9 - Bravo17
#   * Added log_append config variable to control whether local log is deleted on startup
#   * Changed lastlines functionality to being stored in memory rather than getting from local log 
#     using Just a baka's lazy cursor
#   * Make sure that we have something worth decompressing before we attempt to do so
#   * Added user agent to timeout request
# 08.02.2011 - 1.0.10 - Just a baka
#   * Fixed the bug which prevented b3 from parsing while the gzipped remote log is < 500 bytes
# 10.02.2011 - 1.0.11 - Just a baka
#   * Rewritten the inter-cycle sleeping mechanism to achieve a nearly-instant thread exit time
# 25.02.2011 - 1.0.12 - Freelander
#   * Reduced default timeout to 5 seconds
#   * Arranged log messages
#   * Fixed a minor bug
# 02.03.2011 - 1.0.13 - Freelander
#   * Added exception for ValueError that may occur on an interrupted internet connection
# 02.03.2011 - 1.0.14 - Bravo17
#   * Added method to test whether processData thread is still running, for use by parser
# 22.03.2011 - 1.0.15 - Courgette
#   * Do not fail if http response is not gzipped
# 27.04.2011 - 1.0.16 - 82ndab-Bravo17
#   * Auto assign of unique local games_mp log file
# 22/05/2012 - 1.0.17 - Courgette
#   * local_game_log config option can now use the @conf and @b3 shortcuts
#

## @file
#  This plugin downloads and maintains CoD7 game log file

__author__  = 'Freelander, Bravo17, Just a baka'
__version__ = '1.0.17'

import b3, threading
from b3 import functions
import b3.events
import b3.plugin
import urllib2, urllib
import os.path
import StringIO
import gzip
import time
import socket
import re, sys

user_agent =  "B3 Cod7Http plugin/%s" % __version__

class Cod7HttpPlugin(b3.plugin.Plugin):
    """Downloads and appends the remote game log file for CoD7 to a local
    log file from a http location given by GSP.
    """

    requiresConfigFile = False

    #Timout url set by gameservers.com
    _timeout_url = 'http://logs.gameservers.com/timeout'
    _default_timeout = 5
    _logAppend = True
    lastlines = ''
    httpthreadinst = None

    def onLoadConfig(self):
        pass

    def initThread(self):
        """Starts a thread for cod7http plugin."""

        thread1 = threading.Thread(target=self.processData)
        self.info("Starting cod7http thread")
        thread1.start()
        self.httpthreadinst = thread1

    def onStartup(self):
        """Sets and loads config values from the main config file."""

        versionsearch = re.search("^((?P<mainversion>[0-9]).(?P<lowerversion>[0-9]+)?)", sys.version)
        version = int(versionsearch.group(3))
        if version < 6:
            self.error('Python Version %s, this is not supported and may lead to hangs. Please update Python to 2.6' % versionsearch.group(1))
            self.console.die()

        if self.console.config.has_option('server', 'local_game_log'):
            self.locallog = self.console.config.getpath('server', 'local_game_log')
        else:
            # setup ip addresses
            self._publicIp = self.console.config.get('server', 'public_ip')
            self._port = self.console.config.getint('server', 'port')

            if self._publicIp[0:1] == '~' or self._publicIp[0:1] == '/':
                # load ip from a file
                f = file(self.console.getAbsolutePath(self._publicIp))
                self._publicIp = f.read().strip()
                f.close()

            logext = str(self._publicIp.replace('.', '_'))
            logext = 'games_mp_' + logext + '_' + str(self._port) + '.log'
            self.locallog = os.path.normpath(os.path.expanduser(logext))
            self.debug('Local Game Log is %s' % self.locallog)

        if self.console.config.has_option('server', 'log_append'):
            self._logAppend =self.console.config.getboolean('server', 'log_append')
        else:
            self._logAppend = False

        if self.console.config.has_option('server', 'log_timeout'):
            self.timeout = self.console.config.get('server', 'log_timeout')
        else:
            #get timeout value set by gameservers.com
            try:
                
                req = urllib2.Request(self._timeout_url)
                req.headers['User-Agent'] = user_agent
                f = urllib2.urlopen(req)
                self.timeout = int(f.readlines()[0])
                f.close()
                self.debug('Using timeout value of %s seconds' % self.timeout)
                
            except (urllib2.HTTPError, urllib2.URLError, socket.timeout), error: 
                self.timeout = self._default_timeout
                self.error('ERROR: %s' % error)
                self.error('ERROR: Couldn\'t get timeout value. Using default %s seconds' % self.timeout)

        if self.console.config.get('server','game_log')[0:7] == 'http://' :
            self._url = self.console.config.get('server','game_log')
            self.initThread()
        else:
            self.error('Your game log url doesn\'t seem to be valid. Please check your config file')
            self.console.die()

    def httpThreadalive(self):
        """Test whether processData thread is still running."""
        return self.httpthreadinst.isAlive()

    def writeCompletelog(self, locallog, remotelog):
        """Will restart writing the local log when bot started for the first time
        or if last line cannot be found in remote chunk
        """

        #pause the bot from parsing, because we don't
        #want to parse the log from the beginning
        if self.console._paused is False:
            self.console.pause()
            self.debug('Pausing')
        # Remove last line if not complete
        i = remotelog.rfind ('\r\n')
        remotelog = remotelog[:i + 2]
        # remove any blank lines
        while remotelog[-4:-2] == '\r\n':
            remotelog = remotelog[:-2]
        
        # use Just a baka's lazy cursor
        self.lastlines = remotelog[-1000:]

        #create or open the local log file
        if self._logAppend:
            output = open(locallog, 'ab')
        else:
            output = open(locallog, 'wb')

        output.write('\r\n')
        output.write('B3 has restarted writing the log file\r\n')
        output.write('\r\n')
        output.close()

        self.info('Remote log downloaded successfully')

        #we can now start parsing again
        if self.console._paused:
            self.console.unpause()
            self.debug('Unpausing')

    def processData(self):
        """Main method for plugin. It's processed by initThread method."""

        _lastLine = True
        _firstRead = True
        n = 0

        while self.console.working:
            remotelog = ''
            response = ''
            remote_log_data = ''

            #Specify range depending on if the last line
            #is in the remote log chunk or not
            if _lastLine:
                bytes = 'bytes=-10000'
            else:
                bytes = 'bytes=-100000'

            headers =  { 'User-Agent' : user_agent,
                         'Range' : bytes,
                         'Accept-encoding' : 'gzip' }

            #self.verbose('Sending request')

            request = urllib2.Request(self._url, None, headers)

            #get remote log url response and headers
            try:
                response = urllib2.urlopen(request)
                headers = response.info()

                #buffer/download remote log
                if response != '':
                    remote_log_data = response.read()
                    remotelogsize = round((len(remote_log_data)/float(1024)), 2)
                    #self.verbose('Downloaded: %s KB total' % remotelogsize)

                try:
                    #close remote file
                    response.close()
                except AttributeError, error:
                    self.error('ERROR: %s' % error)

            except (urllib2.HTTPError, urllib2.URLError), error:
                self.error('HTTP ERROR: %s' % error)
            except socket.timeout:
                self.error('TIMEOUT ERROR: Socket Timed out!')

            #start keeping the time
            start = time.time()

            #decompress remote log and return for use
            # First, make sure that there is domething worth decompressing
            # In case the server has just done a restart
            if len(remote_log_data) > 0:
                try:
                    #self.debug('Content-Encoding: %s' % headers.get('Content-Encoding'))
                    if headers.get('Content-Encoding') == 'gzip':
                        compressedstream = StringIO.StringIO(remote_log_data)
                        gzipper = gzip.GzipFile(fileobj=compressedstream)
                        remotelog = gzipper.read()
                    else:
                        remotelog = remote_log_data
                except IOError, error:
                    remotelog = ''
                    self.error('IOERROR: %s' % error)

                if os.path.exists(self.locallog) and os.path.getsize(self.locallog) > 0 and not _firstRead:

                    #check if last line is in the remote log chunk
                    if remotelog.find(self.lastlines) != -1:
                        _lastLine = True
                        n = 0

                        #we'll get the new lines i.e what is available after the last line
                        #of our local log file
                        try:
                            checklog = remotelog.rpartition(self.lastlines)
                            newlog = checklog[2]
                            # Remove any broken last line
                            i = newlog.rfind ('\r\n')
                            newlog = newlog[:i + 2]
                            # Remove any blank lines
                            while newlog[-4:-2] == '\r\n':
                                newlog = newlog[:-2]
                        except ValueError, error:
                            self.error ('ValueError: %s' % error)
                            newlog = ''

                        # Remove any blank lines from end
                        
                        #append the additions to our log if there is something and update lazy cursor
                        if len(newlog) > 0:
                            output = open(self.locallog,'ab')
                            output.write(newlog)
                            output.close()
                            self.lastlines = remotelog[-1000:]                        
                            self.debug('Downloaded %s KB and added %s char(s) to log' % (remotelogsize, len(newlog)))

                    else:
                        _lastLine = False
                        self.debug('Can\'t find last line in the log chunk, checking again...')
                        n += 1

                        #check once in a larger chunk and if we are still unable to find last line
                        #in the remote chunk, restart the process
                        if n == 2:
                            self.debug('Logs rotated or unable to find last line in remote log, restarting process...')
                            self.writeCompletelog(self.locallog, remotelog)
                            _lastLine = True
                            n = 0

                else:
                    self.debug('Writing first log read')
                    self.writeCompletelog(self.locallog, remotelog)
                    _firstRead = False

            #calculate how long it took to process
            timespent = time.time() - start

            #calculate time to wait until next request. 
            timeout = float(self.timeout)

            #self.verbose('Given timeout value is %s seconds' % timeout)
            #self.verbose('Total time spent to process the downloaded file is %s seconds' % timespent)

            #Calculate sleep time for next request. Adding 0.1 secs to prevent HTTP Error 403 errors
            wait = float((timeout - timespent) + 0.1)

            if wait <= 0:
                wait = 1

            #self.verbose('Next request in %s second(s)' % wait)

            # Make the plugin thread fast-killable
            i = 0
            w = int(wait)
            while i < w and self.console.working:
                time.sleep(1)
                i += 1
            time.sleep(wait - w)

        self.verbose('B3 is down, stopping Cod7Http Plugin')


if __name__ == '__main__':
    from b3.fake import fakeConsole
    
    p = Cod7HttpPlugin(fakeConsole)
    p._url = "http://www.example.com"
    p.timeout = 5
    p.locallog ='test.log'
    p.processData()
    
########NEW FILE########
__FILENAME__ = codam
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

__author__  = 'ThorN'
__version__ = '0.0.1'

import b3, re
import b3.plugin

#--------------------------------------------------------------------------------------------------
class CodamPlugin(b3.plugin.Plugin):
    _adminPlugin = None

    def startup(self):
        self._adminPlugin = self.console.getPlugin('admin')
        if self._adminPlugin:
            if 'commands' in self.config.sections():
                for cmd in self.config.options('commands'):
                    if cmd == 'codam':
                        self._adminPlugin.registerCommand(self, 'codam', self.config.get('commands', 'codam'), self.cmd_codam)
                    else:
                        self._adminPlugin.registerCommand(self, 'c' + cmd, self.config.get('commands', cmd), self.cmd_command)

            if 'user_commands' in self.config.sections():
                for cmd in self.config.options('user_commands'):
                    self._adminPlugin.registerCommand(self, 'c' + cmd, self.config.get('user_commands', cmd), self.cmd_user_command)

    def cmd_codam(self, data, client, cmd=None):
        """\
        - CoDAM command
        """
        self.console.write('command "%s"' % data)

    def cmd_user_command(self, data, client, cmd=None):
        """\
        - CoDAM user command
        """
        m = re.match('^([^ ]{2,}|[0-9]+) ?(.*)$', data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        cid = m.group(1)
        parm = m.group(2)

        sclient = self._adminPlugin.findClientPrompt(cid, client)
        if sclient:
            self.cmd_codam('%s %s %s' % (cmd.command[1:], parm, sclient.cid), client)

    def cmd_command(self, data, client, cmd=None):
        """\
        - CoDAM command
        """
        self.cmd_codam('%s %s' % (cmd.command, data), client)

    def handle(self, event):
        pass
        
########NEW FILE########
__FILENAME__ = ftpytail
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2009 James "Bakes" Baker
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# CHANGELOG:
# 27/11/2012 - 1.6 - Courgette
#   * remove the first '/' from the url-path to respect RFC 1738
#   * fix issue when public_ip and rcon_ip are different in b3.xml
# 22/05/2012 - 1.5.8 - Courgette
#   * local_game_log config option can now use the @conf and @b3 shortcuts
# 11/05/2011 - 1.5.7 - 82ndab-Bravo17
#   *  Append to local log implemented
# 27/04/2011 - 1.5.6 - 82ndab-Bravo17
#   *  Auto assign of unique local games_mp log file
# 29/10/2010 - 1.5.5 - Courgette
#   * Do not stop thread on FTP permanent error (2nd trial)
#   * add 3 new settings in optional config file : short_delay, long_delay, 
#     max_consecutive_failures to tune how aggressive is B3 at retrying to 
#     connect.
#   * update config file example in test section at the bottom of this file
# 29/10/2010 - 1.5.4 - Courgette
#   * Do not stop thread on FTP permanent error
# 04/10/2010 - 1.5.3 - Courgette
#   * stop thread on FTP permanent error
#   * can activate FTP debug messages with _ftplib_debug_level
#   * display exact error message whenever the ftp connection fails
# 04/09/2010 - 1.5.2 - GrosBedo
#   * b3/delay option now specify the delay between each ftp log fetching
#   * b3/local_game_log option to specify the temporary local log name (permits to manage remotely several servers at once)
# 02/09/2010 - 1.5.1 - Courgette
#    * fix bug in 1.5. Dectect FTP permanent error and give up in such cases
# 02/09/2010 - 1.5 - Courgette
#    * allow to connect on non standard FTP port
# 06/02/2010 - 1.4 - Courgette
#    * force FTP binary mode
# 13/12/2009 - 1.3 - Courgette
#    * default timeout is 30 secondes (as I had a user reporting the FTP server he uses 
#      lags 15 sec before accepting connections).
#    * Can optionnaly read a config file to customize timeout and max allowed gap between
#      remote and local gamelog
#    * add a test to validate config reading
# 12/12/2009 - 1.2 - Courgette
#     does not download huge amount of log in case local file is too far behind remote file (prevents memory errors)
#     In case of connection failure, try to reconnect every second for the first 30 seconds
# 12/12/2009 - 1.1.1 - Courgette
#     Gracefully stop thread when B3 is shutting down
#     Add tests
# 28/08/2009 - 1.1 - Bakes
#     Connects with parser.py to provide real remote b3.
# 17/06/2009 - 1.0 - Bakes
#     Initial Plugin, basic functionality.
 
__version__ = '1.6'
__author__ = 'Bakes, Courgette'
 
import b3, threading
from b3 import functions
import b3.plugin
import os.path
from ftplib import FTP
import ftplib
import time
import re
import sys
#--------------------------------------------------------------------------------------------------
class FtpytailPlugin(b3.plugin.Plugin):
    ### settings
    _maxGap = 20480 # max gap in bytes between remote file and local file
    _maxConsecutiveConnFailure = 30 # after that amount of consecutive failure, pause the bot for _long_delay seconds
    _short_delay = 1 # time (in sec) to wait before reconnecting after loosing FTP connection (if _nbConsecutiveConnFailure < _maxConsecutiveConnFailure)
    _long_delay = 15 # time (in sec) to wait before reconnecting after loosing FTP connection (if _nbConsecutiveConnFailure > _maxConsecutiveConnFailure)
    _connectionTimeout = 30
    
    requiresConfigFile = False
    ftpconfig = None
    buffer = None
    _remoteFileOffset = None
    _nbConsecutiveConnFailure = 0
    _logAppend = False
    
    _ftplib_debug_level = 0 # 0: no debug, 1: normal debug, 2: extended debug
    
    _gamelog_read_delay = 0.150
    
    def onStartup(self):
        versionsearch = re.search("^((?P<mainversion>[0-9]).(?P<lowerversion>[0-9]+)?)", sys.version)
        version = int(versionsearch.group(3))
        if version < 6:
            self.error('Python Version %s, this is not supported and may lead to hangs. Please update Python to 2.6' % versionsearch.group(1))
            self.console.die()

        if self.console.config.has_option('server', 'delay'):
            self._gamelog_read_delay = self.console.config.getfloat('server', 'delay')
        
        if self.console.config.has_option('server', 'local_game_log'):
            self.lgame_log = self.console.config.getpath('server', 'local_game_log')
        else:
            # get B3 actual locally opened game log
            self.lgame_log = os.path.normpath(os.path.expanduser(self.console.input.name))
            self.debug('Local Game Log is %s' % self.lgame_log)

        if self.console.config.get('server','game_log')[0:6] == 'ftp://' :
            self.initThread(self.console.config.get('server','game_log'))
            
        if self.console.config.has_option('server', 'log_append'):
            self._logAppend = self.console.config.getboolean('server', 'log_append')
        else:
            self._logAppend = False
    
    def onLoadConfig(self):
        try:
            self._connectionTimeout = self.config.getint('settings', 'timeout')
        except: 
            self.warning("Error reading timeout from config file. Using default value")
        self.info("FTP connection timeout: %s" % self._connectionTimeout)

        try:
            self._maxGap = self.config.getint('settings', 'maxGapBytes')
        except: 
            self.warning("Error reading maxGapBytes from config file. Using default value")
        self.info("Maximum gap allowed between remote and local gamelog: %s bytes" % self._maxGap)

        try:
            self._maxConsecutiveConnFailure = self.config.getint('settings', 'max_consecutive_failures')
        except: 
            self.warning("Error reading max_consecutive_failures from config file. Using default value")
        self.info("max_consecutive_failures: %s" % self._maxConsecutiveConnFailure)

        try:
            self._short_delay = self.config.getfloat('settings', 'short_delay')
        except: 
            self.warning("Error reading short_delay from config file. Using default value")
        self.info("short_delay: %s seconds" % self._short_delay)

        try:
            self._long_delay = self.config.getint('settings', 'long_delay')
        except: 
            self.warning("Error reading maxGapBytes from config file. Using default value")
        self.info("long_delay: %s seconds" % self._long_delay)

        self.info("until %s consecutive errors are met, the bot will wait for \
%s seconds (short_delay), then it will wait for %s seconds (long_delay)" 
            % (self._maxConsecutiveConnFailure, self._short_delay, self._long_delay))


    def initThread(self, ftpfileDSN):
        self.ftpconfig = functions.splitDSN(ftpfileDSN)
        self.url_path = self.ftpconfig['path'][1:] # the '/' is not part of the uri-path according to RFC 1738 3.1. Common Internet Scheme Syntax
        thread1 = threading.Thread(target=self.update)
        self.info("Starting ftpytail thread")
        thread1.start()
    
    def update(self):
        def handleDownload(block):
            #self.debug('received %s bytes' % len(block))
            self._remoteFileOffset += len(block)
            if self.buffer == None:
                self.buffer = block
            else:
                self.buffer = self.buffer + block
        ftp = None
        self.file = open(self.lgame_log, 'ab')
        self.file.write('\r\n')
        self.file.write('B3 has been restarted\r\n')
        self.file.write('\r\n')
        while self.console.working:
            try:
                if not ftp:
                    ftp = self.ftpconnect()
                    self._nbConsecutiveConnFailure = 0
                    remoteSize = ftp.size(os.path.basename(self.url_path))
                    self.verbose("Connection successful. Remote file size is %s" % remoteSize)
                    if self._remoteFileOffset is None:
                        self._remoteFileOffset = remoteSize
                remoteSize = ftp.size(os.path.basename(self.url_path))
                if remoteSize < self._remoteFileOffset:
                    self.debug("remote file rotation detected")
                    self._remoteFileOffset = 0
                if remoteSize > self._remoteFileOffset:
                    if  (remoteSize - self._remoteFileOffset) > self._maxGap:
                        self.debug('gap between local and remote file too large (%s bytes)', (remoteSize - self._remoteFileOffset))
                        self.debug('downloading only the last %s bytes' % self._maxGap)
                        self._remoteFileOffset = remoteSize - self._maxGap
                    #self.debug('RETR from remote offset %s. (expecting to read at least %s bytes)' % (self._remoteFileOffset, remoteSize - self._remoteFileOffset))
                    ftp.retrbinary('RETR ' + os.path.basename(self.url_path), handleDownload, rest=self._remoteFileOffset)          
                    if self.buffer:
                        self.file.write(self.buffer)
                        self.buffer = None
                        self.file.flush()
                    if self.console._paused:
                        self.console.unpause()
                        self.debug('Unpausing')

            except ftplib.all_errors, e:
                self.debug(str(e))
                self._nbConsecutiveConnFailure += 1
                if self.console._paused is False:
                    self.console.pause()
                self.file.close()
                self.debug('ftp error: resetting local log file?')
                if self._logAppend:
                    try:
                        self.file = open(self.lgame_log, 'ab')
                        self.file.write('\r\n')
                        self.file.write('B3 has restarted writing the log file\r\n')
                        self.file.write('\r\n')
                    except:
                        self.file = open(self.lgame_log, 'w')
                else:
                    self.file = open(self.lgame_log, 'w')
                self.file.close()
                self.file = open(self.lgame_log, 'ab')
                try:
                    ftp.close()
                    self.debug('FTP Connection Closed')
                except:
                    pass
                ftp = None
                
                if self._nbConsecutiveConnFailure <= self._maxConsecutiveConnFailure:
                    time.sleep(self._short_delay)
                else:
                    self.debug('too many failures, sleeping %s sec' % self._long_delay)
                    time.sleep(self._long_delay)
            time.sleep(self._gamelog_read_delay)
        self.verbose("stopping Ftpytail update thread")
        try:
            ftp.close()
        except:
            pass
        try:
            self.file.close()
        except:
            pass
    
    def ftpconnect(self):
        #self.debug('Python Version %s.%s, so setting timeout of 10 seconds' % (versionsearch.group(2), versionsearch.group(3)))
        self.verbose('Connecting to %s:%s ...' % (self.ftpconfig["host"], self.ftpconfig["port"]))
        ftp = FTP()
        ftp.set_debuglevel(self._ftplib_debug_level)
        ftp.connect(self.ftpconfig['host'], self.ftpconfig['port'], self._connectionTimeout)
        ftp.login(self.ftpconfig['user'], self.ftpconfig['password'])
        ftp.voidcmd('TYPE I')
        dir = os.path.dirname(self.url_path)
        self.debug('trying to cwd to [%s]' % dir)
        ftp.cwd(dir)
        self.console.clients.sync()
        return ftp
    
    
if __name__ == '__main__':
    from b3.fake import fakeConsole
    
    print "------------------------------------"
    config = b3.config.XmlConfigParser()
    config.setXml("""
    <configuration plugin="ftpytail">
        <settings name="settings">
            <!-- timeout to allow when connecting to FTP server -->
            <set name="timeout">5</set>
            <!-- how much bytes to read at most from game log file's tail (this is to avoid downloading megabytes) -->
            <set name="maxGapBytes">1024</set>
            <!-- The 3 settings below defines how aggressive will be B3 at 
            trying to reconnect after loosing the FTP connection.
            Before 'max_consecutive_failures' connections error, the bot will wait
            'short_delay' seconds before retrying. Then it will wait 'long_delay'. -->
            <set name="max_consecutive_failures">10</set>
            <set name="short_delay">2</set>
            <set name="long_delay">15</set>
        </settings>
    </configuration>
    """)
    p = FtpytailPlugin(fakeConsole, config)
    p.onStartup()

    #p.initThread('ftp://www.somewhere.tld/somepath/somefile.log')
    p.initThread('ftp://thomas@127.0.0.1/DRIVERS/test.txt')
    time.sleep(120)
    fakeConsole.shutdown()
    time.sleep(8)
########NEW FILE########
__FILENAME__ = httpytail
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 GrosBedo
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# CHANGELOG:
# 2010-09-04 - 0.1 - GrosBedo
#     Initial release, with htaccess authentication support.
# 2011-03-17 - 0.2 - Courgette
#     Make sure that maxGapBytes is never exceeded
# 2011-04-27 - 0.2.1 - 82ndab-Bravo17
#     Auto assign of unique local games_mp log file
# 2011-05-26 - 0.2.2 - 82ndab-Bravo17
#   *  Append to local log implemented
# 22/05/2012 - 0.2.3 - Courgette
#   * local_game_log config option can now use the @conf and @b3 shortcuts
# 19/02/2013 - 1.0 - Courgette
#   * fix issue when public_ip and rcon_ip are different in b3.xml or when a domain name is used in place of an IP

__version__ = '1.0'
__author__ = 'GrosBedo, 82ndab-Bravo17, Courgette'
 
import b3, threading
from b3 import functions
import b3.events
import b3.plugin
import os.path
import time
import re
import sys
import urllib2, urllib

user_agent =  "B3 Httpytail plugin/%s" % __version__
#--------------------------------------------------------------------------------------------------
class HttpytailPlugin(b3.plugin.Plugin):
    ### settings
    _maxGap = 20480 # max gap in bytes between remote file and local file
    _waitBeforeReconnect = 15 # time (in sec) to wait before reconnecting after loosing HTTP connection : 
    _connectionTimeout = 30
    
    requiresConfigFile = False
    httpconfig = None
    buffer = None
    _remoteFileOffset = None
    _nbConsecutiveConnFailure = 0
    _logAppend = False
    
    _httpdelay = 0.150
    
    def onStartup(self):
        versionsearch = re.search("^((?P<mainversion>[0-9]).(?P<lowerversion>[0-9]+)?)", sys.version)
        version = int(versionsearch.group(3))
        if version < 6:
            self.error('Python Version %s, this is not supported and may lead to hangs. Please update Python to 2.6' % versionsearch.group(1))
            self.console.die()

        if self.console.config.has_option('server', 'delay'):
            self._httpdelay = self.console.config.getfloat('server', 'delay')
        
        if self.console.config.has_option('server', 'local_game_log'):
            self.lgame_log = self.console.config.getpath('server', 'local_game_log')
        else:
            self.lgame_log = os.path.normpath(os.path.expanduser(self.console.input.name))
            self.debug('Local Game Log is %s' % self.lgame_log)
            
        if self.console.config.get('server','game_log')[0:7] == 'http://' :
            self.initThread(self.console.config.get('server','game_log'))

        if self.console.config.has_option('server', 'log_append'):
            self._logAppend = self.console.config.getboolean('server', 'log_append')
        else:
            self._logAppend = False

    def onLoadConfig(self):
        try:
            self._connectionTimeout = self.config.getint('settings', 'timeout')
        except: 
            self.warning("Error reading timeout from config file. Using default value")
        self.info("HTTP connection timeout: %s" % self._connectionTimeout)

        try:
            self._maxGap = self.config.getint('settings', 'maxGapBytes')
        except: 
            self.warning("Error reading maxGapBytes from config file. Using default value")
        self.info("Maximum gap allowed between remote and local gamelog: %s bytes" % self._maxGap)
    
    def initThread(self, httpfileDSN):
        self.httpconfig = functions.splitDSN(httpfileDSN)
        self.url = httpfileDSN
        thread1 = threading.Thread(target=self.update)
        self.info("Starting httpytail thread")
        thread1.start()

    class DiffURLOpener(urllib2.HTTPRedirectHandler, urllib2.HTTPDefaultErrorHandler):
        """Create sub-class in order to overide error 206.  This error means a
           partial file is being sent,
           which is ok in this case.  Do nothing with this error.
        """
        def http_error_206(self, url, fp, errcode, errmsg, headers, data=None):
            pass

    def update(self):
        try:
            self.file = open(self.lgame_log, 'ab')
            self.file.write('\r\n')
            self.file.write('B3 has been restarted\r\n')
            self.file.write('\r\n')
            self.file.close()
        except Exception, e:
            if hasattr(e, 'reason'):
                self.error(str(e.reason))
            if hasattr(e, 'code'):
                self.error(str(e.code))
            self.debug(str(e))
            
        while self.console.working:
            try:
                # Opening the local temporary file
                self.file = open(self.lgame_log, 'ab')
                # Crafting the HTTP request
                # - user agent header
                headers =  { 'User-Agent'  : user_agent  }
                
                # - file url
                if self.httpconfig['port']:
                    logurl = self.httpconfig['protocol']+'://'+self.httpconfig['host']+':'+self.httpconfig['port']+'/'+self.httpconfig['path']
                else:
                    logurl = self.httpconfig['protocol']+'://'+self.httpconfig['host']+'/'+self.httpconfig['path']
                
                req =  urllib2.Request(logurl, None, headers)

                # - htaccess authentication
                # we login if the file is protected by a .htaccess and .htpasswd and the user specified a username and password in the b3 config (eg : http://user:password@host/path)
                if self.httpconfig['user']:
                    username = self.httpconfig['user']
                    if self.httpconfig['password']:
                        password = self.httpconfig['password']
                    # create a password manager
                    password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
                    
                    # Add the username and password.
                    # If we knew the realm, we could use it instead of ``None``.
                    top_level_url = logurl
                    password_mgr.add_password(None, top_level_url, username, password)
                    
                    handler = urllib2.HTTPBasicAuthHandler(password_mgr)

                    # We store these parameters in an opener
                    opener = urllib2.build_opener(handler)
                else:
                    # Else if no authentication is needed, then we create a standard opener
                    opener = urllib2.build_opener()


                # Opening the full file and detect its size
                webFile =  opener.open(req)
                urllib2.install_opener(opener)
                filestats = webFile.info()
                remoteSize = filestats.getheader('Content-Length')
                webFile.close() # We close the remote connection as soon as possible to avoid spamming the server, and thus blacklisting us for an amount of time
                
                # If we just started B3, we move the cursor to the current file size
                if self._remoteFileOffset is None:
                        self._remoteFileOffset = remoteSize
                
                # debug line
                #self.debug('Diff - current cursor: %s - remote file size: %s' % (str(self._remoteFileOffset), str(remoteSize)) ) # please leave this debug line, it can be very useful for users to catch some weird things happening without errors, like if the webserver redirects the request because of too many connections (b3/delay is too short)

                # Detecting log rotation if remote file size is lower than our current cursor position
                if remoteSize < self._remoteFileOffset:
                    self.debug("remote file rotation detected")
                    self._remoteFileOffset = 0
                
                # Fetching the diff of the remote file if our cursor is lower than the remote file size
                if remoteSize > self._remoteFileOffset:
                    # For that, we use a custom made opener so that we can download only the diff between what has been added since last cycle
                    DiffURLOpener = self.DiffURLOpener()
                    httpopener = urllib2.build_opener(DiffURLOpener)
                    
                    b1 = self._remoteFileOffset
                    b2 = remoteSize
                    if int(b2) - int(b1) > self._maxGap:
                        b1 = int(b2) - self._maxGap
                    
                    # We add the Range header here, this is the one permitting to fetch only a part of an http remote file
                    range_bytes = "bytes=%s-%s" % (b1, b2)
                    self.verbose("requesting range %s" % range_bytes)
                    req.add_header("Range",range_bytes)
                    # Opening the section we want from the remote file
                    webFileDiff = httpopener.open(req)

                    # Adding the difference to our file (the file is cleaned at each startup by b3, in parser.py)
                    self.file.write(webFileDiff.read())
                    # We update the current cursor position to the size of the remote file
                    self._remoteFileOffset = remoteSize
                    
                    self.verbose("%s bytes downloaded" % webFileDiff.info().getheader('Content-Length'))
                    # Finally, we close the distant file
                    webFileDiff.close()

                # Closing the local temporary file
                self.file.close()
            except Exception, e:
                if hasattr(e, 'reason'):
                    self.error(str(e.reason))
                if hasattr(e, 'code'):
                    self.error(str(e.code))
                self.debug(str(e))
            except IOError, e:
                if hasattr(e, 'reason'):
                    self.error('Failed to reach the server. Reason : %s' % str(e.reason))
                if hasattr(e, 'code'):
                    self.error('The server could not fulfill the request. Error code : %s' % str(e.code))
                self.debug(str(e))

                self.file.close()
                self.debug('http error: resetting local log file?')
                if self._logAppend:
                    try:
                        self.file = open(self.lgame_log, 'ab')
                        self.file.write('\r\n')
                        self.file.write('B3 has restarted writing the log file\r\n')
                        self.file.write('\r\n')
                    except:
                        self.file = open(self.lgame_log, 'w')
                else:
                    self.file = open(self.lgame_log, 'w')
                self.file.close()
                self.file = open(self.lgame_log, 'ab')
                try:
                    self.webFile.close()
                    self.webFileDiff.close()
                    self.debug('HTTP Connection Closed')
                except:
                    pass
                webFile = None
                
                if self._nbConsecutiveConnFailure <= 30:
                    time.sleep(1)
                else:
                    self.debug('too many failures, sleeping %s sec' % self._waitBeforeReconnect)
                    time.sleep(self._waitBeforeReconnect)
            time.sleep(self._httpdelay)
        self.verbose("B3 is down, stopping Httpytail thread")
        try:
            webFile.close()
        except:
            pass
        try:
            self.file.close()
        except:
            pass
    
    
if __name__ == '__main__':
    from b3.fake import fakeConsole
    
    print "------------------------------------"
    config = b3.config.XmlConfigParser()
    config.setXml("""
    <configuration plugin="httpytail">
        <settings name="settings">
            <set name="timeout">15</set>
            <set name="maxGapBytes">1024</set>
        </settings>
    </configuration>
    """)
    p = HttpytailPlugin(fakeConsole, config)
    p.onStartup()
    p._httpdelay = 5
    p.initThread('http://www.somewhere.tld/somepath/somefile.log')
    time.sleep(300)
    fakeConsole.shutdown()
    time.sleep(8)
########NEW FILE########
__FILENAME__ = login
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Plugin for extra authentication of privileged users
# Copyright (C) 2005 Tim ter Laak (ttlogic@xlr8or.com)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# 1.0.1 - 23/08/2009 - Courgette
#     * fix indentation problem
# 1.0.2 - 28/08/2009 - xlr8or
#     * minor update
# 1.0.3 - 17/04/2010 - Bakes
#     * use hashlib if available instead of the deprecated md5
# 1.1 - 25/11/2012 - Courgette
#     * always read password from database to prevent security issues arising from bugged b3 game parsers
#
import string
from b3.clients import Client
import b3.events
import b3.plugin
from b3.functions import hash_password

__author__    = 'Tim ter Laak'
__version__ = '1.1'


class LoginPlugin(b3.plugin.Plugin):

    _pmcomm = ''

    def onLoadConfig(self):
        try:
            self.threshold = self.config.getint('settings', 'thresholdlevel') 
        except:
            self.threshold = 1000
            self.debug('Using default value (%i) for settings::thresholdlevel', self.threshold)
        try:
            self.passwdlevel = self.config.getint('settings', 'passwdlevel') 
        except:
            self.passwdlevel = 100
            self.debug('Using default value (%i) for settings::passwdlevel', self.passwdlevel)
        return


    def onStartup(self):
        self.registerEvent(b3.events.EVT_CLIENT_AUTH)
        self._adminPlugin = self.console.getPlugin('admin')
        if self._adminPlugin:
            self._adminPlugin.registerCommand(self, 'login', 2, self.cmd_login, secretLevel=1)
            self._adminPlugin.registerCommand(self, 'setpassword', self.passwdlevel, self.cmd_setpassword)

        # Whats the command to send a private message?
        if self.console.gameName[:5] == 'etpro':
            self._pmcomm = '/m'
        else:
            self._pmcomm = '/tell'
        self.debug('Using "%s" as the private messaging command' %self._pmcomm)


    def onEvent(self, event):
        if event.type == b3.events.EVT_CLIENT_AUTH:
            self.onAuth(event.client)
        else:
            self.debug('login.dumpEvent -- Type %s, Client %s, Target %s, Data %s', event.type, event.client, event.target, event.data)

    def onAuth(self, client):
        if client.maxLevel > self.threshold and not client.isvar(self, 'loggedin'):

            client_from_db = self._get_client_from_db(client.id)

            #save original groupbits
            client.setvar(self, 'login_groupbits', client_from_db.groupBits)

            #set new groupBits
            try:
                g = self.console.storage.getGroup('reg')
                client.groupBits = g.id
            except:
                client.groupBits = 2

            if not client_from_db.password:
                client.message('You need a password to use all your privileges. Ask the administrator to set a password for you.')
                return
            else:
                message = 'Login via console: %s %s !login yourpassword' %(self._pmcomm, client.cid)
                client.message(message)
                return

    def cmd_login(self, data, client, cmd=None):
        """\
        <password> - login a privileged user to his full capabilities
        """
        if client.isvar(self, 'loggedin'):
            client.message('You are already logged in.')
            return

        if not client.isvar(self, 'login_groupbits'):
            client.message('You do not need to log in.')
            return

        if data:
            digest = hash_password(data)
            client_from_db = self._get_client_from_db(client.id)
            if digest == client_from_db.password:
                client.setvar(self, 'loggedin', 1)
                client.groupBits = client.var(self, 'login_groupbits').value
                client.message('You are successfully logged in.')
                return
            else:
                client.message('^1***Access denied***^7')
                return
        else:
            message = 'Usage (via console): %s %s !login yourpassword' %(self._pmcomm, client.cid)
            client.message(message)
            return
        
    def cmd_setpassword(self, data, client, cmd=None):
        """\
        <password> [<name>] - set a password for a client
        """
        if not data:
            client.message('usage: %s%s <new password> [name]' % (cmd.prefix, cmd.command))
            return

        data = string.split(data)
        if len(data) > 1:
            sclient = self._adminPlugin.findClientPrompt(data[1], client)
            if not sclient: return        
            if client.maxLevel <= sclient.maxLevel and client.maxLevel < 100:
                client.message('You can only change passwords of yourself or lower level players.')
                return
        else:
            sclient = client

        sclient.password = hash_password(data[0])
        sclient.save()
        if client == sclient:
            client.message("your new password is saved")
        else:
            client.message("new password for %s saved" % sclient.name)


    def _get_client_from_db(self, client_id):
        return self.console.storage.getClient(Client(id=client_id))

########NEW FILE########
__FILENAME__ = pingwatch
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#    04/23/2010 - 1.2.2 - Bakes
#    Fix to !ci after bug reported by sgt
#    03/28/2010 - 1.2.1 - xlr8or
#    add default _minLevel for !ci if config option is missing
#    03/21/2010 - 1.2.0 - Bakes
#    Added the !ci command from the admin plugin.
#    11/30/2005 - 1.1.3 - ThorN
#    Use PluginCronTab instead of CronTab
#    8/29/2005 - 1.1.0 - ThorN
#    Converted to use new event handlers

__author__  = 'ThorN'
__version__ = '1.2.2'



import b3, time, thread
import b3.events
import b3.plugin
import b3.cron

#--------------------------------------------------------------------------------------------------
class PingwatchPlugin(b3.plugin.Plugin):
    _interval = 0
    _maxPing = 0
    _maxPingDuration = 0
    _ignoreTill = 0
    _cronTab = None
    _maxCiPing = 500
    _minLevel = 20

    def onStartup(self):
        self.registerEvent(b3.events.EVT_GAME_EXIT)

        # dont check pings on startup
        self._ignoreTill = self.console.time() + 120

    def onLoadConfig(self):
        try:
            self._minLevel = self.config.get('commands', 'ci')
        except:
            pass 

        self._interval = self.config.getint('settings', 'interval')
        self._maxPing = self.config.getint('settings', 'max_ping')
        self._maxPingDuration = self.config.getint('settings', 'max_ping_duration')

        if self._cronTab:
            # remove existing crontab
            self.console.cron - self._cronTab

        self._cronTab = b3.cron.PluginCronTab(self, self.check, '*/%s' % self._interval)
        self.console.cron + self._cronTab
        self._adminPlugin = self.console.getPlugin('admin')
        self._adminPlugin.registerCommand(self, 'ci', self._minLevel, self.cmd_ci)

    def onEvent(self, event):
        if event.type == b3.events.EVT_GAME_EXIT:
            # ignore ping watching for 2 minutes
            self._ignoreTill = self.console.time() + 120

    def check(self):        
        if self.isEnabled() and (self.console.time() > self._ignoreTill):        
            for cid,ping in self.console.getPlayerPings().items():
                #self.console.verbose('ping %s = %s', cid, ping)
                if ping > self._maxPing:                
                    client = self.console.clients.getByCID(cid)
                    if client:
                        if client.var(self, 'highping', 0).value > 0:
                            self.console.verbose('set high ping check %s = %s (%s)', cid, ping, client.var(self, 'highping', 0).value)
                            if self.console.time() - client.var(self, 'highping', 0).value > self._maxPingDuration:
                                if ping == 999:                            
                                    #client.kick('^7Connection interupted')
                                    self.console.say('^7%s ^7ping detected as Connection Interrupted (CI)' % client.name)
                                else:
                                    #client.kick('^7Ping too high %s' % ping)
                                    self.console.say('^7%s ^7ping detected as too high %s' % (client.name, ping))
                        else:
                            self.console.verbose('set ping watch %s = %s', cid, ping)
                            client.setvar(self, 'highping', self.console.time())

    def cmd_ci(self, data, client=None, cmd=None):
        """\
        <player> - Kick a player that has an interrupted connection
        """

        m = self._adminPlugin.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters, you must supply a player name')
            return False

        sclient = self._adminPlugin.findClientPrompt(m[0], client)
        if sclient:
            for cid,ping in self.console.getPlayerPings().items():
                if cid == sclient.cid:
                    if ping > self._maxCiPing:
                        sclient.kick(self._adminPlugin.getReason('ci'), 'ci', client)
                    else:
                        client.message('^7%s ^7is not CI' % sclient.exactName)
                    break
########NEW FILE########
__FILENAME__ = publist
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# $Id: publist.py 43 2005-12-06 02:17:55Z thorn $
#
# CHANGELOG
# 11/30/2005 - 1.0.3 - ThorN
# Use PluginCronTab instead of CronTab
# 23:29 17/07/2008 - 1.1.6- Courgette
# Add specific user-agent
# url is now store in a property
# add info: version, parserversion, database, plugins, os
# cron job will trigger at a random minute time to avoid jamming
# 22:58 18/07/2008 - 1.1.7 - Courgette
# add parser version and plugins' versions
# 7/7/2009 - 1.1.8 - xlr8or
# removed cvar check and critical stop
# 7/14/2009 - 1.1.9 - courgette
# bot version sent is now only the version number
# 10/5/2009 - 1.1.10 - xlr8or
# made the urllib not exit on error when connection to masterserver is impossible
# 10/19/2009 - 1.1.11 - Courgette
# add a timeout to the HTTP call (need urllib2 for that)
# initial call is now threaded
# 13/11/2009 - 1.1.12 - Courgette
# minor severity of messages
# do not send heartbeat when publicIP is obviously not public
# 23/11/2009 - 1.2.0 - Courgette
# * publist plugin now also update B3 master on shutdown
# 22/12/2009 - 1.3 - Courgette
# * bot version tells if the bot is built with py2exe
# 10/03/2010 - 1.4 - Courgette
# * rconPort is sent 
# 21/03/2010 - 1.4.1 - Courgette
# * fix rconPort when update type of ping is sent 
# 17/04/2010 - 1.5 - Courgette
# * allow to send ping to an additionnal master (mostly used for debugging master code)
# * send the python version to the master
# 29/10/2010 - 1.6 - Courgette
# * for BFBC2 and MoH send additional info : bannerUrl and serverDescription
# 05/11/2010 - 1.7 - Courgette
# * delay initial heartbeat and do not sent shutdown heartbeat if initial heartbeat was
#   not already sent. This is to prevent spaming the B3 master with rogue bots that
#   keep restarting forever
# 08/11/2010 - 1.8 - Courgette
# * initial delay can be changed in config file
# * if B3 master respond with "403 Forbidden" the plugin disables itself. This 
#   will allow the B3 master to prevent a bot to send further pings (until that bot restarts)
# 16/11/2010 - 1.9 - Courgette
# * "400 Bad Request" response prevents the plugin from sending further update hearbeats
# * when receiving "403 Forbidden", do not disable the plugin but remove the crontab
#   instead, so the bot can still send a shutdown fainting heartbeat http://goo.gl/4QHoq
# 30/12/2010 - 1.9.1 - xlr8or
# * change initial delay timer into one time cron tab
# 13/04/2011 - 1.10.0 - courgette
# * add default_encoding to sent info 
# 22/06/2011 - 1.10.1 - courgette
# * fix error on B3 shutdown/restart
# 12/08/2012 - 1.10.2 - courgette
# * do not crash when failing to read a plugin version
#
__version__ = '1.10.2'
__author__  = 'ThorN, Courgette'

import sys
import urllib
import urllib2
import socket
import time
import b3, os, random
import b3.events
import b3.plugin
from b3 import functions
from b3.functions import getModule




#--------------------------------------------------------------------------------------------------
class PublistPlugin(b3.plugin.Plugin):
    _cronTab = None
    _url='http://www.bigbrotherbot.net/master/serverping.php'
    _secondUrl = None
    requiresConfigFile = False
    
    _heartbeat_sent = False
    _initial_heartbeat_delay_minutes = 5
    
    def onLoadConfig(self):
        try:
            self._secondUrl = self.config.get('settings', 'url')
            self.debug('Using second url : %s' % self._secondUrl)
        except:
            pass
        
        try:
            self._initial_heartbeat_delay_minutes = self.config.getint('settings', 'delay')
            self.debug('delay : %s' % self._initial_heartbeat_delay_minutes)
        except:
            pass
            
    def onStartup(self):
      
        # get the plugin so we can register commands
        self._adminPlugin = self.console.getPlugin('admin')
        if not self._adminPlugin:
            # something is wrong, can't start without admin plugin
            self.error('Could not find admin plugin')
            return False

        
        # set cvar for advertising purposes
        try:
            cvarValue = 'B3 %s' % b3.versionId
            self.console.setCvar('_B3',cvarValue)
        except:
            pass
        
        
        if self.console._publicIp == '127.0.0.1':
            self.info("publist will not send heartbeat to master server as publicIp is not public.")
            return
        
        rmin = random.randint(0,59)
        rhour = random.randint(0,23)
        self.debug("publist will send heartbeat at %02d:%02d every day" % (rhour,rmin))
        self._cronTab = b3.cron.PluginCronTab(self, self.update, 0, rmin, rhour, '*', '*', '*')
        self.console.cron + self._cronTab
        
        # planning initial heartbeat
        # v1.9.1: Changing the threaded timer to a one time crontab to enable quick shutdown of the bot.
        _im = int(time.strftime('%M')) + self._initial_heartbeat_delay_minutes
        if _im >= 60:
            _im -= 60
        self.info('initial heartbeat will be sent to B3 master server at %s minutes' % (str(_im).zfill(2)))
        self._cronTab = b3.cron.OneTimeCronTab(self.update, 0, _im, '*', '*', '*', '*')
        self.console.cron + self._cronTab
       
      
    def onEvent(self, event):
        if event.type == b3.events.EVT_STOP and self._heartbeat_sent:
            self.shutdown()
    
    def removeCrontab(self):
        try:
            self.console.cron - self._cronTab
        except KeyError: 
            pass

    def shutdown(self):
        """Send a shutdown heartbeat to B3 master server"""
        self.info('Sending shutdown info to B3 master')
        info = {
            'action' : 'shutdown',
            'ip' : self.console._publicIp,
            'port' : self.console._port,
            'rconPort' : self.console._rconPort
        }
        #self.debug(info)
        self.sendInfo(info)
    
    def update(self):
        """send an upate heartbeat to B3 master server"""
        self.debug('Sending heartbeat to B3 master...')
        socket.setdefaulttimeout(10)
        
        plugins = []
        for pname in self.console._pluginOrder:
            try:
                p = self.console.getPlugin(pname)
                p_module = getModule(p.__module__)
                p_version = getattr(p_module, '__version__', 'Unknown Version')
                plugins.append("%s/%s" % (pname, p_version))
            except Exception, e:
                self.warning("Could not get version for plugin named '%s'" % pname, exc_info=e)
          
        try:
            database = functions.splitDSN(self.console.storage.dsn)['protocol']
        except:
            database = "unknown"
            
        version = getattr(b3, '__version__', 'Unknown Version')
        if b3.functions.main_is_frozen():
            version += " win32"
            
        info = {
            'action' : 'update',
            'ip' : self.console._publicIp,
            'port' : self.console._port,
            'rconPort' : self.console._rconPort,
            'version' : version,
            'parser' : self.console.gameName,
            'parserversion' : getattr(getModule(self.console.__module__), '__version__', 'Unknown Version'),
            'database' : database,
            'plugins' : ','.join(plugins),
            'os' : os.name,
            'python_version': sys.version,
            'default_encoding': sys.getdefaultencoding()
        }
        
        if self.console.gameName in ('bfbc2', 'moh', 'bf3'):
            try:
                cvarDescription = self.console.getCvar('serverDescription')
                if cvarDescription is not None:
                    info.update({'serverDescription': cvarDescription.value})
                cvarBannerUrl = self.console.getCvar('bannerUrl')
                if cvarBannerUrl is not None:
                    info.update({'bannerUrl': cvarBannerUrl.value})
            except Exception, err:
                self.debug(err)
        
        self.debug(info)
        self.sendInfo(info)
        
    
    def sendInfo(self, info={}):
        self.sendInfoToMaster(self._url, info)
        self._heartbeat_sent = True
        if self._secondUrl is not None:
            self.sendInfoToMaster(self._secondUrl, info)
    
    def sendInfoToMaster(self, url, info={}):
        try:
            request = urllib2.Request('%s?%s' % (url, urllib.urlencode(info)))
            request.add_header('User-Agent', "B3 Publist plugin/%s" % __version__)
            opener = urllib2.build_opener()
            replybody = opener.open(request).read()
            if len(replybody)>0: 
                self.debug("master replied: %s" % replybody)
        except IOError, e:
            if hasattr(e, 'reason'):
                self.error('Unable to reach B3 masterserver, maybe the service is down or internet was unavailable')
                self.debug(e.reason)
            elif hasattr(e, 'code'):
                if e.code == 400:
                    self.info('B3 masterserver refused the heartbeat. reason: %s. Disabling publist', e.msg)
                    self.removeCrontab()
                elif e.code == 403:
                    self.info('B3 masterserver definitely refused our ping. Disabling publist')
                    self.removeCrontab()
                else:
                    self.info('Unable to reach B3 masterserver, maybe the service is down or internet was unavailable')
                    self.debug(e)
        except:
            self.warning('Unable to reach B3 masterserver. unknown error')
            print sys.exc_info()


if __name__ == '__main__':
    from b3.fake import fakeConsole
    import time
    
    from b3.config import XmlConfigParser
    
    conf = XmlConfigParser()
    conf.setXml("""
    <configuration plugin="publist">
        <settings name="settings">
            <set name="urlsqdf">http://test.somewhere.com/serverping.php</set>
            <set name="url">http://localhost/b3publist/serverping.php</set>
            <set name="delay">30</set>
        </settings>
    </configuration>
    """)

    
    
    def test_startup():
        p._initial_heartbeat_delay = 10
        p.onStartup()
        time.sleep(5)
        print "_heartbeat_sent : %s" % p._heartbeat_sent
        time.sleep(20)
        print "_heartbeat_sent : %s" % p._heartbeat_sent
        fakeConsole.queueEvent(b3.events.Event(b3.events.EVT_STOP, None, None))
        #p.update()
    
    def test_heartbeat():
        p.sendInfo({'version': '1.3-dev', 
                'os': 'nt', 
                'database': 'unknown', 
                'action': 'update', 
                'ip': '91.121.95.52', 
                'parser': 'iourt41', 
                'plugins': '', 
                'port': 27960, 
                'parserversion': '1.2', 
                'rconPort': None,
                'python_version': sys.version,
                'default_encoding': sys.getdefaultencoding()
        })
        
    def test_heartbeat_homefront():
        p.sendInfo({'python_version': '2.6.4 (r264:75708, Oct 26 2009, 08:23:19) [MSC v.1500 32 bit (Intel)]', 
                    'ip': '205.234.152.101', 'parser': 'homefront', 
                    'plugins': 'censor/2.2.1,spamcontrol/1.1.2,admin/1.10.2,tk/1.2.4,stats/1.3.5,adv/1.2.2,status/1.4.4,welcome/1.1,publist/1.9.1', 
                    'port': 27015, 'database': 'mysql', 'parserversion': '0.0', 'version': '1.5.0', 
                    'action': 'update', 'os': 'nt', 'rconPort': 27010,
                    'default_encoding': sys.getdefaultencoding()})
    
    def test_heartbeat_local_urt():
        p.sendInfo({'version': '1.4.1b', 
                'os': 'nt', 
                'database': 'mysql', 
                'action': 'update', 
                'ip': '192.168.10.1', 
                'parser': 'iourt41', 
                'plugins': 'censorurt/0.1.2,admin/1.8.2,publist/1.7.1,poweradminurt/1.5.7,tk/1.2.4,adv/1.2.2', 
                'port': 27960, 
                'parserversion': '1.7.12', 
                'rconPort': 27960,
                'python_version': '2.6.4 (r264:75708, Oct 26 2009, 08:23:19) [MSC v.1500 32 bit (Intel)]',
                'default_encoding': sys.getdefaultencoding()
        })
        
    def test_heartbeat_b3_bfbc2():
        p.sendInfo({'version': '1.4.1b', 
                'os': 'nt', 
                'database': 'mysql', 
                'action': 'update', 
                'ip': '212.7.205.31', 
                'parser': 'bfbc2', 
                'plugins': 'censorurt/0.1.2,admin/1.8.2,publist/1.7.1,poweradminurt/1.5.7,tk/1.2.4,adv/1.2.2', 
                'port': 19567, 
                'parserversion': 'x.x.x', 
                'rconPort': 48888,
                'python_version': 'publist test',
                'serverDescription': 'publist plugin test|from admin: Courgette|email: courgette@bigbrotherbot.net| visit our web site : www.bigbrotherbot.net',
                'bannerUrl': 'http://www.lowpinggameservers.com/i/bc2.jpg',
                'default_encoding': sys.getdefaultencoding()
        })

    def test_crontab():
        def myUpdate():
            p.sendInfo({'version': '1.4.1b', 
                'os': 'nt', 
                'action': 'fake', 
                'ip': '212.7.205.31', 
                'parser': 'bfbc2', 
                'plugins': 'censorurt/0.1.2,admin/1.8.2,publist/1.7.1,poweradminurt/1.5.7,tk/1.2.4,adv/1.2.2', 
                'port': 19567, 
                'parserversion': 'x.x.x', 
                'rconPort': 48888,
                'python_version': 'publist test',
                'serverDescription': 'publist plugin test|from admin: Courgette|email: courgette@bigbrotherbot.net| visit our web site : www.bigbrotherbot.net',
                'bannerUrl': 'http://www.lowpinggameservers.com/i/bc2.jpg',
                'default_encoding': sys.getdefaultencoding()
                })
        p._cronTab = b3.cron.PluginCronTab(p, myUpdate, second='*/10')
        p.console.cron + p._cronTab
        
    
    #fakeConsole._publicIp = '127.0.0.1'
    fakeConsole._publicIp = '11.22.33.44'
    p = PublistPlugin(fakeConsole, conf)
    p.onLoadConfig()
    
    #test_heartbeat()
    #test_heartbeat_local_urt()
    #test_heartbeat_b3_bfbc2()
    test_heartbeat_homefront()
    #test_crontab()
    
    time.sleep(120) # so we can see thread working

    #p.sendInfo({'action' : 'shutdown', 'ip' : '91.121.95.52', 'port' : 27960, 'rconPort' : None })
    
########NEW FILE########
__FILENAME__ = punkbuster
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 19/07/2011 - 1.1.0 - Freelander
#    Support for ftp access to pbbans.dat
# 27/08/2009 - 1.0.9 - Bakes
#    Use command levels set in punkbuster plugin config not admin plugin.
# 11/30/2005 - 1.0.8 - ThorN
#    Use PluginCronTab instead of CronTab

__author__  = 'ThorN'
__version__ = '1.1.0'

import b3, time
import b3.plugin
import b3.cron
from b3 import functions
import StringIO
import ftplib

#--------------------------------------------------------------------------------------------------
class PunkbusterPlugin(b3.plugin.Plugin):
    _cronTab = None
    _rebuildBans = 0
    _remoteBansFile = False
    _ftpConfig = None

    def onStartup(self):
        self._adminPlugin = self.console.getPlugin('admin')
    
        if self._adminPlugin:
            self._adminPlugin.registerCommand(self, 'pbss', self.config.getint('commands', 'pbss'), self.cmd_pbss)
            self._adminPlugin.registerCommand(self, 'pbbuildbans', self.config.getint('commands', 'pbbuildbans'), self.cmd_pbbuildbans)

    def onLoadConfig(self):
        if self.config.get('settings','bans_file')[0:6] == 'ftp://':
            self._bansFile = self.config.get('settings','bans_file')
            self._remoteBansFile = True
            self._ftpConfig = functions.splitDSN(self._bansFile)
            self.info('Accessing pbbans.dat file in remote mode')
        else:
            self._bansFile = self.console.getAbsolutePath(self.config.get('settings', 'bans_file'))


        self._rebuildBans = self.config.get('settings', 'rebuild_bans')

        if self._cronTab:
            # remove old crontab
            self.console.cron - self._cronTab

        if self._rebuildBans == '0' or self._rebuildBans == 0:
            self._rebuildBans = 0
        else:
            minute, hour, day, month, dow = self._rebuildBans.split(' ')
            self._cronTab = b3.cron.PluginCronTab(self, self.rebuildBans, '0', minute, hour, day, month, dow)
            self.console.cron + self._cronTab

    def rebuildBans(self):
        """\
        Rebuild pbbans.dat from database
        """
        cursor = self.console.storage.query("""\
SELECT DISTINCT(c.id), c.name, c.ip, c.pbid, p.time_add, p.reason FROM penalties p, clients c
WHERE c.id = p.client_id && type = 'Ban' && p.inactive = 0 && 
p.time_expire = -1
ORDER BY p.time_add""")

        i = 0
        if self._remoteBansFile:
            f = StringIO.StringIO()
        else:
            f = file(self._bansFile , 'w')

        while not cursor.EOF:
            r = cursor.getRow()

            if r['reason'] != '':            
                f.write('[%s] %s "%s" "%s" %s" ""\r\n\r\n' % (time.strftime('%m.%d.%Y %H:%M:%S', time.localtime(int(r['time_add']))), r['pbid'], r['name'], r['ip'], r['reason']))
            else:
                f.write('[%s] %s "%s" "%s"\r\n\r\n' % (time.strftime('%m.%d.%Y %H:%M:%S', time.localtime(int(r['time_add']))), r['pbid'], r['name'], r['ip']))

            i += 1
            cursor.moveNext()

        cursor.close()

        if self._remoteBansFile:
            ftp = ftplib.FTP(self._ftpConfig['host'], self._ftpConfig['user'], self._ftpConfig['password'])
            f.seek(0)
            try:
                ftp.storbinary('STOR %s' % self._ftpConfig['path'], f)
            except Exception, err:
                self.error('ERROR: %s' % err)
            ftp.quit()
            self.debug('Uploaded pbbans.dat to FTP server successfully.')
        else:
            f.close()
            self.debug('Updated pbbans.dat successfully.')

        self.console.write('PB_SV_BanEmpty')
        self.console.write('PB_SV_BanLoad')

        return i

    def cmd_pbss(self, data, client=None, cmd=None):
        """\
        <player> - Capture a screenshot from the player
        """
        m = self._adminPlugin.parseUserCmd(data)
        if not m:
            client.message('^7Invalid parameters, you must supply a player name')
            return False

        sclient = self._adminPlugin.findClientPrompt(m[0], client)
        if sclient:
            client.message('^3PunkBuster: ^7 %s' % self.console.PunkBuster.getSs(sclient))

    def cmd_pbbuildbans(self, data, client=None, cmd=None):
        """\
        Rebuild punkbuster ban file
        """
        bans = self.rebuildBans()
        client.message('^3PunkBuster: ^7 rebuilt %s bans' % bans)

########NEW FILE########
__FILENAME__ = sftpytail
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2009 James "Bakes" Baker
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# CHANGELOG:
# 22/05/2012 - 1.0.3 - Courgette
#   * local_game_log config option can now use the @conf and @b3 shortcuts
# 26/05/2011 - 1.0.2 - 82ndab-Bravo17
#   *  Append to local log implemented
# 27/04/2011 - 1.0.1 - 82ndab-Bravo17
#   * Auto assign of unique local games_mp log file
# 22/10/2010 - 1.0 - Courgette
#   * obbey the SFTP URI scheme as described in http://tools.ietf.org/html/draft-ietf-secsh-scp-sftp-ssh-uri-04
# 07/09/2010 - 0.1.1 - GrosBedo
#   * b3/delay option now specify the delay between each ftp log fetching
#   * b3/local_game_log option to specify the temporary local log name (permits to manage remotely several servers at once)
# 01/09/2010 - 0.1 - Courgette
# * first attempt. Briefly tested. Seems to work


__version__ = '1.0.3'
__author__ = 'Courgette'
 
import b3, threading
from b3 import functions
import b3.plugin
import os.path
import time
try:
    import paramiko
except ImportError, e:
    log = b3.output.getInstance()
    log.critical("""Missing module paramiko. The paramiko module is required to connect with SFTP.
Install pycrypto from http://www.voidspace.org.uk/python/modules.shtml#pycrypto and paramiko from http://www.lag.net/paramiko/
""")
    raise e

#--------------------------------------------------------------------------------------------------
class SftpytailPlugin(b3.plugin.Plugin):
    ### settings
    _maxGap = 20480 # max gap in bytes between remote file and local file
    _waitBeforeReconnect = 15 # time (in sec) to wait before reconnecting after loosing FTP connection : 
    _connectionTimeout = 30
    
    requiresConfigFile = False
    sftpconfig = None
    buffer = None
    _remoteFileOffset = None
    _nbConsecutiveConnFailure = 0
    _logAppend = False

    _sftpdelay = 0.150
    
    def onStartup(self):
        if self.console.config.has_option('server', 'delay'):
            self._sftpdelay = self.console.config.getfloat('server', 'delay')
        
        if self.console.config.has_option('server', 'local_game_log'):
            self.lgame_log = self.console.config.getpath('server', 'local_game_log')
        else:
            # setup ip addresses
            self._publicIp = self.console.config.get('server', 'public_ip')
            self._port = self.console.config.getint('server', 'port')

            if self._publicIp[0:1] == '~' or self._publicIp[0:1] == '/':
                # load ip from a file
                f = file(self.console.getAbsolutePath(self._publicIp))
                self._publicIp = f.read().strip()
                f.close()
                
            logext = str(self._publicIp.replace('.', '_'))
            logext = 'games_mp_' + logext + '_' + str(self._port) + '.log'
            self.lgame_log = os.path.normpath(os.path.expanduser(logext))
            self.debug('Local Game Log is %s' % self.lgame_log)

        if self.console.config.get('server','game_log')[0:7] == 'sftp://' :
            self.initThread(self.console.config.get('server','game_log'))

        if self.console.config.has_option('server', 'log_append'):
            self._logAppend = self.console.config.getboolean('server', 'log_append')
        else:
            self._logAppend = False

    def onLoadConfig(self):
        try:
            self._connectionTimeout = self.config.getint('settings', 'timeout')
        except: 
            self.warning("Error reading timeout from config file. Using default value")
        self.info("FTP connection timeout: %s" % self._connectionTimeout)

        try:
            self._maxGap = self.config.getint('settings', 'maxGapBytes')
        except: 
            self.warning("Error reading maxGapBytes from config file. Using default value")
        self.info("Maximum gap allowed between remote and local gamelog: %s bytes" % self._maxGap)
        
    
    def initThread(self, ftpfileDSN):
        self.sftpconfig = functions.splitDSN(ftpfileDSN)
        thread1 = threading.Thread(target=self.update)
        self.info("Starting sftpytail thread")
        thread1.start()
    
    def update(self):
        def handleDownload(block):
            self.verbose('received %s bytes' % len(block))
            self._remoteFileOffset += len(block)
            if self.buffer is None:
                self.buffer = block
            else:
                self.buffer = self.buffer + block
        transport = sftp = None
        rfile = None
        self.file = open(self.lgame_log, 'ab')
        self.file.write('\r\n')
        self.file.write('B3 has been restarted\r\n')
        self.file.write('\r\n')
        while self.console.working:
            try:
                if not sftp:
                    transport, sftp = self.sftpconnect()
                    rfile = None
                    self._nbConsecutiveConnFailure = 0
                try:
                    #self.verbose("Getting remote file size for %s" % self.sftpconfig['path'])
                    remoteSize = sftp.stat(self.sftpconfig['path']).st_size
                    #self.verbose("Remote file size is %s" % remoteSize)
                except IOError, e:
                    self.critical(e)
                    raise e
                if self._remoteFileOffset is None:
                    self._remoteFileOffset = remoteSize
                if remoteSize < self._remoteFileOffset:
                    self.debug("remote file rotation detected")
                    self._remoteFileOffset = 0
                if remoteSize > self._remoteFileOffset:
                    if  (remoteSize - self._remoteFileOffset) > self._maxGap:
                        self.verbose('gap between local and remote file too large (%s bytes)', (remoteSize - self._remoteFileOffset))
                        self.verbose('downloading only the last %s bytes' % self._maxGap)
                        self._remoteFileOffset = remoteSize - self._maxGap
                    #self.debug('RETR from remote offset %s. (expecting to read at least %s bytes)' % (self._remoteFileOffset, remoteSize - self._remoteFileOffset))
                    if not rfile:
                        self.debug('opening remote game log file %s for reading' % self.sftpconfig['path'])
                        rfile = sftp.open(self.sftpconfig['path'], 'r')
                    rfile.seek(self._remoteFileOffset)
                    self.debug('reading remote game log file from offset %s' % self._remoteFileOffset)
                    handleDownload(rfile.read())      
                    if self.buffer:
                        self.file.write(self.buffer)
                        self.buffer = None
                        self.file.flush()
                    if self.console._paused:
                        self.console.unpause()
                        self.debug('Unpausing')
            except paramiko.SSHException, e:
                self.debug(str(e))
                self._nbConsecutiveConnFailure += 1
                self.verbose('Lost connection to server, pausing until updated properly')
                if self.console._paused is False:
                    self.console.pause()
                self.file.close()
                self.debug('sFtp error: resetting local log file?')
                if self._logAppend:
                    try:
                        self.file = open(self.lgame_log, 'ab')
                        self.file.write('\r\n')
                        self.file.write('B3 has restarted writing the log file\r\n')
                        self.file.write('\r\n')
                    except:
                        self.file = open(self.lgame_log, 'w')
                else:
                    self.file = open(self.lgame_log, 'w')
                self.file.close()
                self.file = open(self.lgame_log, 'ab')
                try:
                    rfile.close()
                    transport.close()
                    self.debug('sFTP Connection Closed')
                except:
                    pass
                rfile = None
                sftp = None
                
                if self._nbConsecutiveConnFailure <= 30:
                    time.sleep(1)
                else:
                    self.debug('too many failures, sleeping %s sec' % self._waitBeforeReconnect)
                    time.sleep(self._waitBeforeReconnect)
            time.sleep(self._sftpdelay)
        self.verbose("B3 is down, stopping sFtpytail thread")
        try: rfile.close()
        except: pass
        try: transport.close()
        except: pass
        try: self.file.close()
        except: pass
    
    def sftpconnect(self):
        hostname = self.sftpconfig['host']
        port = self.sftpconfig['port']
        username = self.sftpconfig['user']
        password = self.sftpconfig['password']
        
        # get host key, if we know one
        hostkeytype = None
        hostkey = None
        sftp = None
        try:
            host_keys = paramiko.util.load_host_keys(os.path.expanduser('~/.ssh/known_hosts'))
        except IOError:
            try:
                # try ~/ssh/ too, because windows can't have a folder named ~/.ssh/
                host_keys = paramiko.util.load_host_keys(os.path.expanduser('~/ssh/known_hosts'))
            except IOError:
                self.debug('*** Unable to open host keys file')
                host_keys = {}
                
        if host_keys.has_key(hostname):
            hostkeytype = host_keys[hostname].keys()[0]
            hostkey = host_keys[hostname][hostkeytype]
            self.info('Using host key of type %s' % hostkeytype)
        self.info('Connecting to %s ...', self.sftpconfig["host"])
        
        # now, connect and use paramiko Transport to negotiate SSH2 across the connection
        t = paramiko.Transport((hostname, port))
        t.connect(username=username, password=password, hostkey=hostkey)
        sftp = paramiko.SFTPClient.from_transport(t)
        channel = sftp.get_channel()
        channel.settimeout(self._connectionTimeout)
        self.console.clients.sync()
        self.info("Connection successful")
        return t, sftp
    
    
if __name__ == '__main__':
    from b3.fake import fakeConsole
    
    print "------------------------------------"
    config = b3.config.XmlConfigParser()
    config.setXml("""
    <configuration plugin="sftpytail">
        <settings name="settings">
            <set name="timeout">15</set>
            <set name="maxGapBytes">1024</set>
        </settings>
    </configuration>
    """)
    p = SftpytailPlugin(fakeConsole, config)

    
    print "------------------------------------"
    p = SftpytailPlugin(fakeConsole)

    p.initThread('sftp://www.somewhere.tld/somepath/somefile.log')
    time.sleep(30)
    fakeConsole.shutdown()
    time.sleep(8)
########NEW FILE########
__FILENAME__ = spamcontrol
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
# 2005/08/29 - 1.1.0 - ThorN
#   Converted to use new event handlers
# 2012/08/11 - 1.2 - Courgette
#   - Can define group for using the !spamins command different than mod_level
#   - Can define an alias for the !spamins command
#   - fix bug where the !spamins command would not accept uppercase argument
#   - refactor the plugin to allow game specific behavior to be injected at runtime
# 2012/08/11 - 1.3 - Courgette
#   - improve behavior when a spammer received a warning but continues to spam
# 2012/12/18 - 1.3.1 - Courgette
#   - fix regression that prevented the !spamins command to be registered since v1.2
#
from ConfigParser import NoOptionError
import b3, re
import b3.events
import b3.plugin

__author__  = 'ThorN, Courgette'
__version__ = '1.3.1'


class SpamcontrolPlugin(b3.plugin.Plugin):
    _maxSpamins = 10
    _modLevel = 20
    _falloffRate = 6.5

    # dict of <event type, func> that tell onEvent how to delegate event handling.
    # This mechanism allows game parsers to add behaviour for game specific events.
    eventHanlders = {}


    def onLoadConfig(self):
        try:
            self._maxSpamins = self.config.getint('settings', 'max_spamins')
            if self._maxSpamins < 0:
                self._maxSpamins = 0
        except (NoOptionError, ValueError), err:
            self._maxSpamins = 10
            self.warning("using default value %s for max_spamins. %s" % (self._maxSpamins, err))

        try:
            self._modLevel = self.console.getGroupLevel(self.config.get('settings', 'mod_level'))
        except (NoOptionError, KeyError), err:
            self.warning("using default value %s for mod_level. %s" % (self._modLevel, err))

        try:
            self._falloffRate = self.config.getfloat('settings', 'falloff_rate')
        except (NoOptionError, ValueError), err:
            self._falloffRate = 6.5
            self.warning("using default value %s for falloff_rate. %s" % (self._falloffRate, err))


    def onStartup(self):
        self.registerEvent(b3.events.EVT_CLIENT_SAY)
        self.registerEvent(b3.events.EVT_CLIENT_TEAM_SAY)

        self.eventHanlders = {
            b3.events.EVT_CLIENT_SAY: self.onChat,
            b3.events.EVT_CLIENT_TEAM_SAY: self.onChat,
            }

        self._adminPlugin = self.console.getPlugin('admin')
        if self._adminPlugin:
            # register commands
            if 'commands' in self.config.sections():
                for cmd in self.config.options('commands'):
                    level = self.config.get('commands', cmd)
                    sp = cmd.split('-')
                    alias = None
                    if len(sp) == 2:
                        cmd, alias = sp

                    func = self.getCmd(cmd)
                    if func:
                        self._adminPlugin.registerCommand(self, cmd, level, func, alias)
                    else:
                        self.warning("cannot find command function for '%s'" % cmd)

    def getCmd(self, cmd):
        """ return the method for a given command  """
        cmd = 'cmd_%s' % cmd
        if hasattr(self, cmd):
            func = getattr(self, cmd)
            return func
        return None

    def getTime(self):
        """ just to ease automated tests """
        return self.console.time()


    def cmd_spamins(self, data, client, cmd=None):
        """\
        [name] - display a spamins level
        """
        if data:
            sclient = self._adminPlugin.findClientPrompt(data, client)
        else:
            sclient = client

        if sclient:
            if sclient.maxLevel >= self._modLevel:
                cmd.sayLoudOrPM(client, '%s ^7is too cool to spam' % sclient.exactName)
            else:
                now = self.getTime()
                last_message_time = sclient.var(self, 'last_message_time', now).value
                gap = now - last_message_time

                maxspamins = spamins = sclient.var(self, 'spamins', 0).value
                spamins -= int(gap / self._falloffRate)

                if spamins < 1:
                    spamins = 0

                cmd.sayLoudOrPM(client, '%s ^7currently has %s spamins, peak was %s' % (sclient.exactName, spamins, maxspamins))


    def onEvent(self, event):
        if not event.client or event.client.maxLevel >= self._modLevel:
            return

        self.eventHanlders[event.type](event)


    def onChat(self, event):
        points = 0
        client = event.client
        text = event.data

        last_message = client.var(self, 'last_message').value

        color = re.match(r'\^[0-9]', event.data)
        if color and text == last_message:
            points += 5
        elif text == last_message:
            points += 3
        elif color:
            points += 2
        elif text.startswith('QUICKMESSAGE_'):
            points += 2
        else:
            points += 1

        if text[:1] == '!':
            points += 1

        self.add_spam_points(client, points, text)


    def add_spam_points(self, client, points, text):
        now = self.getTime()
        if client.var(self, 'ignore_till', now).value > now:
            #ignore the user
            raise b3.events.VetoEvent

        last_message_time = client.var(self, 'last_message_time', now).value
        gap = now - last_message_time

        if gap < 2:
            points += 1

        spamins = client.var(self, 'spamins', 0).value + points

        # apply natural points decrease due to time
        spamins -= int(gap / self._falloffRate)

        if spamins < 1:
            spamins = 0

        # set new values
        client.setvar(self, 'spamins', spamins)
        client.setvar(self, 'last_message_time', now)
        client.setvar(self, 'last_message', text)

        # should we warn ?
        if spamins >= self._maxSpamins:
            client.setvar(self, 'ignore_till', now + 2)
            self._adminPlugin.warnClient(client, 'spam')
            spamins = int(spamins / 1.5)
            client.setvar(self, 'spamins', spamins)
            raise b3.events.VetoEvent


########NEW FILE########
__FILENAME__ = stats
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#    04/14/2011 - 1.3.7 Courgette
#    * fix bug with !topstats and  !topxp
#    04/13/2011 - 1.3.6 Courgette
#    * import missing string module
#    10/30/2010 - 1.3.5 GrosBedo
#    * added show_awards and show_awards_xp
#    10/20/2010 - 1.3.4 GrosBedo
#    * clientKill and clientDamage separated from clientKillTeam and clientDamageTeam
#    10/20/2010 - 1.3.3 GrosBedo
#    * No more teamKills if team is unknown (eg: parser can't detect the team)
#    8/15/2010 - 1.3.2 GrosBedo
#    * Fixed disabling reset xp option
#    8/14/2010 - 1.3.1 Courgette
#    * move commands in the commands section of config
#    * allow to define aliases in config
#    * add automated tests
#    8/14/2010 - 1.3.0 GrosBedo
#    * Stats are now cleared at the beginning of next round (so they are still available at scoreboard)
#    * Moved the parameters to the xml config file (and added more)
#    * Added XP score and !topxp
#    * Setting to enable/disable score reset at round start
#    9/5/2005 - 1.2.0 - ThorN
#    * Added !topstats command
#    8/29/2005 - 1.1.0 - ThorN
#    * Converted to use new event handlers

__author__ = 'ThorN, GrosBedo'
__version__ = '1.3.7'


import string
import b3
import b3.events
import b3.plugin

#--------------------------------------------------------------------------------------------------
class StatsPlugin(b3.plugin.Plugin):
    _adminPlugin = None

    def onLoadConfig(self):
        try:
            self.mapstatslevel = self.config.getint('commands', 'mapstats')
        except:
            self.mapstatslevel = 0
            self.debug('Using default value (%i) for commands::mapstats', self.mapstatslevel)

        try:
            self.testscorelevel = self.config.getint('commands', 'testscore')
        except:
            self.testscorelevel = 0
            self.debug('Using default value (%i) for commands::testscore', self.testscorelevel)

        try:
            self.topstatslevel = self.config.getint('commands', 'topstats')
        except:
            self.topstatslevel = 2
            self.debug('Using default value (%i) for commands::topstats', self.topstatslevel)

        try:
            self.topxplevel = self.config.getint('commands', 'topxp')
        except:
            self.topxplevel = 2
            self.debug('Using default value (%i) for commands::topxp', self.topxplevel)

        try:
            self.startPoints = self.config.getint('settings', 'startPoints')
        except:
            self.startPoints = 100
            self.debug('Using default value (%i) for settings::startPoints', self.startPoints)

        try:
            self.resetscore = self.config.getboolean('settings', 'resetscore')
        except:
            self.resetscore = False
            self.debug('Using default value (%s) for settings::resetscore', self.resetscore)

        try:
            self.resetxp = self.config.getboolean('settings', 'resetxp')
        except:
            self.resetxp = False
            self.debug('Using default value (%s) for settings::resetxp', self.resetxp)

        try:
            self.show_awards = self.config.getboolean('settings', 'show_awards')
        except:
            self.show_awards = False
            self.debug('Using default value (%s) for settings::show_awards', self.show_awards)

        try:
            self.show_awards_xp = self.config.getboolean('settings', 'show_awards_xp')
        except:
            self.show_awards_xp = False
            self.debug('Using default value (%s) for settings::show_awards_xp', self.show_awards_xp)


    def onStartup(self):
        self._adminPlugin = self.console.getPlugin('admin')
        if not self._adminPlugin:
            self.critical('Cannot find the admin plugin. Disabling Stats plugin')
            self.disable()
            return False

        # register our commands
        if 'commands' in self.config.sections():
            for cmd in self.config.options('commands'):
                level = self.config.get('commands', cmd)
                sp = cmd.split('-')
                alias = None
                if len(sp) == 2:
                    cmd, alias = sp
                func = self.getCmd(cmd)
                if func:
                    self._adminPlugin.registerCommand(self, cmd, level, func, alias)


        self.registerEvent(b3.events.EVT_CLIENT_DAMAGE_TEAM)
        self.registerEvent(b3.events.EVT_CLIENT_KILL_TEAM)
        self.registerEvent(b3.events.EVT_CLIENT_KILL)
        self.registerEvent(b3.events.EVT_CLIENT_DAMAGE)
        #self.registerEvent(b3.events.EVT_CLIENT_DISCONNECT)
        self.registerEvent(b3.events.EVT_GAME_EXIT) # used to show awards at the end of round
        #self.registerEvent(b3.events.EVT_GAME_ROUND_END) # used to show awards at the end of round
        self.registerEvent(b3.events.EVT_GAME_ROUND_START) # better to reinit stats at round start than round end, so that players can still query their stats at the end

    def onEvent(self, event):
        if event.type == b3.events.EVT_GAME_EXIT:
            if self.show_awards: self.cmd_topstats(None)
            if self.show_awards_xp: self.cmd_topxp(None)
        elif event.type == b3.events.EVT_GAME_ROUND_START:
            self.debug('Map Start: clearing stats')
            for cid, c in self.console.clients.items():
                if c.maxLevel >= self.mapstatslevel:
                    try:
                        c.setvar(self, 'shotsTeamHit', 0)
                        c.setvar(self, 'damageTeamHit', 0)
                        c.setvar(self, 'shotsHit', 0)
                        c.setvar(self, 'damageHit', 0)
                        c.setvar(self, 'shotsGot', 0)
                        c.setvar(self, 'damageGot', 0)
                        c.setvar(self, 'teamKills', 0)
                        c.setvar(self, 'kills', 0)
                        c.setvar(self, 'deaths', 0)

                        if self.resetscore:
                            # skill points are reset at the beginning of each map
                            c.setvar(self, 'pointsLost', 0)
                            c.setvar(self, 'pointsWon', 0)
                            c.setvar(self, 'points', self.startPoints)
                        if self.resetxp:
                            c.setvar(self, 'experience', 0)
                        else:
                            c.var(self, 'oldexperience', 0).value += c.var(self, 'experience', 0).value
                            c.setvar(self, 'experience', 0)
                    except:
                        pass
        elif event.client:
            if event.type == b3.events.EVT_CLIENT_DAMAGE:
                self.clientDamage(event.client, event.target, int(event.data[0]))
            elif event.type == b3.events.EVT_CLIENT_DAMAGE_TEAM:
                self.clientDamageTeam(event.client, event.target, int(event.data[0]))
            elif event.type == b3.events.EVT_CLIENT_KILL:
                self.clientKill(event.client, event.target, int(event.data[0]))
            elif event.type == b3.events.EVT_CLIENT_KILL_TEAM:
                self.clientKillTeam(event.client, event.target, int(event.data[0]))


    def getCmd(self, cmd):
        """ return the method for a given command  """
        cmd = 'cmd_%s' % cmd
        if hasattr(self, cmd):
            func = getattr(self, cmd)
            return func
        return None


    def clientDamage(self, killer, victim, points):
        if points > 100:
            points = 100

        killer.var(self, 'shotsHit', 0).value  += 1
        killer.var(self, 'damageHit', 0).value += points

        victim.var(self, 'shotsGot', 0).value  += 1
        victim.var(self, 'damageGot', 0).value += points
        return

    def clientDamageTeam(self, killer, victim, points):
        if points > 100:
            points = 100

        killer.var(self, 'shotsTeamHit', 0).value  += 1
        killer.var(self, 'damageTeamHit', 0).value += points
        return

    def clientKill(self, killer, victim, points):
        if points > 100:
            points = 100

        killer.var(self, 'shotsHit', 0).value  += 1
        killer.var(self, 'damageHit', 0).value += points

        victim.var(self, 'shotsGot', 0).value  += 1
        victim.var(self, 'damageGot', 0).value += points

        killer.var(self, 'kills', 0).value  += 1
        victim.var(self, 'deaths', 0).value += 1

        score = self.score(killer, victim)
        killer.var(self, 'points', self.startPoints).value += score
        killer.var(self, 'pointsWon', 0).value += score

        victim.var(self, 'points', self.startPoints).value -= score
        victim.var(self, 'pointsLost', 0).value += score

        self.updateXP(killer)
        self.updateXP(victim)
        
        return

    def clientKillTeam(self, killer, victim, points):
        if points > 100:
            points = 100

        killer.var(self, 'shotsTeamHit', 0).value  += 1
        killer.var(self, 'damageTeamHit', 0).value += points

        killer.var(self, 'teamKills', 0).value += 1

        score = self.score(killer, victim)
        killer.var(self, 'points', self.startPoints).value -= score
        killer.var(self, 'pointsLost', 0).value += score

        self.updateXP(killer)
        self.updateXP(victim)
        
        return

    def updateXP(self, sclient):
        realpoints = sclient.var(self, 'pointsWon', 0).value - sclient.var(self, 'pointsLost', 0).value
        if sclient.var(self, 'deaths', 0).value != 0:
            experience = (sclient.var(self, 'kills', 0).value * realpoints) / sclient.var(self, 'deaths', 0).value
        else:
            experience = sclient.var(self, 'kills', 0).value * realpoints
        sclient.var(self, 'experience', 0).value = experience

    def cmd_mapstats(self, data, client, cmd=None):
        """\
        [<name>] - list a players stats for the map
        """
        if data:
            sclient = self._adminPlugin.findClientPrompt(data, client)
            if not sclient: return            
        else:
            sclient = client

        message = '^3Stats ^7[ %s ^7] K ^2%s ^7D ^3%s ^7TK ^1%s ^7Dmg ^5%s ^7Skill ^3%1.02f ^7XP ^6%s' % (sclient.exactName, sclient.var(self, 'kills', 0).value, sclient.var(self, 'deaths', 0).value, sclient.var(self, 'teamKills', 0).value, sclient.var(self, 'damageHit', 0).value, round(sclient.var(self, 'points', self.startPoints).value, 2), round(sclient.var(self, 'oldexperience', 0).value + sclient.var(self, 'experience', 0).value, 2))
        cmd.sayLoudOrPM(client, message)

    def cmd_testscore(self, data, client, cmd=None):
        """\
        <name> - how much skill points you will get if you kill the player
        """

        if not data:
            client.message('^7You must supply a player name to test')
            return

        sclient = self._adminPlugin.findClientPrompt(data, client)
        if not sclient: return    
        elif sclient == client:
            client.message('^7You don\'t get points for killing yourself')
            return

        cmd.sayLoudOrPM(client, '^3Stats: ^7%s^7 will get ^3%s ^7skill points for killing %s^7' % (client.exactName, self.score(client, sclient), sclient.exactName))

    def cmd_topstats(self, data, client=None, cmd=None):
        """\
        List the top 5 map-stats players
        """
        self.debug('Haha')
        scores = []
        for c in self.console.clients.getList():
            if c.isvar(self, 'points'):
                scores.append((c.exactName, round(c.var(self, 'points', self.startPoints).value, 2)))
        
        if len(scores):
            tmplist = [(x[1], x) for x in scores]
            tmplist.sort()
            scores = [x for (key, x) in tmplist]
            scores.reverse()

            i = 0
            results = []
            for name, score in scores:
                i += 1

                if i >= 6:
                    break

                results.append('^3#%s^7 %s ^7[^3%s^7]' % (i, name, score))
                
            if client:        
                client.message('^3Top Stats:^7 %s' % string.join(results,', '))
            else:
                self.console.say('^3Top Stats:^7 %s' % string.join(results,', '))
        else:
            client.message('^3Stats: ^7No top players')

    def cmd_topxp(self, data, client=None, cmd=None):
        """\
        List the top 5 map-stats most experienced players
        """

        scores = []
        for c in self.console.clients.getList():
            if c.isvar(self, 'experience'):
                scores.append((c.exactName, round(c.var(self, 'experience', self.startPoints).value, 2)))

        if len(scores):
            tmplist = [(x[1], x) for x in scores]
            tmplist.sort()
            scores = [x for (key, x) in tmplist]
            scores.reverse()

            i = 0
            results = []
            for name, score in scores:
                i += 1

                if i >= 6:
                    break

                results.append('^3#%s^7 %s ^7[^3%s^7]' % (i, name, score))

            if client:
                client.message('^3Top Experienced Players:^7 %s' % string.join(results, ', '))
            else:
                self.console.say('^3Top Experienced Players:^7 %s' % string.join(results, ', '))
        else:
            client.message('^3Stats: ^7No top experienced players')

    def score(self, killer, victim):
        k = int(killer.var(self, 'points', self.startPoints).value)
        v = int(victim.var(self, 'points', self.startPoints).value)

        if k < 1:
            k = 1.00
        if v < 1:
            v = 1.00

        """
        if k > v:
            high = k
            low  = v
        else:
            high = v
            low  = k

        vshift = float(high) / float(low)
        self.console.verbose('stats vshift %s' % vshift)

        #per = (vshift * 100) / 10
        per = (vshift * 10.0) / 100.0

        self.console.verbose('stats per %s' % per)

        if per > 100:
            per = 100.0
        elif per < 1:
            per = 1.0
        """

        vshift = (float(v) / float(k)) / 2
        self.console.verbose('stats vshift %s' % vshift)

        points = (15.00 * vshift) + 5

        if points < 1:
            points = 1.00
        elif points > 100:
            points = 100.00

        return round(points, 2)

"""
#--------------------------------------------------------------------------------------------------
class ClientStats(DelayedSQLObject):
    _table = 'stats'
    timeAdd = IntCol(default=0)
    kills = IntCol(default=0)
    teamKills = IntCol(default=0)
    deaths = IntCol(default=0)
    score  = IntCol(default=0)
    shotsGot  = IntCol(default=0)
    shotsHit  = IntCol(default=0)
    damageGot  = IntCol(default=0)
    damageHit  = IntCol(default=0)
    captures = IntCol(default=0)
    pickups = IntCol(default=0)
    rank = IntCol(default=0)
    gameName = StringCol(default='',length=3)
    gameType = StringCol(default='',length=3)
    pointsWon = IntCol(default=0)
    pointsLost = IntCol(default=0)
    playTime = IntCol(default=0)

    lastEventTime = 0

#    client = ForeignKey('Clients.Client')

    def __init__(self):
        ClientStats.__init__(self)
        self.createTable(ifNotExists=True)
        
    def experiance(self):
        return ( self.kills + self.deaths ) / ( (self.pointsWon + self.pointsLost) / self.playTime )

    def save(self):
        self.playTime += ( (time.time() - time.timezone) - self.lastEventTime ) / 60
        #DelayedSQLObject.save(self)
"""


if __name__ == '__main__':
    """
    Automated tests below
    """
    from b3.fake import fakeConsole
    from b3.fake import superadmin, joe 
    import time
    
    from b3.config import XmlConfigParser
    
    conf = XmlConfigParser()
    conf.setXml("""
<configuration plugin="stats">
  <settings name="commands">
    <set name="mapstats-mystatalias">0</set>
    <set name="testscore-tscr">0</set>
    <set name="topstats-tops">2</set>
    <set name="topxp-txp">2</set>
  </settings>
  <settings name="settings">
    <set name="startPoints">100</set>
    <set name="resetscore">no</set>
    <set name="resetxp">no</set>
  </settings>
</configuration>
    """)

    
    p = StatsPlugin(fakeConsole, conf)
    p.onStartup()
    p.onLoadConfig()
    
    time.sleep(1)
    joe.connects(cid=3)
    joe.says("!mapstats")
    joe.says("!mystatalias")
    joe.says("!testscore")
    joe.says("!tscr")
    joe.says("!topstats")
    joe.says("!tops")
    joe.says("!topxp")
    joe.says("!txp")
    
    
    superadmin.connects(cid=2)
    joe.kills(superadmin)
    joe.kills(superadmin)
    joe.kills(superadmin)
    superadmin.kills(joe)
    
    superadmin.says("!mapstats")
    superadmin.says("!mystatalias")
    superadmin.says("!testscore")
    superadmin.says("!tscr")
    superadmin.says("!topstats")
    superadmin.says("!tops")
    superadmin.says("!topxp")
    superadmin.says("!txp")
    
    

########NEW FILE########
__FILENAME__ = status
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA    02110-1301    USA
#
# CHANGELOG
# 10/02/2013 - 1.4.13 - Courgette
# * add log message with more precise info when failing to sanitize data
# 26/10/2012 - 1.4.12 - Courgette, xlr8or
# * makes sure 'Client' tags have a 'score' attribute
# * Better sync of DB and XML saving for XLRstats v3 webfront
# 12/08/2012 - 1.4.11 - Courgette
# * will provide more debugging info about errors while generating the XML document
# 05/05/2012 - 1.4.10 - Courgette
# * fixes reading config options 'svar_table' and 'client_table'
# 19/07/2011 - 1.4.9 - Freelander
# * fix errors during map change
# 25/04/2011 - 1.4.8 - Courgette
# * in config file, settings/output_file can now use shortcuts such as @b3 and @conf
# 17/04/2011 - 1.4.7 - Courgette
# * XML file generated is now using UTF-8 encoding
# 17/04/2011 - 1.4.6 - Courgette
# * unicode compliant
# 30/03/2011 - 1.4.5 - SGT
# * bugfix camelCasing timeLimit and fragLimit
# 06/01/2011 - 1.4.4 - Gammelbob
# * additionally stores current svars and clients in database
# 13/08/2010 - 1.4.3 - xlr8or
# * Added running roundtime and maptime
# 08/08/2010 - 1.4.2 - xlr8or
# * Moved 'Game section' before 'Clients section', XLRstats needs gameinfo before it adds clients to the playerlist
# 21/03/2010 - 1.4.1 - Courgette
# * does not fail if there is no player score available
# * make errors more verbose
# 23/11/2009 - 1.4.0 - Courgette
# on bot shutdown, write an empty status.xml document.
# add tests
# 03/11/2009 - 1.3.1 - Bakes
# XML code is now produced through xml.dom.minidocument rather than concatenation. This has a number of advantages.
# 03/11/2009 - 1.3.0 - Bakes
# Combined statusftp and status. Use syntax ftp://user:password@host/path/to/status.xml
# 11/02/2009 - 1.2.7 - xlr8or
# If masked show masked level instead of real level
# 11/02/2009 - 1.2.6 - xlr8or
# Sanitized xml data, cleaning ascii < 32 and > 126 (func is in functions.py)
# 21/11/2008 - 1.2.5 - Anubis
# Added PlayerScores
# 12/03/2008 - 1.2.4 - Courgette
# Properly escape strings to ensure valid xml
# 11/30/2005 - 1.2.3 - ThorN
# Use PluginCronTab instead of CronTab
# 8/29/2005 - 1.2.0 - ThorN
# Converted to use new event handlers

__author__    = 'ThorN'
__version__ = '1.4.13'

import b3
import time
import os
import StringIO
import re
import b3.plugin
import b3.cron
from cgi import escape
from ftplib import FTP
from b3 import functions
from xml.dom.minidom import Document
from b3.functions import sanitizeMe

#--------------------------------------------------------------------------------------------------
class StatusPlugin(b3.plugin.Plugin):
    _tkPlugin = None
    _cronTab = None
    _ftpstatus = False
    _ftpinfo = None
    _enableDBsvarSaving = False
    _svarTable = 'current_svars'
    _enableDBclientSaving = False
    _clientTable = 'current_clients'
    
    def onLoadConfig(self):
        if self.config.get('settings','output_file')[0:6] == 'ftp://':
            self._ftpinfo = functions.splitDSN(self.config.get('settings','output_file'))
            self._ftpstatus = True
        else:        
            self._outputFile = self.config.getpath('settings', 'output_file')
                
        self._tkPlugin = self.console.getPlugin('tk')
        self._interval = self.config.getint('settings', 'interval')
        try:
            self._enableDBsvarSaving = self.config.getboolean('settings', 'enableDBsvarSaving')
        except:
            self._enableDBsvarSaving = False
        try:
            self._enableDBclientSaving = self.config.getboolean('settings', 'enableDBclientSaving')
        except:
            self._enableDBclientSaving = False

        try:
            self._svarTable = self.config.get('settings', 'svar_table')
            self.debug('Using custom table for saving server svars: %s' % self._svarTable)
        except:
            self.debug('Using default table for saving server svars: %s' % self._svarTable)
        try:
            self._clientTable = self.config.get('settings', 'client_table')
            self.debug('Using custom table for saving current clients: %s' % self._clientTable)
        except:
            self.debug('Using default table for saving current clients: %s' % self._clientTable)

        if self._enableDBsvarSaving:
            sql = "CREATE TABLE IF NOT EXISTS `%s` (`id` int(11) NOT NULL auto_increment,`name` varchar(255) NOT NULL,`value` varchar(255) NOT NULL, PRIMARY KEY  (`id`), UNIQUE KEY `name` (`name`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;" % (self._svarTable)
            self.console.storage.query(sql)
        if self._enableDBclientSaving:
            sql = "CREATE TABLE IF NOT EXISTS `%s` (`id` INT(3) NOT NULL AUTO_INCREMENT,`Updated` INT(10) NOT NULL ,`Name` VARCHAR(32) NOT NULL ,`Level` INT(10) NOT NULL ,`DBID` INT(10) NOT NULL ,`CID` INT(3) NOT NULL ,`Joined` VARCHAR(25) NOT NULL ,`Connections` INT(11) NOT NULL ,`State` INT(1) NOT NULL ,`Score` INT(10) NOT NULL ,`IP` VARCHAR(16) NOT NULL ,`GUID` VARCHAR(36) NOT NULL ,`PBID` VARCHAR(32) NOT NULL ,`Team` INT(1) NOT NULL ,`ColorName` VARCHAR(32) NOT NULL, PRIMARY KEY (`id`)) ENGINE = MYISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1;" % (self._clientTable)
            self.console.storage.query(sql)

        if self._cronTab:
            # remove existing crontab
            self.console.cron - self._cronTab

        self._cronTab = b3.cron.PluginCronTab(self, self.update, '*/%s' % self._interval)
        self.console.cron + self._cronTab

    def onEvent(self, event):
        if event.type == b3.events.EVT_STOP:
            self.info('B3 stop/exit.. updating status')
            # create an empty status document
            xml = Document()
            b3status = xml.createElement("B3Status")
            b3status.setAttribute("Time", time.asctime())
            xml.appendChild(b3status)
            self.writeXML(xml.toprettyxml(indent="        "))

    def update(self):
        clients = self.console.clients.getList()
        scoreList = self.console.getPlayerScores() 
                 
        self.verbose('Building XML status')
        xml = Document()
        # --- Main section
        b3status = xml.createElement("B3Status")
        b3status.setAttribute("Time", time.asctime())
        xml.appendChild(b3status)

        # --- Game section
        c = self.console.game
        gamename = ''
        gametype = ''
        mapname = ''
        timelimit = ''
        fraglimit = ''
        capturelimit = ''
        rounds = ''
        roundTime = ''
        mapTime = ''
        if c.gameName:
            gamename = c.gameName
        if c.gameType:
            gametype = c.gameType
        if c.mapName:
            mapname = c.mapName
        if c.timeLimit:
            timelimit = c.timeLimit
        if c.fragLimit:
            fraglimit = c.fragLimit
        if c.captureLimit:
            capturelimit = c.captureLimit
        if c.rounds:
            rounds = c.rounds
        if c.roundTime:
            roundTime = c.roundTime()
        if c.mapTime():
            mapTime = c.mapTime()
        # For XML:
        game = xml.createElement("Game")
        game.setAttribute("Ip", str(self.console._publicIp))
        game.setAttribute("Port", str(self.console._port))
        game.setAttribute("Name", str(gamename))
        game.setAttribute("Type", str(gametype))
        game.setAttribute("Map", str(mapname))
        game.setAttribute("TimeLimit", str(timelimit))
        game.setAttribute("FragLimit", str(fraglimit))
        game.setAttribute("CaptureLimit", str(capturelimit))
        game.setAttribute("Rounds", str(rounds))
        game.setAttribute("RoundTime", str(roundTime))
        game.setAttribute("MapTime", str(mapTime))
        game.setAttribute("OnlinePlayers", str(len(clients)))
        b3status.appendChild(game)
        # For DB:
        self.storeServerinfo("Ip", str(self.console._publicIp))
        self.storeServerinfo("Port", str(self.console._port))
        self.storeServerinfo("Name", str(gamename))
        self.storeServerinfo("Type", str(gametype))
        self.storeServerinfo("Map", str(mapname))
        self.storeServerinfo("TimeLimit", str(timelimit))
        self.storeServerinfo("FragLimit", str(fraglimit))
        self.storeServerinfo("CaptureLimit",str(capturelimit) )
        self.storeServerinfo("Rounds", str(rounds))
        self.storeServerinfo("RoundTime", str(roundTime))
        self.storeServerinfo("MapTime", str(mapTime))
        self.storeServerinfo("OnlinePlayers", str(len(clients)))

        for k,v in self.console.game.__dict__.items():
            data = xml.createElement("Data")
            data.setAttribute("Name", str(k))
            data.setAttribute("Value", str(v))
            game.appendChild(data)
            self.storeServerinfo(k, v)

        if self._enableDBsvarSaving:
            sql = "INSERT INTO %s (name, value) VALUES ('lastupdate',UNIX_TIMESTAMP()) ON DUPLICATE KEY UPDATE value = VALUES(value);" % (self._svarTable)
            try:
                self.console.storage.query(sql)
            except:
                self.error('Error: inserting svars. sqlqry=%s' % (sql))
        # --- End Game section        

        # --- Clients section
        b3clients = xml.createElement("Clients")
        b3clients.setAttribute("Total", str(len(clients)))
        b3status.appendChild(b3clients)

        if self._enableDBclientSaving:
            # empty table current_clients
            sql = "TRUNCATE TABLE `%s`;" % (self._clientTable)
            self.console.storage.query(sql)

        for c in clients:
            if not c.name:
                c.name = "@"+str(c.id)
            if c.exactName == "^7":
                c.exactName = "@"+str(c.id)+"^7"

            if not c.maskedLevel:
                _level = c.maxLevel
            else:
                _level = c.maskedLevel

            try:
                client = xml.createElement("Client")
                client.setAttribute("Name", sanitizeMe(c.name))
                client.setAttribute("ColorName", sanitizeMe(c.exactName))
                client.setAttribute("DBID", str(c.id))
                client.setAttribute("Connections", str(c.connections))
                client.setAttribute("CID", c.cid)
                client.setAttribute("Level", str(_level))
                if c.guid:
                    client.setAttribute("GUID", c.guid)
                else:
                    client.setAttribute("GUID", '')
                if c.pbid:
                    client.setAttribute("PBID", c.pbid)
                else:
                    client.setAttribute("PBID", '')
                client.setAttribute("IP", c.ip)
                client.setAttribute("Team", str(c.team))
                client.setAttribute("Joined", str(time.ctime(c.timeAdd)))
                client.setAttribute("Updated", str(time.ctime(c.timeEdit)))
                if scoreList and c.cid in scoreList:
                    client.setAttribute("Score", str(scoreList[c.cid]))
                else:
                    client.setAttribute("Score", "")
                client.setAttribute("State", str(c.state))
                if self._enableDBclientSaving:
                    qryBuilderKey = ""
                    qryBuilderValue = ""
                    # get our attributes
                    for k, v in client.attributes.items():
                        # build the qrystring
                        qryBuilderKey = "%s%s," % (qryBuilderKey, k)
                        qryBuilderValue = "%s'%s'," % (qryBuilderValue, v)
                    # cut last ,
                    qryBuilderKey = qryBuilderKey[:-1]
                    qryBuilderValue = qryBuilderValue[:-1]
                    # and insert
                    try:
                        sql = "INSERT INTO %s (%s) VALUES (%s); " % (self._clientTable, qryBuilderKey, qryBuilderValue)
                        self.console.storage.query(sql)
                    except:
                        self.error('Error: inserting clients. sqlqry=%s' % (sql))

                b3clients.appendChild(client)
                for k,v in c.data.iteritems():
                    data = xml.createElement("Data")
                    data.setAttribute("Name", "%s" % k)
                    try:
                        clean_data = sanitizeMe(v)
                    except Exception, err:
                        self.error("could not sanitize %r" % v, exc_into=err)
                        data.setAttribute("Value", "")
                    else:
                        data.setAttribute("Value", clean_data)
                    client.appendChild(data)
                        
                if self._tkPlugin:
                    if hasattr(c, 'tkplugin_points'):
                        tkplugin = xml.createElement("TkPlugin")
                        tkplugin.setAttribute("Points", str(c.var(self, 'points')))
                        client.appendChild(tkplugin)            
                        if hasattr(c, 'tkplugin_attackers'):
                            for acid,points in c.var(self, 'attackers').value.items():
                                try:
                                    attacker = xml.createElement("Attacker")
                                    attacker.setAttribute("Name", sanitizeMe(self.console.clients[acid].name))
                                    attacker.setAttribute("CID", str(acid))
                                    attacker.setAttribute("Points", str(points))
                                    tkplugin.appendChild(attacker)
                                except:
                                    pass
                                
            except Exception, err:
                self.error('XML Failed: %r' % err, exc_info=err)
                pass

        # --- End Clients section

        self.writeXML(xml.toprettyxml(encoding="UTF-8", indent="        "))

    def storeServerinfo(self, k, v):
        if self._enableDBsvarSaving:
            #remove forbidden sql characters
            _k = re.sub("'", "", str(k))
            _v = re.sub("'", "", str(v))[:255] # length of the database varchar field
            sql = "INSERT INTO %s (name, value) VALUES ('%s','%s') ON DUPLICATE KEY UPDATE value = VALUES(value);" % (self._svarTable, _k, _v)
            try:
                self.console.storage.query(sql)
            except:
                self.error('Error: inserting svars. sqlqry=%s' % (sql))

    def writeXML(self, xml):
        if self._ftpstatus == True:
            self.debug('Uploading XML status to FTP server')
            ftp=FTP(self._ftpinfo['host'],self._ftpinfo['user'],passwd=self._ftpinfo['password'])
            ftp.cwd(os.path.dirname(self._ftpinfo['path']))
            ftpfile = StringIO.StringIO()
            ftpfile.write(xml)
            ftpfile.seek(0)
            ftp.storbinary('STOR '+os.path.basename(self._ftpinfo['path']), ftpfile)
        else:
            self.debug('Writing XML status to %s', self._outputFile)
            f = file(self._outputFile, 'w')
            f.write(xml)
            f.close()
            
            
if __name__ == '__main__':
    from b3.fake import fakeConsole
    from b3.fake import joe
    from b3.fake import simon
    
    p = StatusPlugin(fakeConsole, "@b3/conf/plugin_status.xml")
    p.onStartup()
    p.update()
    
    while True: pass
    

########NEW FILE########
__FILENAME__ = tk
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#    04/04/2012 - 1.2.8 - 82ndab-Bravo17
#    * Remove logfile errors
#    01/29/2012 - 1.2.7 - 82ndab-Bravo17
#    * Check for ROUND_END event to halve TK points for BF3
#    * Add configurable TK point 'half-life' to halve TK points at intervals in long rounds
#    * Add configurable duration for auto TK warning
#    01/06/2012 - 1.2.6 - 82ndab-Bravo17
#    * Add configurable values for sending damage messages
#    03/30/2011 - 1.2.5 - SGT
#    * Introduction of grudge level
#    11/22/2009 - 1.2.4 - Courgette
#    * also send a msg to victim with instructions on how to forgive
#    * add tests
#    10/30/2009 - 1.2.3 - xlr8or
#    * Added a few ffa gametypes for bypassing tk handling
#    08/22/2009 - 1.2.2 - Courgette
#    * fix bug in cmd_forgiveall
#    08/22/2009 - 1.2.1 - Courgette
#    * fix bug in cmd_forgiveall
#    08/22/2009 - 1.2.0b - Courgette
#    * setting to choose if the bot should broadcast or send private messages (default send private)
#    10/20/2008 - 1.1.6b1 - mindriot
#    * indentation fix
#    10/20/2008 - 1.1.6b0 - mindriot
#    * in clientDamage, kill and damage mutlipliers were reversed - changed if killed: to [0] and else: to [1]
#    * added grudge_enable to control grudge command registration
#    8/29/2005 - 1.1.0 - ThorN
#    * Converted to use new event handlers
#    7/23/2005 - 1.0.2 - ThorN
#    * Changed temp ban duration to be based on ban_length times the number of victims

__version__ = '1.2.8'
__author__  = 'ThorN'

import b3, string, re, threading
import b3.events
import b3.plugin
import b3.cron
import time

class TkInfo:
    def __init__(self, plugin, cid):
        self._attackers = {}
        self._attacked  = {}
        self._warnings  = {}
        self._lastAttacker = None
        self._grudged = []
        self.plugin = plugin
        self.cid = cid
        self.lastWarnTime = 0
        
    def _get_attackers(self):
        return self._attackers

    def _get_attacked(self):
        return self._attacked

    def forgive(self, cid):
        try:
            points = self._attackers[cid] 
            del self._attackers[cid]
        except:
            return 0

        if self._lastAttacker == cid:
            self._lastAttacker = None

        if cid in self._grudged:
            grudged = []
            for g in self._grudged:
                if g != cid:
                    grudged.append(g)
            self._grudged = grudged

        return points

    def warn(self, cid, warning):
        self._warnings[cid] = warning

    def forgiven(self, cid):
        try:
            del self._attacked[cid]
        except:
            pass
        
        try:
            w = self._warnings[cid]
        except:
            w = None

        if w:                
            w.inactive = 1
            w.save(self.plugin.console)

            del w
            del self._warnings[cid]


    def damage(self, cid, points):
        self._attacked[cid] = True

    def damaged(self, cid, points):
        try:
            self._attackers[cid] += points
        except:
            self._attackers[cid] = points

        self._lastAttacker = cid

    def _get_lastAttacker(self):
        return self._lastAttacker

    lastAttacker = property(_get_lastAttacker)

    def grudge(self, cid):
        if not cid in self._grudged:
            self._grudged.append(cid)

    def isGrudged(self, cid):
        return cid in self._grudged

    def getAttackerPoints(self, cid):
        try:
            return self._attackers[cid]
        except:
            return 0

    def _get_points(self):
        points = 0

        if len(self._attacked):            
            for cid, bol in self._attacked.items():
                try:
                    client = self.plugin.console.clients.getByCID(cid)
                    points += self.plugin.getClientTkInfo(client).getAttackerPoints(self.cid)
                except:
                    pass

        return points

    attackers = property(_get_attackers)
    attacked = property(_get_attacked)
    points = property(_get_points)

#--------------------------------------------------------------------------------------------------
class TkPlugin(b3.plugin.Plugin):
    _levels = {}
    _adminPlugin = None
    _maxLevel = 0
    _maxPoints = 0
    _grudge_enable = True
    _grudge_level = 0
    _private_messages = None
    _damage_threshold = 100
    _warn_level = 2
    _ffa = ['dm', 'ffa', 'syc-ffa']
    _tkpointsHalflife = 0
    _cronTab_tkhalflife = None
    _round_end_games = 'bf3'
    _use_round_end = False
    _tk_warn_duration = '1h'

    
    def onStartup(self):
        self.registerEvent(b3.events.EVT_CLIENT_DAMAGE_TEAM)
        self.registerEvent(b3.events.EVT_CLIENT_KILL_TEAM)
        self.registerEvent(b3.events.EVT_CLIENT_DISCONNECT)
        self.registerEvent(b3.events.EVT_GAME_EXIT)
        self.registerEvent(b3.events.EVT_GAME_ROUND_END)
        self.registerEvent(b3.events.EVT_GAME_ROUND_START)

        self._adminPlugin = self.console.getPlugin('admin')
        if self._adminPlugin:
            self._adminPlugin.registerCommand(self, 'forgive', 0, self.cmd_forgive, 'f')
            #self._adminPlugin.registerCommand('forgivenow', 0, self.cmd_forgivenow) # this command will forgive the person about to be kicked
            self._adminPlugin.registerCommand(self, 'forgivelist', 0, self.cmd_forgivelist, 'fl')
            self._adminPlugin.registerCommand(self, 'forgiveall', 0, self.cmd_forgiveall, 'fa')
            self._adminPlugin.registerCommand(self, 'forgiveinfo', 20, self.cmd_forgiveinfo, 'fi')
            self._adminPlugin.registerCommand(self, 'forgiveclear', 60, self.cmd_forgiveclear, 'fc')
            self._adminPlugin.registerCommand(self, 'forgiveprev', 0, self.cmd_forgivelast, 'fp')

            #    10/20/2008 - 1.1.6b0 - mindriot
            #    * added grudge_enable to control grudge command registration
            try:
                self._grudge_enable = self.config.getboolean('settings', 'grudge_enable')
            except:
                self.debug('Using default value (%s) for grudge_enable', self._grudge_enable)
            try:
                self._grudge_level = self.config.getint('settings','grudge_level')
            except:
                self.debug('Using default value (%s) for grudge_level', self._grudge_level)
            if self._grudge_enable:
                self._adminPlugin.registerCommand(self, 'grudge', self._grudge_level, self.cmd_grudge, 'grudge')
                
        if self._tkpointsHalflife > 0:
            (min, sec) = self.crontab_time()
            self._cronTab_tkhalflife = b3.cron.OneTimeCronTab(self.halveTKPoints, second=sec, minute=min)
            self.console.cron + self._cronTab_tkhalflife
            self.debug('TK Crontab started')



    def onLoadConfig(self):
        self._issue_warning = self.config.get('settings', 'issue_warning') 
        self._round_grace =  self.config.getint('settings', 'round_grace')

        try:
            levels = string.split(self.config.get('settings', 'levels'), ',')

            for lev in levels:
                self._levels[int(lev)] = (self.config.getfloat('level_%s' % lev, 'kill_multiplier'), self.config.getfloat('level_%s' % lev, 'damage_multiplier'), self.config.getint('level_%s' % lev, 'ban_length'))

            self._maxLevel = int(lev)

            self.debug('tk max level is %s', self._maxLevel)

            self._maxPoints = self.config.getint('settings', 'max_points')
        except Exception, msg:
            self.error('There is an error with your TK Plugin config %s' % msg)
            return False
            
        try:
            self._private_messages = self.config.getboolean('settings','private_messages')
        except:
            self._private_messages = True
        self.debug('Send messages privately ? %s' % self._private_messages)
        
        try:
            self._damage_threshold = self.config.getint('settings','damage_threshold')
        except:
            self._damage_threshold = 100
        self.debug('Damage Threshold is %s' % self._damage_threshold)
        
        try:
            self._tk_warn_duration = self.config.get('settings','warn_duration')
        except:
            self._tk_warn_duration = '1h'
        self.debug('TK Warning duration is %s' % self._tk_warn_duration)  
        
        try:
            self._warn_level = self.config.getint('settings','warn_level')
        except:
            self._warn_level = 2
        self.debug('Max warn level is %s' % self._warn_level)
        
        try:
            self._tkpointsHalflife = self.config.getint('settings','halflife')
        except:
            self._tkpointsHalflife = 0
        self.debug('Half life for TK points is %s (0 is disabled)' % self._tkpointsHalflife)
        
        if self.console.gameName in self._round_end_games:
            self._use_round_end = True
            self.debug('Using ROUND_END event to halve TK points')
        else:
            self.debug('Using GAME_EXIT event to halve TK points')

    def onEvent(self, event):
        if self.console.game.gameType in self._ffa: 
            # game type is deathmatch, ignore
            return
        elif event.type == b3.events.EVT_CLIENT_DAMAGE_TEAM:
            if event.client.maxLevel <= self._maxLevel:
                self.clientDamage(event.client, event.target, int(event.data[0]))

        elif event.type == b3.events.EVT_CLIENT_KILL_TEAM:
            if event.client.maxLevel <= self._maxLevel:
                self.clientDamage(event.client, event.target, int(event.data[0]), True)

        elif event.type == b3.events.EVT_CLIENT_DISCONNECT:
            self.forgiveAll(event.data)
            return

        elif (event.type == b3.events.EVT_GAME_EXIT and not self._use_round_end) or (event.type == b3.events.EVT_GAME_ROUND_END and self._use_round_end):
            if self._cronTab_tkhalflife:
                # remove existing crontab
                self.console.cron - self._cronTab_tkhalflife
            self.halveTKPoints('Map End: cutting all tk points in half')
            return
            
        elif event.type == b3.events.EVT_GAME_ROUND_START:
            if self._tkpointsHalflife > 0:
                if self._cronTab_tkhalflife:
                    # remove existing crontab
                    self.console.cron - self._cronTab_tkhalflife
                (min, sec) = self.crontab_time()
                self._cronTab_tkhalflife = b3.cron.OneTimeCronTab(self.halveTKPoints, second=sec, minute=min)
                self.console.cron + self._cronTab_tkhalflife
                self.debug('TK Crontab started')

            return
        else:
            return

        tkinfo = self.getClientTkInfo(event.client)
        points = tkinfo.points
        if points >= self._maxPoints:
            if points >= self._maxPoints + (self._maxPoints / 2):
                self.forgiveAll(event.client.cid)
                event.client.tempban(self.getMessage('ban'), 'tk', self.getMultipliers(event.client)[2])
            elif event.client.var(self, 'checkBan').value:
                pass
            else:            
                msg = ''
                if len(tkinfo.attacked) > 0:
                    myvictims = []
                    for cid, bol in tkinfo.attacked.items():
                        victim = self.console.clients.getByCID(cid)
                        if not victim:
                            continue
                        
                        v = self.getClientTkInfo(victim)
                        myvictims.append('%s ^7(^1%s^7)' % (victim.name, v.getAttackerPoints(event.client.cid)))
                        
                    if len(myvictims):
                        msg += ', ^1Attacked^7: %s' % ', '.join(myvictims)

                self.console.say(self.getMessage('forgive_warning', { 'name' : event.client.exactName, 'points' : points, 'cid' : event.client.cid }) + msg)
                event.client.setvar(self, 'checkBan', True)

                t = threading.Timer(30, self.checkTKBan, (event.client,))
                t.start()

    def checkTKBan(self, client):
        client.setvar(self, 'checkBan', False)
        tkinfo = self.getClientTkInfo(client)
        if tkinfo.points >= self._maxPoints:
            self.forgiveAll(client.cid)

            mult = len(tkinfo.attacked)
            if mult < 1:
                mult = 1

            duration = self.getMultipliers(client)[2] * mult
            for cid,a in tkinfo.attacked.items():
                self.forgive(cid, client, True)

            client.tempban(self.getMessage('ban'), 'tk', duration)

    def halveTKPoints(self, msg=None):
        if msg == None:
            msg = ('Halving all TK Points')
        self.debug(msg)
        for cid,c in self.console.clients.items():
            try:
                tkinfo = self.getClientTkInfo(c)
                for acid,points in tkinfo.attackers.items():
                    points = int(round(points / 2))

                    if points == 0:
                        self.forgive(acid, c, True)
                    else:
                        try: tkinfo._attackers[acid] = points
                        except: pass
            except:
                pass
        if self._tkpointsHalflife > 0: 
            if self._cronTab_tkhalflife:
                # remove existing crontab
                self.console.cron - self._cronTab_tkhalflife
            (min, sec) = self.crontab_time()
            self._cronTab_tkhalflife = b3.cron.OneTimeCronTab(self.halveTKPoints, second=sec, minute=min)
            self.console.cron + self._cronTab_tkhalflife
            #self.console.say('TK Crontab re-started')
            self.debug('TK Crontab re-started')
            
    def crontab_time(self):
        sec = self._tkpointsHalflife
        min = int(time.strftime('%M'))
        sec = sec + int(time.strftime('%S'))
        while sec > 59:
            min += 1
            sec -= 60
            
        if min > 59:
            min -= 60
            
        return (min, sec)    
    
    def getMultipliers(self, client):
        level = ()
        for lev,mult in self._levels.iteritems():
            if lev <= client.maxLevel:
                level = mult

        if not level:
            return (0,0,0)

        #self.debug('getMultipliers = %s', level)
        #self.debug('round time %s' % self.console.game.roundTime())
        if self._round_grace and self.console.game.roundTime() < self._round_grace:
            # triple tk damage for first 15 seconds of round
            level = (level[0] * 1.5, level[1] * 3, level[2])

        return level

    def clientDamage(self, attacker, victim, points, killed=False):
        if points > 100:
            points = 100

        a = self.getClientTkInfo(attacker)
        v = self.getClientTkInfo(victim)

        #    10/20/2008 - 1.1.6b0 - mindriot
        #    * in clientDamage, kill and damage mutlipliers were reversed - changed if killed: to [0] and else: to [1]
        if killed:        
            points = int(round(points * self.getMultipliers(attacker)[0]))
        else:
            points = int(round(points * self.getMultipliers(attacker)[1]))

        a.damage(v.cid, points)
        v.damaged(a.cid, points)
        
        self.debug('Attacker: %s, TK Points: %s, attacker.maxLevel: %s, last warn time: %s, Console time: %s' % (attacker.exactName, points, attacker.maxLevel, a.lastWarnTime, self.console.time()))

        if self._round_grace and self._issue_warning and self.console.game.roundTime() < self._round_grace and a.lastWarnTime + 60 < self.console.time():
            a.lastWarnTime = self.console.time()
            self._adminPlugin.warnClient(attacker, self._issue_warning, None, False)
        elif points > self._damage_threshold and attacker.maxLevel < self._warn_level and a.lastWarnTime + 180 < self.console.time():
            a.lastWarnTime = self.console.time()
            warning = self._adminPlugin.warnClient(attacker, '^3Do not attack teammates, ^1Attacked: ^7%s ^7[^3%s^7]' % (victim.exactName, points), None, False, newDuration = self._tk_warn_duration)
            a.warn(v.cid, warning)
            victim.message('^7type ^3!fp ^7 to forgive ^3%s' % (attacker.exactName))

    def getClientTkInfo(self, client):
        if not client.isvar(self, 'tkinfo'):
            client.setvar(self, 'tkinfo', TkInfo(self, client.cid))

        if not client.isvar(self, 'checkBan'):
            client.setvar(self, 'checkBan', False)

        return client.var(self, 'tkinfo').value

    def forgive(self, acid, victim, silent=False):
        v = self.getClientTkInfo(victim)
        points = v.forgive(acid)

        attacker = self.console.clients.getByCID(acid)
        if attacker:
            a = self.getClientTkInfo(attacker)
            a.forgiven(victim.cid)

            if not silent:
                if self._private_messages:
                    victim.message(self.getMessage('forgive', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
                    attacker.message(self.getMessage('forgive', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
                else:
                    self.console.say(self.getMessage('forgive', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
        elif not silent:
            if self._private_messages:
                victim.message(self.getMessage('forgive', { 'vname' : victim.exactName, 'aname' : acid, 'points' : points }))
            else:
                self.console.say(self.getMessage('forgive', { 'vname' : victim.exactName, 'aname' : acid, 'points' : points }))

        return points

    def grudge(self, acid, victim, silent=False):
        attacker = self.console.clients.getByCID(acid)
        if attacker:
            try:
                v = self.getClientTkInfo(victim)
                points = v.getAttackerPoints(attacker.cid)
                v.grudge(attacker.cid)

                if not silent:
                    if self._private_messages:
                        victim.message(self.getMessage('grudged', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
                        attacker.message(self.getMessage('grudged', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
                    else:
                        self.console.say(self.getMessage('grudged', { 'vname' : victim.exactName, 'aname' : attacker.name, 'points' : points }))
                return points
            except:
                pass
        return False

    def forgiveAll(self, acid):
        attacker = self.console.clients.getByCID(acid)
        if attacker:
            a = self.getClientTkInfo(attacker)
            a._attacked = {}

        # forgive all his points
        points = 0
        for cid,c in self.console.clients.items():
            try:
                v = self.getClientTkInfo(c)
                points += v.forgive(acid)
                a.forgiven(v.cid)
            except:
                pass

        return points

    def cmd_grudge(self, data, client, cmd=None):
        """\
        <name> - grudge a player for team damaging, a grudge player will not be auto-forgiven
        """
        v = self.getClientTkInfo(client)
        if not len(v.attackers):
            client.message(self.getMessage('no_forgive'))
            return

        if not data:
            if len(v.attackers) == 1:
                for cid, points in v.attackers.items():
                    self.grudge(cid, client)
            else:
                self.cmd_forgivelist(data, client)
        elif data == 'last':
            self.grudge(v.lastAttacker, client)
        elif re.match(r'^[0-9]+$', data):
            self.grudge(data, client)
        else:
            data = data.lower()
            for cid, points in v.attackers.items():
                c = self.console.clients.getByCID(cid)
                if c and c.name.lower().find(data) != -1:
                    self.grudge(c.cid, client)

    def cmd_forgive(self, data, client, cmd=None):
        """\
        <name> - forgive a player for team damaging
        """
        v = self.getClientTkInfo(client)
        if not len(v.attackers):
            client.message(self.getMessage('no_forgive'))
            return

        if not data:
            if len(v.attackers) == 1:
                for cid, points in v.attackers.items():
                    self.forgive(cid, client)
            else:
                self.cmd_forgivelist(data, client)
        elif data == 'last':
            self.forgive(v.lastAttacker, client)
        elif re.match(r'^[0-9]+$', data):
            self.forgive(data, client)
        else:
            data = data.lower()
            for cid, points in v.attackers.items():
                c = self.console.clients.getByCID(cid)
                if c and c.name.lower().find(data) != -1:
                    self.forgive(c.cid, client)

    def cmd_forgivelast(self, data, client, cmd=None):
        """\
        - forgive the last person to tk you
        """
        v = self.getClientTkInfo(client)
        if len(v.attackers) == 1:
            for cid, attacker in v.attackers.items():
                if v.isGrudged(cid):
                    client.message(self.getMessage('no_forgive'))
                else:
                    self.forgive(cid, client)
        elif v.lastAttacker and not v.isGrudged(v.lastAttacker):
            self.forgive(v.lastAttacker, client)
        else:
            client.message(self.getMessage('no_forgive'))            

    def cmd_forgiveall(self, data, client, cmd=None):
        """\
        - forgive all attackers' tk points
        """
        v = self.getClientTkInfo(client)
        if len(v.attackers) > 0:
            forgave = []
            for cid,points in v.attackers.items():
                if v.isGrudged(cid):
                    continue

                attacker = self.console.clients.getByCID(cid)
                points = self.forgive(cid, client, True)
                if attacker and points:
                    forgave.append('%s^7 [^3%s^7]' % (attacker.name, points))
                    if self._private_messages:
                        attacker.message(self.getMessage('forgive_many', { 'vname' : client.exactName, 'attackers' : attacker.exactName }))
                

            if len(forgave):
                if self._private_messages:
                    client.message(self.getMessage('forgive_many', { 'vname' : client.exactName, 'attackers' : string.join(forgave, ', ') }))
                else:
                    self.console.say(self.getMessage('forgive_many', { 'vname' : client.exactName, 'attackers' : string.join(forgave, ', ') }))
            else:
                client.message(self.getMessage('no_forgive'))
        else:
            client.message(self.getMessage('no_forgive'))

    def cmd_forgivelist(self, data, client, cmd=None):
        """\
        - list all the players who have shot you
        """
        # do some stuff here to list forgivable players
        v = self.getClientTkInfo(client)
        if len(v.attackers) > 0:
            myattackers = []
            for cid, points in v.attackers.items():
                attacker = self.console.clients.getByCID(cid)
                if not attacker:
                    v.forgive(cid)
                    continue

                if v.isGrudged(cid):
                    myattackers.append('^7[^2%s^7] ^1%s ^7(^1%s^7)' % (attacker.cid, attacker.name, points))
                else:
                    myattackers.append('^7[^2%s^7] %s ^7[^3%s^7]' % (attacker.cid, attacker.name, points))

            if len(myattackers):
                client.message(self.getMessage('players', ', '.join(myattackers)))
            else:
                client.message(self.getMessage('no_forgive'))
        else:
            client.message(self.getMessage('no_forgive'))

    def cmd_forgiveinfo(self, data, client, cmd=None):
        """\
        <name> - display a user's tk points
        """
        m = re.match('^([a-z0-9]+)$', data)
        if not m:
            client.message('^7Invalid parameters')
            return

        sclient = self._adminPlugin.findClientPrompt(data, client)

        if sclient:
            tkinfo = self.getClientTkInfo(sclient)
            msg = ''
            if len(tkinfo.attacked) > 0:
                myvictims = []
                for cid, bol in tkinfo.attacked.items():
                    victim = self.console.clients.getByCID(cid)
                    if not victim:
                        continue
                    
                    v = self.getClientTkInfo(victim)
                    myvictims.append('%s ^7(^1%s^7)' % (victim.name, v.getAttackerPoints(sclient.cid)))
                    
                if len(myvictims):
                    msg += ', ^1Attacked^7: %s' % ', '.join(myvictims)

            if len(tkinfo.attackers) > 0:
                myattackers = []
                for cid, points in tkinfo.attackers.items():
                    attacker = self.console.clients.getByCID(cid)
                    if not attacker:
                        continue
                    
                    if tkinfo.isGrudged(attacker.cid):
                        myattackers.append('^1%s ^7[^3%s^7]' % (attacker.name, points))
                    else:
                        myattackers.append('%s ^7[^3%s^7]' % (attacker.name, points))
                    
                if len(myattackers):
                    msg += ', ^3Attacked By^7: %s' % ', '.join(myattackers)

            cmd.sayLoudOrPM(client, self.getMessage('forgive_info', { 'name' : sclient.exactName, 'points' : tkinfo.points }) + msg)

    def cmd_forgiveclear(self, data, client, cmd=None):
        """\
        <name> - clear a user's tk points
        """
        m = re.match('^([a-z0-9]+)$', data)
        if not m:
            client.message('^7Invalid parameters')
            return False

        sclient = self._adminPlugin.findClientPrompt(data, client)

        if sclient:
            points = self.forgiveAll(sclient.cid)
            if self._private_messages:
                client.message(self.getMessage('forgive_clear', { 'name' : sclient.exactName, 'points' : points }))
                sclient.message(self.getMessage('forgive_clear', { 'name' : sclient.exactName, 'points' : points }))
            else:
                self.console.say(self.getMessage('forgive_clear', { 'name' : sclient.exactName, 'points' : points }))

            return True



if __name__ == '__main__':
    import time
    from b3.fake import fakeConsole
    from b3.fake import joe
    from b3.fake import simon
    from b3.fake import moderator
    
    p = TkPlugin(fakeConsole, "@b3/conf/plugin_tk.xml")
    p.onStartup() # register events, etc
    
    joe.team = b3.TEAM_BLUE
    simon.team = b3.TEAM_BLUE
    
    time.sleep(5)
    joe.kills(simon)
    time.sleep(6)
    simon.kills(joe)
    time.sleep(2)
    joe.says('!f 2')
    time.sleep(2)
    joe.damages(simon)
    moderator.says('!forgiveinfo joe')
    time.sleep(2)
    joe.damages(simon)
    joe.damages(simon)
    moderator.says('!forgiveinfo joe')
    time.sleep(2)
    joe.kills(simon)
    time.sleep(2)
    
########NEW FILE########
__FILENAME__ = welcome
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# 2010/10/17 - 1.2 - Courgette
#  * add min_gap to customize how long the bot must wait before welcoming a 
#    player again (in seconds)
#  * add tests
# 2010/03/21 - 1.1 - Courgette
#    import cmd_greeting from the admin plugin 
# 3/4/2009 - 1.0.6 - xlr8or
#    Added welcome delay setting to config
# 3/3/2009 - 1.0.5 - xlr8or
#    Fixed another error that caused an exception on new users
# 2/28/2009 - 1.0.4 - xlr8or
#    Removed error generated in welcoming thread on first time players
# 2/26/2009 - 1.0.3 - xlr8or
#    Do not welcome players that where already welcomed in the last hour

__version__ = '1.1'
__author__    = 'ThorN'

import b3, threading, time, re
import b3.events
import b3.plugin

#--------------------------------------------------------------------------------------------------
class WelcomePlugin(b3.plugin.Plugin):
    _newbConnections = 0
    _welcomeFlags = 0
    _welcomeDelay = 0
    _cmd_greeting_minlevel = None
    _min_gap = 3600

    def onStartup(self):
        self.registerEvent(b3.events.EVT_CLIENT_AUTH)

    def onLoadConfig(self):
        try:
            self._cmd_greeting_minlevel = self.config.getint('commands', 'greeting')
        except:
            self._cmd_greeting_minlevel = 20
            self.warning('using default value %s for command !greeting' % self._cmd_greeting_minlevel)
        
        self._adminPlugin = self.console.getPlugin('admin')
        if self._adminPlugin:
            self._adminPlugin.registerCommand(self, 'greeting', self._cmd_greeting_minlevel, self.cmd_greeting)
            
        self._welcomeFlags = self.config.getint('settings', 'flags')
        self._newbConnections = self.config.getint('settings', 'newb_connections')
        try:
            self._welcomeDelay = self.config.getint('settings', 'delay')
            if self._welcomeDelay < 15 or self._welcomeDelay > 90:
                self._welcomeDelay = 30
                self.debug('Welcome delay not in range 15-90 using 30 instead.')
            self.info('delay set to %s. The bot will wait %ss after a player connects to write the welcome message' % (self._welcomeDelay, self._welcomeDelay))
        except:
            self._welcomeDelay = 30

        try:
            self._min_gap = self.config.getint('settings', 'min_gap')
            if self._min_gap < 0:
                self._min_gap = 0
            self.info('min_gap set to %s. The bot will not welcome a player more than once every %s seconds' % (self._min_gap, self._min_gap))
        except:
            self._min_gap = 3600
            self.warning('error while reading min_gap from config. min_gap set to %s (default).' % (self._min_gap))
            

    def cmd_greeting(self, data, client, cmd=None):
        """\
        [<greeting>] - set or list your greeting (use 'none' to remove)
        """
        if data.lower() == 'none':
            client.greeting = ''
            client.save()
            client.message(self.getMessage('greeting_cleared'))
        elif data:
            data = re.sub(r'\$([a-z]+)', r'%(\1)s', data)

            if len(data) > 255:
                client.message('^7Your greeting is too long')
            else:
                try:
                    client.message('Greeting Test: %s' % (str(data) %
                        {'name' : client.exactName, 'greeting' : client.greeting, 'maxLevel' : client.maxLevel, 'group' : getattr(client.maxGroup, 'name', None), 'connections' : client.connections}))
                except ValueError, msg:
                    client.message(self.getMessage('greeting_bad', msg))
                    return False
                else:
                    client.greeting = data
                    client.save()
                    client.message(self.getMessage('greeting_changed', client.greeting))
                    return True
        else:
            if client.greeting:
                client.message(self.getMessage('greeting_yours', client.greeting))
            else:
                client.message(self.getMessage('greeting_empty'))

    def onEvent(self, event):
        if event.type == b3.events.EVT_CLIENT_AUTH:
            if    self._welcomeFlags < 1 or \
                not event.client or \
                event.client.id == None or \
                event.client.cid == None or \
                not event.client.connected or \
                event.client.pbid == 'WORLD':
                return
            if self.console.upTime() < 300:
                self.debug('not welcoming player because the bot started less than 5 min ago')
                return
            t = threading.Timer(self._welcomeDelay, self.welcome, (event.client,))
            t.start()

    def welcome(self, client):
        _timeDiff = 0
        if client.lastVisit:
            self.debug('LastVisit: %s' %(self.console.formatTime(client.lastVisit)))
            _timeDiff = time.time() - client.lastVisit
        else:
            self.debug('LastVisit not available. Must be the first time.')
            _timeDiff = 1000000 # big enough so it will welcome new players

        # don't need to welcome people who got kicked or where already 
        # welcomed in before _min_gap s ago
        if client.connected and _timeDiff > self._min_gap:
            info = {
                'name'    : client.exactName,
                'id'    : str(client.id),
                'connections' : str(client.connections)
            }

            if client.maskedGroup:
                info['group'] = client.maskedGroup.name
                info['level'] = str(client.maskedGroup.level)
            else:
                info['group'] = 'None'
                info['level'] = '0'

            if client.connections >= 2:
                #info['lastVisit'] = self.console.formatTime(client.timeEdit)
                info['lastVisit'] = self.console.formatTime(client.lastVisit)
            else:
                info['lastVisit'] = 'Unknown'

            if client.connections >= 2:
                if client.maskedGroup:
                    if self._welcomeFlags & 16:
                        client.message(self.getMessage('user', info))
                elif self._welcomeFlags & 1:
                    client.message(self.getMessage('newb', info))

                if self._welcomeFlags & 2 and client.connections < self._newbConnections:
                    self.console.say(self.getMessage('announce_user', info))
            else:
                if self._welcomeFlags & 4:
                    client.message(self.getMessage('first', info))
                if self._welcomeFlags & 8:
                    self.console.say(self.getMessage('announce_first', info))

            if self._welcomeFlags & 32 and client.greeting:
                info['greeting'] = client.greeting % info
                self.console.say(self.getMessage('greeting', info))
        else:
            if _timeDiff <= self._min_gap:
                self.debug('Client already welcomed in the past %s seconds' % self._min_gap)



if __name__ == '__main__':
    from b3.fake import fakeConsole
    from b3.fake import joe
    from b3.config import XmlConfigParser
    
    conf = XmlConfigParser()
    conf.setXml("""
<configuration plugin="welcome">
    <settings name="commands">
        <set name="greeting">20</set>
    </settings>
    <settings name="settings">
        <!--
        who to welcome
        1 = welcome newb
        2 = welcome announce_user
        4 = welcome first
        8 = welcome announce_first
        16 = welcome user
        32 = custom greetings
        add numbers, 63 = all
        -->
        <set name="flags">63</set>
        <!-- Maximum number of connections a user has to be considere a newb for the newb message -->
        <set name="newb_connections">15</set>
    <!-- Time in seconds after connection to display the message (range: 15-90) -->
    <set name="delay">15</set>
    <!-- Time in seconds the bot must wait before welcoming a player again. 
      i.e.: if you set min_gap to 3600 seconds (one hour) then the bot will not
      welcome a player more than once per hour
    -->
    <set name="min_gap">6</set>
    </settings>
    <settings name="messages">
        <!--
        Welcome messages
        $name = player name
        $id = player id
        $lastVisit = last visit time (only on welcome_user and welcome_newb)
        $group = players group (only on welcome_user)
        $connections = number of times a user has connected (only on welcome_user and welcome_announce_user)
        -->
        <!-- displayed to admins and regs -->
        <set name="user">^7[^2Authed^7] Welcome back $name ^7[^3@$id^7], last visit ^3$lastVisit^7, you're a ^2$group^7, played $connections times</set>
        <!-- displayed to users who have not yet registered -->
        <set name="newb">^7[^2Authed^7] Welcome back $name ^7[^3@$id^7], last visit ^3$lastVisit. Type !register in chat to register. Type !help for help</set>
        <!-- displayed to everyone when a player with less than 15 connections joins -->
        <set name="announce_user">^7Everyone welcome back $name^7, player number ^3#$id^7, to the server, played $connections times</set>
        <!-- displayed to a user on his first connection -->
        <set name="first">^7Welcome $name^7, this must be your first visit, you are player ^3#$id. Type !help for help</set>
        <!-- displayed to everyone when a player joins for the first time -->
        <set name="announce_first">^7Everyone welcome $name^7, player number ^3#$id^7, to the server</set>
        <!-- displayed if a user has a greeting -->
        <set name="greeting">^7$name^7 joined: $greeting</set>

        <!-- command answers : -->
        <set name="greeting_empty">^7You have no greeting set</set>
        <set name="greeting_yours">^7Your greeting is %s</set>
        <set name="greeting_bad">^7Greeting is not formated properly: %s</set>
        <set name="greeting_changed">^7Greeting changed to: %s</set>
        <set name="greeting_cleared">^7Greeting cleared</set>
    </settings>
</configuration>
    """)

    ## trick the console in thinking it was started an hour ago
    def myUpTime_func():
        return 3600
    fakeConsole.upTime = myUpTime_func
    
    p = WelcomePlugin(fakeConsole, conf)
    p.onStartup()
    # override _welcomeDelay which makes testing a pain
    p._welcomeDelay = 1
    
    print "--------------------------------"
    joe.connects(0)
    time.sleep(2)

    joe.disconnects()
    joe.connected = True
    joe.connects(2)
    time.sleep(8)

    joe.disconnects()
    joe.connected = True
    joe.connects(4)
    time.sleep(5)

    time.sleep(60)

########NEW FILE########
__FILENAME__ = querybuilder
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#
# 2011-04-16 - 1.0.2 - Courgette
# * fix bug in escaping strings containing "
# 2011-04-17 - 1.0.3 / 1.0.4 - Courgette
# * fix bug introduced in 1.0.2
# 2011-05-31 - 1.1.0 - courgette
# * sqlite compatible
#
__author__  = 'ThorN'
__version__ = '1.1.0'

class QueryBuilder(object):
    def __init__(self, db=None):
        # db is not used yet
        # the intention is for the class to use the db's escape method
        pass

    def escape(self, word):
        if isinstance(word, int) or isinstance(word, long) \
            or isinstance(word, complex) or isinstance(word, float):
            return str(word)
        elif word is None:
            return '"None"'
        else:
            return '"%s"' % word.replace('"','\\"')

    def quoteArgs(self, args):
        if type(args[0]) is tuple or type(args[0]) is list:
            args = args[0]

        nargs = []
        for a in args:
            nargs.append(self.escape(a))

        return tuple(nargs)

    def fieldStr(self, fields):
        if isinstance(fields, tuple) or isinstance(fields, list):
            return '`%s`' % '`, `'.join(fields)
        elif isinstance(fields, str):
            if fields == '*':
                return fields
            else:
                return '`%s`' % fields
        else:
            raise TypeError, 'Field must be a tuple, list, or string'

    def WhereClause(self, fields=None, values=None, concat=' and '):
        sql = []
            
        if isinstance(fields, tuple) and values == None \
            and len(fields) == 2:
            if isinstance(fields[1], list):
                values = tuple(fields[1])
            elif not isinstance(fields[1], tuple):
                values = (str(fields[1]),)

            if isinstance(fields[0], tuple) or isinstance(fields[0], list):
                fields = tuple(fields[0])
            elif not isinstance(fields[0], tuple):
                fields = (str(fields[0]),)
        else:
            if isinstance(fields, list):
                fields = tuple(fields)
            if isinstance(values, list):
                values = tuple(values)

        if isinstance(fields, tuple) and isinstance(values, tuple):
            # this will be a combination of both
            if len(fields) == 1 and len(values) == 1:
                sql.append(self.FieldClause(fields[0], values[0]))
            else:
                print fields
                for k,field in enumerate(fields):
                    v = values[k]
                    sql.append(self.FieldClause(field, v))

        elif fields != None and not isinstance(fields, tuple) \
            and values != None and not isinstance(values, tuple):
            sql.append(self.FieldClause(fields, values))

        elif isinstance(fields, tuple) \
            and len(fields) == 1 \
            and isinstance(values, str):
            sql.append(self.FieldClause(fields[0], values))

        elif isinstance(fields, tuple) \
            and len(fields) > 0 \
            and isinstance(values, str):

            sql.append(self.FieldClause(fields[0], values))

            for field in fields[1:]:
                sql.append(self.FieldClause(field, ''))

        elif isinstance(fields, dict):
            for k,v in fields.iteritems():
                sql.append(self.FieldClause(k, v))

        else:
            # its type is unknown, nothing we can do
            return fields

        return concat.join(sql)


    def SelectQuery(self, fields, table, where='', orderby='', limit=0, offset='', groupby='', having='', **keywords):
        sql = []
        sql.append('SELECT %s FROM %s' % (self.fieldStr(fields), table))
            
        if where:   sql.append('WHERE %s' % self.WhereClause(where))
        if groupby: sql.append('GROUP BY %s' % orderby)
        if having:  sql.append('HAVING %s' % having)
        if orderby: sql.append('ORDER BY %s' % orderby)

        if limit:   sql.append('LIMIT')
        if offset:  sql.append(offset + ',')
        if limit:   sql.append(str(limit))

        return ' '.join(sql)

    def FieldClause(self, field, value=None): 
        field = field.strip()

        if type(value) == list or type(value) == tuple:
            values = []
            for v in value:
                values.append(self.escape(v))
            return '`' +  field + '` IN(' + ','.join(values) + ')'
        elif value == None:
            value = self.escape('')
        else:
            value = self.escape(value)

        if len(field) >= 2:
            if field[-2] == '>=': 
                return '`' +  field[:-2].strip() + '` >= ' + value
            elif field[-2] == '<=':
                return '`' +  field[:-2].strip() + '` <= ' + value
            elif field[-1] == '<':
                return '`' +  field[:-1].strip() + '` < ' + value
            elif field[-1] == '>':
                return '`' +  field[:-1].strip() + '` > ' + value
            elif field[-1] == '=':
                return '`' +  field[:-1].strip() + '` = ' + value
            elif field[-1] == '%' and field[0] == '%':
                return '`' +  field[1:-1].strip() + '` LIKE "%' + value[1:-1] + '%"'
            elif field[-1] == '%':
                return '`' +  field[:-1].strip() + '` LIKE "' + value[1:-1] + '%"'
            elif field[0] == '%':
                return '`' +  field[1:].strip() + '` LIKE "%' + value[1:-1] + '"'
            elif field[0] == '&':
                return '`' +  field[1:].strip() + '` & ' + value
            elif field[0] == '|':
                return '`' +  field[1:].strip() + '` | ' + value

        return '`' + field + '` = ' + value

    def UpdateQuery(self, data, table, where, delayed=None): 
        sql = 'UPDATE '

        if delayed:
            sql += 'DELAYED '

        sql += table + ' SET '

        sets = []    
        for k,v in data.iteritems():
            sets.append(self.FieldClause(k, v))

        sql += ', '.join(sets)

        sql += ' WHERE ' + self.WhereClause(where)

        return sql

    def InsertQuery(self, data, table, delayed=None): 
        sql = 'INSERT '

        if delayed:
            sql += 'DELAYED '

        sql += 'INTO ' + table

        keys = []
        values = []
        for k,v in data.iteritems():
            keys.append(k)
            values.append(self.escape(v))

        sql += '(' + self.fieldStr(keys) + ') VALUES (' + ', '.join(values) + ')'

        return sql

    def ReplaceQuery(self, data, table, delayed=None): 
        sql = 'REPLACE '

        if delayed:
            sql += 'DELAYED '

        sql += 'INTO ' + table

        keys = []
        values = []
        for k,v in data.iteritems():
            keys.append(k)
            values.append(self.escape(v))

        sql += '(' + self.fieldStr(keys) + ') VALUES (' + ', '.join(values) + ')'

        return sql
########NEW FILE########
__FILENAME__ = run
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
#
# 2010/02/24 - 1.2 - Courgette
#    * uniformize SystemExit and uncatched exception handling between
#      bot running as a win32 standalone and running as a python script
# 2010/03/20 - 1.3 -  xlr8or
#    * finished options -s --setup and -n, --nosetup
#      where setup launches setup procedure and nosetup prevents bot from entering setup procedure.
# 2010/08/05 - 1.3.1 -  xlr8or
#    * Fixing broken --restart mode
# 2010/10/22 - 1.3.3 -  xlr8or
#    * Restart counter
# 2011/05/19 - 1.4.0 -  xlr8or
#    * Added --update -u arg
# 2011/12/03 - 1.4.1 -  courgette
#    * fix crash at bot start in restart mode when installed from egg

__author__  = 'ThorN'
__version__ = '1.4.1'

import b3, sys, os, time
import traceback
from b3.functions import main_is_frozen
from b3.setup import Setup
from b3.setup import Update
from optparse import OptionParser
import pkg_handler


modulePath = pkg_handler.resource_directory(__name__)

def run_autorestart(args=None):
    _restarts = 0

    if main_is_frozen():
        script = ''
    else:
        script = os.path.join(modulePath[:-3], 'b3_run.py')
        if not os.path.isfile(script):
            # must be running from the egg
            script = os.path.join(modulePath[:-3], 'b3', 'run.py')
        if os.path.isfile(script + 'c'):
            script += 'c'

    if args:
        script = '%s %s %s' % (sys.executable, script, ' '.join(args))
    else:
        script = '%s %s' % (sys.executable, script)

    while True:
        try:
            print 'Running in auto-restart mode...'
            if _restarts > 0:
                print 'Bot restarted %s times.' %_restarts
            time.sleep(1)

            try:
                import subprocess
                status = subprocess.call(script, shell=True)
            except ImportError:
                #for Python versions < 2.5
                #status = os.system(script)
                print 'Restart mode not fully supported!\nUse B3 without the -r (--restart) option or update your python installation!'
                break

            print 'Exited with status %s' % status

            if status == 221:
                # restart
                print 'Restart requested...'
            elif status == 222:
                # stop
                print 'Shutdown requested.'
                break
            elif status == 220:
                # stop
                print 'B3 Error, check log file.'
                break
            elif status == 223:
                # stop
                print 'B3 Error Restart, check log file.'
                break
            elif status == 224:
                # stop
                print 'B3 Error, check console.'
                break
            elif status == 256:
                # stop
                print 'Python error, stopping, check log file.'
                break
            elif status == 0:
                # stop
                print 'Normal shutdown, stopping.'
                break
            elif status == 1:
                # stop
                print 'Error, stopping, check console.'
                break
            else:
                print 'Unknown shutdown status (%s), restarting...' % status
        
            _restarts += 1
            time.sleep(4)
        except KeyboardInterrupt:
            print 'Quit'
            break

def run(config=None, nosetup=False):
    if config:
        config = b3.getAbsolutePath(config)
    else:
        # search for the config file
        config = None
        for p in ('b3.xml', 'conf/b3.xml', 'b3/conf/b3.xml', '~/b3.xml', '~/conf/b3.xml', '~/b3/conf/b3.xml', '@b3/conf/b3.xml'):
            path = b3.getAbsolutePath(p)
            print 'Searching for config file: %s' % path
            if os.path.isfile(path):
                config = path
                break

    if not config:
        # This happens when no config was specified on the commandline and the default configs are missing! 
        if nosetup:
            raise SystemExit('ERROR: Could not find config file, Please run B3 with option: --setup or -s')
        else:
            Setup(config)

    b3.start(config, nosetup)

def run_setup(config=None):
    Setup(config)

def run_update(config=None):
    Update(config)

def main():
    parser = OptionParser(version=b3.getB3versionString())
    parser.add_option('-c', '--config', dest='config', default=None,
                      help='B3 config file. Example: -c b3.xml')
    parser.add_option('-r', '--restart',
                      action='store_true', dest='restart', default=False,
                      help='Auto-restart B3 on crash')
    parser.add_option('-s', '--setup',
                      action='store_true', dest='setup', default=False,
                      help='Setup main b3.xml config file')
    parser.add_option('-u', '--update',
                      action='store_true', dest='update', default=False,
                      help='Update B3 database to latest version')
    parser.add_option('-n', '--nosetup',
                      action="store_true", dest='nosetup', default=False,
                      help='Do not enter setup mode when config is missing')


    (options, args) = parser.parse_args()

    if not options.config and len(args) == 1:
        options.config = args[0]

    if options.setup:
        run_setup(config=options.config)

    if options.update:
        run_update(config=options.config)

    if options.restart:
        if options.config:
            run_autorestart(['--config', options.config] + args)
        else:
            run_autorestart([])
    else:
        try:
            run(config=options.config, nosetup=options.nosetup)
        except SystemExit, msg:
            # This needs some work, is ugly a.t.m. but works... kinda
            if main_is_frozen():
                if sys.stdout != sys.__stdout__:
                    # make sure we are not writing to the log:
                    sys.stdout = sys.__stdout__
                    sys.stderr = sys.__stderr__
                print msg
                raw_input("Press the [ENTER] key")
            raise
        except:
            if sys.stdout != sys.__stdout__:
                # make sure we are not writing to the log:
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__
            traceback.print_exc()
        if main_is_frozen():
            # which happens when running from the py2exe build
            # we wait for keyboad keypress to give a chance to the 
            # user to see the error message
            if sys.stdout != sys.__stdout__:
                # make sure we are not writing to the log:
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__
            raw_input("Press the [ENTER] key")
     
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = database
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG
#   26/11/2012 - 1.13 - courgette
#    add database columns 'login' and 'password' to the Client model
#   11/08/2012 - 1.12 - Courgette
#    getGroup can find group by level if keyword is not provided
#   29/10/2011 - 1.11.1 - 82ndab-Bravo17
#    Decode Reason in penalty from system encodig and recode to UTF-8 to ensure Name is correctly encoded
#   31/05/2011 - 1.11.0 - Courgette
#    sqlite compatible
#    few fixes discovered doing unittests
#   11/04/2011 - 1.10.0 - Courgette
#    the query() method now accepts a second parameter which can be an optional
#    dict of variables to bind on the query
#   08/04/2011 - 1.9.1 - Courgette
#    remove str() wherever we could have unicode
#   02/03/2011 - 1.9 - Courgette
#   Do not catch exception when query fails
#   07/01/2011 - 1.8 - xlr8or
#   Added queryFromFile to execute .sql files
#   12/12/2010 - 1.7.3 - courgette
#   fix setGroup for update query
#   29/06/2010 - 1.7.2 - xlr8or
#   fixed typo myqsldb -> msqldb in error message (thanks ryry46d9)
#   27/03/2010 - 1.7.1 - xlr8or
#   enable setting different port for mysql connections
#   02/13/2010 - 1.7.0 - xlr8or
#   Added 'silent' option to query. Defaults to false. 
#   When set True it will raise an Exception for use in a try/except construction for a failed query
#   instead of just logging an error.
#   08/30/2009 - 1.6.3 - Bakes
#   Removed limit to number of aliases selected.
#   12/23/2008 - 1.6.2 - xlr8or
#   Added fix to catch mySQL connnection error 'mySQL server has gone away' and reconnect
#   01/23/2006 - 1.5.0 - ThorN
#   Added SQLite support, set "database" to "sqlite:///path/to/database.db"
#   11/19/2005 - 1.4.0 - ThorN
#   Added some convenience functions to the Cursor class and added better
#    error checking
#   10/31/2005 - 1.2.0 - ThorN
#   Changed it to use Python DB 2.0 API instead of ADODB
#   8/29/2005 - 1.2.0 - ThorN
#   Changed function to explicitly close the cursor
#   8/29/2005 - 1.1.1 - ThorN
#   Added getCounts()
#   7/23/2005 - 1.1.0 - ThorN
#   Added data column to penalties table

__author__  = 'ThorN'
__version__ = '1.13'


from b3 import functions
from b3.querybuilder import QueryBuilder
from b3.storage import Storage
import b3
import os
import re
import sys
import thread
import time
import traceback



class DatabaseStorage(Storage):
    _reName = re.compile(r'([A-Z])')
    _reVar  = re.compile(r'_([a-z])')
    _lastConnectAttempt = 0
    _connections = []
    _lock = None
    _count = 0

    class Cursor:
        _cursor = None
        _conn = None
        fields = None
        EOF = False
        rowcount = 0
        lastrowid = 0
        
        def __init__(self, rs, conn):
            self._cursor = rs
            self._conn = conn

            self.rowcount  = self._cursor.rowcount
            self.lastrowid = self._cursor.lastrowid

            try:
                self.EOF = self.moveNext()
            except:
                # not a select statement
                self.EOF = not self.fields or self.rowcount <= 0 or not self._cursor 


        def moveNext(self):
            if not self.EOF:
                self.fields = self._cursor.fetchone()
                self.EOF    = (not self.fields or not self._cursor)

                if self.EOF:
                    self.close()

            return self.EOF

        def getOneRow(self, default=None):
            if self.EOF:
                return default
            else:
                d = self.getRow()
                self.close()
                return d

        def getValue(self, key, default=None):
            d = self.getRow()
            if d.has_key(key):
                return d[key]
            else:
                return default

        def getRow(self):
            if self.EOF:
                return {}

            d = {}
            i = 0
            desc = self._cursor.description
            for i in xrange(0,len(self.fields)):
                d[desc[i][0]] = self.fields[i]

            return d
        
        def close(self):
            if self._cursor: self._cursor.close()
            self._cursor = None
            self.EOF = True

    def __init__(self, dsn, console):
        self.console = console
        self._lock = thread.allocate_lock()
        self.db = None
        self.dsn = dsn
        self.dsnDict = functions.splitDSN(self.dsn)
        self.connect()

    def getField(self, name):
        return self._reName.sub(r'_\1', name)

    def getVar(self, name):
        return self._reVar.sub(lambda m: m.group(1).upper(), name)

    def getConnection(self):
        protocol = self.dsnDict['protocol']

        if protocol == 'mysql':
            try:
                # validate dsnDict
                if not self.dsnDict['host']:
                    self.console.critical("invalid MySQL host in %(protocol)s://%(user)s:******@%(host)s:%(port)s%(path)s" % self.dsnDict)
                elif not self.dsnDict['path'] or not self.dsnDict['path'][1:]:
                    self.console.critical("missing MySQL database name in %(protocol)s://%(user)s:******@%(host)s:%(port)s%(path)s" % self.dsnDict)
                else:
                    import MySQLdb
                    return MySQLdb.connect(
                                           host=self.dsnDict['host'],
                                           port=self.dsnDict['port'],
                                           user=self.dsnDict['user'],
                                           passwd=self.dsnDict['password'],
                                           db=self.dsnDict['path'][1:],
                                           charset = "utf8",
                                           use_unicode = True)
            except ImportError, err:
                self.console.critical("%s. You need to install python-mysqldb. Look for 'dependencies' in B3 documentation.",err)
        elif protocol == 'sqlite':
            import sqlite3
            path = self.dsn[9:]
            filepath = b3.getAbsolutePath(path)
            self.console.info("Using database file : %s" % filepath)
            isNewDatabase = not os.path.isfile(filepath)
            conn = sqlite3.connect(filepath, check_same_thread=False)
            conn.isolation_level = None ## set autocommit mode
            if path == ':memory:' or isNewDatabase:
                self.console.info("Creating tables")
                sqlFile = b3.getAbsolutePath("@b3/sql/sqlite/b3.sql")
                with open(sqlFile) as f:
                    conn.executescript(f.read())
            return conn
        else:
            raise Exception('Unknown database protocol %s' % protocol)

    def closeConnection(self):
        for c in self._connections:
            try:
                c.close()
            except:
                pass
        
        self._connections = []
            
        if self.db:
            try:
                self.db.close()
            except:
                pass
            
            self.db = None

    def shutdown(self):
        self.closeConnection()

    def connect(self):
        if self.dsnDict['protocol'] == 'mysql':
            self.console.bot('Attempting to connect to database %s://%s:******@%s%s...', self.dsnDict['protocol'], self.dsnDict['user'], self.dsnDict['host'], self.dsnDict['path'])
        else:
            self.console.bot('Attempting to connect to database %s', self.dsn)
        self._count += 1

        self.closeConnection()

        if time.time() - self._lastConnectAttempt < 60:
            # dont retry for 60 seconds
            self.db = None
            return None

        try:
            self.db = self.getConnection()

            self._connections.append(self.db)
            self._lastConnectAttempt = 0
            self.console.bot('Connected to database [%s times]' % self._count)
            if self._count == 1:
                self.console.screen.write('Connecting to DB : OK\n')
        except Exception, e:
            self.console.error('Database connection failed, working in remote mode: %s - %s', e, traceback.extract_tb(sys.exc_info()[2]))
            if self._count == 1:
                self.console.screen.write('Connecting to DB : FAILED!\n')
            self.db = None
            self._lastConnectAttempt = time.time()

        return self.db

    def status(self):
        if self.db:
            return True
        else:
            return False

    def _query(self, query, bindata=None):
        self._lock.acquire()
        try:
            cursor = self.db.cursor()
            if bindata is None:
                cursor.execute(query)
            else:
                cursor.execute(query, bindata)
            c = DatabaseStorage.Cursor(cursor, self.db)
        finally:
            self._lock.release()
        return c

    def queryFromFile(self, file, silent=False):
        """This method executes an external sql file on the current database"""
        if self.db or self.connect():
            orig_stderr = sys.stderr # save standard error output
            if silent:
                sys.stderr = open(os.devnull, 'w') # silence the mysql warnings for existing tables and such
            sqlFile = b3.getAbsolutePath(file)
            if os.path.exists(sqlFile):
                f = open(sqlFile, 'r')
                sql_text = f.read()
                f.close()
                sql_statements = sql_text.split(';')
                for s in sql_statements:
                    try:
                        self.query(s)
                    except:
                        pass
            else:
                raise Exception('sqlFile does not exist: %s' %sqlFile)
            sys.stderr = orig_stderr # reset standard error output
        return None


    def query(self, query, bindata=None):
        # use existing connection or create a new one
        if self.db or self.connect():
            try:
                return self._query(query, bindata)
            except Exception, e:
                # (2013, 'Lost connection to MySQL server during query')
                # (2006, 'MySQL server has gone away')
                self.console.error('[%s] %r' % (query, bindata))

                if e[0] == 2013 or e[0] == 2006:
                    self.console.warning('Query failed, trying to reconnect - %s: %s' % (type(e), e))

                    # query failed, try to reconnect
                    if self.connect():
                        try:
                            # retry query
                            return self._query(query, bindata)
                        except Exception, e:
                            # fall through to log error message
                            pass
                else:
                    raise e

        return None
        
    def getCounts(self):
        counts = {
            'clients' : 0,
            'Bans' : 0,
            'Kicks' : 0,
            'Warnings' : 0,
            'TempBans' : 0
        }

        cursor = self.query('SELECT COUNT(id) total FROM clients')

        if cursor and cursor.rowcount:
            counts['clients'] = int(cursor.getRow()['total'])
        
        cursor = self.query('SELECT COUNT(id) total, type FROM penalties GROUP BY type')

        if cursor:
            while not cursor.EOF:
                r = cursor.getRow()
                counts[r['type'] + 's'] = int(r['total'])
                cursor.moveNext()

            cursor.close()

        return counts            

    def getClient(self, client):
        self.console.debug('Storage: getClient %s' % client)

        if client.id > 0:        
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'clients', { 'id' : client.id }, None, 1))
        else:
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'clients', { 'guid' : client.guid }, None, 1))

        if not cursor:
            # connection failed, try local cache
            if self.console.config.has_option('admins_cache', client.guid):
                data = self.console.config.get('admins_cache', client.guid, True)
                self.console.debug('Pulling user form admins_cache %s' % data)
                id, name, level   = data.split(',')
                client.id         = id.strip()
                client.name       = name.strip()
                client._tempLevel = int(level.strip())

                return client
            else:
                raise KeyError, 'No client matching guid %s in admins_cache' % client.guid

        if not cursor.rowcount:
            cursor.close()
            raise KeyError, 'No client matching guid %s' % client.guid

        found = False
        for k,v in cursor.getRow().iteritems():
            """
            if hasattr(client, k) and getattr(client, k):
                # don't set already set items
                continue
            """
            setattr(client, self.getVar(k), v)
            found = True
        
        cursor.close()

        if found:
            return client
        else:
            raise KeyError, 'No client matching guid %s' % client.guid
    
    def getClientsMatching(self, match):
        self.console.debug('Storage: getClientsMatching %s' % match)

        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'clients', match, 'time_edit DESC', 5))

        if not cursor:
            return ()

        clients = []
        while not cursor.EOF:
            g = cursor.getRow()

            client = b3.clients.Client()
            for k,v in g.iteritems():
                setattr(client, self.getVar(k), v)
            clients.append(client)
            cursor.moveNext()

        cursor.close()

        return clients

    def setClient(self, client):
        """
        id int(11)   PRI NULL auto_increment 
        ip varchar(16) YES   NULL   
        greeting varchar(128) YES   NULL   
        connections int(11) YES   NULL   
        time_edit int(11) YES   NULL   
        guid varchar(32)   MUL     
        pbid varchar(32) YES   NULL   
        name varchar(32) YES   NULL   
        time_add int(11) YES   NULL   
        auto_login int(11) YES   NULL   
        mask_level int(11) YES   NULL   
        group_bits int(11) 
        """

        self.console.debug('Storage: setClient %s' % client)

        fields = (
            'ip',
            'greeting',
            'connections',
            'time_edit',
            'guid',
            'pbid',
            'name',
            'time_add',
            'auto_login',
            'mask_level',
            'group_bits',
            'login',
            'password'
        )
    
        if client.id > 0:
            data = { 'id' : client.id }
        else:
            data = {}

        for f in fields:
            if hasattr(client, self.getVar(f)):
                data[f] = getattr(client, self.getVar(f))


        self.console.debug('Storage: setClient data %s' % data)
        if client.id > 0:
            self.query(QueryBuilder(self.db).UpdateQuery(data, 'clients', { 'id' : client.id }))
        else:
            cursor = self.query(QueryBuilder(self.db).InsertQuery(data, 'clients'))
            if cursor:
                client.id = cursor.lastrowid
            else:
                client.id = None

        return client.id    

    def setClientAlias(self, alias):
        """
        id  int(10)  UNSIGNED No    auto_increment              
        num_used  int(10)  UNSIGNED No  0                
        alias  varchar(32)   No                  
        client_id  int(10)  UNSIGNED No  0                
        time_add  int(10)  UNSIGNED No  0                
        time_edit  int(10)  UNSIGNED No  0            
        """

        self.console.debug('Storage: setClientAlias %s' % alias)

        fields = (
            'num_used',
            'alias',
            'client_id',
            'time_add',
            'time_edit'
        )
    
        if alias.id:
            data = { 'id' : alias.id }
        else:
            data = {}

        for f in fields:
            if hasattr(alias, self.getVar(f)):
                data[f] = getattr(alias, self.getVar(f))

        self.console.debug('Storage: setClientAlias data %s' % data)
        if alias.id:
            self.query(QueryBuilder(self.db).UpdateQuery(data, 'aliases', { 'id' : alias.id }))
        else:
            cursor = self.query(QueryBuilder(self.db).InsertQuery(data, 'aliases'))

            if cursor:
                alias.id = cursor.lastrowid
            else:
                alias.id = None

        return alias.id

    def getClientAlias(self, alias):
        self.console.debug('Storage: getClientAlias %s' % alias)

        cursor = None
        if hasattr(alias, 'id') and alias.id > 0:
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'aliases', { 'id' : alias.id }, None, 1))
        elif hasattr(alias, 'alias') and hasattr(alias, 'clientId'):
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'aliases', { 'alias' : alias.alias, 'client_id' : alias.clientId }, None, 1))

        if not cursor or cursor.EOF:
            raise KeyError, 'No alias matching %s' % alias

        g = cursor.getOneRow()

        alias.id = int(g['id'])
        alias.alias    = g['alias']
        alias.timeAdd  = int(g['time_add'])
        alias.timeEdit = int(g['time_edit'])
        alias.clientId = int(g['client_id'])
        alias.numUsed = int(g['num_used'])
    
        return alias

    def getClientAliases(self, client):
        self.console.debug('Storage: getClientAliases %s' % client)
        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'aliases', { 'client_id' : client.id }, 'id'))

        if not cursor:
            return ()

        aliases = []
        while not cursor.EOF:
            g = cursor.getRow()

            alias = b3.clients.Alias()
            alias.id = int(g['id'])
            alias.alias    = g['alias']
            alias.timeAdd  = int(g['time_add'])
            alias.timeEdit = int(g['time_edit'])
            alias.clientId = int(g['client_id'])
            alias.numUsed = int(g['num_used'])
            aliases.append(alias)
            cursor.moveNext()

        cursor.close()

        return aliases
    
    def setClientIpAddresse(self, ipalias):
        """
        id  int(10)  UNSIGNED No    auto_increment              
        num_used  int(10)  UNSIGNED No  0                
        ip  int(10)   UNSIGNED No                  
        client_id  int(10)  UNSIGNED No  0                
        time_add  int(10)  UNSIGNED No  0                
        time_edit  int(10)  UNSIGNED No  0            
        """

        self.console.debug('Storage: setClientIpAddresse %s' % ipalias)

        fields = (
            'num_used',
            'ip',
            'client_id',
            'time_add',
            'time_edit'
        )
    
        if ipalias.id:
            data = { 'id' : ipalias.id }
        else:
            data = {}

        for f in fields:
            if hasattr(ipalias, self.getVar(f)):
                data[f] = getattr(ipalias, self.getVar(f))

        self.console.debug('Storage: setClientIpAddresse data %s' % data)
        if ipalias.id:
            self.query(QueryBuilder(self.db).UpdateQuery(data, 'ipaliases', { 'id' : ipalias.id }))
        else:
            cursor = self.query(QueryBuilder(self.db).InsertQuery(data, 'ipaliases'))

            if cursor:
                ipalias.id = cursor.lastrowid
            else:
                ipalias.id = None

        return ipalias.id

    def getClientIpAddress(self, ipalias):
        self.console.debug('Storage: getClientIpAddress %s' % ipalias)

        cursor = None
        if hasattr(ipalias, 'id') and ipalias.id > 0:
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'ipaliases', { 'id' : ipalias.id }, None, 1))
        elif hasattr(ipalias, 'ip') and hasattr(ipalias, 'clientId'):
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'ipaliases', { 'ip' : ipalias.ip, 'client_id' : ipalias.clientId }, None, 1))

        if not cursor or cursor.EOF:
            raise KeyError, 'No ip matching %s' % ipalias

        g = cursor.getOneRow()

        ipalias.id = int(g['id'])
        ipalias.ip    = g['ip']
        ipalias.timeAdd  = int(g['time_add'])
        ipalias.timeEdit = int(g['time_edit'])
        ipalias.clientId = int(g['client_id'])
        ipalias.numUsed = int(g['num_used'])
    
        return ipalias

    def getClientIpAddresses(self, client):
        self.console.debug('Storage: getClientIpAddresses %s' % client)
        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'ipaliases', { 'client_id' : client.id }, 'id'))
        
        if not cursor:
            return ()

        aliases = []
        while not cursor.EOF:
            g = cursor.getRow()

            ip = b3.clients.IpAlias()
            ip.id = int(g['id'])
            ip.ip    = g['ip']
            ip.timeAdd  = int(g['time_add'])
            ip.timeEdit = int(g['time_edit'])
            ip.clientId = int(g['client_id'])
            ip.numUsed = int(g['num_used'])
            aliases.append(ip)
            cursor.moveNext()

        cursor.close()

        return aliases

    def getLastPenalties(self, types='Ban', num=5):
        where = QueryBuilder(self.db).WhereClause( { 'type' : types, 'inactive' : 0 } )
        where += ' and (time_expire = -1 or time_expire > %s)' % int(time.time())

        cursor = self.query(QueryBuilder(self.db).SelectQuery(fields='*', table='penalties', where=where, orderby='time_add DESC, id DESC', limit=num))
        if not cursor:
            return []

        penalties = []
        while not cursor.EOF and len(penalties) < num:
            penalties.append(self._createPenaltyFromRow(cursor.getRow()))
            cursor.moveNext()
        cursor.close()

        return penalties

    def setClientPenalty(self, penalty):
        """
        id  int(10)  UNSIGNED No    auto_increment              
        type  enum('Ban', 'TempBan', 'Kick', 'Warning')   No  Ban                
        duration  int(10)  UNSIGNED No  0                
        inactive  tinyint(1)  UNSIGNED No  0                
        admin_id  int(10)  UNSIGNED No  0                
        time_add  int(10)  UNSIGNED No  0                
        time_edit  int(10)  UNSIGNED No  0                
        time_expire  int(11)   No  0                
        reason  varchar(255)   No                  
        keyword  varchar(16)   No                  
        client_id  int(10)  UNSIGNED No  0       
        """

        fields = (
            'type',
            'duration',
            'inactive',
            'admin_id',
            'time_add',
            'time_edit',
            'time_expire',
            'reason',
            'keyword',
            'client_id',
            'data'
        )

        if penalty.id:
            data = { 'id' : penalty.id }
        else:
            data = {}

        if penalty.keyword and not re.match(r'^[a-z0-9]+$', penalty.keyword, re.I):
            penalty.keyword = ''
            
        if penalty.reason:
            # decode the reason data, as the name may need it
            if hasattr(self.console, "encoding") and self.console.encoding:
                try:
                    penalty.reason = penalty.reason.decode(self.console.encoding)
                except Exception, msg:
                    self.console.warning('ERROR Decoding reason: %r', msg)
                    
                try:
                    penalty.reason = penalty.reason.encode('UTF-8', 'replace')
                except Exception, msg:
                    self.console.warning('ERROR Encoding reason: %r', msg)

        for f in fields:
            if hasattr(penalty, self.getVar(f)):
                data[f] = getattr(penalty, self.getVar(f))

        self.console.debug('Storage: setClientPenalty data %s' % data)
        if penalty.id:
            self.query(QueryBuilder(self.db).UpdateQuery(data, 'penalties', { 'id' : penalty.id }))
        else:
            cursor = self.query(QueryBuilder(self.db).InsertQuery(data, 'penalties'))
            if cursor:
                penalty.id = cursor.lastrowid
            else:
                penalty.id = None

        return penalty.id

    def _createPenaltyFromRow(self, g):
        if g['type'] == 'Warning':
            penalty = b3.clients.ClientWarning()
        elif g['type'] == 'TempBan':
            penalty = b3.clients.ClientTempBan()
        elif g['type'] == 'Kick':
            penalty = b3.clients.ClientKick()
        elif g['type'] == 'Ban':
            penalty = b3.clients.ClientBan()
        elif g['type'] == 'Notice':
            penalty = b3.clients.ClientNotice()
        else:
            penalty = b3.clients.Penalty()
        penalty.id = int(g['id'])
        penalty.type    = g['type']
        penalty.keyword = g['keyword']
        penalty.reason = g['reason']
        penalty.data = g['data']
        penalty.inactive    = int(g['inactive'])
        penalty.timeAdd  = int(g['time_add'])
        penalty.timeEdit = int(g['time_edit'])
        penalty.timeExpire = int(g['time_expire'])
        penalty.clientId = int(g['client_id'])
        penalty.adminId = int(g['admin_id'])
        penalty.duration = int(g['duration'])
        return penalty

    def getClientPenalty(self, penalty):
        self.console.debug('Storage: getClientPenalty %s' % penalty)

        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'penalties', { 'id' : penalty.id }, None, 1))
        g = cursor.getOneRow()
        if not g:
            raise KeyError, 'No penalty matching id %s' % penalty.id
        
        return self._createPenaltyFromRow(g)
    
    def getClientPenalties(self, client, type='Ban'):
        self.console.debug('Storage: getClientPenalties %s' % client)

        where = QueryBuilder(self.db).WhereClause( { 'type' : type, 'client_id' : client.id, 'inactive' : 0 } )
        where += ' and (time_expire = -1 or time_expire > %s)' % int(time.time())

        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'penalties', where, 'time_add DESC'))

        if not cursor:
            return ()

        penalties = []
        while not cursor.EOF:
            penalties.append(self._createPenaltyFromRow(cursor.getRow()))
            cursor.moveNext()
        cursor.close()

        return penalties

    def getClientLastPenalty(self, client, type='Ban'):
        where = QueryBuilder(self.db).WhereClause( { 'type' : type, 'client_id' : client.id, 'inactive' : 0 } )
        where += ' and (time_expire = -1 or time_expire > %s)' % int(time.time())

        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'penalties', where, 'time_add DESC', 1))
        g = cursor.getOneRow()
        if not g:
            return None
        return self._createPenaltyFromRow(g)

    def getClientFirstPenalty(self, client, type='Ban'):
        where = QueryBuilder(self.db).WhereClause( { 'type' : type, 'client_id' : client.id, 'inactive' : 0 } )
        where += ' and (time_expire = -1 or time_expire > %s)' % int(time.time())

        cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'penalties', where, 'time_expire DESC, time_add ASC', 1))
        g = cursor.getOneRow()
        if not g:
            return None
        return self._createPenaltyFromRow(g)


    def disableClientPenalties(self, client, type='Ban'):
        self.query(QueryBuilder(self.db).UpdateQuery( { 'inactive' : 1 }, 'penalties', { 'type' : type, 'client_id' : client.id, 'inactive' : 0 } ))        

    def numPenalties(self, client, type='Ban'):
        where = QueryBuilder(self.db).WhereClause( { 'type' : type, 'client_id' : client.id, 'inactive' : 0 } )
        where += ' and (time_expire = -1 or time_expire > %s)' % int(time.time())


        cursor = self.query('SELECT COUNT(id) total FROM penalties WHERE %s' % where)

        if not cursor:
            return 0

        return int(cursor.getValue('total', 0))

    _groups = None
    def getGroups(self):
        if not self._groups:
            cursor = self.query(QueryBuilder(self.db).SelectQuery('*', 'groups', None, 'level'))
            if not cursor:
                return []

            self._groups = []
            while not cursor.EOF:
                g = cursor.getRow()
                G = b3.clients.Group()

                G.id = int(g['id'])
                G.name    = g['name']
                G.keyword = g['keyword']
                G.level    = int(g['level'])
                G.timeAdd  = int(g['time_add'])
                G.timeEdit = int(g['time_edit'])

                self._groups.append(G)
                cursor.moveNext()
            cursor.close()

        return self._groups

    def getGroup(self, group):
        if hasattr(group, 'keyword') and group.keyword:
            q = QueryBuilder(self.db).SelectQuery('*', 'groups', { 'keyword' : group.keyword }, None, 1)
            self.console.verbose2(q)
            cursor = self.query(q)
            g = cursor.getOneRow()
            if not g:
                raise KeyError, 'No group matching keyword %s' % group.keyword
        elif hasattr(group, 'level') and group.level:
            q = QueryBuilder(self.db).SelectQuery('*', 'groups', { 'level' : group.level }, None, 1)
            self.console.verbose2(q)
            cursor = self.query(q)
            g = cursor.getOneRow()
            if not g:
                raise KeyError, 'No group matching level %s' % group.level
        else:
            raise KeyError("cannot find Group as no keyword/level provided")

        group.id = int(g['id'])
        group.name    = g['name']
        group.keyword = g['keyword']
        group.level    = int(g['level'])
        group.timeAdd  = int(g['time_add'])
        group.timeEdit = int(g['time_edit'])
    
        return group


    def executeSql(self, filename):
        """This method executes an external sql file"""
        sqlFile = b3.getAbsolutePath(filename)
        f = open(sqlFile, 'r')
        sql_text = f.read()
        f.close()
        sql_statements = sql_text.split(';')
        for s in sql_statements:
            if len(s.strip()):
                self.query(s)

    
    
########NEW FILE########
__FILENAME__ = timezones
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

__author__  = 'ThorN'
__version__ = '1.0.0'

timezones = {
    'A' : +1,
    'ACDT' : +10.5,
    'ACST' : +9.5,
    'ADT' : -3,
    'AEDT' : +11,
    'AEST' : +10,
    'AKDT' : -8,
    'AKST' : -9,
    'AST' : -4,
    'AWST' : +8,
    'B' : +2,
    'BST' : +1,
    'C' : +3,
    'CDT' : -5,
    'CEDT' : +2,
    'CEST' : +2,
    'CET' : +1,
    'CST' : -6,
    'CXT' : +7,
    'D' : +4,
    'E' : +5,
    'EDT' : -4,
    'EEDT' : +3,
    'EEST' : +3,
    'EET' : +2,
    'EST' : -5,
    'F' : +6,
    'G' : +7,
    'GMT' : 0,
    'H' : +8,
    'HAA' : -3,
    'HAC' : -5,
    'HADT' : -9,
    'HAE' : -4,
    'HAP' : -7,
    'HAR' : -6,
    'HAST' : -10,
    'HAT' : -2.5,
    'HAY' : -8,
    'HNA' : -4,
    'HNC' : -6,
    'HNE' : -5,
    'HNP' : -8,
    'HNR' : -7,
    'HNT' : -3.5,
    'HNY' : -9,
    'I' : +9,
    'IST' : +1,
    'K' : +10,
    'L' : +11,
    'M' : +12,
    'MDT' : -6,
    'MESZ' : +2,
    'MEZ' : +1,
    'MST' : -7,
    'N' : -1,
    'NDT' : -2.5,
    'NFT' : +11.5,
    'NST' : -3.5,
    'O' : -2,
    'P' : -3,
    'PDT' : -7,
    'PST' : -8,
    'Q' : -4,
    'R' : -5,
    'S' : -6,
    'T' : -7,
    'U' : -8,
    'UTC' : 0,
    'UYT' : -3,
    'V' : -9,
    'W' : -10,
    'WEDT' : +1,
    'WEST' : +1,
    'WET' : 0,
    'WST' : +8,
    'X' : -11,
    'Y' : -12,
    'Z' : 0
}

########NEW FILE########
__FILENAME__ = documentationBuilder
# -*- coding: utf-8 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 BigBrotherBot
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# CHANGELOG:
# 2010/02/20 - 1.1 - Courgette
#    * fix convertion from level to group name for unexpected level numbers
#    * cosmetics to the html export
#    * add maxlevel setting to hide commands reserved to high levels
# 2010/02/23 - 1.2 - Courgette
#    * make the html export validate the W3C test
#    * hide the maxLevel column on the html export
# 2010/02/25 - 1.2.1 - Courgette
#    * fix Internet Explorer issues with logo in html export
#    * remove any use the sets module
# 2010/02/26 - 1.2.2 - Courgette
#    * fix bug making commands with alias appear twice in the results
# 2010/03/07 - 1.2.3 - Courgette
#   * make the html export pass the W3C tests
# 2010/08/25 - 1.2.4 - Courgette
#   * do not fail if 'destination' is found in config but empty
# 2011/05/11 - 1.2.5 - Courgette
#   * update B3 website URL

""" 
This module will generate a user documentation depending
on current config
"""

__author__    = 'Courgette'
__version__ = '1.2.5'

import time, os, StringIO, string, re
from xml.dom.minidom import Document
from ftplib import FTP
from cgi import escape
from b3 import getConfPath
from b3.functions import splitDSN

class DocBuilder:
    _supportedExportType = ['xml','html', 'htmltable']
    _console = None
    _adminPlugin = None
    _outputType = 'html'
    _outputUrl = 'file://' + getConfPath() + '/b3doc.html'
    _maxlevel = None
    
    def __init__(self, console):
        self._console = console
        self._outputDir = getConfPath()
        self._adminPlugin = self._console.getPlugin('admin')
        if self._adminPlugin is None:
            raise Exception('AUTODOC: cannot generate documentation without the admin plugin')
                
        if self._console.config.has_section('autodoc'):
            if self._console.config.has_option('autodoc','destination'):
                dest = self._console.config.get('autodoc','destination')
                if dest is None:
                    self._console.warning('AUTODOC: destination found but empty. using default')
                else:
                    if dest.startswith('ftp://') or dest.startswith('file://'):
                        self._outputUrl = dest
                    else:
                        # assume file
                        self._outputUrl = 'file://' + self._console.config.getpath('autodoc', 'destination')
        
            if self._console.config.has_option('autodoc','type'):
                self._outputType = self._console.config.get('autodoc','type')
    
            if self._console.config.has_option('autodoc','maxlevel'):
                self._maxlevel = self._console.config.getint('autodoc','maxlevel')
    
    
    def save(self):
        if self._outputType not in self._supportedExportType:
            self._console.error('AUTODOC: %s type of doc unsupported' % self._outputType)
            self._console.info('AUTODOC: supported doc types are : %s' % ", ".join(self._supportedExportType))
        else:
            self._console.debug('AUTODOC: saving %s documentation' % self._outputType)
            if self._outputType == 'xml':
                self._write(self.getXml())
            elif self._outputType == 'html':
                self._write(self.getHtml())
            elif self._outputType == 'htmltable':
                self._write(self.getHtmlTable())
        
    
    def getXml(self):
        xml = Document()
        xDoc = xml.createElement("b3doc")
        xDoc.setAttribute("time", time.asctime())
        xDoc.setAttribute("game", self._console.game.gameName)
        xDoc.setAttribute("address", self._console._publicIp +':'+ str(self._console._port))
        
        xCommands = xml.createElement("b3commands")
        for cmd in self._getCommandsDict():
            xCommand = xml.createElement("b3command")
            xCommand.setAttribute("name", cmd['name'])
            if 'alias' in cmd and cmd['alias'] != '' :
                xCommand.setAttribute("alias", cmd['alias'])
            xCommand.setAttribute("plugin", cmd['plugin'])
            xCommand.setAttribute("help", cmd['description'])
            xCommand.setAttribute("minlevel", cmd['minlevel'])
            xCommand.setAttribute("maxlevel", cmd['maxlevel'])
            xCommands.appendChild(xCommand)
        xDoc.appendChild(xCommands)
        xml.appendChild(xDoc)
        return xml.toprettyxml(indent="\t")

    def getHtml(self):
        cssstyle = """
            #b3commands {
                border-collapse: collapse;
            }
            
            #b3commands th, #b3commands td {
                font-family: arial;
                border: 2px solid black;
                padding: 5px;
            }
            
            #b3commands th {
                font-weight: bold;
                background-color: lightgray;
                text-transform: capitalize;
            }
            #b3commands td {
                font-size: 12px;
            }
            #b3commands .b3MaxLevel {
                display: none;
            }
            body {
                font-family: tahoma,sans-serif;
                color: #3F3B3B;
                font-size: 12px;
                margin: 0;
            }
            
            #header {
                background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAACWCAYAAAAfduJyAAAAAXNSR0IArs4c6QAAAAZiS0dEAIcAiACHZn+LRgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9oCGRQCLt1vun0AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAqklEQVQoz3WSwRXDMAhDv7RKZ8jIXagL0QMxNo5zgycBQsDv+wmu6woLMBKWhIEWUYBGypJyKBOWRirAgbDFjd7TRoM5PMkSdgEUIAmHAhs3IMnViiZo15cyahmPikXLIXKSaZ3ZRrbNI3lP8muDxWcJE8Iyj41CDIdoFRKYcM09eT+HTzfqAIqesq5FGKPAThnly3buecHXcy8bPT8nI1e0K32rULT242P/N0QVV4uoqV8AAAAASUVORK5CYII=) repeat-x;
                height: 150px;
            }
            #logo {
                margin: 0 auto;
                width: 950px;
                height: 150px;
                cursor: pointer;
            }
            #logo img {
                border: 0;
            }
            #bodyarea {
                background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAAZCAIAAACUxWgrAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADlJREFUeNpi/P//PwMDAxMDGLC8fv4cRDEyMoIoBgjFiJViAulhYULhESHHhKoSG4ViLdRlUAogwADulwZZy1%2BP%2BAAAAABJRU5ErkJggg%3D%3D) repeat-x scroll 0 0 #FFFFFF;
                padding: 10px 0 20px 20px;
            }
            #bodyarea h1 {
                color: #C1930B;
            }
            #bodyarea table th.header {
                background-image: url(data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw==);
                background-position: right center;
                background-repeat: no-repeat;
                padding-right: 16px;
                padding-left: 2px;
            }
            #bodyarea table th.headerSortDown {
                background-color: #C1930B;
                background-image: url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjI8Bya2wnINUMopZAQA7);
            }
            #bodyarea table th.headerSortUp {
                background-color: #C1930B;
                background-image: url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjB+gC+jP2ptn0WskLQA7);
            }
                """
        
        javascript = """
        //<![CDATA[
/*!
 * jQuery JavaScript Library v1.4.2
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Sat Feb 13 22:33:48 2010 -0500
 */
(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\\./g,"`").replace(/ /g,
"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\\w\\W]+>)[^>]*$|^#([\\w-]+)$/,Ua=/^.[^:#\\[\\.,]*$/,Va=/\\S/,
Wa=/^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g,Xa=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\\],:{}\\s]*$/.test(a.replace(/\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,"]").replace(/(?:^|:|,)(?:\\s*\\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \\/]([\\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \\/]([\\w.]+)/.exec(a)||/(msie) ([\\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\\n\\t]/g,ca=/\\s+/,Za=/\\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\\.(.*)$/,db=function(a){return a.replace(/[^\\w\\s\\.\\|`]/g,
function(b){return"\\\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\\\.)"+c.map(o.slice(0).sort(),db).join("\\\\.(?:.*\\\\.)?")+"(\\\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\\\.)"+d.slice(0).sort().join("\\\\.(?:.*\\\\.)?")+"(\\\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['"][^'"]*['"]|[^[\\]'"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,
e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\\\"){q[1]=(q[1]||"").replace(/\\\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
1)!=="\\\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,
CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,NAME:/\\[name=['"]*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)['"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['"]*)(.*?)\\3|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)(?:\\((['"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\\t\\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\\d/i.test(g.nodeName)},
text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\\r|\\n)*?)/.source+n.match[u].source.replace(/\\\\(\\d+)/g,function(g,
h){return"\\\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\\d+="(?:\\d+|null)"/g,V=/^\\s+/,Ka=/(<([\\w:]+)[^>]*?)\\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\\w:]+)/,ib=/<tbody/i,jb=/<|&#?\\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\\s*(?:[^=]|=\\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\\s]+\\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\\([^)]*\\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\\d+(?:px)?$/i,nb=/^-?\\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\\s)*?\\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\\?(&|$)/,ka=/\\?/,wb=/(\\?|&)_=.*?(&|$)/,xb=/^(\\w+:)?\\/\\/([^\\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\\[\\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);

/*
 * 
 * TableSorter 2.0 - Client-side table sorting with ease!
 * Version 2.0.3
 * @requires jQuery v1.2.3
 * 
 * Copyright (c) 2007 Christian Bach
 * Examples and docs at: http://tablesorter.com
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * 
 */
(function($){$.extend({tablesorter:new function(){var parsers=[],widgets=[];this.defaults={cssHeader:"header",cssAsc:"headerSortUp",cssDesc:"headerSortDown",sortInitialOrder:"asc",sortMultiSortKey:"shiftKey",sortForce:null,sortAppend:null,textExtraction:"simple",parsers:{},widgets:[],widgetZebra:{css:["even","odd"]},headers:{},widthFixed:false,cancelSelection:true,sortList:[],headerList:[],dateFormat:"us",decimal:'.',debug:false};function benchmark(s,d){log(s+","+(new Date().getTime()-d.getTime())+"ms");}this.benchmark=benchmark;function log(s){if(typeof console!="undefined"&&typeof console.debug!="undefined"){console.log(s);}else{alert(s);}}function buildParserCache(table,$headers){if(table.config.debug){var parsersDebug="";}var rows=table.tBodies[0].rows;if(table.tBodies[0].rows[0]){var list=[],cells=rows[0].cells,l=cells.length;for(var i=0;i<l;i++){var p=false;if($.metadata&&($($headers[i]).metadata()&&$($headers[i]).metadata().sorter)){p=getParserById($($headers[i]).metadata().sorter);}else if((table.config.headers[i]&&table.config.headers[i].sorter)){p=getParserById(table.config.headers[i].sorter);}if(!p){p=detectParserForColumn(table,cells[i]);}if(table.config.debug){parsersDebug+="column:"+i+" parser:"+p.id+"\\n";}list.push(p);}}if(table.config.debug){log(parsersDebug);}return list;};function detectParserForColumn(table,node){var l=parsers.length;for(var i=1;i<l;i++){if(parsers[i].is($.trim(getElementText(table.config,node)),table,node)){return parsers[i];}}return parsers[0];}function getParserById(name){var l=parsers.length;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==name.toLowerCase()){return parsers[i];}}return false;}function buildCache(table){if(table.config.debug){var cacheTime=new Date();}var totalRows=(table.tBodies[0]&&table.tBodies[0].rows.length)||0,totalCells=(table.tBodies[0].rows[0]&&table.tBodies[0].rows[0].cells.length)||0,parsers=table.config.parsers,cache={row:[],normalized:[]};for(var i=0;i<totalRows;++i){var c=table.tBodies[0].rows[i],cols=[];cache.row.push($(c));for(var j=0;j<totalCells;++j){cols.push(parsers[j].format(getElementText(table.config,c.cells[j]),table,c.cells[j]));}cols.push(i);cache.normalized.push(cols);cols=null;};if(table.config.debug){benchmark("Building cache for "+totalRows+" rows:",cacheTime);}return cache;};function getElementText(config,node){if(!node)return"";var t="";if(config.textExtraction=="simple"){if(node.childNodes[0]&&node.childNodes[0].hasChildNodes()){t=node.childNodes[0].innerHTML;}else{t=node.innerHTML;}}else{if(typeof(config.textExtraction)=="function"){t=config.textExtraction(node);}else{t=$(node).text();}}return t;}function appendToTable(table,cache){if(table.config.debug){var appendTime=new Date()}var c=cache,r=c.row,n=c.normalized,totalRows=n.length,checkCell=(n[0].length-1),tableBody=$(table.tBodies[0]),rows=[];for(var i=0;i<totalRows;i++){rows.push(r[n[i][checkCell]]);if(!table.config.appender){var o=r[n[i][checkCell]];var l=o.length;for(var j=0;j<l;j++){tableBody[0].appendChild(o[j]);}}}if(table.config.appender){table.config.appender(table,rows);}rows=null;if(table.config.debug){benchmark("Rebuilt table:",appendTime);}applyWidget(table);setTimeout(function(){$(table).trigger("sortEnd");},0);};function buildHeaders(table){if(table.config.debug){var time=new Date();}var meta=($.metadata)?true:false,tableHeadersRows=[];for(var i=0;i<table.tHead.rows.length;i++){tableHeadersRows[i]=0;};$tableHeaders=$("thead th",table);$tableHeaders.each(function(index){this.count=0;this.column=index;this.order=formatSortingOrder(table.config.sortInitialOrder);if(checkHeaderMetadata(this)||checkHeaderOptions(table,index))this.sortDisabled=true;if(!this.sortDisabled){$(this).addClass(table.config.cssHeader);}table.config.headerList[index]=this;});if(table.config.debug){benchmark("Built headers:",time);log($tableHeaders);}return $tableHeaders;};function checkCellColSpan(table,rows,row){var arr=[],r=table.tHead.rows,c=r[row].cells;for(var i=0;i<c.length;i++){var cell=c[i];if(cell.colSpan>1){arr=arr.concat(checkCellColSpan(table,headerArr,row++));}else{if(table.tHead.length==1||(cell.rowSpan>1||!r[row+1])){arr.push(cell);}}}return arr;};function checkHeaderMetadata(cell){if(($.metadata)&&($(cell).metadata().sorter===false)){return true;};return false;}function checkHeaderOptions(table,i){if((table.config.headers[i])&&(table.config.headers[i].sorter===false)){return true;};return false;}function applyWidget(table){var c=table.config.widgets;var l=c.length;for(var i=0;i<l;i++){getWidgetById(c[i]).format(table);}}function getWidgetById(name){var l=widgets.length;for(var i=0;i<l;i++){if(widgets[i].id.toLowerCase()==name.toLowerCase()){return widgets[i];}}};function formatSortingOrder(v){if(typeof(v)!="Number"){i=(v.toLowerCase()=="desc")?1:0;}else{i=(v==(0||1))?v:0;}return i;}function isValueInArray(v,a){var l=a.length;for(var i=0;i<l;i++){if(a[i][0]==v){return true;}}return false;}function setHeadersCss(table,$headers,list,css){$headers.removeClass(css[0]).removeClass(css[1]);var h=[];$headers.each(function(offset){if(!this.sortDisabled){h[this.column]=$(this);}});var l=list.length;for(var i=0;i<l;i++){h[list[i][0]].addClass(css[list[i][1]]);}}function fixColumnWidth(table,$headers){var c=table.config;if(c.widthFixed){var colgroup=$('<colgroup>');$("tr:first td",table.tBodies[0]).each(function(){colgroup.append($('<col>').css('width',$(this).width()));});$(table).prepend(colgroup);};}function updateHeaderSortCount(table,sortList){var c=table.config,l=sortList.length;for(var i=0;i<l;i++){var s=sortList[i],o=c.headerList[s[0]];o.count=s[1];o.count++;}}function multisort(table,sortList,cache){if(table.config.debug){var sortTime=new Date();}var dynamicExp="var sortWrapper = function(a,b) {",l=sortList.length;for(var i=0;i<l;i++){var c=sortList[i][0];var order=sortList[i][1];var s=(getCachedSortType(table.config.parsers,c)=="text")?((order==0)?"sortText":"sortTextDesc"):((order==0)?"sortNumeric":"sortNumericDesc");var e="e"+i;dynamicExp+="var "+e+" = "+s+"(a["+c+"],b["+c+"]); ";dynamicExp+="if("+e+") { return "+e+"; } ";dynamicExp+="else { ";}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+="return a["+orgOrderCol+"]-b["+orgOrderCol+"];";for(var i=0;i<l;i++){dynamicExp+="}; ";}dynamicExp+="return 0; ";dynamicExp+="}; ";eval(dynamicExp);cache.normalized.sort(sortWrapper);if(table.config.debug){benchmark("Sorting on "+sortList.toString()+" and dir "+order+" time:",sortTime);}return cache;};function sortText(a,b){return((a<b)?-1:((a>b)?1:0));};function sortTextDesc(a,b){return((b<a)?-1:((b>a)?1:0));};function sortNumeric(a,b){return a-b;};function sortNumericDesc(a,b){return b-a;};function getCachedSortType(parsers,i){return parsers[i].type;};this.construct=function(settings){return this.each(function(){if(!this.tHead||!this.tBodies)return;var $this,$document,$headers,cache,config,shiftDown=0,sortOrder;this.config={};config=$.extend(this.config,$.tablesorter.defaults,settings);$this=$(this);$headers=buildHeaders(this);this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);var sortCSS=[config.cssDesc,config.cssAsc];fixColumnWidth(this);$headers.click(function(e){$this.trigger("sortStart");var totalRows=($this[0].tBodies[0]&&$this[0].tBodies[0].rows.length)||0;if(!this.sortDisabled&&totalRows>0){var $cell=$(this);var i=this.column;this.order=this.count++%2;if(!e[config.sortMultiSortKey]){config.sortList=[];if(config.sortForce!=null){var a=config.sortForce;for(var j=0;j<a.length;j++){if(a[j][0]!=i){config.sortList.push(a[j]);}}}config.sortList.push([i,this.order]);}else{if(isValueInArray(i,config.sortList)){for(var j=0;j<config.sortList.length;j++){var s=config.sortList[j],o=config.headerList[s[0]];if(s[0]==i){o.count=s[1];o.count++;s[1]=o.count%2;}}}else{config.sortList.push([i,this.order]);}};setTimeout(function(){setHeadersCss($this[0],$headers,config.sortList,sortCSS);appendToTable($this[0],multisort($this[0],config.sortList,cache));},1);return false;}}).mousedown(function(){if(config.cancelSelection){this.onselectstart=function(){return false};return false;}});$this.bind("update",function(){this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);}).bind("sorton",function(e,list){$(this).trigger("sortStart");config.sortList=list;var sortList=config.sortList;updateHeaderSortCount(this,sortList);setHeadersCss(this,$headers,sortList,sortCSS);appendToTable(this,multisort(this,sortList,cache));}).bind("appendCache",function(){appendToTable(this,cache);}).bind("applyWidgetId",function(e,id){getWidgetById(id).format(this);}).bind("applyWidgets",function(){applyWidget(this);});if($.metadata&&($(this).metadata()&&$(this).metadata().sortlist)){config.sortList=$(this).metadata().sortlist;}if(config.sortList.length>0){$this.trigger("sorton",[config.sortList]);}applyWidget(this);});};this.addParser=function(parser){var l=parsers.length,a=true;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==parser.id.toLowerCase()){a=false;}}if(a){parsers.push(parser);};};this.addWidget=function(widget){widgets.push(widget);};this.formatFloat=function(s){var i=parseFloat(s);return(isNaN(i))?0:i;};this.formatInt=function(s){var i=parseInt(s);return(isNaN(i))?0:i;};this.isDigit=function(s,config){var DECIMAL='\\\\'+config.decimal;var exp='/(^[+]?0('+DECIMAL+'0+)?$)|(^([-+]?[1-9][0-9]*)$)|(^([-+]?((0?|[1-9][0-9]*)'+DECIMAL+'(0*[1-9][0-9]*)))$)|(^[-+]?[1-9]+[0-9]*'+DECIMAL+'0+$)/';return RegExp(exp).test($.trim(s));};this.clearTableBody=function(table){if($.browser.msie){function empty(){while(this.firstChild)this.removeChild(this.firstChild);}empty.apply(table.tBodies[0]);}else{table.tBodies[0].innerHTML="";}};}});$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:"text",is:function(s){return true;},format:function(s){return $.trim(s.toLowerCase());},type:"text"});ts.addParser({id:"digit",is:function(s,table){var c=table.config;return $.tablesorter.isDigit(s,c);},format:function(s){return $.tablesorter.formatFloat(s);},type:"numeric"});ts.addParser({id:"currency",is:function(s){return/^[$?.]/.test(s);},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/[^0-9.]/g),""));},type:"numeric"});ts.addParser({id:"ipAddress",is:function(s){return/^\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}$/.test(s);},format:function(s){var a=s.split("."),r="",l=a.length;for(var i=0;i<l;i++){var item=a[i];if(item.length==2){r+="0"+item;}else{r+=item;}}return $.tablesorter.formatFloat(r);},type:"numeric"});ts.addParser({id:"url",is:function(s){return/^(https?|ftp|file):\\/\\/$/.test(s);},format:function(s){return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\\/\\//),''));},type:"text"});ts.addParser({id:"isoDate",is:function(s){return/^\\d{4}[\\/-]\\d{1,2}[\\/-]\\d{1,2}$/.test(s);},format:function(s){return $.tablesorter.formatFloat((s!="")?new Date(s.replace(new RegExp(/-/g),"/")).getTime():"0");},type:"numeric"});ts.addParser({id:"percent",is:function(s){return/\\%$/.test($.trim(s));},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g),""));},type:"numeric"});ts.addParser({id:"usLongDate",is:function(s){return s.match(new RegExp(/^[A-Za-z]{3,10}\\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(AM|PM)))$/));},format:function(s){return $.tablesorter.formatFloat(new Date(s).getTime());},type:"numeric"});ts.addParser({id:"shortDate",is:function(s){return/\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}/.test(s);},format:function(s,table){var c=table.config;s=s.replace(/\\-/g,"/");if(c.dateFormat=="us"){s=s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/,"$3/$1/$2");}else if(c.dateFormat=="uk"){s=s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/,"$3/$2/$1");}else if(c.dateFormat=="dd/mm/yy"||c.dateFormat=="dd-mm-yy"){s=s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2})/,"$1/$2/$3");}return $.tablesorter.formatFloat(new Date(s).getTime());},type:"numeric"});ts.addParser({id:"time",is:function(s){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(am|pm)))$/.test(s);},format:function(s){return $.tablesorter.formatFloat(new Date("2000/01/01 "+s).getTime());},type:"numeric"});ts.addParser({id:"metadata",is:function(s){return false;},format:function(s,table,cell){var c=table.config,p=(!c.parserMetadataName)?'sortValue':c.parserMetadataName;return $(cell).metadata()[p];},type:"numeric"});ts.addWidget({id:"zebra",format:function(table){if(table.config.debug){var time=new Date();}$("tr:visible",table.tBodies[0]).filter(':even').removeClass(table.config.widgetZebra.css[1]).addClass(table.config.widgetZebra.css[0]).end().filter(':odd').removeClass(table.config.widgetZebra.css[0]).addClass(table.config.widgetZebra.css[1]);if(table.config.debug){$.tablesorter.benchmark("Applying Zebra widget",time);}}});})(jQuery);

$(document).ready(function(){ 
    $.tablesorter.addParser({ 
        // set a unique id 
        id: 'b3level', 
        is: function(s) { 
            // return false so this parser is not auto detected 
            return false; 
        }, 
        format: function(cellcontent, domtable, domcell) { 
            // format your data for normalization 
            //console.log(domcell, $("span", domcell).attr('title').split(' - ')[0]);
            var val = -1;
            var title = $("span", domcell).attr('title');
            if (typeof title != "undefined" && title.length > 0) {
                val =  parseInt(title.split(' - ')[0], 0);
            } else {
                val = parseInt(cellcontent, 0);
            }
            return val;
        }, 
        // set type, either numeric or text 
        type: 'numeric' 
    }); 
    $("#bodyarea table").tablesorter({
        sortList: [[0,0],[1,0],[2,0]],
        headers: { 
            1: { sorter:'b3level' } ,
            2: { sorter:'b3level' },
            5: { sorter: false }
        } 
    });
    $("#bodyarea table thead th:lt(5)").css('cursor', 'pointer');
}); 
        //]]>
        """
        
        html = """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
        <head>
            <meta http-equiv="content-type" content="text/html; charset=utf-8" />
            <title>B3 user documentation for %(server)s</title>
            <style type="text/css">%(cssstyle)s</style>
        </head>
        <body>
            <div id="header">
                <div id="head-wrap">
                    <div id="logo">
                        <a title="go to BigBrotherBot website" href="http://www.bigbrotherbot.net/">
                            <img alt="BigBrotherBot" src='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEARwBHAAD/2wBDAAcFBQYFBAcGBQYIBwcIChELCgkJChUPEAwRGBUaGRgVGBcbHichGx0lHRcYIi4iJSgpKywrGiAvMy8qMicqKyr/2wBDAQcICAoJChQLCxQqHBgcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKir/wgARCACWA7YDAREAAhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQGBQf/xAAaAQEAAwEBAQAAAAAAAAAAAAAAAQIDBAUG/9oADAMBAAIQAxAAAAHw8bACQTE4zFlZ3OLbwO3HSvFUIlkWmzDaMgABJAAAABIIJIAJIJBBJABJBJAAAAAAAJC83pjz4mqAG7LVMIBK4qIgkgkgkgkEAkgkEEgAgkgkEEggEkAAAMdq2QSmEEmUSR5cvKl09LddD27Nua6kT4hyEuamPRNwFZUWFoAABMIkAAAAAAAAAAAAAAAABkemUmgAbJkagBmZFQAAAAAAAAAAAAAAAAAABmXkwSzpONoRPPWjezv9Rw29q0WXpZemUxBhE1Hgp+XWrqzGR0R0J4hzB6JmAAAAAAAAAAAAAAAAAAAAbpsHmGILDaNIgAvKAAAAAAAAAAASZmZkCDArIAAAABkZl0IAOfl6+Ov1Hk6ti9LdKWXpnauVogwKSiGpFvlN8+htH0szKDiTgT1yQAAAAAAAAAAAAAAAAAACw9I1DUBJuFBSAXGBgAAAAAAAADIuLS0sAAAINc1DEAAAGZMLhJDyyil/rnnd99q5aUtvTO9M7Vm0RLBFKaTXiflt8+0tHsA3Dwz5meqbAAAAAAAAAAAAAAAAAAABvlh5pANgzNQAzMykAAAAAAAEl5eXAAgxMQSZkgGB55iAAAZmecxeNnO0HG61+peX6PuUv5u2PyD0eEAACTfh9Jz1+c6Z9HMekeobx4Z82PYN4AAAAAgkAAAgkEEgAAAgEgAFh6BpmuDI3DTMQC8oAAAAABBILi8uJCMClNZAJMgQYgvLwaxqAAgkGUOk8Du8j1ebU68tKGlhv9W8z0c7U83fL5F6Xn7MT3mGyYTETGExzFq+LaO1z00Jhen1Y0S854+ZnumyAAAAAAAAAAAAAAAAAADeLDziAbhWa4BcYGAAAAAAMjYNgyBUUlZkWGZIAABBUQbiKU6IAABfnOMotEHhS97zPQ7fl6c7V87fH5J6nnb9bfZuHsWrFq42jCY43XPgtM+uz097PXgN+fcmN4k8YtPeIAAAAAAAAAAAAAAAAAAMj0S0gg1CT3TwTUMiwpB6ZYYnmGIABYbBeDA1z0T3Dky0GJgYEEEEmR7BmYnkF5Qa4AABkTCYbnHtyW9Os8z0+lx1svXzt8fk/reZs1nueboWiJiJjCY5vSnjWr3eG/pZa+enkNcdTfDYN89U2TEwAAAAAAAAAAAAAAAAABsG0e0bJgDkD3DnjIvKSAdoVlx5RzpJJcbBYQUFJ0hoF57JwxYYEmRJJIIIOzNY3DwzxyggAvOnOUMC2k50mrauec8tLtvG9f28Nrb087ox+Vex5QAAA9ul+05uiqttKt/CvXye3h6U2TMGBiAADIggAAAAAAAAAAAAAG2ZHuElRYcedYeGXnvGsWHNHXHnmyeaeOdUYlZqHrA8soOoNU8k9o8wvOeNg9sk8QrPdKDROhPGPSPHPDPbPWMDnzfOhPEOdLCYIZRPMHV+T6nv8fXbenn9GPyz2vI3aX+reX6K1YtXC1a7V5Dox5PfHq+ff3Ofo1K38TbHy+zj6ouJBgYAAsJMSSsAAAAAAAAAAAAAG6VHQG4Vg5A7Y5Q6g8o0DqjgzsyCSs8Y6s588M7E0DTOkOQOmPLNQ6U447A5U6A1DSPdOVOwOWPOO3NcsNQ8A7E5E9U9E5k64440DZEMonPOeevG9wd3ZeZ6Mnn9GHy/3fG3c7/WPH9VekWrjetdo5fow4nq5uh59+l5equLcr1cuHTzdOZmQKzEElpBgSZlIAAAAAAAAAAAAANoqOiJPJOmONOuOZOmPDNQ6s4U7Q0So944s7A4ouOuPBNI6w406s58zPcODO+OWOlPONAvPOOzPnZtnanjkntnHHYnFHtHrHEndnAlpmSZ5W9Lyerw/T5uWvP1H5/3JPN3x+Y+94tkT7vNulEwRjLy9c9W1em5ujpuXqpieA9LzvdtX3SQZGBWZlxiYkEFpQQAAAASQACSASQAASQAZmZ7Z6BieWcwdyc2bJ7xUb5yZ0JJgeUeSdiciQb575YeGc4dieAXnrnHHaHNmydAZHgGodOcMbx1YMTwzxTqD1is5MwOtOKLzMQzzts8msTHB92PYeR6nQ8XZ5+2PzX3fGAgCQyPUy07Lj67qX5now53t4+qN8yIBBJYCsxJILCgAAAAAAAAAAAAAAzIJNUgvLDE6EgHqHClhWXGZJrEG0Sa5rGRsGJSbBQWArLyopMzYKTYLzVNcGZcDXMC0vKQXGZlnIxvFmVtbm04vrp9M8L2dvPSULQmFqr1WrF6xauMxieZaPnvo+f7lo6AsBJiSZGZiYEEEmZUQAAAAAAAAAAAAAAXlhmgYmCbAbZB4xkbRgYlZkZEGBAAAAAAABJJeYFIAAAAAAMiYQbXDtT0542jw6z4i/0bxPX3M9JmJtVas2ibVXqtTGXlWr889Hg3b16U2yYJQCTMkwIIIBkYmAAAAAAAAAAAAAABaeiahJtGuQWGJWXkGBgbRrlhrmRBYVmZgYmZJWWAg1TeKi8tINcgzKwWlRgZF5USYEmoDMQu5Nd3yurW7sMN6UdOfgS5+J7PzPR6Xi67JiZibVm1VoqtXlOvm4/s5PStHRm8TAJAZGRBiDEgkkzKAAAAAAAAAAAAAADaLCCwGZJUVmZJkZlANYvLDM1SSwzKS4rKzMkyKTWN4tLCs1zEzIJMgYEFpgZAgrNYGRMLuTXf8Lt8/wB3iw2pjrWDzTmJUZ393l6fTx12InXvTy98fC6cLLV9k9w2zKEEkESksJMSAYkAksBSYgEggAAAAAAAAAAAAEkgkkEGJAAAAAAAAAJLCwwKzEAAAAAAAAGcJpMXiazEwklNJi8VnmnkGkYEmweiembpmZCEwESEyyIIgEoIBJJkQQQQCAAAAAAAAAAAAAAAAAAAAAAAAAASWEGBAAAAAAAAAAP/xAAvEAABBAIBAgMGBwEBAAAAAAADAAECBBETBRASFCExFSAiMDRABhYjMjM1UEEk/9oACAEBAAEFAtxXW4rrcV1uKmMVbiuthu3cV0xSO92xGIZclLW9+y68ZZXi7C8ZZZNyFhlG/N01grreZbzLeZbzLeZbzLeZbzLeZbzLeZbyreZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzLeZbzIRDSfaREsleW8y3mW4yYpWadgrvvMt5lvMmMVmc5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lvMt5lFeq9Vju65dmx5Gttn4iSq/h63YQPwzTgh8Px8F7Op4Jw3HkR/wxUmrf4fuVmZ5DkM7S6ynGK3jUSQl/mM2XjHtYssN1HFEfDdYtlS/wAn16yd5O/q+IwPYcj0OLNflS46vSi3vOr3G1rzXuNNQmI+EQ7yen+HT2F+WKjNa/DrwXcWsRnaTf5IoJ/JpP3P0jHLv5M/m/TC/a322HWuS0yWh1odaZLXJlj5kV6e5ZPtlxXFvdlCMRwZN7zundFjAo+UpNSs8NSaCiHDalKq0lzFFnQZPCbf5EI90kWXXCjHDTfL9YspfZszumC6YLLsi3yHZnUgp44+Vj3Lhu2PH0nu2RwiOCyy7mXcy7mXcy7mTyZPJk6d1yU93LCJ2PO7IsG2zjUiZj82Vt53/wDQJ8t/jjj2xk+G9X6QipvhusWypfYszumC6YUWWPd7orZFbIrvist7ko9zPHD/ACGzj0eMYyjKDtGcnITi6vhKa5P+ry6y6y6y6y6y6y6y6r37FaVS3G5WufDygi90fjjEHJyCIHKOc/O1R10T+QP+PCOZIr5fpGOXUny/TC9G+ewndMJmWOryiycq2SdfG61utS1stbLWtazOKiRn6mb5NeY2rkEm8ldn2V+NDuvN05P+rVcbGs/lsK/LYV+Wwr8thT/hwK5DjpUJLgpfpc0HtscdYYdk4614fsqmg8fVAX8QWBTi36hgR+H/ABhxxGT4j1jHDTf3IspfNaLumCmizdXnFk5XXxSWtdjfKlBQlh0X9nvwk45+XW8/6nBj+DpyX9YqH9hlZWVlO6/EH064P0sCicJBkqGGaEkykWA2MdzOEShHH+NFsyXhCHj7NKn40y0yHN/Jh0B9loPhzJmT+XWFAs4ezSp+OMzSg8Je6w3dMJm6vJmTlVCPecoRsGOOuWXey713uu513Ou913qNIko+AInolZFh2vDziV/P5LKDbX5KPZe4iOOPbpyX9Yq5GDZ/MQV+Ygr8xBX5hCn/ABAJchyEr0lxteVes6PCJIGr62jF5JgOhgUB9qxhS/d/iCbzVHzrHPGuOvZHZa5BpVnllQ5KER2LErVhmXoz9a301i0OqwjQOPlINpbphMJ3TDZunonIu6UkGkGQbgRhnQ/nN/BCbLvdebrtddi7V2rCwu1dqF/DYuDquMkSw5WLNCMu0XuBi0z+BrouGOo47p9uVF+17z913i/66PTkf635FK2AEu5pxdF9LjfoA/eMflhmWOkv3e7hdqxj70TfCT9tD6W8GR63H05Vm5EzCqD9I0AyhbDAB61ZzO1MLNPjxu/gAorNA9f6bkKpLLU63hg8sZtYId8vZwVCjHvtiGIYROZ2rCZPUDJGoa2rwjM0YtCJq4zSqeV8sXmEHGiHGdAMmnBxzACRpRpBinphdWQPXVeMSn8EFBoxxdHAMxfw8hUJZnUB4evypGko+lejsZqYGU6IZKxXlXlQDGfSxSDGDefXHnjD8g2LfDS7qHTkf65UvrtY1rGtY1rGnENcxVEOC4kruN1Lze++BVv3D+GOPNl/yX7vc7cLzWGWPL7wf7C+tD6YpYhgO2EkrFYVhpD0lh/HyLZvghrByF166qcgZyo/1tf6Y9gddBsCOj0QmQm7Sq7yWghrZ7MAC1Bu2nAq94uxFm9W8GTkDetErk47Mrkn7Ye0TuSMu6HJP23KsOyteFYNGnUs1ymHtDx75tqzyc2MWwSxIX8J7Qq6DYEdrVIZo1BsQ6s8kVzUbcjo49oKNiUZqzeM84N5dMZdcmzuuDL8XTkP65Uvrvcdc0//AJVxH8jrC5GX6tVvKLdrY8ukvXpjKxjp5L4Uzfei9Cfuo/TXYSJWDTJ3K/L/AN8P4+Q+tHLvHyVSRZVqs5ERWd71eP8A574ZEarWnEq3ZvqwPN5osyhLuhyIJymCvMs1cdp3q/0/Kv8Arcd/Mf6cTIX8PKfW15d1e9aNWlDkLZXezfZuPz4xRbM8IX8PIV5GJUrzgVUyM3IItOYT0a8oSLPWKl9QifWdYM/cQGxrFfdWpn8Pb9enIf16HNxE9t217btr21aXtq0vbNpHslsyXEQdYU/hiWe49aCZun/P+4yyaOVjHTDrzXk6j97F8OT1qFHCvvCnsgZH5MUIx7pzgYTQ5CcZWqtvS0TDm0rI2nhE+qGUcQ+KAntgVnkG7awmiTeJkYkXt9zqtacSgQc08oxVvkoQjDLuEwog5KcCGoSjAprAdAlA4mFyM4kt1bWhMQRo/pBa7yEXjRdmseICofvaOVAooC8UBParsrfJNKAo4QL0XZpRkpmGJrt3xKqN2m8QFlLD2+rPh4m7Xd+xXA6T8Ra3V1fbPH6iLURaiLURaiLURaiJgldB4qwRw141xYXKWO2AIZlXhhvkOsMsOvVR9fvW81ITrUpCzJgpoJ4ZTVvMVQExl4+LsCjrJOcRw3OQsovNNWTAZl2My7lOPeohwu3pKOU4kwkzYUo5TCWPJxZUY4Uo9yYWFhSHlaUwsLCcWUMPandTbvWlaUwmWE7ZTiWlRHjpIeVEeOvond5dGg8p3azECEs6titYhZD8nCwrdiNYUpSOauJRjiPysL9yb1dvP72M+mGWFJM3nllGw4nblIKXKiRzmtoYWj0eTJ+7Hqu1YwsrPz8J2w7RysNFSf5OPkvNnDHCfzXI1diqWyUzVrI7Q/ewsdLdsdaBzktGABBF2xTdce4/T0WF69Jev3o4d5JyYo+39JovoLEetxxivD/rNWjJ/DDeMRCwwoQOWLObVCcoBzCcYtTDBpl2lm88uXVCUIijqcMItIGCsGEpRE2uIu+eqMoMGGqQ8C0eeqE1EUdT+oX0jMPBohhE0gtOzrhKM4R1Si7rRDYOMlqiwwwG8ICiSXaPukKOs0BMOUJSbUPvgDMnFFx+4OHdOQ4vGI275Q/UdlcodzjIWqWpzIyJpNJvdmSMI2+ajFSkSwQFdBBhf89zHv46u2Y/ehmw4jP8Y3h2PMbV5vCYpOMi3Q3CLGJhkw0ZtpJNnM7xjYefnGcZBnKHhhz1keApO5BvZ2M0e5vDEk0guVmK8/MT4TFgx5SftnJnAGUMRN/6ZSfHc3hlM2F3d43cWzbHeObMNpN4d5xXfHxcZxaQnaChOHfB4wQXjFEIzgm8Zi2sz4ExWKzyHJmF7g5ds1N/j6YVipArFpEGhWDV3HzhoqHOhde262J88JkXnDyRDGsShXd0GshhZun/AHpjpj5TKUVj/Cwu1Ybpn7VoLyZO/wBvn3MdHgzotSElOjBPUXhU1VRqxUK7KFeLJos3TPXPTKyu5dyysrKz5/8AemV3LKy3+x5LLMu77b//xAAqEQABBAECBQQCAwEAAAAAAAACAAESUREDEAQgITFgEzAyQSIzFCNCYf/aAAgBAwEBPwGZWplamVqZWpFamVqRWplaYitah9Ojqb4UytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytSdSK1MrUytTK1IrUitTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK1MrUytTK+fPJF1jkwseV9+QRckwsyfnwnbHlgBJYwnT+y7Y8qAJOsY2dP7L9/JW2ZmdRfvtphEdtT4+03VP38l03GKIf8AX1voBI0+2p8X2bq69JemoKCinbGwI28kF4vnl4Mejvvq/F9h78x7AnbKdseTD+WGRjEsLhW/rT7avwfZnw69Zl6rL1GXqMpp3zsDYbaLP3WppRbPkTf9RY/zsz46p3y+Vw362T7a3wf2RdmTbMtb4eS4+k64R/699b4PsHyZRZRZYZYZYWoONtKt9d/x8md3dcGXVx31/wBb7afyZY2xvq9ttHvvxD9ceSD3R6UvyZMOVpHA2ffX/W+zPh8r+Qa/kGvXNesS9Yk5O/fbRbcnk+fJGdDq47J3j1F9uF1JDF/rbX/W6i6i6i6i6w6w6w6w6HSJ0IxbG2seGj5K7u/fZhd3wiaP4OgJwLLLTNtQct7hEwNl075fL+TObOEcJsJ3yidnWnqPpvllp6g6jZb2iJgbqiJyfL+TaYSLqi0xx2Q6bSdnRB+WG2dCTi+WWnxTP0Jd+Z+ndHrs3xTu79X8n0ziWX21CaWWWeUTIezpuLL7TcWP2y/kgn4ofpk/Ek/ZOTl38od9svyY8w//xAAsEQABBAIBAwMDBQADAAAAAAABAAIDExFSEAQSITEyYCAwQRQiIzNRQ5Hh/9oACAECAQE/AaY9QqY9QqY9QqY9QqY9QqY9Qqos4wFTFqE6KPHtC6aAh572+F+nZ3ZwqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9QqY9Qqmf4qo9VTHqFTHqFTHqFVHqqY9VTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqFTHqPrIB8onCHHcF3fRlZ+VgBqCz5xw54au8uQ+wD8skk7fCzlBD7IOfk2c/RI/sGVnPngIfZHp8ldjPD3Fp8BWAHB4lk73cRe4faPhD5L1LJTKfCjl/4z7hz1D+yMocRe8cHwFarFYu9d6Bzw5NPySRgkb2lefo613kN5i944d7fqZw9A4QOfkpz+FIag5+P/AFQSWRhy6w/yoHiH3jgjIwqSqSqiqyqygMcPOeO7CZJ3ePkTwSP2lR9+MSevD2hw7SExvaMBdV/aUOIf7B9lwJR4Kh93yQ+Ag7IyEz0wTldYP5OMqA/yDh/tKDiu4ruK7islRuz44l/3mD3fJCcDJQ/0HwmtDfRdc3wHc9P/AGjiT2FArKys8Q+vE3pzAPGfkkhHaQVB1VRrf5CfL248qZnewjnp/wC0cEZGF+ljX6Zi/TsVDFQ1NaG+nE59By0dox8kc3IUnSWDLzkprDL+2VuMenHVxdru4fniD+0LuC7gu4LIWQshZCyE6VoTndxyeIGZPd8k8H1TGNZ6cPlaxneo3mT+Zv8A0ntEjcFSRmN2D9xjS84CAwMD5M3p3NnsJT+7GAMoN7RgBRMLfUqWISjBUkTozg/aYwvPhMYGDA+TdTPXHlvqoepkDskqXqX1Ncz8qOfMXe5D/U05Ccxrxhyl6Nw8sXp6/UPPomdOT7kAB4HyYLqYbI8NQ8ZyumjcIu167fxjx9Lo2v8AcE7o2H0R6N34K/SSIdI78lN6Vo9UGhvp8oawAk8djf8AF6jnu+Yf/8QAPRAAAQIDBAcGBgIABAcAAAAAAQACAxEhEjEzkhAiQVFhcZETICMycoEwQEJQobEEUiRigtE0Q3OiwfDx/9oACAEBAAY/AsR9bqrEfXisR1aXoeI7desR269Yjq0vU7b5Gk57ViPrxVYj5ba3JpbFIPBystc8mfmtLFcPdY8TMseJnKx4mZViuPuqxHj/AFKkZ+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5lMxXy9SxHdVSI/qsV+ZYr8yxX5liP6qkV/VYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yxX5livzLFfmWK/MsV+ZYr8yl0XP8Aa5/tc/2uf7XP9ojYfMESSPfapQsxW1xKBiSgt/zX9F4rnxfeSp/FYedV/wALCyKv8Vg9NF4L3wvyi5gEZg/pf0W4qTqHTrFeZUd9skpKXcmpd2X2nmq+6r7rWv2r/wBqrU6D8KQo39qbdWHteV4TNb+5v+B4jbL/AO7b1r6zDc8KTrlZhq1/Id2Ld15WLFJ5hT/jRbXB67OMCJb1Mfap6J/YbtN+i74tdqryK4/tfor9hSB1R+V2kWkEf9yDWCTRcB8IsiNDmm8FWWOm11RvCbHiCb3eXgquV68xVl18ptcrDvtcu7L5imiqu+BVaqr8PiL1+iruYVhpv28EGfQKuKDGCTRQDRer1er1er1er9Lp3A2UCNiAIA5KbWuIWu1wbLamtBubVTH2qfcn8vRV796vV6v70vgmlFMIzdJF8xq1mEXb00Hzuq7RH9KvV6vV6vV6vV6nDinkbkIopvG4qJ60EHOaQDtIQYGAyTYT4Yk+l6ZEhUtmRH2uXzVe5eqBU039ymiumfwRJwG9doKQyaaJD6kwG5usdMf06IcImQe4BY7+ix39Fjv6LHf0WO/om61tjrjojN4goRhc6igxHXNdrJtqJQVFlyxHZkIjXEkXTcocNrgS2plsU/t0vkqKqp3KaK/DopH4VoI6Wt3BRInGWmP6dED/AKg70L1aI3sjDfcVZd/9V8jo1nKywSbob9omwtlxXmYr29V4jZaPEFpys7DUd4OBbIrzMVLJ5FWXCR79e5RG2JiztT9Rt274gM21V7VsKqJHRL4VU1hds3XJ7JzlJN4k6Y/p0Q4hEw1wKwX9Vgv6rBf1WC/qsF/VN1bDG3DRr0c+ugh4mFaBoqKqoEHIo/Z/dW3zlwU4RuvCcf610eK11oblblIXAd6H6UO0nXcrcMzCbE2gy7le5TQ0uZUjemhjZTR9Kf6T8RnJNESetuQewzBTInGXeY11xKw/yU9ouDiNGsJheHOXHRMGRFyeTw/Sh6Y/p+CO0gD1oOaZg92am1Eb17I/Z/dWId804vlM7k4fU6g0AkHqrLNy3DevLPmgWUrULb1T2DYVD5KH2cqKyTMkzTYQ8xMymjitvVGdG7AgWiVVS7erp81VitQ6jcmtNyAFwQL50UVguaCntF5C8TXctUWSix14VKDaVUWua8suRU72namtdcVt6qcXomhglMJnJQ+zlTegwmZTYQNxmdFqJQbl5FRtnkq1abii83tNNEWLW1U392RvU5StCal/V2mN6dEGf9wsNmVYbMqw2ZVht6LDb0TIsNoaZyMtD4Z2VGkDeUVwXAoc17I92vRbleiPn/dWn3Ky19V4ja706GdibyQ9KaOCDIfnP4QbH1mnbK7RF9Sh8kO1Mprw3KdkB+9NG46OzhCbheUGvlfOiaxBkPzFARtZp0GxsqE1xvITRDlUbU97r3BFx2K0HU/rJA70JbWpnETQZAoPqqgSdTaJpzDtCZoLIAEhtKaYgFNyZyQ7UynwXhumjZFl+8bU1pu26C2AbLRtleiyL5ht3pzUGCUnGuiLB1bMy27uyIqFDf8A6VEhf6hpjenRB9Y7zB/n0ROWlrdwXNcCiNyPVde9uW1bVL5/3UmiZmgS2zLfodLgm8kPSmkbQmxYYtSEiEJtIA36IvqTOSZZaXSQe4WZaDZu7TREJ36A7ehFhttUkUJggbdDpbKJnJQ+SPpUT0nQzkm+hMPBN7NrS071JkJhPJYDeibPjoPPQzkoZDS6StEWQNE9hJ0O1SWzoUYjhLYE552BM56IvrPcElbbR25RBI2hUJj9m3TG9Ohr23tMwvoyr6Mq+jKvoyr6MqnFdOWiI7ZdomUXbyhuVley9l793/ZeVXfhbvsEnvaK7SsVmZYzMy8LXd+EXuqShOIy7epscHU2KxE8u/ctV7T7prQbRJlTRE9SbaiNFNpWNDzLGZmRb/HqT9W5NJ3qsRnVPLTOuzRZfVn6Wq8FaxARbANp2/cpplqI0U2lQ+zcHU2FEuIGrtTx2rJ2T9Whs4jBT+yaWODhZ2FSd5D+FRzXDcvpYOiMKAZzvcmlxkFjMzI6GziNFN6xoeZYzOqMP+Pt+rRZjGR3rVIK13gLs4WH+0wmlViszKKRUF57smgBqnDdOd80dzqhdk468P8AWiMB/VYbui8jui8jui8jui8jui8jui8juipDd0Wu3s273IQ4dw0dk291/JTVUOC99HNbir/xprNXqi4ofPSPwAZfleFQ8UHvNyLnGgTnCkzPRXTTu0+RmfkKKuiyuyMp3tcg9tHNQiQ/cbviFzvYb0XOvcgFLcuY0e6krx3NoWsqLj9gr35sWvDcOS1WPJUjqM/r3Jyp8rI/K2bKvkqldpCGsL+KtNu2t3q3CPMbvhTea7BvVp3sNy4qW1A+yCHRT6qlQtmn/df+FwVFxXP58N3p1n/lmnJOeDcV2lr6pJhmZy3Xodo4zOwBNbOjrii0P1hwRsumW8FrHoEwEzBkQrEK+asNeS7lRF8QyFyFkzFtBpuR7ESA2BeLq+ycYbjNu8LtHOkJyQcX6pupVNa0ztVCsNebXKitvJlOVAiGu1RWacYbjq7CE173ynskmvBnNMbOrhM8ERDcZjeL12j3SE5KlyMXbOQWrc6oTW29cHdRPmeKJY/y3zCtw3TrIzUIF05/hdn2mtyUUTlIVTXvJ1twUS1WQ3J0nSAE5lecy5K2xxlORmmSnOzuvUITnMU4Kx2htcqJ4cbNlF0NxNm+Y7tVciCpDRah+b9qbCWOCs/yPDdv2KYMx3puIA3lWf42uf7bEXONpxXFVvXJHqj1X5UwvL3Ni/SmFRT2rgVx+ec767gteVk30T4ZdKZoVYBmZzuTdarRcgS+yZVmmV1Wok3J89raIBr7DttL1DcDOyAu1DrVVMfyKKw42TOYKsNdM2poOCm2JZG4hBxq0BPDotqYpRBu21NQmi8TmoThWy0AqY/kGSmItk7QnFtGuEphHx7XBQ2i8TmiyL5TVdobij/iJoN22p6GshSLQNyaX0e0q3a4ykohnQiiiA7RRObtJUGvlvVv6bSi18wMkPFkNrZKIPK11yiC1ObZBOmZHYVZ7S26aZrSLRKSgkVs3q32lJzlKqil1LQoogN5u7tdE2q+umoVNYLw3uZwXiMa/wDC14bwvr6LUhOPNeG1rPyvEe561lQSXFcQuaHRfhS2hVX+/emphTCn9+qqfP1CpReZeb8KrvgHRVX/AAKKneu+71VB8v8A/8QAKBAAAwABAwMDBQEBAQAAAAAAAAERITFBUWFx8RCRoYGxwdHw4SAw/9oACAEBAAE/IXRN7l14LOLzwxSbbdwxMyz5Z4YxKuqs9RRbbd1Lp15IhwKJrwzFPwvQ1Wni2V1EdSCm9jRO2cbP3/RxaT6zH3op928IKwujHkB5AeQHkB5AeQHkB5AeQHkB5AeUHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AYCDqPOzAkl1nkB5AJzi9wSfzTRo7zyA8gPIC0fuBp/kHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AeQHkB5AZLnr3GiaL4ifzoFSdrDV1xofQLdtLY7sFkL5HkVpGKuov8AYg9X7n+ntySyxUm2TIuuHD4Es7V/I0WHsE0+sPtMmy4s/OTeQABsSqtUz/MD0hoauh/ZM0Gb4IQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEINUm4hKGLashCEVZhGrIQhV0H2EIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIT0wt21dGPN0XHQ+TnnjpfIxvKJ19RNjra9hmfKe/eMXZUNKG5oPpyxeSnvyt+vQhMo2NjDW+Nxf6JRauI/0x0v6HwZe5xVqxUlXbl8Oxq/Kf4CB9ip8ootmpakLDKmQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEJK99BkxvYY1iEO3DKwzoyEFThgdSEIQhCEIQhCEIQhCEIJ2ibE8LpHVR0Q+kMhstVCEIQhCEIQhCc0YMT1JZ5DNdymvQaSP+tGRR4wvo9UNybTYzlf+rcIWHVmgQwwmJlGxv1JK44BPg8X7DF2wK9j37kKlGj3+hSqyfWSHvk9mZIhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCERbbiUUNr9SEFTiMEYxoiEIRVY1ZCEIQhCEIQhCEIQhoijOuBLVRaRCf9Q0RRD4DHiEIQhCEIT0K6tbCcomiT6/iLh7PZGLsa53dBm4uy0IdqwbITFxPcXA9xcD3FwPc6D3HwPc4D3OA9x/SndB+lGFueBqITtGcy3Q8uiUT6b0m2Rdd5+gQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhDOPVlMPUe5CG+O5MhCFQ0URCEIQhCEIQhCEIaIo5qhqiokWin/AA2lq0NW31SpsEzRp/8ACYMdYQhCEIQgtVNdXNBPkDHB1j2KQEmVt21Hm1bQSkbt+BMb+/J1nudZ7nWe51nudZ7nWe51nudd7mDru6t9BBtPBiunGswjL4M8+igohp1lsQduyQSpSzqeRcuWJCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEO1ohhWiIQ7EaLsZIhBUyInl0hCEIQhCEIQhKa1g54JEsKeuqBIMCarZbV+h1md4nkbrUbnQwmD9cKEIQhCEIK2EsW/uJScGa5jVyt0ZCqeLlci1C/EDCY38+fR7pgtbVnj54+ePnh5Bj2pelpipnhr0fwEBmjGnw0NrivYTNbqKPBzPdOOIcjVvarA7BSjXVZIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQzW7LTHl0hDuRtCEIRVGrhCEIQhCEIQhoqnN9jT3rul7DGmE1qLmEnYk09J6z1gl5wY/a/T7xCEIQhBYWm1yRstdod9CF9pQQmdWi/f8iYmP/fn0/m8/wDAfoXvd/b0af33O9ocMYkdnshgeyY65+SsWulydjw5MEWu5mOcMajIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIyJBIVVbmecf6EFhvRN+hzmPtdxsgmtm6uyC43VZCF2PBCE39qrf6POP9F43RB0aVqmQhCENri6nMGJTT019jnpg6cs0dUNDSfReBdiJ6NGrHtD4oYdc6/ormhTVpLlv9Hn3+hfV20x2WRhpjxKQ2IQhCEIQ2EV1abC6YmyGPQxeyZSTXfI2BMb+PPo8MyUt4zx48ePDh/542ftBIazkrb5YlXEMLWqlwthxFfrHNpoxhGGstV0MOlNRSoXccFWzqE94hCEIQhCEIQhCEIQhCEIQhCEIQhCEIQu74HhNj5Os3LswGdjkKNEyZSGaVbCwoDVbSgRLoEUiEgyZCHwg4V44ooVuOxAFvnRmSIKtDiBtdZBtJW4LWmj/wABb8o3kYPRzT5r7oxv/CIsZGzTB3GIu4kjgngngjga7CTsfsdGmim1yTFMWc5A5eg8ushCCwKimj+H7iP4kL6kII+WVgr2iyYM3IA9mbbyb7DL6n3GwJj/ANOf/HKD45a+jEtJKprccbTyQbujXvAhKuUKVWODUjRKiVPqU94hCEIJm8Kl7xfUbiEIQhCEIQhCEIQhCEIQhCEIQyH1Hk8mh3DchYnljQ9HNhfGGH3OYrINJhFW0peWX2jqIx91izOLJhrc6ZaUL0j4kUC5Xa4OalUTRCLqwHCHNU40TFuol2o6dRlVZxaZwi6hbm/LC3D3TYtjmvVtUJbyunY0CiISkzSKODrSYL3RqgNL2FvLcdiGHpzTEEQIrE+gIMjcsK8U5Boq20aFisn2OkWoTb2vQhbUeafA/YfCQrtQdkQrgv8AiL4+5TyGpe36JqxTpfd0R5G5YSOkJlzLq9FlWLuhkJ6KkWlHZgRlxJpRfH4O6Bfn8iwxMb+3PoiaUTTxPueMHjB4wP8AzYz+mOZqZYnv6OGw6+oOJk9JBNRCNDWWEihCu/aBL5hPcIQhCOrwGpji8H9UYsZxUQhCEIQhCEIQhCEIQhCEIQhCCjQRo9xScqaUTspommqRSMMLqh+oX15PiDoCPyJRrk+4jVUbXsGCJmYE/Z6fKnxIndmzFRjKPhpoqvwH8mMY0pr6+jGqag2EpYQaxi12yz1Y1QUq29kWAmJZGioXKpbjqjRHTcME2jijJZUtzuhelFbZjRl0CF6ImP4Zb92QG9H1HGJvQvQUwoiOhDuZB1+z9E6DY1WsTCNZU1PjfsOVbsyhy75SMcy9RbjqKZwdTt6JnMzA37icVKpNgt2stY77GD88l6R93Ylg9ZEIKBKLuxpNYGs+SqVxZfb8kWd1+B/j0TH/AJc+n8/kpSjYwrlP8H6fD/cWjxLq83uYVWokJ5LDcNR6t1QmGEzIQTNEJe/p+B43Xbln1iNw+TWbYhCEIQhCEIQhCEIQhCEIQhCEGyXp6fcPD8mEOvKMncPRDVsSP2PiBfYfkRopDGUGgNYPV7VtJ6TBXMcr8TMOHYrB6lOQ3DHr1PqZYl1KzCELtEowREK1XUlaXWahBp5KPYfDiF3v3GvefdH9rgxHwP2PgvuxC7ih6pHLV6+5vFLDfsZG1pdX7Fr3fg/SrfIk+J+wqGI7FoIs6md/Ro2cvrp6ZomlK4HAsYMRp1zPj/Rf7dyEIUCVpmIW5VtuOUvThW6LW4rnaxNImsp+n93X0nVJTlf8kXM2bgo3dCkS9HnPYjGXTGRJVsd2KJNGIpt3QlZ1gn8dSfJ8jyFqsMgzoQlSIedK/wCbnAXGqjYa7kJlJ6rDIQhCEIQhCEIQhCEIQhCEIQhDNiVWt0KDLWEIUvxjXPZDsn45oKZqrZA1E1US0iVWorKcUFIIQnTw2glFSlyF7DTRQ/8AOiCvsoxi3hWouw2i0dY9EvpFSFeDaobtMGJGzcJb2pimpeW4VDOJ0GYCSbJakoeSdNc24oG7mm6HEnshKOBcCteJdUIWpVtuzSbfAJZi3Z+BJmLfaIbHCVpOEJfKuW5sNeqfoM+4OfAuJy6qP/CiWv6KsvC2kcydhmQqxe/RiipOjpeT+WPbIkeW9SlxSJa2PVL+gdopgTW+SEIaRFtYZ8p9xNw3wDIl/RBOkid9no5Abb0I87PPzz883PNzzU81Gsb7OK/UNT2FUdR6t8jgRe3ugZrotDGbtBaNu0Eo0uClhLo0S44Jruautktd/YJDE4Gu5d0R1VdGKYvGxm87MhCEIQhCEIQhCEIQhCEIQhCEIKm9gk5RMEsEIloiSGpbL9NzPUIveLcSCbySREcutk4ZQ1WsSNGRvyFoGtksokQ4kI0Bj1YtaiUwRiU6bAhr6tIamiCfQWFCgpxOx6CEuFwb4ggQFGglMi3p6UiCHEOQgrqPKzDONXIQ2ge41YHtnwzJAcp/KGsYfcbj/wAIT0Ma9WnIGYV1fQzxwtzqINW9wej7Jjw2+KGkstNUzPJ3Esa46YRB9L9P2SPdH0Xqjm9+5/HJmj517kGXUhCEIQhCEIQhCEIQhCEIQhCEIQx7zD0OkieDBQsGrVo1e8p6MSWZ+og9rJDqPQfkU5yyJCHUZs5XLCMLmQGmw2ZCEIQhCEIQhCCpxKsa5DTWzH6Rdcxg8kIQhCE9EIQhCekEhcluJVeHgZvadxOmowR1Ath2gy08mvd6whCeo1DXeaOo10t4ToJY3asyBdAtfqBN2zgl9w2X0BNNHAydF+RLIxOUvqJNF3Y0VZfYzz7Tns+RZd8GLr5yQhCEIQhCEIQhCEIQhCEIQhCEGq9xEi4BTNlwKDFGWzBZCi1+QXzUXKncvU8yVsfGHhbsUrsJiFvT4DazMa0yUuY1EhOdibkFsFb0KtsSmrK1NjrOGJe2knQWbPuxSCitSqGl2YJVj9vGB2BtN6MZXm25C+sTBZisIFOtEVGNK4qhBmS8KeomDGaeNGW1N8NgrJKugg8uxhKtiJPdrDLAq37ZisvkRiXgv2DC9KFLFfQBioigSC90ixY5GfTOLYLJGdia9BLT5TNB6s9xsXIsdNgPT4OutshOMQmUPR0alPkOOfIE/dEu4ZNS1sw3RECEIQxmmUmEqfQ4e6KiVq1rBDxIKZNblsN2whGkr3b9CikzRr/moal1qyFpHVaP2P5ahs4MtuKWKJq3DWhdg19garaW+BlvdeqO8JcRdv2QZh4VdITSfzg0+RGWfaa4aDGvc6HbhCEIQhCEIQhCEIQhCEIQhCEIQprRGD1C6aFWBKIUn6UpIqqgx1JuLhENJacrQ0qNci13lF3GImbvUGLlobWamI8R1EtDOYWxR0ZpSgsMmOKpibDsymw62maMGgYla6awzN3pE0HluODpBtFwnBg3CLMm2qOkOTaieS7mIGnUzJ62XIzTZOKxZ9IVNxKeuRY2RhDpMKOsbaccHSEIdwJ3XvqNYbBpLVGBym61KT1JrAb7GpIKvvFaQ5hoLRpk3DcvQYL0DDXIsad2ZimiLTTQ5sAS1ZjE9Z1YMLtk2Mxdy6tTVgXA94pfQZhj0gz6JXyIQhOCI9Eg8tR6MU7HeTrT5ejpG6jZrUcufuGT5vWPYnJdu1kfCLGa6VwPkDJFNL9nqRRMOr0H2zohmFAL9IJVGGqPsYlu7hYl2yPwA49DT6CTWPuEiD1/w11r6Ml+v8h8fqifp4NdhrUxo0eqMWJbqwN12IQhCEIQhCEIQhCEIQhCEIQhCEIaDzqTyRyQKkdBlkIQhCEIQhCEIQhCEGvghLRei22QhCEIQhCEIQhCEIQbqSxEQrl8EjIT0QU5QhwPuhR5PsZHT4+mTdTsjve5plEunpiHCIbHuiqNLnA2n3ZIr4ZhqbNxNyIu/dkdSOpE3+xC5GkNxfU0rAubgVJ1fVCRafQibk9SngxwP7T1hCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCCXIIw6G2yEIQhCEIQhCEIQhCEP/9oADAMBAAIAAwAAABB/9vfk3039ttltt9tkstsslltllttttttsmVN/RsgMssslsslkksslktltttxB6wmbipACSSSSSRSSSSSSSSSSSSSSSSSQCSSCSSSSSSSSSSSSSSSSSSSSSQBBUTIasryQSCQAACAAAAAAAAAAAAAAAAACQASASQAAAAAAAAAASQAAAAAAASHJQSgYARliSQSSSSSSSSSSSSSSSSSSSSQSQSSSSSSSSSSSSQCQSSSASSSSQIjap19kHG8ASAACCCACAACAAQAAAAAAASAASAAAAACAAAACQCSSSQSSAAASDkCJeSSSB2QAQQAAAAAQAAAQCAAAASAACQAQACCAAAAACACSUyAQCSCQAAQDURAeADI1hCQCQSSSSSSSSSSSSSSSSSSSQCQCSCSSSSSSQCSCSQAAASSiSSSPFQvES+1AUQACCAAAAAAAAAAAAAAAAAACSAQAQASCAAAQQQQAAQCSSQQAAACVzf6BsAESKYQQCSSSSSSSSSSSSSSSSSQQCQSSSQSAQASSSCQQAACACSCSQSRh17wAAAAJIAASAACSAAAAAAAAAAAAAAQCSCSAAAQCSCSAAACSSCCSQQQQSCLgvECRLfB8GAACSQQSSSSSSSSSSSSSSQSSCCSSSACQASCSQQAQASAQCSASQDApFIfFkYYjAASACSCAAAAAQAAAAAAAACCCCSCQAAQASAQCCASSSASCSACSSCC0GCUV6CgwCSCCSCASSSSQSSCQSSQSSQQQQSSCSQCQSACSCCAACCQQSCCSTZVGtt/yFdESCQQCASSSSCSSSSSSSQSSSQAQCQSCCSQAAAQAAQCACAQQAQAQPo1Gs7VzIlCSSSCCQAAAAAAAAAAAAAAAAA0iSCSQCSQAAAAAACCAQAAAAAARYulLI1INMiRCQQAASSSSSSSSSSSSSSSSCQCCSSASQSACQAASSSQSQQCCSCQKCnTilv7BABaACQSQAAAAAAAAAAAAAAACSSAQQAQQAASAQCACCQCCACSCAAQAzgKbbYySRYYQACAQQCSASSSSSSSSSSSSSASCCSSSSSSSSSACSSSSSSSSSRdToICASSCCJIaCbSSAQQQAAAAAAAAAAAAAAAAAAAAAAAAAACSAAAAAAAAAAf/EACURAAIDAAICAgIDAQEAAAAAAAABEWGREDEhUUFgIHEwofCBsf/aAAgBAwEBPxCxpY0saWNLmljTwzIsaNPy2iGvcdaXpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGl7LhY0saWNLhc0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0saWNLGljSxpY0sb+ScCZeBKR98JhFDS4jg2X2ttt5GR4njpOhL44MaI/CDGfZycfi9pfRBIXBBoaII5QlPhkz7M1HfE8Oj+CCQh8EGhoj8EIefsqUPx44UOXBIoeeO+7Y0d38KbQ8JOz7KuqT/AGJ6dn45i0+l5EGheJIENPY09kfZD2fuN4fIgc/ZGoQ8eSef6GNDQnF1jQ0NDQ0J44XsSkMe8P7Ko+RE7X8YSAiV+2INC8EQ2P0FBUUEfXP7QSGjA8Nfj7E6TlJRK56Xw5oPyh0jhKNCfwjTyjyUoSEOz7IlLgcG27O8pQSQ9MalDQuXCyofoH6B+ofqGvoRBrhpTCQlBEiv7IlLhDiIa8ogJ+CH/o4aEj9HH9oYaGGho8U47BIRKvp9kRwaIvS/R53hyv8AeeAU01K4/p8OUnwfrP0H6j9fA5nh5m+FCUse37IgZJhYWie6nuePaH/jhG4fRSUlJSVFRQJ3SGHlQIgCR4h2/sildc697idCYkdyEzmaGhjGhofEcZHu7Psk8JKeR5pbiBjS2NFCPjp8olCMYxjGMYkTz7O0Lg6djkEPVnoQjOJgSHBPmGfHr9/AmkldDGMY0QSWg8B52PZPszj4Ijo6G02mmMTf9R7TL/H4GFeqYx2Hj6Z8gPFIkOpaftDWkvXE3yPw+ek/cP/EACoRAQACAQMDAwMFAQEAAAAAAAEAEfEhMVEQQWFgcZGBofAgMLHR4cFA/9oACAECAQE/EMYTGExhMIR/xCYwnK3FEwBBaLO2hv50gQHuDfx/mn2nZVVVUfMxhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMITGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGEwhPD+CLbj4JjCYwmMIFsPgiu4+CYwmMJjCU/0EwhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGExhMYTGH6FothrEsqKCNTZloK3lq16JSzBelvQB9VmUbS1awv0N53ijXoGDL/RaQH1Ol6QK0m/SoZpvLK2KKDBly5fRjpqSp6luAFnStbiDvB5XaKVt4S3QQYP6WGvUpAF09vPPvzAdoO1B+35lICXi8/3t976agbEGL9mQYbTYepGOym3Sh28R1NQC+Pn42563A3dPnoGLoKxg3tBvaW4l+ILiB0dsuK9SKdp4miq27/nvUTjr95QYMfQ3oMGDBgxavR7RVZAFnqStbml+Pf7Rya0ju1bR0vRPJ5iMlL/xqWI4CaEGL5ulxBzw5Ick80OSGelqiLBayXrGvqJKUPNXGbg+F/fz01EB0YJlQcfnz5n8aPSDH8n7ImjNDTFi9SNRWO8ANYZY1Ad8Sq/JBphHzPR0xxOVDkhyQ5Ic0ZK6GkhYsFp9SXWp7EsOsXbSj2eHjWWyatt95aHtp0GL5en2D0CCCBmp9HQixZU+XqS7NCZqPcUtCdv7PzxCbpS629vHPR1Eaen3PQ2WzAOfmU8/M9+e9DywCh0KoXNVolb6kHrW996vx7faHbBPBfBKbQGzatq7n0hppNPtP5dGCvM8s8s8s8080808kS3ZsurEgXNQbHqRto7Ol81ufeCIaLv5/j6dO8ZuebiFDw7tPHtd/mqzaY2/M6EIMIMGDB6X0WGWwepEHfonujemt69vY/5tH3A012+uIRfC0IGlgunj6zv07Mqb9ehCEIQgxZRtnqYBcdt417SzlKdHXt/fEtFrua2eNfzSMei7XW7yfm9xNarJq1VKhWRF1DjvEVW6DBgwYMSqE1DT4htGnqa3eO+8N+7CkDc0+T+oCMrse+ut94JoAHb/ADYlaVNuu1DN0pB7ELNydiTciw6jXqdaliVXn+Dg6ANg3vbvz7wdTrS6/wDDfp//xAAqEAEAAgECBQQCAgMBAAAAAAABABEhMUFRYXHB8BCBkaGx0eHxIDBAUP/aAAgBAQABPxBIGBixDXV1+oAIBUVidtcX3mWmIsVOjr0+WWwdXajR1xt9zJ2S7ENHXp9zKRUeKjpv0+4BVXbDOQvigfMBlYEaqdtcX3jJwFJq3NC9fCXRSMGDOD01z9x9pPliqw1q8xrGcx+ViNvsD+Geed41aer/ACzQp3s36ZWj3FU+bg9i0VH5nlveeW955b3nlveeW955b3nlveeW955b3nlveeW95573nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW95aB4uV+ZUbB4axPpkUV/c8t7zy3vC6K+OsIJndf3RFQGCv3Ty3vPLe88t7xheOc4PuK0E2P5Z5b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveeW955b3nlveXa1Ws4fy/UoYZNnI/d/fKV140N7H77xApnWYoafPdmX1pscevdiyMNCvhPnOOJwaHZoTfj7whY0Ydhh2yv2ZeimDQHDGOpllAWoCjwAhNJsckdGflJpiOfgZl9ylg4s/lMs5or+GdUgsfcl5WeKbeZ3IBVLbqHFWfi4uDFCrPBGJlL6O6AJZ6NVc4rfjWZK+X8UQpJoml9n/QAy/8QAAAAABk5UAnAZ5zK/bP8BjHLpPcA5H+AzqYTD8n/kAAAAAAAEbMJDINYXwdH3/cGY0fS9PHOJdhQqvg8c5hRDxiFHXVZ/csIBoXpwuvmsFrHLeWNzzlNSezYdSdpU0qn9wP4OKSjgsc93s5FEUf+MKmHRoxAHnsOT7VK+6A/tv4H2uOrOhfy5QsQFQMvLy5n/zkPW1e5vlGlrmSB8SPenGE5Yr9iOKeNEcR3PqESBYn/lAAAAAAAxfn6JgTBc3yNDgepV2YaxCsARlrPqIQMsTw6xFK6v8AzAAAD63CaSzriJ1p7+pADRXvNeb0zFaZcz/YABI0rocH2lhGsFzXAc/N45RCUTTi+cuEBWLWrueH9Sg15FGl/glwiEQp5ntKbVBRoH0cX2M6H8wVQGwf6Qm9qSkMorEg51WsF1+h3g9a+qNJ1OOx7xwIpmjELp+uAtn0CbU2Wtinlest+KRTsakQaf8AkAAAAAABttZ6IIAoMEuR+fqEILWAY13Z7wHX/AY6yzDmh/xgAAK0q5EzdTzmrPRifnFmBCgCVylSpUr0C0I5kOVW4OkaoH/UAFAWJeSAasfC+YlxqX3RxTRZFzGriTQSoNDRbr+DnD5hhfGc3Q+doFhYNAaEALUDiz+Mp/EU/gKfwtP6tP4Wn8JTbfCjhnf0Ev4G5UD92zHRQisY09pnCraXiqqEdmKNRqZEojoXFYl0Lgq7Ngedfmb3bOpKUf8AyAAAAAABShvsNzYxGpmVb6lRXl0mi8Amr1MqmCceH/hAABWlXImXI8NWVCj5wGiHAlSpU0edWap8s5H4mb9Iab3p9TjKlSo/HOzwjMcn+kAeIoVJM8Z2tx7sUMBdKxEc1wBbV514LGcgq9ZLV2OdVDTpaDY2D8Q6oZWzaY6Ax1v0nKVG2Ton96n9+n9+n9+n9+n9+n9+gTYfugQ2+W5VWJeOzeujU6ZE5MzjyZcFsfuIyylI1uXZHCAqui4jMEPFtvvFqASlMNYqM/siUoWC9LziOWKrfTlEwf8AxwAAAAACuE3H0VjcXr6jCbMsQvcAiOtNvUQg1YcpJd1/uAADVBbymXFecylnzlaIciVErWaaXwMwes82LUA6Fx448WoaLPuA3XxDehz4dtEyXZg3JebJHQedtKsxKgpzI0/6ABBXC8MRWltzfxEmpp1FuQ4ULnhHZCwpNyYXZU0TPYe8JlgDuaD5SUAcD0ruu/D0NglVoAs+f8OeeU5I1l7X+2PleL0DXIpyb59L7cUOaI/ghyKfglj5K+GO1U1LpdLXvcNK2VXZWudoUV4fSJTfIEqrorjDO74BgCm+uIltOYvYNCIIVhdNz/xwAAAAACtRu+0HedusCi1X0DUAtZVm7LMe9q/4DKDLMQ0P9oADVLzRdfagXCPHeVyjQW4Jx04RiR6tYvyo8cEfX4Zx31gdAOkr0VK9FSo2KSCo8jjB1mVZ2lShTiP9ACwxdBsbE7w1BYuoC7LvlV/UNQT2ehwk+zX+CE5lrgBb8Pj1+7qPw9MPFxmp9D/iTa6uYEqo4GpaJ0n9FgyeYhALGrV/cdSXi6A2Fl7Eswss3cz+pZTs5XGEdH+O/TFQdmv/ABQAAAAAOYbCgAwQ2HQgGzoPpuTq/MH5EXGOjI5h0YbL2jwQ3dC4FO3OXN3bqC0p+PRmkwTEmr6gpYStA8fRusQuIH7AmD2Y6f8AIFSnMRnuygigBwJU0RXgZlkUuLCa8QAl6lMCIqxAmXKJMXX0VNPYFwWLs+7F6ATzE8RANx9o/wCuCvGS1SX6PjG26v7CJxAoKRjvdTEM8hq6/wCkAxgGeNy2oi3urHtdSoTYIFlplMjyThBcABJWHvIAtFF46PwS8PE9LE834eivBipANHxM/pv609Gk1I5O1nACLDLDVPaIAWugbylCLdSKDz1fePnMo5RaGR4jsw1S0FWS+cZkELyw44krEbbwN+sOBY0Of8zYUfQ8SV06X/P/AIoAAAAAFg7IxzQLjC9VfuNzQGobfeOZKDJHSyIgc9itfq5bExq6xWSggFd8pTENdLV0K555YwDVg1bES6+oPB2jjA0r6Ku8nGXZIrFKNRNmUqAVxXY+a+WMN9CKgrwJlsP3Mkcw+iuIc5hrHF0jdC1wi0eJrtTOjAxFVtWb5rMkIDFqg/MmnWNqCLrMEaldYcXwgetsB2Tkvicl8RXZFbiKPzpABdFR0qrvPOCXNYY9k2YZgdniIp8U/MNBv0gUyL/gM8HCSxeXogMqgK6BAehuANGx94uz0RFje1baego+nQXbcsQu1C5PbhyiKe1fvKacPQwHnD1p4SnhKlMr0NmX1Xn8h8UwwqnsB3mtMs6uvaXXyuEQFn7QeRsLX0kwrWpWzw6MqAfi+f2RsuB9Idv84ApTLgEp18pFysWkdEbH/tAAAACriIwzVVDHfpVaooiNxgawHF4xXnmu3q6B2gW26JSrMtUjdDRsbV/UeF3+fRxYbet02/FErkSxTZ0Lkan98lxIRLbQw+VtGaL/AB6q/ETMLdlBR8Qu4ZMojV8LX6Y5lWHBS5qeitCfGpODiszPnJtlPFiuhuYuuRxYbE4g/BiV4HIE+GZjm6U4lak30GFThPaXBgLHYmlqMapayADloKACNnNFqCZbIzIXkG3WXAU5BL5jANLpDR4JySK2NWmOTmwqHNyfRUbicYWfNkUjRQZLgwrlmU04T2n9sirqVlAG1uty5JAWs3zYL8PCMGkvCtP1CRAn0W7HxAAOh8qDq2+uMQ8sFEO+96a4vAlMOeZPyxKIdHlezZDpDKBQ8k2ZVNKIoaXmVLAqlcLWuOsEs9FcpmgsC1oOscMJDnGNoebclSqyF2tQAOq/vUHk9G7z6PQGjKFiV1I3Pk+08p7R8o/E8XfiFIucP4ogfWWEQ0YvD8+jeG8nQsIcrB95qRGWmhKq2b6AsJSwwRT6lPB5MApiovb+me5D6P8AbMC+B93/AI0GUKFFWmp78I6xzavrVlOtnkoKgBtGjX8X/wBoAAAAYHVjvgy4J9kdawsnkQu11ezhSosSNMb3+ziM0NahVNR9xIfK2InAPzxR2QcxZfuNuXp2WUNbqj8QiajYi4cASVLI+Nw+XtBpjS7aqvTrHFNLXtchM+0JfOQ6V6NffMChcJBIwGYRfBLYksD2qGfl5EwlOecEik77plfmPPUrsuoo4tPxKLxKuzviiohzh3pUiwNL2tPaBaYKUWkLVusVd1xIfpV6i1sS3LFXALmKHMANOF1fvdwwdDR5lwCVdWNH4CEIYz7rl+KPaXGyU28HRr9TQ5U7icQ4jD6u4XDY+zUUFhKpKo1e9wE01sEV5C6KLdpc8PwR66FuWqr06xguBaIDokA9LIo4A3vjrLDikbmVPviVRGpfNiDS4IHCEm600aDZxLNOPKX5lr4HK+YVqKyHhjMqY260LAtV61KH6H2j2McWAfLpHLXOpeWROJxxLoi9mwZEEn0g6fsipRLC84emPiYxzYy+tLwTIDiF35PRSiYmkqUBhqLqv4la3FnPh2lyKGvL9kUpsjy0e0B0m9/7jidHeZrjT9eoYG1hhSr0Ra9HeBxqbmR1f6lHbm2H7hgJzVOwihUu9PESv1/2gAAABY3ZuC30IKj2k9h2xjUTSU3je5UTm8Z40e5D520A8PMJcISuko2i+8iiG+r9QtTntqdC9WVDV+BOcAcUxe0uXE7oCX2Ddi2JVe8DUxJhZBxccrmS8hax7EDBkWEQwOooO6FSm5n6hYJEwA2OLByn/JeYz92QB42ILpawPTAJFvF1QGyQ+Hshn7HiXK2Qp+xjKPCqi6WDbvKx0WMc4yIYlVwE0ipSZJhhZQ9yAaE03nSZhcqSya/EUY7TBaVVcOscGYd0H7kn8qlQ6spMFNg8GWgyp0torXtFiB7fI0l3zsyoLaf3YEMHqULAIOlml8rhVAWCt2ZQ3LW1mR5oIdYypgbfE/v2jFgBE3JU8Tk9NE80ssssng/lPB/KK7+HWK7+HWBaPs/cVeCiAeQejDWHHHKn4+ZyIEpZGgE3f1HgaH1UE3YAvuRMsxb5xJZfGXUMdo2bxL8UjZmyPwxGIMNO+NH0Uylm7v04yoOuu6+fBLJMvUyvru/Eq7orFozrSF9FOlle5GqaV6Wp9n/aAAAAFPs0YWRGpCYdLZ9srvD94Vj1ms/xctXRVCJxXf2+oUmm/dYfugQVY6xPFqcXbuQiKbZLba43IcPcjZ1Nod/1aLIWpjfSA1zKzBej1ikgSUGObB6J48Y+VXBj4GU9QpHMByv11iOXaJQZMwr5Uu8dy1AT3MQmsEVvZYC1uvtygu07Dfuak5FgY+4FXOZecO79fiBllrauVhLuEQa3th9ZkBHipik2gCL0LYX4Y2qqgL9ITMFCI0c4ddMIR07N8kQ3mt1K4nLieO5NqHyXciklyg7COCfCDdxL46TI8iYGe7Lsa5n3gEjYtE6zDGN10IpqC1qaOLF4KPHeXljnnwMst0pAOtHN88VK7MTIm0AdjHya7P1Oe+jH1GhvYNvQ1YeK8ApDTGxyjfCEUBe7HPnD7x0oLWBdI7k0eg5IlgJ1C0Xr1jVJKjbOLdwrCwXKmbrXeCdDLhQW59j9VBNwgvXfc60faVKsbALXJtPIO08o7TyjtPOO0847TxztPHO0ti+Cu0XAalGjkM31qJJMzqLVc2EFYawfDxO6fAzArodUpz0WuDtLDTVunlzg5V7P9TxmrMbcqsHJj9xq0Dq1h58ol0F1n7CZ1bXRVt6L2ISs1TjOR+NehiIlpOeD4mwR7H1Adv1L6gw5sBV8mZNgvzGT8VNX/aAAAABBUN3Bj6BziFDG0YedRLSUQf4gnFgOHAgiUoXRuIkUK7GPdtGQpt7zsrCIMu2CFTrKZS24FUCMquRNDb4sMhhENe8zIK8iJiV1hmczCNS4+SL5KitiUAQKn0GJLyhmiGKZWUBkmTMRz1jVpBoEudawTRbbmU8KNBvE5Ox6+7aQzQlAEQuDLMXuoVKJemXo9QBdLUtr0fqJCgFuIadfSYerVtq1ie7MU0V0Gq+HaW7umidkODLvoUjza9LeLLeLM8WU8ZTxZTxYqL4sZpMxSxWG52D9szYNNv0CCspiF+ZaMrOdNyWHXcmv4YFU39yY7zCCzE5PhMou18JVcjN6L95l2Vt1P5mYlVyqvqu3zAt5NmwfOg6ETrI0bsZcQEumJffeXvRs1oPaBSnTo+NZkO8Ohk+e7OUyP+4AAAAFYzG0bisd4MWt7QHQ/EqIKuVF6GZpa944dvovklc3q1P2jBU2UIPm38Q2YWxbvmt365QqjqSjsE0XLlKaQouq+F8YO0WcR7EAaBBcU3KjlMv9wABCQjQBasSG1IUj0ieFG66QnBzWC1G3SWVuWDboWtf8wFFWJemP8wAQQUvDz9NOQA0UJq9XvMq6buyvIiNVt1bURA0pKoaUcT7mdbrdA7Js7QfQFGE/AeXAgeg/xKYticCDezcjhzjt1GynA7ssDLbknLpBwYF/pMlb/p/D9Smm5fR8ZcB3E67fkmjCyqvx5ygKLXcD22hVy33XxbFybs3dT9dDMFGen8Y/B7yxpDsU/RpBhExn8olbjMrZ/fOUyWzNtT9yqUxmx9usBQwYP0srdKCePf8A7gAAAAYmcCmxu/EeRFY3LF/Jcp5ga8YkEAR2VdwDS2B92WPuHwvOAuilPiJ4ampFvXHlHwoK3R1qDd+9RpvZ1DdM/mXyZqu1zVSZStJprAl4iNrJ+1LentALSxUqGg3ZprUooPHKIzLTVRYGWE4xKdwG4F1G6aRCm18YMpUKuTWjdhWaPvEIixobNXTFlR687GU7lXRXG4EQUjV7ibaMFirEIoaDdmjmojGaxZV22gEq8LpdOrXHlGmDWOIRFlDlRlBTGdOMdmM2lWh7mZU1iwo1i3pCk/1MBrTbXvFw2VpQaQ5QlYUps1KFQgdy7fwVDccOnc0feIlKjTE2OV371DUagvTAaxzFBdJzFfiOB+sIXRM6QzYxRg0rnC02kpjdhb1iE1WA4tPJCZiBEUayqfEagImXgDOvKKRplHGLsHrLIGb21DQL97WaAjxHq7w0zA9Uvuyw/MIjVTgMqq+E/pkuXd67xC5NBZhpl35i8UtCZf8AEBIkNppZM0cARSZ1lZ1NdqOOPb5ioeYaHBl67LRtsm8sA8Bht80OJwTRJhGApa/H+WOcLNNrsTkwbhCEQMsOY9gAOrCzMginRNfw6xC+WrAdjlAEONI+jhAVDYvHgwVRh69toPCIB51l1jcDrv8AmbpKfp84QFUPuftvC229aJXYKNb6df0hQxj6rz5YNa2w5quV7dCAlntF9HWZ0bzOo8UbwsONs/iI1YmXcdJXD5EN+cDIFYBxRLKy5Dfj+/f/ALgAAAAUDKK7GXLw0gosW+LHIuClEa0adzXJFGH02BxVnLTXMfbn074KdICMB66blfiJoARZbWrUWcKqFu9MEsl6kLdtJVIoRILikHQxUOCJVJC3zh402wQ6675hCiqop5Vp9zMPGzgpGoG3lFhLZOWazmH5Z54hwkGEzLnlKwywEDjJQ5FwRQEQX4Kfao4eZVHgXekrhkUJklRYKogiJYmesVYCq0+VafcsjMyYHHAj0ZZ83ALoxOppK6AKCx87oJeZ047gjGXBY0HlxMQBNE6kKK6YgGTqnoiOD5hnzKo8C709ACjRSs5RTGYwlipTC7FGZU1RCta0vSKnmJbKhUxF2BbbZWxoQ5DXMWyKmbie/tPo7u7WtZTKGNsmx095aQETx4gUjfGPJu0SZ4sII4DpKasaY948aB053nHPjKIw3ABSUL/GsXsgE2tqdIpPB0JWcnxAQ3FIyLvk97jVYIFypRKUZxS2ln/AI4veEzbWutEY0asaeT+4+N0NsYxiKFpTY196srNuYLDUR014IdGOVBwKHtF9EbBWeaw+5K2xuV/J9QTK1vHtEQF5G/zMM3WoPeCuDUEXVx9QIL5Bk6DQ9oKXTrPzKHIEhcRsOzLuVBjmG0Cw0L1PKZifE+HvBRjCeg+PxLbqTLiQNzX/AAijIOJRNDlk2robdWNDhtw8/LBo3NDJOhoSmwyq0aa4kXYXOF893vLaOXDcf5jv0rXd/CV1aB+SALDa4ceJbwZ4mz2+JqwOcfqDXV8Rk/wF6vacn/WAAAAAqyLGnvBNDDcg1VM2x8RboqLqP/GAAANaC2ZJfmgdZOLOI54E5Yf8gAAB60cA15voVAWAwvbhHA4Sno0XiZR8ExpyLJUWPIP2XL+zzv3luHx1moI6EGll+LjwThBRCRaZWCPRq69zI5ArLkilBLA5PlxS0ac9eMsdl6B+IChM85wG+T1H+IDtxe/m8dkw0rH9RemjgYH7gSjRkvNMWgEKQ5bneOhZTBMPGWZnq2iA3Lc2lSdWciWAGjNtuJ0l9E90dQy56/MdQfIfvEXb9n7lm1HSGnivFlf+oAAAAAAAALmVORBMw8Wc1OSH/KAAAf/Z'/>

                        </a>
                    </div>
                </div>
            </div>
            <div id="bodyarea">
                <h1>BigBrotherBot commands documentation for %(server)s</h1>
                <p>updated on %(dateUpdated)s</p>
                %(commandsTable)s
            </div>
            <p style="border: 10px; float: right;">
                <a href="http://validator.w3.org/check?uri=referer"><img
                src="http://www.w3.org/Icons/valid-xhtml10"
                alt="Valid XHTML 1.0 Transitional" height="31" width="88" style="border: 0;"/></a>
            </p>
            <script type="text/javascript">%(javascript)s</script>
        </body>
        </html>
        """ 
        
        return html % {
            'server': self._console._publicIp +':'+ str(self._console._port),
            'cssstyle': cssstyle,
            'javascript': javascript,
            'dateUpdated': time.asctime(),
            'commandsTable': self.getHtmlTable()
        } 
    
    
    def getHtmlTable(self):
        text = """
            <table id="b3commands">
                <thead>
                    <tr>
                        <th class="b3Plugin">plugin</th>
                        <th class="b3MinLevel">min level</th>
                        <th class="b3MaxLevel">max level</th>
                        <th class="b3Name">command</th>
                        <th class="b3Alias">alias</th>
                        <th class="b3Desc">description</th>
                    </tr>
                </thead>
                <tbody>
                %(commandsTablerow)s
                </tbody>
            </table>
        """
        
        def friendlyLevel(level):
            try:
                intlevel = int(level)
                if intlevel <= 0:
                    return '<span title="%s - Everyone">All</span>' % level
                elif intlevel == 1:
                    return '<span title="%s - Registered players">user</span>' % level
                elif intlevel < 20:
                    return '<span title="%s - Regular players">reg</span>' % level
                elif intlevel < 40:
                    return '<span title="%s - Moderators">mod</span>' % level
                elif intlevel < 60:
                    return '<span title="%s - Admins">admin</span>' % level
                elif intlevel < 80:
                    return '<span title="%s - Full admins">fulladmin</span>' % level
                elif intlevel < 100:
                    return '<span title="%s - Senior admins">senioradmin</span>' % level
                elif intlevel >= 100:
                    return '<span title="%s - Super admins">superadmin</span>' % level
                else:
                    return level
            except:
                return level
        
        htmlCommands = ""
        for cmd in self._getCommandsDict():
            html = """<tr class="b3command">
                <td class="b3Plugin">%(plugin)s</td>
                <td class="b3MinLevel">%(minlevel)s</td>
                <td class="b3MaxLevel">%(maxlevel)s</td>
                <td class="b3Name">%(name)s</td>
                <td class="b3Alias">%(alias)s</td>
                <td class="b3Desc">%(description)s</td>
                </tr>
                """
            cmd['minlevel'] = friendlyLevel(cmd['minlevel'])
            cmd['maxlevel'] = friendlyLevel(cmd['maxlevel'])
            htmlCommands += html % cmd
        return text % {'commandsTablerow': htmlCommands}
    
    def _getCommandsDict(self):
        if self._maxlevel is not None:
            self._console.debug('AUTODOC: get commands with level <= %s' % self._maxlevel)
        commands = {}
        for cmd in self._adminPlugin._commands.values():
            if cmd in commands or \
                cmd.level is None:
                continue
            if self._maxlevel is not None and cmd.level[0] > self._maxlevel:
                continue
            
            #self._console.debug('AUTODOC: making command doc for %s'%cmd.command)
            tmp = {}
            tmp['name'] = cmd.prefix + cmd.command
            tmp['alias'] = ""
            if cmd.alias is not None and cmd.alias != '' :
                tmp['alias'] = cmd.prefix + cmd.alias
            tmp['plugin'] = re.sub('Plugin$', '', cmd.plugin.__class__.__name__) 
            tmp['description'] = escape(cmd.help)
            tmp['minlevel'] = str(cmd.level[0])
            tmp['maxlevel'] = str(cmd.level[1])
            commands[cmd] = tmp
            
        def commands_compare(x, y):
            if x['plugin'] < y['plugin']: return -1
            elif x['plugin'] > y['plugin']: return 1

            elif int(x['minlevel']) < int(y['minlevel']): return -1
            elif int(x['minlevel']) > int(y['minlevel']): return 1

            elif x['name'] < y['name']: return -1
            elif x['name'] > y['name']: return 1

            else:
                return 0

        listCommands = commands.values()
        listCommands.sort(commands_compare)
        return listCommands
    
    def _write(self, text):
        
        if text.strip() == '':
            self._console.warning('AUTODOC: nothing to write')
            
        dsn = splitDSN(self._outputUrl)
        
        if dsn['protocol'] == 'ftp':
            self._console.debug('Uploading to FTP server %s' % dsn['host'])
            ftp=FTP(dsn['host'],dsn['user'],passwd=dsn['password'])
            ftp.cwd(os.path.dirname(dsn['path']))
            ftpfile = StringIO.StringIO()
            ftpfile.write(text)
            ftpfile.seek(0)
            ftp.storbinary('STOR '+os.path.basename(dsn['path']), ftpfile)
        elif dsn['protocol'] == 'file':
            self._console.debug('Writing to %s', dsn['path'])
            f = file(dsn['path'], 'w')
            f.write(text)
            f.close()
        else:
            self._console.error('AUTODOC: protocol [%s] is not supported' % dsn['protocol'])
            
########NEW FILE########
__FILENAME__ = functionprofiler
#!/usr/bin/env python
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 GrosBedo
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# TODO:
# - implement cProfile or yappi, or use threading.setProfile and sys.setProfile, or implement one's own multi-threaded profiler:
# http://code.google.com/p/yappi/
# http://code.activestate.com/recipes/465831-profiling-threads/
# http://effbot.org/librarybook/sys.htm
# 
#
# CHANGELOG:
# 2010-09-22 - v0.4.3 - GrosBedo
#   * added error handling if profile and pstats libraries can't be found
# 2010-09-17 - v0.4.2 - GrosBedo
#   * added an automatic calibration prior to profiling
# 2010-09-17 - v0.4.1 - GrosBedo
#   * fixed import bug
# 2010-09-16 - v0.4 - GrosBedo
#    * fallback to profile instead of cProfile : even if this pure python implementation is much slower, it at least work with threads (cProfile, alias hotshot, is not compatible with multi-threaded applications at the moment)
# 2010-09-09 - v0.3 - GrosBedo
#    * workaround for a bug with cProfile
# 2010-09-08 - v0.2 - GrosBedo
#    * added the parsestats, browsegui and browsenogui functions
#    * centralized runprofile here
# 2010-09-06 - v0.1 - GrosBedo
#    * Initial version.

__author__  = 'GrosBedo'
__version__ = '0.4.3'


noprofiler = False
try:
	import profile, pstats
except:
	noprofiler = True
import sys, os
pathname = os.path.dirname(sys.argv[0])
sys.path.append(os.path.join(pathname, 'b3','lib'))

from kthread import *
from profilebrowser import *
try:
	from runsnakerun import runsnake # runsnakerun needs wxPython lib, if it's not available then we pass
except:
	pass


def runprofile(mainfunction, output, timeout = 60):
	if noprofiler == True:
		print('ERROR: profiler and/or pstats library missing ! Please install it (probably package named python-profile) before running a profiling !')
		return False
	def profileb3():
	    profile.run(mainfunction, output)
	# This is the main function for profiling
	print('=> SAVING MODE\n\n')
	print('Calibrating the profiler...')
	cval = calibrateprofile()
	#print('Found value : %s' % cval)
	print('Initializing the profiler...')
	b3main = KThread(target=profileb3) # we open b3 main function with the profiler, in a special killable thread (see below why)
	print('Will now run the profiling and terminate it in %s seconds. Results will be saved in %s' % (str(timeout), str(output)))
	print('\nCountdown:')
	for i in range(0,5):
		print(str(5-i))
		time.sleep(1)
	print('0\nStarting to profile...')
	b3main.start() # starting the thread
	time.sleep(float(timeout)) # after this amount of seconds, the b3 main function gets killed and the profiler will end its job
	print('\n\nFinishing the profile and saving to the file %s' % str(output))
	b3main.kill() # we must end the main function in order for the profiler to output its results (if we didn't launch a thread and just closed the process, it would have done no result)
	print('=> Profile done ! Exiting...')
	return True

def calibrateprofile():
	pr = profile.Profile()
	calib = []
	crepeat = 10
	for i in range(crepeat):
		calib.append(pr.calibrate(10000))
	final = sum(calib) / crepeat
	profile.Profile.bias = final # Apply computed bias to all Profile instances created hereafter
	return final

def subprocessprofileb3(profiler, mainfunction, output):
	#b3thread = KThread(target=profileb3_timer)
	#b3thread.start()
	profiler.run(mainfunction)

def runprofilesubprocess(mainfunction, output, timeout = 60):
	# Testing function for profiling, using a subprocess (does not really work because of how cProfile works)
	try:
		print('PROFILER SAVING MODE\n--------------------\n')
		print('Preparing the profiler...')
		#b3main = profileb3_thread()
		#b3thread = KThread(target=profileb3_timer)
		#b3thread.start()
		profiler = cProfile.Profile()
		b3main = multiprocessing.Process(target=subprocessprofileb3, args=(profiler, mainfunction,output))
		print('Will now run the profiling and terminate it in %s seconds. Results will be saved in %s' % (str(timeout), str(output)))
		print('\nCountdown:')
		for i in range(0,6):
			print(str(5-i))
			time.sleep(1)
		print('Starting to profile...')
		#profileb3("""b3.tools.profile.subb3()""", output)
		b3main.start() # b3main.start() # starting the thread
		time.sleep(float(timeout)) # after this amount of seconds, the b3 main function gets killed and the profiler will end its job
		print('\n\nFinishing the profile and saving to the file %s' % str(output))
		#b3main.terminate() # b3main.kill() # we must end the main function in order for the profiler to output its results (if we didn't launch a thread and just closed the process, it would have done no result)
		print('=> Profile done ! Exiting...')
		profiler2 = posh.share(profiler)
		profiler2.dump_stats(output)
		#signal.signal(signal.SIGABRT, b3main)
		raise SystemExit(222)
	except SystemExit, e:
		print('SystemExit!')
		sys.exit(223)

def parseprofile(profilelog, out):
	file = open(out, 'w') # opening the output file
	print('Opening the profile in %s...' % profilelog)
	p = pstats.Stats(profilelog, stream=file) # parsing the profile with pstats, and output everything to the file

	print('Generating the stats, please wait...')
	file.write("=== All stats:\n")
	p.strip_dirs().sort_stats(-1).print_stats()
	file.write("=== Cumulative time:\n")
	p.sort_stats('cumulative').print_stats(100)
	file.write("=== Time:\n")
	p.sort_stats('time').print_stats(100)
	file.write("=== Time + cumulative time:\n")
	p.sort_stats('time', 'cum').print_stats(.5, 'init')
	file.write("=== Callees:\n")
	p.print_callees()
	file.write("=== Callers:\n")
	p.print_callers()
	#p.print_callers(.5, 'init')
	#p.add('fooprof')
	file.close()
	print('Stats generated and saved to %s.' % out)
	print('Everything is done. Exiting')

def browseprofile(profilelog):
	print('Starting the pstats profile browser...\n')
	try:
		browser = ProfileBrowser(profilelog)
		print >> browser.stream, "Welcome to the profile statistics browser. Type help to get started."
		browser.cmdloop()
		print >> browser.stream, "Goodbye."
	except KeyboardInterrupt:
		pass

def browseprofilegui(profilelog):
	app = runsnake.RunSnakeRunApp(0)
	app.OnInit(profilelog)
	app.MainLoop()
	
########NEW FILE########
__FILENAME__ = logdiagnostic
#!/usr/bin/env python
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 GrosBedo
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# TODO:
# - Use numpy
# to optimize the runtime, we could go for numpy, but this would add a dependancy.
# Here is a quick comparison of runtimes :
# length | numpy | pure python
#   1            11.7      0.698
#   10          11.7      2.94
#   100        12.1      24.4
#   1000      15         224
#   10000    41         2170
#   100000  301       22200
# found at http://www.gossamer-threads.com/lists/python/dev/704781
#
# Cons are that I'm not sure that the maths functions would be more optimized (particularly about memory usage), one should have to try.
#
# - Fix the memory leak of the save_data() function : cPickle seems to put a huge burden on memory usage when dumping to a file. Maybe one should try an alternative, such as marshal ? Or MessagePack ?
# http://kbyanc.blogspot.com/2007/07/python-serializer-benchmarks.html
#
# CHANGELOG:
# 2010-09-17 - 0.9.5 - GrosBedo
#    * fixed import bug
# 2010-09-16 - 0.9.4 - GrosBedo
#    * fixed: a few bugs in load_data_yaml()
# 2010-09-15 - 0.9.3 - GrosBedo
#    * change: show_results_yaml() -> save_data_yaml()
#    * fixed: save_data_yaml() now saves in a properly formatted yaml standard when saving multiple objects at once
#    * added: load_data_yaml(), can load several yaml objects from several files at once
#    * change: paths to b3/lib are now generalized via sys module
# 2010-09-14 - 0.9.2 - GrosBedo
#    * added: save_data_csv and load_data_csv which are much more efficient and quick
#    * change: replaced pickler by cPickler which should be 1000 times faster (finally cPickler is a little faster than new save_data_csv and load_data_csv functions)
# 2010-09-13 - 0.9.1 - GrosBedo
#    * CRITICAL fix: yet another memory hog in the variance() function from mstats (statlib/stats.py), replaced by a custom variance() function in corestats.py
#    * fixed: replaced many unoptimized functions from mstats by corestats
# 2010-09-10 - 0.9 - GrosBedo
#    * CRITICAL fix: memory hog fixed (it came from corestats.Stats)
#    * added: automatically use numpy arrays if available
# 2010-09-09 - 0.8 - GrosBedo
#    * fixed: load_stats and save_stats duplicate dummy functions !
#    * change: load_stats -> load_data and save_stats -> save_data
#    * added: load_data can now load several files at once
#    * added: load_data can directly merge the data, this being very cost and ressource effective (particularly suited for datas matrixes, less for stats)
# 2010-09-09 - 0.7 - GrosBedo
#    * added: items frequencies and items percentiles
#    * added: perfect value and perfect score
# 2010-09-09 - 0.6 - GrosBedo
#    * change: show_results can now be used to save the stats to a file a digest, human readable format
#    * added: show_results_yaml to show a better human readable format (YAML)
# 2010-09-08 - 0.5 - GrosBedo
#    * renamed DiagPlugin -> LogDiagnostic
#    * integrated in b3 debug mode
# 2010-09-07 - 0.4 - GrosBedo
#    * added a facility to save and load stats and matrix
# 2010-09-07 - 0.3 - GrosBedo
#    * added weighted_mean and merge_matrix to merge the stats of several logs at once
# 2010-09-06 - 0.2 - GrosBedo
#     Initial release.
#
 
__version__ = '0.9.5'
__author__ = 'GrosBedo'
 
import os.path, time, re, sys
pathname = os.path.dirname(sys.argv[0])
sys.path.append(os.path.join(pathname, 'b3','lib'))

# Maths functions
import math
from statlib import stats as mstats
import corestats # we need the corestats lib because the mstats implementation of percentile score is broken
import itertools

# Output and saving functions
import pprint # to nicely print to the console
import cPickle as pickle # raw matrix and raw stats exporter - cPickle is a C implementation that is more efficient than pickle
import yaml # human readable yaml format
try:
    from yaml import CLoader as Loader
    from yaml import CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

import csv

# NOT YET FUNCTIONAL
try: # if we can, we use the numpy arrays instead of Python, they are wayyyyy much more faster
    import numpy
except:
    pass

#--------------------------------------------------------------------------------------------------
class LogDiagnostic():

    _lineFormat = r'^\s*(?P<minutes>[0-9]+):(?P<seconds>[0-9]+)\s*.*'
    
    maxlines = 0
    significantzero = True
    debug = False
    faster = True # space more some outputs like the percentage of completion in lines_per_second, this speeds up the process a lot
    morefaster = False # disable any feedback output, this is the fastest, but you won't see the process progression at all

    def lines_per_second(self, *args):
        self.supermatrix = []
        for game_log in args:
            matrix = [] # we will store the count of each lines in this matrix
            previoustime = None # this var will permit us to know what to do and fill the gaps in the matrix
            f = re.compile(self._lineFormat, re.IGNORECASE)
            previouscursor = 0 # keeps track of the current positionning in the file (useless technically, only used for user's feedback)
            try:
                # Opening the game file
                self.file = open(game_log, 'r')
                self.file.seek(0, os.SEEK_SET)

                i = 0
                for line in self.file:
                    i += 1
                    m = re.match(f, line)
                    if m:
                        gametime = int(m.group('seconds')) + (int(m.group('minutes')) * 60) # game time at the time this line was outputted
                        if self.debug: print('%i- gametime %s %s:%s' % (i, str(gametime), str(m.group('minutes')), str(m.group('seconds'))))
                        if previoustime is None:
                            matrix.append(1)
                        elif gametime == previoustime:
                            matrix[-1] += 1 # adding 1 count to the last item in the array
                        else:
                            if gametime > previoustime + 1: # if the gametime is more than one second ahead, then we see if we either add the missing zero values (for missing lines), or if we just skip them and only count existing lines
                                if self.significantzero: # if we think that zero values _are_ significant (time for which the server have outputted no line), then we fill in the array the missing values
                                    matrix.extend( [0 for j in range(previoustime, gametime - 1)] )
                                matrix.append(1) # we then append a count for the current line
                            else: # else, if the gametime is just one second ahead OR if the gametime is lower than the previoustime (at the end of a match, the server gametime may come back to 0), we just append a new value of 1
                                matrix.append(1)
                        #elif gametime < self.previoustime: # at the end of a match, the game server time may come back to 0, we just continue as our math algo don't care as long as these were generated after
                        #    matrix.append(1)

                        previoustime = gametime
                    if i >= self.maxlines and self.maxlines > 0: # to avoid infinite loops, you can specify a max number of lines to process
                        print('Reached maxlines, breaking...')
                        break
                    # Feedback the current status of the process
                    filestats = os.fstat(self.file.fileno())
                    currpos = self.file.tell() # we store the current cursor position and filesize to avoid accessing several times the same file at once
                    filesize = filestats.st_size
                    if previouscursor != currpos:
                        if self.faster:
                            if (i % 1000) == 0: print('Processing %s%% (byte %s of %s)...' % (str(currpos*100/filesize), str(currpos), str(filesize)))
                        elif not self.morefaster:
                            print('Processing %s%% (byte %s of %s)...' % (str(currpos*100/filesize), str(currpos), str(filesize)))
                        previouscursor = currpos
                    # Sleep cycle to avoid freezing the system
                    time.sleep(0.0001)

                self.file.close()
                if self.debug: pprint.pprint(matrix)
                self.supermatrix.append( (game_log, matrix) )
            except Exception, e:
                print('Exception when reading the logs per second: '+str(e))

        return self.supermatrix
        
    def stats_per_second(self, *args):
        superstats = []
        for game_log, matrix in args:
            cstats = corestats.Stats()
            stats = {}
            mode = cstats.mode(matrix)
            stats['mode'] = mode[0][0]
            stats['modenext'] = mode[1][0]
            stats['mean'] = cstats.mean(matrix)
            stats['median'] = cstats.median(matrix)
            #stats['harmonicmean'] = mstats.harmonicmean(matrix)
            stats['variance'] = cstats.variance(matrix)
            stats['stddeviation'] = stats['variance'] ** 0.5
            stats['3sigma'] = 3*stats['stddeviation']
            stats['cumfreq'] = mstats.cumfreq(matrix)
            stats['itemfreq'] = mstats.itemfreq(matrix) # frequency of each item (each item being the count of the occurrencies for each number of lines per second)
            stats['min'] = min(matrix)
            stats['max'] = max(matrix)
            stats['samplespace'] = stats['max'] - stats['min']
            stats['count'] = len(matrix)
            stats['kurtosis'] = mstats.kurtosis(matrix)
            stats['perfectvalue'] = int(math.ceil(stats['3sigma'] + stats['mean']))
            stats['perfectscore'] = cstats.percentileforvalue(matrix, math.ceil(stats['3sigma'] + stats['mean']))
            scorepercentiles = [10, 30, 50, 70, 80, 85, 90, 95, 99, 99.9, 99.99]
            stats['itemscore'] = [(percentile, cstats.valueforpercentile(matrix, percentile)) for percentile in scorepercentiles]
            stats['skew'] = mstats.skew(matrix) # if positive, there are more smaller than higher values from the mean. If negative, there are more higher than smaller values from the mean.
            if stats['skew'] > 0:
                stats['skewmeaning'] = 'There exist more smaller values from the mean than higher'
            else:
                stats['skewmeaning'] = 'There exist more higher values from the mean than smaller'
            superstats.append( (game_log, stats) )
        return superstats

    def show_results(self, filename=None, *args):
        restorestdout = sys.stdout
        if filename:
            self.stream = open(filename, 'w')
            sys.stdout = self.stream
        else:
            self.stream = sys.stdout
        try:
            for game_log, stats in args:
                print >> self.stream, '\n-------------------------'
                print >> self.stream, '\nStats per second of the log file %s:\n' % game_log
                print >> self.stream, 'Zero is significant (count missing lines): %s' % str(self.significantzero)
                pprint.pprint(stats)
        except:
            pprint.pprint(args)
        sys.stdout = restorestdout

    def save_data_yaml(self, filename=None, *args):
        ''' Save or show the results in YAML '''
        if filename:
            self.stream = open(filename, 'w')
        else:
            self.stream = sys.stdout
        try:
            for game_log, stats in args:
                print >> self.stream, '### Stats per second of the log file %s:\n' % game_log
                print >> self.stream, '# Zero is significant (count missing lines): %s' % str(self.significantzero)
                print >> self.stream, yaml.dump(stats, default_flow_style=False, Dumper=Dumper)
                print >> self.stream, '---' # YAML objects separator
        except:
            print >> self.stream, yaml.dump_all(args, default_flow_style=False, Dumper=Dumper)

    def load_data_yaml(self, *args):
        ''' Load one or several YAML stats files and merge them with current results '''
        superstats = []
        for filename in args:
            self.stream = open(filename, 'r')
            superstats.extend([data for data in yaml.load_all(self.stream, Loader=Loader) if data is not None])
        return superstats

    def save_data_csv(self, filename, *args):
        ''' much more ressource efficient function but can only save matrixes (better than pickler but not cPickler) '''
        try:
            file = open(filename, 'w')
            csvWriter = csv.writer(file, delimiter='\n', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            csvWriter.writerow([object for object in args])
            file.close
            return True
        except Exception, e:
            print('Exception when trying to save the stats: %s' % str(e))
            return False        

    def load_data_csv(self, *args):
        ''' load the stats in a simple format and preallocate memory, faster than pickler but slower than cPickler '''
        def count(file):
            while 1:
                block = file.read(65536)
                if not block:
                     break
                yield block.count("\n")

        superstats = []
        for filename in args:
            try:
                # count data rows, to preallocate array
                file = open(filename, 'rb')
                linecount = sum(count(file))
                #print('file has %s rows' % str(linecount))
                
                # pre-allocate array and load data into array
                #m = np.zeros(linecount, dtype=[('a', np.uint32), ('b', np.uint32)])
                lastindex = len(superstats)
                superstats.extend([0] * linecount)
                file.seek(0)
                i = 0
                for row in file:
                    if row.strip():
                        superstats[lastindex + i] = int(row.strip())
                        i += 1
                file.close
            except Exception, e:
                print('Exception when trying to load the stats: %s' % str(e))
                return False
        return superstats

    def save_data(self, filename, *args):
        ''' an all-round saving to file function, it can dump any python object and restore it later, but it's not very ressource efficient '''
        try:
            file = open(filename, 'w')
            for object in args:
                pickle.dump(object, file)
            file.close
            return True
        except Exception, e:
            print('Exception when trying to save the stats: %s' % str(e))
            return False

    def load_data(self, merge=False, *args):
        ''' merge will directly merge the stats asap if enabled, this saves us a lot of memory '''
        #try:
            #superstats = numpy.array([])
        #except:
        superstats = []
        for filename in args:
            try:
                file = open(filename, 'r')
                if merge:
                    for object in pickle.load(file):
                        if type(superstats) is numpy.ndarray:
                            superstats = numpy.hstack(superstats, object[1])
                        else:
                            superstats.extend(object[1])
                else:
                    superstats.append(pickle.load(file))
                file.close
            except Exception, e:
                print('Exception when trying to load the stats: %s' % str(e))
                return False
        #print(type(superstats))
        return superstats
    
    def merge_matrix(self, *args):
        # this way to merge several logs is the most precise : it will take all the values and do the stats calculation directly against this huge amount of data
        # the drawback of this method is that it is very ressources consuming, so you may prefer the weighted_mean_merge approach for very huge logs
        merged_matrix = self.flatten([somelist[1] for somelist in args])
        return ('merged gamelogs', merged_matrix)
    
    def weighted_mean_merge(self, *args):
        # The weighted mean sum the stats and ponderate (multiply then divide) them with their number of lines that were counted in the calculation
        # this produces a final weighted stat that should provide a good merge between all the stats based on their weight (number of lines)
        newstat = {}
        superstats = {}
        args = [elmt for elmt in args if elmt is not None] # trimming null objects
        # first, we multiply each stats values to the count of lines, then we do the sum of these stats
        for stats in args:
            count = stats['count']
            try:
                del stats['skewmeaning'] # avoid some complication later...
                del stats['cumfreq'] # same...
                del stats['itemfreq'] # same...
                del stats['itemscore'] # same...
            except KeyError, e:
                print('Notice: one of the loaded stat file seems to have been generated by an older version of the Diagnostic tool ! You may miss some important new parameters !')
                pass
            for key, value in stats.iteritems():
                if key is not 'count' and key is not 'skewmeaning' and key is not 'cumfreq':
                    newstat[key] = value * count # multiply by the count of lines
                    try: # doing the sum of all the stats (one stat at a time)
                        superstats[key] += newstat[key]
                    except Exception, e:
                        superstats[key] = newstat[key]
        divisor = sum([stat['count'] for stat in args]) # calculating the common divisor, being the sum of all the counts of lines of all the stats
        weighted_stats = dict( (map(lambda (key, value): (key,float(value) / divisor), superstats.iteritems())) ) # dividing each of the superstats by the common divisor, this gives us the final weighted_stats
        # adding a few useful fields
        weighted_stats['count'] = divisor
        weighted_stats['perfectvalue'] = int(math.ceil(weighted_stats['3sigma'] + weighted_stats['mean']))
        weighted_stats['perfectscore'] = 'NA - Cannot know without the raw datas matrix !'
        if weighted_stats['skew'] > 0:
            weighted_stats['skewmeaning'] = 'There exist more smaller values from the mean than higher'
        else:
            weighted_stats['skewmeaning'] = 'There exist more higher values from the mean than smaller'
        # return weighted stats (and print it if debug mode)
        if self.debug: pprint.pprint(weighted_stats)
        return [('weighted-mean merged log', weighted_stats)]

    def flatten(self, *args):
        # flatten a list of sublists into one level of list
        return [item for sublist in args[0] for item in sublist]
        #for elem in lst:
        #    if type(elem) in (tuple, list):
        #        for i in self.flatten(elem):
        #            yield i
        #    else:
        #        yield elem

    def flatten2(self, sequence):
        # flatten any level of nested lists or dict to one level of list
        def rflat(seq2):
            seq = []
            for entry in seq2:
                if '__contains__' in dir(entry) and \
                             type(entry) != str and \
                             type(entry)!=dict:
                    seq.extend([i for i in entry])
                else:
                    seq.append(entry)
            return seq

        def seqin(sequence):
            for i in sequence:
                if '__contains__' in dir(i) and \
                             type(i) != str and \
                             type(i) != dict:
                    return True
            return False

        seq = sequence[:]
        while seqin(seq):
            seq = rflat(seq)
        return seq
    
    
if __name__ == '__main__':
    # Instanciating the class
    p = LogDiagnostic()
    # Configuring the general parameters
    p.significantzero = False # fill in the missing lines and count them as zero (ie: take into account the times when no lines were outputted by the game server)
    p.debug = False # show some more debug stuffs
    p.maxlines = 0 # limit the logs processing to a maximum of lines. Set to 0 for unlimited.
    
    # Parsing the logs
    supermatrix = p.lines_per_second(r'/some/dir/games_mp.log', r'/some/dir/games_mp2.log')
    # Generating the stats
    superstats = p.stats_per_second(*supermatrix)
    # Merging the stats of all logs into one, weighted-mean method (approximative but less ressource consuming as it uses only the stats, so there are much less informations to process)
    weighted_merged_stats = p.weighted_mean_merge( *superstats )
    # Merging the stats of all logs into one, matrix merge method (exact but more ressource consuming as it uses the full original and unaltered matrixes)
    merged_matrix = p.merge_matrix( *supermatrix )    
    merged_stats = p.stats_per_second( merged_matrix )
    
    # Showing the results
    # show_results(filename, *stats) # if you use None for filename, you get sys.stdout (console output)
    p.show_results(None, *superstats)
    p.show_results(None, *weighted_merged_stats)
    p.show_results(None, *merged_stats)
    
    # Testing some quick save and load, you can try with matrix too instead of stats
    p.save_data(r'/some/dir/somestats.txt', *superstats)
    somestats = p.load_data(False, r'/some/dir/somestats.txt') #load_data(merge, files) # you can specify if you want to merge the stats or matrix right now to save a lot of cpu
    p.show_results(None, *somestats)

    # some sample stats if you want to try
    testsuperstats = [('/some/dir/games_mp.log',
  {'3sigma': 6.945390758841171,
   'count': 11,
   'cumfreq': ([20171,
                25702,
                25808,
                25850,
                25862,
                25879,
                25891,
                25898,
                25908,
                25909],
               -1.86000005,
               5.7200001,
               0),
   'kurtosis': 114.34922587149542,
   'max': 53,
   'mean': 2.651009301787024,
   'median': 2.0230774326176335,
   'min': 1,
   'mode': 2,
   'modenext': 1,
   'samplespace': 52,
   'skew': 7.7869815045235207,
   'skewmeaning': 'There exist more smaller values from the mean than higher',
   'stddeviation': 2.315130252947057,
   'variance': 5.3598280881107039}),
 ('/some/dir/games_mp2.log',
  {'3sigma': 6.945390758841171,
   'count': 11,
   'cumfreq': ([20171,
                25702,
                25808,
                25850,
                25862,
                25879,
                25891,
                25898,
                25908,
                25909],
               -1.86000005,
               5.7200001,
               0),
   'kurtosis': 114.34922587149542,
   'max': 53,
   'mean': 2.651009301787024,
   'median': 2.0230774326176335,
   'min': 6,
   'mode': 2,
   'modenext': 1,
   'samplespace': 52,
   'skew': 7.7869815045235207,
   'skewmeaning': 'There exist more smaller values from the mean than higher',
   'stddeviation': 2.315130252947057,
   'variance': 5.3598280881107039})]
    
########NEW FILE########
__FILENAME__ = memoryprofiler
#!/usr/bin/env python
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 GrosBedo
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
# 2010-09-17 - v0.1.1 - GrosBedo
#   * fixed import bug
# 2010-09-11 - v0.1 - GrosBedo
#    * Initial version.

__author__  = 'GrosBedo'
__version__ = '0.1.1'

import os, sys
pathname = os.path.dirname(sys.argv[0])
sys.path.append(os.path.join(pathname, 'b3','lib')) # we add the b3/lib path for the import to work for some complex libraries (like guppy)

import threading
import time

try:
    from guppy import hpy
except:
    pass

#from sizer import code
#from sizer.sizer import scanner
#objs = scanner.Objects()
#code.interact(local = {'objs': objs})


def memoryprofile(output):
    hpy().heap().stat.dump(filename)
    time.sleep(0.1)

def runmemoryprofile(output):
    memorythread = threading.Thread(target=memoryprofile, args=(output,))
    memorythread.start()

def memoryinteractive():
    hpy().monitor()

def memorygui(input):
    hpy().pb(input)
########NEW FILE########
__FILENAME__ = update
# -*- encoding: utf-8 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas "Courgette" LVEIL <courgette@bigbrotherbot.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
from exceptions import ValueError, IOError, Exception, KeyError
import json
import re
import string
import sys
import urllib2
from distutils import version
from types import StringType


## url from where we can get the latest B3 version number
URL_B3_LATEST_VERSION = 'http://master.bigbrotherbot.net/version.json'

# supported update channels
UPDATE_CHANNEL_STABLE = 'stable'
UPDATE_CHANNEL_BETA = 'beta'
UPDATE_CHANNEL_DEV = 'dev'



class B3version(version.StrictVersion):
        """
        Version numbering for BigBrotherBot.
        Compared to version.StrictVersion this class allows version numbers such as :
            1.0dev
            1.0dev2
            1.0d3
            1.0a
            1.0a
            1.0a34
            1.0b
            1.0b1
            1.0b3
            1.9.0dev7.daily21-20121004
        And make sure that any 'dev' prerelease is inferior to any 'alpha' prerelease
        """

        version_re = re.compile(r'''^
(?P<major>\d+)\.(?P<minor>\d+)   # 1.2
(?:\. (?P<patch>\d+))?           # 1.2.45
(?P<prerelease>                  # 1.2.45b2
  (?P<tag>a|b|dev)
  (?P<tag_num>\d+)?
)?
(?P<daily>                       # 1.2.45b2.daily4-20120901
    \.daily(?P<build_num>\d+?)
    (?:-20\d\d\d\d\d\d)?
)?
$''', re.VERBOSE)
        prerelease_order = {'dev': 0, 'a': 1, 'b': 2}


        def parse (self, vstring):
            match = self.version_re.match(vstring)
            if not match:
                raise ValueError, "invalid version number '%s'" % vstring

            major = match.group('major')
            minor = match.group('minor')

            patch = match.group('patch')
            if patch:
                self.version = tuple(map(string.atoi, [major, minor, patch]))
            else:
                self.version = tuple(map(string.atoi, [major, minor]) + [0])

            prerelease = match.group('tag')
            prerelease_num = match.group('tag_num')
            if prerelease:
                self.prerelease = (prerelease, string.atoi(prerelease_num if prerelease_num else '0'))
            else:
                self.prerelease = None

            daily_num = match.group('build_num')
            if daily_num:
                self.build_num = string.atoi(daily_num if daily_num else '0')
            else:
                self.build_num = None



        def __cmp__ (self, other):
            if isinstance(other, StringType):
                other = B3version(other)

            compare = cmp(self.version, other.version)
            if compare != 0:
                return compare

            # we have to compare prerelease
            compare = self.__cmp_prerelease(other)
            if compare != 0:
                return compare

            # we have to compare build num
            return self.__cmp_build(other)


        def __cmp_prerelease(self, other):
            # case 1: neither has prerelease; they're equal
            # case 2: self has prerelease, other doesn't; other is greater
            # case 3: self doesn't have prerelease, other does: self is greater
            # case 4: both have prerelease: must compare them!
            if not self.prerelease and not other.prerelease:
                return 0
            elif self.prerelease and not other.prerelease:
                return -1
            elif not self.prerelease and other.prerelease:
                return 1
            elif self.prerelease and other.prerelease:
                return cmp((self.prerelease_order[self.prerelease[0]], self.prerelease[1]),
                    (self.prerelease_order[other.prerelease[0]], other.prerelease[1]))

        def __cmp_build(self, other):
            # case 1: neither has build_num; they're equal
            # case 2: self has build_num, other doesn't; other is greater
            # case 3: self doesn't have build_num, other does: self is greater
            # case 4: both have build_num: must compare them!
            if not self.build_num and not other.build_num:
                return 0
            elif self.build_num and not other.build_num:
                return -1
            elif not self.build_num and other.build_num:
                return 1
            elif self.build_num and other.build_num:
                return cmp(self.build_num, other.build_num)


def getDefaultChannel(currentVersion):
    if currentVersion is None:
        return UPDATE_CHANNEL_STABLE
    m = re.match(r'^\d+\.\d+(\.\d+)?(?i)(?P<prerelease>[ab]|dev)\d*$', currentVersion)
    if not m:
        return UPDATE_CHANNEL_STABLE
    elif m.group('prerelease').lower() in ('dev', 'a'):
        return UPDATE_CHANNEL_DEV
    elif m.group('prerelease').lower() == 'b':
        return UPDATE_CHANNEL_BETA


def checkUpdate(currentVersion, channel=None, singleLine=True, showErrormsg=False, timeout=4):
    """
    check if an update of B3 is available

    """

    if channel is None:
        channel = getDefaultChannel(currentVersion)

    if not singleLine:
        sys.stdout.write("checking for updates... \n")

    message = None
    errorMessage = None
    version_info = None
    try:
        json_data = urllib2.urlopen(URL_B3_LATEST_VERSION, timeout=timeout).read()
        version_info = json.loads(json_data)
    except IOError, e:
        if hasattr(e, 'reason'):
            errorMessage = "%s" % e.reason
        elif hasattr(e, 'code'):
            errorMessage = "error code: %s" % e.code
        else:
            errorMessage = "%s" % e
    except Exception, e:
        errorMessage = repr(e)
    else:
        latestVersion = None
        latestUrl = None
        try:
            channels = version_info['B3']['channels']
        except KeyError, err:
            errorMessage = repr(err) + ". %s" % version_info
        else:
            if channel not in channels:
                errorMessage = "unknown channel '%s'. Expecting one of '%s'"  % (channel, ", '".join(channels.keys()))
            else:
                try:
                    latestVersion = channels[channel]['latest-version']
                except KeyError:
                    errorMessage = repr(err) + ". %s" % version_info

        if not errorMessage:
            try:
                latestUrl = version_info['B3']['channels'][channel]['url']
            except KeyError:
                latestUrl = "www.bigbrotherbot.net"

            not singleLine and sys.stdout.write("latest B3 %s version is %s\n" % (channel, latestVersion))
            _lver = B3version(latestVersion)
            _cver = B3version(currentVersion)
            if _cver < _lver:
                if singleLine:
                    message = "*** NOTICE: B3 %s is available. See %s ! ***" % (latestVersion, latestUrl)
                else:
                    message = """
                 _\|/_
                 (o o)    {version:^21}
         +----oOO---OOo-----------------------+
         |                                    |
         |                                    |
         | A newer version of B3 is available |
         |                                    |
         | {url:^34} |
         |                                    |
         +------------------------------------+

        """.format(version=latestVersion, url=latestUrl)

    if errorMessage and showErrormsg:
        return "Could not check updates. %s" % errorMessage
    elif message:
        return message
    else:
        return None



########NEW FILE########
__FILENAME__ = b3_debug
#!/usr/bin/env python
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2010 GrosBedo
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# CHANGELOG:
# 2010-10-02 - v0.7 - Courgette
#   * separated b3_run.py from b3_debug.py. To use the debug stuff, start B3 
#     using python b3_debug.py instead of python b3_run.py
# 2010-09-17 - v0.6.1 - GrosBedo
#   * fixed import bug
# 2010-09-16 - v0.6 - GrosBedo
#   * fixed function profiler, it now works with threads
# 2010-09-16 - v0.5.5 - GrosBedo
#   * fixed a few more bugs with diagnostic mode
# 2010-09-16 - v0.5.4 - GrosBedo
#   * fixed some bugs with diagnostic mode and removed one list (smaller memory footprint)
# 2010-09-15 - v0.5.3 - GrosBedo
#   * added --diagload to load human readable stats files and merge the results
# 2010-09-15 - v0.5.2 - GrosBedo
#   * fixed a few bugs again in log diagnostic mode
# 2010-09-14 - v0.5.1 - GrosBedo
#   * fixed a few bugs in log diagnostic mode
# 2010-09-13 - v0.5 - GrosBedo
#   * reworked the diagnostic switchs, now can save a raw merged matrix from loaded raw matrix and should be more efficient at memory management
# 2010-09-09 - v0.4.2 - GrosBedo
#   * more memory efficient when loading huge datas matrixes
# 2010-09-09 - v0.4.1 - GrosBedo
#   * fixed some bugs when loading several files at once
# 2010-09-09 - v0.4 - GrosBedo
#    * added diagnostic tool switchs
# 2010-09-08 - v0.3 - GrosBedo
#    * added the debug subparser
#    * does not conflict with standard b3 switchs anymore (--help show the b3 help)
# 2010-09-07 - v0.2 - GrosBedo
#    * added the special debug switchs, like debug, profile save and load.
# 2010-09-06 - v0.1 - GrosBedo
#    * Initial version.

# This section is DoxuGen information. More information on how to comment your code
# is available at http://wiki.bigbrotherbot.net/doku.php/customize:doxygen_rules
## @file
# Run B3 in developer debug mode (for developers)

__author__  = 'GrosBedo'
__version__ = '0.7'

import time, sys, os
import b3.run

pathname = os.path.dirname(sys.argv[0])
sys.path.append(os.path.join(pathname, 'b3','lib')) # we add the b3/lib path for the import to work for some complex libraries (like guppy)
sys.path.append(os.path.join(pathname, 'b3','tools'))

from b3_run import *
import argparse
from functionprofiler import *
from logdiagnostic import *
from memoryprofiler import *
#from datetime import datetime
import pprint, timeit

def parse_cmdline_args():
        # Initializing variables
        #currdateprofile = os.path.join(pathname, '%s.profile' % str(datetime.now().strftime("%Y-%m-%d_%H-%M-%S")))
        cancontinue = True # define if b3 can continue to run normally or not

        # Initializing the arguments parser
        parser = argparse.ArgumentParser(conflict_handler='resolve', add_help=False, usage='%(prog)s [debugoptions]', description='B3 DEBUG MODE: Switch to some special debug functionnalities.', epilog='Note: for the profile to be saved, you need to wait the end of the runtime that the profile ends by itself (do not close b3 !)')
        #parser.add_argument('--help', '-h', dest='help', action='store_true', default=False, help='show this help message and exit')
        parser.add_argument('--debughelp', '-debughelp', '--debug', '-debug', dest='debughelp', action='store_true', default=False, help='show this help message and exit')
        parser.add_argument('--memory', '-m', dest='memory', action='store_true', default=False, help='activate the memory monitor')
        parser.add_argument('--memorysave', '-msave', dest='memorysave', action='store', default=None, type=str, metavar='/dir/memory.profile', help='store the memory profile to the specified file')
        parser.add_argument('--memoryload', '-mload', dest='memoryload', action='store', default=None, type=str, metavar='/dir/memory.profile', help='load a memory profile from the specified file')
        parser.add_argument('--memorydraw', '-mdraw', dest='memorydraw', action='store_true', default=False, help='draw an interactive GUI chart for the loaded memory profile')
        parser.add_argument('--memoryinteractive', '-mi', dest='memoryinteractive', action='store_true', default=False, help='draw an interactive console terminal _while_ the application is running')
        parser.add_argument('--profile', '-p', dest='profile', action='store_true', default=False, help='activate the functions profiler')
        parser.add_argument('--profilesave', '-psave', dest='profilesave', action='store', default=None, type=str, metavar='/dir/some.profile', help='store the generated profile to the specified file')
        parser.add_argument('--profileload', '-pload', dest='profileload', action='store', default=None, type=str, metavar='/dir/some.profile', help='load a profile from the specified file')
        parser.add_argument('--profiledraw', '-pdraw', dest='profiledraw', action='store_true', default=False, help='draw an interactive GUI chart for the loaded profile')
        parser.add_argument('--profiledrawnogui', '-pdraw2', dest='profiledrawnogui', action='store_true', default=False, help='draw an interactive console interface to analyze the loaded profile')
        parser.add_argument('--profilesavestats', '-pstats', dest='profilesavestats', action='store', default=None, type=str, metavar='/dir/somefile.txt', help='parse and save some stats from the loaded profile')
        parser.add_argument('--profileruntime', '-ptime', dest='profileruntime', action='store', default=60, type=float, metavar='seconds', help='time to run the profile test (the program will be stopped after)')
        parser.add_argument('--diagnostic', '-diag', dest='diagnostic', action='store_true', default=False, help='activate the log diagnostic tool')
        parser.add_argument('--diaglog', '-dlog', dest='diaglog', action='store', nargs='+', default=None, type=str, metavar='games_mp.log', help='load and analyze one or several log files, generating stats per second')
        parser.add_argument('--diagzerocount', '-d0', dest='diagzerocount', action='store_true', default=False, help='Zero is significant (count missing lines)')
        parser.add_argument('--diagsave', '-dsave', dest='diagsave', action='store', default=None, type=str, metavar='stats.txt', help='store stats per second to the specified file, in a readable human format (YAML)')
        parser.add_argument('--diagload', '-dload', dest='diagload', action='store', nargs='+', default=None, type=str, metavar='stats.txt', help='load stats in YAML format resulting from a previous diagnostic and weight-merge the stats (much more approximate than rawload !)')
        parser.add_argument('--diagstatssave', '-dssave', dest='diagstatssave', action='store', default=None, type=str, metavar='statsdata.txt', help='(deprecated, see --diagsave) store computer readable stats to the specified file (for later processing)')
        parser.add_argument('--diagstatsload', '-dsload', dest='diagstatsload', action='store', nargs='+', default=None, type=str, metavar='statsdata.txt', help='(deprecated, see --diagload) load stats resulting from a previous diagnostic and weight-merge the stats (much more approximate than rawload !)')
        parser.add_argument('--diagrawsave', '-drsave', dest='diagrawsave', action='store', default=None, type=str, metavar='rawdata.txt', help='store the raw datas matrix from the log(s) for later processing')
        parser.add_argument('--diagrawload', '-drload', dest='diagrawload', action='store', nargs='+', default=None, type=str, metavar='rawdata.txt', help='load the raw datas and merge them')
        parser.add_argument('--diagmergeonly', '-dmerge', dest='diagmergeonly', action='store_true', default=None, help='only save one, merged result from all the gathered stats')
        parser.add_argument('--debugverbose', '-dv', dest='verbose', action='store_true', help='verbose option, output more informations on screen')

        # Parsing (loading) the arguments
        try:
            args, extras = parser.parse_known_args() # We parse only the special commandlines parameter here, for the rest, the normal switchs, we give them up to the rest of B3 functions (namely the main() in b3/run.py). The recognized args are stored in args var, for the rest it's stored in extras var
            extras.insert(0, sys.argv[0]) # add the path to this script file (to normalize the arguments)
            sys.argv = extras # trim out the debug vars we will process here, so that b3 can parse the arguments normally
        except BaseException, e:
            print('Exception: %s' % str(e))
            pass	

        #pprint.pprint(args)

        # Processing the arguments
        if args.debughelp: # debug help message
            parser.print_help()
            return False

        # Profiling functionnalities
        if args.memory:
                print('MEMORY PROFILER MODE\n--------------------\n')
                if args.memorysave:
                        runmemoryprofile(args.memorysave)
                if args.memoryload:
                        if args.memorydraw:
                                memorygui(args.memoryload)
                if args.memoryinteractive:
                        memoryinteractive()
                cancontinue = False

        # Profiling functionnalities
        if args.profile:
            print('FUNCTIONS PROFILER MODE\n--------------------\n')
            if args.profilesave:
                runprofile("""main()""", args.profilesave, args.profileruntime)
            if args.profileload:
                if args.profiledraw:
                    browseprofilegui(args.profileload)
                if args.profilesavestats:
                    parseprofile(args.profileload, args.profilesavestats)
                if args.profiledrawnogui:
                    browseprofile(args.profileload)
                #if cancontinue is not False:
                #    print('Profile loaded but no action specified ! Type --debughelp for more infos')
            cancontinue = False

        # Log Diagnostic functionnalities
        if args.diagnostic:
            print('LOG DIAGNOSTIC MODE\n--------------------\n')
            diag = LogDiagnostic()
            if args.diagzerocount:
                diag.significantzero = True
            else:
                diag.significantzero = False
            supermatrix = []
            superstats = []
            loadmatrix = []
            prestats = []
            # Processing the logs in input
            if args.diaglog:
                print('Analyzing the log(s) %s' % (' - '.join(args.diaglog)))
                supermatrix.extend(diag.lines_per_second(*args.diaglog))
                print('Analyze completed.')
            # Loading some previous results' matrix
            if args.diagrawload:
                print('Loading raw data results from %s. This can take some time, please be patient...' % (' - '.join(args.diagrawload)))
                loadmatrix.extend(diag.load_data(True, *args.diagrawload))
            # Merge the matrix first
            if len(supermatrix) > 1:
                print('Merging the raw data...')
                #mergedmatrix = diag.merge_matrix( *supermatrix)
                for matrix in supermatrix:
                        loadmatrix.extend(matrix[1])
                print('Raw data merge completed.')

            # Save the raw datas matrix(es)
            if args.diagrawsave:
                print('Saving the raw data to %s' % args.diagrawsave)
                if len(loadmatrix) > 0:
                        diag.save_data(args.diagrawsave, *loadmatrix)
                else:
                        diag.save_data(args.diagrawsave, *supermatrix)

            # Stats Generation
            # Input logs stats generation (to show in the final summary digest)
            if args.diaglog:
                print('Generating stats per second from logs...')
                superstats = diag.stats_per_second(*supermatrix)
                del supermatrix
                print('Generation completed.')
            # Raw merged stats generation
            if len(loadmatrix) > 0:
                print('Generating merged stats from raw data...')
                prestats = [diag.stats_per_second( ('raw merged logs', loadmatrix) )[0][1]] # we keep only the stats here, we trim the generated log name because we don't need it for the calculation of the weighted mean
                del loadmatrix
                print('Generation completed.')
            else:
                prestats.extend(superstats)

            # Loading some previous results' stats
            if args.diagstatsload:
                print('Loading previous stats results from %s' % (' - '.join(args.diagstatsload)))
                prestats.extend( (diag.load_data(False, statsfile)[0][0][1] for statsfile in args.diagstatsload ) )
            # Loading some previous results' stats in YAML
            if args.diagload:
                print('Loading previous stats results from %s' % (' - '.join(args.diagload)))
                prestats.extend( diag.load_data_yaml(*args.diagload) )
            # Merge then all the stats (only if there is an additional stats to merge after the matrix merge !)
            if args.diagload or args.diagstatsload:
                print('Merging the stats with a weighted mean algorithm...')
                mergedstats = diag.weighted_mean_merge( *prestats )
                print('Merging of stats completed.')
            else:
                mergedstats = [('raw merged logs', prestats[0])]
            del prestats

            # Save the stats in computer readable format
            if args.diagstatssave:
                if args.diagmergeonly: # Save only the merged result if specified by the user
                    print('Saving the final, merged stats to %s' % args.diagstatssave)
                    diag.save_data(args.diagstatssave, *mergedstats)
                else:
                    print('Saving all the stats + merged to %s' % args.diagstatssave)
                    superstats.extend(mergedstats)
                    diag.save_data(args.diagstatssave, *superstats)
            # Save the stats in human readable format
            if args.diagsave:
                if args.diagmergeonly: # Save only the merged result if specified by the user
                    print('Saving the stats digest to %s' % args.diagsave)
                    diag.save_data_yaml(args.diagsave, *mergedstats)
                else:
                    print('Saving the full stats digest (all the stats + merged) to %s' % args.diagsave)
                    superstats.extend(mergedstats)
                    diag.save_data_yaml(args.diagsave, *superstats)
            # Show the stats results on screen, in the console
            else:
                if args.diagmergeonly: # Save only the merged result if specified by the user
                    diag.show_results(None, *mergedstats)
                else:
                    superstats.extend(mergedstats)
                    diag.show_results(None, *superstats)
            del superstats
            del mergedstats
            
            print('Everything is done. Exiting.')
            cancontinue = False

        return cancontinue




def main():
    b3.run.main()

if __name__ == '__main__':
    result = parse_cmdline_args() # we parse here for special debug switchs, if there are none, the program will continue normally
    if result: # result will be False if we launched the profiler, or any function that should activate a special behaviour that could conflict with the normal main function
        main()
    
########NEW FILE########
__FILENAME__ = b3_run
#!/usr/bin/env python
#
# BigBrotherBot(B3) (www.bigbrotherbot.com)
# Copyright (C) 2005 Michael "ThorN" Thornton
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# This section is DoxuGen information. More information on how to comment your code
# is available at http://wiki.bigbrotherbot.net/doku.php/customize:doxygen_rules
## @mainpage
# <p>This documentation is the Bigbrotherbot Reference for developers.</p>
# <p>If you are a B3 developer, please document your classes, methods properly.<br />
# More information on how to document code can be found on http://wiki.bigbrotherbot.net/doku.php/customize:doxygen_rules</p>
# <p><a href="http://doc.bigbrotherbot.net">doc.bigbrotherbot.net</a></p>
## @file
# The entry point to run B3

__author__  = 'ThorN'
__version__ = '1.1.1'


import sys
if sys.version_info >= (3,):
    raise SystemExit("Sorry, cannot continue, B3 is not yet compatible with python version 3!")
if sys.version_info < (2,6):
    raise SystemExit("Sorry, cannot continue, B3 is not compatible with python versions earlier than 2.6!")  
    
import b3.run    

def main():
    b3.run.main()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = build
import os
import re
import sys
import subprocess

CONFIG_FILE = 'build.yaml'

script_dir = os.path.abspath(os.path.dirname(__file__))

try:
    # make sure to import the b3 module from the parent directory
    # (in case an other b3 module was installed system wide with an egg)
    sys.path.insert(0, os.path.abspath(os.path.join(script_dir, '..')))
    from b3 import __version__ as b3_version
    from b3.update import B3version
except ImportError:
    print "Could not import b3"
    raise

egg_pkginfo_file = os.path.abspath(os.path.join(script_dir, '../b3.egg-info/PKG-INFO'))

# read version from the b3/PKG-INFO file
re_pkginfo_version = re.compile(r'^\s*Version:\s*(?P<version>(?P<numbers>\d+\.\d+(?:\.\d+)?)(?P<pre_release>(?:a|b|dev|d)\d*)?(?P<suffix>.*?))\s*$', re.MULTILINE)
with open(egg_pkginfo_file, 'r') as f:
    m = re_pkginfo_version.search(f.read())
if not m:
    print "could not find version from %s" % egg_pkginfo_file
    sys.exit(1)
current_b3_version = m.group("version")
current_b3_version_part1 = m.group("numbers")
current_b3_version_part2 = ""
if m.group("pre_release"):
    current_b3_version_part2 += m.group("pre_release")
if m.group("suffix"):
    current_b3_version_part2 += m.group("suffix")


config = None
def load_config():
    global config
    config_file_path = os.path.normpath(os.path.join(script_dir, CONFIG_FILE))
    if not os.path.isfile(config_file_path):
        print "Could not find config file '%s'" % config_file_path
        choice = raw_input("\nDo you want to create a stub ? [yN] : " % current_b3_version)
        if choice.lower() == 'y':
            create_config_file_stub()
            print "config file stub created"
            sys.exit(0)
        else:
            sys.exit(0)

    from b3.lib import yaml
    with open(config_file_path, 'r') as f:
        config = yaml.load(f)

    if not 'innosetup_scripts' in config:
        print "Invalid config file. Could not find 'innosetup_scripts'."
        sys.exit(1)
    if not len(config['innosetup_scripts']):
        print "Invalid config file. No script found in 'innosetup_scripts' section."
        sys.exit(1)
    if not 'iscc' in config:
        print "Invalid config file. Could not find 'iscc'."
        sys.exit(1)
    if not os.path.isfile(os.path.abspath(os.path.join(script_dir, config['iscc']))):
        print "Invalid config file. '%s' is not a file." % config['iscc']
        sys.exit(1)
    # location of the InnoSetup Compiler program taken from environment variable ISCC_EXE if exists, else from
    # the yaml config file.
    config['iscc'] = os.environ.get('ISCC_EXE', config['iscc'])
    if not config['iscc'].lower().endswith('iscc.exe'):
        print "Invalid location for the ISCC.exe program. '%s' is not a iscc.exe." % config['iscc']
        sys.exit(1)
    if not 'output_dir' in config:
        print "Invalid config file. output_dir not set."
        sys.exit(1)
    else:
        dist_dir = os.path.abspath(os.path.join(script_dir, config['output_dir']))
        if not os.path.isdir(dist_dir):
            os.makedirs(dist_dir)


def create_config_file_stub():
    with open(os.path.abspath(os.path.join(script_dir, CONFIG_FILE)), 'w') as f:
        f.write("""\
# list of InnoSetup script to compile
innosetup_scripts:
 - b3-installer-project.iss

# where to find the InnoSetup compiler
# you can override this value setting the environment variable ISCC_EXE
iscc:  C:\Program Files (x86)\Inno Setup 5\ISCC.exe

# where to generate the distribution files
output_dir: ../releases
""")


def build_innosetup_scripts(innosetup_scripts):
    """\
    build each given innosetup script
    """
    results = {}
    compiler = os.path.abspath(os.path.join(script_dir, config["iscc"]))
    for file_name in innosetup_scripts:
        script_file = os.path.abspath(os.path.join(script_dir, file_name))
        print "building %s" % script_file
        try:
            cmd = [compiler, script_file, '/Q']
            cmd.append('/O%s' % os.path.join(script_dir, config['output_dir']))
            cmd.append('/dB3_VERSION_NUMBER=' + current_b3_version_part1)
            cmd.append('/dB3_VERSION_SUFFIX=' + current_b3_version_part2)
            print " ".join(cmd)
            exit_code = subprocess.call(cmd)
            if exit_code == 0:
                results[file_name] = 'OK'
            else:
                results[file_name] = 'KO'
        except Exception, err:
            results[file_name] = err
    return results.items()


def build_zip_distribution(source_folder):
    """\
    create a zipped distribution without installer
    """
    import zipfile
    dist_dir = os.path.join(script_dir, config['output_dir'])
    zip_filename = 'BigBrotherBot-%s-win32.zip' % current_b3_version
    print "building " + zip_filename + " (from " + os.path.abspath(source_folder) + ")"
    zip = zipfile.ZipFile(os.path.join(dist_dir, zip_filename), 'w')
    for root, dirs, files in os.walk(source_folder):
        for file in files:
            file_path = os.path.abspath(os.path.join(root, file))
            zip.write(file_path, arcname=os.path.join('b3', file_path[len(os.path.abspath(source_folder)):]))
    zip.close()
    return os.path.join(dist_dir, zip_filename), 'OK'


def main():
    load_config()
    print "{0:>50} :  {1}".format('current B3 version', current_b3_version)
    build_results = list()
    build_results += build_innosetup_scripts(config['innosetup_scripts'])
    build_results.append(build_zip_distribution(os.path.join(script_dir, "dist_py2exe")))

    print "\nBuild results :"
    print "---------------"
    for file_name, result in build_results:
        print "{0:>50} :  {1}".format(os.path.relpath(file_name), result)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
########NEW FILE########
__FILENAME__ = test_Client
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import operator
from b3.clients import Client, Group
from mock import Mock
from b3 import TEAM_UNKNOWN
from b3.clients import Alias, IpAlias
from b3.events import EVT_CLIENT_NAME_CHANGE, EVT_CLIENT_TEAM_CHANGE
import unittest2 as unittest
from tests import B3TestCase
 
class Test_Client(B3TestCase):
    
    def setUp(self):
        B3TestCase.setUp(self)
        self.client = Client(console=self.console)
    
    def test_construct(self):
        c = Client(name="Courgette", guid="1234567890")
        self.assertEqual(c.name, "Courgette")
        self.assertEqual(c.exactName, "Courgette^7")
        self.assertEqual(c.guid, "1234567890")
        self.assertEqual(c.team, TEAM_UNKNOWN)
        self.assertTrue(c.connected)
        self.assertFalse(c.hide)
        self.assertEqual(c.ip, '')
        self.assertEqual(c.greeting, '')
        self.assertEqual(c.pbid, '')

    def test_team(self):
        m = Mock()
        self.client.team = m
        self.assertEqual(self.client.team, m)
        
    def test_team_change(self):
        self.console.queueEvent = Mock()
        self.client.team = 24
        self.assertEqual(self.client.team, 24)
        self.console.queueEvent.assert_called()
        args = self.console.queueEvent.call_args
        eventraised = args[0][0]
        self.assertEquals(eventraised.type, EVT_CLIENT_TEAM_CHANGE)
        self.assertEquals(eventraised.data, 24)

    def test_name_change(self):
        self.console.queueEvent = Mock()
        self.client.authed = True
        self.client.name = "cucurb"
        self.assertEqual(self.client.name, "cucurb")
        self.console.queueEvent.assert_called()
        args = self.console.queueEvent.call_args
        eventraised = args[0][0]
        self.assertEquals(eventraised.type, EVT_CLIENT_NAME_CHANGE)
        self.assertEquals(eventraised.data, 'cucurb')

    def test_makeAlias_new(self):
        self.client.id = 123
        self.console.storage.getClientAlias = Mock(side_effect = KeyError())
        self.client.makeAlias("bar")
        self.assertEquals(self.console.storage.getClientAlias.call_count, 1)
        alias = self.console.storage.getClientAlias.call_args[0][0]
        self.assertIsInstance(alias, Alias)
        self.assertEqual(alias.alias, "bar")
        self.assertEqual(alias.numUsed, 1)

    def test_makeAlias_existing(self):
        self.client.id = 123
        aliasFoo = Alias()
        aliasFoo.alias = "foo"
        aliasFoo.clientId = self.client.id
        aliasFoo.numUsed = 48
        self.console.storage.getClientAlias = Mock(side_effect = lambda x: aliasFoo)
        self.client.makeAlias("whatever")
        self.assertEquals(self.console.storage.getClientAlias.call_count, 1)
        self.assertIsInstance(aliasFoo, Alias)
        self.assertEqual(aliasFoo.alias, "foo")
        self.assertEqual(aliasFoo.numUsed, 49)

    def test_guid_readonly(self):
        self.assertFalse(self.client.authed)
        self.client.guid = "foo"
        self.assertEqual(self.client.guid, "foo")
        self.client.auth()
        self.assertTrue(self.client.authed)
        # upon guid change, prevent change and consider client not
        # authed anymore
        self.client.guid = "bar"
        self.assertFalse(self.client.authed)
        self.client.guid = "foo"

    def test_set_ip(self):
        self.client.ip = "1.2.3.4"
        self.assertEqual(self.client._ip, "1.2.3.4")
        self.client.ip = "5.6.7.8:27960"
        self.assertEqual(self.client._ip, "5.6.7.8")
        
    def test_makeIpAlias_new(self):
        self.client.id = 123
        self.console.storage.getClientIpAddress = Mock(side_effect = KeyError())
        self.client.makeIpAlias("1.4.7.8")
        self.assertEquals(self.console.storage.getClientIpAddress.call_count, 1)
        alias = self.console.storage.getClientIpAddress.call_args[0][0]
        self.assertIsInstance(alias, IpAlias)
        self.assertEqual(alias.ip, "1.4.7.8")
        self.assertEqual(alias.numUsed, 1)

    def test_makeIpAlias_existing(self):
        self.client.id = 123
        aliasFoo = IpAlias()
        aliasFoo.ip = "9.5.4.4"
        aliasFoo.clientId = self.client.id
        aliasFoo.numUsed = 8
        self.console.storage.getClientIpAddress = Mock(side_effect = lambda x: aliasFoo)
        self.client.makeIpAlias("whatever")
        self.assertEquals(self.console.storage.getClientIpAddress.call_count, 1)
        self.assertIsInstance(aliasFoo, IpAlias)
        self.assertEqual(aliasFoo.ip, "9.5.4.4")
        self.assertEqual(aliasFoo.numUsed, 9)



class Test_Client_groups(B3TestCase):

    def setUp(self):
        B3TestCase.setUp(self)
        self.client = Client(console=self.console)
        self.group_guest = self.console.storage.getGroup(Group(keyword="guest"))
        self.group_user = self.console.storage.getGroup(Group(keyword="user"))
        self.group_reg = self.console.storage.getGroup(Group(keyword="reg"))
        self.group_mod = self.console.storage.getGroup(Group(keyword="mod"))
        self.group_admin = self.console.storage.getGroup(Group(keyword="admin"))
        self.group_fulladmin = self.console.storage.getGroup(Group(keyword="fulladmin"))
        self.group_senioradmin = self.console.storage.getGroup(Group(keyword="senioradmin"))
        self.group_superadmin = self.console.storage.getGroup(Group(keyword="superadmin"))

    def assertGroups(self, groups):
        keywords = map(operator.attrgetter('keyword'), groups)
        self.assertListEqual(keywords, map(operator.attrgetter('keyword'), self.client.groups))
        self.assertListEqual(keywords, map(operator.attrgetter('keyword'), self.client.getGroups()))

    def test_addGroup(self):
        # GIVEN
        self.client.addGroup(self.group_mod)
        self.assertGroups([self.group_mod])
        # WHEN
        self.client.addGroup(self.group_superadmin)
        # THEN
        self.assertGroups([self.group_mod, self.group_superadmin])

    def test_rmGroup(self):
        # GIVEN
        self.client.addGroup(self.group_mod)
        self.assertGroups([self.group_mod])
        self.client.addGroup(self.group_superadmin)
        # WHEN
        self.client.remGroup(self.group_mod)
        # THEN
        self.assertGroups([self.group_superadmin])

    def test_guest_group_is_the_default_group_when_none(self):
        self.assertGroups([self.group_guest])

        self.client.remGroup(self.group_guest)
        self.assertGroups([self.group_guest])

        self.client.addGroup(self.group_admin)
        self.assertGroups([self.group_admin])

    def test_inGroup(self):
        self.assertFalse(self.client.inGroup(self.group_guest))
        self.assertFalse(self.client.inGroup(self.group_user))
        self.assertFalse(self.client.inGroup(self.group_reg))
        self.assertFalse(self.client.inGroup(self.group_mod))
        self.assertFalse(self.client.inGroup(self.group_admin))
        self.assertFalse(self.client.inGroup(self.group_fulladmin))
        self.assertFalse(self.client.inGroup(self.group_senioradmin))
        self.assertFalse(self.client.inGroup(self.group_superadmin))

        self.client.addGroup(self.group_user)
        self.assertTrue(self.client.inGroup(self.group_user))
        self.client.addGroup(self.group_reg)
        self.assertTrue(self.client.inGroup(self.group_reg))
        self.client.addGroup(self.group_mod)
        self.assertTrue(self.client.inGroup(self.group_mod))
        self.client.addGroup(self.group_admin)
        self.assertTrue(self.client.inGroup(self.group_admin))
        self.client.addGroup(self.group_fulladmin)
        self.assertTrue(self.client.inGroup(self.group_fulladmin))
        self.client.addGroup(self.group_senioradmin)
        self.assertTrue(self.client.inGroup(self.group_senioradmin))
        self.client.addGroup(self.group_superadmin)
        self.assertTrue(self.client.inGroup(self.group_superadmin))


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_Clients
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.clients import Clients, Client
from tests import B3TestCase
from mock import Mock, patch
import b3



class TestClients(B3TestCase):
    clients = None
    joe = None
    
    def setUp(self):
        B3TestCase.setUp(self)
        Clients.authorizeClients = Mock()
        self.clients = Clients(self.console)
        self.clients.newClient(1, name='joe')
        self.clients.newClient(2, name=' H a    x\t0r')


    def test_getClientsByName(self):
        clients = self.clients.getClientsByName('joe')
        self.assertEqual(1, len(clients))
        self.assertEqual(1, clients[0].cid)
        
        clients = self.clients.getClientsByName('oe')
        self.assertEqual(1, len(clients))
        self.assertEqual(1, clients[0].cid)
        
        clients = self.clients.getClientsByName('hax')
        self.assertEqual(1, len(clients))
        self.assertEqual(2, clients[0].cid)
        
        clients = self.clients.getClientsByName('qsdfqsdf fqsd fsqd fsd f')
        self.assertEqual([], clients)

    @patch.object(b3.events, 'Event')
    def test_disconnect(self, Event_mock):
        joe = self.clients.getByCID(1)
        self.assertIsInstance(joe, Client)
        self.assertTrue(1 in self.clients)
        self.assertEqual(joe, self.clients[1])

        self.assertEqual(2, len(self.clients))
        self.clients.disconnect(joe)
        self.assertEqual(1, len(self.clients))

        # verify that the Client object is removed from Clients
        self.assertFalse(1 in self.clients)
        self.assertIsNone(self.clients.getByCID(1))
        self.assertIsNone(self.clients.getByName('joe'))

        # verify that an proper event was fired
        Event_mock.assert_called_once_with(b3.events.EVT_CLIENT_DISCONNECT, 1, client=joe)

########NEW FILE########
__FILENAME__ = test_abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import re
import unittest2 as unittest

from mock import Mock, patch, call
from b3.clients import Client
from b3.plugins.admin import AdminPlugin
from b3.config import XmlConfigParser
from b3.parsers.frostbite.abstractParser import AbstractParser


sleep_patcher = None
def setUpModule():
    sleep_patcher = patch("time.sleep")
    sleep_patcher.start()

def tearDownModule():
    if sleep_patcher:
        sleep_patcher.stop()



class ConcretegameParser(AbstractParser):
    gameName = 'thegame'


class AbstractParser_TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing AbstractParser parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.fake import FakeConsole

        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # AbstractParser -> FakeConsole -> Parser

    def tearDown(self):
        if hasattr(self, "parser"):
            self.parser.working = False # this tells some parser threads to end


########################################################################################################################
#
#  T E S T    B 3    P A R S E R    A P I    I M P L E M E N T A T I O N
#
########################################################################################################################


class Test_tempban(AbstractParser_TestCase):
    def setUp(self):
        AbstractParser_TestCase.setUp(self)
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("<configuration/>")
        self.parser = ConcretegameParser(self.conf)
        self.parser.PunkBuster = None
        self.parser.ban_with_server = True

        self.getMessage_patcher = patch.object(self.parser, "getMessage")
        getMessage_mock = self.getMessage_patcher.start()
        getMessage_mock.return_value = ""

        self.foo = Mock(spec=Client)
        self.foo.cid = 'f00'
        self.foo.guid = 'EA_AAABBBBCCCCDDDDEEEEFFFF00000'
        self.foo.name = 'f00'

    def tearDown(self):
        AbstractParser_TestCase.tearDown(self)
        self.getMessage_patcher.stop()


    def test_kick_having_cid_and_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.assertTrue(self.foo.cid)
            self.assertTrue(self.foo.guid)

            # WHEN
            self.parser.tempban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'seconds', '120', ''))])


    def test_kick_having_no_cid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.cid = None
            self.assertFalse(self.foo.cid)

            # WHEN
            self.parser.tempban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'seconds', '120', ''))])



class Test_ban(AbstractParser_TestCase):
    def setUp(self):
        AbstractParser_TestCase.setUp(self)
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("<configuration/>")
        self.parser = ConcretegameParser(self.conf)
        self.parser.PunkBuster = None
        self.parser.ban_with_server = True

        self.getMessage_patcher = patch.object(self.parser, "getMessage")
        getMessage_mock = self.getMessage_patcher.start()
        getMessage_mock.return_value = ""

        self.foo = Mock(spec=Client)
        self.foo.cid = 'f00'
        self.foo.guid = 'EA_AAABBBBCCCCDDDDEEEEFFFF00000'
        self.foo.name = 'f00'
        self.foo.ip = '11.22.33.44'

    def tearDown(self):
        AbstractParser_TestCase.tearDown(self)
        self.getMessage_patcher.stop()


    def test_kick_having_cid_and_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.assertTrue(self.foo.cid)
            self.assertTrue(self.foo.guid)

            # WHEN
            self.parser.ban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'perm', ''))])


    def test_kick_having_no_cid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.cid = None
            self.assertFalse(self.foo.cid)

            # WHEN
            self.parser.ban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'perm', ''))])



########################################################################################################################
#
#  T E S T    G A M E    E V E N T S
#
########################################################################################################################
class Test_OnPlayerChat(AbstractParser_TestCase):
    def setUp(self):
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)

        self.admin_plugin_mock = Mock(spec=AdminPlugin)
        self.admin_plugin_mock._commands = {}
        self.admin_plugin_mock.cmdPrefix = '!'
        self.admin_plugin_mock.cmdPrefixLoud = '@'
        self.admin_plugin_mock.cmdPrefixBig = '&'
        self.parser.getPlugin = Mock(return_value=self.admin_plugin_mock)

        self.joe = Mock(spec=Client)
        self.parser.getClient = Mock(return_value=self.joe)



    def test_normal_text(self):
        self.assertEqual('foo', self.parser.OnPlayerChat(action=None, data=('joe', 'foo', 'all')).data)
        self.assertEqual('  foo', self.parser.OnPlayerChat(action=None, data=('joe', '  foo', 'all')).data)

    def test_command(self):
        self.assertEqual('!1', self.parser.OnPlayerChat(action=None, data=('joe', '!1', 'all')).data)
        self.assertEqual('!foo', self.parser.OnPlayerChat(action=None, data=('joe', '!foo', 'all')).data)
        self.assertEqual('!!foo', self.parser.OnPlayerChat(action=None, data=('joe', '!!foo', 'all')).data)
        self.assertEqual('@foo', self.parser.OnPlayerChat(action=None, data=('joe', '@foo', 'all')).data)
        self.assertEqual('@@foo', self.parser.OnPlayerChat(action=None, data=('joe', '@@foo', 'all')).data)
        self.assertEqual(r'&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'&foo', 'all')).data)
        self.assertEqual(r'&&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'&&foo', 'all')).data)

    def test_slash_prefix(self):
        self.assertEqual('!1', self.parser.OnPlayerChat(action=None, data=('joe', '/!1', 'all')).data)
        self.assertEqual('!foo', self.parser.OnPlayerChat(action=None, data=('joe', '/!foo', 'all')).data)
        self.assertEqual('@foo', self.parser.OnPlayerChat(action=None, data=('joe', '/@foo', 'all')).data)
        self.assertEqual(r'&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'/&foo', 'all')).data)



########################################################################################################################
#
#  T E S T    P U N K B U S T E R    E V E N T S
#
########################################################################################################################
class Test_OnPBPlayerGuid(AbstractParser_TestCase):
    def setUp(self):
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)

        self.event_raw_data = ["punkBuster.onMessage", 'servername: Player GUID Computed 03121513135AAFF(-) (slot #12) 11.22.44.33:1254 Snoopy']
        regex_for_OnPBPlayerGuid = [x for (x, y) in self.parser._punkbusterMessageFormats if y == 'OnPBPlayerGuid'][0]
        self.event_match = Mock(wraps=re.match(regex_for_OnPBPlayerGuid, self.event_raw_data[1]))
        self.event_match.__eq__ = Test_OnPBPlayerGuid.SREMatch_equals

    @staticmethod
    def SREMatch_equals(m1, m2):
        """
        @return True if m1 and m2 could be re.match responses for the same regex and data to match
        """
        if m2 is None:
            return False
        else:
            return m1.groups() == m2.groups()

    def test_OnPBPlayerGuid_is_called(self):
        with patch.object(self.parser, "OnPBPlayerGuid") as OnPBPlayerGuid_mock:
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            OnPBPlayerGuid_mock.assert_called_once_with(self.event_match, self.event_raw_data[1])

    def test_OnPBPlayerGuid_saves_client(self):
        with patch.object(self.parser, "getClient") as getClient_mock:
            # GIVEN
            snoopy = Mock()
            snoopy.guid = 'EA_AAAAAAAABBBBBBBBBBBBBB00000000000012222'
            getClient_mock.return_value = snoopy
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            getClient_mock.assert_called_once_with("Snoopy")
            snoopy.save.assert_called_once_with()





########################################################################################################################
#
#  T E S T    C O N F I G
#
########################################################################################################################



########################################################################################################################
#
#  T E S T    O T H E R    S T U F F
#
########################################################################################################################
class Map_related_TestCase(AbstractParser_TestCase):
    """
    Test case that controls replies given by the parser write method as follow :

    ## mapList.list
    Responds with the maps found on test class properties 'maps'.
    Response contains 5 maps at most ; to get other maps, you have to use the 'StartOffset' command parameter that appears
    from BF3 R12 release.

    ## mapList.getMapIndices
    Responds with the value of the test class property 'map_indices'.

    ## getEasyName
    Responds with whatever argument was passed to it.

    ## getGameMode
    Responds with whatever argument was passed to it.
    """

    maps = (
        ('MP_001 ', 'ConquestLarge0', '2'),
        ('MP_002 ', 'Rush0', '2'),
        ('MP_003 ', 'ConquestLarge0', '2'),
        )
    map_indices = [1, 2]

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        self.parser.startup()

        # simulate responses we can expect from the rcon command mapList.list
        def write(data):
            if type(data) in (tuple, list):
                if data[0].lower() == 'maplist.list':
                    offset = 0
                    if len(data) > 1:
                        try:
                            offset = int(data[1])
                        except ValueError:
                            raise CommandFailedError(['InvalidArguments'])
                            # simulate that the Frostbite2 server responds with 5 maps at most for the mapList.list command
                    maps_to_send = self.__class__.maps[offset:offset + 5]
                    return [len(maps_to_send), 3] + list(reduce(tuple.__add__, maps_to_send, tuple()))
                elif data[0].lower() == 'maplist.getmapindices':
                    return self.__class__.map_indices
            return []

        self.parser.write = Mock(side_effect=write)

        self.parser.getEasyName = Mock(side_effect=lambda x: x)
        self.parser.getGameMode = Mock(side_effect=lambda x: x)


########NEW FILE########
__FILENAME__ = test_util
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import unittest2 as unittest
from b3.parsers.frostbite.util import BanlistContent, PlayerInfoBlock



class TestBanlistContent(unittest.TestCase):
    def test_bad(self):
        self.assertRaises(TypeError, BanlistContent, None)
        self.assertRaises(IndexError, BanlistContent, [])
    def test_minimal(self):
        self.assertEqual(0, len(BanlistContent([0])))
        self.assertEqual('BanlistContent[]', repr(BanlistContent([0])))
        self.assertEqual(0, len(BanlistContent(['0'])))
        self.assertEqual('BanlistContent[]', repr(BanlistContent(['0'])))
        self.assertEqual(1, len(BanlistContent(['1','d1','d2','d3','d4','d5'])))
        self.assertEqual("BanlistContent[{'idType': 'd1', 'reason': 'd5', 'banType': 'd3', 'id': 'd2', 'time': 'd4'}]", repr(BanlistContent(['1','d1','d2','d3','d4','d5'])))
    def test_1(self):
        bloc = BanlistContent(['2','d1','d2','d3','d4','d5','p1','p2','p3','p4','p5'])
        self.assertEqual(2, len(bloc))
        self.assertEqual("BanlistContent[{'idType': 'd1', 'reason': 'd5', 'banType': 'd3', 'id': 'd2', 'time': 'd4'}{'idType': 'p1', 'reason': 'p5', 'banType': 'p3', 'id': 'p2', 'time': 'p4'}]", repr(bloc))



class TestPlayerInfoBlock(unittest.TestCase):
    def test_no_param(self):
        self.assertRaises(TypeError, PlayerInfoBlock, None)
    def test_none(self):
        self.assertRaises(TypeError, PlayerInfoBlock, (None,))
    def test_empty_list(self):
        self.assertRaises(TypeError, PlayerInfoBlock, ([],))
    def test_bad_list(self):
        self.assertRaises(TypeError, PlayerInfoBlock, ([None],))
        self.assertRaises(TypeError, PlayerInfoBlock, ([0],))
        self.assertRaises(TypeError, PlayerInfoBlock, ([0,1],))
    def test_minimal(self):
        self.assertEqual(0, len(PlayerInfoBlock([0,0])))
        self.assertEqual('PlayerInfoBlock[]', repr(PlayerInfoBlock([0,0])))
        self.assertEqual(0, len(PlayerInfoBlock(['0','0'])))
        self.assertEqual(0, len(PlayerInfoBlock(['1','test','0'])))
        self.assertEqual('PlayerInfoBlock[]', repr(PlayerInfoBlock(['1','test','0'])))
    def test_1(self):
        bloc = PlayerInfoBlock(['1','param1','1','blabla'])
        self.assertEqual(1, len(bloc))
        self.assertEqual('blabla', bloc[0]['param1'])
        self.assertEqual("PlayerInfoBlock[{'param1': 'blabla'}]", repr(bloc))
    def test_2(self):
        bloc = PlayerInfoBlock(['1','param1','2','bla1', 'bla2'])
        self.assertEqual(2, len(bloc))
        self.assertEqual('bla1', bloc[0]['param1'])
        self.assertEqual('bla2', bloc[1]['param1'])
        self.assertEqual("PlayerInfoBlock[{'param1': 'bla1'}{'param1': 'bla2'}]", repr(bloc))
    def test_3(self):
        bloc = PlayerInfoBlock(['2','param1','param2','2','bla1','bla2','foo1','foo2'])
        self.assertEqual(2, len(bloc))
        self.assertEqual('bla1', bloc[0]['param1'])
        self.assertEqual('bla2', bloc[0]['param2'])
        self.assertEqual('foo1', bloc[1]['param1'])
        self.assertEqual('foo2', bloc[1]['param2'])
        self.assertEqual("PlayerInfoBlock[{'param2': 'bla2', 'param1': 'bla1'}{'param2': 'foo2', 'param1': 'foo1'}]", repr(bloc))

########NEW FILE########
__FILENAME__ = test_abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import re
import unittest2 as unittest

from mock import Mock, patch, call
from b3.clients import Client
from b3.plugins.admin import AdminPlugin
from b3.config import XmlConfigParser
from b3.parsers.frostbite2.protocol import CommandFailedError
from b3.parsers.frostbite2.abstractParser import AbstractParser

sleep_patcher = None
def setUpModule():
    sleep_patcher = patch("time.sleep")
    sleep_patcher.start()

def tearDownModule():
    if sleep_patcher:
        sleep_patcher.stop()



class ConcretegameParser(AbstractParser):
    gameName = 'thegame'


class AbstractParser_TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing AbstractParser parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.fake import FakeConsole

        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # AbstractParser -> FakeConsole -> Parser

    def tearDown(self):
        if hasattr(self, "parser"):
            for c in self.parser.clients.values():
                if hasattr(c, 'messagequeue'):
                    c.messagequeue.queue.clear()
            del self.parser.clients
            self.parser.working = False # this tells some parser threads to end


########################################################################################################################
#
#  T E S T    B 3    P A R S E R    A P I    I M P L E M E N T A T I O N
#
########################################################################################################################
class Test_saybig(AbstractParser_TestCase):
    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        self.parser._settings['big_msg_duration'] = '3.1'


    def test_saybig(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            self.parser.saybig('test')
            self.parser.saybig('test2')

            self.assertTrue(write_mock.called)
            write_mock.assert_any_call(('admin.yell', 'test', '3'))
            write_mock.assert_any_call(('admin.yell', 'test2', '3'))



class Test_tempban(AbstractParser_TestCase):
    def setUp(self):
        AbstractParser_TestCase.setUp(self)
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("<configuration/>")
        self.parser = ConcretegameParser(self.conf)
        self.parser.PunkBuster = None
        self.parser.ban_with_server = True

        self.getMessage_patcher = patch.object(self.parser, "getMessage")
        getMessage_mock = self.getMessage_patcher.start()
        getMessage_mock.return_value = ""

        self.foo = Mock(spec=Client)
        self.foo.cid = 'f00'
        self.foo.guid = 'EA_AAABBBBCCCCDDDDEEEEFFFF00000'
        self.foo.name = 'f00'

    def tearDown(self):
        AbstractParser_TestCase.tearDown(self)
        self.getMessage_patcher.stop()


    def test_kick_having_cid_and_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.assertTrue(self.foo.cid)
            self.assertTrue(self.foo.guid)

            # WHEN
            self.parser.tempban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'seconds', '120', ''))])


    def test_kick_having_cid_and_empty_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.guid = ''
            self.assertTrue(self.foo.cid)
            self.assertFalse(self.foo.guid)

            # WHEN
            self.parser.tempban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'name', self.foo.name, 'seconds', '120', ''))])


    def test_kick_having_no_cid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.cid = None
            self.assertFalse(self.foo.cid)

            # WHEN
            self.parser.tempban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'seconds', '120', ''))])



class Test_ban(AbstractParser_TestCase):
    def setUp(self):
        AbstractParser_TestCase.setUp(self)
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("<configuration/>")
        self.parser = ConcretegameParser(self.conf)
        self.parser.PunkBuster = None
        self.parser.ban_with_server = True

        self.getMessage_patcher = patch.object(self.parser, "getMessage")
        getMessage_mock = self.getMessage_patcher.start()
        getMessage_mock.return_value = ""

        self.foo = Mock(spec=Client)
        self.foo.cid = 'f00'
        self.foo.guid = 'EA_AAABBBBCCCCDDDDEEEEFFFF00000'
        self.foo.name = 'f00'
        self.foo.ip = '11.22.33.44'

    def tearDown(self):
        AbstractParser_TestCase.tearDown(self)
        self.getMessage_patcher.stop()


    def test_kick_having_cid_and_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.assertTrue(self.foo.cid)
            self.assertTrue(self.foo.guid)

            # WHEN
            self.parser.ban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'perm', ''))])


    def test_kick_having_cid_and_empty_guid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.guid = ''
            self.assertTrue(self.foo.cid)
            self.assertFalse(self.foo.guid)

            # WHEN
            self.parser.ban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'name', self.foo.name, 'perm', ''))])


    def test_kick_having_no_cid(self):
        with patch.object(AbstractParser, 'write') as write_mock:
            # GIVEN
            self.foo.cid = None
            self.assertFalse(self.foo.cid)

            # WHEN
            self.parser.ban(self.foo)

            # THEN
            self.assertTrue(write_mock.called)
            write_mock.assert_has_calls([call(('banList.add', 'guid', self.foo.guid, 'perm', ''))])



########################################################################################################################
#
#  T E S T    G A M E    E V E N T S
#
########################################################################################################################
class Test_OnPlayerChat(AbstractParser_TestCase):
    def setUp(self):
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)

        self.admin_plugin_mock = Mock(spec=AdminPlugin)
        self.admin_plugin_mock._commands = {}
        self.admin_plugin_mock.cmdPrefix = '!'
        self.admin_plugin_mock.cmdPrefixLoud = '@'
        self.admin_plugin_mock.cmdPrefixBig = '&'
        self.parser.getPlugin = Mock(return_value=self.admin_plugin_mock)

        self.joe = Mock(spec=Client)
        self.parser.getClient = Mock(return_value=self.joe)



    def test_normal_text(self):
        self.assertEqual('foo', self.parser.OnPlayerChat(action=None, data=('joe', 'foo', 'all')).data)
        self.assertEqual('  foo', self.parser.OnPlayerChat(action=None, data=('joe', '  foo', 'all')).data)

    def test_command(self):
        self.assertEqual('!1', self.parser.OnPlayerChat(action=None, data=('joe', '!1', 'all')).data)
        self.assertEqual('!foo', self.parser.OnPlayerChat(action=None, data=('joe', '!foo', 'all')).data)
        self.assertEqual('!!foo', self.parser.OnPlayerChat(action=None, data=('joe', '!!foo', 'all')).data)
        self.assertEqual('@foo', self.parser.OnPlayerChat(action=None, data=('joe', '@foo', 'all')).data)
        self.assertEqual('@@foo', self.parser.OnPlayerChat(action=None, data=('joe', '@@foo', 'all')).data)
        self.assertEqual(r'&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'&foo', 'all')).data)
        self.assertEqual(r'&&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'&&foo', 'all')).data)

    def test_slash_prefix(self):
        self.assertEqual('!1', self.parser.OnPlayerChat(action=None, data=('joe', '/!1', 'all')).data)
        self.assertEqual('!foo', self.parser.OnPlayerChat(action=None, data=('joe', '/!foo', 'all')).data)
        self.assertEqual('@foo', self.parser.OnPlayerChat(action=None, data=('joe', '/@foo', 'all')).data)
        self.assertEqual(r'&foo', self.parser.OnPlayerChat(action=None, data=('joe', r'/&foo', 'all')).data)

    def test_slash_no_prefix_no_command(self):
        self.assertNotIn('non_existing_command', self.admin_plugin_mock._commands)
        self.assertEqual('/non_existing_command', self.parser.OnPlayerChat(action=None, data=('joe', '/non_existing_command', 'all')).data)

    def test_slash_no_prefix_command(self):
        self.admin_plugin_mock._commands['exiting_command'] = Mock()
        self.assertIn('exiting_command', self.admin_plugin_mock._commands)
        self.assertEqual('!exiting_command', self.parser.OnPlayerChat(action=None, data=('joe', '/exiting_command', 'all')).data)
        self.assertEqual('!exiting_command', self.parser.OnPlayerChat(action=None, data=('joe', '!exiting_command', 'all')).data)
        self.admin_plugin_mock._commands['a'] = Mock()
        self.assertIn('a', self.admin_plugin_mock._commands)
        self.assertEqual('!a', self.parser.OnPlayerChat(action=None, data=('joe', '/a', 'all')).data)
        self.assertEqual('!a', self.parser.OnPlayerChat(action=None, data=('joe', '!a', 'all')).data)



########################################################################################################################
#
#  T E S T    P U N K B U S T E R    E V E N T S
#
########################################################################################################################
class Test_OnPBPlayerGuid(AbstractParser_TestCase):
    def setUp(self):
        log = logging.getLogger('output')
        log.setLevel(logging.NOTSET)

        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)

        self.event_raw_data = ["punkBuster.onMessage", 'PunkBuster Server: 14 300000aaaaaabbbbbbccccc111223300(-) 11.122.103.24:3659 OK   1 3.0 0 (W) "Snoopy"']
        regex_for_OnPBPlistItem = [x for (x, y) in self.parser._punkbusterMessageFormats if y == 'OnPBPlistItem'][0]
        self.event_match = Mock(wraps=re.match(regex_for_OnPBPlistItem, self.event_raw_data[1]))
        self.event_match.__eq__ = Test_OnPBPlayerGuid.SREMatch_equals

    @staticmethod
    def SREMatch_equals(m1, m2):
        """
        @return True if m1 and m2 could be re.match responses for the same regex and data to match
        """
        if m2 is None:
            return False
        else:
            return m1.groups() == m2.groups()


    def test_OnPBPlistItem_is_called(self):
        with patch.object(self.parser, "OnPBPlistItem") as OnPBPlistItem_mock:
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            OnPBPlistItem_mock.assert_called_once_with(self.event_match, self.event_raw_data[1])

    def test_OnPBPlayerGuid_is_called(self):
        with patch.object(self.parser, "OnPBPlayerGuid") as OnPBPlayerGuid_mock:
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            OnPBPlayerGuid_mock.assert_called_once_with(self.event_match, self.event_raw_data[1])

    def test_OnPBPlayerGuid_saves_client_with_guid(self):
        with patch.object(self.parser, "getClient") as getClient_mock:
            # GIVEN
            snoopy = Mock()
            snoopy.guid = 'EA_AAAAAAAABBBBBBBBBBBBBB00000000000012222'
            getClient_mock.return_value = snoopy
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            getClient_mock.assert_called_once_with("Snoopy")
            snoopy.save.assert_called_once_with()

    def test_OnPBPlayerGuid_does_not_save_client_without_guid(self):
        with patch.object(self.parser, "getClient") as getClient_mock:
            # GIVEN
            snoopy = Mock()
            snoopy.guid = ''
            getClient_mock.return_value = snoopy
            # WHEN
            self.parser.routeFrostbitePacket(self.event_raw_data)
            # THEN
            getClient_mock.assert_called_once_with("Snoopy")
            self.assertFalse(snoopy.save.called)







########################################################################################################################
#
#  T E S T    C O N F I G
#
########################################################################################################################
class Test_config(AbstractParser_TestCase):
    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration/>""")
        self.parser = ConcretegameParser(self.conf)
        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)



    def assert_big_b3_private_responses(self, expected, config):
        self.parser._settings['big_b3_private_responses'] = None
        self.conf.loadFromString(config)
        self.parser.load_conf_big_b3_private_responses()
        self.assertEqual(expected, self.parser._settings['big_b3_private_responses'])

    def test_big_b3_private_responses_on(self):
        self.assert_big_b3_private_responses(True, """<configuration>
                    <settings name="thegame">
                        <set name="big_b3_private_responses">on</set>
                    </settings>
                </configuration>""")

        self.assert_big_b3_private_responses(False, """<configuration>
                    <settings name="thegame">
                        <set name="big_b3_private_responses">off</set>
                    </settings>
                </configuration>""")

        self.assert_big_b3_private_responses(False, """<configuration>
                    <settings name="thegame">
                        <set name="big_b3_private_responses">off</set>
                    </settings>
                </configuration>""")

        self.assert_big_b3_private_responses(False, """<configuration>
                    <settings name="thegame">
                        <set name="big_b3_private_responses">f00</set>
                    </settings>
                </configuration>""")

        self.assert_big_b3_private_responses(False, """<configuration>
                    <settings name="thegame">
                        <set name="big_b3_private_responses"></set>
                    </settings>
                </configuration>""")


    def assert_big_msg_duration(self, expected, config):
        self.parser._settings['big_msg_duration'] = None
        self.conf.loadFromString(config)
        self.parser.load_conf_big_msg_duration()
        self.assertEqual(expected, self.parser._settings['big_msg_duration'])

    def test_big_msg_duration(self):
        default_value = 4
        self.assert_big_msg_duration(0, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration">0</set>
                    </settings>
                </configuration>""")

        self.assert_big_msg_duration(5, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration">5</set>
                    </settings>
                </configuration>""")

        self.assert_big_msg_duration(default_value, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration">5.6</set>
                    </settings>
                </configuration>""")

        self.assert_big_msg_duration(30, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration">30</set>
                    </settings>
                </configuration>""")

        self.assert_big_msg_duration(default_value, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration">f00</set>
                    </settings>
                </configuration>""")

        self.assert_big_msg_duration(default_value, """<configuration>
                    <settings name="thegame">
                        <set name="big_msg_duration"></set>
                    </settings>
                </configuration>""")


class Test_config_ban_agent(AbstractParser_TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration/>""")
        self.parser = AbstractParser(self.conf)
        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)


    def assert_both(self, config):
        self.conf.loadFromString(config)
        self.parser.load_conf_ban_agent()
        self.assertNotEqual(None, self.parser.PunkBuster)
        self.assertTrue(self.parser.ban_with_server)

    def assert_punkbuster(self, config):
        self.conf.loadFromString(config)
        self.parser.load_conf_ban_agent()
        self.assertNotEqual(None, self.parser.PunkBuster)
        self.assertFalse(self.parser.ban_with_server)

    def assert_frostbite(self, config):
        self.conf.loadFromString(config)
        self.parser.load_conf_ban_agent()
        self.assertEqual(None, self.parser.PunkBuster)
        self.assertTrue(self.parser.ban_with_server)

    def test_both(self):
        self.assert_both("""<configuration><settings name="server"><set name="ban_agent">both</set></settings></configuration>""")
        self.assert_both("""<configuration><settings name="server"><set name="ban_agent">BOTH</set></settings></configuration>""")

    def test_punkbuster(self):
        self.assert_punkbuster("""<configuration><settings name="server"><set name="ban_agent">punkbuster</set></settings></configuration>""")
        self.assert_punkbuster("""<configuration><settings name="server"><set name="ban_agent">PUNKBUSTER</set></settings></configuration>""")

    def test_frostbite(self):
        self.assert_frostbite("""<configuration><settings name="server"><set name="ban_agent">server</set></settings></configuration>""")
        self.assert_frostbite("""<configuration><settings name="server"><set name="ban_agent">SERVER</set></settings></configuration>""")

    def test_default(self):
        self.assert_frostbite("""<configuration/>""")
        self.assert_frostbite("""<configuration><settings name="server"><set name="ban_agent"></set></settings></configuration>""")
        self.assert_frostbite("""<configuration><settings name="server"><set name="ban_agent"/></settings></configuration>""")


class Test_conf_max_say_line_length(AbstractParser_TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration/>""")
        self.parser = ConcretegameParser(self.conf)

        self.MAX_SAY_LINE_LENGTH__MIN = 20
        self.MAX_SAY_LINE_LENGTH__MAX = self.parser.SAY_LINE_MAX_LENGTH
        self.MAX_SAY_LINE_LENGTH__DEFAULT = self.parser._settings['line_length']

        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)

    def _assert(self, conf_data=None, expected=None):
        self.conf.loadFromString("""
            <configuration>
                <settings name="thegame">%s</settings>
            </configuration>
            """ % (('<set name="max_say_line_length">%s</set>' % conf_data) if conf_data is not None else ''))
        self.parser.load_conf_max_say_line_length()
        if expected:
            self.assertEqual(expected, self.parser._settings['line_length'])


    def test_max_say_line_length__None(self):
        self._assert(conf_data=None, expected=self.MAX_SAY_LINE_LENGTH__DEFAULT)

    def test_max_say_line_length__empty(self):
        self._assert(conf_data='', expected=self.MAX_SAY_LINE_LENGTH__DEFAULT)

    def test_max_say_line_length__nan(self):
        self._assert(conf_data='foo', expected=self.MAX_SAY_LINE_LENGTH__DEFAULT)

    def test_max_say_line_length__too_low(self):
        self._assert(conf_data=self.MAX_SAY_LINE_LENGTH__MIN - 1, expected=self.MAX_SAY_LINE_LENGTH__MIN)

    def test_max_say_line_length__lowest(self):
        self._assert(conf_data=self.MAX_SAY_LINE_LENGTH__MIN, expected=self.MAX_SAY_LINE_LENGTH__MIN)

    def test_max_say_line_length__25(self):
        self._assert(conf_data='25', expected=25)

    def test_max_say_line_length__highest(self):
        self._assert(conf_data=self.MAX_SAY_LINE_LENGTH__MAX, expected=self.MAX_SAY_LINE_LENGTH__MAX)

    def test_max_say_line_length__too_high(self):
        self._assert(conf_data=self.MAX_SAY_LINE_LENGTH__MAX+1, expected=self.MAX_SAY_LINE_LENGTH__MAX)


class Test_bf3_config_message_delay(AbstractParser_TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration/>""")
        self.parser = ConcretegameParser(self.conf)

        self.MESSAGE_DELAY__DEFAULT = self.parser._settings['message_delay']
        self.MESSAGE_DELAY__MIN = .5
        self.MESSAGE_DELAY__MAX = 3

        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)


    def _test_message_delay(self, conf_data=None, expected=None):
        self.conf.loadFromString("""
            <configuration>
                <settings name="thegame">%s</settings>
            </configuration>
            """ % (('<set name="message_delay">%s</set>' % conf_data) if conf_data is not None else ''))
        self.parser.load_config_message_delay()
        if expected:
            self.assertEqual(expected, self.parser._settings['message_delay'])


    def test_message_delay__None(self):
        self._test_message_delay(conf_data=None, expected=self.MESSAGE_DELAY__DEFAULT)

    def test_message_delay__empty(self):
        self._test_message_delay(conf_data='', expected=self.MESSAGE_DELAY__DEFAULT)

    def test_message_delay__nan(self):
        self._test_message_delay(conf_data='foo', expected=self.MESSAGE_DELAY__DEFAULT)

    def test_message_delay__too_low(self):
        self._test_message_delay(conf_data=self.MESSAGE_DELAY__MIN-.1, expected=self.MESSAGE_DELAY__MIN)

    def test_message_delay__minimum(self):
        self._test_message_delay(conf_data=self.MESSAGE_DELAY__MIN, expected=self.MESSAGE_DELAY__MIN)

    def test_message_delay__2(self):
        self._test_message_delay(conf_data='2', expected=2)

    def test_message_delay__maximum(self):
        self._test_message_delay(conf_data=self.MESSAGE_DELAY__MAX, expected=self.MESSAGE_DELAY__MAX)

    def test_message_delay__too_high(self):
        self._test_message_delay(conf_data=self.MESSAGE_DELAY__MAX+1, expected=self.MESSAGE_DELAY__MAX)



########################################################################################################################
#
#  T E S T    O T H E R    S T U F F
#
########################################################################################################################
class Map_related_TestCase(AbstractParser_TestCase):
    """
    Test case that controls replies given by the parser write method as follow :

    ## mapList.list
    Responds with the maps found on test class properties 'maps'.
    Response contains 5 maps at most ; to get other maps, you have to use the 'StartOffset' command parameter that appears
    from BF3 R12 release.

    ## mapList.getMapIndices
    Responds with the value of the test class property 'map_indices'.

    ## getEasyName
    Responds with whatever argument was passed to it.

    ## getGameMode
    Responds with whatever argument was passed to it.
    """

    maps = (
        ('MP_001 ', 'ConquestLarge0', '2'),
        ('MP_002 ', 'Rush0', '2'),
        ('MP_003 ', 'ConquestLarge0', '2'),
        )
    map_indices = [1, 2]

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        self.parser.startup()

        # simulate responses we can expect from the rcon command mapList.list
        def write(data):
            if type(data) in (tuple, list):
                if data[0].lower() == 'maplist.list':
                    offset = 0
                    if len(data) > 1:
                        try:
                            offset = int(data[1])
                        except ValueError:
                            raise CommandFailedError(['InvalidArguments'])
                            # simulate that the Frostbite2 server responds with 5 maps at most for the mapList.list command
                    maps_to_send = self.__class__.maps[offset:offset + 5]
                    return [len(maps_to_send), 3] + list(reduce(tuple.__add__, maps_to_send, tuple()))
                elif data[0].lower() == 'maplist.getmapindices':
                    return self.__class__.map_indices
            return []

        self.parser.write = Mock(side_effect=write)

        self.parser.getEasyName = Mock(side_effect=lambda x: x)
        self.parser.getGameMode = Mock(side_effect=lambda x: x)



class Test_getNextMap(Map_related_TestCase):
    def test_empty(self):
        # setup context
        Map_related_TestCase.maps = tuple()
        Map_related_TestCase.map_indices = [0, 0]
        self.parser.game.serverinfo = {'roundsTotal': 2}
        self.parser.game.mapName = 'map_foo'
        self.parser.game.gameType = 'gametype_foo'
        # verify
        self.assertEqual('map_foo (gametype_foo) 2 rounds', self.parser.getNextMap())

    def test_one_map(self):
        # setup context
        Map_related_TestCase.maps = (('MP_001', 'ConquestLarge0', '3'),)
        Map_related_TestCase.map_indices = [0, 0]
        # verify
        self.assertEqual('MP_001 (ConquestLarge0) 3 rounds', self.parser.getNextMap())

    def test_two_maps_0(self):
        # setup context
        Map_related_TestCase.maps = (
            ('MP_001', 'ConquestLarge0', '1'),
            ('MP_002', 'Rush0', '1'),
            )
        Map_related_TestCase.map_indices = [0, 0]
        # verify
        self.assertEqual('MP_001 (ConquestLarge0) 1 round', self.parser.getNextMap())

    def test_two_maps_1(self):
        # setup context
        Map_related_TestCase.maps = (
            ('MP_001', 'ConquestLarge0', '2'),
            ('MP_002', 'Rush0', '1'),
            )
        Map_related_TestCase.map_indices = [0, 1]
        # verify
        self.assertEqual('MP_002 (Rush0) 1 round', self.parser.getNextMap())


class Test_getFullMapRotationList(Map_related_TestCase):
    """
    getFullMapRotationList is a method of AbstractParser that calls the Frostbite2 mapList.list command the number of
    times required to obtain the exhaustive list of map in the current rotation list.
    """

    @classmethod
    def setUpClass(cls):
        super(Test_getFullMapRotationList, cls).setUpClass()
        Map_related_TestCase.map_indices = [0, 0]


    def test_empty(self):
        # setup context
        Map_related_TestCase.maps = tuple()
        # verify
        mlb = self.parser.getFullMapRotationList()
        self.assertEqual(0, len(mlb))
        self.assertEqual(1, self.parser.write.call_count)

    def test_one_map(self):
        # setup context
        Map_related_TestCase.maps = (('MP_001', 'ConquestLarge0', '2'),)
        # verify
        mlb = self.parser.getFullMapRotationList()
        self.assertEqual('MapListBlock[MP_001:ConquestLarge0:2]', repr(mlb))
        self.assertEqual(2, self.parser.write.call_count)

    def test_two_maps(self):
        # setup context
        Map_related_TestCase.maps = (
            ('MP_001', 'ConquestLarge0', '2'),
            ('MP_002', 'Rush0', '1'),
            )
        # verify
        mlb = self.parser.getFullMapRotationList()
        self.assertEqual('MapListBlock[MP_001:ConquestLarge0:2, MP_002:Rush0:1]', repr(mlb))
        self.assertEqual(2, self.parser.write.call_count)


    def test_lots_of_maps(self):
        # setup context
        Map_related_TestCase.maps = (
            ('MP_001 ', 'ConquestLarge0', '2'), # first batch
            ('MP_002 ', 'ConquestLarge0', '2'),
            ('MP_003 ', 'ConquestLarge0', '2'),
            ('MP_004 ', 'ConquestLarge0', '2'),
            ('MP_005 ', 'ConquestLarge0', '2'),
            ('MP_006 ', 'ConquestLarge0', '2'), # 2nd
            ('MP_007 ', 'ConquestLarge0', '2'),
            ('MP_008 ', 'ConquestLarge0', '2'),
            ('MP_009 ', 'ConquestLarge0', '2'),
            ('MP_0010', 'ConquestLarge0', '2'),
            ('MP_0011', 'ConquestLarge0', '2'), # 3rd
            ('MP_0012', 'ConquestLarge0', '2'),
            )
        # verify
        mlb = self.parser.getFullMapRotationList()
        self.assertEqual(12, len(mlb))
        # check in details what were the 4 calls made to the write method
        assert [
            ((('mapList.list', 0),), {}),
            ((('mapList.list', 5),), {}),
            ((('mapList.list', 10),), {}),
            ((('mapList.list', 15),), {}),
        ], self.parser.write.call_args_list


class Test_getFullBanList(AbstractParser_TestCase):
    """
    getFullBanList is a method of AbstractParser that calls the Frostbite2 banList.list command the number of
    times required to obtain the exhaustive list of bans.
    """

    bans = (
        ('name', 'Joe', 'perm', '0', '0', 'Banned by admin'),
        ('name', 'Jack', 'rounds', '0', '4', 'tk'),
        ('name', 'Averell', 'seconds', '3576', '0', 'being stupid'),
        ('name', 'William', 'perm', '0', '0', 'hacking'),
        )

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        self.parser.startup()

        # simulate responses we can expect from the rcon command mapList.list
        def write(data):
            if type(data) in (tuple, list):
                if data[0].lower() == 'banlist.list':
                    offset = 0
                    if len(data) > 1:
                        try:
                            offset = int(data[1])
                        except ValueError:
                            raise CommandFailedError(['InvalidArguments'])
                            # simulate that the Frostbite2 server responds with 5 bans at most for the banList.list command
                    bans_to_send = self.__class__.bans[offset:offset + 5]
                    return list(reduce(tuple.__add__, bans_to_send, tuple()))
            return []

        self.parser.write = Mock(side_effect=write)




    def test_empty(self):
        # setup context
        self.__class__.bans = tuple()
        # verify
        bl = self.parser.getFullBanList()
        self.assertEqual(0, len(bl))
        self.assertEqual(1, self.parser.write.call_count)

    def test_one_ban(self):
        # setup context
        self.__class__.bans = (('name', 'Foo1 ', 'perm', '0', '0', 'Banned by admin'),)
        # verify
        mlb = self.parser.getFullBanList()
        self.assertEqual(
            "BanlistContent[{'idType': 'name', 'seconds_left': '0', 'reason': 'Banned by admin', 'banType': 'perm', 'rounds_left': '0', 'id': 'Foo1 '}]"
            , repr(mlb))
        self.assertEqual(2, self.parser.write.call_count)

    def test_two_bans(self):
        # setup context
        self.__class__.bans = (
            ('name', 'Foo1 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo2 ', 'perm', '0', '0', 'Banned by admin'),
            )
        # verify
        mlb = self.parser.getFullBanList()
        self.assertEqual("BanlistContent[{'idType': 'name', 'seconds_left': '0', 'reason': 'Banned by admin', 'banType': 'perm', 'rounds_left': '0', 'id': 'Foo1 '}, \
{'idType': 'name', 'seconds_left': '0', 'reason': 'Banned by admin', 'banType': 'perm', 'rounds_left': '0', 'id': 'Foo2 '}]"
            , repr(mlb))
        self.assertEqual(2, self.parser.write.call_count)


    def test_lots_of_bans(self):
        # setup context
        self.__class__.bans = (
            ('name', 'Foo1 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo2 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo3 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo4 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo5 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo6 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo7 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo8 ', 'perm', '0', '0', 'Banned by admin'),
            ('name', 'Foo9 ', 'perm', '0', '0', 'Banned by admin'),
            )
        # verify
        mlb = self.parser.getFullBanList()
        self.assertEqual(9, len(mlb))
        # check in details what were the 3 calls made to the write method
        assert [
            ((('banList.list', 0),), {}),
            ((('banList.list', 5),), {}),
            ((('banList.list', 10),), {}),
        ], self.parser.write.call_args_list


class Test_patch_b3_clients_getByMagic(AbstractParser_TestCase):
    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        # setup context
        self.foobar = self.parser.clients.newClient(cid='Foobar', name='Foobar', guid="aaaaaaa5555555")
        self.joe = self.parser.clients.newClient(cid='joe', name='joe', guid="bbbbbbbb5555555")
        self.jack = self.parser.clients.newClient(cid='jack', name='jack', guid="ccccccccc5555555")
        self.jacky = self.parser.clients.newClient(cid='jacky', name='jacky', guid="ddddddddd5555555")
        self.p123456 = self.parser.clients.newClient(cid='123456', name='123456', guid="eeeeeee5555555")


    def test_exact_name(self):
        self.assertEqual([self.foobar], self.parser.clients.getByMagic('Foobar'))
        self.assertEqual([self.foobar], self.parser.clients.getByMagic('fOObAr'))

    def test_partial_name(self):
        self.assertEqual([self.foobar], self.parser.clients.getByMagic('foo'))
        self.assertEqual([self.foobar], self.parser.clients.getByMagic('oba'))
        self.assertSetEqual(set([self.jacky, self.jack]), set(self.parser.clients.getByMagic('jac')))
        self.assertSetEqual(set([self.jacky, self.jack]), set(self.parser.clients.getByMagic('jack')))

    def test_player_123456_with_exact_name(self):
        self.assertEqual([self.p123456], self.parser.clients.getByMagic('123456'))

    def test_player_123456_with_partial_name(self):
        """
        This test will fail if the b3.clients.Clients.getByMagic method was not patched
        """
        self.assertEqual([self.p123456], self.parser.clients.getByMagic('345'))


class Test_patch_b3_client_yell(AbstractParser_TestCase):
    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = ConcretegameParser(self.conf)
        self.parser._settings['big_msg_duration'] = '3.1'
        # setup context
        self.joe = self.parser.clients.newClient(cid='joe', name='joe', guid="bbbbbbbb5555555")


    def test_client_yell(self):
        with patch.object(AbstractParser, 'write') as write_mock:

            self.joe.yell('test')
            self.joe.yell('test2')
            self.joe.yell('test3')

            self.assertTrue(write_mock.called)
            write_mock.assert_any_call(('admin.yell', '[pm] test', '3', 'player', 'joe'))
            write_mock.assert_any_call(('admin.yell', '[pm] test2', '3', 'player', 'joe'))
            write_mock.assert_any_call(('admin.yell', '[pm] test3', '3', 'player', 'joe'))



########NEW FILE########
__FILENAME__ = test_util
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

import unittest2 as unittest
from b3.parsers.frostbite2.util import BanlistContent, BanlistContentError, PlayerInfoBlock, TeamScoresBlock, MapListBlock, MapListBlockError


class Test_BanlistContent(unittest.TestCase):

    def test_bad(self):
        self.assertRaises(BanlistContentError, BanlistContent, ['x'])
        self.assertRaises(BanlistContentError, BanlistContent, ['a1','a2','a3'])
        self.assertRaises(BanlistContentError, BanlistContent, ['a1','a2','a3','a4','a5'])
        self.assertRaises(BanlistContentError, BanlistContent, ['a1','a2','a3','a4','a5','a6','a7'])
        self.assertRaises(BanlistContentError, BanlistContent, 'foo')

    def test_minimal(self):
        blc = BanlistContent([])
        self.assertEqual(0, len(blc))
        self.assertEqual('BanlistContent[]', repr(blc))
        blc = BanlistContent()
        self.assertEqual(0, len(blc))
        self.assertEqual('BanlistContent[]', repr(blc))
        blc = BanlistContent(['name', 'Averell', 'seconds', '3600', '0', 'reason 2'])
        self.assertEqual(1, len(blc))
        self.assertEqual("BanlistContent[{'idType': 'name', 'seconds_left': '3600', 'reason': 'reason 2', 'banType': 'seconds', 'rounds_left': '0', 'id': 'Averell'}]", repr(blc))

    def test_1(self):
        bloc = BanlistContent([
            'name', 'William', 'perm', '0', '0', 'reason 1',
            'name', 'Averell', 'seconds', '3600', '0', 'reason 2',
        ])
        self.assertEqual(2, len(bloc))
        self.assertEqual("BanlistContent[{'idType': 'name', 'seconds_left': '0', 'reason': 'reason 1', 'banType': 'perm', 'rounds_left': '0', 'id': 'William'}, \
{'idType': 'name', 'seconds_left': '3600', 'reason': 'reason 2', 'banType': 'seconds', 'rounds_left': '0', 'id': 'Averell'}]", repr(bloc))

    def test_slice(self):
        bloc = BanlistContent([
            'name', 'William', 'perm', None , None, 'reason 1',
            'name', 'Averell', 'seconds', 3600, None , 'reason 2',
            'name', 'Jack', 'rounds', None, 2, 'reason 3',
            'name', 'Joe', 'seconds', 120 , None, 'reason 4',
            'guid', 'EA_ababab564ba654ba654ba', 'seconds', 120, None , 'reason 4',
        ])
        self.assertEqual(5, len(bloc))
        self.assertEqual(2, len(bloc[1:3]))
        print bloc[1:3]
        self.assertEqual('name', bloc[1:3][0]['idType'])
        self.assertEqual('Averell', bloc[1:3][0]['id'])
        self.assertEqual('seconds', bloc[1:3][0]['banType'])
        self.assertEqual(3600, bloc[1:3][0]['seconds_left'])
        self.assertEqual(None, bloc[1:3][0]['rounds_left'])
        self.assertEqual('reason 2', bloc[1:3][0]['reason'])

        self.assertEqual('name', bloc[1:3][1]['idType'])
        self.assertEqual('Jack', bloc[1:3][1]['id'])
        self.assertEqual('rounds', bloc[1:3][1]['banType'])
        self.assertEqual(None, bloc[1:3][1]['seconds_left'])
        self.assertEqual(2, bloc[1:3][1]['rounds_left'])
        self.assertEqual('reason 3', bloc[1:3][1]['reason'])


    def test_append(self):
        data1 = ['a1','a2','a3','a4','a5','a6', 'b1','b2','b3','b4','b5','b6']
        data2 = ['c1','c2','c3','c4','c5','a6']
        # check both data lists make valid MapListBlock individually
        blc1 = BanlistContent(data1)
        self.assertEqual(2, len(blc1))
        blc2 = BanlistContent(data2)
        self.assertEqual(1, len(blc2))
        # check both 2nd list can be appended to the 1st one.
        blc3 = BanlistContent(data1)
        blc3.append(data2)
        # check new list length
        blc3_length = len(blc3)
        self.assertEqual(len(blc1) + len(blc2), blc3_length)
        # check appending empty stuff does not affect current length
        blc3.append([])
        self.assertEqual(blc3_length, len(blc3))



class Test_PlayerInfoBlock(unittest.TestCase):

    def test_no_param(self):
        self.assertRaises(TypeError, PlayerInfoBlock, None)

    def test_none(self):
        self.assertRaises(TypeError, PlayerInfoBlock, (None,))

    def test_empty_list(self):
        self.assertRaises(TypeError, PlayerInfoBlock, ([],))

    def test_bad_list(self):
        self.assertRaises(TypeError, PlayerInfoBlock, ([None],))
        self.assertRaises(TypeError, PlayerInfoBlock, ([0],))
        self.assertRaises(TypeError, PlayerInfoBlock, ([0,1],))

    def test_minimal(self):
        self.assertEqual(0, len(PlayerInfoBlock([0,0])))
        self.assertEqual('PlayerInfoBlock[]', repr(PlayerInfoBlock([0,0])))
        self.assertEqual(0, len(PlayerInfoBlock(['0','0'])))
        self.assertEqual(0, len(PlayerInfoBlock(['1','test','0'])))
        self.assertEqual('PlayerInfoBlock[]', repr(PlayerInfoBlock(['1','test','0'])))

    def test_1(self):
        bloc = PlayerInfoBlock(['1','param1','1','blabla'])
        self.assertEqual(1, len(bloc))
        self.assertEqual('blabla', bloc[0]['param1'])
        self.assertEqual("PlayerInfoBlock[{'param1': 'blabla'}]", repr(bloc))

    def test_2(self):
        bloc = PlayerInfoBlock(['1','param1','2','bla1', 'bla2'])
        self.assertEqual(2, len(bloc))
        self.assertEqual('bla1', bloc[0]['param1'])
        self.assertEqual('bla2', bloc[1]['param1'])
        self.assertEqual("PlayerInfoBlock[{'param1': 'bla1'}{'param1': 'bla2'}]", repr(bloc))

    def test_3(self):
        bloc = PlayerInfoBlock(['2','param1','param2','2','bla1','bla2','foo1','foo2'])
        self.assertEqual(2, len(bloc))
        self.assertEqual('bla1', bloc[0]['param1'])
        self.assertEqual('bla2', bloc[0]['param2'])
        self.assertEqual('foo1', bloc[1]['param1'])
        self.assertEqual('foo2', bloc[1]['param2'])
        self.assertEqual("PlayerInfoBlock[{'param2': 'bla2', 'param1': 'bla1'}{'param2': 'foo2', 'param1': 'foo1'}]", repr(bloc))

    def test_slice(self):
        bloc = PlayerInfoBlock(['2','param1','param2','4','player0-p1','player0-p2','player1-p1','player1-p2', 'player2-p1','player2-p2','player3-p1','player3-p2' ])
        self.assertEqual(4, len(bloc))
        self.assertEqual(2, len(bloc[1:3]))
        self.assertEqual('player1-p1', bloc[1:3][0]['param1'])
        self.assertEqual('player1-p2', bloc[1:3][0]['param2'])
        self.assertEqual('player2-p1', bloc[1:3][1]['param1'])
        self.assertEqual('player2-p2', bloc[1:3][1]['param2'])
        self.assertEqual("[{'param2': 'player1-p2', 'param1': 'player1-p1'}, {'param2': 'player2-p2', 'param1': 'player2-p1'}]", repr(bloc[1:3]))

    def test_R38_no_player(self):
        bloc = PlayerInfoBlock(['8', 'name', 'guid', 'teamId', 'squadId', 'kills', 'deaths', 'score', 'rank', '0'])
        self.assertEqual(0, len(bloc))
        self.assertRaises(IndexError, bloc.__getitem__, 0)

    def test_R38_one_player(self):
        bloc = PlayerInfoBlock(['8', 'name', 'guid', 'teamId', 'squadId', 'kills', 'deaths', 'score', 'rank',
                                '1', 'Cucurbitaceae', '', '1', '1', '0', '0', '0', '58'])
        self.assertEqual(1, len(bloc))
        p1 = bloc[0]
        self.assertEqual("Cucurbitaceae", p1['name'])
        self.assertEqual("", p1['guid'])
        self.assertEqual("1", p1['teamId'])
        self.assertEqual("1", p1['squadId'])
        self.assertEqual("0", p1['kills'])
        self.assertEqual("0", p1['deaths'])
        self.assertEqual("0", p1['score'])
        self.assertEqual("58", p1['rank'])

class Test_TeamScoreBlock(unittest.TestCase):

    def test_no_param(self):
        self.assertRaises(TypeError, TeamScoresBlock, None)

    def test_none(self):
        self.assertRaises(TypeError, TeamScoresBlock, (None,))

    def test_empty_list(self):
        self.assertRaises(TypeError, TeamScoresBlock, ([],))

    def test_bad_list(self):
        self.assertRaises(TypeError, TeamScoresBlock, ([None],))
        self.assertRaises(TypeError, TeamScoresBlock, ([0],))
        self.assertRaises(TypeError, TeamScoresBlock, ([0,1],))

    def test_minimal(self):
        self.assertEqual(0, len(TeamScoresBlock([0,1000])))
        self.assertEqual('TeamScoresBlock[], target: 100', repr(TeamScoresBlock([0,100])))
        self.assertEqual(0, len(TeamScoresBlock(['0','0'])))
        self.assertEqual(1, len(TeamScoresBlock(['1','10','5000'])))
        self.assertEqual('TeamScoresBlock[10], target: 5000', repr(TeamScoresBlock(['1','10','5000'])))

    def test_1(self):
        bloc = TeamScoresBlock(['2','15','48','2500'])
        self.assertEqual(2, len(bloc))
        self.assertEqual(15, bloc[0])
        self.assertEqual(48, bloc[1])
        self.assertEqual(2500, bloc.get_target_score())
        self.assertEqual("TeamScoresBlock[15, 48], target: 2500", repr(bloc))



class Test_MapListBlock(unittest.TestCase):

    def test_no_param(self):
        self.assertEqual(0, len(MapListBlock()))

    def test_none(self):
        self.assertRaises(MapListBlockError, MapListBlock, (None,))

    def test_empty_list(self):
        self.assertRaises(MapListBlockError, MapListBlock, ([],))

    def test_bad_list(self):
        self.assertRaises(MapListBlockError, MapListBlock, ('foo',))
        self.assertRaises(MapListBlockError, MapListBlock, (['x'],))
        self.assertRaises(MapListBlockError, MapListBlock, ([None],))
        self.assertRaises(MapListBlockError, MapListBlock, ([0],))
        self.assertRaises(MapListBlockError, MapListBlock, ([0,1],))
        self.assertRaises(MapListBlockError, MapListBlock, ([0,'x'],))
        self.assertRaises(MapListBlockError, MapListBlock, (['a','b','c','d'],))
        self.assertRaises(MapListBlockError, MapListBlock, (['1','3', 'a1','b1','1', 'a2'],))
        self.assertRaises(MapListBlockError, MapListBlock, (['1','3', 'a1','b1','xxx'],))

    def test_minimal(self):
        self.assertEqual(0, len(MapListBlock([0,3])))
        self.assertEqual('MapListBlock[]', repr(MapListBlock([0,3])))
        self.assertEqual(0, len(MapListBlock(['0','3'])))
        tmp = MapListBlock(['1', '3', 'test','mode', '2'])
        self.assertEqual(1, len(tmp), repr(tmp))
        self.assertEqual('MapListBlock[]', repr(MapListBlock(['0','3'])))
        self.assertEqual(0, len(MapListBlock(['0','3']).getByName('MP_003')))

    def test_1(self):
        bloc = MapListBlock(['1', '3', 'test','mode', '2'])
        self.assertEqual(1, len(bloc))
        self.assertEqual('test', bloc[0]['name'])
        self.assertEqual('mode', bloc[0]['gamemode'])
        self.assertEqual(2, bloc[0]['num_of_rounds'])
        self.assertEqual("MapListBlock[test:mode:2]", repr(bloc))
        self.assertEqual(0, len(bloc.getByName('MP_003')))
        self.assertEqual(1, len(bloc.getByName('test')))

    def test_2(self):
        bloc = MapListBlock(['2','3','map1','mode1', '1', 'map2', 'mode2', '2'])
        self.assertEqual(2, len(bloc))
        self.assertEqual('map1', bloc[0]['name'])
        self.assertEqual('mode1', bloc[0]['gamemode'])
        self.assertEqual(1, bloc[0]['num_of_rounds'])
        self.assertEqual('map2', bloc[1]['name'])
        self.assertEqual('mode2', bloc[1]['gamemode'])
        self.assertEqual(2, bloc[1]['num_of_rounds'])
        self.assertEqual("MapListBlock[map1:mode1:1, map2:mode2:2]", repr(bloc))
        self.assertEqual(0, len(bloc.getByName('MP_003')))
        self.assertEqual(1, len(bloc.getByName('map1')))
        self.assertEqual(1, len(bloc.getByName('map2')))
        self.assertIn(0, bloc.getByName('map1'))
        self.assertIn(1, bloc.getByName('map2'))
        self.assertTrue(bloc.getByName('map1')[0]['gamemode'] == 'mode1')
        self.assertTrue(bloc.getByName('map2')[1]['gamemode'] == 'mode2')
        self.assertEqual(0, len(bloc.getByNameAndGamemode('map1', 'mode?')))
        self.assertEqual(1, len(bloc.getByNameAndGamemode('map1', 'mode1')))
        self.assertEqual(0, len(bloc.getByNameAndGamemode('map2', 'mode?')))
        self.assertEqual(1, len(bloc.getByNameAndGamemode('map2', 'mode2')))
        self.assertIn(0, bloc.getByNameAndGamemode('map1', 'mode1'))
        self.assertIn(1, bloc.getByNameAndGamemode('map2', 'mode2'))


    def test_3(self):
        bloc = MapListBlock(['3','3', 'map1','mode1','1', 'map2','mode2','2', 'map1','mode2','2'])
        self.assertEqual(3, len(bloc))
        self.assertEqual('map1', bloc[2]['name'])
        self.assertEqual('mode2', bloc[2]['gamemode'])
        self.assertEqual(0, len(bloc.getByName('MP_003')))
        self.assertEqual(2, len(bloc.getByName('map1')))
        self.assertEqual(1, len(bloc.getByName('map2')))
        self.assertEqual("MapListBlock[map1:mode1:1, map2:mode2:2, map1:mode2:2]", repr(bloc))
        self.assertIn(0, bloc.getByName('map1'))
        self.assertIn(1, bloc.getByName('map2'))
        self.assertIn(2, bloc.getByName('map1'))
        self.assertTrue(bloc.getByName('map1')[0]['gamemode'] == 'mode1')
        self.assertTrue(bloc.getByName('map1')[2]['gamemode'] == 'mode2')
        self.assertTrue(bloc.getByName('map2')[1]['gamemode'] == 'mode2')
        self.assertEqual(0, len(bloc.getByNameAndGamemode('map1', 'mode?')))
        self.assertEqual(1, len(bloc.getByNameAndGamemode('map1', 'mode1')))
        self.assertEqual(1, len(bloc.getByNameAndGamemode('map1', 'mode2')))
        self.assertEqual(0, len(bloc.getByNameAndGamemode('map2', 'mode?')))
        self.assertEqual(0, len(bloc.getByNameAndGamemode('map2', 'mode1')))
        self.assertEqual(1, len(bloc.getByNameAndGamemode('map2', 'mode2')))
        self.assertIn(0, bloc.getByNameAndGamemode('map1', 'mode1'))
        self.assertIn(1, bloc.getByNameAndGamemode('map2', 'mode2'))
        self.assertIn(2, bloc.getByNameAndGamemode('map1', 'mode2'))
        self.assertIn(2, bloc.getByNameGamemodeAndRounds('map1', 'mode2', '2'))


class Test_MapListBlock_append(unittest.TestCase):

    def test_append_list_with_different_num_words(self):
        data1 = [1, 3, 'a1','a2',1]
        data2 = [1, 4, 'b1','b2',1,'b4']
        # check both data lists make valid MapListBlock individually
        self.assertEqual(1, len(MapListBlock(data1)))
        self.assertEqual(1, len(MapListBlock(data2)))
        # check both 2nd list cannot be appended to the 1st one.
        mlb1 = MapListBlock(data1)
        self.assertEqual(3, mlb1._num_words)
        try:
            mlb1.append(data2)
        except MapListBlockError, err:
            self.assertIn('cannot append data', str(err), "expecting error message to contain 'cannot append data' but got %r instead" % err)
        except Exception, err:
            self.fail("expecting MapListBlockError but got %r instead" % err)
        else:
            self.fail("expecting MapListBlockError")


    def test_append_list_with_same_num_words(self):
        data1 = [1, 3, 'a1','a2',1]
        data2 = [1, 3, 'b1','b2',2]
        # check both data lists make valid MapListBlock individually
        mlb1 = MapListBlock(data1)
        self.assertEqual(1, len(mlb1))
        mlb2 = MapListBlock(data2)
        self.assertEqual(1, len(mlb2))
        # check both 2nd list can be appended to the 1st one.
        mlb3 = MapListBlock(data1)
        mlb3.append(data2)
        # check new list length
        self.assertEqual(len(mlb1) + len(mlb2), len(mlb3))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_HomefrontParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 self.courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.parsers.homefront import HomefrontParser
from mock import Mock, sentinel
import b3
import unittest2 as unittest

 
class Test_HomefrontParser(unittest.TestCase):

    def setUp(self):
        # prepare mocks
        self.mock_parser = Mock(spec=HomefrontParser)
        self.mock_parser._reSteamId64 = HomefrontParser._reSteamId64
        self.mock_parser.onServerKill = HomefrontParser.onServerKill

        self.courgette = Mock(spec=b3.clients.Client, name="courgette")
        self.freelander = Mock(spec=b3.clients.Client, name="freelander")
        
        def getClient(name):
            if name == 'courgette': return self.courgette
            elif name == 'Freelander': return self.freelander
            else: return Mock(spec=b3.clients.Client)
        self.mock_parser.getClient = getClient

        def getByGUID(guid):
            if guid == '12311111111111111': return self.courgette
            elif guid == '12300000000000000': return self.freelander
            else: return Mock(spec=b3.clients.Client)
        self.mock_parser.clients.getByGUID = getByGUID


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False


    def test_unmeaningful_data(self):
        self.assertIsNone(self.mock_parser.onServerKill(self.mock_parser, "qsdf"))


    def test_teamkill_with_names(self):
        self.mock_parser.reset_mock()
        self.courgette.team = self.freelander.team = sentinel.DEFAULT
        self.mock_parser.onServerKill(self.mock_parser, "courgette EXP_Frag Freelander")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_KILL_TEAM', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.freelander, getEvent_args[3])

    def test_teamkill_with_steamid(self):
        self.mock_parser.reset_mock()
        self.courgette.team = self.freelander.team = sentinel.DEFAULT
        self.mock_parser.onServerKill(self.mock_parser, "12311111111111111 EXP_Frag 12300000000000000")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_KILL_TEAM', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.freelander, getEvent_args[3])


    def test_kill_with_names(self):
        self.mock_parser.reset_mock()
        self.mock_parser.onServerKill(self.mock_parser, "courgette EXP_Frag Freelander")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_KILL', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.freelander, getEvent_args[3])

    def test_kill_with_steamid(self):
        self.mock_parser.reset_mock()
        self.mock_parser.onServerKill(self.mock_parser, "12311111111111111 EXP_Frag 12300000000000000")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_KILL', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.freelander, getEvent_args[3])


    def test_suicide_with_names(self):
        self.mock_parser.reset_mock()
        self.mock_parser.onServerKill(self.mock_parser, "courgette EXP_Frag courgette")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_SUICIDE', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.courgette, getEvent_args[3])

    def test_suicide_with_steamid(self):
        self.mock_parser.reset_mock()
        self.mock_parser.onServerKill(self.mock_parser, "12311111111111111 EXP_Frag 12311111111111111")
        self.assertTrue(self.mock_parser.getEvent.called)
        getEvent_args = self.mock_parser.getEvent.call_args[0]
        self.assertEqual('EVT_CLIENT_SUICIDE', getEvent_args[0])
        self.assertEqual('EXP_Frag', getEvent_args[1][1])
        self.assertEqual(self.courgette, getEvent_args[2])
        self.assertEqual(self.courgette, getEvent_args[3])
        
        

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_abstractParser
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.parsers.q3a.abstractParser import AbstractParser
from mock import Mock
import unittest2 as unittest

class Test(unittest.TestCase):


    def test_getCvar(self):
        # prepare mocks
        mock_parser = Mock(spec=AbstractParser)
        mock_parser._reCvarName = AbstractParser._reCvarName
        mock_parser._reCvar = AbstractParser._reCvar
        mock_parser.getCvar = AbstractParser.getCvar
        
        def assertGetCvar(cvar_name, gameserver_response, expected_response):
            mock_parser.write = Mock(return_value=gameserver_response)
            cvar = mock_parser.getCvar(mock_parser, cvar_name)
            if cvar is None:
                self.assertEqual(expected_response, None)
            else:
                self.assertEqual(expected_response, (cvar.name, cvar.value, cvar.default))
        
        assertGetCvar('g_password', '"g_password" is:"^7" default:"scrim^7"', ("g_password", '', "scrim"))
        assertGetCvar('g_password', '"g_password" is:"^7" default:"^7"', ("g_password", '', ""))
        assertGetCvar('g_password', '"g_password" is:"test^7" default:"^7"', ("g_password", 'test', ""))
        assertGetCvar('g_password', 'whatever', None)
        assertGetCvar('g_password', '"g_password" is:"^7"', ("g_password", '', None))
        assertGetCvar('sv_maxclients', '"sv_maxclients" is:"16^7" default:"8^7"', ("sv_maxclients", '16', '8'))
        assertGetCvar('g_maxGameClients', '"g_maxGameClients" is:"0^7", the default', ("g_maxGameClients", '0', '0'))
        assertGetCvar('mapname', '"mapname" is:"ut4_abbey^7"', ("mapname", 'ut4_abbey', None))


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
########NEW FILE########
__FILENAME__ = test_arma2
# -*- encoding: utf-8 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import unittest2 as unittest
from mock import Mock, patch, call
from mockito import when
from b3.fake import FakeClient
from b3.parsers.arma2 import Arma2Parser
from b3.config import XmlConfigParser



class Arma2TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Arma2 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.battleye.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Arma2Parser -> AbstractParser -> FakeConsole -> Parser

    def tearDown(self):
        if hasattr(self, "parser"):
            self.parser.working = False





class EventParsingTestCase(Arma2TestCase):

    def setUp(self):
        """ran before each test"""
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = Arma2Parser(self.conf)
        self.parser.output = Mock() # mock Rcon

        self.evt_queue = []
        def queue_event(evt):
            self.evt_queue.append(evt)
        self.queueEvent_patcher = patch.object(self.parser, "queueEvent", wraps=queue_event)
        self.queueEvent_mock = self.queueEvent_patcher.start()

        self.write_patcher = patch.object(self.parser, "write")
        self.write_mock = self.write_patcher.start()

        self.parser.startup()


    def tearDown(self):
        """ran after each test to clean up"""
        Arma2TestCase.tearDown(self)
        self.queueEvent_patcher.stop()
        self.write_patcher.stop()
        if hasattr(self, "parser"):
            self.parser.working = False


    def clear_events(self):
        """
        clear the event queue, so when assert_has_event is called, it will look only at the newly caught events.
        """
        self.evt_queue = []


    def assert_has_event(self, event_type, data=None, client=None, target=None):
        """
        assert that self.evt_queue contains at least one event for the given type that has the given characteristics.
        """
        assert isinstance(event_type, basestring)

        def assert_event_equals(expected_event, actual_event):
            if expected_event is None:
                self.assertIsNone(actual_event)
            self.assertEqual(expected_event.type, actual_event.type, "expecting type %s, but got %s" %
                                                                     (self.parser.getEventKey(expected_event.type), self.parser.getEventKey(actual_event.type)))
            self.assertEqual(expected_event.client, actual_event.client, "expecting client %s, but got %s" % (expected_event.client, actual_event.client))
            self.assertEqual(expected_event.target, actual_event.target, "expecting target %s, but got %s" % (expected_event.target, actual_event.target))
            self.assertEqual(expected_event.data, actual_event.data, "expecting data %s, but got %s" % (expected_event.data, actual_event.data))

        expected_event = self.parser.getEvent(event_type, data, client, target)
        if not len(self.evt_queue):
            self.fail("expecting %s. Got no event instead" % expected_event)
        elif len(self.evt_queue) == 1:
            assert_event_equals(expected_event, self.evt_queue[0])
        else:
            for evt in self.evt_queue:
                try:
                    assert_event_equals(expected_event, evt)
                    return
                except Exception:
                    pass
            self.fail("expecting event %s. Got instead: %s" % (expected_event, map(str, self.evt_queue)))


    ################################################################################################################



class Test_game_events_parsing(EventParsingTestCase):

    def test_player_connected(self):
        # GIVEN
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""Player #0 Bravo17 (76.108.91.78:2304) connected""")
        # THEN
        self.assertEqual(1, len(self.evt_queue))
        event = self.evt_queue[0]
        self.assertEqual(self.parser.getEventID("EVT_CLIENT_CONNECT"), event.type)
        self.assertEqual("Bravo17", event.client.name)
        self.assertEqual("0", event.client.cid)
        self.assertEqual("76.108.91.78", event.client.ip)


    def test_Verified_guid__with_connected_player(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17")
        bravo17.connects("0")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""Verified GUID (80a5885ebe2420bab5e158a310fcbc7d) of player #0 Bravo17""")
        # THEN
        self.assert_has_event("EVT_CLIENT_AUTH", data=bravo17, client=bravo17)


    def test_Verified_guid__with_unknown_player(self):
        # GIVEN
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""Verified GUID (80a5885ebe2420bab5e158a310fcbc7d) of player #0 Bravo17""")
        # THEN
        self.assertTrue(len(self.evt_queue))
        event = self.evt_queue[0]
        self.assertEqual(self.parser.getEventID("EVT_CLIENT_CONNECT"), event.type)
        self.assertEqual("Bravo17", event.client.name)
        self.assertEqual("0", event.client.cid)
        bravo17 = event.client
        self.assert_has_event("EVT_CLIENT_AUTH", data=bravo17, client=bravo17)


    def test_player_disconnect(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""Player #12 Bravo17 disconnected""")
        # THEN
        self.assert_has_event("EVT_CLIENT_DISCONNECT", client=bravo17, data='12')


    def test_Lobby_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Lobby) Bravo17: hello b3""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='hello b3 (Lobby)')


    def test_Global_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Global) Bravo17: global channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='global channel (Global)')


    def test_Direct_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Direct) Bravo17: test direct channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='test direct channel (Direct)')


    def test_Vehicule_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Vehicle) Bravo17: test vehicle channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='test vehicle channel (Vehicle)')


    def test_Group_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Group) Bravo17: test group channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='test group channel (Group)')


    def test_Side_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Side) Bravo17: test side channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='test side channel (Side)')


    def test_Command_chat(self):
        # GIVEN
        bravo17 = FakeClient(self.parser, name="Bravo17", guid="80a5885ebe2420bab5e158a310fcbc7d")
        bravo17.connects("12")
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent("""(Command) Bravo17: test command channel""")
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", client=bravo17, data='test command channel (Command)')


class Test_utf8_issues(EventParsingTestCase):

    def test_player_connected_utf8(self):
        # GIVEN
        self.clear_events()
        # WHEN routeBattleyeMessagePacket is given a UTF-8 encoded message
        self.parser.routeBattleyeEvent(u"""Player #0 F00xx (11.1.1.8:2304) connected""")
        # THEN
        self.assertEqual(1, len(self.evt_queue))
        event = self.evt_queue[0]
        self.assertEqual(self.parser.getEventID("EVT_CLIENT_CONNECT"), event.type)
        self.assertEqual(u"F00xx", event.client.name)


    def test_player_connected_utf8_2(self):
        # GIVEN
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent(u'Player #1 toiltst (77.205.193.131:2304) connected')
        # THEN
        self.assertEqual(1, len(self.evt_queue))
        event = self.evt_queue[0]
        self.assertEqual(self.parser.getEventID("EVT_CLIENT_CONNECT"), event.type)
        self.assertEqual(u"toiltst", event.client.name)


    def test_verified_guid(self):
        # GIVEN
        self.clear_events()
        # WHEN
        self.parser.routeBattleyeEvent(u'Verified GUID (a4c3eba0a790300fd7d9d39e26e00eb0) of player #1 toiltst')
        # THEN
        self.assertTrue(len(self.evt_queue))
        event = self.evt_queue[0]
        self.assertEqual(self.parser.getEventID("EVT_CLIENT_CONNECT"), event.type)
        self.assertEqual(u"toiltst", event.client.name)





@patch('time.sleep')
class Test_parser_API(Arma2TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = Arma2Parser(self.conf)
        self.parser.output = Mock()

        self.parser.sayqueue.put = Mock(side_effect=self.parser._say)

        self.parser.startup()

        self.player = self.parser.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def test_getPlayerList(self, sleep_mock):
        # GIVEN
        when(self.parser.output).write('players').thenReturn(u'''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
0   11.111.11.11:2304     63   80a5885eb00000000000000000000000(OK) toil
0   192.168.0.100:2316    0    80a5885eb00000000000000000000000(OK) toil (Lobby)
(1 players in total)
''')
        # WHEN
        players = self.parser.getPlayerList()
        # THEN
        self.maxDiff = 1024
        self.assertDictEqual({u'0': {'cid': u'0',
                                     'guid': u'80a5885eb00000000000000000000000',
                                     'ip': u'192.168.0.100',
                                     'lobby': True,
                                     'name': u'toil',
                                     'ping': u'0',
                                     'port': u'2316',
                                     'verified': u'OK'}}, players)


    def test_say(self, sleep_mock):
        # GIVEN
        self.parser.msgPrefix = "[Pre]"
        # WHEN
        self.parser.say("f00")
        # THEN
        self.parser.output.write.assert_has_calls([call('say -1 [Pre] f00')])


    def test_saybig(self, sleep_mock):
        # GIVEN
        self.parser.msgPrefix = "[Pre]"
        # WHEN
        self.parser.saybig("f00")
        # THEN
        self.parser.output.write.assert_has_calls([call('say -1 [Pre] f00')])


    def test_message(self, sleep_mock):
        # GIVEN
        self.parser.msgPrefix = "[Pre]"
        # WHEN
        self.parser.message(self.player, "f00")
        # THEN
        self.parser.output.write.assert_has_calls([call('say 4 [Pre] f00')])


    def test_kick(self, sleep_mock):
        self.parser.kick(self.player, reason="f00")
        self.parser.output.write.assert_has_calls([call('kick 4 f00')])


    def test_ban__by_cid(self, sleep_mock):
        self.assertIsNotNone(self.player.cid)
        self.parser.ban(self.player, reason="f00")
        self.parser.output.write.assert_has_calls([call('ban 4 0 f00'), call('writeBans')])


    def test_ban__by_guid(self, sleep_mock):
        self.player.cid = None
        self.assertIsNone(self.player.cid)
        self.parser.ban(self.player, reason="f00")
        self.parser.output.write.assert_has_calls([call('addBan theGuid 0 f00'), call('writeBans')])


    def test_unban(self, sleep_mock):
        # GIVEN
        self.player.cid = None
        self.assertIsNone(self.player.cid)
        when(self.parser).getBanlist().thenReturn({
            'theGuid': {'ban_index': '152', 'guid': 'theGuid', 'reason': 'the ban reason', 'min_left': 'perm'},
            })
        # WHEN
        self.parser.unban(self.player, reason="f00")
        # THEN
        self.parser.output.write.assert_has_calls([call('removeBan 152'), call('writeBans')])


    def test_tempban__by_cid(self, sleep_mock):
        self.assertIsNotNone(self.player.cid)
        self.parser.tempban(self.player, reason="f00", duration='2h')
        self.parser.output.write.assert_has_calls([call('ban 4 120 f00'),
                                                   call('writeBans')])


    def test_tempban__by_guid(self, sleep_mock):
        self.player.cid = None
        self.assertIsNone(self.player.cid)
        self.parser.tempban(self.player, reason="f00", duration='2h')
        self.parser.output.write.assert_has_calls([call('addBan theGuid 120 f00'),
                                                   call('writeBans')])

#
#    def test_getMap(self, sleep_mock):
#        pass
#
#
#    def test_getMaps(self, sleep_mock):
#        pass
#
#
#    def test_rotateMap(self, sleep_mock):
#        pass
#
#
#    def test_changeMap(self, sleep_mock):
#        pass


    def test_getPlayerPings(self, sleep_mock):
        # GIVEN
        when(self.parser.output).write('players').thenReturn(u'''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
0   76.108.91.78:2304     63   80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17
0   192.168.0.100:2316    0    80a5885ebe2420bab5e158a310fcbc7d(OK) Bravo17 (Lobby)
2   111.22.3.4:2316       47   80a50000000000000000000000fcbc7d(?)  bob
(1 players in total)
''')
        # WHEN
        pings = self.parser.getPlayerPings()
        # THEN
        self.maxDiff = 1024
        self.assertDictEqual({u'0': 63, u'2': 47}, pings)

#
#    def test_getPlayerScores(self, sleep_mock):
#        pass


class test_sync(EventParsingTestCase):

    def test_known_client_with_unverified_guid_but_same_ip_is_auth(self):
        # GIVEN a known client Bob
        bob = FakeClient(self.parser, name="bob", guid="80a50000000000000000000000fcbc7d", ip="111.22.3.4")
        bob.save()
        # WHEN
        when(self.parser.output).write('players').thenReturn('''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
2   111.22.3.4:2316       47   80a50000000000000000000000fcbc7d(?)  bob
(1 players in total)
''')
        rv = self.parser.sync()
        # THEN
        self.assertIn('2', rv)
        client = rv["2"]
        self.assertEqual(bob.guid, client.guid)
        self.assertEqual(bob.ip, client.ip)
        self.assertTrue(client.authed)


    def test_known_client_with_unverified_guid_and_different_ip_is_not_auth(self):
        # GIVEN a known client Bob
        bob = FakeClient(self.parser, name="bob", guid="80a50000000000000000000000fcbc7d", ip="1.2.3.4")
        bob.save()
        # WHEN
        when(self.parser.output).write('players').thenReturn('''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
2   4.6.8.10:2316       47   80a50000000000000000000000fcbc7d(?)  bob
(1 players in total)
''')
        rv = self.parser.sync()
        # THEN
        self.assertIn('2', rv)
        client = rv["2"]
        self.assertEqual("bob", client.name)
        self.assertEqual("4.6.8.10", client.ip)
        self.assertEqual('', client.guid)
        self.assertFalse(client.authed)


    def test_unknown_client_with_unverified_guid(self):
        # WHEN
        when(self.parser.output).write('players').thenReturn('''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
2   4.6.8.10:2316       47   80a50000000000000000000000fcbc7d(?)  bob
(1 players in total)
''')
        rv = self.parser.sync()
        # THEN
        self.assertIn('2', rv)
        client = rv["2"]
        self.assertEqual("bob", client.name)
        self.assertEqual("4.6.8.10", client.ip)
        self.assertEqual('', client.guid)
        self.assertFalse(client.authed)

    def test_unknown_client_with_verified_guid(self):
        # WHEN
        when(self.parser.output).write('players').thenReturn('''\
Players on server:
[#] [IP Address]:[Port] [Ping] [GUID] [Name]
--------------------------------------------------
2   4.6.8.10:2316       47   80a50000000000000000000000fcbc7d(OK)  bob
(1 players in total)
''')
        rv = self.parser.sync()
        # THEN
        self.assertIn('2', rv)
        client = rv["2"]
        self.assertEqual("bob", client.name)
        self.assertEqual("4.6.8.10", client.ip)
        self.assertEqual('80a50000000000000000000000fcbc7d', client.guid)
        self.assertTrue(client.authed)



class test_others(Arma2TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = Arma2Parser(self.conf)
        self.parser.output = Mock()
        self.parser.startup()
        self.player = self.parser.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def test_getBanlist(self):
        # GIVEN
        self.maxDiff = 1024
        when(self.parser.output).write("bans").thenReturn("""\
GUID Bans:
[#] [GUID] [Minutes left] [Reason]
----------------------------------------
0  b57c222222a76f458893641000000005 perm Script Detection: Gerk
1  8ac61111111cd2ff4235140000000026 perm Script Detection: setVehicleInit DoThis;""")
        # WHEN
        rv = self.parser.getBanlist()
        # THEN
        self.assertDictEqual({
            'b57c222222a76f458893641000000005': {'ban_index': '0', 'guid': 'b57c222222a76f458893641000000005', 'reason': 'Script Detection: Gerk', 'min_left': 'perm'},
            '8ac61111111cd2ff4235140000000026': {'ban_index': '1', 'guid': '8ac61111111cd2ff4235140000000026', 'reason': 'Script Detection: setVehicleInit DoThis;', 'min_left': 'perm'},
        }, rv)

########NEW FILE########
__FILENAME__ = test_bf3
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import os
import re
import unittest2 as unittest
from mock import Mock, DEFAULT, patch, call
from mockito import when, unstub
from b3.clients import Client, Clients
from b3.fake import FakeClient
from b3.parsers.bf3 import Bf3Parser, MAP_NAME_BY_ID, GAME_MODES_BY_MAP_ID, GAME_MODES_NAMES
from b3.config import XmlConfigParser
from b3.parsers.frostbite2.util import MapListBlock
from b3.plugins.admin import AdminPlugin

sleep_patcher = None
def setUpModule():
    sleep_patcher = patch("time.sleep")
    sleep_patcher.start()


# make sure to unpatch core B3 stuf
original_getByMagic = Clients.getByMagic
original_message = Client.message
original_disconnect = Clients.disconnect
def tearDownModule():
    Clients.getByMagic = original_getByMagic
    Client.message = original_message
    Clients.disconnect = original_disconnect
    if hasattr(Client, "messagequeueworker"):
        del Client.messagequeueworker
    if sleep_patcher:
        sleep_patcher.stop()


class BF3TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing BF3 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.frostbite2.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # BF3Parser -> AbstractParser -> FakeConsole -> Parser

    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False
        unstub()  # following unstubs ALL stubs!



class Test_getServerInfo(unittest.TestCase):

    def test_decodeServerinfo_pre_R9(self):
        self.assertDictContainsSubset({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '0',
            'team1score': None,
            'team2score': None,
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '0', '0', '', 'true', 'true', 'false', '5148', '455')))

        self.assertDictContainsSubset({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '1',
            'team1score': '47',
            'team2score': None,
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '1', '47', '0', '', 'true', 'true', 'false', '5148', '455')))

        self.assertDictContainsSubset({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '2',
            'team1score': '300',
            'team2score': '300',
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '2', '300', '300', '0', '', 'true', 'true', 'false', '5148', '455')))

        self.assertDictContainsSubset({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '1',
            'roundsTotal': '2',
            'numTeams': '3',
            'team1score': '300',
            'team2score': '215',
            'team3score': '25',
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '1', '2', '3', '300', '215', '25', '0', '', 'true', 'true', 'false', '5148', '455')))

        self.assertDictContainsSubset({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '1',
            'roundsTotal': '2',
            'numTeams': '4',
            'team1score': '300',
            'team2score': '215',
            'team3score': '25',
            'team4score': '84',
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '1', '2', '4', '300', '215', '25', '84', '0', '', 'true', 'true', 'false', '5148', '455')))

    def test_decodeServerinfo_R9(self):
        self.maxDiff = None
        self.assertDictEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '0',
            'team1score': None,
            'team2score': None,
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': '1.2.3.4:5445',
            'punkBusterVersion': '1.5',
            'joinQueueEnabled': 'false',
            'region': 'EU',
            'closestPingSite': '45',
            'country': 'FR',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '0', '0', '', 'true', 'true', 'false', '5148', '455', '1.2.3.4:5445', '1.5', 'false', 'EU', '45', 'FR')))

        self.assertDictEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '1',
            'team1score': '47',
            'team2score': None,
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': '1.2.3.4:5445',
            'punkBusterVersion': '1.5',
            'joinQueueEnabled': 'false',
            'region': 'EU',
            'closestPingSite': '45',
            'country': 'FR',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '1', '47', '0', '', 'true', 'true', 'false', '5148', '455', '1.2.3.4:5445', '1.5', 'false', 'EU', '45', 'FR')))

        self.assertDictEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '0',
            'roundsTotal': '2',
            'numTeams': '2',
            'team1score': '300',
            'team2score': '300',
            'team3score': None,
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': '1.2.3.4:5445',
            'punkBusterVersion': '1.5',
            'joinQueueEnabled': 'false',
            'region': 'EU',
            'closestPingSite': '45',
            'country': 'FR',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '0', '2', '2', '300', '300', '0', '', 'true', 'true', 'false', '5148', '455', '1.2.3.4:5445', '1.5', 'false', 'EU', '45', 'FR')))

        self.assertDictEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '1',
            'roundsTotal': '2',
            'numTeams': '3',
            'team1score': '300',
            'team2score': '215',
            'team3score': '25',
            'team4score': None,
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': '1.2.3.4:5445',
            'punkBusterVersion': '1.5',
            'joinQueueEnabled': 'false',
            'region': 'EU',
            'closestPingSite': '45',
            'country': 'FR',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '1', '2', '3', '300', '215', '25', '0', '', 'true', 'true', 'false', '5148', '455', '1.2.3.4:5445', '1.5', 'false', 'EU', '45', 'FR')))

        self.assertDictEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '1',
            'roundsTotal': '2',
            'numTeams': '4',
            'team1score': '300',
            'team2score': '215',
            'team3score': '25',
            'team4score': '84',
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': '1.2.3.4:5445',
            'punkBusterVersion': '1.5',
            'joinQueueEnabled': 'false',
            'region': 'EU',
            'closestPingSite': '45',
            'country': 'FR',
        }, Bf3Parser.decodeServerinfo(('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '1', '2', '4', '300', '215', '25', '84', '0', '', 'true', 'true', 'false', '5148', '455', '1.2.3.4:5445', '1.5', 'false', 'EU', '45', 'FR')))

    def test_getServerInfo_pre_R9(self):
        self.maxDiff = None
        bf3_response = ('BigBrotherBot #2', '0', '16', 'ConquestLarge0', 'MP_012', '1', '2',
                                  '4', '300', '215', '25', '84',
                                  '0', '', 'true', 'true', 'false', '5148', '455')
        parser = Mock(spec=Bf3Parser)
        parser.write = lambda x: bf3_response

        data = Bf3Parser.getServerInfo(parser)
        self.assertEqual(bf3_response, data)
        self.assertEqual(parser.game.sv_hostname, 'BigBrotherBot #2')
        self.assertEqual(parser.game.sv_maxclients, 16)
        self.assertEqual(parser.game.gameType, 'ConquestLarge0')
        self.assertFalse(parser._publicIp.called)
        self.assertFalse(parser._port.called)

        self.assertEqual({
            'serverName': 'BigBrotherBot #2',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'ConquestLarge0',
            'level': 'MP_012',
            'roundsPlayed': '1',
            'roundsTotal': '2',
            'numTeams': '4',
            'team1score': '300',
            'team2score': '215',
            'team3score': '25',
            'team4score': '84',
            'targetScore': '0',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '5148',
            'roundTime': '455',
            'gameIpAndPort': None,
            'punkBusterVersion': None,
            'joinQueueEnabled': None,
            'region': None,
            'closestPingSite': None,
            'country': None,
        }, parser.game.serverinfo)

    def test_getServerInfo_R9(self):

        bf3_response = ['i3D.net - BigBrotherBot #3 (FR)', '0', '16', 'SquadDeathMatch0', 'MP_013',
                        '0', '1','4', '0', '0', '0', '0', '50', '', 'true', 'true', 'false', '92480',
                        '4832', '4.5.6.7:542', '', '', 'EU', 'ams', 'DE']
        parser = Mock(spec=Bf3Parser)
        parser.write = lambda x: bf3_response

        data = Bf3Parser.getServerInfo(parser)
        self.assertEqual(bf3_response, data)
        self.assertEqual(parser.game.sv_hostname, 'i3D.net - BigBrotherBot #3 (FR)')
        self.assertEqual(parser.game.sv_maxclients, 16)
        self.assertEqual(parser.game.gameType, 'SquadDeathMatch0')
        self.assertEqual(parser._publicIp, '4.5.6.7')
        self.assertEqual(parser._gamePort, '542')
        self.assertEqual({
            'serverName': 'i3D.net - BigBrotherBot #3 (FR)',
            'numPlayers': '0',
            'maxPlayers': '16',
            'gamemode': 'SquadDeathMatch0',
            'level': 'MP_013',
            'roundsPlayed': '0',
            'roundsTotal': '1',
            'numTeams': '4',
            'team1score': '0',
            'team2score': '0',
            'team3score': '0',
            'team4score': '0',
            'targetScore': '50',
            'onlineState': '',
            'isRanked': 'true',
            'hasPunkbuster': 'true',
            'hasPassword': 'false',
            'serverUptime': '92480',
            'roundTime': '4832',
            'gameIpAndPort': '4.5.6.7:542',
            'punkBusterVersion': '',
            'joinQueueEnabled': '',
            'region': 'EU',
            'closestPingSite': 'ams',
            'country': 'DE',
        }, parser.game.serverinfo)



class Test_bf3_events(BF3TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = Bf3Parser(self.conf)
        self.parser.startup()
        # mock parser queueEvent method so we can make assertions on it later on
        self.parser.queueEvent = Mock(name="queueEvent method")
        self.joe = Mock(name="Joe", spec=Client)

    def test_cmd_rotateMap_generates_EVT_GAME_ROUND_END(self):
        # prepare fake BF3 server responses
        def fake_write(data):
            if data ==  ('mapList.getMapIndices', ):
                return [0, 1]
            else:
                return []
        self.parser.write = Mock(side_effect=fake_write)
        self.parser.getFullMapRotationList = Mock(return_value=MapListBlock(['4', '3', 'MP_007', 'RushLarge0', '4', 'MP_011', 'RushLarge0', '4', 'MP_012',
                                                                             'SquadRush0', '4', 'MP_013', 'SquadRush0', '4']))
        self.parser.rotateMap()
        self.assertEqual(1, self.parser.queueEvent.call_count)
        self.assertEqual(self.parser.getEventID("EVT_GAME_ROUND_END"), self.parser.queueEvent.call_args[0][0].type)
        self.assertIsNone(self.parser.queueEvent.call_args[0][0].data)


    def test_player_onChat_event_all(self):
        self.parser.getClient = Mock(return_value=self.joe)

        self.parser.routeFrostbitePacket(['player.onChat', 'Cucurbitaceae', 'test all', 'all'])
        self.assertEqual(1, self.parser.queueEvent.call_count)

        event = self.parser.queueEvent.call_args[0][0]
        self.assertEqual("Say", self.parser.getEventName(event.type))
        self.assertEquals('test all', event.data)
        self.assertEqual(self.joe, event.client)


    def test_player_onChat_event_team(self):
        self.parser.getClient = Mock(return_value=self.joe)

        self.parser.routeFrostbitePacket(['player.onChat', 'Cucurbitaceae', 'test team', 'team', '1'])
        self.assertEqual(1, self.parser.queueEvent.call_count)

        event = self.parser.queueEvent.call_args[0][0]
        self.assertEqual("Team Say", self.parser.getEventName(event.type))
        self.assertEquals('test team', event.data)
        self.assertEqual(self.joe, event.client)


    def test_player_onChat_event_squad(self):
        self.parser.getClient = Mock(return_value=self.joe)

        self.parser.routeFrostbitePacket(['player.onChat', 'Cucurbitaceae', 'test squad', 'squad', '1', '1'])
        self.assertEqual(1, self.parser.queueEvent.call_count)

        event = self.parser.queueEvent.call_args[0][0]
        self.assertEqual("Team Say", self.parser.getEventName(event.type))
        self.assertEquals('test squad', event.data)
        self.assertEqual(self.joe, event.client)


class Test_punkbuster_events(BF3TestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = Bf3Parser(self.conf)
        self.parser.startup()

    def pb(self, msg):
        return self.parser.OnPunkbusterMessage(action=None, data=[msg])

    def assert_pb_misc_evt(self, msg):
        assert str(self.pb(msg)).startswith('Event<EVT_PUNKBUSTER_MISC>')

    def test_PB_SV_BanList(self):
        self.assert_pb_misc_evt('PunkBuster Server: 1   b59ffffffffffffffffffffffffffc7d {13/15} "Cucurbitaceae" "87.45.14.2:3659" retest" ""')
        self.assert_pb_misc_evt('PunkBuster Server: 1   b59ffffffffffffffffffffffffffc7d {0/1440} "Cucurbitaceae" "87.45.14.2:3659" mlkjsqfd" ""')

        self.assertEquals(
            '''Event<EVT_PUNKBUSTER_UNKNOWN>(['PunkBuster Server: 1   (UnBanned) b59ffffffffffffffffffffffffffc7d {15/15} "Cucurbitaceae" "87.45.14.2:3659" retest" ""'], None, None)''',
            str(self.pb('PunkBuster Server: 1   (UnBanned) b59ffffffffffffffffffffffffffc7d {15/15} "Cucurbitaceae" "87.45.14.2:3659" retest" ""')))

        self.assert_pb_misc_evt('PunkBuster Server: Guid=b59ffffffffffffffffffffffffffc7d" Not Found in the Ban List')
        self.assert_pb_misc_evt('PunkBuster Server: End of Ban List (1 of 1 displayed)')

    def test_PB_UCON_message(self):
        result = self.pb('PunkBuster Server: PB UCON "ggc_85.214.107.154"@85.214.107.154:14516 [admin.say "GGC-Stream.com - Welcome Cucurbitaceae with the GUID 31077c7d to our server." all]\n')
        self.assertEqual('Event<EVT_PUNKBUSTER_UCON>({\'ip\': \'85.214.107.154\', \'cmd\': \'admin.say "GGC-Stream.com - Welcome Cucurbitaceae with the GUID 31077c7d to our server." all\', \'from\': \'ggc_85.214.107.154\', \'port\': \'14516\'}, None, None)', str(result))

    def test_PB_Screenshot_received_message(self):
        result = self.pb('PunkBuster Server: Screenshot C:\\games\\bf3\\173_199_73_213_25200\\862147\\bf3\\pb\\svss\\pb000709.png successfully received (MD5=4576546546546546546546546543E1E1) from 19 Jaffar [da876546546546546546546546547673(-) 111.22.33.111:3659]\n')
        self.assertEqual(r"Event<EVT_PUNKBUSTER_SCREENSHOT_RECEIVED>({'slot': '19', 'name': 'Jaffar', 'ip': '111.22.33.111', 'pbid': 'da876546546546546546546546547673', 'imgpath': 'C:\\games\\bf3\\173_199_73_213_25200\\862147\\bf3\\pb\\svss\\pb000709.png', 'port': '3659', 'md5': '4576546546546546546546546543E1E1'}, None, None)", str(result))

    def test_PB_SV_PList(self):
        self.assert_pb_misc_evt("PunkBuster Server: Player List: [Slot #] [GUID] [Address] [Status] [Power] [Auth Rate] [Recent SS] [O/S] [Name]")
        self.assert_pb_misc_evt('PunkBuster Server: End of Player List (0 Players)')

    def test_PB_Ver(self):
        self.assertIsNone(self.pb('PunkBuster Server: PunkBuster Server for BF3 (v1.839 | A1386 C2.279) Enabled\n'))

    def test_PB_SV_BanGuid(self):
        self.assert_pb_misc_evt('PunkBuster Server: Ban Added to Ban List')
        self.assert_pb_misc_evt('PunkBuster Server: Ban Failed')

    def test_PB_SV_UnBanGuid(self):
        self.assert_pb_misc_evt('PunkBuster Server: Guid b59f190e5ef725e06531387231077c7d has been Unbanned')

    def test_PB_SV_UpdBanFile(self):
        self.assert_pb_misc_evt("PunkBuster Server: 0 Ban Records Updated in d:\\localuser\\g119142\\pb\\pbbans.dat")

    def test_misc(self):
        self.assertEqual("Event<EVT_PUNKBUSTER_LOST_PLAYER>({'slot': '1', 'ip': 'x.x.x.x', 'port': '3659', 'name': 'joe', 'pbuid': '0837c128293d42aaaaaaaaaaaaaaaaa'}, None, None)",
            str(self.pb("PunkBuster Server: Lost Connection (slot #1) x.x.x.x:3659 0837c128293d42aaaaaaaaaaaaaaaaa(-) joe")))

        self.assert_pb_misc_evt("PunkBuster Server: Invalid Player Specified: None")
        self.assert_pb_misc_evt("PunkBuster Server: Matched: Cucurbitaceae (slot #1)")
        self.assert_pb_misc_evt("PunkBuster Server: Received Master Security Information")
        self.assert_pb_misc_evt("PunkBuster Server: Auto Screenshot 000714 Requested from 25 Goldbat")


class Test_bf3_sends_no_guid(BF3TestCase):
    """
    See bug https://github.com/courgette/big-brother-bot/issues/69
    """
    def setUp(self):
        BF3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.loadFromString("<configuration/>")
        self.parser = Bf3Parser(self.conf)
        self.parser.startup()

        self.authorizeClients_patcher = patch.object(self.parser.clients, "authorizeClients")
        self.authorizeClients_patcher.start()

        self.write_patcher = patch.object(self.parser, "write")
        self.write_mock = self.write_patcher.start()

        self.event_raw_data = 'PunkBuster Server: 14 300000aaaaaabbbbbbccccc111223300(-) 11.122.103.24:3659 OK   1 3.0 0 (W) "Snoopy"'
        self.regex_for_OnPBPlistItem = [x for (x, y) in self.parser._punkbusterMessageFormats if y == 'OnPBPlistItem'][0]


    def tearDown(self):
        BF3TestCase.tearDown(self)
        self.authorizeClients_patcher.stop()
        self.write_mock = self.write_patcher.stop()


    def test_auth_client_without_guid_but_with_known_pbid(self):
        # GIVEN

        # known superadmin named Snoopy
        superadmin = Client(console=self.parser, name='Snoopy', guid='EA_AAAAAAAABBBBBBBBBBBBBB00000000000012222', pbid='300000aaaaaabbbbbbccccc111223300', group_bits=128, connections=21)
        superadmin.save()

        # bf3 server failing to provide guid
        def write(data):
            if data == ('admin.listPlayers', 'player', 'Snoopy'):
                return ['7', 'name', 'guid', 'teamId', 'squadId', 'kills', 'deaths', 'score', '1', 'Snoopy', '', '2', '8', '0', '0', '0']
            else:
                return DEFAULT
        self.write_mock.side_effect = write

        # WHEN
        self.assertFalse('Snoopy' in self.parser.clients)
        self.parser.OnPBPlayerGuid(match=re.match(self.regex_for_OnPBPlistItem, self.event_raw_data), data=self.event_raw_data)

        # THEN
        # B3 should have authed Snoopy
        self.assertTrue('Snoopy' in self.parser.clients)
        snoopy = self.parser.clients['Snoopy']
        self.assertTrue(snoopy.authed)
        for attb in ('name', 'pbid', 'guid', 'groupBits'):
            self.assertEqual(getattr(superadmin, attb), getattr(snoopy, attb))



    def test_does_not_auth_client_without_guid_and_unknown_pbid(self):
        # GIVEN
        # bf3 server failing to provide guid
        def write(data):
            if data == ('admin.listPlayers', 'player', 'Snoopy'):
                return ['7', 'name', 'guid', 'teamId', 'squadId', 'kills', 'deaths', 'score', '1', 'Snoopy', '', '2', '8', '0', '0', '0']
            else:
                return DEFAULT
        self.write_mock.side_effect = write

        # WHEN
        self.assertFalse('Snoopy' in self.parser.clients)
        self.parser.OnPBPlayerGuid(match=re.match(self.regex_for_OnPBPlistItem, self.event_raw_data), data=self.event_raw_data)

        # THEN
        # B3 should have authed Snoopy
        self.assertTrue('Snoopy' in self.parser.clients)
        snoopy = self.parser.clients['Snoopy']
        self.assertFalse(snoopy.authed)



class Test_bf3_maps(BF3TestCase):

    def setUp(self):
        BF3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = Bf3Parser(self.conf)


    def test_each_map_has_at_least_one_gamemode(self):
        for map_id in MAP_NAME_BY_ID:
            self.assertIn(map_id, GAME_MODES_BY_MAP_ID)
            self.assertGreater(len(GAME_MODES_BY_MAP_ID[map_id]), 0)


    def test_each_gamemode_is_valid(self):
        game_modes_found = set()
        map(game_modes_found.update, GAME_MODES_BY_MAP_ID.values())
        self.assertSetEqual(set(GAME_MODES_NAMES.keys()), game_modes_found)
        for game_mode in game_modes_found:
            self.assertIn(game_mode, GAME_MODES_NAMES)


    def test_getEasyName(self):
        self.assertEqual('Grand Bazaar', self.parser.getEasyName('MP_001'))
        self.assertEqual('Tehran Highway', self.parser.getEasyName('MP_003'))
        self.assertEqual('Caspian Border', self.parser.getEasyName('MP_007'))
        self.assertEqual('Seine Crossing', self.parser.getEasyName('MP_011'))
        self.assertEqual('Operation Firestorm', self.parser.getEasyName('MP_012'))
        self.assertEqual('Damavand Peak', self.parser.getEasyName('MP_013'))
        self.assertEqual('Noshahar Canals', self.parser.getEasyName('MP_017'))
        self.assertEqual('Kharg Island', self.parser.getEasyName('MP_018'))
        self.assertEqual('Operation Metro', self.parser.getEasyName('MP_Subway'))
        self.assertEqual('Strike At Karkand', self.parser.getEasyName('XP1_001'))
        self.assertEqual('Gulf of Oman', self.parser.getEasyName('XP1_002'))
        self.assertEqual('Sharqi Peninsula', self.parser.getEasyName('XP1_003'))
        self.assertEqual('Wake Island', self.parser.getEasyName('XP1_004'))
        self.assertEqual('Scrapmetal', self.parser.getEasyName('XP2_Factory'))
        self.assertEqual('Operation 925', self.parser.getEasyName('XP2_Office'))
        self.assertEqual('Donya Fortress', self.parser.getEasyName('XP2_Palace'))
        self.assertEqual('Ziba Tower', self.parser.getEasyName('XP2_Skybar'))
        self.assertEqual('Bandar Desert', self.parser.getEasyName('XP3_Desert'))
        self.assertEqual('Alborz Mountains', self.parser.getEasyName('XP3_Alborz'))
        self.assertEqual('Armored Shield', self.parser.getEasyName('XP3_Shield'))
        self.assertEqual('Death Valley', self.parser.getEasyName('XP3_Valley'))
        self.assertEqual('Epicenter', self.parser.getEasyName('XP4_Quake'))
        self.assertEqual('Markaz Monolith', self.parser.getEasyName('XP4_FD'))
        self.assertEqual('Azadi Palace', self.parser.getEasyName('XP4_Parl'))
        self.assertEqual('Talah market', self.parser.getEasyName('XP4_Rubble'))
        self.assertEqual('Operation Riverside', self.parser.getEasyName('XP5_001'))
        self.assertEqual('Nebandan Flats', self.parser.getEasyName('XP5_002'))
        self.assertEqual('Kiasar Railroad', self.parser.getEasyName('XP5_003'))
        self.assertEqual('Sabalan Pipeline', self.parser.getEasyName('XP5_004'))
        self.assertEqual('f00', self.parser.getEasyName('f00'))


    def test_getHardName(self):
        self.assertEqual('MP_001', self.parser.getHardName('Grand Bazaar'))
        self.assertEqual('MP_003', self.parser.getHardName('Tehran Highway'))
        self.assertEqual('MP_007', self.parser.getHardName('Caspian Border'))
        self.assertEqual('MP_011', self.parser.getHardName('Seine Crossing'))
        self.assertEqual('MP_012', self.parser.getHardName('Operation Firestorm'))
        self.assertEqual('MP_013', self.parser.getHardName('Damavand Peak'))
        self.assertEqual('MP_017', self.parser.getHardName('Noshahar Canals'))
        self.assertEqual('MP_018', self.parser.getHardName('Kharg Island'))
        self.assertEqual('MP_Subway', self.parser.getHardName('Operation Metro'))
        self.assertEqual('XP1_001', self.parser.getHardName('Strike At Karkand'))
        self.assertEqual('XP1_002', self.parser.getHardName('Gulf of Oman'))
        self.assertEqual('XP1_003', self.parser.getHardName('Sharqi Peninsula'))
        self.assertEqual('XP1_004', self.parser.getHardName('Wake Island'))
        self.assertEqual('XP2_Factory', self.parser.getHardName('Scrapmetal'))
        self.assertEqual('XP2_Office', self.parser.getHardName('Operation 925'))
        self.assertEqual('XP2_Palace', self.parser.getHardName('Donya Fortress'))
        self.assertEqual('XP2_Skybar', self.parser.getHardName('Ziba Tower'))
        self.assertEqual('XP3_Desert', self.parser.getHardName('Bandar Desert'))
        self.assertEqual('XP3_Alborz', self.parser.getHardName('Alborz Mountains'))
        self.assertEqual('XP3_Shield', self.parser.getHardName('Armored Shield'))
        self.assertEqual('XP3_Valley', self.parser.getHardName('Death Valley'))
        self.assertEqual('XP4_Quake', self.parser.getHardName('Epicenter'))
        self.assertEqual('XP4_FD', self.parser.getHardName('Markaz Monolith'))
        self.assertEqual('XP4_Parl', self.parser.getHardName('Azadi Palace'))
        self.assertEqual('XP4_Rubble', self.parser.getHardName('Talah market'))
        self.assertEqual('XP5_001', self.parser.getHardName('Operation Riverside'))
        self.assertEqual('XP5_002', self.parser.getHardName('Nebandan Flats'))
        self.assertEqual('XP5_003', self.parser.getHardName('Kiasar Railroad'))
        self.assertEqual('XP5_004', self.parser.getHardName('Sabalan Pipeline'))
        self.assertEqual('f00', self.parser.getHardName('f00'))


    def test_getMapsSoundingLike(self):
        self.assertEqual(['operation metro', 'kiasar railroad', 'gulf of oman',], self.parser.getMapsSoundingLike(''), '')
        self.assertEqual('MP_Subway', self.parser.getMapsSoundingLike('Operation Metro'), 'Operation Metro')
        self.assertEqual('MP_001', self.parser.getMapsSoundingLike('grand'))
        self.assertEqual(['operation metro', 'operation firestorm', 'operation 925'], self.parser.getMapsSoundingLike('operation'))
        self.assertEqual('XP3_Desert', self.parser.getMapsSoundingLike('bandar'))
        self.assertEqual('XP3_Desert', self.parser.getMapsSoundingLike('desert'))
        self.assertEqual('XP3_Alborz', self.parser.getMapsSoundingLike('alborz'))
        self.assertEqual('XP3_Alborz', self.parser.getMapsSoundingLike('mountains'))
        self.assertEqual('XP3_Alborz', self.parser.getMapsSoundingLike('mount'))
        self.assertEqual('XP3_Shield', self.parser.getMapsSoundingLike('armored'))
        self.assertEqual('XP3_Shield', self.parser.getMapsSoundingLike('shield'))
        self.assertEqual('XP3_Valley', self.parser.getMapsSoundingLike('Death'))
        self.assertEqual('XP3_Valley', self.parser.getMapsSoundingLike('valley'))
        self.assertEqual('XP4_Quake', self.parser.getMapsSoundingLike('Epicenter'))
        self.assertEqual('XP4_Quake', self.parser.getMapsSoundingLike('Epicentre'))
        self.assertEqual('XP4_Quake', self.parser.getMapsSoundingLike('epi'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('markaz Monolith'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('markazMonolith'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('markaz Monolit'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('markaz Mono'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('markaz'))
        self.assertEqual('XP4_FD', self.parser.getMapsSoundingLike('Monolith'))
        self.assertEqual('XP4_Parl', self.parser.getMapsSoundingLike('Azadi Palace'))
        self.assertEqual('XP4_Parl', self.parser.getMapsSoundingLike('AzadiPalace'))
        self.assertEqual('XP4_Parl', self.parser.getMapsSoundingLike('Azadi'))
        self.assertEqual('XP4_Parl', self.parser.getMapsSoundingLike('Palace'))
        self.assertEqual('XP4_Parl', self.parser.getMapsSoundingLike('Azadi Place'))
        self.assertEqual('XP4_Rubble', self.parser.getMapsSoundingLike('Talah market'))
        self.assertEqual('XP4_Rubble', self.parser.getMapsSoundingLike('Talahmarket'))
        self.assertEqual('XP4_Rubble', self.parser.getMapsSoundingLike('Talah'))
        self.assertEqual('XP4_Rubble', self.parser.getMapsSoundingLike('market'))
        self.assertEqual('XP5_001', self.parser.getMapsSoundingLike('Operation Riverside'))
        self.assertEqual('XP5_001', self.parser.getMapsSoundingLike('Operationriverside'))
        self.assertEqual('XP5_001', self.parser.getMapsSoundingLike('Riverside'))
        self.assertEqual('XP5_001', self.parser.getMapsSoundingLike('riverside'))
        self.assertEqual('XP5_002', self.parser.getMapsSoundingLike('Nebandan Flats'))
        self.assertEqual('XP5_002', self.parser.getMapsSoundingLike('NebandanFlats'))
        self.assertEqual('XP5_002', self.parser.getMapsSoundingLike('Nebandan'))
        self.assertEqual('XP5_002', self.parser.getMapsSoundingLike('Flats'))
        self.assertEqual('XP5_003', self.parser.getMapsSoundingLike('Kiasar Railroad'))
        self.assertEqual('XP5_003', self.parser.getMapsSoundingLike('KiasarRailroad'))
        self.assertEqual('XP5_003', self.parser.getMapsSoundingLike('Kiasar'))
        self.assertEqual('XP5_003', self.parser.getMapsSoundingLike('Railroad'))
        self.assertEqual('XP5_004', self.parser.getMapsSoundingLike('Sabalan Pipeline'))
        self.assertEqual('XP5_004', self.parser.getMapsSoundingLike('SabalanPipeline'))
        self.assertEqual('XP5_004', self.parser.getMapsSoundingLike('Sabalan'))
        self.assertEqual('XP5_004', self.parser.getMapsSoundingLike('Pipeline'))

    def test_getGamemodeSoundingLike(self):
        self.assertEqual('ConquestSmall0', self.parser.getGamemodeSoundingLike('MP_011', 'ConquestSmall0'), 'ConquestSmall0')
        self.assertEqual('ConquestSmall0', self.parser.getGamemodeSoundingLike('MP_011', 'Conquest'), 'Conquest')
        self.assertListEqual(['Team Deathmatch', 'Squad Deathmatch'], self.parser.getGamemodeSoundingLike('MP_011', 'Deathmatch'), 'Deathmatch')
        self.assertListEqual(['Rush', 'Conquest', 'Conquest64'], self.parser.getGamemodeSoundingLike('MP_011', 'foo'))
        self.assertEqual('TeamDeathMatch0', self.parser.getGamemodeSoundingLike('MP_011', 'tdm'), 'tdm')
        self.assertEqual('TeamDeathMatch0', self.parser.getGamemodeSoundingLike('MP_011', 'teamdeathmatch'), 'teamdeathmatch')
        self.assertEqual('TeamDeathMatch0', self.parser.getGamemodeSoundingLike('MP_011', 'team death match'), 'team death match')
        self.assertEqual('ConquestLarge0', self.parser.getGamemodeSoundingLike('MP_011', 'CQ64'), 'CQ64')
        self.assertEqual('TankSuperiority0', self.parser.getGamemodeSoundingLike('XP3_Valley', 'tank superiority'), 'tank superiority')
        self.assertEqual('TankSuperiority0', self.parser.getGamemodeSoundingLike('XP3_Valley', 'tanksuperiority'), 'tanksuperiority')
        self.assertEqual('TankSuperiority0', self.parser.getGamemodeSoundingLike('XP3_Valley', 'tanksup'), 'tanksup')
        self.assertEqual('TankSuperiority0', self.parser.getGamemodeSoundingLike('XP3_Valley', 'tank'), 'tank')
        self.assertEqual('TankSuperiority0', self.parser.getGamemodeSoundingLike('XP3_Valley', 'superiority'), 'superiority')
        self.assertEqual('SquadDeathMatch0', self.parser.getGamemodeSoundingLike('XP4_Quake', 'sqdm'), 'sqdm')
        self.assertEqual('Scavenger0', self.parser.getGamemodeSoundingLike('XP4_Quake', 'scavenger'), 'scavenger')
        self.assertEqual('Scavenger0', self.parser.getGamemodeSoundingLike('XP4_Quake', 'scav'), 'scav')
        self.assertEqual('Scavenger0', self.parser.getGamemodeSoundingLike('XP4_FD', 'scav'), 'scav')
        self.assertEqual('Scavenger0', self.parser.getGamemodeSoundingLike('XP4_Parl', 'scav'), 'scav')
        self.assertEqual('Scavenger0', self.parser.getGamemodeSoundingLike('XP4_Rubble', 'scav'), 'scav')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_001', 'ctf'), 'ctf')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_002', 'ctf'), 'ctf')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_003', 'ctf'), 'ctf')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_004', 'ctf'), 'ctf')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_004', 'flag'), 'flag')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_004', 'cap'), 'cap')
        self.assertEqual('CaptureTheFlag0', self.parser.getGamemodeSoundingLike('XP5_004', 'capture'), 'capture')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_001', 'airsuperiority'), 'airsuperiority')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_002', 'airsuperiority'), 'airsuperiority')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_003', 'airsuperiority'), 'airsuperiority')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_004', 'airsuperiority'), 'airsuperiority')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_004', 'air'), 'air')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_004', 'airsup'), 'airsup')
        self.assertEqual('AirSuperiority0', self.parser.getGamemodeSoundingLike('XP5_004', 'superiority'), 'superiority')


class Test_getPlayerPings(BF3TestCase):

    def setUp(self):
        BF3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.parser = Bf3Parser(self.conf)
        self.p1 = FakeClient(self.parser, name="Player1")
        self.p2 = FakeClient(self.parser, name="Player2")

    def test_no_player(self):
        # WHEN
        actual_result = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({}, actual_result)

    def test_one_player(self):
        # GIVEN
        self.p1.connects("Player1")
        when(self.parser).write(('player.ping', self.p1.cid)).thenReturn(['140'])
        # WHEN
        actual_result = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({self.p1.cid: 140}, actual_result)

    def test_two_player(self):
        # GIVEN
        self.p1.connects("Player1")
        self.p2.connects("Player2")
        when(self.parser).write(('player.ping', self.p1.cid)).thenReturn(['140'])
        when(self.parser).write(('player.ping', self.p2.cid)).thenReturn(['450'])
        # WHEN
        actual_result = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({self.p1.cid: 140, self.p2.cid: 450}, actual_result)

    def test_bad_data(self):
        # GIVEN
        self.p1.connects("Player1")
        self.p2.connects("Player2")
        when(self.parser).write(('player.ping', self.p1.cid)).thenReturn(['140'])
        when(self.parser).write(('player.ping', self.p2.cid)).thenReturn(['f00'])
        # WHEN
        actual_result = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({self.p1.cid: 140}, actual_result)

    def test_exception(self):
        # GIVEN
        self.p1.connects("Player1")
        self.p2.connects("Player2")
        when(self.parser).write(('player.ping', self.p1.cid)).thenReturn(['140'])
        when(self.parser).write(('player.ping', self.p2.cid)).thenRaise(Exception)
        # WHEN
        actual_result = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({self.p1.cid: 140}, actual_result)


class Test_admin_cmd_map(BF3TestCase):

    def setUp(self):
        BF3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""
                <configuration>
                </configuration>
            """)
        self.console = Bf3Parser(self.conf)

        from b3 import __file__ as b3_module__file__
        admin_config_file = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml"))
        admin_config = XmlConfigParser()
        admin_config.load(admin_config_file)
        self.adminPlugin = AdminPlugin(self.console, admin_config)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()
        when(self.console).getPlugin('admin').thenReturn(self.adminPlugin)

        # monkeypatch the admin plugin
        self.console.patch_b3_admin_plugin()

        self.changeMap_patcher = patch.object(self.console, "changeMap")
        self.changeMap_mock = self.changeMap_patcher.start()

        self.player = FakeClient(self.console, name="Player1", guid="Player1GUID", groupBits=128)
        self.player.connects("p1")

        # GIVEN
        self.console.game.gameType = 'ConquestLarge0'
        when(self.console).write(('mapList.list', 0)).thenReturn(['4', '3', 'MP_001', 'RushLarge0', '1', 'MP_003',
                                                                  'ConquestSmall0', '2', 'XP5_001', 'ConquestSmall0',
                                                                  '2', 'MP_007', 'SquadDeathMatch0', '3'])
        when(self.console).write(('mapList.getMapIndices',)).thenReturn(['0', '0'])

    def tearDown(self):
        BF3TestCase.tearDown(self)
        self.changeMap_patcher.stop()

    def test_cmd_help_map(self):
        # WHEN
        self.player.says('!help map')
        # THEN
        self.assertListEqual(['!map <map> [, gamemode [, num of rounds]] - switch current map. Optionally specify a '
                              'gamemode and # of rounds by separating them from the map name with a commas'],
                             self.player.message_history)

    def test_cmd_map_no_parameter(self):
        # WHEN
        self.player.says('!map')
        # THEN
        self.assertListEqual(['Invalid parameters, type !help map'], self.player.message_history)

    def test_cmd_map_known_map_no_gamemode(self):
        # WHEN
        self.player.says('!map riverside, 2')
        # THEN
        self.assertListEqual([call('XP5_001', gamemode_id='ConquestLarge0', number_of_rounds=2)],
                             self.changeMap_mock.mock_calls)
        self.assertListEqual([], self.player.message_history)

    def test_cmd_map_known_map_and_gamemode(self):
        # WHEN
        self.player.says('!map riverside, air, 1')
        # THEN
        self.assertListEqual([call('XP5_001', gamemode_id='AirSuperiority0', number_of_rounds=1)],
                             self.changeMap_mock.mock_calls)
        self.assertListEqual([], self.player.message_history)

    def test_XP5_maps_and_gamemodes(self):
        def assertCmd(cmd, expected_call):
            self.changeMap_mock.reset_mock()
            self.player.clearMessageHistory()
            self.player.says(cmd)
            self.assertListEqual([], self.player.message_history, cmd)
            self.assertListEqual([expected_call], self.changeMap_mock.mock_calls, cmd)
        # XP5_001
        assertCmd('!map XP5_001, ConquestLarge0, 2', call('XP5_001', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map operation Riverside, Cq64, 2', call('XP5_001', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Riverside, Cq64, 2', call('XP5_001', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Riverside, Cq, 2', call('XP5_001', gamemode_id='ConquestSmall0', number_of_rounds=2))
        assertCmd('!map Riverside, tdm, 2', call('XP5_001', gamemode_id='TeamDeathMatch0', number_of_rounds=2))
        assertCmd('!map Riverside, sqdm, 1', call('XP5_001', gamemode_id='SquadDeathMatch0', number_of_rounds=1))
        assertCmd('!map Riverside, squad rush, 2', call('XP5_001', gamemode_id='SquadRush0', number_of_rounds=2))
        assertCmd('!map Riverside, rush, 2', call('XP5_001', gamemode_id='RushLarge0', number_of_rounds=2))
        assertCmd('!map Riverside, ctf, 2', call('XP5_001', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map Riverside, flag, 2', call('XP5_001', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map Riverside, capture, 2', call('XP5_001', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map Riverside, air, 1', call('XP5_001', gamemode_id='AirSuperiority0', number_of_rounds=1))
        assertCmd('!map Riverside, sup, 1', call('XP5_001', gamemode_id='AirSuperiority0', number_of_rounds=1))
        # XP5_002
        assertCmd('!map XP5_002, ConquestLarge0, 2', call('XP5_002', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Nebandan Flats, Cq64, 2', call('XP5_002', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Nebandan, Cq64, 2', call('XP5_002', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Nebandan, Cq, 2', call('XP5_002', gamemode_id='ConquestSmall0', number_of_rounds=2))
        assertCmd('!map Nebandan, tdm, 2', call('XP5_002', gamemode_id='TeamDeathMatch0', number_of_rounds=2))
        assertCmd('!map Nebandan, sqdm, 1', call('XP5_002', gamemode_id='SquadDeathMatch0', number_of_rounds=1))
        assertCmd('!map flats, squad rush, 2', call('XP5_002', gamemode_id='SquadRush0', number_of_rounds=2))
        assertCmd('!map flats, rush, 2', call('XP5_002', gamemode_id='RushLarge0', number_of_rounds=2))
        assertCmd('!map flats, ctf, 2', call('XP5_002', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map flats, flag, 2', call('XP5_002', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map flats, capture, 2', call('XP5_002', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map flats, air, 1', call('XP5_002', gamemode_id='AirSuperiority0', number_of_rounds=1))
        assertCmd('!map flats, sup, 1', call('XP5_002', gamemode_id='AirSuperiority0', number_of_rounds=1))
        # XP5_003
        assertCmd('!map XP5_003, ConquestLarge0, 2', call('XP5_003', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Kiasar Railroad, Cq64, 2', call('XP5_003', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Kiasar, Cq64, 2', call('XP5_003', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Kiasar, Cq, 2', call('XP5_003', gamemode_id='ConquestSmall0', number_of_rounds=2))
        assertCmd('!map Kiasar, tdm, 2', call('XP5_003', gamemode_id='TeamDeathMatch0', number_of_rounds=2))
        assertCmd('!map Kiasar, sqdm, 1', call('XP5_003', gamemode_id='SquadDeathMatch0', number_of_rounds=1))
        assertCmd('!map Kiasar, squad rush, 2', call('XP5_003', gamemode_id='SquadRush0', number_of_rounds=2))
        assertCmd('!map Railroad, rush, 2', call('XP5_003', gamemode_id='RushLarge0', number_of_rounds=2))
        assertCmd('!map Railroad, ctf, 2', call('XP5_003', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map rail, flag, 2', call('XP5_003', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map rail, capture, 2', call('XP5_003', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map kia, air, 1', call('XP5_003', gamemode_id='AirSuperiority0', number_of_rounds=1))
        assertCmd('!map rail, sup, 1', call('XP5_003', gamemode_id='AirSuperiority0', number_of_rounds=1))
        # XP5_004
        assertCmd('!map XP5_004, ConquestLarge0, 2', call('XP5_004', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Sabalan Pipeline, Cq64, 2', call('XP5_004', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Sabalan, Cq64, 2', call('XP5_004', gamemode_id='ConquestLarge0', number_of_rounds=2))
        assertCmd('!map Sabalan, Cq, 2', call('XP5_004', gamemode_id='ConquestSmall0', number_of_rounds=2))
        assertCmd('!map Sabalan, tdm, 2', call('XP5_004', gamemode_id='TeamDeathMatch0', number_of_rounds=2))
        assertCmd('!map Sabalan, sqdm, 1', call('XP5_004', gamemode_id='SquadDeathMatch0', number_of_rounds=1))
        assertCmd('!map Sabalan, squad rush, 2', call('XP5_004', gamemode_id='SquadRush0', number_of_rounds=2))
        assertCmd('!map Pipeline, rush, 2', call('XP5_004', gamemode_id='RushLarge0', number_of_rounds=2))
        assertCmd('!map Pipeline, ctf, 2', call('XP5_004', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map Pipeline, flag, 2', call('XP5_004', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map pipe, capture, 2', call('XP5_004', gamemode_id='CaptureTheFlag0', number_of_rounds=2))
        assertCmd('!map saba, air, 1', call('XP5_004', gamemode_id='AirSuperiority0', number_of_rounds=1))
        assertCmd('!map pipe, sup, 1', call('XP5_004', gamemode_id='AirSuperiority0', number_of_rounds=1))
        
########NEW FILE########
__FILENAME__ = test_cod
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.config import XmlConfigParser
from b3.parsers.cod import CodParser

log = logging.getLogger("test")
log.setLevel(logging.INFO)


class CodTestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Cod parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # CodParser -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = CodParser(self.parser_conf)

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)

        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_parser_API(CodTestCase):

    def test_getPlayerList_without_punkbuster(self):
        # GIVEN
        self.console.PunkBuster = None
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: mp_villa
num score ping guid   name            lastmsg address               qport rate
--- ----- ---- ---------- --------------- ------- --------------------- ------ -----
  0     0    0      0 democlient^7         1650 unknown                 1773  5000
  1     0   55 63281996 BandAid^7              50 11.11.11.11:524        8045 25000
  2     0  157 81554346 hugobongenhielm^7      50 11.11.11.11:524    22481 25000
  3     0  156 86330555 Irish^7                 0 11.11.11.11:9162     14288 25000
  4     0  999 68003079 Ashhole^7             750 11.11.11.11:19978 19033 25000
  5     5   53 318670 bigredtwit^7            011.11.11.11:28966     1259 25000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertDictContainsSubset({
            'slot': '1', 'score': '0', 'ping': '55', 'guid': '63281996', 'name': 'BandAid^7', 'last': '50', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('1', {}), rv)
        self.assertDictContainsSubset({
            'slot': '2', 'score': '0', 'ping': '157', 'guid': '81554346', 'name': 'hugobongenhielm^7', 'last': '50', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('2', {}), rv)
        self.assertDictContainsSubset({
            'slot': '3', 'score': '0', 'ping': '156', 'guid': '86330555', 'name': 'Irish^7', 'last': '0', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('3', {}), rv)
        self.assertDictContainsSubset({
            'slot': '4', 'score': '0', 'ping': '999', 'guid': '68003079', 'name': 'Ashhole^7', 'last': '750', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('4', {}), rv)
        self.assertDictContainsSubset({
            'slot': '5', 'score': '5', 'ping': '53', 'guid': '318670', 'name': 'bigredtwit^7', 'last': '0', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('5', {}), rv)


########NEW FILE########
__FILENAME__ = test_cod4
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock, patch, call, ANY
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.config import XmlConfigParser
from b3.fake import FakeClient
from b3.parsers.cod4 import Cod4Parser

log = logging.getLogger("test")
log.setLevel(logging.INFO)


class Cod4TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Cod4 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Cod4Parser -> AbstractParser -> FakeConsole -> Parser


    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Cod4Parser(self.parser_conf)

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)

        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_parser_API(Cod4TestCase):

    def test_getPlayerList_without_punkbuster(self):
        # See http://forum.bigbrotherbot.net/general-discussion/%27bug%27-in-cod4parser/msg38165/
        # See http://forum.bigbrotherbot.net/general-usage-support/b3-not-authenticate/msg38262/
        # GIVEN
        self.console.PunkBuster = None
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: mp_backlot
num score ping guid                             name            lastmsg address               qport rate
--- ----- ---- -------------------------------- --------------- ------- --------------------- ----- -----
  0     0   14 1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab player1^7               0 11.22.33.44:-6187 -1609 25000
  1     0   12 1ccccccccccccccccccccccccccccccc player2^7               0 22.33.44.55:-10803-23569 25000
  3   486  185 ecc77e3400a38cc71b3849207e20e1b0 GO_NINJA^7              0 111.222.111.111:-15535-2655 25000
  5    92  509 0123456789abcdef0123456789abcdef 7ajimaki^7            100 11.222.111.44:28960   -27329 25000
  6     0  206 0123456789a654654646545789abcdef [NRNS]ArmedGuy^7        0 11.22.111.44:28960    -21813 25000
  7    30  229 012343213211313213321313131bcdef Franco^7                0 111.22.111.111:23144  22922 25000
  8     0  110 a630006508000000000000000011d9a2 Badschga2002^7          0 11.11.11.6328960   -21738 25000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertDictEqual({'slot': '0', 'score': '0', 'ping': '14', 'guid': '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab', 'name': 'player1^7', 'last': '0', 'ip': '11.22.33.44', 'port': '-6187', 'qport': '-1609', 'rate': '25000', 'pbid': None}, rv.get("0", {}), rv)
        self.assertDictEqual({'slot': '1', 'score': '0', 'ping': '12', 'guid': '1ccccccccccccccccccccccccccccccc', 'name': 'player2^7', 'last': '0', 'ip': '22.33.44.55', 'port': '-10803', 'qport': '-23569', 'rate': '25000', 'pbid': None}, rv.get("1", {}), rv)
        self.assertDictEqual({'slot': '3', 'score': '486', 'ping': '185', 'guid': 'ecc77e3400a38cc71b3849207e20e1b0', 'name': 'GO_NINJA^7', 'last': '0', 'ip': '111.222.111.111', 'port': '-15535', 'qport': '-2655', 'rate': '25000', 'pbid': None}, rv.get("3", {}), rv)
        self.assertDictEqual({'slot': '5', 'score': '92', 'ping': '509', 'guid': '0123456789abcdef0123456789abcdef', 'name': '7ajimaki^7', 'last': '100', 'ip': '11.222.111.44', 'port': '28960', 'qport': '-27329', 'rate': '25000', 'pbid': None}, rv.get("5", {}), rv)
        self.assertDictEqual({'slot': '6', 'score': '0', 'ping': '206', 'guid': '0123456789a654654646545789abcdef', 'name': '[NRNS]ArmedGuy^7', 'last': '0', 'ip': '11.22.111.44', 'port': '28960', 'qport': '-21813', 'rate': '25000', 'pbid': None}, rv.get("6", {}), rv)
        self.assertDictEqual({'slot': '7', 'score': '30', 'ping': '229', 'guid': '012343213211313213321313131bcdef', 'name': 'Franco^7', 'last': '0', 'ip': '111.22.111.111', 'port': '23144', 'qport': '22922', 'rate': '25000', 'pbid': None}, rv.get("7", {}), rv)
        self.assertDictEqual({'slot': '8', 'score': '0', 'ping': '110', 'guid': 'a630006508000000000000000011d9a2', 'name': 'Badschga2002^7', 'last': '0', 'ip': '11.11.11.63', 'port': '28960', 'qport': '-21738', 'rate': '25000', 'pbid': None}, rv.get("8", {}), rv)



class Test_cod4ClientAuthMethod(Cod4TestCase):

    def test_unexpected_exception(self):
        # GIVEN
        when(self.console.storage).getClient(anything()).thenRaise(NotImplementedError())
        joe = FakeClient(console=self.console, name="Joe", guid="joe_guid")
        # WHEN
        with patch.object(self.console, "error") as error_mock:
            joe.auth()
        # THEN
        error_mock.assert_called_with('auth self.console.storage.getClient(client) - Client<@0:joe_guid|:"Joe":None>',
                                   exc_info=ANY)

########NEW FILE########
__FILENAME__ = test_cod5
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.config import XmlConfigParser
from b3.parsers.cod5 import Cod5Parser

log = logging.getLogger("test")
log.setLevel(logging.INFO)


class Cod5TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Cod5 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Cod5Parser -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Cod5Parser(self.parser_conf)

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)

        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_parser_API(Cod5TestCase):

    def test_getPlayerList_without_punkbuster(self):
        # GIVEN
        self.console.PunkBuster = None
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: mp_gits_tanks
num score ping guid       name            lastmsg address               qport  rate
--- ----- ---- ---------- --------------- ------- --------------------- ------ -----
  0     0  349 784729936 BagpipeHero^7          50 11.11.11.11:28960   7309 25000
  1     0  999 680213351 US_Wannabe^7          750 11.11.11.11:28960   -13830 25000
  2  1230  159 1689890858 2cool4yaD^7             0 11.11.11.11:-9427     31128 25000
  3  1520  163 763506664 SestaPT^7               0 11.11.11.11:28960   -9436 25000
  4   410  129 281198399 xRedoxX^7               0 11.11.11.11:29195    -28834 25000
  5     0  999 1359560555 MikeIsDaBomb^7          0 11.11.11.11:28960   -20411 25000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertDictEqual({'slot': '0', 'score': '0', 'ping': '349', 'guid': '784729936', 'name': 'BagpipeHero^7', 'last': '50', 'ip': '11.11.11.11', 'port': '28960', 'qport': '7309', 'rate': '25000', 'pbid': None}, rv.get("0", {}))
        self.assertDictEqual({'slot': '1', 'score': '0', 'ping': '999', 'guid': '680213351', 'name': 'US_Wannabe^7', 'last': '750', 'ip': '11.11.11.11', 'port': '28960', 'qport': '-13830', 'rate': '25000', 'pbid': None}, rv.get("1", {}))
        self.assertDictEqual({'slot': '2', 'score': '1230', 'ping': '159', 'guid': '1689890858', 'name': '2cool4yaD^7', 'last': '0', 'ip': '11.11.11.11', 'port': '-9427', 'qport': '31128', 'rate': '25000', 'pbid': None}, rv.get("2", {}))
        self.assertDictEqual({'slot': '3', 'score': '1520', 'ping': '163', 'guid': '763506664', 'name': 'SestaPT^7', 'last': '0', 'ip': '11.11.11.11', 'port': '28960', 'qport': '-9436', 'rate': '25000', 'pbid': None}, rv.get("3", {}))
        self.assertDictEqual({'slot': '4', 'score': '410', 'ping': '129', 'guid': '281198399', 'name': 'xRedoxX^7', 'last': '0', 'ip': '11.11.11.11', 'port': '29195', 'qport': '-28834', 'rate': '25000', 'pbid': None}, rv.get("4", {}))
        self.assertDictEqual({'slot': '5', 'score': '0', 'ping': '999', 'guid': '1359560555', 'name': 'MikeIsDaBomb^7', 'last': '0', 'ip': '11.11.11.11', 'port': '28960', 'qport': '-20411', 'rate': '25000', 'pbid': None}, rv.get("5", {}))


########NEW FILE########
__FILENAME__ = test_cod6
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.config import XmlConfigParser
from b3.parsers.cod6 import Cod6Parser

log = logging.getLogger("test")
log.setLevel(logging.INFO)


class Cod6TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Cod6 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Cod6Parser -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Cod6Parser(self.parser_conf)

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)

        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_parser_API(Cod6TestCase):

    def test_getPlayerList_without_punkbuster(self):
        # GIVEN
        self.console.PunkBuster = None
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: mp_highrise
num score ping guid                             name            lastmsg address               qport rate
--- ----- ---- -------------------------------- --------------- ------- --------------------- ----- -----
  0     1   69                 011000010002d113 Minikruku!^7            0 11.11.11.11:16864    20125 25000
  1     1  101                 011000010002caf1 GuMaK111^7             50 11.11.11.11:4294934838  690 25000
  2     1  175                 0110000100003fb4 phantom1151^7           0 11.11.11.11:28960    10929 25000
  3     1   49                 011000010003ed88 isidora10^7             0 11.11.11.11:429496262727388 25000
  4     1   31                 011000018e87f252 [^5RnK^0] ^4B^7              50 11.11.11.11:28960  26213 25000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertDictContainsSubset({
            'slot': '0', 'score': '1', 'ping': '69', 'guid': '011000010002d113', 'name': 'Minikruku!^7', 'last': '0', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('0', {}))
        self.assertDictContainsSubset({
            'slot': '1', 'score': '1', 'ping': '101', 'guid': '011000010002caf1', 'name': 'GuMaK111^7', 'last': '50', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('1', {}))
        self.assertDictContainsSubset({
            'slot': '2', 'score': '1', 'ping': '175', 'guid': '0110000100003fb4', 'name': 'phantom1151^7', 'last': '0', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('2', {}))
        self.assertDictContainsSubset({
            'slot': '3', 'score': '1', 'ping': '49', 'guid': '011000010003ed88', 'name': 'isidora10^7', 'last': '0', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('3', {}))
        self.assertDictContainsSubset({
            'slot': '4', 'score': '1', 'ping': '31', 'guid': '011000018e87f252', 'name': '[^5RnK^0] ^4B^7', 'last': '50', 'ip': '11.11.11.11', 'pbid': None
        }, rv.get('4', {}))

########NEW FILE########
__FILENAME__ = test_cod7
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.config import XmlConfigParser
from b3.parsers.cod7 import Cod7Parser

log = logging.getLogger("test")
log.setLevel(logging.INFO)


class Cod7TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Cod7 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Cod5Parser -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Cod7Parser(self.parser_conf)

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)

        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_parser_API(Cod7TestCase):

    def test_getPlayerList_without_punkbuster(self):
        # GIVEN
        self.console.PunkBuster = None
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: mp_stadium
num score ping guid   name            lastmsg address               qport rate
--- ----- ---- ---------- --------------- ------- --------------------- ------ -----
  0     0    0      0 democlient^7       362150 unknown                 1773  5000
  1   200   47 8326146 ShaGGyTuBBs^7           0 11.11.11.11:524       16783 25000
  2  1360   61 56089378 fresh breeze^7          0 11.11.11.11:-27409   -7422 25000
  3   470   97 69406003 kossi__86^7             0 11.11.11.11:524      -24017 25000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertNotIn("0", rv)
        self.assertDictContainsSubset({'slot': '1', 'score': '200', 'ping': '47', 'guid': '8326146', 'name': 'ShaGGyTuBBs^7', 'last': '0', 'ip': '11.11.11.11', 'port': '524', 'qport': '16783', 'rate': '25000', 'pbid': None}, rv.get("1", {}))
        self.assertDictContainsSubset({'slot': '2', 'score': '1360', 'ping': '61', 'guid': '56089378', 'name': 'fresh breeze^7', 'last': '0', 'ip': '11.11.11.11', 'port': '-27409', 'qport': '7422', 'rate': '25000', 'pbid': None}, rv.get("2", {}))
        self.assertDictContainsSubset({'slot': '3', 'score': '470', 'ping': '97', 'guid': '69406003', 'name': 'kossi__86^7', 'last': '0', 'ip': '11.11.11.11', 'port': '524', 'qport': '24017', 'rate': '25000', 'pbid': None}, rv.get("3", {}))


########NEW FILE########
__FILENAME__ = test_csgo
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from mock import Mock, call, patch
from mockito import when, verify
import sys
import unittest2 as unittest
from b3 import TEAM_BLUE, TEAM_RED, TEAM_UNKNOWN, TEAM_SPEC
from b3.clients import Client
from b3.config import XmlConfigParser
from b3.fake import FakeClient
from b3.parsers.csgo import CsgoParser


WAS_FROSTBITE_LOADED = 'b3.parsers.frostbite' in sys.modules.keys() or 'b3.parsers.frostbite2' in sys.modules.keys()


STATUS_RESPONSE = '''\
hostname: Courgette's Server
version : 1.17.5.1/11751 5038 secure
udp/ip  : 11.23.32.44:27015  (public ip: 11.23.32.44)
os      :  Linux
type    :  community dedicated
map     : cs_foobar
players : 1 humans, 10 bots (20/20 max) (not hibernating)

# userid name uniqueid connected ping loss state rate adr
#224 "Moe" BOT active
# 194 2 "courgette" STEAM_1:0:1111111 33:48 67 0 active 20000 11.222.111.222:27005
#225 "Quintin" BOT active
#226 "Kurt" BOT active
#227 "Arnold" BOT active
#228 "Rip" BOT active
#229 "Zach" BOT active
#230 "Wolf" BOT active
#231 "Minh" BOT active
#232 "Ringo" BOT active
#233 "Quade" BOT active
#end
L 08/28/2012 - 01:28:40: rcon from "11.222.111.222:4181": command "status"
'''


def client_equal(client_a, client_b):
    if client_a is None and client_b is not None:
        return False
    if client_a is not None and client_b is None:
        return False
#    for p in ('cid', 'guid', 'name', 'ip', 'ping'):
#        if client_a.get(p, None) != client_b.get(p, None):
#            return False
    return all(map(lambda x: getattr(client_a, x, None) == getattr(client_b, x, None), ('cid', 'guid', 'name', 'ip', 'ping')))
#    return True


class CsgoTestCase(unittest.TestCase):
    """
    Test case that is suitable for testing CS:GO parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.fake import FakeConsole
        CsgoParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # CsgoParser -> FakeConsole -> Parser


    def setUp(self):
        self.status_response = None # defaults to STATUS_RESPONSE module attribute
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = CsgoParser(self.conf)
        self.parser.output = Mock()
        self.parser.output.write = Mock(wraps=self.output_write)
        when(self.parser).is_sourcemod_installed().thenReturn(True)

        self.evt_queue = []
        def queue_event(evt):
            self.evt_queue.append(evt)
        self.queueEvent_patcher = patch.object(self.parser, "queueEvent", wraps=queue_event)
        self.queueEvent_mock = self.queueEvent_patcher.start()

        self.parser.startup()


    def tearDown(self):
        self.queueEvent_patcher.stop()
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False


    def clear_events(self):
        """
        clear the event queue, so when assert_has_event is called, it will look only at the newly caught events.
        """
        self.evt_queue = []


    def assert_has_event(self, event_type, data=None, client=None, target=None):
        """
        assert that self.evt_queue contains at least one event for the given type that has the given characteristics.
        """
        assert isinstance(event_type, basestring)
        expected_event = self.parser.getEvent(event_type, data, client, target)

        if not len(self.evt_queue):
            self.fail("expecting %s. Got no event instead" % expected_event)
        elif len(self.evt_queue) == 1:
            actual_event = self.evt_queue[0]
            self.assertEqual(expected_event.type, actual_event.type)
            self.assertEqual(expected_event.data, actual_event.data)
            self.assertTrue(client_equal(expected_event.client, actual_event.client))
            self.assertTrue(client_equal(expected_event.target, actual_event.target))
        else:
            for evt in self.evt_queue:
                if expected_event.type == evt.type \
                    and expected_event.data == evt.data \
                    and client_equal(expected_event.client, evt.client) \
                    and client_equal(expected_event.target, evt.target):
                    return

            self.fail("expecting event %s. Got instead: %s" % (expected_event, map(str, self.evt_queue)))


    def output_write(self, *args, **kwargs):
        """Used to override parser self.output.write method so we can control the response given to the 'status'
        rcon command"""
        if len(args) and args[0] == "status":
            if self.status_response is not None:
                return self.status_response
            else:
                return STATUS_RESPONSE



class Test_gamelog_parsing(CsgoTestCase):

    def test_server_cvars_start(self):
        self.queueEvent_mock.reset_mock()
        self.parser.parseLine("""L 08/26/2012 - 05:46:50: server cvars start""")
        self.assertFalse(self.queueEvent_mock.called)


    def test_server_cvars_end(self):
        self.queueEvent_mock.reset_mock()
        self.parser.parseLine("""L 08/26/2012 - 05:46:50: server cvars end""")
        self.assertFalse(self.queueEvent_mock.called)


    def test_killed(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot17 = FakeClient(self.parser, name="Ringo", guid="BOT_17")
        bot22.connects("22")
        bot17.connects("17")

        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Ringo<17><BOT><CT>" with "glock" (headshot)''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KILL", client=bot22, target=bot17, data=(100, 'glock', 'head', None))

        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Ringo<17><BOT><CT>" with "glock"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KILL", client=bot22, target=bot17, data=(100, 'glock', 'body', None))


    def test_killed_but_really_is_teamkill(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot17 = FakeClient(self.parser, name="Ringo", guid="BOT_17")
        bot22.connects("22")
        bot17.connects("17")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Ringo<17><BOT><TERRORIST>" with "glock"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KILL_TEAM", client=bot22, target=bot17, data=(100, 'glock', 'body', None))


    def test_killed_but_really_is_suicide(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot22.connects("22")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Pheonix<22><BOT><TERRORIST>" with "glock"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_SUICIDE", client=bot22, target=bot22, data=(100, 'glock', 'body', None))


    def test_committed_suicide(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot22.connects("22")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:38:04: "Pheonix<22><BOT><TERRORIST>" committed suicide with "world"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_SUICIDE", client=bot22, target=bot22, data=(100, 'world', 'body', None))



    def test_server_cvar(self):
        # GIVEN
        self.parser.game.cvar = {}
        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 03:49:58: server_cvar: "mp_freezetime" "5"''')
        # THEN
        self.assertDictEqual({'mp_freezetime': "5"}, self.parser.game.cvar)


    def test_cvar(self):
        # GIVEN
        self.parser.game.cvar = {}
        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 03:49:56: "decalfrequency" = "10"''')
        # THEN
        self.assertDictEqual({'decalfrequency': "10"}, self.parser.game.cvar)


    def test_map_change(self):
        # GIVEN
        self.parser.game.mapName = "old"
        # WHEN
        self.parser.parseLine('''L 08/27/2012 - 23:57:14: -------- Mapchange to de_dust --------''')
        # THEN
        self.assertEqual("de_dust", self.parser.game.mapName)


    def test_loading_map(self):
        # GIVEN
        self.parser.game.mapName = "old"
        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 03:49:56: Loading map "de_nuke"''')
        # THEN
        self.assertEqual("de_nuke", self.parser.game.mapName)


    def test_started_map(self):
        # GIVEN
        self.parser.game.mapName = "old"
        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 03:22:35: Started map "de_dust" (CRC "1592693790")''')
        # THEN
        self.assertEqual("de_dust", self.parser.game.mapName)


    def test_userid_validated(self):
        # GIVEN
        self.assertIsNone(self.parser.clients.getByCID("2"))
        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><>" STEAM USERID validated''')
        # THEN
        client = self.parser.clients.getByCID("2")
        self.assertIsNotNone(client)
        self.assertEqual("courgette", client.name)
        self.assertEqual("STEAM_1:0:1111111", client.guid)
        self.assert_has_event("EVT_CLIENT_CONNECT", data=client, client=client)
        self.assert_has_event("EVT_CLIENT_AUTH", data=client, client=client)


    def test_player_connected(self):
        # GIVEN
        self.assertIsNone(self.parser.clients.getByCID("2"))
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><>" connected, address "11.222.111.222:27005"''')
        # THEN
        client = self.parser.clients.getByCID("2")
        self.assertIsNotNone(client)
        self.assertEqual("courgette", client.name)
        self.assertEqual("STEAM_1:0:1111111", client.guid)
        self.assertEqual("11.222.111.222", client.ip)
        self.assert_has_event("EVT_CLIENT_CONNECT", data=client, client=client)
        self.assert_has_event("EVT_CLIENT_AUTH", data=client, client=client)


    def test_player_connected__unicode(self):
        # GIVEN
        self.assertIsNone(self.parser.clients.getByCID("2"))
        # WHEN
        self.clear_events()
        self.parser.parseLine(b'''L 08/26/2012 - 03:22:36: "Spoon\xc2\xab\xc2\xab<2><STEAM_1:0:1111111><>" connected, address "11.222.111.222:27005"''')
        # THEN
        client = self.parser.clients.getByCID("2")
        self.assertIsNotNone(client)
        self.assertEqual(u"Spoon", client.name)
        self.assertEqual("STEAM_1:0:1111111", client.guid)
        self.assertEqual("11.222.111.222", client.ip)
        self.assert_has_event("EVT_CLIENT_CONNECT", data=client, client=client)
        self.assert_has_event("EVT_CLIENT_AUTH", data=client, client=client)


    def test_bot_connected(self):
        # GIVEN
        self.assertIsNone(self.parser.clients.getByCID("3"))
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "Moe<3><BOT><>" connected, address "none"''')
        # THEN
        client = self.parser.clients.getByCID("3")
        self.assertIsNotNone(client)
        self.assertEqual("Moe", client.name)
        self.assertEqual("BOT_3", client.guid)
        self.assertEqual("", client.ip)
        self.assert_has_event("EVT_CLIENT_CONNECT", data=client, client=client)
        self.assert_has_event("EVT_CLIENT_AUTH", data=client, client=client)


    def test_kicked_by_console(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot22.connects("22")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 04:45:04: "Pheonix<22><BOT><TERRORIST>" disconnected (reason "Kicked by Console")''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KICK", data='Kicked by Console', client=bot22)
        self.assert_has_event("EVT_CLIENT_DISCONNECT", data='22', client=bot22)


    def test_player_entered(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 05:38:36: "courgette<2><STEAM_1:0:1111111><>" entered the game''')
        # THEN
        self.assert_has_event("EVT_CLIENT_JOIN", client=player)


    def test_bot_entered(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22")
        bot22.connects("22")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 05:29:48: "Pheonix<22><BOT><>" entered the game''')
        # THEN
        self.assert_has_event("EVT_CLIENT_JOIN", client=bot22)



    def test_player_join_team(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><Unassigned>" joined team "CT"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_TEAM_CHANGE", data=TEAM_RED, client=player)
        self.assertEqual(TEAM_RED, player.team)


    def test_bot_join_team(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_11")
        bot22.connects("11")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "Pheonix<11><BOT><Unassigned>" joined team "TERRORIST"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_TEAM_CHANGE", data=TEAM_BLUE, client=bot22)
        self.assertEqual(TEAM_BLUE, bot22.team)


    def test_world_triggered_event__Round_End(self):
        # GIVEN
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: World triggered "Round_End"''')
        # THEN
        self.assert_has_event("EVT_GAME_ROUND_END")


    def test_world_triggered_event__Round_Start(self):
        # GIVEN
        with patch.object(self.parser.game, "startRound") as startRound_mock:
            # WHEN
            self.assertFalse(startRound_mock.called)
            self.parser.parseLine('''L 08/26/2012 - 03:22:36: World triggered "Round_Start"''')
            # THEN
            self.assertTrue(startRound_mock.called)


    def test_world_triggered_event__Game_Commencing(self):
        # GIVEN
        with patch.object(self.parser, "warning") as warning_mock:
            # WHEN
            self.clear_events()
            self.parser.parseLine('''L 08/26/2012 - 03:22:36: World triggered "Game_Commencing"''')
            # THEN
            self.assertEqual([], self.evt_queue)
            self.assertFalse(warning_mock.called)


    def test_world_triggered_event__killlocation(self):
        # GIVEN
        with patch.object(self.parser, "warning") as warning_mock:
            # WHEN
            self.clear_events()
            self.assertIsNone(self.parser.last_killlocation_properties)
            self.parser.parseLine('''L 08/29/2012 - 22:26:59: World triggered "killlocation" (attacker_position "-282 749 -21") (victim_position "68 528 64")''')
            # THEN
            self.assertEqual([], self.evt_queue)
            self.assertEqual(''' (attacker_position "-282 749 -21") (victim_position "68 528 64")''', self.parser.last_killlocation_properties)
            self.assertFalse(warning_mock.called)


    def test_world_triggered_event__unknown_event(self):
        # GIVEN
        with patch.object(self.parser, "warning") as warning_mock:
            # WHEN
            self.clear_events()
            self.parser.parseLine('''L 08/26/2012 - 03:22:36: World triggered "f00"''')
            # THEN
            self.assertEqual([], self.evt_queue)
            self.assertTrue(warning_mock.called)
            warning_mock.assert_has_calls([call("unexpected world event : 'f00'. Please report this on the B3 forums")])


    def test_client_triggered_event__known(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")

        def assertEvent(event_name):
            # WHEN
            self.clear_events()
            self.parser.parseLine('''L 08/26/2012 - 05:04:55: "courgette<2><STEAM_1:0:1111111><CT>" triggered "%s"''' % event_name)
            # THEN
            self.assert_has_event("EVT_CLIENT_ACTION", data=event_name, client=player)

        assertEvent("Got_The_Bomb")
        assertEvent("Dropped_The_Bomb")
        assertEvent("Begin_Bomb_Defuse_Without_Kit")
        assertEvent("Begin_Bomb_Defuse_With_Kit")
        assertEvent("Planted_The_Bomb")
        assertEvent("headshot")


    def test_client_triggered_event__unknown(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111", team=TEAM_RED)
        player.connects("2")

        with patch.object(self.parser, "warning") as warning_mock:
            # WHEN
            self.clear_events()
            self.parser.parseLine('''L 08/26/2012 - 05:04:55: "courgette<2><STEAM_1:0:1111111><CT>" triggered "f00"''')
            # THEN
            self.assertEqual([], self.evt_queue)
            self.assertTrue(warning_mock.called)
            warning_mock.assert_has_calls([call("unknown client event : 'f00'. Please report this on the B3 forums")])


    def test_team_triggered_event__known(self):
        def assert_unknown_event_warning_called(event_name, expect_unknown=True):
            with patch.object(self.parser, "warning") as warning_mock:
                # WHEN
                self.clear_events()
                self.parser.parseLine('''L 08/26/2012 - 03:48:09: Team "CT" triggered "%s" (CT "3") (T "5")''' % event_name)
                # THEN
            self.assertEqual([], self.evt_queue)
            self.assertEqual(expect_unknown, warning_mock.called, warning_mock.mock_calls)
            if expect_unknown:
                warning_mock.assert_has_calls([call("unexpected team event : '%s'. Please report this on the B3 forums" % event_name)])

        assert_unknown_event_warning_called("bar")
        assert_unknown_event_warning_called("SFUI_Notice_Target_Saved", expect_unknown=False)
        assert_unknown_event_warning_called("SFUI_Notice_Target_Bombed", expect_unknown=False)
        assert_unknown_event_warning_called("SFUI_Notice_Terrorists_Win", expect_unknown=False)
        assert_unknown_event_warning_called("SFUI_Notice_CTs_Win", expect_unknown=False)
        assert_unknown_event_warning_called("SFUI_Notice_Bomb_Defused", expect_unknown=False)


    def test_client_say(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111", team=TEAM_BLUE)
        player.connects("2")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 05:09:55: "courgette<2><STEAM_1:0:1111111><CT>" say "!iamgod"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", "!iamgod", player)


    def test_client_say__no_team(self):
        # GIVEN
        player = FakeClient(self.parser, name="Spoon", guid="STEAM_1:0:10000000", team=TEAM_UNKNOWN)
        player.connects("2")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 09/16/2012 - 04:55:17: "Spoon<2><STEAM_1:0:10000000><>" say "!h"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", "!h", player)


    def test_client_teamsay(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111", team=TEAM_BLUE)
        player.connects("2")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 05:04:44: "courgette<2><STEAM_1:0:1111111><CT>" say_team "team say"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_TEAM_SAY", "team say", player)


    def test_bad_rcon_password(self):
        # GIVEN
        with patch.object(self.parser, "error") as error_mock:
            # WHEN
            self.parser.parseLine('''L 08/26/2012 - 05:21:23: rcon from "78.207.134.100:15073": Bad Password''')
            # THEN
            self.assertTrue(error_mock.called)
            error_mock.assert_has_calls([call('Bad RCON password, check your b3.xml file')])


    def test_clantag(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111", team=TEAM_BLUE)
        player.connects("2")
        # WHEN
        self.assertFalse(hasattr(player, "clantag"))
        self.parser.parseLine('''L 08/26/2012 - 05:43:31: "courgette<2><STEAM_1:0:1111111><CT>" triggered "clantag" (value "f00")''')
        # THEN
        self.assertEqual("f00", player.clantag)


    def test_Banid(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")
        # WHEN
        player.disconnects() # ban
        self.clear_events()
        self.parser.parseLine('''L 08/28/2012 - 00:03:01: Banid: "courgette<91><STEAM_1:0:1111111><>" was banned "for 1.00 minutes" by "Console"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_BAN_TEMP", {'reason': None, 'duration': '1.00 minutes', 'admin': 'Console'}, player)


    def test_kick(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")
        # WHEN
        player.disconnects() # kick
        self.clear_events()
        self.parser.parseLine('''L 08/28/2012 - 00:12:07: [basecommands.smx] "Console<0><Console><Console>" kicked "courgette<91><STEAM_1:0:1111111><>" (reason "f00")''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KICK", 'f00', player)


    def test_EVT_SUPERLOGS_WEAPONSTATS(self):
        # GIVEN
        bot48 = FakeClient(self.parser, name="Gunner", guid="BOT_48", team=TEAM_RED)
        bot48.connects("48")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/28/2012 - 14:58:55: "Gunner<48><BOT><CT>" triggered "weaponstats" (weapon "m4a1") (shots "13") (hits "2") (kills "0") (headshots "0") (tks "0") (damage "42") (deaths "0")''')
        # THEN
        self.assert_has_event("EVT_SUPERLOGS_WEAPONSTATS", client=bot48, data={
            'weapon': "m4a1",
            'shots': "13",
            'hits': "2",
            'kills': "0",
            'headshots': "0",
            'tks': "0",
            'damage': "42",
            'deaths': "0",
        })


    def test_EVT_SUPERLOGS_WEAPONSTATS2(self):
        # GIVEN
        bot = FakeClient(self.parser, name="Vitaliy", guid="BOT_51", team=TEAM_RED)
        bot.connects("51")
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/28/2012 - 14:58:55: "Vitaliy<51><BOT><CT>" triggered "weaponstats2" (weapon "famas") (head "0") (chest "0") (stomach "1") (leftarm "0") (rightarm "0") (leftleg "0") (rightleg "0")''')
        # THEN
        self.assert_has_event("EVT_SUPERLOGS_WEAPONSTATS2", client=bot, data={
            'weapon': "famas",
            'head': "0",
            'chest': "0",
            'stomach': "1",
            'leftarm': "0",
            'rightarm': "0",
            'leftleg': "0",
            'rightleg': "0",
        })


    def test_unknown_line(self):
        # GIVEN
        with patch.object(self.parser, "warning") as warning_mock:
            # WHEN
            self.clear_events()
            self.parser.parseLine('''L 08/26/2012 - 05:04:55: f00''')
            # THEN
            self.assertEqual([], self.evt_queue)
            self.assertTrue(warning_mock.called)
            warning_mock.assert_has_calls([call('unhandled log line : f00. Please report this on the B3 forums')])


    def test_killed_with_SuperLogs_plugin(self):
        # GIVEN
        bot22 = FakeClient(self.parser, name="Pheonix", guid="BOT_22", team=TEAM_BLUE)
        bot17 = FakeClient(self.parser, name="Ringo", guid="BOT_17", team=TEAM_RED)
        bot4 = FakeClient(self.parser, name="F00", guid="BOT_4", team=TEAM_BLUE)
        bot22.connects("22")
        bot17.connects("17")
        bot4.connects("4")

        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/29/2012 - 22:26:59: World triggered "killlocation" (attacker_position "-282 749 -21") (victim_position "68 528 64")''')
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "Pheonix<22><BOT><TERRORIST>" killed "Ringo<17><BOT><CT>" with "glock" (headshot)''')
        self.parser.parseLine('''L 08/26/2012 - 03:46:44: "F00<4><BOT><TERRORIST>" killed "Ringo<17><BOT><CT>" with "glock" (headshot)''')
        # THEN
        self.assert_has_event("EVT_CLIENT_KILL", client=bot22, target=bot17, data=(100, 'glock', 'head', None, {'attacker_position': "-282 749 -21", 'victim_position': "68 528 64"}))
        self.assert_has_event("EVT_CLIENT_KILL", client=bot4, target=bot17, data=(100, 'glock', 'head', None))


    def test_basechat_smx(self):
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 09/12/2012 - 23:15:47: [basechat.smx] "Console<0><Console><Console>" triggered sm_say (text f00)''')
        # THEN
        self.assertListEqual([], self.evt_queue)


    def test_rcon_from(self):
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 09/12/2012 - 23:24:02: rcon from "78.207.134.100:3804": command "sm_say fOO)"''')
        # THEN
        self.assertListEqual([], self.evt_queue)


    def test_server_need_restart(self):
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 09/17/2012 - 23:41:44: Your server needs to be restarted in order to receive the latest update.''')
        # THEN
        self.assert_has_event("EVT_SERVER_REQUIRES_RESTART", data="Your server needs to be restarted in order to receive the latest update.")

    def test_server_need_restart_2(self):
        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 09/17/2012 - 23:41:44: Your server is out of date.  Please update and restart.''')
        # THEN
        self.assert_has_event("EVT_SERVER_REQUIRES_RESTART", data="Your server is out of date.  Please update and restart.")




class Test_parser_API(CsgoTestCase):

    def setUp(self):
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = CsgoParser(self.conf)
        self.parser.output = Mock()
        when(self.parser.output).write("status").thenReturn(STATUS_RESPONSE)
        when(self.parser).is_sourcemod_installed().thenReturn(True)
        self.parser.startup()

    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False


    def test_getPlayerList(self):
        # GIVEN
        with patch.object(self.parser, "queryServerInfo") as queryServerInfo_Mock:
            # WHEN
            c3 = Mock()
            c4 = Mock()
            c12 = Mock()
            queryServerInfo_Mock.return_value = {'3': c3, '4': c4, '12': c12, }
            rv = self.parser.getPlayerList()
            # THEN
            self.assertDictEqual({'3': c3, '4': c4, '12': c12, }, rv)


    def test_say(self):
        self.parser.msgPrefix = "[Pre]"
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.say("f00")
            write_mock.assert_has_calls([call('sm_say [Pre] f00')])


    def test_saybig(self):
        self.parser.msgPrefix = "[Pre]"
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.saybig("f00")
            write_mock.assert_has_calls([call('sm_hsay [Pre] f00')])

#    @unittest.skipIf(WAS_FROSTBITE_LOADED, "Frostbite(1|2) parsers monkey patch the Client class and make this test fail")
    def test_message(self):
        self.parser.msgPrefix = "[Pre]"
        player = Client(console=self.parser, guid="theGuid")
        with patch.object(self.parser.output, 'write') as write_mock:
            player.message("f00")
            write_mock.assert_has_calls([call('sm_psay #theGuid "[Pre] f00"')])


    def test_kick(self):
        player = Client(console=self.parser, cid="4", guid="theGuid", name="theName")
        with patch.object(self.parser.output, 'write') as write_mock:
            player.kick(reason="f00")
            write_mock.assert_has_calls([call('sm_kick #4 f00')])


    def test_ban(self):
        # GIVEN
        player = Client(console=self.parser, cid="2", name="courgette", guid="STEAM_1:0:1111111")
        # WHEN
        self.clear_events()
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.ban(player, reason="test")
        # THEN
        write_mock.assert_has_calls([call('sm_addban 0 "STEAM_1:0:1111111" test'),
                                     call('sm_kick #2 test'),
                                     call('sm_say courgette was banned test')])


    def test_ban__not_connected(self):
        # GIVEN
        player = Client(console=self.parser, cid=None, name="courgette", guid="STEAM_1:0:1111111")
        # WHEN
        self.clear_events()
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.ban(player, reason="test")
        # THEN
        write_mock.assert_has_calls([call('sm_addban 0 "STEAM_1:0:1111111" test'),
                                     call('sm_say courgette was banned test')])


    def test_unban(self):
        # GIVEN
        player = Client(console=self.parser, cid=None, name="courgette", guid="STEAM_1:0:1111111")
        # WHEN
        self.clear_events()
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.unban(player)
        # THEN
        write_mock.assert_has_calls([call('sm_unban "STEAM_1:0:1111111"')])



    def test_tempban(self):
        # GIVEN
        player = Client(console=self.parser, cid="2", name="courgette", guid="STEAM_1:0:1111111")
        # WHEN
        self.clear_events()
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.tempban(player, reason="test", duration="45m")
        # THEN
        write_mock.assert_has_calls([call('sm_addban 45 "STEAM_1:0:1111111" test'),
                                     call('sm_kick #2 test'),
                                     call('sm_say courgette was temp banned for 45 minutes test')])


    def test_getMap(self):
        # WHEN
        rv = self.parser.getMap()
        # THEN
        self.assertEqual('cs_foobar', rv)


    def test_getMaps(self):
        when(self.parser.output).write("listmaps").thenReturn('''Map Cycle:
cs_italy
de_dust
de_aztec
cs_office
de_dust2
de_train
de_inferno
de_nuke
L 08/28/2012 - 01:16:28: rcon from "11.222.111.222:4107": command "listmaps"
''')
        maps = self.parser.getMaps()
        verify(self.parser.output).write("listmaps")
        self.assertListEqual(["cs_italy",
                              "de_dust",
                              "de_aztec",
                              "cs_office",
                              "de_dust2",
                              "de_train",
                              "de_inferno",
                              "de_nuke",
                              ], maps)


    @patch('time.sleep')
    def test_rotateMap(self, sleep_mock):
        # GIVEN
        when(self.parser).getNextMap().thenReturn('the_next_map')
        # WHEN
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.rotateMap()
        # THEN
        write_mock.assert_has_calls([call('sm_hsay Changing to next map : the_next_map'),
                                     call('map the_next_map')])
        sleep_mock.assert_was_called_once_with(1)


    def test_changeMap(self):
        # GIVEN
        when(self.parser).getMapsSoundingLike("de_f00").thenReturn("de_f00")
        # WHEN
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.changeMap("de_f00")
        # THEN
        write_mock.assert_has_calls([call('sm_map de_f00')])


    def test_changeMap__suggestions(self):
        # GIVEN
        when(self.parser).getMapsSoundingLike("f00").thenReturn(["de_f001", "de_f002"])
        # WHEN
        with patch.object(self.parser.output, 'write') as write_mock:
            rv = self.parser.changeMap("f00")
        # THEN
        self.assertSetEqual(set(["de_f001", "de_f002"]), set(rv))
        self.assertEqual(0, write_mock.call_count)


    def test_getPlayerPings(self):
        # GIVEN
        with patch.object(self.parser, "queryServerInfo") as queryServerInfo_Mock:
            # WHEN
            queryServerInfo_Mock.return_value = {
                '3': Client(ping="45"),
                '4': Client(ping="112"),
                '12': Client(ping="54"),
            }
            rv = self.parser.getPlayerPings()
            # THEN
            self.assertEqual(3, len(rv))
            self.assertEqual("45", rv['3'])
            self.assertEqual("112", rv['4'])
            self.assertEqual("54", rv['12'])


    @unittest.skip("TODO")
    def test_getPlayerScores(self):
        pass


    @unittest.skip("TODO")
    def test_inflictCustomPenalty(self):
        pass




class Test_parser_other(CsgoTestCase):

    def test_getTeam(self):
        self.assertEqual(TEAM_RED, self.parser.getTeam('CT'))
        self.assertEqual(TEAM_BLUE, self.parser.getTeam('TERRORIST'))
        self.assertEqual(TEAM_UNKNOWN, self.parser.getTeam('Unassigned'))


    def test_getNextMap(self):
        when(self.parser.output).write("sm_nextmap").thenReturn('''\
"sm_nextmap" = "de_dust" ( def. "" ) notify
L 09/18/2012 - 00:10:00: rcon from "78.207.134.100:4652": command "sm_nextmap"
''')
        nextmap = self.parser.getNextMap()
        verify(self.parser.output).write("sm_nextmap")
        self.assertEqual('de_dust', nextmap)


    def test_getAvailableMaps(self):
        when(self.parser.output).write("maps *").thenReturn("""\
-------------
PENDING:   (fs) ar_baggage.bsp
PENDING:   (fs) ar_shoots.bsp
PENDING:   (fs) cs_italy.bsp
PENDING:   (fs) cs_italy_se.bsp
PENDING:   (fs) cs_office.bsp
PENDING:   (fs) training1.bsp""")
        maps = self.parser.getAvailableMaps()
        verify(self.parser.output).write("maps *")
        self.assertListEqual(["ar_baggage", "ar_shoots", "cs_italy", "cs_italy_se", "cs_office", "training1"], maps)


    def test_getMapsSoundingLike(self):
        # GIVEN
        available_maps = ["ar_baggage", "ar_shoots", "cs_italy", "cs_italy_se", "de_bank", "de_dust"]
        when(self.parser).getAvailableMaps().thenReturn(available_maps)
        # THEN searching for a map by its exact name should return that map
        for available_map in available_maps:
            self.assertEqual(available_map, self.parser.getMapsSoundingLike(available_map))
        # THEN searching for a map by a close name should return the correct name
        self.assertEqual("ar_baggage", self.parser.getMapsSoundingLike("baggage"))
        self.assertEqual("ar_baggage", self.parser.getMapsSoundingLike("bagg"))
        self.assertEqual("ar_baggage", self.parser.getMapsSoundingLike("bag"))
        self.assertEqual("ar_shoots", self.parser.getMapsSoundingLike("shoots"))
        self.assertEqual("ar_shoots", self.parser.getMapsSoundingLike("shoot"))
        self.assertEqual("de_bank", self.parser.getMapsSoundingLike("bank"))
        self.assertEqual("de_dust", self.parser.getMapsSoundingLike("dust"))
        # THEN searching for a map by a unknown name should return suggestions
        self.assertSetEqual(set(["ar_baggage", "ar_shoots"]) , set(self.parser.getMapsSoundingLike("ar")))
        self.assertSetEqual(set(["cs_italy", "cs_italy_se"]) , set(self.parser.getMapsSoundingLike("cs")))
        self.assertSetEqual(set(["de_bank", "de_dust"]) , set(self.parser.getMapsSoundingLike("de")))
        self.assertSetEqual(set(["cs_italy", "cs_italy_se"]) , set(self.parser.getMapsSoundingLike("italy")))


    def test_queryServerInfo(self):
        # WHEN
        rv = self.parser.queryServerInfo()
        # THEN
        self.assertEqual('cs_foobar', self.parser.game.mapName)
        self.assertEqual("Courgette's Server", self.parser.game.sv_hostname)
        self.assertEqual(1, len(rv))
        client = rv["194"]
        self.assertEqual("194", client.cid)
        self.assertEqual("courgette", client.name)
        self.assertEqual("STEAM_1:0:1111111", client.guid)
        self.assertEqual("67", client.ping)
        self.assertEqual("11.222.111.222", client.ip)


    def test_status_response_utf8_encoded(self):
        def assert_client(rv, cid, name, guid, ping, ip):
            self.assertIn(cid, rv)
            client = rv[cid]
            self.assertEqual(cid, client.cid)
            self.assertEqual(name, client.name)
            self.assertEqual(guid, client.guid)
            self.assertEqual(ping, client.ping)
            self.assertEqual(ip, client.ip)

        # GIVEN
        self.status_response = b'''\
hostname: UK - #2 Zombie Escape || FastDL - EHDGaming.co.uk [B3]
version : 1.18.0.3/11803 5045 secure
udp/ip  : 109.70.148.17:27017  (public ip: 109.70.148.17)
os      :  Windows
type    :  community dedicated
players : 14 humans, 0 bots (56/56 max) (not hibernating)

# userid name uniqueid connected ping loss state rate adr
# 12 1 "nooky treac" STEAM_1:1:00000807 28:23 505 6 spawning 30000 111.111.181.248:27005
#  4 2 "karta218" STEAM_1:0:00000003 34:30 548 0 spawning 10000 111.111.114.142:27005
# 30 3 "\xe9\xaa\xa8 xX Assassine Xx \xe9\xaa\xa8 ;)" STEAM_1:0:00000823 00:05 111 82 spawning 30000 194.208.143.16:27005
#  6 4 "Spoon" STEAM_1:0:00000181 33:33 43 0 active 30000 111.111.82.35:27005
#  7 5 "MercenarianWolf" STEAM_1:1:00000526 30:31 320 0 spawning 10000 111.111.13.88:27005
# 10 6 "eci" STEAM_1:0:00000740 28:47 35 16 active 30000 111.111.74.202:27005
# 11 8 "The Artist" STEAM_1:1:00000719 28:37 64 0 active 30000 111.111.93.239:27005
# 27 9 "=LIS=" STEAM_1:1:00000643 03:41 61 0 active 30000 111.111.30.26:27005
# 15 10 "ErayTR" STEAM_1:1:00000976 25:32 108 0 active 30000 111.111.117.145:27005
# 28 11 "ackop6uhka96" STEAM_1:1:00000052 02:16 90 0 active 30000 111.111.229.26:27005
# 25 12 "\xd0\xba\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd1\x81\xd0\xbe\xd1\x81\xd1\x83\xd1\x88\xd0\xb8\xd0\xb9" STEAM_1:1:00000018 04:11 91 0 active 20000 111.111.237.162:27594
# 29 13 "WahOO" STEAM_1:1:00000678 00:22 69 0 active 20000 111.111.98.248:27005
# 23 14 "M\xe1\xb9\xa2 Xilver" STEAM_1:0:00000813 09:22 131 0 spawning 30000 111.111.215.27:27005
# 26 15 "Argon" STEAM_1:1:00000243 04:04 163 0 spawning 30000 111.111.197.113:27005
#end
L 09/10/2012 - 15:21:28: rcon from "109.70.148.17:3552": command "status"'''.decode('UTF-8')
        # WHEN
        rv = self.parser.queryServerInfo()
        # THEN
        self.assertEqual('cs_foobar', self.parser.game.mapName)
        self.assertEqual('UK - #2 Zombie Escape || FastDL - EHDGaming.co.uk [B3]', self.parser.game.sv_hostname)
        self.assertEqual(14, len(rv))
        assert_client(rv, "12", "nooky treac", "STEAM_1:1:00000807", "505", "111.111.181.248")
        assert_client(rv, "4", "karta218", "STEAM_1:0:00000003", "548", "111.111.114.142")
        assert_client(rv, "30", u" xX Assassine Xx  ;)", "STEAM_1:0:00000823", "111", "194.208.143.16")
        self.assertIn("6", rv)
        self.assertIn("7", rv)
        self.assertIn("10", rv)
        self.assertIn("11", rv)
        self.assertIn("27", rv)
        self.assertIn("15", rv)
        self.assertIn("28", rv)
        assert_client(rv, "25", u"", "STEAM_1:1:00000018", "91", "111.111.237.162")
        assert_client(rv, "23", u"M Xilver", "STEAM_1:0:00000813", "131", "111.111.215.27")
        self.assertIn("26", rv)


    def test_loaded_sm_plugins(self):
        # GIVEN
        when(self.parser.output).write("sm plugins list").thenReturn('''\
[SM] Listing 19 plugins:
01 "Basic Ban Commands" (1.5.0-dev+3635) by AlliedModders LLC
02 "B3 Say" (1.0.0.0) by Spoon
03 "Basic Commands" (1.5.0-dev+3635) by AlliedModders LLC
04 "Fun Commands" (1.5.0-dev+3635) by AlliedModders LLC
05 "Basic Chat" (1.5.0-dev+3635) by AlliedModders LLC
06 "Admin Help" (1.5.0-dev+3635) by AlliedModders LLC
07 "Reserved Slots" (1.5.0-dev+3635) by AlliedModders LLC
08 "Sound Commands" (1.5.0-dev+3635) by AlliedModders LLC
09 "Player Commands" (1.5.0-dev+3635) by AlliedModders LLC
10 "Admin Menu" (1.5.0-dev+3635) by AlliedModders LLC
11 "Basic Votes" (1.5.0-dev+3635) by AlliedModders LLC
12 "Client Preferences" (1.5.0-dev+3635) by AlliedModders LLC
13 "Nextmap" (1.5.0-dev+3635) by AlliedModders LLC
14 "SuperLogs: CSS" (1.2.4) by psychonic
15 "Admin File Reader" (1.5.0-dev+3635) by AlliedModders LLC
16 "Basic Comm Control" (1.5.0-dev+3635) by AlliedModders LLC
17 "Basic Info Triggers" (1.5.0-dev+3635) by AlliedModders LLC
18 "Anti-Flood" (1.5.0-dev+3635) by AlliedModders LLC
19 "Fun Votes" (1.5.0-dev+3635) by AlliedModders LLC
L 09/13/2012 - 09:06:45: rcon from "78.207.134.100:2212": command "sm plugins list"''')
        # WHEN
        rv = self.parser.get_loaded_sm_plugins()
        # THEN
        self.assertDictEqual({
            "Basic Ban Commands": ("01", "1.5.0-dev+3635", "AlliedModders LLC"),
            "B3 Say": ("02", "1.0.0.0", "Spoon"),
            "Basic Commands": ("03", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Fun Commands": ("04", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Basic Chat": ("05", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Admin Help": ("06", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Reserved Slots": ("07", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Sound Commands": ("08", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Player Commands": ("09", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Admin Menu": ("10", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Basic Votes": ("11", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Client Preferences": ("12", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Nextmap": ("13", "1.5.0-dev+3635", "AlliedModders LLC"),
            "SuperLogs: CSS": ("14", "1.2.4", "psychonic"),
            "Admin File Reader": ("15", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Basic Comm Control": ("16", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Basic Info Triggers": ("17", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Anti-Flood": ("18", "1.5.0-dev+3635", "AlliedModders LLC"),
            "Fun Votes": ("19", "1.5.0-dev+3635", "AlliedModders LLC"),
        }, rv)



class Test_getClientOrCreate(CsgoTestCase):

    def test_new_client_with_cid_guid_name_team(self):
        # GIVEN
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 1}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName", team="CT")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("2", client.cid)
        self.assertEqual("AAAAAAAAAAAA000000000000000", client.guid)
        self.assertEqual("theName", client.name)
        self.assertEqual(TEAM_RED, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_new_client_with_cid_guid_name(self):
        # GIVEN
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 1}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("2", client.cid)
        self.assertEqual("AAAAAAAAAAAA000000000000000", client.guid)
        self.assertEqual("theName", client.name)
        self.assertEqual(TEAM_UNKNOWN, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_connected_client_by_cid(self):
        # GIVEN
        self.parser.clients.newClient(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName", team=TEAM_BLUE)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(cid="2", guid=None, name=None)
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("2", client.cid)
        self.assertEqual("AAAAAAAAAAAA000000000000000", client.guid)
        self.assertEqual("theName", client.name)
        self.assertEqual(TEAM_BLUE, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_connected_client_by_cid_different_name(self):
        # GIVEN
        self.parser.clients.newClient(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName", team=TEAM_BLUE)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(cid="2", guid=None, name="newName")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("2", client.cid)
        self.assertEqual("AAAAAAAAAAAA000000000000000", client.guid)
        self.assertEqual("newName", client.name)
        self.assertEqual(TEAM_BLUE, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_known_client_by_cid(self):
        # GIVEN
        known_client = Client(console=self.parser, guid="AAAAAAAAAAAA000000000000000", name="theName")
        known_client.save()
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(cid="2", guid="AAAAAAAAAAAA000000000000000", name="newName", team="CT")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual(known_client.id, client.id)
        self.assertEqual("2", client.cid)
        self.assertEqual("AAAAAAAAAAAA000000000000000", client.guid)
        self.assertEqual("newName", client.name)
        self.assertEqual(TEAM_RED, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_changing_team(self):
        # GIVEN
        client = self.parser.getClientOrCreate(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName", team="CT")
        self.assertEqual(TEAM_RED, client.team)

        def assertTeam(execpted_team, new_team):
            # WHEN
            self.parser.getClientOrCreate(cid="2", guid="AAAAAAAAAAAA000000000000000", name="theName", team=new_team)
            # THEN
            self.assertEqual(execpted_team, client.team)

        assertTeam(TEAM_RED, "CT")
        assertTeam(TEAM_RED, None)
        assertTeam(TEAM_RED, "")
        assertTeam(TEAM_RED, "f00")
        assertTeam(TEAM_RED, "Unassigned")
        assertTeam(TEAM_BLUE, "TERRORIST")



class Test_functional(CsgoTestCase):

    def test_banned_player_reconnects(self):
        # GIVEN
        player = FakeClient(self.parser, name="courgette", guid="STEAM_1:0:1111111")
        player.connects("2")
        self.assertEqual(0, player.numBans)
        player.ban(reason="test")
        self.assertEqual(1, player.numBans)
        player.disconnects()
        # WHEN
        with patch.object(player, "ban") as ban_mock:
            player.connects("3")
        # THEN
        ban_mock.assert_was_called_once()


    def test_clantag_and_say_with_weird_line(self):
        """
        Sometimes (is it from CS:GO patch http://store.steampowered.com/news/8855/ released on 9/14/2012 ?) we got the following line :

        L 09/18/2012 - 18:26:21: "Spoon<3><STEAM_1:0:11111111><EHD Gaming>" triggered "clantag" (value "EHD")
        where we find the Clan name in place of the player team and the Clan tag in the 'value' property.

        It would have been better to have something like
        L 09/18/2012 - 18:26:21: "Spoon<3><STEAM_1:0:11111111><CT>" triggered "clantag" (value "EHD") (clanname "EHD Gaming")

        Also, after that, 'say' lines get affected in the same way :
        L 09/18/2012 - 18:26:35: "Spoon<3><STEAM_1:0:11111111><EHD Gaming>" say "!lt"
        In such case we need to make sure we are not loosing the correct team value
        """
        # GIVEN
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><>" connected, address "11.222.111.222:27005"''')
        player = self.parser.getClient("2")
        self.assertEqual("STEAM_1:0:1111111", player.guid)
        self.assertFalse(hasattr(player, "clantag"))
        self.parser.parseLine('''L 08/26/2012 - 03:22:36: "courgette<2><STEAM_1:0:1111111><Unassigned>" joined team "CT"''')
        self.assertEqual(TEAM_RED, player.team)

        # WHEN
        self.parser.parseLine('''L 08/26/2012 - 05:43:31: "courgette<2><STEAM_1:0:1111111><The Clan Name>" triggered "clantag" (value "TCN")''')
        # THEN
        self.assertEqual("TCN", getattr(player, "clantag", None))
        self.assertEqual(TEAM_RED, player.team) # make sure we do not break existing correct team value

        # WHEN
        self.clear_events()
        self.parser.parseLine('''L 08/26/2012 - 05:09:55: "courgette<2><STEAM_1:0:1111111><The Clan Name>" say "blah blah blah"''')
        # THEN
        self.assert_has_event("EVT_CLIENT_SAY", "blah blah blah", player)
        self.assertEqual(TEAM_RED, player.team) # make sure we do not break existing correct team value

########NEW FILE########
__FILENAME__ = test_iourt41
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mockito import mock, when, any, verify
from mock import Mock, patch, ANY
import unittest2 as unittest
import b3
from b3.clients import Client
from b3.config import XmlConfigParser
from b3.events import Event
from b3.fake import FakeClient
from b3.parsers.iourt41 import Iourt41Parser

log = logging.getLogger("test")
log.setLevel(logging.INFO)

class Iourt41TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing iourt41 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Iourt41Parser -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Iourt41Parser(self.parser_conf)
        self.console.PunkBuster = None # no Punkbuster support in that game

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = write


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False


class Test_parser_API_implementation(Iourt41TestCase):
    """Test case that is responsible for testing all methods of the b3.parser.Parser class API that
    have to override because they have to talk to their targeted game server in their specific way"""

    def test_getPlayerList(self):
        """\
        Query the game server for connected players.
        return a dict having players' id for keys and players' data as another dict for values
        """
        when(self.output_mock).write('status', maxRetries=any()).thenReturn("""\
map: ut4_casa
num score ping name            lastmsg  address              qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
10     0   13 snowwhite        0       192.168.1.11:51034     9992 15000
12     0   10 superman         0       192.168.1.12:53039     9993 15000
""")
        result = self.console.getPlayerList()
        verify(self.output_mock).write('status', maxRetries=any())
        self.assertDictEqual({'10': {'ip': '192.168.1.11',
                                     'last': '0',
                                     'name': 'snowwhite',
                                     'pbid': None,
                                     'ping': '13',
                                     'port': '51034',
                                     'qport': '9992',
                                     'rate': '15000',
                                     'score': '0',
                                     'slot': '10'},
                              '12': {'ip': '192.168.1.12',
                                     'last': '0',
                                     'name': 'superman',
                                     'pbid': None,
                                     'ping': '10',
                                     'port': '53039',
                                     'qport': '9993',
                                     'rate': '15000',
                                     'score': '0',
                                     'slot': '12'}}
            , result)


    def test_authorizeClients(self):
        """\
        For all connected players, fill the client object with properties allowing to find
        the user in the database (usualy guid, or punkbuster id, ip) and call the
        Client.auth() method
        """
        superman = mock()
        self.console.clients = mock()
        when(self.console.clients).getByCID("12").thenReturn(superman)
        when(self.output_mock).write('status', maxRetries=any()).thenReturn("""\
map: ut4_casa
num score ping name            lastmsg  address              qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
12     0   10 superman         0       192.168.1.12:53039     9993 15000
""")
        self.console.authorizeClients()
        verify(self.output_mock).write('status', maxRetries=any())
        verify(superman).auth()


    def test_sync(self):
        """\
        For all connected players returned by self.getPlayerList(), get the matching Client
        object from self.clients (with self.clients.getByCID(cid) or similar methods) and
        look for inconsistencies. If required call the client.disconnect() method to remove
        a client from self.clients.
        This is mainly useful for games where clients are identified by the slot number they
        occupy. On map change, a player A on slot 1 can leave making room for player B who
        connects on slot 1.
        """
        self.console.sync()
        verify(self.output_mock).write('status', maxRetries=any())


    def test_say(self):
        """\
        broadcast a message to all players
        """
        self.console.msgPrefix = "B3:"
        self.console.say("something")
        verify(self.output_mock).write('say B3: something')


    def test_saybig(self):
        """\
        broadcast a message to all players in a way that will catch their attention.
        """
        self.console.msgPrefix = "B3:"
        self.console.saybig("something")
        verify(self.output_mock).write('bigtext "B3: something"')


    def test_message(self):
        """\
        display a message to a given player
        """
        superman = Client(console=self.console, cid="11")
        self.console.msgPrefix = "B3:"
        self.console.message(superman, "something")
        verify(self.output_mock).write('tell 11 B3: ^3[pm]^7 something')


    def test_kick(self):
        """\
        kick a given player
        """
        self.console.getMessage = Mock(return_value="")
        superman = mock()
        superman.cid="11"
        self.console.kick(superman)
        verify(self.output_mock).write('clientkick 11')
        verify(superman).disconnect()

    def test_ban(self):
        """\
        ban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN', data={'reason': reason,
        'admin': admin}, client=target)
        """
        self.console.getMessage = Mock(return_value="")
        superman = mock()
        superman.cid="11"
        self.console.ban(superman)
        verify(self.output_mock).write('addip 11')
        verify(superman).disconnect()


    def test_unban(self):
        """\
        unban a given player on the game server
        """
        superman = mock()
        superman.ip="1.1.3.4"
        self.console.unban(superman)
        verify(self.output_mock, times=5).write('removeip 1.1.3.4')


    def test_tempban(self):
        """\
        tempban a given player on the game server and in case of success
        fire the event ('EVT_CLIENT_BAN_TEMP', data={'reason': reason,
        'duration': duration, 'admin': admin}, client=target)
        """
        self.console.getMessage = Mock(return_value="")
        superman = mock()
        superman.cid="11"
        self.console.tempban(superman)
        verify(self.output_mock).write('clientkick 11')
        verify(superman).disconnect()


    def test_getMap(self):
        """\
        return the current map/level name
        """
        when(self.output_mock).write('status').thenReturn("""\
map: ut4_casa
num score ping name            lastmsg  address              qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
12     0   10 superman         0       192.168.1.12:53039     9993 15000
""")
        map = self.console.getMap()
        verify(self.output_mock).write('status')
        self.assertEqual("ut4_casa", map)


    def test_getMaps(self):
        """\
        return the available maps/levels name
        """
        when(self.output_mock).write('fdir *.bsp').thenReturn("""\

---------------
maps/ut4_abbey.bsp
maps/ut4_algiers.bsp
maps/ut4_austria.bsp
maps/ut4_casa.bsp
""")
        maps = self.console.getMaps()
        verify(self.output_mock).write('fdir *.bsp')
        self.assertSetEqual(set(['ut4_abbey', 'ut4_algiers', 'ut4_austria', 'ut4_casa']), set(maps))


    def test_rotateMap(self):
        """\
        load the next map/level
        """
        with patch("time.sleep"):
            self.console.rotateMap()
        verify(self.output_mock).write('cyclemap')


    @patch("time.sleep")
    def test_changeMap(self, sleep_mock):
        """\
        load a given map/level
        return a list of suggested map names in cases it fails to recognize the map that was provided
        """
        when(self.output_mock).write('fdir *.bsp').thenReturn("""\

---------------
maps/ut4_abbey.bsp
maps/ut4_abbeyctf.bsp
maps/ut4_algiers.bsp
maps/ut4_austria.bsp
maps/ut4_casa.bsp
""")
        suggestions = self.console.changeMap('algier')
        self.assertIsNone(suggestions)
        verify(self.output_mock).write('map ut4_algiers')

        suggestions = self.console.changeMap('bey')
        self.assertIsNotNone(suggestions)
        self.assertSetEqual(set(['ut4_abbey', 'ut4_abbeyctf']), set(suggestions))



    @patch("time.sleep")
    def test_changeMap_2(self, sleep_mock):
        """\
        see http://forum.bigbrotherbot.net/urt/!map-x-bug/msg37759/#msg37759
        """
        when(self.output_mock).write('fdir *.bsp').thenReturn("""\
---------------
maps/ut4_abbey.bsp
maps/ut4_abbeyctf.bsp
maps/ut4_algiers.bsp
maps/ut4_ambush.bsp
maps/ut4_area3_b4.bsp
maps/ut4_asylum_b1.bsp
maps/ut4_austria.bsp
maps/ut4_aztek_b2.bsp
maps/ut4_baeza.bsp
maps/ut4_beijing_b3.bsp
maps/ut4_blackhawk.bsp
maps/ut4_blitzkrieg.bsp
maps/ut4_boxtrot_x6.bsp
maps/ut4_cambridge_b1.bsp
maps/ut4_cambridge_fixed.bsp
maps/ut4_casa.bsp
maps/ut4_commune.bsp
maps/ut4_company.bsp
maps/ut4_crossing.bsp
maps/ut4_deception_v2.bsp
maps/ut4_desolate_rc1.bsp
maps/ut4_docks.bsp
maps/ut4_dressingroom.bsp
maps/ut4_druglord2.bsp
maps/ut4_dust2_v2.bsp
maps/ut4_dust2_v3b.bsp
maps/ut4_eagle.bsp
maps/ut4_eezabad.bsp
maps/ut4_elgin.bsp
maps/ut4_exhibition_a24.bsp
maps/ut4_facade_b5.bsp
maps/ut4_ferguson_b12.bsp
maps/ut4_firingrange.bsp
maps/ut4_granja.bsp
maps/ut4_guerrilla.bsp
maps/ut4_harbortown.bsp
maps/ut4_heroic_beta1.bsp
maps/ut4_herring.bsp
maps/ut4_horror.bsp
maps/ut4_kingdom.bsp
maps/ut4_kingdom_rc6.bsp
maps/ut4_kingpin.bsp
maps/ut4_mandolin.bsp
maps/ut4_maximus_v1.bsp
maps/ut4_maya.bsp
maps/ut4_metropolis_b2.bsp
maps/ut4_oildepot.bsp
maps/ut4_orbital_sl.bsp
maps/ut4_pandora_b7.bsp
maps/ut4_paradise.bsp
maps/ut4_paris_v2.bsp
maps/ut4_poland_b11.bsp
maps/ut4_prague.bsp
maps/ut4_ramelle.bsp
maps/ut4_ricochet.bsp
maps/ut4_riyadh.bsp
maps/ut4_roma_beta2b.bsp
maps/ut4_sanc.bsp
maps/ut4_shahideen.bsp
maps/ut4_snoppis.bsp
maps/ut4_subterra.bsp
maps/ut4_suburbs.bsp
maps/ut4_subway.bsp
maps/ut4_swim.bsp
maps/ut4_terrorism7.bsp
maps/ut4_thingley.bsp
maps/ut4_tohunga_b8.bsp
maps/ut4_tombs.bsp
maps/ut4_toxic.bsp
maps/ut4_train_dl1.bsp
maps/ut4_tunis.bsp
maps/ut4_turnpike.bsp
maps/ut4_uptown.bsp
maps/ut4_venice_b7.bsp
maps/ut4_village.bsp
75 files listed
""")
        suggestions = self.console.changeMap('tohunga')
        self.assertIsNone(suggestions)
        verify(self.output_mock).write('map ut4_tohunga_b8')



    def test_getPlayerPings(self):
        """\
        returns a dict having players' id for keys and players' ping for values
        """
        when(self.output_mock).write('status').thenReturn("""\
map: ut4_casa
num score ping name            lastmsg  address              qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
10     0   13 snowwhite        0       192.168.1.11:51034     9992 15000
12     0  110 superman         0       192.168.1.12:53039     9993 15000
""")
        pings = self.console.getPlayerPings()
        self.assertDictEqual({'10': 13, '12': 110}, pings)


    def test_getPlayerScores(self):
        """\
        returns a dict having players' id for keys and players' scores for values
        """
        when(self.output_mock).write('status').thenReturn("""\
map: ut4_casa
num score ping name            lastmsg  address              qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
10     5   13 snowwhite        0       192.168.1.11:51034     9992 15000
12    27  110 superman         0       192.168.1.12:53039     9993 15000
""")
        pings = self.console.getPlayerScores()
        self.assertDictEqual({'10': 5, '12': 27}, pings)


    def test_inflictCustomPenalty(self):
        """
        Called if b3.admin.penalizeClient() does not know a given penalty type.
        Overwrite this to add customized penalties for your game like 'slap', 'nuke',
        'mute', 'kill' or anything you want.
        /!\ This method must return True if the penalty was inflicted.
        """
        superman = mock()
        superman.cid="11"
        # slap
        result = self.console.inflictCustomPenalty('slap', superman)
        verify(self.output_mock).write('slap 11')
        self.assertTrue(result)
        # nuke
        result = self.console.inflictCustomPenalty('nuke', superman)
        verify(self.output_mock).write('nuke 11')
        self.assertTrue(result)
        # mute
        result = self.console.inflictCustomPenalty('mute', superman, duration="15s")
        verify(self.output_mock).write('mute 11 15.0')
        self.assertTrue(result)



class Test_OnClientuserinfo(Iourt41TestCase):

    def setUp(self):
        super(Test_OnClientuserinfo, self).setUp()
        self.console.PunkBuster = None

    def test_ioclient(self):
        infoline = r"2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65"
        self.assertFalse('2' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('2' in self.console.clients)
        client = self.console.clients['2']
        self.assertEqual('145.99.135.227', client.ip)
        self.assertEqual('[SNT]^1XLR^78or^7', client.exactName)
        self.assertEqual('[SNT]XLR8or', client.name)
        self.assertEqual('58D4069246865BB5A85F20FB60ED6F65', client.guid)

    def test_bot(self):
        infoline = r"0 \gear\GMIORAA\team\blue\skill\5.000000\characterfile\bots/ut_chicken_c.c\color\4\sex\male\race\2\snaps\20\rate\25000\name\InviteYourFriends!"
        self.assertFalse('0' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('0' in self.console.clients)
        client = self.console.clients['0']
        self.assertEqual('0.0.0.0', client.ip)
        self.assertEqual('InviteYourFriends!^7', client.exactName)
        self.assertEqual('InviteYourFriends!', client.name)
        self.assertEqual('BOT0', client.guid)


    def test_quake3_client(self):
        infoline = r"2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0"
        self.assertFalse('2' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('2' in self.console.clients)
        client = self.console.clients['2']
        self.assertEqual('145.99.135.227', client.ip)
        self.assertEqual('[SNT]^1XLR^78or^7', client.exactName)
        self.assertEqual('[SNT]XLR8or', client.name)
        self.assertEqual('145.99.135.227', client.guid)


    def test_client_with_password_gamepassword(self):
        """
        Case where a player saved the password to join the game in its UrT config. As a result, we find a 'password'
        field in the clientuserinfo line.
        This value must not overwrite the 'password' property of the Client object.
        """
        # GIVEN a known client
        c = FakeClient(console=self.console, name="Zesco", guid="58D4069246865BB5A85F20FB60ED6F65", login="login_in_database", password="password_in_database")
        c.save()
        c.connects('15')
        self.assertEqual('password_in_database', c.password)
        # WHEN
        infoline = r"15 \ip\1.2.3.4:27960\name\Zesco\password\some_password_here\racered\2\raceblue\3\rate\8000\ut_timenudge\0\cg_rgb\128 128 128\cg_predictitems\0\cg_physics\1\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\gear\GMIORAA\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65\weapmodes\00000110120000020002"
        self.assertTrue('15' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        # THEN
        client = self.console.clients['15']
        self.assertEqual('1.2.3.4', client.ip)
        self.assertEqual('Zesco^7', client.exactName)
        self.assertEqual('Zesco', client.name)
        self.assertEqual('58D4069246865BB5A85F20FB60ED6F65', client.guid)
        self.assertEqual('password_in_database', client.password)




class Test_pluginsStarted(Iourt41TestCase):

    def test_hacker_with_no_ip(self):
        """ see http://forum.bigbrotherbot.net/general-usage-support/iourt41-py-1-11-5-error/msg34328/ """
        when(self.console).write("status", maxRetries=ANY).thenReturn(r"""\
map: ut4_uberjumps_beta3
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
10    -2   53 [PoliSh TeAm] Haxxer^7      0 80.54.100.100:27960      31734 25000""")

        when(self.console).write('dumpuser 10').thenReturn('userinfo\n--------\ngear                FLAATWA\ncl_packetdup        2\nrate                25000\nname                [PoliSh TeAm] Haxxer\nracered             2\nraceblue            2\nut_timenudge        0\ncg_rgb              255 255 0\nfunred              patch,ninja,phat\nfunblue             Diablo\ncg_predictitems     0\ncg_physics          1\ncl_anonymous        0\nsex                 male\nhandicap            100\ncolor2              5\ncolor1              4\nteam_headmodel      *james\nteam_model          james\nheadmodel           sarge\nmodel               sarge\nsnaps               20\nteamtask            0\ncl_guid             4128583FD6F924B081D7E10F39712FBB\nweapmodes           00000110220000020002')

        logging.getLogger('output').setLevel(logging.NOTSET)
        self.console.pluginsStarted()

        verify(self.console, atleast=1).write('status', maxRetries=ANY)
        verify(self.console).write('dumpuser 10')
        self.assertIn('10', self.console.clients)
        client = self.console.clients['10']
        self.assertEqual('[PoliShTeAm]Haxxer', client.name)
        self.assertEqual('[PoliShTeAm]Haxxer^7', client.exactName)
        self.assertEqual('4128583FD6F924B081D7E10F39712FBB', client.guid)
        self.assertEqual('80.54.100.100', client.ip)



class Test_OnKill(Iourt41TestCase):

    def setUp(self):
        Iourt41TestCase.setUp(self)
        self.console.startup()
        self.joe = FakeClient(self.console, name="Joe", guid="000000000000000")
        self.joe.connects('0')
        self.bob = FakeClient(self.console, name="Bob", guid="111111111111111")
        self.bob.connects('1')
        self.world = self.console.clients['-1']

    def assertEvent(self, log_line, event_type, event_client=None, event_data=None, event_target=None):
        with patch.object(self.console, 'queueEvent') as queueEvent:
            self.console.parseLine(log_line)
            if event_type is None:
                assert not queueEvent.called
                return
            assert queueEvent.called, "No event was fired"
            args = queueEvent.call_args

        if type(event_type) is basestring:
            event_type_name = event_type
        else:
            event_type_name = self.console.getEventName(event_type)
            self.assertIsNotNone(event_type_name, "could not find event with name '%s'" % event_type)

        eventraised = args[0][0]
        self.assertIsInstance(eventraised, Event)
        self.assertEquals(self.console.getEventName(eventraised.type), event_type_name)
        self.assertEquals(eventraised.data, event_data)
        self.assertEquals(eventraised.target, event_target)
        self.assertEquals(eventraised.client, event_client)


    def test_nuke(self):
        self.assertEvent('5:19 Kill: 0 0 34: Joe killed Joe by UT_MOD_NUKED',
            event_type='EVT_CLIENT_KILL',
            event_client=self.world,
            event_target=self.joe,
            event_data=(100, self.console.UT_MOD_NUKED, 'body', 'UT_MOD_NUKED'))

    def test_lava(self):
        self.assertEvent('5:19 Kill: 1022 0 3: <world> killed Joe by MOD_LAVA',
            event_type='EVT_CLIENT_SUICIDE',
            event_client=self.joe,
            event_target=self.joe,
            event_data=(100, self.console.MOD_LAVA, 'body', 'MOD_LAVA'))

    def test_constants(self):
        def assert_mod(kill_mod_number, kill_mod_name):
            self.assertTrue(hasattr(self.console, kill_mod_name), "expecting parser to have a constant named %s" % kill_mod_name)
            with patch.object(self.console, 'queueEvent') as queueEvent:
                self.console.parseLine(r'''Kill: 0 1 %s: Joe killed Bob by %s''' % (kill_mod_number, kill_mod_name))
                assert queueEvent.called, "No event was fired"
                args = queueEvent.call_args
            event_type_name = ('EVT_CLIENT_KILL', 'EVT_CLIENT_SUICIDE')
            eventraised = args[0][0]
            self.assertIsInstance(eventraised, Event)
            self.assertIn(self.console.getEventKey(eventraised.type), event_type_name)
            self.assertEquals(eventraised.data[0], 100)
            self.assertEquals(eventraised.data[1], getattr(self.console, kill_mod_name))
            self.assertEquals(eventraised.data[2], 'body')
            self.assertEquals(eventraised.data[3], kill_mod_name)

        assert_mod('1', 'MOD_WATER')
        assert_mod('3', 'MOD_LAVA')
        assert_mod('5', 'MOD_TELEFRAG')
        assert_mod('6', 'MOD_FALLING')
        assert_mod('7', 'MOD_SUICIDE')
        assert_mod('9', 'MOD_TRIGGER_HURT')
        assert_mod('10', 'MOD_CHANGE_TEAM')
        assert_mod('12', 'UT_MOD_KNIFE')
        assert_mod('13', 'UT_MOD_KNIFE_THROWN')
        assert_mod('14', 'UT_MOD_BERETTA')
        assert_mod('15', 'UT_MOD_DEAGLE')
        assert_mod('16', 'UT_MOD_SPAS')
        assert_mod('17', 'UT_MOD_UMP45')
        assert_mod('18', 'UT_MOD_MP5K')
        assert_mod('19', 'UT_MOD_LR300')
        assert_mod('20', 'UT_MOD_G36')
        assert_mod('21', 'UT_MOD_PSG1')
        assert_mod('22', 'UT_MOD_HK69')
        assert_mod('23', 'UT_MOD_BLED')
        assert_mod('24', 'UT_MOD_KICKED')
        assert_mod('25', 'UT_MOD_HEGRENADE')
        assert_mod('28', 'UT_MOD_SR8')
        assert_mod('30', 'UT_MOD_AK103')
        assert_mod('31', 'UT_MOD_SPLODED')
        assert_mod('32', 'UT_MOD_SLAPPED')
        assert_mod('33', 'UT_MOD_BOMBED')
        assert_mod('34', 'UT_MOD_NUKED')
        assert_mod('35', 'UT_MOD_NEGEV')
        assert_mod('37', 'UT_MOD_HK69_HIT')
        assert_mod('38', 'UT_MOD_M4')
        assert_mod('39', 'UT_MOD_FLAG')
        assert_mod('40', 'UT_MOD_GOOMBA')


class Test_getMapsSoundingLike(Iourt41TestCase):

    def setUp(self):
        Iourt41TestCase.setUp(self)
        self.console.startup()


    def test_no_map(self):
        # GIVEN
        when(self.console).getMaps().thenReturn([])
        rv = self.console.getMapsSoundingLike('tohunga')
        # THEN
        self.assertEqual([], rv)


    def test_one_map(self):
        # GIVEN
        when(self.console).getMaps().thenReturn(["ut4_baeza"])
        rv = self.console.getMapsSoundingLike('tohunga')
        # THEN
        self.assertEqual('ut4_baeza', rv)


    def test_lots_of_maps(self):
        # GIVEN
        when(self.console).getMaps().thenReturn(["ut4_abbey", "ut4_abbeyctf", "ut4_algiers", "ut4_ambush", "ut4_area3_b4",
             "ut4_asylum_b1", "ut4_austria", "ut4_aztek_b2", "ut4_baeza", "ut4_beijing_b3", "ut4_blackhawk", "ut4_blitzkrieg",
             "ut4_boxtrot_x6", "ut4_cambridge_b1", "ut4_cambridge_fixed", "ut4_casa", "ut4_commune", "ut4_company",
             "ut4_crossing", "ut4_deception_v2", "ut4_desolate_rc1", "ut4_docks", "ut4_dressingroom", "ut4_druglord2",
             "ut4_dust2_v2", "ut4_dust2_v3b", "ut4_eagle", "ut4_eezabad", "ut4_elgin", "ut4_exhibition_a24", "ut4_facade_b5",
             "ut4_ferguson_b12", "ut4_firingrange", "ut4_granja", "ut4_guerrilla", "ut4_harbortown", "ut4_heroic_beta1",
             "ut4_herring", "ut4_horror", "ut4_kingdom", "ut4_kingdom_rc6", "ut4_kingpin", "ut4_mandolin",
             "ut4_maximus_v1", "ut4_maya", "ut4_metropolis_b2", "ut4_oildepot", "ut4_orbital_sl", "ut4_pandora_b7",
             "ut4_paradise", "ut4_paris_v2", "ut4_poland_b11", "ut4_prague", "ut4_ramelle", "ut4_ricochet", "ut4_riyadh",
             "ut4_roma_beta2b", "ut4_sanc", "ut4_shahideen", "ut4_snoppis", "ut4_subterra", "ut4_suburbs", "ut4_subway",
             "ut4_swim", "ut4_terrorism7", "ut4_thingley", "ut4_tohunga_b8", "ut4_tombs", "ut4_toxic", "ut4_train_dl1",
             "ut4_tunis", "ut4_turnpike", "ut4_uptown", "ut4_venice_b7", "ut4_village"])
        # THEN
        self.assertEqual('ut4_tohunga_b8', self.console.getMapsSoundingLike('ut4_tohunga_b8'))
        self.assertEqual('ut4_tohunga_b8', self.console.getMapsSoundingLike('tohunga_b8'))
        self.assertEqual('ut4_tohunga_b8', self.console.getMapsSoundingLike('tohunga'))
        self.assertEqual('ut4_tohunga_b8', self.console.getMapsSoundingLike('tohung'))


########NEW FILE########
__FILENAME__ = test_iourt42
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mock import Mock, call, patch
from mockito import mock, when, any as anything
import unittest2 as unittest
from b3.clients import Clients, Client
from b3.config import XmlConfigParser
from b3.events import Event
from b3.fake import FakeClient as original_FakeClient
from b3.parsers.iourt42 import Iourt42Parser, Iourt42Client

log = logging.getLogger("test")
log.setLevel(logging.INFO)


# make sure to unpatch the Clients.newClient method and FakeClient
original_newClient = Clients.newClient
def tearDownModule():
    Clients.newClient = original_newClient


# We need our own FakeClient class to use the new auth() method from the Iourt42Client class
class FakeClient(original_FakeClient, Iourt42Client):
    # Python resolution rule for multiple inheritance will try to find the called methods in original_FakeClient class
    # first ; second from the b3.clients.Client class (which is inherited from the original_FakeClient class) ; third
    # from the Iourt42Client class ; and fourth from the b3.clients.Client class (which is inherited from the
    # Iourt42Client class).
    #
    # We want to have the methods from the original FakeClient class called preferably over the ones from
    # the Client Iourt42Client class, expected for the auth() method which has to be the one implemented in the
    # Iourt42Client class.
    #
    # So we have to keep the Iourt42Client class in second position and we overwrite the auth() method here to
    # control what code will be called in the end.
    def auth(self):
        return Iourt42Client.auth(self)


class Iourt42TestCase(unittest.TestCase):
    """
    Test case that is suitable for testing iourt42 parser specific features
    """

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Iourt42TestCase -> AbstractParser -> FakeConsole -> Parser

        logging.getLogger('output').setLevel(logging.ERROR)

    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Iourt42Parser(self.parser_conf)
        self.console.PunkBuster = None # no Punkbuster support in that game

        self.output_mock = mock()
        # simulate game server actions
        def write(*args, **kwargs):
            pretty_args = map(repr, args) + ["%s=%s" % (k, v) for k, v in kwargs.iteritems()]
            log.info("write(%s)" % ', '.join(pretty_args))
            return self.output_mock.write(*args, **kwargs)
        self.console.write = Mock(wraps=write)


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_log_lines_parsing(Iourt42TestCase):

    def assertEvent(self, log_line, event_type, event_client=None, event_data=None, event_target=None):
        with patch.object(self.console, 'queueEvent') as queueEvent:
            self.console.parseLine(log_line)
            if event_type is None:
                assert not queueEvent.called
                return
            assert queueEvent.called, "No event was fired"
            args = queueEvent.call_args

        if type(event_type) is basestring:
            event_type_name = event_type
        else:
            event_type_name = self.console.getEventName(event_type)
            self.assertIsNotNone(event_type_name, "could not find event with name '%s'" % event_type)

        eventraised = args[0][0]
        self.assertIsInstance(eventraised, Event)
        self.assertEquals(self.console.getEventName(eventraised.type), event_type_name)
        self.assertEquals(eventraised.data, event_data)
        self.assertEquals(eventraised.target, event_target)
        self.assertEquals(eventraised.client, event_client)

    def setUp(self):
        Iourt42TestCase.setUp(self)
        self.console.startup()
        self.joe = FakeClient(self.console, name="Joe", guid="000000000000000")

    def test_Radio(self):
        self.joe.connects('0')
        self.assertEvent(r'''Radio: 0 - 7 - 2 - "New Alley" - "I'm going for the flag"''',
            event_type='EVT_CLIENT_RADIO',
            event_client=self.joe,
            event_data={'msg_group': '7', 'msg_id': '2', 'location': 'New Alley', 'text': "I'm going for the flag" })

    def test_Hotpotato(self):
        self.assertEvent(r'''Hotpotato:''', event_type='EVT_GAME_FLAG_HOTPOTATO')

    def test_Callvote(self):
        self.joe.connects('1')
        self.assertEvent(r'''Callvote: 1 - "map dressingroom"''',
            event_type='EVT_CLIENT_CALLVOTE',
            event_client=self.joe,
            event_data="map dressingroom")

    def test_Vote(self):
        self.joe.connects('0')
        self.assertEvent(r'''Vote: 0 - 2''',
            event_type='EVT_CLIENT_VOTE',
            event_client=self.joe,
            event_data="2")

    def test_Hit_1(self):
        fatmatic = FakeClient(self.console, name="Fat'Matic", guid="11111111111111")
        d4dou = FakeClient(self.console, name="[FR]d4dou", guid="11111111111111")
        fatmatic.connects('3')
        d4dou.connects('6')
        self.assertEvent(r'''Hit: 6 3 5 8: Fat'Matic hit [FR]d4dou in the Torso''',
            event_type='EVT_CLIENT_DAMAGE',
            event_client=fatmatic,
            event_target=d4dou,
            event_data=(15, '19', '5'))

    def test_Hit_2(self):
        fatmatic = FakeClient(self.console, name="Fat'Matic", guid="11111111111111")
        d4dou = FakeClient(self.console, name="[FR]d4dou", guid="11111111111111")
        fatmatic.connects('3')
        d4dou.connects('6')
        self.assertEvent(r'''Hit: 3 6 9 17: [FR]d4dou hit Fat'Matic in the Legs''',
            event_type='EVT_CLIENT_DAMAGE',
            event_client=d4dou,
            event_target=fatmatic,
            event_data=(15, '35', '9'))

    def test_Kill(self):
        patate = FakeClient(self.console, name="Patate", guid="Patate_guid")
        psyp = FakeClient(self.console, name="psyp", guid="psyp_guid")
        patate.connects('0')
        psyp.connects('1')
        self.assertEvent(r'''Kill: 0 1 38: Patate killed psyp by UT_MOD_GLOCK''',
            event_type='EVT_CLIENT_KILL',
            event_client=patate,
            event_target=psyp,
            event_data=(100, '38', 'body', 'UT_MOD_GLOCK'))

    def test_say(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('6')
        self.assertEvent(r'''say: 6 ^5Marcel ^2[^6CZARMY^2]: !help''',
            event_type='EVT_CLIENT_SAY',
            event_client=marcel,
            event_data="!help")


    def test_ClientJumpTimerStarted(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientJumpTimerStarted: 0 - way: 1 (Hard Way)''',
            event_type='EVT_CLIENT_JUMP_TIMER_START',
            event_client=marcel,
            event_data={'way_id': '1', 'way_label': 'Hard Way'})

    def test_ClientJumpTimerStarted_no_location(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientJumpTimerStarted: 0 - way: 0''',
            event_type='EVT_CLIENT_JUMP_TIMER_START',
            event_client=marcel,
            event_data={'way_id': '0', 'way_label': None})

    def test_ClientJumpTimerStopped(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientJumpTimerStopped: 0 - 5 seconds - way: 1 (Hard Way)''',
            event_type='EVT_CLIENT_JUMP_TIMER_STOP',
            event_client=marcel,
            event_data={'way_id': '1', 'way_label': 'Hard Way', 'duration': '5 seconds'})

    def test_ClientJumpTimerStopped_no_location(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientJumpTimerStopped: 0 - 4 seconds - way: 0''',
            event_type='EVT_CLIENT_JUMP_TIMER_STOP',
            event_client=marcel,
            event_data={'way_id': '0', 'way_label': None, 'duration': '4 seconds'})


    def test_ClientSavePosition(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientSavePosition: 0 - 335.384887 - 67.469154 - -23.875000 - "unknown"''',
            event_type='EVT_CLIENT_POS_SAVE',
            event_client=marcel,
            event_data={'position': (335.384887, 67.469154, -23.875), 'name': 'unknown'})

    def test_ClientLoadPosition(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''ClientLoadPosition: 0 - 335.384887 - 67.469154 - -23.875000 - "unknown"''',
            event_type='EVT_CLIENT_POS_LOAD',
            event_client=marcel,
            event_data={'position': (335.384887, 67.469154, -23.875), 'name': 'unknown'})


    def test_SurvivorWinner_player(self):
        marcel = FakeClient(self.console, name="^5Marcel ^2[^6CZARMY^2]", guid="11111111111111")
        marcel.connects('0')
        self.assertEvent(r'''SurvivorWinner: 0''', event_type='EVT_CLIENT_SURVIVOR_WINNER', event_client=marcel)

    def test_SurvivorWinner_team(self):
        self.assertEvent(r'''SurvivorWinner: Red''', event_type='EVT_SURVIVOR_WIN', event_data="Red")
        self.assertEvent(r'''SurvivorWinner: Blue''', event_type='EVT_SURVIVOR_WIN', event_data="Blue")




class Test_kill_mods(Test_log_lines_parsing):
    def setUp(self):
        Test_log_lines_parsing.setUp(self)
        self.joe = FakeClient(self.console, name="Joe", guid="000000000000000")
        self.joe.connects('0')
        self.bob = FakeClient(self.console, name="Bob", guid="111111111111111")
        self.bob.connects('1')
        self.world = self.console.clients['-1']

    def test_mod_water(self):
        self.assertEvent('0:56 Kill: 1022 0 1: <world> killed Joe by MOD_WATER',
            event_type='EVT_CLIENT_SUICIDE',
            event_client=self.joe,
            event_target=self.joe,
            event_data=(100, self.console.MOD_WATER, 'body', 'MOD_WATER')
        )

    def test_nuke(self):
        self.assertEvent('5:19 Kill: 0 0 34: Joe killed Joe by UT_MOD_NUKED',
            event_type='EVT_CLIENT_KILL',
            event_client=self.world,
            event_target=self.joe,
            event_data=(100, self.console.UT_MOD_NUKED, 'body', 'UT_MOD_NUKED'))

    def test_lava(self):
        self.assertEvent('5:19 Kill: 1022 0 3: <world> killed Joe by MOD_LAVA',
            event_type='EVT_CLIENT_SUICIDE',
            event_client=self.joe,
            event_target=self.joe,
            event_data=(100, self.console.MOD_LAVA, 'body', 'MOD_LAVA'))

    def test_falling(self):
        self.assertEvent('0:32 Kill: 1022 0 6: <world> killed Joe by MOD_FALLING',
            event_type='EVT_CLIENT_SUICIDE',
            event_client=self.joe,
            event_target=self.joe,
            event_data=(100, self.console.MOD_FALLING, 'body', 'MOD_FALLING'))

    def test_constants(self):
        def assert_mod(kill_mod_number, kill_mod_name):
            self.assertTrue(hasattr(self.console, kill_mod_name), "expecting parser to have a constant named %s = '%s'" % (kill_mod_name, kill_mod_number))
            with patch.object(self.console, 'queueEvent') as queueEvent:
                self.console.parseLine(r'''Kill: 0 1 %s: Joe killed Bob by %s''' % (kill_mod_number, kill_mod_name))
                assert queueEvent.called, "No event was fired"
                args = queueEvent.call_args
            event_type_name = ('EVT_CLIENT_KILL', 'EVT_CLIENT_SUICIDE')
            eventraised = args[0][0]
            self.assertIsInstance(eventraised, Event)
            self.assertIn(self.console.getEventKey(eventraised.type), event_type_name)
            self.assertEquals(eventraised.data[0], 100)
            self.assertEquals(eventraised.data[1], getattr(self.console, kill_mod_name))
            self.assertEquals(eventraised.data[2], 'body')
            self.assertEquals(eventraised.data[3], kill_mod_name)

        assert_mod('1', 'MOD_WATER')
        assert_mod('3', 'MOD_LAVA')
        assert_mod('5', 'MOD_TELEFRAG')
        assert_mod('6', 'MOD_FALLING')
        assert_mod('7', 'MOD_SUICIDE')
        assert_mod('9', 'MOD_TRIGGER_HURT')
        assert_mod('10', 'MOD_CHANGE_TEAM')
        assert_mod('12', 'UT_MOD_KNIFE')
        assert_mod('13', 'UT_MOD_KNIFE_THROWN')
        assert_mod('14', 'UT_MOD_BERETTA')
        assert_mod('15', 'UT_MOD_DEAGLE')
        assert_mod('16', 'UT_MOD_SPAS')
        assert_mod('17', 'UT_MOD_UMP45')
        assert_mod('18', 'UT_MOD_MP5K')
        assert_mod('19', 'UT_MOD_LR300')
        assert_mod('20', 'UT_MOD_G36')
        assert_mod('21', 'UT_MOD_PSG1')
        assert_mod('22', 'UT_MOD_HK69')
        assert_mod('23', 'UT_MOD_BLED')
        assert_mod('24', 'UT_MOD_KICKED') # not exising in 4.2 ?
        assert_mod('25', 'UT_MOD_HEGRENADE')
        assert_mod('27', 'UT_MOD_SR8')
        assert_mod('29', 'UT_MOD_AK103')
        assert_mod('30', 'UT_MOD_SPLODED')
        assert_mod('31', 'UT_MOD_SLAPPED')
        assert_mod('32', 'UT_MOD_SMITED')
        assert_mod('33', 'UT_MOD_BOMBED')
        assert_mod('34', 'UT_MOD_NUKED')
        assert_mod('35', 'UT_MOD_NEGEV')
        assert_mod('36', 'UT_MOD_HK69_HIT')
        assert_mod('37', 'UT_MOD_M4')
        assert_mod('38', 'UT_MOD_GLOCK')
        assert_mod('39', 'UT_MOD_FLAG')
        assert_mod('40', 'UT_MOD_GOOMBA')




class Test_OnClientuserinfo(Iourt42TestCase):

    def setUp(self):
        super(Test_OnClientuserinfo, self).setUp()
        self.console.PunkBuster = None

    def test_ioclient(self):
        infoline = r'''2 \ip\11.22.33.44:27961\challenge\-284496317\qport\13492\protocol\68\name\laCourge\racered\2\raceblue\2\rate\16000\ut_timenudge\0\cg_rgb\128 128 128\cg_predictitems\0\cg_physics\1\cl_anonymous\0\sex\male\handicap\100\color2\5\color1\4\team_headmodel\*james\team_model\james\headmodel\sarge\model\sarge\snaps\20\cg_autoPickup\-1\gear\GLAORWA\authc\0\teamtask\0\cl_guid\00000000011111111122222223333333\weapmodes\00000110220000020002'''
        self.assertFalse('2' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('2' in self.console.clients)
        client = self.console.clients['2']
        self.assertEqual('11.22.33.44', client.ip)
        self.assertEqual('laCourge^7', client.exactName)
        self.assertEqual('laCourge', client.name)
        self.assertEqual('00000000011111111122222223333333', client.guid)

    @unittest.skip("need to validate rcon responses from real 4.2 gameserver")
    def test_bot(self):
        infoline = r"0 \gear\GMIORAA\team\blue\skill\5.000000\characterfile\bots/ut_chicken_c.c\color\4\sex\male\race\2\snaps\20\rate\25000\name\InviteYourFriends!"
        self.assertFalse('0' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('0' in self.console.clients)
        client = self.console.clients['0']
        self.assertEqual('0.0.0.0', client.ip)
        self.assertEqual('InviteYourFriends!^7', client.exactName)
        self.assertEqual('InviteYourFriends!', client.name)
        self.assertEqual('BOT0', client.guid)

    @unittest.skip("will there still be Q3 mod ?")
    def test_quake3_client(self):
        infoline = r"2 \ip\145.99.135.227:27960\challenge\-232198920\qport\2781\protocol\68\battleye\1\name\[SNT]^1XLR^78or\rate\8000\cg_predictitems\0\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\teamtask\0"
        self.assertFalse('2' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        self.assertTrue('2' in self.console.clients)
        client = self.console.clients['2']
        self.assertEqual('145.99.135.227', client.ip)
        self.assertEqual('[SNT]^1XLR^78or^7', client.exactName)
        self.assertEqual('[SNT]XLR8or', client.name)
        self.assertEqual('145.99.135.227', client.guid)

    def test_client_with_password_gamepassword(self):
        """
        Case where a player saved the password to join the game in its UrT config. As a result, we find a 'password'
        field in the clientuserinfo line.
        This value must not overwrite the 'password' property of the Client object.
        """
        # GIVEN a known client
        c = FakeClient(console=self.console, name="Zesco", guid="58D4069246865BB5A85F20FB60ED6F65", login="login_in_database", password="password_in_database")
        c.save()
        c.connects('15')
        self.assertEqual('password_in_database', c.password)
        # WHEN
        infoline = r"15 \ip\1.2.3.4:27960\name\Zesco\password\some_password_here\racered\2\raceblue\3\rate\8000\ut_timenudge\0\cg_rgb\128 128 128\cg_predictitems\0\cg_physics\1\snaps\20\model\sarge\headmodel\sarge\team_model\james\team_headmodel\*james\color1\4\color2\5\handicap\100\sex\male\cl_anonymous\0\gear\GMIORAA\teamtask\0\cl_guid\58D4069246865BB5A85F20FB60ED6F65\weapmodes\00000110120000020002"
        self.assertTrue('15' in self.console.clients)
        self.console.OnClientuserinfo(action=None, data=infoline)
        # THEN
        client = self.console.clients['15']
        self.assertEqual('1.2.3.4', client.ip)
        self.assertEqual('Zesco^7', client.exactName)
        self.assertEqual('Zesco', client.name)
        self.assertEqual('58D4069246865BB5A85F20FB60ED6F65', client.guid)
        self.assertEqual('password_in_database', client.password)



class Test_queryClientFrozenSandAccount(Iourt42TestCase):

    def test_authed(self):
        # GIVEN
        when(self.console).write('auth-whois 0').thenReturn(r'''auth: id: 0 - name: ^7laCourge - login: courgette - notoriety: serious - level: -1''')
        # WHEN
        data = self.console.queryClientFrozenSandAccount('0')
        # THEN
        self.assertDictEqual({'cid': '0', 'name': 'laCourge', 'login': 'courgette', 'notoriety': 'serious', 'level': '-1', 'extra': None}, data)

    def test_not_active(self):
        # GIVEN
        when(self.console).write('auth-whois 3').thenReturn(r'''Client 3 is not active.''')
        # WHEN
        data = self.console.queryClientFrozenSandAccount('3')
        # THEN
        self.assertDictEqual({}, data)

    def test_no_account(self):
        # GIVEN
        when(self.console).write('auth-whois 3').thenReturn(r'''auth: id: 3 - name: ^7laCourge - login:  - notoriety: 0 - level: 0  - ^7no account''')
        # WHEN
        data = self.console.queryClientFrozenSandAccount('3')
        # THEN
        self.assertDictEqual({'cid': '3', 'name': 'laCourge', 'login': '', 'notoriety': '0', 'level': '0', 'extra': '^7no account'}, data)

    def test_all(self):
        # GIVEN
        when(self.console).write('auth-whois all', maxRetries=anything()).thenReturn(r'''No player found for "all".
auth: id: 0 - name: ^7laCourge - login: courgette - notoriety: serious - level: -1
auth: id: 1 - name: ^7f00 - login:  - notoriety: 0 - level: 0  - ^7no account
auth: id: 2 - name: ^7Qant - login: qant - notoriety: basic - level: -1
''')
        # WHEN
        data = self.console.queryAllFrozenSandAccount()
        # THEN
        self.assertDictEqual({'0': {'cid': '0', 'extra': None, 'level': '-1', 'login': 'courgette', 'name': 'laCourge', 'notoriety': 'serious'},
                              '1': {'cid': '1', 'extra': "^7no account", 'level': '0', 'login': '', 'name': 'f00', 'notoriety': '0'},
                              '2': {'cid': '2', 'extra': None, 'level': '-1', 'login': 'qant', 'name': 'Qant', 'notoriety': 'basic'}
                            }, data)


class Test_auth_without_FSA(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        # GIVEN a player without FSA joe_fsa that will connect on slot 3
        when(self.console).write('auth-whois 3').thenReturn(r'''auth: id: 3 - name: ^7Joe - login:  - notoriety: 0 - level: 0  - ^7no account''')

    def test_unknown_cl_guid(self):
        # GIVEN a player with a unknown cl_guid
        player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        self.assertEqual(0, len(self.console.clients))
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 0, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # WHEN player connects on slot 3
        player.connects("3")
        # THEN player is authenticated
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        # THEN a new player entry is created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertNotEqual(0, player.id)
        # THEN the new entry in database has the correct cl_guid and no FSA
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("joe_cl_guid", player_from_db.guid)
        self.assertEqual('', player_from_db.pbid)

    def test_known_cl_guid(self):
        # GIVEN a known player in database with cl_guid "joe_cl_guid"
        known_player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        known_player.save()
        self.assertNotEqual(0, known_player.id)
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(0, len(self.console.clients))
        # WHEN a player connects on slot 3 with cl_guid "joe_cl_guid" and no FSA
        player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        player.connects("3")
        # THEN player is authenticated
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        # THEN no new entry is created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(known_player.id, player.id)


class Test_auth_with_unknown_FSA(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        # GIVEN a player with FSA joe_fsa that will connect on slot 3
        when(self.console).write('auth-whois 3').thenReturn(r'''auth: id: 3 - name: ^7Joe - login: joe_fsa - notoriety: serious - level: -1''')

    def test_unknown_cl_guid(self):
        # GIVEN a player with cl_guid "joe_cl_guid" that does not exists in database
        player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        self.assertEqual(0, len(self.console.clients))
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 0, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # WHEN player connects
        player.connects("3")
        # THEN player is authenticated
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        # THEN a new player entry is created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertNotEqual(0, player.id)
        # THEN database entry has the new FSA value
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual('joe_fsa', player_from_db.pbid)

    def test_known_cl_guid(self):
        # GIVEN a known player in database with cl_guid "joe_cl_guid"
        known_player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        known_player.save()
        self.assertNotEqual(0, known_player.id)
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(0, len(self.console.clients))
        # WHEN a player connects on slot 3 with cl_guid "joe_cl_guid" and no FSA
        player = FakeClient(console=self.console, name="Joe", guid="joe_cl_guid")
        player.connects("3")
        # THEN player is authenticated
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        # THEN no new entry is created in DB
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(known_player.id, player.id)


class Test_auth_with_uniquely_known_FSA(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        # GIVEN a known player with FSA joe_fsa, cl_guid "cl_guid_A" that will connect on slot 3
        when(self.console).write('auth-whois 3').thenReturn(r'''auth: id: 3 - name: ^7Joe - login: joe_fsa - notoriety: serious - level: -1''')
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_A", pbid="joe_fsa")
        player.save()
        self.known_player_db_id = player.id
        # THEN we have 0 connected players and 1 player known in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(0, len(self.console.clients))

    def test_unknown_cl_guid(self):
        # GIVEN player with known FSA and unknown cl_guid
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_B")
        # WHEN player connects
        player.connects("3")
        # THEN player auth against the known database entry
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        self.assertEqual(self.known_player_db_id, player.id)
        # THEN no new client entry must be created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # THEN the DB player entry cl_guid is replaced with the new value
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("cl_guid_B", player_from_db.guid)

    def test_known_cl_guid_for_that_fsa(self):
        # GIVEN player with known FSA and known cl_guid for that FSA
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_A")
        # WHEN player connects
        player.connects("3")
        # THEN player auth against the known DB entry
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        self.assertEqual(self.known_player_db_id, player.id)
        # THEN no new client entry must be created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # THEN the DB player entry cl_guid is still "cl_guid_A"
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("cl_guid_A", player_from_db.guid)

    def test_known_cl_guid_for_another_fsa(self):
        # GIVEN another known player with FSA jack_fsa, cl_guid "cl_guid_X"
        the_other_player = FakeClient(console=self.console, name="Jack", guid="cl_guid_X", pbid="jack_fsa")
        the_other_player.save()
        the_other_player_db_id = the_other_player.id
        # THEN we have 0 connected players and 2 players known in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(0, len(self.console.clients))
        # GIVEN player with known FSA and known cl_guid for another FSA
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_X")
        # WHEN player connects
        player.connects("3")
        # THEN player auth against the known DB entry that matches the FSA
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        self.assertEqual(self.known_player_db_id, player.id)
        self.assertNotEqual(the_other_player_db_id, player.id)
        # THEN no new client entry must be created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # THEN the DB player entry cl_guid remains unchanged
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("cl_guid_A", player_from_db.guid)


class Test_auth_with_non_uniquely_known_FSA(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        # GIVEN a known player with FSA joe_fsa, cl_guid "cl_guid_A" that will connect on slot 3
        when(self.console).write('auth-whois 3').thenReturn(r'''auth: id: 3 - name: ^7Joe - login: joe_fsa - notoriety: serious - level: -1''')
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_A", pbid="joe_fsa")
        player.save()
        self.known_player_db_id = player.id
        # GIVEN another known player with FSA joe_fsa and cl_guid "cl_guid_B" that we do not expect to connect
        the_other_player = FakeClient(console=self.console, name="Jack", guid="cl_guid_B", pbid="joe_fsa")
        the_other_player.save()
        # THEN we have 0 connected players and 2 players known in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        self.assertEqual(0, len(self.console.clients))

    def test_unknown_cl_guid(self):
        # GIVEN player with known FSA and unknown cl_guid
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_f00")
        # WHEN player connects
        player.connects("3")
        # THEN player is authenticated
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        # THEN a new client entry is be created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 3, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # THEN the new database player entry has the current values for cl_guid and FSA
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("cl_guid_f00", player_from_db.guid)
        self.assertEqual("joe_fsa", player_from_db.pbid)
        # THEN we now have 3 database entries for FSA joe_fsa
        self.assertEqual(3, len(self.console.storage.getClientsMatching({'pbid': "joe_fsa"})))

    def test_known_cl_guid_for_that_fsa(self):
        # GIVEN player with known FSA and known cl_guid for that FSA
        player = FakeClient(console=self.console, name="Joe", guid="cl_guid_A")
        # WHEN player connects
        player.connects("3")
        # THEN player auth against the known DB entry
        self.assertEqual(1, len(self.console.clients))
        self.assertTrue(player.authed)
        self.assertEqual(self.known_player_db_id, player.id)
        # THEN no new client entry must be created in database
        self.assertDictEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 0, 'Warnings': 0}, self.console.storage.getCounts())
        # THEN the DB player entry cl_guid is still "cl_guid_A"
        player_from_db = self.console.storage.getClient(Client(id=player.id))
        self.assertEqual("cl_guid_A", player_from_db.guid)



class Test_parser_API(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")

    def test_getPlayerList(self):
        # GIVEN
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: ut4_casa
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
  4     0  141 theName^7              0 11.22.33.44:27961     38410  8000
  5     0   48 theName2^7             0 11.22.33.45:27961     38410  8000
''')
        # WHEN
        rv = self.console.getPlayerList()
        # THEN
        self.assertDictContainsSubset({
            '5': {'slot': '5', 'last': '0', 'name': 'theName2^7', 'ip': '11.22.33.45', 'ping': '48', 'pbid': None, 'qport': '38410', 'rate': '8000', 'score': '0', 'port': '27961'},
            '4': {'slot': '4', 'last': '0', 'name': 'theName^7', 'ip': '11.22.33.44', 'ping': '141', 'pbid': None, 'qport': '38410', 'rate': '8000', 'score': '0', 'port': '27961'}
        }, rv)



    def test_sync(self):
        # GIVEN
        when(self.console).write('status', maxRetries=anything()).thenReturn('''\
map: ut4_casa
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
  0     0   48 laCourge^7              0 11.22.33.44:27961  13492 16000
''')
        when(self.console).write('dumpuser 0').thenReturn('''\
userinfo
--------
ip                  11.22.33.44:27961
name                laCourge
cl_guid             00000000000000014111111111111111
''')
        when(self.console).write('auth-whois 0').thenReturn('''\
auth: id: 0 - name: ^7laCourge - login: courgette - notoriety: serious - level: -1
''')
        # WHEN
        mlist = self.console.sync()
        # THEN
        self.assertIn("0", mlist)
        player = mlist.get("0", None)
        self.assertIsNotNone(player)
        self.assertEqual('00000000000000014111111111111111', player.guid)
        self.assertEqual('courgette', player.pbid)
        self.assertTrue(player.authed)


    def test_say(self):
        self.console.say("f00")
        self.console.write.assert_has_calls([call('say  f00')])


    def test_saybig(self):
        self.console.saybig("f00")
        self.console.write.assert_has_calls([call('bigtext " f00"')])


    def test_message(self):
        self.console.message(self.player, "f00")
        self.console.write.assert_has_calls(call('tell 4  ^3[pm]^7 f00'))


    def test_kick(self):
        self.console.kick(self.player, reason="f00")
        self.console.write.assert_has_calls([call('kick 4 "f00"'), call('say  theName^7 was kicked f00')])


    def test_ban(self):
        self.console.ban(self.player, reason="f00")
        self.console.write.assert_has_calls([call('addip 4'), call('say  theName^7 was banned f00')])


    def test_unban(self):
        self.console.unban(self.player, reason='f00')
        self.console.write.assert_has_calls([call('removeip 11.22.33.44'),
                                          call('removeip 11.22.33.44'),
                                          call('removeip 11.22.33.44'),
                                          call('removeip 11.22.33.44'),
                                          call('removeip 11.22.33.44')])


    def test_tempban(self):
        self.console.tempban(self.player, reason="f00", duration="1h")
        self.console.write.assert_has_calls([call('kick 4 "f00"'), call('say  theName^7 was temp banned for 1 hour^7 f00')])


    def test_getMap(self):
        # GIVEN
        when(self.console).write('status').thenReturn('''\
map: ut4_casa
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
''')
        # WHEN
        rv = self.console.getMap()
        # THEN
        self.assertEqual('ut4_casa', rv)


    def test_getMaps(self):
        # GIVEN
        when(self.console).write('fdir *.bsp').thenReturn('''\
---------------
maps/ut4_abbey.bsp
maps/ut4_algiers.bsp
maps/ut4_ambush.bsp
3 files listed
''')
        # WHEN
        rv = self.console.getMaps()
        # THEN
        self.assertListEqual(['ut4_abbey', 'ut4_algiers', 'ut4_ambush'], rv)


    @patch('time.sleep')
    def test_rotateMap(self, sleep_mock):
        self.console.rotateMap()
        self.console.write.assert_has_calls([call('say  ^7Changing to next map'), call('cyclemap')])
        sleep_mock.assert_called_once_with(1)


    @patch('time.sleep')
    def test_changeMap(self, sleep_mock):
        # GIVEN
        when(self.output_mock).write('fdir *.bsp').thenReturn("""\
---------------
maps/ut4_foo.bsp
1 files listed
""")
        # WHEN
        suggestions = self.console.changeMap('ut4_f00')
        # THEN
        self.assertIsNone(suggestions)
        self.console.write.assert_has_calls([call('map ut4_foo')])
        sleep_mock.assert_called_once_with(1)


    def test_getPlayerPings(self):
        # GIVEN
        when(self.console).write('status').thenReturn('''\
map: ut4_casa
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
  4     0  141 theName^7              0 11.22.33.44:27961     38410  8000
  5     0   48 theName2^7             0 11.22.33.45:27961     38410  8000
''')
        # WHEN
        rv = self.console.getPlayerPings()
        # THEN
        self.assertDictEqual({"4": 141, "5": 48}, rv)


    def test_getPlayerScores(self):
        # GIVEN
        when(self.console).write('status').thenReturn('''\
map: ut4_casa
num score ping name            lastmsg address               qport rate
--- ----- ---- --------------- ------- --------------------- ----- -----
  4    11  141 theName^7              0 11.22.33.44:27961     38410  8000
  5    25   48 theName2^7             0 11.22.33.45:27961     38410  8000
''')
        # WHEN
        rv = self.console.getPlayerScores()
        # THEN
        self.assertDictEqual({"4": 11, "5": 25}, rv)




class Test_inflictCustomPenalty(Iourt42TestCase):
    """
    Called if b3.admin.penalizeClient() does not know a given penalty type.
    Overwrite this to add customized penalties for your game like 'slap', 'nuke',
    'mute', 'kill' or anything you want.
    /!\ This method must return True if the penalty was inflicted.
    """
    def setUp(self):
        Iourt42TestCase.setUp(self)
        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")

    def test_slap(self):
        result = self.console.inflictCustomPenalty('slap', self.player)
        self.console.write.assert_has_calls([call('slap 4')])
        self.assertTrue(result)

    def test_nuke(self):
        result = self.console.inflictCustomPenalty('nuke', self.player)
        self.console.write.assert_has_calls([call('nuke 4')])
        self.assertTrue(result)

    def test_mute(self):
        result = self.console.inflictCustomPenalty('mute', self.player, duration="15s")
        self.console.write.assert_has_calls([call('mute 4 15.0')])
        self.assertTrue(result)

    def test_kill(self):
        result = self.console.inflictCustomPenalty('kill', self.player)
        self.console.write.assert_has_calls([call('smite 4')])
        self.assertTrue(result)




class Test_load_conf_frozensand_ban_settings(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        self.console.load_conf_permban_with_frozensand = Mock()
        self.console.load_conf_tempban_with_frozensand = Mock()


    def test_auth_public(self):
        # GIVEN
        when(self.console).write("auth").thenReturn('"auth" is:"1^7"')
        when(self.console).write("auth_owners").thenReturn('"auth_owners" is:"452^7" default:"^7"')
        # WHEN
        self.console.load_conf_frozensand_ban_settings()
        # THEN
        self.assertEqual(1, self.console.load_conf_permban_with_frozensand.call_count)
        self.assertEqual(1, self.console.load_conf_tempban_with_frozensand.call_count)


    def test_auth_notoriety(self):
        # GIVEN
        when(self.console).write("auth").thenReturn('"auth" is:"-1^7"')
        when(self.console).write("auth_owners").thenReturn('"auth_owners" is:"452^7" default:"^7"')
        # WHEN
        self.console.load_conf_frozensand_ban_settings()
        # THEN
        self.assertEqual(1, self.console.load_conf_permban_with_frozensand.call_count)
        self.assertEqual(1, self.console.load_conf_tempban_with_frozensand.call_count)


    def test_auth_private(self):
        # GIVEN
        when(self.console).write("auth").thenReturn('"auth" is:"-2^7"')
        when(self.console).write("auth_owners").thenReturn('"auth_owners" is:"452^7" default:"^7"')
        # WHEN
        self.console.load_conf_frozensand_ban_settings()
        # THEN
        self.assertEqual(1, self.console.load_conf_permban_with_frozensand.call_count)
        self.assertEqual(1, self.console.load_conf_tempban_with_frozensand.call_count)


    def test_auth_off(self):
        # GIVEN
        when(self.console).write("auth").thenReturn('"auth" is:"0^7"')
        when(self.console).write("auth_owners").thenReturn('"auth_owners" is:"452^7" default:"^7"')
        # WHEN
        self.console.load_conf_frozensand_ban_settings()
        # THEN
        self.assertEqual(0, self.console.load_conf_permban_with_frozensand.call_count)
        self.assertEqual(0, self.console.load_conf_tempban_with_frozensand.call_count)


    def test_no_authowners(self):
        # GIVEN
        when(self.console).write("auth").thenReturn('"auth" is:"1^7"')
        when(self.console).write("auth_owners").thenReturn('"auth_owners" is:"^7" default:"^7"')
        # WHEN
        self.console.load_conf_frozensand_ban_settings()
        # THEN
        self.assertEqual(0, self.console.load_conf_permban_with_frozensand.call_count)
        self.assertEqual(0, self.console.load_conf_tempban_with_frozensand.call_count)






@patch("time.sleep")
class Test_ban_with_FrozenSand_auth(Iourt42TestCase):

    def setUp(self):
        Iourt42TestCase.setUp(self)
        self.player = self.console.clients.newClient(cid="4", guid="theGuid", name="theName", ip="11.22.33.44")
        self.player.pbid = "thePlayerAccount"

    #-------------------------------------------------------------------------------------------------------------------
    @staticmethod
    def mock_authban(client, response="auth: sending ban for slot %(cid)s : %(pbid)s", disconnect=True):
        def write(cmd):
            if cmd.startswith("auth-ban %s " % client.cid):
                if disconnect:
                    client.disconnect()
                return response % {'cid': client.cid, 'pbid': client.pbid}
        return write

    @staticmethod
    def mock_authban_no_auth(client):
        return Test_ban_with_FrozenSand_auth.mock_authban(client, response="Auth services disabled", disconnect=False)

    @staticmethod
    def mock_authban_no_authowner(client):
        return Test_ban_with_FrozenSand_auth.mock_authban(client, response="auth: not banlist available. Please set correctly auth_owners.", disconnect=False)
    #-------------------------------------------------------------------------------------------------------------------

    def test_ban_with_frozensand(self, mock_sleep):
        # GIVEN
        self.console._permban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban(self.player)) as write_mock:
            # WHEN
            self.console.ban(self.player, reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 0'),
                                     call('say  theName^7 was banned f00')])


    def test_ban_with_frozensand_no_auth(self, mock_sleep):
        # GIVEN
        self.console._permban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban_no_auth(self.player)) as write_mock:
            # WHEN
            self.console.ban(self.player, reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 0'),
                                     call('addip 4'),
                                     call('say  theName^7 was banned f00')])



    def test_ban_with_frozensand_no_authowners(self, mock_sleep):
        # GIVEN
        self.console._permban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban_no_authowner(self.player)) as write_mock:
            # WHEN
            self.console.ban(self.player, reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 0'),
                                     call('addip 4'),
                                     call('say  theName^7 was banned f00')])


    def test_tempban_with_frozensand_1minute(self, mock_sleep):
        # GIVEN
        self.console._tempban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban(self.player)) as write_mock:
            # WHEN
            self.console.tempban(self.player, duration="1m", reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 1'),
                                     call('say  theName^7 was temp banned for 1 minute^7 f00')])


    def test_tempban_with_frozensand_90min(self, mock_sleep):
        # GIVEN
        self.console._tempban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban(self.player)) as write_mock:
            # WHEN
            self.console.tempban(self.player, duration="90m", reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 1 30'),
                                     call('say  theName^7 was temp banned for 1.5 hour^7 f00')])


    def test_tempban_with_frozensand_40days(self, mock_sleep):
        # GIVEN
        self.console._tempban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban(self.player)) as write_mock:
            # WHEN
            self.console.tempban(self.player, duration="40d", reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 40 0 0'),
                                     call('say  theName^7 was temp banned for 5.7 weeks^7 f00')])



    def test_tempban_with_frozensand_no_auth(self, mock_sleep):
        # GIVEN
        self.console._tempban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban_no_auth(self.player)) as write_mock:
            # WHEN
            self.console.tempban(self.player, duration="1m", reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 1'),
                                     call('kick 4 "f00"'),
                                     call('say  theName^7 was temp banned for 1 minute^7 f00')])



    def test_tempban_with_frozensand_no_authowners(self, mock_sleep):
        # GIVEN
        self.console._tempban_with_frozensand = True
        with patch.object(self.console, "write", wraps=Test_ban_with_FrozenSand_auth.mock_authban_no_authowner(self.player)) as write_mock:
            # WHEN
            self.console.tempban(self.player, duration="1m", reason="f00")
        # THEN
        write_mock.assert_has_calls([call('auth-ban 4 0 0 1'),
                                     call('kick 4 "f00"'),
                                     call('say  theName^7 was temp banned for 1 minute^7 f00')])





class Test_config(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        from b3.parsers.q3a.abstractParser import AbstractParser
        from b3.fake import FakeConsole
        AbstractParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # Iourt42TestCase -> AbstractParser -> FakeConsole -> Parser
        logging.getLogger('output').setLevel(logging.ERROR)


    def setUp(self):
        self.parser_conf = XmlConfigParser()
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console = Iourt42Parser(self.parser_conf)
        self.console.PunkBuster = None # no Punkbuster support in that game


    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False




class Test_load_conf_permban_with_frozensand(Test_config):

    def test_yes(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="permban_with_frozensand">yes</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "permban_with_frozensand"))
        # WHEN
        self.console.load_conf_permban_with_frozensand()
        # THEN
        self.assertTrue(self.console._permban_with_frozensand)


    def test_missing(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertFalse(self.parser_conf.has_option("server", "permban_with_frozensand"))
        # WHEN
        self.console.load_conf_permban_with_frozensand()
        # THEN
        self.assertFalse(self.console._permban_with_frozensand)


    def test_empty(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="permban_with_frozensand"/>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "permban_with_frozensand"))
        # WHEN
        self.console.load_conf_permban_with_frozensand()
        # THEN
        self.assertFalse(self.console._permban_with_frozensand)


    def test_no(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="permban_with_frozensand">no</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "permban_with_frozensand"))
        # WHEN
        self.console.load_conf_permban_with_frozensand()
        # THEN
        self.assertFalse(self.console._permban_with_frozensand)


    def test_foo(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="permban_with_frozensand">foo</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "permban_with_frozensand"))
        # WHEN
        self.console.load_conf_permban_with_frozensand()
        # THEN
        self.assertFalse(self.console._permban_with_frozensand)





class Test_load_conf_tempban_with_frozensand(Test_config):

    def test_yes(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="tempban_with_frozensand">yes</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "tempban_with_frozensand"))
        # WHEN
        self.console.load_conf_tempban_with_frozensand()
        # THEN
        self.assertTrue(self.console._tempban_with_frozensand)


    def test_missing(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertFalse(self.parser_conf.has_option("server", "tempban_with_frozensand"))
        # WHEN
        self.console.load_conf_tempban_with_frozensand()
        # THEN
        self.assertFalse(self.console._tempban_with_frozensand)


    def test_empty(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="tempban_with_frozensand"/>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "tempban_with_frozensand"))
        # WHEN
        self.console.load_conf_tempban_with_frozensand()
        # THEN
        self.assertFalse(self.console._tempban_with_frozensand)


    def test_no(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="tempban_with_frozensand">no</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "tempban_with_frozensand"))
        # WHEN
        self.console.load_conf_tempban_with_frozensand()
        # THEN
        self.assertFalse(self.console._tempban_with_frozensand)


    def test_foo(self):
        # GIVEN
        self.parser_conf.loadFromString("""<configuration>
                <settings name="server">
                    <set name="game_log"/>
                    <set name="tempban_with_frozensand">foo</set>
                </settings>
            </configuration>""")
        self.console.loadConfig(self.parser_conf)
        self.assertTrue(self.parser_conf.has_option("server", "tempban_with_frozensand"))
        # WHEN
        self.console.load_conf_tempban_with_frozensand()
        # THEN
        self.assertFalse(self.console._tempban_with_frozensand)



########NEW FILE########
__FILENAME__ = test_punkbuster
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
from mockito import when
from b3.parsers.punkbuster import PunkBuster
from tests import B3TestCase
from b3.output import VERBOSE2


class Test_Punkbuster(B3TestCase):

    def setUp(self):
        logger = logging.getLogger('output')
        logger.propagate = False
        B3TestCase.setUp(self)
        self.pb = PunkBuster(self.console)
        logger.setLevel(VERBOSE2)
        logger.propagate = True

    def test_getPlayerList_nominal(self):
        # GIVEN
        when(self.console).write('PB_SV_PList').thenReturn('''\
: Player List: [Slot #] [GUID] [Address] [Status] [Power] [Auth Rate] [Recent SS] [O/S] [Name]
: 4  27b26543216546163546513465135135(-) 111.11.1.11:28960 OK   1 3.0 0 (W) "ShyRat"
: 5 387852749658574858598854913cdf11(-) 222.222.222.222:28960 OK   1 10.0 0 (W) "shatgun"
: 6 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 7 290d4ad01d240000000026f304572ea(VALID) 11.43.50.163:28960 OK   1 3.0 0 (W) "RascalJr>XI<"
^3PunkBuster Server: 8290d4ad01d240000000026f304572eaf(VALID) 11.43.50.163:28960 OK   1 3.0 0 (W) "RascalJr>XI<"
''')
        # WHEN
        rv = self.pb.getPlayerList()
        # THEN
        self.assertDictContainsSubset({'slot': '4', 'pbid': '27b26543216546163546513465135135', 'guid': '27b26543216546163546513465135135', 'ip': '111.11.1.11', 'name': 'ShyRat'}, rv.get('3', {}))
        self.assertDictContainsSubset({'slot': '5', 'pbid': '387852749658574858598854913cdf11', 'guid': '387852749658574858598854913cdf11', 'ip': '222.222.222.222', 'name': 'shatgun'}, rv.get('4', {}))
        self.assertDictContainsSubset({'slot': '6', 'pbid': '9732d328485274156125252141252ba1', 'guid': '9732d328485274156125252141252ba1', 'ip': '33.133.3.133', 'name': 'FATTYBMBLATY'}, rv.get('5', {}))
        self.assertDictContainsSubset({'slot': '7', 'pbid': '290d4ad01d240000000026f304572ea', 'guid': '290d4ad01d240000000026f304572ea', 'ip': '11.43.50.163', 'name': 'RascalJr>XI<'}, rv.get('6', {}))
        self.assertDictContainsSubset({'slot': '8', 'pbid': '290d4ad01d240000000026f304572eaf', 'guid': '290d4ad01d240000000026f304572eaf', 'ip': '11.43.50.163', 'name': 'RascalJr>XI<'}, rv.get('7', {}))

    def test_getPlayerList_with_color_prefix(self):
        # GIVEN
        when(self.console).write('PB_SV_PList').thenReturn('''\
^3PunkBuster Server: Player List: [Slot #] [GUID] [Address] [Status] [Power] [Auth Rate] [Recent SS] [O/S] [Name]
^3PunkBuster Server: 1  290d4ad01d240000000026f3045720ea(VALID) 11.43.50.163:28960 OK   1 3.0 0 (W) "RascalJr>XI<"
^3PunkBuster Server: 2  a645e2a3a37200000000c5cebc1fc23f(VALID) 11.70.166.147:28960 OK   1 3.3 0 (W) "Szopen"
^3PunkBuster Server: 3  a251eea4c887000000000645f5ddca23(VALID) 11.93.170.145:28960 OK   1 3.0 0 (W) "Gatorgirl>XI<"
^3PunkBuster Server: 4  70b4914e81120000000020766dc48450(VALID) 11.126.17.53:28962 OK   1 3.0 0 (W) "chewmysaxJR>XI<"
^3PunkBuster Server: 5  01f540988986000000000a0f7c7bf48f(VALID) 11.197.210.166:28960 OK   1 3.0 0 (W) "|B|HELLSPAWN"
^3PunkBuster Server: 6  38e7b5ab9c6100000000cbe75d7ce9c2(VALID) 11.216.172.20:28960 OK   1 3.1 0 (W) "Xp3rT>XI<"
^3PunkBuster Server: 7  f8dfea9a5e2300000000876c14403b94(VALID) 11.212.246.118:28960 OK   1 3.0 0 (W) "[TO]Patriot"
^3PunkBuster Server: 8  e0fc8351d95c00000000f048e961eedc(VALID) 11.213.226.170:28960 OK   1 3.0 0 (W) "^2|D2|^1Corp"
^3PunkBuster Server: 9  a251eea4c887000000000645f5ddca23(VALID) 11.93.170.145:56969 OK   1 3.0 0 (W) "Angus >XI<"
^3PunkBuster Server: 10 71305d46e6a000000000a71501d23a48(VALID) 11.228.145.96:28960 OK   1 3.0 0 (W) ":.:RaDaR:.:"
^3PunkBuster Server: 11 33f77d20d6d000000000b08807defb1(VALID) 11.252.69.220:28960 OK   1 3.0 0 (W) "motodude>XI<"
^3PunkBuster Server: 12 adb91dcf5277000000004fff22df9930(VALID) 11.55.191.99:28960 OK   1 3.0 0 (W) "<X> Art Intel"
^3PunkBuster Server: 13 bda238afe0a900000000a91512f3d8ed(VALID) 11.235.70.149:28960 OK   1 3.0 0 (W) "UnChileno>XI<AD"
^3PunkBuster Server: 14 fe64aacedc6c0000000061271334da91(VALID) 11.43.34.219:28960 OK   1 3.0 0 (W) "UnArmed>XI<"
^3PunkBuster Server: 15 3c5c02546bd900000000bdcee588b243(VALID) 11.248.226.6:45696 OK   1 3.1 0 (M) "Kato"
^3PunkBuster Server: 16 d5f52bcc8ccb00000000453ea2c40266(VALID) 11.201.169.193:51461 OK   1 3.0 0 (W) "Xalandra"
^3PunkBuster Server: 17 3634bef3586c00000000be14cfc6d6c0(VALID) 11.177.104.230:28960 OK   1 3.1 0 (W) "=GEG=Devil"
^3PunkBuster Server: 18 896f2a1b018500000000bd3d4719fa20(VALID) 11.53.2.85:28960 OK   1 3.0 0 (W) "gi.Timmah!"
^3PunkBuster Server: 19 ea6c0590d1700000000087dac8a4a4bd(VALID) 11.51.188.97:28960 OK   1 3.0 0 (M) "chomama>XI<"
^3PunkBuster Server: 20 3a432901787e000000003ce5525dbfc3(VALID) 11.141.203.77:28960 OK   1 3.0 0 (W) "Sheepdog45>XI<"
^3PunkBuster Server: 21 a1f6548635d1000000004e623aa78271(VALID) 11.183.5.54:28960 OK   1 3.0 0 (W) "KillerKitty>XI<"
^3PunkBuster Server: 22 951d9c7e0ec400000000afccff20a5e7(VALID) 11.94.100.12:55959 OK   1 3.0 0 (W) "Bama>XI<ADM"
^3PunkBuster Server: 23 ea8d4efaed70000000004cf39b04816c(VALID) 11.193.122.135:28960 OK   1 3.0 0 (W) "^6P!nk^0>XI<Adm"
^3PunkBuster Server: 24 639d096de997000000001af19daef6ea(VALID) 11.108.11.19:62451 OK   1 3.2 0 (W) "Iron Belly>XI<"
^3PunkBuster Server: 25 b86f0bb06a0f00000000ee6fab2f33ef(VALID) 11.10.109.13:28960 OK   1 3.0 0 (W) "criss59"
^3PunkBuster Server: 26 1c8500be8b0100000000b76a4e0c2b96(VALID) 11.227.254.172:43459 OK   1 3.0 0 (M) "snipeRover"
^3PunkBuster Server: 27 f2b31d7bb120000000005a3913b0df1a(VALID) 11.214.133.187:28960 OK   1 3.0 0 (W) "^4google>XI<"
^3PunkBuster Server: 280e038f99dbf000000000980bc3c34567(VALID) 11.213.204.52:28960 OK   1 3.0 0 (W) "snaFU73 >XI<"
^3PunkBuster Server: 30 7a0b82d0396f000000003fa9a94f77b6(VALID) 11.2.215.216:28960 OK   1 3.0 0 (W) "drunksniper>XI<"
^3PunkBuster Server: 31 015dd0825cb100000000ee2500094db9(VALID) 11.138.243.153:63489 OK   1 3.0 0 (W) "RUSOKINGNOOB"
^3PunkBuster Server: 32 35731f786cc6000000003cefbf06ad53(VALID) 11.67.148.6:28960 OK   1 3.0 0 (W) "Deckard>XI<"
^3PunkBuster Server: 33 cc2f13bed79a00000000c43d2261425e(VALID) 11.145.139.44:28960 OK   1 3.0 0 (W) "ZABluesilver"
^3PunkBuster Server: End of Player List (32 Players)
''')
        # WHEN
        rv = self.pb.getPlayerList()
        # THEN
        self.assertDictContainsSubset({'slot': '1', 'pbid': '290d4ad01d240000000026f3045720ea', 'guid': '290d4ad01d240000000026f3045720ea', 'ip': '11.43.50.163', 'name': 'RascalJr>XI<'}, rv.get('0', {}))
        self.assertDictContainsSubset({'slot': '2', 'pbid': 'a645e2a3a37200000000c5cebc1fc23f', 'guid': 'a645e2a3a37200000000c5cebc1fc23f', 'ip': '11.70.166.147', 'name': 'Szopen'}, rv.get('1', {}))
        self.assertDictContainsSubset({'slot': '3', 'pbid': 'a251eea4c887000000000645f5ddca23', 'guid': 'a251eea4c887000000000645f5ddca23', 'ip': '11.93.170.145', 'name': 'Gatorgirl>XI<'}, rv.get('2', {}))
        self.assertDictContainsSubset({'slot': '4', 'pbid': '70b4914e81120000000020766dc48450', 'guid': '70b4914e81120000000020766dc48450', 'ip': '11.126.17.53', 'name': 'chewmysaxJR>XI<'}, rv.get('3', {}))
        self.assertDictContainsSubset({'slot': '5', 'pbid': '01f540988986000000000a0f7c7bf48f', 'guid': '01f540988986000000000a0f7c7bf48f', 'ip': '11.197.210.166', 'name': '|B|HELLSPAWN'}, rv.get('4', {}))
        self.assertDictContainsSubset({'slot': '6', 'pbid': '38e7b5ab9c6100000000cbe75d7ce9c2', 'guid': '38e7b5ab9c6100000000cbe75d7ce9c2', 'ip': '11.216.172.20', 'name': 'Xp3rT>XI<'}, rv.get('5', {}))
        self.assertDictContainsSubset({'slot': '7', 'pbid': 'f8dfea9a5e2300000000876c14403b94', 'guid': 'f8dfea9a5e2300000000876c14403b94', 'ip': '11.212.246.118', 'name': '[TO]Patriot'}, rv.get('6', {}))
        self.assertDictContainsSubset({'slot': '8', 'pbid': 'e0fc8351d95c00000000f048e961eedc', 'guid': 'e0fc8351d95c00000000f048e961eedc', 'ip': '11.213.226.170', 'name': '^2|D2|^1Corp'}, rv.get('7', {}))
        self.assertDictContainsSubset({'slot': '9', 'pbid': 'a251eea4c887000000000645f5ddca23', 'guid': 'a251eea4c887000000000645f5ddca23', 'ip': '11.93.170.145', 'name': 'Angus >XI<'}, rv.get('8', {}))
        self.assertDictContainsSubset({'slot': '10', 'pbid': '71305d46e6a000000000a71501d23a48', 'guid': '71305d46e6a000000000a71501d23a48', 'ip': '11.228.145.96', 'name': ':.:RaDaR:.:'}, rv.get('9', {}))
        self.assertDictContainsSubset({'slot': '11', 'pbid': '33f77d20d6d000000000b08807defb1', 'guid': '33f77d20d6d000000000b08807defb1', 'ip': '11.252.69.220', 'name': 'motodude>XI<'}, rv.get('10', {}))
        self.assertDictContainsSubset({'slot': '12', 'pbid': 'adb91dcf5277000000004fff22df9930', 'guid': 'adb91dcf5277000000004fff22df9930', 'ip': '11.55.191.99', 'name': '<X> Art Intel'}, rv.get('11', {}))
        self.assertDictContainsSubset({'slot': '13', 'pbid': 'bda238afe0a900000000a91512f3d8ed', 'guid': 'bda238afe0a900000000a91512f3d8ed', 'ip': '11.235.70.149', 'name': 'UnChileno>XI<AD'}, rv.get('12', {}))
        self.assertDictContainsSubset({'slot': '14', 'pbid': 'fe64aacedc6c0000000061271334da91', 'guid': 'fe64aacedc6c0000000061271334da91', 'ip': '11.43.34.219', 'name': 'UnArmed>XI<'}, rv.get('13', {}))
        self.assertDictContainsSubset({'slot': '15', 'pbid': '3c5c02546bd900000000bdcee588b243', 'guid': '3c5c02546bd900000000bdcee588b243', 'ip': '11.248.226.6', 'name': 'Kato'}, rv.get('14', {}))
        self.assertDictContainsSubset({'slot': '16', 'pbid': 'd5f52bcc8ccb00000000453ea2c40266', 'guid': 'd5f52bcc8ccb00000000453ea2c40266', 'ip': '11.201.169.193', 'name': 'Xalandra'}, rv.get('15', {}))
        self.assertDictContainsSubset({'slot': '17', 'pbid': '3634bef3586c00000000be14cfc6d6c0', 'guid': '3634bef3586c00000000be14cfc6d6c0', 'ip': '11.177.104.230', 'name': '=GEG=Devil'}, rv.get('16', {}))
        self.assertDictContainsSubset({'slot': '18', 'pbid': '896f2a1b018500000000bd3d4719fa20', 'guid': '896f2a1b018500000000bd3d4719fa20', 'ip': '11.53.2.85', 'name': 'gi.Timmah!'}, rv.get('17', {}))
        self.assertDictContainsSubset({'slot': '19', 'pbid': 'ea6c0590d1700000000087dac8a4a4bd', 'guid': 'ea6c0590d1700000000087dac8a4a4bd', 'ip': '11.51.188.97', 'name': 'chomama>XI<'}, rv.get('18', {}))
        self.assertDictContainsSubset({'slot': '20', 'pbid': '3a432901787e000000003ce5525dbfc3', 'guid': '3a432901787e000000003ce5525dbfc3', 'ip': '11.141.203.77', 'name': 'Sheepdog45>XI<'}, rv.get('19', {}))
        self.assertDictContainsSubset({'slot': '21', 'pbid': 'a1f6548635d1000000004e623aa78271', 'guid': 'a1f6548635d1000000004e623aa78271', 'ip': '11.183.5.54', 'name': 'KillerKitty>XI<'}, rv.get('20', {}))
        self.assertDictContainsSubset({'slot': '22', 'pbid': '951d9c7e0ec400000000afccff20a5e7', 'guid': '951d9c7e0ec400000000afccff20a5e7', 'ip': '11.94.100.12', 'name': 'Bama>XI<ADM'}, rv.get('21', {}))
        self.assertDictContainsSubset({'slot': '23', 'pbid': 'ea8d4efaed70000000004cf39b04816c', 'guid': 'ea8d4efaed70000000004cf39b04816c', 'ip': '11.193.122.135', 'name': '^6P!nk^0>XI<Adm'}, rv.get('22', {}))
        self.assertDictContainsSubset({'slot': '24', 'pbid': '639d096de997000000001af19daef6ea', 'guid': '639d096de997000000001af19daef6ea', 'ip': '11.108.11.19', 'name': 'Iron Belly>XI<'}, rv.get('23', {}))
        self.assertDictContainsSubset({'slot': '25', 'pbid': 'b86f0bb06a0f00000000ee6fab2f33ef', 'guid': 'b86f0bb06a0f00000000ee6fab2f33ef', 'ip': '11.10.109.13', 'name': 'criss59'}, rv.get('24', {}))
        self.assertDictContainsSubset({'slot': '26', 'pbid': '1c8500be8b0100000000b76a4e0c2b96', 'guid': '1c8500be8b0100000000b76a4e0c2b96', 'ip': '11.227.254.172', 'name': 'snipeRover'}, rv.get('25', {}))
        self.assertDictContainsSubset({'slot': '27', 'pbid': 'f2b31d7bb120000000005a3913b0df1a', 'guid': 'f2b31d7bb120000000005a3913b0df1a', 'ip': '11.214.133.187', 'name': '^4google>XI<'}, rv.get('26', {}))
        self.assertDictContainsSubset({'slot': '28', 'pbid': '0e038f99dbf000000000980bc3c34567', 'guid': '0e038f99dbf000000000980bc3c34567', 'ip': '11.213.204.52', 'name': 'snaFU73 >XI<'}, rv.get('27', {}))
        self.assertDictContainsSubset({'slot': '30', 'pbid': '7a0b82d0396f000000003fa9a94f77b6', 'guid': '7a0b82d0396f000000003fa9a94f77b6', 'ip': '11.2.215.216', 'name': 'drunksniper>XI<'}, rv.get('29', {}))
        self.assertDictContainsSubset({'slot': '31', 'pbid': '015dd0825cb100000000ee2500094db9', 'guid': '015dd0825cb100000000ee2500094db9', 'ip': '11.138.243.153', 'name': 'RUSOKINGNOOB'}, rv.get('30', {}))
        self.assertDictContainsSubset({'slot': '32', 'pbid': '35731f786cc6000000003cefbf06ad53', 'guid': '35731f786cc6000000003cefbf06ad53', 'ip': '11.67.148.6', 'name': 'Deckard>XI<'}, rv.get('31', {}))
        self.assertDictContainsSubset({'slot': '33', 'pbid': 'cc2f13bed79a00000000c43d2261425e', 'guid': 'cc2f13bed79a00000000c43d2261425e', 'ip': '11.145.139.44', 'name': 'ZABluesilver'}, rv.get('32', {}))


    def test_getPlayerList_missing_chars_randomly(self):
        """ it was reported that PB responses miss a character in an inconsistent manner.
        We do our best to extract the only info we need.
        """
        lines = '''\
^3PunkBuster Server:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
3PunkBuster Server:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^PunkBuster Server:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3unkBuster Server:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBusterServer:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster erver:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server:1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 19732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1() 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(- 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-)33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-2960 OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960OK   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 K   1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK1 5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   5.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   15.0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 .0 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 50 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5. 0 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.00 (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0  (W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0(W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 W) "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 () "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W "FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W)"FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) FATTYBMBLATY"
^3PunkBuster Server: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
'''
        for line in lines.split('\n'):
            if not line: # avoid empty lines
                continue
                # GIVEN
            when(self.console).write('PB_SV_PList').thenReturn(line)
            # WHEN
            rv = self.pb.getPlayerList()
            # THEN
            self.assertIn('0', rv, repr(line))
            self.assertDictContainsSubset(
                {'slot': '1', 'pbid': '9732d328485274156125252141252ba1', 'guid': '9732d328485274156125252141252ba1', 'ip': '33.133.3.133', 'name': 'FATTYBMBLATY'}, rv['0'],
                msg=repr(line)
            )

    def test_getPlayerList_missing_chars_randomly_no_pb_prefix(self):
        """ it was reported that PB responses miss a character in an inconsistent manner.
        We do our best to extract the only info we need.
        """
        lines = '''\
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
  1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
:1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 19732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1() 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(- 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-)33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-2960 OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960OK   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 K   1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK1 5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   5.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   15.0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 .0 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 50 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5. 0 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.00 (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0  (W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0(W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 W) "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 () "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W "FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W)"FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) FATTYBMBLATY"
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY
: 1 9732d328485274156125252141252ba1(-) 33.133.3.133:-28960 OK   1 5.0 0 (W) "FATTYBMBLATY"
'''
        for line in lines.split('\n'):
            if not line: # avoid empty lines
                continue
                # GIVEN
            when(self.console).write('PB_SV_PList').thenReturn(line)
            # WHEN
            rv = self.pb.getPlayerList()
            # THEN
            self.assertIn('0', rv, repr(line))
            self.assertDictContainsSubset(
                {'slot': '1', 'pbid': '9732d328485274156125252141252ba1', 'guid': '9732d328485274156125252141252ba1', 'ip': '33.133.3.133', 'name': 'FATTYBMBLATY'}, rv['0'],
                msg=repr(line)
            )



    def test_getPlayerList_cod5(self):
        # GIVEN
        when(self.console).write('PB_SV_PList').thenReturn('''\
whatever: 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK 0 2.9 0 (W) "FATTYBMBLATY"
''')
        # WHEN
        rv = self.pb.getPlayerList()
        # THEN
        self.assertDictContainsSubset({'slot': '19', 'pbid': 'c0356dc89ddb0000000d4f9509db46d1', 'guid': 'c0356dc89ddb0000000d4f9509db46d1', 'ip': '11.111.111.11', 'name': 'FATTYBMBLATY'}, rv.get('18', {}))

    def test_getPlayerList_cod5_missing_chars_randomly(self):
        """ it was reported that PB responses miss a character in an inconsistent manner.
        We do our best to extract the only info we need.
        """
        lines = '''\
whatever: 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever: 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever: 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever:19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1() 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(- 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-)11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960OK   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 K   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 O   0 2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK    2.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   02.9 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 29 0 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.90 (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9  (W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 W) "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 () "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W "FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W)"FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) FATTYBMBLATY"
whatever 19 c0356dc89ddb0000000d4f9509db46d1(-) 11.111.111.11:28960 OK   0 2.9 0 (W) "FATTYBMBLATY
'''
        for line in lines.split('\n'):
            if not line: # avoid empty lines
                continue
                # GIVEN
            when(self.console).write('PB_SV_PList').thenReturn(line)
            # WHEN
            rv = self.pb.getPlayerList()
            # THEN
            self.assertIn('18', rv, msg="for test line %r" % line)
            self.assertDictContainsSubset(
                {'slot': '19', 'pbid': 'c0356dc89ddb0000000d4f9509db46d1', 'guid': 'c0356dc89ddb0000000d4f9509db46d1', 'ip': '11.111.111.11', 'name': 'FATTYBMBLATY'}, rv['18'],
                msg="for test line %r" % line
            )

########NEW FILE########
__FILENAME__ = test_ravaged
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import os
from mock import Mock, call, patch
import unittest2 as unittest
from mockito import when
from b3 import TEAM_UNKNOWN
from b3.clients import Client
from b3.config import XmlConfigParser
from b3.fake import FakeClient
from b3.parsers.ravaged import RavagedParser, TEAM_SCAVENGERS, TEAM_RESISTANCE
from b3.plugins.admin import AdminPlugin

from b3 import __file__ as b3_module__file__
ADMIN_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml"))
ADMIN_CONFIG = None


def client_equal(client_a, client_b):
    if client_a is None and client_b is not None:
        return False
    if client_a is not None and client_b is None:
        return False
    return all(map(lambda x: getattr(client_a, x, None) == getattr(client_b, x, None), ('cid', 'guid', 'name', 'ip', 'ping')))


class RavagedTestCase(unittest.TestCase):
    """
    Test case that is suitable for testing Ravaged parser specific features
    """
    whatever = object()

    @classmethod
    def setUpClass(cls):
        from b3.fake import FakeConsole
        RavagedParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # RavagedParser -> FakeConsole -> Parser


    def setUp(self):
        self.status_response = None # defaults to STATUS_RESPONSE module attribute
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = RavagedParser(self.conf)
        self.parser.output = Mock()
        self.parser.output.write = Mock()

        self.evt_queue = []
        def queue_event(evt):
            self.evt_queue.append(evt)
        self.queueEvent_patcher = patch.object(self.parser, "queueEvent", wraps=queue_event)
        self.queueEvent_mock = self.queueEvent_patcher.start()

        self.parser.startup()


    def tearDown(self):
        self.queueEvent_patcher.stop()
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False


    def clear_events(self):
        """
        clear the event queue, so when assert_has_event is called, it will look only at the newly caught events.
        """
        self.evt_queue = []


    def assert_has_event(self, event_type, data=None, client=None, target=None):
        """
        assert that self.evt_queue contains at least one event for the given type that has the given characteristics.
        """
        assert isinstance(event_type, basestring)
        expected_event = self.parser.getEvent(event_type, data, client, target)

        if not len(self.evt_queue):
            self.fail("expecting %s. Got no event instead" % expected_event)
        elif len(self.evt_queue) == 1:
            actual_event = self.evt_queue[0]
            self.assertEqual(expected_event.type, actual_event.type)
            if data != self.whatever:
                self.assertEqual(expected_event.data, actual_event.data)
            if client != self.whatever:
                self.assertTrue(client_equal(expected_event.client, actual_event.client))
            if target != self.whatever:
                self.assertTrue(client_equal(expected_event.target, actual_event.target))
        else:
            for evt in [e for e in self.evt_queue if e.type == expected_event.type]:
                results = [expected_event.type == evt.type]
                if data != self.whatever:
                    results.append(expected_event.data == evt.data)
                if client != self.whatever:
                    results.append(client_equal(expected_event.client, evt.client))
                if target != self.whatever:
                    results.append(client_equal(expected_event.target, evt.target))
                if all(results):
                    return

            self.fail("expecting event %s. Got instead: %s" % (expected_event, map(str, self.evt_queue)))







class Test_parser_API(RavagedTestCase):

    def test_say(self):
        self.parser.msgPrefix = "[Pre]"
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.say("Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt "
                            "ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco "
                            "laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in "
                            "voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat "
                            "cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")
            write_mock.assert_has_calls([call("say <FONT COLOR='#F2C880'> [Pre] <FONT COLOR='#F2C880'> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,"),
                                         call(u"say <FONT COLOR='#F2C880'> quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla"),
                                         call(u"say <FONT COLOR='#F2C880'> pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")])


    def test_saybig(self):
        self.parser.msgPrefix = "[Pre]"
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.saybig("Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque "
                               "laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi "
                               "architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas "
                               "sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione "
                               "voluptatem sequi nesciunt.")
            write_mock.assert_has_calls([call("say <FONT COLOR='#FC00E2'> [Pre] <FONT COLOR='#FC00E2'> Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore"),
                                         call(u"say <FONT COLOR='#FC00E2'> veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores"),
                                         call(u"say <FONT COLOR='#FC00E2'> eos qui ratione voluptatem sequi nesciunt.")])


    def test_message(self):
        self.parser.msgPrefix = "[Pre]"
        with patch.object(self.parser.output, 'write') as write_mock:
            self.parser.saybig("At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium "
                               "voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint "
                               "occaecati cupiditate non provident, similique sunt in culpa")
            write_mock.assert_has_calls([call("say <FONT COLOR='#FC00E2'> [Pre] <FONT COLOR='#FC00E2'> At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas"),
                                         call(u"say <FONT COLOR='#FC00E2'> molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa")])


    def test_getMap(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Canyon
1 CTR_Derelict
2 CTR_IceBreaker
3 CTR_Liberty
""")
        # WHEN
        rv = self.parser.getMap()
        # THEN
        self.assertEqual('CTR_Canyon', rv)



    def test_getNextMap(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Canyon
1 CTR_Derelict
2 CTR_IceBreaker
3 CTR_Liberty
""")
        # WHEN
        rv = self.parser.getNextMap()
        # THEN
        self.assertEqual('CTR_Derelict', rv)


    def test_changeMap(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Bridge
1 CTR_Canyon
2 CTR_Derelict
3 CTR_IceBreaker
4 CTR_Liberty
5 CTR_Rooftop
6 Thrust_Bridge
7 Thrust_Canyon
8 Thrust_Chasm
9 Thrust_IceBreaker
10 Thrust_Liberty
11 Thrust_Oilrig
12 Thrust_Rooftop
""")
        # WHEN
        with patch.object(self.parser.output, 'write', wraps=self.parser.output.write) as write_mock:
            rv = self.parser.changeMap('oil')
        # THEN
        write_mock.assert_has_calls([call("addmap Thrust_Oilrig 1"), call("nextmap")])


    def test_getPlayerPings(self):
        # GIVEN
        when(self.parser.output).write("getplayerlist").thenReturn("""1 players:
courgette 21 pts 4:8 38ms steamid: 12312312312312312
""")
        # WHEN
        rv = self.parser.getPlayerPings()
        # THEN
        self.assertDictEqual({'12312312312312312': 38}, rv)



    def test_getPlayerScores(self):
        # GIVEN
        when(self.parser.output).write("getplayerlist").thenReturn("""1 players:
courgette 21 pts 4:8 38ms steamid: 12312312312312312
""")
        # WHEN
        rv = self.parser.getPlayerScores()
        # THEN
        self.assertDictEqual({'12312312312312312': 21}, rv)



class Test_gamelog_parsing(RavagedTestCase):

    def test_unknown_line(self):
        self.queueEvent_mock.reset_mock()
        with patch.object(self.parser, 'warning') as warning_mock:
            self.parser.route_game_event('''f00 f00 f00''')
        self.assertFalse(self.queueEvent_mock.called)
        warning_mock.assert_has_calls([call('unhandled log line : [f00 f00 f00]. Please report this on the B3 forums')])


    def test_connected(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", ip="192.168.0.1")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"<12312312312312312><>" connected, address "192.168.0.1"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_CONNECT', data=self.whatever, client=p)


    def test_disconnected(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"courgette<12312312312312312><0>"disconnected''')
        # THEN
        self.assert_has_event('EVT_CLIENT_DISCONNECT', data="12312312312312312", client=p)


    def test_entered_the_game(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"courgette<12312312312312312><0>" entered the game''')
        # THEN
        self.assert_has_event('EVT_CLIENT_JOIN', client=p)


    def test_joined_team(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"courgette<12312312312312312><1>" joined team "1"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_TEAM_CHANGE', data=TEAM_RESISTANCE, client=p)


    def test_Server_say(self):
        self.queueEvent_mock.reset_mock()
        self.parser.route_game_event(b'''Server say "Admin: B\xb3: www.bigbrotherbot.net (b3) v1.10dev [nt] [Coco] [ONLINE]"''')
        self.assertFalse(self.queueEvent_mock.called)


    def test_Server_say_team(self):
        self.queueEvent_mock.reset_mock()
        self.parser.route_game_event(b'''Server say_team "f00" to team "1"''')
        self.assertFalse(self.queueEvent_mock.called)


    def test_loading_map(self):
        # GIVEN
        self.parser.game.mapName = "F00"
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''Loading map "CTR_Derelict"''')
        # THEN
        self.assert_has_event('EVT_GAME_MAP_CHANGE', data={'old': "F00", 'new': "CTR_Derelict"})


    def test_round_started(self):
        # GIVEN
        self.parser.game.mapName = "F00"
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''Round started''')
        # THEN
        self.assert_has_event('EVT_GAME_ROUND_START', data=self.parser.game)


    def test_round_finished(self):
        # GIVEN
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''Round finished, winning team is "0"''')
        # THEN
        self.assert_has_event('EVT_GAME_ROUND_END', data=TEAM_SCAVENGERS)


    def test_say(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"courgette<12312312312312312><1>" say "<FONT COLOR='#FF0000'> hi"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_SAY', data="hi", client=p)


    def test_say_team(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event(r'''"courgette<12312312312312312><1>" say_team "(Team) <FONT COLOR='#66CCFF'> hi team"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_TEAM_SAY', data="hi team", client=p)


    def test_committed_suicide(self):
        # GIVEN
        p = Client(cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''"courgette<12312312312312312><1>" committed suicide with "R_DmgType_M26Grenade"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_SUICIDE', data=(100, "R_DmgType_M26Grenade", 'body'), client=p, target=p)


    def test_kill_enemy(self):
        # GIVEN
        p1 = FakeClient(self.parser, guid="11111111111111")
        p1.connects("11111111111111")
        p2 = FakeClient(self.parser, guid="2222222222222")
        p2.connects("2222222222222")
        self.queueEvent_mock.reset_mock()
        self.clear_events()
        # WHEN
        self.parser.route_game_event('''"Name1<11111111111111><0>" killed "Name2<2222222222222><1>" with "the_weapon"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_KILL', data=(100, "the_weapon", 'body'), client=p1, target=p2)

    def test_kill_enemy_2(self):
        # GIVEN
        p1 = FakeClient(self.parser, guid="76561000000000000")
        p1.connects("76561000000000000")
        p2 = FakeClient(self.parser, guid="70000000000000005")
        p2.connects("70000000000000005")
        self.queueEvent_mock.reset_mock()
        self.clear_events()
        # WHEN
        self.parser.route_game_event('''"txsniper<76561000000000000><1>" killed "Killer Badger<70000000000000005><0>" with R_DmgType_SniperPrimary''')
        # THEN
        self.assert_has_event('EVT_CLIENT_KILL', data=(100, "R_DmgType_SniperPrimary", 'body'), client=p1, target=p2)


    def test_kill_teammate(self):
        # GIVEN
        p1 = FakeClient(self.parser, guid="11111111111111")
        p1.connects("11111111111111")
        p2 = FakeClient(self.parser, guid="2222222222222")
        p2.connects("2222222222222")
        self.queueEvent_mock.reset_mock()
        self.clear_events()
        # WHEN
        self.parser.route_game_event('''"Name1<11111111111111><0>" killed "Name2<2222222222222><0>" with "the_weapon"''')
        # THEN
        self.assert_has_event('EVT_CLIENT_KILL_TEAM', data=(100, "the_weapon", 'body'), client=p1, target=p2)


    def test_killed(self):
        # GIVEN
        p1 = FakeClient(self.parser, guid="11111111111111")
        p1.connects("11111111111111")
        self.queueEvent_mock.reset_mock()
        self.clear_events()
        # WHEN
        self.parser.route_game_event('''"Name1<11111111111111><0>" killed  with UTDmgType_VehicleCollision''')
        # THEN
        self.assert_has_event('EVT_CLIENT_SUICIDE', data=(100, "UTDmgType_VehicleCollision", 'body'), client=p1, target=p1)


    def test_connected_remotely(self):
        # GIVEN
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''(127.0.0.1:3508 has connected remotely)''')
        # THEN
        self.assertFalse(self.queueEvent_mock.called)


    def test_connected_remotely(self):
        # GIVEN
        self.queueEvent_mock.reset_mock()
        # WHEN
        self.parser.route_game_event('''RCon:(Admin127.0.0.1:3508 has disconnected from RCon)''')
        # THEN
        self.assertFalse(self.queueEvent_mock.called)



class Test_getClientOrCreate(RavagedTestCase):

    def test_new_client__guid_name_team(self):
        # GIVEN
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 1}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(guid="12312312312312312", name="courgette", team="1")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("12312312312312312", client.cid)
        self.assertEqual("12312312312312312", client.guid)
        self.assertEqual("courgette", client.name)
        self.assertEqual(TEAM_RESISTANCE, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_new_client__guid_name(self):
        # GIVEN
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 1}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(guid="12312312312312312", name="courgette")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("12312312312312312", client.cid)
        self.assertEqual("12312312312312312", client.guid)
        self.assertEqual("courgette", client.name)
        self.assertEqual(TEAM_UNKNOWN, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_connected_client__guid(self):
        # GIVEN
        self.parser.clients.newClient(cid="12312312312312312", guid="12312312312312312", name="courgette", team=TEAM_SCAVENGERS)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(guid="12312312312312312", name=None)
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("12312312312312312", client.cid)
        self.assertEqual("12312312312312312", client.guid)
        self.assertEqual("courgette", client.name)
        self.assertEqual(TEAM_SCAVENGERS, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_connected_client__guid_different_name(self):
        # GIVEN
        self.parser.clients.newClient(cid="12312312312312312", guid="12312312312312312", name="courgette", team=TEAM_SCAVENGERS)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(guid="12312312312312312", name="F00")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual("12312312312312312", client.cid)
        self.assertEqual("12312312312312312", client.guid)
        self.assertEqual("F00", client.name)
        self.assertEqual(TEAM_SCAVENGERS, client.team)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())


    def test_known_client__guid(self):
        # GIVEN
        known_client = Client(console=self.parser, guid="12312312312312312", name="courgette", connections=15)
        known_client.save()
        self.assertEqual(1, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())
        # WHEN
        client = self.parser.getClientOrCreate(guid="12312312312312312", name="newName", team="0")
        # THEN
        self.assertIsInstance(client, Client)
        self.assertEqual(known_client.id, client.id)
        self.assertEqual("12312312312312312", client.cid)
        self.assertEqual("12312312312312312", client.guid)
        self.assertEqual("newName", client.name)
        self.assertEqual(TEAM_SCAVENGERS, client.team)
        self.assertEqual(16, client.connections)
        self.assertTrue(client.authed)
        self.assertEqual(2, len(self.parser.clients))
        self.assertDictContainsSubset({'clients': 2}, self.parser.storage.getCounts())



class Test_other(RavagedTestCase):

    def test_getTeam(self):
        self.assertEqual(TEAM_SCAVENGERS, self.parser.getTeam("0"))
        self.assertEqual(TEAM_RESISTANCE, self.parser.getTeam("1"))
        self.assertEqual(TEAM_UNKNOWN, self.parser.getTeam("3"))
        self.assertEqual(TEAM_UNKNOWN, self.parser.getTeam(""))
        self.assertEqual(TEAM_UNKNOWN, self.parser.getTeam("-1"))


    def test_getmaplist(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Canyon
1 CTR_Derelict
2 CTR_IceBreaker
3 CTR_Liberty
4 CTR_Rooftop
5 Thrust_Bridge
6 Thrust_Canyon
7 Thrust_Chasm
8 Thrust_IceBreaker
9 Thrust_Liberty
10 Thrust_Oilrig
11 Thrust_Rooftop
12 CTR_Bridge
""")
        # WHEN
        rv = self.parser.getmaplist()
        # THEN
        self.assertListEqual(['CTR_Canyon',
                              'CTR_Derelict',
                              'CTR_IceBreaker',
                              'CTR_Liberty',
                              'CTR_Rooftop',
                              'Thrust_Bridge',
                              'Thrust_Canyon',
                              'Thrust_Chasm',
                              'Thrust_IceBreaker',
                              'Thrust_Liberty',
                              'Thrust_Oilrig',
                              'Thrust_Rooftop',
                              'CTR_Bridge'], rv)


    def test_getplayerlist(self):
        # GIVEN
        courgette = Client(console=self.parser, cid="12312312312312312", guid="12312312312312312", name="courgette")
        self.parser.clients["12312312312312312"] = courgette
        when(self.parser.output).write("getplayerlist").thenReturn("""1 players:
courgette 21 pts 4:8 38ms steamid: 12312312312312312
""")
        # WHEN
        rv = self.parser.getplayerlist()
        # THEN
        self.assertDictEqual({'12312312312312312': courgette}, rv)
        self.assertEqual(21, courgette.score)
        self.assertEqual(4, courgette.kills)
        self.assertEqual(8, courgette.deaths)
        self.assertEqual(38, courgette.ping)


    def test_getMapsSoundingLike_matching(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Bridge
1 CTR_Canyon
2 CTR_Derelict
3 CTR_IceBreaker
4 CTR_Liberty
5 CTR_Rooftop
6 Thrust_Bridge
7 Thrust_Canyon
8 Thrust_Chasm
9 Thrust_IceBreaker
10 Thrust_Liberty
11 Thrust_Oilrig
12 Thrust_Rooftop
""")
        # WHEN
        rv = self.parser.getMapsSoundingLike('oil')
        # THEN
        self.assertEqual('Thrust_Oilrig', rv)


    def test_getMapsSoundingLike_no_match(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Bridge
1 CTR_Canyon
2 CTR_Derelict
3 CTR_IceBreaker
4 CTR_Liberty
5 CTR_Rooftop
6 Thrust_Bridge
7 Thrust_Canyon
8 Thrust_Chasm
9 Thrust_IceBreaker
10 Thrust_Liberty
11 Thrust_Oilrig
12 Thrust_Rooftop
""")
        # WHEN
        rv = self.parser.getMapsSoundingLike('Canyon')
        # THEN
        self.assertSetEqual(set(['Thrust_Canyon', 'CTR_Canyon']), set(rv))


    def test_getMapsSoundingLike_3(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn("""0 CTR_Bridge
1 CTR_Canyon
2 CTR_Derelict
3 CTR_IceBreaker
4 CTR_Liberty
5 CTR_Rooftop
6 Thrust_Bridge
7 Thrust_Canyon
8 Thrust_Chasm
9 Thrust_IceBreaker
10 Thrust_Liberty
11 Thrust_Oilrig
12 Thrust_Rooftop
""")
        # WHEN
        rv = self.parser.getMapsSoundingLike('CTR canyon')
        # THEN
        self.assertEqual('CTR_Canyon', rv)




class test_functional(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        from b3.fake import FakeConsole
        RavagedParser.__bases__ = (FakeConsole,)
        # Now parser inheritance hierarchy is :
        # RavagedParser -> FakeConsole -> Parser


    def setUp(self):
        self.status_response = None # defaults to STATUS_RESPONSE module attribute
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration></configuration>""")
        self.parser = RavagedParser(self.conf)
        self.parser.output = Mock()
        self.parser.output.write = Mock()

        ADMIN_CONFIG = XmlConfigParser()
        ADMIN_CONFIG.load(ADMIN_CONFIG_FILE)
        self.adminPlugin = AdminPlugin(self.parser, ADMIN_CONFIG)
        when(self.parser).getPlugin("admin").thenReturn(self.adminPlugin)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()

        self.parser.startup()

    def tearDown(self):
        if hasattr(self, "parser"):
            del self.parser.clients
            self.parser.working = False



    def test_map(self):
        # GIVEN
        when(self.parser.output).write("getmaplist false").thenReturn(u"""0 CTR_Bridge
1 CTR_Canyon
2 CTR_Derelict
3 CTR_IceBreaker
4 CTR_Liberty
5 CTR_Rooftop
6 Thrust_Bridge
7 Thrust_Canyon
8 Thrust_Chasm
9 Thrust_IceBreaker
10 Thrust_Liberty
11 Thrust_Oilrig
12 Thrust_Rooftop
""".encode('UTF-8'))
        admin = FakeClient(console=self.parser, name="admin", guid="guid_admin", groupBits=128)
        admin.connects("guid_admin")
        # WHEN
        with patch.object(self.parser.output, 'write', wraps=self.parser.output.write) as write_mock:
            admin.says("!map chasm")
        # THEN
        write_mock.assert_has_calls([call("addmap Thrust_Chasm 1"), call("nextmap")])
########NEW FILE########
__FILENAME__ = test_admin
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from mock import Mock, patch, call
import time
import sys
from mockito import when, any as whatever
from tests import B3TestCase
import unittest2 as unittest
import os

from b3 import __file__ as b3_module__file__
from b3.plugin import Plugin
from b3.plugins.admin import AdminPlugin, Command
from b3.config import XmlConfigParser
from b3.clients import Client, Group, ClientVar, Penalty, ClientBan, ClientTempBan


ADMIN_CONFIG_FILE = os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml")

class Admin_TestCase(B3TestCase):
    """ tests from a class inherithing from Admin_TestCase must call self.init() """
    def setUp(self):
        B3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.p = AdminPlugin(self.console, self.conf)

    def init(self, config_content=None):
        """ optionally specify a config for the plugin. If called with no parameter, then the default config is loaded """
        if config_content is None:
            if not os.path.isfile(ADMIN_CONFIG_FILE):
                B3TestCase.tearDown(self) # we are skipping the test at a late stage after setUp was called
                raise unittest.SkipTest("%s is not a file" % ADMIN_CONFIG_FILE)
            else:
                self.conf.load(ADMIN_CONFIG_FILE)
        else:
            self.conf.loadFromString(config_content)
        self.p.onLoadConfig()
        self.p.onStartup()


class Test_parseUserCmd(Admin_TestCase):

    def setUp(self):
        Admin_TestCase.setUp(self)
        self.init()

    @unittest.expectedFailure
    def test_clientinfo_bad_arg(self):
        self.assertIsNone(self.p.parseUserCmd(None))

    def test_clientinfo_empty_arg(self):
        self.assertIsNone(self.p.parseUserCmd(''))

    def test_clientinfo_only_1_arg(self):
        self.assertEqual(('someone', None), self.p.parseUserCmd('someone'))
        # see https://github.com/xlr8or/big-brother-bot/issues/54
        self.assertIsNone(self.p.parseUserCmd('someone', req=True))

    def test_clientinfo_2_args(self):
        self.assertEqual(('someone', 'param1'), self.p.parseUserCmd('someone param1'))
        self.assertEqual(('someone', 'param1'), self.p.parseUserCmd('someone param1', req=True))

    def test_clientinfo_3_args(self):
        self.assertEqual(('someone', 'param1 param2'), self.p.parseUserCmd('someone param1 param2'))
        self.assertEqual(('someone', 'param1 param2'), self.p.parseUserCmd('someone param1 param2', req=True))

    def test_clientinfo_int(self):
        self.assertEqual(('45', None), self.p.parseUserCmd('45'))
        self.assertEqual(('45', None), self.p.parseUserCmd("'45'"))
        self.assertEqual(('45', 'some param'), self.p.parseUserCmd("'45' some param"))


class Test_getGroupLevel(Admin_TestCase):

    def setUp(self):
        Admin_TestCase.setUp(self)
        self.init()

    def test_nominal(self):
        for test_data, expected in {
            'NONE': 'none',
            '0': 0,
            '1': 1,
            'guest': 0,
            'user': 1,
            'reg': 2,
            'mod': 20,
            'admin': 40,
            'fulladmin': 60,
            'senioradmin': 80,
            'superadmin': 100,
            '1-20': '1-20',
            '40-20': '40-20',
            'user-admin': '1-40',
        }.items():
            result = self.p.getGroupLevel(test_data)
            if expected != result:
                self.fail("%r, expecting %r but got %r" % (test_data, expected, result))

    def test_failures(self):
        self.p.error = Mock()
        for test_data in ('foo', 'mod-foo', 'foo-mod'):
            self.assertFalse(self.p.getGroupLevel(test_data))
            assert self.p.error.called



class Test_misc_cmd(Admin_TestCase):

    def setUp(self):
        Admin_TestCase.setUp(self)
        self.init()
        self.p.console.say = Mock()

    def test_die(self):
        self.console.die = Mock()
        self.p.cmd_die(None, None, Mock())
        assert self.console.die.called

    def test_restart(self):
        self.console.restart = Mock()
        self.p.cmd_restart(None, None, Mock())
        assert self.console.restart.called

    def test_reconfig(self):
        self.console.reloadConfigs = Mock()
        self.p.cmd_reconfig(None, None, Mock())
        assert self.console.reloadConfigs.called

    def test_map(self):
        mock_client = Mock(spec=Client, name="client")
        self.console.changeMap = Mock()

        # no data
        self.p.cmd_map(data=None, client=mock_client, cmd=Mock(spec=Command))
        mock_client.message.assert_called_once_with('^7You must supply a map to change to.')
        assert not self.console.changeMap.called

        # correct data
        mock_client.reset_mock()
        self.console.changeMap = Mock(return_value='foo')
        self.p.cmd_map(data='bar', client=mock_client, cmd=Mock(spec=Command))
        self.console.changeMap.assert_called_once_with('bar')
        assert not mock_client.message.called

        # incorrect data
        mock_client.reset_mock()
        self.console.changeMap = Mock(return_value=['foo1', 'foo2', 'foo3'])
        self.p.cmd_map(data='bar', client=mock_client, cmd=Mock(spec=Command))
        self.console.changeMap.assert_called_once_with('bar')
        assert mock_client.message.called

    def test_maps(self):
        mock_client = Mock(spec=Client, name="client")
        mock_cmd = Mock(spec=Command)

        # None
        self.console.getMaps = Mock(return_value=None)
        self.p.cmd_maps(data=None, client=mock_client, cmd=mock_cmd)
        mock_client.message.assert_called_once_with('^7Error: could not get map list')

        # no map
        self.console.getMaps = Mock(return_value=[])
        self.p.cmd_maps(data=None, client=mock_client, cmd=mock_cmd)
        mock_cmd.sayLoudOrPM.assert_called_once_with(mock_client, '^7Map Rotation list is empty')

        # one map
        mock_cmd.reset_mock()
        self.console.getMaps = Mock(return_value=['foo'])
        self.p.cmd_maps(data=None, client=mock_client, cmd=mock_cmd)
        mock_cmd.sayLoudOrPM.assert_called_once_with(mock_client, '^7Map Rotation: ^2foo')

        # many maps
        mock_cmd.reset_mock()
        self.console.getMaps = Mock(return_value=['foo1', 'foo2', 'foo3'])
        self.p.cmd_maps(data=None, client=mock_client, cmd=mock_cmd)
        mock_cmd.sayLoudOrPM.assert_called_once_with(mock_client, '^7Map Rotation: ^2foo1^7, ^2foo2^7, ^2foo3')

    def test_maprotate(self):
        self.console.rotateMap = Mock()
        self.p.cmd_maprotate(None, None, Mock(spec=Command))
        assert self.console.rotateMap.called

    def test_b3(self):
        self.console.say = Mock()
        self.p.config = Mock(name="config")
        self.p.config.getint = Mock(return_value=10)

        mock_client = Mock(spec=Client, name="client")
        mock_command = Mock(spec=Command, name='cmd')

        mock_client.maxLevel = 0
        self.p.cmd_b3(data='', client=mock_client, cmd=mock_command)
        assert mock_command.sayLoudOrPM.called

        mock_client.maxLevel = 20
        mock_client.reset_mock()
        self.p.cmd_b3(data='', client=mock_client, cmd=mock_command)
        assert mock_command.sayLoudOrPM.called

        for param in ('poke', 'expose', 'stare', 'stab', 'triangulate', 'bite', 'fuck', 'slap', 'fight', 'feed',
                      'throw', 'furniture', 'indeed', 'flog', 'sexor', 'hate', 'smoke', 'maul', 'procreate',
                      'shoot'):
            mock_client.reset_mock()
            self.p.cmd_b3(data=param, client=mock_client, cmd=mock_command)
            if not self.console.say.called:
                self.fail("self.console.say was not called for %r" % param)


    def test_enable(self):
        mock_client = Mock(spec=Client, name="client")
        mock_client.maxLevel = 0
        mock_command = Mock(spec=Command, name='cmd')

        self.p.cmd_enable(data='', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7You must supply a plugin name to enable.')

        mock_client.reset_mock()
        self.p.cmd_enable(data='admin', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7You cannot disable/enable the admin plugin.')

        mock_client.reset_mock()
        self.p.console.getPlugin = Mock(return_value=None)
        self.p.cmd_enable(data='foo', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7No plugin named foo loaded.')

        mock_client.reset_mock()
        mock_pluginA = Mock(spec=Plugin)
        mock_pluginA.isEnabled = Mock(return_value=True)
        self.p.console.getPlugin = Mock(return_value=mock_pluginA)
        self.p.cmd_enable(data='foo', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7Plugin foo is already enabled.')

        mock_client.reset_mock()
        mock_pluginA = Mock(spec=Plugin)
        mock_pluginA.__class__.__name__ = "MockPlugin"
        mock_pluginA.isEnabled = Mock(return_value=False)
        self.p.console.getPlugin = Mock(return_value=mock_pluginA)
        self.p.cmd_enable(data='foo', client=mock_client, cmd=mock_command)
        self.p.console.say.assert_called_once_with('^7MockPlugin is now ^2ON')


    def test_disable(self):
        mock_client = Mock(spec=Client, name="client")
        mock_client.maxLevel = 0
        mock_command = Mock(spec=Command, name='cmd')

        self.p.cmd_disable(data='', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7You must supply a plugin name to disable.')

        mock_client.reset_mock()
        self.p.cmd_disable(data='admin', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7You cannot disable/enable the admin plugin.')

        mock_client.reset_mock()
        self.p.console.getPlugin = Mock(return_value=None)
        self.p.cmd_disable(data='foo', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7No plugin named foo loaded.')

        mock_client.reset_mock()
        mock_pluginA = Mock(spec=Plugin)
        mock_pluginA.isEnabled = Mock(return_value=False)
        self.p.console.getPlugin = Mock(return_value=mock_pluginA)
        self.p.cmd_disable(data='foo', client=mock_client, cmd=mock_command)
        mock_client.message.assert_called_once_with('^7Plugin foo is already disable.')

        mock_client.reset_mock()
        mock_pluginA = Mock(spec=Plugin)
        mock_pluginA.__class__.__name__ = "MockPlugin"
        mock_pluginA.isEnabled = Mock(return_value=True)
        self.p.console.getPlugin = Mock(return_value=mock_pluginA)
        self.p.cmd_disable(data='foo', client=mock_client, cmd=mock_command)
        self.p.console.say.assert_called_once_with('^7MockPlugin is now ^1OFF')


    def test_rebuild(self):
        mock_client = Mock(spec=Client, name="client")
        mock_client.maxLevel = 0
        mock_command = Mock(spec=Command, name='cmd')
        self.p.console.clients.sync = Mock()

        assert not self.p.console.clients.sync.called
        self.p.cmd_rebuild(data='', client=mock_client, cmd=mock_command)
        assert self.p.console.clients.sync.called


class CommandTestCase(Admin_TestCase):
    """ tests from a class inherithing from CommandTestCase must call self.init() """
    def setUp(self):
        Admin_TestCase.setUp(self)
        self.mock_client = Mock(spec=Client, name="client")
        self.mock_client.maxLevel = 0
        self.mock_client.exactName = "MockClient"
        self.mock_command = Mock(spec=Command, name='cmd')

        self.p.getMessage = Mock(return_value='')


class Test_cmd_iamgod(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self._commands_patcher = patch.object(self.p, '_commands')
        self._commands_patcher.start()

    def tearDown(self):
        CommandTestCase.tearDown(self)
        self._commands_patcher.stop()

    def iamgod(self, data=''):
        return self.p.cmd_iamgod(data=data, client=self.mock_client, cmd=self.mock_command)


    def test_when_there_is_already_a_superadmin(self):
        self.p._commands['iamgod'] = 'foo'
        self.p.warning = Mock()
        self.p.console.clients.lookupSuperAdmins = Mock(return_value=[Mock(spec=Client)])

        self.iamgod()
        self.p.warning.assert_called()
        self.assertNotIn('iamgod', self.p._commands)


    def test_is_already_superadmin(self):
        mock_iamgod_cmd = Mock(spec=Command, name="iamgod command")
        mock_superadmin_group = Mock(spec=Group)
        mock_superadmin_group.exactName = "superadmin"
        self.p._commands['iamgod'] = mock_iamgod_cmd
        self.p.console.clients.lookupSuperAdmins = Mock(return_value=[])
        self.p.console.storage.getGroup = Mock(return_value=mock_superadmin_group)
        self.mock_client.groups = [mock_superadmin_group]

        self.iamgod()
        self.mock_client.message.assert_called_once_with('^7You are already a superadmin')


    def test_when_there_is_no_superadmin(self):
        mock_iamgod_cmd = Mock(spec=Command, name="iamgod command")
        mock_superadmin_group = Mock(spec=Group)
        self.p._commands['iamgod'] = mock_iamgod_cmd
        self.p.console.clients.lookupSuperAdmins = Mock(return_value=[])
        self.p.console.storage.getGroup = Mock(return_value=mock_superadmin_group)
        self.mock_client.groups = []

        self.iamgod()
        self.mock_client.setGroup.assert_called_once_with(mock_superadmin_group)
        self.mock_client.save.assert_called_once_with()
        self.mock_client.message.assert_called_once_with('^7You are now a %s' % mock_superadmin_group.name)


class Test_cmd_warn(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.p.warnClient = Mock()

    def warn(self, data=''):
        return self.p.cmd_warn(data=data, client=self.mock_client, cmd=self.mock_command)

    def test_no_parameter(self):
        self.warn()
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.p.warnClient.called

    def test_player_not_found(self):
        self.p.findClientPrompt = Mock(return_value=None)
        self.warn('foo')
        self.p.findClientPrompt.assert_called_once_with('foo', self.mock_client)
        assert not self.p.warnClient.called

    def test_prevent_warn_self(self):
        foo_player = self.mock_client
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.warn('foo')
        self.p.getMessage.assert_called_once_with('warn_self', self.mock_client.exactName)
        assert not self.p.warnClient.called

    def test_player_is_higher_level(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        self.mock_client.maxLevel = 0
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.warn('foo')
        self.p.getMessage.assert_called_once_with('warn_denied', self.mock_client.exactName, foo_player.exactName)
        assert not self.p.warnClient.called

    def test_already_warned_recently(self):
        self.p.console.time = Mock(return_value=8)
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        foo_player.var = Mock(return_value=ClientVar(5))
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.warn('foo')
        self.mock_client.message.assert_called_once_with('^7Only one warning per 15 seconds can be issued')
        assert not self.p.warnClient.called

    def test_nominal_no_keyword(self):
        self.p.console.time = Mock(return_value=16)
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        foo_player.var = Mock(return_value=ClientVar(None))
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.warn('foo')
        self.p.warnClient.assert_called_once_with(foo_player, None, self.mock_client)

    def test_nominal_with_keyword(self):
        self.p.console.time = Mock(return_value=16)
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        foo_player.var = Mock(return_value=ClientVar(None))
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.warn('foo thekeyword')
        self.p.warnClient.assert_called_once_with(foo_player, 'thekeyword', self.mock_client)



class Test_cmd_kick(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.p._noreason_level = 2

    def kick(self, data=''):
        return self.p.cmd_kick(data=data, client=self.mock_client, cmd=self.mock_command)

    def test_no_parameter(self):
        self.kick()
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.kick.called

    def test_no_reason(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 1
        assert self.mock_client.maxLevel < self.p._noreason_level
        self.kick('foo')
        self.mock_client.message.assert_called_once_with('^1ERROR: ^7You must supply a reason')
        assert not self.mock_client.kick.called

    def test_player_not_found(self):
        self.p.findClientPrompt = Mock(return_value=None)
        self.mock_client.maxLevel = 3
        self.kick('foo')
        self.p.findClientPrompt.assert_called_once_with('foo', self.mock_client)
        assert not self.mock_client.kick.called

    def test_prevent_kick_self(self):
        foo_player = self.mock_client
        self.mock_client.maxLevel = 3
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.kick('foo')
        self.p.getMessage.assert_called_once_with('kick_self', self.mock_client.exactName)
        assert not self.mock_client.kick.called

    def test_player_is_higher_level(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = None
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.kick('foo')
        self.p.getMessage.assert_called_once_with('kick_denied', foo_player.exactName, self.mock_client.exactName, foo_player.exactName)
        assert not self.mock_client.kick.called

    def test_player_is_higher_level_but_masked(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = Mock()
        foo_player.exactName = "Foo"
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.kick('foo')
        self.mock_client.message.assert_called_once_with('^7%s ^7is a masked higher level player, can\'t kick' % foo_player.exactName)
        assert not self.mock_client.kick.called

    def test_nominal_no_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.kick('foo')
        foo_player.kick.assert_called_once_with('', None, self.mock_client)

    def test_nominal_with_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.kick('foo theReason')
        foo_player.kick.assert_called_once_with('theReason', 'theReason', self.mock_client)

    def test_nominal_with_reason_keyword(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.p.getReason = Mock(return_value="aReason")
        self.kick('foo theKeyword')
        foo_player.kick.assert_called_once_with('aReason', 'theKeyword', self.mock_client)


class Test_cmd_spank(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.p._noreason_level = 2

    def spank(self, data=''):
        return self.p.cmd_spank(data=data, client=self.mock_client, cmd=self.mock_command)

    def test_no_parameter(self):
        self.spank()
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.kick.called

    def test_no_reason(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 1
        assert self.mock_client.maxLevel < self.p._noreason_level
        self.spank('foo')
        self.mock_client.message.assert_called_once_with('^1ERROR: ^7You must supply a reason')
        assert not self.mock_client.kick.called

    def test_player_not_found(self):
        self.p.findClientPrompt = Mock(return_value=None)
        self.mock_client.maxLevel = 3
        self.spank('foo')
        self.p.findClientPrompt.assert_called_once_with('foo', self.mock_client)
        assert not self.mock_client.kick.called

    def test_prevent_kick_self(self):
        foo_player = self.mock_client
        self.mock_client.maxLevel = 3
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.spank('foo')
        self.p.getMessage.assert_called_once_with('kick_self', self.mock_client.exactName)
        assert not self.mock_client.kick.called

    def test_player_is_higher_level(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = None
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.spank('foo')
        self.p.getMessage.assert_called_once_with('kick_denied', foo_player.exactName, self.mock_client.exactName, foo_player.exactName)
        assert not self.mock_client.kick.called

    def test_player_is_higher_level_but_masked(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = Mock()
        foo_player.exactName = "Foo"
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.spank('foo')
        self.mock_client.message.assert_called_once_with('^7%s ^7is a masked higher level player, can\'t spank' % foo_player.exactName)
        assert not self.mock_client.kick.called

    def test_nominal_no_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.spank('foo')
        foo_player.kick.assert_called_once_with('', None, self.mock_client, silent=True)

    def test_nominal_with_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.spank('foo theReason')
        foo_player.kick.assert_called_once_with('theReason', 'theReason', self.mock_client, silent=True)

    def test_nominal_with_reason_keyword(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.p.getReason = Mock(return_value="aReason")
        self.spank('foo theKeyword')
        foo_player.kick.assert_called_once_with('aReason', 'theKeyword', self.mock_client, silent=True)



class Test_cmd_permban(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.p._noreason_level = 2

    def permban(self, data=''):
        return self.p.cmd_permban(data=data, client=self.mock_client, cmd=self.mock_command)

    def test_no_parameter(self):
        self.permban()
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.ban.called

    def test_no_reason(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 1
        assert self.mock_client.maxLevel < self.p._noreason_level
        self.permban('foo')
        self.mock_client.message.assert_called_once_with('^1ERROR: ^7You must supply a reason')
        assert not self.mock_client.ban.called

    def test_player_not_found(self):
        self.p.findClientPrompt = Mock(return_value=None)
        self.mock_client.maxLevel = 3
        self.permban('foo')
        self.p.findClientPrompt.assert_called_once_with('foo', self.mock_client)
        assert not self.mock_client.ban.called

    def test_prevent_permban_self(self):
        foo_player = self.mock_client
        self.mock_client.maxLevel = 3
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.permban('foo')
        self.p.getMessage.assert_called_once_with('ban_self', self.mock_client.exactName)
        assert not self.mock_client.ban.called

    def test_player_is_higher_level(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = None
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.permban('foo')
        self.p.getMessage.assert_called_once_with('ban_denied', self.mock_client.exactName, foo_player.exactName)
        assert not self.mock_client.ban.called

    def test_player_is_higher_level_but_masked(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = Mock()
        foo_player.exactName = "Foo"
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.permban('foo')
        self.mock_client.message.assert_called_once_with('^7%s ^7is a masked higher level player, can\'t ban' % foo_player.exactName)
        assert not self.mock_client.ban.called

    def test_nominal_no_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.permban('foo')
        foo_player.ban.assert_called_once_with('', None, self.mock_client)

    def test_nominal_with_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.permban('foo theReason')
        foo_player.ban.assert_called_once_with('theReason', 'theReason', self.mock_client)

    def test_nominal_with_reason_keyword(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.p.getReason = Mock(return_value="aReason")
        self.permban('foo theKeyword')
        foo_player.ban.assert_called_once_with('aReason', 'theKeyword', self.mock_client)


class Test_cmd_tempban(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.p._noreason_level = 2
        self.p._long_tempban_level = 2

    def tempban(self, data=''):
        return self.p.cmd_tempban(data=data, client=self.mock_client, cmd=self.mock_command)

    def test_no_parameter(self):
        self.tempban()
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.tempban.called

    def test_invalid_duration(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 3
        assert self.mock_client.maxLevel < self.p.config.getint('whatever')
        self.tempban('foo sdf')
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.tempban.called

    def test_no_duration(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 3
        assert self.mock_client.maxLevel < self.p.config.getint('whatever')
        self.tempban('foo')
        self.mock_client.message.assert_called_once_with('^7Invalid parameters')
        assert not self.mock_client.tempban.called

    def test_no_reason(self):
        self.p.config.getint = Mock(return_value=4)
        self.mock_client.maxLevel = 1
        assert self.mock_client.maxLevel < self.p._noreason_level
        self.tempban('foo 3h')
        self.mock_client.message.assert_called_once_with('^1ERROR: ^7You must supply a reason')
        assert not self.mock_client.tempban.called

    def test_player_not_found(self):
        self.p.findClientPrompt = Mock(return_value=None)
        self.mock_client.maxLevel = 3
        self.tempban('foo 3h')
        self.p.findClientPrompt.assert_called_once_with('foo', self.mock_client)
        assert not self.mock_client.tempban.called

    def test_prevent_tempban_self(self):
        foo_player = self.mock_client
        self.mock_client.maxLevel = 3
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.tempban('foo 3h')
        self.p.getMessage.assert_called_once_with('temp_ban_self', self.mock_client.exactName)
        assert not self.mock_client.tempban.called

    def test_player_is_higher_level(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = None
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.tempban('foo 3h')
        self.p.getMessage.assert_called_once_with('temp_ban_denied', self.mock_client.exactName, foo_player.exactName)
        assert not self.mock_client.tempban.called

    def test_player_is_higher_level_but_masked(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 20
        foo_player.maskGroup = Mock()
        foo_player.exactName = "Foo"
        self.mock_client.maxLevel = 5
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.tempban('foo 3h')
        self.mock_client.message.assert_called_once_with('^7%s ^7is a masked higher level player, can\'t temp ban' % foo_player.exactName)
        assert not self.mock_client.tempban.called

    def test_nominal_no_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.tempban('foo 3h')
        foo_player.tempban.assert_called_once_with('', None, 3*60, self.mock_client)

    def test_nominal_with_reason(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.tempban('foo 3h theReason')
        foo_player.tempban.assert_called_once_with('theReason', 'theReason', 3*60, self.mock_client)

    def test_nominal_with_reason_keyword(self):
        foo_player = Mock(spec=Client, name="foo")
        foo_player.maxLevel = 0
        self.mock_client.maxLevel = 20
        self.p.findClientPrompt = Mock(return_value=foo_player)
        self.p.getReason = Mock(return_value="aReason")
        self.tempban('foo 3h theKeyword')
        foo_player.tempban.assert_called_once_with('aReason', 'theKeyword', 3*60, self.mock_client)


class Test_cmd_mask(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.player = Client(console=self.console, name="joe", _maxLevel=0)
        self.player.message = Mock()
        self.assertEqual(0, self.player.maskedLevel)
        self.assertIsNone(self.player.maskedGroup)

    def mask(self, data=''):
        return self.p.cmd_mask(data=data, client=self.player, cmd=self.mock_command)

    def test_no_parameter(self):
        self.mask()
        self.player.message.assert_called_once_with('^7Invalid parameters')
        self.assertEqual(0, self.player.maskedLevel)
        self.assertIsNone(self.player.maskedGroup)

    def test_invalid_group(self):
        self.mask('foo')
        self.player.message.assert_called_once_with('^7Group foo does not exist')
        self.assertEqual(0, self.player.maskedLevel)
        self.assertIsNone(self.player.maskedGroup)

    def test_valid_group(self):
        self.mask('senioradmin')
        self.player.message.assert_called_once_with('^7Masked as Senior Admin')
        self.assertEqual(80, self.player.maskedLevel)
        self.assertIsNotNone(self.player.maskedGroup)


@patch.object(time, "sleep")
class Test_sendRules(Admin_TestCase):

    def test_nominal(self, sleep_mock):
        self.init(r"""<configuration><settings name="spamages">
                        <set name="foo">foo</set>
                        <set name="rule1">this is rule #1</set>
                        <set name="rule2">this is rule #2</set>
                        <set name="bar">bar</set>
                    </settings></configuration>""")
        self.console.say = Mock(wraps=lambda *args: sys.stdout.write("\t\tSAY: " + str(args) + "\n"))
        self.p._sendRules(None)
        self.console.say.assert_has_calls([call('this is rule #1'), call('this is rule #2')])

    def test_no_rule_1(self, sleep_mock):
        self.init(r"""<configuration><settings name="spamages">
                        <set name="rule5">this is rule #5</set>
                        <set name="rule2">this is rule #2</set>
                    </settings></configuration>""")
        self.console.say = Mock(wraps=lambda *args: sys.stdout.write("\t\tSAY: " + str(args) + "\n"))
        self.p._sendRules(None)
        self.assertFalse(self.console.say.called)


    def test_gap_in_rules(self, sleep_mock):
        self.init(r"""<configuration><settings name="spamages">
                        <set name="rule1">this is rule #1</set>
                        <set name="rule2">this is rule #2</set>
                        <set name="rule4">this is rule #4</set>
                    </settings></configuration>""")
        self.console.say = Mock(wraps=lambda *args: sys.stdout.write("\t\tSAY: " + str(args) + "\n"))
        self.p._sendRules(None)
        self.console.say.assert_has_calls([call('this is rule #1'), call('this is rule #2')])


    def test_no_rule_in_config(self, sleep_mock):
        self.init(r"""<configuration><settings name="spamages">
                        <set name="foo">foo</set>
                        <set name="bar">bar</set>
                    </settings></configuration>""")
        self.console.say = Mock(wraps=lambda *args: sys.stdout.write("\t\tSAY: " + str(args) + "\n"))
        self.p._sendRules(None)
        self.assertFalse(self.console.say.called)


    def test_too_many_rules(self, sleep_mock):
        self.init(r"""<configuration><settings name="spamages">""" +
            "\n".join(["""<set name="rule%s">this is rule #%s</set>""" % (x, x) for x in range(1, 23)]) +
            """</settings></configuration>""")
        self.console.say = Mock(wraps=lambda *args: sys.stdout.write("\t\tSAY: " + str(args) + "\n"))
        self.p._sendRules(None)
        self.console.say.assert_has_calls([call('this is rule #%s' % x) for x in range(1, 20)])


class Test_cmd_lastbans(CommandTestCase):

    def setUp(self):
        CommandTestCase.setUp(self)
        self.init()
        self.player = Client(console=self.console, name="joe", _maxLevel=0)
        self.player.message = Mock()

    def lastbans(self):
        self.p.cmd_lastbans(data='', client=self.player, cmd=self.mock_command)

    def test_no_ban(self):
        self.lastbans()
        self.mock_command.sayLoudOrPM.assert_called_once_with(self.player, '^7There are no active bans')

    def test_one_ban(self):
        # GIVEN
        player1 = Client(console=self.console, guid='BillGUID', name="Bill")
        player1.save()
        penalty1 = ClientBan(clientId=player1.id, timeExpire=-1, adminId=0)
        when(self.console.storage).getLastPenalties(types=whatever(), num=whatever()).thenReturn([penalty1])
        # WHEN
        self.lastbans()
        # THEN
        self.mock_command.sayLoudOrPM.assert_called_once_with(self.player, u'^2@1^7 Bill^7^7 (Perm)')

    def test_one_ban_with_reason(self):
        # GIVEN
        player1 = Client(console=self.console, guid='BillGUID', name="Bill")
        player1.save()
        penalty1 = ClientBan(clientId=player1.id, timeExpire=-1, adminId=0, reason="test reason")
        when(self.console.storage).getLastPenalties(types=whatever(), num=whatever()).thenReturn([penalty1])
        # WHEN
        self.lastbans()
        # THEN
        self.mock_command.sayLoudOrPM.assert_called_once_with(self.player, u'^2@1^7 Bill^7^7 (Perm) test reason')

    def test_two_bans_with_reason(self):
        # GIVEN
        when(self.console).time().thenReturn(0)
        player1 = Client(console=self.console, guid='player1GUID', name="P1")
        player1.save()
        penalty1 = ClientBan(clientId=player1.id, timeExpire=-1, adminId=0, reason="test reason")

        player2 = Client(console=self.console, guid='player2GUID', name="P2")
        player2.save()
        penalty2 = ClientTempBan(clientId=player2.id, timeExpire=self.console.time() + 60*2, adminId=0, reason="test reason f00")

        when(self.console.storage).getLastPenalties(types=whatever(), num=whatever()).thenReturn([penalty1, penalty2])
        # WHEN
        self.lastbans()
        # THEN
        self.mock_command.sayLoudOrPM.assert_has_calls([
            call(self.player, u'^2@1^7 P1^7^7 (Perm) test reason'),
            call(self.player, u'^2@2^7 P2^7^7 (2 minutes remaining) test reason f00'),
        ])




if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_admin_functional
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging

from mock import Mock, call, patch
import sys, os, thread
import time
from mockito import when
import unittest2 as unittest

from b3 import __file__ as b3_module__file__, TEAM_BLUE, TEAM_RED
from b3.clients import Group

from tests import B3TestCase
from b3.fake import FakeClient
from b3.config import XmlConfigParser
from b3.plugins.admin import AdminPlugin

ADMIN_CONFIG_FILE = os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml")

class Admin_functional_test(B3TestCase):
    """ tests from a class inherithing from Admin_functional_test must call self.init() """
    def setUp(self):
        B3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.p = AdminPlugin(self.console, self.conf)

    def init(self, config_content=None):
        """ optionally specify a config for the plugin. If called with no parameter, then the default config is loaded """
        if config_content is None:
            if not os.path.isfile(ADMIN_CONFIG_FILE):
                B3TestCase.tearDown(self) # we are skipping the test at a late stage after setUp was called
                raise unittest.SkipTest("%s is not a file" % ADMIN_CONFIG_FILE)
            else:
                self.conf.load(ADMIN_CONFIG_FILE)
        else:
            self.conf.loadFromString(config_content)
        self.p.onLoadConfig()
        self.p.onStartup()

        self.joe = FakeClient(self.console, name="Joe", exactName="Joe", guid="joeguid", groupBits=128, team=TEAM_RED)
        self.mike = FakeClient(self.console, name="Mike", exactName="Mike", guid="mikeguid", groupBits=1, team=TEAM_BLUE)


class Cmd_tempban(Admin_functional_test):

    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.joe.message = Mock()
        self.joe.connects(0)

    def test_no_duration(self):
        self.mike.connects(1)
        self.joe.says('!tempban mike')
        self.joe.message.assert_called_with('^7Invalid parameters')

    def test_bad_duration(self):
        self.mike.connects(1)
        self.mike.tempban = Mock()
        self.joe.says('!tempban mike 5hour')
        self.joe.message.assert_called_with('^7Invalid parameters')
        assert not self.mike.tempban.called

    def test_non_existing_player(self):
        self.mike.connects(1)
        self.joe.says('!tempban foo 5h')
        self.joe.message.assert_called_with('^7No players found matching foo')

    def test_no_reason(self):
        self.mike.connects(1)
        self.mike.tempban = Mock()
        self.joe.says('!tempban mike 5h')
        self.mike.tempban.assert_called_with('', None, 5*60, self.joe)


class Cmd_lastbans(Admin_functional_test):

    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.joe.message = Mock()
        self.joe.connects(0)

    def test_no_ban(self):
        self.joe.says('!lastbans')
        self.joe.message.assert_called_with('^7There are no active bans')

    @patch('time.time', return_value=0)
    def test_one_tempban(self, mock_time):
        # GIVEN
        self.mike.connects(1)
        # WHEN
        self.joe.says('!tempban mike 5h test reason')
        self.joe.says('!lastbans')
        # THEN
        self.joe.message.assert_called_with(u'^2@2^7 Mike^7^7 (5 hours remaining) test reason')
        # WHEN
        self.joe.says('!unban @2')
        self.joe.says('!lastbans')
        # THEN
        self.joe.message.assert_called_with('^7There are no active bans')



class Cmd_help(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.p._commands = {}  # make sure to empty the commands list as _commands is a wrongly a class property
        self.init()
        self.joe.message = Mock()
        self.joe.connects(0)

    def test_non_existing_cmd(self):
        self.joe.says('!help fo0')
        self.joe.message.assert_called_with('^7Command not found fo0')

    def test_existing_cmd(self):
        self.joe.says('!help help')
        self.joe.message.assert_called_with('^2!help ^7%s' % self.p.cmd_help.__doc__.strip())

    def test_no_arg(self):
        self.joe.says('!help')
        self.joe.message.assert_called_with('^7Available commands: admins, admintest, aliases, b3, ban, banall, baninfo,'
                                            ' clear, clientinfo, die, disable, enable, find, help, iamgod, kick, kickall, lastbans'
                                            ', leveltest, list, lookup, makereg, map, maprotate, maps, mask, nextmap, no'
                                            'tice, pause, permban, poke, putgroup, rebuild, reconfig, regtest, regulars, restart, '
                                            'rules, runas, say, scream, seen, spam, spams, spank, spankall, status, temp'
                                            'ban, time, unban, ungroup, unmask, unreg, warn, warnclear, warninfo, warnremove, w'
                                            'arns, warntest')
        self.mike.message = Mock()
        self.mike.connects(0)
        self.mike.says('!help')
        self.mike.message.assert_called_with('^7Available commands: help, iamgod, regtest, regulars, rules, time')

    def test_joker(self):
        self.joe.says('!help *ban')
        self.joe.message.assert_called_with('^7Available commands: ban, banall, baninfo, lastbans, permban, tempban, unban')


class Cmd_mask(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()

    def test_nominal(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        # only superadmin joe is connected
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7]')
        # introducing mike (senioradmin)
        self.mike.connects(1)
        self.joe.says('!putgroup mike senioradmin')
        # we know have 2 admins connected
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7], Mike^7^7 [^380^7]')
        # joe masks himself as a user
        self.joe.says('!mask user')
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Mike^7^7 [^380^7]')
        # joe unmasks himself
        self.joe.says('!unmask')
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7], Mike^7^7 [^380^7]')
        # joe masks mike as a user
        self.joe.says('!mask user mike')
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7]')
        # joe unmasks mike
        self.joe.says('!unmask mike')
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7], Mike^7^7 [^380^7]')


class Cmd_makereg_unreg(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.group_user = self.console.storage.getGroup(Group(keyword='user'))
        self.group_reg = self.console.storage.getGroup(Group(keyword='reg'))
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.mike.connects(1)

    def test_nominal(self):
        # GIVEN
        self.assertTrue(self.mike.inGroup(self.group_user))
        self.assertFalse(self.mike.inGroup(self.group_reg))
        # WHEN
        self.joe.says("!makereg mike")
        # THEN
        self.assertFalse(self.mike.inGroup(self.group_user))
        self.assertTrue(self.mike.inGroup(self.group_reg))
        self.joe.message.assert_called_with('^7Mike^7 ^7put in group Regular')
        # WHEN
        self.joe.says("!unreg mike")
        # THEN
        self.assertTrue(self.mike.inGroup(self.group_user))
        self.assertFalse(self.mike.inGroup(self.group_reg))
        self.joe.message.assert_called_with('^7Mike^7^7 removed from group Regular')


    def test_unreg_when_not_regular(self):
        # GIVEN
        self.assertTrue(self.mike.inGroup(self.group_user))
        self.assertFalse(self.mike.inGroup(self.group_reg))
        # WHEN
        self.joe.says("!unreg mike")
        # THEN
        self.assertTrue(self.mike.inGroup(self.group_user))
        self.assertFalse(self.mike.inGroup(self.group_reg))
        self.joe.message.assert_called_with('^7Mike^7^7 is not in group Regular')


    def test_makereg_when_already_regular(self):
        # GIVEN
        self.mike.addGroup(self.group_reg)
        self.mike.remGroup(self.group_user)
        self.assertTrue(self.mike.inGroup(self.group_reg))
        # WHEN
        self.joe.says("!makereg mike")
        # THEN
        self.assertFalse(self.mike.inGroup(self.group_user))
        self.assertTrue(self.mike.inGroup(self.group_reg))
        self.joe.message.assert_called_with('^7Mike^7^7 is already in group Regular')


    def test_makereg_no_parameter(self):
        # WHEN
        self.joe.says("!makereg")
        # THEN
        self.joe.message.assert_called_with('^7Invalid parameters')


    def test_unreg_no_parameter(self):
        # WHEN
        self.joe.says("!unreg")
        # THEN
        self.joe.message.assert_called_with('^7Invalid parameters')


    def test_makereg_unknown_player(self):
        # WHEN
        self.joe.says("!makereg foo")
        # THEN
        self.joe.message.assert_called_with('^7No players found matching foo')


    def test_unreg_unknown_player(self):
        # WHEN
        self.joe.says("!unreg foo")
        # THEN
        self.joe.message.assert_called_with('^7No players found matching foo')


def _start_new_thread(callable, args_list, kwargs_dict):
    """ used to patch thread.start_new_thread so it won't create a new thread but call the callable synchronously """
    callable(*args_list, **kwargs_dict)

@patch.object(time, "sleep")
@patch.object(thread, "start_new_thread", wraps=_start_new_thread)
class Cmd_rules(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()

    def test_nominal(self, start_new_thread_mock, sleep_mock):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('!rules')
        self.joe.message.assert_has_calls([call('^3Rule #1: No racism of any kind'),
                                           call('^3Rule #2: No clan stacking, members must split evenly between the teams'),
                                           call('^3Rule #3: No arguing with admins (listen and learn or leave)'),
                                           call('^3Rule #4: No abusive language or behavior towards admins or other players'),
                                           call('^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names'),
                                           call('^3Rule #6: No recruiting for your clan, your server, or anything else'),
                                           call('^3Rule #7: No advertising or spamming of websites or servers'),
                                           call('^3Rule #8: No profanity or offensive language (in any language)'),
                                           call('^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning'),
                                           call('^3Rule #10: Offense players must play for the objective and support their team')])

    def test_nominal_loud(self, start_new_thread_mock, sleep_mock):
        self.console.say = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('@rules')
        self.console.say.assert_has_calls([call('^3Rule #1: No racism of any kind'),
                                           call('^3Rule #2: No clan stacking, members must split evenly between the teams'),
                                           call('^3Rule #3: No arguing with admins (listen and learn or leave)'),
                                           call('^3Rule #4: No abusive language or behavior towards admins or other players'),
                                           call('^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names'),
                                           call('^3Rule #6: No recruiting for your clan, your server, or anything else'),
                                           call('^3Rule #7: No advertising or spamming of websites or servers'),
                                           call('^3Rule #8: No profanity or offensive language (in any language)'),
                                           call('^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning'),
                                           call('^3Rule #10: Offense players must play for the objective and support their team')])

    def test_nominal_bigtext(self, start_new_thread_mock, sleep_mock):
        self.console.saybig = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('&rules')
        self.console.saybig.assert_has_calls([call('^3Rule #1: No racism of any kind'),
                                           call('^3Rule #2: No clan stacking, members must split evenly between the teams'),
                                           call('^3Rule #3: No arguing with admins (listen and learn or leave)'),
                                           call('^3Rule #4: No abusive language or behavior towards admins or other players'),
                                           call('^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names'),
                                           call('^3Rule #6: No recruiting for your clan, your server, or anything else'),
                                           call('^3Rule #7: No advertising or spamming of websites or servers'),
                                           call('^3Rule #8: No profanity or offensive language (in any language)'),
                                           call('^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning'),
                                           call('^3Rule #10: Offense players must play for the objective and support their team')])

    def test_nominal_to_player(self, start_new_thread_mock, sleep_mock):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.mike.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.mike.connects(1)
        self.joe.says('!rules mike')
        self.mike.message.assert_has_calls([call('^3Rule #1: No racism of any kind'),
                                           call('^3Rule #2: No clan stacking, members must split evenly between the teams'),
                                           call('^3Rule #3: No arguing with admins (listen and learn or leave)'),
                                           call('^3Rule #4: No abusive language or behavior towards admins or other players'),
                                           call('^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names'),
                                           call('^3Rule #6: No recruiting for your clan, your server, or anything else'),
                                           call('^3Rule #7: No advertising or spamming of websites or servers'),
                                           call('^3Rule #8: No profanity or offensive language (in any language)'),
                                           call('^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning'),
                                           call('^3Rule #10: Offense players must play for the objective and support their team')])

    def test_unknown_player(self, start_new_thread_mock, sleep_mock):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('!rules fOO')
        self.joe.message.assert_has_calls([call('^7No players found matching fOO')])


class Cmd_warns(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()

    def test_nominal(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('!warns')
        self.joe.message.assert_called_once_with('^7Warnings: adv, afk, argue, badname, camp, ci, color, cuss, fakecmd,'
        ' jerk, lang, language, name, nocmd, obj, profanity, racism, recruit, rule1, rule10, rule2, rule3, rule4, rule5'
        ', rule6, rule7, rule8, rule9, sfire, spam, spawnfire, spec, spectator, stack, tk')


class Test_warn_reasons_default_config(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.joe.connects(0)
        self.mike.connects(1)

    def test_no_reason(self):
        with patch.object(self.mike, "warn") as mock:
            self.joe.says('!warn mike')
            mock.assert_has_calls([call(60.0, '^7behave yourself', None, self.joe, '')])

    def test_reason_is_not_a_keyword(self):
        with patch.object(self.mike, "warn") as mock:
            self.joe.says('!warn mike f00')
            mock.assert_has_calls([call(60.0, '^7 f00', 'f00', self.joe, '')])

    def test_reason_is_a_keyword(self):
        with patch.object(self.mike, "warn") as warn_mock:
            def assertWarn(keyword, duration, text):
                # GIVEN
                warn_mock.reset_mock()
                self.mike.delvar(self.p, 'warnTime')
                # WHEN
                self.joe.says('!warn mike %s' % keyword)
                # THEN
                warn_mock.assert_has_calls([call(float(duration), text, keyword, self.joe, '')])

            assertWarn("rule1", 14400, '^3Rule #1: No racism of any kind')
            assertWarn("rule2", 1440, '^3Rule #2: No clan stacking, members must split evenly between the teams')
            assertWarn("rule3", 1440, '^3Rule #3: No arguing with admins (listen and learn or leave)')
            assertWarn("rule4", 1440, '^3Rule #4: No abusive language or behavior towards admins or other players')
            assertWarn("rule5", 60, '^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names')
            assertWarn("rule6", 1440, '^3Rule #6: No recruiting for your clan, your server, or anything else')
            assertWarn("rule7", 1440, '^3Rule #7: No advertising or spamming of websites or servers')
            assertWarn("rule8", 4320, '^3Rule #8: No profanity or offensive language (in any language)')
            assertWarn("rule9", 180, '^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning')
            assertWarn("rule10", 4320, '^3Rule #10: Offense players must play for the objective and support their team')
            assertWarn("stack", 1440, '^3Rule #2: No clan stacking, members must split evenly between the teams')
            assertWarn("lang", 4320, '^3Rule #8: No profanity or offensive language (in any language)')
            assertWarn("language", 4320, '^3Rule #8: No profanity or offensive language (in any language)')
            assertWarn("cuss", 4320, '^3Rule #8: No profanity or offensive language (in any language)')
            assertWarn("profanity", 4320, '^3Rule #8: No profanity or offensive language (in any language)')
            assertWarn("name", 60, '^3Rule #5: No offensive or potentially offensive names, annoying names, or in-game (double caret (^)) color in names')
            assertWarn("color", 60, '^7No in-game (double caret (^)) color in names')
            assertWarn("badname", 60, '^7No offensive, potentially offensive, or annoying names')
            assertWarn("spec", 5, '^7spectator too long on full server')
            assertWarn("adv", 1440, '^3Rule #7: No advertising or spamming of websites or servers')
            assertWarn("racism", 14400, '^3Rule #1: No racism of any kind')
            assertWarn("stack", 1440, '^3Rule #2: No clan stacking, members must split evenly between the teams')
            assertWarn("recruit", 1440, '^3Rule #6: No recruiting for your clan, your server, or anything else')
            assertWarn("argue", 1440, '^3Rule #3: No arguing with admins (listen and learn or leave)')
            assertWarn("sfire", 180, '^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning')
            assertWarn("spawnfire", 180, '^3Rule #9: Do ^1NOT ^3fire at teammates or within 10 seconds of spawning')
            assertWarn("jerk", 1440, '^3Rule #4: No abusive language or behavior towards admins or other players')
            assertWarn("afk", 5, '^7you appear to be away from your keyboard')
            assertWarn("tk", 1440, '^7stop team killing!')
            assertWarn("obj", 60, '^7go for the objective!')
            assertWarn("camp", 60, '^7stop camping or you will be kicked!')
            assertWarn("fakecmd", 60, '^7do not use fake commands')
            assertWarn("nocmd", 60, '^7do not use commands that you do not have access to, try using !help')
            assertWarn("ci", 5, '^7connection interupted, reconnect')
            assertWarn("spectator", 5, '^7spectator too long on full server')
            assertWarn("spam", 60, '^7do not spam, shut-up!')


class Test_reason_keywords(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.joe.connects(0)
        self.mike.connects(1)
        self.adv_text = "^3Rule #7: No advertising or spamming of websites or servers"


    def test_warn_with_keyword(self):
        with patch.object(self.console, "say") as say_mock:
            self.joe.says('!warn mike adv')
            say_mock.assert_has_calls([call('^1WARNING^7 [^31^7]: Mike^7^7, %s' % self.adv_text)])

    def test_warn_with_unknown_keyword(self):
        with patch.object(self.console, "say") as say_mock:
            self.joe.says('!warn mike f00')
            say_mock.assert_has_calls([call('^1WARNING^7 [^31^7]: Mike^7^7, ^7 f00')])


    def test_notice_with_keyword(self):
        with patch.object(self.mike, "notice") as notice_mock:
            self.joe.says('!notice mike adv')
            notice_mock.assert_has_calls([call('adv', None, self.joe)])

    def test_notice_with_unknown_keyword(self):
        with patch.object(self.mike, "notice") as notice_mock:
            self.joe.says('!notice mike f00')
            notice_mock.assert_has_calls([call('f00', None, self.joe)])


    def test_kick_with_keyword(self):
        with patch.object(self.console, "kick") as kick_mock:
            self.joe.says('!kick mike adv')
            kick_mock.assert_has_calls([call(self.mike, self.adv_text, self.joe, False)])

    def test_kick_with_unknown_keyword(self):
        with patch.object(self.console, "kick") as kick_mock:
            self.joe.says('!kick mike f00')
            kick_mock.assert_has_calls([call(self.mike, 'f00', self.joe, False)])


    def test_ban_with_keyword(self):
        with patch.object(self.mike, "tempban") as tempban_mock:
            self.joe.says('!ban mike adv')
            tempban_mock.assert_has_calls([call(self.adv_text, 'adv', 20160.0, self.joe)])

    def test_ban_with_unknown_keyword(self):
        with patch.object(self.mike, "tempban") as tempban_mock:
            self.joe.says('!ban mike f00')
            tempban_mock.assert_has_calls([call('f00', 'f00', 20160.0, self.joe)])


    def test_permban_with_keyword(self):
        with patch.object(self.mike, "ban") as permban_mock:
            self.joe.says('!permban mike adv')
            permban_mock.assert_has_calls([call(self.adv_text, 'adv', self.joe)])

    def test_permban_with_unknown_keyword(self):
        with patch.object(self.mike, "ban") as permban_mock:
            self.joe.says('!permban mike f00')
            permban_mock.assert_has_calls([call('f00', 'f00', self.joe)])


@unittest.skipUnless(os.path.isfile(ADMIN_CONFIG_FILE), "%s is not a file" % ADMIN_CONFIG_FILE)
class Test_config(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        logging.getLogger('output').setLevel(logging.INFO)

    def test_no_generic_or_default_warn_readon(self):

        # load the default plugin_admin.xml file after having remove the 'generic' setting from section 'warn_reasons'
        from b3.lib.elementtree import ElementTree as ET
        root = ET.parse(ADMIN_CONFIG_FILE).getroot()
        warn_reasons_nodes = [x for x in root.findall('settings') if x.get('name') == 'warn_reasons' ][0]
        if len(warn_reasons_nodes):
            generic_nodes = [x for x in warn_reasons_nodes[0].findall('set') if x.get('name') == "generic"]
            if len(generic_nodes):
                warn_reasons_nodes[0].remove(generic_nodes[0])
            default_nodes = [x for x in warn_reasons_nodes[0].findall('set') if x.get('name') == "default"]
            if len(default_nodes):
                warn_reasons_nodes[0].remove(default_nodes[0])
        self.init(ET.tostring(root))

        self.joe.message = Mock(lambda x: sys.stdout.write("message to Joe: " + x + "\n"))
        self.joe.connects(0)
        self.joe.says('!warntest')
        self.joe.message.assert_called_once_with('^2TEST: ^1WARNING^7 [^31^7]: ^7behave yourself')
        self.joe.message.reset_mock()
        self.joe.says('!warntest argue')
        self.joe.message.assert_called_once_with('^2TEST: ^1WARNING^7 [^31^7]: ^3Rule #3: No arguing with admins (listen and learn or leave)')


    def test_bad_format_for_generic_and_default(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="generic">1h</set>
                            <set name="default">/</set>
                        </settings>
                    </configuration>""")
        self.assertEqual((60, "^7"), self.p.warn_reasons['generic'])
        self.assertEqual((60, "^7behave yourself"), self.p.warn_reasons['default'])

    def test_bad_format_1(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="foo">foo</set>
                            <set name="bar">5d</set>
                        </settings>
                    </configuration>""")
        self.assertNotIn('foo', self.p.warn_reasons)

    def test_bad_format_2(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="foo">/foo bar</set>
                        </settings>
                    </configuration>""")
        self.assertNotIn('foo', self.p.warn_reasons)

    def test_bad_format_3(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="foo">/spam#</set>
                            <set name="bar">/spam# qsdf sq</set>
                        </settings>
                    </configuration>""")
        self.assertNotIn('foo', self.p.warn_reasons)

    def test_reference_to_warn_reason(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="foo">2h, foo</set>
                            <set name="bar">/foo</set>
                        </settings>
                    </configuration>""")
        self.assertIn('foo', self.p.warn_reasons)
        self.assertEqual((120, 'foo'), self.p.warn_reasons['foo'])
        self.assertIn('bar', self.p.warn_reasons)
        self.assertEqual((120, 'foo'), self.p.warn_reasons['bar'])


    def test_invalid_reference_to_warn_reason(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="foo">2h, foo</set>
                            <set name="bar">/nonexisting</set>
                        </settings>
                    </configuration>""")
        self.assertIn('foo', self.p.warn_reasons)
        self.assertEqual((120, 'foo'), self.p.warn_reasons['foo'])
        self.assertNotIn('bar', self.p.warn_reasons)


    def test_reference_to_spamage(self):
        self.init("""<configuration>
                        <settings name="spamages">
                            <set name="foo">fOO fOO</set>
                        </settings>
                        <settings name="warn_reasons">
                            <set name="bar">4h, /spam#foo</set>
                        </settings>
                    </configuration>""")
        self.assertIn('bar', self.p.warn_reasons)
        self.assertEqual((240, 'fOO fOO'), self.p.warn_reasons['bar'])


    def test_invalid_reference_to_spamage(self):
        self.init("""<configuration>
                        <settings name="warn_reasons">
                            <set name="bar">4h, /spam#foo</set>
                        </settings>
                    </configuration>""")
        self.assertNotIn('bar', self.p.warn_reasons)


class Cmd_admins(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()

    def test_nominal(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        # only superadmin joe is connected
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7]')
        # introducing mike (senioradmin)
        self.mike.connects(1)
        self.joe.says('!putgroup mike senioradmin')
        # we know have 2 admins connected
        self.joe.says('!admins')
        self.joe.message.assert_called_with('^7Admins online: Joe^7^7 [^3100^7], Mike^7^7 [^380^7]')


class Cmd_regulars(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)

    def test_no_regular(self):
        # only superadmin joe is connected
        self.joe.says('!regulars')
        self.joe.message.assert_called_with('^7There are no regular players online')

    def test_one_regular(self):
        # GIVEN
        self.mike.connects(1)
        self.joe.says('!makereg mike')
        # WHEN
        self.joe.says('!regs')
        # THEN
        self.joe.message.assert_called_with('^7Regular players online: Mike^7')

    def test_two_regulars(self):
        # GIVEN
        self.mike.connects(1)
        self.joe.says('!makereg mike')
        self.jack = FakeClient(self.console, name="Jack", guid="jackguid", groupBits=1)
        self.jack.connects(2)
        self.joe.says('!makereg jack')
        # WHEN
        self.joe.says('!regs')
        # THEN
        self.joe.message.assert_called_with('^7Regular players online: Mike^7, Jack^7')



class Cmd_map(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()

    def test_missing_param(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        self.joe.says('!map')
        self.joe.message.assert_called_once_with('^7You must supply a map to change to.')

    def test_suggestions(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        when(self.console).changeMap('f00').thenReturn(["bar1", "bar2", "bar3", "bar4", "bar5", "bar6", "bar7", "bar8", "bar9", "bar10", "bar11", "bar"])
        self.joe.says('!map f00')
        self.joe.message.assert_called_once_with('do you mean : bar1, bar2, bar3, bar4, bar5 ?')

    def test_nominal(self):
        self.joe.message = Mock(wraps=lambda x: sys.stdout.write("\t\t" + x + "\n"))
        self.joe.connects(0)
        when(self.console).changeMap('f00').thenReturn(None)
        self.joe.says('!map f00')
        self.assertEqual(0, self.joe.message.call_count)


class Cmd_kick(Admin_functional_test):
    def setUp(self):
        Admin_functional_test.setUp(self)
        self.init()
        # superadmin joe is connected on slot '0'
        self.joe.connects('0')
        self.kick_patcher = patch.object(self.console, 'kick')
        self.kick_mock = self.kick_patcher.start()

    def tearDown(self):
        Admin_functional_test.tearDown(self)
        self.kick_patcher.stop()

    def test_no_parameter(self):
        # WHEN
        self.joe.says('!kick')
        # THEN
        self.assertListEqual(['Invalid parameters'], self.joe.message_history)
        self.assertListEqual([], self.kick_mock.mock_calls)

    def test_self_kick(self):
        # WHEN
        with patch.object(self.console, "say") as say_mock:
            self.joe.says('!kick joe')
        # THEN
        self.assertListEqual([], self.kick_mock.mock_calls)
        self.assertListEqual([call("^7Joe^7 ^7Can't kick yourself newb!")], say_mock.mock_calls)

    def test_no_reason_when_required(self):
        # GIVEN
        self.joe._groupBits = 16
        # WHEN
        self.joe.says('!kick f00')
        # THEN
        self.assertListEqual(['ERROR: You must supply a reason'], self.joe.message_history)
        self.assertListEqual([], self.kick_mock.mock_calls)

    def test_kick_higher_level_admin(self):
        # GIVEN
        self.mike._groupBits = 16
        self.mike.connects("1")
        # WHEN
        with patch.object(self.console, "say") as say_mock:
            self.mike.says('!kick joe reason1')
        # THEN
        self.assertListEqual([call("^7Joe^7^7 gets 1 point, Mike^7^7 gets none, Joe^7^7 wins, can't kick")], say_mock.mock_calls)
        self.assertListEqual([], self.kick_mock.mock_calls)

    def test_kick_masked_higher_level_admin(self):
        # GIVEN
        self.mike._groupBits = 16
        self.mike.connects("1")
        self.joe.says("!mask reg")
        # WHEN
        self.mike.says('!kick joe reason1')
        # THEN
        self.assertListEqual(["Joe is a masked higher level player, can't kick"], self.mike.message_history)
        self.assertListEqual([], self.kick_mock.mock_calls)

    def test_existing_player_name(self):
        # GIVEN
        self.mike.connects('1')
        # WHEN
        self.joe.says('!kick mike the reason')
        # THEN
        self.assertListEqual([call(self.mike, 'the reason', self.joe, False)], self.kick_mock.mock_calls)

    def test_unknown_player_name(self):
        # GIVEN
        self.mike.connects('6')
        # WHEN
        self.joe.says('!kick f00')
        # THEN
        self.assertListEqual(['No players found matching f00'], self.joe.message_history)
        self.assertListEqual([], self.kick_mock.mock_calls)

    def test_kick_by_slot_id(self):
        # GIVEN
        self.mike.connects('6')
        # WHEN
        self.joe.says('!kick 6')
        # THEN
        self.assertListEqual([call(self.mike, '', self.joe, False)], self.kick_mock.mock_calls)

    def test_kick_by_slot_id_when_no_known_player_is_on_that_slot(self):
        # GIVEN
        self.mike.connects('6')
        # WHEN
        self.joe.says('!kick 4')
        # THEN
        self.assertListEqual([call('4', '', self.joe)], self.kick_mock.mock_calls)
########NEW FILE########
__FILENAME__ = test_adv
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import StringIO
import logging
import os
from mock import patch, call, Mock
from mockito import when, any as mockito_any, unstub
from b3.fake import FakeClient
from b3.lib import feedparser
from b3.plugins.admin import AdminPlugin
from tests import B3TestCase
import unittest2 as unittest

from b3.plugins.adv import AdvPlugin, MessageLoop
from b3.config import XmlConfigParser

from b3 import __file__ as b3_module__file__
ADMIN_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml"))
ADMIN_CONFIG = None

default_plugin_file = os.path.normpath(os.path.join(os.path.dirname(__file__), "../../b3/conf/plugin_adv.xml"))
default_plugin_content = None

timer_patcher = None
feedparser_patcher = None


def setUpModule():
    global default_plugin_content, default_plugin_file, ADMIN_CONFIG, ADMIN_CONFIG_FILE, timer_patcher, feedparser_patcher
    if os.path.exists(default_plugin_file):
        with open(default_plugin_file, 'r') as f:
            default_plugin_content = f.read()

    ADMIN_CONFIG = XmlConfigParser()
    ADMIN_CONFIG.load(ADMIN_CONFIG_FILE)

    timer_patcher = patch('threading.Timer')
    timer_patcher.start()

    feedparser_patcher = patch.object(feedparser, 'parse')
    feedparser_patcher.start()


def tearDownModule():
    global timer_patcher, feedparser_patcher
    timer_patcher.stop()
    feedparser_patcher.stop()


class AdvTestCase(B3TestCase):
    """ Ease test cases that need an working B3 console and need to control the ADV plugin config """

    def setUp(self):
        self.log = logging.getLogger('output')
        self.log.propagate = False

        B3TestCase.setUp(self)

        self.adminPlugin = AdminPlugin(self.console, ADMIN_CONFIG)
        when(self.console).getPlugin("admin").thenReturn(self.adminPlugin)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()

        self.console.startup()
        self.log.propagate = True

    def tearDown(self):
        B3TestCase.tearDown(self)
        unstub()

    def init_plugin(self, config_content=None):
        conf = None
        if config_content:
            conf = XmlConfigParser()
            conf.setXml(config_content)
        elif default_plugin_content:
            conf = XmlConfigParser()
            conf.setXml(default_plugin_content)
        else:
            unittest.skip("cannot get default plugin config file at %s" % default_plugin_file)

        self.p = AdvPlugin(self.console, conf)
        self.p.save = Mock()
        self.conf = self.p.config
        self.log.setLevel(logging.DEBUG)
        self.log.info("============================= Adv plugin: loading config ============================")
        self.p.onLoadConfig()
        self.log.info("============================= Adv plugin: starting  =================================")
        self.p.onStartup()


class Test_default_config(AdvTestCase):
    """ test that bad words from the default config are detected """

    def test_default_config(self):
        self.init_plugin()
        self.assertEqual('2', self.p._rate)
        self.assertIsNone(self.p._fileName)
        self.assertEqual(10, len(self.p._msg.items))
        self.assertEqual("http://forum.bigbrotherbot.net/news-2/?type=rss;action=.xml", self.p._feed)
        self.assertEqual("News: ", self.p._feedpre)
        self.assertEqual(4, self.p._feedmaxitems)
        self.assertEqual('News: ', self.p._feedpre)
        self.assertIsNotNone(self.p._cronTab)
        self.assertTupleEqual((0, range(0, 59, 2), -1, -1, -1, -1),
                              (self.p._cronTab.second, self.p._cronTab.minute, self.p._cronTab.hour,
                               self.p._cronTab.day, self.p._cronTab.month, self.p._cronTab.dow))

    def test_empty(self):
        self.init_plugin("""<configuration plugin="adv" />""")
        self.assertIsNone(self.p._rate)
        self.assertIsNone(self.p._fileName)
        self.assertEqual(0, len(self.p._msg.items))
        self.assertEqual("http://forum.bigbrotherbot.net/news-2/?type=rss;action=.xml", self.p._feed)
        self.assertEqual("News: ", self.p._feedpre)
        self.assertEqual(5, self.p._feedmaxitems)
        self.assertEqual('News: ', self.p._feedpre)
        self.assertIsNone(self.p._cronTab)

    def test_rate_nominal(self):
        self.init_plugin("""\
<configuration plugin="adv">
    <settings name="settings">
        <set name="rate">1</set>
    </settings>
</configuration>
""")
        self.assertEqual('1', self.p._rate)
        self.assertIsNotNone(self.p._cronTab)
        self.assertTupleEqual((0, range(60), -1, -1, -1, -1),
                              (self.p._cronTab.second, self.p._cronTab.minute, self.p._cronTab.hour,
                               self.p._cronTab.day, self.p._cronTab.month, self.p._cronTab.dow))

    def test_rate_nominal_second(self):
        self.init_plugin("""\
<configuration plugin="adv">
    <settings name="settings">
        <set name="rate">40s</set>
    </settings>
</configuration>
""")
        self.assertEqual('40s', self.p._rate)
        self.assertIsNotNone(self.p._cronTab)
        self.assertTupleEqual(([0, 40], -1, -1, -1, -1, -1),
                              (self.p._cronTab.second, self.p._cronTab.minute, self.p._cronTab.hour,
                               self.p._cronTab.day, self.p._cronTab.month, self.p._cronTab.dow))

    def test_rate_junk(self):
        try:
            self.init_plugin("""\
<configuration plugin="adv">
    <settings name="settings">
        <set name="rate">f00</set>
    </settings>
</configuration>
""")
        except TypeError, err:
            print err
        except Exception:
            raise
        self.assertEqual('f00', self.p._rate)
        self.assertIsNone(self.p._cronTab)



class Test_commands(AdvTestCase):

    def setUp(self):
        AdvTestCase.setUp(self)
        self.joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128)

    def tearDown(self):
        AdvTestCase.tearDown(self)

    #################### advlist ####################
    def test_advlist_empty(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">30s</set>
                </settings>
                <ads>
                </ads>
            </configuration>
        """)
        self.joe.clearMessageHistory()
        self.p.cmd_advlist(data=None, client=self.joe)
        self.assertEqual([], self.p._msg.items)
        self.assertEqual(['Adv: No ads loaded'], self.joe.message_history)

    def test_advlist_one_item(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">30s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                </ads>
            </configuration>
        """)
        self.joe.clearMessageHistory()
        self.p.cmd_advlist(data=None, client=self.joe)
        self.assertEqual(['f00'], self.p._msg.items)
        self.assertEqual(['Adv: [1] f00'], self.joe.message_history)

    def test_advlist_many_items(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">30s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.joe.clearMessageHistory()
        self.p.cmd_advlist(data=None, client=self.joe)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.assertEqual(['Adv: [1] f00', 'Adv: [2] bar', 'Adv: [3] test'], self.joe.message_history)

    #################### advrate ####################

    def test_advrate_no_arg_30s(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">30s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.joe.clearMessageHistory()
        self.p.cmd_advrate(data='', client=self.joe)
        self.assertEqual('30s', self.p._rate)
        self.assertEqual(['Current rate is every 30 seconds'], self.joe.message_history)

    def test_advrate_no_arg_2min(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">2</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.joe.clearMessageHistory()
        self.p.cmd_advrate(data=None, client=self.joe)
        self.assertEqual('2', self.p._rate)
        self.assertEqual(['Current rate is every 2 minutes'], self.joe.message_history)

    def test_advrate_set_20s(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual('45s', self.p._rate)
        self.joe.clearMessageHistory()
        self.p.cmd_advrate(data="20s", client=self.joe)
        self.assertEqual('20s', self.p._rate)
        self.assertEqual(['Adv: Rate set to 20 seconds'], self.joe.message_history)

    def test_advrate_set_3min(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual('45s', self.p._rate)
        self.joe.clearMessageHistory()
        self.p.cmd_advrate(data="3", client=self.joe)
        self.assertEqual('3', self.p._rate)
        self.assertEqual(['Adv: Rate set to 3 minutes'], self.joe.message_history)

    #################### advrem ####################

    def test_advrem_nominal(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advrem(data="2", client=self.joe)
        self.assertEqual(['f00', 'test'], self.p._msg.items)
        self.assertEqual(['Adv: Removed item: bar'], self.joe.message_history)

    def test_advrem_no_arg(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advrem(data=None, client=self.joe)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.assertEqual(['Invalid data, use the !advlist command to list valid items numbers'], self.joe.message_history)

    def test_advrem_junk(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advrem(data='f00', client=self.joe)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.assertEqual(['Invalid data, use the !advlist command to list valid items numbers'], self.joe.message_history)

    def test_advrem_invalid_index(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                    <ad>bar</ad>
                    <ad>test</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advrem(data='-18', client=self.joe)
        self.assertEqual(['f00', 'bar', 'test'], self.p._msg.items)
        self.assertEqual(['Invalid data, use the !advlist command to list valid items numbers'], self.joe.message_history)

    #################### advadd ####################

    def test_advadd_nominal(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advadd(data="bar", client=self.joe)
        self.assertEqual(['f00', 'bar'], self.p._msg.items)
        self.assertEqual(['Adv: "bar" added'], self.joe.message_history)

    def test_advadd_no_arg(self):
        self.init_plugin("""
            <configuration>
                <settings name="settings">
                    <set name="rate">45s</set>
                </settings>
                <ads>
                    <ad>f00</ad>
                </ads>
            </configuration>
        """)
        self.assertEqual(['f00'], self.p._msg.items)
        self.joe.clearMessageHistory()
        self.p.cmd_advadd(data=None, client=self.joe)
        self.assertEqual(['f00'], self.p._msg.items)
        self.assertEqual(['Invalid data, specify the message to add'], self.joe.message_history)


class Test_keywords(AdvTestCase):

    def setUp(self):
        AdvTestCase.setUp(self)
        self.init_plugin()

    def test_admins(self):
        # GIVEN
        when(self.p._msg).getnext().thenReturn("@admins")
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128)
        when(self.p._adminPlugin).getAdmins().thenReturn([joe])
        with patch.object(self.console, "say") as say_mock:
            # WHEN
            self.p.adv()
        # THEN
        say_mock.assert_has_calls([call('^7Admins online: Joe^7^7 [^3100^7]')])

    def test_regulars(self):
        # GIVEN
        when(self.p._msg).getnext().thenReturn("@regulars")
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=2)
        when(self.p._adminPlugin).getRegulars().thenReturn([joe])
        with patch.object(self.console, "say") as say_mock:
            # WHEN
            self.p.adv()
        # THEN
        say_mock.assert_has_calls([call('^7Regular players online: Joe^7')])

    def test_topstats(self):
        when(self.p._msg).getnext().thenReturn("@topstats")
        self.p._xlrstatsPlugin = Mock()
        with patch.object(self.p._xlrstatsPlugin, "cmd_xlrtopstats") as xlrtopstats_mock:
            self.p.adv()
            xlrtopstats_mock.assert_has_calls([call(ext=True, cmd=None, data='3', client=None)])

    def test_time(self):
        when(self.p._msg).getnext().thenReturn("@time")
        when(self.console).formatTime(mockito_any()).thenReturn("f00")
        with patch.object(self.console, "say") as say_mock:
            self.p.adv()
            say_mock.assert_has_calls([call('^2Time: ^3f00')])

    def test_nextmap(self):
        when(self.p._msg).getnext().thenReturn("@nextmap")
        when(self.console).getNextMap().thenReturn("f00")
        with patch.object(self.console, "say") as say_mock:
            self.p.adv()
            say_mock.assert_has_calls([call('^2Next map: ^3f00')])


class Test_MessageLoop(unittest.TestCase):

    def test_empty(self):
        ml = MessageLoop()
        self.assertEqual([], ml.items)
        self.assertEqual(None, ml.getnext())

    def test_one_element(self):
        ml = MessageLoop()
        ml.items = ['f00']
        self.assertEqual('f00', ml.getnext())
        self.assertEqual('f00', ml.getnext())

    def test_three_elements(self):
        ml = MessageLoop()
        ml.items = ['f001', 'f002', 'f003']
        self.assertEqual('f001', ml.getnext())
        self.assertEqual('f002', ml.getnext())
        self.assertEqual('f003', ml.getnext())
        self.assertEqual('f001', ml.getnext())
        self.assertEqual('f002', ml.getnext())
        self.assertEqual('f003', ml.getnext())

    def test_put(self):
        ml = MessageLoop()
        self.assertEqual([], ml.items)
        ml.put("bar")
        self.assertEqual(["bar"], ml.items)

    def test_getitem(self):
        ml = MessageLoop()
        ml.items = ['f00']
        self.assertEqual("f00", ml.getitem(0))
        self.assertEqual(None, ml.getitem(1))

    def test_remove(self):
        ml = MessageLoop()
        ml.items = ['f00', 'bar']
        self.assertEqual("f00", ml.getitem(0))
        ml.remove(0)
        self.assertEqual(['bar'], ml.items)
        self.assertEqual("bar", ml.getitem(0))

    def test_clear(self):
        ml = MessageLoop()
        ml.items = ['f00', 'bar']
        ml.clear()
        self.assertEqual([], ml.items)
########NEW FILE########
__FILENAME__ = test_censor
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import os
from mock import Mock, patch
import sys
from b3.fake import FakeClient
from tests import B3TestCase
import unittest2 as unittest

import b3
from b3.plugins.censor import CensorPlugin
from b3.config import XmlConfigParser


default_plugin_file = os.path.normpath(os.path.join(os.path.dirname(__file__), "../../b3/conf/plugin_censor.xml"))


class CensorTestCase(B3TestCase):
    """ Ease testcases that need an working B3 console and need to control the censor plugin config """

    def setUp(self):
        # Timer needs to be patched or the Censor plugin would schedule a 2nd check one minute after
        # penalizing a player.
        self.timer_patcher = patch('threading.Timer')
        self.timer_patcher.start()

        self.log = logging.getLogger('output')
        self.log.propagate = False

        B3TestCase.setUp(self)
        self.console.startup()
        self.log.propagate = True

        self.joe = FakeClient(self.console, name="Joe", exactName="Joe", guid="zaerezarezar", groupBits=1, team=b3.TEAM_UNKNOWN)

    def tearDown(self):
        B3TestCase.tearDown(self)
        self.timer_patcher.stop()



    def init_plugin(self, config_content):
        self.conf = XmlConfigParser()
        self.conf.setXml(config_content)
        self.p = CensorPlugin(self.console, self.conf)

        self.log.setLevel(logging.DEBUG)
        self.log.info("============================= Censor plugin: loading config ============================")
        self.p.onLoadConfig()
        self.log.info("============================= Censor plugin: starting  =================================")
        self.p.onStartup()


class Detection_TestCase(CensorTestCase):
    """base class for TestCase that verify bad words and bad names are correctly detected """

    def setUp(self):
        CensorTestCase.setUp(self)
        self.init_plugin(r"""
            <configuration plugin="censor">
                <badwords>
                    <penalty type="warning" reasonkeyword="racist"/>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                </badnames>
            </configuration>
        """)

    def assert_name_penalized_count(self, name, count):
        self.p.penalizeClientBadname = Mock()

        mock_client = Mock()
        mock_client.connected = True
        mock_client.exactName = name

        self.p.checkBadName(mock_client)
        self.assertEquals(count, self.p.penalizeClientBadname.call_count, "name '%s' should have been penalized %s time" % (name, count))

    def assert_name_is_penalized(self, name):
        self.assert_name_penalized_count(name, 1)

    def assert_name_is_not_penalized(self, name):
        self.assert_name_penalized_count(name, 0)

    def assert_chat_is_penalized(self, text):
        self.p.penalizeClient = Mock()

        mock_client = Mock()
        mock_client.connected = True

        try:
            self.p.checkBadWord(text, mock_client)
            self.fail("text [%s] should have raised a VetoEvent" % text)
        except b3.events.VetoEvent, e:
            self.assertEquals(1, self.p.penalizeClient.call_count, "text [%s] should have been penalized" % text)
            return self.p.penalizeClient.call_args[0] if len(self.p.penalizeClient.call_args) else None


    def assert_chat_is_not_penalized(self, text):
        self.p.penalizeClient = Mock()

        mock_client = Mock()
        mock_client.connected = True

        try:
            self.p.checkBadWord(text, mock_client)
        except b3.events.VetoEvent, e:
            self.fail("text [%s] should not have raised a VetoEvent" % text)
        else:
            self.assertEquals(0, self.p.penalizeClient.call_count, "text [%s] should not have been penalized" % text)


class Test_Censor_badword(Detection_TestCase):
    """ test that bad words are detected """

    def test_word(self):

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        self.p._badNames = []
        self.assert_chat_is_not_penalized('Joe')

        self.p._badNames = []
        self.p._add_bad_word(rulename='ass', word='ass')
        self.assert_chat_is_penalized('ass')
        self.assert_chat_is_penalized('dumb ass!')
        self.assert_chat_is_penalized('what an ass')
        self.assert_chat_is_not_penalized('nice one!')


    def test_regexp(self):

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        self.p._badWords = []
        self.assert_chat_is_not_penalized('Joe')

        self.p._badWords = []
        self.p._add_bad_word(rulename='ass', regexp=r'\b[a@][s$]{2}\b')
        self.assert_chat_is_penalized('what an ass!')
        self.assert_chat_is_penalized('a$s')
        self.assert_chat_is_penalized('in your a$s! noob')
        self.assert_chat_is_penalized('kI$$ my a$s n00b')
        self.assert_chat_is_penalized('right in the ass')

        self.p._badWords = []
        self.p._add_bad_word(rulename='ass', regexp=r'f[u\*]+ck')
        self.assert_chat_is_penalized('fuck')
        self.assert_chat_is_penalized(' fuck ')
        self.assert_chat_is_penalized(' fuck !')
        self.assert_chat_is_penalized('fuck!')
        self.assert_chat_is_penalized('fuck#*!')
        self.assert_chat_is_penalized('you fat fuck')
        self.assert_chat_is_penalized('f*ck u')
        self.assert_chat_is_penalized('f*****ck')
        self.assert_chat_is_penalized('f*uu**ck')




class Test_Censor_badname(Detection_TestCase):
    """ test that bad names are detected """

    def test_regexp(self):

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        self.p._badNames = []
        self.assert_name_is_not_penalized('Joe')

        self.p._badNames = []
        self.p._add_bad_name(rulename='ass', regexp=r'\b[a@][s$]{2}\b')
        self.assert_name_is_penalized('ass')
        self.assert_name_is_penalized('a$s')
        self.assert_name_is_penalized(' a$s ')
        self.assert_name_is_penalized('kI$$ my a$s n00b')
        self.assert_name_is_penalized('right in the ass')


    def test_word(self):

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        self.p._badNames = []
        self.assert_name_is_not_penalized('Joe')

        self.p._badNames = []
        self.p._add_bad_name(rulename='ass', word='ass')
        self.assert_name_is_penalized('ass')
        self.assert_name_is_penalized('dumb ass!')
        self.assert_name_is_penalized('what an ass')



@unittest.skipUnless(os.path.exists(default_plugin_file), reason="cannot get default plugin_censor.xml config file at %s" % default_plugin_file)
class Test_Censor_badword_default_config(Detection_TestCase):
    """ test that bad words from the default config are detected """

    def setUp(self):
        super(Test_Censor_badword_default_config, self).setUp()

        self.p.debug = Mock()

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        def my_warning(text):
            print("WARNING\t%s" % text)
        #self.p.warning = my_warning

        self.p.config.load(default_plugin_file)
        self.p.onLoadConfig()
        self.assertEqual(68, len(self.p._badWords))

    def test_default_penalty(self):
        self.assertEqual("warning", self.p._defaultBadWordPenalty.type)
        self.assertEqual(0, self.p._defaultBadWordPenalty.duration)
        self.assertEqual("cuss", self.p._defaultBadWordPenalty.keyword)
        self.assertIsNone(self.p._defaultBadWordPenalty.reason)

    def test_fuck_has_custom_penalty(self):
        badword_objects = [x for x in self.p._badWords if x.name == 'fuck']
        self.assertEqual(1, len(badword_objects))
        badword_object = badword_objects[0]
        self.assertEqual('tempban', badword_object.penalty.type)
        self.assertEqual(2, badword_object.penalty.duration)
        self.assertIsNone(badword_object.penalty.reason)
        self.assertEquals("cuss", badword_object.penalty.keyword)

    def test_shit_has_custom_penalty(self):
        badword_objects = [x for x in self.p._badWords if x.name == 'shit']
        self.assertEqual(1, len(badword_objects))
        badword_object = badword_objects[0]
        self.assertEqual('warning', badword_object.penalty.type)
        self.assertEqual(60*24, badword_object.penalty.duration)
        self.assertEquals("^7Please don't use profanity", badword_object.penalty.reason)
        self.assertIsNone(badword_object.penalty.keyword)

    def test_asshole_has_default_penalty(self):
        badword_objects = [x for x in self.p._badWords if x.name == 'asshole']
        self.assertEqual(1, len(badword_objects))
        badword_object = badword_objects[0]
        self.assertEqual(self.p._defaultBadWordPenalty.type, badword_object.penalty.type)
        self.assertEqual(self.p._defaultBadWordPenalty.keyword, badword_object.penalty.keyword)
        self.assertEqual(self.p._defaultBadWordPenalty.reason, badword_object.penalty.reason)
        self.assertEqual(self.p._defaultBadWordPenalty.duration, badword_object.penalty.duration)

    def test_shit(self):
        self.assert_chat_is_penalized('shit')
        self.assert_chat_is_penalized('x shit x')
        self.assert_chat_is_penalized('sh!t')
        self.assert_chat_is_penalized('sh*t')
        self.assert_chat_is_penalized('sh1t')
        self.assert_chat_is_penalized('$h1t')
        self.assert_chat_is_penalized('$hit')
        self.assert_chat_is_penalized('$hiiiiit')
        self.assert_chat_is_penalized('$hiiii*t')
        self.assert_chat_is_penalized('$h!t')
        self.assert_chat_is_penalized('xc $h!t. x ')

    def test_ass(self):
        self.assert_chat_is_penalized('ass')
        self.assert_chat_is_penalized('x ass x ')

    def test_asshole(self):
        self.assert_chat_is_penalized('asshole')
        self.assert_chat_is_penalized('x asshole x')
        self.assert_chat_is_penalized('assh0le')
        self.assert_chat_is_penalized('as$h0le')
        self.assert_chat_is_penalized('@sshole')
        self.assert_chat_is_penalized('stupid@sshole!')

    def test_fuck(self):
        self.assert_chat_is_penalized('fuck')
        self.assert_chat_is_penalized('x fuck x')
        self.assert_chat_is_penalized('fock')
        self.assert_chat_is_penalized('f*ck')
        self.assert_chat_is_penalized('f0ck')
        self.assert_chat_is_penalized('fucking')
        self.assert_chat_is_penalized('x fucking x')
        self.assert_chat_is_penalized('focking')
        self.assert_chat_is_penalized('f*cking')
        self.assert_chat_is_penalized('f0cking')
        self.assert_chat_is_penalized('fu0ouuuck')

    def test_fuc(self):
        self.assert_chat_is_penalized('fuc')
        self.assertTrue(self.p.debug.call_args[0][0].startswith('badword rule [fuc]'))
        self.assert_chat_is_penalized('foc')
        self.assert_chat_is_penalized('f0c')
        self.assert_chat_is_penalized('x fuc x')
        self.assert_chat_is_penalized('fuk ')
        self.assertTrue(self.p.debug.call_args[0][0].startswith('badword rule [fuc]'))
        self.assert_chat_is_penalized('x fuk x')

    def test_cunt(self):
        self.assert_chat_is_penalized('cunt')
        self.assert_chat_is_penalized('x cunt x')
        self.assert_chat_is_not_penalized('xcuntx')

    def test_cock(self):
        self.assert_chat_is_penalized('cock')
        self.assert_chat_is_penalized('c0ck')
        self.assert_chat_is_not_penalized('xxc0ckxx')
        self.assert_chat_is_penalized('x cock x')

    def test_dick(self):
        self.assert_chat_is_penalized('dick')
        self.assert_chat_is_not_penalized('dickhead')
        self.assert_chat_is_penalized('d1ck')
        self.assert_chat_is_penalized('d!ck')
        self.assert_chat_is_penalized('d*ck')
        self.assert_chat_is_penalized('x dick x')

    def test_bitch(self):
        self.assert_chat_is_penalized('bitch')
        self.assert_chat_is_penalized('x bitch x')

    def test_biatch(self):
        self.assert_chat_is_penalized('biatch')
        self.assert_chat_is_penalized('x biatch x')

    def test_fag(self):
        self.assert_chat_is_penalized('fag')
        self.assert_chat_is_penalized('x fag x')

    def test_nigger(self):
        self.assert_chat_is_penalized('nigger')
        self.assert_chat_is_penalized('x nigger x')

    def test_pussy(self):
        self.assert_chat_is_penalized('pussy')
        self.assert_chat_is_penalized('x pussy x')

    def test_lul(self):
        self.assert_chat_is_penalized('lul')

    def test_flikker(self):
        self.assert_chat_is_penalized('flikker')
        self.assert_chat_is_penalized('x flikker x')

    def test_homo(self):
        self.assert_chat_is_penalized('homo')
        self.assert_chat_is_penalized('x homo x')

    def test_kanker(self):
        self.assert_chat_is_penalized('kanker')
        self.assert_chat_is_penalized('x kanker x')

    def test_teringlijer(self):
        self.assert_chat_is_penalized('teringlijer')
        self.assert_chat_is_penalized('x teringlijer x')

    def test_kut(self):
        self.assert_chat_is_penalized('kut')
        self.assert_chat_is_penalized('x kut x')

    def test_hoer(self):
        self.assert_chat_is_penalized('hoer')
        self.assert_chat_is_penalized('x hoer x')

    def test_neuk(self):
        self.assert_chat_is_penalized('neuk')
        self.assert_chat_is_penalized('x neuk x')

    def test_vittu(self):
        self.assert_chat_is_penalized('vittu')
        self.assert_chat_is_penalized('x vittu x')

    def test_paskiainen(self):
        self.assert_chat_is_penalized('paskiainen')
        self.assert_chat_is_penalized('x paskiainen x')

    def test_kusipaeae(self):
        self.assert_chat_is_penalized('kusipaeae')
        self.assert_chat_is_penalized('x kusipaeae x')

    def test_fitte(self):
        self.assert_chat_is_penalized('fitte')
        self.assert_chat_is_penalized('x fitte x')

    def test_pikk(self):
        self.assert_chat_is_penalized('pikk')
        self.assert_chat_is_penalized('xs pikk x')

    def test_hore(self):
        self.assert_chat_is_penalized('hore')
        self.assert_chat_is_penalized('x hore x')

    def test_fitta(self):
        self.assert_chat_is_penalized('fitta')
        self.assert_chat_is_penalized('x fitta x')

    def test_knullare(self):
        self.assert_chat_is_penalized('knullare')
        self.assert_chat_is_penalized('x knullare x')

    def test_kuksugare(self):
        self.assert_chat_is_penalized('kuksugare')
        self.assert_chat_is_penalized('x kuksugare x')

    def test_huora(self):
        self.assert_chat_is_penalized('huora')
        self.assert_chat_is_penalized('x huora x')

    def test_spica(self):
        self.assert_chat_is_penalized('spica')
        self.assert_chat_is_penalized('x spica x')

    def test_piroca(self):
        self.assert_chat_is_penalized('piroca')
        self.assert_chat_is_penalized('x piroca x')

    def test_caralho(self):
        self.assert_chat_is_penalized('caralho')
        self.assert_chat_is_penalized('x caralho x')

    def test_puta(self):
        self.assert_chat_is_penalized('puta')
        self.assert_chat_is_penalized('x puta x')

    def test_cabra(self):
        self.assert_chat_is_penalized('cabra')
        self.assert_chat_is_penalized('x cabra x')

    def test_maricon(self):
        self.assert_chat_is_penalized('maricon')
        self.assert_chat_is_penalized('x maricon x')

    def test_pinche(self):
        self.assert_chat_is_penalized('pinche')
        self.assert_chat_is_penalized('x pinche x')

    def test_batard(self):
        self.assert_chat_is_penalized('batard')
        self.assert_chat_is_penalized('x batard x')

    def test_encule(self):
        self.assert_chat_is_penalized('encule')
        self.assert_chat_is_penalized('x encule x')

    def test_merde(self):
        self.assert_chat_is_penalized('merde')
        self.assert_chat_is_penalized('x merde x')

    def test_putain(self):
        self.assert_chat_is_penalized('putain')
        self.assert_chat_is_penalized('x putain x')

    def test_salaud(self):
        self.assert_chat_is_penalized('salaud')
        self.assert_chat_is_penalized('x salaud x')

    def test_connard(self):
        self.assert_chat_is_penalized('connard')
        self.assert_chat_is_penalized('x connard x')

    def test_salopard(self):
        self.assert_chat_is_penalized('salopard')
        self.assert_chat_is_penalized('x salopard x')

    def test_salope(self):
        self.assert_chat_is_penalized('salope')
        self.assert_chat_is_penalized('x salope x')

    def test_scheisse(self):
        self.assert_chat_is_penalized('scheisse')
        self.assert_chat_is_penalized('x scheisse x')

    def test_arsch(self):
        self.assert_chat_is_penalized('arsch')
        self.assert_chat_is_penalized('x arsch x')

    def test_huendin(self):
        self.assert_chat_is_penalized('huendin')
        self.assert_chat_is_penalized('x huendin x')

    def test_kopulieren(self):
        self.assert_chat_is_penalized('kopulieren')
        self.assert_chat_is_penalized('x kopulieren x')

    def test_fick(self):
        self.assert_chat_is_penalized('fick')
        self.assert_chat_is_penalized('x fick x')

    def test_chuj(self):
        self.assert_chat_is_penalized('chuj')
        self.assert_chat_is_penalized('x chuj x')

    def test_kutas(self):
        self.assert_chat_is_penalized('kutas')
        self.assert_chat_is_penalized('x kutas x')

    def test_fiut(self):
        self.assert_chat_is_penalized('fiut')
        self.assert_chat_is_penalized('x fiut x')

    def test_pedal(self):
        self.assert_chat_is_penalized('pedal')
        self.assert_chat_is_penalized('x pedal x')

    def test_cipa(self):
        self.assert_chat_is_penalized('cipa')
        self.assert_chat_is_penalized('x cipa x')

    def test_pizda(self):
        self.assert_chat_is_penalized('pizda')
        self.assert_chat_is_penalized(' x pizda x')

    def test_ciota(self):
        self.assert_chat_is_penalized('ciota')
        self.assert_chat_is_penalized('x ciota x')

    def test_dupek(self):
        self.assert_chat_is_penalized('dupek')
        self.assert_chat_is_penalized('x dupek x')

    def test_kurwa(self):
        self.assert_chat_is_penalized('kurwa')
        self.assert_chat_is_penalized('x kurwa x')

    def test_skurwysyn(self):
        self.assert_chat_is_penalized('skurwysyn')
        self.assert_chat_is_penalized('  x skurwysyn  x')

    def test_zajebac(self):
        self.assert_chat_is_penalized('zajebac')
        self.assert_chat_is_penalized('x zajebac x')

    def test_pojebac(self):
        self.assert_chat_is_penalized('pojebac')
        self.assert_chat_is_penalized(' x pojebac x')

    def test_wyjebac(self):
        self.assert_chat_is_penalized('wyjebac')
        self.assert_chat_is_penalized('x wyjebac x')

    def test_pierdolic(self):
        self.assert_chat_is_penalized('pierdolic')
        self.assert_chat_is_penalized('x pierdolic x')

    def test_rozpierdalac(self):
        self.assert_chat_is_penalized('rozpierdalaj')
        self.assert_chat_is_penalized(' x rozpierdalaj x')
        self.assert_chat_is_penalized('rozpierdol')
        self.assert_chat_is_penalized('rozpierdola')
        self.assert_chat_is_penalized('rozpierdolic')

    def test_popierdolony(self):
        self.assert_chat_is_penalized('popierdolony')
        self.assert_chat_is_penalized('x popierdolony x')

    def test_wypierdalac(self):
        self.assert_chat_is_penalized('wypierdalac')
        self.assert_chat_is_penalized('x wypierdalac x')



@unittest.skipUnless(os.path.exists(default_plugin_file), reason="cannot get default plugin_censor.xml config file at %s" % default_plugin_file)
class Test_Censor_badname_default_config(Detection_TestCase):
    """ test that bad names from the default config are detected """

    def setUp(self):
        super(Test_Censor_badname_default_config, self).setUp()

        def my_info(text):
            print("INFO\t%s" % text)
        #self.p.info = my_info

        def my_warning(text):
            print("WARNING\t%s" % text)
        #self.p.warning = my_warning

        self.p.config.load(default_plugin_file)
        self.p.onLoadConfig()
        self.assertEqual(17, len(self.p._badNames))

    def test_default_penalty(self):
        self.assertEqual("warning", self.p._defaultBadNamePenalty.type)
        self.assertEqual(0, self.p._defaultBadNamePenalty.duration)
        self.assertEqual("badname", self.p._defaultBadNamePenalty.keyword)
        self.assertIsNone(self.p._defaultBadNamePenalty.reason)

    def test_nigger_has_custom_penalty(self):
        badname_objects = [x for x in self.p._badNames if x.name == 'nigger']
        self.assertEqual(1, len(badname_objects))
        badname_object = badname_objects[0]
        self.assertEqual('ban', badname_object.penalty.type)
        self.assertEqual('racism', badname_object.penalty.keyword)

    def test_shit_has_default_penalty(self):
        badname_objects = [x for x in self.p._badNames if x.name == 'shit']
        self.assertEqual(1, len(badname_objects))
        badname_object = badname_objects[0]
        self.assertEqual(self.p._defaultBadNamePenalty.type, badname_object.penalty.type)
        self.assertEqual(self.p._defaultBadNamePenalty.keyword, badname_object.penalty.keyword)
        self.assertEqual(self.p._defaultBadNamePenalty.reason, badname_object.penalty.reason)
        self.assertEqual(self.p._defaultBadNamePenalty.duration, badname_object.penalty.duration)

    def test_doublecolor(self):
        self.assert_name_is_penalized('j^^33oe')

    def test_ass(self):
        self.assert_name_is_not_penalized('jassica')
        self.assert_name_is_penalized('ass')
        self.assert_name_is_penalized('a$s')
        self.assert_name_is_penalized('big a$s joe')
        self.assert_name_is_penalized('big ass joe')

    def test_fuck(self):
        self.assert_name_is_penalized('fuck')
        self.assert_name_is_penalized(' fuck ')
        self.assert_name_is_penalized('what the fuck!')
        self.assert_name_is_penalized('fUck')
        self.assert_name_is_penalized('f*ck')
        self.assert_name_is_penalized('f.ck')
        self.assert_name_is_penalized('f.uck')
        self.assert_name_is_penalized('fuuuuck')
        self.assert_name_is_penalized('fuckkkkk')
        self.assert_name_is_penalized('watdafuck?')

    def test_shit(self):
        self.assert_name_is_penalized('shit')
        self.assert_name_is_penalized(' shit ')
        self.assert_name_is_penalized('this is shit!')
        self.assert_name_is_penalized('shIt')
        self.assert_name_is_penalized('sh!t')
        self.assert_name_is_penalized('sh.t')

    def test_bitch(self):
        self.assert_name_is_penalized('bitch')
        self.assert_name_is_penalized('son of a bitch!')
        self.assert_name_is_penalized('b*tch')
        self.assert_name_is_penalized('b!tch')
        self.assert_name_is_penalized('b.tch')
        self.assert_name_is_penalized('daBiTch')

    def test_pussy(self):
        self.assert_name_is_penalized('pussy')
        self.assert_name_is_penalized('qsdf pussy qsdf')
        self.assert_name_is_penalized('pu$sy')
        self.assert_name_is_penalized('pus$y')
        self.assert_name_is_penalized('pu$$y')
        self.assert_name_is_penalized('DaPussyKat')

    def test_nigger(self):
        self.assert_name_is_penalized('nigger')
        self.assert_name_is_penalized('qsfd nigger qsdf ')
        self.assert_name_is_penalized('n1gger')
        self.assert_name_is_penalized('n.gger')
        self.assert_name_is_penalized('n!gger')
        penalty = self.p.penalizeClientBadname.call_args[0][0]
        self.assertEqual('ban', penalty.type)
        self.assertEqual('racism', penalty.keyword)

    def test_cunt(self):
        self.assert_name_is_penalized('cunt')
        self.assert_name_is_penalized('stupid cunt')
        self.assert_name_is_penalized('cunt on this')

    def test_nazi(self):
        self.assert_name_is_penalized('nazi')
        self.assert_name_is_penalized('naz!')
        self.assert_name_is_penalized('n@z!')
        self.assert_name_is_penalized('n@zi')

    def test_jihad(self):
        self.assert_name_is_penalized("jihad")
        self.assert_name_is_penalized("jih@d")
        self.assert_name_is_penalized("j!h@d")
        self.assert_name_is_penalized("j!had")
        self.assert_name_is_penalized("j1had")

    def test_admin(self):
        self.assert_name_is_penalized("admin")
        self.assert_name_is_penalized("@dmin")
        self.assert_name_is_penalized("@dm1n")
        self.assert_name_is_penalized("adm1n")
        self.assert_name_is_penalized("adm!n")

    def test_hitler(self):
        self.assert_name_is_penalized("hitler")
        self.assert_name_is_penalized("hitl3r")
        self.assert_name_is_penalized("hitl.r")
        self.assert_name_is_penalized("h!tler")
        self.assert_name_is_penalized("h1tler")
        self.assert_name_is_penalized("hit1er")

    def test_asshole(self):
        self.assert_name_is_penalized("asshole")
        self.assert_name_is_penalized("asshOle")
        self.assert_name_is_penalized("asshO1e")
        self.assert_name_is_penalized("a$$hO1e")
        self.assert_name_is_penalized("@$$hO1e")

    def test_kut(self):
        self.assert_name_is_penalized("kut")

    def test_hoer(self):
        self.assert_name_is_penalized("hoer")
        self.assert_name_is_penalized("h0er")
        self.assert_name_is_penalized("h0err")

    def test_huora(self):
        self.assert_name_is_penalized("huora")
        self.assert_name_is_penalized("hu0ra")
        self.assert_name_is_penalized("hu0r@")

    def test_puta(self):
        self.assert_name_is_penalized("puta")
        self.assert_name_is_penalized("put@")




class Test_config(CensorTestCase):
    """ test different config are correctly loaded """

    def assert_default_badwords_penalty(self):
        self.assertEqual("warning", self.p._defaultBadWordPenalty.type)
        self.assertEqual(0, self.p._defaultBadWordPenalty.duration)
        self.assertEqual("cuss", self.p._defaultBadWordPenalty.keyword)
        self.assertIsNone(self.p._defaultBadWordPenalty.reason)

    def assert_default_badnames_penalty(self):
        self.assertEqual("warning", self.p._defaultBadNamePenalty.type)
        self.assertEqual(0, self.p._defaultBadNamePenalty.duration)
        self.assertEqual("badname", self.p._defaultBadNamePenalty.keyword)
        self.assertIsNone(self.p._defaultBadNamePenalty.reason)



    @unittest.skipUnless(os.path.exists(default_plugin_file), reason="cannot get default plugin_censor.xml config file at %s" % default_plugin_file)
    def test_default_conf(self):
        with open(default_plugin_file) as default_conf:
            self.init_plugin(default_conf.read())
        self.assertEqual(40, self.p._maxLevel)
        self.assertEqual(3, self.p._ignoreLength)
        self.assertEqual(68, len(self.p._badWords))
        self.assertEqual(17, len(self.p._badNames))
        self.assert_default_badwords_penalty()
        self.assert_default_badnames_penalty()

    def test_broken_conf__emtpy_conf(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
            </configuration>
        """)
        self.assertEqual(0, self.p._maxLevel)
        self.assertEqual(3, self.p._ignoreLength)
        self.assertEqual(0, len(self.p._badWords))
        self.assertEqual(0, len(self.p._badNames))
        self.assert_default_badwords_penalty()
        self.assert_default_badnames_penalty()

    def test_broken_conf__max_level_missing(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                </settings>
            </configuration>
        """)
        self.assertEqual(0, self.p._maxLevel)

    def test_broken_conf__max_level_empty(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
		            <set name="max_level"></set>
                </settings>
            </configuration>
        """)
        self.assertEqual(0, self.p._maxLevel)

    def test_broken_conf__max_level_NaN(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
		            <set name="max_level">fo0</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(0, self.p._maxLevel)


    def test_broken_conf__ignore_length_missing(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                </settings>
            </configuration>
        """)
        self.assertEqual(3, self.p._ignoreLength)

    def test_broken_conf__ignore_length_empty(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="ignore_length"></set>
                </settings>
            </configuration>
        """)
        self.assertEqual(3, self.p._ignoreLength)

    def test_broken_conf__ignore_length_NaN(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="ignore_length">fo0</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(3, self.p._ignoreLength)


class Test_functional(CensorTestCase):
    """ test simulated in-game scenarios """

    def test_joe_says_badword(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="max_level">40</set>
                    <!-- ignore bad words that have equal or less characters: -->
                    <set name="ignore_length">3</set>
                </settings>
                <badwords>
                    <penalty type="warning" reasonkeyword="default_reason"/>
                    <badword name="foo" lang="en">
                        <regexp>\bf[o0]{2}\b</regexp>
                    </badword>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                    <badname name="cunt">
                        <word>cunt</word>
                    </badname>
                </badnames>
            </configuration>
        """)
        self.joe.warn = Mock()
        self.joe.connects(0)
        self.joe.says("qsfdl f0o!")
        self.assertEqual(1, self.joe.warn.call_count)


    def test_cunt_connects(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="max_level">40</set>
                    <!-- ignore bad words that have equal or less characters: -->
                    <set name="ignore_length">3</set>
                </settings>
                <badwords>
                    <penalty type="warning" reasonkeyword="default_reason"/>
                    <badword name="foo" lang="en">
                        <regexp>\bf[o0]{2}\b</regexp>
                    </badword>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                    <badname name="cunt">
                        <word>cunt</word>
                    </badname>
                </badnames>
            </configuration>
        """)
        self.joe.name = self.joe.exactName = "cunt"
        self.joe.warn = Mock()
        self.joe.connects(0)
        self.assertEqual(1, self.joe.warn.call_count)


    def test_2_letters_badword_when_ignore_length_is_2(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="max_level">40</set>
                    <!-- ignore bad words that have equal or less characters: -->
                    <set name="ignore_length">2</set>
                </settings>
                <badwords>
                    <penalty type="warning" reasonkeyword="default_reason"/>
                    <badword name="TG" lang="fr">
                        <regexp>\bTG\b</regexp>
                    </badword>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                </badnames>
            </configuration>
        """)

        self.joe.warn = Mock()
        self.joe.warn.reset_mock()
        self.joe.connects(0)
        self.joe.says("tg")
        self.assertEqual(0, self.joe.warn.call_count)


    def test_2_letters_badword_when_ignore_length_is_1(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="max_level">40</set>
                    <!-- ignore bad words that have equal or less characters: -->
                    <set name="ignore_length">1</set>
                </settings>
                <badwords>
                    <penalty type="warning" reasonkeyword="default_reason"/>
                    <badword name="TG" lang="fr">
                        <regexp>\bTG\b</regexp>
                    </badword>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                </badnames>
            </configuration>
        """)

        self.joe.warn = Mock()
        self.joe.warn.reset_mock()
        self.joe.connects(0)
        self.joe.says("tg")
        self.assertEqual(1, self.joe.warn.call_count)


    def test_tempban_penalty_is_applied(self):
        self.init_plugin(r"""
            <configuration plugin="censor">
                <settings name="settings">
                    <set name="max_level">40</set>
                    <!-- ignore bad words that have equal or less characters: -->
                    <set name="ignore_length">3</set>
                </settings>
                <badwords>
                    <penalty type="warning" reasonkeyword="default_reason"/>
                    <badword name="anani" lang="en">
                        <penalty type="tempban" reasonkeyword="cuss" duration="7d" />
                        <regexp>\s[a@]n[a@]n[iy!1]</regexp>
                    </badword>
                </badwords>
                <badnames>
                    <penalty type="warning" reasonkeyword="badname"/>
                </badnames>
            </configuration>
        """)
        self.joe.warn = Mock(wraps=lambda *args: sys.stdout.write("warning joe %s" % repr(args)))
        self.joe.tempban = Mock(wraps=lambda *args: sys.stdout.write("tempbanning joe %s" % repr(args)))
        self.joe.warn.reset_mock()
        self.joe.tempban.reset_mock()
        self.joe.connects(0)
        self.joe.says("anani")
        self.assertEqual(0, self.joe.warn.call_count)
        self.assertEqual(1, self.joe.tempban.call_count)

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_login
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import os
from mockito import when
from b3.fake import FakeClient
from b3.plugins.admin import AdminPlugin
from tests import B3TestCase
import unittest2 as unittest

from b3.plugins.login import LoginPlugin
from b3.config import XmlConfigParser

from b3 import __file__ as b3__file__

default_plugin_file = os.path.normpath(os.path.join(os.path.dirname(b3__file__), "conf/plugin_login.xml"))
ADMIN_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3__file__), "conf/plugin_admin.xml"))

F00_MD5 = '9f06f2538cdbb40bce9973f60506de09'

class LoginTestCase(B3TestCase):
    """ Ease testcases that need an working B3 console and need to control the censor plugin config """

    def setUp(self):
        self.log = logging.getLogger('output')
        self.log.propagate = False

        B3TestCase.setUp(self)

        admin_conf = XmlConfigParser()
        admin_conf.load(ADMIN_CONFIG_FILE)
        self.adminPlugin = AdminPlugin(self.console, admin_conf)
        when(self.console).getPlugin("admin").thenReturn(self.adminPlugin)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()

        self.console.gameName = "theGame"
        self.console.startup()
        self.log.propagate = True


    def tearDown(self):
        B3TestCase.tearDown(self)

    def init_plugin(self, config_content=None):
        self.conf = XmlConfigParser()
        if config_content:
            self.conf.setXml(config_content)
        else:
            self.conf.load(default_plugin_file)
        self.p = LoginPlugin(self.console, self.conf)

        self.log.setLevel(logging.DEBUG)
        self.log.info("============================= Login plugin: loading config ============================")
        self.p.onLoadConfig()
        self.log.info("============================= Login plugin: starting  =================================")
        self.p.onStartup()




@unittest.skipUnless(os.path.exists(default_plugin_file), reason="cannot get default plugin_login.xml config file at %s" % default_plugin_file)
class Test_default_config(LoginTestCase):

    def setUp(self):
        LoginTestCase.setUp(self)
        self.init_plugin()

    def test_thresholdlevel(self):
        self.assertEqual(40, self.p.threshold)

    def test_passwdlevel(self):
        self.assertEqual(40, self.p.passwdlevel)


class Test_load_config(LoginTestCase):

    def test_empty_conf(self):
        self.init_plugin("""<configuration plugin="login">
            <settings name="settings"/>
        </configuration>""")
        self.assertEqual(1000, self.p.threshold)
        self.assertEqual(100, self.p.passwdlevel)

    def test_thresholdlevel_empty(self):
        self.init_plugin("""<configuration plugin="login">
            <settings name="settings">
                <set name="thresholdlevel"></set>
            </settings>
        </configuration>""")
        self.assertEqual(1000, self.p.threshold)

    def test_thresholdlevel_junk(self):
        self.init_plugin("""<configuration plugin="login">
            <settings name="settings">
                <set name="thresholdlevel">f00</set>
            </settings>
        </configuration>""")
        self.assertEqual(1000, self.p.threshold)

    def test_passwdlevel_empty(self):
        self.init_plugin("""<configuration plugin="login">
            <settings name="settings">
                <set name="passwdlevel"></set>
            </settings>
        </configuration>""")
        self.assertEqual(100, self.p.passwdlevel)

    def test_passwdlevel_junk(self):
        self.init_plugin("""<configuration plugin="login">
            <settings name="settings">
                <set name="passwdlevel">f00</set>
            </settings>
        </configuration>""")
        self.assertEqual(100, self.p.passwdlevel)


class Test_cmd_setpassword(LoginTestCase):

    def setUp(self):
        LoginTestCase.setUp(self)
        self.init_plugin()
        self.joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128)

    def test_no_parameter(self):
        # GIVEN
        self.joe.connects("0")
        self.joe._groupBits = 128 # force superadmin
        self.assertEqual('', self.joe.password)
        joe_db = self.p._get_client_from_db(self.joe.id)
        self.assertEqual('', joe_db.password)
        # WHEN
        self.joe.clearMessageHistory()
        self.joe.says("!setpassword")
        # THEN
        self.assertEqual(['usage: !setpassword <new password> [name]'], self.joe.message_history)
        self.assertEqual('', self.joe.password)
        joe_db = self.p._get_client_from_db(self.joe.id)
        self.assertEqual('', joe_db.password)

    def test_nominal(self):
        # GIVEN
        self.joe.connects("0")
        self.joe._groupBits = 128 # force superadmin
        self.assertEqual('', self.joe.password)
        joe_db = self.p._get_client_from_db(self.joe.id)
        self.assertEqual('', joe_db.password)
        # WHEN
        self.joe.clearMessageHistory()
        self.joe.says("!setpassword f00")
        # THEN
        self.assertEqual(['your new password is saved'], self.joe.message_history)
        self.assertEqual(F00_MD5, self.joe.password)
        joe_db = self.p._get_client_from_db(self.joe.id)
        self.assertEqual(F00_MD5, joe_db.password)


    def test_change_someone_else(self):
        # GIVEN
        self.joe.connects("0")
        self.joe._groupBits = 128 # force superadmin

        jack = FakeClient(self.console, name="Jack", guid="jackguid")
        jack.connects("1")
        self.assertEqual('', jack.password)
        jack_db = self.p._get_client_from_db(jack.id)
        self.assertEqual('', jack_db.password)

        # WHEN
        self.joe.clearMessageHistory()
        self.joe.says("!setpassword f00 jack")

        # THEN
        self.assertEqual(['new password for Jack saved'], self.joe.message_history)
        self.assertEqual(F00_MD5, jack.password)
        jack_db = self.p._get_client_from_db(jack.id)
        self.assertEqual(F00_MD5, jack_db.password)


    def test_change_someone_else_not_found(self):
        # GIVEN
        self.joe.connects("0")
        self.joe._groupBits = 128 # force superadmin

        # WHEN
        self.joe.clearMessageHistory()
        self.joe.says("!setpassword new_password jack")

        # THEN
        self.assertEqual(['No players found matching jack'], self.joe.message_history)



class Test_auth(LoginTestCase):

    def setUp(self):
        LoginTestCase.setUp(self)
        self.init_plugin()

    def test_low_level(self):
        # GIVEN
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=8)
        # WHEN
        joe.clearMessageHistory()
        joe.connects("0")
        # THEN
        self.assertEqual([], joe.message_history)
        self.assertEqual(8, joe.groupBits)


    def test_high_level_no_password_set(self):
        # GIVEN
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128)
        # WHEN
        joe.clearMessageHistory()
        joe.connects("0")
        # THEN
        self.assertEqual(['You need a password to use all your privileges. Ask the administrator to set a password for you.'], joe.message_history)
        self.assertEqual(2, joe.groupBits)


    def test_high_level_having_password(self):
        # GIVEN
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128, password=F00_MD5)
        joe.save()
        # WHEN
        joe.clearMessageHistory()
        joe.connects("0")
        # THEN
        self.assertEqual(['Login via console: /tell 0 !login yourpassword'], joe.message_history)
        self.assertEqual(2, joe.groupBits)



class Test_cmd_login(LoginTestCase):

    def setUp(self):
        LoginTestCase.setUp(self)
        self.init_plugin()
        # create a client which needs to log in and has a password saved in database
        self.jack = FakeClient(self.console, name="Jack", guid="jackguid", groupBits=128, password=F00_MD5)
        self.jack.save()

    def test_already_logged_in(self):
        # GIVEN
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=128)
        joe.setvar(self.p, 'loggedin', 1)
        joe.connects("0")
        # WHEN
        joe.clearMessageHistory()
        joe.says("!login")
        # THEN
        self.assertEqual(['You are already logged in.'], joe.message_history)

    def test_low_level(self):
        # GIVEN
        joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=8)
        joe.connects("0")
        # WHEN
        joe.clearMessageHistory()
        joe.says("!login")
        # THEN
        self.assertEqual(['You do not need to log in.'], joe.message_history)
        self.assertFalse(self.jack.isvar(self.p, 'loggedin'))

    def test_high_level_no_parameter(self):
        # GIVEN
        self.jack.connects("0")
        self.assertEqual(2, self.jack.groupBits) # the login plugin set his level down to 2 while waiting for the password
        # WHEN
        self.jack.clearMessageHistory()
        self.jack.says("!login")
        # THEN
        self.assertEqual(['Usage (via console): /tell 0 !login yourpassword'], self.jack.message_history)
        self.assertEqual(2, self.jack.groupBits)
        self.assertFalse(self.jack.isvar(self.p, 'loggedin'))

    def test_high_level_wrong_password(self):
        # GIVEN
        self.jack.connects("0")
        self.assertEqual(2, self.jack.groupBits) # the login plugin set his level down to 2 while waiting for the password
        # WHEN
        self.jack.clearMessageHistory()
        self.jack.says("!login qsfddqsf")
        # THEN
        self.assertEqual(['***Access denied***'], self.jack.message_history)
        self.assertEqual(2, self.jack.groupBits)
        self.assertFalse(self.jack.isvar(self.p, 'loggedin'))

    def test_high_level_correct_password(self):
        # GIVEN
        self.jack.connects("0")
        self.assertEqual(2, self.jack.groupBits) # the login plugin set his level down to 2 while waiting for the password
        # WHEN
        self.jack.clearMessageHistory()
        self.jack.says("!login f00")
        # THEN
        self.assertEqual(['You are successfully logged in.'], self.jack.message_history)
        self.assertEqual(128, self.jack.groupBits)
        self.assertTrue(self.jack.isvar(self.p, 'loggedin'))

    def test_high_level_spoofed_password_with_compromised_client_object(self):
        """
        in some B3 game parser implementation there is an issue which could let the 'password' property of client
        objects be compromised.
        """
        # GIVEN
        batman_md5 = 'ec0e2603172c73a8b644bb9456c1ff6e'
        self.jack.connects("0")
        self.assertEqual(2, self.jack.groupBits) # the login plugin set his level down to 2 while waiting for the password
        self.jack.password = batman_md5
        # WHEN
        self.jack.clearMessageHistory()
        self.jack.says("!login batman")
        # THEN
        self.assertEqual(['***Access denied***'], self.jack.message_history)
        self.assertEqual(2, self.jack.groupBits)
        self.assertFalse(self.jack.isvar(self.p, 'loggedin'))

    def test_high_level_correct_password_with_compromised_client_object(self):
        """
        in some B3 game parser implementation there is an issue which could let the 'password' property of client
        objects be compromised.
        """
        # GIVEN
        batman_md5 = 'ec0e2603172c73a8b644bb9456c1ff6e'
        self.jack.connects("0")
        self.assertEqual(2, self.jack.groupBits) # the login plugin set his level down to 2 while waiting for the password
        self.jack.password = batman_md5
        # WHEN
        self.jack.clearMessageHistory()
        self.jack.says("!login f00")
        # THEN
        self.assertEqual(['You are successfully logged in.'], self.jack.message_history)
        self.assertEqual(128, self.jack.groupBits)
        self.assertTrue(self.jack.isvar(self.p, 'loggedin'))

########NEW FILE########
__FILENAME__ = test_spamcontrol
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import new
import os
from mockito import when
from mock import Mock, call, patch
import unittest2 as unittest
from b3.events import Event
from b3.fake import FakeClient
from b3.plugins.admin import AdminPlugin
from b3.plugins.spamcontrol import SpamcontrolPlugin
from tests import B3TestCase

from b3 import __file__ as b3_module__file__
from b3.config import XmlConfigParser


ADMIN_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml"))
SPAMCONTROM_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_spamcontrol.xml"))

class SpamcontrolTestCase(B3TestCase):
    """ Ease testcases that need an working B3 console and need to control the Spamcontrol plugin config """

    def setUp(self):
        self.timer_patcher = patch('threading.Timer')
        self.timer_patcher.start()

        self.log = logging.getLogger('output')
        self.log.propagate = False

        B3TestCase.setUp(self)
        self.console.startup()
        self.log.propagate = True

    def tearDown(self):
        B3TestCase.tearDown(self)
        self.timer_patcher.stop()

    def init_plugin(self, config_content):
        self.conf = XmlConfigParser()
        self.conf.setXml(config_content)
        self.p = SpamcontrolPlugin(self.console, self.conf)

        self.log.setLevel(logging.DEBUG)
        self.log.info("============================= Spamcontrol plugin: loading config ============================")
        self.p.onLoadConfig()
        self.log.info("============================= Spamcontrol plugin: starting  =================================")
        self.p.onStartup()



class Test_config(SpamcontrolTestCase):
    """ test different config are correctly loaded """
    default_max_spamins = 10
    default_mod_level = 20
    default_falloff_rate = 6.5

    @unittest.skipUnless(os.path.exists(SPAMCONTROM_CONFIG_FILE), reason="cannot get default plugin config file at %s" % SPAMCONTROM_CONFIG_FILE)
    def test_default_conf(self):
        with open(SPAMCONTROM_CONFIG_FILE) as default_conf:
            self.init_plugin(default_conf.read())
        self.assertEqual(self.default_max_spamins, self.p._maxSpamins)
        self.assertEqual(self.default_mod_level, self.p._modLevel)
        self.assertEqual(self.default_falloff_rate, self.p._falloffRate)


    def test_emtpy_conf(self):
        self.init_plugin(r"""<configuration plugin="spamcontrol"/>""")
        self.assertEqual(self.default_max_spamins, self.p._maxSpamins)
        self.assertEqual(self.default_mod_level, self.p._modLevel)
        self.assertEqual(self.default_falloff_rate, self.p._falloffRate)


    def test_max_spamins_empty(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
                    <set name="max_spamins"></set>
                </settings>
            </configuration>
        """)
        self.assertEqual(self.default_max_spamins, self.p._maxSpamins)

    def test_max_spamins_NaN(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
		            <set name="max_spamins">fo0</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(self.default_max_spamins, self.p._maxSpamins)

    def test_max_spamins_negative(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
		            <set name="max_spamins">-15</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(0, self.p._maxSpamins)


    def test_mod_level_empty(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
                    <set name="mod_level"></set>
                </settings>
            </configuration>
        """)
        self.assertEqual(self.default_mod_level, self.p._modLevel)

    def test_mod_level_NaN(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
                    <set name="mod_level">fo0</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(self.default_mod_level, self.p._modLevel)

    def test_mod_level_nominal(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
                    <set name="mod_level">60</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(60, self.p._modLevel)

    def test_mod_level_by_group_keyword(self):
        self.init_plugin(r"""
            <configuration plugin="spamcontrol">
                <settings name="settings">
                    <set name="mod_level">senioradmin</set>
                </settings>
            </configuration>
        """)
        self.assertEqual(80, self.p._modLevel)



@unittest.skipUnless(os.path.exists(SPAMCONTROM_CONFIG_FILE), reason="cannot get default plugin config file at %s" % SPAMCONTROM_CONFIG_FILE)
class Test_plugin(SpamcontrolTestCase):

    def setUp(self):
        SpamcontrolTestCase.setUp(self)

        self.adminPlugin = AdminPlugin(self.console, ADMIN_CONFIG_FILE)
        when(self.console).getPlugin("admin").thenReturn(self.adminPlugin)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()

        with open(SPAMCONTROM_CONFIG_FILE) as default_conf:
            self.init_plugin(default_conf.read())

        self.joe = FakeClient(self.console, name="Joe", guid="zaerezarezar", groupBits=1)
        self.joe.connects("1")

        self.superadmin = FakeClient(self.console, name="Superadmin", guid="superadmin_guid", groupBits=128)
        self.superadmin.connects("2")


    def assertSpaminsPoints(self, client, points):
        actual = client.var(self.p, 'spamins', 0).value
        self.assertEqual(points, actual, "expecting %s to have %s spamins points" % (client.name, points))


    def test_say(self):
        when(self.p).getTime().thenReturn(0).thenReturn(1).thenReturn(20).thenReturn(120)

        self.assertSpaminsPoints(self.joe, 0)

        self.joe.says("doh") # 0s
        self.assertSpaminsPoints(self.joe, 2)

        self.joe.says("foo") # 1s
        self.assertSpaminsPoints(self.joe, 4)

        self.joe.says("bar") # 20s
        self.assertSpaminsPoints(self.joe, 3)

        self.joe.says("hi") # 120s
        self.assertSpaminsPoints(self.joe, 0)


    def test_cmd_spamins(self):
        # GIVEN
        when(self.p).getTime().thenReturn(0).thenReturn(3).thenReturn(4).thenReturn(4).thenReturn(500)
        self.joe.says("doh") # 0s
        self.joe.says("doh") # 3s
        self.joe.says("doh") # 4s
        # WHEN
        self.superadmin.clearMessageHistory()
        self.superadmin.says("!spamins joe")
        # THEN
        self.assertListEqual(['Joe currently has 9 spamins, peak was 9'], self.superadmin.message_history) # 4s
        # WHEN
        self.superadmin.clearMessageHistory()
        self.superadmin.says("!spamins joe")
        self.assertListEqual(['Joe currently has 0 spamins, peak was 9'], self.superadmin.message_history) # 500s


    def test_cmd_spamins_lowercase(self):
        # GIVEN
        mike = FakeClient(self.console, name="Mike")
        mike.connects("3")
        # WHEN
        self.superadmin.clearMessageHistory()
        self.superadmin.says("!spamins mike")
        # THEN
        self.assertListEqual(['Mike currently has 0 spamins, peak was 0'], self.superadmin.message_history)


    def test_cmd_spamins_uppercase(self):
        # GIVEN
        mike = FakeClient(self.console, name="Mike")
        mike.connects("3")
        # WHEN
        self.superadmin.clearMessageHistory()
        self.superadmin.says("!spamins MIKE")
        # THEN
        self.assertListEqual(['Mike currently has 0 spamins, peak was 0'], self.superadmin.message_history)


    def test_cmd_spamins_unknown_player(self):
        # WHEN
        self.superadmin.clearMessageHistory()
        self.superadmin.says("!spamins nobody")
        # THEN
        self.assertListEqual(['No players found matching nobody'], self.superadmin.message_history)


    def test_cmd_spamins_no_argument(self):
        # WHEN
        self.joe.clearMessageHistory()
        self.joe.says("!spamins")
        # THEN
        self.assertListEqual(['You do not have sufficient access to use !spamins'], self.joe.message_history)
        # WHEN
        self.superadmin.says("!putgroup joe mod")
        self.joe.clearMessageHistory()
        self.joe.says("!spamins")
        # THEN
        self.assertListEqual(['Joe is too cool to spam'], self.joe.message_history)


    def test_joe_gets_warned(self):
        # GIVEN
        when(self.p).getTime().thenReturn(0)
        self.joe.warn = Mock()

        # WHEN
        self.joe.says("doh 1")
        self.joe.says("doh 2")
        self.joe.says("doh 3")
        self.joe.says("doh 4")
        self.joe.says("doh 5")

        # THEN
        self.assertEqual(1, self.joe.warn.call_count)




class Test_game_specific_spam(SpamcontrolTestCase):

    def setUp(self):
        SpamcontrolTestCase.setUp(self)

        with open(SPAMCONTROM_CONFIG_FILE) as default_conf:
            self.init_plugin(default_conf.read())

        self.joe = FakeClient(self.console, name="Joe", exactName="Joe", guid="zaerezarezar", groupBits=1)
        self.joe.connects("1")

        # let's say our game has a new event : EVT_CLIENT_RADIO
        EVT_CLIENT_RADIO = self.console.Events.createEvent('EVT_CLIENT_RADIO', 'Event client radio')

        # teach the Spamcontrol plugin how to react on such events
        def onRadio(event):
            new_event = Event(type=event.type, client=event.client, target=event.target, data=event.data['text'])
            self.p.onChat(new_event)
        self.p.eventHanlders[EVT_CLIENT_RADIO] = onRadio
        self.p.registerEvent(EVT_CLIENT_RADIO)

        # patch joe to make him able to send radio messages
        def radios(me, text):
            me.console.queueEvent(Event(type=EVT_CLIENT_RADIO, client=me, data={'text': text}))
        self.joe.radios = new.instancemethod(radios, self.joe, FakeClient)


    def test_radio_spam(self):
        when(self.p).getTime().thenReturn(0)
        self.joe.warn = Mock()
        self.joe.says("doh 1")
        self.joe.radios("doh 2")
        self.joe.says("doh 3")
        self.joe.radios("doh 4")
        self.joe.says("doh 5")
        self.assertEqual(1, self.joe.warn.call_count)

########NEW FILE########
__FILENAME__ = test_status
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from mock import patch
from tests import B3TestCase

from b3.plugins.status import StatusPlugin
from b3.config import XmlConfigParser


class Test_config(B3TestCase):

    @patch("b3.cron.PluginCronTab")
    def test_no_svar_table(self, pluginCronTab_mock):
        conf = XmlConfigParser()
        conf.setXml(r"""<configuration plugin="status">
            <settings name="settings">
                <set name="interval">60</set>
                <set name="output_file">~/status.xml</set>
            </settings>
        </configuration>""")
        self.p = StatusPlugin(self.console, conf)
        self.p.onLoadConfig()
        self.assertEqual("current_svars", self.p._svarTable)


    @patch("b3.cron.PluginCronTab")
    def test_svar_table(self, pluginCronTab_mock):
        conf = XmlConfigParser()
        conf.setXml(r"""<configuration plugin="status">
            <settings name="settings">
                <set name="interval">60</set>
                <set name="output_file">~/status.xml</set>
                <set name="svar_table">alternate_svar_table</set>
            </settings>
        </configuration>""")
        self.p = StatusPlugin(self.console, conf)
        self.p.onLoadConfig()
        self.assertEqual("alternate_svar_table", self.p._svarTable)


    @patch("b3.cron.PluginCronTab")
    def test_no_client_table(self, pluginCronTab_mock):
        conf = XmlConfigParser()
        conf.setXml(r"""<configuration plugin="status">
            <settings name="settings">
                <set name="interval">60</set>
                <set name="output_file">~/status.xml</set>
            </settings>
        </configuration>""")
        self.p = StatusPlugin(self.console, conf)
        self.p.onLoadConfig()
        self.assertEqual("current_clients", self.p._clientTable)


    @patch("b3.cron.PluginCronTab")
    def test_client_table(self, pluginCronTab_mock):
        conf = XmlConfigParser()
        conf.setXml(r"""<configuration plugin="status">
            <settings name="settings">
                <set name="interval">60</set>
                <set name="output_file">~/status.xml</set>
                <set name="client_table">alternate_client_table</set>
            </settings>
        </configuration>""")
        self.p = StatusPlugin(self.console, conf)
        self.p.onLoadConfig()
        self.assertEqual("alternate_client_table", self.p._clientTable)
########NEW FILE########
__FILENAME__ = test_tk
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import os
from mock import Mock, patch, sentinel
import unittest2 as unittest

from b3.plugins.tk import TkPlugin, TkInfo
from b3.config import XmlConfigParser

from tests import B3TestCase


default_plugin_file = os.path.normpath(os.path.join(os.path.dirname(__file__), "../../b3/conf/plugin_tk.xml"))

@patch("threading.Timer")
class Test_Tk_plugin(B3TestCase):

    def setUp(self):
        super(Test_Tk_plugin, self).setUp()
        self.console.gameName = 'f00'
        self.conf = XmlConfigParser()
        self.p = TkPlugin(self.console, self.conf)


    def test_onLoadConfig_minimal(self, timer_patcher):
        self.conf.setXml(r"""
        <configuration plugin="tk">
            <settings name="settings">
                <set name="max_points">400</set>
                <set name="levels">0</set>
                <set name="round_grace">7</set>
                <set name="issue_warning">sfire</set>
            </settings>
            <settings name="level_0">
                <set name="kill_multiplier">2</set>
                <set name="damage_multiplier">1</set>
                <set name="ban_length">2</set>
            </settings>
        </configuration>
        """)
        self.p = TkPlugin(self.console, self.conf)
        self.p.onLoadConfig()
        self.assertEqual(400, self.p._maxPoints)
        self.assertEqual(0, self.p._maxLevel)
        self.assertEqual(7, self.p._round_grace)
        self.assertEqual('sfire', self.p._issue_warning)
        self.assertTrue(self.p._private_messages)


    def test_onLoadConfig(self, timer_patcher):
        self.conf.setXml(r"""
        <configuration plugin="tk">
            <settings name="settings">
                <set name="max_points">350</set>
                <set name="levels">0,1,2</set>
                <set name="round_grace">3</set>
                <set name="issue_warning">foo</set>
                <set name="private_messages">off</set>
            </settings>
            <settings name="level_0">
                <set name="kill_multiplier">2</set>
                <set name="damage_multiplier">1</set>
                <set name="ban_length">2</set>
            </settings>
            <settings name="level_1">
                <set name="kill_multiplier">2</set>
                <set name="damage_multiplier">1</set>
                <set name="ban_length">2</set>
            </settings>
            <settings name="level_2">
                <set name="kill_multiplier">1</set>
                <set name="damage_multiplier">0.5</set>
                <set name="ban_length">1</set>
            </settings>
        </configuration>
        """)
        self.p = TkPlugin(self.console, self.conf)
        self.p.onLoadConfig()
        self.assertEqual(350, self.p._maxPoints)
        self.assertEqual(2, self.p._maxLevel)
        self.assertEqual(3, self.p._round_grace)
        self.assertEqual('foo', self.p._issue_warning)
        self.assertFalse(self.p._private_messages)





@unittest.skipUnless(os.path.exists(default_plugin_file), reason="cannot get default plugin config file at %s" % default_plugin_file)
class Test_Tk_default_config(B3TestCase):

    def setUp(self):
        super(Test_Tk_default_config, self).setUp()
        self.console.gameName = 'f00'
        self.conf = XmlConfigParser()
        self.conf.load(default_plugin_file)
        self.p = TkPlugin(self.console, self.conf)
        self.p.onLoadConfig()


    def test(self):
        self.assertEqual("sfire", self.p._issue_warning)
        self.assertEqual(7, self.p._round_grace)
        self.assertEqual(40, self.p._maxLevel)
        self.assertEqual(400, self.p._maxPoints)
        self.assertEqual({
                0: (2.0, 1.0, 2),
                1: (2.0, 1.0, 2),
                2: (1.0, 0.5, 1),
                20: (1.0, 0.5, 0),
                40: (0.75, 0.5, 0)
        }, self.p._levels)
        self.assertTrue(self.p._private_messages)




class Test_TkInfo(unittest.TestCase):

    def setUp(self):
        self.my_cid = 1
        self.mock_plugin = Mock(name="plugin", spec=TkPlugin)
        self.info = TkInfo(self.mock_plugin, self.my_cid)

    def test_construct(self):
        self.assertIsNone(self.info.lastAttacker)
        self.assertEqual({}, self.info.attackers)
        self.assertEqual({}, self.info.attacked)
        self.assertEqual(0, self.info.points)

    def test_damage(self):
        self.assertNotIn(2, self.info._attacked)
        self.info.damage(cid=2, points=5)
        self.assertTrue(self.info._attacked[2])

    def test_damaged(self):
        cidA = 3
        self.assertNotIn(cidA, self.info._attackers)
        self.info.damaged(cidA, points=15)
        self.assertEqual(15, self.info._attackers[cidA])

        self.info.damaged(cidA, points=5)
        self.assertEqual(20, self.info._attackers[cidA])

        cidB = 2
        self.info.damaged(cidB, points=7)
        self.assertEqual(20, self.info._attackers[cidA])
        self.assertEqual(7, self.info._attackers[cidB])

    def test_grudge(self):
        cid = 4
        self.assertNotIn(cid, self.info._grudged)
        self.assertFalse(self.info.isGrudged(cid))
        self.info.grudge(cid=cid)
        self.assertIn(cid, self.info._grudged)
        self.assertTrue(self.info.isGrudged(cid))

    def test_getAttackerPoints(self):
        cidA = 2
        s = sentinel
        self.info._attackers[cidA] = s
        self.assertEqual(s, self.info.getAttackerPoints(cidA))

        cidB = 3
        self.assertEqual(0, self.info.getAttackerPoints(cidB))

    def test_points(self):
        self.assertEqual(0, self.info.points)

        cid2 = 2
        cid3 = 3
        infos = {
            cid2: TkInfo(self.mock_plugin, cid2),
            cid3: TkInfo(self.mock_plugin, cid3)
        }
        self.mock_plugin.console.clients.getByCID = Mock(side_effect=lambda cid:cid)
        self.mock_plugin.getClientTkInfo = Mock(side_effect=lambda cid:infos[cid])

        points_2 = 45
        self.info.damage(cid2, points_2)
        infos[cid2].damaged(self.my_cid, points_2)
        self.assertEqual(points_2, self.info.points)

        points_3 = 21
        self.info.damage(cid3, points_3)
        infos[cid3].damaged(self.my_cid, points_3)
        self.assertEqual(points_2 + points_3, self.info.points)

    def test_lastAttacker(self):
        self.assertIsNone(self.info.lastAttacker)
        cid2 = 2
        self.info.damaged(cid2, 32)
        self.assertEqual(cid2, self.info.lastAttacker)

    def test_forgive(self):
        cid2 = 2
        cid3 = 3
        self.info.damaged(cid2, 75)
        self.info.damaged(cid3, 47)
        self.assertEqual(75, self.info.getAttackerPoints(cid2))
        self.assertEqual(47, self.info.getAttackerPoints(cid3))
        self.info.forgive(cid2)
        self.assertEqual(0, self.info.getAttackerPoints(cid2))
        self.assertEqual(47, self.info.getAttackerPoints(cid3))

    def test_forgive_last_attacker(self):
        cid2 = 2
        cid3 = 3
        self.info.damaged(cid2, 75)
        self.info.damaged(cid3, 47)
        self.assertEqual(75, self.info.getAttackerPoints(cid2))
        self.assertEqual(47, self.info.getAttackerPoints(cid3))
        self.assertEqual(cid3, self.info.lastAttacker)
        self.info.forgive(cid3)
        self.assertEqual(75, self.info.getAttackerPoints(cid2))
        self.assertEqual(0, self.info.getAttackerPoints(cid3))
        self.assertNotEqual(cid3, self.info.lastAttacker)

    def test_forgiven(self):
        self.mock_plugin.console = Mock()
        cid2 = 2
        self.info._attacked[cid2] = True
        self.info._warnings[cid2] = mock_warn = Mock()

        self.info.forgiven(cid2)

        self.assertNotIn(cid2, self.info._attacked)
        self.assertEqual(1, mock_warn.inactive)
        mock_warn.save.assert_called_once_with(self.mock_plugin.console)





if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_tk_functional
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import os

from mock import Mock, patch
import unittest2 as unittest
from mockito import when

import b3
from b3.plugins.admin import AdminPlugin
from b3.plugins.tk import TkPlugin
from b3.config import XmlConfigParser
from b3.fake import FakeClient

from tests import B3TestCase

from b3 import __file__ as b3_module__file__


ADMIN_CONFIG_FILE = os.path.normpath(os.path.join(os.path.dirname(b3_module__file__), "conf/plugin_admin.xml"))

@unittest.skipUnless(os.path.exists(ADMIN_CONFIG_FILE), reason="cannot get default plugin config file at %s" % ADMIN_CONFIG_FILE)
@patch("threading.Timer")
class Tk_functional_test(B3TestCase):


    def setUp(self):
        B3TestCase.setUp(self)

        self.console.gameName = 'f00'

        self.adminPlugin = AdminPlugin(self.console, ADMIN_CONFIG_FILE)
        when(self.console).getPlugin("admin").thenReturn(self.adminPlugin)
        self.adminPlugin.onLoadConfig()
        self.adminPlugin.onStartup()

        self.conf = XmlConfigParser()
        self.conf.setXml(r"""
        <configuration plugin="tk">
            <settings name="settings">
                <set name="max_points">400</set>
                <set name="levels">0,1,2,20,40</set>
                <set name="round_grace">7</set>
                <set name="issue_warning">sfire</set>
                <set name="grudge_enable">True</set>
                <set name="private_messages">True</set>
            </settings>
            <settings name="messages">
                <set name="ban">^7team damage over limit</set>
                <set name="forgive">^7$vname^7 has forgiven $aname [^3$points^7]</set>
                <set name="grudged">^7$vname^7 has a ^1grudge ^7against $aname [^3$points^7]</set>
                <set name="forgive_many">^7$vname^7 has forgiven $attackers</set>
                <set name="forgive_warning">^1ALERT^7: $name^7 auto-kick if not forgiven. Type ^3!forgive $cid ^7to forgive. [^3damage: $points^7]</set>
                <set name="no_forgive">^7no one to forgive</set>
                <set name="no_punish">^7no one to punish</set>
                <set name="players">^7Forgive who? %s</set>
                <set name="forgive_info">^7$name^7 has ^3$points^7 TK points</set>
                <set name="grudge_info">^7$name^7 is ^1grudged ^3$points^7 TK points</set>
                <set name="forgive_clear">^7$name^7 cleared of ^3$points^7 TK points</set>
            </settings>
            <settings name="level_0">
                <set name="kill_multiplier">2</set>
                <set name="damage_multiplier">1</set>
                <set name="ban_length">2</set>
            </settings>
            <settings name="level_1">
                <set name="kill_multiplier">2</set>
                <set name="damage_multiplier">1</set>
                <set name="ban_length">2</set>
            </settings>
            <settings name="level_2">
                <set name="kill_multiplier">1</set>
                <set name="damage_multiplier">0.5</set>
                <set name="ban_length">1</set>
            </settings>
            <settings name="level_20">
                <set name="kill_multiplier">1</set>
                <set name="damage_multiplier">0.5</set>
                <set name="ban_length">0</set>
            </settings>
            <settings name="level_40">
                <set name="kill_multiplier">0.75</set>
                <set name="damage_multiplier">0.5</set>
                <set name="ban_length">0</set>
            </settings>
        </configuration>
        """)
        self.p = TkPlugin(self.console, self.conf)
        self.p.onLoadConfig()
        self.p.onStartup()

        self.joe = FakeClient(self.console, name="Joe", guid="joeguid", groupBits=1, team=b3.TEAM_RED)
        self.mike = FakeClient(self.console, name="Mike", guid="mikeguid", groupBits=1, team=b3.TEAM_RED)
        self.bill = FakeClient(self.console, name="Bill", guid="billguid", groupBits=1, team=b3.TEAM_RED)
        self.superadmin = FakeClient(self.console, name="superadmin",guid="superadminguid", groupBits=128, team=b3.TEAM_RED)


    def test_dammage_different_teams(self, timer_patch):
        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)
        self.mike.team = b3.TEAM_BLUE
        self.joe.damages(self.mike)
        self.assertEqual(0, self.joe.warn.call_count)


    def test_kill_different_teams(self, timer_patch):
        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)
        self.mike.team = b3.TEAM_BLUE
        self.joe.kills(self.mike)
        self.assertEqual(0, self.joe.warn.call_count)


    def test_kill_within_10s(self, timer_patch):
        self.p._round_grace = 10

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)

        self.joe.kills(self.mike)
        self.assertEqual(1, self.joe.warn.call_count)

    def test_dammage(self, timer_patch):
        self.p._round_grace = 0

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)

        self.joe.damages(self.mike)
        self.joe.damages(self.mike)
        self.joe.damages(self.mike)
        self.joe.damages(self.mike)
        self.joe.damages(self.mike)
        self.assertEqual(0, self.joe.warn.call_count)


    def test_kill(self, timer_patch):
        self.p._round_grace = 0

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)

        self.joe.kills(self.mike)
        self.assertEqual(1, self.joe.warn.call_count)
        self.assertIsNotNone(self.mike.getMessageHistoryLike("^7type ^3!fp ^7 to forgive"))


    def test_multikill(self, timer_patch):
        self.p._round_grace = 0

        with patch.object(self.console, "say") as patched_say:
            self.joe.warn = Mock()
            self.joe.tempban = Mock()
            self.joe.connects(0)
            self.mike.connects(1)

            self.mike.clearMessageHistory()
            self.joe.kills(self.mike)
            self.assertEqual(1, self.joe.warn.call_count)
            self.assertEquals(1, len(self.mike.getAllMessageHistoryLike("^7type ^3!fp ^7 to forgive")))

            self.joe.kills(self.mike)
            self.assertEqual(1, len([call_args[0][0] for call_args in patched_say.call_args_list if "auto-kick if not forgiven" in call_args[0][0]]))

            self.joe.kills(self.mike)
            self.assertEqual(1, self.joe.tempban.call_count)


    def test_forgiveinfo(self, timer_patch):
        self.superadmin.connects(99)

        self.p._round_grace = 0

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)
        self.bill.connects(2)

        self.joe.kills(self.mike)

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(['Joe has 200 TK points, Attacked: Mike (200)'], self.superadmin.message_history)

        self.joe.damages(self.bill, points=6)

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(['Joe has 206 TK points, Attacked: Mike (200), Bill (6)'], self.superadmin.message_history)

        self.mike.damages(self.joe, points=27)

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(['Joe has 206 TK points, Attacked: Mike (200), Bill (6), Attacked By: Mike [27]'], self.superadmin.message_history)


    def test_forgive(self, timer_patch):
        self.superadmin.connects(99)
        self.p._round_grace = 0

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)

        self.joe.kills(self.mike)

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(['Joe has 200 TK points, Attacked: Mike (200)'], self.superadmin.message_history)

        self.mike.says("!forgive")

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(["Joe has 0 TK points"], self.superadmin.message_history)


    def test_forgiveclear(self, timer_patch):
        self.superadmin.connects(99)

        self.p._round_grace = 0

        self.joe.warn = Mock()
        self.joe.connects(0)
        self.mike.connects(1)

        self.joe.kills(self.mike)

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(['Joe has 200 TK points, Attacked: Mike (200)'], self.superadmin.message_history)

        self.superadmin.says("!forgiveclear joe")

        self.superadmin.clearMessageHistory()
        self.superadmin.says("!forgiveinfo joe")
        self.assertEqual(["Joe has 0 TK points"], self.superadmin.message_history)


    def test_forgivelist(self, timer_patcher):
        self.p._round_grace = 0

        self.joe.connects(0)
        self.mike.connects(1)
        self.bill.connects(2)

        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(["no one to forgive"], self.joe.message_history)

        self.mike.damages(self.joe, points=14)
        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(['Forgive who? [1] Mike [14]'], self.joe.message_history)


        self.bill.damages(self.joe, points=84)
        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(['Forgive who? [1] Mike [14], [2] Bill [84]'], self.joe.message_history)


    def test_forgiveall(self, timer_patcher):
        self.p._round_grace = 0

        self.joe.connects(0)
        self.mike.connects(1)
        self.bill.connects(2)

        self.mike.damages(self.joe, points=14)
        self.bill.damages(self.joe, points=84)

        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(['Forgive who? [1] Mike [14], [2] Bill [84]'], self.joe.message_history)

        self.joe.says("!forgiveall")
        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertNotIn("Mike", self.joe.message_history[0])
        self.assertNotIn("Bill", self.joe.message_history[0])


    def test_forgiveprev(self, timer_patcher):
        self.p._round_grace = 0

        self.joe.connects(0)
        self.mike.connects(1)
        self.bill.connects(2)

        self.mike.damages(self.joe, points=14)
        self.bill.damages(self.joe, points=84)

        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(['Forgive who? [1] Mike [14], [2] Bill [84]'], self.joe.message_history)

        self.joe.says("!forgiveprev")
        self.joe.clearMessageHistory()
        self.joe.says("!forgivelist")
        self.assertEqual(['Forgive who? [1] Mike [14]'], self.joe.message_history)


########NEW FILE########
__FILENAME__ = run
"""
Run the all the tests using nosetests.
Eventual command line arguments will be passed over to nosetests.
"""

if __name__ == '__main__':
    import nose
    nose.main()

########NEW FILE########
__FILENAME__ = test_download
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
"""
This test is about testing the setup feature which downloads a plugin zip file
and extract it in the correct directory of the B3 installation in the case
the plugin is not composed of a single python file module but instead of a
python module defined as a folder. (example the metabans plugin)
"""
import os
import shutil
from b3.setup import Setup
import unittest2 as unittest
from mock import Mock, patch # http://www.voidspace.org.uk/python/mock/

import urllib2

import tempfile
tmp_dir = os.path.join(tempfile.gettempdir(), "download_test")
mocked_getAbsolutePath = Mock(return_value=tmp_dir)

# this is the base64 representation of a zip file containing the same structure as the metbans plugin
metaban_zip_base64_content = """UEsDBBQAAAAAADkubD8AAAAAAAAAAAAAAAAJAAAAbWV0YWJhbnMvUEsDBBQAAAAAAPctbD8AAAAA
AAAAAAAAAAAtAAAAbWV0YWJhbnMvY291cmdldHRlLWIzLXBsdWdpbi1tZXRhYmFucy14eHh4eHgv
UEsDBBQAAAAAAPctbD8AAAAAAAAAAAAAAAA4AAAAbWV0YWJhbnMvY291cmdldHRlLWIzLXBsdWdp
bi1tZXRhYmFucy14eHh4eHgvZXh0cGx1Z2lucy9QSwMEFAAAAAAA9y1sPwAAAAAAAAAAAAAAAD0A
AABtZXRhYmFucy9jb3VyZ2V0dGUtYjMtcGx1Z2luLW1ldGFiYW5zLXh4eHh4eC9leHRwbHVnaW5z
L2NvbmYvUEsDBAoAAAAAACQubD8AAAAAAAAAAAAAAABQAAAAbWV0YWJhbnMvY291cmdldHRlLWIz
LXBsdWdpbi1tZXRhYmFucy14eHh4eHgvZXh0cGx1Z2lucy9jb25mL3BsdWdpbl9tZXRhYmFucy54
bWxQSwMEFAAAAAAAMy5sPwAAAAAAAAAAAAAAAEEAAABtZXRhYmFucy9jb3VyZ2V0dGUtYjMtcGx1
Z2luLW1ldGFiYW5zLXh4eHh4eC9leHRwbHVnaW5zL21ldGFiYW5zL1BLAwQKAAAAAAATLmw/AAAA
AAAAAAAAAAAATAAAAG1ldGFiYW5zL2NvdXJnZXR0ZS1iMy1wbHVnaW4tbWV0YWJhbnMteHh4eHh4
L2V4dHBsdWdpbnMvbWV0YWJhbnMvc29tZWZpbGUucHlQSwMECgAAAAAAEy5sPwAAAAAAAAAAAAAA
AEwAAABtZXRhYmFucy9jb3VyZ2V0dGUtYjMtcGx1Z2luLW1ldGFiYW5zLXh4eHh4eC9leHRwbHVn
aW5zL21ldGFiYW5zL19faW5pdF9fLnB5UEsDBAoAAAAAAAIubD+wAF6zEAAAABAAAAA3AAAAbWV0
YWJhbnMvY291cmdldHRlLWIzLXBsdWdpbi1tZXRhYmFucy14eHh4eHgvcmVhZG1lLnR4dE1ldGFi
YW5zIHBsdWdpbiBQSwECPwAUAAAAAAA5Lmw/AAAAAAAAAAAAAAAACQAkAAAAAAAAABAAAAAAAAAA
bWV0YWJhbnMvCgAgAAAAAAABABgAcdOSgfagzAFx05KB9qDMAcCoaDj2oMwBUEsBAj8AFAAAAAAA
9y1sPwAAAAAAAAAAAAAAAC0AJAAAAAAAAAAQAAAAJwAAAG1ldGFiYW5zL2NvdXJnZXR0ZS1iMy1w
bHVnaW4tbWV0YWJhbnMteHh4eHh4LwoAIAAAAAAAAQAYAPdOdzj2oMwB9053OPagzAElTm449qDM
AVBLAQI/ABQAAAAAAPctbD8AAAAAAAAAAAAAAAA4ACQAAAAAAAAAEAAAAHIAAABtZXRhYmFucy9j
b3VyZ2V0dGUtYjMtcGx1Z2luLW1ldGFiYW5zLXh4eHh4eC9leHRwbHVnaW5zLwoAIAAAAAAAAQAY
ACPJfjj2oMwBI8l+OPagzAH3Tnc49qDMAVBLAQI/ABQAAAAAAPctbD8AAAAAAAAAAAAAAAA9ACQA
AAAAAAAAEAAAAMgAAABtZXRhYmFucy9jb3VyZ2V0dGUtYjMtcGx1Z2luLW1ldGFiYW5zLXh4eHh4
eC9leHRwbHVnaW5zL2NvbmYvCgAgAAAAAAABABgASRJ4OPagzAFJEng49qDMARiddzj2oMwBUEsB
Aj8ACgAAAAAAJC5sPwAAAAAAAAAAAAAAAFAAJAAAAAAAAAAgAAAAIwEAAG1ldGFiYW5zL2NvdXJn
ZXR0ZS1iMy1wbHVnaW4tbWV0YWJhbnMteHh4eHh4L2V4dHBsdWdpbnMvY29uZi9wbHVnaW5fbWV0
YWJhbnMueG1sCgAgAAAAAAABABgAZZSEaPagzAEAyUgE85bMAQDJSATzlswBUEsBAj8AFAAAAAAA
My5sPwAAAAAAAAAAAAAAAEEAJAAAAAAAAAAQAAAAkQEAAG1ldGFiYW5zL2NvdXJnZXR0ZS1iMy1w
bHVnaW4tbWV0YWJhbnMteHh4eHh4L2V4dHBsdWdpbnMvbWV0YWJhbnMvCgAgAAAAAAABABgAq69D
evagzAGrr0N69qDMASPJfjj2oMwBUEsBAj8ACgAAAAAAEy5sPwAAAAAAAAAAAAAAAEwAJAAAAAAA
AAAgAAAA8AEAAG1ldGFiYW5zL2NvdXJnZXR0ZS1iMy1wbHVnaW4tbWV0YWJhbnMteHh4eHh4L2V4
dHBsdWdpbnMvbWV0YWJhbnMvc29tZWZpbGUucHkKACAAAAAAAAEAGADV/5dW9qDMAeKFeHj2oMwB
431gXPagzAFQSwECPwAKAAAAAAATLmw/AAAAAAAAAAAAAAAATAAkAAAAAAAAACAAAABaAgAAbWV0
YWJhbnMvY291cmdldHRlLWIzLXBsdWdpbi1tZXRhYmFucy14eHh4eHgvZXh0cGx1Z2lucy9tZXRh
YmFucy9fX2luaXRfXy5weQoAIAAAAAAAAQAYANX/l1b2oMwBAMlIBPOWzAEAyUgE85bMAVBLAQI/
AAoAAAAAAAIubD+wAF6zEAAAABAAAAA3ACQAAAAAAAAAIAAAAMQCAABtZXRhYmFucy9jb3VyZ2V0
dGUtYjMtcGx1Z2luLW1ldGFiYW5zLXh4eHh4eC9yZWFkbWUudHh0CgAgAAAAAAABABgAvGhTQvag
zAEAyUgE85bMAQDJSATzlswBUEsFBgAAAAAJAAkA7QQAACkDAAAAAA=="""

fake_download_url = "qsdfqsdfqdsfsf"

# this will trick urllib2 into returning our base64 zip file instead of downloading something of the network
urlopen_response = Mock()
urlopen_response.url = fake_download_url
urlopen_response.info = Mock(return_value={})
urlopen_response.read = Mock(return_value= metaban_zip_base64_content.decode('base64'))


class Test_download(unittest.TestCase):

    def setUp(self):
        # create a tmp dir that the code under test will use to work
        if os.path.isdir(tmp_dir):
            shutil.rmtree(tmp_dir, ignore_errors=True)
        if not os.path.isdir(tmp_dir):
            os.mkdir(tmp_dir)
        # disable whatever is done in the Setup constructor
        Setup.__init__ = object.__init__

    def tearDown(self):
        # cleaning
        shutil.rmtree(tmp_dir, ignore_errors=True)
        
    # those 2 decorators will replace some methods with mocks that we have control over
    # that way we know exactly what is to be expected
    @patch.object(urllib2, 'urlopen', Mock(return_value=urlopen_response))
    @patch.object(Setup, 'getAbsolutePath', new=mocked_getAbsolutePath)
    def test_metabans_plugin(self):
        global fake_download_url
        os.mkdir(os.path.join(tmp_dir, 'conf'))

        # create class instance to test
        setup = Setup()
        setup._set_external_dir = tmp_dir
        # call the method under test
        setup.download("metabans", fake_download_url, "metabans.zip")

        # verify that the work was done as intended
        plugin_module_dest_dir = os.path.join(tmp_dir, 'metabans')
        self.assertTrue(os.path.isdir(plugin_module_dest_dir), plugin_module_dest_dir)
        def assertIsFile(file):
            self.assertTrue(os.path.isfile(file), file + ' is not a file')
        assertIsFile(plugin_module_dest_dir + '/__init__.py')
        assertIsFile(plugin_module_dest_dir + '/somefile.py')
        assertIsFile(tmp_dir + '/conf/plugin_metabans.xml')

########NEW FILE########
__FILENAME__ = common
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.clients import Client, Alias, IpAlias, Penalty, Group
from mock import Mock

class StorageAPITest(object):
    storage = None
        
    def test_setClient(self):
        c1 = Client(ip="1.2.3.4", connections=2, guid="abcdefghijkl", pbid="123546abcdef", name="some dude", greeting="hi!", mask_level=20, group_bits=8, login="test login", password="test password")
        c1_id = self.storage.setClient(c1)
        self.assertEqual(1, c1_id)
        c2 = self.storage.getClient(Client(id=c1_id))
        self.assertIsInstance(c2, Client)
        self.assertEqual("1.2.3.4", c2.ip)
        self.assertEqual(2, c2.connections)
        self.assertEqual("abcdefghijkl", c2.guid)
        self.assertEqual("123546abcdef", c2.pbid)
        self.assertEqual("some dude", c2.name)
        self.assertEqual("hi!", c2.greeting)
        self.assertEqual("test login", c2.login)
        self.assertEqual("test password", c2.password)
        c3 = Client(id=c1_id, ip="5.6.7.8", connections=1, guid="ddddddddd", pbid="zzzzzzzzzzz", name="milka", greeting="hello")
        self.storage.setClient(c3)
        c4 = self.storage.getClient(Client(id=c1_id))
        self.assertIsInstance(c4, Client)
        self.assertEqual("5.6.7.8", c4.ip)
        self.assertEqual(1, c4.connections)
        self.assertEqual("ddddddddd", c4.guid)
        self.assertEqual("zzzzzzzzzzz", c4.pbid)
        self.assertEqual("milka", c4.name)
        self.assertEqual("hello", c4.greeting)

    def test_setClient_no_db(self):
        self.storage.query = Mock(return_value=None)
        c1 = Mock()
        c1.id = None
        self.assertIsNone(self.storage.setClient(c1))

    def test_getClient_id(self):
        c1 = Client(ip="1.2.3.4", connections=3, guid="mlkjmlkjqsdf", pbid="123546abcdef", name="some dude", greeting="hi!")
        c1_id = self.storage.setClient(c1)
        self.assertEqual(1, c1_id)
        c2 = self.storage.getClient(Client(id=c1_id))
        self.assertIsInstance(c2, Client)

    def test_getClient_guid(self):
        c1 = Client(ip="1.2.3.4", connections=3, guid="mlkjmlkjqsdf", pbid="123546abcdef", name="some dude", greeting="hi!")
        c1_id = self.storage.setClient(c1)
        self.assertEqual(1, c1_id)
        c2 = self.storage.getClient(Client(guid="mlkjmlkjqsdf"))
        self.assertIsInstance(c2, Client)
        self.assertRaises(KeyError, self.storage.getClient, Client(guid='god'))

    def test_getClientsMatching(self):
        self.storage.setClient(Client(ip="1.2.3.4", connections=2, guid="mlkjmlkjqsdf", pbid="123546abcdef", name="bill"))
        self.storage.setClient(Client(ip="4.2.3.5", connections=3, guid="azerazerazer", pbid="wxcvwxvcxwcv", name="john"))
        self.storage.setClient(Client(ip="4.2.3.5", connections=45, guid="rtyrtyrty", pbid="rtyrtyrrtyr", name="jack"))

        result = self.storage.getClientsMatching({'guid': "xxxxxxxxxx"})
        self.assertEqual(0, len(result))

        result = self.storage.getClientsMatching({'ip': "1.2.3.4"})
        self.assertEqual(1, len(result))
        self.assertEqual('bill', result[0].name)

        result = self.storage.getClientsMatching({'ip': "4.2.3.5"})
        self.assertEqual(2, len(result))

        result = self.storage.getClientsMatching({'pbid': "rtyrtyrrtyr"})
        self.assertEqual(1, len(result))
        self.assertEqual('jack', result[0].name)

        result = self.storage.getClientsMatching({'name': "jack"})
        self.assertEqual(1, len(result))
        self.assertEqual('jack', result[0].name)

        result = self.storage.getClientsMatching({'ip': "4.2.3.5", 'name': 'jack'})
        self.assertEqual(1, len(result))
        self.assertEqual('jack', result[0].name)

        result = self.storage.getClientsMatching({'ip': "4.2.3.5", 'connections >': 10})
        self.assertEqual(1, len(result))
        self.assertEqual('jack', result[0].name)

    def test_getClientsMatching_no_db(self):
        self.storage.query = Mock(return_value=None)
        self.assertEquals((), self.storage.getClientsMatching({'guid': "xxxxxxxxxx"}))

    def test_setClientAlias(self):
        alias_id1 = self.storage.setClientAlias(Alias(alias='bill', clientId=1))
        self.assertIsNotNone(alias_id1)
        alias_id2 = self.storage.setClientAlias(Alias(alias='joe', clientId=1))
        self.assertEqual(alias_id1 + 1, alias_id2)
        alias_id3 = self.storage.setClientAlias(Alias(id=alias_id1, alias='billy', clientId=1))
        self.assertIsNotNone(alias_id3)

    def test_setClientAlias_no_db(self):
        self.storage.query = Mock(return_value=None)
        alias = Mock()
        alias.id = None
        self.assertIsNone(self.storage.setClientAlias(alias))

    def test_getClientAlias(self):
        alias = Alias(alias='bill', timeAdd=12, timeEdit=654, numUsed=7, clientId=54)
        alias_id = self.storage.setClientAlias(alias)
        alias = self.storage.getClientAlias(Alias(id=alias_id))
        self.assertIsInstance(alias, Alias)
        self.assertEqual(alias.alias, 'bill')
        self.assertEqual(alias.timeAdd, 12)
        self.assertEqual(alias.timeEdit, 654)
        self.assertEqual(alias.numUsed, 7)
        self.assertEqual(alias.clientId, 54)
        alias2 = self.storage.getClientAlias(Alias(clientId=54, alias='bill'))
        self.assertEqual(alias.id, alias2.id)

    def test_getClientAlias_KeyError(self):
        alias = Mock()
        alias.id = 132
        self.assertRaises(KeyError, self.storage.getClientAlias, alias)

    def test_getClientAliases(self):
        client = Mock()
        client.id = 15
        self.storage.setClientAlias(Alias(alias='bill', clientId=client.id))
        self.storage.setClientAlias(Alias(alias='joe', clientId=client.id))
        self.storage.setClientAlias(Alias(alias='jack', clientId=0))
        aliases = self.storage.getClientAliases(client)
        self.assertIsInstance(aliases, list)
        self.assertEqual(len(aliases), 2)
        bucket = []
        for i in aliases:
            self.assertIsInstance(i, Alias)
            self.assertEqual(i.clientId, client.id)
            self.assertNotEqual(i.id, None)
            self.assertNotEqual(i.alias, None)
            self.assertNotEqual(i.timeAdd, None)
            self.assertNotEqual(i.timeEdit, None)
            self.assertNotEqual(i.numUsed, None)
            bucket.append(i.alias)
        self.assertIn('bill', bucket)
        self.assertIn('joe', bucket)
        self.assertNotIn('jack', bucket)

    def test_getClientAliases_no_db(self):
        self.storage.query = Mock(return_value=None)
        client = Mock()
        client.id = 15
        self.assertEquals((), self.storage.getClientAliases(client))

    def test_setClientIpAddresse(self):
        ipalias_id1 = self.storage.setClientIpAddresse(IpAlias(ip='1.2.3.4', clientId=1))
        self.assertIsNotNone(ipalias_id1)
        ipalias_id2 = self.storage.setClientIpAddresse(IpAlias(ip='127.0.0.1', clientId=1))
        self.assertEqual(ipalias_id1 + 1, ipalias_id2)
        ipalias_id3 = self.storage.setClientIpAddresse(IpAlias(id=ipalias_id1, ip='0.0.0.0', clientId=1))
        self.assertEqual(ipalias_id1, ipalias_id3)
    
    def test_setClientIpAddresse_no_db(self):
        self.storage.query = Mock(return_value=None)
        ipalias = Mock()
        ipalias.id = None
        self.assertIsNone(self.storage.setClientIpAddresse(ipalias))

    def test_getClientIpAddress(self):
        ipalias = IpAlias(ip='88.44.55.22', timeAdd=12, timeEdit=654, numUsed=7, clientId=54)
        ipalias_id = self.storage.setClientIpAddresse(ipalias)
        ipalias = self.storage.getClientIpAddress(IpAlias(id=ipalias_id))
        self.assertIsInstance(ipalias, IpAlias)
        self.assertEqual(ipalias.ip, '88.44.55.22')
        self.assertEqual(ipalias.timeAdd, 12)
        self.assertEqual(ipalias.timeEdit, 654)
        self.assertEqual(ipalias.numUsed, 7)
        self.assertEqual(ipalias.clientId, 54)
        ipalias2 = self.storage.getClientIpAddress(IpAlias(clientId=ipalias.clientId, ip=ipalias.ip))
        self.assertEqual(ipalias.id, ipalias2.id)

    def test_getClientIpAddress_no_db(self):
        self.storage.query = Mock(return_value=None)
        client = Mock()
        client.id = 15
        self.assertRaises(KeyError, self.storage.getClientIpAddress, client)

    def test_getClientIpAddresses(self):
        client = Mock()
        client.id = 15
        self.storage.setClientIpAddresse(IpAlias(ip='44.44.44.44', clientId=client.id))
        self.storage.setClientIpAddresse(IpAlias(ip='55.55.55.55', clientId=client.id))
        self.storage.setClientIpAddresse(IpAlias(ip='66.66.66.66', clientId=0))
        ipaliases = self.storage.getClientIpAddresses(client)
        self.assertIsInstance(ipaliases, list)
        self.assertEqual(len(ipaliases), 2)
        ips = []
        for i in ipaliases:
            self.assertIsInstance(i, IpAlias)
            self.assertEqual(i.clientId, client.id)
            self.assertNotEqual(i.id, None)
            self.assertNotEqual(i.ip, None)
            self.assertNotEqual(i.timeAdd, None)
            self.assertNotEqual(i.timeEdit, None)
            self.assertNotEqual(i.numUsed, None)
            ips.append(i.ip)
        self.assertIn('44.44.44.44', ips)
        self.assertIn('55.55.55.55', ips)
        self.assertNotIn('66.66.66.66', ips)
        
    def test_getClientIpAddresses_no_db(self):
        self.storage.query = Mock(return_value=None)
        client = Mock()
        client.id = 15
        self.assertEquals((), self.storage.getClientIpAddresses(client))

    def test_getLastPenalties(self):
        c1 = Mock()
        c1.id = 15
        c2 = Mock()
        c2.id = 18
        Penalty(clientId=c1.id, adminId=0, inactive=1, type='Ban', timeExpire=-1, data=u'pA').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Ban', timeExpire=self.console.time()+10, data=u'pB').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Warning', timeExpire=self.console.time()+10, data=u'pC').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Kick', timeExpire=self.console.time()-10, data=u'pD').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Ban', timeExpire=self.console.time()-10, data=u'pE').save(self.console)
        Penalty(clientId=c2.id, adminId=0, inactive=0, type='Warning', timeExpire=-1, data=u'pF').save(self.console)
        Penalty(clientId=c2.id, adminId=0, inactive=0, type='TempBan', timeExpire=-1, data=u'pG').save(self.console)
        Penalty(clientId=c2.id, adminId=0, inactive=0, type='Ban', timeExpire=-1, data=u'pH').save(self.console)

        def getLastPenalties(types, num):
            p_datas = []
            for p in self.storage.getLastPenalties(types=types, num=num):
                p_datas.append(p.data)
                self.assertTrue(p.inactive == 0)
                self.assertTrue(p.timeExpire == -1 or p.timeExpire > self.console.time())
            self.assertGreaterEqual(num, len(p_datas))
            return p_datas

        self.assertListEqual([u'pH', u'pG', u'pF', u'pC', u'pB'], getLastPenalties(types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), num=5))
        self.assertListEqual([u'pH', u'pG', u'pF', u'pC'], getLastPenalties(types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), num=4))
        self.assertListEqual([u'pH', u'pG', u'pB'], getLastPenalties(types=('Ban', 'TempBan'), num=5))

    def test_setClientPenalty(self):
        id1 = self.storage.setClientPenalty(Penalty(type='Ban', clientId=1, adminId=0))
        self.assertIsNotNone(id1)
        id2 = self.storage.setClientPenalty(Penalty(type='Kick', clientId=1, adminId=0))
        self.assertEqual(id1 + 1, id2)
        id3 = self.storage.setClientPenalty(Penalty(id=id1, type='Warning', clientId=1, adminId=0))
        self.assertEqual(id1, id3)

    def test_setClientPenalty_bad_keyword(self):
        id1 = self.storage.setClientPenalty(Penalty(keyword='!=+', clientId=1, adminId=0))
        self.assertIsNotNone(id1)
        p1 = self.storage.getClientPenalty(Penalty(id=id1, type='foo'))
        self.assertIsInstance(p1, Penalty)
        self.assertIs(type(p1), Penalty)
        self.assertEquals('', p1.keyword)

    def test_setClientPenalty_no_db(self):
        self.storage.query = Mock(return_value=None)
        p1 = Mock(spec=Penalty)
        p1.id = None
        p1.keyword = 'test'
        self.assertIsNone(self.storage.setClientPenalty(p1))

    def test_getClientPenalty(self):
        tmp = Penalty(type='Kick', 
                      clientId=54,
                      inactive=1,
                      adminId=4,
                      reason='respect the rules',
                      keyword='rules',
                      data='foo',
                      timeAdd=123,
                      timeEdit=1234,
                      timeExpire=654,
                      duration=87,
                      )
        tmp_id = self.storage.setClientPenalty(tmp)
        penalty = self.storage.getClientPenalty(Penalty(type="Kick", id=tmp_id))
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.type, 'Kick')
        self.assertEqual(penalty.clientId, 54)
        self.assertEqual(penalty.inactive, 1)
        self.assertEqual(penalty.adminId, 4)
        self.assertEqual(penalty.reason, 'respect the rules')
        self.assertEqual(penalty.keyword, 'rules')
        self.assertEqual(penalty.data, 'foo')
        self.assertEqual(penalty.timeAdd, 123)
        self.assertEqual(penalty.timeEdit, 1234)
        self.assertEqual(penalty.timeExpire, 654)
        self.assertEqual(penalty.duration, 87)
        self.assertRaises(KeyError, self.storage.getClientPenalty, Penalty(id=654654))

    def test_getClientPenalties(self):
        c1 = Mock()
        c1.id = 15
        c2 = Mock()
        c2.id = 18
        Penalty(clientId=c1.id, adminId=0, inactive=1, type='Ban', timeExpire=-1, data='pA').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Ban', timeExpire=self.console.time()+10, data='pB').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Warning', timeExpire=self.console.time()+10, data='pC').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Kick', timeExpire=self.console.time()-10, data='pD').save(self.console)
        Penalty(clientId=c1.id, adminId=0, inactive=0, type='Ban', timeExpire=self.console.time()-10, data='pE').save(self.console)
        Penalty(clientId=c2.id, adminId=0, inactive=0, type='Warning', timeExpire=-1, data='pF').save(self.console)
        Penalty(clientId=c2.id, adminId=0, inactive=0, type='TempBan', timeExpire=-1, data='pG').save(self.console)

        def assertPenalties(client, types, penalties_in=[], penalties_notin=[]):
            penalties = self.storage.getClientPenalties(client=client, type=types)
            self.assertIsInstance(penalties, list)
            bucket = []
            for i in penalties:
                self.assertIsInstance(i, Penalty)
                self.assertEqual(i.clientId, client.id)
                bucket.append(i.data)
            for i in penalties_in:
                self.assertIn(i, bucket)
            for i in penalties_notin:
                self.assertNotIn(i, bucket)

        assertPenalties(client=c1, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pB','pC'), penalties_notin=('pA','pD','pE','pF','pG'))
        assertPenalties(client=c2, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pF','pG'), penalties_notin=('pA','pB','pC','pD','pE'))
        
        self.storage.query = Mock(return_value=None)
        self.assertEquals((), self.storage.getClientPenalties(c1))


    def test_getClientLastPenalty(self):
        client = Mock()
        client.id = 15
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=2, timeExpire=-1, type='Ban', data='pA'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=4, timeExpire=-1, type='Kick',data='pB'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=1, timeExpire=-1, type='Notice', data='pC'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=3, timeExpire=-1, type='Ban', data='pD'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=6, timeExpire=-1, type='Kick', data='pE'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=5, timeExpire=-1, type='Ban', data='pF'))
        penalty = self.storage.getClientLastPenalty(client=client)
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pF')
        penalty = self.storage.getClientLastPenalty(client=client, type=('Ban', 'Kick'))
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pE')
        penalty = self.storage.getClientLastPenalty(client=client, type=('Ban', 'Kick','Notice'))
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pE')
        self.assertIsNone(self.storage.getClientLastPenalty(Penalty(clientId=3231)))

    def test_getClientFirstPenalty(self):
        client = Mock()
        client.id = 15
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=2, timeExpire=-1, type='Ban', data='pA'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=4, timeExpire=-1, type='Kick', data='pB'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=1, timeExpire=-1, type='Notice', data='pC'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=3, timeExpire=-1, type='Ban', data='pD'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=6, timeExpire=-1, type='Kick', data='pE'))
        self.storage.setClientPenalty(Penalty(clientId=client.id, adminId=0, timeAdd=5, timeExpire=-1, type='Ban', data='pF'))
        penalty = self.storage.getClientFirstPenalty(client=client)
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pA')
        penalty = self.storage.getClientFirstPenalty(client=client, type=('Ban', 'Kick'))
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pA')
        penalty = self.storage.getClientFirstPenalty(client=client, type=('Ban', 'Kick','Notice'))
        self.assertIsInstance(penalty, Penalty)
        self.assertEqual(penalty.data, 'pC')
        self.assertIsNone(self.storage.getClientFirstPenalty(Penalty(clientId=3231)))


    def test_disableClientPenalties(self):
        c1 = Mock()
        c1.id = 15
        c2 = Mock()
        c2.id = 18
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Ban', inactive=1, data='pA').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Ban', inactive=0, data='pB').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Warning', inactive=0, data='pC').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Kick', inactive=0, data='pD').save(self.console)
        Penalty(clientId=c2.id, adminId=0, timeExpire=-1, type='Notice', inactive=0, data='pE').save(self.console)
        Penalty(clientId=c2.id, adminId=0, timeExpire=-1, type='Warning', inactive=0, data='pF').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='TempBan', inactive=0, data='pG').save(self.console)

        def assertPenalties(client, types='Ban', penalties_in=[], penalties_notin=[]):
            penalties = self.storage.getClientPenalties(client=client, type=types)
            self.assertIsInstance(penalties, list)
            bucket = []
            for i in penalties:
                self.assertIsInstance(i, Penalty)
                self.assertEqual(i.clientId, client.id)
                bucket.append(i.data)
            for i in penalties_in:
                self.assertIn(i, bucket)
            for i in penalties_notin:
                self.assertNotIn(i, bucket)

        assertPenalties(client=c1, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pB','pC','pD','pG'), penalties_notin=('pA','pE','pF'))
        assertPenalties(client=c2, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pE','pF'), penalties_notin=('pA','pB','pC','pD','pG'))

        self.storage.disableClientPenalties(client=c1)
        assertPenalties(client=c1, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pC','pD','pG'), penalties_notin=('pA','pB','pE','pF'))
        assertPenalties(client=c2, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pE','pF'), penalties_notin=('pA','pB','pC','pD','pG'))

        self.storage.disableClientPenalties(client=c1, type=('Kick','Notice'))
        assertPenalties(client=c1, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pC','pG'), penalties_notin=('pA','pB','pD','pE','pF'))
        assertPenalties(client=c2, types=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice'), 
                        penalties_in=('pE','pF'), penalties_notin=('pA','pB','pC','pD','pG'))

    def test_numPenalties(self):
        c1 = Mock()
        c1.id = 15
        c2 = Mock()
        c2.id = 18
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Ban', inactive=1, data='pA').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Ban', inactive=0, data='pB').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Warning', inactive=0, data='pC').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='Kick', inactive=0, data='pD').save(self.console)
        Penalty(clientId=c2.id, adminId=0, timeExpire=-1, type='Notice', inactive=0, data='pE').save(self.console)
        Penalty(clientId=c2.id, adminId=0, timeExpire=-1, type='Warning', inactive=0, data='pF').save(self.console)
        Penalty(clientId=c1.id, adminId=0, timeExpire=-1, type='TempBan', inactive=0, data='pG').save(self.console)
        self.assertEqual(1, self.storage.numPenalties(client=c1))
        self.assertEqual(4, self.storage.numPenalties(client=c1, type=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice')))
        self.assertEqual(0, self.storage.numPenalties(client=c2))
        self.assertEqual(2, self.storage.numPenalties(client=c2, type=('Ban', 'TempBan', 'Kick', 'Warning', 'Notice')))
        
        self.storage.query = Mock(return_value=None)
        self.assertEqual(0, self.storage.numPenalties(client=c1))


    def test_getGroups(self):
        groups = self.storage.getGroups()
        self.assertEqual(8, len(groups))
        for g in groups:
            self.assertIsInstance(g, Group)
    
    def test_getGroups_unknown(self):
        self.storage.query = Mock(return_value=None)
        self.assertEqual([], self.storage.getGroups())


    def test_getGroup_by_keyword(self):
        g = self.storage.getGroup(Group(keyword='superadmin'))
        self.assertIsInstance(g, Group)
        self.assertEquals('superadmin', g.keyword)
        self.assertEquals(100, g.level)
        self.assertRaises(KeyError, self.storage.getGroup, Group(keyword='foo'))

    def test_getGroup_by_level(self):
        g = self.storage.getGroup(Group(level='20'))
        self.assertIsInstance(g, Group)
        self.assertEquals('mod', g.keyword)
        self.assertEquals(20, g.level)
        self.assertRaises(KeyError, self.storage.getGroup, Group(level='500'))

    def test_getGroup_none(self):
        try:
            self.storage.getGroup(None)
            self.fail("expecting KeyError")
        except KeyError:
            pass
        except Exception:
            self.fail("expecting KeyError")

    def test_getGroup_junk(self):
        try:
            self.storage.getGroup(5)
            self.fail("expecting KeyError")
        except KeyError:
            pass
        except Exception:
            self.fail("expecting KeyError")

    def test_getGroup_bad_group(self):
        try:
            self.storage.getGroup(Group())
            self.fail("expecting KeyError")
        except KeyError:
            pass
        except Exception:
            self.fail("expecting KeyError")


    def test_getCounts(self):
        c1 = Client(guid="aaaaaaaaa")
        self.assertEqual({'Kicks': 0, 'TempBans': 0, 'clients': 0, 'Bans': 0, 'Warnings': 0}, self.storage.getCounts())
        self.storage.setClient(c1)
        self.assertEqual({'Kicks': 0, 'TempBans': 0, 'clients': 1, 'Bans': 0, 'Warnings': 0}, self.storage.getCounts())
        self.storage.setClient(Client(guid="bbbbbbbbbb"))
        self.assertEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 0, 'Warnings': 0}, self.storage.getCounts())
        Penalty(clientId=c1.id, adminId=0, type='Ban').save(self.console)
        self.assertEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 1, 'Warnings': 0}, self.storage.getCounts())
        Penalty(clientId=c1.id, adminId=0, type='Ban').save(self.console)
        self.assertEqual({'Kicks': 0, 'TempBans': 0, 'clients': 2, 'Bans': 2, 'Warnings': 0}, self.storage.getCounts())
        Penalty(clientId=c1.id, adminId=0, type='TempBan').save(self.console)
        self.assertEqual({'Kicks': 0, 'TempBans': 1, 'clients': 2, 'Bans': 2, 'Warnings': 0}, self.storage.getCounts())
        Penalty(clientId=c1.id, adminId=0, type='Kick').save(self.console)
        self.assertEqual({'Kicks': 1, 'TempBans': 1, 'clients': 2, 'Bans': 2, 'Warnings': 0}, self.storage.getCounts())
        Penalty(clientId=c1.id, adminId=0, type='Warning').save(self.console)
        self.assertEqual({'Kicks': 1, 'TempBans': 1, 'clients': 2, 'Bans': 2, 'Warnings': 1}, self.storage.getCounts())

########NEW FILE########
__FILENAME__ = test_DatabaseStorage
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.clients import Client
from b3.storage.database import DatabaseStorage
from mock import Mock, patch, sentinel
import unittest2 as unittest

class Test_DatabaseStorage(unittest.TestCase):

    def test_construct(self):
        storage = DatabaseStorage('foo://bar', Mock())
        self.assertRaises(Exception, storage.getConnection)
        
        
    def test_getClient_connectionfailed(self):
        mock_storage = Mock(spec=DatabaseStorage)
        mock_storage.getClient = DatabaseStorage.getClient
        mock_storage.db = None
        mock_storage.query = Mock(return_value=None)
        mock_storage.console = Mock()
        mock_storage.console.config = Mock()
        mock_storage.console.config.get = Mock(return_value="123,myname,100")
        
        mock_storage.console.config.has_option = Mock(return_value=True)
        c1 = Client()
        c2 = mock_storage.getClient(mock_storage, c1)
        self.assertIs(c2, c1)
        self.assertEqual(123, c1.id)
        self.assertEqual("myname", c1.name)
        self.assertEqual(100, c1._tempLevel)
        
        mock_storage.console.config.has_option = Mock(return_value=False)
        self.assertRaises(KeyError, mock_storage.getClient, mock_storage, Mock())


    def test_getConnection_mysql(self):
        # mock the MySQLdb module so we can test in an environement which does not have this module installed
        mock_MySQLdb = Mock()
        mock_MySQLdb.connect = Mock(return_value=sentinel)
        with patch.dict('sys.modules', {'MySQLdb': mock_MySQLdb}):

            # verify that a correct dsn does work as expected
            storage = DatabaseStorage("mysql://someuser:somepasswd@somehost:someport/somedbname", Mock())
            assert mock_MySQLdb.connect.called, "expecting MySQLdb.connect to be called"
            self.assertEqual(sentinel, storage.db)

            # verify that an incorrect dsn does fail an stops the bot with a nice error message
            mock_MySQLdb.connect.reset_mock()
            console_mock = Mock()
            storage = DatabaseStorage("mysql://someuser:somepasswd@somehost:3446/", console_mock)
            assert console_mock.critical.called
            self.assertIn("missing MySQL database name", console_mock.critical.call_args[0][0])
            assert not mock_MySQLdb.connect.called, "expecting MySQLdb.connect not to be called"
            self.assertIsNone(storage.db)

            # verify that an incorrect dsn does fail an stops the bot with a nice error message
            mock_MySQLdb.connect.reset_mock()
            console_mock = Mock()
            storage = DatabaseStorage("mysql://someuser:somepasswd@/database", console_mock)
            assert console_mock.critical.called
            self.assertIn("invalid MySQL host", console_mock.critical.call_args[0][0])
            assert not mock_MySQLdb.connect.called, "expecting MySQLdb.connect not to be called"
            self.assertIsNone(storage.db)

########NEW FILE########
__FILENAME__ = test_mysql
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.storage.database import DatabaseStorage
from tests import B3TestCase
from tests.storage.common import StorageAPITest
import nose
import unittest2 as unittest

"""
    NOTE: to work properly you must be running a MySQL database on localhost
    which must have a user named 'b3test' with password 'test' which has 
    all privileges over a table (already created or not) named 'b3_test'
"""
MYSQL_DB = 'mysql://b3test:test@localhost/b3_test'
MYSQL_HOST = 'localhost'
MYSQL_USER = 'b3test'
MYSQL_PASSWORD = 'test'

#===============================================================================
# 
# Test if we can run the MySQL tests
#
#===============================================================================

is_mysql_ready = True
no_mysql_reason = ''

try:
    import MySQLdb
except ImportError:
    is_mysql_ready = False
    no_mysql_reason = "no MySQLdb module available"
else:
    try:
        MySQLdb.connect(host=MYSQL_HOST, user=MYSQL_USER, passwd=MYSQL_PASSWORD)
    except MySQLdb.Error, err:
        is_mysql_ready = False
        no_mysql_reason = "%s" % err[1]
    except Exception, err:
        is_mysql_ready = False
        no_mysql_reason = "%s" % err


#===============================================================================
# 
# Load the tests
# 
#===============================================================================
@unittest.skipIf(not is_mysql_ready, no_mysql_reason)
class Test_MySQL(B3TestCase, StorageAPITest):

    def setUp(self):
        """this method is called before each test"""
        B3TestCase.setUp(self)
        try:
            db = MySQLdb.connect(host=MYSQL_HOST, user=MYSQL_USER, passwd=MYSQL_PASSWORD)
        except MySQLdb.OperationalError, message:
            self.fail("Error %d:\n%s" % (message[0], message[1]))
        db.query("DROP DATABASE IF EXISTS b3_test")
        db.query("CREATE DATABASE b3_test CHARACTER SET utf8;")
        self.storage = self.console.storage = DatabaseStorage(MYSQL_DB, self.console)
        self.storage.executeSql("@b3/sql/b3.sql")

    def tearDown(self):
        """this method is called after each test"""
        B3TestCase.tearDown(self)
        self.storage.query("DROP DATABASE b3_test")
        self.storage.shutdown()


if __name__ == '__main__':
    nose.main()
    
    
########NEW FILE########
__FILENAME__ = test_postgresql
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.storage.database import DatabaseStorage
from tests import B3TestCase
from tests.storage.common import StorageAPITest
import nose
import unittest2 as unittest

"""
    NOTE: to work properly you must be running a PostgreSQL database on localhost
    which must have a user named 'b3test' with password 'test' which has 
    all privileges over a table (already created or not) named 'b3_test'
"""
POSTGRESQL_DB = 'postgresql://b3test:test@localhost/b3_test'
POSTGRESQL_HOST = 'localhost'
POSTGRESQL_USER = 'b3test'
POSTGRESQL_PASSWORD = 'test'

#===============================================================================
# 
# Test if we can run the MySQL tests
#
#===============================================================================

is_postgresql_ready = True
no_postgresql_reason = ''

try:
    import psycopg2
except ImportError:
    is_postgresql_ready = False
    no_postgresql_reason = "no psycopg2 module available"
else:
    try:
        psycopg2.connect(host=POSTGRESQL_HOST, user=POSTGRESQL_USER, password=POSTGRESQL_PASSWORD, database='postgres')
    except psycopg2.Error, err:
        is_postgresql_ready = False
        no_postgresql_reason = "%r" % err
    except Exception, err:
        is_postgresql_ready = False
        no_postgresql_reason = "%r" % err


#===============================================================================
# 
# Load the tests
# 
#===============================================================================
@unittest.skip('work in progress')
@unittest.skipIf(not is_postgresql_ready, no_postgresql_reason)
class Test_PostgreSQL(B3TestCase, StorageAPITest):

    def setUp(self):
        """this method is called before each test"""
        B3TestCase.setUp(self)
        try:
            conn = psycopg2.connect(host='localhost', user='b3test', password='test', database='postgres')
        except psycopg2.OperationalError, message:
            self.fail("Error %d:\n%s" % (message[0], message[1]))
        conn.set_isolation_level(0)
        cursor = conn.cursor()
        cursor.execute("DROP DATABASE IF EXISTS b3_test;")
        cursor.execute("CREATE DATABASE b3_test WITH OWNER = b3test ENCODING = 'UTF8';")
        self.storage = self.console.storage = DatabaseStorage(POSTGRESQL_DB, self.console)
        self.storage.executeSql("@b3/sql/postgresql/b3.sql")

    def tearDown(self):
        """this method is called after each test"""
        B3TestCase.tearDown(self)
        self.storage.query("DROP DATABASE b3_test")
        self.storage.shutdown()


if __name__ == '__main__':
    nose.main()
    
    
########NEW FILE########
__FILENAME__ = test_sqlite
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.storage.database import DatabaseStorage
from tests import B3TestCase
from tests.storage.common import StorageAPITest
import nose

SQLITE_DB = ":memory:"
#SQLITE_DB = "c:/Users/Thomas/b3.db"

class Test_sqlite(B3TestCase, StorageAPITest):
    """
    NOTE: to work properly you must be running a MySQL database on localhost
    which must have a user named 'b3test' with password 'test' which has 
    all privileges over a table (already created or not) named 'b3_test'
    """

    def setUp(self):
        """this method is called before each test"""
        B3TestCase.setUp(self)
        self.storage = self.console.storage = DatabaseStorage('sqlite://'+SQLITE_DB, self.console)
        self.storage.executeSql("@b3/sql/sqlite/b3.sql")

    def tearDown(self):
        """this method is called after each test"""
        B3TestCase.tearDown(self)
        self.storage.shutdown()


if __name__ == '__main__':
    nose.main()
    
    
########NEW FILE########
__FILENAME__ = test_Storage
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from b3.storage import Storage, getStorage
from b3.storage.database import DatabaseStorage
from mock import Mock, patch
from tests import B3TestCase
import unittest2 as unittest

class Test_Storage(B3TestCase):
    storage = None

    def setUp(self):
        B3TestCase.setUp(self)
        self.storage = Storage()

    def test_getCounts(self):
        self.assertRaises(NotImplementedError, self.storage.getCounts)

    def test_getClient(self):
        self.assertRaises(NotImplementedError, self.storage.getClient, Mock())

    def test_getClientsMatching(self):
        self.assertRaises(NotImplementedError, self.storage.getClientsMatching, Mock())

    def test_setClient(self):
        self.assertRaises(NotImplementedError, self.storage.setClient, Mock())

    def test_setClientAlias(self):
        self.assertRaises(NotImplementedError, self.storage.setClientAlias, Mock())

    def test_getClientAlias(self):
        self.assertRaises(NotImplementedError, self.storage.getClientAlias, Mock())

    def test_getClientAliases(self):
        self.assertRaises(NotImplementedError, self.storage.getClientAliases, Mock())

    def test_setClientIpAddresse(self):
        self.assertRaises(NotImplementedError, self.storage.setClientIpAddresse, Mock())

    def test_getClientIpAddress(self):
        self.assertRaises(NotImplementedError, self.storage.getClientIpAddress, Mock())

    def test_getClientIpAddresses(self):
        self.assertRaises(NotImplementedError, self.storage.getClientIpAddresses, Mock())

    def test_setClientPenalty(self):
        self.assertRaises(NotImplementedError, self.storage.setClientPenalty, Mock())

    def test_getClientPenalty(self):
        self.assertRaises(NotImplementedError, self.storage.getClientPenalty, Mock())

    def test_getClientPenalties(self):
        self.assertRaises(NotImplementedError, self.storage.getClientPenalties, Mock())

    def test_getClientLastPenalty(self):
        self.assertRaises(NotImplementedError, self.storage.getClientLastPenalty, Mock())

    def test_getClientFirstPenalty(self):
        self.assertRaises(NotImplementedError, self.storage.getClientFirstPenalty, Mock())

    def test_disableClientPenalties(self):
        self.assertRaises(NotImplementedError, self.storage.disableClientPenalties, Mock())

    def test_numPenalties(self):
        self.assertRaises(NotImplementedError, self.storage.numPenalties, Mock())

    def test_getGroups(self):
        self.assertRaises(NotImplementedError, self.storage.getGroups)

    def test_getGroup(self):
        self.assertRaises(NotImplementedError, self.storage.getGroup, Mock())


class Test_getStorage(unittest.TestCase):

    @patch("b3.storage.DatabaseStorage")
    def test_Database(self, mock_DatabaseStorage):
        getStorage('database')
        mock_DatabaseStorage.assert_called_once()

    @patch("b3.storage.Storage")
    def test_empty(self, mock_Storage):
        getStorage('')
        mock_Storage.assert_called_once()


########NEW FILE########
__FILENAME__ = test_b3
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
from tests import B3TestCase
import b3
    
class Test_getConfPath(B3TestCase):

    def test_getConfPath(self):
        self.console.config.fileName = "/some/where/conf/b3.xml"
        self.assertEqual('/some/where/conf', b3.getConfPath())

        self.console.config.fileName = "./b3.xml"
        self.assertEqual('.', b3.getConfPath())
########NEW FILE########
__FILENAME__ = test_config
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import ConfigParser
import logging
import unittest2 as unittest
import sys
from b3.config import XmlConfigParser, CfgConfigParser
from tests import B3TestCase

@unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")
class Test_XmlConfigParser_windows(B3TestCase):

    def setUp(self):
        B3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.setXml("""
            <configuration plugin="test">
                <settings name="settings">
                    <set name="output_file">@conf/status.xml</set>
                </settings>
            </configuration>
        """)

    def test_getpath(self):
        self.console.config.fileName = r"c:\some\where\conf\b3.xml"
        self.assertEqual(r"c:\some\where\conf\status.xml", self.conf.getpath('settings', 'output_file'))

    def test_issue_xlr8or_18(self):
        self.console.config.fileName = r"b3.xml"
        self.assertEqual(r"status.xml", self.conf.getpath('settings', 'output_file'))


class CommonTestMethodsMixin:

    def _assert_func(self, func, expected, conf_value):
        self.conf.loadFromString(self.__class__.assert_func_template % conf_value)
        try:
            self.assertEqual(expected, func('section_foo', 'foo'))
        except (ConfigParser.Error, ValueError), err:
            self.fail("expecting %s, but got %r" % (expected, err))

    def _assert_func_raises(self, func, expected_error, section, name, conf):
        try:
            self.conf.loadFromString(conf)
            func(section, name)
        except expected_error:
            pass
        except Exception, err:
            self.fail("expecting %s, but got %r" % (expected_error, err))
        else:
            self.fail("expecting %s" % expected_error)

    def assert_get(self, expected, conf_value):
        self._assert_func(self.conf.get, expected, conf_value)

    def assert_get_raises(self, expected_error, section, name, conf):
        self._assert_func_raises(self.conf.get, expected_error, section, name, conf)

    def assert_getint(self, expected, conf_value):
        self._assert_func(self.conf.getint, expected, conf_value)

    def assert_getint_raises(self, expected_error, section, name, conf):
        self._assert_func_raises(self.conf.getint, expected_error, section, name, conf)

    def assert_getfloat(self, expected, conf_value):
        self._assert_func(self.conf.getfloat, expected, conf_value)

    def assert_getfloat_raises(self, expected_error, section, name, conf):
        self._assert_func_raises(self.conf.getfloat, expected_error, section, name, conf)

    def assert_getboolean(self, expected, conf_value):
        self._assert_func(self.conf.getboolean, expected, conf_value)

    def assert_getboolean_raises(self, expected_error, section, name, conf):
        self._assert_func_raises(self.conf.getboolean, expected_error, section, name, conf)

    def test_get(self):
        self.assert_get('bar', 'bar')
        self.assert_get('', '')
        self.assert_get_raises(ConfigParser.NoOptionError, 'section_foo', 'bar', self.assert_func_template % "")
        self.assert_get_raises(ConfigParser.NoOptionError, 'section_bar', 'foo', self.assert_func_template % "")

    def test_getint(self):
        self.assert_getint(-54, '-54')
        self.assert_getint(0, '0')
        self.assert_getint(64, '64')
        self.assert_getint_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "bar")
        self.assert_getint_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "64.5")
        self.assert_getint_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "")
        self.assert_getint_raises(ConfigParser.NoOptionError, 'section_foo', 'bar', self.assert_func_template % "")
        self.assert_getint_raises(ConfigParser.NoOptionError, 'section_bar', 'foo', self.assert_func_template % "")

    def test_getfloat(self):
        self.assert_getfloat(-54.0, '-54')
        self.assert_getfloat(-54.6, '-54.6')
        self.assert_getfloat(0.0, '0')
        self.assert_getfloat(0.0, '0.0')
        self.assert_getfloat(64.0, '64')
        self.assert_getfloat(64.45, '64.45')
        self.assert_getfloat_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "bar")
        self.assert_getfloat_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "64,5")
        self.assert_getfloat_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "")
        self.assert_getfloat_raises(ConfigParser.NoOptionError, 'section_foo', 'bar', self.assert_func_template % "")
        self.assert_getfloat_raises(ConfigParser.NoOptionError, 'section_bar', 'foo', self.assert_func_template % "")

    def test_getboolean(self):
        self.assert_getboolean(False, 'false')
        self.assert_getboolean(False, '0')
        self.assert_getboolean(False, 'off')
        self.assert_getboolean(False, 'OFF')
        self.assert_getboolean(False, 'no')
        self.assert_getboolean(False, 'NO')
        self.assert_getboolean(True, 'true')
        self.assert_getboolean(True, '1')
        self.assert_getboolean(True, 'on')
        self.assert_getboolean(True, 'ON')
        self.assert_getboolean(True, 'yes')
        self.assert_getboolean(True, 'YES')
        self.assert_getboolean_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "bar")
        self.assert_getboolean_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "64,5")
        self.assert_getboolean_raises(ValueError, 'section_foo', 'foo', self.assert_func_template % "")
        self.assert_getboolean_raises(ConfigParser.NoOptionError, 'section_foo', 'bar', self.assert_func_template % "")
        self.assert_getboolean_raises(ConfigParser.NoOptionError, 'section_bar', 'foo', self.assert_func_template % "")


class Test_XmlConfigParser(CommonTestMethodsMixin, B3TestCase):

    assert_func_template = """
        <configuration>
            <settings name="section_foo">
                <set name="foo">%s</set>
            </settings>
        </configuration>"""

    def setUp(self):
        B3TestCase.setUp(self)
        self.conf = XmlConfigParser()
        self.conf.loadFromString("""<configuration/>""")
        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)

    def test_get_missing(self):
        self.assert_get_raises(ConfigParser.NoOptionError, 'section_foo', 'bar', """<configuration><settings name="section_foo"><set name="foo"/></settings></configuration>""")
        self.assert_get_raises(ConfigParser.NoOptionError, 'section_bar', 'foo', """<configuration><settings name="section_foo"><set name="foo"/></settings></configuration>""")


class Test_CfgConfigParser(CommonTestMethodsMixin, B3TestCase):

    assert_func_template = """
[section_foo]
foo = %s
"""

    def setUp(self):
        B3TestCase.setUp(self)
        self.conf = CfgConfigParser()
        self.conf.loadFromString("[foo]")
        log = logging.getLogger('output')
        log.setLevel(logging.DEBUG)


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_cron
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import time
import unittest2 as unittest
from mock import sentinel, Mock
from b3.cron import CronTab, OneTimeCronTab, PluginCronTab, Cron
from tests import B3TestCase

class Test_Crontab(unittest.TestCase):

    def test_constructor_defaults(self):
        command = sentinel
        tab = CronTab(command)
        self.assertEqual(command, tab.command)
        self.assertEqual(0, tab.second)
        self.assertEqual(-1, tab.minute)
        self.assertEqual(-1, tab.hour)
        self.assertEqual(-1, tab.day)
        self.assertEqual(-1, tab.month)
        self.assertEqual(-1, tab.dow)
        self.assertEqual(0, tab.maxRuns)

    def test_constructor(self):
        command = sentinel
        tab = CronTab(command, second=1, minute=2, hour=3, day=4, month=5, dow=1)
        self.assertEqual(command, tab.command)
        self.assertEqual(1, tab.second)
        self.assertEqual(2, tab.minute)
        self.assertEqual(3, tab.hour)
        self.assertEqual(4, tab.day)
        self.assertEqual(5, tab.month)
        self.assertEqual(1, tab.dow)

    def test_dow(self):
        tab = CronTab(None)

        tab.dow = '*' # any day
        self.assertEqual(-1, tab.dow)

        tab.dow = 0 # sunday
        self.assertEqual(0, tab.dow)

        tab.dow = 1 # monday
        self.assertEqual(1, tab.dow)

        tab.dow = 2 # tuesday
        self.assertEqual(2, tab.dow)

        tab.dow = 3 # wednesday
        self.assertEqual(3, tab.dow)

        tab.dow = 4 # thursday
        self.assertEqual(4, tab.dow)

        tab.dow = 5 # friday
        self.assertEqual(5, tab.dow)

        tab.dow = 6 # saturday
        self.assertEqual(6, tab.dow)

        try:
            tab.dow = 7
        except ValueError:
            pass
        else:
            self.fail("expecting ValueError when setting dow to 7")

        try:
            tab.dow = -1
        except ValueError:
            pass
        else:
            self.fail("expecting ValueError when setting dow to 7")

    def test_run(self):
        command = Mock(name="command")
        tab = CronTab(command)
        assert not command.called
        tab.run()
        assert command.called


    def test_match(self):
        tab = CronTab(None, second='*', minute='*', hour='*', day='*', month='*', dow='*')
        self.assertTrue(tab.match(time.gmtime()))

        tab = CronTab(None, second='*', minute='*', hour='*', day='*', month='*', dow='0,1,2,3,4,5,6')
        self.assertTrue(tab.match(time.gmtime()))


class Test_OneTimeCrontab(unittest.TestCase):

    def test_constructor(self):
        tab = OneTimeCronTab(None)
        self.assertEqual(1, tab.maxRuns)


class Test_PluginCronTab(unittest.TestCase):

    def test(self):
        CronTab.match = Mock(return_value=True)
        mock_command = Mock()
        p = Mock()
        tab = PluginCronTab(plugin=p, command=mock_command)

        mock_command.reset_mock()
        p.isEnabled = Mock(return_value=True)
        self.assertTrue(tab.match(time.gmtime()))
        tab.run()
        self.assertTrue(mock_command.called)

        mock_command.reset_mock()
        p.isEnabled = Mock(return_value=False)
        self.assertFalse(tab.match(time.gmtime()))
        tab.run()
        self.assertFalse(mock_command.called)


class Test_Crontab_getRate(unittest.TestCase):

    def setUp(self):
        self._t = CronTab(None)

    def tearDown(self):
        pass

    def t(self, param):
        return self._t._getRate(param, 60)

    def test_None(self):
        self.assertRaises(TypeError, self.t, None)

    def test_getRate_int(self):
        self.assertEquals(0, self.t(0))
        self.assertEquals(1, self.t(1))
        self.assertEquals(59, self.t(59))
        self.assertRaises(ValueError, self.t, 60)
        self.assertRaises(ValueError, self.t, -1)

    def test_float(self):
        self.assertEquals(0, self.t(0.0))
        self.assertEquals(1, self.t(1.0))
        self.assertEquals(59, self.t(59.0))
        self.assertRaises(ValueError, self.t, 60.0)
        self.assertRaises(ValueError, self.t, -1.0)

    def test_str_every(self):
        self.assertEquals(-1, self.t('*'))

    def test_str_everySo(self):
        self.assertEquals(range(0,60,2), self.t('*/2') )
        self.assertEquals(range(0,60,17), self.t('*/17'))
        self.assertEquals([0,59], self.t('*/59'))
        self.assertEquals([0], self.t('*/60'))
        self.assertRaises(ValueError, self.t, ('*/61'))
        self.assertRaises(TypeError, self.t, ('*/-1'))
        self.assertRaises(ValueError, self.t, ('*/80'))

    def test_str_range(self):
        self.assertEquals(range(5,12), self.t('5-11'))
        self.assertRaises(TypeError, self.t, ('-5-11'))
        self.assertRaises(ValueError, self.t, ('35-11'))
        self.assertRaises(TypeError, self.t, ('5--11'))
        self.assertRaises(ValueError, self.t, ('5-80'))

    def test_str_range_with_step(self):
        self.assertEquals(range(5,12,2), self.t('5-11/2'))
        self.assertEquals([5], self.t('5-11/60'))
        self.assertRaises(ValueError, self.t, ('5-11/80'))
        self.assertRaises(TypeError, self.t, ('5-11/'))
        self.assertRaises(TypeError, self.t, ('5-11/-1'))

    def test_str_other(self):
        self.assertRaises(TypeError, self.t, (''))
        self.assertRaises(TypeError, self.t, ('test'))

    def test_list(self):
        self.assertEquals([5,11,32,45], self.t('5,11,45,32'))
        self.assertEquals([0,1,2,5,6,7,8], self.t('5-8,0-2'))
        self.assertEquals([5,6,7,20,30], self.t('5-7, 20, 30'))
        self.assertEquals([5,6,7,30,40], self.t('5-7,40,30'))
        self.assertEquals([0,5,6,7,40], self.t('5-7,40,0'))
        self.assertEquals([5,7,9,11,30,40,41,42], self.t('5-12/2, 30, 40-42'))
        self.assertRaises(TypeError, self.t, ('5-12/2, -5, 40-42'))


class Test_Cron(B3TestCase):

    def setUp(self):
        B3TestCase.setUp(self)
        self.cron = Cron(self.console)
        #self.console.verbose = lambda *args: sys.stdout.write(str(args) + "\n")

    def test_add(self):
        mock_tab = Mock(spec=CronTab)
        res = self.cron.add(mock_tab)
        self.assertEqual(1, len(self.cron._tabs))
        self.assertEqual(id(mock_tab), res)
        self.assertIn(id(mock_tab), self.cron._tabs)

    def test_add_operator(self):
        mock_tab = Mock(spec=CronTab)
        self.cron + mock_tab
        self.assertEqual(1, len(self.cron._tabs))
        self.assertIn(id(mock_tab), self.cron._tabs)

    def test_cancel(self):
        mock_tab = Mock(spec=CronTab)
        res = self.cron.add(mock_tab)
        self.assertEqual(1, len(self.cron._tabs))

        self.cron.cancel(-1)
        self.assertEqual(1, len(self.cron._tabs))

        self.cron.cancel(id(mock_tab))
        self.assertNotIn(id(mock_tab), self.cron._tabs)
        self.assertEqual(0, len(self.cron._tabs))

    def test_sub_operator(self):
        mock_tab = Mock(spec=CronTab)
        res = self.cron.add(mock_tab)
        self.assertEqual(1, len(self.cron._tabs))
        self.cron - mock_tab
        self.assertNotIn(res, self.cron._tabs)
        self.assertEqual(0, len(self.cron._tabs))

    def test_create(self):
        crontab_id = self.cron.create(None)
        self.assertEqual(1, len(self.cron._tabs))
        self.assertIn(crontab_id, self.cron._tabs)
        self.assertEqual(CronTab, type(self.cron._tabs[crontab_id]))


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_functions
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import time
import sys
from b3 import functions
import unittest2 as unittest
    
class TestSplitDSN(unittest.TestCase):
    def assertDsnEqual(self, url, expected):
        tmp = functions.splitDSN(url)
        self.assertEqual(tmp, expected)

    def test_sqlite(self):
        self.assertDsnEqual('sqlite://c|/mydatabase/test.db', 
        {'protocol': 'sqlite', 'host': 'c|', 'user': None, 
        'path': '/mydatabase/test.db', 'password': None, 'port': None })

    def test_ftp(self):
        self.assertDsnEqual('ftp://username@domain.com/index.html', 
        {'protocol': 'ftp', 'host': 'domain.com', 'user': 'username', 
         'path': '/index.html', 'password': None, 'port': 21 })
        
    def test_ftp2(self):
        self.assertDsnEqual('ftp://username:password@domain.com/index.html', 
        {'protocol': 'ftp', 'host': 'domain.com', 'user': 'username', 
         'path': '/index.html', 'password': 'password', 'port': 21 })
        
    def test_ftp3(self):
        self.assertDsnEqual('ftp://username@domain.com:password@domain.com/index.html', 
        {'protocol': 'ftp', 'host': 'domain.com', 'user': 'username@domain.com', 
         'path': '/index.html', 'password': 'password', 'port': 21 })
        
    def test_ftp4(self):
        self.assertDsnEqual('ftp://username@domain.com:password@domain.com:2121/index.html', 
        {'protocol': 'ftp', 'host': 'domain.com', 'user': 'username@domain.com', 
         'path': '/index.html', 'password': 'password', 'port': 2121 })
        
    def test_mysql(self):
        self.assertDsnEqual('mysql://b3:password@localhost/b3', 
        {'protocol': 'mysql', 'host': 'localhost', 'user': 'b3', 
         'path': '/b3', 'password': 'password', 'port': 3306} )
        self.assertDsnEqual('mysql://b3:password@localhost:3406/b3',
        {'protocol': 'mysql', 'host': 'localhost', 'user': 'b3',
         'path': '/b3', 'password': 'password', 'port': 3406} )
        self.assertDsnEqual("mysql://someuser:somepasswd@somehost:3326/",
        {'protocol': 'mysql', 'host': 'somehost', 'user': 'someuser',
         'path': '/', 'password': 'somepasswd', 'port': 3326} )

class TestFuzziGuidMatch(unittest.TestCase):
    def test_1(self):
        self.assertTrue(functions.fuzzyGuidMatch( '098f6bcd4621d373cade4e832627b4f6', '098f6bcd4621d373cade4e832627b4f6'))
        self.assertTrue(functions.fuzzyGuidMatch( '098f6bcd4621d373cade4e832627b4f6', '098f6bcd4621d373cade4e832627b4f'))
        self.assertTrue(functions.fuzzyGuidMatch( '098f6bcd4621d373cade4e832627b4f6', '098f6bcd4621d373cde4e832627b4f6'))
        self.assertTrue(functions.fuzzyGuidMatch( '098f6bcd4621d373cade4e832627bf6',  '098f6bcd4621d373cade4e832627b4f6'))
        self.assertFalse(functions.fuzzyGuidMatch('098f6bcd4621d373cade4e832627b4f6', '098f6bcd46d373cade4e832627b4f6'))
        self.assertFalse(functions.fuzzyGuidMatch('098f6bcd4621d373cade4832627b4f6',  '098f6bcd4621d73cade4e832627b4f6'))
    
    def test_caseInsensitive(self):
        self.assertTrue(functions.fuzzyGuidMatch( '098F6BCD4621D373CADE4E832627B4F6', '098f6bcd4621d373cade4e832627b4f6'))
        self.assertTrue(functions.fuzzyGuidMatch( '098F6BCD4621D373CADE4E832627B4F6', '098f6bcd4621d373cade4e832627b4f'))
        self.assertTrue(functions.fuzzyGuidMatch( '098F6BCD4621D373CADE4E832627B4F6', '098f6bcd4621d373cde4e832627b4f6'))
        self.assertFalse(functions.fuzzyGuidMatch('098F6BCD4621D373CADE4E832627B4F6', '098f6bcd46d373cade4e832627b4f6'))
        self.assertTrue(functions.fuzzyGuidMatch( '098F6BCD4621D373CADE4E832627BF6', '098f6bcd4621d373cade4e832627b4f6'))
        self.assertFalse(functions.fuzzyGuidMatch('098F6BCD4621D373CADE4832627B4F6', '098f6bcd4621d73cade4e832627b4f6'))
        
class TestMinutes2int(unittest.TestCase):
    def test_NaN(self):
        self.assertEqual(functions.minutes2int('mlkj'), 0)
        self.assertEqual(functions.minutes2int(''), 0)
        self.assertEqual(functions.minutes2int('50,654'), 0)
    def test_int(self):
        self.assertEqual(functions.minutes2int('50'), 50)
        self.assertEqual(functions.minutes2int('50.654'), 50.65)
      
class TestTime2minutes(unittest.TestCase):
    def test_None(self):
        self.assertEqual(functions.time2minutes(None), 0)
    def test_int(self):
        self.assertEqual(functions.time2minutes(0), 0)
        self.assertEqual(functions.time2minutes(1), 1)
        self.assertEqual(functions.time2minutes(154), 154)
    def test_str(self):
        self.assertEqual(functions.time2minutes(''), 0)
    def test_str_h(self):
        self.assertEqual(functions.time2minutes('145h'), 145*60)
        self.assertEqual(functions.time2minutes('0 h'), 0)
        self.assertEqual(functions.time2minutes('0    h'), 0)
        self.assertEqual(functions.time2minutes('5h'), 5*60)
    def test_str_m(self):
        self.assertEqual(functions.time2minutes('145m'), 145)
        self.assertEqual(functions.time2minutes('0 m'), 0)
        self.assertEqual(functions.time2minutes('0    m'), 0)
        self.assertEqual(functions.time2minutes('5m'), 5)
    def test_str_s(self):
        self.assertEqual(functions.time2minutes('0 s'), 0)
        self.assertEqual(functions.time2minutes('0    s'), 0)
        self.assertEqual(functions.time2minutes('60s'), 1)
        self.assertEqual(functions.time2minutes('120s'), 2)
        self.assertEqual(functions.time2minutes('5s'), 5.0/60)
        self.assertEqual(functions.time2minutes('90s'), 1.5)
    def test_str_d(self):
        self.assertEqual(functions.time2minutes('0 d'), 0)
        self.assertEqual(functions.time2minutes('0    d'), 0)
        self.assertEqual(functions.time2minutes('60d'), 60*24*60)
        self.assertEqual(functions.time2minutes('120d'), 120*24*60)
        self.assertEqual(functions.time2minutes('5d'), 5*24*60)
        self.assertEqual(functions.time2minutes('90d'), 90*24*60)
    def test_str_w(self):
        self.assertEqual(functions.time2minutes('0 w'), 0)
        self.assertEqual(functions.time2minutes('0    w'), 0)
        self.assertEqual(functions.time2minutes('60w'), 60*7*24*60)
        self.assertEqual(functions.time2minutes('120w'), 120*7*24*60)
        self.assertEqual(functions.time2minutes('5w'), 5*7*24*60)
        self.assertEqual(functions.time2minutes('90w'), 90*7*24*60)

class Test_misc(unittest.TestCase):
    def test_minutesStr(self):
        for test_data, expected in {
            '3s': '3 seconds',
            '4m': '4 minutes',
            '41': '41 minutes',
            '2h': '2 hours',
            '2.5h': '2.5 hours',
            '3d': '3 days',
            '5w': '5 weeks',
            0: '0 second',
            0.5: '30 seconds',
            60: '1 hour',
            90: '1.5 hour',
            120: '2 hours',
            122: '2 hours',
            1266: '21.1 hours',
            1440: '1 day',
            3600: '2.5 days',
            10080: '1 week',
            15120: '1.5 week',
            60480: '6 weeks',
            525600: '1 year',
            861984: '1.6 year',
            1051200: '2 years',
            10512000: '20 years',
        }.items():
            result = functions.minutesStr(test_data)
            if expected != result:
                self.fail("%r, expecting '%s' but got '%s'" % (test_data, expected, result))

    def test_vars2printf(self):
        for test_data, expected in {
            '': '',
            'qsdf': 'qsdf',
            'qsdf $azer xcw': 'qsdf %(azer)s xcw',
            'qsdf $wdrf5 xcw': 'qsdf %(wdrf)s5 xcw',
            '$test': '%(test)s',
            '  $test ': '  %(test)s ',
            '  $test $foo $ $bar': '  %(test)s %(foo)s $ %(bar)s',
        }.items():
            result = functions.vars2printf(test_data)
            if expected != result:
                self.fail("%r, expecting '%s' but got '%s'" % (test_data, expected, result))

    def test_meanstdv(self):
        for test_data, expected in {
            (5,): (5.0, 0),
            (10,): (10.0, 0),
            (): (0, 0)
        }.items():
            result = functions.meanstdv(test_data)
            if expected != result:
                self.fail("%r, expecting '%s' but got '%s'" % (test_data, expected, result))


class Test_getStuffSoundingLike(unittest.TestCase):

    def test_empty_expected_stuff(self):
        self.assertListEqual([], functions.getStuffSoundingLike('foO', []))

    def test_exact_match(self):
        self.assertListEqual(['foO'], functions.getStuffSoundingLike('foO', ['foO']))
        self.assertListEqual(['foO'], functions.getStuffSoundingLike('foO', ['bar', 'foO', 'joe', 'jack', 'averell', 'william']))

    def test_substring_match(self):
        self.assertListEqual(['averell'], functions.getStuffSoundingLike('ere', ['bar', 'foO', 'joe', 'jack', 'averell', 'william']))
        self.assertListEqual(['joe', 'jack'], functions.getStuffSoundingLike('j', ['bar', 'foO', 'joe', 'jack', 'averell', 'william']))
        self.assertListEqual(['xxxfoOx1', 'xxxfoOx2', 'xxxfoOx3', 'xxxfoOx4', 'xxxfoOx5', 'xxxfoOx6'],
            functions.getStuffSoundingLike('foO', ['xxxfoOx1', 'xxxfoOx2', 'xxxfoOx3', 'xxxfoOx4', 'xxxfoOx5', 'xxxfoOx6', 'bar']))

    def test_soundex_match(self):
        self.assertListEqual(['jack'], functions.getStuffSoundingLike('jak', ['bar', 'foO', 'joe', 'jack', 'averell', 'william']))

    def test_fallback(self):
        self.assertListEqual(['bar', 'foO', 'joe', 'jack', 'averell', 'william'], functions.getStuffSoundingLike('xxx', ['bar', 'foO', 'joe', 'jack', 'averell', 'william']))


########NEW FILE########
__FILENAME__ = test_parser
# coding=UTF-8
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2012 Courgette
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import logging
import unittest2 as unittest
from b3.clients import Client
from b3.parser import Parser


class DummyParser(Parser):
    gameName = "dummy"

    def __init__(self):
        pass # skip parent class constructor
        self.log = logging.getLogger("output")


class Test_getMessage(unittest.TestCase):

    def setUp(self):
        self.parser = DummyParser()
        self.parser._messages = {}

    def test_unknown_msg__falls_back_on_default(self):
        self.parser._messages = {}
        self.parser._messages_default = {"f00": "lorem ipsum"}
        self.assertEqual("lorem ipsum", self.parser.getMessage("f00"))

    def test_no_parameter(self):
        self.parser._messages['f00'] = "bar"
        self.assertEqual("bar", self.parser.getMessage('f00'))

    def test_with_parameter(self):
        self.parser._messages['f00'] = "bar %s"
        self.assertEqual("bar joe", self.parser.getMessage('f00', 'joe'))

    def test_with_unexpected_parameter(self):
        self.parser._messages['f00'] = "bar"
        self.assertRaises(TypeError, self.parser.getMessage, 'f00', 'joe')

    def test_with_dict_parameter(self):
        self.parser._messages['f00'] = "bar %(p1)s"
        self.assertEqual("bar joe", self.parser.getMessage('f00', {'p1': 'joe'}))

    def test_with_missing_dict_parameter(self):
        self.parser._messages['f00'] = "bar %(p1)s"
        self.assertRaises(KeyError, self.parser.getMessage, 'f00', {'p2': 'joe'})

    def test_with_unicode_dict_parameter(self):
        self.parser._messages['f00'] = "bar %(p1)s"
        self.assertEqual(u"bar jo", self.parser.getMessage('f00', {'p1': u'jo'}))



class Test_getMessageVariables(unittest.TestCase):

    def setUp(self):
        self.parser = DummyParser()

    def test_with_parameters(self):
        client = Client(name="Jack")
        rv = self.parser.getMessageVariables(client)
        self.assertDictContainsSubset({'name': client.name}, rv, rv)

    def test_with_named_parameters(self):
        client = Client(name="Jack")
        self.assertDictContainsSubset({'clientname': client.name, 'reason': 'this is a good reason'}, self.parser.getMessageVariables(client=client, reason="this is a good reason"))

    def test_with_named_parameters__unicode(self):
        client = Client(name=u"")
        self.assertDictContainsSubset({'clientname':client.name, 'reason': 'this is a good reason'}, self.parser.getMessageVariables(client=client, reason="this is a good reason"))




if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_update
# -*- encoding: utf-8 -*-
#
# BigBrotherBot(B3) (www.bigbrotherbot.net)
# Copyright (C) 2011 Thomas "Courgette" LVEIL <courgette@bigbrotherbot.net>
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
import time
from b3 import update
import urllib2
import unittest2 as unittest
from mock import patch
from b3.update import B3version

class TestB3Version(unittest.TestCase):
    def test_no_exception(self):
        B3version("1.4")
        B3version("1.4.2")
        B3version("0.7dev")
        B3version("0.7dev0")
        B3version("0.7dev4")
        B3version("1.8a")
        B3version("1.8a0")
        B3version("1.8a1")
        B3version("1.8a45")
        B3version("1.8b")
        B3version("1.8b0")
        B3version("1.8b78")
        B3version("0.7.2dev")
        B3version("0.7.2dev0")
        B3version("0.7.2dev4")
        B3version("1.8.2a")
        B3version("1.8.2a0")
        B3version("1.8.2a1")
        B3version("1.8.2a45")
        B3version("1.8.2b")
        B3version("1.8.2b0")
        B3version("1.8.2b78")
        B3version("1.9.0dev7.daily21-20121004")

    def test_exception(self):
        for version in ("1", "0", "24", '1.x', '1.5.2.1', '1.4alpha', '1.5.4beta', '1.6d'):
            try:
                B3version(version)
                self.fail("should have raised a ValueError for version '%s'" % version)
            except ValueError:
                pass

    def test_equals(self):
        self.assertEqual(B3version("1.1.0"), B3version('1.1'))
        self.assertEqual(B3version("1.1dev"), B3version('1.1dev0'))
        self.assertEqual(B3version("1.1.0dev"), B3version('1.1.0dev0'))
        self.assertEqual(B3version("1.1.0dev"), B3version('1.1dev0'))
        self.assertEqual(B3version("1.1a"), B3version('1.1a0'))
        self.assertEqual(B3version("1.1.0a"), B3version('1.1.0a0'))
        self.assertEqual(B3version("1.1b"), B3version('1.1b'))
        self.assertEqual(B3version("1.1.0b"), B3version('1.1.0b0'))
        self.assertEqual(B3version("1.1.0b"), B3version('1.1b0'))
        self.assertEqual(B3version("1.9.0dev7.daily21-20121004"), B3version("1.9dev7.daily21"))

    def test_greater(self):
        self.assertGreater(B3version('1.0'), B3version('1.0dev'))
        self.assertGreater(B3version('1.0'), B3version('1.0dev1'))
        self.assertGreater(B3version('1.0'), B3version('1.0.0dev'))
        self.assertGreater(B3version('1.0'), B3version('1.0.0dev2'))
        self.assertGreater(B3version('1.0'), B3version('1.0a'))
        self.assertGreater(B3version('1.0'), B3version('1.0a5'))
        self.assertGreater(B3version('1.0'), B3version('1.0b'))
        self.assertGreater(B3version('1.0'), B3version('1.0b5'))
        self.assertGreater(B3version('1.0'), B3version('0.5'))
        self.assertGreater(B3version('1.0'), B3version('0.5dev'))
        self.assertGreater(B3version('1.0'), B3version('0.5a'))
        self.assertGreater(B3version('1.0'), B3version('0.5b'))
        self.assertGreater(B3version("1.9.0dev7.daily21-20121004"), B3version("1.9dev7.daily19-20121001"))

    def test_less(self):
        self.assertLess(B3version('1.0'), B3version('1.0.1'))
        self.assertLess(B3version('1.0'), B3version('1.1'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.1dev6'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.1a'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.1a5'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.1b'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.1b5'))
        self.assertLess(B3version('2.5.1dev'), B3version('2.5.2'))
        self.assertLess(B3version('2.5.1dev5'), B3version('2.5.2'))
        self.assertLess(B3version('2.5.1a'), B3version('2.5.2'))
        self.assertLess(B3version('2.5.1a2'), B3version('2.5.2'))
        self.assertLess(B3version('2.5.1b'), B3version('2.5.2'))
        self.assertLess(B3version('2.5.1b4'), B3version('2.5.2'))
        self.assertLess(B3version("1.9.0dev7.daily5-20120904"), B3version("1.9dev7.daily19-20121001"))


class TestGetDefaultChannel(unittest.TestCase):
    def test_rotten_input(self):
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel(None))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel(""))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel(" "))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel(" qsdf sf qsd"))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel("1.4.5.6"))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel("1.4beta"))

    def test_stable(self):
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel("1.0"))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel("1.0.1"))
        self.assertEqual(update.UPDATE_CHANNEL_STABLE, update.getDefaultChannel("1.2"))

    def test_beta(self):
        self.assertEqual(update.UPDATE_CHANNEL_BETA, update.getDefaultChannel("1.0b"))
        self.assertEqual(update.UPDATE_CHANNEL_BETA, update.getDefaultChannel("1.0.1b2"))
        self.assertEqual(update.UPDATE_CHANNEL_BETA, update.getDefaultChannel("1.2b5"))

    def test_dev(self):
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.0a"))
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.0.1a2"))
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.2a5"))
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.0dev"))
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.0.1dev2"))
        self.assertEqual(update.UPDATE_CHANNEL_DEV, update.getDefaultChannel("1.2dev5"))


class TestCheckUpdateUrl(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.original_url = update.URL_B3_LATEST_VERSION

    def setUp(self):
        self._time_start = 0
        self._time_start = time.time()

    def tearDown(self):
        # make sure to restore update url between tests
        update.URL_B3_LATEST_VERSION = self.__class__.original_url
        ms = ((time.time() - self._time_start)*1000)
        self.assertTrue(ms < 10000, "Test exceeded timeout : %s ms" % ms)

    def test_official_url(self):
        result = update.checkUpdate('1.2', singleLine=False, showErrormsg=True)
        self.assertIsNotNone(result)
        self.assertNotIn('Could not check updates', result)

    @patch.object(urllib2, "urlopen")
    def test_not_existing_url(self, mocked_urlopen):
        update.URL_B3_LATEST_VERSION = 'http://no.where.local/'
        mocked_urlopen.side_effect = urllib2.URLError
        result = update.checkUpdate('1.2', singleLine=True, showErrormsg=True)
        self.assertIn('Could not check updates', result)


class TestCheckUpdate (unittest.TestCase):

    def setUp(self):
        self.expected_stable = u'*** NOTICE: B3 1.4.3 is available. See http://www.url.stable.fake ! ***'
        self.expected_beta = u'*** NOTICE: B3 1.5.3b3 is available. See http://www.url.beta.fake ! ***'
        self.expected_dev = u'*** NOTICE: B3 1.6dev5 is available. See http://www.url.dev.fake ! ***'

        def urlopen(*args, **kwargs):
            """
            will fake urllib2.urlopen
            """
            import StringIO
            return StringIO.StringIO("""
                {
                    "B3": {
                        "channels": {
                            "stable": {
                                "url": "http://www.url.stable.fake",
                                "latest-version": "1.4.3"
                            },
                            "beta": {
                                "url": "http://www.url.beta.fake",
                                "latest-version": "1.5.3b3"
                            },
                            "dev": {
                                "url": "http://www.url.dev.fake",
                                "latest-version": "1.6dev5"
                            }
                        }
                    }
                }
            """)
        self.original_urlopen = urllib2.urlopen
        urllib2.urlopen = urlopen

    def tearDown(self):
        urllib2.urlopen = self.original_urlopen

    def test_default_channel(self):
        for v in ('1.0', '1.1.1', '1.4', '1.4.2'):
            self.assertEqual(self.expected_stable, update.checkUpdate(v))
        for v in ('1.4.3', '1.4.4', '1.5', '1.5.2', '1.5.3', '1.5.4', '1.6', '1.6.1'):
            self.assertEqual(None, update.checkUpdate(v))

        for v in ('1.0b', '1.1.1b', '1.1.1b2', '1.4.3b', '1.4.3b1', '1.4.4b', '1.5.3b', '1.5.3b1', '1.5.3b2'):
            self.assertEqual(self.expected_beta, update.checkUpdate(v))
        for v in ('1.5.3b3', '1.5.3b4', '1.5.4b', '1.6b', '1.6b1'):
            self.assertEqual(None, update.checkUpdate(v))

        for v in ('1.0dev15', '1.1.1dev7', '1.4.3dev', '1.4.3dev1', '1.4.4dev', '1.5.3dev', '1.5.3dev1', '1.5.4dev', '1.6dev', '1.6dev4'):
            self.assertEqual(self.expected_dev, update.checkUpdate(v))
        for v in ('1.6dev5', '1.6dev6', '1.7dev'):
            self.assertEqual(None, update.checkUpdate(v))


    def test_stable_channel(self):
        for v in ('1.0dev15','1.0b', '1.0', '1.1.1', '1.1.1b', '1.1.1b2', '1.1.1dev7', '1.4', '1.4.2', '1.4.3dev',
                  '1.4.3dev1', '1.4.3b', '1.4.3b1'):
            self.assertEqual(self.expected_stable, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_STABLE))
        for v in ('1.4.3', '1.4.3', '1.4.4dev', '1.4.4b', '1.4.4', '1.5', '1.5.2', '1.5.3dev', '1.5.3dev1',
                  '1.5.3b', '1.5.3b1', '1.5.3b2', '1.5.3b3', '1.5.3b4', '1.5.3', '1.5.4dev', '1.5.4b', '1.5.4',
                  '1.6dev', '1.6dev4', '1.6dev5', '1.6dev6', '1.6b', '1.6b1', '1.6', '1.6.1'):
            self.assertEqual(None, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_STABLE))

    def test_beta_channel(self):
        for v in ('1.0dev15','1.0b', '1.0', '1.1.1', '1.1.1b', '1.1.1b2', '1.1.1dev7', '1.4', '1.4.2', '1.4.3dev',
                  '1.4.3dev1', '1.4.3b', '1.4.3b1', '1.4.3', '1.4.3', '1.4.4dev', '1.4.4b', '1.4.4', '1.5',
                  '1.5.2', '1.5.3dev', '1.5.3dev1', '1.5.3b', '1.5.3b1', '1.5.3b2'):
            self.assertEqual(self.expected_beta, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_BETA))
        for v in ('1.5.3b3', '1.5.3b4', '1.5.3', '1.5.4dev', '1.5.4b', '1.5.4', '1.6dev', '1.6dev4', '1.6dev5',
                  '1.6dev6', '1.6b', '1.6b1', '1.6', '1.6.1'):
            self.assertEqual(None, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_BETA))

    def test_dev_channel(self):
        for v in ('1.0dev15','1.0b', '1.0', '1.1.1', '1.1.1b', '1.1.1b2', '1.1.1dev7', '1.4', '1.4.2', '1.4.3dev',
                  '1.4.3dev1', '1.4.3b', '1.4.3b1', '1.4.3', '1.4.3', '1.4.4dev', '1.4.4b', '1.4.4', '1.5',
                  '1.5.2', '1.5.3dev', '1.5.3dev1', '1.5.3b', '1.5.3b1', '1.5.3b2', '1.5.3b3', '1.5.3b4', '1.5.3',
                  '1.5.4dev', '1.5.4b', '1.5.4', '1.6dev', '1.6dev4'):
            self.assertEqual(self.expected_dev, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_DEV))
        for v in ('1.6dev5',
                  '1.6dev6', '1.6b', '1.6b1', '1.6', '1.6.1'):
            self.assertEqual(None, update.checkUpdate(v, channel=update.UPDATE_CHANNEL_DEV))

    def test_unknown_channel(self):
        self.assertIn("unknown channel 'foo'", update.checkUpdate('1.0', channel="foo", showErrormsg=True))

    @unittest.expectedFailure
    def test_bad_version(self):
        update.checkUpdate('one.two', showErrormsg=True)

    def test_broken_json(self):
        def urlopen2(*args, **kwargs):
            """
            will fake urllib2.urlopen
            """
            import StringIO
            return StringIO.StringIO("""
                {
                    "B3": {
                        "channels": {
                            "stable": {
                                "url": "http://www.url.stable.fake",
                                "latest-version": "1.4.3"
                            },
                            "be
            """)
        import urllib2
        urllib2.urlopen = urlopen2
        self.assertIn("Could not check updates", update.checkUpdate('1.0', showErrormsg=True))


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
