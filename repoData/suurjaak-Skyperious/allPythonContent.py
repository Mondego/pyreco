__FILENAME__ = make_srcdist
"""
Creates Skyperious source distribution archive from current version in src\.
Sets execute flag permission on .sh files.

@author    Erki Suurjaak
@created   12.12.2013
@modified  28.02.2014
"""
import glob
import os
import sys
import time
import zipfile
import zlib


if "__main__" == __name__:
    INITIAL_DIR = os.getcwd()
    PACKAGING_DIR = os.path.realpath(os.path.join(os.path.dirname(__file__)))
    os.chdir(os.path.join(os.path.dirname(__file__), ".."))
    sys.path.append("src")
    import conf

    BASE_DIR = ""
    ZIP_DIR = "skyperious_%s" % conf.Version
    DEST_FILE = "skyperious_%s-src.zip" % conf.Version
    print("Creating source distribution %s.\n" % DEST_FILE)

    def pathjoin(*args):
        # Cannot have ZIP system UNIX with paths like Windows
        return "/".join(filter(None, args))

    def add_files(zf, filenames, subdir="", subdir_local=None):
        global BASE_DIR
        size = 0
        for filename in filenames:
            fullpath = os.path.join(BASE_DIR,
                subdir_local if subdir_local is not None else subdir, filename)
            zi = zipfile.ZipInfo()
            zi.filename = pathjoin(ZIP_DIR, subdir, filename)
            zi.date_time = time.localtime(os.path.getmtime(fullpath))[:6]
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.create_system = 3 # UNIX
            zi.external_attr = 0644 << 16L # Permission flag -rw-r--r--
            if os.path.splitext(filename)[-1] in [".sh"]:
                zi.external_attr = 0755 << 16L # Permission flag -rwxr-xr-x
            print("Adding %s, %s bytes" % (zi.filename, os.path.getsize(fullpath)))
            zf.writestr(zi, open(fullpath, "rb").read())
            size += os.path.getsize(fullpath)
        return size

    with zipfile.ZipFile(os.path.join(INITIAL_DIR, DEST_FILE), mode="w") as zf:
        size = 0
        for subdir, wildcard in [("res", "*"),
        (pathjoin("res", "emoticons"), "*"), ("src", "*.py"),
        ("packaging", "*"), (pathjoin("src", "third_party"), "*.py")]:
            entries = glob.glob(os.path.join(BASE_DIR, subdir, wildcard))
            files = sorted([os.path.basename(x) for x in entries
                          if os.path.isfile(x)], key=str.lower)
            files = filter(lambda x: not x.lower().endswith(".zip"), files)
            files = filter(lambda x: not x.lower().endswith(".pyc"), files)
            size += add_files(zf, files, subdir)
        rootfiles = ["CHANGELOG.md", "LICENSE.md", "README.md",
                     "requirements.txt", "skyperious.bat", "skyperious.sh"]
        size += add_files(zf, rootfiles)
        size += add_files(zf, ["skyperious.ini"],
                          subdir_local=os.path.split(PACKAGING_DIR)[-1])

    os.chdir(INITIAL_DIR)
    size_zip = os.path.getsize(DEST_FILE)
    print ("\nCreated %s, %s bytes (from %s, %.2f compression ratio)." % 
           (DEST_FILE, size_zip, size, float(size_zip) / size))

########NEW FILE########
__FILENAME__ = emoticons_to_py
#-*- coding: utf-8 -*-
"""
Simple small script for generating a nicely formatted Python module with
embedded Skype emoticon images and docstrings.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author    Erki Suurjaak
@created   26.01.2014
@modified  31.01.2014
"""
import base64
import datetime
import os
import shutil
import sys
import wx.tools.img2py

"""Target Python script to write."""
TARGET = os.path.join("..", "src", "emoticons.py")

Q3 = '"""'

# Skype emoticons
EMOTICONS = {
    "angel": {"title": "Angel", "file": "0131-angel.gif", "strings": ["(angel)"]},
    "angry": {"title": "Angry", "file": "0121-angry.gif", "strings": [":@", ":-@", ":=@", "x(", "x-(", "x=(", "X(", "X-(", "X=("]},
    "bandit": {"title": "Bandit", "file": "0174-bandit.gif", "strings": ["(bandit)"]},
    "beer": {"title": "Beer", "file": "0167-beer.gif", "strings": ["(beer)", "(b)", "(B)"]},
    "blush": {"title": "Blush", "file": "0111-blush.gif", "strings": [":$", "(blush)", ":-$", ":=$"]},
    "bow": {"title": "Bow", "file": "0139-bow.gif", "strings": ["(bow)"]},
    "brokenheart": {"title": "Broken heart", "file": "0153-brokenheart.gif", "strings": ["(u)", "(U)", "(brokenheart)"]},
    "bug": {"title": "Bug", "file": "0180-bug.gif", "strings": ["(bug)"]},
    "cake": {"title": "Cake", "file": "0166-cake.gif", "strings": ["(cake)", "(^)"]},
    "call": {"title": "Call", "file": "0129-call.gif", "strings": ["(call)"]},
    "cash": {"title": "Cash", "file": "0164-cash.gif", "strings": ["(cash)", "(mo)", "($)"]},
    "clap": {"title": "Clapping", "file": "0137-clapping.gif", "strings": ["(clap)"]},
    "coffee": {"title": "Coffee", "file": "0162-coffee.gif", "strings": ["(coffee)"]},
    "cool": {"title": "Cool", "file": "0103-cool.gif", "strings": ["8=)", "8-)", "B=)", "B-)", "(cool)"]},
    "cry": {"title": "Crying", "file": "0106-crying.gif", "strings": [";(", ";-(", ";=("]},
    "dance": {"title": "Dance", "file": "0169-dance.gif", "strings": ["(dance)", "\\o/", "\\:D/", "\\:d/"]},
    "devil": {"title": "Devil", "file": "0130-devil.gif", "strings": ["(devil)"]},
    "doh": {"title": "Doh!", "file": "0120-doh.gif", "strings": ["(doh)"]},
    "drink": {"title": "Drink", "file": "0168-drink.gif", "strings": ["(d)", "(D)"]},
    "drunk": {"title": "Drunk", "file": "0175-drunk.gif", "strings": ["(drunk)"]},
    "dull": {"title": "Dull", "file": "0114-dull.gif", "strings": ["|(", "|-(", "|=(", "|-()"]},
    "eg": {"title": "Evil grin", "file": "0116-evilgrin.gif", "strings": ["]:)", ">:)", "(grin)"]},
    "emo": {"title": "Emo", "file": "0147-emo.gif", "strings": ["(emo)"]},
    "envy": {"title": "Envy", "file": "0132-envy.gif", "strings": ["(envy)"]},
    "finger": {"title": "Finger", "file": "0173-middlefinger.gif", "strings": ["(finger)"]},
    "flower": {"title": "Flower", "file": "0155-flower.gif", "strings": ["(f)", "(F)"]},
    "fubar": {"title": "Fubar", "file": "0181-fubar.gif", "strings": ["(fubar)"]},
    "giggle": {"title": "Giggle", "file": "0136-giggle.gif", "strings": ["(chuckle)", "(giggle)"]},
    "handshake": {"title": "Shaking Hands", "file": "0150-handshake.gif", "strings": ["(handshake)"]},
    "happy": {"title": "Happy", "file": "0142-happy.gif", "strings": ["(happy)"]},
    "headbang": {"title": "Headbang", "file": "0179-headbang.gif", "strings": ["(headbang)", "(banghead)"]},
    "heart": {"title": "Heart", "file": "0152-heart.gif", "strings": ["(h)", "(H)", "(l)", "(L)"]},
    "hi": {"title": "Hi", "file": "0128-hi.gif", "strings": ["(hi)"]},
    "hug": {"title": "Hug", "file": "0134-bear.gif", "strings": ["(hug)", "(bear)"]},
    "inlove": {"title": "In love", "file": "0115-inlove.gif", "strings": ["(inlove)"]},
    "kiss": {"title": "Kiss", "file": "0109-kiss.gif", "strings": [":*", ":=*", ":-*"]},
    "laugh": {"title": "Laugh", "file": "0102-bigsmile.gif", "strings": [":D", ":=D", ":-D", ":d", ":=d", ":-d"]},
    "lipssealed": {"title": "My lips are sealed", "file": "0127-lipssealed.gif", "strings": [":x", ":-x", ":X", ":-X", ":#", ":-#", ":=x", ":=X", ":=#"]},
    "mail": {"title": "Mail", "file": "0154-mail.gif", "strings": ["(e)", "(m)"]},
    "makeup": {"title": "Make-up", "file": "0135-makeup.gif", "strings": ["(makeup)", "(kate)"]},
    "mmm": {"title": "mmmmm..", "file": "0125-mmm.gif", "strings": ["(mm)"]},
    "mooning": {"title": "Mooning", "file": "0172-mooning.gif", "strings": ["(mooning)"]},
    "movie": {"title": "Movie", "file": "0160-movie.gif", "strings": ["(~)", "(film)", "(movie)"]},
    "muscle": {"title": "Muscle", "file": "0165-muscle.gif", "strings": ["(muscle)", "(flex)"]},
    "music": {"title": "Music", "file": "0159-music.gif", "strings": ["(music)"]},
    "nerdy": {"title": "Nerd", "file": "0126-nerd.gif", "strings": ["8-|", "B-|", "8|", "B|", "8=|", "B=|", "(nerd)"]},
    "ninja": {"title": "Ninja", "file": "0170-ninja.gif", "strings": ["(ninja)"]},
    "no": {"title": "No", "file": "0149-no.gif", "strings": ["(n)", "(N)"]},
    "nod": {"title": "Nodding", "file": "0144-nod.gif", "strings": ["(nod)"]},
    "party": {"title": "Party", "file": "0123-party.gif", "strings": ["(party)"]},
    "phone": {"title": "Phone", "file": "0161-phone.gif", "strings": ["(ph)", "(mp)"]},
    "pizza": {"title": "Pizza", "file": "0163-pizza.gif", "strings": ["(pizza)", "(pi)"]},
    "poolparty": {"title": "Poolparty", "file": "0182-poolparty.gif", "strings": ["(poolparty)"]},
    "puke": {"title": "Puking", "file": "0119-puke.gif", "strings": ["(puke)", ":&", ":-&", ":=&"]},
    "punch": {"title": "Punch", "file": "0146-punch.gif", "strings": ["(punch)"]},
    "rain": {"title": "Raining", "file": "0156-rain.gif", "strings": ["(rain)", "(london)", "(st)"]},
    "rock": {"title": "Rock", "file": "0178-rock.gif", "strings": ["(rock)"]},
    "rofl": {"title": "Rolling on the floor laughing", "file": "0140-rofl.gif", "strings": ["(rofl)"]},
    "sad": {"title": "Sad", "file": "0101-sadsmile.gif", "strings": [":(", ":=(", ":-("]},
    "shake": {"title": "Shaking", "file": "0145-shake.gif", "strings": ["(shake)"]},
    "skype": {"title": "Skype", "file": "0151-skype.gif", "strings": ["(skype)", "(ss)"]},
    "sleepy": {"title": "Sleepy", "file": "0113-sleepy.gif", "strings": ["|-)", "I-)", "I=)", "(snooze)"]},
    "smile": {"title": "Smile", "file": "0100-smile.gif", "strings": [":)", ":=)", ":-)"]},
    "smirk": {"title": "Smirking", "file": "0143-smirk.gif", "strings": ["(smirk)"]},
    "smoke": {"title": "Smoking", "file": "0176-smoke.gif", "strings": ["(smoking)", "(smoke)", "(ci)"]},
    "speechless": {"title": "Speechless", "file": "0108-speechless.gif", "strings": [":|", ":=|", ":-|"]},
    "star": {"title": "Star", "file": "0171-star.gif", "strings": ["(*)"]},
    "sun": {"title": "Sun", "file": "0157-sun.gif", "strings": ["(sun)"]},
    "surprised": {"title": "Surprised", "file": "0104-surprised.gif", "strings": [":O", ":=o", ":-o", ":o", ":=O", ":-O"]},
    "swear": {"title": "Swearing", "file": "0183-swear.gif", "strings": ["(swear)"]},
    "sweat": {"title": "Sweating", "file": "0107-sweating.gif", "strings": ["(sweat)", "(:|"]},
    "talk": {"title": "Talking", "file": "0117-talking.gif", "strings": ["(talk)"]},
    "think": {"title": "Thinking", "file": "0138-thinking.gif", "strings": ["(think)", ":?", ":-?", ":=?"]},
    "time": {"title": "Time", "file": "0158-time.gif", "strings": ["(time)"]},
    "tmi": {"title": "Too much information", "file": "0184-tmi.gif", "strings": ["(tmi)"]},
    "toivo": {"title": "Toivo", "file": "0177-toivo.gif", "strings": ["(toivo)"]},
    "tongueout": {"title": "Tongue out", "file": "0110-tongueout.gif", "strings": [":P", ":=P", ":-P", ":p", ":=p", ":-p"]},
    "wait": {"title": "Wait", "file": "0133-wait.gif", "strings": ["(wait)"]},
    "wasntme": {"title": "It wasn't me!", "file": "0122-itwasntme.gif", "strings": ["(wasntme)"]},
    "whew": {"title": "Relieved", "file": "0141-whew.gif", "strings": ["(whew)"]},
    "wink": {"title": "Wink", "file": "0105-wink.gif", "strings": ["(wink)", ";)", ";-)", ";=)"]},
    "wonder": {"title": "Wondering", "file": "0112-wondering.gif", "strings": [":^)"]},
    "worry": {"title": "Worried", "file": "0124-worried.gif", "strings": [":S", ":-S", ":=S", ":s", ":-s", ":=s"]},
    "yawn": {"title": "Yawn", "file": "0118-yawn.gif", "strings": ["(yawn)"]},
    "yes": {"title": "Yes", "file": "0148-yes.gif", "strings": ["(y)", "(Y)", "(ok)"]},
    # The following do not have emoticon images in Skyperious
    "bertlett": {"title": "(bartlett)", "strings": ["(bartlett)"]},
    "facepalm": {"title": "Facepalm", "strings": ["(facepalm)"]},
    "fingerscrossed": {"title": "Fingers crossed", "strings": ["(fingerscrossed)"]},
    "heidy": {"title": "Heidy", "strings": ["(heidy)"]},
    "highfive": {"title": "High five", "strings": ["(highfive)"]},
    "hollest": {"title": "Hollest", "strings": ["(hollest)"]},
    "lalala": {"title": "Lalala", "strings": ["(lalala)"]},
    "oliver": {"title": "(oliver)", "strings": ["(oliver)"]},
    "soccer": {"title": "(soccer)", "strings": ["(soccer)"]},
    "tumbleweed": {"title": "Tumbleweed", "strings": ["(tumbleweed)"]},
    "waiting": {"title": "Waiting", "strings": ["(waiting)"]},
    "wfh": {"title": "Working from home", "strings": ["(wfh)"]},
    "wtf": {"title": "What the...", "strings": ["(wtf)"]},
}


HEADER = """%s
Contains embedded Skype emoticon image resources. Auto-generated.
Skype emoticon images are property of Skype, released under the
Skype Component License 1.0.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@created     11.06.2013
@modified    %s
------------------------------------------------------------------------------
%s
try:
    import wx
    from wx.lib.embeddedimage import PyEmbeddedImage
except ImportError:
    class PyEmbeddedImage(object):
        \"\"\"Data stand-in for wx.lib.embeddedimage.PyEmbeddedImage.\"\"\"
        def __init__(self, data):
            self.data = data
""" % (Q3, datetime.date.today().strftime("%d.%m.%Y"), Q3)



def create_py(target):
    global HEADER, EMOTICONS
    f = open(target, "w")
    f.write(HEADER)
    for name, data in sorted(EMOTICONS.items()):
        if "file" not in data: continue # continue for name, data in ..            
        f.write("\n\n%sSkype emoticon \"%s %s\".%s\n%s = PyEmbeddedImage(\n" %
                (Q3, data["title"], data["strings"][0], Q3, name))
        filename = os.path.join("emoticons", data["file"])
        raw = base64.b64encode(open(filename, "rb").read())
        while raw:
            f.write("    \"%s\"\n" % raw[:72])
            raw = raw[72:]
        f.write(")\n")
    f.write("\n\n%sEmoticon metadata: name, strings, title.%s\n"
            "EmoticonData = {\n" % (Q3, Q3))
    for name, data in sorted(EMOTICONS.items()):
        data_py = {"title": data["title"], "strings": data["strings"]}
        f.write("    \"%s\": %s,\n" % (name, data_py))
    f.write("}\n")
    f.write("\n\n%sMaps emoticon strings to emoticon names.%s\n" % (Q3, Q3))
    f.write("EmoticonStrings = dict((s, k) for k, d in EmoticonData.items()"
            " for s in d[\"strings\"])\n")
    f.close()


if "__main__" == __name__:
    create_py(TARGET)

########NEW FILE########
__FILENAME__ = images_to_py
"""
Simple small script for generating a nicely formatted Python module with
embedded binary resources and docstrings.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author    Erki Suurjaak
@created   07.02.2012
@modified  20.04.2014
------------------------------------------------------------------------------
"""
import base64
import datetime
import os
import shutil
import wx.tools.img2py

"""Target Python script to write."""
TARGET = os.path.join("..", "src", "images.py")

Q3 = '"""'

"""Application icons of different size and colour depth."""
APPICONS = {
  "Icon16x16_8bit.png":  "Skyperious application 16x16 icon, 8-bit colour.",
  "Icon16x16_32bit.png": "Skyperious application 16x16 icon, 32-bit colour.",
  "Icon24x24_8bit.png":  "Skyperious application 24x24 icon, 8-bit colour.",
  "Icon24x24_32bit.png": "Skyperious application 24x24 icon, 32-bit colour.",
  "Icon32x32_8bit.png":  "Skyperious application 32x32 icon, 8-bit colour.",
  "Icon32x32_32bit.png": "Skyperious application 32x32 icon, 32-bit colour.",
  "Icon48x48_8bit.png":  "Skyperious application 48x48 icon, 8-bit colour.",
  "Icon48x48_32bit.png": "Skyperious application 48x48 icon, 32-bit colour.",
  "Icon64x64_8bit.png":  "Skyperious application 64x64 icon, 8-bit colour.",
  "Icon64x64_32bit.png": "Skyperious application 64x64 icon, 32-bit colour.",
}
IMAGES = {
    "AvatarDefault.png":
        "Default avatar image for contacts without one.",
    "AvatarDefaultLarge.png":
        "Default large avatar image for contacts.",
    "ButtonClear.png":
        "Small icon for clear list button on start page.",
    "ButtonCompare.png":
        "Small icon for compare databases button on start and merger page.",
    "ButtonDetect.png":
        "Large icon for detect databases button on start page.",
    "ButtonFolder.png":
        "Large icon for import folder button on start page.",
    "ButtonExport.png":
        "Small icon for export button on start page.",
    "ButtonHome.png":
        "Large icon for home on start page.",
    "ButtonListDatabase.png":
        "Button for databases in database list.",
    "ButtonMergeLeft.png":
        "Small icon for left merge button on merger page.",
    "ButtonMergeLeftMulti.png":
        "Small icon for left merge multi button on merger page.",
    "ButtonOpen.png":
        "Button for open file on main page.",
    "ButtonOpenA.png":
        "Large icon for open database button on start page.",
    "ButtonRemove.png":
        "Small icon for remove database button on start page.",
    "ButtonRemoveMissing.png":
        "Small icon for remove missing button on start page.",
    "ButtonSaveAs.png":
        "Small icon for save as button on start page.",
    "ButtonScanDiff.png":
        "Small icon for scan button on merge page.",
    "ExportClock.png":
        "Clock image icon for new days in exported chat HTML.",
    "ExportEdited.png":
        "Edited image icon for edited messages in exported chat HTML.",
    "ExportRemoved.png":
        "Removed image icon for removed messages in exported chat HTML.",
    "HelpChats.png":
        "Help image on default search page for chats page.",
    "HelpContacts.png":
        "Help image on default search page for contacts import page.",
    "HelpTables.png":
        "Help image on default search page for tables page.",
    "HelpInfo.png":
        "Help image on default search page for information page.",
    "HelpSearch.png":
        "Help image on default search page for search page.",
    "HelpSQL.png":
        "Help image on default search page for SQL window page.",
    "MergeToRight.png":
        "Icon between database info on merger page",
    "PageChats.png":
        "Icon for the Chats page in a database tab.",
    "PageContacts.png":
        "Icon for the Contacts+ page in a database tab, and\n"
        "Merge Contacts page in a merger tab.",
    "PageTables.png":
        "Icon for the Data tables page in a database tab.",
    "PageInfo.png":
        "Icon for the Info page in a database tab.",
    "PageMergeAll.png":
        "Icon for the Merge All page in a merger tab.",
    "PageMergeChats.png":
        "Icon for the Merge Chats page in a merger tab.",
    "PageSearch.png":
        "Icon for the Search page in a database tab.",
    "PageSQL.png":
        "Icon for the SQL Window page in a database tab.",
    "ToolbarCommit.png":
        "Toolbar icon for commit button in database table grids.",
    "ToolbarContact.png":
        "Toolbar icon for contacts button on search page.",
    "ToolbarDelete.png":
        "Toolbar icon for delete button in database table grids.",
    "ToolbarFilter.png":
        "Toolbar icon for filter chat button in chat page.",
    "ToolbarInsert.png":
        "Toolbar icon for insert button in database table grids.",
    "ToolbarMaximize.png":
        "Toolbar icon for maximize chat button in chat page.",
    "ToolbarMessage.png":
        "Toolbar icon for message toggle button on search page.",
    "ToolbarRollback.png":
        "Toolbar icon for rollback button in database table grids.",
    "ToolbarStats.png":
        "Toolbar icon for stats button in chat page.",
    "ToolbarStop.png":
        "Toolbar icon for stop button on search page.",
    "ToolbarStopped.png":
        "Toolbar icon for inactive stop button on search page.",
    "ToolbarTables.png":
        "Toolbar icon for tables button on search page.",
    "ToolbarTabs.png":
        "Toolbar icon for tabs toggle button on search page.",
    "ToolbarTitle.png":
        "Toolbar icon for title toggle button on search page.",
}
HEADER = """%s
Contains embedded image and icon resources for Skyperious. Auto-generated.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     07.02.2012
@modified    %s
------------------------------------------------------------------------------
%s
try:
    import wx
    from wx.lib.embeddedimage import PyEmbeddedImage
except ImportError:
    class PyEmbeddedImage(object):
        \"\"\"Data stand-in for wx.lib.embeddedimage.PyEmbeddedImage.\"\"\"
        def __init__(self, data):
            self.data = data
""" % (Q3, datetime.date.today().strftime("%d.%m.%Y"), Q3)


def create_py(target):
    global HEADER, APPICONS, IMAGES
    f = open(target, "w")
    f.write(HEADER)
    icons = [os.path.splitext(i)[0] for i in sorted(APPICONS.keys())]
    icon_parts = [", ".join(icons[4*i:4*i+4]) for i in range(len(icons) / 4)]
    iconstr = ",\n        ".join(icon_parts)
    f.write("\n\n%s%s%s\ndef get_appicons():\n    icons = wx.IconBundle()\n"
            "    [icons.AddIcon(i.Icon) "
            "for i in [\n        %s\n    ]]\n    return icons\n" % (Q3,
        "Returns the application icon bundle, "
        "for several sizes and colour depths.",
        Q3, iconstr.replace("'", "").replace("[", "").replace("]", "")
    ))
    for filename, desc in sorted(APPICONS.items()):
        name, extension = os.path.splitext(filename)
        f.write("\n\n%s%s%s\n%s = PyEmbeddedImage(\n" % (Q3, desc, Q3, name))
        data = base64.b64encode(open(filename, "rb").read())
        while data:
            f.write("    \"%s\"\n" % data[:72])
            data = data[72:]
        f.write(")\n")
    for filename, desc in sorted(IMAGES.items()):
        name, extension = os.path.splitext(filename)
        f.write("\n\n%s%s%s\n%s = PyEmbeddedImage(\n" % (Q3, desc, Q3, name))
        data = base64.b64encode(open(filename, "rb").read())
        while data:
            f.write("    \"%s\"\n" % data[:72])
            data = data[72:]
        f.write(")\n")
    f.close()


if "__main__" == __name__:
    create_py(TARGET)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
"""
Application settings, and functionality to save/load some of them from
an external file. Configuration file has simple INI file format,
and all values are kept in JSON.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     26.11.2011
@modified    08.05.2014
------------------------------------------------------------------------------
"""
from ConfigParser import RawConfigParser
import datetime
import json
import os
import sys
import urllib

import util

"""Program title, version number and version date."""
Title = "Skyperious"
Version = "3.2"
VersionDate = "08.05.2014"

if getattr(sys, "frozen", False):
    # Running as a pyinstaller executable
    ApplicationDirectory = os.path.dirname(sys.executable)
    ResourceDirectory = os.path.join(getattr(sys, "_MEIPASS", ""), "res")
else:
    ApplicationDirectory = os.path.dirname(os.path.dirname(__file__))
    ResourceDirectory = os.path.join(ApplicationDirectory, "res")

"""Name of file where FileDirectives are kept."""
ConfigFile = "%s.ini" % os.path.join(ApplicationDirectory, Title.lower())

"""List of attribute names that can be saved to and loaded from ConfigFile."""
FileDirectives = ["ConsoleHistoryCommands", "DBDoBackup",  "DBFiles",
    "ErrorsReportedOnDay", "ErrorReportsAutomatic", "ErrorReportHashes",
    "LastActivePage", "LastSearchResults", "LastSelectedFiles",
    "LastUpdateCheck", "RecentFiles", "SearchHistory", "SearchInChatInfo",
    "SearchInContacts", "SearchInMessages", "SearchUseNewTab",
    "SearchInTables", "SQLWindowTexts", "TrayIconEnabled",
    "UpdateCheckAutomatic", "WindowIconized", "WindowPosition", "WindowSize",
]
"""Map of attribute names from old version to new, retain values on upgrade."""
FileDirectiveCompatiblity = {
    "SearchInNewTab" : "SearchUseNewTab",
    "SearchInMessageBody": "SearchInMessages",
}
"""List of attributes saved if changed from default."""
OptionalFileDirectives = ["ExportChatTemplate", "ExportDbTemplate", "LogSQL",
    "MinWindowSize", "MaxConsoleHistory", "MaxHistoryInitialMessages",
    "MaxRecentFiles", "MaxSearchHistory", "MaxSearchMessages",
    "MaxSearchTableRows", "SearchContactsChunk", "SearchResultsChunk",
    "StatisticsPlotWidth", "StatusFlashLength", "UpdateCheckInterval",
]
OptionalFileDirectiveDefaults = {}

"""---------------------------- FileDirectives: ----------------------------"""

"""Whether a backup copy is made of a database before it's changed."""
DBDoBackup = False

"""All detected/added databases."""
DBFiles = []

"""History of commands entered in console."""
ConsoleHistoryCommands = []

"""Whether caught errors are reported automatically to author."""
ErrorReportsAutomatic = False

"""Errors reported on day X, e.g. {'20130530': 4, '20130531': 1, }."""
ErrorsReportedOnDay = {}

"""Saved hashes of automatically reported errors."""
ErrorReportHashes = []

"""Index of last active page in database tab, {db path: index}."""
LastActivePage = {}

"""HTMLs of last search result, {db path: {"content", "info", "title"}}."""
LastSearchResults = {}

"""Files selected in the database lists on last run."""
LastSelectedFiles = ["", ""]

"""Contents of Recent Files menu."""
RecentFiles = []

"""
Texts entered in chat global search, used for drop down auto-complete.
Last value can be an empty string: search box had no text.
"""
SearchHistory = []

"""Whether to search in chat title and participants."""
SearchInChatInfo = False

"""Whether to search in contact information."""
SearchInContacts = False

"""Whether to search in message body."""
SearchInMessages = True

"""Whether to create a new tab for each search or reuse current."""
SearchUseNewTab = True

"""Whether to search in all columns of all tables."""
SearchInTables = False

"""Texts in SQL window, loaded on reopening a database {filename: text, }."""
SQLWindowTexts = {}

"""Chat export filename template, format can use Skype.Conversations data."""
ExportChatTemplate = u"Skype %(title_long_lc)s"

"""Database export filename template, format can use Skype.Accounts data."""
ExportDbTemplate = u"Export from %(fullname)s"

"""Whether the program tray icon is used."""
TrayIconEnabled = True

"""Whether the program checks for updates every UpdateCheckInterval."""
UpdateCheckAutomatic = True

"""Whether the program has been minimized and hidden."""
WindowIconized = False

"""Main window position, (x, y)."""
WindowPosition = None

"""Main window size in pixels, [w, h] or [-1, -1] for maximized."""
WindowSize = (1080, 710)

"""---------------------------- /FileDirectives ----------------------------"""

"""Whether logging to log window is enabled."""
LogEnabled = True

"""Whether to log all SQL statements to log window."""
LogSQL = False

"""URLs for download list, changelog, submitting feedback and homepage."""
DownloadURL  = "http://erki.lap.ee/downloads/Skyperious/"
ChangelogURL = "http://suurjaak.github.com/Skyperious/changelog.html"
ReportURL    = "http://erki.lap.ee/downloads/Skyperious/feedback"
HomeUrl = "http://suurjaak.github.com/Skyperious/"

"""Maximum number of error reports sent per day."""
ErrorReportsPerDay = 5

"""Maximum number of error hashes and report days to keep."""
ErrorsStoredMax = 1000

"""Minimum allowed size for the main window, as (width, height)."""
MinWindowSize = (600, 400)

"""Console window size in pixels, (width, height)."""
ConsoleSize = (800, 300)

"""Maximum number of console history commands to store."""
MaxConsoleHistory = 1000

"""Maximum number of search texts to store."""
MaxSearchHistory = 500

"""Days between automatic update checks."""
UpdateCheckInterval = 7

"""Date string of last time updates were checked."""
LastUpdateCheck = None

"""Maximum number of messages shown initially in chat history."""
MaxHistoryInitialMessages = 1500

"""Maximum length of a tab title, overflow will be cut on the left."""
MaxTabTitleLength = 60

"""
Maximum number of messages to show in search results.
"""
MaxSearchMessages = 500

"""Maximum number of table rows to show in search results."""
MaxSearchTableRows = 500

"""Number of search results to yield in one chunk from search thread."""
SearchResultsChunk = 50

"""Number of contact search results to yield in one chunk."""
SearchContactsChunk = 10

"""Name of font used in chat history."""
HistoryFontName = "Tahoma"

"""Font size in chat history."""
HistoryFontSize = 8

"""Window background colour."""
BgColour = "#FFFFFF"

"""Text colour."""
FgColour = "#000000"

"""Main screen background colour."""
MainBgColour = "#FFFFFF"

"""Widget (button etc) background colour."""
WidgetColour = "#D4D0C8"

"""Default text colour for chat messages."""
MessageTextColour = "#202020"

"""Foreground colour for gauges."""
GaugeColour = "#008000"

"""Disabled text colour."""
DisabledColour = "#808080"

"""Table border colour in search help."""
HelpBorderColour = "#D4D0C8"

"""Code element text colour in search help."""
HelpCodeColour = "#006600"

"""Colour for clickable links."""
LinkColour = "#0000FF"

"""Colour for in-message links in export."""
ExportLinkColour = "#3399FF"

"""Colours for main screen database list."""
DBListBackgroundColour = "#ECF4FC"
DBListForegroundColour = "#000000"

"""Background colour of exported chat history."""
HistoryBackgroundColour = "#8CBEFF"

"""Colour used for timestamps in chat history."""
HistoryTimestampColour = "#999999"

"""Colour used for remote authors in chat history."""
HistoryRemoteAuthorColour = "#3399FF"

"""Colour used for local authors in chat history."""
HistoryLocalAuthorColour = "#999999"

"""Colour used for greyed items in chat history."""
HistoryGreyColour = "#999999"

"""Colour used for clickable links in chat history"""
SkypeLinkColour = "#3399FF"

"""Default colour in chat history."""
HistoryLineColour = "#E4E8ED"

"""Descriptive text shown in chat history searchbox."""
HistorySearchDescription = "Search for.."

"""Background colour of opened items in lists."""
ListOpenedBgColour = "pink"

"""Foreground colour for error labels."""
LabelErrorColour = "#CC3232"

"""Color set to database table list tables that have been changed."""
DBTableChangedColour = "red"

"""Color set to the database table list table that is currently open."""
DBTableOpenedColour = "pink"

"""Colour set to table/list rows that have been changed."""
GridRowChangedColour = "#FFCCCC"

"""Colour set to table/list rows that have been inserted."""
GridRowInsertedColour = "#88DDFF"

"""Colour set to table/list cells that have been changed."""
GridCellChangedColour = "#FF7777"

"""Background colour for merge page HtmlWindow with scan results."""
MergeHtmlBackgroundColour = "#ECF4FC"

"""Colour for messages plot in chat statistics."""
PlotMessagesColour = "#3399FF"

"""Colour for SMSes plot in chat statistics."""
PlotSMSesColour = "#FFB333"

"""Colour for calls plot in chat statistics."""
PlotCallsColour = "#FF6C91"

"""Colour for files plot in chat statistics."""
PlotFilesColour = "#33DD66"

"""Background colour for plots in chat statistics."""
PlotBgColour = "#DDDDDD"

"""
Width and height tuple of the avatar image, shown in chat data and export HTML
statistics."""
AvatarImageSize = (32, 32)

"""Width and height tuple of the large avatar image, shown in HTML export."""
AvatarImageLargeSize = (96, 96)

"""Width of the chat statistics plots, in pixels."""
StatisticsPlotWidth = 350

"""Duration of "flashed" status message on StatusBar, in milliseconds."""
StatusFlashLength = 30000

"""How many items in the Recent Files menu."""
MaxRecentFiles = 20

"""Font files used for measuring text extent in export."""
FontXlsxFile = os.path.join(ResourceDirectory, "Carlito.ttf")
FontXlsxBoldFile = os.path.join(ResourceDirectory, "CarlitoBold.ttf")


def load():
    """Loads FileDirectives from ConfigFile into this module's attributes."""
    section = "*"
    module = sys.modules[__name__]
    parser = RawConfigParser()
    parser.optionxform = str # Force case-sensitivity on names
    try:
        parser.read(ConfigFile)

        def parse_value(name):
            try: # parser.get can throw an error if not found
                value_raw = parser.get(section, name)
            except Exception:
                return False, None
            # First, try to interpret as JSON
            try:
                value = json.loads(value_raw)
            except ValueError: # JSON failed, try to eval it
                try:
                    value = eval(value_raw)
                except SyntaxError: # Fall back to string
                    value = value_raw
            return True, value

        for oldname, name in FileDirectiveCompatiblity.items():
            [setattr(module, name, v) for s, v in [parse_value(oldname)] if s]
        for name in FileDirectives:
            [setattr(module, name, v) for s, v in [parse_value(name)] if s]
        for name in OptionalFileDirectives:
            OptionalFileDirectiveDefaults[name] = getattr(module, name, None)
            success, value = parse_value(name)
            if success:
                setattr(module, name, value)
    except Exception:
        pass # Fail silently


def save():
    """Saves FileDirectives into ConfigFile."""
    section = "*"
    module = sys.modules[__name__]
    parser = RawConfigParser()
    parser.optionxform = str # Force case-sensitivity on names
    parser.add_section(section)
    try:
        f, fname = open(ConfigFile, "wb"), util.longpath(ConfigFile)
        f.write("# %s configuration autowritten on %s.\n" %
                (fname, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        for name in FileDirectives:
            try:
                value = getattr(module, name)
                parser.set(section, name, json.dumps(value))
            except Exception:
                pass
        for name in OptionalFileDirectives:
            try:
                value = getattr(module, name, None)
                if OptionalFileDirectiveDefaults.get(name) != value:
                    parser.set(section, name, json.dumps(value))
            except Exception:
                pass
        parser.write(f)
        f.close()
    except Exception:
        pass # Fail silently

########NEW FILE########
__FILENAME__ = controls
# -*- coding: utf-8 -*-
"""

Stand-alone GUI components for wx:

- BusyPanel(wx.Window):
  Primitive hover panel with a message that stays in the center of parent
  window.

- EntryDialog(wx.Dialog):
  Non-modal text entry dialog with auto-complete dropdown, appears in lower
  right corner.

- NonModalOKDialog(wx.Dialog):
  A simple non-modal dialog with an OK button, stays on top of parent.

- NoteButton(wx.PyPanel, wx.Button):
  A large button with a custom icon, main label, and additional note.
  Inspired by wx.CommandLinkButton, which does not support custom icons
  (at least not of wx 2.9.4).

- PropertyDialog(wx.Dialog):
  Dialog for displaying an editable property grid. Supports strings,
  integers, booleans, and tuples interpreted as wx.Size.

- ProgressWindow(wx.Dialog):
  A simple non-modal ProgressDialog, stays on top of parent frame.

- RangeSlider(wx.PyPanel):
  A horizontal slider with two markers for selecting a value range. Supports
  numeric and date/time values.

- ScrollingHtmlWindow(wx.html.HtmlWindow):
  HtmlWindow that remembers its scroll position on resize.
    
- SearchableStyledTextCtrl(wx.PyPanel):
  A wx.stc.StyledTextCtrl with a search bar that appears on demand, top or
  bottom of the control.
  Search bar has a text box, next-previous buttons, search options and a
  close button. Next/previous buttons set search direction: after clicking
  "Previous", pressing Enter in search box searches upwards.

- SortableListView(wx.ListView, wx.lib.mixins.listctrl.ColumnSorterMixin):
  A sortable list view that can be batch-populated, autosizes its columns.

- SQLiteTextCtrl(wx.stc.StyledTextCtrl):
  A StyledTextCtrl configured for SQLite syntax highlighting.

- TabbedHtmlWindow(wx.PyPanel):
  wx.html.HtmlWindow with tabs for different content pages.
    
- TextCtrlAutoComplete(wx.TextCtrl):
  A text control with autocomplete using a dropdown list of choices. During
  typing, the first matching choice is appended to textbox value, with the
  appended text auto-selected.
  If wx.PopupWindow is not available (Mac), behaves like a common TextCtrl.
  Based on TextCtrlAutoComplete by Michele Petrazzo, from a post
  on 09.02.2006 in wxPython-users thread "TextCtrlAutoComplete",
  http://wxpython-users.1045709.n5.nabble.com/TextCtrlAutoComplete-td2348906.html

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     13.01.2012
@modified    27.04.2014
------------------------------------------------------------------------------
"""
import ast
import collections
import datetime
import locale
import operator
import os
import re
import sys
import wx
import wx.html
import wx.lib.agw.flatnotebook
import wx.lib.agw.gradientbutton
import wx.lib.agw.shapedbutton
import wx.lib.embeddedimage
import wx.lib.mixins.listctrl
import wx.lib.newevent
import wx.lib.wordwrap
import wx.stc



class BusyPanel(wx.Window):
    """
    Primitive hover panel with a message that stays in the center of parent
    window.
    """
    FOREGROUND_COLOUR = wx.WHITE
    BACKGROUND_COLOUR = wx.Colour(110, 110, 110, 255)

    def __init__(self, parent, label):
        wx.Window.__init__(self, parent)
        self.Hide()
        sizer = self.Sizer = wx.BoxSizer(wx.VERTICAL)
        label = self._label = wx.StaticText(parent=self, label=label)
        self.BackgroundColour = self.BACKGROUND_COLOUR
        label.ForegroundColour = self.FOREGROUND_COLOUR
        sizer.Add(label, border=15, flag=wx.ALL | wx.ALIGN_CENTER_HORIZONTAL)
        self.Fit()
        self.Layout()
        self.CenterOnParent()
        self.Show()
        parent.Refresh()
        wx.YieldIfNeeded()


    def Close(self):
        try:
            self.Hide()
            self.Parent.Refresh()
            self.Destroy()
        except Exception: pass
        


class NonModalOKDialog(wx.Dialog):
    """A simple non-modal dialog with an OK button, stays on top of parent."""

    def __init__(self, parent, title, message):
        wx.Dialog.__init__(self, parent=parent, title=title,
                           style=wx.CAPTION | wx.CLOSE_BOX | 
                                 wx.FRAME_FLOAT_ON_PARENT)

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        self.label_message = wx.StaticText(self, label=message)
        self.Sizer.Add(self.label_message, proportion=1,
                       border=2*8, flag=wx.ALL)
        sizer_buttons = self.CreateButtonSizer(wx.OK)
        self.Sizer.Add(sizer_buttons, proportion=0, border=8,
                       flag=wx.ALIGN_CENTER | wx.BOTTOM)
        self.Bind(wx.EVT_BUTTON, self.OnClose, id=wx.ID_OK)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Fit()
        self.Layout()
        self.CenterOnParent()
        self.Show()


    def OnClose(self, event):
        self.Close()
        event.Skip()



class EntryDialog(wx.Dialog):
    """
    Non-modal text entry dialog with auto-complete dropdown, appears in lower
    right corner.
    Fires a wx.EVT_COMMAND_ENTER event on pressing Enter or button.
    """
    HIDE_TIMEOUT = 1500 # Milliseconds to wait for hiding after losing focus

    def __init__(self, parent, title, label="", value="", emptyvalue="", tooltip="", choices=[]):
        """
        @param   title       dialog window title
        @param   label       label before text entry, if any
        @param   value       default value of text entry
        @param   emptyvalue  gray text shown in text box if empty and unfocused
        @param   tooltip     tooltip shown for enter button
        """
        style = wx.CAPTION | wx.CLOSE_BOX | wx.STAY_ON_TOP
        wx.Dialog.__init__(self, parent=parent, title=title, style=style)
        self._hider = None # Hider callback wx.Timer

        if label:
            label_text = self._label = wx.StaticText(self, label=label)
        text = self._text = TextCtrlAutoComplete(
            self, description=emptyvalue, size=(200, -1),
            style=wx.TE_PROCESS_ENTER)
        tb = wx.ToolBar(parent=self, style=wx.TB_FLAT | wx.TB_NODIVIDER)

        text.Value = value
        text.SetChoices(choices)
        bmp = wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD, wx.ART_TOOLBAR,
                                       (16, 16))
        tb.SetToolBitmapSize(bmp.Size)
        tb.AddLabelTool(wx.ID_FIND, "", bitmap=bmp, shortHelp=tooltip)
        tb.Realize()

        self.Bind(wx.EVT_ACTIVATE, self._OnActivate, self)
        text.Bind(wx.EVT_KEY_DOWN, self._OnKeyDown)
        self.Bind(wx.EVT_TEXT_ENTER, self._OnSearch, text)
        self.Bind(wx.EVT_TOOL, self._OnSearch, id=wx.ID_FIND)
        self.Bind(wx.EVT_LIST_DELETE_ALL_ITEMS, self._OnClearChoices, text)

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_top = wx.BoxSizer(wx.HORIZONTAL)
        if label:
            sizer_top.Add(label_text, flag=wx.ALIGN_CENTER_VERTICAL |
                          wx.LEFT, border=5)
        sizer_top.Add(text, flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=5)
        sizer_top.Add(tb, flag=wx.LEFT | wx.RIGHT |
                      wx.ALIGN_CENTER_VERTICAL, border=5)
        self.Sizer.Add(sizer_top, flag=wx.GROW | wx.TOP | wx.BOTTOM, border=5)
        self.Fit()
        x, y, w, h = wx.GetClientDisplayRect()
        self.Position = (x + w - self.Size.width, y + h - self.Size.height)
        self._pos_last = self.Position
        self._displayrect_last = (x, y, w, h)



    def Show(self, show=True):
        """Shows or hides the window, and raises it if shown."""
        if show:
            x, y, w, h = wx.GetClientDisplayRect()
            if (x, y, w, h) != self._displayrect_last:     # Display size has
                self.Position = (x + w - self.Size.width,  # changed, move to
                                 y + h - self.Size.height) # screen corner.
                self._displayrect_last = (x, y, w, h)
            self.Raise()
            self._text.SetFocus()
        wx.Dialog.Show(self, show)


    def GetValue(self):
        """Returns the text box value."""
        return self._text.Value
    def SetValue(self, value):
        """Sets the text box value."""
        self._text.Value = value
    Value = property(GetValue, SetValue)


    def SetChoices(self, choices):
        """Sets the auto-complete choices for text box."""
        self._text.SetChoices(choices)


    def _OnActivate(self, event):
        if not (event.Active or self._hider):
            self._hider = wx.CallLater(self.HIDE_TIMEOUT, self.Hide)
        elif event.Active and self._hider: # Kill the hiding timeout, if any
            self._hider.Stop()
            self._hider = None


    def _OnKeyDown(self, event):
        if wx.WXK_ESCAPE == event.KeyCode and not self._text.IsDropDownShown():
            self.Hide()
        event.Skip()


    def _OnSearch(self, event):
        findevent = wx.CommandEvent(wx.wxEVT_COMMAND_ENTER, self.GetId())
        wx.PostEvent(self, findevent)


    def _OnClearChoices(self, event):
        choice = wx.MessageBox("Clear search history?", self.Title,
                               wx.OK | wx.CANCEL | wx.ICON_QUESTION)
        if wx.OK == choice:
            self._text.SetChoices([])



class NoteButton(wx.PyPanel, wx.Button):
    """
    A large button with a custom icon, main label, and additional note.
    Inspired by wx.CommandLinkButton, which does not support custom icons
    (at least not of wx 2.9.4).
    """

    """Stipple bitmap for focus marquee line."""
    BMP_MARQUEE = None

    def __init__(self, parent, label=wx.EmptyString, note=wx.EmptyString,
                 bmp=wx.NullBitmap, id=-1, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, name=wx.PanelNameStr):
        """
        @param   
        """
        wx.PyPanel.__init__(self, parent, id, pos, size,
                            style | wx.FULL_REPAINT_ON_RESIZE, name)
        self._label = label
        self._note = note
        self._bmp = bmp
        self._bmp_disabled = bmp
        if bmp is not None and bmp.IsOk():
            img = bmp.ConvertToImage().ConvertToGreyscale()
            self._bmp_disabled = wx.BitmapFromImage(img) if img.IsOk() else bmp
        self._hover = False # Whether button is being mouse hovered
        self._press = False # Whether button is being mouse pressed
        self._align = style & (wx.ALIGN_RIGHT | wx.ALIGN_CENTER)
        self._enabled = True
        self._size = self.Size

        # Wrapped texts for both label and note
        self._text_label = None
        self._text_note = None
        # (width, height, lineheight) for wrapped texts in current DC
        self._extent_label = None
        self._extent_note = None

        self._cursor_hover   = wx.StockCursor(wx.CURSOR_HAND)
        self._cursor_default = wx.StockCursor(wx.CURSOR_DEFAULT)

        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouseEvent)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLostEvent)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_SET_FOCUS, self.OnFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnFocus)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)

        self.SetCursor(self._cursor_hover)
        fgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT)
        bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNFACE)
        self.ForegroundColour, self.BackgroundColour = fgcolour, bgcolour
        self.WrapTexts()


    def GetMinSize(self):
        return self.DoGetBestSize()


    def DoGetBestSize(self):
        w = 100 if self.Size.width < 100 else self.Size.width
        h = 40 if self.Size.height < 40 else self.Size.height
        if self._extent_label:    
            h1 = 10 + self._bmp.Size.height + 10
            h2 = 10 + self._extent_label[1] + 10 + self._extent_note[1] + 10
            h  = max(h1, h2)
        size = wx.Size(w, h)

        return size


    def Draw(self, dc):
        """Draws the control on the given device context."""
        width, height = self.GetClientSize()
        if not self.Shown or not (width > 20 and height > 20):
            return
        if not self._extent_label:
            self.WrapTexts()

        PEN = lambda c, w=1, s=wx.SOLID: wx.ThePenList.FindOrCreatePen(c, w, s)
        BRUSH = lambda c, s=wx.SOLID: wx.TheBrushList.FindOrCreateBrush(c, s)
        x, y = 10, 10
        if (self._align & wx.ALIGN_RIGHT):
            x = width - 10 - self._bmp.Size.width
        elif (self._align & wx.ALIGN_CENTER):
            x = 10 + (width - self.DoGetBestSize().width) / 2

        dc.Font = self.Font
        dc.Brush = BRUSH(self.BackgroundColour, wx.SOLID)
        if self.IsThisEnabled():
            dc.TextForeground = self.ForegroundColour
        else:
            graycolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
            dc.TextForeground = graycolour
        dc.Pen = PEN(dc.TextForeground)
        dc.Clear()

        is_focused = (self.FindFocus() == self)
        if self._press or (is_focused and wx.GetKeyState(wx.WXK_SPACE)):
            # Button is being clicked with mouse: create sunken effect.
            colours = [(128, 128, 128)] * 2
            lines   = [(1, 1, width - 2, 1), (1, 1, 1, height - 2)]
            dc.DrawLineList(lines, [PEN(wx.Colour(*c)) for c in colours])
            x += 1; y += 1
        elif self._hover and self.IsThisEnabled():
            # Button is being hovered with mouse: create raised effect.
            colours  = [(255, 255, 255)] * 2
            if wx.WHITE == self.BackgroundColour:
                colours =  [(158, 158, 158)] * 2
            lines    = [(0, 0, 0, height - 1), (0, 0, width - 1, 0)]
            colours += [(128, 128, 128)] * 2
            lines   += [(1, height - 2, width - 1, height - 2),
                        (width - 2, 1, width - 2, height - 2)]
            colours += [(64, 64, 64)] * 2
            lines   += [(0, height - 1, width, height - 1),
                        (width - 1, 0, width - 1, height - 1)]
            dc.DrawLineList(lines, [PEN(wx.Colour(*c)) for c in colours])

        if self._bmp:
            bmp = self._bmp if self.IsThisEnabled() else self._bmp_disabled
            dc.DrawBitmap(bmp, x, y)

        if self._align & wx.ALIGN_RIGHT:
            x -= 10 + max(self._extent_label[0], self._extent_note[0])
        else:
            x += self._bmp.Size.width + 10

        # Draw label and accelerator key underlines
        dc.Font = wx.Font(dc.Font.PointSize, dc.Font.Family, dc.Font.Style,
                          wx.FONTWEIGHT_BOLD, face=dc.Font.FaceName)
        text_label = self._text_label
        if "&" in self._label:
            text_label, h, lines = "", y - 1, []
            for line in self._text_label.split("\n"):
                i, chars = 0, ""
                while i < len(line):
                    if "&" == line[i]:
                        i += 1
                        if i < len(line) and "&" != line[i]:
                            extent = dc.GetTextExtent(line[i])
                            extent_all = dc.GetTextExtent(chars)
                            x1, y1 = x + extent_all[0], h + extent[1]
                            dc.DrawLine(x1, y1, x1 + extent[0], y1)
                        elif i < len(line):
                            chars += line[i] # Double ampersand: add as one.
                    if i < len(line):
                        chars += line[i]
                    i += 1
                h += self._extent_label[2]
                text_label += chars + "\n"
        dc.DrawText(text_label, x, y)

        # Draw note
        _, label_h, _ = dc.GetMultiLineTextExtent(self._text_label)
        y += label_h + 10
        dc.Font = self.Font
        dc.DrawText(self._text_note, x, y)

        if is_focused or not self.IsThisEnabled():
            # Draw simple border around button
            dc.Brush = wx.TRANSPARENT_BRUSH
            dc.DrawRectangle(0, 0, width, height)

            # Button is focused: draw focus marquee.
            if is_focused:
                if not NoteButton.BMP_MARQUEE:
                    NoteButton.BMP_MARQUEE = wx.EmptyBitmap(2, 2)
                    dc_bmp = wx.MemoryDC()
                    dc_bmp.SelectObject(NoteButton.BMP_MARQUEE)
                    dc_bmp.Background = wx.Brush(self.BackgroundColour)
                    dc_bmp.Clear()
                    dc_bmp.Pen = wx.Pen(self.ForegroundColour)
                    dc_bmp.DrawPointList([(0, 1), (1, 0)])
                    dc_bmp.SelectObject(wx.NullBitmap)
                pen = PEN(dc.TextForeground, 1, wx.STIPPLE)
                pen.Stipple, dc.Pen = NoteButton.BMP_MARQUEE, pen
                dc.DrawRectangle(4, 4, width - 8, height - 8)


    def WrapTexts(self):
        """Wraps button texts to current control size."""
        width, height = self.Size
        label = self._label
        self._text_label = label
        self._text_note = self._note
        WORDWRAP = wx.lib.wordwrap.wordwrap
        if width > 20 and height > 20:
            dc = wx.ClientDC(self)
        else: # Not properly sized yet: assume a reasonably fitting size
            dc, width, height = wx.MemoryDC(), 500, 100
        dc.Font = self.Font
        x = 10 + self._bmp.Size.width + 10
        self._text_note = WORDWRAP(self._text_note, width - 10 - x, dc)
        dc.Font = wx.Font(dc.Font.PointSize, dc.Font.Family, dc.Font.Style,
                          wx.FONTWEIGHT_BOLD, face=dc.Font.FaceName)
        self._text_label = WORDWRAP(self._text_label, width - 10 - x, dc)
        self._extent_label = dc.GetMultiLineTextExtent(self._text_label)
        self._extent_note = dc.GetMultiLineTextExtent(self._text_note)


    def OnPaint(self, event):
        """Handler for paint event, calls """
        dc = wx.BufferedPaintDC(self)
        self.Draw(dc)


    def OnSize(self, event):
        """Handler for size event, resizes texts and repaints control."""
        if event.Size != self._size:
            self._size = event.Size
            wx.CallAfter(lambda: self and (self.WrapTexts(), self.Refresh(),
                         self.InvalidateBestSize(), self.Parent.Layout()))
        event.Skip()


    def OnFocus(self, event):
        """Handler for receiving/losing focus, repaints control."""
        if self: # Might get called when control already destroyed
            self.Refresh()
            

    def OnEraseBackground(self, event):
        """Handles the wx.EVT_ERASE_BACKGROUND event."""
        pass # Intentionally empty to reduce flicker.


    def OnKeyDown(self, event):
        """Refreshes display if pressing space."""
        if not event.AltDown() and event.UnicodeKey in [wx.WXK_SPACE]:
            self.Refresh()


    def OnKeyUp(self, event):
        """Fires button event on releasing space or enter."""
        skip = True
        if not event.AltDown():
            key = event.UnicodeKey
            if key in [wx.WXK_SPACE, wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER]:
                button_event = wx.PyCommandEvent(wx.EVT_BUTTON.typeId, self.Id)
                button_event.EventObject = self
                wx.PostEvent(self, button_event)
                skip = False
                self.Refresh()
        if skip:
            event.Skip()


    def OnMouseEvent(self, event):
        """
        Mouse handler, creates hover/press border effects and fires button
        event on click.
        """
        refresh = False
        if event.Entering():
            refresh = True
            self._hover = True
            if self.HasCapture():
                self._press = True
        elif event.Leaving():
            refresh = True
            self._hover = self._press = False
        elif event.LeftDown():
            refresh = True
            self._press = True
            self.CaptureMouse()
        elif event.LeftUp():
            refresh = True
            self._press = False
            if self.HasCapture():
                self.ReleaseMouse()
                if self._hover:
                    btnevent = wx.PyCommandEvent(wx.EVT_BUTTON.typeId, self.Id)
                    btnevent.EventObject = self
                    wx.PostEvent(self, btnevent)
        if refresh:
            self.Refresh()
        event.Skip()


    def OnMouseCaptureLostEvent(self, event):
        """Handles MouseCaptureLostEvent, updating control UI if needed."""
        self._hover = self._press = False


    def ShouldInheritColours(self):
        return True


    def InheritsBackgroundColour(self):
        return True


    def Enable(self, enable=True):
        """
        Enable or disable this control for user input, returns True if the
        control state was changed.
        """
        self._enabled = enable
        result = wx.PyPanel.Enable(self, enable)
        if result:
            self.Refresh()
        return result


    def IsThisEnabled(self):
        """Returns the internal enabled state, independent of parent state."""
        if hasattr(wx.PyPanel, "IsThisEnabled"):
            result = wx.PyPanel.IsThisEnabled(self)
        else:
            result = self._enabled
        return result


    def GetLabel(self):
        return self._label
    def SetLabel(self, label):
        if label != self._label:
            self._label = label
            self.WrapTexts()
            self.InvalidateBestSize()
            self.Refresh()
    Label = property(GetLabel, SetLabel)


    def SetNote(self, note):
        if note != self._note:
            self._note = note
            self.WrapTexts()
            self.InvalidateBestSize()
            self.Refresh()
    def GetNote(self):
        return self._note
    Note = property(GetNote, SetNote)



class PropertyDialog(wx.Dialog):
    """
    Dialog for displaying an editable property grid. Supports strings,
    integers, booleans, and wx classes like wx.Size interpreted as tuples.
    """

    COLOUR_ERROR = wx.RED

    def __init__(self, parent, title):
        wx.Dialog.__init__(self, parent=parent, title=title,
                          style=wx.CAPTION | wx.CLOSE_BOX | wx.RESIZE_BORDER)
        self.properties = [] # [(name, type, orig_val, default, label, ctrl), ]

        panelwrap = wx.Panel(self)
        panel = self.panel = wx.lib.scrolledpanel.ScrolledPanel(panelwrap)

        button_save = wx.Button(panelwrap, label="Save")
        button_reset = wx.Button(panelwrap, label="Restore defaults")
        button_cancel = wx.Button(panelwrap, label="Cancel", id=wx.CANCEL)

        self.Bind(wx.EVT_BUTTON, self._OnSave, button_save)
        self.Bind(wx.EVT_BUTTON, self._OnReset, button_reset)
        self.Bind(wx.EVT_BUTTON, self._OnCancel, button_cancel)

        button_save.SetDefault()
        self.SetEscapeId(wx.CANCEL)

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        panelwrap.Sizer = wx.BoxSizer(wx.VERTICAL)
        panel.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_buttons = wx.BoxSizer(wx.HORIZONTAL)
        sizer_items = self.sizer_items = wx.GridBagSizer(hgap=5, vgap=1)

        panel.Sizer.Add(sizer_items, proportion=1, border=5, flag=wx.GROW | wx.RIGHT)
        panelwrap.Sizer.Add(panel, proportion=1, border=10, flag=wx.GROW | wx.ALL)
        [sizer_buttons.Add(b, border=10, flag=wx.LEFT)
         for b in (button_save, button_reset, button_cancel)]
        panelwrap.Sizer.Add(sizer_buttons, border=10, flag=wx.ALL | wx.ALIGN_RIGHT)
        self.Sizer.Add(panelwrap, proportion=1, flag=wx.GROW)

        self.MinSize, self.Size = (320, 180), (420, 420)
        self.BackgroundColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)


    def AddProperty(self, name, value, help="", default=None, typeclass=unicode):
        """Adds a property to the frame."""
        row = len(self.properties) * 2
        label = wx.StaticText(self.panel, label=name)
        if bool == typeclass:
            ctrl = wx.CheckBox(self.panel)
            ctrl_flag = wx.ALIGN_CENTER_VERTICAL
        else:
            ctrl = wx.TextCtrl(self.panel, style=wx.BORDER_SIMPLE)
            ctrl_flag = wx.GROW | wx.ALIGN_CENTER_VERTICAL
        tip = wx.StaticText(self.panel, label=help)

        ctrl.Value = self._GetValueForCtrl(value, typeclass)
        ctrl.ToolTipString = label.ToolTipString = "Type %s%s." % (
            typeclass.__name__,
            "" if default is None else ", default value %s" % (default, ))
        tip.ForegroundColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
        tipfont, tipfont.PixelSize = tip.Font, (0, 9)
        tip.Font = tipfont

        self.sizer_items.Add(label, pos=(row, 0), flag=wx.ALIGN_CENTER_VERTICAL)
        self.sizer_items.Add(ctrl, pos=(row, 1), flag=ctrl_flag)
        self.sizer_items.Add(tip, pos=(row + 1, 0), span=(1, 2),
                             flag=wx.BOTTOM, border=3)
        self.properties.append((name, typeclass, value, default, label, ctrl))


    def Realize(self):
        """Lays out the properties, to be called when adding is completed."""
        self.panel.SetupScrolling(scroll_x=False)
        self.sizer_items.AddGrowableCol(1) # Grow ctrl column


    def GetProperties(self):
        """
        Returns the current legal property values, as [(name, value), ].
        Illegal values are replaced with initial values.
        """
        result = []
        for name, typeclass, orig, default, label, ctrl in self.properties:
            value = self._GetValueForType(ctrl.Value, typeclass)
            result.append((name, orig if value is None else value))
        return result


    def _OnSave(self, event):
        """
        Handler for clicking save, checks values and hides the dialog if all 
        ok, highlights errors otherwise.
        """
        all_ok = True
        for name, typeclass, orig, default, label, ctrl in self.properties:
            if self._GetValueForType(ctrl.Value, typeclass) is None:
                all_ok = False
                label.ForegroundColour = ctrl.ForegroundColour = self.COLOUR_ERROR
            else:                
                label.ForegroundColour = ctrl.ForegroundColour = self.ForegroundColour
        if all_ok:
            self.Hide()
            self.IsModal() and self.EndModal(wx.ID_OK)
        else:
            self.Refresh()


    def _OnReset(self, event):
        """Handler for clicking reset, restores default values if available."""
        for name, typeclass, orig, default, label, ctrl in self.properties:
            if default is not None:
                ctrl.Value = self._GetValueForCtrl(default, typeclass)
            if self.COLOUR_ERROR == ctrl.ForegroundColour:
                label.ForegroundColour = ctrl.ForegroundColour = self.ForegroundColour
        self.Refresh()


    def _OnCancel(self, event):
        """Handler for clicking cancel, hides the dialog."""
        self.Hide()
        self.IsModal() and self.EndModal(wx.ID_CANCEL)


    def _GetValueForType(self, value, typeclass):
        """Returns value in type expected, or None on failure."""
        try:
            result = typeclass(value) if "wx" not in typeclass.__module__ \
                     else tuple(typeclass(*ast.literal_eval(value)))
            isinstance(result, basestring) and result.strip()[0] # Reject empty
            return result 
        except StandardError as e:
            return None


    def _GetValueForCtrl(self, value, typeclass):
        """Returns the value in type suitable for appropriate wx control."""
        value = tuple(value) if isinstance(value, list) else value
        return str(value) if int == typeclass or "wx" in typeclass.__module__ \
               else "" if value is None else value



class ProgressWindow(wx.Dialog):
    """
    A simple non-modal ProgressDialog, stays on top of parent frame.
    """

    def __init__(self, parent, title, message="", maximum=100, cancel=True,
                 style=wx.CAPTION | wx.CLOSE_BOX | wx.FRAME_FLOAT_ON_PARENT):
        wx.Dialog.__init__(self, parent=parent, title=title, style=style)
        self._is_cancelled = False

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        panel = self._panel = wx.Panel(self)
        sizer = self._panel.Sizer = wx.BoxSizer(wx.VERTICAL)

        label = self._label_message = wx.StaticText(panel, label=message)
        sizer.Add(label, border=2*8, flag=wx.LEFT | wx.TOP)
        gauge = self._gauge = wx.Gauge(panel, range=maximum, size=(300,-1),
                              style=wx.GA_HORIZONTAL | wx.PD_SMOOTH)
        sizer.Add(gauge, border=2*8,
                  flag=wx.LEFT | wx.RIGHT | wx.TOP | wx.GROW)
        gauge.Value = 0
        if cancel:
            self._button_cancel = wx.Button(self._panel, id=wx.ID_CANCEL)
            sizer.Add(self._button_cancel, border=8,
                      flag=wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_HORIZONTAL)
            self.Bind(wx.EVT_BUTTON, self.OnCancel, self._button_cancel)
            self.Bind(wx.EVT_CLOSE, self.OnCancel)
        else:
            sizer.Add((8, 8))

        self.Sizer.Add(panel, flag=wx.GROW)
        self.Fit()
        self.Layout()
        self.Refresh()
        self.Show()


    def Update(self, value, message=None):
        """
        Updates the progressbar value, and message if given.

        @return  False if dialog was cancelled by user, True otherwise
        """
        if message is not None:
            self._label_message.Label = message
        self._gauge.Value = value
        self.Refresh()
        return not self._is_cancelled


    def OnCancel(self, event):
        """
        Handler for cancelling the dialog, hides the window.
        """
        self._is_cancelled = True
        self.Hide()


    def SetGaugeForegroundColour(self, colour):
        self._gauge.ForegroundColour = colour



class RangeSlider(wx.PyPanel):
    """
    A horizontal slider with two markers for selecting a value range. Supports
    numeric and date/time values.
    """
    BACKGROUND_COLOUR       = None
    BAR_ARROW_BG_COLOUR     = wx.Colour(212, 208, 200)
    BAR_ARROW_FG_COLOUR     = wx.Colour(0,     0,   0)
    BAR_COLOUR1             = wx.Colour(255, 255, 255) # Scrollbar buttons background
    BAR_COLOUR2             = wx.Colour(162, 162, 162) # gradient start and end
    BAR_HL_COLOUR           = wx.Colour(230, 229, 255) # Scrollbar hilite gradient start
    BOX_COLOUR              = wx.Colour(205, 205, 205) # Drawn around range values
    LABEL_COLOUR            = wx.Colour(136, 136, 136)
    SELECTION_LINE_COLOUR   = wx.Colour(68,   68,  68) # Line surrounding selection
    LINE_COLOUR             = wx.Colour(97,   97,  97)
    MARKER_BUTTON_COLOUR    = wx.Colour(102, 102, 102) # Drag button border
    MARKER_BUTTON_BG_COLOUR = wx.Colour(227, 227, 227) # Drag button background
    RANGE_COLOUR            = wx.Colour(185, 185, 255, 128)
    RANGE_DISABLED_COLOUR   = wx.Colour(185, 185, 185, 128)
    TICK_COLOUR             = wx.Colour(190, 190, 190)
    BAR_BUTTON_WIDTH        = 11 # Width of scrollbar arrow buttons
    BAR_HEIGHT              = 11 # Height of scrollbar
    MARKER_BUTTON_WIDTH     = 9  # Width of drag button that appears on hover
    MARKER_BUTTON_HEIGHT    = 16 # Width of drag button that appears on hover
    MARKER_CAPTURE_PADX     = 3  # x-distance from marker where highlight starts
    MARKER_WIDTH            = 5
    RANGE_TOP               = 5  # Vertical start of range area
    RANGE_BOTTOM            = 15 # Vertical end of range area
    RANGE_LABEL_TOP_GAP     = 3  # Upper padding of range label in range area
    RANGE_LABEL_BOTTOM_GAP  = 6  # Lower padding of range label in range area
    SCROLL_STEP             = 5  # Scroll step in pixels
    TICK_HEIGHT             = 5
    TICK_STEP               = 5  # Tick after every xth pixel


    def __init__(self, parent, id=-1, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, name=wx.PanelNameStr,
                 rng=None, vals=None, fmt="%Y-%m-%d"):
        """
        Creates a new RangeSlider.

        @param   rng   the value range this control uses, as (min, max). If
                       range and values are left blank, default to a date range
                       of 3 years until now; if only range is blank, it is
                       assigned the values also
        @param   vals  the initial range positions, as (left, right). If values
                       and range are left blank, default to date values 2 and 1
                       years past; if only values are blank, they are assigned
                       the range values
        @param   fmt   format string or function used for formatting label
                       values, see LabelFormat
        """
        wx.PyPanel.__init__(self, parent, id, pos, size,
                            style | wx.FULL_REPAINT_ON_RESIZE, name)
        if not RangeSlider.BACKGROUND_COLOUR:
            bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
            RangeSlider.BACKGROUND_COLOUR = bgcolour

        # Fill unassigned range and values with other givens, or assign
        # a default date range.
        if not rng and vals:
            rng = vals
        elif not rng:
            now = datetime.datetime.now().date()
            rng = (now - datetime.timedelta(days=3*365), now)
            vals = (now - datetime.timedelta(days=2*365),
                    now - datetime.timedelta(days=1*365), )
        elif not vals:
            vals = rng

        self._rng = list(rng)
        self._vals = list(vals)
        self._vals_prev = [None, None]
        self._fmt = fmt
        if self._vals[0] < self._rng[0]:
            self._vals[0] = self._rng[0]
        if self._vals[1] > self._rng[1]:
            self._vals[1] = self._rng[1]
        # (x,y,w,h) tuples for left and right marker mouse capture areas
        self._capture_areas = [None, None]
        self._mousepos = None # Current mouse position, or None if mouse not in
        self._mousepos_special = False # If last mousepos needed redrawing
        self._dragging_markers = [False, False] # Whether marker is under drag
        self._dragging_scrollbar = False # Whether scrollbar is under drag
        self._marker_xs = [None, None] # [left x, right x]
        self._active_marker = None # Index of the currently hovered marker
        self._cursor_marker_hover    = wx.StockCursor(wx.CURSOR_SIZEWE)
        self._cursor_default         = wx.StockCursor(wx.CURSOR_DEFAULT)
        self._grip_area = None # Current scrollbar grip area
        self._bar_arrow_areas = None # Scrollbar arrow areas
        self._box_area = None # Current range area
        self._bar_area = None # Scrollbar area
        self.SetInitialSize(self.GetMinSize())
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouseEvent)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLostEvent)
        self.SetToolTipString("Double-click on marker or scrollbar to "
                              "maximize/restore values.")


    def GetLabelFormat(self):
        return self._fmt
    def SetLabelFormat(self, label_format):
        self._fmt = label_format
    LabelFormat = property(GetLabelFormat, SetLabelFormat, doc=
        """
        Format string or function used for formatting values. Format strings
        are used as common Python format strings, except for date or time
        values they are given to strftime. Format functions are given a single
        value parameter and are expected to return a string value.
        """
    )


    def GetLeftValue(self):
        return self._vals(0)
    def SetLeftValue(self, value):
        return self.SetValue(wx.LEFT, value)
    LeftValue = property(GetLeftValue, SetLeftValue, doc=
        "The left position value. Cannot get greater than the right value."
    )
    def GetRightValue(self):
        return self._vals(1)
    def SetRightValue(self, value, refresh=True):
        return self.SetValue(wx.RIGHT, value, refresh)
    RightValue = property(GetRightValue, SetRightValue, doc=
        "The right position value. Cannot get smaller than the left value."
    )


    def GetValues(self):
        """
        Returns the chosen left and right values, as a tuple.
        """
        return tuple(self._vals)
    def SetValues(self, left, right, refresh=True):
        """
        Sets both position values. Values will be confined to available
        range, not going beyond the same edge or the other marker. Control
        will be redrawn if value has changed (and `refresh` is not False).
        """
        new_vals = [left, right]
        for i, value in enumerate(new_vals):
            if value is not None:
                confiners = [(min, max), (max, min)][i]
                limits = (new_vals[1 - i], self._rng[i])
                for confine, limit in zip(confiners, limits):
                    try:    # Confine value between range edge and other marker
                        former_value = value
                        value = confine(value, limit)
                    except: # Fails if a value of new type is being set
                        self._vals[i] = None
                if self._rng[0] is not None \
                and not (self._rng[0] <= value <= self._rng[1]):
                    value = self._rng[0] if value < self._rng[0] \
                            else self._rng[1]
            self._vals_prev[i] = self._vals[i]
            self._vals[i] = value
        if refresh and self._vals != self._vals_prev:
            self.Refresh()
    Values = property(GetValues, SetValues, doc=
                      "See `GetValues` and `SetValues`.")


    def GetValue(self, side):
        """
        Returns the position value on the specified side.
        Side is 0 for left, non-0 for right (wx.LEFT and wx.RIGHT fit).
        """
        return self._vals[1 if side else 0]


    def SetValue(self, side, value, refresh=True):
        """
        Sets the position value on the specified side. Value will be confined
        to available range, not going beyond the same edge or the other marker.
        Side is 0 for left, non-0 for right (wx.LEFT and wx.RIGHT fit). Control
        will be redrawn if value has changed (and `refresh` is not False).
        """
        i = 1 if side else 0
        if value is not None:
            confiners = [(min, max), (max, min)][i]
            limits = (self._vals[1 - i], self._rng[i])
            for confine, limit in zip(confiners, limits):
                try:    # Confine value between range edge and other marker
                    former_value = value
                    value = confine(value, limit)
                except: # Comparison fails if a value of new type is being set
                    self._vals[i] = None
            if self._rng[0] is not None \
            and not (self._rng[0] < value < self._rng[1]):
                value = self._rng[0] if value < self._rng[0] else self._rng[1]
        self._vals_prev[i] = self._vals[i]
        self._vals[i] = value
        if refresh and self._vals[i] != self._vals_prev[i]:
            self.Refresh()


    def GetRange(self):
        return tuple(self._rng)
    def SetRange(self, left, right, refresh=True):
        #assert value_range, len(value_range) == 2,
        #       type(value_range[0]) == type(value_range[1])
        former_rng = self._rng
        self._rng = list((left, right))
        for i in range(2):
            # Set the value again to confine it inside the new range. If it
            # fails (probably a type change), reset it to range edge.
            self.SetValue(i, self._vals[i])
            if self._vals[i] is None:
                self.SetValue(i, self._rng[i])
        if refresh and former_rng != self._rng:
            self.Refresh()
    Range = property(GetRange, SetRange, doc=
        """
        The current value range of the control. Setting the range as outside of
        current selection causes selection to be reset to range edges.
        """
    )


    def GetMinSize(self):
        best = wx.Size(-1, -1)
        # GetFullTextExtent returns (width, height, descent, leading)
        extent = self.GetFullTextExtent(self.FormatLabel(self._rng[1]))
        # 2.3 provides a bit of space between 2 labels
        best.width  = 2.3 * extent[0]
        # 1 for upper gap, plus all set positions plus 2 * label height
        best.height = (1 + 2 * (extent[1] + extent[2]) + self.RANGE_TOP
                      + self.RANGE_LABEL_TOP_GAP + self.RANGE_LABEL_BOTTOM_GAP
                      + self.TICK_HEIGHT + self.BAR_HEIGHT)
        return best


    def OnPaint(self, event):
        dc = wx.BufferedPaintDC(self)
        self.Draw(dc)


    def OnEraseBackground(self, event):
        """Handles the wx.EVT_ERASE_BACKGROUND event."""
        pass # Intentionally empty to reduce flicker.


    def FormatLabel(self, value):
        """Returns the value as given by the current format."""
        formatted = None
        formatter = self._fmt or "%s"
        if callable(formatter):
            formatted = formatter(value)
        elif isinstance(self._rng[0], (datetime.date, datetime.time)):
            formatted = value.strftime(formatter)
        else:
            if type(self._rng[0]) == int and type(value) == float:
                value = int(value)
            formatted = formatter % value
        return formatted



    def Draw(self, dc):
        width, height = self.GetClientSize()
        if not width or not height:
            return

        dc.Clear()
        if self.Enabled:
            dc.SetTextForeground(self.LABEL_COLOUR)
        else:
            graycolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
            dc.SetTextForeground(graycolour)
        if not any(filter(None, self._rng)):
            return

        PEN = lambda c, w=1, s=wx.SOLID: wx.ThePenList.FindOrCreatePen(c, w, s)
        BRUSH = lambda c, s=wx.SOLID: wx.TheBrushList.FindOrCreateBrush(c, s)
        timedelta_micros = lambda delta: delta.days * 86400 * 1000000 \
                               + delta.seconds * 1000000 + delta.microseconds

        # Clear area and init data
        left_label, right_label = map(self.FormatLabel, self._rng)
        # GetFullTextExtent returns (width, height, descent, leading)
        left_extent  = self.GetFullTextExtent(left_label)
        right_extent = self.GetFullTextExtent(right_label)
        max_extent = right_extent if (right_extent > left_extent) \
                     else left_extent
        range_delta = self._rng[1] - self._rng[0]
        box_top = (max_extent[1] + max_extent[2]) + 2 # 1 for border, 1 for gap
        selection_top = box_top + self.RANGE_TOP
        selection_height = height - selection_top - self.RANGE_BOTTOM
        self._box_area = wx.Rect(self.BAR_BUTTON_WIDTH, box_top,
            width - 2 * self.BAR_BUTTON_WIDTH,
            height - box_top - self.BAR_HEIGHT
        )
        dc.SetFont(self.GetFont())
        range_colour = self.RANGE_COLOUR if self.Enabled \
                       else self.RANGE_DISABLED_COLOUR

        # Fill background
        dc.SetBrush(BRUSH(self.BACKGROUND_COLOUR, wx.SOLID))
        dc.SetPen(PEN(self.BACKGROUND_COLOUR))
        dc.DrawRectangle(0, 0, width, height)
        dc.SetPen(PEN(self.BOX_COLOUR))
        dc.DrawLine(0, box_top, width, box_top) # Top line
        #dc.DrawRectangle(-1, box_top, width + 2, height - box_top)

        # Draw current selection background, edge and scrollbar
        self._bar_arrow_areas = None
        if any(filter(None, self._vals)):
            value_rect = wx.Rect(-1, selection_top, -1, selection_height)
            for i in range(2):
                marker_delta = self._vals[i] - self._rng[0]
                range_delta_local = range_delta
                if i and not range_delta \
                and isinstance(self._rng[0], datetime.date):
                    # If date selection and only single day, fill entire area
                    marker_delta = range_delta_local = 1
                elif isinstance(self._vals[i], (datetime.date, datetime.time)):
                    # Cannot divide by timedeltas: convert to microseconds
                    marker_delta = timedelta_micros(marker_delta)
                    range_delta_local = timedelta_micros(range_delta) or 1
                x = self._box_area.x \
                    + self._box_area.width * marker_delta / range_delta_local
                value_rect[2 if i else 0] = (x - value_rect[0]) if i else x
            dc.SetBrush(BRUSH(range_colour, wx.SOLID))
            dc.SetPen(PEN(range_colour))
            dc.DrawRectangle(*value_rect)
            # Draw scrollbar arrow buttons
            self._bar_area = wx.Rect(
                0, height - self.BAR_HEIGHT, width, self.BAR_HEIGHT
            )
            dc.SetPen(PEN(self.TICK_COLOUR))
            self._bar_arrow_areas = [None, None]
            for i in range(2):
                self._bar_arrow_areas[i] = wx.Rect(
                    self._bar_area.width - self.BAR_BUTTON_WIDTH if i else 0,
                    self._bar_area.y, self.BAR_BUTTON_WIDTH, self.BAR_HEIGHT
                )
                #dc.GradientFillLinear(self._bar_arrow_areas[i],
                #   self.BAR_COLOUR1, self.BAR_COLOUR2, wx.WEST
                #)
                button_colour = self.BAR_ARROW_BG_COLOUR
                if self._bar_arrow_areas[i].Contains(self._mousepos):
                    button_colour = self.BAR_HL_COLOUR
                dc.SetBrush(BRUSH(button_colour, wx.SOLID))
                dc.DrawRectangle(*self._bar_arrow_areas[i])
            dc.SetBrush(BRUSH(self.BAR_ARROW_FG_COLOUR, wx.SOLID))
            dc.SetPen(PEN(self.BAR_ARROW_FG_COLOUR))
            dc.DrawPolygon(((self.BAR_BUTTON_WIDTH / 2 + 1,
                height - self.BAR_HEIGHT / 2 - 3), (
                    self.BAR_BUTTON_WIDTH / 2 + 1, 
                    height - self.BAR_HEIGHT / 2 + 1
                ), (self.BAR_BUTTON_WIDTH / 2 - 1,
                    height - self.BAR_HEIGHT / 2 - 1
                )
            ))
            dc.DrawPolygon(((width - self.BAR_BUTTON_WIDTH / 2 - 2,
                height - self.BAR_HEIGHT / 2 - 3), (
                    width - self.BAR_BUTTON_WIDTH / 2 - 2,
                    height - self.BAR_HEIGHT / 2 + 1
                ), (width - self.BAR_BUTTON_WIDTH / 2,
                    height - self.BAR_HEIGHT / 2 - 1
                )
            ))
            # Draw scrollbar
            bar_rect = self._grip_area = wx.Rect(
                value_rect.x,
                height - self.BAR_HEIGHT,
                value_rect.width,
                self.BAR_HEIGHT - 1 # -1 for box border
            )
            dc.GradientFillLinear(bar_rect, self.BAR_COLOUR1,
                self.BAR_HL_COLOUR if (
                    self._grip_area.Contains(self._mousepos)
                ) else self.BAR_COLOUR2, wx.SOUTH
            )
            # Draw a few vertical dashes in the scrollbar center
            if bar_rect.width > 12:
                dashes = [(
                    bar_rect.x + bar_rect.width / 2 - 3 + i,
                    bar_rect.y + (3 if i % 2 else 2),
                    bar_rect.x + bar_rect.width / 2 - 3 + i,
                    bar_rect.y + bar_rect.height - (1 if i % 2 else 2)
                ) for i in range(8)]
                pens = [PEN(self.BAR_COLOUR2), PEN(self.BAR_COLOUR1)] * 4
                dc.DrawLineList(dashes, pens)
            # Draw range edges
            edges = [
                # Left edge to selection start
                (0, box_top, value_rect.x, box_top),
                # Selection end to right edge
                (value_rect.x + value_rect.width, box_top, width, box_top),
                # Selection bottom left-right
                (value_rect.x, height - 1, value_rect.x + value_rect.width,
                    height - 1
                ),
            ]
            dc.SetPen(PEN(self.SELECTION_LINE_COLOUR))
            dc.DrawLineList(edges)

        # Draw ticks and main ruler line
        tick_count = self._box_area.width / self.TICK_STEP + 1
        lines = [(
            self._box_area.x + i * self.TICK_STEP,
            height - self.BAR_HEIGHT - self.TICK_HEIGHT,
            self._box_area.x + i * self.TICK_STEP,
            height - self.BAR_HEIGHT
        ) for i in range(tick_count)
        ]
        lines.append(( # Ruler line
            0, height - self.BAR_HEIGHT,
            width - 1, height - self.BAR_HEIGHT
        ))
        dc.SetPen(PEN(self.TICK_COLOUR))
        dc.DrawLineList(lines)

        # Draw labels, determining how many labels can fit comfortably.
        # 4/3 leaves a nice padding between.
        label_count = int(width / (max_extent[0] * 4 / 3.0))
        labels = [left_label]
        label_coords = [(2, selection_top + self.RANGE_LABEL_TOP_GAP)]
        if isinstance(self._rng[0], (datetime.date, datetime.time)):
            # Cannot use floats to divide timedeltas
            value_step = range_delta / (label_count or sys.maxsize)
            # Tickid on major ja minor. Valime siin, kuhu me mida paneme.
            # variandid: aasta-kuu, aastakuu-pev, pev-tund, tund-minut jne
        else:
            # Should use floats for other values, to get finer precision
            value_step = range_delta / float(label_count)
        # Skip first and last, as left and right are already set.
        for i in range(1, label_count - 1):
            labels.append(self.FormatLabel(self._rng[0] + i * value_step))
            label_coords.append((self._box_area.x \
                + i * self._box_area.width / label_count,
                selection_top + self.RANGE_LABEL_TOP_GAP
            ))
        labels.append(right_label)
        label_coords.append((self._box_area.right - right_extent[0],
            selection_top + self.RANGE_LABEL_TOP_GAP
        ))
        dc.DrawTextList(labels, label_coords)

        # Draw left and right markers
        marker_labels = [None, None] # [(text, area) * 2]
        marker_draw_order = [0, 1] if self._active_marker == 1 else [1, 0]
        # Draw active marker last, leaving its content on top
        for i in marker_draw_order:
            marker_delta = self._vals[i] - self._rng[0]
            range_delta_local = range_delta
            if i and not range_delta \
            and isinstance(self._rng[0], datetime.date):
                # If date selection and only single day, fill entire area
                marker_delta = range_delta_local = 1
            elif isinstance(self._vals[i], (datetime.date, datetime.time)):
                # Cannot divide by timedeltas: convert to microseconds
                marker_delta = timedelta_micros(marker_delta)
                range_delta_local = timedelta_micros(range_delta) or 1
            x = self._box_area.x \
                + self._box_area.width * marker_delta / range_delta_local
            self._marker_xs[i] = x
            label = self.FormatLabel(self._vals[i])
            # GetFullTextExtent returns (width, height, descent, leading)
            label_extent = self.GetFullTextExtent(label)
            # Center label on top of marker. +2 for padding
            label_area = wx.Rect(x - label_extent[0] / 2, 0, 
                label_extent[0] + 2, sum(label_extent[1:2])
            )
            if not self.ClientRect.ContainsRect(label_area):
                # Rest label against the edge if going out of control area
                label_area.x = 1 if (label_area.x < 1) \
                    else (width - label_area.width)
            marker_labels[i] = (label, label_area)

            area = wx.Rect(
                x - self.MARKER_WIDTH / 2, box_top,
                self.MARKER_WIDTH, height - box_top - self.BAR_HEIGHT
            )
            # Create a slightly larger highlight capture area for marker
            capture_area = self._capture_areas[i] = wx.Rect(*area)
            capture_area.x     -= self.MARKER_CAPTURE_PADX
            capture_area.width += self.MARKER_CAPTURE_PADX

            dc.SetPen(PEN(self.SELECTION_LINE_COLOUR))
            dc.DrawLine(x, box_top, x, height)
            if self._mousepos is not None:
                # Draw drag buttons when mouse in control
                button_area = wx.Rect(-1, -1, self.MARKER_BUTTON_WIDTH,
                    self.MARKER_BUTTON_HEIGHT
                ).CenterIn(area)
                button_radius = 3
                if i == self._active_marker:
                    brush_colour = wx.WHITE#self.BAR_HL_COLOUR
                else:
                    brush_colour = self.MARKER_BUTTON_BG_COLOUR
                dc.SetBrush(BRUSH(brush_colour, wx.SOLID))
                dc.SetPen(PEN(self.MARKER_BUTTON_COLOUR))
                dc.DrawRoundedRectangle(*button_area, radius=button_radius)
                button_lines = [
                    (button_area.x + button_radius + i * 2, 
                        button_area.y + button_radius,
                        button_area.x + button_radius + i * 2, 
                         button_area.y + button_area.height - button_radius
                    ) for i in range(
                        (self.MARKER_BUTTON_WIDTH - 2 * button_radius + 1) / 2
                    )
                ]
                dc.SetPen(PEN(self.SELECTION_LINE_COLOUR))
                dc.DrawLineList(button_lines)
        # Move marker labels apart if overlapping each other
        if marker_labels[0][1].Intersects(marker_labels[1][1]):
            # +1 for padding
            overlap = wx.Rect(*marker_labels[0][1]) \
                .Intersect(marker_labels[1][1]).width
            delta1 = (overlap / 2) + 1
            if (marker_labels[0][1].x - delta1 < 1):
                # Left is going over left edge: set to 1
                delta1 = marker_labels[0][1].x - 1
            delta2 = overlap - delta1
            if (marker_labels[1][1].right + delta2 > width):
                # Right is going over right side: set to right edge
                delta2 = width - marker_labels[1][1].right
                delta1 = overlap - delta2

            marker_labels[0][1].x -= delta1
            marker_labels[1][1].x += delta2
        # Draw left and right marker labels
        for text, area in marker_labels:
            dc.DrawText(text, area.x, 0)


    def OnMouseEvent(self, event):
        if not self.Enabled:
            return

        if not self._box_area:
            # Must not have been drawn yet
            self.Refresh()
        last_pos = self._mousepos
        self._mousepos = event.Position
        refresh = False
        active_markers = [i for i, c in enumerate(self._capture_areas)
                          if c and c.Contains(event.Position)]
        active_marker = active_markers[0] if active_markers else None
        if len(active_markers) > 1 and last_pos \
        and last_pos.x > event.Position.x:
            # Switch marker to right if two are overlapping and approaching
            # from the right.
            active_marker = active_markers[-1]
        if event.Entering():
            refresh = True
        elif event.Moving():
            if active_marker is not None:
                if not self._mousepos_special:
                    # Moved into a special position: draw active areas
                    self._active_marker = active_marker
                    self._mousepos_special = True
                    self.TopLevelParent.SetCursor(self._cursor_marker_hover)
                    refresh = True
            elif self._mousepos_special:
                # Moved out from a special position: draw default
                self._active_marker = None
                self.TopLevelParent.SetCursor(self._cursor_default)
                self._mousepos_special = False
                refresh = True
            elif self._grip_area:
                if (self._grip_area.Contains(self._mousepos) \
                and not self._grip_area.Contains(last_pos)) \
                or (self._grip_area.Contains(last_pos) \
                and not self._grip_area.Contains(self._mousepos)):
                    refresh = True
                else:
                    for button_area in self._bar_arrow_areas:
                        if button_area.Contains(self._mousepos):
                            refresh = True
        elif event.LeftDClick():
            if active_marker is not None:
                # Maximize/restore marker value on double-clicking a marker
                i = active_marker
                if self._vals[i] == self._rng[i]:
                    # Currently is maximized: restore to previous value, or
                    # center of available space if nothing previous.
                    if self._vals_prev[i] is None \
                    or self._vals_prev[i] == self._rng[i]:
                        center = self._rng[i] \
                            + (self._rng[i] - self._vals[1 - i]) / 2
                        self.SetValue(i, center, False)
                    else:
                        self.SetValue(i, self._vals_prev[i], False)
                else:
                    # Currently is not maximized: set value to range edge
                    self.SetValue(i, self._rng[i], False)
                refresh = True
            elif self._grip_area and self._grip_area.Contains(event.Position):
                # Maximize/restore both markers on double-clicking scrollbar
                if self._vals == self._rng:
                    # Currently is maximized: restore to previous values, or
                    # spaced evenly in available space if nothing previous.
                    for i in range(2):
                        if self._vals_prev[i] is None \
                        or self._vals_prev[i] == self._rng[i]:
                            center = self._rng[i] \
                                + (self._rng[i] - self._vals[1 - i]) / 2
                            self.SetValue(i, center, False)
                        else:
                            self.SetValue(i, self._vals_prev[i], False)
                else:
                    # Currently is not maximized: set value to range edge
                    self.SetValues(*self._rng, refresh=False)
        elif event.LeftDown():
            if active_marker is not None:
                self.CaptureMouse()
                self._dragging_markers[active_marker] = True
            elif self._grip_area and self._grip_area.Contains(event.Position):
                self.CaptureMouse()
                self._dragging_scrollbar = True
            elif self._bar_area and self._bar_area.Contains(event.Position):
                arrow = [i for i, a in enumerate(self._bar_arrow_areas) \
                    if a.Contains(event.Position)
                ]
                arrow = arrow[0] if arrow else None
                if arrow is not None:
                    # Nudge scrollbar in arrow direction
                    direction = [-1, 1][arrow]
                    step = self.SCROLL_STEP * (
                        (self._rng[1] - self._rng[0]) / self.ClientSize.width
                    )
                else:
                    # Move scrollbar by its length
                    direction = -1 \
                        if (event.Position.x < self._grip_area.x) else 1
                    step = (self._vals[1] - self._vals[0])
                if isinstance(self._rng[0], datetime.date) and step.days < 1:
                    # Enforce a minimum step of 1 day for date values
                    step = datetime.timedelta(days=1)
                new_vals = [(x + step) if (direction > 0) else (x - step) \
                    for x in self._vals
                ]
                # If one value would go over the edge, pull both values
                # back equally
                for i in range(2):
                    # Test left with less-than, right with greater-than
                    if [operator.lt, operator.gt][i](new_vals[i], self._rng[i]):
                        new_vals[i] = self._rng[i]
                        if direction > 0:
                            new_vals[1 - i] -= step \
                                - (self._rng[i] - self._vals[i])
                        else:
                            new_vals[1 - i] += step \
                                - (self._vals[i] - self._rng[i])
                self.SetValues(*new_vals, refresh=False)
                refresh = True
        elif event.LeftUp():
            if self.HasCapture():
                self.ReleaseMouse()
                if active_marker is None:
                    self.TopLevelParent.SetCursor(self._cursor_default)
                    self._mousepos_special = False
                    self._active_marker = None
                if not self.ClientRect.Contains(event.Position):
                    # Mouse was down inside self, dragged out and released
                    self._mousepos = None
            self._dragging_markers[i] = False
            self._dragging_scrollbar = False
            refresh = True
        elif event.Dragging():
            if self._mousepos_special:
                i = self._active_marker
                do_step = True
                # Skip drag if marker is against an edge (either range edge or
                # the other marker) and cursor is beyond that edge.
                if self._vals[i] in [self._rng[i], self._vals[1 - i]]:
                    # if is_right_side XOR is_against_range
                    direction = -1 if (i ^ (self._vals[i] != self._rng[i])) \
                        else 1
                    do_step = 0 <= \
                        direction * cmp(event.Position.x, self._marker_xs[i])
                if do_step:
                    self._dragging_markers[i] = True
                    x_delta = abs(event.Position.x - last_pos.x)
                    x_direction = 1 if (event.Position.x > last_pos.x) else -1
                    range_delta = self._rng[1] - self._rng[0]
                    range_width = self.GetClientSize().width
                    step = range_delta * x_delta / self.GetClientSize().width
                    if isinstance(self._rng[0], datetime.date) and step.days < 1:
                        # Enforce a minimum step of 1 day for date values
                        step = datetime.timedelta(days=1)
                    in_area = self._grip_area.ContainsXY(
                        event.Position.x, self._grip_area.Top
                    )
                    enlarging = (x_direction > 0) if i else (x_direction < 0)
                    x_i_delta = abs(self._marker_xs[i] - event.Position.x)
                    if x_i_delta > 5 and not (in_area ^ enlarging):
                        # Skip if mouse is far from the border being moved and
                        # area is enlarged from inside or shrunk from outside
                        step = 0
                    if step:
                        new_val = (self._vals[i] + step) if x_direction > 0 \
                                  else (self._vals[i] - step)
                        self.SetValue(i, new_val, False)
                        refresh = True
            elif self._dragging_scrollbar:
                do_step = True
                # Skip drag if scrollbar is against the range edge and
                # cursor is moving toward that edge.
                if self._grip_area.x <= self._box_area.x \
                or self._grip_area.right >= self._box_area.right:
                    going_right = (event.Position.x > last_pos.x)
                    edge_x = self._box_area.x \
                             if self._grip_area.x <= self._box_area.x \
                             else self._box_area.right + 1
                    do_step = going_right \
                        and (self._grip_area.right < self._box_area.right) \
                        or not going_right \
                        and (self._grip_area.x > self._box_area.x)
                if do_step:
                    x_delta = abs(event.Position.x - last_pos.x)
                    x_direction = 1 if (event.Position.x > last_pos.x) else -1
                    going_right = (event.Position.x > last_pos.x)
                    range_delta = self._rng[1] - self._rng[0]
                    range_width = self.GetClientSize().width
                    step = range_delta * x_delta / range_width
                    in_area = self._grip_area.ContainsXY(
                        event.Position.x, self._grip_area.Top
                    )
                    closest_i, x_i_delta = 0, sys.maxsize
                    for i in range(2):
                        dlt = abs(self._marker_xs[i] - event.Position.x)
                        if dlt < x_i_delta:
                            closest_i, x_i_delta = i, dlt
                    outwards = (x_direction > 0) if closest_i \
                               else (x_direction < 0)
                    if in_area or not outwards:
                        step = 0
                    if step:
                        if isinstance(self._rng[0], datetime.date) \
                        and step.days < 1:
                            # Enforce a minimum step of 1 day for date values
                            step = datetime.timedelta(days=1)
                        new_vals = [(x + step) if going_right else (x - step)
                            for x in self._vals
                        ]
                        # If one value would go over the edge, pull both values
                        # back equally
                        for i in range(2):
                            # Test left with less-than, right with greater-than
                            if [operator.lt,
                            operator.gt][i](new_vals[i], self._rng[i]):
                                new_vals[i] = self._rng[i]
                                if going_right:
                                    new_vals[1 - i] -= step \
                                        - (self._rng[i] - self._vals[i])
                                else:
                                    new_vals[1 - i] += step \
                                        - (self._vals[i] - self._rng[i])
                        self.SetValues(*new_vals, refresh=False)
                        refresh = True
        elif event.Leaving():
            i = self._active_marker
            if not self.HasCapture():
                self._mousepos = None
            if self._mousepos_special and not self.HasCapture():
                self.TopLevelParent.SetCursor(self._cursor_default)
                self._mousepos_special = False
                self._active_marker = None
            refresh = True
        if refresh:
            self.Refresh()
        # event.Y
        # event.X
        # event.WheelRotation
        # event.WheelDelta
        # event.Position
        # event.Moving
        # event.LogicalPosition
        # event.LeftUp
        # event.LeftIsDown
        # event.LeftDown
        # event.LeftDClick
        # event.Leaving
        # event.EventType
        # event.Event
        # event.Entering
        # event.Dragging


    def OnMouseCaptureLostEvent(self, event):
        """Handles MouseCaptureLostEvent, updating control UI if needed."""
        if self._mousepos_special:
            self._mousepos_special = False
            self.Refresh()


    def AcceptsFocusFromKeyboard(self):
        return True

    def AcceptsFocus(self):
        return True

    def ShouldInheritColours(self):
        return True

    def GetDefaultAttributes(self):
        return wx.PyPanel.GetClassDefaultAttributes()

    def DoGetBestSize(self):
        best = wx.Size(200, 40)
        self.CacheBestSize(best)
        return best



class ScrollingHtmlWindow(wx.html.HtmlWindow):
    """
    HtmlWindow that remembers its scroll position on resize.
    """

    def __init__(self, *args, **kwargs):
        wx.html.HtmlWindow.__init__(self, *args, **kwargs)
        self.Bind(wx.EVT_SCROLLWIN, self._OnScroll)
        self.Bind(wx.EVT_SIZE, self._OnSize)
        self._last_scroll_pos = [0, 0]
        self._last_scroll_range = [0, 0]


    def _OnSize(self, event):
        """
        Handler for sizing the HtmlWindow, sets new scroll position based
        previously stored one (HtmlWindow loses its scroll position on resize).
        """
        if hasattr(self, "_last_scroll_pos"):
            for i in range(2):
                orient = wx.VERTICAL if i else wx.HORIZONTAL
                # Division can be > 1 on first resizings, bound it to 1.
                pos, rng = self._last_scroll_pos[i], self._last_scroll_range[i]
                ratio = pos / float(rng) if rng else 0.0
                ratio = min(1, pos / float(rng) if rng else 0.0)
                self._last_scroll_pos[i] = ratio * self.GetScrollRange(orient)
            # Execute scroll later as something resets it after this handler
            try:
                wx.CallLater(50, lambda:
                    self.Scroll(*self._last_scroll_pos) if self else None
                )
            except:
                pass # CallLater fails if not called from the main thread
        event.Skip() # Allow event to propagate wx handler


    def _OnScroll(self, event):
        """
        Handler for scrolling the window, stores scroll position
        (HtmlWindow loses it on resize).
        """
        self._last_scroll_pos = [
            self.GetScrollPos(wx.HORIZONTAL), self.GetScrollPos(wx.VERTICAL)
        ]
        self._last_scroll_range = [
            self.GetScrollRange(wx.HORIZONTAL), self.GetScrollRange(wx.VERTICAL)
        ]
        event.Skip() # Allow event to propagate wx handler



class SortableListView(wx.ListView, wx.lib.mixins.listctrl.ColumnSorterMixin):
    """
    A sortable list view that can be batch-populated, autosizes its columns,
    can be filtered by string value matched on any row column.
    """

    def __init__(self, *args, **kwargs):
        wx.ListView.__init__(self, *args, **kwargs)
        wx.lib.mixins.listctrl.ColumnSorterMixin.__init__(self, 0)
        self.itemDataMap = {} # {item_id: [values], } for ColumnSorterMixin
        self._data_map = {} # {item_id: row dict, } currently visible data
        self._id_rows = [] # [(item_id, {row dict}), ] all data items
        self._columns = [] # [(name, label), ]
        self._filter = "" # Filter string
        self._col_widths = {} # {col_index: width, }
        self._col_maxwidth = -1 # Maximum width for auto-sized columns
        # Remember row colour attributes { item_id: {SetItemTextColour: x,
        # SetItemBackgroundColour: y, }, }
        self._row_colours = collections.defaultdict(dict)
        # Default row column formatter function
        frmt = lambda: lambda r, c: "" if r.get(c) is None else unicode(r[c])
        self._formatters = collections.defaultdict(frmt)


    def SetColumnFormatters(self, formatters):
        """
        Sets the functions used for formatting displayed column values.

        @param   formatters  {col_name: function(rowdict, col_name), }
        """
        self._formatters.clear()
        if formatters:
            self._formatters.update(formatters)


    def Populate(self, rows):
        """
        Populates the control with rows, clearing previous data, if any.
        Re-selects the previously selected row, if any.

        @param   rows        a list of data dicts
        """
        self._col_widths.clear()
        self._row_colours.clear()
        self._id_rows = [(wx.NewId(), r) for r in rows]
        self.RefreshRows()


    def AppendRow(self, data):
        """
        Appends the specified data to the control as a new row.

        @param   data     item data dictionary
        """
        item_id = wx.NewId()
        if self._RowMatchesFilter(data):
            columns = [c[0] for c in self._columns]
            index = self.ItemCount
            col_value = self._formatters[columns[0]](data, columns[0])
            self.InsertStringItem(index, col_value)
            for i, col_name in enumerate(columns[1:]):
                col_value = self._formatters[col_name](data, col_name)
                self.SetStringItem(index, i + 1, col_value)
                self._col_widths[col_name] = max(
                    self._col_widths.get(col_name, 0), len(col_value))
            self.SetItemData(index, item_id)
            self.itemDataMap[item_id] = [data[c] for c in columns]
            self._data_map[item_id] = data
            self.SetItemImage(index, -1)
            self.SetItemColumnImage(index, 0, -1)
        self._id_rows.append((item_id, data))


    def GetFilter(self):
        return self._filter
    def SetFilter(self, value, force_refresh=False):
        """
        Sets the text to filter list by. Any row not containing the text in any
        column will be hidden.

        @param   force_refresh  if True, all content is refreshed even if
                                filter value did not change
        """
        if force_refresh or value != self._filter:
            if force_refresh:
                self._col_widths.clear()
            self._filter = value
            if self._id_rows:
                self.RefreshRows()


    def RefreshRows(self):
        """
        Clears the list and inserts all unfiltered rows, auto-sizing the 
        columns.
        """
        selected_ids, selected = [], self.GetFirstSelected()
        while selected >= 0:
            selected_ids.append(self.GetItemData(selected))
            selected = self.GetNextSelected(selected)

        # Store row colour attributes
        for i in range(self.ItemCount):
            t, b = self.GetItemTextColour(i), self.GetItemBackgroundColour(i)
            id = self.GetItemData(i)
            for func, value in [(self.SetItemTextColour, t),
                                (self.SetItemBackgroundColour, b)]:
                if wx.NullColour != value:
                    self._row_colours[id][func] = value
                elif func in self._row_colours[id]:
                    del self._row_colours[id][func]
            if id in self._row_colours and not self._row_colours[id]:
                del self._row_colours[id]

        self.Freeze()
        wx.ListView.DeleteAllItems(self)
        # To map list item data ID to row, ListView allows only integer per row
        row_data_map = {} # {item_id: {row dict}, }
        item_data_map = {} # {item_id: [row values], }
        # For measuring by which to set column width: header or value
        header_lengths = {} # {col_name: integer}
        col_lengths = {} # {col_name: integer}
        for col_name, col_label in self._columns:
            # Keep space for sorting arrows.
            col_lengths[col_name] = 0
            header_lengths[col_name] = (6 + self.GetTextExtent(col_label)[0]
                                            / self.GetTextExtent("n")[0])
        index = 0
        for item_id, row in self._id_rows:
            if not self._RowMatchesFilter(row):
                continue # continue for index, (item_id, row) in enumerate(..)
            col_name = self._columns[0][0]
            col_value = self._formatters[col_name](row, col_name)
            # Keep space for the 0 (icon) column, to decrease display changes.
            col_lengths[col_name] = max(col_lengths[col_name],
                                        len(col_value) + 3)
            self.InsertStringItem(index, col_value)
            self.SetItemData(index, item_id)
            self.SetItemImage(index, -1)
            self.SetItemColumnImage(index, 0, -1)
            item_data_map[item_id] = {0: row[col_name]}
            row_data_map[item_id] = row
            col_index = 1 # First was already inserted
            for col_name, col_label in self._columns[col_index:]:
                col_value = self._formatters[col_name](row, col_name)
                col_lengths[col_name] = max(col_lengths[col_name],
                                            len(col_value))
                self.SetStringItem(index, col_index, col_value)
                item_data_map[item_id][col_index] = row.get(col_name)
                col_index += 1
            index += 1
        self._data_map = row_data_map
        self.itemDataMap = item_data_map
        if self._id_rows and not self._col_widths:
            if self._col_maxwidth > 0:
                for col_name, width in col_lengths.items():
                    col_lengths[col_name] = min(width, self._col_maxwidth)
            col_index = 0
            for col_name, col_label in self._columns:
                self.SetColumnWidth(col_index,
                    wx.LIST_AUTOSIZE
                    if (col_lengths[col_name] > header_lengths[col_name])
                    else header_lengths[col_name] * self.GetTextExtent("n")[0])
                #wx.LIST_AUTOSIZE_USEHEADER
                col_index += 1
            if self._col_maxwidth > 0:
                widths = self.GetColumnWidths()
                for i, w in [(i, w) for i, w in enumerate(widths)
                             if w > self._col_maxwidth]:
                    self.SetColumnWidth(i, 300)
            self._col_widths = dict(enumerate(self.GetColumnWidths()))
        elif self._col_widths:
            for col, width in self._col_widths.items():
                self.SetColumnWidth(col, width)
        if self.GetSortState()[0] >= 0:
            self.SortListItems(*self.GetSortState())

        if selected_ids or self._row_colours:
            idindx = dict((self.GetItemData(i), i)
                          for i in range(self.ItemCount))
        for item_id, attrs in self._row_colours.items(): # Re-colour rows
            if item_id not in idindx: continue
            [func(idindx[item_id], value) for func, value in attrs.items()]
        if selected_ids: # Re-select the previously selected items
            [self.Select(idindx[i]) for i in selected_ids if i in idindx]

        self.Thaw()


    def ResetColumnWidths(self):
        """Resets the stored column widths, triggering a fresh autolayout."""
        self._col_widths.clear()


    def DeleteItem(self, index):
        """Deletes the row at the specified index."""
        data_id = self.GetItemData(index)
        data = self._data_map.get(data_id)
        del self._data_map[data_id]
        self._id_rows.remove((data_id, data))
        return wx.ListView.DeleteItem(self, index)


    def DeleteAllItems(self):
        """Deletes all items data and clears the list."""
        self.itemDataMap = {}
        self._data_map = {}
        self._id_rows = []
        self._row_colours.clear()
        self.Freeze()
        result = wx.ListView.DeleteAllItems(self)
        self.Thaw()
        return result


    def GetItemCountFull(self):
        """Returns the full row count, including items hidden by filter."""
        return len(self._id_rows)


    def SetColumnsMaxWidth(self, width):
        """Sets the maximum width for all columns, used in auto-size."""
        self._col_maxwidth = width


    def SetColumns(self, columns):
        """
        Sets the list columns, clearing current columns if any.

        @param   columns  [(column name, column label), ]
        """
        self.ClearAll()
        self.SetColumnCount(len(columns))
        for i, (name, label) in enumerate(columns):
            # Keep space for sorting arrows.
            self.InsertColumn(i + 1, label + "  ")
        self._columns = columns


    def GetItemMappedData(self, index):
        """Returns the data mapped to the specified row index."""
        data_id = self.GetItemData(index)
        data = self._data_map.get(data_id)
        return data


    def GetListCtrl(self):
        """Required by ColumnSorterMixin."""
        return self


    def SortListItems(self, col=-1, ascending=1):
        """Sorts the list items on demand."""
        wx.lib.mixins.listctrl.ColumnSorterMixin.SortListItems(
            self, col, ascending)
        self.OnSortOrderChanged()


    def GetColumnSorter(self):
        """
        Override ColumnSorterMixin.GetColumnSorter to specify our sorting,
        which accounts for None values.
        """
        sorter = self.__ColumnSorter if hasattr(self, "itemDataMap") \
            else wx.lib.mixins.listctrl.ColumnSorterMixin.GetColumnSorter(self)
        return sorter


    def OnSortOrderChanged(self):
        """
        Callback called by ColumnSorterMixin after sort order has changed
        (whenever user clicked column header), refreshes column header sort
        direction info.
        """
        ARROWS = {True: u" ", False: u" "}
        col_sorted, ascending = self.GetSortState()
        for i in range(self.ColumnCount):
            col_item = self.GetColumn(i)
            if i == col_sorted:
                new_item = wx.ListItem()
                t = col_item.Text.replace(ARROWS[0], "").replace(ARROWS[1], "")
                new_item.Text = u"%s%s" % (t, ARROWS[ascending])
                self.SetColumn(i, new_item)
            elif any(filter(lambda i: i in col_item.Text, ARROWS.values())):
                # Remove the previous sort arrow, if any
                new_item = wx.ListItem()
                t = col_item.Text.replace(ARROWS[0], "").replace(ARROWS[1], "")
                new_item.Text = t
                self.SetColumn(i, new_item)


    def _RowMatchesFilter(self, row):
        """Returns whether the row dict matches the current filter."""
        result = True
        if self._filter:
            result = False
            pattern = re.escape(self._filter)
            for col_name, col_label in self._columns:
                col_value = self._formatters[col_name](row, col_name)
                if re.search(pattern, col_value, re.I):
                    result = True
                    break
        return result


    def __ColumnSorter(self, key1, key2):
        """
        Sort function fed to ColumnSorterMixin, is given two integers which we
        have mapped on our own.
        """
        col = self._col
        ascending = self._colSortFlag[col]
        item1 = self.itemDataMap[key1][col]
        item2 = self.itemDataMap[key2][col]

        #--- Internationalization of string sorting with locale module
        if isinstance(item1, unicode) and isinstance(item2, unicode):
            cmpVal = locale.strcoll(item1.lower(), item2.lower())
        elif isinstance(item1, str) or isinstance(item2, str):
            items = item1.lower(), item2.lower()
            cmpVal = locale.strcoll(*map(unicode, items))
        else:
            if item1 is None:
                cmpVal = -1
            elif item2 is None:
                cmpVal = 1
            else:
                cmpVal = cmp(item1, item2)

        # If items are equal, pick something else to make the sort value unique
        if cmpVal == 0:
            cmpVal = apply(cmp, self.GetSecondarySortValues(col, key1, key2))

        result = cmpVal if ascending else -cmpVal
        return result



class SQLiteTextCtrl(wx.stc.StyledTextCtrl):
    """A StyledTextCtrl configured for SQLite syntax highlighting."""

    """SQLite reserved keywords."""
    KEYWORDS = [
        u"ABORT", u"ACTION", u"ADD", u"AFTER", u"ALL", u"ALTER", u"ANALYZE",
        u"AND", u"AS", u"ASC", u"ATTACH", u"AUTOINCREMENT", u"BEFORE",
        u"BEGIN", u"BETWEEN", u"BY", u"CASCADE", u"CASE", u"CAST", u"CHECK",
        u"COLLATE", u"COLUMN", u"COMMIT", u"CONFLICT", u"CONSTRAINT",
        u"CREATE", u"CROSS", u"CURRENT_DATE", u"CURRENT_TIME",
        u"CURRENT_TIMESTAMP", u"DATABASE", u"DEFAULT", u"DEFERRABLE",
        u"DEFERRED", u"DELETE", u"DESC", u"DETACH", u"DISTINCT", u"DROP",
        u"EACH", u"ELSE", u"END", u"ESCAPE", u"EXCEPT", u"EXCLUSIVE",
        u"EXISTS", u"EXPLAIN", u"FAIL", u"FOR", u"FOREIGN", u"FROM", u"FULL",
        u"GLOB", u"GROUP", u"HAVING", u"IF", u"IGNORE", u"IMMEDIATE", u"IN",
        u"INDEX", u"INDEXED", u"INITIALLY", u"INNER", u"INSERT", u"INSTEAD",
        u"INTERSECT", u"INTO", u"IS", u"ISNULL", u"JOIN", u"KEY", u"LEFT",
        u"LIKE", u"LIMIT", u"MATCH", u"NATURAL", u"NO", u"NOT", u"NOTNULL",
        u"NULL", u"OF", u"OFFSET", u"ON", u"OR", u"ORDER", u"OUTER", u"PLAN",
        u"PRAGMA", u"PRIMARY", u"QUERY", u"RAISE", u"REFERENCES", u"REGEXP",
        u"REINDEX", u"RELEASE", u"RENAME", u"REPLACE", u"RESTRICT", u"RIGHT",
        u"ROLLBACK", u"ROW", u"SAVEPOINT", u"SELECT", u"SET", u"TABLE",
        u"TEMP", u"TEMPORARY", u"THEN", u"TO", u"TRANSACTION", u"TRIGGER",
        u"UNION", u"UNIQUE", u"UPDATE", u"USING", u"VACUUM", u"VALUES", u"VIEW",
        u"VIRTUAL", u"WHEN", u"WHERE"
    ]
    AUTOCOMP_STOPS = " .,;:([)]}'\"\\<>%^&+-=*/|`"
    FONT_FACE = "Courier New" if os.name == "nt" else "Courier"
    """String length from which autocomplete starts."""
    AUTOCOMP_LEN = 2

    def __init__(self, *args, **kwargs):
        wx.stc.StyledTextCtrl.__init__(self, *args, **kwargs)
        self.autocomps_added = set()
        # All autocomps: added + KEYWORDS
        self.autocomps_total = self.KEYWORDS
        # {word.upper(): set(words filled in after word+dot), }
        self.autocomps_subwords = {}

        self.SetLexer(wx.stc.STC_LEX_SQL)
        self.SetMarginWidth(1, 0) # Get rid of left margin
        self.SetTabWidth(4)
        # Keywords must be lowercase, required by StyledTextCtrl
        self.SetKeyWords(0, u" ".join(self.KEYWORDS).lower())
        self.AutoCompStops(self.AUTOCOMP_STOPS)
        self.SetWrapMode(wx.stc.STC_WRAP_WORD)
        self.SetCaretLineBackground("#00FFFF")
        self.SetCaretLineBackAlpha(20)
        self.SetCaretLineVisible(True)
        self.AutoCompSetIgnoreCase(True)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)

        bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
        self.StyleSetSpec(wx.stc.STC_STYLE_DEFAULT, 
                          "face:%s,back:%s" % (self.FONT_FACE,
                          bgcolour.GetAsString(wx.C2S_HTML_SYNTAX)))
        self.StyleClearAll() # Apply the new default style to all styles
        self.StyleSetSpec(wx.stc.STC_SQL_DEFAULT, "face:%s" % self.FONT_FACE)
        self.StyleSetSpec(wx.stc.STC_SQL_STRING, "fore:#FF007F") # "
        self.StyleSetSpec(wx.stc.STC_SQL_CHARACTER, "fore:#FF007F") # "
        self.StyleSetSpec(wx.stc.STC_SQL_QUOTEDIDENTIFIER, "fore:#0000FF")
        self.StyleSetSpec(wx.stc.STC_SQL_WORD, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_WORD2, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_USER1, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_USER2, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_USER3, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_USER4, "fore:#0000FF,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_SQLPLUS, "fore:#ff0000,bold")
        self.StyleSetSpec(wx.stc.STC_SQL_SQLPLUS_COMMENT, "back:#ffff00")
        self.StyleSetSpec(wx.stc.STC_SQL_SQLPLUS_PROMPT, "back:#00ff00")
        # 01234567890.+-e
        self.StyleSetSpec(wx.stc.STC_SQL_NUMBER, "fore:#FF00FF")
        # + - * / % = ! ^ & . , ; <> () [] {}
        self.StyleSetSpec(wx.stc.STC_SQL_OPERATOR, "fore:#0000FF")
        # --...
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENTLINE, "fore:#008000")
        # #...
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENTLINEDOC, "fore:#008000")
        # /*...*/
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENT, "fore:#008000")
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENTDOC, "fore:#008000")
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENTDOCKEYWORD, "back:#AAFFAA")
        self.StyleSetSpec(wx.stc.STC_SQL_COMMENTDOCKEYWORDERROR, "back:#AAFFAA")

        self.StyleSetSpec(wx.stc.STC_STYLE_BRACELIGHT, "fore:#0000FF")
        self.StyleSetSpec(wx.stc.STC_STYLE_BRACEBAD, "fore:#FF0000")

        """
        This is how a non-sorted case-insensitive list can be used.
        self.Bind(wx.stc.EVT_STC_USERLISTSELECTION, self.OnUserListSelected)
        # listType must be > 0, value is not important for STC.
        self.UserListShow(listType=1, itemList=u" ".join(self.autocomps_total))
        def OnUserListSelected(self, event):
            text = event.GetText()
            if text:
                pos = 1#self._posBeforeCompList
                self.SetTargetStart(pos)
                self.SetTargetEnd(self.GetCurrentPos())
                self.ReplaceTarget("")
                self.InsertText(pos, text)
                self.GotoPos(pos + len(text))
        """


    def AutoCompAddWords(self, words):
        """Adds more words used in autocompletion."""
        self.autocomps_added.update(words)
        # A case-insensitive autocomp has to be sorted, will not work
        # properly otherwise. UserList would support arbitrarily sorting.
        self.autocomps_total = sorted(
            list(self.autocomps_added) + self.KEYWORDS, cmp=self.stricmp
        )


    def AutoCompAddSubWords(self, word, subwords):
        """
        Adds more subwords used in autocompletion, will be shown after the word
        and a dot.
        """
        if word not in self.autocomps_added:
            self.AutoCompAddWords([word])
        if subwords:
            word_key = word.upper()
            if word_key not in self.autocomps_subwords:
                self.autocomps_subwords[word_key] = set()
            self.autocomps_subwords[word_key].update(subwords)


    def OnKillFocus(self, event):
        """Handler for control losing focus, hides autocomplete."""
        self.AutoCompCancel()


    def OnKeyDown(self, event):
        """
        Shows autocomplete if user is entering a known word, or pressed
        Ctrl-Space. Added autocomplete words are listed first, SQL keywords
        second.
        """
        skip = True
        if self.CallTipActive():
            self.CallTipCancel()
        if not self.AutoCompActive() and not event.AltDown():
            do_autocomp = False
            words = self.autocomps_total
            autocomp_len = 0
            key_code = event.UnicodeKey
            if wx.WXK_SPACE == event.UnicodeKey and event.CmdDown():
                # Start autocomp when user presses Ctrl+Space
                do_autocomp = True
            elif not event.CmdDown():
                # Check if we have enough valid text to start autocomplete
                char = None
                try: # Not all keycodes can be chars
                    char = chr(event.UnicodeKey).decode("latin1")
                except:
                    pass
                if char not in [wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER, 10, 13] \
                and char is not None:
                    # Get a slice of the text on the current text up to caret.
                    line_text = self.GetTextRange(
                        self.PositionFromLine(self.GetCurrentLine()),
                        self.GetCurrentPos()
                    )
                    text = u""
                    for last_word in re.findall("(\w+)$", line_text):
                        text += last_word
                    text = text.upper()
                    if "." == char:
                        # User entered "word.", show subword autocompletion if
                        # defined for the text.
                        if text in self.autocomps_subwords:
                            words = sorted(
                                self.autocomps_subwords[text], cmp=self.stricmp
                            )
                            do_autocomp = True
                            skip = False
                            self.AddText(char)
                    else:
                        text += char
                        if (len(text) >= self.AUTOCOMP_LEN) and any(filter(
                            lambda x: x.upper().startswith(text),
                            self.autocomps_total
                        )):
                            do_autocomp = True
                            current_pos = self.GetCurrentPos() - 1
                            while chr(self.GetCharAt(current_pos)).isalnum():
                                current_pos -= 1
                            autocomp_len = self.GetCurrentPos() - current_pos - 1
            if do_autocomp:
                if skip: event.Skip()
                self.AutoCompShow(autocomp_len, u" ".join(words))
        elif self.AutoCompActive() and wx.WXK_DELETE == event.KeyCode:
            self.AutoCompCancel()
        if skip: event.Skip()


    def stricmp(self, a, b):
        return cmp(a.lower(), b.lower())



class SearchableStyledTextCtrl(wx.PyPanel):
    """
    A StyledTextCtrl with a search bar that appears on demand, top or bottom.
    Search bar has a text box, next-previous buttons, search options and a
    close button. Next/previous buttons set search direction: after clicking
    "Previous", pressing Enter in search box searches upwards.

    Bar appears on pressing Ctrl-F in the control, or clicking the search icon
    in the right corner (bottom by default).

    @author    Erki Suurjaak
    @created   07.01.2012
    @modified  08.02.2012
    """

    """Ctrl-hotkey for showing-focusing search bar."""
    SEARCH_HOTKEY_CODE = ord("F")

    """Label before the search box."""
    SEARCH_LABEL = "Find: "

    """Label for the Next button."""
    BUTTON_NEXT_LABEL = " Next"

    """Label for the Previous button."""
    BUTTON_PREV_LABEL = " Previous"

    """Label for the "Match case" checkbox."""
    CB_CASE_LABEL = "Match case"

    """Label for the "Match whole word" checkbox."""
    CB_WHOLEWORD_LABEL = "Whole word"

    """Label for the "Match regex" checkbox."""
    CB_REGEX_LABEL = "Regex"

    """Width of the search box, in pixels."""
    SEARCH_WIDTH = 150

    """Background colour for the search edit box if no match found."""
    SEARCH_NOMATCH_BGCOLOUR = wx.NamedColour("#FF6666")

    """Foreground colour for the search edit box if no match found."""
    SEARCH_NOMATCH_FGCOLOUR = wx.NamedColour("#FFFFFF")

    """Font colour of descriptive text in the search box."""
    SEARCH_DESCRIPTIVE_COLOUR = None # Postpone to after wx.App creation

    """Text to be displayed in the search box when it"s empty and unfocused."""
    SEARCH_DESCRIPTIVE_TEXT = "Search for.."

    """Background colour for selected matched text in the control."""
    MATCH_SELECTED_BGCOLOUR = wx.NamedColour("#0A246A")

    """Foreground colour for search buttons."""
    BUTTON_FGCOLOUR = wx.NamedColour("#475358")

    """Top background colour for search button gradient."""
    BUTTON_BGCOLOUR_TOP = wx.NamedColour("#FEFEFE")

    """Middle background colour for search button gradient."""
    BUTTON_BGCOLOUR_MIDDLE = wx.NamedColour("#ECECEC")

    """Bottom background colour for search button gradient."""
    BUTTON_BGCOLOUR_BOTTOM = wx.NamedColour("#DFDFDF")

    """Image for the close button."""
    IMG_CLOSE = wx.lib.embeddedimage.PyEmbeddedImage(
        "iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQ"
        "U1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnL"
        "pRPAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTAw9HKhAAAAUklEQVQoU2N"
        "Yu2nLf7eg8P9AwICMQWIgOQYQA4ZhCpDFwLpgAhWNLf9BGFkD3FhkCRAbZhpcQXlDM1wn"
        "iI2iAGYkSAJZIUgRYUcuX7MOpzdBcgBnRZ25rvtD2gAAAABJRU5ErkJggg==")

    """Image for the Previous button."""
    IMG_PREV = wx.lib.embeddedimage.PyEmbeddedImage(
        "iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAAXNSR0IArs4c6QAAAARnQ"
        "U1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnL"
        "pRPAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTAw9HKhAAAAQklEQVQYV2P"
        "4//8/Aww/efr0f3v/JCD3PwNccPmadf/9o+L/uwWFQySOnjj5PzWvCCwAw/glYOaDjPIO"
        "i0YYhctyAJvWYR0gpxhPAAAAAElFTkSuQmCC")

    """Image for the Next button."""
    IMG_NEXT = wx.lib.embeddedimage.PyEmbeddedImage(
        "iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAAXNSR0IArs4c6QAAAARnQ"
        "U1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnL"
        "pRPAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTAw9HKhAAAARElEQVQYV2P"
        "4//8/Q3v/pP9Pnj4FMv8zwDCY4RYU/t8/Kv7/8jXr4JJwCZAkCKfmFf0/euIkRCtMEKuE"
        "d1g0plHYLAcAYhZhHfMXUEMAAAAASUVORK5CYII=")



    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=(300, 40), style=0, name=wx.stc.STCNameStr,
                 searchBarPos=wx.BOTTOM, searchDirection=wx.DOWN):
        """
        Creates a new searchable StyledTextCtrl instance, with the search bar
        hidden.

        @param   searchPos        vertical position for search bar,
                                  wx.BOTTOM (default) or wx.TOP
        @param   searchDirection  initial search direction,
                                  wx.DOWN (default) or wx.UP
        """
        wx.PyPanel.__init__(self, parent=parent, pos=pos,
            size=size, style=style | wx.TAB_TRAVERSAL
        )
        if not SearchableStyledTextCtrl.SEARCH_DESCRIPTIVE_COLOUR:
            desccolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_DESKTOP)
            SearchableStyledTextCtrl.SEARCH_DESCRIPTIVE_COLOUR = desccolour

        self._search_direction = wx.DOWN if (searchDirection == wx.DOWN) \
                                 else wx.UP
        self._search_pos = -1       # Current search caret position
        self._search_text = ""      # Current search text
        self._search_at_end = False # Is current search position last found?

        self._bar_pos = wx.BOTTOM if (searchBarPos == wx.BOTTOM) else wx.TOP
        self.Sizer = wx.BoxSizer(wx.VERTICAL)

        # Remove border bits from given style, as the border style will be set
        # to the wrapping panel.
        nobits = [wx.BORDER_DOUBLE, wx.BORDER_RAISED, wx.BORDER_SIMPLE,
            wx.BORDER_STATIC, wx.BORDER_SUNKEN, wx.BORDER_THEME, wx.BORDER
        ]
        style_sub = reduce(lambda a, b: a & ~b, nobits, style | wx.BORDER_NONE)
        self._stc = wx.stc.StyledTextCtrl(id=id, parent=self,
            style=style_sub, name=name
        )

        self._button_toggle = wx.lib.agw.shapedbutton.SBitmapButton(
            parent=self._stc, id=wx.ID_ANY, size=(20, 20),
            bitmap=wx.ArtProvider_GetBitmap(wx.ART_FIND, size=(16, 16))
        )
        self._button_toggle.SetUseFocusIndicator(False) # Hide focus marquee
        self._button_toggle.SetToolTipString("Show search bar (Ctrl-F)")

        panel = self._panel_bar = wx.Panel(parent=self)
        sizer_bar = panel.Sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._label_search = wx.StaticText(parent=panel,
            label=self.SEARCH_LABEL
        )
        self._edit = wx.TextCtrl(parent=panel, style=wx.TE_PROCESS_ENTER,
            value=self.SEARCH_DESCRIPTIVE_TEXT, size=(self.SEARCH_WIDTH, -1)
        )
        self._edit.SetForegroundColour(self.SEARCH_DESCRIPTIVE_COLOUR)
        self._button_next = wx.lib.agw.gradientbutton.GradientButton(
            parent=panel, label=self.BUTTON_NEXT_LABEL, size=(-1, 26),
            bitmap=self.IMG_NEXT.GetBitmap()
        )
        self._button_prev = wx.lib.agw.gradientbutton.GradientButton(
            parent=panel, label=self.BUTTON_PREV_LABEL, size=(-1, 26),
            bitmap=self.IMG_PREV.GetBitmap()
        )
        for b in [self._button_next, self._button_prev]:
            b.SetForegroundColour   (self.BUTTON_FGCOLOUR)
            b.SetTopStartColour     (self.BUTTON_BGCOLOUR_TOP)
            b.SetTopEndColour       (self.BUTTON_BGCOLOUR_MIDDLE)
            b.SetBottomStartColour  (self.BUTTON_BGCOLOUR_MIDDLE)
            b.SetBottomEndColour    (self.BUTTON_BGCOLOUR_BOTTOM)
            b.SetPressedTopColour   (self.BUTTON_BGCOLOUR_MIDDLE)
            b.SetPressedBottomColour(self.BUTTON_BGCOLOUR_BOTTOM)
        # Linux tweak: as GradientButtons get their background from their
        # parent, and backgrounds might not propagate well through the window
        # hierarchy, set the parent background to a guaranteed proper one.
        panel.BackgroundColour = self._label_search.BackgroundColour

        self._cb_case = wx.CheckBox(parent=panel, label=self.CB_CASE_LABEL)
        self._cb_wholeword = wx.CheckBox(
            parent=panel, label=self.CB_WHOLEWORD_LABEL
        )
        self._cb_regex = wx.CheckBox(parent=panel, label=self.CB_REGEX_LABEL)
        self._button_close = wx.lib.agw.shapedbutton.SBitmapButton(
            parent=panel, id=wx.ID_ANY, size=(16, 16),
            bitmap=self.IMG_CLOSE.GetBitmap()
        )
        self._button_close.SetUseFocusIndicator(False) # Hide focus marquee
        self._button_close.SetToolTipString("Hide search bar.")
        sizer_bar.Add(self._label_search, border=5,
            flag=wx.LEFT | wx.ALIGN_CENTER_VERTICAL
        )
        sizer_bar.Add(self._edit, border=5,
            flag=wx.LEFT | wx.ALIGN_CENTER_VERTICAL
        )
        sizer_bar.Add(self._button_next, border=5, flag=wx.LEFT)
        sizer_bar.Add(self._button_prev, border=5, flag=wx.LEFT)
        sizer_bar.AddStretchSpacer()
        for i in [self._cb_case, self._cb_wholeword, self._cb_regex]:
            sizer_bar.Add(i, border=5,
                flag=wx.RIGHT | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL
            )
        sizer_bar.Add(self._button_close,
            flag=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL
        )

        # AddMany tuples: (item, proportion=0, flag=0, border=0).
        item_child = (self._stc, 1, wx.EXPAND)
        item_bar = (panel, 0, wx.EXPAND | wx.ALL, 5)
        items = [item_child, item_bar]
        if self._bar_pos != wx.BOTTOM:
            item_bar = (panel, 0,
                wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5
            )
            items = [item_bar, item_chile]
        self.Sizer.AddMany(items)
        self._panel_bar.Hide()

        self._stc.Bind(wx.EVT_KEY_UP, self.OnKeyUpCtrl)
        self._stc.Bind(
            wx.stc.EVT_STC_PAINTED, lambda e: self.UpdateToggleButton()
        )
        self._stc.Bind(
            wx.stc.EVT_STC_UPDATEUI, lambda e: self.UpdateToggleButton()
        )
        self._edit.Bind(wx.EVT_SET_FOCUS, self.OnFocusSearch)
        self._edit.Bind(wx.EVT_KILL_FOCUS, self.OnFocusSearch)
        self._edit.Bind(wx.EVT_TEXT_ENTER, lambda e: self.DoSearch())
        self._edit.Bind(wx.EVT_TEXT, self.OnTextSearch)
        self._edit.Bind(wx.EVT_KEY_DOWN, self.OnKeyDownSearch)
        self._button_next.Bind(wx.EVT_BUTTON, self.OnButtonSearchNext)
        self._button_prev.Bind(wx.EVT_BUTTON, self.OnButtonSearchPrev)
        self._button_close.Bind(wx.EVT_BUTTON, self.OnButtonClose)
        self._button_toggle.Bind(
            wx.EVT_BUTTON, lambda e: self.ToggleSearchBar()
        )
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Layout()


    def SetFocusSearch(self, selectAll=True):
        """Sets focus to the search box."""
        self._edit.SetFocus()
        if selectAll:
            self._edit.SelectAll()


    def GetSearchBarPosition(self):
        """
        Returns the current vertical position of the search bar,
        wx.BOTTOM (default) or wx.TOP.
        """
        return self._bar_pos
    def SetSearchBarPosition(self, pos):
        """
        Sets the current vertical position of the search bar,
        wx.BOTTOM (default) or wx.TOP.
        """
        prev_pos = self._bar_pos
        self._bar_pos = wx.TOP if (pos == wx.TOP) else wx.BOTTOM
        if prev_pos != pos:
            item = (self._panel_bar, 0, wx.EXPAND | wx.ALL, 5)
            if pos == wx.BOTTOM:
                item = (self._panel_bar, 0, wx.EXPAND | wx.ALL, 5)
            self.Sizer.Remove(self.Sizer.GetItemIndex(self._panel_bar))
            self.Sizer.Insert(0, *item)
            self.UpdateToggleButton()
            #self.Layout()
    SearchBarPosition = property(GetSearchBarPosition, SetSearchBarPosition,
        doc=
        """
        Current vertical position of the search bar,
        wx.BOTTOM (default) or wx.TOP.
        """
    )


    def GetSearchDirection(self):
        """Returns the current search direction, wx.DOWN (default) or wx.UP."""
        return self._search_direction
    def SetSearchDirection(self, direction):
        """Sets the current search direction, wx.DOWN (default) or wx.UP."""
        self._search_direction = wx.DOWN if (direction == wx.DOWN) else wx.UP
    SearchDirection = property(GetSearchDirection, SetSearchDirection,
        doc="Current search direction, wx.DOWN (default) or wx.UP."
    )


    def GetSearchText(self):
        """Returns the currently set search text, if any."""
        return self._search_text


    def GetSearchPosition(self):
        """
        Returns the current search position, in characters. Next search
        will start from this position.
        """
        return self._search_pos
    def SetSearchPosition(self, position):
        """
        Sets the current search position, in characters. Next search
        will start from this position, or from start position if negative.
        """
        self._search_pos = int(position)
    SearchPosition = property(GetSearchPosition, SetSearchPosition, doc=\
        """
        Current search position, in characters. Next search will
        will start from this position, or from start position if negative.
        """
    )


    def IsSearchBarVisible(self):
        """Returns whether the search bar is currently visible."""
        return self._panel_bar.Shown
    def SetSearchBarVisible(self, visible=True):
        """Sets the search bar visible/hidden."""
        self._panel_bar.Shown = visible
        self._button_toggle.Shown = not visible
        self.Layout()
    SearchBarVisible = property(IsSearchBarVisible, SetSearchBarVisible, doc=\
        """Search bar visibility."""
    )


    def FindNext(self, text, flags=0, direction=wx.DOWN):
        """
        Finds and selects the next occurrence of the specified text from the
        current search position, in the current search direction.

        @param   text   text string to search
        @param   flags  search flags (wx.stc.STC_FIND_*)
        @return         position of found match, negative if no more found
        """
        pos_found = -1
        if text:
            down = (self._search_direction == wx.DOWN)
            pos = self._search_pos or (0 if down else self._stc.Length)
            if self._search_at_end and text == self._search_text:
                # Wrap search around to direction start if last search was
                # unsuccessful for the same text.
                pos = 0 if down else self._stc.Length
                self._search_at_end = False
            elif down and pos <= self.Length and text == self._search_text:
                # Increment position if searching downwards for same text, STC
                # remains stuck in last found position otherwise.
                pos += 1
            self.SetCurrentPos(pos)
            self.SetAnchor(pos)
            self.SearchAnchor()
            functions = {wx.DOWN: self.SearchNext, wx.UP: self.SearchPrev}
            final = text if type(text) is unicode else text.decode("utf-8")
            self._search_pos = functions[self._search_direction](flags, final)
            if (self._search_pos < 0):
                # There are no more matches: clear selection and reset position
                self.SetSelection(-1, 0)
                self._search_at_end = True
                self._search_pos = None
            else:
                # Match found
                pos_found = self._search_pos
                self.EnsureCaretVisible() # Scrolls to search anchor
                self._search_at_end = False
        else: # No search text at all: clear selection
            self.SetSelection(-1, 0)
        self._search_text = text
        return pos_found


    def Search(self, text, flags=0, direction=wx.DOWN, position=0):
        """
        Finds and selects the next occurrence of specified text with the
        specified settings, and sets the search parameters into the search bar.

        @param   text       text string to search
        @param   flags      search flags (wx.stc.STC_FIND_*)
        @param   direction  search direction, wx.DOWN (default) or wx.UP
        @param   position   search position, in characters
        @return             position of found match, negative if not found
        """
        self._edit.Value = text
        self._cb_case.Value = (flags & wx.stc.STC_FIND_MATCHCASE)
        self._cb_wholeword.Value = (flags & wx.stc.STC_FIND_WHOLEWORD)
        self._cb_regex.Value = (flags & wx.stc.STC_FIND_REGEXP)
        self.SearchDirection = direction
        self.SearchPosition = position
        self.DoSearch()


    def DoSearch(self):
        """
        Searches for currently entered search text from the current search
        position, in the current search direction. Search is wrapped around
        to direction start.
        """
        text = self._edit.Value
        nomatch = False
        if text and text != self.SEARCH_DESCRIPTIVE_TEXT:
            flags = 0
            if self._cb_case.Value:
                flags |= wx.stc.STC_FIND_MATCHCASE
            if self._cb_wholeword.Value:
                flags |= wx.stc.STC_FIND_WHOLEWORD
            if self._cb_regex.Value:
                flags |= wx.stc.STC_FIND_REGEXP
            nomatch = self.FindNext(text, flags, self._search_direction) < 0
        if text != self.SEARCH_DESCRIPTIVE_TEXT:
            bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
            self._edit.SetBackgroundColour(self.SEARCH_NOMATCH_BGCOLOUR
                if nomatch else bgcolour)
            self._edit.SetForegroundColour(self.SEARCH_NOMATCH_FGCOLOUR
                if nomatch else self.ForegroundColour)
            self._edit.Refresh() # Repaint text box colours


    def ToggleSearchBar(self):
        """
        Toggles the search bar visible/hidden.
        """
        self._panel_bar.Show(not self._panel_bar.Shown)
        self._button_toggle.Show(not self._panel_bar.Shown)
        if self._panel_bar.Shown:
            self._edit.SetFocus()
            self._edit.SelectAll()
        else:
            self._stc.SetFocus()
        self.SendSizeEvent()


    def OnSize(self, event):
        """Repositions toggle search button."""
        self.Layout() # Force size update
        self.UpdateToggleButton()
        event.Skip()


    def UpdateToggleButton(self):
        """Updates the toggle button position."""
        size_btn = self._button_toggle.Size
        size_stc = self._stc.ClientRect
        newpos = wx.Point(
            size_stc.width - size_btn.width, size_stc.height - size_btn.height
        )
        if self._bar_pos != wx.BOTTOM:
            newpos.y = 0
        if self._button_toggle.Position != newpos:
            self._button_toggle.Position = newpos


    def OnButtonClose(self, event):
        """Handler for clicking the Close button, hides the search bar."""
        self.ToggleSearchBar()
        self._stc.SetFocus()


    def OnFocusSearch(self, event):
        """
        Handler for focusing/unfocusing the search control, shows/hides
        description.
        """
        if self.FindFocus() == self._edit:
            if self._edit.Value == self.SEARCH_DESCRIPTIVE_TEXT:
                self._edit.SetForegroundColour(self.ForegroundColour)
                self._edit.Value = ""
        else:
            if not self._edit.Value:
                self._edit.SetForegroundColour(self.SEARCH_DESCRIPTIVE_COLOUR)
                self._edit.Value = self.SEARCH_DESCRIPTIVE_TEXT
        event.Skip() # Allow to propagate to parent, to show having focus


    def OnKeyUpCtrl(self, event):
        """Shows and focuses search on Ctrl-F."""
        if self.SEARCH_HOTKEY_CODE == event.KeyCode and event.CmdDown():
            if not self._panel_bar.Shown:
                self.SetSearchBarVisible(True)
            self._edit.SetFocus()
            self._edit.SelectAll()
        event.Skip() # Allow event to propagate


    def OnKeyDownSearch(self, event):
        """Handler for key down in search box, hides search bar on escape."""
        if (wx.WXK_ESCAPE == event.KeyCode):
            self.SetSearchBarVisible(False)
            self._stc.SetFocus()
        else:
            event.Skip() # Allow event to propagate


    def OnTextSearch(self, event):
        """
        Handler for entering text in search box, calls search if not
        entering a regular expression.
        """
        if not self._cb_regex.Value:
            self.DoSearch()


    def OnButtonSearchNext(self, event):
        """
        Handler for the Next button, searches downwards from the current
        search position.
        """
        self._search_direction = wx.DOWN
        self.DoSearch()


    def OnButtonSearchPrev(self, event):
        """
        Handler for the Previous button, searches downwards from the current
        search position.
        """
        self._search_direction = wx.UP
        self.DoSearch()


    def __getattr__(self, name):
        """Wraps all access to StyledTextCtrl transparently."""
        attr = None
        if hasattr(SearchableStyledTextCtrl, name):
            attr = getattr(self, name)
        elif hasattr(self._stc, name):
            attr = getattr(self._stc, name)
        else:
            raise AttributeError("\"%s\" object has no attribute \"%s\"" % (
                self.__class__.__name__, name
            ))
        return attr


    STC = property(lambda s: s._stc)



TabLeftDClickEvent, EVT_TAB_LEFT_DCLICK = wx.lib.newevent.NewEvent()

class TabbedHtmlWindow(wx.PyPanel):
    """
    HtmlWindow with tabs for different content pages.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.html.HW_DEFAULT_STYLE,
                 name=wx.html.HtmlWindowNameStr):
        wx.PyPanel.__init__(self, parent, pos=pos, size=size, style=style)
        # [{"title", "content", "id", "info", "scrollpos", "scrollrange"}]
        self._tabs = []
        self._default_page = ""      # Content shown on the blank page
        self._delete_callback = None # Function called after deleting a tab
        bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
        tabcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNFACE)
        self.BackgroundColour = bgcolour

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        notebook = self._notebook = wx.lib.agw.flatnotebook.FlatNotebook(
            parent=self, size=(-1, 27),
            agwStyle=wx.lib.agw.flatnotebook.FNB_NO_X_BUTTON |
                     wx.lib.agw.flatnotebook.FNB_MOUSE_MIDDLE_CLOSES_TABS |
                     wx.lib.agw.flatnotebook.FNB_NO_TAB_FOCUS |
                     wx.lib.agw.flatnotebook.FNB_VC8)
        self._html = wx.html.HtmlWindow(parent=self, style=style, name=name)

        self.Sizer.Add(notebook, flag=wx.GROW)
        self.Sizer.Add(self._html, proportion=1, flag=wx.GROW)

        self._html.Bind(wx.EVT_SIZE, self._OnSize)
        notebook.GetTabArea().Bind(wx.EVT_LEFT_DCLICK, self._OnLeftDClickTabArea)
        notebook.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self._OnChangeTab)
        notebook.Bind(wx.lib.agw.flatnotebook.EVT_FLATNOTEBOOK_PAGE_CLOSING,
                      self._OnDeleteTab)
        notebook.Bind(wx.lib.agw.flatnotebook.EVT_FLATNOTEBOOK_PAGE_DROPPED,
                      self._OnDropTab)
        self._html.Bind(wx.EVT_SCROLLWIN, self._OnScroll)

        notebook.SetActiveTabColour(bgcolour)
        notebook.SetTabAreaColour(tabcolour)
        try: notebook._pages.GetSingleLineBorderColour = notebook.GetActiveTabColour
        except: pass # Hack to get uniform background colour

        # Monkey-patch object with HtmlWindow and FlatNotebook attributes
        for name in ["Scroll", "GetScrollRange", "GetScrollPos",
                     "GetBackgroundColour", "SetBackgroundColour"]:
            setattr(self, name, getattr(self._html, name))
        for name in ["GetTabAreaColour", "SetTabAreaColour"]:
            setattr(self, name, getattr(self._notebook, name))

        self._CreateTab(0, "") # Make default empty tab in notebook with no text
        self.Layout()


    def _OnLeftDClickTabArea(self, event):
        """Fires a TabLeftDClickEvent if a tab header was double-clicked."""
        area = self._notebook.GetTabArea()
        where, tab = area.HitTest(event.GetPosition())
        if wx.lib.agw.flatnotebook.FNB_TAB == where and tab < len(self._tabs):
            wx.PostEvent(self, TabLeftDClickEvent(Data=self._tabs[tab]))


    def _OnSize(self, event):
        """
        Handler for sizing the HtmlWindow, sets new scroll position based
        previously stored one (HtmlWindow loses its scroll position on resize).
        """
        if self._tabs:
            tab = self._tabs[self._notebook.GetSelection()]
            for i in range(2):
                orient = wx.VERTICAL if i else wx.HORIZONTAL
                # Division can be > 1 on first resizings, bound it to 1.
                pos, rng = tab["scrollpos"][i], tab["scrollrange"][i]
                ratio = pos / float(rng) if rng else 0.0
                ratio = min(1, pos / float(rng) if rng else 0.0)
                tab["scrollpos"][i] = ratio * self.GetScrollRange(orient)
            # Execute scroll later as something resets it after this handler
            try:
                wx.CallLater(50, lambda:
                             self.Scroll(*tab["scrollpos"]) if self else None)
            except:
                pass # CallLater fails if not called from the main thread
        event.Skip() # Allow event to propagate to wx handler



    def _OnScroll(self, event):
        """
        Handler for scrolling the window, stores scroll position
        (HtmlWindow loses it on resize).
        """
        event.Skip() # Propagate to wx handler and get updated results later
        wx.CallAfter(self._StoreScrollPos)


    def _StoreScrollPos(self):
        """Stores the current scroll position for the current tab, if any."""
        if self and self._tabs:
            tab = self._tabs[self._notebook.GetSelection()]
            tab["scrollpos"]   = [self.GetScrollPos(wx.HORIZONTAL),
                                  self.GetScrollPos(wx.VERTICAL)]
            tab["scrollrange"] = [self.GetScrollRange(wx.HORIZONTAL),
                                  self.GetScrollRange(wx.VERTICAL)]
        

    def _OnChangeTab(self, event):
        """Handler for selecting another tab in notebook, loads tab content."""
        if self._tabs:
            self.SetActiveTab(self._notebook.GetSelection())
            # Forward event to TabbedHtmlWindow listeners
            wx.PostEvent(self.GetEventHandler(), event)


    def _OnDropTab(self, event):
        """Handler for dropping a dragged tab."""
        new, old = event.GetSelection(), event.GetOldSelection()
        new = min(new, len(self._tabs) - 1) # Can go over the edge
        if self._tabs and new != old and new >= 0:
            self._tabs[old], self._tabs[new] = self._tabs[new], self._tabs[old]


    def _OnDeleteTab(self, event):
        """Handler for clicking in notebook to close a tab."""
        if not self._tabs:
            event.Veto() # User clicked to delete the default page, cancel
        else:
            nb = self._notebook
            tab = self._tabs[event.GetSelection()]
            self._tabs.remove(tab)
            if 1 == nb.GetPageCount(): # Was the only page,
                nb.SetPageText(0, "")  # reuse as default empty tab
                event.Veto()
                self._SetPage(self._default_page)
                # Default empty tab has no closing X: remove X from tab style
                style = nb.GetAGWWindowStyleFlag()
                style ^= wx.lib.agw.flatnotebook.FNB_X_ON_TAB
                nb.SetAGWWindowStyleFlag(style)
            else:
                index = min(nb.GetSelection(), nb.GetPageCount() - 2)
                self.SetActiveTab(index)
            if self._delete_callback:
                self._delete_callback(tab)


    def _CreateTab(self, index, title):
        """Creates a new tab in the tab container at specified index."""
        p = wx.Panel(parent=self, size=(0,0)) 
        p.Hide() # Dummy empty window as notebook needs something to hold
        self._notebook.InsertPage(index, page=p, text=title, select=True)


    def _SetPage(self, content):
        """Sets current HTML page content."""
        self._html.SetPage(content)
        bgcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
        self._html.SetBackgroundColour(bgcolour)


    def SetDeleteCallback(self, callback):
        """Sets the function called after deleting a tab, with tab data."""
        self._delete_callback = callback


    def SetDefaultPage(self, content):
        self._default_page = content
        if not self._tabs:
            self._SetPage(self._default_page)


    def InsertTab(self, index, title, id, content, info):
        """
        Inserts a new tab with the specified title and content at the specified
        index, and activates the new tab.
        """
        tab = {"title": title, "content": content, "id": id,
               "scrollpos": [0, 0], "scrollrange": [0, 0], "info": info}
        is_empty = bool(self._tabs)
        self._tabs.insert(index, tab)
        if is_empty:
            self._CreateTab(index, tab["title"])
        else: # First real tab: fill the default empty one
            self._notebook.SetPageText(0, tab["title"])
            # Default empty tab had no closing X: add X to tab style
            style = self._notebook.GetAGWWindowStyleFlag()
            style |= wx.lib.agw.flatnotebook.FNB_X_ON_TAB
            self._notebook.SetAGWWindowStyleFlag(style)

        self._html.Freeze()
        self._SetPage(tab["content"])
        self._html.Thaw()


    def GetTabDataByID(self, id):
        """Returns the data of the tab with the specified ID, or None."""
        result = next((x for x in self._tabs if x["id"] == id), None)
        return result


    def SetTabDataByID(self, id, title, content, info, new_id=None):
        """
        Sets the title, content and info of the tab with the specified ID.

        @param   info    additional info associated with the tab
        @param   new_id  if set, tab ID is updated to this
        """
        tab = next((x for x in self._tabs if x["id"] == id), None)
        if tab:
            tab["title"], tab["content"], tab["info"] = title, content, info
            if new_id is not None:
                tab["id"] = new_id
            self._notebook.SetPageText(self._tabs.index(tab), tab["title"])
            self._notebook.Refresh()
            if self._tabs[self._notebook.GetSelection()] == tab:
                self._html.Freeze()
                self._SetPage(tab["content"])
                self._html.Scroll(*tab["scrollpos"])
                self._html.Thaw()


    def SetActiveTab(self, index):
        """Sets active the tab at the specified index."""
        tab = self._tabs[index]
        self._notebook.SetSelection(index)
        self._html.Freeze()
        self._SetPage(tab["content"])
        self._html.Scroll(*tab["scrollpos"])
        self._html.Thaw()


    def SetActiveTabByID(self, id):
        """Sets active the tab with the specified ID."""
        tab = next((x for x in self._tabs if x["id"] == id), None)
        index = self._tabs.index(tab)
        self._notebook.SetSelection(index)
        self._html.Freeze()
        self._SetPage(tab["content"])
        self._html.Scroll(*tab["scrollpos"])
        self._html.Thaw()


    def GetActiveTabData(self):
        """Returns all the data for the active tab."""
        if self._tabs:
            return self._tabs[self._notebook.GetSelection()]


    def GetTabCount(self):
        """Returns the number of tabs (default empty tab is not counted)."""
        return len(self._tabs)



class TextCtrlAutoComplete(wx.TextCtrl):
    """
    A text control with autocomplete using a dropdown list of choices. During
    typing, the first matching choice is appended to textbox value, with the
    appended text auto-selected.
    Fires a wx.EVT_LIST_DELETE_ALL_ITEMS event if user clicked to clear all
    choices.

    If wx.PopupWindow is not available (Mac), behaves like a common TextCtrl.
    Based on TextCtrlAutoComplete by Michele Petrazzo, from a post
    on 09.02.2006 in wxPython-users thread "TextCtrlAutoComplete",
    http://wxpython-users.1045709.n5.nabble.com/TextCtrlAutoComplete-td2348906.html
    """
    DROPDOWN_COUNT_PER_PAGE = 8
    DROPDOWN_CLEAR_TEXT = "Clear search history"
    DROPDOWN_CLEAR_COLOUR = "blue"
    DROPDOWN_TEXT_COLOUR = None # Postpone to after wx.App creation
    DESCRIPTION_COLOUR = None # Postpone to after wx.App creation


    def __init__(self, parent, choices=None, description="",
                 **kwargs):
        """
        @param   choices      list of auto-complete choices, if any
        @param   description  description text shown if nothing entered yet
        """
        if "style" in kwargs:
            kwargs["style"] = wx.TE_PROCESS_ENTER | kwargs["style"]
        else:
            kwargs["style"] = wx.TE_PROCESS_ENTER
        wx.TextCtrl.__init__(self, parent, **kwargs)
        self._text_colour = self.GetForegroundColour()

        if not TextCtrlAutoComplete.DROPDOWN_TEXT_COLOUR:
            graycolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
            TextCtrlAutoComplete.DROPDOWN_TEXT_COLOUR = graycolour
            TextCtrlAutoComplete.DESCRIPTION_COLOUR = graycolour

        self._choices = [] # Ordered case-insensitively
        self._choices_lower = [] # Cached lower-case choices
        self._ignore_textchange = False # ignore next OnText
        self._skip_autocomplete = False # skip setting textbox value in OnText
        self._lastinsertionpoint = None # For whether to show dropdown on click
        self._description = description
        self._description_on = False # Is textbox filled with description?
        if not self.Value:
            self.Value = self._description
            self.SetForegroundColour(self.DESCRIPTION_COLOUR)
            self._description_on = True
        try:
            self._listwindow = wx.PopupWindow(self)
            self._listbox = wx.ListCtrl(self._listwindow, pos=(0, 0),
                                        style=wx.BORDER_SIMPLE | wx.LC_REPORT
                                        | wx.LC_SINGLE_SEL | wx.LC_NO_HEADER)
        except AttributeError:
            # Probably Mac, where wx.PopupWindow does not exist yet as of 2013.
            self._listbox = self._listwindow = None

        if self._listbox:
            self._listbox.TextColour = self.DROPDOWN_TEXT_COLOUR
            self.SetChoices(choices or [])
            self._cursor = None
            # For changing cursor when hovering over final "Clear" item.
            self._cursor_action_hover = wx.StockCursor(wx.CURSOR_HAND)
            self._cursor_default      = wx.StockCursor(wx.CURSOR_DEFAULT)

            gp = self
            while gp is not None:
                # Dropdown has absolute position, must be moved when parent is.
                gp.Bind(wx.EVT_MOVE,                self.OnSizedOrMoved, gp)
                gp.Bind(wx.EVT_SIZE,                self.OnSizedOrMoved, gp)
                gp = gp.GetParent()
            self.Bind(wx.EVT_TEXT,                  self.OnText, self)
            self.Bind(wx.EVT_KEY_DOWN,              self.OnKeyDown, self)
            self.Bind(wx.EVT_LEFT_DOWN,             self.OnClickDown, self)
            self.Bind(wx.EVT_LEFT_UP,               self.OnClickUp, self)
            self._listbox.Bind(wx.EVT_LEFT_DOWN,    self.OnListClick)
            self._listbox.Bind(wx.EVT_LEFT_DCLICK,  self.OnListDClick)
            self._listbox.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouse)
            self._listwindow.Bind(wx.EVT_LISTBOX,   self.OnListItemSelected,
                                  self._listbox)
        self.Bind(wx.EVT_SET_FOCUS,                 self.OnFocus, self)
        self.Bind(wx.EVT_KILL_FOCUS,                self.OnFocus, self)


    def OnListClick(self, event):
        """Handler for clicking the dropdown list, selects the clicked item."""
        index, flag = self._listbox.HitTest(event.GetPosition())
        if len(self._choices) > index >= 0:
            self._listbox.Select(index)
        elif index == len(self._choices) + 1: # Clicked "Clear choices" item
            event = wx.CommandEvent(wx.wxEVT_COMMAND_LIST_DELETE_ALL_ITEMS,
                                    self.GetId())
            wx.PostEvent(self, event)


    def OnListDClick(self, event):
        """
        Handler for double-clicking the dropdown list, sets textbox value to
        selected item and fires TEXT_ENTER.
        """
        self.SetValueFromSelected()
        enterevent = wx.CommandEvent(wx.wxEVT_COMMAND_TEXT_ENTER, self.GetId())
        wx.PostEvent(self, enterevent)


    def OnSizedOrMoved(self, event):
        """
        Handler for moving or sizing the control or any parent, hides dropdown.
        """
        if self:
            self.ShowDropDown(False)
        event.Skip()


    def OnClickDown(self, event):
        """
        Handler for clicking and holding left mouse button, remembers click
        position.
        """
        self._lastinsertionpoint = self.GetInsertionPoint()
        event.Skip()


    def OnClickUp(self, event):
        """
        Handler for releasing left mouse button, toggles dropdown list
        visibility on/off if clicking same spot in textbox.
        """
        if (self.GetInsertionPoint() == self._lastinsertionpoint):
            self.ShowDropDown(not self._listwindow.Shown)
        event.Skip()


    def OnListItemSelected(self, event):
        """
        Handler for selecting an item in the dropdown list, sets its value to
        textbox.
        """
        self.SetValueFromSelected()
        event.Skip()


    def OnFocus(self, event):
        """
        Handler for focusing/unfocusing the control, shows/hides description.
        """
        if self and self.FindFocus() == self:
            if self._description_on:
                self.Value = ""
            self.SelectAll()
        elif self:
            if self._description and not self.Value:
                # Control has been unfocused, set and colour description
                self.Value = self._description
                self.SetForegroundColour(self.DESCRIPTION_COLOUR)
                self._description_on = True
            if self._listbox:
                self.ShowDropDown(False)
        event.Skip() # Allow to propagate to parent, to show having focus


    def OnMouse(self, event):
        """
        Handler for mouse events, changes cursor to pointer if hovering over
        action item like "Clear history".
        """
        index, flag = self._listbox.HitTest(event.GetPosition())
        if index == self._listbox.ItemCount - 1:
            if self._cursor != self._cursor_action_hover:
                self._cursor = self._cursor_action_hover
                self._listbox.SetCursor(self._cursor_action_hover)
        elif self._cursor == self._cursor_action_hover:
            self._cursor = self._cursor_default
            self._listbox.SetCursor(self._cursor_default)
        event.Skip()


    def OnKeyDown(self, event):
        """Handler for any keypress, changes dropdown items."""
        if not self._choices:
            return event.Skip()

        skip = True
        visible = self._listwindow.Shown
        selected = self._listbox.GetFirstSelected()
        selected_new = None
        if event.KeyCode in [wx.WXK_DOWN, wx.WXK_UP]:
            if visible:
                step = 1 if (wx.WXK_UP != event.KeyCode) else -1
                itemcount = len(self._choices)
                selected_new = min(itemcount - 1, max(0, selected + step))
                self._listbox.Select(selected_new)
                ensured = selected_new + (0
                          if selected_new != len(self._choices) - 1 else 2)
                self._listbox.EnsureVisible(ensured)
            self.ShowDropDown()
            skip = False
        elif event.KeyCode in [wx.WXK_PAGEDOWN, wx.WXK_PAGEUP]:
            if visible:
                step = 1 if (wx.WXK_PAGEUP != event.KeyCode) else -1
                self._listbox.ScrollPages(step)
                itemcount = len(self._choices)
                countperpage = self._listbox.CountPerPage
                next_pos = selected + countperpage * step
                selected_new = min(itemcount - 1, max(0, next_pos))
                ensured = selected_new + (0
                          if selected_new != len(self._choices) - 1 else 2)
                self._listbox.EnsureVisible(ensured)
                self._listbox.Select(selected_new)
            self.ShowDropDown()
            skip = False
        elif event.KeyCode in [wx.WXK_BACK, wx.WXK_DELETE]:
            #if self.Value:
            self._skip_autocomplete = True
            self.ShowDropDown()
        try:
            keychar = chr(event.KeyCode)
        except:
            keychar = str(event.KeyCode)
        if visible:
            if selected_new is not None: # Replace textbox value with new text
                self._ignore_textchange = True
                self.Value = self._listbox.GetItemText(selected_new)
                self.SetInsertionPointEnd()
            if wx.WXK_RETURN == event.KeyCode:
                self.ShowDropDown(False)
            if wx.WXK_ESCAPE == event.KeyCode:
                self.ShowDropDown(False)
                skip = False
        if skip:
            event.Skip()


    def OnText(self, event):
        """
        Handler for changing textbox value, auto-completes the text and selects
        matching item in dropdown list, if any.
        """
        if self._ignore_textchange:
            self._ignore_textchange = self._skip_autocomplete = False
            event.Skip()
            return
        text = self.Value
        if text and not self._description_on:
            found = False
            text_lower = text.lower()
            for i, choice in enumerate(self._choices):
                if self._choices_lower[i].startswith(text_lower):
                    choice = text + choice[len(text):]
                    found = True
                    self.ShowDropDown(True)
                    self._listbox.Select(i)
                    self._listbox.EnsureVisible(i)
                    if not self._skip_autocomplete:
                        # Use a callback function to change value - changing
                        # value inside handler causes multiple events in Linux.
                        def autocomplete_callback():
                            if self and self.Value == text: # Can have changed
                                self._ignore_textchange = True # To skip OnText
                                self.Value = choice # Auto-complete text
                                self.SetSelection(len(text), -1) # Select added
                        wx.CallAfter(autocomplete_callback)
                    break
            if not found: # Deselect currently selected item
                self._listbox.Select(self._listbox.GetFirstSelected(), False)
        else:
            self.ShowDropDown(False)
        self._skip_autocomplete = False
        event.Skip()


    def SetChoices(self, choices):
        """Sets the choices available in the dropdown list."""
        if choices:
            lower = [i.lower() for i in choices]
            sorted_all = sorted(zip(lower, choices)) # [("a", "A"), ("b", "b")]
            self._choices_lower, self._choices = map(list, zip(*sorted_all))
        else:
            self._choices_lower, self._choices = [], []

        if self._listbox:
            self._listbox.ClearAll()
            self._listbox.InsertColumn(0, "Select")
            choices = self._choices[:]
            choices += ["", self.DROPDOWN_CLEAR_TEXT] if choices else []
            for i, text in enumerate(choices):
                self._listbox.InsertStringItem(i, text)
            if choices: # Colour "Clear" item
                self._listbox.SetItemTextColour(i, self.DROPDOWN_CLEAR_COLOUR)

            itemheight = self._listbox.GetItemRect(0)[-1] if choices else 0
            itemcount = min(len(choices), self.DROPDOWN_COUNT_PER_PAGE)
            # Leave room vertically for border and padding.
            size = wx.Size(self.Size.width - 3, itemheight * itemcount + 5)
            self._listbox.Size = self._listwindow.Size = size
            # Leave room for vertical scrollbar
            self._listbox.SetColumnWidth(0, size.width - 16)
            self._listbox.SetScrollbar(wx.HORIZONTAL, 0, 0, 0)


    def SetValueFromSelected(self):
        """Sets the textbox value from the selected dropdown item, if any."""
        selected = self._listbox.GetFirstSelected()
        if len(self._choices) > selected >= 0:
            self.SetValue(self._listbox.GetItemText(selected))
            self.SetInsertionPointEnd()
            self.SetSelection(-1, -1)
            self.ShowDropDown(False)


    def ShowDropDown(self, show=True):
        """Toggles the dropdown list visibility on/off."""
        if show and self.IsShownOnScreen() and self._choices and self._listwindow:
            size = self._listwindow.GetSize()
            width, height = self.Size.width - 3, self.Size.height
            x, y = self.ClientToScreenXY(0, height - 2)
            if size.GetWidth() <> width:
                size.SetWidth(width)
                self._listwindow.SetSize(size)
                self._listbox.SetSize(self._listwindow.GetClientSize())
                # Leave room for vertical scrollbar
                self._listbox.SetColumnWidth(0, width - 16)
                self._listbox.SetScrollbar(wx.HORIZONTAL, 0, 0, 0)
            if y + size.GetHeight() < wx.GetDisplaySize().height:
                self._listwindow.SetPosition((x, y))
            else: # No room at the bottom: show dropdown on top of textbox
                self._listwindow.SetPosition((x, y - height - size.height))
            self._listwindow.Show()
        elif self._listwindow:
            self._listwindow.Hide()


    def IsDropDownShown(self):
        """Returns whether the dropdown window is currently shown."""
        return self._listwindow.Shown


    def GetValue(self):
        """
        Returns the current value in the text field, or empty string if filled
        with description.
        """
        value = wx.TextCtrl.GetValue(self)
        if self._description_on:
            value = ""
        return value
    def SetValue(self, value):
        """Sets the value in the text entry field."""
        self.SetForegroundColour(self._text_colour)
        self._description_on = False
        self._ignore_textchange = True
        return wx.TextCtrl.SetValue(self, value)
    Value = property(GetValue, SetValue)

########NEW FILE########
__FILENAME__ = emoticons
"""
Contains embedded Skype emoticon image resources. Auto-generated.
Skype emoticon images are property of Skype, released under the
Skype Component License 1.0.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@created     11.06.2013
@modified    31.01.2014
------------------------------------------------------------------------------
"""
try:
    import wx
    from wx.lib.embeddedimage import PyEmbeddedImage
except ImportError:
    class PyEmbeddedImage(object):
        """Data stand-in for wx.lib.embeddedimage.PyEmbeddedImage."""
        def __init__(self, data):
            self.data = data


"""Skype emoticon "Angel (angel)"."""
angel = PyEmbeddedImage(
    "R0lGODlhEwATAPfOAP///zMzM5lmM//44f/04v/z4//64//iiOO3A//crv/UHf///v/DMv+/"
    "aP/Hff7THP/88v/89P/fqv/drf/Lav/ssf/ss//JK//ktP/Eav/jjP/PJf+4Kf/DKv/bh//I"
    "H/+5JP+5Jv/GLv/XGv/FK/+5PP+9Kv/rtf/JIv+7Jf/Va//cXP/aXf+qLP/eq//HKv/LOP/Q"
    "IP7FL/+/Of+0KP/MH//Xaf/CMv/DLf/JO/7IL//QTf/MIv/AI//rtP7NIf+yJ//chv/OJP+7"
    "K//HIf/Fd//PH/+0K/+8MP+zNP/MJv++Mf/GeP/jtP+/J//RTP/NKP/jjf/hi//QI/7RHv/R"
    "JP7HL/+/Lv+7Pf/ih//MOf+8J/+/If/YaP/ALP/OT//EI//EUf+7R//pgf/PNf/sp/+yKv/g"
    "qf++RP+9Nv/rs/+0Lv+8M/++Uf7ILv/ZZ//EMuO3Av/EJv+2Jf+wJ//RHf/FJv+uN/+3Iv+/"
    "Kf/AM//BL//55P/XG//CJf/gjP/TS/+5Lv/CKf+8Wf/CaOjEMv/HZv/EZv+8Of+2NP/Gd//C"
    "TuzNUf/AP//z5P/76//EaP/BU/+/QOrJQfPfkP/hif/Ba/+xOP+8WuO2AOe/IPz24OrIQO/V"
    "be7SYf/77P/67P367/378PTkn//HJ/+xOf/Kaue/If/04/z34/367PDXdPv23+jCK/fqtP/s"
    "suS3Bf+9Of/Laf/druW8FPz24fjsvP/fqf+7WuS4B/+/P+jEMf/BVP/Bav/DaPnuxO7SYv+1"
    "NP/EZ//Gdvjtv/++P//Caea9Ge7TZv/BTv/HZ//+/f+8WO7RYP///wAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFADOACwA"
    "AAAAEwATAAAI7wCdCRxIsKDBgwgTKlzIkGACBw2YNHCQQGGBIk0GaNSIQVGBgwUInVBjoYLJ"
    "VxZ8HPpYEJOHPwJiZokpQEqQQQUniFHRJQqoR2UefdLwxgaaCQQtYfnyJEKAAAueRgC0YwYk"
    "gnfM5NAC4WnUABDIwJiThGALIHkusOBjYIwBAyugyMFDh+AlGinA8IihoM8IBUY+cAGRiGCG"
    "I1v8oPhB5cGDOjWI9AhhiKCLNUMEBVCyocoUIQHsOOEgoWCbQF5IPF39ooOJRQYJlECyR4YV"
    "HW5E4LiCiMBBApHY6GEAh8GNJWF8J5RAQVKaRhTOGAwIACH5BAUKAM4ALAcABgAFAAIAAAgN"
    "AAUIcCaw0gFnBw4EBAAh+QQFCgDOACwGAAEABwAKAAAIHwBHccpEkNMoZwgTKlzIsKHDhgEC"
    "OIv4EAAAZxadBQQAIfkEBQoAzgAsBQAAAAkADwAACC8AWXkqhKBgoWabNB3r9KsWMWS0Tm0C"
    "RtCgp03OMmrcyLGjx48gQ4ocSRIkKY8BAQAh+QQFyADOACwCAAAADwATAAAIawCdhaLEaBIC"
    "ZwgRTGJEKRRCTbl2rXKVCqGtTq1gaUIoiuCkOCBBLqQkCqHJkyhTqkzpaOWwlggdGVvpTBhM"
    "XDQRMnM2K+fJXj4R+gpKFGUposGKKiua8oLKZAhR5YyFkhfTW6aKOdMlC2VAADs="
)


"""Skype emoticon "Angry :@"."""
angry = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////9///7//37//35v/v7//v5v/vxf//AP/m5v/mzv/mxebm5v/m"
    "pf/mnP/exf/ezv/xAP/etf/erf/en//mUv/Wz//ehP/ee//Vxf/Wsf/eY//eWv/WpNnZ2f/e"
    "If/MzP/eGf/Wa//WUv/Rgv/fAP/Oo//WSv/Ltf/Krf/WKf/WMf/WIf/OUv/MZv/OQv/Fov/P"
    "Ov/FgszMzP/OKf/OIf/Fc//MM//Fav+9o//MAP/FQv/FOv+5sP+2vf/FKf/FMf+9a//FIf+9"
    "c/+8e/+6hP+9Y/+1o/+9Qv+9OsDAwP+9Kf+9Mf+9If+3Uv+1a/+trf+1Wv+1Y/+tmf+spf+1"
    "Sv+1Qv+thP+1Ov+1Mf+1If+5AP+1Kf+taP+tWv+lnP+tUP+pdf+tOv+tMf+tKf+lY/+lU/+j"
    "a/+lQv+oIf+lOv+dhP+iSv+lKf+lMf+Zmf+cdv+oAP+ZZv+cVaurq/+cQv+UhP+cIf+cKf+Z"
    "M/+Rdf+XOv+Pa/+RVP+UQv+MiP+ZAP+UKf+NY/+PSsyZZv+MQv+OMf+QIf+MOv+MKf+PAP9+"
    "e5mZmf99iv+EQv+DUv+EOv9+c/+EMf+AWv9+a/+EKf98Y/9/Sv+EAP+AIf97Ov97Qv97Mf9z"
    "gP97Kf9za/9zc/9yY/9zUv9zQv9zOoyMjP9zMf9re/92AP9wKf9vIf9rP/9mZv9jeP9kSv9k"
    "U/9mM/9jPv9mAP9jJv9jEP9YZXt7e/9aOv9aMf9WWv9UQv9TUP9XIf9aAf9WFf9SOv9TKf9S"
    "Mf9KSv9KQv9KOv9KMf9KKZlmM/9KIf9KBP9CT/9CQv9CMf9COv9CKWZmZv86Tv9AAf8+Ff86"
    "Pf8+If86K5xVMf8xQf8zM/8xSv8xIf8zAFpaWpxKMf8pK/8pIVpaAJxCMVJSUv8kEJw6Mf8e"
    "AJwxQlpKAJkzM0JCQjo6OkI8AFoxAP8AADMzM1opIUIpAFohACkpKSEhISkiAEIZGUIZAFoQ"
    "ACkZABkZGSkQAEIAACkDAgoKCgAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRSoYAgaKQjRDFEwsKFAKUQkCJg4UQIRKQ7/EUAz4YDHjx8noCEwcCOF"
    "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"
    "AAQAAAgQAP8JHEiwoMGDCBMqXKgwIAA7"
)


"""Skype emoticon "Bandit (bandit)"."""
bandit = PyEmbeddedImage(
    "R0lGODlhEwATAPcrAP/RPf/RPs3Nzf/559mzPBAQEN+3NsysSP/88//dbp+fn9/f37KyskBA"
    "QD8/PzAnDP/cbvLy8i8nC8/Pz4CAgNnZ2ZmZmf/TR/Pz8//TSOXl5aWlpc2tSO/v72ZmZrOz"
    "s3Nzc5CQkL+/v//lkv/mkv///v/lkf/lkwAAADMzM////////wAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFMgArACwA"
    "AAAAEwATAAAIsQBXCBTYYYODFP9SOLCwYKBDgQwKIJyYsACDhwIVUNyYUMFDDRITiuRYwSGI"
    "kSgpehi4gKPLhBMEhnjpkoLABjRTNhAo8QGBAAkGDDghNEEAAg8QroiQ0ECAAAhSpCghFcFT"
    "AwgjCGj6NOrUqlcRCtiaQsJPCEJNCIVwVIJYsinjvpVLd6xIDgAC5N2r94BIuwgBZAAAQGoK"
    "whcA/MUg8gDhx5D9IlShgu5LFSIsx/0QEAAh+QQFCgArACwGAAgABgAEAAAIFABXCCQhMMUK"
    "FQYRHkwocMUIgQEBACH5BAVkACsALAcADwAFAAEAAAgGAFMIFBgQACH5BAUKACsALAcADwAF"
    "AAEAAAgHAAGsGAggIAAh+QQFMgArACwGAAgABgAEAAAIFQBXCDwhEMGKFCUOGkR4UOAKEwID"
    "AgAh+QQFCgArACwHAAgABgAEAAAIFABXrCAhcIWKFSkOJkSoUOCIggEBACH5BAVkACsALAcA"
    "DwAFAAEAAAgGAFMIFBgQACH5BAUAACsALAcADwAFAAEAAAgHAAGsGAggIAA7"
)


"""Skype emoticon "Beer (beer)"."""
beer = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP////7+/v39/fz8/Pv7+/r6+vn5+fj4+Pf39/b29vX19fz04vT09PPz"
    "8/Ly8vHx8fDw8O/v7+7u7u3t7ezs7Ovr6+rq6unp6ejo6Ofn5/fl0Pbkz+bm5uXl5eTk5OPj"
    "4+Li4uHh4eDg4N/f397e3vPbv93d3dzc3PnagNra2tnZ2djY2NfX19bW1tXV1dTU1NPT0+/O"
    "qvXQgNLS0tHR0dDQ0M/Pz87Ozs3NzczMzMrKyvDHgMnJycfHx8bGxsXFxerAkcTExMPDw+u9"
    "gMHBwcDAwL+/v76+vr29vby8vL+8t7u7u8+7gbq6urm5udO4dcS4lb23r7e3t7a2trW1tb61"
    "m/K0ALS0tLOzs7SyrbKysrGxsbCwsLKwrK+vr7Ovp+iqQbevoOOnZcurfLqtm66urq2trbes"
    "nbGso+6qAKysrK2trMupdbGsorGro6urq9SmV6qqqqmpqaioqKmopqenp7ekiN+eUKampqWl"
    "paemo9+dT+qhAKSkpKaloqKioqGhodCbTKCgoKOfmqefk6Cgn9iZO+WZAOGXJbecdduXMOGX"
    "Jp+endyUP52dncqXTOWXAJycnMeXT6GblJubm6Gbk5qamtqSJpmZmbyVTsCVRr+VSL+VR76V"
    "Sr2VTb2VTLyVT8CVR+GRANqSDtiSE9aSF9CTJOKRAOCOAM+OLc2OMdKNJsyOM9GNKNKNKN+K"
    "ANyKEduHEdqFEduFANmDEdeCJLuHQ9uEAMGFNdiBEdd/EdZ9Edh+AMqAHdN8CNV7ENd7ANR6"
    "ENR5ENZ6ANV3ANJyANJxANFxANFwANBvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAAACwA"
    "AAAAEgATAAAI3gABCBwocAYeTHhmECRowAggS2bqiHCgoo4ZS4KMGBiIBUsHDB0SDGzgoYKH"
    "MlgGWoqwsGUGSxy9eLjgBEuLBzS0IAEx4k1KgQaiFMJEho0eS36eVLFUqMjGgUCSFQM2CxUk"
    "PmmsiIJFcMOeZFKHzNoBSUYaFFsHbgh2rFbYsWXPphV451iJqMXEkjWLlqvAY40A4NUbt+9A"
    "wILf7pXrF0Ddu4oLzwWgga3bvHD5TqZ8ByzmxYYXDs7MuOVo0JsFxkBmjBivW69OQTo0DExL"
    "AGKE/dqlKxctWbEQLRAYEAAh+QQFCgAAACwAAAAAEgATAAAI3QABCBwoEEYdS3VgECRowIgg"
    "TGbqfEhgoo8ZS4JGEMRypUKDBgEGKoiAgIYlCgMxMVjIskiTgVi4fOiwJc4LCDTUNMlwYASm"
    "gQaiFLJEho0fTH6eVLHEFAtBIMmKAZuFChKfNFZEwSK4YU+yqENm7YAkIw0KrQM3BDtWC6xY"
    "smbRCrxzrATUYmHHlj27VeCxRgDu5oXLd+DfwG71xu0LgK7dxITlAtCwti3et3slT77z9bLi"
    "wgsFY17MUvRnzQJjIDNGjNetV6cgHRoGhiUAMcJ+7dKVi5asWIgWCAwIACH5BAUKAAAALAYA"
    "AgAMAAUAAAgbACdMAEAQgIQPBRMqXMgQQISGBeVggngpRY6AACH5BAkKAAAALAAAAAASABMA"
    "AAg5AAEIHEiwoMGDCAt2QFghocOHBLn0mABxIJMwXihUHOgmiaWNAAxRMgMSgI8mJVOqXMmy"
    "pcuXMAMCACH5BAkKAAAALAAAAAATABMAAAj6AAEIHChwBh5LeGAQXGjAiCBLZvKASGCijhlL"
    "gkYsxKKlQ4QJBAZSIFEBhiUKBDExWLgwwBIpBLFw8WABi5cVCmB44dJjggNMBA1EKYSJDBs/"
    "lvw8YfLFCwVLDggCSVYM2CxUkPiksfKJC4c6HwRu2JOM6pBZOyDJSIOi0w0AcToA2BDsWC2z"
    "aNWy3WSDhRYDAO4cKzG12Nm0a1GYOsPCiMBjjQAUPqwXhahEfx48jjw5b2JRrOQKFEwYL2K2"
    "omAR1FD3rmHPqFWvvlP29WnLshd2vp2apWTTlXuzjIHMGDFet16dgnRoGBjfAMQI+7VLVy5a"
    "smIhWjAwIAAh+QQJCgAAACwAAAAAEwATAAAI/gABCBwocAYeS3hgEFxowIggS2bygEhgoo4Z"
    "S4JGLMSipUOECQQGUiBRAYYlCgQxMVi4MMASJwSxcPFgAYuXFQpgeOHSY4IDTAQNRCmEiQwb"
    "P5b8PGESxgsFSwuBJCsGbBYqSHzSWCG1BkSdgRv2JJs6ZNYOSDLSoAhVg0IcBwA2BDtWi6xZ"
    "tGo/uQCA5QOAO8dKSC1W9mxaFJ1qADjSAcCxRgAGF8aLYpONAmUMOIYs+e5hU2dYGBEIWLBd"
    "w2pFJfrzQKCGuXUJe07NqvFADXfGykaNQhQslpFPU/YNvDNv4ixjIDNGjNetV6cgHRoGBjgA"
    "McJ+7dKVi5asWIgWAwwMCAAh+QQJCgAAACwAAAAAEwATAAAI/wABCBwocAYeS3hgEFxowIgg"
    "S2bygEhgoo4ZS4JGLMSipUOECQQGUiBRAYYlCgQxMVi4MMASJwSxcPFgAYuXFQpgeOHSY4ID"
    "TAQNRCmEiQwbP5b8PGESxgsFSwuBJCsGbBYqSHzSWBHlJglUgRv2JJs6ZNYOSDLSoBAViJIZ"
    "sMGO1SJrFq1aUpWaUBF451gJqcXKnk2LItSMCFscADjWCABgwXZRfHIBAMmHxY0f1yXcqQaA"
    "Ix0A9P1Ld7DaTTYKlDEAQEPcuYE3qzV1hoWRgRrujI1tem2iPw+ilo4silVo4byJw2IJIAYy"
    "Y8R43Xp1CtKhYWCYAxAj7NcuXbloyQaKhWjBwIAAIfkECQoAAAAsAAAAABMAEwAACP8AAQgc"
    "KHAGHkx4ZhBcaMAIIEtm4phwoKKOGUuCRizEgqUDhg4JBjbwUOGFJQoELUVYyJJIE4JYvHi4"
    "MIWLiwc0uFBxoWACJoIGohTCRIaNHkt+nkBBEwmGpYVAkhUDNgsVJD5prIgaEwnPwA17kkkd"
    "MmsHJBlpUIiCpSKHwA3BjtUaW/Zs2rUE7xwrEbUYWbNo1boSshLAsUYA+v61i4JUJSI8BB5O"
    "TBdw2lAzImxxAEAv38qMP7kAgOQDAA1x5/qtG7hTDQBHOgjUcEfsassoNtkoUMYAQcWs05o6"
    "w8IIVNCBRSX682BhDGTGiPG69eoUpEPD4MhmKUbYr126ctEIkhUL0YKBAQEAIfkECQoAAAAs"
    "AAAAABMAEwAACPwAAQgcKHAGHkt4YBBcaMCIIEtm8HxIoKKOGUuCRizEouXChAkCBkr44GCG"
    "JQoEMSVYuDBAkiYEsZQJgaGMnBYKaLzZUuOBBEsEDUQpZIkMGz+W/DyB0sbRxYVAkhUDNgsV"
    "JD5prIgyVCTHwA17kkkdMmsHJBlpUIiCRXBDsGO1xpY9m3YtwTvHSkQtRtYsWrVsBx5rBGBv"
    "X7qACQ4uLNdvXVVJHgjEq7cxYlN2kCwRqOFtXL5z/26yMUANAs53xIJ2jEKTwiIdCBoOnTaT"
    "QiMfZFv+66kFAicNCMZAZowYr1uvTkE61GuQiiAsxQj7tUtXLlqyYi3KEucCgIAAIfkECQoA"
    "AAAsAAAAABMAEwAACPgAAQgcKHAGHkt4YBBcaMCIIEtm8oBAYKKOGUuCjBggiEVLhwgTCAyk"
    "QKICCDVmCGJisLAlA0ocBmLh4sECFi8rGsDwgsWGgw+YNgo0EKUQJjJs/Fjy8wRKG0uUciwE"
    "kqwYsFmoIPFJY0XUpQkEN+xJVnXIrB2QZKRBIQpW2GDHapU9m3ZtW4J3jpWgWswsWrVs3Q48"
    "1ggAX791AxMkbHjuX7uCBebd6zjx3YEa4MrtSxewqFU/KGC+Q5bzYxSjMP3QMbUyYE40Jmh5"
    "QPBw57WgaABAEoJgDGTGiPG69eoUpEO4lJzwuFCMsF+7dOWiJSuWoi44ZhQICAAh+QQJCgAA"
    "ACwAAAAAEwATAAAI6QABCBwocAYeTHhmEFxowAggS2bqiHCgoo4ZS4KMGCCIBUsHDB0SDGzg"
    "oYKHMlgIWoqwsGUGSxy9eLjgBEuLBzS0IAEx4k3KgQaiFMJEho0eS36eVLFUqMhGgkCSFQM2"
    "CxUkPmmsiIK1cMOeZFKHzNoBSUYaFFsJbgh2rFbYsWXPph1451iJqMXEkjWLluvAY40A4NUb"
    "ty9BwILf7pXrV2Ddu4oLzxWoga3bvHD5TqZ8ByzmxYZbDs4st5WOCwtHgy41KQiPhTGQGSPG"
    "69arU5AO2eJBQY2ChWKE/dqlKxctWbEe0Zkjp0JAACH5BAkKAAAALAAAAAATABMAAAjoAAEI"
    "HChwBh5MeGYQLBBgoAEjgCyZqSPCgYo6ZiwJMmKAIBYsHTB0SDCwgYcKHspgIWgpAsGXAjNY"
    "8ujFwwUnWFo8oKEFCYgRb1Y6jFIIExk2eiz5eVLFUqEiHQkCSVYM2CxUkPiksSIK1ssNe5JR"
    "HTJrByQZaVB0Jbgh2LFaY8ueTbt24J1jJaYWI2sWrVqvA481AqCX79y/BAUTjtuXLmCBd/My"
    "PlxXoAa3cPfK9VvZ8h2xmhsjhll4s2OYi0NTTpXEwcsYyIwR43Xr1SlIh3wR8rFkwEsxwn7t"
    "0pWLlqxYkhj1wTMgIAAh+QQJCgAAACwAAAAAEgATAAAI4QABCBwocAYeTHhmDETAYKABI4As"
    "makjwoGKOmYsCTJiYCAWLB0wdEgwsIGHCh7KYBloKQLBlwIzWPLoxcMFJ1haPKChBQmIEW9W"
    "CjQQpRAmMmz0WPLzpIqlQkU6DgSSrBiwWagg8UljRRQsghv2JKs6ZNYOSDLSoPA6cEOwY7XI"
    "mkWrlq3AO8dKUC1W9mzatV8FHmsEYG9fuoAHDi4s12/dwADw6m2M2C4ADW/j8p371/LlO2M3"
    "O0780jDnxzBNj/YsMAYyY8R43Xp1CtKhYWBgAhAj7NcuXbloyYqFaIHAgAAh+QQFCgAAACwA"
    "AAAAEgATAAAI3gABCBwocAYeTHhmECRowAggS2bqiHCgoo4ZS4KMGBiIBUsHDB0SDGzgoYKH"
    "MlgGWoqwsGUGSxy9eLjgBEuLBzS0IAEx4k1KgQaiFMJEho0eS36eVLFUqMjGgUCSFQM2CxUk"
    "PmmsiIJFcMOeZFKHzNoBSUYaFFsHbgh2rFbYsWXPphV451iJqMXEkjWLlqvAY40A4NUbt+9A"
    "wILf7pXrF0Ddu4oLzwWgga3bvHD5TqZ8ByzmxYYXDs7MuOVo0JsFxkBmjBivW69OQTo0DExL"
    "AGKE/dqlKxctWbEQLRAYEAAh+QQFCgAAACwAAAAAAQABAAAIBAABBAQAIfkEBQoAAAAsAAAA"
    "AAEAAQAACAQAAQQEACH5BAkKAAAALAAAAAASABMAAAggAAEIHEiwoMGDCBMqXMiwocOHECNK"
    "nEixosWLGDNGDAgAOw=="
)


"""Skype emoticon "Blush :$"."""
blush = PyEmbeddedImage(
    "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"
    "kZKTlJWWl5iZmoqBADs="
)


"""Skype emoticon "Bow (bow)"."""
bow = PyEmbeddedImage(
    "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"
    "Ay+NEWMplWNgKiMYGC5gL2NAhABjEmOBADs="
)


"""Skype emoticon "Broken heart (u)"."""
brokenheart = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP/////39/fv7//m5vfm5v/e3vfe3u/e3ube3v/W1vfW1u/W1ubW1vfO"
    "zv/MzO/OzubOzt7Ozu/Fxf+9vfe9ve+9vea9vd69vf+1tda9ve+1tea1tf+trd61tfetre+t"
    "reatrf+lpd6trfelpdatre+lpealpd6lpdalpf+Zme+cnOacnN6cnNacnO+UlP+MjMWcnMyZ"
    "mcyZmdaUlO+MjOaMjP+EhN6MjNaMjO+EhOaEhN6EhP97e9aEhO97e86EhMWEhN57e/9zc72E"
    "hNZ7e+9zc+Zzc8V7e95zc/dra9Zzc+9ra/9mZs5zc/9mZuZra8Vzc95ra/djY71zc9Zra7Vz"
    "c+ZjY/9aWsxmZtZjY8xmZsVjY+ZaWv9SUtZaWrVjY61jY85aWuZSUv9KSsVaWt5SUtZSUrVa"
    "Ws5SUuZKSv9CQsVSUvdCQr1SUrVSUtZKSq1SUsVKSuZCQqVSUv86Ot5CQvc6OtZCQs5CQv8z"
    "M+Y6OsVCQr1CQvcxMbVCQs46Oq1CQqVCQsU6OuYxMf8pKb06Ot4xMdYxMbU6OvcpKe8pKcwz"
    "M606OuYpKcUxMf8hId4pKfchIb0xMbUxMdYpKc4pKe8hIa0xMeYhIcUpKf8ZGaUxMd4hIZkz"
    "M/cZGb0pKdYhIe8ZGbUpKc4hIa0pKeYZGcUhId4ZGb0hIf8QEPcQEJwpKbUhIe8QEK0hIcUZ"
    "GaUhIeYQEP8ICJwhId4QEL0ZGbUZGdYQEPcICJQhIe8ICK0ZGc4QEOYICKUZGf8AAMUQEN4I"
    "CPcAAL0QEJwZGbUQENYICJQZGc4ICO8AAK0QEMUICOYAAN4AAKUQEL0ICJwQENYAAJQQELUI"
    "CK0ICMwAAIwQEMUAAKUICL0AAJwICLUAAJQICK0AAKUAAJkAAJkAAIwAAIQAAGYAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAAACwA"
    "AAIAEgAQAAAI2AABCOQwhpCaFwEABLBBR1OeFAIFvqCjpsuYPHkS5KEzhg4hVUkETqDTRYgN"
    "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"
)


"""Skype emoticon "Bug (bug)"."""
bug = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Cake (cake)"."""
cake = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Call (call)"."""
call = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP///////v/99P/89Pz8/P/87v/88//88v/76//67Pn5+f/65P/55fb2"
    "9v/05fT09PLy8v/xyP/wyf/xx//wyO3t7f/qzf/pzf/p0f/p0P/ozerq6v/rqP/po//pov/p"
    "pP/opP/npf/npubm5v/phf/mp//liv/ijv/jjP/gof/ftP/ftf/grf/hgf/hgP/fhP/ggv/g"
    "gf/fg//dh//ehf/ehv/hXv/dYv/Wqdra2v/bZP/aZv/ZZ//YaP/Xav/Xaf/YS//Wa//bHv/X"
    "Of/aH//aHv/WTdTU1P7bG/7bHv/bG//YIP/ZHf/Rav/Saf/UT/7ZHv7ZIP/YJf/XH//XJv/W"
    "K//SUf/VOv/TUP/VLf/VI//VIv/WJf/WIf/WIP/UMv/UJv/UH//QU//TLf/VH//PVP/RPf/S"
    "K8/Pz//RLv/TJP/TIf/RN//RMv/NVv/QPv/QN//PN//PP//RLP/RJ//RI//SH//QNv/PJv/N"
    "Ov/OMv/QH//OJf/OKf/PIv/NNP/MQf/MOv/MNv/LOf/NIv/MLf/MMMvLy//KP//MIP/LMP/K"
    "M//Ecf/Ecv/KJv/JN//JM//IQf/IOf/EaMrJyP/KKv/Eaf/KIP/ILv7HPf/HLP/HJ//HJP/F"
    "Pv/Ab8fHx//IJf7FPv+/ev++cf/EMvjGN//COf+9cf/EKf/FJ/i/b/+9cP/FJf+/Y//CNP/E"
    "Iv/BQMTExP/DLdrFcf/DH//BKtrDc/+/MP/BJenBW/+/Jv/AIv++Lf++JP+7QsDAwP+9If+3"
    "V/+7Lf+5Rv+8IP+0Zf+7KP+4Rf+4Rv+4Pf+2SP+2Sf+2Qv+5Jf+4Of+2Ov+zN/+xP/+0JP+0"
    "Jsi6idO3gf+wQP+xLP+vPP+vJv+uMv+wJ/+sNv+qPf+tKLOzs/+pKv+mRf+mPf+lMv+jPf+j"
    "Mv+jLv+hOP+hN6ysrP+hMv+gOf+gOP+eMv+cMq6omaamppiYmJmYlZiWlZiWlJiXlJSUlJCQ"
    "kI+Pj4mJiYiIiDMzM////wAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFMgD8ACwA"
    "AAAAEwATAAAI/wD5CRSII5y7YgjdhcMxsKFAcqJWFJg4UYUocg75ZVjHQgKFCBNCTogggcW6"
    "DAMzsEtRIgSIDh08wPwQQkQKdBgEnrM0g4aMGC1cCHXRAsaLGpPQ8dPQrkmQHzxQJEDAAQEC"
    "FDt6+HDSTsMqc27EWHkyYN++AGYFGMFipYy5VeLARQL0xowBs2j3GbjyRg4icOLUeeMFyVCa"
    "GwsWkEhsY0waRbWyqSu3rVkqR3jUaImSRMiSLXX4gCImrdy4yrsu+VnjBQoSJUzI2ElEC9i0"
    "cd2uGcPFaV+dLkuIFJkSZt+lV72udfOkzVitTX32gaEiRQqXfXgcsdKlzdMFbsJqaWoqNMes"
    "+TN9KqESxu0Cv2DQbpFSpKfNl/tf2hjCJAtaMIEOYPOMK48IEgccbLBxxx+LkOIMNg4M5IA1"
    "yZgiySCB5JHHII+Ykkw0ETrUCjO+wBJKJp3A4gszrWQ00AWNKIPMMMcow4h7DQUEACH5BAUK"
    "APwALAAACwAOAAcAAAgqAPkJFEhooME9BhMmpJSvmsKE937de2gw34N8FAfe+zYxI78j+o54"
    "5BcQACH5BAUKAPwALAAACwANAAcAAAg4APnl40ewoEGBAPLlIkhnn0OHavIBAFCP4L6JGPdJ"
    "BKCv4EOHBCfCO2gw3qGEJAtuiBdvQ0qCAQEAIfkEBQoA/AAsAAAKAAUACAAACCQA+eXjRzAf"
    "gHzvShEEAO/dwgoDCRIYCIEfw3TpLA5Mly+fqoAAIfkEBQoA/AAsAAAFAA4ADQAACHAA+Qkc"
    "uMMEPwQc+CVAMXCgEQH89gWIOKChwCsGIk7clzFfwzE2+C0gIfJGPgD58FGz2PAkgBz2VrLk"
    "N48fAABH5M1sCECBRzAN9/FEOUfoQABCFQhEya9NUH7xciytt/NQvCNobnqcGesev3xbWQYE"
    "ACH5BAUKAPwALAAABQAPAA0AAAh0APkJHMhPhwl+CDjwS3CCXz6C/IAI4LcvAMUB+QA8HDjk"
    "AEWL+wxk3Ciwig1+C0jwY3BjYL56tiDK5FeB0r1ZMyEC+FQvJz8FAgE00MePihSf/ADoy5Jl"
    "H9IHRL98kXloYKx6JAnmuPdpRFCNM3PEc5l1YEAAIfkEBQoA/AAsCQALAAUAAgAACAsA+e0b"
    "KBCAwX0BAQAh+QQFCgD8ACwJAA4ABQACAAAIDAD3ARi4j9++g/wCAgAh+QQFCgD8ACwAAAAA"
    "AQABAAAIBAD5BQQAIfkEBQoA/AAsAAAAAAEAAQAACAQA+QUEACH5BAUKAPwALAkADgAFAAIA"
    "AAgNAL/sG2iIH5s7f/gFBAAh+QQFCgD8ACwJAAsABQACAAAIDQD5FZkShp+UfQjxBAQAIfkE"
    "BQoA/AAsCgAMAAMAAgAACAgApXBRs69gQAAh+QQFCgD8ACwKAAwAAwACAAAIBwD3CQRAMCAA"
    "IfkEBQoA/AAsCAAMAAcAAwAACBAA+e0TSHAfAH4IAQxcSDAgACH5BAUKAPwALAAAAAABAAEA"
    "AAgEAPkFBAAh+QQFCgD8ACwAAAAAAQABAAAIBAD5BQQAIfkEBQoA/AAsAAAAAAEAAQAACAQA"
    "+QUEACH5BAUKAPwALAAAAAABAAEAAAgEAPkFBAAh+QQFCgD8ACwAAAUADwANAAAIeAD5CRzI"
    "zwQCfhwOoujBzxxBfgL28QsgcQAWceAiETQgkSI/A2/U5eNF0MYCfiRO3kgzEB81PA9j8sth"
    "j9oamQ+PyKuDkx8AgQry0XmoBubDfHMe7utT6aieh20MCcwxsJ6gODIPxTuCRmC+QYFiAoh1"
    "b6AvWDIDAgAh+QQFCgD8ACwAAAUADgANAAAIeAD5CRyIIgE/Dgj4odgxcOCAffwCQBRgpKFA"
    "AxAl8jNwhZ+3hjcW8CMh0saYctuapXJkseG4fM12XfLTUmA+fvnelSJUsyG8d30GSpHCxWKF"
    "fIUgZqnCdCAAm4r47YPYUB8EgfAe9UyXDgCAfKYk1VSQ7qYqZj0DAgAh+QQFCgD8ACwAAAoA"
    "BQAIAAAIKgD5beNHsFs+Y7g4EcyXaxNBfvU0PdRHih8AfvBcxTvEL1+yDfHibWgVEAAh+QQJ"
    "CgD8ACwAAAAAEwATAAAITQD5CRxIsKDBgwgTKlzIsKHDhxAjSpxI8VpET9qM1RK4r2DHgpTy"
    "VdvIb86+kyfPGLz3696tgW2+yPyC8EG+Zw/vfbtn7eERfUcoPgwIADs="
)


"""Skype emoticon "Cash (cash)"."""
cash = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////5v//zP//xf//tf//rf//mf//jPf33v/3xf//Zv//Uv//Sv//"
    "Qv//M//3hP//Ov/3c//3e///CP//EP//AO/vvf/3Me/vpf/3If/3Kf/vWv/3AP/vQv/vOv/m"
    "hO/vUubmtf/vAO/vOu/ezv/ec+berf/mCP/eOubWte/mAP/eGd7ea+/eMf/eCPfeAP/WMf/W"
    "EO/WOv/WAPfOY97WKf/MM//OIebWGd7WIf/OENbWIdbFnP/FGf/FEN7OCP/FCP+9Ic7FWta9"
    "lP+9CM69lPe9Gf+9APe9CPe9EPe9AO+9EP+1CP+1EN69AO+tKcW1Ot6tIeatAN6tAM6tAOal"
    "AM6lIb2tAN6cAL2cWrWca9acAK2lAN6UGcyZAMyZAL2UUsWUKb2UKb2UIaWUGbWMOr2MAL2E"
    "GaWMAKWEQrWEALV7Ga17Mb17AK17Ka17ALVzAKVzGaVzIZxzKaVzCIR7AK1rAJRzAKVrEJxr"
    "IZRrKYxrMYxrAJlmAJlmAJRjGYxjKf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgCBACwD"
    "AAAADgATAAAI1wADCRTIpg+bgQgFxunTpwTDOAmz9BHy4MABBQx+9MkysM8HiywOgBhxQUMf"
    "hTsWSIDCh0afNR08WIHYp8aCCGRaMtxJEweEBjnqyOADJmEfLhd+ttgwpg9EhHrEdMhAYUIF"
    "Di+onBzIB80VFRw4iDixQszWjndQRIniwkWMNwcHarkDg6GTGTq89EmjxovePjb+sPHSo4fe"
    "OUtu2DAD+E+eKT6MwGHDZk0QIEq2+NhShQiRME/L9JHiGUmSJEyw0Em4sM2TM3L2nE1opwvD"
    "uAkFusEDKHdAACH5BAUKAIEALAAAAAABAAEAAAgEAAMFBAAh+QQFCgCBACwAAAAAAQABAAAI"
    "BAADBQQAIfkEBQoAgQAsAAAAAAEAAQAACAQAAwUEACH5BAUKAIEALAAAAAABAAEAAAgEAAMF"
    "BAAh+QQJCgCBACwDAAAADgATAAAIJwADCRxIsKBAHgYNkkCQkOCQBAIENJxIsaLFixgzatzI"
    "saPHjxoDAgAh+QQJCgCBACwCAAAADwATAAAI5wADCRQIgE0fNgMHAgAgkMeQPiX69ImTMBCA"
    "FCQQPDhwQAGDH32yJBySQIAACwdAjLigoc/AOBgWSIBShEafNR08WKEYaEjMCGT42JQokWcf"
    "HBAa5Kgjgw+YioH6cLmQtMWGMROh6hHTIQOFCRU4vKDiMiEfNFdUcOAg4sQKMWUT9rmDIkoU"
    "Fy5ivEGYUMsdGBKdzNDhxWUaNV4K97Hxh42XHj0KB5qz5IYNM4v/5JniwwgchGzWBAGiZIuP"
    "LVWIEAnDM1CZPlJUI0mShAkWOlDj9Gnz5IycPXGh2ukikS9UgW7wAIIaEAAh+QQJCgCBACwC"
    "AAAADwATAAAI4wADCQQgkE0fNgITKgQQp0+fEg7jLASQggQCAQIOKGDwo08WhX0SBBDA4gCI"
    "ERc09EkYZ8eCAVD40OizpoMHKxID9anxkoxMh0Bz9sEBoUCOOjL4gFEosA+XCxAatNgwpk9O"
    "hXrEdMhAYUIFDi+orFTIB80VFRw4iDixQsxYkHdQRIniwkWMNwgVarkDw6GTGTq8rEyjxovg"
    "Pjb+sPHSo4fgQHOW3LBhBvGfPFN8GIGDkM2aIECUbPGxpQoRImGulukj5TSSJEmYYKHDNFDD"
    "Nk/OyNnztradLg7z1hboBg+g2gEBACH5BAUKAIEALAMAAAAOABMAAAjcAAMJFMimD5uBCAXy"
    "6NOnBMM4CAGkGBLiwYEDChj86JNlYJ8AAg6wOABixAUNfQTGwUBggAk+NPqs6eDBCsQ+NRZE"
    "IAOToc+bOCA0yFFHBh8wCftwuSC0xYYxfSAi1COmQwYKEypweEEl5UA+aK6o4MBBxIkVYrx6"
    "vIMiShQXLmK8OThQyx0YDJ3M0OGlTxo1Xvr2sfGHjZcePfrOWXLDhpnBf/JM8WEEDhs2a4IA"
    "UbLFx5YqRIiEkVqmj5TQSJIkYYKFTsI4fdo8OSNnj9qEdrowpJtQoBs8gHoHBAAh+QQJCgCB"
    "ACwCAAAADwATAAAIMAADCRxIsGDBIQYNkkCQ8GCCQAIsNBy4QAKUIhOHYJjIsaPHjyBDihxJ"
    "sqTJkx4DAgAh+QQJCgCBACwDAAAADgATAAAI1wADCRTIpg+bgQgFxunTpwTDOAmz9BHy4MAB"
    "BQx+9MkysM8HiywOgBhxQUMfhTsWSIDCh0afNR08WIHYp8aCCGRaMtxJEweEBjnqyOADJmEf"
    "Lhd+ttgwpg9EhHrEdMhAYUIFDi+onBzIB80VFRw4iDixQszWjndQRIniwkWMNwcHarkDg6GT"
    "GTq89EmjxovePjb+sPHSo4feOUtu2DAD+E+eKT6MwGHDZk0QIEq2+NhShQiRME/L9JHiGUmS"
    "JEyw0Em4sM2TM3L2nE1opwvDuAkFusEDKHdAADs="
)


"""Skype emoticon "Clapping (clap)"."""
clap = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////9///7//37//35vf39//vxe/v7+/v3v/vpf/mzubm5v/mpf/m"
    "nP/mhP/mjP/etf/erf/enP/ejN7e3v/ehP/ee//eY//eWv/eIf/WY//eGf/Wa//WUt7Wvf/W"
    "Sv/WOv/WKf/WGf/WId7Ovf/MZv/OUv/OQv/OOszMzP/OKf/MM//Fc//OIffOKf/Fa//FOv/F"
    "Qv/FMf+9e//FKf+9a87Ftf/FIcXFxf+9c/+9Y/fFKffFMebFSt7FUv+9Qt7FSv+9Mf+9Kd69"
    "hP+9Ife9Mf+1Y/+1Wv+1Uv+1Sr29vf+1Qv+1Mf+1Ota9Wv+1Kc69a961jP+1Ife1Md61c961"
    "a/+tWv+tUta1e9a1Y/+tOrW1tf+tMc61a/+tKbW1rb21jLW1pbW1nL21hLW1lP+lQs6te9at"
    "a/+lOsWthP+lMf+lKb2tlLWtpcWte7WtnK2trb2thK2tpbWtjL2te7WthP+ZM7WljK2llKWl"
    "pa2ljKWllJmZmZmZmYyMjISEhHt7e1paWjMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgCDACwA"
    "AAAAEwATAAAI/wAHCRSoIEcZIwjL5FAwsKFAIzMgCJg4EcIMIw4HESgTwYDHjx8jlCEwcKME"
    "BihRNkiJUsJIgVZeVJg504JNCzQrvLAySIEdDkA1PBhAIAEBAg80AOVgp6AaEyY6dAggSBCA"
    "qgE+SDWhJgeaNTFOnEAhoOpVQQJAoBDrBY0aL0FWrFBx4aiDoxhCqFhBw4saNU+k0FChYoTh"
    "DBkMt1BBg4iUv0+EELnRoscYOXAyk3Hi4gaRJ2q0cBFC40YgQHAAqIbDx48Tz1y01BhNgwYf"
    "JapXb0khhoYQLiwUaGFSO7XqAgCULACwhUYQLQyPNAkiwzgAHFuQH9gio8kRgQS0NDKpnhu7"
    "6u1NtJAEv6SJ9QV5cKjesmR9Qx1vUqhegGdPCgpfZDSQDW1kxgYWZhSIQ0MBAQAh+QQFCgCD"
    "ACwEAAoACwAJAAAIVgB3QHkDB8wGH2/kQOGRxQ8AAH4EAXrIJ4uYFA+/IPjycFCYLQ8BaAT5"
    "UMmWAoMGRfwT0iTKQXNQxGlJEsAdFHVacgSQIg4MNzg64oAD5w2VJFUIpgwIACH5BAUKAIMA"
    "LAIACgAPAAkAAAhqAKd0eQMHzAgRGzaI8PFGTpciWfQAAOBHkEWLgCbiyfImxcQvCEKG/DIx"
    "RZgtEymKDPknpZItBSbOuWgxjkuYMlHo1Glz4suUd3bqrHOzZJwfMJLGSINj4hYccOB8iZJk"
    "yaAlSYZ8iYojIAAh+QQJCgCDACwAAAAAEwATAAAIiQAHCRxIsKDBgwgTKlzIsKHDhxAjSpw4"
    "aEqXN3DAjCg4wscbOV2mCDyjB8AgP4IKCgI0CACeMwLbpDDpB0FBBH9apmgjcIvJQXNSEhRE"
    "RyAAJT0LmJyzouCKOEaRDtqiFGhTgk+j9vx5B4bTOlqnmkwR50fBH2lwtNwiEAecqSRYFGTh"
    "gS0ctQEBACH5BAkKAIMALAAAAAATABMAAAj/AAcJFKggRxkjCMvkUDCwoUAjMyAImDgRwgwj"
    "DgcRKBPBgMePHyOUITBwowQGKFE2SIlSwkiBVl5UmDnTgk0LNCu8sDJIgR0OQDU8GEAgAQEC"
    "DzQA5WCnoBoTJjp0CCBIEICqAT5INaEmB5o1MU6cQCGg6lVBAkCgEOsFjRovQVasUHHhqIOj"
    "GEKoWEHDixo1T6TQUKFihOEMGQy3UEGDiJS/T6Z0eQMHzAgRGzaI8PFGTpciT9Ro4ZJFDwAA"
    "fqqqBnQaTxYuWmpweZPi9BcEuHF/OZ0iDBcWCrRsOY06N+4/xJVoYXhkS4HTc1RXjZP8iEAC"
    "zqGj2L6d+mklJAUOKD99h/v2Oskbjk8R5weM9zHS4Di9pSEOOHC+REmyhH+SIV/gh4NAAQEA"
    "IfkECQoAgwAsAAAAABMAEwAACP8ABwkUqCBHGSMIy+RQMLChQCMzIAiYOBHCDCMOBxEoE8GA"
    "x48fI5QhMHCjBAYoUTZIiVLCSIFWXlSYOdOCTQs0K7ywMkiBHQ5ANTwYQCABAQIPNADlYKeg"
    "GhMmOnQIIEgQgKoBPkg1oSYHmjUxTpxAIaDqVUECQKAQ6wWNGi9BVqxQceGog6MYQqhYQcOL"
    "GjVPpNBQoWKE4QwZDLdQQYOIlL9PhBDZAeUNHDAbfLyRA4XHDSJP1GjhIoRGFj8AAPgRBCg1"
    "nyyfuWipQZqGmBSpvyD4kjpFGBpCuLBQoIUJjS2pAehGnloJjSBaGB5pEmRLgdSr/yRXIqPJ"
    "EYEEtDQzsZ56Doo425toIQl+CXMAd1DU2b6EfUPeAFLEgeEGR+otGQmEAxxwvEFFElVYBgcO"
    "DQUEADs="
)


"""Skype emoticon "Coffee (coffee)"."""
coffee = PyEmbeddedImage(
    "R0lGODlhEwATAMQAAPf3/+b3/+bv997v/97v99bm/9bm99bm787m/87m973e/7Xe/63W/63O"
    "96XO/5nM/5TF95y93pS93pS13oy11oSt1nOl1pmZmXOczmaZzP///wAAAAAAAAAAAAAAAAAA"
    "ACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAaACwCAAAAEAATAAAFcaAmahdpjuhYrmnKli36"
    "xq4J0zia7Xy/64FBAaFYMByPRQYoJCqOyZ1EoMkEh0WokrITWJtZpFJzyEy+WKN4qeFaBdjn"
    "WuS+EtVRckaCvmszXBhedmFRZlQZBmByDw1sIhEVCWlHEBYSKAARPjwTACghACH5BAkKABoA"
    "LAIAAAAQABMAAAVwoCZqF2mOqFiuacuWbfrG6EzfaabvvI5mgUEBoVgwHI9F5hccKhTHpE4i"
    "0ACFRCNSSdEJrk6tVHPITMDZqFLUBQqc0O1S026m5eSMBF1UZ7oYX3Z9cmZVGQZYT1ENcyIR"
    "FQlhRxAWEigAET07EwAoIQAh+QQJCgAaACwCAAAAEAATAAAFcaAmXhpJimharqeqmqubwq1M"
    "y3ie7Xy/p5nAoIBQLBiOxyIDFBIVCqRyJxFogsPiMbmk7ATY53aqOWQmYa10KfIGBc8ol6lx"
    "O9XzckaSNq4zXhhgd35zZ1YZBllQUg10IhEVCWJIEBYSKQARPjwTACkhACH5BAUKABoALAIA"
    "AAAQABMAAAVyoCZeGkmKaDqWrKqarbvCMgqfda5mfO/zqUxgUEAoFgzHY5EJDosKRXLJkwg0"
    "QqIRqWRSeIIslEvVHDIT8XbKFH2FAqi029S8n2u6OSNRH9kZXxhheH90aFcZBlpRUw11IhEV"
    "CWNJEBYSKQARPz0TACkhACH5BAkKABoALAIAAAAQABMAAAUVoCaOZGmeaKqubOu+cCzPdG3f"
    "OBkCADs="
)


"""Skype emoticon "Cool 8=)"."""
cool = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////7//35v/vxd7v///mzubm/+bm5v/mpf/mnM7m///etf/erf/e"
    "nP/ehLXe///eIf/eGf/WWv/WSv/WKf/WMf/WIf/OOr3O9//OKf/MM//Fc//OIf/Fa//FOv/F"
    "Qv+9e//FKf/FMf/FIf+9c/+9a/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1Wv+1Sv+1Ur29vf+1"
    "Qv+1Ov+1Mf+1Kf+1If+tWv+tOv+tMbW1tf+tKXO9//+lQv+lOv+lKf+lMXu192u19/+ZM1q1"
    "/2Ol95mZmTGl/2uU5oyMjDqM7xCU/wCZ/wCZ/wiU/3t7eyF77xl77xB77xBz72ZmZjFj3ilj"
    "3iFa3lJSUilC1jMzzDMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBbACwAAAAAEwAT"
    "AAAH/4BbgoIFJDwsiDwkBYONgiwgCwGTkwsgLI5bAjwMA56fnww8AoObDQioqAmpqA2jgjYd"
    "DrO0tbQdNlsFQlq9vr+9Ob1ChT9aWVZRS1FWWlhWUkoAVFo/JD0+x8nLzc9ABAAGSDo9Pzop"
    "WttRWhTpTzsASB46Pz80NSG/FhAQvgchK2rUo6FixQgOFhJGiJDQgoQRK2j8uIFDRYiDCPdB"
    "SMiBA0QcN0pUDBEiQwYKKC20MxlCBY5FN2aQNAmMAssUNxi1kJFChAYNFYIG/SkihIwWggTc"
    "kOFTw4WnT4nKuEEqaQwZHjxAjeohRoyqjUzEOHEiq4cPJ2KYyDSowAYXMQfgutjAqFEgACH5"
    "BAUKAFsALAAAAAABAAEAAAcDgFuBACH5BAUKAFsALAoABQAHAAkAAAchgFuCW1ODg0FWg0lD"
    "QUdXg0ZBVyKGToaCF5eaFIYUnIaBACH5BAUKAFsALAkABQAIAAkAAAcdgFuCglqDhlGGW1JN"
    "UVaFgotRj4aThhyJmJkUmYEAIfkEBQoAWwAsAAAAAAEAAQAABwOAW4EAIfkEBQoAWwAsCQAF"
    "AAgACQAABx+AW4KCU4OGQYZbSUNBR1eDUEZBj4lOiYIXl5qJWpqBACH5BAUKAFsALAoABQAH"
    "AAkAAAcfgFuCW0WDgwpVg0QPChhOg0MKj4YwhoITlpmWWlqWgQAh+QQFCgBbACwMAAUABQAI"
    "AAAHHIBbWzmCggCCQAQABkhbOwBIHoIHhVsSlYValYEAIfkEBQoAWwAsAAAAAAEAAQAABwOA"
    "W4EAIfkEBQoAWwAsAAAAAAEAAQAABwOAW4EAIfkEBQoAWwAsAAAAAAEAAQAABwOAW4EAIfkE"
    "BQoAWwAsAAAAAAEAAQAABwOAW4EAIfkECQoAWwAsAAAAABMAEwAABx2AW4KDhIWGh4iJiouM"
    "jY6PkJGSk5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Crying ;("."""
cry = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/31v/33v/vxf/vvf/vtf/vnP/mzv/mpf/mnP/e"
    "tdbm3v/erf/enL3m///ehP/eY8Xe98Xe3v/eIf/Wa//WUv/WKf/WMb3W3v/WIcXWvf/OUq3W"
    "9//MZq3W5v/OQv/OOv/OKf/OIf/MM//Fc//Fa5TW/+bOOt7OQv/FOv/FQv/FKf/FMZzO9/+9"
    "e63Oxf+9a//FIf+9c/+9Y/+9QubFOv+9Ot7FQv+9Kf+9MdbFSv+9If+1Y87FUv+1Wv+1Uv+1"
    "Sv+1Qr3FY5zFzpTF5v+1Or3FWv+1Mf+1Kb29lP+1If+tWsW9Y729a729Y/+tOr29WrW9c4S9"
    "9/+tMf+tKYS974S91v+lQpS9hL21Y/+lOv+lKf+lMZS1rZS1jJS1hIS1lJStpf+ZM4S1jJSt"
    "lFqt/1qt74SlnGOttWOtrWOltTOZ/xCc7xCc9wCZ/5lmMzMzM////wAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgB0ACwAAAAAEwAT"
    "AAAH/4B0goIKNVo/iFo1CoONgj8xDQKTkw0xP450A1oPBp5yBqCeD1oDg5sQC6pyCwwLrKoQ"
    "pYJOKBK3cre6ubcoTnQKZRfDcgcBAQXHB3LDF2WFXx4eGAgA1tcACBgYHl81XV4tIiIBAHNz"
    "5ugBI+NXXV9XPCYmAun2AiQmLldfX0tNLkgwwHYtAQkXPpr0W7LDBw0qbiJiieiGSgkaPpZ8"
    "kWJlhwsaJUpw4GDBwkgzF31YkTKjo4uAJDLI5JAhSZwpLnZYmaFAipKXJEicO5eBTRw2OaUw"
    "CoKExwsTczRIlfomzhsXSIIIGiAFyVMTI8KGjUMWiRRTW4kgYcFCbNgwcR7OEEHbyAaRGzfY"
    "smhxg4iNTIMUnBhChPCQE4waBQIAIfkEBQoAdAAsDAALAAMABwAABxaAdCUlGWMkRXRRa3Rs"
    "b3RvcZFncWSBACH5BAUKAHQALAsADAAEAAcAAAcagHR0JHRzGWOERXRRdGuNdG+QdHGTdGBx"
    "KYEAIfkEBQoAdAAsDAANAAMABgAABxOAdCQkJmMvRXRRa3Rtb3RwcZGBACH5BAkKAHQALAAA"
    "AAATABMAAActgHSCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXgnMmkSYmL5AmLESQN2o2kEx0EYSB"
    "ACH5BAUKAHQALAAAAAATABMAAAf/gHSCggo1Wj+IWjUKg42CPzENApOTDTE/jnQDWg8GnnIG"
    "oJ4PWgODmxALqnILDAusqhClgk4oErdyt7q5tyhOdAplF8NyBwEBBccHcsMXZYVfHh4YCADW"
    "1wAIGBgeXzVdXi0iIgEAc3Pm6AEj41ddX1c8JiYC6fYCJCYuV19fS00uSDDAdi0BCRc+mvRb"
    "ssMHjR5GYMDYINFIjxI0fCz5IsXKDhc0SpTgwMGCBZIiM1qRMsOji4AkMsjkIJPEwR1WZiiQ"
    "ouSlzXNAM9h0sUMKoyBIeLwwMUeDU6dzTLxwgSSIoAFSkCw1MaJr13kvkEgxdZUIEhYsvH5l"
    "QYQI2UY2GIjcuIGWRYsbRGxkGqTgxBAif4ecYNQoEAAh+QQFCgB0ACwFAAIACQAJAAAHJ4AG"
    "goODC4ZydHKGCxISiHSJjRePkIkTlZiZmpuclSUJAgIEoQkcgQAh+QQFCgB0ACwGAA0ABwAC"
    "AAAHC4B0GXSEgyaEiCaBACH5BAUKAHQALAUAAgAJAAwAAAclgHSCcnSEgoMLdAuGhRKHEoRy"
    "B4eCB4yUmJmam5ydnoJzh6F0gQAh+QQFCgB0ACwGAA4ABwABAAAHB4BzdIODc4EAIfkEBQoA"
    "dAAsBQAKAAkAAQAABwqAOB0UFA6EHSqBACH5BAUKAHQALAUACgAJAAEAAAcKgDoyHx8VhDIr"
    "gQAh+QQFCgB0ACwFAAoACQABAAAHCoA9RjAwG4RGPYEAIfkEBQoAdAAsBQAKAAkAAQAABwqA"
    "QFlVVSGEWUCBACH5BAUKAHQALAUACgAJAAEAAAcKgE9paGhHhGlPgQAh+QQFCgB0ACwFAAoA"
    "CQABAAAHCYBUboNYg25UgQAh+QQFCgB0ACwLAAsABAAEAAAHEIB0dGaCSXFTGUVxUXQmgoEA"
    "IfkEBQoAdAAsDAANAAMAAgAABwiAbHRsW3FigQAh+QQJCgB0ACwAAAAAEwATAAAHJIB0goOE"
    "hYaHiImKi4yNjo+QkZKTlJWWl4JvdJqPYXFhmKGMgQA7"
)


"""Skype emoticon "Dance (dance)"."""
dance = PyEmbeddedImage(
    "R0lGODlhEwATAMQAAN7e3szMzL29vbW1ta2trZmZmYyMjHt7e3Nzc2ZmZlJSUkJCQjMzMyEh"
    "IRAQEAAAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "ACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAQACwEAAAACgATAAAFWCAkQsDzHOMomEoqBmbh"
    "QgFzHoEoLGaPHr1goISA8GIQxCOnNIlMAAjQKTWIpo1ZM+EqMWyClOFBADiyI6CIF74+RI1H"
    "W/oArJYjJcIsF/GLQG1KCQCFhCEAIfkECQoAEAAsAgAAAA4AEwAABWUgJI7E4wBjOirPI6gq"
    "0r4wJAhyUhNN6ycokYDFOPh8BFHrIHL4ZAYRAzFaHBdBlbXVyGpbjNrI+FiIRaXWIiA2CgyP"
    "htgqfXirD5G7lrBDSgp3EH1RBVxeAE5RAAk9TCNwZmwpIQAh+QQJCgAQACwCAAAADgATAAAF"
    "ayAkjlDyJGQqPqyaso0LAYLQPIEKIGzfFCSC44FY9GAASOHBEEAMvQThcYAIFjlrjwDNkgQ9"
    "gWPhCmwVQFdvTHABHg2CoqUCVyFGF7QNOTxcfmlzCElBVCI3RClLCiI7C2QkN40yWgwAmCQh"
    "ACH5BAkKABAALAIAAAAOABMAAAVoICSOUOA8AKlCx/McK9k+RAwJAvIkJKEsDZfQgUhBFruD"
    "UigsQABGkbAhaCxiwkTghXUdFKjY6YVA2JCuBSwWJCRcghXgoRDp4ioBF2II5/dvCVEiemto"
    "dT10IgAGC1ckSIg2egyDIiEAIfkECQoAEAAsAwAAAA0AEwAABV0gJI5i8hhkCjyPIxIPQwCi"
    "wDbvwrTJYbCElADBYiFSI1jxgITYbg+mqijQNYsOhwC5KiaaEAfLQWsSWWWu+BEEL4xgSCPG"
    "AP8S7/SokAW8pSNdCxBngBA/DQOHRSEAIfkECQoAEAAsBAAAAAwAEwAABWogYEBQ4DwCSTJP"
    "AB3Pc6jvA0BGPKoEKuSMmyoQKz4SKZXh0DA+EDTIoliA7UjTGEmhoCViDhIsiYstSIGFiwSI"
    "NaKqdmwdLTxyUDgMknjrbXYEcDkEbWdRMF0xgjRNbycOdAIPQRACU0EhACH5BAkKABAALAUA"
    "AAALABMAAAVhIAQBjhOIqHg8T5KiAYu8UCA0DfAKLOsgOhGgRyygCkRB4iFALVgMkcMlej4W"
    "ogZTpGBhIYfFCWLw0iCMh7aZWhmGVJRWxPiiWLqFPfswoPcQLAUxgGpkeCkOBAAAaQooIQAh"
    "+QQJCgAQACwCAAAADwATAAAFZCAkisLjAGOaHs9zqDD7ELAKME8hBDUkLK3gApVKBFsLhMNF"
    "hDAciuALAFyMAkup6PYaFY6CHikYFpdazVi2If4yqA9xNMwqw4Cieq3gsEKiaSIISBAAaCoB"
    "LQo8iTliW19+IyEAIfkECQoAEAAsAgAAAA4AEwAABW4gJAKOE4hoCgnPo6hq0L5wejyJIBgJ"
    "8zQjg6NFbCgUiRWRmFMdHARfSwAzPAC3KYxlyD5OKkCj4K1BCIrhg1EDtBaEYY1FSzyosMdB"
    "dCvAEC4iVnspgA8OfA8EKgsLCHgKD35mIpFAlAAAPngiIQAh+QQJCgAQACwDAAAADQATAAAF"
    "XCAkGg8jnijUPI+QogrrQoDBPGfgPMax7IwF6sBiGQIpYrHwKjwWxRmsQYi+Aqsi4AUhWbk3"
    "Fle0eyTGAe1YKRxDHY7tC/AkIrjEBWB1RyFYQjEtJ14NBjQxCichACH5BAkKABAALAMAAAAM"
    "ABMAAAVmICRCzcOIhAKM0OOKyyOwzNOIh8NCxOMch8VNJIi5jgiRweU4GmaiRzJxhEKWq0N1"
    "FBMVjqwCAeUa7q6u5BlSeyjWgMchoTsjHgDt2nHq7r5JDWYiAE0HX3g0Lk+GI3cKUAENbyIh"
    "ADs="
)


"""Skype emoticon "Devil (devil)"."""
devil = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Doh! (doh)"."""
doh = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP/WG//KHf/dX////f/hfP/onf/nzf/stv++Kf++Jf+7If++Nf+zNv/6"
    "6P/STf/RG/+zYf/BIv/WKP/ffv+wIf/aGv+0Qf+tVP/fgf/hdf//2/+mOf/nn//mof/NNv/L"
    "Lf/88v+9PP//6f+5Hf/XZv+1If+lJ//py//ZRv+yPv+gLv+fK//wyP/VJ//VLv/gqf/aYv/g"
    "VP/ZJP/ozf//9f/dg//YGv//4f/QKv/RHv/WHf+8bP+qLv//+f//5f+zOv/cYP+rOf/PJv/R"
    "Zv/ztv/CZv/gnP/UNv+7Yf/TKP/kiP/qlf/YZP/Bbv/71f+sKf/YIf+dLv/YHP/z2//ROP/K"
    "bf+eOv+gPP+zWv/KIv/bF//2yf+8YP/BOv/XNf/AY/+uM/+yRP+tJP/88P/qmZxtM//QOv7M"
    "KP/OIf/PMv/QLP/ZM//INP7PHv/HOf/WIf/TIf+7Lf+6Kv+2I/+3Jv+sI///7v/QT//WaP/o"
    "xf/MPf/KO//UKP/on/+7bf/SOP/z4f/gfjMzMP+9av+7VP//8f//6//z1/+6SP/urP/smP/j"
    "of/le/+mPpViL//z5f/87//xx/+vYv/wx/+oMv+3Pv+fLv/RM//64/+7dv/fsf+aLv/ifP+i"
    "Of+tPP+gPv+5b//WSf+0Of/LNf+9If+8Hv++MP/IKv/IIf/TLf/IMf/HKP/HI//KJv+/G//S"
    "J/+3Kf+rIv+pJP/AHv/MK//AL//RKP/AJf/KL//JL//MHP/NHv/MMv+0K//BLP/HIP/MLP/O"
    "Lv/QMv/QM/+/ZP/PIv+6bv/PO//ZGv/THf/US//NUv/PUP/05v/MNf/KM//OMP+1U//KIf/M"
    "I//QIf+zVf/HPf/z5v+hO//SLv/RI//re//eVv/UIv/XM///8v/65P/97f/ny//IPf/KdP/2"
    "zKF0N//egv/EX//vyf+wO/+gN//NMP/imP+pQf+1Rv/FYf/JM//lpP+iO//XIf/qnP/OUv/s"
    "o//76//HZf/TTv/UTf/je//QUC8vL////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRRoAJQVSQitgDIwsKFACJk0QZo4UVMmCA7/Pfr0gsWkSZFChmTx4tOj"
    "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"
)


"""Skype emoticon "Drink (d)"."""
drink = PyEmbeddedImage(
    "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"
    "FUCAcEgsGo/IpHLJbDqf0Kh0Sq1CgwA7"
)


"""Skype emoticon "Drunk (drunk)"."""
drunk = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP///zMzM//87//wx//pzf/oo//xx//hgP+0Zf/z5v/05ZkAAP/ozf/h"
    "gf+9cP+2SP+/ev+jMv/LOf+1Y//COf+kQv/NOv/ftf+7cv+hMv+4Pf+sNv+eMv+7Qv+iPv/o"
    "zv+vPP+mPf/gof+2Qv/ZSv/dY//SUf/yyf/RN//YJf/bZP/cY//QPf/aZv/WTf/FMP/DLf/Z"
    "KP++Lf/KJv/Saf+xLP+tKP/CKP+7Kf/LMP/KP/+jLv/npP/fhP+/Y/+5Rv+kMv/PJf+lMv++"
    "JP/Rav+qPf/igP+3V//EM//KKv+iL//Ecv/HLP/Ecf/BLP/ehf/VH/+4JP/QN/+/ZP/mp/+o"
    "K//JN//ML//DH//MOv/AQP/WIf/FPv+yN//ehv+kQP7FPv+4Rv+wQP/Xav/ZHf/Wa//YN/+2"
    "Ov+wV//FJf+vJv/BKv+/Jv/grf/RJ/+0JP+wLf+lP//BJf/KMf/dh//IQf+7Lf+pKv+4L//A"
    "Iv/npf/UH//ggv/PVP/KM//bG//grP+5Jf/vyf/SH/+tMv/MLf/TJf/EKf/KIP+zN//RIv/P"
    "P//DaP+/bv/EaP/no//MQf+9If/BQP7bG//oov+/MP/fg/+xP/+wWP+wJ//FJ//HJ//CNP+3"
    "WP/oof/ggf/OMv/JM//MNv/ILv+0Jv+4Of/EIv+xKf/wyP/HJP/NNP+7J//PN//05v/Ab//z"
    "5/7HPf/MIP/NIv/npv/IJf+4Rf/NVv7bHv/MKP/INf+8IP/QH/+qPP+uMv/IOf/QU//YIP/U"
    "QP/0z//de//ZZ//zy//VK//hd//10v/Xaf/1yf/00//VOv/fOf/XH//zuf/00P/xuv/aHv/a"
    "H//SK//1x//eYf/XJv/WLf/zx//zz//XLP/ULf/QNv/UJv/WJf/WLP/1zf/RLP/YZ//wuv/y"
    "uf7eOf/XN//YS//VI//TIf/RM//PIv/PKv7ZHv/JIv/WIP/RI//YaP/QPv/TLP/bHv/PJv/U"
    "UP/QLv/YKf7ZIP/OJf/LJ//yuv/z0P///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRT4AYMHBAg9YPgwsKHACRAuCJg48QKECQ7/JajQRtCAAQZCfkQFqEKC"
    "gQm+iKCi51GBAp4oveQxS0ScVwIxMaLzxNKnBgcOGDnQgE8PL47Q/GPAgUiZZMRaqFhR4pgw"
    "ANCGjaHBgYEDJbZ+jTsBIJs1EsgAqF1mos8OByGq1IGkTS2AcGbULlgAYJGOOyEy2JARyq7a"
    "GMrsFsuxRk2GCJmiaCK7t9qtZs8ARAtGS9ebCEBOBcrDghyAcuYm/SEDZVAsLJFICeEFZ5Wc"
    "VLIUbQE2TZqzPbsQmRpSo0gjQjhubMLlxtu1FCm+GQoyIw2bXq4IbMDjhEkhcdywbWUDZ4xa"
    "gCSH7Gwg8K9Tl0ov5oAKQL/+lVEwEh0R2ArEGU65iMKKFCig0I0qfiBRCggKDKSAGBpQ4IsE"
    "WVhggQRWUKDBJQ06NMUIHWgBBixcSNLBCD5kNBABSzwQxg+1PNAEew0FBAAh+QQFCgD/ACwA"
    "AAAAAQABAAAIBAD/BQQAIfkEBQoA/wAsBgANAAEAAQAACAQAAwQEACH5BAUKAP8ALAAAAAAB"
    "AAEAAAgEAP8FBAAh+QQFCgD/ACwAAAAAAQABAAAIBAD/BQQAIfkEBQoA/wAsBAAFAAoACwAA"
    "CEMAh/kDIOzYv4MHlwH4BwAZwoMLIT78V+zfggXKJs4jB6CfuYnv2KmD526iyZMBUqZ8KC4A"
    "gJcAArRDuI7hS5Qr/wUEACH5BAUKAP8ALAAAAAABAAEAAAgEAP8FBAAh+QQFCgD/ACwEAAUA"
    "CwAIAAAITgCTEWuhYsW/EitUtJBn4p4LdCT+kSCBzsW9eSyYBTgXwMw5ZsxYBBgJLt+/kQHo"
    "4eNnz1A6ff/qAUsXb9+/mzhz6kQZQOdNAEAB9PwXEAAh+QQFCgD/ACwAAAAAAQABAAAIBAD/"
    "BQQAIfkEBQoA/wAsAAAAAAEAAQAACAQA/wUEACH5BAUKAP8ALAAAAAABAAEAAAgEAP8FBAAh"
    "+QQFCgD/ACwEAAUACwALAAAIXQD/CRx4TBgAaMPGnQCQzdo/ZAAiLtMWEUA4MxEXLKhY8Z+y"
    "isUWaqz2r9kzANGCsSAHoJy5gTAHApsmzVnMf96upUjxzRDMANywbQNnjFqAn/8CKL0pEAWK"
    "bgMDAgAh+QQFCgD/ACwAAAAAAQABAAAIBAD/BQQAIfkEBQoA/wAsAAAAAAEAAQAACAQA/wUE"
    "ACH5BAVkAP8ALAYADQABAAEAAAgEAMUFBAA7"
)


"""Skype emoticon "Dull |("."""
dull = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/mzv/mpf/etf/erf/epf/ehP/eY//eWv/e"
    "If/eGf/WY//WUv/WSv/WOv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/OKf/OIf/Fc//MM//Fa//F"
    "Qv/FOv/FKf+9e//FMf/FIf+9c/+9a/+9Y/+9Qv+9Kf+9Mf+9If+1Wv+1Y/+1Sv+1Qv+1Ov+1"
    "Mf+1If+1Kf+tWv+tOv+tQv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMzM////wAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBAACwAAAAAEwAT"
    "AAAH/4BAgoIFJTktiDklBYONgi0iBwKTkwciLY5AAzkIBJ6fnwg5A4ObCQaoqaoGCaOCNB4K"
    "srO0sx40QAU9Fj69vgu+vhY9hTsXFwE/PwERzcnLEBc7JTo8HxgBAAABEt0C2gEYGDg6Ozgp"
    "HQ8DAwsT7gzrCx0hODvmMiEaGhX8DQ38GzSEWCHD3owUK0hs4FfBgQOGG0ismLGjxo0UIRQu"
    "rOAPYMSJNUxcDJFPg7uTE/SFSHFjUY0YJPWhdKcyRQ1GLGCoGNGhp7IfFHqOCAGDhaABNWDw"
    "7JChaVOhMGqQOmoDBggQTp+CgPFiaqMTL1Cg+ADiwwcUL05kGlSAgwsXaAZdcGDUKBAAIfkE"
    "BQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAs"
    "AAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEA"
    "AQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOA"
    "QIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsBQAHAAkAAQAABwiAPz9AhISC"
    "gQAh+QQFCgBAACwFAAYACQADAAAHD4AAAECEhIKFiIQ/P4mLgQAh+QQFCgBAACwEAAcACgAC"
    "AAAHEIA/QABAhUCCAIIDhodAA4EAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAs"
    "AAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEA"
    "AQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOA"
    "QIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkEBQoAQAAsAAAAAAEAAQAABwOAQIEAIfkE"
    "BQoAQAAsBAAGAAkAAwAABxCAPz9AhISChYiEDwOJDAOBACH5BAUKAEAALAQABwAJAAEAAAcJ"
    "gAEAQISEAgCBACH5BAUKAEAALAQABgAKAAEAAAcKgAFAP0CFQII/gQAh+QQJCgBAACwAAAAA"
    "EwATAAAHHYBAgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmoqBADs="
)


"""Skype emoticon "Evil grin ]:)"."""
eg = PyEmbeddedImage(
    "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"
    "x8iNgQA7"
)


"""Skype emoticon "Emo (emo)"."""
emo = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////7//35v/vpf/mzujo5t7e797e3v/gc97e5v/WMf/WKf/WId7O"
    "tf/OOv/OKf/MM//Fc//OIf/FOv/FQu/OGf/FMf/FKf+9a//FIebGY/+9Y//FGf+9Qu/FHv+9"
    "Kf+9Mf+9IP+1W/+1Sv+1Qv+1Ov+1If+xMf+xKf+tQv+tOrW1te+vH++tKd6yGc61Ga2tra2r"
    "oM6tIc6tEd6lIa2lc5mZmZSUpLyTGa2UGYyMtYyMjISEpYSEjL17KXt7rXt7nIR7e5h7GZRr"
    "QoRrD4RjEGhjUIRdIXNXEFJSc3NKGWNKGVJKIUJCf0REQlJCCFI6EDMzZjMzZjExczExWjMz"
    "MzExUkIxCEIpMSkpZ0IpIUIpECkpSjEpBi8lISEhYyEhUjEhCCEhMRkZXxkZUhkZQhkZMRkZ"
    "ISEZARAQWhAQYxAQOhAQRhAQDggIQggIShAIKRAIIQgIKQgIIRAIAAAAWgAAUgAAQgAAOgAA"
    "MwAAIQAAKQAAEAAAGQAAAAAACP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgCAACwA"
    "AAAAEwATAAAI/wABCRRoQEeTOnbsNNGRYKBDgT/UjMkypWIWMmyAPARUYEqail/IiARDhcoa"
    "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"
)


"""Skype emoticon "Envy (envy)"."""
envy = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP///zMzM/+4ZNflqv/bHKO4KoS5Tf705v+4Rd+zOv/SUW6uLcjeif76"
    "6YbCS6XMXbzXbozLMpnFbdTMbf/LMuTvysfbs/+pK8rTRf/MI4K8HYi5Jv/SNIa3Vd6uOa7T"
    "Q+TSTHKqObzMZZq8d2uoLcTLMavNRufGa/+9dP/gocLHKo7SM4nLK5DSOevbdf/LOcnUOnKh"
    "Qs/kpuLNQv/pzf+8JPfszP/GJo/VOu715ZhlMrXFVfjwz//ULKvKPf/EP//88YXCI6/WbX60"
    "RqbJLfX25cnLRMG6Lf/KK52zHf/CKv765ePMSuHMPP/COarMNebnqsa6PP+0WIvENGylMeju"
    "yanBPKnSNP/TauTMUGmeMtzo0OS9VovBVv+xPuK7TI2zZ/+7Ld65L7TSlZK8aP+kPeHFPKPI"
    "fcfLO//cYuPTRqa9NH6vTdfbccbQNPLhqKfKMcrDSqPFI//DaqbJgv+jMf+tNP/TIP/ehYnB"
    "K77ciMO1MvX589DVXefTZNfOdeDFNnm1PP/wx32qUW2ePP+yJrPRWd7hjJfEQ//EMv/npMjB"
    "ROXSVKrPZ+PZQf+4O5nLRe7hkeLESvPjtP389IfHKuPTP/+wK3y8Pc3EVenms3OxM3K2LuC2"
    "QenIdarWOfPor4C2F6bANPDvzMPFM6TELP/hgb+7Jv/28eC/O3qsRq7WPpLKOX3COe7ii8rY"
    "Ot2rMP+lQI3MOHm9NazROeG6Rf/PVK3VOt/CMZ7FTvj78WibNf+eMszSS//grf+rPv/ftYSu"
    "XP/Fcsbjl3akSKbPNMe+QcjQP6PPV+HuyP/hV//OP/r89f+zN6jRONHkl63QP+W+X4fHJYLD"
    "QcjUN4/XNaXIJ+HKNu/ekf/YN7XQmJ60IdXVb9HHYv/hecbAPXmnTP/CIeLHQsrPR//YH//Z"
    "KLDCSMW3OsS8NXaxOv/ZSnW5Mfz88v+/MP/YaOLmmeLomZ+8Hc7ZTYvPL5vTSMDAJqHAIqjM"
    "OqjPMHerQafMLeTWScfRN2+0KsvWQv///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFAD/ACwA"
    "AAAAEwATAAAI/wD/CRRIA0UZAQjLoKAxsKFAASiAAZk4ERgKAQ7/HYjlS5DHjx99xTowcGMK"
    "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"
    "hOMYMcAtA3QYEAA7"
)


"""Skype emoticon "Finger (finger)"."""
finger = PyEmbeddedImage(
    "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"
    "CLBTCIxQErIAABKsircSwL2LUMTCmYEAOw=="
)


"""Skype emoticon "Flower (f)"."""
flower = PyEmbeddedImage(
    "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"
    "usB0ERIqLARyKYNQYEAAOw=="
)


"""Skype emoticon "Fubar (fubar)"."""
fubar = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Giggle (chuckle)"."""
giggle = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//35v/3zv/v3v/vzv/v1v/vxf/vrf/mvf/mxf/m"
    "rf/mpf/mnP/etf/erf/ehP/ee//eY//Wpf/eWv/We//eIf/WY//eGf/Wa//WUv/WSv/WQv/M"
    "mf/OjP/Mmf/WOv/WKf/WMf/WIf/Oc//OUv/OSv/OOv/Fe//OKczMzP/MM//Fc//OIf/FQv/F"
    "Ov/FKf/FMf/FIf+9a/+9Qv+9Mf+9Kf+1c/+9If+1Wr29vf+1Qv+1Ov+1Mf+1If+1Kf+tWv+t"
    "Uv+tSv+tOv+tQv+tMf+tKf+lSv+lQv+lOv+lMb2tOqWlpb2lSr2lQr2lOr2cSr2UUr2UQmZm"
    "ZjMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBXACwAAAAAEwAT"
    "AAAH/4BXgoMQO0k5OUJDFQODjlcGQiAHAQICAQgfOwyPVwxDCwUJo6QHCTUVjgxEDQ4Pr7Cw"
    "CjupgkQmEhO6u7wSF0oIVxBLGxnGFBbJyRTGG0YfVztMJycdVlYe2R7XHSgcR0ZXS0gxKVYi"
    "JFYk6etWKSlBTFdMSDgzKysjIyUYJfr4MoDIYxJEB40XL0rw09CvxAsaOgTOC4Lj4AsoVao0"
    "0aDwoY54V4gcwSHDCkYATqpA8WeFBo0fRa58OEKliowqAFACqDLCygoZMn6ouEKgCE6cOlP6"
    "/HnjCCeZOJ0kZVGlRYsZM3y4cIQ0p9QqT1K0iKGVANecaKtIiQHDhg8QZhUd8UBKdYoNGz1c"
    "ROg0KGMVHnwHBQIAIfkECQoAVwAsAAAAABMAEwAABx2AV4KDhIWGh4iJiouMjY6PkJGSk5SV"
    "lpeYmZqKgQAh+QQFCgBXACwAAAEAEwASAAAH/4BXgoMQO0k5OUJDFQODjlcGQiAHAQICAQgf"
    "OwyPVwxDCwUJo6QHCTUVjgxEDQ4Pr7CwCjupgkQmEhO6u7wSF0oIVxBLGxnGFBbJyRTGG0Yf"
    "VztMJycdVlYe2R7XHSgcR0ZXS0gxKVYiJFYk6etWKSlBTFdMSDgzKysjIyUYJfr4MoDIYxJE"
    "B40XL6BUqdKkX4kXNHQInBcEx0GFAJxUiVLiYcR4V4gcoVLFShUAGQFU8WeFBo0fRa58OHLy"
    "ZEqNI6yskCHjh4orBIqcdHKTRUmAN45wkmkTJdEqT1q0mDHDhwtHTVFCfdcihlUCjnjYNCol"
    "RQwYNnyAANtpYZUpNgfi9nARwVEgACH5BAkKAFcALAAAAQATABIAAAccgFeCg4SFhoeIiYqL"
    "jI2Oj5CRkpOUlZaXmJmRgQA7"
)


"""Skype emoticon "Shaking Hands (handshake)"."""
handshake = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP/////39/f39/f37/fv7/fv5u/v5u/m5u/m3u/m1u/e1ube1ubezv/W"
    "rebWzubWxd7Wxf/Opf/Mmd7Ovd7Oxd7OtdbOtffFlPfFnObFpd7FpdbFtdbFre+9jOa9lOa9"
    "jN69nNa9rda9pc69pea1hN61hNa1lM61pc61nM61lMW1lMW1nN6thNathM6tlNate86tjM6t"
    "hM6te8WtlMWtjL2tjM6lc86le8WljMWlhMWle8Wlc72ljL2lhL2le72chMWcc72ce72cc7Wc"
    "c7Wce72Ua7WUc7WUa7WMa7WMY62Ma62MY////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgBMACwAAAQAEwAM"
    "AAAHj4BMgoMIQ0lAiEBHEINMOEeHNktAJR0fFxISFzdLSxwJHx2ZF4mKRTclmJkfLJmurxId"
    "LEBJrbC3F0U2JZpHNre3Hy9AkyxHosASxLsXHcNLL6PAF8+nHyRFmYcvqrlAH5okNkdFQJKC"
    "I0M34B8fRUtH6x9HRgmNEEpLSTYvJB83R+AxajTIQUB4OBIuIBgIACH5BAkKAEwALAAABQAT"
    "AA0AAAefgEyCg4IbNEdLPYSLE0pLS0c3JBIXHzlHODgbC0BALyRFS0UvLyweEQ0SHR8fJC8S"
    "sJSkpDdHSZOxubqwFxIlSUmvu7s2Ry8XHUBFw7GVF6BFkjc2zL5ARyyrxUdAsEnZub0fQElF"
    "Jc/YQEwzR9Sw3CQXFyWhN0k4CIOPNh0XL6FHSnwocWTBIiY/HkX6ZONREA4HBRkYkQnHkEcT"
    "FgUCACH5BAkKAEwALAAAAgATAAwAAAeVgEyCg0wFCTiIMw+EjAFMRkU3H5MkNksIhAQoQCZC"
    "SUCgJR8YES9BKhMGQCQSrRIdkyUvRUc2JRIfLzauvK0fF7gvSze9xRJAS5EkJTYsxr6TFx0v"
    "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"
    "gyYoWbKkCJAiMxAsCgQAOw=="
)


"""Skype emoticon "Happy (happy)"."""
happy = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//35v/vxf/vpf/mzv/mpf/mjP/mhP/etf/erf/e"
    "pf/ehP/eY//eIf/Wa//eGf/WUv/WSv/WOv/WMf/WKf/WIf/OUv/MZv/OQv/OOv/OKf/OIf/F"
    "c//MM//Fa//FQv/FOv+9e//FKf/FMf/FIf+9a/+9c/+9Y/+9Qv+9Kf+9Mf+9If+1Wv+1Y/+1"
    "Sv+1Qv+1Mf+1Ov+1If+1Kf+tWv+tOv+tQv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMzM///"
    "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBDACwAAAAAEwAT"
    "AAAH/4BDgoIHKTwwiDwpB4ONgjBBkQKTkUEwjkMEPEEFnZ6eQTwEg5oNCKeoqQgNooI3IQ6x"
    "sg4Ksw4hN0MHQBG9EQkDAgaTCQ++QIU+GRkTEwFCQgDQARTNGT4pPT8iGxscz9HTFRzdOz0+"
    "OywgIBYPBAQK7w8XHSAlOz7oNSUdHRj/ECD889ChhIsa+WywcHHCwz8MEiQ89HDChQ0fOHSw"
    "KNHQIYaAAylaxIFCYwl+HS6oXNmvBAsdKA7gmHGynwULK+kVZIGD0QsaLUysAwFNiIV1JkrQ"
    "eCGIAA4aQkFwmDoVKQ0co5rmoDFiBNWqI2jIyNpIhYwVK0SMECFihQwVmA0GHfgQI4bbGB8Y"
    "NQoEACH5BAUKAEMALAQAAQALAA0AAAcngEMkCwJDhgILJEMMQ0GOjY+MQYaUhpOVmJmam5yd"
    "np+goZRCo5SBACH5BAUKAEMALAQAAQALAA4AAAcqgENBg0OFg0GCQwWLioyICIWRhZCSlZaX"
    "mJmam5ydnoVCFpEXQpWloJGBACH5BAUKAEMALAQAAQALAAwAAAclgEMkCwKFhQskQwxDQY2M"
    "jotBQ5OUjJWXmJmam5ydnp+XQpmigQAh+QQFCgBDACwEAAEACwADAAAHFYBDQYNDhYNBgkMF"
    "i4qMiAiFkYWQgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAH"
    "A4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh"
    "+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBD"
    "ACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAA"
    "AQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAH"
    "A4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh"
    "+QQJCgBDACwAAAAAEwATAAAHHYBDgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmoqBADs="
)


"""Skype emoticon "Headbang (headbang)"."""
headbang = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////9///rf/57//39//35v//Zv//Uv/v5v/v3v//EP//AP/m3vfm"
    "5v/lz//3CP/lrfzsSvfe3v/etffeyv/Zw//elN7e3u/vAP/Zpf3civ/ee/fWuP/Wc/feOv/O"
    "xfnOtv/Lpf/OjP/Mmf/MmffMrffFxf/MZvfWGf/OQv/LWvfFpf/Fh//Fev/MM9bWJv/FSv/M"
    "AO+9vf/FQv+9hPe9mv/FIf+9d//FFv+1pf/FCP+1lP+9N/28SP+zive1i9bOAP+9Gf+1a/+9"
    "EP+1Y/+6Kf+9B/+yWv+1Ie+trP+1Gf+1EO+uhf+1A/+tSv6pav+mefCpe/+oUu+lpf+rOv+s"
    "Ie+llP+rGfuoMf+lQvKlc729Ib29EP+qBP+lKfeccsW1AP+aXP+Ycf+bTv+cQv+cOu+ba/2c"
    "Kf+Ue++aY/+ZM/+ZM+aUlPGVWv+XIf+UPf+ZAP+UKf+Mc/+UGf+MPP+IY/eMTf+MMe+MVv+M"
    "Kf+MIf+OAZmZmf+CWeaEhPeEOv+EIf+BQu+EUv+EKf+CMe+CSuaESu99QuZ7e+Z7c/97Gf97"
    "If9+A/97EPJ7Nf9zUuZzc/9zGf9zIe9zOu9zMfpwMP9zAOZzQv9rQv9uEISEhP9rGflrId5r"
    "a+9rKf9mM+xrMd5rYOZsOv9mAP9mAP9jEN5jYe9jIe9jKf9fGf9fCOZiK/dcGd5fNf5aEN5a"
    "WulaHt5aQt5aSv9SHXNzc/9SCd5SUvVSEO9SGd5SQnNzIeZSGv9KCfZKCOZKEOZKGd5KM/9C"
    "CPdCCN5CQvdCAO9CCNZCQuZCDN5CKd5CGdZCMf86CP86AO86CNY6Mf8zAPczAO80AOY1CN40"
    "C9YxMdYxGvcpAO8pANYpH94pCMUxAO8hAOYiANYhId4iANYhFeYZAN4ZANEZGUJCMdYZBpwp"
    "AGYzAN4QANUQAc4QEJwZAIQhANYIADMzM84ICM4IAMwAAGsYAHsSAFoZAGMQAFoQAFIQAEIQ"
    "ADUQADEIACkIACEIABkEABAAAAgAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAAACwA"
    "AAAAEwATAAAI4wDvCQRAsKDBgwD8zfuHsGHBftoYOmzoT5/EiQf95btYkMUNIkeySHFQ0J86"
    "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"
)


"""Skype emoticon "Heart (h)"."""
heart = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP/////6+v/7+//5+f319frz8//w8P/v7/Pw8P/r6//n5/zn5/vm5v/j"
    "4//g4PXg4P/d3erg4Ozg4P3a2v/X1/fT0//R0f/Pz/LQ0OjQ0OPQ0OXQ0P/Dw//AwP28vOXA"
    "wP+5uf+2tvm1tfWysv+wsN2wsP+mpvmnp/+jo/akpPSiovOhof+dnf2cnP+amtqgoN2goP+W"
    "ltmgoP+Pj/+Njf+Kit6QkP+Ghv+EhP+Cgv+AgP9+fv98fPp7e+iAgP96euaAgP94eP93d92A"
    "gNmAgP90dP9ycv5xcf9ubvxubvJxcf9sbP9qav9oaP9mZtxwcPhmZv9hYf9eXvJiYv9cXP9b"
    "W/BeXv9ZWdxgYPxWVv9WVv9VVfpVVdJgYP9TU/9RUfxSUv9QUP9PT/9OTvlQUO9RUf9LS/RO"
    "Tv9KSv9JSf9HR/9FRdZQUP9DQ/9ERP9AQP1AQP8+Pv89PfRAQP87O/46Ov86Ov84OPw5Of83"
    "N91AQP43N/42NtdAQP82Nv81Nf00NNFAQP8zM8pAQPwzM/8xMfwwMP8uLvwuLv0sLP8sLP4q"
    "KugwMPwqKt8wMP8oKPwnJ/soKP4mJv0kJP8kJP8jI/okJM0wMP8gIMUwMP4fH/wgIPkhIf8e"
    "HvofH/IgIP8cHOshIfYeHvsbG/gbG/8aGv8ZGdwgIPcZGf0YGPsYGP8XF+UdHdcgIP8VFfkV"
    "FfcWFv8TE/AXF/wUFM0gIP0SEvwREf8REfoSEvcSEv8PD/sPD/MREf8NDewREfcODvUODvcM"
    "DOgQEP8JCfsJCfUKCv8GBtwQEPMJCf8FBfoEBPEHB/8DA/4DA/MGBv0CAv8CAvoDA8oQEPQF"
    "BfUDA/kCAvoBAf8AAP4BAfIEBMYQEMEQEPADA/wAAO0EBO0DA+4CAvYAAPgAAOoCAu8BAfMA"
    "APQAAOwAAO4AAOECAuoAAOcAAOYBAegAAOIBAeYAAOMAAOUAAOIAAN0AAOEAANoAANYAANQA"
    "ANEAAMwAAM4AAMsAAMgAAMMAAMUAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwE"
    "AAUACwAKAAAIcAD/ufgyJoaBGXQI9RAYRooXQW7kmCHES4kZKmEUxXKlSJEqb8LiXCmU7Nqw"
    "VbqsvZvHxI0mbNdiQuNWr0+IRamexbwWLd0+GP/IeLJkC1s1dfkG/ftX4MycT+Dc6cuEYClT"
    "K6zs7aNq1aqPVkS6BgQAIfkEBQoA/wAsAwADAA0ACwAACIkA/10Q4ycMiH8h0hR64+GfhTZh"
    "rqRRFKVgGkm/RnzxwuQKolWg+KT5V4tbqDxSpCga9mxYKlC9rLWT10ZLHF3XciZLdk0cvWNH"
    "/gHCmTPnP27/2JBYZKjWv6dPlf3bB+MfF0+2oD719m/QUwaigkXDBtXetghQK8gCRw7qNg1a"
    "/z1gRA8q2qcBAQAh+QQFCgD/ACwCAAIADwAOAAAIpgD//buh6JCRBv8cMMEE6ggBgWvc/LvS"
    "RhGLQ//G7BlFqsANN0x0IBGoKQ4SJnBQLZui6J+Of3Yw/YuFsQ4pZOPUKaJShA4zaAKDBoXn"
    "JYyUR9eECq3nSAgdMZKwKQ16D8uFRXAmMZv6756+D/+yNPpHTGg4gfsCCVxgCZbSeP/4SZMQ"
    "VASyZUr59SuhdISvdkH5aeM7FQOjeffyXdrANSiQU0OmBgQAIfkEBQoA/wAsAAABABIAEAAA"
    "COkA/wkkgeaRGxoC/924s0pQi4T/athxE8bMnz8U/txRI0cSLigCO9j5YgQHkn+UQPlZoiMK"
    "oVzOVPxD4+ZIDSZyMLm69edflUICv4X690hMjiadmEFLZszUoVXXrAl89w/TmB9tmEE0psvY"
    "P3EC6fl040TQNYgJr5WLV0+PwjxeFEFDK7Abunn3nvyDIClOomF0r5mD909fBoFgIv2bhQ3i"
    "NXHr7O0LlHCBJYHR0kK2x0+aBIgngAkUJ65buXec/b2gmyIbun/o1NG7x6+fDLoCV/hal5Cf"
    "ttu4BWJghDffpQ3B0QI5NQR3QAAh+QQJCgD/ACwAAAAAEwASAAAI/gD//VMg5FElKiYE/jNx"
    "BdSqKBMUcvDjR46af4qoHJCi6F+bf5p2nRhY8cuRH1FAynnkRUiQLZKCOcMQJE8YHTOWuKkU"
    "K5bCn9/KPJKDZIaUSr2MKX30RY4rY9X+qWtXaQ0PJJSg/RzmaphAcQLhKVJjBI3Xn/+uKQwn"
    "8NgVOU7sJEP781q5f/b0oDgURo4uugq7nfuHz0YCUHX+lVJL95o5eP/ySfiXBBKeTcwAi2Nn"
    "L18XgQssCSRGV9y6evukTRZ4IhcstNdM2/vn7wVaKMgUiutm7t1sf5/pTuGG7h86dfLu8esX"
    "HPCKc+sU8vMnA/BPDKHmdaa1wTpdIKeGA1gPCAAh+QQJCgD/ACwAAAEAEgAQAAAI9wD/CSSB"
    "5pEbGgH+DbhxZ5WgFgIF1rDjJoyZP38o/LmjRo4kXFAEdrDzxQgOJG8ogfKzREcUQrmcqfiH"
    "xs2RGkzkYHJ16w+TKoVUIfsW6t8jMTmadGIGLZkxU4dWXbNGbt27f5jG/GjD7JrXa8Z0Gbsm"
    "Tp08ev+quHEi6Ktbr+Xi1dPz70YeL4qgvfXaDd28e0/+QZAUJ9GwvdfMwbunL4NAMJEQzcL2"
    "Vtw6e/sCRVxgidOraN2+WrbHT5qEiP9OACtGTZy4buXekfb3ArXAFNnQ6VZH7x6/fjJsR1zh"
    "ax29evj4aQsuPCIGRn/zXdrQXDiQU0OaBwQAIfkECQoA/wAsAgACAA8ADgAACMQA/wm4oeiQ"
    "kQb/HDDBBOoIAYFr3Gy50kYRi0NqxuwZRarADTdMdCBR80hTHCRM4KBaNkWRFx1M7GByFeuQ"
    "mTqkkI1Tp4hKETrMoCUz5gpUL3Hn4MHzEkbKo2tQo14rF6+eIyF0xEjCJvVaN3Tz7mG5sAjO"
    "JGZdzcm7p+/DvyyNPBGTGo6dvX2B/v1bYAlWMXHiulG1x0+aBL3/RCBbRg6dOnr3+PUrgVjv"
    "CF/t5NXDx08b5cp6MTAKm+/SBtCggZwagjogACH5BAkKAP8ALAMAAwANAAwAAAiXAP9dEOMn"
    "DIh/IdIUeuPhn4U2Ya6kURSlYBpJv0Z88cLkCqJVoPikEVSLW6g8UqQoGvZsWCpQvay1k9dG"
    "Sxxd13ImS3ZNHL1jR94AwpkzJzZu9tiQWGSoVtGcytztg/GPiydb2Io284Zv0L9/DEQFi4YN"
    "WzRv9rZF+Pqvgixw5MC507dNA9uvDxjRs5cv09q7bH20IgI4IAA7"
)


"""Skype emoticon "Hi (hi)"."""
hi = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////9///7//37//35vf39+/v7//vxf/vpf/mzubm5v/mpf/mjP/m"
    "hP/etf/erf/epd7e3v/ehP/eY//eIf/Wa//eGdbW1v/WUt7Wtf/WSv/WOv/WKf/WMf/WIf/O"
    "Uv/MZv/OQv/OOszMzP/OKf/MM//OIf/Fc97Oa+bOWv/Fa/fFe//FOv/FQv/FMf+9e//FKebF"
    "a/+9a/+9c//FIcXFxd7Fc8XFvf+9Y/+9Qu+9Y+bFMfe9Sv+9Mf+9Kf+9If+1Wv+1Y969c/+1"
    "Sr29vc69jP+1Qu+1c/+1Ov+1Md69Qv+1If+1Kd61hOa1c/+tWt61a/+tQv+tOsW1lP+tMcW1"
    "jL21pbW1tcW1e7W1rf+tKfetKbW1pe+tOv+lQuatOv+lOt6tOv+lMf+lKbWtnK2trcWtWq2t"
    "nP+ZM8WlWq2lnKWlpaWlnKWljNacUrWlY7Wcc62ca6WcjKWca5mZmZmZmZmZmaWUhJSMjIyM"
    "jJSMe4SEhHNzc1paWjMzMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAAACwA"
    "AAAAEwATAAAI/wABCBSYYIaXIAi9zEgwsKHAIC8cCJg40cGLIA4BEPDy4IDHjx8feCEwcCOE"
    "BShTqlwAYaTAJyokyJwpoQFNCSqeAEiApoLPCgwGCEAwkcGEn2gKivnwAQOGAH78AIgaQIPT"
    "D2JmgBnTIkQIEVClUt0gwqsWMGK09ChRosMEAgQawJ3AgUQJGFrEpF0CgwQJD4ApUABsggSM"
    "H0v0MvHxg4YJwB4sWIBsgsYPJmKkUPEBg4afxx4EA/5smYkUGZth9PXDoXVrP35h+KAiI4GU"
    "JKr9Rt1d13APKQyBIOnhgm3bDsjZunCBBIhAAlKQFC8honp15UikkHweBQkLFtavsx5AYmR7"
    "QxxGcuT4zqJFDiM4Mg5McGLIkPdDTjBsGBAAIfkECQoAAAAsAAAAABMAEwAACP8AAQgUmGCG"
    "lyAIvcxIMLChwCAvHAiYONHBiyAOARDw8uCAx48fH3ghMHAjhAUoU6pcAGGkwCcqJMicKaEB"
    "TQkqngBIgKaCzwoMBghAMJHBhJ9oCor58AEDhgB+/ACIGkCD0w9iZoAZ0yJECBFQpVLdIMKr"
    "FjBitPQoUaLDBAIEGsCdwIFECRhaxKRdAoMECQ+AKVAAbIIEjB9L9DLx8YOGCcAeLFiAbILG"
    "DyZipFDxAYOGn8ceBAP+bJmJFBmbYfT1w6F1az9+YfigIiOBlCSq/UbdXddwDykMgSDp4YJt"
    "2w7I2bpwgQSIQAJSkBQvIaJ6deVIpJAEEGFNnu928tgmsF6CBRIj2wHkCbB+PZ48LFi0yGEE"
    "h0MDV8LnsUNGB/0hJzDUUEAAIfkECQoAAAAsAAAAABMAEwAACP8AAQgUmGCGlyAIvcxIMLCh"
    "wCAvHAiYONHBiyAOARDw8uCAx48fH3ghMHAjhAUoU6pcAGGkwCcqJMicKaEBTQkqngBIgKaC"
    "zwoMBghAMJHBhJ9oCor58AEDhgB+/ACIGkCD0w9iZoAZ0yJECBFQpVLdIMKrFjBitPQoUaLD"
    "BAIEGsCdwIFECRhaxKRdAoMECQ+AKVAAbIIEjB9L9DLx8YOGCcAeLFiAbILGDyZipFDxAYOG"
    "n8ceBAP+bJmJFBmbYfT1w6F1az9+YfigIiOBlCSq/UbdXddwDykMj+QZPrxIh+Md2LpwgQSI"
    "QDsB8kQPYOeMiOvKkUghCQBPhADTL+ApuS6iBAskRrgDqGFnRIECI/JMYcGiRQ4jODJGWDOc"
    "TZMh9w1xAkMNBQQAIfkECQoAAAAsAAAAABMAEwAACP8AAQgUmGCGlyAIvcxIMLChwCAvHAiY"
    "ONHBiyAOARDw8uCAx48fH3ghMHAjhAUoU6pcAGGkwCcqJMicKaEBTQkqngBIgKaCzwoMBghA"
    "MJHBhJ9oCor58AEDhgB+/ACIGkCD0w9iZoAZ0yJECBFQpVLdIMKrFjBitPQoUaLDBAIEGsCd"
    "wIFECRhaxKRdAoMECQ+AKVAAbIIEjB9L9DLx8YOGCcAeLFiAbILGDyZipFDxAYOGn8ceBAP+"
    "bJmJFBlU8qhWjYKDaw5+/MLwQUVGgjwBcOveE9VPXcM9pDDUnTvACDsdkrN14QIJEIHEcSvI"
    "I6L6ciRSSAIocyWA9zxXzlQoF1GCBRIj2gEowHNFgYIreGKwYNEihxEcGRWUUa3GyRD7Q5zA"
    "UEMBAQAh+QQJCgAAACwAAAAAEwATAAAI/wABCBSYYIaXIAi9zEgwsKHAIC8cCJg40cGLIA4B"
    "EPDy4IDHjx8feCEwcCOEBShTqlwAYaTAJyokyJwpoQFNCSqeAEiApoLPCgwGCEAwkcGEn2gK"
    "ivnwAQOGAH78AIgaQIPTD2JmgBnTIkQIEVClUt0gwqsWMGK09ChRosMEAgQawJ3AgUQJGFrE"
    "pF0CgwQJD4ApUABsggSMH0v0MvGRp3EewBYsAPZggsYPJmKkUGkcIE9nD4IB+6l8WYoMz6g7"
    "p+DA2o9fGD6oyEiQGrWdqH7qGu4hhaHnAMBRdxjO1oULJEAE/g7eWYTz4kikkARQ5gpw4GXO"
    "OBdRggUSI9MBKB7Ac0VBhDJ4YrBg0SKHERwZFZRprMbJEPdDTjBsGBAAIfkEBQoAAAAsAAAA"
    "ABMAEwAACP8AAQgUmGCGlyAIvcxIMLChwCAvHAiYONHBiyAOARDw8uCAx48fH3ghMHAjhAUo"
    "U6pcAGGkwCcqJMicKaEBTQkqngBIgKaCzwoMBghAMJHBhJ9oCor58AEDhgB+/ACIGkCD0w9i"
    "ZoAZ0yJECBFQpVLdIMKrFjBitPQoUaLDBAIEGsCdwIFECRhaxKRdkqdvHg8eKFAAbIIEjB9L"
    "9DLpGyBPYw8WLAD2YILGDyZipDje/FgwYD+VL0uRwXlzCg6o/ZAw7IOKjASOA8h2bCeqn7qG"
    "e0hhGHt24w7A2bpwgQSIwN6yG4tYLhyJFJIAylxJHqDMmeUiSrBAYgQ6AAV4rigbiFAGTwwW"
    "LFrkMIIjo4IyfdU4GbJ+yAmGDQMCACH5BAUKAAAALAgADQABAAEAAAgEAPMEBAAh+QQJCgAA"
    "ACwAAAAAAQABAAAIBAABBAQAIfkECQoAAAAsAAAAABMAEwAACHEAAQgcSLCgwYMIEypcyLCh"
    "w4cQI0oEsCVMGjNvPDSEcqeKnAxzNDLME4Bknh0L8UQwWVIJB4V5CtQAoMAOkT19FOJRMHDN"
    "BS5mFNoxMNCAgixxYEYIMNBOEREKL+CpoSDCGjs8WCyMwCYPniwrhiwMCAAh+QQFCgAAACwA"
    "AAAAEwATAAAI/wABCBSYYIaXIAi9zEgwsKHAIC8cCJg40cGLIA4BEPDy4IDHjx8feCEwcCOE"
    "BShTqlwAYaTAJyokyJwpoQFNCSqeAEiApoLPCgwGCEAwkcGEn2gKivnwAQOGAH78AIgaQIPT"
    "D2JmgBnTIkQIEVClUt0gwqsWMGK09ChRosMEAgQawJ3AgUQJGFrEpF2Sp28eDx4oUABsggSM"
    "H0v0MukbIE9jDxYsAPZggsYPJmKkON78WDBgP5UvS5HBeXMKDqj9kDDsg4qMBI4DyN4c1U9d"
    "wz2kMIw9u3GH32xduEACRCBv2Y1FKA+ORApJAGWuIA9Q5oxyESVYIDHyHIACPFcURBoogycG"
    "CxYtchjBkVFBmb5qnAxRP+QEw4YBAQAh+QQJCgAAACwHAAoAAQABAAAIBAABBAQAIfkECQoA"
    "AAAsAAAAABMAEwAACF8AAQgcSLCgwYMIEypcyLChw4cQI0ocCGNgnoZf7JRRgAfARYVd9BTI"
    "E2FNgI8J3VhRsIblyYVwrgyMQGQNH4VyLgxkc6FMG4U3DBS0g0XhiDUEiXRUWECjRRsMhT4M"
    "CAAh+QQJCgAAACwAAAAAEwATAAAI/wABCBSYYIaXIAi9zEgwsKHAIC8cCJg40cGLIA4BEPDy"
    "4IDHjx8feCEwcCOEBShTqlwAYaTAJyokyJwpoQFNCSqeAEiApoLPCgwGCEAwkcGEn2gKivnw"
    "AQOGAH78AIgaQIPTD2JmgBnTIkQIEVClUt0gwqsWMGK09ChRosMEAgQawJ3AgUQJGFrEpF2S"
    "p28eDx4oUABsggSMH0v0MukbIE9jDxYsAPZggsYPJmKkON78WDBgP5UvS5HBeXMKDqj9kDDs"
    "g4qMBI4DyN4c1U9dwz2kMIw9u3GH32xduEACRCBv2Y1FKA+ORApJAGWuIA9Q5oxyESVYIDHy"
    "HIACPFcURBoogycGCxYtchjBkVFBmb5qnAxRP+QEw4YBAQAh+QQJCgAAACwAAAAAEwATAAAI"
    "/wABCBSYYIaXIAi9zEgwsKHAIC8cCJg40cGLIA4BEPDy4IDHjx8feCEwcCOEBShTqlwAYaTA"
    "JyokyJwpoQFNCSqeAEiApoLPCgwGCEAwkcGEn2gKivnwAQOGAH78AIgaQIPTD2JmgBnTIkQI"
    "EVClUt0gwqsWMGK09ChRosMEAgQawJ3AgUQJGFrEiNkSJo2ZNx4CU6AQ2AQJGD+W6IVyp4qc"
    "DHMCW7AQ2IMJGj+YiJGSJ08Az3l2eBgc2M/lzFLwRAD9WQmH1xz8kDjsg4qMPAVqBFBgh8ie"
    "PlH91D3cQ0oCPAoCKF9zgYuZDtDZunCBBAgAOwaUBzCgIEscEeClIzSRQjJPBO0B7BQBH54F"
    "EiMkAVzAU0NBhDV2eLDY3yKHERwORcBGHnhkscIQQ/g3xAkMNRQQACH5BAkKAAAALAAAAAAT"
    "ABMAAAj/AAEIFJhghpcgCL3MSDCwocAgLxwImDjRwYsgDgEQ8PLggMePHx94ITBwI4QFKFOq"
    "XABhpMAnKiTInCmhAU0JKp4ASICmgs8KDAYIQDCRwYSfaAqK+fABA4YAfvwAiBpAg9MPYmaA"
    "GdMiRAgRUKVS3SDCqxYwYrT0KFGiwwQCBBrAncCBRAkYWsSkXZKnbx4PHihQAGyCBIwfS/Qy"
    "6RsgT2MPFiwA9mCCxg8mYqQ43vxYMGA/lS9LkcF5cwoOqP2QMOyDiowEjgPI3hzVT13DPaQw"
    "jD27cYffbF24QAJEIG/ZjUUoD45ECkkAZa4gD1DmjHIRJVggMfIcgAI8VxREGiiDJwYLFi1y"
    "GMGRUUGZvmqcDFE/5ATDhgEBACH5BAUKAAAALAAAAAATABMAAAj/AAEIFJhghpcgCL3MSDCw"
    "ocAgLxwImDjRwYsgDgEQ8PLggMePHx94ITBwI4QFKFOqXABhpMAnKiTInCmhAU0JKp4ASICm"
    "gs8KDAYIQDCRwYSfaAqK+fABA4YAfvwAiBpAg9MPYmaAGdMiRAgRUKVS3SDCqxYwYrT0KFGi"
    "wwQCBBrAncCBRAkYWsSkXQIjj988HihQ8ODBBAkYP5boZfLFThkFeADksWCBcGEaP5iIkdJF"
    "T4E8EdYEyCOYsB8TmJlIkeHGioI1r0dzmO2HxGEfVGQkgHMlgO8IRNbwiVr3cA8pDOVc8B2A"
    "zYUybTp0YOvCBRIgAm8YYO7bDhYRIqgjMJFCEsAI0cyJ4AEfngUSI+UBFHCsIEKZPDZYsGiR"
    "wwiOjAbcl4caTgzR3xAnMNRQQAAh+QQJCgAAACwAAAAAAQABAAAIBAABBAQAIfkEBQoAAAAs"
    "AAAAABMAEwAACHoAAQgcSLCgwYMIEypcyLChw4cQI0oEsCVMGjNvPHhgCOVOFTkZ5mhcmCdP"
    "AAAB8uzYmBBPBJMwlXBQmKdADQAK7BDZ08dPSwUnAay5wMVMh4R2DAQ1oCBLHBEJ80QICsBO"
    "EagJL+CpoSDCGjs8WCyMwCYPniwrhiwMCAAh+QQJCgAAACwAAA4AAgAFAAAIBwABCBxIMCAA"
    "IfkECQoAAAAsAAAAABMAEwAACFgAAQgcSLCgwYMIEypcyLChw4cQI0oEoGVJnot5GjK5GCBP"
    "x4YdQ2ZUKMOjyY4pFCbwCCCAyIUjW5qEOdDlR4VlrtQsc2ahAjxXFEQogycGQwVlLqpxsjAg"
    "ACH5BAkKAAAALAAAAAATABMAAAj/AAEIFJhghpcgCL3MSDCwocAgLxwImDjRwYsgDgEQ8PLg"
    "gMePHx94ITBwI4QFKFOqXABhpMAnKiTInCmhAU0JKp4ASICmgs8KDAYIQDCRwYSfaAqK+fAB"
    "A4YAfvwAiBpAg9MPYmaAGdMiRAgRUKVS3SDCqxYwYrT0KFGiwwQCBBrAncCBRAkYWsSkXQKD"
    "BAkPgClQAGyCBIwfS/Qy8fGDhgnAHixYgGyCxg8mYqRQ8QGDhp/HHgQD/myZiRQZVPKoVo2C"
    "g2sOfvzC8EFFRoI8AXDr3hPVT13DPaQw1J07wAg7HZKzdeECCRCBxHEryCOi+nIkUkgCKHMl"
    "gPc8V85UKBdRggUSI9oBKMBzRYGCK3hisGDRIocRHBkVlFGtxskQ+0OcwFBDAQEAIfkEBQoA"
    "AAAsAAAAABMAEwAACP8AAQgUmGCGlyAIvcxIMLChwCAvHAiYONHBiyAOARDw8uCAx48fH3gh"
    "MHAjhAUoU6pcAGGkwCcqJMicKaEBTQkqngBIgKaCzwoMBghAMJHBhJ9oCor58AEDhgB+/ACI"
    "GkCD0w9iZoAZ0yJECBFQpVLdIMKrFjBitPQoUaLDBAIEGsCdwIFECRhaxKRdAoMECQ+AKVAA"
    "bIIEjB9L9DLx8YOGCcAeLFiAbILGDyZipFDxAYOGn8ceBAP+bJmJFBmbYfT1w6F1az9+Yfig"
    "IiOBlCSq/UbdXddwDykMgSDp4YJt2w7I2bpwgQSIQAJSkBQvIaJ6deVIpJB8HgUJCxbWr7Me"
    "QGJke0McRnLk+M6iRQ4jODIOTHBiyJD3Q04wbBgQACH5BAUKAAAALAAAAAABAAEAAAgEAAEE"
    "BAAh+QQFCgAAACwAAAAAAQABAAAIBAABBAQAIfkEBQoAAAAsAAAAAAEAAQAACAQAAQQEACH5"
    "BAUKAAAALAAAAAABAAEAAAgEAAEEBAAh+QQFCgAAACwAAAAAAQABAAAIBAABBAQAIfkEBQoA"
    "AAAsAAAAAAEAAQAACAQAAQQEACH5BAUKAAAALAAAAAABAAEAAAgEAAEEBAAh+QQFCgAAACwA"
    "AAAAAQABAAAIBAABBAQAIfkECQoAAAAsAAAAAAEAAQAACAQAAQQEADs="
)


"""Skype emoticon "Hug (hug)"."""
hug = PyEmbeddedImage(
    "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"
    "YA+Ix4weBgRLsmGejg0jBwQCADs="
)


"""Skype emoticon "In love (inlove)"."""
inlove = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//39//35v/v3v/vxf/vpf/mzv/mxf/mpf/mnP/m"
    "jP/mhP/etf/erf/enP/ejP/ehP/eY//eWu/Wvf/eIf/eGf/Wa//WY//WUv/WSv/WOv/WMf/W"
    "Kf/WGf/WIf/OUv/MZv/OQv/OOv/OKf/OIf/Fc//MM//Fa//FOv/FQv/FKf/FMf+9e/+9a/+9"
    "c//FIf+9Y/+9Qv+9Ov+9Kf+9Mf+9If+1Wv+1Y/+1Uv+1Sv+1Qv+1Ov+1Mf+1Kf+1If+tWv+t"
    "Uv+tOv+tMf+tKf+lQv+lOv+lKf+lMf+ZM/97e857e85za85zWs5rSs5rQs5rOsxmZsxmM85j"
    "Kc5jIc5aMc5aIdZSKcVSUv9CQs5KIc5KGcVCGcUxEP8AADMzM9YAAHMZGaUAAP///wAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgBlACwAAAAAEwAT"
    "AAAH/4BlgoIJMUc6iEcxYGBljIKPjA8ClJQPYluMYmWYTIxgYgeio2RioGRlpZmnCwsMrQtQ"
    "pWROZVqlp1ITEw4OuxNRZFdCZQlfs1QNAwUIBQUNGhlUGUuFSl5kVRsBYWEA3QEcGxsiSjFI"
    "SSxWJCUC3d9hAh0lJCRGSEpGNykpJhTODpxV+GAiRQsjSpQACdLChIkQEC9cgHjCRAscQRIC"
    "sYFDxgmIIDBgAAHixAkZOIAoIVLERgsZYT6CBBEiJsoiRGC0bNEwzAeIEGNatFEERQIiP3g6"
    "7MbU4VAiCcrk8HHDBT8PWLHyc9HCRw5BBYj4sJqihFmzW31AHVSgh48VKyHOol3Ro0eBQYNm"
    "9KBBA+4KFjR6zMBLWAEKHj0Q8zBKOBAAIfkECQoAZQAsAAAAABMAEwAAB/+AZYJbZQkxRzqJ"
    "RzFgYGWNgpE6Lw8ClpZiW0yNYJllBUcQB6OkB2SZjWJkn0cRC1sLsQyxUKedZE1lQioTvb4O"
    "Dr1Sp2RZhVsZGVsaDQMFCAUFDRpUZFRLhkoiIhsbAWFhAOABHBtVIkoxSEksJCQlAuDiYQId"
    "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"
    "BQIAOw=="
)


"""Skype emoticon "Kiss :*"."""
kiss = PyEmbeddedImage(
    "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"
    "Ow=="
)


"""Skype emoticon "Laugh :D"."""
laugh = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/33v/vxf/vpf/mzv/mxf/mpf/mnP/mhP/mjP/m"
    "e//etf/erf/enP/ehP/ee//eY//eSv/eOv/eKf/eIf/WY//Wa//eGf/WUv/WSv/WOv/WMf/W"
    "Kf/WIf/MZv/OUv/OQv/OOv/OKf/MM//OIf/Fc//FY//Fa//FOv/FQv/FMf+9e//FKf+9c//F"
    "If+9a/+9Y/+9Qv+9Ov+9Kf+9Mf+9If+1Y/+1Wv+1Uv+1Sv+1Qv+1Ov+1Mf+1Kf+1If+tWv+t"
    "Ov+tMf+tKf+lQv+lOv+lKf+lMf+ZMzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBMACwAAAAAEwAT"
    "AAAH+4BMgoIHMEc5iEcwB4ONgjkuDgKTkw4uOY5MBEYPBZ6fnw9GBIMDRhAJCqqrqwkQRgOC"
    "OikRtUtLDbm3ErUpO0wHSRkZGEsTE8bGyBjDSQgwSSIiGxscFNfYHNQiSTJDRSwjIx3kFeYV"
    "5B3iRUNJRTcmSx7zFvUWHx5LJi9ASUlANl7cGkjwVgkc/f7ZiLEEgMOHD5fEQJjEyI+ADSFC"
    "XPLCxg8jMIgEFKjR4ZISHYksSvKjRYt4Gk+ivJGEkZAhN17GI2jChMshOgQNODLEpQkSSEn0"
    "9OnjSCyhRGusWJF0ao0jTjPlUHLEx9QVTZVgykQIhhElaEEyahQIACH5BAUKAEwALAQABAAL"
    "AAgAAAcxgExMEhKCg4WCE0tLE0yKjIJLkUySlIaXmCaYlx4lJR8fF6IXIB+ei6ipJy+VmEsn"
    "gQAh+QQFCgBMACwEAAQACwAIAAAHLIBMTEtLgoOFgksTE4WKjIIbghRMk0wchpiZiJmJhJ6f"
    "ngCio6OEAJxMAEuBACH5BAUKAEwALAQABAALAAgAAAcxgExMEhKCg4WCE0tLE0yKjIJLkUyS"
    "lIaXmCaYlx4lJR8fF6IXIB+ei6ipJy+VmEsngQAh+QQFCgBMACwEAAQACwAIAAAHLIBMTEtL"
    "goOFgksTE4WKjIIbghRMk0wchpiZiJmJhJ6fngCio6OEAJxMAEuBACH5BAUKAEwALAQABAAL"
    "AAgAAAcxgExMEhKCg4WCE0tLE0yKjIJLkUySlIaXmCaYlx4lJR8fF6IXIB+ei6ipJy+VmEsn"
    "gQAh+QQFCgBMACwEAAQACwAIAAAHLIBMTEtLgoOFgksTE4WKjIIbghRMk0wchpiZiJmJhJ6f"
    "ngCio6OEAJxMAEuBACH5BAUKAEwALAQABAALAAgAAAcxgExMEhKCg4WCE0tLE0yKjIJLkUyS"
    "lIaXmCaYlx4lJR8fF6IXIB+ei6ipJy+VmEsngQAh+QQFCgBMACwEAAQACwAIAAAHLIBMTEtL"
    "goOFgksTE4WKjIIbghRMk0wchpiZiJmJhJ6fngCio6OEAJxMAEuBACH5BAUKAEwALAQABAAL"
    "AAgAAAcxgExMEhKCg4WCE0tLE0yKjIJLkUySlIaXmCaYlx4lJR8fF6IXIB+ei6ipJy+VmEsn"
    "gQAh+QQFCgBMACwAAAAAEwATAAAHiIBMgoOEhYaHiImKhwmNCUyOj4oRlAsLlBGDQoJKhAwC"
    "AgagDIRKB4UbAUtLAKsBHIuqrK6LTBMDAwu4E0wlhkGKJ0wvhzEnIMgaGsgghUOFxyAXF8jO"
    "hSVLH9ogH0u+1oIl2KurH4TPhx7q6rXthD2DJPLyJkw98Ic9NDSDLDT4inj0EMjjUCAAIfkE"
    "BQoATAAsBQALAAkAAQAABwiAJ0yDhEwngQAh+QQFCgBMACwAAAAAAQABAAAHA4BMgQAh+QQF"
    "CgBMACwAAAAAAQABAAAHA4BMgQAh+QQJCgBMACwAAAAAEwATAAAHIIBMgoOEhYaHiImKi4yN"
    "jo+QkZKTlIRLh5eVmpucnZqBADs="
)


"""Skype emoticon "My lips are sealed :x"."""
lipssealed = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP////zFJP64O/7KMv/ehTMzM//hgemnO+Pdz+q2aP+1ZP+wPf/pzf/T"
    "O/+0V/+0WP+xK9S9devr69e0Mf/SUf/OP+TEav3UIv+8cf6rPejEOd3Zzf3LJOrFHOu4Hv/8"
    "7v/wyP/po+3cqv/bZerKSte4ReLEV//WTf+lPeTVjN7c2Ofi0/+iMvHr0+2sIv/npv/z5tqr"
    "MP/KQP/xx/PPHP+1JevWmdzHePPz8+/HIfWxQv/05eqnRP/kjOO7Lf/65PHDI/j4+OzjyfLk"
    "v//EMu3EK//Xav7Dcf/OVeTTnf+xJ/+5LuLLleyxLP64RPK+Jf6+ZPn38f7BKf+iPeuyWOu9"
    "LvW9Kv/Rav+jL//ftf/ppP+/ev+eMv/god3GYv/88//99P/67P///v+pK//grf/76//Eaf+s"
    "Nv+9If+kMvz8/O26Of+yN/+kQP+6JvXTG/PmzP/ZaPXy4f+uMu3dr/G7O/62SezcpeTTlfbL"
    "K/v48fzcYPnVHuS3Pf+/Jf3BPerXova7NfLJIPfDNP7OLuCxL/y9bv7SLfSzO/+vJvfw2ei8"
    "dP/FKP++Lf+tKPy3RfHoxfLWWuHDJv/AbvXFLvGtQv/CLf/phf66KfPp2f/bH+O6QtrOqfLu"
    "5PSrNfCpPOfDdOTPf+6zNP/rqOW3MuzZn/rGLf/ILtzKgeDTre25Muvgtv+/MNu1Wf2/KvHD"
    "PtTOuOHYuvn27f+xQPvmyd3Mlf7DH/7+/ubbt+nWsvHZj/+2Qvr14Pr15v7GLOPFKf/KKdLA"
    "hfDSkO+5QfDUj+PZqOjXrea+J/CyH+u9IPzx4vz34eC4Mfi6Jfq/JOnQj/jEKdrUv/m3Juev"
    "Wve5YPyrMe+xRe+1TvrLKfvJLvrNK/msLPuzQd3HUNjEjPK7a//sp+3HJ+iyOvCnJ/HNk/Wt"
    "I+CuZ9zLjOXVp/fy4vrx5ea8O/exI/7fX/a1LM6vQMyySPK1XtCnO+7fqda1Js/ElPmmPPip"
    "MfyqNfTnzP/PKPixR/i1Qv7XIN/GfP///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRTIAMMUBQinYGAwsKFABVuyfJg4McsWBQ7/wWhDBgSIGSBDgiDTBsZA"
    "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"
)


"""Skype emoticon "Mail (e)"."""
mail = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Make-up (makeup)"."""
makeup = PyEmbeddedImage(
    "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"
    "mIklJZE3Li6RITY3o4iBADs="
)


"""Skype emoticon "mmmmm.. (mm)"."""
mmm = PyEmbeddedImage(
    "R0lGODlhEwATAPd/AP/aHv+pK//on//LJ//SUf/pzf/RLv+0Jf/EMv/GJf/ehv/wx//KMv+8"
    "cf/aZf/npv/oo/+4O/+0ZP/NNf/WIv+5Jf+xK//RMv/NIf/IJv/hgP/LOf/66v/VJv/KQf/d"
    "Y//UIP/QIv/VTv+iMv7GPv+6Lv/Xav/PKv/TJf/OVf+mPv/OMv/QN/+kQf/05f/IN//z5v/K"
    "If/CLf/CKf+/Jf/YIP/RH//PJf/QPf+4Rv/ML//ZSv/Sav/UMv/NOv/88/+9If/ZKf+jL//g"
    "rf/Ecv/bG/+/ZP/BQP+zN//hef+qPf+uMv+lMv/WK//kjP/87//65P+sNv+2Qv+7Qv/ftf+2"
    "SP/gof+/ev/COf+vPP/YJf+eMv+iPv+vJ//HLP/npP++Lf/ggv/KP//PP//EaP/AIv/BJf/E"
    "Iv/KKv/ILv/EKf/ZaP/DH/+7KP+/bv/DaP/Ab//fhP+xQP/vyf/igP+/MP+wWP+3WP/UOv//"
    "/v/TLP/gX//phf/YNzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFMgB/ACwA"
    "AAAAEwATAAAI/wD/CBRYoAEXCQi5NCgwsKFACVeoPJk4kcoVCQ7/wGgxZM6CjyA/DmkBY+BG"
    "Kw8efIEAQQBLCF8eWFFR8o+dNwoUxAmjoSednmHiKCBj50+BLTxMmFjjhAMHCE6dOFhjgseW"
    "gkJSECAg4ocfP3m+/hCxNYWQBioCePCAA4dXsGLx4BgjJoCKEV3AMNBh4AMUKHz+7tFjQMeM"
    "LiPwVkgw4AYKCjUAAKhBIcSNDEAOjGBioUKZGCFAUABQpAgAEDYwsMnMRImFNmYSYAgBWXIN"
    "1DHO0LCgxM2SNjMyDPDTQYvxDn5uDEhAYwmcAlFKyPDC96t1PSfQqCkRheEdJHUQME5YcaGH"
    "+R4XdKSRgeSOQBdZIiB4MYGFffsTGCCIkMXFQBdyRIDFCxv4YOAGL2ARgRz+OWSEFFMcQcKE"
    "R0whhREZDVQAEVXk4GEVRDDUUEAAIfkEBQoAfwAsBgAFAAcACQAACB4AHTj4QPCDgyQcOAhI"
    "mOSPw4cQI0qcSDEiCol+AgIAIfkEBQoAfwAsBQAGAAgACAAACCQA/4jYQbDgHz9//vRJiFBP"
    "kyAQgzRJSLGixYsV/aDAiLCinoAAIfkEBWQAfwAsBAAHAAoABwAACBgA//j5Q7CgQIMIEypc"
    "yFDgAIYDDTYhGBAAIfkEBQoAfwAsBAAHAAoABwAACBoA/+D4Q7DgHzwGEypcyLDhnwx+GupI"
    "GPFPQAAh+QQFCgB/ACwFAAYACAAIAAAIJwD/JOHAQQDBJH9+/PmTZ6HCD1Cg8Im4Z6HFixgz"
    "XhzgR6MBjH4CAgAh+QQFCgB/ACwGAAUABwAJAAAIHgCdcOAAYaCTH3785En444/DhxAjSpxI"
    "MaIfiXoCAgA7"
)


"""Skype emoticon "Mooning (mooning)"."""
mooning = PyEmbeddedImage(
    "R0lGODlhEwATAMQAAP/////Fvfe1te+ttdalte+cpeaUnNaUnP+EhOaElNaEjHOcxbWMnHOU"
    "tVqUtcVjcwCU1sVaa1JzlFprlAB7va1KKQBjjJkzAAAhWgAAmQAAewAAZgAAAP///wAAAAAA"
    "ACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAdACwAAAAAEwATAAAFpWDXHVFZHmKqiiQAJEEQ"
    "oasaJQCXDHFUp5FBYmgIDAq+X6c0aBaalmj0d0AYCoQoZAuROlYRhpZL7n5ZEcmWQimzu+iB"
    "BcKu29mWWVCOl/otFBYDTBEYURmIGRuJGVGDexiLiRqSGRoaGIMkAxgYl5cbG5+UGDMjJZGh"
    "oamqGDQpE56XnbKdSp2IGLG5Ez8VFxe0HbTANRXHv8HDwMkryMfFzMgiIQAh+QQFCgAdACwA"
    "AAAAAQABAAAFA2AXAgAh+QQJCgAdACwAAAAAEwATAAAFFmAnjmRpnmiqrmzrvnAsz3Rt33iu"
    "qyEAIfkECQoAHQAsAAAAABMAEwAABaBg1x1RWR5iqookACRBEKGrGiUAlwxxVKeRQWJoCAwK"
    "vl+nNGgWmpZo9HdAGAqEKGQLkTpWEYaWS+5+VZIthVJed1MkC2RNr68trKB0z4+iggMWTU1D"
    "gEIJFjNBERgmjo8YA0wDGBgalxobG5iZkYpNGJqioaIbniMlE5aXlauVJyuVGRkYqrMYShUX"
    "F60drbs1FcK6vL67xCvDwsDHwyIhACH5BAkKAB0ALAAAAQATABIAAAWbYNcdURk9h6iuIgkA"
    "SRBEKbtGCcAlgxzZqsggQTQEBpZk0lYaOAtJiBSidKwOCEOSwu12LdagckxetpoygC+gPv5G"
    "QqFAJjBE5ke7SDjgO4l+gClxERiGGIAJh4Y0fIUZkIsYkBkYfSROGBqbG52dmxqWPyQlmhqd"
    "GJ+MNCyGka6VQB0VFxeHE4e1NhW8tLYdGLW+LL28usK9IiEAIfkEBQoAHQAsAAACABMAEQAA"
    "BZhg1x1RGT2HqK4iCQBJEERsHSUAlwyB5fsOVmSQKBp8EIryFxSVBgOfYtpoLKYKCwshKckG"
    "EUvkW1KRhjKAbKwOgFXDoUAmMETmbrsTOoQSE31/NB1xJUWHN4gYe2AYjiYZJhGPByRQGBkZ"
    "jpmajo5vlgOYnKOdfC0lm52jiyUpKhUXF54TnrI1Fbmxsx0Ysrssurm3v7oiIQAh+QQFCgAd"
    "ACwAAAAAAQABAAAFA2AXAgAh+QQFCgAdACwAAAAAAQABAAAFA2AXAgAh+QQJCgAdACwAAAIA"
    "EwARAAAFFWAnjmRpnmiqrmzrvnAsz3Rt3/gdAgAh+QQJCgAdACwAAAEAEwASAAAFm2DXHVEZ"
    "PYeoriIJAEkQRCm7RgnAJYMc2arIIEE0BAaWZNJWGjgLSYgUonSsDghDksLtdi3WoHJMXraa"
    "MoAvoD7+RkKhQCYwROZHu0g44DuJfoApcREYhhiACYeGNHyFGZCLGJAZGH0kThgamxudnZsa"
    "lj8kJZoanRifjDQshpGulUAdFRcXhxOHtTYVvLS2HRi1viy9vLrCvSIhACH5BAkKAB0ALAAA"
    "AAATABMAAAWgYNcdUVkeYqqKJAAkQRChqxolAJcMcVSnkUFiaAgMCr5fpzRoFpqWaPR3QBgK"
    "hChkC5E6VhGGlkvuflWSLYVSXndTJAtkTa+vLaygdM+PooIDFk1NQ4BCCRYzQREYJo6PGANM"
    "AxgYGpcaGxuYmZGKTRiaoqGiG54jJROWl5WrlScrlRkZGKqzGEoVFxetHa27NRXCury+u8Qr"
    "w8LAx8MiIQA7"
)


"""Skype emoticon "Movie (~)"."""
movie = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP////7+/v39/fr6+vT09PLy8vDw8Ozs7Ovr6+rq6ufn5+Li4uDg4Nra"
    "2tfX19XV1dDQ0M3NzczMzMfHx8LCwsDAwL6+vr29vby8vLq6urm5ubCwsK+vr6ysrKenp6Cg"
    "oJSUlJCQkI2NjYmJiYeHh4WFhYGBgYCAgHt7e3R0dHJycnBwcG9vb25ubmtra2lpaWdnZ2Vl"
    "ZWRkZGNjY2BgYF9fX15eXltbW1dXV1NTU1JSUlBQUE9PT05OTklJSUdHR0ZGRkBAQD4+Pjw8"
    "PDg4ODc3NzU1NTQ0NDMzMzIyMjExMTAwMC4uLi0tLSsrKykpKScnJyIiIiEhISAgIBwcHBsb"
    "GxgYGBAQEA8PDw4ODgsLCwcHBwYGBgQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAAACwCAAAADgAT"
    "AAAHdIAAgoOCI4SHgzFIQoiEMQBISI+NipCMlJAAl4iVi40Aj0ian52bhxiRo58ASZFJr7Cw"
    "olBOJba3tyRJAFBKS7/AwaJGEsXFIMbFRgDExhpGGsnLzRImRtfIyszJN0Y30tvGMh4y4EYV"
    "yekUyzpH7u/wRzqBACH5BAkKAAAALAIAAAAOABMAAAcZgACCg4SFhoeIiYqLjI2Oj5CRkpOU"
    "lZaNgQAh+QQJCgAAACwDAAMADQAQAAAHY4AAgoOER0eEiIYAXoeFhl6LigCGR5CMko+RkoOH"
    "l4ichkmio6NIUFElqaqrSVBJSkuxsrJIRhkSuBIgubhEtrkaRhq8vrcSJkbJu72/uDdGN8TN"
    "EjIeMtIcvNoTRS+U3986gQAh+QQFCgAAACwDAAYADQANAAAHVoBHRoOEhUaCXgBei4qMXoON"
    "iYuSj4KGhkdPViWcnZ0iT09KS6SlpUpPRhKrqyCsq0SqrBpGGq+xrCaErrCyqzdGN7e+EjIe"
    "MsMWr8sSRTpH0NHSRz+BACH5BAUKAAAALAAAAAABAAEAAAcDgACBACH5BAUKAAAALAAAAAAB"
    "AAEAAAcDgACBACH5BAUKAAAALAAAAAABAAEAAAcDgACBACH5BAkKAAAALAMABgANAA0AAAcU"
    "gACCg4SFhoeIiYqLjI2Oj5CRkIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAs"
    "AAAAABMAEwAAB8aAXoKDhIWGg1csHAcABxwrV4eCPAgRLVQAUCoOBzuHKww7XIIAgl0zCiyF"
    "NQVMkl5GBzWICj6ES0GRgzEHui0SiBAAw56mDapeFy6DOxAfOwAVhCgXpFWFUxsAxYJJpV7D"
    "34JLwieD4aRShFNTV8OETd8XKcwAEDQADIQj1V4tEFsGhTBgb8kgLQ5aCMKSAMcrQTASZBlk"
    "YwGQVzsQ2CjEgkCOc4NwAEBWqAeCByeIABhSosEBHq+wtOiAAACCDi2wPNw5KBAAIfkEBQoA"
    "AAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAsAAAA"
    "AAEAAQAABwOAAIEAIfkECQoAAAAsAAAAABMAEwAABx2AAIKDhIWGh4iJiouMjY6PkJGSk5SV"
    "lpeYmZqKgQAh+QQFCgAAACwAAAAAAQABAAAHA4AAgQAh+QQFCgAAACwAAAAAEwATAAAHxIBe"
    "goOEhYaDVywcBwAHHCtXh4I8CBEtVABQKg4HO4crDDtcggCCXTMKLIU1BUySXkYHNYgKPoRL"
    "QVOEMQeRXi0ShB8AxCuDXQ2qXhcug1MADFfEhCgXpFWEU0tL0IRJpV7E4IJLBgCepNPhUrcG"
    "BuiDTeAXKYjmGycnhCPWvxBbgmiIU+dFi4MWgrAkwPFKEIwEWQbZWADk1Q4ENgqxIJBj0Dgc"
    "AJQV6oHgwQkiAIaUaHCAxyssLTogAICgQwssDXMOCgQAIfkEBQoAAAAsAAAAAAEAAQAABwOA"
    "AIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkE"
    "CQoAAAAsAAAAABMAEwAABx2AAIKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqKgQAh+QQFCgAA"
    "ACwAAAAAAQABAAAHA4AAgQAh+QQFCgAAACwAAAAAEwATAAAHs4BegoOEhYaDVywcBwAHHCtX"
    "h4I8CBEtVABQKg4HO4crDDtcggCCXTMKLIU1BUySXkYHNYgKPoVLQYQxB5FeLRK3BqWDXQ2q"
    "XhcuhCfCw4MoF6RVhAAfAM6CScPXzlNe19Tg31KG4oNNwxcp5dheI9G+EFuF5l5aDi2CWAk4"
    "r4IwCbIMsrEAyKsdCGwUYkEgxyBnOAAcK9QDwYMTRAAMKdHgAI9XWFp0QAAAQYcWWPypHBQI"
    "ACH5BAUKAAAALAAAAAABAAEAAAcDgACBACH5BAUKAAAALAAAAAABAAEAAAcDgACBACH5BAUK"
    "AAAALAAAAAABAAEAAAcDgACBACH5BAkKAAAALAAAAAATABMAAAcdgACCg4SFhoeIiYqLjI2O"
    "j5CRkpOUlZaXmJmaioEAIfkECQoAAAAsAAAAAAEAAQAABwOAAIEAOw=="
)


"""Skype emoticon "Muscle (muscle)"."""
muscle = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP/39/f37/fv7/fv5u/m3u/m5ube1ubezubWzt7Wzt7Wxf/Mmd7Oxd7O"
    "vdbOvf/FjPfFlPfFjO/FlNbFvfe9jO+9jPe1c/e1e++1e/e1a++1hOa1jO+1c+a1hN61hM61"
    "pc61nPetY/eta++ta++tc8W1nOate++tY96te9ate8WtlO+lY++lWu+lUt6la9ale72ljO+c"
    "SuacUuacSt6cWs6cc+aUSt6USrWce86UWtaUSs6UUq2UhK2Uc9aMSs6MUs6MSsWMSrWMWq2M"
    "c62Ma72ESq2EY7WESq2EUq2EWqWEY6WEWrV7Sq17SqV7WqV7SqV7Upx7WqVzSpxzUpxzSpRr"
    "SpRrQmZmZkJCQkI6Ov///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgBaACwAAAAAEwAT"
    "AAAH1YBaBjBUOAZaiImKiQNGSR5IS4eLlB9UCxIVSDyUlFQvEBwcLlAAnYpUEBgnJCIsSaeJ"
    "UBcjLD4+NlCxiFAPIzJMVMGeVFQwWlQWI1lZU0QIi1QV08bMWVhZBJ3SFSQ5VFlXV1jYqMVB"
    "3d7g48zFiNwVQSQkK9/WIxUQT1TI0/P0MYIUu8FixYgREaBY6ZCORIyAAokUmRGDxcGEKAA+"
    "hMivx8SKBuet2MgRUYMoRYLYADlyYxCBKhIxcHIkyA2SLwXyW4RACRMgOV8Wi3kKRLGjOxcF"
    "AgAh+QQJCgBaACwAAAAAEwATAAAHnYBagloqVIaDiImChRUVVDCKioyNjpGJVI0kmo+Wgpia"
    "K6BUnVqfJDFBMTGjnVlZJCtBVEGyiIacWllXrresnpSculdYWZGYFSQ5o65YxLaGQcjJo1Qk"
    "rlmsxxVBoMqloY2Hx5qwqNQroSSO45qqtKMfVDHpjsgrqqjvnqro5Pf4+gbN4ocOXz5fngYa"
    "pCUL4SJoDN9RUdGp161IgQAAIfkEBQoAWgAsAgAAABEAEwAAB82AWoKCB1RUH4OJiiVJFSlW"
    "DIqDBQ6GCxUQQlSSgkNUJg8YJBc1m5xUGxgjLCQcOVUKkgRZFiMjMz8sIVIDkllXWRc0TU02"
    "PqaGVDBav8BZVckqWlQV1cq/WFhZAwbJhtUkOYZZWdofVDXVFUEVJOGGIxrk3+rrJCviVCsc"
    "FCsrVOzauVsRI8ghKrYgrDA4wh2JGAUNTmMxgoM/WwQhRtxERQZFDP4yQgwicZqPGBQziNw4"
    "6NyMGC1YjCRpKBEMKkWA6JhZU5EAFd6ScQoEACH5BAkKAFoALAIAAAARABMAAAcdgFqCghOD"
    "hoeIiYqLjI2Oj5CRkpOUlZaXmJmaloEAIfkECQoAWgAsAAAAABMAEwAAB52AWoJaKlSGAYOJ"
    "ioRUFRVUMIuLhY6OVJKKjRUknJCYgo2cK6KXn6EkMUExMaWYWVkkK0FUQbOJhp5aWVevuK1a"
    "mo+Ru1dYWZKaJDmXr1jGt4ZBm8qXVCSvWaXBQaLLwKOW1Y6csanVK6Mkj8mcq7WXH1Qx6Y+b"
    "K6up76Cr6OT3+PoG0eKHDl++X8AGGqw1CyEjWgzfUVFhypchSYEAADs="
)


"""Skype emoticon "Music (music)"."""
music = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP////7+/vz8/Pv7+/r6+vn5+fj4+Pf39/b29vX19fT09PPz8/Ly8vHx"
    "8e/v7+7u7u3t7evr6+rq6unp6ejo6Obm5uXl5ePj49/f393d3dra2tnZ2dfX19XV1dTU1NPT"
    "09DQ0M3NzczMzMrKysnJycjIyMfHx8XFxcPDw8DAwL+/v76+vry8vLi4uLa2trS0tLOzs7Ky"
    "srCwsK+vr6urq6qqqqampqWlpaSkpKKiop2dnZqampmZmZaWlpWVlZKSkpCQkI6Ojo2NjYmJ"
    "iYWFhYODg4KCgoGBgYCAgH9/f35+fn19fXl5eXh4eHd3d3Nzc3JycmpqamlpaWhoaGZmZmVl"
    "ZWNjY2BgYF9fX15eXl1dXVlZWVhYWFZWVlVVVVJSUk1NTUpKSklJSUhISEZGRkVFRUNDQ0FB"
    "QUBAQD09PTs7Ozo6Ojk5OTU1NTMzMzExMRsbGw4ODgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAAACwMAAIABQAN"
    "AAAHIoAAggBUg4SGhYOJgouHioiQFjcxVjdul2mXl2M2aG5PFYEAIfkEBQoAAAAsCgACAAYA"
    "DwAAByeAAIKCboOEhgCFhoqDjIeLiI6JkZQ8YG5bblRunJxonZopl2A8AIEAIfkEBQoAAAAs"
    "CgACAAYADwAAByeAAIKCTIOEhgCFhoqDjIeLiI6JkZQsQ0w/TDtMnJxHnZodl0MsAIEAIfkE"
    "CQoAAAAsCgACAAYADwAABw+AAIKDhIWGh4iJiouMjIEAIfkECQoAAAAsAwACAAoADQAAB0iA"
    "AII8VlA3G4KJPFtujWhQioyNjYohGzZPaG6ViQBanIlUoIKigyGdVDFgbmQoqJNuJ6gwVFQp"
    "gipVW2CdABuTar0LVG5gIYEAIfkEBQoAAAAsAwABAA4AEgAAB1OAAIKCbmBJMRaDioRujYWH"
    "iYqOk42LlJOWFTBIYJiSippIbpaLhKSlo5+op6ymqzydW6mWVJSlAG5ok1S3bimdYDyKsG6y"
    "twC1nqW6jry3v4XCgQAh+QQFCgAAACwDAAEADgASAAAHU4AAgoJMQzQhD4OKhEyNhYeJio6T"
    "jYuUk5YOITRDmJKKmjRMlouEpKWjn6inrKarLJ0/qZY7lKUATEeTO7dMHZ1DLIqwTLK3ALWe"
    "pbqOvLe/hcKBACH5BAUKAAAALAMAAQAOABIAAAdTgACCgiwnHRYIg4qELI2Fh4mKjpONi5ST"
    "lgcVHSeYkoqaHSyWi4SkpaOfqKespqsZnSSpliGUpQAsKZMhtywSnScZirAssrcAtZ6luo68"
    "t7+FwoEAIfkECQoAAAAsAAABABEAEgAAB0eAAIKDhIWGh4iJiouMjY6Pg1QGj1QblDkKjlQs"
    "UwmNWgBlX41egmxBjKUAZD+MXABEXxCJG1BuZgxxHIpobr4wjEJuaDyMgQAh+QQJCgAAACwD"
    "AAUACgANAAAHSoAAggBuEIOHhB6Ig242i4JuMTqPbg9vM4tuABtsLYiaACZiE4egE2EJpQAD"
    "TlCCFjc3mkplDQAxbrluIlGphLpuIYcwaG5bKYiBACH5BAUKAAAALAUAAQALAA8AAAdPgACC"
    "gm6DhoNuCIeGbi2LiGePhFtAkm4JcCiPhShYmoeFAChxi6EAXTqgghBmn4gAB1lKgjxgbluF"
    "a02CVG6+vgAXA4Jov25Uhym2YDyLgQAh+QQFCgAAACwFAAEACwAPAAAHSoAAgoJMg4aDhYeG"
    "TCCKiEaOhD8ukYVSHI6FHD2Yh4kcV4qJAEArnoILRZ2Igj41gixDTD+FSzaCO0y6ugAQg0e7"
    "TDuHHbJDLIqBACH5BAkKAAAALAUAAQANAA8AAAdegACCgiyDhoeFh1SIFIqIKY6GLCUahouS"
    "AC8Rg5eDhREjmwCdhIIRMoKkAIkAJhijiIIFOFloYrEAI21ubmoAGScsJIUrH0JuYCkhLMzM"
    "AAiHKc0sIYeCEsEnGdaCgQA7"
)


"""Skype emoticon "Nerd 8-|"."""
nerdy = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP/////87//05f/05v/z5//z5v/wyP/wx//xx//vyf/pzf/ozv/ozf/n"
    "pf/oo//npP/no//oof/oov/npv/mp//gof/grP/grf/ftf/igP/hgP/hgf/fg//fhP/ggf/g"
    "gv/ehf/ehv/dh//dY//cY//Xav/Wa//bHv7bHv7bG//bG//aH//aHv/ZKP/YN//ZHf/YJf/Y"
    "IP7ZHv/XLP/Rav/Saf7ZIP/WLP/XJv/XH//WLf/WIP/VK//WIf/ULf/WJf/UJv/PVP/VH//U"
    "H//SK//TJf/TIf/RN//NVv/RJ//RIv/QN//QNv/QMf/RLP/SH//PN//NOv/QH//PKv/OMv/M"
    "Nv/PIv/PJf/NNP/MOv/ML//NIv/MKP/MLf/LOf/Ecf/KM//MIP/Ecv/KMf/INf/IOf/DaP/E"
    "aP/JN//KKv/KJv/KIP/JIv/ILv7HPf/IJf/HJP/FPv/Ab//HJ//HLP7FPv+/ev+/bv/EM//F"
    "MP+/ZP/EKf/FJ/+/Y//FJf+9cP/COf/BQP/CNP/AQP/EIv/DLf+7cv/DH//BKv/CKP/BLP+/"
    "MP/BJf+/Jv++Lf/AIv++JP+7Qv+7Lf+9If+3V/+5Rv+3WP+1Y/+4Pf+8IP+7J/+7Kf+4Rf+4"
    "Rv+0Zf+2Qv+4Of+5Jf+2SP+4L/+4JP+2Ov+zN/+wWP+wV/+0Jv+0JP+xP/+yN/+wQP+xKf+v"
    "PP+xLP+wLf+wJ/+uMv+vJv+tMv+sNv+tKP+qPP+qPf+pKv+mPf+oK/+kQP+lP/+kQv+kMv+l"
    "Mv+iPv+jLv+jMv+iL/+hMv+eMplmMzMzMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAAACwA"
    "AAAAEwATAAAI/wABCBS4wJAwTwiFGVowsKHAS3YwBJg4EYOdSw4BFPh1IcGBAwhCfjRg4VeB"
    "gQV6VaCArKWDCBJaIptQwRcBgafMiADBwcMGDRoyaNjwoUOIM6gAMDhGw0Syp8lIjBgBNVmJ"
    "GscY/CmGJBnFAFC/Jgsy7M8uXk8nek3mYq3aZLp2Gbu1yCvFZDPsqkVEyxgxWaT2VG2B4kTV"
    "NplUEQPmKhQjNlOA9JCRQoWNH0W2HJqUKhiuWJoYwdmipEeMFSxyDJGyhhAkWLnu1NqUaA6X"
    "JEBwwICB+YoaP41myVFga5QiOl2c+NAx4wYPIlPS7JFkSwEAS6wW5RlDpWqyJlraFEkyRUng"
    "gFelBJGpAmXJkSNMsIDBA+qVgIECWmECVMZLlihReIEGIJiscp9DenwSySB1uBFHIJF80kdG"
    "AykghiidVMKJKF9Y11BAACH5BAUKAAAALAAAAAABAAEAAAgEAAEEBAAh+QQFCgAAACwFAAIA"
    "CQACAAAIEgCRCQRAUCCyBhAcEATgwMGDgAAh+QQFCgAAACwFAAIACQACAAAIEQATHDgAoOBA"
    "A8gSFgSQEFlAACH5BAUKAAAALAUAAgAJAAIAAAgSAJEJBEBQILIGEBwQBODAwYOAACH5BAUK"
    "AAAALAUAAgAJAAIAAAgRABMcOACg4EADyBIWBJAQWUAAIfkEBQoAAAAsAAAAAAEAAQAACAQA"
    "AQQEACH5BAkKAAAALAAAAAABAAEAAAgEAAEEBAA7"
)


"""Skype emoticon "Ninja (ninja)"."""
ninja = PyEmbeddedImage(
    "R0lGODlhEwATALMAAN7e3szMzL29va2trZmZmYyMjHt7e3Nzc2ZmZlJSUkJCQjMzMyEhIRAQ"
    "EAAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAPACwDAAAADQASAAAEU/DJSSU6ikwQ"
    "JkpP4HRP4mgiaThLwTifc1CC4tyOQlYCXlUmxm+DyA1FOMXw4UgIDo6lQjmIDhGIR29HQQiZ"
    "gmFDA/4BDBNHeClRsx8rboVwo0QAACH5BAUKAA8ALAAAAAABAAEAAAQC8EUAIfkEBQoADwAs"
    "AAAAAAEAAQAABALwRQAh+QQFCgAPACwAAAAAAQABAAAEAvBFACH5BAkKAA8ALAMAAAANABIA"
    "AAQQ8MlJq7046827/2AojmQ5RQAh+QQJCgAPACwDAAIADQAQAAAERfDJyVyYeDYnJhBLQByK"
    "4yho+aSIYTqGMXRZtWQZ4hz4FGyInmTRQAkFlkJD+OAgmQ3BUwib4gaOj0NIKDysQh3zUTBh"
    "IgAh+QQJCgAPACwFAAEACgARAAAER/DJB6aVrdX7nAsc0TiGJSye15QPkwDjch5dpTh0ocDF"
    "c5APReIxkNx6gw3GIeA8Rk3OwEFwChwNEMcTtRC4l4CneEkgyJIIACH5BAkKAA8ALAUAAQAJ"
    "ABEAAARE8MkXwLzN2fuc5oTXEBfjOQx1GGcWCM5iKB5yCeYwAbQnTIURa/NgJB6sScBBSjgm"
    "B+YjOmHYHoOn5IrUXkLeCaJAjAAAIfkEBQoADwAsAgABAAwAEQAABEfwyfkAvdU1PINznER8"
    "jMAxn7NQQFGkjWNJgsMcy4dcloAOGIEiZXo0DAGEqqCcjGwEiQE0OUQnilXo0dyOto+p97Nd"
    "HAKTCAAh+QQJCgAPACwCAAEADAARAAAED/DJSau9OOvNu/9gKI5eBAAh+QQFCgAPACwFAAEA"
    "CQARAAAERPDJF8C8zdn7nOaE1xAX4zkMdRhnFgjOYigecgnmMAG0J0yFEWvzYCQerEnAQUo4"
    "JgfmIzph2B6Dp+SK1F5C3gmiQIwAACH5BAkKAA8ALAUAAQAJABEAAAQN8MlJq7046827/2AY"
    "AQAh+QQFCgAPACwFAAEACgARAAAER/DJB6aVrdX7nAsc0TiGJSye15QPkwDjch5dpTh0ocDF"
    "c5APReIxkNx6gw3GIeA8Rk3OwEFwChwNEMcTtRC4l4CneEkgyJIIACH5BAkKAA8ALAUAAQAK"
    "ABEAAAQN8MlJq7046827/2AYRgAh+QQFCgAPACwDAAIADQAQAAAERfDJyVyYeDYnJhBLQByK"
    "4yho+aSIYTqGMXRZtWQZ4hz4FGyInmTRQAkFlkJD+OAgmQ3BUwib4gaOj0NIKDysQh3zUTBh"
    "IgAh+QQJCgAPACwDAAIADQAQAAAED/DJSau9OOvNu/9gKI5iBAA7"
)


"""Skype emoticon "No (n)"."""
no = PyEmbeddedImage(
    "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"
    "MguamwCWCxA9RKEiAiYVDAKoIQA7"
)


"""Skype emoticon "Nodding (nod)"."""
nod = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///5v//7//37//35v/31v/vzv/vxf/vtf/vrf/vpf/vhP/m"
    "zv/mxf/mpf/mlP/mjP/mhP/etf/erf/enP/epf/ehP/ee//ec//eY//eKf/eIf/eGf/WY//W"
    "a//WUv/WSv/WOv/WKf/WMf/WIf/OUv/MZv/OQv/OOv/FjP/OKf/OIf/Fc//MM//FY//Fa//F"
    "Wv/FQv/FOv+9e//FMf/FKf+9a//FIf+9c/+9Y/+9Qv+9Kf+9Mf+9If+1Y/+1Wv+1Sv+1Qv+1"
    "Mf+1Ov+1Kf+1If+tWv+tOv+tQv+tMf+tKf+lQv+lOv+lKf+lMf+cOv+ZMzMzM////wAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBTACwAAAAAEwAT"
    "AAAH/4BTgoINOUw/iEw5DYONgj80EwOTkxM0P45TBUwUCJ6fnxRMBYObFg+oqaoPFqOCRzAX"
    "srMXErQXMEdTDVEfvh4RBAMLkxEavh9RhU8mJiAgAVJSANIBIc8mTzlNTjIoKCnR09UiKd9L"
    "TU9LPC4uJBoFBRLxGiMrLjZLT+pGNisrJQJy4BCQxQobPozsK8LDBw4WAUt06BCRBQ4fRZ4g"
    "UcLDxkOIJQYWtIgRyQ2ONvytGMGy5T8bPJTcaIBkSMoVUlqylPKSBxJGQIj0qNFOmtF2NWoQ"
    "ASKoABIiRF2kmDoVKREkpJomITJjBtWqM4gIydpIh5AdO2TMkCFjhxAdmQ0GNWgRJIjbIC0Y"
    "NQoEACH5BAUKAFMALAIAAAAPABAAAAeJgFOCg1GFg4eCTCoOgw4qTIdQOgcGlZYGBzpQU5IJ"
    "np4Kn56aTRUQp6ipp00vGK4YGbGxrxgxHrcaEgMDC7sSGhq3JiAgIYiCIcQmKMwiAVJSANAB"
    "IiLMNS4uJBoFBQwCBRokJC41Uy4rI4Ib7BuDK+8j6u5T7urH+Pnwh/fHUtrjSPzLB60gokAA"
    "IfkEBQoAUwAsAgAAAA8AEAAAB46AU4KDP4WDh4I0EwOMjBM0h0wUCJSVlRRMU0wWD52enw8W"
    "TDAXpaYXEqcXMB+tHhEEAwuMERqtHyYmICABUlIAvgEhuyYyKCgpiIIiKcc8Li4kGgUFEtQa"
    "IysuNkY2Kysl4Rwc4SwrNj5TPjgs4SUdHSWDOPMs7fJT5cr7/FNSiP/2ufBF0EW/FAgRIgoE"
    "ACH5BAUKAFMALAIAAAAPABAAAAeJgFOCg1GFg4eCTCoOgw4qTIdQOgcGlZYGBzpQU5IJnp4K"
    "n56aTRUQp6ipp00vGK4YGbGxrxgxHrcaEgMDC7sSGhq3JiAgIYiCIcQmKMwiAVJSANABIiLM"
    "NS4uJBoFBQwCBRokJC41Uy4rI+ob7BuDK+/qI+0b6sf3+FPp8vb3UtrjSEjJB60gokAAIfkE"
    "BQoAUwAsAgAAAA8AEAAAB46AU4KDP4WDh4I0EwOMjBM0h0wUCJSVlRRMU0wWD52enw8WTDAX"
    "paYXEqcXMB+tHhEEAwuMERqtHyYmICABUlIAvgEhuyYyKCgpiIIiKcc8Li4kGgUFEtQaIysu"
    "NkY2Kysl4Rwc4SwrNj5TPjgs4SUdHSWDOPMs7fJT5cr7/FNSiP/2ufBF0EW/FAgRIgoEACH5"
    "BAUKAFMALAIAAAAPABAAAAeJgFOCg1GFg4eCTCoOgw4qTIdQOgcGlZYGBzpQU5IJnp4Kn56a"
    "TRUQp6ipp00vGK4YGbGxrxgxHrcaEgMDC7sSGhq3JiAgIYiCIcQmKMwiAVJSANABIiLMNS4u"
    "JBoFBQwCBRokJC41Uy4rI+ob7BuDK+/qI+0b6sf3+FPp8vb3UtrjSEjJB60gokAAIfkEBQoA"
    "UwAsAgAAAA8AEAAAB46AU4KDP4WDh4I0EwOMjBM0h0wUCJSVlRRMU0wWD52enw8WTDAXpaYX"
    "EqcXMB+tHhEEAwuMERqtHyYmICABUlIAvgEhuyYyKCgpiIIiKcc8Li4kGgUFEtQaIysuNkY2"
    "Kysl4Rwc4SwrNj5TPjgs4SUdHSWDOPMs7fJT5cr7/FNSiP/2ufBF0EW/FAgRIgoEACH5BAUK"
    "AFMALAAAAAABAAEAAAcDgFOBACH5BAUKAFMALAAAAAABAAEAAAcDgFOBACH5BAUKAFMALAAA"
    "AAABAAEAAAcDgFOBACH5BAUKAFMALAAAAAABAAEAAAcDgFOBACH5BAUKAFMALAAAAAABAAEA"
    "AAcDgFOBACH5BAUKAFMALAAAAAABAAEAAAcDgFOBACH5BAUKAFMALAAAAAABAAEAAAcDgFOB"
    "ACH5BAUKAFMALAAAAAABAAEAAAcDgFOBACH5BAkKAFMALAAAAAATABMAAAcdgFOCg4SFhoeI"
    "iYqLjI2Oj5CRkpOUlZaXmJmaioEAOw=="
)


"""Skype emoticon "Party (party)"."""
party = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Phone (ph)"."""
phone = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP////f39+b35u/v79b33ubv/+bv9+bv797v/+bv3t7v5ubm5ubm787v"
    "3t7m98Xv1s7m/87m997mzu/e3r3vzs7m3rXvxebe3tbmvd7e3s7mtc7e96Xvxb3m1rXm1sXe"
    "9+bWzr3e99bW1pzmxbXW/5Tmvb3elObOva3W/4zmvZzezqXW/7XehJzexZTezszMzJTexa3e"
    "c4zezozexYTexaXea6XO/4zW3ozW1nvetYTW3sXFxea9tYzWzpnM/5TO75nM/5TO93PetYTW"
    "1mvmhIzO/4TWznPepZTO5oTWxYzO72vetXvW1mverVLvSozO5mPerWvelHvWvTr3MTr3KTr3"
    "IVrmazr3Gb29vUrmhErme2vWvYzWOhn3Ogj/GYTWOinvQhD3MSHvShD3KXvWKSHvQhD3IbW1"
    "tQj3Gd6llK2trWvOEN6chGbMAKWlpd6Uc5mZmZmZmd6Ea4yMjISEhHt7e9ZjOnNzc9ZSKWZm"
    "ZmZmZs5CEMwzAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAAACwDAAAACwAT"
    "AAAHbYAAgoOCeYSHAIYAC3V5jo95dYxnAYcBbo0BPpucPgGOmp2bn3mhoqSaRaqqno4DPqus"
    "A66im7N5A7m6uq58fLMDbW23u8WOCy87Z2pqZzsLxwvS09LHycvNz44Z1NMZkXAZ4uMZcHUZ"
    "jZCO54EAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEA"
    "IfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoAAAAsAAAAAAEAAQAABwOAAIEAIfkEBQoA"
    "AAAsAAAAAAEAAQAABwOAAIEAIfkECQoAAAAsAwAAAAsAEwAABxaAAIKDhIWGh4iJiouMjY6P"
    "kJGSk5OBACH5BAkKAAAALAIAAAANABMAAAfBgACCg4R5hC9ziWpnZy8igwN5ajtnbnBzdXd3"
    "CwAidQU2NigkJBAGc24AZ3QoPq6vKG6pZ3Ctr64oc2cAsq1Fv0U+KHS7c2quwMEfdS8Ac1g2"
    "t64fd490IgwfHygoKzYH1QB5C3Z2A2oDLBqRAeIDPDznAzVcC4YLmyIvOzuOGS+GRGzKkEFE"
    "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"
)


"""Skype emoticon "Pizza (pizza)"."""
pizza = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Poolparty (poolparty)"."""
poolparty = PyEmbeddedImage(
    "R0lGODlhEwATAMQAAP/37//35v/v7//v5vfm1vfmzv/e3v/ezvfevffWtf/MzN7WxffOrffO"
    "nPfOpe/FlP+1tf+tpf+ZmfechP+ZZsWlc/+MjP97e2aZzP9za/9mZqV7UoxaIcwzAP///wAA"
    "ACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAeACwDAAAADQATAAAFZ6AnesvGbcuoetXjVuv4"
    "YPMTi4z7MLcHJI8EIHbQGREig0UzMeoGno5Gk3lQrA/EozEUaCQNncMzeBA8Co0i50p4CGPP"
    "5UuX0CMizdLOp4v6gBoQKy4ehTeFhzGJNog2ioSPjZFGKiEAIfkECQoAHgAsAwAAAA0AEwAA"
    "BSegJ45kaZ5oqq5s675wLHuFhyD06XhAw58+wC5wwhVqOBPA41j6YCEAIfkECQoAHgAsAwAB"
    "AA0AEgAABWugJ3rLxm3LqHrV41br+GDzE4uM+zC3BySPBCB20BkRIoNFMzHqBp6ORpN5UKwP"
    "xKMxFGgkDZ3DM3gQPAqNIudKeAhjz+VLl9AjIs3SzqeL+oAaECoFWVoFNw4PAGFDMTkDkDdl"
    "DJQ3TjYjIQA7"
)


"""Skype emoticon "Puking (puke)"."""
puke = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Punch (punch)"."""
punch = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//8v/38v/35v/z1f/vw/7qs+7o5/Dp2/Lqyv/sjP/mzv/mov/fvv/j"
    "lP3epf/cs+fe1v/dhf/eZf3WlP/eHuXVs+bTwv7TaezSpf/Mmf7TU//SQ9TQ0P/TIdjOwf/M"
    "M+XFnP/BadrErf29kP+8e93DlP+8c+HBjP/AJM6/tf68Rde8nP+zX9i5d/61Jci2oNC1lN21"
    "XLu2seC2Mf+nPs6xbdKrjP+oLsWtlO+tIcOvjMKxacGrg86lfreonb6ljLqllP+ZM+SZecWc"
    "ddiVX7Wcg72YdcyZM5mZmcSSXMWTS8+UIayUe6qVZ/97Ur2LTMSLOr2PIb6IMZqMeK6HYq2A"
    "Uv9nTK9+R7GAMZCCUoSBf4x+a45/XaByT6txOqVxMP9SOoRzZpVvQXtyWI9uUJlmM4tiRWZm"
    "Zm5kVo5cI2teRF9dVYVQL4hOGYBOIWtPM1ZOO1JOSntIEXNBIm08DEQ/OpEpDPsKB0Y7KGYz"
    "AMUXCDMzMzUwJCklHRwZGQ0MCP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgCAACwA"
    "AAAAEwATAAAI/wABCRSowAQNFghpmFAwsKFAFiQeAJg48QEJFg4BCaDxgIDHjx8d0BAwcKOD"
    "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"
    "gwgTKlzIsKHDhxAjSpxIsaLFixgzalQYEAA7"
)


"""Skype emoticon "Raining (rain)"."""
rain = PyEmbeddedImage(
    "R0lGODlhEwATALMAAP///+/v7+bm5t7e3tbW1szMzMXFxZnM/729vbW1ta2traWlpZycpZmZ"
    "mWaZzP///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgAPACwAAAAAEwATAAAEcfDJ+dpqjWq9"
    "hk9GgmyUIgQBERaEQibWmRpNSiQacjaATaAqHCXhIxhVBpqBMbEcjcloVLGoSK9YA+LCwHi/"
    "YIzr4ZiUJWfy5qBml90PuCZNN1Pe7TzejuarNXCBeht1fYZ9gnh7h4V/FGwSkHETkg8RACH5"
    "BAkKAA8ALAAAAAATABMAAARy8Mn52mqNar2GT0aCbJQiBAERFoRCJtaZGk1KJBpyNoBNoCoc"
    "JeEjGFUGmoExsRyNyWhUsahIr1gD4sLAeL9gjOvheBzIZvS5fJ6UJW80fLNOs9VySnzv1tv/"
    "dW1zg3lxE4F4d4aEfISJgHiHkhKCgg8RACH5BAkKAA8ALAAAAAATABMAAARy8Mn52mqNar2G"
    "R0aCbJQiBAERFoRCJhaaGk1KJBpyNoBNoCocJeEjGFUGmoExsRyNyWhUsahIr1gD4sLAeL9g"
    "jGviIJslZfPhUV632Y/1GY6eT9xxOB6vSdP/fnqCb29zfocbe4N5gXWOgBRrknmTkw8RACH5"
    "BAkKAA8ALAAAAAATABMAAARx8Mn52mqNar2GR0aCbJQiBAERFoRCJhaaGk1KJBpyNoBNoCoc"
    "JeEjGFUGmoExsRyNyWhUsahIr1gD4sLAeL9gjOtxeDjIZvS5fNa005L3O81W28sTeX6vqfvp"
    "cBR6cXyEf2uAhYOBE4d3jBJ4aJGNEhEAOw=="
)


"""Skype emoticon "Rock (rock)"."""
rock = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP///4mJiTMzM7i4uP/jiv/ksf+9HP7RJf/ozv/mpP+iPv+7cv+0Pf/Z"
    "iePj4//QOP/psv+tKv+ZM/+7If/THf/13a6mmv+uNf+8LIiIiP/TOv/Fcf++cP/iYf/GIf/z"
    "5v+2Qf/NIf/dOf/MKv7GJf/KM//ba//Mhf/dpP/FKv/UFv/JKP/BJv/GMf+7Vf+yOv/UNP+y"
    "U//JLv/DOf/Siv/YMv/NL/+pPv/ANP/RI//GHf/LIv+oNP/GLf/CQ//BbbKysv/Uav+cMv+1"
    "ZP+/KP+2Jf/HbP+5Pf/jev+kQ//AHv+fMv/LHf+2Of/zwf+4MP/FYf+7Xv/uppiYmP+1Iv+2"
    "Hv+0Rf+1Nf///P//9v7OJf7IM//qxv/LG/+rJv/PH//BIOmnYf+qMf/qyf+/O//PGf+5Jv/h"
    "mv+9Z//mav+kM//JTf+eOf/NZP+xRP/BLv/EGf+2Kv/QKf/gkP+jLP/oqP/Ref/FNuqzWv+/"
    "Jf/Kcv/haf/MO/++XP7+/pGRkfr6+q+vr//Wlf+8Iv/CK//ihf39/f+5H9PT0/+pSv/aWv/d"
    "dv+wI//OMv/elv/gqf/DI//Hb//Zhv/PerWxnv+wWP/og//GZ/+wJv+dL//jU//SGP/al/+h"
    "Ov/RQ//dQv+1LP/WKf+xXf/JOv/OPf/ThP/Hev/GP/+cOf+fO//UH/+/MJmYlrWvmv/TVv/S"
    "Y//lkv+uTv+5R//Qgv/bf//qr/+eNP/dev/MR//NN//NWP+xPv/Nbv/twP/obv+sRv+2Sv/v"
    "yP+yQZWVlf/gbf/YJ//WIP/mnv+ZNENDQ//EaP/aH/+vM//JNf/TWP/fUP/CWP/sq/+/Y/7h"
    "Qf+2Xv/ViP+xLf/SLf/Naf/fn//XJv+4V/+cMP+fP//rm/+pTf+4QP7fM/nZYv/aY//cYv+7"
    "U//Yev+/Vv/EUP/GVP/Xfv/TcP/fZP/Ymv/BSvnYS/+4Ov/KJv/bLv+pKv/LV/+7Lf/ot//X"
    "TP+xKf+nPf/Ja//nl/+8RP/akf+8Q////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRSIYIECIQgVLEAwcGAAgUMUBNjQDsWjExySDGkYAECATpU6BshWwF4B"
    "FII4KPggUGSsPiITQAhmL1u/WWg6sRQZoKfHM3Vq1RHQwI6+WJX+dQQCaAAAj4Vg7RNAgNa6"
    "NueWIOjodIDXAAKQhF1k4hU9d3Q4WABi6CkARKzY7ZnLTpGrNavm5QvzJ5ADPw6mTBGgSYDh"
    "e57uTMC0RA0eCxkit3o3rfKnTxpsgJlARY0afGbyeNhxIFS40/JCfWECZlARNTesmWFBIkQO"
    "Y8aWLTOm6ssOSHms3eDADAOhFSMEhNJWrJg2AQfikSDC7AeCC0/eyLBxzbD3a3JWpGCodwEB"
    "gG0vVrUo0QiGe/eNbMh482IbgH8fdsGb0SzXgwcaaPBALiXcAc8uLAn0gTDgzDAKH3yQQgof"
    "o8wAjjAJDgQAGiD448MpIPrADwjS3NfQQAhsAIwsLAKzAUMNBQQAIfkEBQoA/wAsAAAAABMA"
    "EwAACP8A/wkcKFCCQYIICaL6R83UiRMcRHVLKJCNgoE0BLUTRMOUqFQJbbkZyOlRgUecZkWq"
    "RJFgNnvB7GWrpqdPkpYCz0DoBUGAJF7Q3EjAOedYAgFzzLVB1yTTgpYCCkW9FUSXjzh0Liak"
    "RI6Y13GucK2q4kWCEIRTkgl4JqCtJxkGqjASsiQClQlK4DA5UEOEiBoHmMAxcAjTknwRigwC"
    "o6NLmU0qVGwq00WHkgkR/v0QYyYPJA8hvlAYTeELEw9gJoj5x4UHKCKQSAjQcuBAjhwCdpDI"
    "E4cHFywumGEglGJE2+MjVqQgwswFln8VXlxZ1UOGjevXZfR4c+VFhYEVGDQqwdFiS4nzJVrg"
    "aMLgO8EsUBgcITPjzgwyRxhAydJyzD8rIARoRST+ERQQACH5BAUKAP8ALAMAAQAOAA8AAAiO"
    "AP/9Q/bv17YoUWIkQiVQoJCGlyLpiaQsyjeB3Hg0nFSqWqlJRvokYtNQoCRHZxw1sHOpnIKS"
    "/+YkqJVgjjps52D+gxXNSTQBtIKkA1dyGAFvUgQQWPRqzROYAixFRWLC2SkqDVuJ65DGVxp2"
    "ikiV1CGgrKayAnboXMu2bUktMOHqFDBCjl05AtiiLQszIAAh+QQFCgD/ACwAAAAAAQABAAAI"
    "BAD/BQQAIfkEBQoA/wAsAwABAA4ADwAACI0A//1D9Y+aqRMnOIjqJlCggoY0BLUTRMOUKIG2"
    "3DTk9KjAI06zIlXq1FBgNnvB7GWrpqdPkpL/zkDoBUGAJF7QYP6bcyyBgDnm2qBrUpKVgEJH"
    "bwXR5SMOTHLEoo5zhWtVlYZTkgl4JqCrJxkl4TA5UEOEiBoHmOhcy7ZtSQEw4eoc0bXuCLY2"
    "8uaFGRAAOw=="
)


"""Skype emoticon "Rolling on the floor laughing (rofl)"."""
rofl = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////7//31v/3zv/v1v/vzv/vxf/vvf/vtf/mvf/mxf/mtf/mpf/m"
    "nP/mhP/etf/evf/erf/epf/enP/ejP/ehP/ec//ee//ea//eY//eWv/Wrf/Wpf/WnP/eSv/e"
    "Ov/eQv/WlP/WhP/eMf/Wc//eIf/eKf/WY//Wa//WUv/WQv/WSv/WOv/Oe//WMf/WKf/Oc//O"
    "Wv/OUv/MZv/OQv/OSv/OOv/Fe//OKf/MM//OIf/Fc//FY//Fa//FWv/FOv/FQv+9e//FMf/F"
    "Kf+9a//FIf+9c/+9Y/+9Wv+9Sv+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1Wv+1Sv+1Uv+1Qv+1Ov+1"
    "Mf+1Kf+1If+tUv+tSv+tQv+tOv+tMf+tKf+lOv+lMf+ZMzMzM////wAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBQBiACwAAAAAEwAT"
    "AAAH3oBigoMJO15fX0QJg4yDD1tbVVVWXVyIEY2CPFRLTExNoD9AMkhPjT1TS0KrQ0NCOTQy"
    "KCKmghJTP7k5YbxhsCkoFSEdglFKQDY2YQDMYS4qYcEMRGIKSUA0NMvMAM4sKWEVDB0JLdfa"
    "3M0uLCthDgwGRFHY6OneYRnvBk/z2dvcYUZ88JAPHj96/5oJxKfvSYtj9QCu8+AOHhFrCO2t"
    "a/eOnJgpQH4k+3cPgzhqYm7p2tXLBQ1gwogJQvWDVSscv2bVGrTJ0xBQQ2CR2snoUSQrSLtc"
    "ysSoEKJEixoFAgAh+QQFBQBiACwJAAUAAgAJAAAHD4BhOGEvhGEmYSWJh4YvgQAh+QQFBQBi"
    "ACwAAAAAEwATAAAH64BigoNiRFBYWDcRhIyCX2IzFxQMBxFPHY1iUF9VNTEnFpMHAhtQjEhc"
    "VmI0NSkZYWENCAIFpoIdqU1CYTYqrhaxsxyDXFVNQzhiLiy+GmEOsgJPYhPGQ0OCYS4uKh4a"
    "FtAIiztVQshh2S9i3ehismJbTEI5mYLeYRUNWGJC84wA6LilCBNq35IfjQAAXObrBAkt9cQo"
    "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"
    "nKipqquYgQA7"
)


"""Skype emoticon "Sad :("."""
sad = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/ve//mzv/mpf/mnP/etf/erf/enP/ehP/e"
    "e//eY//eWv/eIf/Wa//eGf/WUv/WSv/WOv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv/FMf+9e//FKf+9c//FIf+9a/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1"
    "Wv+1Sv+1Uv+1Qv+1Ov+1Mf+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMz"
    "M////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBEACwAAAAAEwAT"
    "AAAH/4BEgoIGJz0wiD0nBoONgjAlCQKTkwklMI5EAz0KBJ5CBKCeCj0Dg5sLB6pCBwgHrKoL"
    "pYI5IQy3Qre6ubchOUQGQRHDQg7Gxw5CwxFBhT8aGhMTDQMDCNUNFNIaPyc+QCIbGxUBQ0MA"
    "5gEVHOI8Pj88LR8fFwLm6EMCFh0fJjw/P3DcMNGhw4NqBao9ANHBxIsbAHG4eIECBIaLEiRc"
    "xAACxQscP3TscGGiokUMECBcBNHxxQ4dKUaaIGiuprmCJlzsWKTDxswhHSwIHQrURAsdjGLU"
    "aEFi3oWnT+eRIFEjhqABOmo0/cCha1epNXSYukqjxogRXr+OoEFjbCMVNBhWrBAxQoSIFTRU"
    "ZBpkwIMMGn9leGDUKBAAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsBQACAAkA"
    "DAAAByqABIKDgweGQkRChgcMDIhEiY0Rj5CJDpWYmZqbnJ2ekB0dFpUWox2bHYEAIfkEBQoA"
    "RAAsBwAMAAUAAQAABwWAQ4KCgQAh+QQFCgBEACwFAAIACQALAAAHI4BEgkJEhIKDB0QHhoUM"
    "hwyEQg6Hgg6MlJiZmpucnYdDmKCBACH5BAUKAEQALAUADQAJAAEAAAcIgENEg4REQ4EAIfkE"
    "BQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAs"
    "AAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEA"
    "AQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkECQoARAAsAAAAABMAEwAABx2A"
    "RIKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Shaking (shake)"."""
shake = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Skype (skype)"."""
skype = PyEmbeddedImage(
    "R0lGODlhEwATANUAAP////f//+///+/3/+b3/973/9b3/9bv/87v/8Xv/73v/73m/7Xm/7Xm"
    "963m96Xm96Xe95ze95Te94ze94Te94TW93vW93PW92vW92vO92PO91rO91LO91LF90rF90LF"
    "9zrF9zq99zG99zG97ym97ym99yG97yG17xm17xC17wi17wCt7////wAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBF"
    "Mi4wAwEAAAAh+QQFCgAsACwAAAAAEwATAAAG8UAW67MqmgrCpDKJIlUcFdBK85kklsIPicFw"
    "RCIaT8djUlmWq0o3Irl0NJZNSGtSrroPSUYSAPgJFiImJ0krEnkWFX4JEQV+FyUpZywmHRET"
    "GQ8ABicgJwoAFiYoKkIEUxUaDgACFSEkKCmyRQ9CGhsWGRt9fwseRUUaWRsXHiciDo5+ABfA"
    "H7YgKMBFKBYGAAfAwiwOwBLM3gAI00gs4QMRuAIAC9N1LBayKQvLfgejKbErSSQiJCYfKEB4"
    "0MFECREjEO7jJ8KDw4diHkpZEm+EQxAeNGTIgEFDimdYEkj4oGEFyQsbUKDAgoWACWdCggAA"
    "IfkEBQoALAAsAAAAAAEAAQAABgNAVhAAIfkEBQoALAAsAAAAAAEAAQAABgNAVhAAIfkEBQoA"
    "LAAsAAAAAA4ABwAABilAFkuj2XxGwmRyU3EsJEqlpoJIsB6sTXToSCy2yo0VrPxAyMoRB50M"
    "AgAh+QQFCgAsACwAAAAACwANAAAGS0AW65MyiTzCJGokYT0sGuhwpGAlFonIpLJJNa8Kx2TM"
    "MlkX4UWSJWpgG441yzNRNCIJOUvzaEwYehYSERZ6exUUhiwXHYqOayqKQQAh+QQFCgAsACwA"
    "AAAAEAAQAAAGfkCWcEU0CY/IY8VRAa0ynuSRwXBEIhmN5ZKdDCvViMSiqYgnk0t0VX1ILhDk"
    "wJEBkVaSa0UiPCSUQiYdYhYLLAQWaQgsFUdPEhUKQgtkIkkZFxKacpJIHhaQFhSLUkcZWRkb"
    "H0alLBsaGIaNra6pDbRHExodJLhHHR+WvsNCQQAh+QQFCgAsACwAAAEAEgAQAAAGjkCWcEgs"
    "GouejsekshyJHY1lA+p8nqyMhEiQbDYd4oNlqQgTkWEkc5kUM2PDyXNlOSyW8LCicbAGEx0c"
    "UWwbdSwbFhkbRQYTi0tDGxceJx8NRQ8fJkMaISgrKSYiHxoNBCwFJ0UroWNeGhgLTyqiQwsP"
    "fk8WpB4HWEYaFxYSDLOMWBwVEhMWGsBDExuLWEEAIfkEBQoALAAsAgADABEAEAAABolAlnBI"
    "/JBMxGTSIjKdlFDWpZSyRFmgk4JlMZWQ0EqIhEqlUCTRlUVYeFIm0cdKVCcrow9HQ1z5Vyh0"
    "LB8bGoIrElJ+KRBChRgdLH+JAxEZE0IHGhkbHiMsZikLSQQWF5CfLGlHHYkKExYVFhkeRGmF"
    "XBUSErB8SyQbsRMSERKCUYYdF8trRKlEQQAh+QQFCgAsACwGAAYADQANAAAGXkCWcDhEqYhI"
    "Vmq1Sg6ZTI2TdYF+pgdoBrmSCJkpE3FjES5WYZEneTCZRB9Oh/WhQB4dU8izyVwyHoGCG1IW"
    "FBUaKSOBIB0WFRMREBdSQh8ZJhkTDxEXc0keHRqjQkEAIfkECQoALAAsAAAAABMAEwAABj1A"
    "lnBILBqPyKRyyWw6n9CodEp9rlbQ68rkRKW8WGZJNCKHlZ6OZx1KMTWZDEZj6ixXH81lQxo1"
    "TVcpdixBADs="
)


"""Skype emoticon "Sleepy |-)"."""
sleepy = PyEmbeddedImage(
    "R0lGODlhEwATANUAAP//7//35v/vxf/mzv/mpf/mnP/etf/erf/enP/ehP/eY//eIf/eGf/W"
    "a//WUv/WSv/WOv/WMf/WKf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//OIf/MM//Fa//FOv/FQv/F"
    "Mf+9e//FKf/FIf+9a/+9c/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Wv+1Y/+1Uv+1Sv+1Qv+1Mf+1"
    "Ov+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZMzMzM////wAAACH/C05FVFNDQVBF"
    "Mi4wAwEAAAAh+QQFCgA+ACwAAAAAEwATAAAG80CfUDgg4VhIHGkwbApZIANgOjWAWE5fAHcQ"
    "eL/fAy4w3CIIaHQhjUaMhTROYk6v0zk034DX6DcUgIGAfjxFOhUVDg4PjI2MihU6JDk7HhYW"
    "EJmamheXNzk6NygbGxEREqipEhgbITc6OjMyIRgYE7cLC7caGCEqMrAzKSoiGj23DMfHGiI9"
    "Mzo1NikhxcY9PboT1z0qNjUj0iG0GKkTqLUhKTYjAzUw4rUSp6noKDVMKzEoH6Sm/qQfPsRY"
    "ISRAjRj8Nly4sA1gjBpkCr6I0aHDwosbOrx4EbFJiRcmTFTs4MHEixJZhgzI4OJFSxcZmDQJ"
    "AgAh+QQFCgA+ACwAAAEABwAFAAAGEUBfb9jzGY3Do7B4TCqJxV4QACH5BAUKAD4ALAAAAAAB"
    "AAEAAAYDQF8QACH5BAUKAD4ALAAAAAABAAEAAAYDQF8QACH5BAUKAD4ALAAAAAABAAEAAAYD"
    "QF8QACH5BAUKAD4ALAgABQABAAEAAAYDwF4QACH5BAUKAD4ALAAAAAABAAEAAAYDQF8QACH5"
    "BAUKAD4ALAAAAAABAAEAAAYDQF8QACH5BAUKAD4ALAAAAAABAAEAAAYDQF8QACH5BAUKAD4A"
    "LAoABQABAAEAAAYDwF4QACH5BAUKAD4ALAAAAAABAAEAAAYDQF8QACH5BAUKAD4ALAAAAAAB"
    "AAEAAAYDQF8QACH5BAkKAD4ALAAAAAATABMAAAYaQJ9wSCwaj8ikcslsOp/QqHRKrVqv2KxW"
    "GQQAIfkEBQoAPgAsAAAAABMAEwAABvNAn1A4IOFYSBxpMGwKWSADYDo1gFhOXwB3EHi/3wMu"
    "MNwiCGh0IY1GjIU0TmJOr9M5NN+A1+g3FICBgH48RToVFQ4OD4yNjIoVOiQ5Ox4WFhCZmpoX"
    "lzc5OjcoGxsRERKoqRIYGyE3OjozMiEYGBO3Cwu3GhghKjKwMykqIho9twzHxxoiPTM6NTYp"
    "IcXGPT26E9c9KjY1I9IhtBipE6i1ISk2IwM1MOK1Eqep6Cg1TCsxKB+kpv6kHz7EWCEkQI0Y"
    "/DZcuLANYIwaZAq+iNGhw8KLGzq8eBGxSYkXJkxU7ODBxIsSWYYMyODiRUsXGZg0CQIAIfkE"
    "CQoAPgAsAAAAABMAEwAABhpAn3BILBqPyKRyyWw6n9CodEqtWq/YrFYZBAA7"
)


"""Skype emoticon "Smile :)"."""
smile = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/vpf/mzv/mpf/mnP/mjP/mhP/etf/erf/e"
    "nP/ehP/eY//eIf/eGf/Wa//WUv/WSv/WOv/WMf/WKf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv/FMf+9e//FKf+9a/+9c//FIf+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1"
    "Wv+1Uv+1Sv+1Qv+1Mf+1Ov+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZMzMzM///"
    "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBDACwAAAAAEwAT"
    "AAAH/4BDgoIGKD0wiD0oBoONgjAlCwKTkwslMI5DAz0MBJ6fnww9A4ObDQeoqAipqA2jgjkh"
    "DrO0Cgq0syE5QwZBEr8SCZMFkwkPwEGFPxoaExMBQkIA0QEUzho/KD5AIhsbFdDS1BUc3jw+"
    "PzwtHx8WDwMDCvAPFx0fJjw/Pzg3Jh0dGAJCgBAQRAcTL27ow+HiRQoQATFEiBARRIoXOH7o"
    "2OHCRAohEDEMDAjy4g4dJzia8CfkgksMF4T8M+FixwkDOmqs/BetZ72DLXQwimGjBQl2FpIm"
    "ZUeChI0YggbosHH0A4erV5na0EEqKg0bI0ZgzTqCBo2ujVTQWLFCxAgRIhFW0FCRaZABDzNo"
    "5J3hgVGjQAAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwFAAsACQADAAAHEIAg"
    "Q4OEQ4IdhUMXhIuDjYEAIfkEBQoAQwAsBwANAAUAAQAABwWAQoKCgQAh+QQFCgBDACwGAAwA"
    "BwABAAAHB4BCQ4ODQoEAIfkEBQoAQwAsBQALAAkAAQAABwiAQkODhENCgQAh+QQFCgBDACwA"
    "AAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQAB"
    "AAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwAAAAAAQABAAAHA4BD"
    "gQAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQJCgBDACwAAAAAEwATAAAHHYBDgoOEhYaH"
    "iImKi4yNjo+QkZKTlJWWl5iZmoqBADs="
)


"""Skype emoticon "Smirking (smirk)"."""
smirk = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//35v/vxf/vpf/mzv/mpf/mhP/mjP/etf/erf/e"
    "pf/ehP/eY//eWv/eIf/eGf/Wa//WUv/WSv/WOv/WMf/WKf/WIf/OUv/MZv/OQv/OOv/OKf/F"
    "c//MM//OIf/Fa//FOv/FQv/FMf/FKf+9e//FIf+9c/+9a/+9Y/+9Qv+9Mf+9Kf+9If+1Wv+1"
    "Y/+1Sv+1Qv+1Ov+1Mf+1If+1Kf+tWv+tQv+tOv+tMf+tKf+lQv+lOv+lKf+lMf+ZMzMzM///"
    "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBDACwAAAAAEwAT"
    "AAAH/4BDgoIHKT0xiD0pB4ONgjEnCwKTkwsnMY5DBD0MBZ6fnww9BIObDQioqaoIDaOCOCIO"
    "srMOCbQOIjhDB0ETvhMPwcLBv0GFQBoaFAEAAAEVzM4UFBpAKT4/JBwcQkIAAhbdzh3bPD5A"
    "PC0gIA8EBBAYEO4PHiAmPEDoNiYeHhn/ESL8C+HBxAsb+W64eIEixL8MEiQ8DIHixQ0gOna4"
    "MNHQYYaAAyla1KFCowkTQjxgWMmynwkXOxbpqHHSQ7ebQjC4bKGDEQwaLUqsA3Gh6IV1JUrQ"
    "gCGIgA4aQkF0mDoVKQ0dpJrmoDFiBNWqI2jMyNpoxQwWLLqOIMFixopMgwwOfJAho62MD4wa"
    "BQIAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkE"
    "BQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAs"
    "AAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEA"
    "AQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOA"
    "Q4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkE"
    "BQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAs"
    "AAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsBQAHAAkABwAABxSAAUNCQ0MCg4WJiouMjY6PiIyE"
    "gQAh+QQFCgBDACwFAAUACQAEAAAHIoBDCgMCBgICCkMUQ0JCAI1DFR0BjY9CARYXDwQECZwP"
    "GIEAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkE"
    "BQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAsAAAAAAEAAQAABwOAQ4EAIfkEBQoAQwAs"
    "AAAAAAEAAQAABwOAQ4EAIfkECQoAQwAsAAAAABMAEwAABz2AQ4KDhIWGh4iJiouMjYoPkJEP"
    "iwFDAAEVAQBDlYkBQkMCFgJDQp2IDwRDEBgQQwSTjrKztLW2t7i5uomBADs="
)


"""Skype emoticon "Smoking (smoking)"."""
smoke = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP///5lmMzMzM/7de/+0ZP+5Jf/ehv/aZfTUov/oo//87//pzf/65vX1"
    "9fHx8f3PK//VTv+xK/Hj0dPS0P/z5tbLrf/NIf/hgP/LJ//KQf/aHv+iMv/wx//ZSv/JM+zG"
    "aN7e3v/UJePKjP/01szMzPW6Lt3UttzNtP+mPv+xP/+4Rv/SUf/Xav7EPOPRiv/xx/+kQf/6"
    "4//OVdbW1vv48f+4L/TFev/SIv7mpf/CKf/VH/+2SP/npv/05f/YS//gof+9cP+eMv/WIP/E"
    "cv/Sav/YJf/ozv/bG/+/ev/QPv+pK/+jL//frP+7cv/ftf+iPv+4POLLqvPIif+qPf+kMv+0"
    "Jf/RJ/+8IOfn5/n5+fTbn9DQz//JIf/OJf+tMv+sNuXFk//QLurLnv/KP729vURERO3Pav/R"
    "H/LOdP/BLP+/bv/dY//AIv/ZaP+9Lf/toerRe//fZ+XUtf/ulP+tKP/YIP/EaP+wWP/QU//e"
    "af/igP/ggv/MMP/IJffNLP/heP/BJerOfv/PP//vyf/HLO7esP+7KPfAPP/DaP/wyP+vJpF9"
    "Lv+wJ/+3WP/oof/npP/FJ/O3Pf/HJ/TTa//rqfHmxuzWnv/FMv+/JezXjP+zN+rDR/hZAOAp"
    "AO2uPf+vPP/VKpeCL+qWMP/DH+zWo+m0X9fTxfvlyuhvS+F/R/uvNv/Ab/7LLTExMezs7O+9"
    "Lv55Ifbt1/nu4dzRr/39/cTExPnITf+/Y/+7QuvTlPrmpsnJyP/EIu69devEk+DKh/Xty93W"
    "yv/FJf/MLf+/MP2eLfcOAP/mqdzXx/9jBP+2QvdFGf/BQP/DZfVoL/8+AN7On/HlyPnv0f/k"
    "p/jlofDjxvHWYuC/kP3YLvfOefjHfe6/b9HNwcnEr7+2lurYhvDXdfDYdffYePjRdPradP3W"
    "LuXRkPDIk/zYMurFjP/pqP/EKf7+/qurq+bVvubYsPXVWPvjpfXAXdbUz//KKurXhP6oOv/R"
    "LPjjn+vRrOvZkerYn+PSqOTYp+rg0////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRRopMkTAgifNDEysKFAAkicKJg40QkSAg7/UYDBZBAHDi9CfkzEBAaF"
    "gRt/8ODxKEECRy4TPOLxA8XJf3cQGTAQoOeFC3p+7tlp584/I0GIsGDR5sCBAGt6BjjQhgWR"
    "IEaALJGBZwUECD46iO3gA8KKFTKWAEGhJEOGJAMYAGDwRi6DP0kEjVGCYgMdNx74ABBAeHDh"
    "MHxyKNqwgVEBSBjyxAAQY87kGHG69LlSZQOVCAXYcOlyQ4iGI0c06DhjYRRnKlMiGALUx0Lp"
    "Oho0CFnNhRemCFPUeDGUQxIGKyGKKA8RogsGYZi8rFrwpUYaQqwe+FnUKhSoew/orWJz82XB"
    "v0aqSpR4tQkOmQZkSJBANimNpkYA/skSlYpULAAAArBFAw2AMAEUn/QgkAOcdAIgDYUEsssM"
    "BM4wQQoKLggLKmKU4kkkh6ARjHzBSJGRAw40cMoQO6jg4g5DmNdQQAAh+QQFCgD/ACwJAA0A"
    "BwAFAAAIKADLdJtAYsK7MVl2NaDlagYyAFgASHRFghsJV1lcTQhm6x3BCe7+BQQAIfkEBQoA"
    "/wAsAQANAA8ABgAACFAA/wn8N+zeQG+zKszK1eKfJmKXPEAY2A7YiEqz+PUo5mzaiIH/TI0Y"
    "Ga0CgGfGBCoQWKFCNGnVTkQBkGwZk2a4Blo6UeFEPoEAgi4ASfRfQAAh+QQFCgD/ACwJAAsA"
    "CQAHAAAIRAD//UOnb1aFWbmgCOxnAtiISrOitApVweGIEdUqNKg1w9Q/adVOyPk3A8QMgyfE"
    "UIBGYoulFlBSCGzRghkuZbcE/gsIACH5BAUKAP8ALAEACwARAAgAAAhZAP8JHEgQWzgXv0Sg"
    "0USw4b9v5qip0yIiHUFWDwi60EWJ0jEt1/6pKlHi1aaGJrTo0gJGjCxRqUjFcvjPnAgwUv45"
    "4NRJIA2aBB3AQiWmlCegQR00OIV0YEAAIfkEBQoA/wAsCQAKAAoACAAACEwA/wksB87FLxE2"
    "pggUUu8fPhxawPgSGMKFQHXHEEQRCCqTOS3x/oHxJ5DEvH3mRPw7R0tgAxATLkH51OPfLhAv"
    "JwjciWaeSRs7BQYEACH5BAUKAP8ALAwACgAHAAUAAAgoAEHBM/Phgzx71syQGzBuWy8zAyIO"
    "0OZrkhlxA7L1kvAvE8FeNtgFBAA7"
)


"""Skype emoticon "Speechless :|"."""
speechless = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/vpf/mzv/mpf/mnP/mjP/mhP/etf/erf/e"
    "nP/ehP/eY//eIf/eGf/Wa//WUv/WSv/WOv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv/FMf+9e//FKf+9c//FIf+9a/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1"
    "Wv+1Uv+1Sv+1Qv+1Mf+1Ov+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZMzMzM///"
    "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBDACwAAAAAEwAT"
    "AAAH/4BDgoIGJz0wiD0nBoONgjAlCwKTkwslMI5DAz0MBJ6fnww9A4ObDQeoqAipqA2jgjkh"
    "DrO0Cgq0syE5QwZBEr8SCZMFkwkPwEGFPxoaExMBQkIA0QEUzho/Jz5AIhsbFdDS1BUc3jw+"
    "PzwtHx8XDwMDCvAPFh0fJjw/Pzg3Jh0dGAJCgBAQRAcTL27ow+HiBQoQATFEiBARBIoXOH7o"
    "2OHCxEOIGAYWtPhih44UHE3462ChJYaW/0y42LFIRw2VHaLpjBazhQ5GMWy0IMHuglGj7EiQ"
    "sBFD0AAdNoh+4ECValIbOkg5pWFjxIiqVkfQoKG1kQoaK1aIGCFCxAoaKg4yDTLgYQYNuzM8"
    "MGoUCAAh+QQFCgBDACwAAAAAAQABAAAHA4BDgQAh+QQFCgBDACwGAA0ABwABAAAHCIAdFhZD"
    "gxaBACH5BAUKAEMALAgADQADAAEAAAcEgEKCgQAh+QQFCgBDACwHAA0ABQABAAAHBYBCgoKB"
    "ACH5BAUKAEMALAYADQAHAAEAAAcGgEKCg0KBACH5BAUKAEMALAAAAAABAAEAAAcDgEOBACH5"
    "BAUKAEMALAAAAAABAAEAAAcDgEOBACH5BAUKAEMALAAAAAABAAEAAAcDgEOBACH5BAUKAEMA"
    "LAAAAAABAAEAAAcDgEOBACH5BAUKAEMALAAAAAABAAEAAAcDgEOBACH5BAUKAEMALAAAAAAB"
    "AAEAAAcDgEOBACH5BAkKAEMALAAAAAATABMAAAcdgEOCg4SFhoeIiYqLjI2Oj5CRkpOUlZaX"
    "mJmaioEAOw=="
)


"""Skype emoticon "Star (*)"."""
star = PyEmbeddedImage(
    "R0lGODlhEwATAMQAAP/33v/vxf/mrf/3AP/vAP/elP/ejP/mAP/We//eAP/MZv/WAP/MAP/F"
    "AP+9Qv+9Mf+9AP+1If+1AP+tGf+tEP+tAP+lAP+lCP+ZAP///wAAAAAAAAAAAAAAAAAAAAAA"
    "ACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAZACwAAAEAEwASAAAFeWAmjqNDnqiIYEHqZpQV"
    "vWiBNSxNUhJTUTqRAcNg4AyoCGbJhBQZEiZzFrE8r1iGZSICXKzZa+UCGAEwlXAxWiYJML0s"
    "BCNIIcBYi8J1D1tMKQ54YjMpEz0QFhgWThJAKTyKDgAKi1EuSw9tGQAOS5sjAREtKJ11IiEA"
    "IfkEBQoAGQAsAwAEAAgADQAABRNgJo5kWVpmCaXmsrRv6bJ0bYshACH5BAUKABkALAMABAAL"
    "AAsAAAUZYCaOZGmeqGmVS+uyi9jCckzOGT66b+qPIQAh+QQFCgAZACwEAAUADAALAAAFEmAm"
    "jmRJWqWFpqvpvnAsz3RdhgAh+QQFCgAZACwDAAQADQANAAAFE2AmjmRpnmgqMmrrjgTxznRt"
    "oyEAIfkEBQoAGQAsAwADAA0ADQAABR5gJo7YaJ5oqq6mNS5wy6oEMcwisdY3vsLAhW8oCgEA"
    "IfkEBQoAGQAsAwADAA0ADQAABR1gJo7WaJ5oqq4mNjJwy6pHPYvHWuf3Cv+MnlAUAgAh+QQF"
    "CgAZACwDAAQADQANAAAFE2AmjmRpnmgqQmrrjsfxznRtoyEAIfkEBQoAGQAsBAAFAAwACwAA"
    "BRJgJo5kSWIlhqar6b5wLM90XYYAIfkECQoAGQAsAAABABMAEgAABSNgJo5kaZ5oqq5s674m"
    "1jJ0PTMifec4q2e/Vc0GKxqPyCQqBAA7"
)


"""Skype emoticon "Sun (sun)"."""
sun = PyEmbeddedImage(
    "R0lGODlhEwATANUAAP//5v//zP/mlP/mjP/mhP/vIf/ma//mUv/ehP/eY//eIf/WY//WIebW"
    "Uv/OUubOUv/FIf+1Sv+1Qt69If+tGf+lUv+lOv+lGf+lEP+cSv+ZM/+UKf+ZAP+MSv+MKf+E"
    "GTMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBF"
    "Mi4wAwEAAAAh+QQFCgAhACwAAAAAEwATAAAGrMCQcCjsfDrE5LCDNH6OIaZS+PxcrtfqNPTh"
    "cARgsPeT7Gy6CMRgIBgQ0pwnMrrBLBJ4gx6fWMTnXBwODyAgDQcNhQ8OcUscEAwgCgUglAUK"
    "IAwQHEgVEo8MkwWjpAqafxIaoKKko6abcqqQla2jmbBNoBO0pCATp4CyDLuFhb8MjUUaFJAM"
    "oQqmzrBkURpdEM3O0n+AQsuP2NhjWxoaHV7oWlNSTlBSW0tQU0EAIfkECQoAIQAsAAAAABMA"
    "EwAABhrAkHBILBqPyKRyyWw6n9CodEqtWq/YrFYZBAAh+QQFCgAhACwAAAAAEwATAAAGsMCQ"
    "cOjpDDueoVKJ9BSdxaUQ2bxYrc6OlunkcARgsBeqzHg4CMRgIBgQ0hwnUYNZJO6G/D2x4BhD"
    "UBwODyAgDQcNhQ8OcUZIHBAMIAoFIJUFCiAMEI0AEZAMlAWjpAqbcR4BFaCipKOmnEYeFqCW"
    "rqOanEmPkRO2pCATp1EdtL2FyMIMqH8VFJEMoQqm0bF/IRZnENDR1ahKTs6Q29teTVIA2V7r"
    "clJHUE1R7u9E10NBACH5BAkKACEALAAAAAATABMAAAYawJBwSCwaj8ikcslsOp/QqHRKrVqv"
    "2KxWGQQAOw=="
)


"""Skype emoticon "Surprised :O"."""
surprised = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/31v/33v/3zv/vxf/vpf/vrf/mzv/mpf/mnP/m"
    "jP/mhP/etf/erf/enP/ehP/eY//eIf/Wa//eGf/WUv/WSv/WOv/WMf/WKf/WIf/MZv/OUv/O"
    "Qv/OOv/OKf/Fc//MM//OIf/Fa//FQv/FOv+9e//FMf/FKf/FIf+9c/+9a/+9Y/+9Qv+9Ov+9"
    "Mf+9Kf+9If+1Y/+1Wv+1Uv+1Sv+1Qv+1Mf+1Ov+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+l"
    "Mf+lKf+ZM5lmMzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBIACwAAAAAEwAT"
    "AAAH/4BIgoIKLEE0iEEsCoONgjRGkQKTkUY0jkgDQUYHnZ6eRkEDg5oRCwsEAQECqgSnEaKC"
    "PSUSEgcAuLkAB7UlPUgKRRXDAQBHR8bIAcMVRYVDHh4XxcfJAAEXFx5DLEJEJh8fCLq5CCDh"
    "QEJDQDEjIxoIkwSTCBshIypAQ0M8OyohITgIpEBBIIkQKmbs2MdDxowVJARysGBBIokVM3gM"
    "8fFDhgqIEY8dMXhxxg8fLTqq+BcCGa4j9hDK+LHIR46VAF0ai6kihg9GNXTESOFO5xF3KVLo"
    "qCFogA8dREeAEAkCqQ4fo5ri0HHiBIivX0ecwIEjayMXOF68MHHChIkXOA9cYBqkQMQNHHdv"
    "iGDUKBAAIfkEBQoASAAsBAABAAsADwAAByuASCgPAoWFDyhIEEaMSI6MRouOk5RGlJeYmZqb"
    "nJ2en6CgGkekGpkgqJSBACH5BAUKAEgALAQAAgALAA0AAAdLgEgHg4SESAuIiAyJiBKOjg4O"
    "jxIVFQ0CAgiYDRNIFxdIoaJIGKEZSEdHqKqnoRMDAw6wnaO1tre1HBQUtxu+HBu2G6lHwbYa"
    "yKOBACH5BAUKAEgALAAAAAABAAEAAAcDgEiBACH5BAUKAEgALAAAAAABAAEAAAcDgEiBACH5"
    "BAUKAEgALAQABAALAAsAAAc0gEhGgwECAYNGggQAjI0ABImMSJOUAJMGlJmYSBkJhgUCAgkZ"
    "maWmp6ioR6unR41HrayUgQAh+QQFCgBIACwEAAIACwALAAAHOYBIRoNIhYNGgkgEAQECjASJ"
    "BwCTlAAHSBUBSEdHm50BFYWio6IIlZQIhRqkhRusr7CsnJ2ylLRIgQAh+QQFCgBIACwEAAEA"
    "CwAPAAAHKIBIRoNIhYNGggeKi4tGC4WQkY+RlJWWl5iZmpucnZxHAKFHlkelkYEAIfkEBQoA"
    "SAAsAAAAAAEAAQAABwOASIEAIfkEBQoASAAsAAAAAAEAAQAABwOASIEAIfkEBQoASAAsAAAA"
    "AAEAAQAABwOASIEAIfkEBQoASAAsAAAAAAEAAQAABwOASIEAIfkECQoASAAsAAAAABMAEwAA"
    "Bx2ASIKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Swearing (swear)"."""
swear = PyEmbeddedImage(
    "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"
)


"""Skype emoticon "Sweating (sweat)"."""
sweat = PyEmbeddedImage(
    "R0lGODlhEwATAPcAAP//////9///7//35v/vxf/ve//mzv/mpf/mnP/etf/erf/enP/ehN7e"
    "1v/ee87e///eY87e9//eWv/eIc7W7//Wa//eGf/WUt7Wvf/WSs7W3t7Wpd7WnP/WOv/WMf/W"
    "Kf/WIf/MZv/OUt7Opf/OQv/OOu/OUs7Ovf/OKe/OWv/Fc//OIf/MM8XOxd7Oc+/OQv/Fa//F"
    "Ov/FQu/FWv/FMf+9e//FKf+9c/+9a//FIcXFxd7Fe/+9Y+/FQt7FY8XFtd7FUsXFpd7FWv+9"
    "Qs7FjP+9OsXFlN69jMXFjKXF5v+9Mf+9Kc7Fc/+9Ie+9Qv+1Ws69nP+1Y969Y/+1Sv+1UsW9"
    "nN69Ut69WsW9pf+1Qs69c/+1OsW9jMW9lP+1Mf+1KaW93sW9hM69a/+1Ie+1QqW91sW9e6W9"
    "zv+tWqW9xc61nN61Y6W9vcW1pf+tUv+tOt61Uv+tMc61c8W1e/+tKc61a96te++tQu+tSqW1"
    "vc6tlKW1xaW1rd6tWv+lQqW1taW1pf+lOs6tc/+lMf+lKcWte6Wtxd6lY6Wtvc6lhKWtpcWl"
    "hP+ZM6WlrWul/3uMrYSEhIxzY5lmMzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgCUACwA"
    "AAAAEwATAAAI/wApCRRo4IafKAj93DAwsKHAKDUSCJg4MUGNKA4fDPCjgIBHSQRAelTgZ8DA"
    "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"
    "y5cwY8osGBAAOw=="
)


"""Skype emoticon "Talking (talk)"."""
talk = PyEmbeddedImage(
    "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"
    "mI2flaqrkoEAOw=="
)


"""Skype emoticon "Thinking (think)"."""
think = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/vvf/vpf/vnP/mzv/mpf/mnP/etf/erf/e"
    "nP/ehP/eIf/Wa//eGf/WUv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//OIf/MM//Fa//F"
    "Qv/FOv/FMf+9e//FKf+9c//FIf+9a/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1Wv+1Uv+1Sv+1"
    "Qv+1Ov+1Mf+1If+1Kf+tWv+tUv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMzM////wAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBCACwAAAAAEwAT"
    "AAAH/4BCgoIIJDstiDskCIONgi0iCwKTkwsiLY5CAzsMBARAoJ+gDDsDg5sNCQlAqgqqqkAN"
    "pYI2Hg63BAFBQbm7tx42Qgg/EMUFAAC7yLsFxT+FPRcXEgHI1tYBEhc9JDw+HxgY1dfY4To8"
    "PToqHR0G5NYJHSM6PT01NCMaGgeTB/wCBzSMYEGjXo0VLEpwqMAwQgSGFTiUYFGjB44cK0Yo"
    "XFjhwQOGHCSyyIHDBMYR+TRMWFlhpb4RK3JsQIBjBkp9K3NOeKkCByMXMlSE6LBrFwUK7EKE"
    "kOFC0AAcMoZ2yECValIZOEw5jSEDBIiqVkHEiKG10YkYKFB8APHhA4oYJw0yDUKwAUYMuzBm"
    "OgoEACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5"
    "BAUKAEIALAAAAAABAAEAAAcDgEKBACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5BAUKAEIA"
    "LAAAAAABAAEAAAcDgEKBACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5BAUKAEIALAAAAAAB"
    "AAEAAAcDgEKBACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5BAUKAEIALAYABAAIAAsAAAcb"
    "gEJBQgSChIYAiEKLjI2Oj5CRkpOSHYxBg0KBACH5BAUKAEIALAAAAAABAAEAAAcDgEKBACH5"
    "BAUKAEIALAUAAgAKAA0AAAcrgEJAggSDQgSCCUIKikKJQkGHkJKOkQCTl46am5ydnp+goaKj"
    "nRQUmpFCgQAh+QQFCgBCACwAAAAAAQABAAAHA4BCgQAh+QQFCgBCACwAAAAAAQABAAAHA4BC"
    "gQAh+QQFCgBCACwAAAAAAQABAAAHA4BCgQAh+QQFCgBCACwAAAAAAQABAAAHA4BCgQAh+QQF"
    "CgBCACwAAAAAAQABAAAHA4BCgQAh+QQFCgBCACwAAAAAAQABAAAHA4BCgQAh+QQFCgBCACwA"
    "AAAAAQABAAAHA4BCgQAh+QQFCgBCACwAAAAAAQABAAAHA4BCgQAh+QQFCgBCACwFAAIACgAN"
    "AAAHK4BCBEJCQIOFQglAiQqEiYuDQYJCkoQAlEKXlY6cnZ6foKGio6SfQZsdhIEAIfkECQoA"
    "QgAsAAAAABMAEwAABx2AQoKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Time (time)"."""
time = PyEmbeddedImage(
    "R0lGODlhEwATAPedAFiRkVqSkt7r69Tl5drp6NDi4sXc2wAAAOTv7nmnp4GsrIOtre309Nvq"
    "6XimplmSkurx8WWZmejx8eXv78zg4M7h4fX5+XalpY20tGKYmOvy8rXPz1uTk2+goFmRkWSZ"
    "mdno5/X4+AgNDXemprzW1oKtrZq9vfL4+O/19eLs7LfQ0LfPz+ny8qbFxYixsZu9vevz89vo"
    "6LfT097p6X6qqsfb28ba2rXOzs7f37/V1c3f36PCwoqysuHr64SurvD29vH29tbl5cLb2tzo"
    "6HelpeDr693p6XKiomqdnXOjo5m8vOnx8Ymystrn56zJyYmxsWKXl4+1tWOYmF6VlY+2tqTD"
    "w7bQ0KHBwbzU1L3U1Mjc3HuoqKrIyIavr8HW1tfn5pG3t+Hs7JW6urjQ0HGiovb5+YuysrbP"
    "z4y0tPL399vn58rd3V+VlXinp2mcnKzIyIOurtvp6KvIyKPDw3+qqnmmpl2UlHqoqMLX19Tj"
    "46jFxY61taLCwoyzs4qzs2GXl/P4+KfFxbnS0s/f37nR0ajGxs/h4d7q6s/g4Pz9/aDAwNjl"
    "5fT4+Njm5mecnHKjo2uennqnp2aampq8vN/q6nWlpZy/v4ewsIKurXOion+rq53AwP//////"
    "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFMgCdACwA"
    "AAAAEwATAAAI/wA7CRQIYcWCAAhLbIAwsKHAN398jEmRJswGBWy4OOwUIgGNHljMRHjwgQkh"
    "REmIMBrYUcwQB24CBQGA40WHEUG6jAghcAedFABMoGAgQQSCCUbAABh0QVEnCFCKtJkDAAYC"
    "ASJAEBAAgMeFGlOWqHiSowMQBggaDBBRocCABnGkbKBxw4cNDC1OSBAwgIIIIQYoDBBAxUUL"
    "BQFQRDj0YwKBAgZEyCBhoACBGhnWBPCQiAMAAAhAVPhHmnSFzx5mbGYRoUnjx5EnVyaAJ4OO"
    "AAu8YOCjly8FA4AFC8DgooqCFQrKnk07oEDbt18ynLlzQwOHGQlMVL1KQCtXr1rsMFfcsWAI"
    "gD2AiIKeEAMNgBhkrggskyBKDwcfXhiiqQTJCB1wEGHBQBbUscUiWfQRQQAf+CGIDUc4MKBD"
    "TnCQgB5qsJBHIQ4EIMdGA2mgwgIPlFiCFRo4FBAAIfkEBQoAnQAsCQAEAAUABwAACBgAAXQa"
    "2IkAQREFBoroZEDEQoIQIZKAGBAAIfkEBQoAnQAsCQAFAAYABQAACBUAOwnsBGBgpwEDhRgY"
    "SMKgw3//AgIAIfkEBQoAnQAsCQAJAAYABQAACBQAOwnsVAHAv4ED/x1E2GkhwoMBAQAh+QQF"
    "CgCdACwJAAgABQAHAAAIGAD/dRpIsGDBf0IMDBTYaUAnhp0AQOwUEAAh+QQFCgCdACwFAAgA"
    "BQAHAAAIGAA7CexEYqDBg//+Gej0T2CBhgIJGAQQEAAh+QQFCgCdACwEAAkABgAFAAAIFQD/"
    "CfzXqaDBTiQMDqBgEMFBAAcDAgAh+QQFCgCdACwEAAUABgAFAAAIFgA7/etEsODAggT/HUT4"
    "DwACEBUIBgQAOw=="
)


"""Skype emoticon "Too much information (tmi)"."""
tmi = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//35u/v7//vxf/vpe/v3v/mzubm5v/mpf/mjP/m"
    "hP/etf/ere/ezv/epf/ehN7e3u/erf/eY+/elO/ejP/eIe/WlP/Wa//eGe/WjP/WUu/We//W"
    "Kf/WIe/Oe//OUv/MZv/OQu/Oa//OOv/OKf/MM//OIf/Fc//Fa+bOWu/Fe//FOv/FQv/FKf+9"
    "e//FMf+9c/+9a+bFa//FIf+9Y+bFUv+9Qv+9Kf+9If+1Wua9Wv+1Y+a9Uv+1Su+1a/+1Qv+1"
    "Oua1a/+1Kf+1Iea1Wv+tWv+tOrW1tf+tMbW1rf+tKeatY7W1pf+lQv+lOv+lMf+lKe+lUrWt"
    "pbWtnK2tra2tnK2tlP+ZM62lnK2llJmZmYyMjDMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBgACwAAAAAEwAT"
    "AAAH8oBggoIJM1A+iFAzCYONgj4xDgKTkw4xPo5gBFAPBp6fnw9QBIObEQuoqaoLEaOCSCsS"
    "srMSF163TxkrSGAJWhrAGgwDAhReAMhKXiFahVIiIh0dAV+31shXWFIzUVMvJCQmAcfI5QAT"
    "Xk1RUk06KCgnFeTmAArpUuzWXiDz5kpbRvDdAnBsXz8AV7z0KCKlIEGCIPjpw4JjR5EkDguy"
    "+MCR44kTMHQsmdGvYEePIHUkSVCS4JeXX97JgDGEB5iDBE3oNCFzSBJSV5SYy7aTp4shQkiB"
    "sadEwYSENVxIfZFDyA1HChJ62UIECJCqQFQwahQIACH5BAUKAGAALAAAAAABAAEAAAcDgGCB"
    "ACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUK"
    "AGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAA"
    "AAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEA"
    "AAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCB"
    "ACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUKAGAALAAAAAABAAEAAAcDgGCBACH5BAUK"
    "AGAALAcABAALAAgAAAc6gGCCDRyCXlUtgmAHCF6CAEpeVGBfimCOAFdbX5iWABNeBJ2KAApe"
    "IKOPSltgqJ5XXkeCGJZeWz1ggQAh+QQFCgBgACwIAAQACwAIAAAHOoBgghIZgl5WQYJgAghe"
    "ggBKXhBgAIpgjgBXW1+OlpQTXgSdlgAKXiCjipBbYBupmV5OghiWXltHYIEAIfkECQoAYAAs"
    "AAAAABMAEwAAB0eAYIKDhIWGh4iJiouMihIZgl5WBYsCFl6CAEqYiV+EmABXiQCchAATiQ2l"
    "gwAKiRirmUqKG6uhsYYgn1tEjb6/wMHCw8RggQAh+QQFCgBgACwAAAAAEwATAAAH64BggoIJ"
    "M1A+iFAzCYONgj4xDgKTkw4xPo5gBFAPBp6fnw9QBIObEQuoqaoLEaOCSCsSsrMSDbQSK0hg"
    "CVoavhoMAwIHkwwVHl7JTDNSIiIdHQFfXwDTASVeANpKUVMvJCQm0tTTyebaUk06KCgnFQQE"
    "DQTZ2vUA6eZeIPsYGPT295IByKYPxIYN/+wRHDiQHwYQCQFcWUiQxYeLF/N52ZKQIMaLJ07A"
    "0JEkQceB06axkwFjCA8wEQeamGli5ZAkpK4osXcFC82aLoYIIQVGgRclCiZMrOGi6YscQm44"
    "UjBxIxEgQKACUcGoUSAAIfkECQoAYAAsAAAAABMAEwAABx2AYIKDhIWGh4iJiouMjY6PkJGS"
    "k5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Toivo (toivo)"."""
toivo = PyEmbeddedImage(
    "R0lGODlhEwATANU5ADJlmGWYzP338vbUs6SWh/XRrMjHwa6zs99gYNIgIPnf38iwluygoOHc"
    "1/TJnvzw5PLl379/YPro1uvHoOmRkebMwMzPz4h8cKtZMM3Q0Li8vNKlj/TNpffYuq/A0Kut"
    "rcyZgOXMv9iyn/77+P7Ro/3PoP7UqPPFl/vs3f3Lmf/Wq/3Mm/nkz/7Sp/3Pnv3z6v3NnPng"
    "yPvs3Pzv46+0tJgyAPLBkP///8wAAP///wAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBF"
    "Mi4wAwEAAAAh+QQJAAA5ACwAAAAAEwATAAAGicCcMNcgXAiNoXIpXNieC6Y0ZwtUbVNm4Wkr"
    "ZJeCgW0g+Ao9toNhYjjYJF8rLaOx0Gyc78dBu/lpDlhZNg99fw+CU1iGNzRUXzYKOJOTColS"
    "NgyUkwyXUgibOAhmOQmTFJMJpFRYTxAbGGZPrDW1SyEgSrOzObW+tRW6rYK/tkoAyDnIAL1K"
    "EUJBACH5BAkAADkALAAAAAATABMAAAaLwJww1yBcCI2hcilc2J4LpjRnC1RtU2bhaStkl4KB"
    "bSD4Cj22g2FiONgkXysto7HQbJzvx0G7+WkOWFk2D31/D4JTWIY3NFRfNgo4k5MKiVI2DJST"
    "DJdSCJs4CGY5CZMUkwmkVFhPEBsYTBBKT6w1t0siFbStgre/NRFLtbU5wLhKAMo5ygDGSsI5"
    "QQAh+QQJAAA5ACwAAAAAEwATAAAGicCcMNcgXAiNoXIpXNieC6Y0ZwtUbVNm4WkrZJeCgW0g"
    "+Ao9toNhYjjYJF8rLaOx0Gyc78dBu/lpDlhZNg99fw+CU1iGNzRUXzYKOJOTColSNgyUkwyX"
    "UgibOAhmOQmTFJMJpFRYTxAbGGZPrDW1SyEgSrOzObW+tRW6rYK/tkoAyDnIAL1KEUJBACH5"
    "BAkAADkALAAAAAATABMAAAaLwJww1yBcCI2hcilc2J4LpjRnC1RtU2bhaStkl4KBbSD4Cj22"
    "g2FiONgkXysto7HQbJzvx0G7+WkOWFk2D31/D4JTWIY3NFRfNgo4k5MKiVI2DJSTDJdSCJs4"
    "CGY5CZMUkwmkVFhPEBsYTBBKT6w1t0siFbStgre/NRFLtbU5wLhKAMo5ygDGSsI5QQAh+QQJ"
    "AAA5ACwAAAAAEwATAAAGicCcMNcgXAiNoXIpXNieC6Y0ZwtUbVNm4WkrZJeCgW0g+Ao9toNh"
    "YjjYJF8rLaOx0Gyc78dBu/lpDlhZNg99fw+CU1iGNzRUXzYKOJOTColSNgyUkwyXUgibOAhm"
    "OQmTFJMJpFRYTxAbGGZPrDW1SyEgSrOzObW+tRW6rYK/tkoAyDnIAL1KEUJBACH5BAkAADkA"
    "LAAAAAATABMAAAaLwJww1yBcCI2hcilc2J4LpjRnC1RtU2bhaStkl4KBbSD4Cj22g2FiONgk"
    "Xysto7HQbJzvx0G7+WkOWFk2D31/D4JTWIY3NFRfNgo4k5MKiVI2DJSTDJdSCJs4CGY5CZMU"
    "kwmkVFhPEBsYTBBKT6w1t0siFbStgre/NRFLtbU5wLhKAMo5ygDGSsI5QQAh+QQJAAA5ACwA"
    "AAAAEwATAAAGjcCcMNcgXAiNoXIpXNieC6Y0ZwtUbVNm4WkrZJUjwcA2EHyFMsfBMDEcbJLs"
    "60nLaCw0GyfLsnVoN4E0DlhTKy45gIIPhVIqKomBNzRUZwo4mJgKjVMMmZgMnFIInzgIZzkJ"
    "mBSYCahUWE8QGxhnT7A1uUshIEq3tzm5wrkVvrGFw7pKAMw5zADBShFCQQAh+QQJAAA5ACwA"
    "AAAAEwATAAAGjMCcMNcgXAiNoXIpXNieC6Y0ZwtUbVMhqSUsPG2FbG4Fy80EA9tAII59D4aJ"
    "4WCTTAVfWkZjodk4YkI0N4Q0DliBg4UPiGKKNzRUgQo4lZUKjVMMlpUMmVIInDgIgTkJlRSV"
    "CaVUWE8QGxhMEEpPrTW4SyIVta6IuMA1EUu2tjnBuUoAyznLAMdKwzlBACH5BAkAADkALAAA"
    "AAATABMAAAaUQJIpl2sQLoQGccnMpUrEhW26aDY7DqItsLVZmRJbJ1eY2grfpWDaEQxsA0F6"
    "iTrZDoaJ4WCTzHMjAzQZGhY0Nhx/RDQ3jTQOXoqMjg+Rf5M3NDmWaQo4n58KnF8MoJ8Mo1YI"
    "pjgIijkJnxSfCa+bXlMQGxiKU7c1wE0hIEy+vjnAycAVxbiRysFMANM50wDITBFEQQAh+QQJ"
    "AAA5ACwAAAAAEwATAAAGlkCSKZdrEC6EBnHJzKVKxIVtumg2Ow6iLbC1WZkSWydXmNoK36Vg"
    "2hEMbANBeok62Q6GieFgk8xzIwM0GRoWNDYcf0Q0N400Dl6KjI4PkX+TNzQ5lmkKOJ+fCpxf"
    "DKCfDKNWCKY4CIo5CZ8Unwmvm15TEBsYVhBMU7c1wk0iFb+4kcLKNRFNwMA5y8NMANU51QDR"
    "TM05QQAh+QQJAAA5ACwAAAAAEwATAAAGlECSKZdrEC6EBnHJzKVKxIVtumg2Ow6iLbC1WZkS"
    "WydXmNoK36Vg2hEMbANBeok62Q6GieFgk8xzIwM0GRoWNDYcf0Q0N400Dl6KjI4PkX+TNzQ5"
    "lmkKOJ+fCpxfDKCfDKNWCKY4CIo5CZ8Unwmvm15TEBsYilO3NcBNISBMvr45wMnAFcW4kcrB"
    "TADTOdMAyEwRREEAIfkECQAAOQAsAAAAABMAEwAABpZAkimXaxAuhAZxycylSsSFbbpoNjsO"
    "oi2wtVmZElsnV5jaCt+lYNoRDGwDQXqJOtkOhonhYJPMcyMDNBkaFjQ2HH9ENDeNNA5eioyO"
    "D5F/kzc0OZZpCjifnwqcXwygnwyjVgimOAiKOQmfFJ8Jr5teUxAbGFYQTFO3NcJNIhW/uJHC"
    "yjURTcDAOcvDTADVOdUA0UzNOUEAIfkECQAAOQAsAAAAABMAEwAABpRAkimXaxAuhAZxycyl"
    "SsSFbbpoNjsOoi2wtVmZElsnV5jaCt+lYNoRDGwDQXqJOtkOhonhYJPMcyMDNBkaFjQ2HH9E"
    "NDeNNA5eioyOD5F/kzc0OZZpCjifnwqcXwygnwyjVgimOAiKOQmfFJ8Jr5teUxAbGIpTtzXA"
    "TSEgTL6+OcDJwBXFuJHKwUwA0znTAMhMEURBACH5BAkAADkALAAAAAATABMAAAaMwJww1yBc"
    "CI2hcilc2J4LpjRnC1RtUyGpJSw8bYVsbgXLzQQD20Agjn0PhonhYJNMBV9aRmOh2ThiQjQ3"
    "hDQOWIGDhQ+IYoo3NFSBCjiVlQqNUwyWlQyZUgicOAiBOQmVFJUJpVRYTxAbGEwQSk+tNbhL"
    "IhW1roi4wDURS7a2OcG5SgDLOcsAx0rDOUEAIfkECQAAOQAsAAAAABMAEwAABo3AnDDXIFwI"
    "jaFyKVzYngumNGcLVG1TZuFpK2SVI8HANhB8hTLHwTAxHGyS7OtJy2gsNBsny7J1aDeBNA5Y"
    "UysuOYCCD4VSKiqJgTc0VGcKOJiYCo1TDJmYDJxSCJ84CGc5CZgUmAmoVFhPEBsYZ0+wNblL"
    "ISBKt7c5ucK5Fb6xhcO6SgDMOcwAwUoRQkEAIfkECQAAOQAsAAAAABMAEwAABovAnDDXIFwI"
    "jaFyKVzYngumNGcLVG1TZuFpK2SXgoFtIPgKPbaDYWI42CRfKy2jsdBsnO/HQbv5aQ5YWTYP"
    "fX8PglNYhjc0VF82CjiTkwqJUjYMlJMMl1IImzgIZjkJkxSTCaRUWE8QGxhMEEpPrDW3SyIV"
    "tK2Ct781EUu1tTnAuEoAyjnKAMZKwjlBACH5BAkAADkALAAAAAATABMAAAaJwJww1yBcCI2h"
    "cilc2J4LpjRnC1RtU2bhaStkl4KBbSD4Cj22g2FiONgkXysto7HQbJzvx0G7+WkOWFk2D31/"
    "D4JTWIY3NFRfNgo4k5MKiVI2DJSTDJdSCJs4CGY5CZMUkwmkVFhPEBsYZk+sNbVLISBKs7M5"
    "tb61Fbqtgr+2SgDIOcgAvUoRQkEAIfkECQAAOQAsAAAAABMAEwAABovAnDDXIFwIjaFyKVzY"
    "ngumNGcLVG1TZuFpK2SXgoFtIPgKPbaDYWI42CRfKy2jsdBsnO/HQbv5aQ5YWTYPfX8PglNY"
    "hjc0VF82CjiTkwqJUjYMlJMMl1IImzgIZjkJkxSTCaRUWE8QGxhMEEpPrDW3SyIVtK2Ct781"
    "EUu1tTnAuEoAyjnKAMZKwjlBACH5BAkAADkALAAAAAATABMAAAaJwJww1yBcCI2hcilc2J4L"
    "pjRnC1RtU2bhaStkl4KBbSD4Cj22g2FiONgkXysto7HQbJzvx0G7+WkOWFk2D31/D4JTWIY3"
    "NFRfNgo4k5MKiVI2DJSTDJdSCJs4CGY5CZMUkwmkVFhPEBsYZk+sNbVLISBKs7M5tb61Fbqt"
    "gr+2SgDIOcgAvUoRQkEAIfkECQAAOQAsAAAAABMAEwAABovAnDDXIFwIjaFyKVzYngumNGcL"
    "VG1TZuFpK2SXgoFtIPgKPbaDYWI42CRfKy2jsdBsnO/HQbv5aQ5YWTYPfX8PglNYhjc0VF82"
    "CjiTkwqJUjYMlJMMl1IImzgIZjkJkxSTCaRUWE8QGxhMEEpPrDW3SyIVtK2Ct781EUu1tTnA"
    "uEoAyjnKAMZKwjlBACH5BAUAADkALAAAAAATABMAAAaJwJww1yBcCI2hcilc2J4LpjRnC1Rt"
    "U2bhaStkl4KBbSD4Cj22g2FiONgkXysto7HQbJzvx0G7+WkOWFk2D31/D4JTWIY3NFRfNgo4"
    "k5MKiVI2DJSTDJdSCJs4CGY5CZMUkwmkVFhPEBsYZk+sNbVLISBKs7M5tb61Fbqtgr+2SgDI"
    "OcgAvUoRQkEAIfkEBQAAOQAsAAAAAAEAAQAABgPAXBAAIfkEBQAAOQAsAAAAAAEAAQAABgPA"
    "XBAAIfkEBQAAOQAsAAAAAAEAAQAABgPAXBAAOw=="
)


"""Skype emoticon "Tongue out :P"."""
tongueout = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/vpf/mzv/mpf/mnP/mhP/mjP/etf/erf/e"
    "nP/ehP/eY//eIf/eGf/Wa//WUv/WSv/WOv/WMf/WKf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv+9e//FKf/FMf+9a/+9c//FIf+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1"
    "Wv+1Sv+1Uv+1Qv+1Ov+1Mf+1Kf+1If+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZM/8AMzMz"
    "M////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBEACwAAAAAEwAT"
    "AAAH/4BEgoIGKD0wiD0oBoONgjAkCwKTkwskMI5EAz0MBJ6fnww9A4ObDQeoqAipqA2jgjkh"
    "DrO0CQm0syE5RAZBEr8SCpMFkwoPwEGFPxoaExMBANHRARTOGj8oPkAiGxsVQ0MA4AABFRzd"
    "PD4/PC0fHxbgA/EPFx0fJTw/Pzc4JR0dGAJCgBAQRIcSL3Dou+HiRQoQATFEiBARRIoXN37o"
    "2OGixEOIGAYWtPhih44THEv463ChJYaWQw662HHCgA4bKjsMuWCh5YUhQg620MEoRo0WJtyB"
    "WyqkaYkaMQQN0FEj6QcOWJtqFaKDlFQaNUaMwJp1q9dGKmisWCFihAgRWg4zDTLgQQYNuzI8"
    "MGoUCAAh+QQFCgBEACwAAAAAAQABAAAHA4BEgQAh+QQFCgBEACwMAAwABAAGAAAHFYBEHUSE"
    "g4QfJocmNUQjNDQrNCpEgQAh+QQFCgBEACwGAAYABwALAAAHKYBEQ0OChAGCAIJEDwNECY1E"
    "kZKTlJWKk0Mdg5sXRBafnx+THByiox+BACH5BAUKAEQALAAAAAABAAEAAAcDgESBACH5BAUK"
    "AEQALAAAAAABAAEAAAcDgESBACH5BAUKAEQALAYABgAHAAsAAAcmgEQAAIKEQ4KHhodDh0SO"
    "j5CRkkQdkRdDFxYXm4uMjEKQQqKRooEAIfkEBQoARAAsDAAMAAQABgAABw+ARENEhEKFQoaI"
    "iouIRIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEA"
    "IfkECQoARAAsAAAAABMAEwAABx2ARIKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqKgQA7"
)


"""Skype emoticon "Wait (wait)"."""
wait = PyEmbeddedImage(
    "R0lGODlhEwATAPf/AP///4mJiTMzM5lmM//87//wx//z5v+0Zf/pzf/05f/xx/+eMv+iPv+/"
    "ev+2SP/ozf/ozv+7cv/ftf/NOv+9cP+kQv+1Y//RN//gof+jMv+hMv+mPf/89P/++f/99//V"
    "Mv/grf/hgf+xLP/YIP+uMv/KIf/EM//PJf/BKf/LOf/KJv/oo/r6+v+sNv/unf/wyJCQkP+z"
    "N//CLf/BQP/11//SUf/yyOrq6v+7Qv+/Y//ZZ//UT//JN/+vPP+4Pf/VI//ehf/88//npf/M"
    "MP/Wa//TJf/RPf/uvf/Ecf/MLZGRkf/mp/+2Qv/COf+pKv+5Rv/KP/+vJv/EKf+qPf++Lf/P"
    "VP/vyf/SH//FJ/+4Rv/MQf+8IP/bG//WLf/ZHf/AIv+3V/+0JP/EaP/EIv+/Jv+tKP/Saf+l"
    "P//ILv/DH/+4Rf/Rav+lMv/FJf/IJf/QH//RI//QNv/KKv/JM//QPv+0Jv7HPf+9If/dh/+i"
    "L//MOv/MIP/NVv/UMv/WIP/UH/+7Lf/PKv/FPv/WIf7bG/7FPv+5Jf+kMv/DaP/Ab/+wV/+w"
    "J//fg/+wWP+xKf+4Of/z5//Xaf/QN/+qPP/IQf/no//QMf/QU//aH/+jLv+kQP7ZHv+xP//N"
    "NP/KM5mZmf+oK/++JP+4JP/VH9/f37Ozs//uof/98aurq66urv/to//XJuLi4v/TMf/98v/8"
    "8v/88f/YJf/RLv/SK//KMf/XH//aHv/bHv/TLf7bHv/65P+7KZiXlv+7J//TIf/ehv+/bv/P"
    "Jv/ULf/BJf7ZIObm5unMWv/opP+3WP/xyv/HLP/99erCi//UJv/qo5KSkq6sqf/76//HJ//H"
    "JP+/MP/pn66pmv/PN//RM//NIurAav/PIv/WJf+4L//RJ//MKP/RLP/89v/tqP/12P/qq//X"
    "LIiIiMfHx9LS0r29vf/kjP///sDAwP/VK+Lc0+LAkf/WLP+2Ov/gX//sp/z8/L2xmP/67P/Y"
    "aP/05r6yoP/PP//eYf/phf/UOv/oof///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgD/ACwA"
    "AAAAEwATAAAI/wD/CRQIIQKDAwgZRIAwsKFACw0kEJg4UUIDCw7/GagAwkqBAgpCfnwBooKB"
    "gQY0YVgipNKAlytWvByA4QwkgY0Q4QHCKIQNDx5s/PSQ7JcYRf8eLFhDJJKOIwCiSo16xMyC"
    "BxTy8LlUYwcHAAIERA0LgEOVTBQ2gKKkhY6RIGDFxgUQBIqTDRrKUJkzRJaqqVOPoYiiIcMi"
    "UVhUBCvi4tQpFy5gwarmZkuYDIccGfpSYpsvP5sIcfEy6sqeNHfqsJkkotewadngDBqByVat"
    "P29KjAklYgowErtQSPvmrdmqWAK4FTmhog0ZEokQtOgmQ1kAcMK6iBUwK5AcKYBaIGH4hywG"
    "tQAAAmDr80FAK0tD0MiIAUagO17moga4JunChTideGLCIz0kIBAM6LCgXwp6TDBBCjw04QMn"
    "Bh54DgsssAPDDIXYIcgMODCRg0OsfBJAALy840AWT6jhABLjNRQQACH5BAUKAP8ALAAAAgAQ"
    "ABEAAAiOAP8JHPhvgEGBBgcQJEijQwcaDTuMWyhQAYCLGC8mo7jsnwABAj/+C0expMl/4v5d"
    "FLiS3MIAuFS5cmXK1KtXzoYQDAAgwA9iuW6N+AHnxMueJ/8FWMozwECRA3lmVGLM40WQAqWu"
    "RMoSq9KMTZ/uvLFSpdOSqUqVRWXN5I1npViRQqVE28kbqQRCY3YyIAAh+QQFCgD/ACwJAA0A"
    "BAACAAAIDADLCRAw69+HVv8CAgAh+QQFMgD/ACwKAAsAAgADAAAICQBt1RIgAF67gAAh+QQF"
    "CgD/ACwAAAIAEAARAAAIlQD/CRz4r4ACBQILvABBkOCAhytWPBzQUGAIGx482MDoIdmvikf+"
    "AQAgcOS/kBVTqgzyT4AAgS7/sSQoS9XImzePEVQRrIiLU6dcuIAFq1rDEgF8qRQootewpQOB"
    "kdiFIsC/AM3+xYrFrchABAHCigwgrKXLl1BVwig20OrStQRJwVCZ7hMreixI/au3NJ0SgTDy"
    "LQ0IACH5BAUKAP8ALAAACgANAAkAAAhGAP8JFLhtoEGD07LBOXhQ2jdvDP+16CZDWQBwB2f9"
    "QxaDWgAAAbAxdMfL3D+Q1xjCQMdCYIAUKs+1ZAdjBkNWnwTyescwIAAh+QQFMgD/ACwBAAMA"
    "DwAQAAAIewD/CRy4YoU/gSuECBnIMITDhyEYMRSozl60edGiqdNxL9LEfwL+rRMgYNmOGjU+"
    "hhwpIEg/Ovom7tOlix9NebhkDfn4g1iuWyN+wDnxsajRo0VJKjWaZGA5eO2KmqDV6Si+HvFM"
    "8Kh6NAEnH014IBWYgwmOsQIRIDkaEAA7"
)


"""Skype emoticon "It wasn't me! (wasntme)"."""
wasntme = PyEmbeddedImage(
    "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"
    "l5iZmoqBADs="
)


"""Skype emoticon "Relieved (whew)"."""
whew = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35vf37//vxf/ve//mzubm5v/mpf/mnP/etf/erf/e"
    "pf/ehN7e3v/ee97e1t7ezv/eY97excXe///eWv/eIf/Wa97WxdbW1v/eGffWc//WUt7WvffW"
    "a//WSsXW797Wrf/WOv/WKf/WMf/WId7Ovd7Orf/OUtbOzv/MZv/OQt7OnP/OOvfOSv/OKczM"
    "zP/MM//Fc//OIf/Fa//FOv/FQv/FKf/FMf+9e/+9c//FIf+9a/+9Y8XFvf+9Qv+9Mf+9Kf+9"
    "If+1Y/+1Wv+1Ss69jP+1QsW9nMW9jP+1Mf+1Ove1Ot61hN61jP+1If+1KcW9hMW9e9a1lP+t"
    "WsW1pf+tOsW1nP+tQsW1lM61hP+tMcW1jMW1e/+tKcW1hP+lQsWtlP+lOsWthPelQv+lKf+l"
    "Ma2trf+ZM3Ot962lnKWlpaWlnKWljKWllGul/6WchKWcjKWce6Wcc5mZmZmZmaWUhKWUc6WU"
    "e5SUjKWMc4yMjEJCQjMzM////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgB/ACwAAAAAEwAT"
    "AAAH/4B/goIHO3h8iHprGYONgkQ6bAgAlAAxfFSOfwNhDG0RlZUPemEDg5wNCW4SoZV6KKWC"
    "VTUODnGsrQB6LTVVfwdpGMIYbYjFkw98HBhphWcpKR0dEANtkwDJSR0pZztjZjdwLC4Bfn16"
    "iUcuLCxfY2dfYHBSJQJ+fgD3AiQwMjhfZ+DBGQjDwoABBg5aoAEDxxAoAaN4gTOFhomLGzZc"
    "NEGDx5AoZ65wEYKDBw2LJi5cuHjSY5QrPUbiwAEDBombOGviEMJlx4ErS2bWJOEHJ7+GQa4c"
    "+FOESZAcMmTg81OiRNQcOJgUETTgChOoMlz4cUH2KpMrprhmYWLDBtm3Mh9sMEGStpEPJECA"
    "tLVxAwgSH5oGHZhhxIhfIzOWNgoEACH5BAkKAH8ALAAAAAATABMAAAdygH+Cg39hRHd/fHx6"
    "aA+EjwsCbAiCAAAxfBqPggUFbRGElg96m38JCW4Sj5Z6oI8ODnGqoQB6TqUTE22KuwgAD3xl"
    "pYIDCm2+v3xYjyyEfgB9iYtHj0F/MsPDXn9T2aVwf+Dej15w3ePo6err7O3u7+OBACH5BAkK"
    "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"
    "GY0cBQIAOw=="
)


"""Skype emoticon "Wink (wink)"."""
wink = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/vpf/mzv/mpf/mnP/mjP/mhP/etf/erf/e"
    "nP/ehP/eY//eIf/Wa//eGf/WUv/WSv/WOv/WMf/WKf/WIf/OUv/MZv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv/FMf/FKf+9e//FIf+9a/+9c/+9Y/+9Qv+9Ov+9Kf+9Mf+9If+1Y/+1"
    "Wv+1Uv+1Sv+1Qv+1Mf+1Ov+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMz"
    "M////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBEACwAAAAAEwAT"
    "AAAH/4BEgoIGKT0wiD0pBoONgjAmCwKTkwsmMI5EAz0MBJ6fnww9A4ObDQcHQqgIqK0No4I5"
    "IQ60DkIOCgq1tCE5RAZBEcIRDw9CxcjDQYU/GRkTE0NDFBTS1NAZPyk+QCIbG0MVFeHS4hzf"
    "PD4/PC4fHxYWF/LzFx0fJTw/Pzg3JR0dGAJCgBAQRIcSL27ow9HixYkhATFIkBARxIkXOH7o"
    "2NGixEMQAgliAGHxxQ4dKDiW8DdkHoYLQ/6VaLEDhQEdNVb+k8az3sEWOhjFsOGChDt4SN2R"
    "IGEjhqABOmwY/cChalWlNnSQekrDxogRVq+OoEFjayMVNFasEDFChIgVNA9UZBpkwMMMGndn"
    "eGDUKBAAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEA"
    "IfkEBQoARAAsBQADAAMACAAABxGARAdEhIWEFBQVREOGhCCEgQAh+QQFCgBEACwFAAQACAAI"
    "AAAHJYBERA6ChUQJAgIFiQlEAUNDAIIBjoKSlQ8DAwqaD4afoEQgoYEAIfkEBQoARAAsAAAA"
    "AAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAABwOARIEAIfkEBQoARAAsAAAAAAEAAQAA"
    "BwOARIEAIfkEBQoARAAsBQAEAAgACAAAByKARERCgoVEDw9CiIhEFI4UgpAVgpNEkxYXmZqG"
    "nJ1EQ56BACH5BAUKAEQALAUAAwADAAgAAAcPgERCRISFhEOIRBWGh4SBACH5BAUKAEQALAAA"
    "AAABAAEAAAcDgESBACH5BAkKAEQALAAAAAATABMAAAcdgESCg4SFhoeIiYqLjI2Oj5CRkpOU"
    "lZaXmJmaioEAOw=="
)


"""Skype emoticon "Wondering :^)"."""
wonder = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//37//35v/vxf/vpf/mzv/mpf/mnP/mhP/mjP/etf/e"
    "rf/enP/ehP/eY//eWv/eIf/Wa//eGf/WUv/WSv/WOv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/O"
    "Kf/MM//Fc//OIf/Fa//FQv/FOv/FMf+9e//FKf+9a//FIf+9c/+9Y/+9Qv+9Ov+9Mf+9Kf+9"
    "If+1Y/+1Wv+1Uv+1Sv+1Qv+1Ov+1Mf+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+Z"
    "M5lmMzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBGACwAAAAAEwAT"
    "AAAH/4BGgoIHKz8yiD8rB4ONgjJEDAKTkwwnMo5GBD8NBUQFoKEFDT8Eg5sOCKpECAmqrw6l"
    "gjsjD7a2RApEu0S2IztGB0MTxAsDAgsQC5MLxBNDhUEcHBVFRQABFtbYFRUcQStAQiQdHdsC"
    "F9sBHuU+QEE+LyAgEAQEERgR9hAfICg+QYLoyIHiwwcNCCVIQCjiA4oYOQLqgBFDhQiEGihQ"
    "wChCRQwdQXj0gIHC4kUNChl2jNGDR4qRKAp+wEBTA02DKGD0SHGAB46YBq0JxYDzBQ9GM268"
    "MDEvg1On80yYuDFDEAEeN5iC8MCVa9QbPExZtXGjRImuXkvYsCG2EQsbLRdakChBgkQLGywy"
    "DToQooYNvzVCMGoUCAAh+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh+QQFCgBGACwFAAEAAgAC"
    "AAAHBoAnRkYFgQAh+QQFCgBGACwHAAMABwACAAAHDIAIRoOERg9GCg+KgQAh+QQFCgBGACwF"
    "AAUACQAJAAAHKoATCwICBoQLEBUBRUUARo8WF4uNj0YXGRAEBAqaEBiVoKGio6Shn4+ngQAh"
    "+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh+QQFCgBG"
    "ACwFAAUACQAJAAAHLoALA0YLEAtGAgtFRQABFkaQAYsAAheQRgEQBEYRGBFGBBCXo6Slpqek"
    "RZeqRoEAIfkEBQoARgAsBwADAAcAAgAABwuAREaDhEaCRIhEgQAh+QQFCgBGACwFAAEAAgAC"
    "AAAHBoBERkZEgQAh+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh+QQFCgBGACwAAAAAAQABAAAH"
    "A4BGgQAh+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh+QQFCgBGACwAAAAAAQABAAAHA4BGgQAh"
    "+QQJCgBGACwAAAAAEwATAAAHHYBGgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmoqBADs="
)


"""Skype emoticon "Worried :S"."""
worry = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////9///7//35v/vxf/ve//mzv/mpf/mnP/etf/erf/enP/ehP/e"
    "e//eY//eWv/eIf/Wa//eGf/WUv/WSv/WOv/WKf/WMf/WIf/MZv/OUv/OQv/OOv/OKf/Fc//M"
    "M//OIf/Fa//FQv/FOv/FMf+9e//FKf+9c//FIf+9a/+9Y/+9Qv+9Ov+9Mf+9Kf+9If+1Y/+1"
    "Wv+1Sv+1Uv+1Qv+1Ov+1Mf+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+ZM5lmMzMz"
    "M////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBEACwAAAAAEwAT"
    "AAAH/4BEgoIGJz0wiD0nBoONgjAlCQKTkwklMI5EAz0KBJ6fnwo9A4ObCweoQkIIqqgHC6OC"
    "OSEMtUK1uLe1ITlEBkERwREOxMXEwkGFPxoaExMNAwMI0Q0Uzho/Jz5AIhsbFQFDQwDiARUc"
    "3jw+PzwtHx8XAuLkQwIWHR8mPD8/ODcmHTo8iFYg2gMQHUy8uMEPh4sXKEBgmChBwkQMIFC8"
    "wPFDxw4XJiJKxAABwkQQGV/s0JHiowmAHSzIxCAzoAkXOxbpsPEy4BCZ4u4lbKGDUYwaLUi8"
    "uyDuAtMPJEjUiCFogI4aSj9w2Lr1nVQdpKrSqDFiBNeuI2jQCNtIBY0VKxZEjBAhYgUNFZkG"
    "GfAgg0ZfGR4YNQoEACH5BAUKAEQALAAAAAABAAEAAAcDgESBACH5BAUKAEQALAAAAAABAAEA"
    "AAcDgESBACH5BAUKAEQALAAAAAABAAEAAAcDgESBACH5BAUKAEQALAAAAAABAAEAAAcDgESB"
    "ACH5BAUKAEQALAAAAAABAAEAAAcDgESBACH5BAUKAEQALAUAAgAJAA0AAAcogESCQkSEgocH"
    "RImHjIyGjY+NkpOUlZaUQ4JDmYcXmxeehxyjox9EgQAh+QQFCgBEACwAAAAAAQABAAAHA4BE"
    "gQAh+QQFCgBEACwAAAAAAQABAAAHA4BEgQAh+QQFCgBEACwAAAAAAQABAAAHA4BEgQAh+QQF"
    "CgBEACwAAAAAAQABAAAHA4BEgQAh+QQFCgBEACwAAAAAAQABAAAHA4BEgQAh+QQFCgBEACwA"
    "AAAAAQABAAAHA4BEgQAh+QQFCgBEACwAAAAAAQABAAAHA4BEgQAh+QQFCgBEACwAAAAAAQAB"
    "AAAHA4BEgQAh+QQFCgBEACwFAAIACQANAAAHKYAEgoODRIZCRIiGi4yGEY2GDpCTlJWWl40W"
    "mhgWjEOaQ5+LF6EXpESBACH5BAUKAEQALAAAAAABAAEAAAcDgESBACH5BAkKAEQALAAAAAAT"
    "ABMAAAcdgESCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmaioEAOw=="
)


"""Skype emoticon "Yawn (yawn)"."""
yawn = PyEmbeddedImage(
    "R0lGODlhEwATAOYAAP//////7//35v/33v/vxe/v3v/mzv/mpf/mnP/me//etf/erf/enP/e"
    "hP/ee//eY//eWv/Wa//WY//eGf/WUv/WSv/WOv/WMf/WKf/WIf/WGf/OUv/MZv/OQv/OOv/O"
    "Kf/Fc//MM//OIf/Fa//FOv/FQv+9e//FKf/FMf+9a/+9c//FIf+9Y/+9Qv+9Ov+9Mf+9Kf+9"
    "If+1Y/+1Wv+1Sv+1Uv+1Qv+1Ov+1Mf+1If+1Kf+tWv+tOv+tMf+tKf+lQv+lOv+lMf+lKf+Z"
    "M5lmMzMzM////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgBGACwAAAAAEwAT"
    "AAAH/4BGgoIGKj8yiD8qBoONgjImCgGTkwomMo5GAj8LBJ6fnws/AoObDAeoqAipqAyjgjsj"
    "DQ1FtQ63tUWzIztGBkMREUUSEg9Fxg/JRcFDhUEbGxTS09MV0htBKkBCJR0e3+DgFh4dHT5A"
    "QT4vISEf7rnuGB8hJz5BQTo5J+4fRQX/RdyJOBEjxz0dMGKsEOHvH0ARIlbE0BGERw8YJxY2"
    "dFgkosQePFJcPLFv48MVJ2D0SGGABw6SJ0wWKALzBQ9GM268QIEixMYi7EjemCFIAI8bPNnl"
    "YhcCxQ0epIrauEGCRDgPIUjYsBG1EQsbLVpUJVGihQ0WmQYZAEHDRlsaIAQYNQoEACH5BAUK"
    "AEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAAA"
    "AAABAAEAAAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAQABAALAAwA"
    "AAc0gA0NDoSFDoIREUVFD42LiUZFRpGUlZOXmJkfm5mXi5KdoaKjoh+gkZyTJyefq6uYHrGY"
    "gQAh+QQFCgBGACwHAAMABgABAAAHBYAIgoOBACH5BAUKAEYALAYACQAHAAYAAAcdgCKCgyIZ"
    "RYeHGYZGjEUiH0WMRkUflYiVJ5maJ4EAIfkEBQoARgAsBgAPAAgAAQAABwaAJ4KDgoEAIfkE"
    "BQoARgAsBQADAAoADQAAB0OARkYHB4OEgoiJiESMi40UgpCQRhWCAUVFAJgBiJeZm4qhiBkZ"
    "ExMaihiYRRihGK+hrK+sJ4IhF7i4ISG2Hr6+u0aBACH5BAUKAEYALAYABAAIAAoAAAcngERE"
    "RoSCRhIPiYqEjI2Oj44QAgIJkxCQjRmajkWdhCJFGKKiRUaBACH5BAUKAEYALAAAAAABAAEA"
    "AAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaB"
    "ACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUK"
    "AEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAAAAAABAAEAAAcDgEaBACH5BAUKAEYALAYA"
    "BAAIAAoAAAckgA4ORoSCRkREhIeJio2Oj48ikpMikI1FmI4Ym4SbRYpFGEaBACH5BAUKAEYA"
    "LAUABQAKAAoAAAcwgBFFRUaFgxFGhImLjB6Ojx6FRh+UlR+SmJmSg4qYRQWgnZKgBZofnJeX"
    "Riesra2BACH5BAUKAEYALAYABAAJAAsAAAcagA2Cgw1GhoeIiYqLjI2Oj5CJIReUlCEhRoEA"
    "IfkEBQoARgAsBAAEAAsACwAAByyARkYOhIUOgkZFiIuKRRSLiBSKkJSVlUWYlwWbk5aenkWb"
    "BZ2CJyeYRaamgQAh+QQJCgBGACwAAAAAEwATAAAHIYBGgoOEhYaHiImKi4yEDY+QDY2TlJWW"
    "l5iZmpucnZ6egQA7"
)


"""Skype emoticon "Yes (y)"."""
yes = PyEmbeddedImage(
    "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"
    "hhgNtykhADs="
)


"""Emoticon metadata: name, strings, title."""
EmoticonData = {
    "angel": {'strings': ['(angel)'], 'title': 'Angel'},
    "angry": {'strings': [':@', ':-@', ':=@', 'x(', 'x-(', 'x=(', 'X(', 'X-(', 'X=('], 'title': 'Angry'},
    "bandit": {'strings': ['(bandit)'], 'title': 'Bandit'},
    "beer": {'strings': ['(beer)', '(b)', '(B)'], 'title': 'Beer'},
    "bertlett": {'strings': ['(bartlett)'], 'title': '(bartlett)'},
    "blush": {'strings': [':$', '(blush)', ':-$', ':=$'], 'title': 'Blush'},
    "bow": {'strings': ['(bow)'], 'title': 'Bow'},
    "brokenheart": {'strings': ['(u)', '(U)', '(brokenheart)'], 'title': 'Broken heart'},
    "bug": {'strings': ['(bug)'], 'title': 'Bug'},
    "cake": {'strings': ['(cake)', '(^)'], 'title': 'Cake'},
    "call": {'strings': ['(call)'], 'title': 'Call'},
    "cash": {'strings': ['(cash)', '(mo)', '($)'], 'title': 'Cash'},
    "clap": {'strings': ['(clap)'], 'title': 'Clapping'},
    "coffee": {'strings': ['(coffee)'], 'title': 'Coffee'},
    "cool": {'strings': ['8=)', '8-)', 'B=)', 'B-)', '(cool)'], 'title': 'Cool'},
    "cry": {'strings': [';(', ';-(', ';=('], 'title': 'Crying'},
    "dance": {'strings': ['(dance)', '\\o/', '\\:D/', '\\:d/'], 'title': 'Dance'},
    "devil": {'strings': ['(devil)'], 'title': 'Devil'},
    "doh": {'strings': ['(doh)'], 'title': 'Doh!'},
    "drink": {'strings': ['(d)', '(D)'], 'title': 'Drink'},
    "drunk": {'strings': ['(drunk)'], 'title': 'Drunk'},
    "dull": {'strings': ['|(', '|-(', '|=(', '|-()'], 'title': 'Dull'},
    "eg": {'strings': [']:)', '>:)', '(grin)'], 'title': 'Evil grin'},
    "emo": {'strings': ['(emo)'], 'title': 'Emo'},
    "envy": {'strings': ['(envy)'], 'title': 'Envy'},
    "facepalm": {'strings': ['(facepalm)'], 'title': 'Facepalm'},
    "finger": {'strings': ['(finger)'], 'title': 'Finger'},
    "fingerscrossed": {'strings': ['(fingerscrossed)'], 'title': 'Fingers crossed'},
    "flower": {'strings': ['(f)', '(F)'], 'title': 'Flower'},
    "fubar": {'strings': ['(fubar)'], 'title': 'Fubar'},
    "giggle": {'strings': ['(chuckle)', '(giggle)'], 'title': 'Giggle'},
    "handshake": {'strings': ['(handshake)'], 'title': 'Shaking Hands'},
    "happy": {'strings': ['(happy)'], 'title': 'Happy'},
    "headbang": {'strings': ['(headbang)', '(banghead)'], 'title': 'Headbang'},
    "heart": {'strings': ['(h)', '(H)', '(l)', '(L)'], 'title': 'Heart'},
    "heidy": {'strings': ['(heidy)'], 'title': 'Heidy'},
    "hi": {'strings': ['(hi)'], 'title': 'Hi'},
    "highfive": {'strings': ['(highfive)'], 'title': 'High five'},
    "hollest": {'strings': ['(hollest)'], 'title': 'Hollest'},
    "hug": {'strings': ['(hug)', '(bear)'], 'title': 'Hug'},
    "inlove": {'strings': ['(inlove)'], 'title': 'In love'},
    "kiss": {'strings': [':*', ':=*', ':-*'], 'title': 'Kiss'},
    "lalala": {'strings': ['(lalala)'], 'title': 'Lalala'},
    "laugh": {'strings': [':D', ':=D', ':-D', ':d', ':=d', ':-d'], 'title': 'Laugh'},
    "lipssealed": {'strings': [':x', ':-x', ':X', ':-X', ':#', ':-#', ':=x', ':=X', ':=#'], 'title': 'My lips are sealed'},
    "mail": {'strings': ['(e)', '(m)'], 'title': 'Mail'},
    "makeup": {'strings': ['(makeup)', '(kate)'], 'title': 'Make-up'},
    "mmm": {'strings': ['(mm)'], 'title': 'mmmmm..'},
    "mooning": {'strings': ['(mooning)'], 'title': 'Mooning'},
    "movie": {'strings': ['(~)', '(film)', '(movie)'], 'title': 'Movie'},
    "muscle": {'strings': ['(muscle)', '(flex)'], 'title': 'Muscle'},
    "music": {'strings': ['(music)'], 'title': 'Music'},
    "nerdy": {'strings': ['8-|', 'B-|', '8|', 'B|', '8=|', 'B=|', '(nerd)'], 'title': 'Nerd'},
    "ninja": {'strings': ['(ninja)'], 'title': 'Ninja'},
    "no": {'strings': ['(n)', '(N)'], 'title': 'No'},
    "nod": {'strings': ['(nod)'], 'title': 'Nodding'},
    "oliver": {'strings': ['(oliver)'], 'title': '(oliver)'},
    "party": {'strings': ['(party)'], 'title': 'Party'},
    "phone": {'strings': ['(ph)', '(mp)'], 'title': 'Phone'},
    "pizza": {'strings': ['(pizza)', '(pi)'], 'title': 'Pizza'},
    "poolparty": {'strings': ['(poolparty)'], 'title': 'Poolparty'},
    "puke": {'strings': ['(puke)', ':&', ':-&', ':=&'], 'title': 'Puking'},
    "punch": {'strings': ['(punch)'], 'title': 'Punch'},
    "rain": {'strings': ['(rain)', '(london)', '(st)'], 'title': 'Raining'},
    "rock": {'strings': ['(rock)'], 'title': 'Rock'},
    "rofl": {'strings': ['(rofl)'], 'title': 'Rolling on the floor laughing'},
    "sad": {'strings': [':(', ':=(', ':-('], 'title': 'Sad'},
    "shake": {'strings': ['(shake)'], 'title': 'Shaking'},
    "skype": {'strings': ['(skype)', '(ss)'], 'title': 'Skype'},
    "sleepy": {'strings': ['|-)', 'I-)', 'I=)', '(snooze)'], 'title': 'Sleepy'},
    "smile": {'strings': [':)', ':=)', ':-)'], 'title': 'Smile'},
    "smirk": {'strings': ['(smirk)'], 'title': 'Smirking'},
    "smoke": {'strings': ['(smoking)', '(smoke)', '(ci)'], 'title': 'Smoking'},
    "soccer": {'strings': ['(soccer)'], 'title': '(soccer)'},
    "speechless": {'strings': [':|', ':=|', ':-|'], 'title': 'Speechless'},
    "star": {'strings': ['(*)'], 'title': 'Star'},
    "sun": {'strings': ['(sun)'], 'title': 'Sun'},
    "surprised": {'strings': [':O', ':=o', ':-o', ':o', ':=O', ':-O'], 'title': 'Surprised'},
    "swear": {'strings': ['(swear)'], 'title': 'Swearing'},
    "sweat": {'strings': ['(sweat)', '(:|'], 'title': 'Sweating'},
    "talk": {'strings': ['(talk)'], 'title': 'Talking'},
    "think": {'strings': ['(think)', ':?', ':-?', ':=?'], 'title': 'Thinking'},
    "time": {'strings': ['(time)'], 'title': 'Time'},
    "tmi": {'strings': ['(tmi)'], 'title': 'Too much information'},
    "toivo": {'strings': ['(toivo)'], 'title': 'Toivo'},
    "tongueout": {'strings': [':P', ':=P', ':-P', ':p', ':=p', ':-p'], 'title': 'Tongue out'},
    "tumbleweed": {'strings': ['(tumbleweed)'], 'title': 'Tumbleweed'},
    "wait": {'strings': ['(wait)'], 'title': 'Wait'},
    "waiting": {'strings': ['(waiting)'], 'title': 'Waiting'},
    "wasntme": {'strings': ['(wasntme)'], 'title': "It wasn't me!"},
    "wfh": {'strings': ['(wfh)'], 'title': 'Working from home'},
    "whew": {'strings': ['(whew)'], 'title': 'Relieved'},
    "wink": {'strings': ['(wink)', ';)', ';-)', ';=)'], 'title': 'Wink'},
    "wonder": {'strings': [':^)'], 'title': 'Wondering'},
    "worry": {'strings': [':S', ':-S', ':=S', ':s', ':-s', ':=s'], 'title': 'Worried'},
    "wtf": {'strings': ['(wtf)'], 'title': 'What the...'},
    "yawn": {'strings': ['(yawn)'], 'title': 'Yawn'},
    "yes": {'strings': ['(y)', '(Y)', '(ok)'], 'title': 'Yes'},
}


"""Maps emoticon strings to emoticon names."""
EmoticonStrings = dict((s, k) for k, d in EmoticonData.items() for s in d["strings"])

########NEW FILE########
__FILENAME__ = export
# -*- coding: utf-8 -*-
"""
Functionality for exporting Skype data to external files.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     13.01.2012
@modified    27.04.2014
------------------------------------------------------------------------------
"""
import collections
import csv
import datetime
import os
import re
import traceback

from PIL import ImageFile, ImageFont
try:
    import xlsxwriter
    XLSX_WILDCARD = "Excel workbook (*.xlsx)|*.xlsx|"
except ImportError:
    xlsxwriter = None
    XLSX_WILDCARD = ""

from third_party import step

import conf
import emoticons
import images
import main
import skypedata
import templates
import util

try: # Used in measuring text extent for Excel column auto-width.
    FONT_XLSX = ImageFont.truetype(conf.FontXlsxFile, 15)
    FONT_XLSX_BOLD = ImageFont.truetype(conf.FontXlsxBoldFile, 15)
except IOError:
    FONT_XLSX = FONT_XLSX_BOLD = ImageFont.load_default()

"""FileDialog wildcard strings, matching extensions lists and default names."""
CHAT_WILDCARD = ("HTML document (*.html)|*.html|Text document (*.txt)|*.txt|"
                 "%sCSV spreadsheet (*.csv)|*.csv" % XLSX_WILDCARD)
CHAT_EXTS = ["html", "txt", "xlsx", "csv"] if xlsxwriter \
            else ["html", "txt", "csv"]
CHAT_WILDCARD_SINGLEFILE = "Excel workbook (*.xlsx)|*.xlsx" # Cannot end with |
CHAT_EXTS_SINGLEFILE = ["xlsx"]

TABLE_WILDCARD = ("HTML document (*.html)|*.html|"
                  "SQL INSERT statements (*.sql)|*.sql|"
                  "%sCSV spreadsheet (*.csv)|*.csv" % XLSX_WILDCARD)
TABLE_EXTS = ["html", "sql", "xlsx", "csv"] if xlsxwriter \
             else ["html", "sql", "csv"]

QUERY_WILDCARD = ("HTML document (*.html)|*.html|"
                  "%sCSV spreadsheet (*.csv)|*.csv" % XLSX_WILDCARD)
QUERY_EXTS = ["html", "xlsx", "csv"] if xlsxwriter else ["html", "csv"]


def export_chats(chats, path, format, db, messages=None, skip=True, progress=None):
    """
    Exports the specified chats from the database under path.

    @param   chats     list of chat dicts, as returned from SkypeDatabase
    @param   path      full path of directory where to save
    @param   format    export format (html|txt|xlsx|csv|filename.ext).
                       If format is filename.ext, a single file is created:
                       for single chat exports and multi chat XLSX exports
                       (for multi-file exports, filenames are named by chats).
    @param   db        SkypeDatabase instance
    @param   messages  list messages to export if a single chat
    @param   skip      whether to skip chats with no messages
    @param   progress  function called before exporting each chat, with the
                       number of messages exported so far
    @return            (list of exported filenames, number of chats exported)
    """
    files, count = [], 0
    def make_filename(chat):
        if len(format) > 4: # Filename already given in format
            filename = os.path.join(path, format)
        else:
            args = collections.defaultdict(str); args.update(chat)
            filename = "%s.%s" % (conf.ExportChatTemplate % args, format)
            filename = os.path.join(path, util.safe_filename(filename))
            filename = util.unique_path(filename)
        return filename
    main.logstatus("Exporting %s from %s %sto %s.",
                   util.plural("chat", chats), db.filename,
                   "" if len(format) > 4 else "as %s " % format.upper(),
                   format if len(format) > 4 else path)

    if format.lower().endswith(".xlsx"):
        filename = make_filename(chats[0])
        count = export_chats_xlsx(chats, filename, db, messages, skip, progress)
        files.append(filename)
    else:
        if not os.path.exists(path):
            os.makedirs(path)
        export_func = (export_chats_xlsx if format.lower().endswith("xlsx")
                       else export_chat_csv if format.lower().endswith("csv")
                       else export_chat_template)
        message_count = 0
        for chat in chats:
            if skip and not messages and not chat["message_count"]:
                main.log("Skipping exporting %s: no messages.",
                         chat["title_long_lc"])
                if progress: progress(message_count)
                continue # continue for chat in chats
            main.status("Exporting %s.", chat["title_long_lc"])
            if progress: progress(message_count)
            filename = make_filename(chat)
            msgs = messages or db.get_messages(chat)
            chatarg = [chat] if "xlsx" == format.lower() else chat
            export_func(chatarg, filename, db, msgs)
            message_count += chat["message_count"]
            files.append(filename)
        count = len(files)
    return (files, count)


def export_chats_xlsx(chats, filename, db, messages=None, skip=True, progress=None):
    """
    Exports the chats to a single XLSX file with chats on separate worksheets.

    @param   chats     list of chat data dicts, as returned from SkypeDatabase
    @param   filename  full path and filename of resulting file
    @param   db        SkypeDatabase instance
    @param   messages  list of messages to export if a single chat
    @param   skip      whether to skip chats with no messages
    @param   progress  function called before exporting each chat, with the
                       number of messages exported so far
    @return            number of chats exported
    """
    count, style = 0, {0: "timestamp", 2: "wrap", 3: "hidden"}

    writer = xlsx_writer(filename, autowrap=[2])
    message_count = 0
    for chat in chats:
        if skip and not messages and not chat["message_count"]:
            main.log("Skipping exporting %s: no messages.",
                     chat["title_long_lc"])
            continue # continue for chat in chats
        main.status("Exporting %s.", chat["title_long_lc"])
        if progress: progress(message_count)
        parser = skypedata.MessageParser(db, chat=chat, stats=False)
        writer.add_sheet(chat["title"])
        writer.set_header(True)
        writer.writerow(["Time", "Author", "Message", "Skype Name"],
                        {3: "boldhidden"})
        writer.set_header(False)
        msgs = messages or db.get_messages(chat)
        for i, m in enumerate(msgs):
            text = parser.parse(m, output={"format": "text"})
            try:
                text = text.decode("utf-8")
            except UnicodeError: pass
            values = [m["datetime"], m["from_dispname"], text, m["author"]]
            style[1] = "local" if db.id == m["author"] else "remote"
            writer.writerow(values, style)
        message_count += chat["message_count"]
        count += 1
    writer.close()
    return count


def export_chat_template(chat, filename, db, messages):
    """
    Exports the chat messages to file using templates.

    @param   chat      chat data dict, as returned from SkypeDatabase
    @param   filename  full path and filename of resulting file, file extension
                       .html|.txt determines file format
    @param   db        SkypeDatabase instance
    @param   messages  list of message data dicts
    """
    tmpfile, tmpname = None, None # Temporary file for exported messages
    try:
        is_html = filename.lower().endswith(".html")
        parser = skypedata.MessageParser(db, chat=chat, stats=is_html)
        namespace = {"db": db, "chat": chat, "messages": messages,
                     "parser": parser}

        if is_html:
            # Collect chat and participant images.
            namespace.update({"participants": [], "chat_picture_size": None,
                              "chat_picture_raw": None, })
            if chat["meta_picture"]:
                raw = skypedata.fix_image_raw(chat["meta_picture"])
                imgparser = ImageFile.Parser(); imgparser.feed(raw)
                img = imgparser.close()
                namespace.update(chat_picture_size=img.size,
                                 chat_picture_raw=raw)
            for p in chat["participants"]:
                contact = p["contact"].copy()
                namespace["participants"].append(contact)
                contact.update(avatar_raw_small="", avatar_raw_large="")
                bmp = contact.get("avatar_bitmap")
                raw = contact.get("avatar_raw_small")
                raw_large = contact.get("avatar_raw_large")
                if not raw and not bmp:
                    raw = skypedata.get_avatar_raw(contact, conf.AvatarImageSize)
                    if raw:
                        p["contact"]["avatar_raw_small"] = raw
                raw = bmp and util.wx_bitmap_to_raw(bmp) or raw
                if raw:
                    if not raw_large:
                        size_large = conf.AvatarImageLargeSize
                        raw_large = skypedata.get_avatar_raw(contact, size_large)
                        p["contact"]["avatar_raw_large"] = raw_large
                    contact["avatar_raw_small"] = raw
                    contact["avatar_raw_large"] = raw_large

        # As HTML and TXT contain statistics in their headers before
        # messages, write out all messages to a temporary file first,
        # statistics will be available for the main file after parsing.
        # Cannot keep all messages in memory at once - very large chats
        # (500,000+ messages) can take gigabytes.
        tmpname = util.unique_path("%s.messages" % filename)
        tmpfile = open(tmpname, "w+")
        mtemplate = templates.CHAT_MESSAGES_HTML if is_html \
                    else templates.CHAT_MESSAGES_TXT
        step.Template(mtemplate, strip=False).stream(tmpfile, namespace)

        namespace["stats"] = stats = parser.get_collected_stats()
        namespace.update({
            "date1": stats["startdate"].strftime("%d.%m.%Y")
                     if stats.get("startdate") else "",
            "date2": stats["enddate"].strftime("%d.%m.%Y")
                     if stats.get("enddate") else "",
            "emoticons_used": list(filter(lambda e: hasattr(emoticons, e),
                                     parser.emoticons_unique)),
            "message_count":  stats.get("messages", 0),
        })

        tmpfile.flush(), tmpfile.seek(0)
        namespace["message_buffer"] = iter(lambda: tmpfile.read(65536), "")
        template = templates.CHAT_HTML if is_html else templates.CHAT_TXT
        with open(filename, "w") as f:
            step.Template(template, strip=False).stream(f, namespace)
    finally:
        if tmpfile: util.try_until(tmpfile.close)
        if tmpname: util.try_until(lambda: os.unlink(tmpname))


def export_chat_csv(chat, filename, db, messages):
    """
    Exports the chat messages to a CSV data file.

    @param   chat      chat data dict, as returned from SkypeDatabase
    @param   filename  full path and filename of resulting file
    @param   db        SkypeDatabase instance
    @param   messages  list of message data dicts
    """
    parser = skypedata.MessageParser(db, chat=chat, stats=False)
    dialect = csv.excel
    # Delimiter for Excel dialect "," is actually not used by Excel.
    # Default linefeed "\r\n" would cause another "\r" to be written.
    dialect.delimiter, dialect.lineterminator = ";", "\r"
    with open(filename, "wb") as f:
        writer = csv.writer(f, dialect)
        writer.writerow(["Time", "Author", "Message"])
        for i, m in enumerate(messages):
            text = parser.parse(m, output={"format": "text"})
            try:
                text = text.decode("utf-8")
            except UnicodeError: pass
            values = [m["datetime"].strftime("%Y-%m-%d %H:%M:%S"),
                      m["from_dispname"], text ]
            values = [v.encode("latin1", "replace") for v in values]
            writer.writerow(values)


def export_grid(grid, filename, title, db, sql_query="", table=""):
    """
    Exports the current contents of the specified wx.Grid to file.

    @param   grid       a wx.Grid object
    @param   filename   full path and filename of resulting file, file extension
                        .html|.csv|.sql|.xslx determines file format
    @param   title      title used in HTML
    @param   db         SkypeDatabase instance
    @param   sql_query  the SQL query producing the grid contents, if any
    @param   table      name of the table producing the grid contents, if any
    """
    result = False
    f = None
    is_html = filename.lower().endswith(".html")
    is_csv  = filename.lower().endswith(".csv")
    is_sql  = filename.lower().endswith(".sql")
    is_xlsx = filename.lower().endswith(".xlsx")
    try:
        with open(filename, "w") as f:
            columns = [c["name"] for c in grid.Table.columns]

            def iter_rows():
                """Iterating row generator."""
                row, index = grid.Table.GetRow(0), 0
                while row:
                    yield row
                    index += 1; row = grid.Table.GetRow(index)

            if is_csv or is_xlsx:
                if is_csv:
                    dialect = csv.excel
                    dialect.delimiter, dialect.lineterminator = ";", "\r"
                    writer = csv.writer(f, dialect)
                    if sql_query:
                        flat = sql_query.replace("\r", " ").replace("\n", " ")
                        sql_query = flat.encode("latin1", "replace")
                    header = [c.encode("latin1", "replace") for c in columns]
                else:
                    writer = xlsx_writer(filename, table or "SQL Query")
                    writer.set_header(True)
                    header = columns
                if sql_query:
                    a = [[sql_query]] + (["bold", 0, False] if is_xlsx else [])
                    writer.writerow(*a)
                writer.writerow(*([header, "bold"] if is_xlsx else [header]))
                writer.set_header(False) if is_xlsx else 0
                for row in iter_rows():
                    values = []
                    for col in columns:
                        val = "" if row[col] is None else row[col]
                        if is_csv:
                            val = val if isinstance(val, unicode) else str(val)
                            val = val.encode("latin1", "replace")
                        values.append(val)
                    writer.writerow(values)
                writer.close() if is_xlsx else 0
            else:
                namespace = {
                    "db_filename": db.filename,
                    "title":       title,
                    "columns":     columns,
                    "row_count":   grid.NumberRows,
                    "rows":        iter_rows(),
                    "sql":         sql_query,
                    "table":       table,
                    "app":         conf.Title,
                }
                if is_sql and table:
                    # Add CREATE TABLE statement.
                    create_sql = db.tables[table.lower()]["sql"] + ";"
                    re_sql = re.compile("^(CREATE\s+TABLE\s+)", re.IGNORECASE)
                    replacer = lambda m: ("%sIF NOT EXISTS " % m.group(1))
                    namespace["create_sql"] = re_sql.sub(replacer, create_sql)

                template = templates.GRID_HTML if is_html else templates.SQL_TXT
                step.Template(template, strip=False).stream(f, namespace)

            result = True
    finally:
        if f: util.try_until(f.close)
    return result



class xlsx_writer(object):
    """Convenience wrapper for xslxwriter, with csv.Writer-like interface."""
    COL_MAXWIDTH   = 100 # In Excel units, 1 == width of "0" in standard font
    ROW_MAXNUM     = 1048576 # Maximum per worksheet
    FMT_DEFAULT    = {"bg_color": "white", "valign": "top"}
    FMT_BOLD       = dict(FMT_DEFAULT, **{"bold": True})
    FMT_WRAP       = dict(FMT_DEFAULT, **{"text_wrap": True})
    FMT_LOCAL      = dict(FMT_DEFAULT, **{"font_color": "#999999"})
    FMT_REMOTE     = dict(FMT_DEFAULT, **{"font_color": "#3399FF"})
    FMT_HIDDEN     = dict(FMT_DEFAULT, **{"font_color": "white"})
    FMT_BOLDHIDDEN = dict(FMT_DEFAULT, **{"font_color": "white", "bold": True})
    FMT_TIMESTAMP  = dict(FMT_DEFAULT, **{"font_color": "#999999",
                                          "align": "left",
                                          "num_format": "yyyy-mm-dd HH:MM", })

    def __init__(self, filename, sheetname=None, autowrap=[]):
        """
        @param   sheetname  title of the first sheet to create, if any
        @param   autowrap   a list of column indices that will get their width
                            set to COL_MAXWIDTH and their contents wrapped
        """
        self._workbook = xlsxwriter.Workbook(filename,
            {"constant_memory": True, "strings_to_formulas": False})
        self._sheet      = None # Current xlsxwriter.Worksheet, if any
        self._sheets     = {} # {lowercase sheet name: xlsxwriter.Worksheet, }
        self._sheetnames = {} # {xlsxwriter.Worksheet: original given name, }
        self._headers    = {} # {sheet name: [[values, style, merge_cols], ], }
        self._col_widths = {} # {sheet name: {col index: width in Excel units}}
        self._autowrap   = [c for c in autowrap] # [column index to autowrap, ]
        self._format     = None

        # Worksheet style formats
        format_default = self._workbook.add_format(self.FMT_DEFAULT)
        self._formats  = collections.defaultdict(lambda: format_default)
        for t in ["bold", "wrap", "local", "remote",
                  "hidden", "boldhidden", "timestamp"]:
            f = getattr(self, "FMT_%s" % t.upper(), self.FMT_DEFAULT)
            self._formats[t] = self._workbook.add_format(f)

        # For calculating column widths
        self._fonts = collections.defaultdict(lambda: FONT_XLSX)
        self._fonts["bold"] = FONT_XLSX_BOLD
        unit_width_default = self._fonts[None].getsize("0")[0]
        self._unit_widths = collections.defaultdict(lambda: unit_width_default)
        self._unit_widths["bold"] = self._fonts["bold"].getsize("0")[0]

        if sheetname: # Create default sheet
            self.add_sheet(sheetname)


    def add_sheet(self, name=None):
        """Adds a new worksheet. Name will be changed if invalid/existing."""
        if self._sheet and hasattr(self._sheet, "_opt_close"):
            self._sheet._opt_close() # Close file handle to not hit ulimit
        safename = None
        if name:
            # Max length 31, no []:\\?/*\x00\x03, cannot start/end with '.
            stripped = name.strip("'")
            safename = re.sub(r"[\[\]\:\\\?\/\*\x00\x03]", " ", stripped)
            safename = safename[:29] + ".." if len(safename) > 31 else safename
            # Ensure unique name, appending (counter) if necessary
            base, counter = safename, 2
            while safename.lower() in self._sheets:
                suffix = " (%s)" % (counter)
                safename = base + suffix
                if len(safename) > 31:
                    safename = "%s..%s" % (base[:31 - len(suffix) - 2], suffix)
                counter += 1
        sheet = self._workbook.add_worksheet(safename)
        self._sheets[sheet.name.lower()] = self._sheet = sheet
        self._sheetnames[sheet] = name or sheet.name
        self._col_widths[sheet.name] = collections.defaultdict(lambda: 0)
        for c in self._autowrap:
            sheet.set_column(c, c, self.COL_MAXWIDTH, self._formats[None])
        self._row = 0

        # Worksheet write functions for different data types
        self._writers = collections.defaultdict(lambda: sheet.write)
        self._writers[datetime.datetime] = sheet.write_datetime
        # Avoid using write_url: URLs are very limited in Excel (max len 256)
        self._writers[str] = self._writers[unicode] = sheet.write_string


    def set_header(self, start):
        """Starts or stops header section: bold lines split from the rest."""
        self._format = "bold" if start else None
        if start:
            self._headers[self._sheet.name] = []
        else:
            self._sheet.freeze_panes(self._row, 0)


    def writerow(self, values, style={}, merge_cols=0, autowidth=True):
        """
        Writes to the current row from first column, steps to next row.
        If current sheet is full, starts a new one.

        @param   style       format name to apply for all columns, or a dict
                             mapping column indices to format names
        @param   merge_cols  how many columns to merge (0 for none)
        @param   autowidth   are the values used to auto-size column max width
        """
        if self._row >= self.ROW_MAXNUM: # Sheet full: start a new one
            name_former = self._sheet.name
            self.add_sheet(self._sheetnames[self._sheet])
            if name_former in self._headers: # Write same header
                self.set_header(True)
                [self.writerow(*x) for x in self._headers[name_former]]
                self.set_header(False)
        if "bold" == self._format:
            self._headers[self._sheet.name] += [(values, style, merge_cols)]
        if merge_cols:
            f = self._formats[self._format]
            self._sheet.merge_range(self._row, 0, self._row, merge_cols, "", f)
            values = values[0] if values else []
        for c, v in enumerate(values):
            writefunc = self._writers[type(v)]
            fmt_name = style if isinstance(style, basestring) \
                       else style.get(c, self._format)
            writefunc(self._row, c, v, self._formats[fmt_name])
            if (merge_cols or not autowidth or "wrap" == fmt_name
            or c in self._autowrap):
                continue # continue for c, v in enumerate(Values)

            # Calculate and update maximum written column width
            strval = v if isinstance(v, basestring) \
                     else v.strftime("%Y-%m-%d %H:%M") \
                     if isinstance(v, datetime.datetime) else str(v)
            pixels = max(self._fonts[fmt_name].getsize(x)[0]
                         for x in strval.split("\n"))
            width = float(pixels) / self._unit_widths[fmt_name] + 1
            if not merge_cols and width > self._col_widths[self._sheet.name][c]:
                self._col_widths[self._sheet.name][c] = width
        self._row += 1


    def close(self):
        """Finalizes formatting and saves file content."""

        # Auto-size columns with calculated widths
        for sheet in self._workbook.worksheets():
            c = -1
            for c, w in sorted(self._col_widths[sheet.name].items()):
                w = min(w, self.COL_MAXWIDTH)
                sheet.set_column(c, c, w, self._formats[None])
            sheet.set_column(c + 1, 50, cell_format=self._formats[None])
        self._workbook.set_properties({"comments": "Exported with %s on %s." %
            (conf.Title, datetime.datetime.now().strftime("%d.%m.%Y %H:%M"))})
        self._workbook.close()

########NEW FILE########
__FILENAME__ = guibase
# -*- coding: utf-8 -*-
"""
GUI frame template:
- auto-accelerated control shortcuts, "&OK" will turn Alt-O into shortcut
- Python console window, initially hidden,
  with auto-saved command history kept in conf.ConsoleHistoryCommands
- wx widget inspector window, initially hidden
- option for log panel, handles logging messages via wx events

@author      Erki Suurjaak
@created     03.04.2012
@modified    27.04.2014
"""
import os
import wx
import wx.lib.inspection
import wx.lib.newevent
import wx.py

import conf
import wx_accel


"""Custom application event for adding to log."""
LogEvent,    EVT_LOG =    wx.lib.newevent.NewEvent()
"""Custom application event for setting main window status."""
StatusEvent, EVT_STATUS = wx.lib.newevent.NewEvent()


class TemplateFrameMixIn(wx_accel.AutoAcceleratorMixIn):
    """Application main window."""

    def __init__(self):
        wx_accel.AutoAcceleratorMixIn.__init__(self)

        conf.load()

        self.Bind(EVT_LOG,      self.on_log_message)
        self.Bind(EVT_STATUS,   self.on_set_status)
        self.Bind(wx.EVT_CLOSE, self.on_exit)

        self.console_commands = set() # Commands from run_console()
        self.frame_console = wx.py.shell.ShellFrame(parent=self,
            title=u"%s Console" % conf.Title, size=conf.ConsoleSize)
        self.frame_console.Bind(wx.EVT_CLOSE, self.on_showhide_console)
        self.frame_console_shown = False # Init flag
        console = self.console = self.frame_console.shell
        if not isinstance(conf.ConsoleHistoryCommands, list):
            conf.ConsoleHistoryCommands = [] 
        for cmd in conf.ConsoleHistoryCommands:
            console.addHistory(cmd)
        console.Bind(wx.EVT_KEY_DOWN, self.on_keydown_console)
        self.widget_inspector = wx.lib.inspection.InspectionTool()

        self.CreateStatusBar()


    def create_log_panel(self, parent):
        """Creates and returns the log output panel."""
        panel = wx.Panel(parent)
        sizer = panel.Sizer = wx.BoxSizer(wx.VERTICAL)

        button_clear = wx.Button(parent=panel, label="C&lear log",
                                 size=(100, -1))
        button_clear.Bind(wx.EVT_BUTTON, lambda event: self.log.Clear())
        edit_log = self.log = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        edit_log.SetEditable(False)
        # Read-only controls tend to be made grey by default
        getcolour = wx.SystemSettings.GetColour
        edit_log.BackgroundColour = getcolour(wx.SYS_COLOUR_WINDOW)
        edit_log.ForegroundColour = getcolour(wx.SYS_COLOUR_GRAYTEXT)

        sizer.Add(button_clear, border=5, flag=wx.ALIGN_RIGHT | wx.TOP | 
                  wx.RIGHT)
        sizer.Add(edit_log, border=5, proportion=1, flag=wx.GROW | wx.ALL)
        return panel


    def create_menu(self):
        """Creates the program menu."""
        menu = wx.MenuBar()
        menu_file = wx.Menu()
        menu.Insert(0, menu_file, "&File")
        menu_recent = self.menu_recent = wx.Menu()
        menu_file.AppendMenu(id=wx.NewId(), text="&Recent files",
            submenu=menu_recent, help="Recently opened files.")
        menu_file.AppendSeparator()
        menu_console = self.menu_console = menu_file.Append(
            id=wx.NewId(), kind=wx.ITEM_CHECK, text="Show &console\tCtrl-E",
            help="Show/hide a Python shell environment window")
        menu_inspect = self.menu_inspect = menu_file.Append(
            id=wx.NewId(), kind=wx.ITEM_CHECK, text="Show &widget inspector",
            help="Show/hide the widget inspector")

        self.file_history = wx.FileHistory(conf.MaxRecentFiles)
        self.file_history.UseMenu(menu_recent)
        for f in conf.RecentFiles[::-1]: # Backwards - FileHistory is a stack
            os.path.exists(f) and self.file_history.AddFileToHistory(f)
        wx.EVT_MENU_RANGE(self, wx.ID_FILE1, wx.ID_FILE9, self.on_recent_file)
        menu_file.AppendSeparator()
        m_exit = menu_file.Append(-1, "E&xit\tAlt-X", "Exit")

        self.Bind(wx.EVT_MENU, self.on_showhide_console, menu_console)
        self.Bind(wx.EVT_MENU, self.on_open_widget_inspector, menu_inspect)
        self.Bind(wx.EVT_MENU, self.on_exit, m_exit)
        self.SetMenuBar(menu)


    def on_exit(self, event):
        """Handler on application exit, saves configuration."""
        do_exit = True
        if do_exit:
            conf.save()
            self.Destroy()


    def on_keydown_console(self, event):
        """Handler for keydown in console, saves entered command in history."""
        event.Skip()
        if (wx.WXK_RETURN == event.KeyCode and not event.ShiftDown()
        and self.console.history):
            # Defer saving until command is inserted into console history
            wx.CallAfter(self.save_last_command)


    def run_console(self, command):
        """
        Runs the command in the Python console. Will not be saved to console
        commands history.
        """
        self.console.run(command)
        self.console_commands.add(command)


    def save_last_command(self):
        """
        Saves the last console command in conf, minus the commands given via
        run_console().
        """
        h = [x for x in self.console.history if x not in self.console_commands]
        history = h[:conf.MaxConsoleHistory][::-1]
        if history != conf.ConsoleHistoryCommands:
            conf.ConsoleHistoryCommands[:] = history
            conf.save()


    def on_set_status(self, event):
        """Event handler for adding a message to the log control."""
        self.SetStatusText(event.text)


    def on_log_message(self, event):
        """Event handler for adding a message to the log control."""
        if hasattr(self, "log") and getattr(conf, "LogEnabled", False):
            text = event.text
            try:
                self.log.AppendText(text + "\n")
            except Exception:
                try:
                    self.log.AppendText(text.decode("utf-8", "replace") + "\n")
                except Exception as e:
                    print("Exception %s: %s in on_log_message" %
                          (e.__class__.__name__, e))


    def on_showhide_console(self, event):
        """Toggles the console shown/hidden."""
        show = not self.frame_console.IsShown()
        if show:
            if not self.frame_console_shown:
                # First showing of console, set height to a fraction of main
                # form, and position it immediately under the main form, or
                # covering its bottom if no room.
                self.frame_console_shown = True
                size = wx.Size(self.Size.width, max(200, self.Size.height / 3))
                self.frame_console.Size = size
                display = wx.GetDisplaySize()
                y = 0
                min_bottom_space = 130 # Leave space for autocomplete dropdown
                if size.height > display.height - self.Size.height \
                - self.Position.y - min_bottom_space:
                    y = display.height - self.Size.height - self.Position.y \
                        - size.height - min_bottom_space
                self.frame_console.Position = (
                    self.Position.x, self.Position.y + self.Size.height + y
                )
            # Scroll to the last line
            self.console.ScrollToLine(self.console.LineCount + 3 - (
                self.console.Size.height / self.console.GetTextExtent(" ")[1]
            ))
        self.frame_console.Show(show)
        if hasattr(self, "menu_console"):
            self.menu_console.Check(show)


    def on_open_widget_inspector(self, event):
        """Toggles the widget inspection tool shown/hidden."""
        visible = not (self.widget_inspector.initialized
                       and self.widget_inspector._frame)
        if visible:
            self.widget_inspector.Init()
            self.widget_inspector.Show(selectObj=self, refreshTree=True)
            self.widget_inspector._frame.Bind(wx.EVT_CLOSE, lambda e: e.Skip())
        else:
            self.widget_inspector._frame.Close()
        if hasattr(self, "menu_inspect"):
            self.menu_inspect.Check(visible)


    def on_recent_file(self, event):
        """Handler for clicking an entry in Recent Files menu."""
        filename = self.file_history.GetHistoryFile(event.GetId() - wx.ID_FILE1)
        self.open_file(filename)

########NEW FILE########
__FILENAME__ = images
"""
Contains embedded image and icon resources for Skyperious. Auto-generated.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     07.02.2012
@modified    20.04.2014
------------------------------------------------------------------------------
"""
try:
    import wx
    from wx.lib.embeddedimage import PyEmbeddedImage
except ImportError:
    class PyEmbeddedImage(object):
        """Data stand-in for wx.lib.embeddedimage.PyEmbeddedImage."""
        def __init__(self, data):
            self.data = data


"""Returns the application icon bundle, for several sizes and colour depths."""
def get_appicons():
    icons = wx.IconBundle()
    [icons.AddIcon(i.Icon) for i in [
        Icon16x16_32bit, Icon16x16_8bit, Icon24x24_32bit, Icon24x24_8bit,
        Icon32x32_32bit, Icon32x32_8bit, Icon48x48_32bit, Icon48x48_8bit
    ]]
    return icons


"""Skyperious application 16x16 icon, 32-bit colour."""
Icon16x16_32bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAB3RJTUUH3QMaFiYCLwtVsAAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAEhSURBVHjaY/z//z8DKYAF"
    "mXP07Z/WWz9vf/mHLJgkz1qpxgHnMsJtePztn9nBLy9+oltoIsB8yp6HkRHKZYJLrHj6C1M1"
    "EJz98PftL4Q4wkkvfqCofuzOK8PJhKkfIWQuxIwsUXntx5c///Fp8BZnNeRHcFc++T37wa/f"
    "//7j1MDNwjjTgFOYDeq73/8ZWm7+3PHyD04NQGAqyDLfiFOIFarn3e//See/n/3wB6cGIPAQ"
    "Y6nTYGeHCb/59T/r4o8ff//j1MDKxJgizxYjywoXOfX+73Ykh2EJOKBn6tQ5kEWOvEVogMYD"
    "MLr77v4sufKDARuQ4GBEtwEY834SLFhVy3AwRsqwodsABMrczA4izE++owS8Pj9TmSo7cpQz"
    "kpq8AZv/aJiCXJ+bAAAAAElFTkSuQmCC"
)


"""Skyperious application 16x16 icon, 8-bit colour."""
Icon16x16_8bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAB3RJTUUH3QMaFiYSMrxF1AAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAACEUExURf////3+/0DD8yS6"
    "8lPJ9Mnu+9rz/ACv8By38eP2/f7+/4zb+Ira9+H1/XLS9vT7/mPO9a7l+vr9/pDc+Aex8DbA"
    "8/f8/rLn+hK08RS18czv+8ru+xO18bLm+jG+8gWw8I7b+Knk+VzM9fP7/gGv8Ov4/uL1/Ri2"
    "8TS/88Ts+0nG9IbZ91Ok98QAAABxSURBVHjabc9HEoAwCAVQe+y9917vfz+D4iQLWeW/DAwI"
    "wl8dpwx1fXndyFO7iWC/mcwLggvJ4EYMAOPEwGspdH3IpKqp5A3XlOVUipJBGMVUkpQb48Pg"
    "gGtyANz3bVq4GLHxV8Osf8uJ0nObov5efgN2BQW1nHoFYgAAAABJRU5ErkJggg=="
)


"""Skyperious application 24x24 icon, 32-bit colour."""
Icon24x24_32bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABtklEQVRIx9WVT08TURTFf+/N"
    "9N9QiHFDamoEAyysKxbExC/AsomJm66JYaMS+QpESfgEJLBw5wZISNi5cEfKwhg1YnVhjJRI"
    "SIgdoe10Zq5rOn2lw6QL73LOyz33vXPPGUTkmQyvnisREYZYmiGXbQK8EKpnPi9rHnu/O8YG"
    "TybSrN3PkrdVPIL9M5+F901qf8O+E35qBJy0xUhgfKL1H96VzQE+NkKO2xL/iXbqfs/vD25a"
    "ZPTlaU9aIWDFIwgMy/V61mE6r5NvUWms90QrtTYXgSQneHo3jWNFhXtz1GHlq8f5gCRGgvnx"
    "FOWCTfdytAJh86fHtkGj7jI6WYAvbsDjgyafG0EEL+Y0bx+OMHOFHkZUAfdGLbbmHIq56LFf"
    "zZBH1QsO3RBJEhUzec1qKUshGz166Aa8+tbitI8PBtq3csFmcTLNSJcgvsBW3efdqZ+MwLEU"
    "y1MZKsVUBHN9Ye17O3ma5ix4MZXpiX34E8SLilCgXD3H7QpRk8EspeIRaAVjlmL3uDPQ7cq3"
    "7OsZTQ3QvDSqWZxMXyeLNHec/hJVbqfYmHWYu2HHd/J/80/WwNIQ+y/9A4Hd7fikpHoZAAAA"
    "AElFTkSuQmCC"
)


"""Skyperious application 24x24 icon, 8-bit colour."""
Icon24x24_8bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABt0lEQVRIx9WWP2vbUBTFf0+S"
    "/8lOCF2Ci0vr4GSoO2UIhXyBjIZCl8yleOnSfgXTBvwJAsmQLUtaKGTLkK04QwhJaeJ2KCFN"
    "qDGYWvU/WdLL1KGWn21FeMgddR73XL1zz5EEgJRSMoUSQggxreb/SmPKZagA24NKw+F91Wb/"
    "d1/Z4PWTKOVncVKGCEbwpeHw6rhD9a83csKzpkutJ5UEyiva/GmPbQ5w2vS46cngV/Tp2hn6"
    "/PkDnZj2/7S1rgfowQhcxXLtLJssprTwW5SfHT5Rqdqj7crwBG8Wopi6X7jdX31KFzatCUmU"
    "BGvzEQppg8Hl6LqS7UubjwqNfG5WOVkC3yyXl0cdvjZdH55JaBysJlkao4cSFcDTGZ29FZNM"
    "wn/squPxotLm3PKQYaJiKaWxkY+TjvuPnlsuH753qY/wwUT7VkgbFLNRkgOCOBL2rh0O6044"
    "AlMXvMvFWM9EfJjlSMo/euHTNKHD21xsKHbyxw0WFZ6EQqWFNRCiKoPpQgQj0ATM6oLPN/2J"
    "3q7w0Lib0cQEzfMzGsVs9C5ZpPHYHC3R+qMIW8smK3NGcCffm2+ymPZvyy1gEpaViewcZQAA"
    "AABJRU5ErkJggg=="
)


"""Skyperious application 32x32 icon, 32-bit colour."""
Icon32x32_32bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlw"
    "SFlzAAALEQAACxEBf2RfkQAAAAd0SU1FB90DGhY0Alf/JWMAAAAadEVYdFNvZnR3YXJlAFBh"
    "aW50Lk5FVCB2My41LjEwMPRyoQAAAYFJREFUWEftlr1KxFAUhG9h4QNYWFpY+gg+hoWFhYWP"
    "ZOFDCIog/qAgYiOuYmFhoWih4B8Ys8m6utk97gQWUuxmJoeVNHsgVW7O+e5kcifBzEL/qqtC"
    "ncPzTU8AZAVu4swWTxMLW5F0PaZdyVcSwMbDjzS0CIdnlKIA11FWeThAls5TZT434UojdQFM"
    "70SW9TgDVWBm98sFABXOPjJKQAGY6W6bmtlGkVAApoCyyzIZKADMxFR4+varQAFO3jsUYOG4"
    "aW0nAwWAfIoKq5ctarhhCySApP89zR3EVIn1e+3wKYJIAHjgLulSAHjl6K1TSQkZAF3RnBkS"
    "99UccMWxkgvzh7HhtSlVSYFBw7WrFlUCa5RyAWBzSjQjyFi5AND0pd0zBE6ZJxBkrNwAaNz4"
    "LI9qHOOs/hUA6rAqBcC7nt3zx/FYFFAcP8oHY/HA/qt2+AyDwI8sK+oBpNzUtvYnXITYfP5l"
    "s/P7FACLlDQcDF++SPPcUEsCUJt51k0AoECdKoQ/7vOGvN+DWQIAAAAASUVORK5CYII="
)


"""Skyperious application 32x32 icon, 8-bit colour."""
Icon32x32_8bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAwBQ"
    "TFRFAAAAAK/wBLDwCLLwFLXxGLfxILnyJLryLL3zPML0VMn1WMv1XMz1YM32ZM72lN35mN/5"
    "rOX6uOn7vOr7wOv7xOz8zO/80PD81PL82PP93PT94PX95Pf96Pj+9Pz++P3//v7/AAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAA6f5MRgAAAQB0Uk5T////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////AFP3ByUAAAAJcEhZcwAACxEAAAsRAX9kX5EAAAAHdElNRQfdAxoWMzY5"
    "CkcRAAAAGnRFWHRTb2Z0d2FyZQBQYWludC5ORVQgdjMuNS4xMDD0cqEAAADDSURBVDhPrZNb"
    "FoIwDAWJ4AsRUVQQFbr/TeLxQG4TwuOH/tEMN20GgtbNrjaYrzu3KlAeCeuNzr5F5stEmQUK"
    "WafYAokCQgtECqAHEzgD11+DwQDgBLzagwBijvjoCAB3Bg6NIvwcEHGeAOodZ1wkIWRVuGgu"
    "CGkzH1GhdUPHvh6R9d9KOSOdAByMF2bU3cY37DOSCcA9eyBaAsgAW63bJuACHWjPcNMJpWnR"
    "bCRxHZkDbBKdKi9Duhh8bN3jCsDS7/8DqHNjgvHE59IAAAAASUVORK5CYII="
)


"""Skyperious application 48x48 icon, 32-bit colour."""
Icon48x48_32bit = PyEmbeddedImage(
    "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"
    "D5GjATh9KtVTAAAAAElFTkSuQmCC"
)


"""Skyperious application 48x48 icon, 8-bit colour."""
Icon48x48_8bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAAEX2zkjAAAAB3RJTUUH3QYHESIrZgkebwAA"
    "AAlwSFlzAAAK8AAACvABQqw0mAAAAARnQU1BAACxjwv8YQUAAAC0UExURQAAAP////7+/v3+"
    "/v/+/2TO9QCv8ASw8CC58ii88kjG9HDS9qbj+fL6/Ri38Qyz8XTT9+/6/svv/Nfy/X/X9+P2"
    "/TjB80TE9Of3/sPs+5/h+WDN9lTJ9fv+/3zW9/P7/o/c+Kvl+giy8Lvq+3jV9yS68pfe+Sy9"
    "8/f8/zzC9FjL9WzR9tPx/N/1/b/r+6fj+ovb+HDS9xC08TC+82TO9rfo+0DD9IfZ+Mft/FDI"
    "9dv0/TS/88xqrdsAAAABdFJOUwBA5thmAAABrUlEQVR42pWUDVuCQAzHOayJViBqpSZh9iaa"
    "ZvZqff/vFdxxsHE3wT2Pwu63P9ttB44jMkv/AUBe3qS3AHkRt4CYikxAsuxfMRUJ3fQy1J74"
    "9UBHZPLSybwXoR3Rr4Z1lNNKfydlWJ5cOkslKTVftjx5UEkKp/DUo1PHK/MwVct7H5XTqtZG"
    "TIMAtP0QAMgswPKoqSKvZg79sNgAYkRSkHLvFAkNkI4caLtouWOiKJZ7ZES2ljjMcr1g9teW"
    "OfZ0H+NqDy3lEvCBwCcGbQTeMdjJpYU5jyE7KDBIDiYKBOYEV8XJrw4qUWRpjvZRkSdztAE5"
    "Dri7CsxNQI4dBqEJptzZHXEAz+OSAF8vByHZh+vmbnEj+FPCvoSc4Lh4I/V6D1XbHRAMArDY"
    "NyvYgNXmC07wbBfAAyfAQduwXI84QYIEqyZdWpNCtg3auiZdam8azGFIkvijWoGIyNmFJKoT"
    "CBHT7vZqBenAfbKVca1AiHv8AeIHh22GFbMGAhHjbtkFkfWsohfayDDh4m+4kq7s8dfspvu2"
    "cG/AttV1T3H/vU737PyiftKHzTnyO+M4/8CIIdP02kirAAAAAElFTkSuQmCC"
)


"""Skyperious application 64x64 icon, 32-bit colour."""
Icon64x64_32bit = PyEmbeddedImage(
    "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"
    "RK5CYII="
)


"""Skyperious application 64x64 icon, 8-bit colour."""
Icon64x64_8bit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAAHqsLF6AAAAB3RJTUUH3QYHES0v5vzGuQAA"
    "AAlwSFlzAAAK8AAACvABQqw0mAAAAARnQU1BAACxjwv8YQUAAADDUExURQAAAP////7+///+"
    "//7///3+/v7+/jzC9ACv8Bi38SC58jS/80zH9GzR9pfe+dfy/e/6/gSw8Ci88o/c+Pf8/6Pi"
    "+hy48rfo+1zM9ZPd+fv+/xC08cPs+wyz8d/1/XjV91TJ9dv0/YPY+ETE9PP7/giy8FDI9RS1"
    "8eP2/VjL9XDS97vq+6vl+r/r+9Px/CS68uv5/jjB8+f3/mjQ9pvg+afj+rPn+4fZ+EDD9Ivb"
    "+GDN9kjG9Cy988/w/J/h+a/m+nTT9/c0HisAAAABdFJOUwBA5thmAAACTklEQVR42rWWaVvi"
    "MBCAO147RV0sLB6VFg8QZcUDvN1d/f+/SkqbJpnJNOTx2flCmbx5m5mmgSiCMopPRFxeoLoY"
    "FZ/VUFJeAGX2EDvVUMGWQx82s9RUHhA8qIfMqNgyrIRFAOqUchSZXTMBzGElrNtGzd9tR53I"
    "aULdpKsSb4sv78zRNxPtIpOatZyx4jrWXZSmJVZ75GzhInKS+GVJG+p3taOMT9ThAEZoRocB"
    "O2gHAzI0l+pYw9DqumuRaW2fSVU8OWogjTlRxL4A6LXqxbJG0tsoYIRCIyI6s4qEAYfW+BFf"
    "5KaxDvPa97gjD+AbX2FDGY2ajXUR9w5g4N4vNXCKHiCxgX8MIJ2OfQCKgFimAlIJyCSFAmYK"
    "yKROvijiVmp1rIgLAdC9ehYA3Yu+ADjfPms/3DUdIMu44aWQHXXNOkq33FUFTCRAHSRjAtQH"
    "jPhu0vFzCnQIkFOgb4/rZ+p+/RPggLmtzaOwBraM5JYLkGKF88Hr+J/zxRWm09fDl1ZMmj9w"
    "Gniqd4xC7K0ieEA55isILrApcq/guXE+XnkFrWYB/vUJWNWX5PH4BH+IoA2+IIIeXcIkUAAT"
    "akiuwwTwyho3bgcJYHbLFPfDEMHifMmYYh4kcO7nxyABwJwZsnaQAIY/eCvSEMHiX3vMFNMg"
    "AcA0oYZumACgSw2/AwVwSQTbgYKcHTAewbnnPDD/GDsFpz7Bma+EQfP8E+9TSI+b5vfAK+BH"
    "ii7/wNVm/hToFo5b2zu7P8UzgQnW1lzY+vrGhiD49o/rd36fi8lfI7xBk5tF2NYAAAAASUVO"
    "RK5CYII="
)


"""Default avatar image for contacts without one."""
AvatarDefault = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlw"
    "SFlzAAALEgAACxIB0t1+/AAAABV0RVh0Q3JlYXRpb24gVGltZQA2LzIwLzA4DqTMIgAAABx0"
    "RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNAay06AAAAF/SURBVFiFzZfbioNADIZ/"
    "t0IKgoKlhfoMQt//MYT2oiBYKFgYITCCFwMD7ZVlD27nZNf9wStj8mmSSYz6vr9jQX0sGfxf"
    "AMQ+D0kp0ff9V0dxjO12izh2cxm51MDtdkPbtlBKTd4nIhRF4QRiBaC1xuVygRDCyikRoSxL"
    "EJHR1qoGqqqyDg4ASikcj8dfv5QTgJTSytEUxPV6DQPQWuN8PjsHHyWEgJTSH6DrOmitvQEA"
    "gJn9AUKDA/jRrk4Ac2gYhmUBkiTxB3A91Xx8vAQw0dtotVr5A5jyZ6OgFDRNEwxgOozengLT"
    "PHgJkKZpMEBQCjabTTBAlmX+AGmaBqWBiJDn+Usbq33gdDoZh8p3JUmCw+FgtLM6CU1vMSXb"
    "+nkbwG63mw+AiJxqwcXeehi5zIX1em1tayzCYRgghHBeTrIsw36/9+sCpRTatgUze+2Dn2Va"
    "1Z8ASikwM4QQswyhKeV5/rxGmKiu63vXdc59PhdMXNf1nwYexcxg5uV/Th+5hK9m92rw1QAA"
    "AABJRU5ErkJggg=="
)


"""Default large avatar image for contacts."""
AvatarDefaultLarge = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABHNCSVQICAgIfAhkiAAAAAlw"
    "SFlzAAALEgAACxIB0t1+/AAAABV0RVh0Q3JlYXRpb24gVGltZQA2LzIwLzA4DqTMIgAAABx0"
    "RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNAay06AAAAQ2SURBVHic7Z3NauM8FIbf"
    "TgQqCGpQiMEFQ70L9P6voFeQRaALQwMODSggsMFQgUO/xYeHgWlnPI2PjuTqge4aydZjSUc/"
    "lm+6rntHgo0f3Bfw3UkCmEkCmEkCmEkCmEkCmEkCmEkCmEkCmBHcFzAF5xze3t4AAJfLBX3f"
    "//X/siyDlBJaawgR7m0Ge2Vt2+J4PKJt2y/9vus6AIAQAmVZoiiKOS9vNm5CmwtyzqGu6y8X"
    "/GdorVFVFaSUs6Z7LUEIGIYB1lp0XQdjDGleSikURRFM08QuoO977Pd7DMPgPe88z/Hw8MAq"
    "gjUK4ix8ADDGYL/fwznHkj/AKGAYBjw/P7MV/kjf99jtdp9GVtSwNEHGGBwOB/bC/xUhBB4f"
    "H6GU8pqvVwFUEc5cKKWw3W69RkreBIxVPQaqqvI2bvDWB1wuF19ZXU3TNN7ySnNBHzAMA/l4"
    "ZMSbgNfXV19ZzYKvWuBFwMvLC6y1PrKaDeecFwnkAqy1OJ1O1NmQ0DQNecRGKmAYBtR1TZkF"
    "OcfjkTR9UgFN0wQ12PoKbduSjpLJBAzDgPP5TJW8VygjIjIB1tron/4RygCCTADnDOPcUN5L"
    "EjARqn4gCZjIuMY8N2kqYiJU44EkYCKpBjBDFdElAROhWrgnE3B3d0eVNAtU95NqwES01iTp"
    "JgETybKMJF0yASHsOpsTqoV6MgG+t3fEShLADJmA1Wq1KAlRDsSWJCC6PgCgu2jf5Hkep4Cl"
    "LMhQ7pJLS5IToKzJaUlyArvdLr7JuFj3An2Ec47sfsgEcL3wQEV0nfBSIqCR29tbknTTSHgi"
    "0U1HU03fckD5MJEJoJq+5SBKAVLKxTRDUQoA/h/CL4FoBSylH6Bc3yafjIs9HKVuRsnXhKni"
    "Z19Q7+4gFxD79pT1ek2aPrmAmPsBKWX8NUApFe2YoCxL8jy87AvabrdRhaRCCFRV5eWavR7W"
    "wX0+0BR8H9jhdWecUir4PoFy/fcjvG9NDH1c4Hv6JO0N/QUhhPew2buAkCfoOJpH7wJCDkk5"
    "Dnf1LmC1WgXZEXNNn7P0ASEK4LomFgHr9Tq49weo53w+g0VAaM0QR/QzwhaGhjQe4HwY2ASE"
    "FA1xPgxpIAbeh4FNQOwLNXPBenh3KIyfPeGATcDhcODK+jfqukZd1yxH7HhfDzDGwFob7HlC"
    "WmsUReGtXyAX0LYtrLVBF/pHSClRliX5p05IBIwFvoS3ZIQQP2sFxVzRbAL6vsfpdFpEoX9G"
    "lmXYbDazrhVfJSCGNp0CIQQ2mw3u7++vHsT9swDnHKy1MMYs7jWkr3DtZ7EmCRi/83U+n4P9"
    "/EgIaK1//k2V8UcB45Me29HzITBVxm8CvkNn6ps/ybjpuu7dOQdjDIwx36oz5UAphTzPobWG"
    "lBI3T09P76kz5UEphR+p8Pno+z6tB3CTBDCTBDCTBDCTBDDzH7726OxO0Z6SAAAAAElFTkSu"
    "QmCC"
)


"""Small icon for clear list button on start page."""
ButtonClear = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAgdJREFUeNqkk8tu00AUho9nfKnDJU5j5NoJkTB20+JU3ZR1"
    "F+xaKhZIkRCSAYkdL9CqEgtW9B14BVa8AiyQQCELJCRUFUgXMZAKqOPY8WWYsZISaFohdaTP"
    "njnz/2c84zMcIQTO0rg3L7iT5oqUZ6P+Q8rPaSJ0SvKmbt2zdcu1Wf8kEcoygH+hu7qMhdKa"
    "Vru5qNXWF7GgrLHYNO3UBBTXsN0GCT+JJPwsGtbdBov9VwK60rJ0rrZaKjfM7Z2vsL3zDZTy"
    "NVMqVFfZ3LEEKX1MwMYPKtYdJ/I/oiAIgDHs7yH9yi2HzY00Rx6UpTTTCJLBjQuKsyLLRSON"
    "f4Hv+zlp7EOhoBjnL1orTDPp4dP06EBlDnGucXXdiYMvMExDaLVa4Hke7D9ahozsAj9bd9Le"
    "rksy8pLqB/lfiBMABv2c2+W560sIRUpv0AGvvwftdhu63S6kQghEjADESJGK1SWmHfsQK0SK"
    "CpzYVKuN+d7hW4izHgg4gu/ekxwRD3Mw50NR1+YJ4CbzMC9K6BboNu6rlfpCnH2QeeSDhMMc"
    "VXucMx4zZCmRS3OXFpiHeVGSgIUFaUOrzJgC/IAZutKYcZuMMfSqYiKe32BePgjIlllXbREf"
    "YkLYif65XMHBZv7uHzz/u34xYKM2a79/523xwQCi16/2OzTcOV7pT0+/iRxE3Fmv828BBgCY"
    "syym9ECFNgAAAABJRU5ErkJggg=="
)


"""Small icon for compare databases button on start and merger page."""
ButtonCompare = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAu9JREFUeNqcU99LFFEUPndmdmZd3fXHqmlrta6SYZnmSNhv"
    "I4l8UEjIeuihJx+iQAj6E6K3giDaoAjaHjPYCipLkyIoEiuTLNx2Ze2Huq7uOrPj3pm50xld"
    "o8fqwjf3cufc75z7ne+StpszAITA2rAYA9M0QVMUEBwO4Hh+ZV+UJAwjQVy+MAwjZOg6GJSC"
    "AH85dDzAcZyMSzm3FbI/NsEZsKxqnNOIKOIVYjIXJFuW1Y3zdss0yxlWdrStSr73fLoPz6yQ"
    "CFhOzbH2ykBaNfUfieXA5ymlBeOeYYCfJ+xUfcBTvs7rKnSKvJMA4RMJCh2tFXJ4eKoPCRKC"
    "fRdUgLN0kLwuUdrXUOx5+nr6nNvF+/e3+Cp0Cg6TWqCDhRpYQKkB2awAeja7UqKAQkT6B2KC"
    "31dQUFmS741OLZUay1rD7p3+AlUxeV4A9jWe+B6NLybVDNW7DtXL/Y8/jqCgl3mH4xFpvDhm"
    "67AJ73q4tNjZrKSWOrfWVRZLoiSazLDejce/zCczg4TjgtihG3ZW+7BDkkKCKAIJnB9elYsQ"
    "nhlG2Ocr2lvsr/QsaRQy8Zn03JzykhOELowwEccRNYgLa93h0smkiGhWFhauiHl8jVpd7R6l"
    "EqgapTMLasbj9XzDuF7GTLtTrYgyrPYg1TRQUyngHdu6r3rceWfL6jY2ppua/FHm5Eo43Uy8"
    "GVO1zVsmeH+V4CRmCVUysqEtswM9e2ojoxGbhDLGYiT/xO23Had75AdpEXRsbZmp6XRg8CeH"
    "P6Uj7fOzxClw2Ca3A8CDasVUgB1FAPE79ydXfKCjHSeymEJNZlk0tph6/2mWUXrL5XbHMg+f"
    "HPLW1Rbq630uw10gLnMCx5BMYwA010bCdwWDWE4TrucQH1Dhu7wgjCABoEdqUflduG/fv9DW"
    "bEPvydr49dAkxoVR3CHCdV5D01m/PY9+BySAHAGYhrH6yDAGrXwp18YwPrQh9ME/PKbVkiOI"
    "cUwwtLZP/sz+P+OXAAMAj/dc2TUqu0UAAAAASUVORK5CYII="
)


"""Large icon for detect databases button on start page."""
ButtonDetect = PyEmbeddedImage(
    "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"
)


"""Small icon for export button on start page."""
ButtonExport = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAiJJREFUeNqMk8trE1EUxr87GfOYR9KKLUQwCUi6jdK9CkUI"
    "WoluIm5dBQTXroKIZOPWTSGb/A26cCW4EFQU0UUXaRERNTXpJM1k8pyZO56bR5shEnvgm3uZ"
    "Offc+/3uGeZ5HkTk8/lbNMRxuqiRXoiJPHszHA7j5XJ5p9vtot/vw3FcNBoWzTnC4Qh0XUc0"
    "GkUsFkWhcPdBIBCAr4AIx3HQbrdhGMa4QL3ewWDIoao6HNeBFJCgqBHfUaSlB2WAMOgxPhEm"
    "On0BSp8s9KaL3bHmY97Cp1Kp9DKTyWxzztHr9aZWHGIQhqZp5D+GarX6inI//qvAZrFY3J6H"
    "WD800R2MEAwFoekqYgTx+s072YeF++IGPvwX4p/DNrqjESIEzuYr+L63i57VQbPZ9ETOQoFF"
    "iCfeOXNhHrWQvZelaywIdpdJn5dC5NwBtwfoHTXxs1qFbdswDgzsG/vP6fM1YZvNOjGXy20m"
    "EonH8xBt18bq2iqSF5OIX4hD0RXfBulz6UfyyW58AeKPXwdotBrY2/2GL++/YtgfYOv2FtbP"
    "r2NjbaPIGHtzbMGyLG8GsVarkX6j2TZgOX2cOasieSmNEQGdLn5KS16T3h2fgKjKS5uJpK5o"
    "KD8rI5VKtTqdzlvfLVABRZblcbMEg8GxhUAoAmVgQgoxqFoEV25cHfdCpVJhItdXwDRNgyA+"
    "cV1q1wlYJkQhHpAkSYyemNOfaIhRxF8BBgAPDR3S0EHTJwAAAABJRU5ErkJggg=="
)


"""Large icon for import folder button on start page."""
ButtonFolder = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAp5JREFUeNrsl01oE0EYht9NNj8btMWIhHopEhAKRgURBC+2"
    "0uLFU/HkwYMIUhEUBIMpPWlBFHtS9CB4F48iNl5r8dTSnmKjCFYpHpL2EJP9m/Wb2Z+YH2M2"
    "0c1BlwzfZjOz3zPv+81kV7IsC4M8QhjwIb+bl8SJJPkfzMdIdsxQmP5N9xck9jrXm4vuCi//"
    "gUkcpptNp6fuzqGDnR/yWcFKba1Bgb6TA+cOnrk3m8hch2oYqOm6iCpFzTRx5XMKlYqGV5OY"
    "K+azruVr7QAuUjvgJzuf8NjZhdyuQ9dgULJOx8kvM1iaxOzGolDiOLWnwsa3tz3/7xy78OwW"
    "v6vlmCQiYyI2XGuKJs3WoFmL7y4Z6ma7xkRkWfQvvM7O09ecUMDpe4nDFFdXfekfVxQMJ5OI"
    "UZSj0Y6QDUAWpAYL6EL6xNXnNy3T8AVQrVTxaWUF+0dHoSQSnlLSL6KrDAVv+cvMvhZihg6m"
    "qr4AomEJY+OnsJ5/g72pFPaNjLTY1g6GcoZsq+oAksUHMdP3MjB2ysicnsD75WVsbW52NYbZ"
    "Flwmlscy5RUKWCYBmKyntahvl5E+eqT7DWxi/MbSw/MPfi7CEJ8960EBb1bV7133DcfiXh14"
    "NcABrD4AfO0ffLItAH1Y4BuA8tQBmFuE/Vng6y9Y5LL3gsFb4Kge7nUZ9gbAQHnDTTVAVIHV"
    "gNlSA6GgFaBP8zJk4ofAANopwIIEcBXQnSLcLpWga2ogAJFoFbpbhDVNXFOGhoegqdVAAKIx"
    "BZRXEQBVGyC2UypD04NRIBqpgfLGBMDCS2BmCvFkcg891xmBAMhhmR5aEX+0SOfFLQwXvmLj"
    "yf1cJMgXko/fUKDcu/l+HOeqcBucRzTpL+fmZa86zZT++XfD/wA/BBgA+029gcH4w1sAAAAA"
    "SUVORK5CYII="
)


"""Large icon for home on start page."""
ButtonHome = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tl"
    "dCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1l"
    "dGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUu"
    "MC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpS"
    "REYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgt"
    "bnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8v"
    "bnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNv"
    "bS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEu"
    "MC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9w"
    "IENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkNDMzdGODExN0VENTEx"
    "RTBBRjEwRENFMzEyMUUzMjQ1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkNDMzdGODEy"
    "N0VENTExRTBBRjEwRENFMzEyMUUzMjQ1Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmlu"
    "c3RhbmNlSUQ9InhtcC5paWQ6Q0MzN0Y4MEY3RUQ1MTFFMEFGMTBEQ0UzMTIxRTMyNDUiIHN0"
    "UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Q0MzN0Y4MTA3RUQ1MTFFMEFGMTBEQ0UzMTIxRTMy"
    "NDUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBh"
    "Y2tldCBlbmQ9InIiPz41BSmtAAAC8UlEQVR42sRWy27TQBSdaztpmlSUBRSxAdEFQt0VuuiK"
    "BV/Rv2CFBHs2iA3/gMRXVKyQQDzElsemYkNRRUlsJ37NzOXO2E5sj50QhIaotxOPPT5n7j3n"
    "ZgAR2f/8eAcPj9V4jWKfYmQJd0rxkeKbV0zsv7h/+Gh3Z7RnA/3kbPr56Nmbx5pAUYKtGzvD"
    "W9/H8VsbBK5fHh4Q7pYuQTlJPCSzpAeNVWqgyADQf0FhhYHGQoRqBkCxkmiJQJ4BqGaAJlGx"
    "skRAY7FaBiQiZ5ZKUGDVMgBSMk41kFYIENZcA2UqiJWwpQHZUQJKgB0bKiyjBLkL/rwEXGKW"
    "ZDKZJSLiQqYZXQsh6Y9JoFc7wBzXcVzPBa/nOv3hhrs56LkD12E9hdUsgSIgCH5pCihvIoh5"
    "EEY8jDIRrzANbUYKGlOK2XnIJkDMNonExVH/qkFA7V5UOlQNWCIfz9KJP8sC0S5ULFPauIaG"
    "/dg04XGUCN9oRLkGpNEw/Cjzx9PMJ2BRPttCAFZcNzWApg3zTjhnkHGZnfnJecJlUuwJ9BJs"
    "gShf1zWyeodRbjNtSNsvbTBLRfQzSMfFrqEG1Pa9et011voAyrkNF41IE2BhzMMxpZ2mEUCx"
    "bG5hWRpYxzNo2LBNhMKPs+lkxkOdbr0SOsq6rgygQUALsk4g5Zj6JTgUK7pcBh33oEUTzTWQ"
    "u8FwQUy+Zqp/LB4sZafPKWBuUL1nDkn3Ya45c/OYP5S/BpGZLtD+LncO9bxBu6mgMg+them4"
    "L6sZWJyIEGGFf//diQjRJKA7ADhWCMiKCMl7anSQ5T8gls6E1AukxvKEEDmRXLFOV2NrqzGu"
    "aYJKi2eEqw3gca5OR8zVvRbqYqmMuFxj9R8k6O4WWGiAEa5by4D2yF9oABduXWMRLDLw6/gJ"
    "2773IHj35dS5c/PKJRsa+PD1h0saCCYvn2rq26PbR3uD3buHzO1dsHImE5mfnLx+Fb5//kkR"
    "GFD0KTYoejaOhBRJcVLivwUYACZZJwaDak8bAAAAAElFTkSuQmCC"
)


"""Button for databases in database list."""
ButtonListDatabase = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAB3RJTUUH3QgQDRcfgk6jPwAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAM/SURBVHjazZc9bxMxGMcf"
    "596TFCI69ysUUWBASLAwVZ27d0JCSCULCztzlnyJrCA2vkGL1H6BDt060ObIvV9sHjv2ne96"
    "1zRqInD0yHdNes/ffz/+2UcYY/Avm6nfHB4eqssXGHtrzvUL44RfTCaTZgGqzefzvdFo9LXf"
    "72/Xv+OORVEOQZBCGGb4W4BOh2AYYBgGmKYFlmViWHhtiojj8PdwePSFEHJypwOVL0xz++rq"
    "CpOEmCyAJElEcj5jcZyC7ydCCGNEJLVtGxzHAc/zoNv1RO+6LoYDW1tbT9rydB7uLNM+oEX1"
    "fv0CCA9MIvsiKimXS3iAA+zWvfgQBk2fDQhQEvQUcrTCCbppB6QIomacNoybFv1mBBBWiiDK"
    "DboIwqQ45cS6BZDCA9Dnv17/y2qgjQOn4/H4++7u7kEURZCmKShk53kuuKDYwBsHEAePYsFi"
    "/Zdxfn7+AyQF7yvg+XA4PEAicioCpVRCaBFRnKGABMIohXxOgXASCgoqIRjYW7YlIPXqzbv9"
    "j++PvjWJaCUhH7Xv++0knEUQopCcUTDMjkimRi9IiL3nIg0dQcLN1ACDOnzqc0+LWL8AKQLq"
    "y46ohBSqgF67gGr1i8SkiQObcIBoIyI1MXpSuT9sBsVqE2rYCxWESjGrc2A1N3QKkttYhjum"
    "4P8F0fHx8QFPkGWZCJ5YjFOAKIU/QQRBHENGM+FAB1lgWsYCQg4XgoGC+P3T1y/3P3/4tBqI"
    "1EgbQYTXPv59FieQAwowCDpgiMSua4vjmJe5Akbu3AUTHWprD9yOy3NAWXjNW/KqNbCSiFKK"
    "3BFru+K9BfBNR/btnumtqH7VV1kA2irgz8Rj+d0C+HxLAf3licvkhECVA1CektQ9rqbeUgHT"
    "6VQJsFedgjqQFhtVKQyfbS8VcHZ2Bjs7O7za3fsLgCKZvjMyUhVzfX3tcAGXl5ftAvhyu7i4"
    "gMFg4KFiH1/NHnG49Hq9KgeSFPoBLs84hISmIhnBJy04YEogcQ7wQ4kNwTTyb25uuhgFvIrZ"
    "1N+OUeEAu8e4jt9i/0ydhFRxNlQBkf8H0l6mrpXdmu2nWGM/sZ/hM/02Adx6FWt4bas0bmGE"
    "kWLOwoa/OzOLOIBt5xoAAAAASUVORK5CYII="
)


"""Small icon for left merge button on merger page."""
ButtonMergeLeft = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAe1JREFUeNrEUz1MFEEUfm92uOO4cJgYz3AEjQnRhgC6ibEx"
    "VthRWRAIdnYmxl4LayoaCwqojlgRQgeFsbDlLnEbAW1MOLyD3N3esjc3+zO7vlkXc4UkJBS8"
    "5Mubef/z3huM4xiuQgyuSPzZeiM5IOIqMTOV76owfHduJBwHwiAAZhjJ3ev1wBMCfM8DTobn"
    "dpPzz0sPEZBtfflthHG8TLKOVgRkiOz/xTKtTFFrd3zPcRSM5HEokHLGp0ytej3JdGEPXNsG"
    "X0qNb0f1M8d1A7h7O1ckp9ey273Zb0wNXyUs9cuM4cdLSQVErY4jZ0eL+VvHDXsol2U3mm0x"
    "TQ4n5GmHvu/R+QM9+QlxQdxSSgHXUaMoMiU1hRBV91nNKxTuBAN8rHS/ONuuNaddW4gwUEo3"
    "svRowjyu/nybjr+MY2929169fGpaXQY1hSDCGI7OFESkZwiQH0AY5JiUq2XNXgTDGbp//loh"
    "0Xuux/ErMMCKMqDnoWhSuRHi8V8HQXD1OQ3QzdJUOAUmv2QPqHmVzY+bl966wcUFk298qviI"
    "K9D6sYPZqRdw2XVmD+b2kqecHqyo/e2yanwH7llJdioKMoSsTkLIpVzLjH8jK9w7BGlXVWXN"
    "ous4oYl91RlpoH4YF/wXRZB6y/Haf+MfAQYAtE0LahFUAvsAAAAASUVORK5CYII="
)


"""Small icon for left merge multi button on merger page."""
ButtonMergeLeftMulti = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB2ElEQVQ4y8WTMWgTYRTHf9/d"
    "eUlsS1PFFKpFBJEOlaq3KRK6utqloou4CeLkokMXwTplcQiiLhGngqMdHIJjm6IxCK0FUWIa"
    "CdV4vV6+u+/uPockpShYnfrg8f7vPfjx4L0H+20CIP/0WxFwejUDSHp6sXx99O7fAAZApNTk"
    "5ekjZ2emc04cqVN9bRJfulCsD+8JUEHw9cfPMHDdGENHyfd2qFw3ZnhAHFRSntkTEEr5rt7c"
    "cj1PcWjQtL40XO15iuOjmVwYBDdP3397GGBqvlacmq9d/RPQ6bx8/6HZkGEQ6SjMrK63jE4Y"
    "JI1mO3sslzofRdHjibmlfCilE0p5e2JuaQciTtwpF4UQDsDY+MhkNJK1FUIcQGuFEHqjtea1"
    "fT9ScQwwdu6k01hZr2itC58e5kvi6K3F5RvXLjrVbYOPAdS3YhINhoBEw5AtSFsC6OabnYQh"
    "W8DrNxXgnhX4Pp+VSTWxiSwYzEKsu55o8DV4urvXRMN2CpQFA74PgBVKWVl4tPBPR2MA6Suz"
    "jvX8RSUUouCWZl+J/7m69MyzZYCktVoIyw9KAFavZwE2kALSQKYXbcDsA9RGbQ3ZXokrT6rA"
    "OLApdk1n9kC73eyv+jeLAQn4+/6M/AJo6ded0dcRQQAAAABJRU5ErkJggg=="
)


"""Button for open file on main page."""
ButtonOpen = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAZFJREFUeNqkUz0vBFEUPe9jyQqKJWyi4gdoKEgU/oNKKxKl"
    "UrI0CqKXqERHIxLxA0QnolkEWWJCLLtLJozdnZk1M++5M1Z8hGRkb3Jzz8u957x778xjWms0"
    "YvJwif2a4Az9FMZ+SW0pjeOPeyX5BHnvzyoqwsCMmrMcB0+2jUmjA6ZpY/WolVN6kHwtrGP7"
    "C1gYmt7OIAigtYJWXz14j2GujhljyK5PLRJ3NuogUBAhWb3WvhHVF3KE61GIBCJOSOZ1ge83"
    "/02OOmE8Ekg2UfuhiE8H5Xswc3uolR+BUIw29O6KzhTVJ+acIyEwQuR54l9LEpWuVYJPRenh"
    "8Vifrmd0Yqj6YHSfbWaWpU9jVcw7iJYU3Ici4vwXjMZ4zB3kXR+noYB8ujfQ1TcAnxYZx0RT"
    "MwpXJ0Xbxbn0FGTFekGaJWILBJ5bLtwYJcGRl75PO0mm4Ll2tPk4Zt7nCpaDS4JaEmhvbeuE"
    "oLkgeIz5GW6Ni+eqi2OC1L6Dq52Nld3/PCB6J1kvwF4k2Ohr5GjQ3gQYAE2uCzTGoVQ4AAAA"
    "AElFTkSuQmCC"
)


"""Large icon for open database button on start page."""
ButtonOpenA = PyEmbeddedImage(
    "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"
)


"""Small icon for remove database button on start page."""
ButtonRemove = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAhFJREFUeNpi/P//PwMlgImBQsACY6xiZPQAUi1Q7vF/DAy5"
    "v4GMH1BFbBBam5GBIRjINALibWH//8+CGwBU3BJRUmL84/v3/zdPn5a8fuqUJdBzJjB5ILuT"
    "gY3N7fevX++AhvQChbaDxBlhYbCAkTENyErTNjeXVNTWlvr57dvvM/v23Xn96lUsPx9fjqiU"
    "lN2DGzeuAzVnszIwPATSDFFAvXAD5jMyMvxiYDAGOj0cyHUyd3RU4hEQ4L937dozdg4OhhsX"
    "L54DOjcdqPkFK8hmHAaA/fwXaBBQwUw9Q0N1BiYm9tvXrt36/v27DiPEK2AgDjUAHgaPENEi"
    "ChSsVZKSkv7x8SPbradPbwjy8vJ/+/Pn0pffv/VAlvwB4lfo0fgDEpAgyRoFUVFTMWZmsWtP"
    "n97++PPnxPtv3pxlZ2XlAspt+4crHYAMAJqeLsHL663GxCT15NOnF29//lwIdPJcoMagR9++"
    "beVhYZEHstt+Q9SiGgD0t/xPBoZUaw4O+e+/fn098/HjeSB/zieg3D+Iy/Kf/PmzFmiREVCz"
    "I4YBQMW5hlxckjx//7Js/fTpPpBfD1T0HqYQakgd0IAzQDmPH9BEiGyAgw07u+SlX7/ePv/7"
    "dwdQ49nvQPHvEDm4IUCX1gD5r4De0ENJSNHApPwfkpTfMgPDAhhlD5BSIQNa4CkCxSSW/f9/"
    "nHHAcyNAgAEAxF3igbzwV7kAAAAASUVORK5CYII="
)


"""Small icon for remove missing button on start page."""
ButtonRemoveMissing = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAUFJ"
    "REFUOI2lkt8qhFEUxX9r7z0mkijlAqUMKbnwPN7CO0yY8BbeyBQayh0Xahokme/bLpiPD6Vh"
    "1en822vtdfbZ2jtoH0ns8gdkcsx+p51lWf5p7HfaGW9KSbfbHSt7q9UCIAAkVQfjonJweX1e"
    "v4gG4Y574B5EBGGORwP3oNlofgiMsLiwXK0lvc2IJBklAnCzuoMaBFdz8wCsD/pczMwCsDbo"
    "k2WSWWKfBOwr3+SsD/oAFXnj4R43w8yQrCZQc2AmJNUCAMKdMhOUIJCsek4tUjJMxtn0DABb"
    "z88AnE5OYWaYCUOY/+BglFUSm0+PyBwzsT0cUiZkFmSRyITLKCjqApJxe3dDeBCjr3PH42Pv"
    "HjQmJtBPNVhZWv1az+9IGL4UDF+K7wK9Xu93gU/4dys3m++dmHDSOdzbGYv9jkyOXwHmFJKW"
    "bHJGnQAAAABJRU5ErkJggg=="
)


"""Small icon for save as button on start page."""
ButtonSaveAs = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAf1JREFUeNqMUktoE1EUPfOzEzDalQ2FBjV+tuIim5ZOFxYX"
    "igqK4LJ0U0GquLLgQnEnUmvppl20SLrSTV1IF65KYxeCCSglgi0IGmokaLQxDm/ezPPdl86Q"
    "SavtgTtv7pt7DufeuZoQAsPmExA27/7Abqj0jEzLY7nzeWH+00APzK37ERkZGR93E+CN2lnj"
    "p7joHejIynRUCQiI43dyw7dPXEvK9zgeLH5BqeJGeVqGc/kYZic3r4ogeLMlEOiMMXDZju/7"
    "MYG361WcuXQKH37JFnnzbqUK9A9luxae5m+FDvQgCMAk2fO8mMDhTg0vcstRrmka6v19yD9a"
    "+OYetCdCBwbnXAm4bQJjF47E8isPV8BzL9Fd+PoO++15JRAI3yDrTLpoF2hH5lAHTlpJlErv"
    "1yhvCkgHJPB7g2Ffl/1fgXvnT6OyWMOq5EQCYQtrzz5jL0gkEorT4qDZQrFYBC3WTqDhhXAc"
    "R3FaWzDJgWEY6B3NbPsTlmXh9eQ60uk0yuUyqJY4rQ5McmCaJup1F0vjq4qYvX40skzfCLZt"
    "q10hTiTgg1u6rquiRoMhlUqpYnpXMxJGTIB2hjiU6/TwhDv1eGzmVXXje40xoYophGhGeNcq"
    "wMSfpAxoNLRz+k154Q7Kjby/ZM7ldxqiw4f6YkOFVpDHDe1fU98r/gowAMaC+CTtivcaAAAA"
    "AElFTkSuQmCC"
)


"""Small icon for scan button on merge page."""
ButtonScanDiff = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAzJJ"
    "REFUOI2V091rW2UcB/Dv85y3vJ6kWdIloTZpHRjaxq6FqRXXiyzaCo7pbhRRfLnYjS8l/gNe"
    "Kd45UEGrU2RDigwdtjAJdVPHwItRjGtr2mXdurV1WdpmJk1yznOe8xwvZoMvF+L36nf14Qff"
    "3484joPdDBw7q0uE5BSJZLlwBgFApqRg2c6s7Tjvzk8+XsM/QnaBvpe+yqiUTI0k48HBRERJ"
    "7PVD12UYnKG4UeUff7dUZVw8s/jpU+f+BaSe/yLjVZTpowMpz53tW8ifn+Hl9ZLErRZi9/SK"
    "N159UXp4JI1X3vu+ubbVOFw8+WwbIfuePqHLlJaOpPoiv8zP2UuLl0CUej4eshdTqZ7AxUur"
    "3dVNdujR7Bh54bkj9LUP8xXLFvuWp16uAQAFN3K9Pl9g8/ZtXLu6jA7P1bcOPRA89dnkO9oH"
    "x99+4vz0+6EHh/3HL1z4yZmbW8ZYOhGEbeZ2N6BUsGzU41Xni79ySW3k0/3J0siBAyucGx8B"
    "+Nblcl07ODK0oXpE/vTMD3Yy1KEQ28zuArJlNgddRIFgQnI5t4o9Pfs3h9PpNUUx6+vrC7nG"
    "lq3v7Pze75G2u5o1c1wlGiyzNdgGhGWAWQySrIFC4z6f1/DsUU0h/IYQgBaoKz6f11AVjRPH"
    "jVq9BcGNdgsUghW2aluQNc1m6OpnjCmsyqVAgCmBwN2ZMaa0nFi/2++3VzfKgG0W2gC3zNm1"
    "6oYZDumy133f2OWl7eTC9SvRcll4y2XhXbh+JXp5qZJ0q/eO93Yn5OLNks0tY7ZdY+zg67pE"
    "aGkodn+kaYBbJghRyl93x+U8ANxYtx6zzOBRv18j4VCA/Fg85zg3zh67ubrySfuQ4qMTGYXK"
    "3wxE+ryUathpCk4cWYLjQFBmd+humVIbhd9+xuEhDTOnP281mq0nN8qb+fYpx0cnMpTQqU53"
    "WN/jCWk+1QdCKJpWE5VGxS7X10hUq4jRgU450uHF5IlTOyZjGfLXZ4qPTugEJCcRmhW4+0wU"
    "pGA7YtZZObNNeOPNaFdCeuSh4aAqQUx9eebO34D/SnxveBzAyVAo2Ix1hrsXiiX8L+BPZD+A"
    "aQBdAFb/ADonfMWfJE59AAAAAElFTkSuQmCC"
)


"""Clock image icon for new days in exported chat HTML."""
ExportClock = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAIAAAAmzuBxAAAAK3RFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMiB2ZWViciAyMDEyIDAxOjU5OjU2ICswMjAwk8LXDAAAAAd0SU1FB9wCAgAAKExUReUA"
    "AAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAAx0lEQVR42m2QPRJEQBBG"
    "29SWiEgkE3EAcwGXmTvZy7gAByCSKAnJEEnGW3bV7pYOprrfN/3rOedEZFmWpmn6vt+2zff9"
    "JEnyPA/DEEn4MQxDWZZ1XVtrCXnxIfBXPjHBNE3uMPzTgeCjKopTMIoi+TUIHFXRO01TuTM4"
    "qmK090Qfex6GA0d9MDmLXJ+MMddXOKpisa7rbrvAUZXWum3beZ7/ZAgc1WOxcRyrqsqyjNFo"
    "R3GykYuiiOPYO2+6ritX+r4p2UEQIO0jepg0AJyJFgAAAABJRU5ErkJggg=="
)


"""Edited image icon for edited messages in exported chat HTML."""
ExportEdited = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAIAAAAmzuBxAAAAKnRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gNSBzZXB0IDIwMTMgMTU6Mjk6MzQgKzAyMDCZinEkAAAAB3RJTUUH3QkFDCAbTkEjOAAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAACWSURBVHjabZAxEoMRFIQT"
    "k9GpdA6g0jmHc7qAnjvoVCqdhopG3h8zIvJvY+d9O/vwHGM8Njnneu9CCMbYnKAdAwshxBiN"
    "MTnnm4T3fhoooJSeCShYCc75mqO9AEJgCCH3CbjBNFLKfTVauNb6X/BNAJjPO/Al+I/WmrW2"
    "lJJSAj9+dXVgjGGL1hp/dFS85gFAKbX+YNcbtEZUbc4oXmUAAAAASUVORK5CYII="
)


"""Removed image icon for removed messages in exported chat HTML."""
ExportRemoved = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAIAAAAmzuBxAAAAKnRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gNSBzZXB0IDIwMTMgMTc6MjA6MDIgKzAyMDDonN18AAAAB3RJTUUH3QkFDhQehoXwLgAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAA/SURBVHjaY/z//z8DXsCE"
    "xp81axaaCCPQDExROEhLS2NiIAj+g8HMmTOxkkBA2Az6qGCEhBhWDwO9ilCBBwAAobAv6s9R"
    "MfoAAAAASUVORK5CYII="
)


"""Help image on default search page for chats page."""
HelpChats = PyEmbeddedImage(
    "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"
    "Gi7gKHOKpsQAAAAASUVORK5CYII="
)


"""Help image on default search page for contacts import page."""
HelpContacts = PyEmbeddedImage(
    "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"
)


"""Help image on default search page for information page."""
HelpInfo = PyEmbeddedImage(
    "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"
    "gg=="
)


"""Help image on default search page for SQL window page."""
HelpSQL = PyEmbeddedImage(
    "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"
    "/gtqRDNRb9yo9wAAAABJRU5ErkJggg=="
)


"""Help image on default search page for search page."""
HelpSearch = PyEmbeddedImage(
    "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"
)


"""Help image on default search page for tables page."""
HelpTables = PyEmbeddedImage(
    "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"
    "q9mX0jpfcPsb0i0aSxTJwvQAAAAASUVORK5CYII="
)


"""Icon between database info on merger page"""
MergeToRight = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAADv0lEQVRIx+2UTUgrVxiG35OZ"
    "ycw1arj+3VSiqUhwISW0AcWaUBA3uhFxYxddVnR1sZsgIZtmERCkF4RCQnd2UaSg4A9E7OKi"
    "dHEx4KYoRdtICA2dyV/zP2fOnC6qIVWvd1Po5r7wcpgz883DOR/fC7zX/y0CAOvr61EAXgA5"
    "AEkAbzjnPwUCgd//E0AkEjmbnp7+uFar0XK5XNE0rZjJZPKMsbhpmt8Eg0H1seJIJBIFkFhb"
    "W4u9DWABAMMwwBizGIYhK4rS5XK5hsbHxz/q7+//3DTNH8Lh8GePFRuG4TUMYykcDi89CaCU"
    "QhAEWK1WCIIASikajYY0MDDwocfj+YQQ8ioUCn0VDAaV1mJKKWZmZryU0qVQKPQoRACAyclJ"
    "78XFBW5ubv5UVTXHGGvYbDYRgARAcTqdz0ul0nClUpn2+/1Wn89X9Pl8f5mm+eXIyEi/2+3u"
    "v7i46Pf7/Tg9PU086AEABAIBi2maLwAMcc6nAUw5nU6n2+0epJRKsiyjVCoV0um0pqpqRdd1"
    "AwDm5+e9hUIBdrsdu7u7Cc55bGNjI/YAcF+rq6t2xthLRVEWxsbGhq1Wq03XdYiiCJvNBqvV"
    "CkIIOOdQVRWiKKKzs7MJ2dzcjD0JuNPKysoU5/yLvr6+T10ul6Otra3zbd9KkoT29vYmJBqN"
    "xsR3AWq1GiwWC+r1OrLZLFRVBaUUjLF/migIkCQJkiTBZrNBkiToug5CyNNXtLi4aBdF8aWi"
    "KAujo6PDhmHYqtUqZFmGLMvNH9TrdTQaDQCAw+HAyclJghAS29raigFA8wQLCwsWQsgLAEOE"
    "kGnG2JTD4XAODg4OlstlSVEUCIJQSKfTWi6XazZ5YmLCq+s6enp6cHx8nCCExLa3t5tNFgFg"
    "bm4uyhjzyrIsdHR0WLu7uzt7e3u7OOdttVoNsiw3Li8vk9ls9ooQ8iOA14SQG9M033DO0dXV"
    "haOjowQhJLazs/OvqRZvB8a7vLzsLZVK0DQN1WoVjUYDgiBA1/XC2dlZUtf1LYvF8u3e3l79"
    "rnh2dhaSJOHw8DBBCIkdHBw8iAzxLioqlQpSqRQYYxBFEYIg0Kurq3QymfyNEPJ1PB5//UhU"
    "YH9/P0EIicXj8UfzSATwjFKKYrFoAqDlcrmSyWSKqVQqXygUfr6+vv4un8+rAD4AYLZa07Rf"
    "TNNMnJ+ffw9AaXnH71YC4LnH43llt9tHOed5wzD+0DTt11wud5bNZltT1ATAABj3TG/dusdu"
    "bRIAz24tv2Pw+P0TtJjde+Yt63s9rb8BX+/h8JD+o8gAAAAASUVORK5CYII="
)


"""Icon for the Chats page in a database tab."""
PageChats = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAK3RFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjYgamFhbiAyMDEyIDIwOjA4OjAyICswMjAwNrNp7AAAAAd0SU1FB9wBGhQHFZJfkT8A"
    "AAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAHIklEQVR42q1XW48cRxX+"
    "TnX33HZ34qydrAO2sTcsDiECJSgoSiLBA1EuWJGCUCLxEIlHeIUHHnjiAYU8RAr8AEBCAglL"
    "8YuRkEAKAqMgBwUS2U7WFpeNN/HYa3Z3dmd2pruriu9UT89tdy2ZpKSZ7qo6fS7fudQpwdg4"
    "fWnNn7t0HSurbWTdDmJxyKMIHpPDc8GHVQlzGTz1IePEMnqpVCtYumcWjz+wgFMnF2QXyfdP"
    "X/Bvtht4/HMVPHT0AGrcqUYeGUmU57QSbvCxeAkvQSEZYzhQtBxbqcHyP1t448I67jt6B14+"
    "tShDBb575l9++SbwzCMLmK310OkY9CSGxA7VzJG1TEqnUPFExmRwJqcglRSFNUzTBuUFNokw"
    "y+22NTj7p5t49KjFD58+JvKH5Zv+B7+7gQdPHsPhRo6tRh1R5JDYHH0kiMSNcwrsHXHOjSD2"
    "OSKntkfIJaFeBomzuxRQv1hiWXUxsr7F9a7F2++t4pVTR2D+SJ9X5w/DNirozNQgxkDINOdH"
    "LlKoDSyZF4xypJEJAo1PyDemMsK1ODhKAjhETFKugd+BikbBPYZ73dggrdcwR2RnZhfwOmWb"
    "d284NBu0NFHLyNh6pFTCUwGFVJwqYAsLXS3Ewq3ovGSkrSPODYWDgrthTelqeU4jiFylgtlZ"
    "wcp1i3gzjXGnI5S+EphKMNujTyYV64Zz4/Z+n6bba14OS3X8IKKFxuxkYKZ5CZBSB/RpkVL4"
    "TC0T9EO+FXM7CGuhWTF5N6vcUwQIvDMe7ZR+Jp2b+k75DDPHO9WCSBrVADmnsXcaIMIJFcn0"
    "O1smGNGSMI/5PN40uHfOY4nPhbqgWRnFmKURG1RgtQNc3vS4sgV82LGDqBgpEFGSC3ZoXDCD"
    "KDu2jFpNI8uIcQ5D4eWH9zQMnjhi8PDdwrowTIaJZNMQVaUOE+0vHhJs0ZDfXwXOXVNkZMIF"
    "oVI5dYUElGL9o8uQ5wO23gwLymOfEDy3aDBfmyxEuzN9cm2WGj13wuALB4FfLztc3ijLh9YK"
    "W6RycAVzzAXrCUiuSgif/GWCT80Inv+0BOH7Cd1vlLSLTeCbnzFomIJnRjRSyskyylSDabhR"
    "+HNGg/50Iyd8hhtfOwHMVW5D6j7jOJX4yidpHHm7LKOBPvxUnsJqIuKfsjxmWUTtmNtE4/55"
    "4MEF2VX//9/xxHHBwRp5B3QzdHOGI9+ZNlrmVBvCQp+U2j1wFxNTbg/2W407qsCxOSClkV1b"
    "hdhthl7KtEwQa27a4IYiFjT1nPvoQqeH8lTjkqwNwxqgMcADn+62dhiEGYtMPwXOX5WQGR+X"
    "CzZ2gIstFjrK6tHdfTuHKNNs6GlV9UPtctaCnP7564rgjav+Y3PBmUseK+s0SmsCS3/KVOyY"
    "BBX63uhJ5QcuyNIiE9pdj5+/6YPmH3Usr3mcfscRWRra59lAOX2eEynPHl+kof4x4glNziDJ"
    "cp7cTJG3WMlePefR2i4Y3Y47StoLLY8fv+5xbbOoAznPhg3boMtpve+zMlotxVoQCgW0ULhI"
    "I9CEivjaPwR//yDDay8m6LE+1JORANlDaLm23gV++ZbFmYsea9vRkCbyHUg2C0mIOo9udX2s"
    "Qajl2HGW0f8aE4Ed1xSZd1sOKxuFTf9ZLxidmBccmhkJ1JrS2vZ477rH+fcFf2MMXf5vXrQh"
    "Y40h2xdkIQMknAXhMNJSLNpiWfW/0XOisMYX/tF5Kfxbv0p5AhscSGIcarJdZQsmREpL+LVu"
    "iu2+fqzdEib4lMOiGto557SPLghiX/TYhQK5CpShCwyjROcq/MVfjPZu9BgbHaA8vEq66e/K"
    "+RABNVQVcUVT74t+wAUotRhl1o+KkCKAYv7Cz1xh1WAvILMH3X7zYZyINjYFAkF3ahBLaDvV"
    "XxXttjlLgn9iTc+xuWjQ7PE+TbfXvByOLYmaLbQmM4XrTbNOv/dSVKmKjXa42EOFh7V24+Pz"
    "/d6n6faalz8FhZmOGu8SWhOa1R2YhxerWFtbxYG5iLlJHFgkYtmh63oMjBkkbMWNsagPjumM"
    "QXgrukQ6iJhN2kFL0kXEy4uuKZ1jgNbYIc83LDZba/jS4p0wLzy2iH77Q2zzLnjk7iqZOPQY"
    "QMIPY15NchaOjNBpd+ulEg6S3M0gZXfTM8WaXl6cFhilMyO6zDUKuqjOFr2CerSNxbsirLW3"
    "4Lvv46lH7i1S+UdnL/pXTl/Bic8/irkDTfS22blos6om84pWRNDkDVHGnuWvuDOYXVVT44wJ"
    "iDleflrtG/j3hfN46RtL+PaTJ0c9809++7b/KZXo1w6iOX8ILkmogAlXr+kh47qITN4dZfdZ"
    "HgI962J97SZdt4nvPX8/vvPVz44up+X4zZ8v+bN/WcWV1ibhI6Auxqgv0ugvM4vXL+3hdVdK"
    "ChOu6SZ0u2PlWYq9iNeyxSMJnn1oCV//8tJQ7v8AarJQ9wfXBWsAAAAASUVORK5CYII="
)


"""Icon for the Contacts+ page in a database tab, and
Merge Contacts page in a merger tab."""
PageContacts = PyEmbeddedImage(
    "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"
)


"""Icon for the Info page in a database tab."""
PageInfo = PyEmbeddedImage(
    "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"
)


"""Icon for the Merge All page in a merger tab."""
PageMergeAll = PyEmbeddedImage(
    "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"
)


"""Icon for the Merge Chats page in a merger tab."""
PageMergeChats = PyEmbeddedImage(
    "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"
    "F8pelXv5qYcAAAAASUVORK5CYII="
)


"""Icon for the SQL Window page in a database tab."""
PageSQL = PyEmbeddedImage(
    "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"
)


"""Icon for the Search page in a database tab."""
PageSearch = PyEmbeddedImage(
    "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"
)


"""Icon for the Data tables page in a database tab."""
PageTables = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAK3RFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjYgamFhbiAyMDEyIDIwOjA4OjAyICswMjAwNrNp7AAAAAd0SU1FB9wBGhQHKMo33S4A"
    "AAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAH4ElEQVR42pVXW29dRxX+"
    "1uy9z82XxEmI09QJqotJgQJqEG0aKoqqSIEoKgiqln+A4AkFHhBqeUAVqgBFopV4Kg88VELC"
    "SAXJkYAgtRQKJJUS3IYQt7Spg3Nx7Bof+xyfc/aeGb41+1wdt9BRJmfPeM2ab93XCPrG9MUl"
    "/+eLi5hfqCKt1xCLQxZF8Bgcnhs+7EpYS/tXf6SfWHofhWIBU7cN44G7x3H8wLjcQvKd6Qv+"
    "lWoFD3ysgIP7tqPEvxQjj5QkynMzCNc+LF7CRwAkfQzbQDtjrWUw9+YN/PXCCu7atw0/PD4p"
    "XQDfev4tP7cMHDs0juFSA7WaQUNiSOxQTB1Zy+DtvFQ8NWNSOJPxIr0pCnvYTBvAC2wSYZh/"
    "rlqDmZeWcXifxfe/sF/kD3PL/vHf3sQ9B/ZjTyXDWqWMKHJIbIYmEkTi+jkF9o56zowg9hki"
    "p7JHyCQhLoPE2VsAqF0sdVl0MdKmxWLdYvbSAk4en4B5kTYv7tgDWymgNlSCGAMh04yHXKSq"
    "NrBknjPK0IpMuND4hHxjghHuxcFQEpRDjUmLe+A5EGgUzGP4t3ps0CqXMELNDg2P4wXebf55"
    "02G0QkkTlYyMrUeLIDwBqErFKQCbS+hKwRfei85LStoy4szwcvDiethTulKWUQhqrlDA8LBg"
    "ftEiXm3FGHNUpS8EphLE9miSScG67tq4rb8302217gxLOL7t0UJhNlIw0rwElRIDmpRIKXyq"
    "kgmaId7ytW279ebvzXRbrbuR452ioCaNIkDGZeydOohwQSCpnrOdAKO2pLsWOljRWHxw2GDv"
    "kMHtFWqizbtFY1+pOVytAdc3KLWTAT6dEfEmF7CrXzCCeHds6bUaRpZMnEPfoc5BJhHe9Mmd"
    "gocmYgKgDc1ACumyZ8Ti7TXg9ILH+SXy84MA1AQhUzk1hQQtxfofTYYsa2c2bwZ4x5T8Sx/W"
    "y6Ur8buNhEc/tA3YT5A/yyKcWRxMX140V9g8lIMpHGIXpKdCsjyl9mcvNd99e4EHbxfI/7i8"
    "fxTof49MCS6vAgvrgwlJ/xm9UwUOPsBFRm/QiaAWaaddHy6d2maCZO937KLz7+G8vNKTiIEJ"
    "q6Hp0b6PACLqv8XdNI3aBSYPk05VeXHe497bBCOF9wfg0jvAqzRBansANOIck5RFmRqgdDbV"
    "NKcaAAk5Mx9mi+haaf59/rrDz2cdVpv//+XXax7PnnNYXM/59GaEui1C7DpN3aKTJuoDjhh8"
    "cEL1BekztppH1zNzDrMEcmwqwmE647bSrTGgvnNt3eNvVz1Ov+lwpbqF05AoSat0Zhd8gAWf"
    "AKztOqG1eaaSkLlpI0bAifsNKkPAk6cdnl5yeK5MAGW06dr2Eg05YLmmZdeF9eNHDF56nSa8"
    "3CtOnnkkY5Q5GUKUrvB8gwB4UuNf1e00Pjm7hZrzd68LnjwCfPchg1+96rDe4EXrwl9mvNAU"
    "sGQT6HDJY5Rz73bBVz5usDsWnFugs9k+D6ZpIxawVsGiZhKMNTNGgbpexwQkyBNE7oTCeXZe"
    "8NO/AF+7T3DkWIRFSvkv2rhFrWn207FvyIfQu5MZcje1tVD1+N5pj+urGGiRYq0NJrg+Wqw9"
    "Pg9DDQuGHpFmzN0uJOtcfCP5enpWpWFCutvjc5MGB3fkeeF+RF3maoKFVY9TF4FTlwjynR6f"
    "HpFBLa5ghFm34NfI2Woq1oSQA0hbtGXkQsRqRjTcf+KowdiY4MQvBE/dTPHsGYOdRfYB7Ia6"
    "dLwoY8ldpGmqjSicO/nVCDPnHX4/11cLfA2SDkMSap2lW00fnFA9ynGVMn2qTwQbcE8Z/+Y1"
    "i598McGPH/X0gSjYfr3hORP8ezkNUk7sEvpAjDvGPX9d8IEx8jjzNnmmPQCEjTREgARTh2Lk"
    "fG7rzCqxUS1185CmzJcZUj96weLEZ6MtfMAEsJt94MoK8M1fZ7j6n8Eu2aIY2jnnJI80307F"
    "+hEAaCSEitNRrQvr584Cr7zl8NinPI7eFeGesdwHDn1g0AfmmXanzwme/7vDpeW8UQ3FraMB"
    "FVSBuDzn5k6o3Y1u+jxtuk4PqhpAb33hmscTpyye+SPzfEVyZw1OSKC6YpW7tmawWo/yc9Lj"
    "080Dos1MroFQeIkgltB2srVGITgt++Fgn1jDs28tdBrL1HmVGW5xLfhvly7veuMtz8V9CFzQ"
    "CAVmKKYmN70ZLRN/o4Uiodhog5sNFFistRvvX7/b92a6rdadqcpkOUCJbwnXZOIqbsB8erKI"
    "paUFbB+JGJvUA5vJWDZoOqa8bAgJW3HDFFqmwxvNmOwb34sukRoiRpN20JLUETFcdU/pHFux"
    "EsN1R8Vi9cYS7p0cg3nsM5NoVq9hnW/Bid1FMnFo0PGEB2M+TTJbYfcWhe7WSyEUkswNocXu"
    "pmHyPX28ONJZpTM9utRVcrqozBa9gHK0jkk67lJ1Db5+BZ8/dGeepn4w8w9/cvoN3PGJwxjZ"
    "PooGE0pLm1UVmU+0brnrs6f0/XZm/mYwt7wj1c8YgBjh4+dG9SYuXziLpx6ZwtePHujV3qdP"
    "zfpnCKJZ2onRHbvgkoQATHh6bR7Sj0Vk8O3Y/5TrA2DSOlaWlmm6VXz70Y/iG0c+0nucdsYv"
    "/3TRz7y8gDdurFJ9VKiLIb2bun0hA4kKScOelw6FCT2l6RSzNsb8DAVhKz05keDhg1P48oNT"
    "3Xv/CzAtpFE0X7e2AAAAAElFTkSuQmCC"
)


"""Toolbar icon for commit button in database table grids."""
ToolbarCommit = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB3RJTUUH3AEaFDUPgk08NAAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAABHSURBVHjaY2CgKajn+w/G"
    "eAATpXaMGoDNAFwhj0OcEatCfKDxEyN+A/AZgqYZtwHYDMGimTAgIiVSDBDOItUmqJcoTgcU"
    "AwAXqRhzWeRKpQAAAABJRU5ErkJggg=="
)


"""Toolbar icon for contacts button on search page."""
ToolbarContact = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjEgbeRydHMgMjAxMyAyMjo0NjoyMSArMDIwMGnY+V8AAAAHdElNRQfdAxUVAARfk92u"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAATFJREFUeNqlkrGKg0AQ"
    "hjeXE1QIFlaW2oiVjYUWGsFK8Bks7H0GzRNY2ecNAja2e21II9gJipJXSKGiOdci5LzsGbi/"
    "2eXf2W9nZgeAf2qDO0jTdF9VlYn2PM8D27YPbwGyLNsnSRI2TWMOwzB72+0WSJIEDMMwFUX5"
    "eo7/XAJOp9N8+dlDoDzPQdu2cPnoxyLt4Hq9mgCjoijA8XgMsICpZjCO459NO5/PAAsgCGK1"
    "67vdDg9gGGYVwLIsHgAhXAWUZYkHqKq6ChBFEQ9wXfcwlYFNg6ZpqOs6xAKQLMvCAjRNg8tB"
    "ejnKvu/fb7fbD4+iKBDH8a/4h3G5XNAIm9NXhnVdv5wHjuNQGaHjOFCW5TmTTRRFQdd1Iepu"
    "3/erTUQiSRIIgoDWcON53v2tWxh9A8ITakM7BOFPAAAAAElFTkSuQmCC"
)


"""Toolbar icon for delete button in database table grids."""
ToolbarDelete = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB3RJTUUH3AEbFAgjYsF/DAAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAAkSURBVHjaY2AYBcMAMCJz"
    "TvDx/SdGk8WnT3B9TAPtg1EwKAAAoFkEBI8Fc8MAAAAASUVORK5CYII="
)


"""Toolbar icon for filter chat button in chat page."""
ToolbarFilter = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAYVJREFUeNqUUsFKAlEUPa95OqOptHBTiUZtwjCCCYJA0I27"
    "6BPyD4Q+wIVf4ipctGnrxr3Q1hZCBJWrChHR0nFe9zqpM+TieeHO4717znnnvrl4FQJvlPeU"
    "FBeUN7zy/v0v19WYw1wx/wA1KmQflDoodjp2K5t9vBbiBb5YU+sooConXv3ssFa7KjSb6Ha7"
    "KOTz9n6xaPsFCq3WqlYq2c/VapjP5bdXN93hEB+DAZ7KZeyk03D6fT8/UGMs8cy5wEgpXiPu"
    "aITLRgMn7TZCponPVArxen0pcJrL4SiTwXYiAcYSLxJwMKPDXqWCSDSKKR2MaW8lk0sBfsZY"
    "LAa4Lhi7cIBjL2/VhsEc5krlXWC41IqrFHRii/4cIQ34BRwWmM30BAxjJYCFAPXmaApIb7AC"
    "DiQ7mDiOlgA8BzLYAjmYagpshUL/3kCywESzBYOwSwdj6sfiOeAWNAXChFVCmDxDsqfUXkaI"
    "uCHlfIi0HBCWroozl23sjoGvc8u6wwbxQxzm/gowAL873XjUIXE3AAAAAElFTkSuQmCC"
)


"""Toolbar icon for insert button in database table grids."""
ToolbarInsert = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB3RJTUUH3AEbFAgw5n8+0gAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAAvSURBVHjaY2AY3oCP78R/"
    "EManholSSwbeAEZ0PxOj6dMnC7g+il2AF4yQWBgGAADm3wucN+5mGAAAAABJRU5ErkJggg=="
)


"""Toolbar icon for maximize chat button in chat page."""
ToolbarMaximize = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9i"
    "ZSBJbWFnZVJlYWR5ccllPAAAAhZJREFUeNqMUr1rU1EU/7373kteW5QOrVJBEVQ0k8MtONSK"
    "LhWpiotQNUJx6ZrRP8DBUdBBcRGMi3+AU6HWRRQz2KUhwcmEQEIeeUljk/u+POf50rxnOvTA"
    "vefe8/E7n1oYhrjxrvUGgMTRqbS1Pr/BD4Mv3/Pk2sqCdN1JS8JPkUEeHzcb4z9fge+XPnz6"
    "feTwmqaVUgBUxkaYCEUZsTBPlgXiL4gXdcM4FEwkP4N+H33HgadU3vO8wqPVs5I5/1nO+kMB"
    "eraNVq0WGVAmec91C/k752W53MPD1XOS/yxnPduxfQqgGwsiZ6UKj+/lyLkL3w9QqfTw4PZF"
    "yXLWJ+1TJYwir9+/LKvVHlwaiUNpNxoNbG/v4ta10weZTPYgjvxkbVE2m/vUswE6nRba7TaE"
    "CDA7a6Fe72Dl6pkoEyRAotZSo5Z5Cq/ebh2MZ2npglT7Po7PWPjy9VfpvzEuEyumxxgEo1J4"
    "jD8ckUU3E8Ik7g6HoDEukmOct0gv0ohooTAcDKK3bU7BnjIBU4erVHSylgWh6+nNjMb4vQhV"
    "24GeuwtxIhcDTKNjUVYZwXsRyVTtJ/5sPsOxK9yCmwmAb8V/cPUdZK8/hTZ/CY6RxV6GsqWA"
    "1H2ErTKGn59jbP9+YhMZbI6MTvnkwPVOmxo0oYH/LCf9STqZiRJi4uLm6Mz4zd2K/fL1WGNX"
    "K3QvcBV09mIe0V8BBgDmbCZA3KkdNgAAAABJRU5ErkJggg=="
)


"""Toolbar icon for message toggle button on search page."""
ToolbarMessage = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjEgbeRydHMgMjAxMyAyMjoyNzo0OSArMDIwMJsvH8IAAAAHdElNRQfdAxUVATP+NUng"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAADlJREFUeNpjYKAQMIKI"
    "pKSk/+RonjdvHiMTpS4YNWDUABBgxCWBnjpBqY4sG0AGkZvUqW8IRQbgAgCLFhLOKKE9wQAA"
    "AABJRU5ErkJggg=="
)


"""Toolbar icon for rollback button in database table grids."""
ToolbarRollback = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB3RJTUUH3AEaFDUVfy/FTgAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAABHSURBVHjaY2CgEDDCWcL1"
    "/0nS+bYRrJeJUhfQGIC8RcBrjHg1Y/EzcQbgshWLIYxEa8ZhCBNRCnE4nzAgIhApTgejBlAB"
    "AACTkRU1bx46WQAAAABJRU5ErkJggg=="
)


"""Toolbar icon for stats button in chat page."""
ToolbarStats = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB3RJTUUH3QMZFCYg61pv1AAA"
    "AAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAHpSURBVHjapZO/ahtBEMa/"
    "XUuyJXAs2Q7YhDSCFEkj8L5ButRpUghjgyEuz4bkIVKJ4DIQCCr8BiZgUqdRQIXShKRQI4Nk"
    "+4Tks+7frmf3VneSkKsMzN3e3Hy/3Z2dZUop/I/l9IMd8WSkfQV1ejqP5DcQo4mIRuTqi0wA"
    "M1anBOfFiRCBO0kiMnkVKmv402hNwc25FaTiiMQfhHA7AxPwe/fmvbpbhNcbo3pcE//O2nMQ"
    "Pic+3RPXP3uIRyG8vyMM318Z12Mdc9t9PD94KXSu0aSAEE7VqYmryy7CYWBcTuJ0aXo8jbu/"
    "+th5WxVak20hBIada8R3sZnJiDwJvp8HAgVWymHij4E8A6/k4Xc9o5kDxDRL5IbprGyVQ35L"
    "vvkhgcrJYmUQQUm2ANBHEknzc6kVCbiRANQK5Uy40WSAgCru3SNeI+ytFQUzgMgKramiTP9n"
    "KyhTUB/9E5s1mgHskK8vrMryuP1o+F/HLf6MeGUkXppJLiGLk6uLuKU1plb6LrDXxAlVnbrO"
    "4acFoeth7LcFvMpY6nPUomkbdCJN9UNaAGP6DgBPqTm24bBPObGsluojiQck7lMXUpsYrQXo"
    "WmyRb9Ne32AT75aexg3OqTbfadQnH5A2mgK43Wlp4X4sM92id+QeaeUD+ILiaqdNXpsAAAAA"
    "SUVORK5CYII="
)


"""Toolbar icon for stop button on search page."""
ToolbarStop = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjEgbeRydHMgMjAxMyAyMTo1ODowNSArMDIwML0/WYwAAAAHdElNRQfdAxUTOiUy3m87"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAAZ0Uk5TANQA0ADICuWh"
    "ugAAANVJREFUeNpjvHLhBAMpgAWZ83vmwgfTp6OpUMjMZE2Px6IBoto/ORlNw8bp0xUYGOB6"
    "mPCrBgKgIFAKqAChAY9qTD2MQE/fNrDAoxrhtrlzVS+cgPrhz+/fEAbrQpAxv+Pj0djonv75"
    "4weUER7Os3IlRCkQfAkPR7OHCa4Bjt76+0MEgQxkcVQbvn+HmyG1axeEIbxx4zM3NwI2QFTf"
    "t7MDIohmNBtAoQQJVm0LCzxBdPXECUiUg2wAUkAOUIigaoST8OhBVs2AnJZAeoDShBIfI6nJ"
    "GwC7TZxZQGalGAAAAABJRU5ErkJggg=="
)


"""Toolbar icon for inactive stop button on search page."""
ToolbarStopped = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjEgbeRydHMgMjAxMyAyMTo1ODowNSArMDIwML0/WYwAAAAHdElNRQfdAxYXCxC3jKuY"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAIZJREFUeNpjYCAAGGGM"
    "9v9rkYSDGSoZURSApGORFCyGK2HEJo2shBG7NEIJUIHJf2zSECVnGFlAjN9gbjEQ9yLREABW"
    "8BPMbGOoAkuCWAjABCJ+QGEdWKgOzsdQ0AQWasKloAvIygNCBiALoQDqTRMsfjgD8yZ2JWcQ"
    "AYVNyRnUoMYXWQQBALXDQEUeuvmAAAAAAElFTkSuQmCC"
)


"""Toolbar icon for tables button on search page."""
ToolbarTables = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAcZJ"
    "REFUOI2dk81qIkEQx38zjh8T3KsYDyLxc1T0CXLMcV9Ddm8+iA+wz5B3kRCJDoiCeNnTgLDg"
    "qNNdtYfsiMbLJgUF1d3Uv3/9L9oZj8ffM5nMPV8Ia+1vT1Urk8nk11cExuPxD09VHYDn52dU"
    "9Zwics7LdXo+Go1QVcdNksQVEQCCIACg0+lc1e12+6YWEZIkcT1rraOqAIRhSLFYZLfbISKU"
    "y2V2ux2qelOrKtZaxzPGuKlAEAREUcTj4yMAi8WCbrcLwOvrK8PhEIDpdIqqYox5J0ifEIYh"
    "pVKJ5XKJiOD7Pm9vb6gqd3d3vLy8kF4mIlhrHdcYc+NBvV6n2WwSxzFBENDtdtnv9wwGgzOF"
    "iLwTXAqkBOv1GhGhUCgQhiGqiu/7zGazKwJjjOsmSeJ8JKjVajw8PHA4HGi1WrTbbeI4ptfr"
    "0e/3L6dwbWJKsNlsEBFyuRzL5RJVJZ/PM5/PzwSpia619moKANVqlVqtxul0otFo0Gw2OR6P"
    "Zz9SAWut68VxnPnowXa7Jd1brVZcEl56EMdxxouiKJ/NZnl6evrvPwCQzWaJoijvVCqVn7lc"
    "rvqp7n9xOp22DuAD3wDvk/0G+PMX80pIbz0EU9oAAAAASUVORK5CYII="
)


"""Toolbar icon for tabs toggle button on search page."""
ToolbarTabs = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5F"
    "VCB2My41LjEwMPRyoQAAASNJREFUOE+d0b1qg1AYxvF3Chkyd+gUehfF1dHF0VJwMm3sh0IK"
    "RRA0d+TuBXgBvYIgKH4hRiIxGk99pEuhkJwe+OPrCz+OIDmOc+e6rjI+Vwjzdru9v2YHS7Zt"
    "PyRJ8sV+DmbTNFfX7GDJsqynYRjY+Xyewuz7/vS8tIOlzWbz3Pc967puCrPneSwIgl/9tYMl"
    "wzDWp9OJHY/HqbZtGd4vhctgSdf1NeDhcOAKBpY0TdObpmH7/Z4rGFhSVfWlrmtWliVXMLCk"
    "KMprVVUsz3OuYGBJluU33D7+d65gYEmSpPeiKFgURVzBwJIoikaapiwMQ65gYEkQBBOfv9vt"
    "uIKBpeVy+ZFlGYvjmCsYWJrP54+LxeLzP8HSeGZjN2O3nMHMvgFTmvUJKTInOAAAAABJRU5E"
    "rkJggg=="
)


"""Toolbar icon for title toggle button on search page."""
ToolbarTitle = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AE4gMjEgbeRydHMgMjAxMyAyMjowNjo0MSArMDIwMB9ug1oAAAAHdElNRQfdAxUVAhfpG/7y"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAEJJREFUeNpjYBhowAhj"
    "JCUl/SdF47x588B6WXBJIBuKTQwGmHBpJmQzUQBkGyGvMRFr2KgBw9oArKkKV+IhKRUSCwAF"
    "qxgZvjJU7QAAAABJRU5ErkJggg=="
)

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-
"""
Skyperious main program entrance: launches GUI application or executes command
line interface, handles logging and status calls.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     26.11.2011
@modified    27.04.2014
------------------------------------------------------------------------------
"""
import argparse
import atexit
import codecs
import collections
import datetime
import glob
import locale
import itertools
import Queue
import os
import shutil
import sys
import threading
import time
import traceback

try:
    import wx
    is_gui_possible = True
except ImportError:
    is_gui_possible = False
try: # For printing to a console from a packaged Windows binary
    import win32console
except ImportError:
    win32console = None

import conf
import export
import skypedata
import util
import workers
if is_gui_possible:
    import guibase
    import skyperious
    import support

ARGUMENTS = {
    "description": "%s - Skype SQLite database viewer and merger." % conf.Title,
    "arguments": [
        {"args": ["--verbose"], "action": "store_true",
         "help": "print detailed progress messages to stderr"}, ],
    "commands": [
        {"name": "export",
         "help": "export Skype databases as HTML, text or spreadsheet",
         "description": "Export all message history from a Skype database "
                        "into files under a new folder, or a single Excel "
                        "workbook with chats on separate sheets.",
         "arguments": [
             {"args": ["-t", "--type"], "dest": "type",
              "choices": ["html", "xlsx", "csv", "txt", "xlsx_single"],
              "default": "html", "required": False,
              "help": "export type: HTML files (default), Excel workbooks, "
                      "CSV spreadsheets, text files, or a single Excel "
                      "workbook with separate sheets", },
             {"args": ["FILE"], "nargs": "+",
              "help": "one or more Skype databases to export", }, 
             {"args": ["--verbose"], "action": "store_true",
              "help": "print detailed progress messages to stderr"}, ],
        }, 
        {"name": "search",
         "help": "search Skype databases for messages or data",
         "description": "Search Skype databases for messages, chat or contact "
                        "information, or table data.",
         "arguments": [
             {"args": ["-t", "--type"], "dest": "type", "required": False,
              "choices": ["message", "contact", "chat", "table"],
              "default": "message",
              "help": "search in message body (default), in contact "
                      "information, in chat title and participants, or in any "
                      "database table", },
             {"args": ["QUERY"],
              "help": "search query, with a Google-like syntax, for example: "
                      "\"this OR that chat:links from:john\". More on syntax "
                      "at https://suurjaak.github.io/Skyperious/help.html. " },
             {"args": ["FILE"], "nargs": "+",
              "help": "Skype database file(s) to search", },
             {"args": ["--verbose"], "action": "store_true",
              "help": "print detailed progress messages to stderr"}, ],
        }, 
        {"name": "merge", "help": "merge two or more Skype databases "
                                  "into a new database",
         "description": "Merge two or more Skype database files into a new "
                        "database in current directory, with a full combined "
                        "message history. New filename will be chosen "
                        "automatically. Last database in the list will "
                        "be used as base for comparison.",
         "arguments": [
             {"args": ["FILE1"], "metavar": "FILE1", "nargs": 1,
              "help": "first Skype database"},
             {"args": ["FILE2"], "metavar": "FILE2", "nargs": "+",
              "help": "more Skype databases"},
             {"args": ["--verbose"], "action": "store_true",
              "help": "print detailed progress messages to stderr"}, ],
        }, 
        {"name": "diff", "help": "compare chat history in two Skype databases",
         "description": "Compare two Skype databases for differences "
                        "in chat history.",
         "arguments": [
             {"args": ["FILE1"], "help": "first Skype database", "nargs": 1},
             {"args": ["FILE2"], "help": "second Skype databases", "nargs": 1},
             {"args": ["--verbose"], "action": "store_true",
              "help": "print detailed progress messages to stderr"}, ],
        }, 
        {"name": "gui",
         "help": "launch Skyperious graphical program (default option)",
         "arguments": [
             {"args": ["FILE"], "nargs": "*",
              "help": "Skype database to open on startup, if any"}, ]
        },
    ],
}


window = None         # Application main window instance
deferred_logs = []    # Log messages cached before main window is available
deferred_status = []  # Last status cached before main window is available
is_cli = False        # Is program running in command-line interface mode
is_verbose = False    # Is command-line interface verbose


def log(text, *args):
    """
    Logs a timestamped message to main window.

    @param   args  string format arguments, if any, to substitute in text
    """
    global deferred_logs, is_cli, is_verbose, window
    now = datetime.datetime.now()
    try:
        finaltext = text % args if args else text
    except UnicodeError:
        args = tuple(map(util.to_unicode, args))
        finaltext = text % args if args else text
    if "\n" in finaltext: # Indent all linebreaks
        finaltext = finaltext.replace("\n", "\n\t\t")
    msg = "%s.%03d\t%s" % (now.strftime("%H:%M:%S"), now.microsecond / 1000,
                           finaltext)
    if window:
        process_deferreds()
        wx.PostEvent(window, guibase.LogEvent(text=msg))
    elif is_cli and is_verbose:
        sys.stderr.write(msg + "\n"), sys.stderr.flush()
    else:
        deferred_logs.append(msg)


def status(text, *args):
    """
    Sets main window status text.

    @param   args  string format arguments, if any, to substitute in text
    """
    global deferred_status, is_cli, is_verbose, window
    try:
        msg = text % args if args else text
    except UnicodeError:
        args = tuple(map(util.to_unicode, args))
        msg = text % args if args else text
    if window:
        process_deferreds()
        wx.PostEvent(window, guibase.StatusEvent(text=msg))
    elif is_cli and is_verbose:
        sys.stderr.write(msg + "\n")
    else:
        deferred_status[:] = [msg]



def status_flash(text, *args):
    """
    Sets main window status text that will be cleared after a timeout.

    @param   args  string format arguments, if any, to substitute in text
    """
    global deferred_status, window
    try:
        msg = text % args if args else text
    except UnicodeError:
        args = tuple(map(util.to_unicode, args))
        msg = text % args if args else text
    if window:
        process_deferreds()
        wx.PostEvent(window, guibase.StatusEvent(text=msg))
        def clear_status():
            if window.StatusBar and window.StatusBar.StatusText == msg:
                window.SetStatusText("")
        wx.CallLater(conf.StatusFlashLength, clear_status)
    else:
        deferred_status[:] = [msg]


def logstatus(text, *args):
    """
    Logs a timestamped message to main window and sets main window status text.

    @param   args  string format arguments, if any, to substitute in text
    """
    log(text, *args)
    status(text, *args)


def logstatus_flash(text, *args):
    """
    Logs a timestamped message to main window and sets main window status text
    that will be cleared after a timeout.

    @param   args  string format arguments, if any, to substitute in text
    """
    log(text, *args)
    status_flash(text, *args)


def process_deferreds():
    """
    Forwards log messages and status, cached before main window was available.
    """
    global deferred_logs, deferred_status, window
    if window:
        if deferred_logs:
            for msg in deferred_logs:
                wx.PostEvent(window, guibase.LogEvent(text=msg))
            del deferred_logs[:]
        if deferred_status:
            wx.PostEvent(window, guibase.StatusEvent(text=deferred_status[0]))
            del deferred_status[:]


def run_merge(filenames):
    """Merges all Skype databases to a new database."""
    dbs = [skypedata.SkypeDatabase(f) for f in filenames]
    db_base = dbs.pop()
    counts = collections.defaultdict(lambda: collections.defaultdict(int))
    postbacks = Queue.Queue()
    postfunc = lambda r: postbacks.put(r)
    worker = workers.MergeThread(postfunc)

    name, ext = os.path.splitext(os.path.split(db_base.filename)[-1])
    now = datetime.datetime.now().strftime("%Y%m%d")
    filename_final = util.unique_path("%s.merged.%s%s" %  (name, now, ext))
    print("Creating %s, using %s as base." % (filename_final, db_base))
    shutil.copyfile(db_base.filename, filename_final)
    db2 = skypedata.SkypeDatabase(filename_final)
    chats2 = db2.get_conversations()
    db2.get_conversations_stats(chats2)

    for db1 in dbs:
        chats = db1.get_conversations()
        db1.get_conversations_stats(chats)
        bar_total = sum(c["message_count"] for c in chats)
        bar_text = " Processing %.*s.." % (30, db1)
        bar = ProgressBar(max=bar_total, afterword=bar_text)
        bar.start()
        args = {"db1": db1, "db2": db2, "chats": chats,
                "type": "diff_merge_left"}
        worker.work(args)
        while True:
            result = postbacks.get()
            if "error" in result:
                print("Error merging %s:\n\n%s" % (db1, result["error"]))
                worker = None # Signal for global break
                break # break while True
            if "done" in result:
                break # break while True
            if "diff" in result:
                counts[db1]["chats"] += 1
                counts[db1]["msgs"] += len(result["diff"]["messages"])
                msgcounts = sum(c["message_count"] for c in result["chats"])
                bar.update(bar.value + msgcounts)
            if result["output"]:
                log(result["output"])
        if not worker:
            break # break for db1 in dbs
        bar.stop()
        bar.afterword = " Processed %s." % db1
        bar.update(bar_total)
        print

    if not counts:
        print("Nothing new to merge.")
        db2.close()
        os.unlink(filename_final)
    else:
        for db1 in dbs:
            print("Merged %s in %s from %s." %
                  (util.plural("message", counts[db1]["msgs"]),
                   util.plural("chat", counts[db1]["chats"]), db1))
        print("Merge into %s complete." % db2)


def run_search(filenames, query):
    """Searches the specified databases for specified query."""
    dbs = [skypedata.SkypeDatabase(f) for f in filenames]

    postbacks = Queue.Queue()
    postfunc = lambda r: postbacks.put(r)
    worker = workers.SearchThread(postfunc)

    for db in dbs:
        log("Searching \"%s\" in %s." % (query, db))
        args = {"db": db, "text": query, "table": "messages", "output": "text"}
        worker.work(args)
        while True:
            result = postbacks.get()
            if "error" in result:
                print("Error searching %s:\n\n%s" %
                      (db, result.get("error_short", result["error"])))
                break # break while True
            if "done" in result:
                log("Finished searching for \"%s\" in %s.", query, db)
                break # break while True
            if result.get("count", 0) or is_verbose:
                if len(dbs) > 1:
                    print "%s:" % db,
                print(result["output"])


def run_export(filenames, format):
    """Exports the specified databases in specified format."""
    dbs = [skypedata.SkypeDatabase(f) for f in filenames]
    is_xlsx_single = ("xlsx_single" == format)

    for db in dbs:
        formatargs = collections.defaultdict(str)
        formatargs["skypename"] = os.path.basename(db.filename)
        formatargs.update(db.account or {})
        basename = util.safe_filename(conf.ExportDbTemplate % formatargs)
        dbstr = "from %s " % db if len(dbs) != 1 else ""
        if is_xlsx_single:
            export_dir = os.getcwd()
            filename = util.unique_path("%s.xlsx" % basename)
        else:
            export_dir = util.unique_path(os.path.join(os.getcwd(), basename))
            filename = format
        target = filename if is_xlsx_single else export_dir
        try:
            print("Exporting as %s %sto %s." % 
                  (format[:4].upper(), dbstr, target))
            chats = sorted(db.get_conversations(),
                           key=lambda x: x["title"].lower())
            db.get_conversations_stats(chats)
            bar_total = sum(c["message_count"] for c in chats)
            bartext = " Exporting %.*s.." % (30, db.filename) # Enforce width
            bar = ProgressBar(max=bar_total, afterword=bartext)
            bar.start()
            result = export.export_chats(chats, export_dir, filename, db,
                                         progress=lambda x: bar.update(x))
            files, count = result
            bar.stop()
            if count:
                bar.afterword = " Exported %s to %s. " % (db, target)
                bar.update(bar_total)
                print
                log("Exported %s %sto %s as %s.", util.plural("chat", count),
                     dbstr, target, format)
            else:
                print("\nNo messages to export%s." %
                      ("" if len(dbs) == 1 else " from %s" % db))
                os.unlink(filename) if is_xlsx_single else os.rmdir(export_dir)
        except Exception as e:
            print("Error exporting chats: %s\n\n%s" % 
                  (e, traceback.format_exc()))


def run_diff(filename1, filename2):
    """Compares the first database for changes with the second."""
    if os.path.realpath(filename1) == os.path.realpath(filename2):
        print("Error: cannot compare %s with itself." % filename1)
        return
    db1, db2 = map(skypedata.SkypeDatabase, [filename1, filename2])
    counts = collections.defaultdict(lambda: collections.defaultdict(int))
    postbacks = Queue.Queue()
    postfunc = lambda r: postbacks.put(r)
    worker = workers.MergeThread(postfunc)

    chats1, chats2 = db1.get_conversations(), db2.get_conversations()
    db1.get_conversations_stats(chats1), db2.get_conversations_stats(chats2)
    for db in [db1, db2]:
        db.get_conversations_stats(db.get_conversations())
    bar_total = sum(c["message_count"] for c in chats1)
    bar_text = "%.*s.." % (50, " Scanning %s vs %s" % (db1, db2))
    bar = ProgressBar(max=bar_total, afterword=bar_text)
    bar.start()
    args = {"db1": db1, "db2": db2, "chats": chats1, "type": "diff_left"}
    worker.work(args)
    while True:
        result = postbacks.get()
        if "error" in result:
            print("Error scanning %s and %s:\n\n%s" %
                  (db1, db2, result["error"]))
            worker = None # Signal for global break
            break # break while True
        if "done" in result:
            break # break while True
        if "chats" in result and result["chats"]:
            counts[db1]["chats"] += 1
            msgs = len(result["chats"][0]["diff"]["messages"])
            msgs_text = util.plural("new message", msgs)
            contacts_text = util.plural("new participant", 
                            result["chats"][0]["diff"]["participants"])
            text = ", ".join(filter(None, [msgs_text, contacts_text]))
            print("%s, %s." % (result["chats"][0]["chat"]["title_long"], text))
            counts[db1]["msgs"] += msgs
            bar.update(bar.value + result["chats"][0]["chat"]["message_count"])
        if result["output"]:
            log(result["output"])
    bar.stop()
    bar.afterword = " Scanned %s and %s." % (db1, db2)
    bar.update(bar_total)
    print


def run_gui(filenames):
    """Main GUI program entrance."""
    global deferred_logs, deferred_status, window

    # Values in some threads would otherwise not be the same
    sys.modules["main"].deferred_logs = deferred_logs
    sys.modules["main"].deferred_status = deferred_status

    # Create application main window
    app = wx.App(redirect=True) # stdout and stderr redirected to wx popup
    window = sys.modules["main"].window = skyperious.MainWindow()
    app.SetTopWindow(window) # stdout/stderr popup closes with MainWindow
    # Decorate write to catch printed errors
    try: sys.stdout.write = support.reporting_write(sys.stdout.write)
    except: pass

    # Some debugging support
    window.run_console("import datetime, os, re, time, sys, wx")
    window.run_console("# All %s modules:" % conf.Title)
    window.run_console("import conf, controls, emoticons, export, guibase, "
                       "images, main, searchparser, skypedata, skyperious, "
                       "support, templates, util, wordcloud, workers, "
                       "wx_accel")

    window.run_console("self = main.window # Application main window instance")
    log("Started application on %s.", datetime.date.today())
    for f in filter(os.path.isfile, filenames):
        wx.CallAfter(wx.PostEvent, window, skyperious.OpenDatabaseEvent(file=f))
    app.MainLoop()


def run(argv):
    """Parses command-line arguments and either runs GUI, or a CLI action."""
    global is_cli, is_gui_possible, is_verbose

    if (getattr(sys, 'frozen', False) # Binary application
    or sys.executable.lower().endswith("pythonw.exe")):
        sys.stdout = ConsoleWriter(sys.stdout) # Hooks for attaching to 
        sys.stderr = ConsoleWriter(sys.stderr) # a text console

    argparser = argparse.ArgumentParser(description=ARGUMENTS["description"])
    for arg in ARGUMENTS["arguments"]:
        names = arg["args"]; del arg["args"]
        argparser.add_argument(*names, **arg)
    subparsers = argparser.add_subparsers(dest="command")
    for cmd in ARGUMENTS["commands"]:
        kwargs = dict((k, cmd[k]) for k in cmd if k in ["help", "description"])
        subparser = subparsers.add_parser(cmd["name"], **kwargs)
        for arg in cmd["arguments"]:
            kwargs = dict((k, arg[k]) for k in arg if k != "args")
            subparser.add_argument(*arg["args"], **kwargs)

    if not argv or (argv[0] not in subparsers.choices 
    and argv[0].endswith(".db")):
        argv[:0] = ["gui"] # argparse hack: force default argument
    if argv[0] in ("-h", "--help") and len(argv) > 1:
        argv[:2] = argv[:2][::-1] # Swap "-h option" to "option -h"

    arguments = argparser.parse_args(argv)

    if hasattr(arguments, "FILE1") and hasattr(arguments, "FILE2"):
        arguments.FILE1 = [util.to_unicode(f) for f in arguments.FILE1]
        arguments.FILE2 = [util.to_unicode(f) for f in arguments.FILE2]
        arguments.FILE = arguments.FILE1 + arguments.FILE2
    if arguments.FILE: # Expand wildcards to actual filenames
        arguments.FILE = sum([(sorted(glob.glob(f)) if "*" in f else [f])
                             for f in arguments.FILE], [])
        arguments.FILE = [util.to_unicode(f) for f in arguments.FILE]

    if "gui" == arguments.command and not is_gui_possible:
        argparser.print_help()
        print("\n\nwxPython not found. %s graphical program will not run." %
              conf.Title)
        sys.exit()
    elif "gui" != arguments.command:
        conf.load()
        is_cli = sys.modules["main"].is_cli = True
        is_verbose = sys.modules["main"].is_verbose = arguments.verbose
        enc = sys.stdout.encoding or locale.getpreferredencoding() or "utf-8"
        if "nt" == os.name: # Avoid print encoding errors under windows
            sys.stdout = codecs.getwriter(enc)(sys.stdout, "xmlcharrefreplace")
            sys.stderr = codecs.getwriter(enc)(sys.stderr, "xmlcharrefreplace")

    if "diff" == arguments.command:
        run_diff(*arguments.FILE)
    elif "merge" == arguments.command:
        run_merge(arguments.FILE)
    elif "export" == arguments.command:
        run_export(arguments.FILE, arguments.type)
    elif "search" == arguments.command:
        run_search(arguments.FILE, arguments.QUERY)
    elif "gui" == arguments.command:
        run_gui(arguments.FILE)


class ConsoleWriter(object):
    """
    Wrapper for sys.stdout/stderr, attaches to the parent console or creates 
    a new command console, usable from python.exe, pythonw.exe or
    compiled binary. Hooks application exit to wait for final user input.
    """
    handle = None # note: class variables
    is_loaded = False
    realwrite = None

    def __init__(self, stream):
        """
        @param   stream  sys.stdout or sys.stderr
        """
        self.encoding = getattr(stream, "encoding", locale.getpreferredencoding())
        self.stream = stream


    def flush(self):
        if not ConsoleWriter.handle and ConsoleWriter.is_loaded:
            self.stream.flush()
        elif hasattr(ConsoleWriter.handle, "flush"):
            ConsoleWriter.handle.flush()


    def write(self, text):
        """
        Prints text to console window. GUI application will need to attach to
        the calling console, or launch a new console if not available.
        """
        global window
        if not window and win32console:
            if not ConsoleWriter.is_loaded and not ConsoleWriter.handle:
                try:
                    win32console.AttachConsole(-1) # pythonw.exe from console
                    atexit.register(lambda: ConsoleWriter.realwrite("\n"))
                except Exception:
                    pass # Okay if fails: can be python.exe from console
                try:
                    handle = win32console.GetStdHandle(
                                          win32console.STD_OUTPUT_HANDLE)
                    handle.WriteConsole("\n" + text)
                    ConsoleWriter.handle = handle
                    ConsoleWriter.realwrite = handle.WriteConsole
                except Exception: # Fails if GUI program: make new console
                    try: win32console.FreeConsole()
                    except Exception: pass
                    try:
                        win32console.AllocConsole()
                        handle = open("CONOUT$", "w")
                        argv = [util.longpath(sys.argv[0])] + sys.argv[1:]
                        handle.write(" ".join(argv) + "\n\n" + text)
                        handle.flush()
                        ConsoleWriter.handle = handle
                        ConsoleWriter.realwrite = handle.write
                        sys.stdin = open("CONIN$", "r")
                        exitfunc = lambda s: (handle.write(s), handle.flush(),
                                              raw_input())
                        atexit.register(exitfunc, "\nPress ENTER to exit.")
                    except Exception:
                        try: win32console.FreeConsole()
                        except Exception: pass
                        ConsoleWriter.realwrite = self.stream.write
                ConsoleWriter.is_loaded = True
            else:
                try:
                    self.realwrite(text)
                    self.flush()
                except Exception:
                    self.stream.write(text)
        else:
            self.stream.write(text)


class ProgressBar(threading.Thread):
    """
    A simple ASCII progress bar with a ticker thread, drawn like
    '[---------\   36%            ] Progressing text..'.
    """

    def __init__(self, max=100, value=0, min=0, width=30, forechar="-",
                 backchar=" ", foreword="", afterword="", interval=1):
        """
        Creates a new progress bar, without drawing it yet.

        @param   max        progress bar maximum value, 100%
        @param   value      progress bar initial value
        @param   min        progress bar minimum value, for 0%
        @param   width      progress bar width (in characters)
        @param   forechar   character used for filling the progress bar
        @param   backchar   character used for filling the background
        @param   foreword   text in front of progress bar
        @param   afterword  text after progress bar
        @param   interval   ticker thread interval, in seconds
        """
        threading.Thread.__init__(self)
        self.daemon = True # Daemon threads do not keep application running
        self.max = max
        self.min = min
        self.width = width
        self.forechar = forechar
        self.backchar = backchar
        self.foreword = foreword
        self.afterword = afterword
        self.interval = interval
        self.percent = None        # Current progress ratio in per cent
        self.value = None          # Current progress bar value
        self.bar = "%s[-%s]%s" % (foreword, " " * (self.width - 3), afterword)
        self.progresschar = itertools.cycle(["-", "\\", "|", "/"])
        self.is_running = False
        self.update(value, draw=False)


    def update(self, value, draw=True):
        """Updates the progress bar value, and refreshes by default."""
        self.value = min(self.max, max(self.min, value))
        new_percent = int(round(100.0 * self.value / (self.max or 1)))
        full_w = self.width - 2
        done_w = max(1, int(round((new_percent / 100.0) * full_w)))
        # Build bar outline, animate by cycling last char from progress chars
        char_last = self.forechar
        if draw and done_w < full_w: char_last = next(self.progresschar)
        self.bar = "%s[%s%s%s]%s" % (
                   self.foreword, self.forechar * (done_w - 1), char_last,
                   self.backchar * (full_w - done_w), self.afterword)
        # Write percentage into the middle of the bar
        centertxt = " %2d%% " % new_percent
        pos = len(self.foreword) + self.width / 2 - len(centertxt) / 2
        self.bar = self.bar[:pos] + centertxt + self.bar[pos + len(centertxt):]
        self.percent = new_percent
        if draw: self.draw()


    def draw(self):
        """Prints the progress bar, from the beginning of the current line."""
        print "\r" + self.bar,


    def run(self):
        self.is_running = True
        while self.is_running:
            self.update(self.value), time.sleep(self.interval)


    def stop(self):
        self.is_running = False


if "__main__" == __name__:
    run(sys.argv[1:])

########NEW FILE########
__FILENAME__ = searchparser
# -*- coding: utf-8 -*-
"""
Parses a Google-like search grammar into SQL for querying a Skype database.

- words can consist of any non-whitespace characters including all Unicode,
  excluding round brackets and quotes ()" 
- asterisk (*) can be used as a wildcard, matching any character or whitespace
- quoted text is a literal phrase: "one two  three   ."
- can use operator "OR" to make an either-or search: one OR two
- words can be grouped with round brackets: (one two) OR (three four)
- keywords chat:chatname, from:authorname,
  date:year[-month[-day]][..year[-month[-day]]],
  value can be in quotes, e.g. chat:"link chat". Keywords are global, ignoring
  all groups and OR-expressions.
- "-" immediately before: exclude words, phrases, grouped words and keywords
- can also provide queries to search all fields in any table

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     13.07.2013
@modified    11.04.2014
"""
import calendar
import collections
import datetime
import re
import string
import traceback
import warnings

from pyparsing import *

import util

UNPRINTABLES = "".join(set(unichr(i) for i in range(128))
                       .difference(string.printable))
ALLWORDCHARS = u"".join(set(unichr(c) for c in range(65536)
                        if not unichr(c).isspace())
                        .difference(UNPRINTABLES))
ALLCHARS = ALLWORDCHARS + string.whitespace
WORDCHARS = ALLWORDCHARS.replace("(", "").replace(")", "").replace("\"", "")
ESCAPE_CHAR = "\\" # Character used to escape SQLite special characters like _%
ParserElement.enablePackrat() # Speeds up recursive grammar significantly


class SearchQueryParser(object):

    # For naive identification of "chat:xyz" and "from:xyz" keywords
    PATTERN_KEYWORD = re.compile("^(-?)(chat|from)\:([^\s]+)$", re.I)


    def __init__(self):
        with warnings.catch_warnings():
            # In Python 2.6, pyparsing throws warnings on its own code.
            warnings.simplefilter("ignore")
            orOperator = Suppress(CaselessLiteral("OR")
                                 ).setResultsName("OR_OPERATOR")
            quoteContents = Group(Word(ALLCHARS.replace("\"", "")))
            quoteContents.leaveWhitespace()
            quotedWord = Group(Suppress('"') + quoteContents + Suppress('"')
                              ).setResultsName("QUOTES")
            plainWord = Group(NotAny(CaselessLiteral("OR"))
                              + Word(WORDCHARS.replace("-", ""), WORDCHARS)
                             ).setResultsName("PLAINWORD")
            anyWord = Group(NotAny('(') + ~FollowedBy(')') + Word(ALLWORDCHARS)
                           ).setResultsName("ANYWORD")
            keyWord = Group(Combine(Optional("-") + Word(string.ascii_letters)
                                    + Literal(":")
                                    + (Word(WORDCHARS) | quotedWord))
                           ).setResultsName("KEYWORD")
            notExpr = Group(Suppress("-") + NotAny(string.whitespace)
                            + (quotedWord | plainWord)
                           ).setResultsName("NOT")
            word = Group(keyWord | notExpr | quotedWord | plainWord
                        ).setResultsName("WORD")
            words = Group(OneOrMore(word)).setResultsName("WORDS")

            grammar = Forward()
            parens = Forward()

            orOperand = Group(word | parens | notExpr | anyWord
                             ).setResultsName("OR_OPERAND")
            orExpr = Group(
                FollowedBy(orOperand + orOperator + orOperand)
                + Group(orOperand + OneOrMore(orOperator + orOperand))
                ).setResultsName("OR_EXPRESSION")
            oneExpr = Group(orExpr | parens | word | anyWord
                           ).setResultsName("ONE EXPRESSION")
            parens <<= Group(
                Group(Optional("-")).setResultsName("NOT_PARENTHESIS")
                + Suppress("(") + ZeroOrMore(parens | grammar)
                + Suppress(")")).setResultsName("PARENTHESIS")
            grammar <<= ((oneExpr + grammar) | oneExpr
                        ).setResultsName("GRAMMAR")
            self._grammar = grammar

    
    def Parse(self, query, table=None):
        """
        Parses the query string and returns (sql, sql params, words).

        @param   table  if set, search is performed on all the fields of this
                        specific table, ignoring all Skype-specific keywords,
                        only taking into account the table: keyword
                        {"name": "Table name": "columns[{"name", "pk_id", }, ]}
        @return         (SQL string, SQL parameter dict, word and phrase list)
        """
        words = [] # All encountered text words and quoted phrases
        keywords = collections.defaultdict(list) # {"from": [], "chat": [], ..}
        sql_params = {} # Parameters for SQL query {"body_like0": "%word%", ..}

        try:
            parse_results = self._grammar.parseString(query, parseAll=True)
        except Exception:
            # Grammar parsing failed: do a naive parsing into keywords and words
            split_words = query.lower().split()

            for word in split_words[:]:
                if self.PATTERN_KEYWORD.match(word):
                    _, negation, key, value, _ = self.PATTERN_KEYWORD.split(word)
                    key = negation + key
                    keywords[key.lower()].append(value)
                    split_words.remove(word)
            parse_results = ParseResults(split_words)

        result = self._makeSQL(parse_results, words, keywords, sql_params,
                              table=table)
        if table:
            skip_table = False
            for kw, values in keywords.items():
                if ("table"  == kw and table["name"].lower() not in values) \
                or ("-table" == kw and table["name"].lower() in values):
                    skip_table = True
                    break # break for kw, value in keywords.items()
            if skip_table:
                result = ""
            else:
                result = "SELECT * FROM %s WHERE %s" % (table["name"], result)
                for col in table["columns"]:
                    if col.get("pk"):
                        result += " ORDER BY %s ASC" % col["name"]
                        break # break for col in table["columns"]
        else:
            if "table" in keywords: del keywords["table"]
            if "-table" in keywords: del keywords["-table"]
            kw_sql = self._makeKeywordsSQL(keywords, sql_params)
        if not table and kw_sql:
            result = "%s%s" % ("%s AND " % result if result else "", kw_sql)

        return result, sql_params, words


    def _makeSQL(self, item, words, keywords, sql_params,
                table=None, parent_name=None):
        """
        Returns the ParseResults item as an SQL string, appending
        words and phrases to words list, and keyword and sql parameter values
        to argument dictionaries.
        """
        result = ""
        if isinstance(item, ParseResults):
            elements = item
            parsed_elements = []
            name = item.getName()
            do_recurse = True
            negation = ("NOT" == name)
            if "KEYWORD" == name:
                key, word = elements[0].split(":", 1)
                if key.lower() in ["from", "-from", "chat", "-chat", "date", "-date",
                                   "table", "-table"]:
                    keywords[key.lower()].append(word)
                    do_recurse = False
            elif "PARENTHESIS" == name:
                name_elem0 = getattr(elements[0], "getName", lambda: "")()
                if len(elements) and "NOT_PARENTHESIS" == name_elem0:
                    negation = bool(elements[0])
                    elements = elements[1:] # Drop the optional "-" in front
            elif "QUOTES" == name:
                elements = self._flatten(elements)
            if do_recurse:
                words_ptr = [] if negation else words # No words from negations
                for i in elements:
                    sql = self._makeSQL(i, words_ptr, keywords, sql_params,
                                       table, name)
                    parsed_elements.append(sql)
                or_names = ["OR_OPERAND", "OR_EXPRESSION"]
                glue = " OR " if name in or_names else " AND "
                result, count = self._join_strings(parsed_elements, glue)
                result = "(%s)"   % result if count > 1 else result
                result = "NOT %s" % result if negation else result
        else:
            words.append(item)
            safe = self._escape(item, ("*" if "QUOTES" != parent_name else ""))
            if not table:
                table = {"name": "m", "columns": [{"name": "body_xml"}]}
            i = len(sql_params)
            for col in table["columns"]:
                result_col = "%s.%s LIKE :body_like%s" % \
                             (table["name"], col["name"], i)
                if len(safe) > len(item):
                    result_col += " ESCAPE '%s'" % ESCAPE_CHAR
                result += (" OR " if result else "") + result_col
            if len(table["columns"]) > 1: result = "(%s)" % result
            sql_params["body_like%s" % i] = "%" + safe + "%"
        return result


    def _makeKeywordsSQL(self, keywords, sql_params):
        """
        Returns the keywords as an SQL string, appending SQL parameter values
        to argument dictionary.
        """
        result = ""
        for keyword, words in keywords.items():
            kw_sql = ""
            for i, word in enumerate(words):
                param = add_escape = ""
                escaped = self._escape(word)
                if len(escaped) > len(word):
                    add_escape = " ESCAPE '%s'" % ESCAPE_CHAR
                if keyword.endswith("from") or keyword.endswith("chat"):
                    fields = ["m.author", "m.from_dispname"]
                    param = "author_like%s" % len(sql_params)
                    if keyword.endswith("chat"):
                        fields = ["c.identity", "c.displayname",
                                  "c.given_displayname", "c.meta_topic"]
                        param = "chat_like%s" % len(sql_params)
                    items = ["%s LIKE :%s%s" % (f, param, add_escape)
                             for f in fields]
                    sql = " OR ".join(items)
                    sql_params[param] = "%" + word + "%"
                elif keyword.endswith("date"): # date:2002..2003-11-21
                    UNIX_EPOCH = datetime.date(1970, 1, 1)
                    sql = ""
                    date_words, dates = [None] * 2, [None] * 2
                    if ".." not in word:
                        # Single date value given: use strftime matching
                        ymd = list(map(util.to_int, word.split("-")[:3]))
                        while len(ymd) < 3: ymd.append(None) # Ensure 3 values
                        if not any(ymd): # No valid values given: skip
                            continue # continue for i, word in enumerate(words)
                        format, value = "", ""
                        for j, (frm, val) in enumerate(zip("Ymd", ymd)):
                            if val is None: continue # continue for j, (forma..
                            format += ("-" if format else "") + "%" + frm
                            value += ("-" if value else "")
                            value += "%02d" % val if j else "%04d" % val 
                        param = "timestamp_%s" % len(sql_params)
                        temp = "STRFTIME('%s', m.timestamp, 'unixepoch') = :%s"
                        sql = temp % (format, param)
                        sql_params[param] = value
                    else:
                        # Date range given: use timestamp matching
                        date_words = word.split("..", 1)
                    for j, d in filter(lambda x: x[1], enumerate(date_words)):
                        parts = filter(None, d.split("-")[:3])
                        ymd = list(map(util.to_int, parts))
                        if not ymd or ymd[0] is None:
                            continue # continue for j, d in filter(..
                        while len(ymd) < 3: ymd.append(None) # Ensure 3 values
                        ymd[0] = max(min(ymd[0], 9999), 1) # Year in 1..9999
                        # Force month into legal range
                        if ymd[1] is None:
                            ymd[1] = [1, 12][j]
                        else:
                            ymd[1] = max(min(ymd[1], 12), 1) # Month in 1..12
                        # Force day into legal range
                        day_max = calendar.monthrange(*ymd[:2])[1]
                        if ymd[2] is None:
                            ymd[2] = day_max if j else 1
                        else:
                            ymd[2] = max(min(ymd[2], day_max), 1)
                        dates[j] = datetime.date(*ymd)
                    for j, d in filter(lambda x: x[1], enumerate(dates)):
                        timestamp = int(util.timedelta_seconds(d - UNIX_EPOCH))
                        param = "timestamp_%s" % len(sql_params)
                        sql += (" AND " if sql else "")
                        sql += "m.timestamp %s :%s" % ([">=", "<="][j], param)
                        sql_params[param] = timestamp
                kw_sql += (" OR " if kw_sql else "") + sql
            if kw_sql:
                negation = keyword.startswith("-")
                result += " AND " if result else ""
                result += "%s(%s)" % ("NOT " if negation else "", kw_sql)
        return result


    def _flatten(self, items):
        """
        Flattens the list to a single level, if possible,
        e.g. [[['a', 'b']]] to ['a', 'b'].
        """
        result = items
        while len(result) == 1 and not isinstance(result, basestring):
            result = result[0]
        result = [result]
        return result


    def _escape(self, item, wildcards=""):
        """
        Escapes special SQLite characters _% in item.

        @param   wildcards  characters to replace with SQL wildcard %
        """
        result =   item.replace("%", ESCAPE_CHAR + "%")
        result = result.replace("_", ESCAPE_CHAR + "_")
        if wildcards:
            result = "".join(result.replace(c, "%") for c in wildcards)
        return result


    def _join_strings(self, strings, glue=" AND "):
        """
        Returns the non-empty strings joined together with the specified glue.

        @param   glue  separator used as glue between strings 
        @return        (joined string, number of strings actually used)
        """
        strings = list(filter(None, strings))
        return glue.join(strings), len(strings)



if "__main__" == __name__:
    DO_TRACE = True
    TEST_QUERIES = [
        'WORDTEST word "quoted words"',
        'ORTEST OR singleword OR (grouped words) OR lastword',
        'NEGATIONTEST -notword -"not this phrase" -(not these words) '
                     '-chat:notthischat -from:notthisauthor -date:1..9999',
        'WILDCARDTEST under_score percent% wild*card from:notawild*card',
        'DATETEST date:2002 -date:2002-12-24..2003 date:..2002-12-29 '
                 'date:*-*-24',
        'CHARACTERTEST ragnark OR bust!{[]}\\$$@~` from:jrmungandr',
        'KEYWORDTEST --from:notkeyword chats:notkeyword from: singleword '
                    'chat:"quoted title" date:t date:20022-x-20..2003-x-y',
        'WORDFAILTEST chat:parens in(anyword',
        'BIGTEST OR word OR (grouped words) OR -(excluded grouped words) '
                'OR -excludedword OR (word2 OR (nested grouped words)) '
                'date:2011-11..2013-02 -date:2012-06..2012-08 '
                '-(excluded last grouped words) (last grouped words) '
                '(last (nested grouped words)) verylastword',
    ]
    import textwrap

    parser = SearchQueryParser()
    # Decorate SearchQueryParser._makeSQL() with a print logger
    loglines = [] # Cached trace lines
    def makeSQLLogger(func):
        level = [0] # List as workaround: enclosing scope cannot be reassigned
        def inner(item, words, keywords, sql_params, table=None, parent_name=None):
            txt = "%s_makeSQL(<%s> %s, parent_name=%s)" % \
                  ("  " * level[0], item.__class__.__name__, item, parent_name)
            if hasattr(item, "getName"):
                txt += ", name=%s" % item.getName()
            loglines.append(txt)
            level[0] += 1
            result = func(item, words, keywords, sql_params, table, parent_name)
            level[0] -= 1
            loglines.append("%s = %s." % (txt, result))
            return result
        return inner
    if DO_TRACE:
        parser._makeSQL = makeSQLLogger(parser._makeSQL)

    for i, item in enumerate(TEST_QUERIES):
        del loglines[:]
        print("\n%s\n" % ("-" * 60) if i else "")
        print("QUERY: %s" % repr(item))
        d1 = datetime.datetime.now()
        r = parser.Parse(item)
        d2 = datetime.datetime.now()
        print("\n".join(loglines))
        print("PARSE DURATION: %s" % (d2 - d1))
        try:
            parsetree = parser._grammar.parseString(query, parseAll=True)
            print("PARSE TREE: %s" % parsetree)
        except:
            pass
        sql, params, words = r
        for name, value in params.items():
            sql = sql.replace(":%s " % name, '"%s" ' % value)
            sql = sql.replace(":%s)" % name, '"%s")' % value)
        wrapper = textwrap.TextWrapper(width=140, subsequent_indent="  ",
                                       replace_whitespace=False,
                                       drop_whitespace=False)
        print("SQL: %s" % "\n".join(wrapper.wrap(sql)))
        print("PARAMS: %s" % "\n".join(wrapper.wrap(repr(params))))
        print("WORDS: %s" % repr(words))
        print("QUERY: %s" % item)

########NEW FILE########
__FILENAME__ = skypedata
# -*- coding: utf-8 -*-
"""
Skype database access and message parsing functionality.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     26.11.2011
@modified    10.04.2014
------------------------------------------------------------------------------
"""
import cgi
import collections
import copy
import cStringIO
import csv
import datetime
import math
import os
import Queue
import re
import sqlite3
import shutil
import string
import sys
import textwrap
import time
import traceback
import urllib
import xml.etree.cElementTree

from PIL import Image, ImageFile
try:
    import wx
except ImportError:
    pass # Most functionality works without wx

from third_party import step

import conf
import emoticons
import main
import templates
import util
import wordcloud


CHATS_TYPE_SINGLE          =   1 # 1:1 chat
CHATS_TYPE_GROUP           =   2 # 1:n chat
CHATS_TYPE_CONFERENCE      =   4 # video conference
CHATS_TYPENAMES = {
    CHATS_TYPE_SINGLE    : "Single",
    CHATS_TYPE_GROUP     : "Group",
    CHATS_TYPE_CONFERENCE: "Conference"
}
MESSAGE_REMOVED_TEXT = "This message has been removed."
MESSAGES_TYPE_TOPIC        =   2 # Changed chat topic or picture
MESSAGES_TYPE_GROUP        =   4 # Created group conversation
MESSAGES_TYPE_PARTICIPANTS =  10 # Added participants to chat
MESSAGES_TYPE_REMOVE       =  12 # Removed participants from chat
MESSAGES_TYPE_LEAVE        =  13 # Contact left the chat
MESSAGES_TYPE_CALL         =  30 # Started Skype call
MESSAGES_TYPE_CALL_END     =  39 # Skype call ended
MESSAGES_TYPE_SHARE_DETAIL =  51 # Sharing contact details
MESSAGES_TYPE_INFO         =  60 # Info message like "/me is planting corn"
MESSAGES_TYPE_MESSAGE      =  61 # Ordinary message
MESSAGES_TYPE_CONTACTS     =  63 # Sent contacts
MESSAGES_TYPE_SMS          =  64 # SMS message
MESSAGES_TYPE_FILE         =  68 # File transfer
MESSAGES_TYPE_BIRTHDAY     = 110 # Birthday notification
TRANSFER_TYPE_OUTBOUND     =   1 # Transfer sent by partner_handle
TRANSFER_TYPE_INBOUND      =   2 # Transfer sent to partner_handle
CONTACT_FIELD_TITLES = {
    "displayname" : "Display name",
    "skypename"   : "Skype Name",
    "province"    : "State/Province",
    "city"        : "City",
    "pstnnumber"  : "Phone",
    "phone_home"  : "Home phone",
    "phone_office": "Office phone",
    "phone_mobile": "Mobile phone",
    "homepage"    : "Website",
    "emails"      : "Emails",
    "about"       : "About me",
    "mood_text"   : "Mood",
    "country"     : "Country/Region",
}
ACCOUNT_FIELD_TITLES = {
    "fullname"           : "Full name",
    "skypename"          : "Skype name",
    "mood_text"          : "Mood",
    "phone_mobile"       : "Mobile phone",
    "phone_home"         : "Home phone",
    "phone_office"       : "Office phone",
    "emails"             : "E-mails",
    "country"            : "Country",
    "province"           : "Province",
    "city"               : "City",
    "homepage"           : "Website",
    "gender"             : "Gender",
    "birthday"           : "Birth date",
    "languages"          : "Languages",
    "nrof_authed_buddies": "Contacts",
    "about"              : "About me",
    "skypeout_balance"   : "SkypeOut balance",
}


class SkypeDatabase(object):
    """Access to a Skype database file."""

    """SQL CREATE statements for Skype tables."""
    CREATE_STATEMENTS = {
      "accounts": "CREATE TABLE Accounts (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, skypename TEXT, fullname TEXT, pstnnumber TEXT, birthday INTEGER, gender INTEGER, languages TEXT, country TEXT, province TEXT, city TEXT, phone_home TEXT, phone_office TEXT, phone_mobile TEXT, emails TEXT, homepage TEXT, about TEXT, profile_timestamp INTEGER, received_authrequest TEXT, displayname TEXT, refreshing INTEGER, given_authlevel INTEGER, aliases TEXT, authreq_timestamp INTEGER, mood_text TEXT, timezone INTEGER, nrof_authed_buddies INTEGER, ipcountry TEXT, given_displayname TEXT, availability INTEGER, lastonline_timestamp INTEGER, capabilities BLOB, avatar_image BLOB, assigned_speeddial TEXT, lastused_timestamp INTEGER, authrequest_count INTEGER, status INTEGER, pwdchangestatus INTEGER, suggested_skypename TEXT, logoutreason INTEGER, skypeout_balance_currency TEXT, skypeout_balance INTEGER, skypeout_precision INTEGER, skypein_numbers TEXT, offline_callforward TEXT, commitstatus INTEGER, cblsyncstatus INTEGER, chat_policy INTEGER, skype_call_policy INTEGER, pstn_call_policy INTEGER, avatar_policy INTEGER, buddycount_policy INTEGER, timezone_policy INTEGER, webpresence_policy INTEGER, owner_under_legal_age INTEGER, phonenumbers_policy INTEGER, voicemail_policy INTEGER, assigned_comment TEXT, alertstring TEXT, avatar_timestamp INTEGER, mood_timestamp INTEGER, type INTEGER, rich_mood_text TEXT, partner_optedout TEXT, service_provider_info TEXT, registration_timestamp INTEGER, nr_of_other_instances INTEGER, synced_email BLOB, set_availability INTEGER, authorized_time INTEGER, sent_authrequest TEXT, sent_authrequest_time INTEGER, sent_authrequest_serial INTEGER, buddyblob BLOB, cbl_future BLOB, node_capabilities INTEGER, node_capabilities_and INTEGER, revoked_auth INTEGER, added_in_shared_group INTEGER, in_shared_group INTEGER, authreq_history BLOB, profile_attachments BLOB, stack_version INTEGER, offline_authreq_id INTEGER, subscriptions TEXT, authrequest_policy INTEGER, ad_policy INTEGER, options_change_future BLOB, verified_email BLOB, verified_company BLOB, partner_channel_status TEXT, cbl_profile_blob BLOB, flamingo_xmpp_status INTEGER, federated_presence_policy INTEGER, liveid_membername TEXT, roaming_history_enabled INTEGER, uses_jcs INTEGER, cobrand_id INTEGER)",
      "alerts": "CREATE TABLE Alerts (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, timestamp INTEGER, partner_name TEXT, is_unseen INTEGER, partner_id INTEGER, partner_event TEXT, partner_history TEXT, partner_header TEXT, partner_logo TEXT, message_content TEXT, message_footer TEXT, meta_expiry INTEGER, message_header_caption TEXT, message_header_title TEXT, message_header_subject TEXT, message_header_cancel TEXT, message_header_later TEXT, message_button_caption TEXT, message_button_uri TEXT, message_type INTEGER, window_size INTEGER, notification_id INTEGER, extprop_hide_from_history INTEGER, chatmsg_guid BLOB, event_flags INTEGER)",
      "appschemaversion": "CREATE TABLE AppSchemaVersion (ClientVersion TEXT NOT NULL, SQLiteSchemaVersion INTEGER NOT NULL, SchemaUpdateType INTEGER NOT NULL)",
      "callmembers": "CREATE TABLE CallMembers (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, quality_status INTEGER, call_name TEXT, price_precision INTEGER, transfer_status INTEGER, transfer_active INTEGER, transferred_by TEXT, transferred_to TEXT, guid TEXT, identity TEXT, dispname TEXT, languages TEXT, call_duration INTEGER, price_per_minute INTEGER, price_currency TEXT, type INTEGER, status INTEGER, failurereason INTEGER, sounderror_code INTEGER, soundlevel INTEGER, pstn_statustext TEXT, pstn_feedback TEXT, forward_targets TEXT, forwarded_by TEXT, debuginfo TEXT, videostatus INTEGER, target_identity TEXT, mike_status INTEGER, is_read_only INTEGER, next_redial_time INTEGER, nrof_redials_left INTEGER, nrof_redials_done INTEGER, transfer_topic TEXT, real_identity TEXT, start_timestamp INTEGER, pk_status INTEGER, call_db_id INTEGER, prime_status INTEGER, is_conference INTEGER, quality_problems TEXT, identity_type INTEGER, country TEXT, creation_timestamp INTEGER, payment_category TEXT, stats_xml TEXT, is_premium_video_sponsor INTEGER, is_multiparty_video_capable INTEGER, recovery_in_progress INTEGER, nonse_word TEXT, nr_of_delivered_push_notifications INTEGER, call_session_guid TEXT, version_string TEXT)",
      "calls": "CREATE TABLE Calls (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, begin_timestamp INTEGER, partner_handle TEXT, partner_dispname TEXT, server_identity TEXT, type INTEGER, old_members BLOB, status INTEGER, failurereason INTEGER, topic TEXT, pstn_number TEXT, old_duration INTEGER, conf_participants BLOB, pstn_status TEXT, failurecode INTEGER, is_muted INTEGER, vaa_input_status INTEGER, is_incoming INTEGER, is_conference INTEGER, host_identity TEXT, mike_status INTEGER, duration INTEGER, soundlevel INTEGER, access_token TEXT, active_members INTEGER, is_active INTEGER, name TEXT, video_disabled INTEGER, joined_existing INTEGER, is_unseen_missed INTEGER, is_on_hold INTEGER, members BLOB, conv_dbid INTEGER, start_timestamp INTEGER, quality_problems TEXT, current_video_audience TEXT, premium_video_status INTEGER, premium_video_is_grace_period INTEGER, is_premium_video_sponsor INTEGER, premium_video_sponsor_list TEXT)",
      "chatmembers": "CREATE TABLE ChatMembers (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, chatname TEXT, identity TEXT, role INTEGER, is_active INTEGER, cur_activities INTEGER, adder TEXT)",
      "chats": "CREATE TABLE Chats (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, name TEXT, timestamp INTEGER, adder TEXT, type INTEGER, posters TEXT, participants TEXT, topic TEXT, activemembers TEXT, friendlyname TEXT, alertstring TEXT, is_bookmarked INTEGER, activity_timestamp INTEGER, mystatus INTEGER, passwordhint TEXT, description TEXT, options INTEGER, picture BLOB, guidelines TEXT, dialog_partner TEXT, myrole INTEGER, applicants TEXT, banned_users TEXT, topic_xml TEXT, name_text TEXT, unconsumed_suppressed_msg INTEGER, unconsumed_normal_msg INTEGER, unconsumed_elevated_msg INTEGER, unconsumed_msg_voice INTEGER, state_data BLOB, lifesigns INTEGER, last_change INTEGER, first_unread_message INTEGER, pk_type INTEGER, dbpath TEXT, split_friendlyname TEXT, conv_dbid INTEGER)",
      "contactgroups": "CREATE TABLE ContactGroups (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, type_old INTEGER, given_displayname TEXT, nrofcontacts INTEGER, nrofcontacts_online INTEGER, custom_group_id INTEGER, type INTEGER, associated_chat TEXT, proposer TEXT, description TEXT, members TEXT, cbl_id INTEGER, cbl_blob BLOB, fixed INTEGER, keep_sharedgroup_contacts INTEGER, chats TEXT, extprop_is_hidden INTEGER, extprop_sortorder_value INTEGER, extprop_is_expanded INTEGER, given_sortorder INTEGER)",
      "contacts": "CREATE TABLE Contacts (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, type INTEGER, skypename TEXT, pstnnumber TEXT, aliases TEXT, fullname TEXT, birthday INTEGER, gender INTEGER, languages TEXT, country TEXT, province TEXT, city TEXT, phone_home TEXT, phone_office TEXT, phone_mobile TEXT, emails TEXT, hashed_emails TEXT, homepage TEXT, about TEXT, avatar_image BLOB, mood_text TEXT, rich_mood_text TEXT, timezone INTEGER, capabilities BLOB, profile_timestamp INTEGER, nrof_authed_buddies INTEGER, ipcountry TEXT, avatar_timestamp INTEGER, mood_timestamp INTEGER, received_authrequest TEXT, authreq_timestamp INTEGER, lastonline_timestamp INTEGER, availability INTEGER, displayname TEXT, refreshing INTEGER, given_authlevel INTEGER, given_displayname TEXT, assigned_speeddial TEXT, assigned_comment TEXT, alertstring TEXT, lastused_timestamp INTEGER, authrequest_count INTEGER, assigned_phone1 TEXT, assigned_phone1_label TEXT, assigned_phone2 TEXT, assigned_phone2_label TEXT, assigned_phone3 TEXT, assigned_phone3_label TEXT, buddystatus INTEGER, isauthorized INTEGER, popularity_ord INTEGER, external_id TEXT, external_system_id TEXT, isblocked INTEGER, authorization_certificate BLOB, certificate_send_count INTEGER, account_modification_serial_nr INTEGER, saved_directory_blob BLOB, nr_of_buddies INTEGER, server_synced INTEGER, contactlist_track INTEGER, last_used_networktime INTEGER, authorized_time INTEGER, sent_authrequest TEXT, sent_authrequest_time INTEGER, sent_authrequest_serial INTEGER, buddyblob BLOB, cbl_future BLOB, node_capabilities INTEGER, revoked_auth INTEGER, added_in_shared_group INTEGER, in_shared_group INTEGER, authreq_history BLOB, profile_attachments BLOB, stack_version INTEGER, offline_authreq_id INTEGER, node_capabilities_and INTEGER, authreq_crc INTEGER, authreq_src INTEGER, pop_score INTEGER, authreq_nodeinfo BLOB, main_phone TEXT, unified_servants TEXT, phone_home_normalized TEXT, phone_office_normalized TEXT, phone_mobile_normalized TEXT, sent_authrequest_initmethod INTEGER, authreq_initmethod INTEGER, verified_email BLOB, verified_company BLOB, sent_authrequest_extrasbitmask INTEGER, extprop_seen_birthday INTEGER, extprop_sms_target INTEGER, extprop_external_data TEXT, extprop_must_hide_avatar INTEGER, liveid_cid TEXT)",
      "conversations": "CREATE TABLE Conversations (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, identity TEXT, type INTEGER, live_host TEXT, live_start_timestamp INTEGER, live_is_muted INTEGER, alert_string TEXT, is_bookmarked INTEGER, given_displayname TEXT, displayname TEXT, local_livestatus INTEGER, inbox_timestamp INTEGER, inbox_message_id INTEGER, unconsumed_suppressed_messages INTEGER, unconsumed_normal_messages INTEGER, unconsumed_elevated_messages INTEGER, unconsumed_messages_voice INTEGER, active_vm_id INTEGER, context_horizon INTEGER, consumption_horizon INTEGER, last_activity_timestamp INTEGER, active_invoice_message INTEGER, spawned_from_convo_id INTEGER, pinned_order INTEGER, creator TEXT, creation_timestamp INTEGER, my_status INTEGER, opt_joining_enabled INTEGER, opt_access_token TEXT, opt_entry_level_rank INTEGER, opt_disclose_history INTEGER, opt_history_limit_in_days INTEGER, opt_admin_only_activities INTEGER, passwordhint TEXT, meta_name TEXT, meta_topic TEXT, meta_guidelines TEXT, meta_picture BLOB, premium_video_status INTEGER, premium_video_is_grace_period INTEGER, guid TEXT, dialog_partner TEXT, meta_description TEXT, premium_video_sponsor_list TEXT, chat_dbid INTEGER, history_horizon INTEGER, extprop_profile_height INTEGER, extprop_chat_width INTEGER, extprop_chat_left_margin INTEGER, extprop_chat_right_margin INTEGER, extprop_entry_height INTEGER, extprop_windowpos_x INTEGER, extprop_windowpos_y INTEGER, extprop_windowpos_w INTEGER, extprop_windowpos_h INTEGER, extprop_window_maximized INTEGER, extprop_window_detached INTEGER, extprop_pinned_order INTEGER, extprop_new_in_inbox INTEGER, extprop_tab_order INTEGER, extprop_video_layout INTEGER, extprop_video_chat_height INTEGER, extprop_chat_avatar INTEGER, extprop_consumption_timestamp INTEGER, extprop_form_visible INTEGER, extprop_recovery_mode INTEGER, mcr_caller TEXT, history_sync_state TEXT, picture TEXT, is_p2p_migrated INTEGER, thread_version TEXT, consumption_horizon_set_at INTEGER, alt_identity TEXT)",
      "dbmeta": "CREATE TABLE DbMeta (key TEXT NOT NULL PRIMARY KEY, value TEXT)",
      "legacymessages": "CREATE TABLE LegacyMessages (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER)",
      "messages": "CREATE TABLE Messages (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, chatname TEXT, timestamp INTEGER, author TEXT, from_dispname TEXT, chatmsg_type INTEGER, identities TEXT, leavereason INTEGER, body_xml TEXT, chatmsg_status INTEGER, body_is_rawxml INTEGER, edited_by TEXT, edited_timestamp INTEGER, newoptions INTEGER, newrole INTEGER, dialog_partner TEXT, oldoptions INTEGER, guid BLOB, convo_id INTEGER, type INTEGER, sending_status INTEGER, param_key INTEGER, param_value INTEGER, reason TEXT, error_code INTEGER, consumption_status INTEGER, author_was_live INTEGER, participant_count INTEGER, pk_id INTEGER, crc INTEGER, remote_id INTEGER, call_guid TEXT, extprop_contact_review_date TEXT, extprop_contact_received_stamp INTEGER, extprop_contact_reviewed INTEGER)",
      "participants": "CREATE TABLE Participants (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, convo_id INTEGER, identity TEXT, rank INTEGER, requested_rank INTEGER, text_status INTEGER, voice_status INTEGER, video_status INTEGER, live_identity TEXT, live_price_for_me TEXT, live_fwd_identities TEXT, live_start_timestamp INTEGER, sound_level INTEGER, debuginfo TEXT, next_redial_time INTEGER, nrof_redials_left INTEGER, last_voice_error TEXT, quality_problems TEXT, live_type INTEGER, live_country TEXT, transferred_by TEXT, transferred_to TEXT, adder TEXT, is_premium_video_sponsor INTEGER, is_multiparty_video_capable INTEGER, live_identity_to_use TEXT, livesession_recovery_in_progress INTEGER, extprop_default_identity INTEGER, last_leavereason INTEGER, is_multiparty_video_updatable INTEGER, real_identity TEXT)",
      "smses": "CREATE TABLE SMSes (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, is_failed_unseen INTEGER, price_precision INTEGER, type INTEGER, status INTEGER, failurereason INTEGER, price INTEGER, price_currency TEXT, target_numbers TEXT, target_statuses BLOB, body TEXT, timestamp INTEGER, reply_to_number TEXT, chatmsg_id INTEGER, extprop_hide_from_history INTEGER, extprop_extended INTEGER, identity TEXT, notification_id INTEGER, event_flags INTEGER, reply_id_number TEXT, convo_name TEXT, outgoing_reply_type INTEGER)",
      "transfers": "CREATE TABLE Transfers (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, type INTEGER, partner_handle TEXT, partner_dispname TEXT, status INTEGER, failurereason INTEGER, starttime INTEGER, finishtime INTEGER, filepath TEXT, filename TEXT, filesize TEXT, bytestransferred TEXT, bytespersecond INTEGER, chatmsg_guid BLOB, chatmsg_index INTEGER, convo_id INTEGER, pk_id INTEGER, nodeid BLOB, last_activity INTEGER, flags INTEGER, old_status INTEGER, old_filepath INTEGER, extprop_localfilename TEXT, extprop_hide_from_history INTEGER, extprop_window_visible INTEGER, extprop_handled_by_chat INTEGER, accepttime INTEGER, parent_id INTEGER, offer_send_list TEXT)",
      "videomessages": "CREATE TABLE VideoMessages (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, qik_id BLOB, attached_msg_ids TEXT, sharing_id TEXT, status INTEGER, vod_status INTEGER, vod_path TEXT, local_path TEXT, public_link TEXT, progress INTEGER, title TEXT, description TEXT, author TEXT, creation_timestamp INTEGER)",
      "videos": "CREATE TABLE Videos (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, status INTEGER, dimensions TEXT, error TEXT, debuginfo TEXT, duration_1080 INTEGER, duration_720 INTEGER, duration_hqv INTEGER, duration_vgad2 INTEGER, duration_ltvgad2 INTEGER, timestamp INTEGER, hq_present INTEGER, duration_ss INTEGER, ss_timestamp INTEGER, media_type INTEGER, convo_id INTEGER, device_path TEXT)",
      "voicemails": "CREATE TABLE Voicemails (id INTEGER NOT NULL PRIMARY KEY, is_permanent INTEGER, type INTEGER, partner_handle TEXT, partner_dispname TEXT, status INTEGER, failurereason INTEGER, subject TEXT, timestamp INTEGER, duration INTEGER, allowed_duration INTEGER, playback_progress INTEGER, convo_id INTEGER, chatmsg_guid BLOB, notification_id INTEGER, flags INTEGER, size INTEGER, path TEXT, failures INTEGER, vflags INTEGER, xmsg TEXT, extprop_hide_from_history INTEGER)",
    }


    def __init__(self, filename, log_error=True):
        """
        Initializes a new Skype database object from the file.

        @param   log_error  if False, exceptions on opening the database
                            are not written to log (written by default)
        """
        self.filename = filename
        self.basefilename = os.path.basename(self.filename)
        self.backup_created = False
        self.consumers = set() # Registered objects, notified on clearing cache
        self.account = None    # Row from table Accounts
        self.id = None   # Accounts.skypename
        self.tables = {} # {"name": {"Name":str, "rows": 0, "columns": []}, }
        self.tables_list = None # Ordered list of table items
        self.table_rows = {}    # {"tablename1": [..], }
        self.table_objects = {} # {"tablename1": {id1: {rowdata1}, }, }
        self.update_fileinfo()
        try:
            self.connection = sqlite3.connect(self.filename,
                                              check_same_thread=False)
            self.connection.row_factory = self.row_factory
            self.connection.text_factory = str
            rows = self.execute("SELECT name, sql FROM sqlite_master "
                                "WHERE type = 'table'").fetchall()
            for row in rows:
                self.tables[row["name"].lower()] = row
        except Exception:
            if log_error:
                main.log("Error opening database %s.\n\n%s",
                         filename, traceback.format_exc())
            self.close()
            raise

        try:
            self.account = self.execute("SELECT *, "
                "COALESCE(fullname, displayname, skypename, '') AS name, "
                "skypename AS identity FROM accounts LIMIT 1"
            ).fetchone()
            self.id = self.account["skypename"]
        except Exception:
            if log_error:
                main.log("Error getting account information from %s.\n\n%s",
                         filename, traceback.format_exc())


    def __str__(self):
        if self and hasattr(self, "filename"):
            return self.filename


    def check_integrity(self):
        """Checks SQLite database integrity, returning a list of errors."""
        result = []
        rows = self.execute("PRAGMA integrity_check").fetchall()
        if len(rows) != 1 or "ok" != rows[0]["integrity_check"].lower():
            result = [r["integrity_check"] for r in rows]
        return result


    def recover_data(self, filename):
        """
        Recovers as much data from this database to a new database as possible.
        
        @return  a list of encountered errors, if any
        """
        result = []
        with open(filename, "w") as _: pass # Truncate file
        self.execute("ATTACH DATABASE ? AS new", (filename, ))
        # Create structure for all tables
        for t in filter(lambda x: x.get("sql"), self.tables_list or []):
            if t["name"].lower().startswith("sqlite_"): continue # Internal use
            sql  = t["sql"].replace("CREATE TABLE ", "CREATE TABLE new.")
            self.execute(sql)
        # Copy data from all tables
        for t in filter(lambda x: x.get("sql"), self.tables_list or []):
            if t["name"].lower().startswith("sqlite_"): continue # Internal use
            sql = "INSERT INTO new.%(name)s SELECT * FROM main.%(name)s" % t
            try:
                self.execute(sql)
            except Exception as e:
                result.append(repr(e))
                main.log("Error copying table %s from %s to %s.\n\n%s",
                         t["name"], self.filename, filename,
                         traceback.format_exc())
        # Create indexes
        indexes = []
        try:
            sql = "SELECT * FROM sqlite_master WHERE TYPE = ?"
            indexes = self.execute(sql, ("index", )).fetchall()
        except Exception as e:
            result.append(repr(e))
            main.log("Error getting indexes from %s.\n\n%s",
                     self.filename, traceback.format_exc())
        for i in filter(lambda x: x.get("sql"), indexes):
            sql  = i["sql"].replace("CREATE INDEX ", "CREATE INDEX new.")
            try:
                self.execute(sql)
            except Exception as e:
                result.append(repr(e))
                main.log("Error creating index %s for %s.\n\n%s",
                         i["name"], filename, traceback.format_exc())
        self.execute("DETACH DATABASE new")
        return result


    def clear_cache(self):
        """Clears all the currently cached rows."""
        self.table_rows.clear()
        self.table_objects.clear()
        self.get_tables(True)


    def update_accountinfo(self):
        """Refreshes Skype account information."""
        try:
            self.account = self.execute("SELECT *, "
                "COALESCE(fullname, displayname, skypename, '') AS name, "
                "skypename AS identity FROM accounts LIMIT 1").fetchone()
            self.id = self.account["skypename"]
        except Exception as e:
            main.log("Error getting account information from %s.\n\n%s",
                     self, traceback.format_exc())


    def register_consumer(self, consumer):
        """
        Registers a consumer with the database, notified on clearing cache by
        consumer.on_database_changed().
        """
        self.consumers.add(consumer)


    def unregister_consumer(self, consumer):
        """Removes a registered consumer from the database."""
        if consumer in self.consumers:
            self.consumers.remove(consumer)


    def has_consumers(self):
        """Returns whether the database has currently registered consumers."""
        return len(self.consumers) > 0


    def close(self):
        """Closes the database and frees all allocated data."""
        if hasattr(self, "connection"):
            try:
                self.connection.close()
            except Exception:
                pass
            del self.connection
            self.connection = None
        for attr in ["tables", "tables_list", "table_rows", "table_objects"]:
            if hasattr(self, attr):
                delattr(self, attr)
                setattr(self, attr, None if ("tables_list" == attr) else {})


    def execute(self, sql, params=[], log=True):
        """Shorthand for self.connection.execute()."""
        result = None
        if self.connection:
            if log and conf.LogSQL:
                main.log("SQL: %s%s", sql,
                         ("\nParameters: %s" % params) if params else "")
            result = self.connection.execute(sql, params)
        return result


    def execute_action(self, sql):
        """
        Executes the specified SQL INSERT/UPDATE/DELETE statement and returns
        the number of affected rows.
        """
        self.ensure_backup()
        res = self.execute(sql)
        affected_rows = res.rowcount
        self.connection.commit()
        return affected_rows


    def check_future_dates(self):
        """
        Checks whether any messages in the database have a timestamp in the
        future (this can happen if the computer clock has been erraneously
        set to a future date when receing messages).

        @return  (future message count, max future datetime)
        """
        result = (None, None)
        if self.is_open() and "messages" in self.tables:
            now = self.future_check_timestamp = int(time.time())
            try:
                maxtimestamp = self.execute("SELECT MAX(timestamp) AS max "
                                             "FROM messages").fetchone()["max"]
                count = self.execute("SELECT COUNT(*) AS count FROM messages "
                                     "WHERE timestamp > ?", [now]
                                    ).fetchone()["count"]
                result = (count, datetime.datetime.fromtimestamp(maxtimestamp))
            except Exception:
                pass

        return result


    def move_future_dates(self, days, hours):
        """
        Updates the timestamp of future messages.

        @param   days   days to move, positive or negative number
        @param   hours  hours to move, positive or negative number
        """
        if self.is_open() and "messages" in self.tables:
            self.ensure_backup()
            seconds = (days * 24 + hours) * 3600
            self.execute(
                "UPDATE messages SET timestamp = timestamp + ? "
                "WHERE timestamp > ?", [seconds, self.future_check_timestamp]
            )
            self.connection.commit()
            self.last_modified = datetime.datetime.now()


    def is_open(self):
        """Returns whether the database is currently open."""
        return (self.connection is not None)


    def get_tables(self, refresh=False, this_table=None):
        """
        Returns the names and rowcounts of all tables in the database, as
        [{"name": "tablename", "rows": 0, "sql": CREATE SQL}, ].
        Uses already retrieved cached values if possible, unless refreshing.

        @param   refresh     if True, information including rowcounts is
                             refreshed
        @param   this_table  if set, only information for this table is
                             refreshed
        """
        if self.is_open() and (refresh or self.tables_list is None):
            sql = "SELECT name, sql FROM sqlite_master WHERE type = 'table' " \
                  "%sORDER BY name COLLATE NOCASE" % \
                  ("AND name = ? " if this_table else "")
            params = [this_table] if this_table else []
            rows = self.execute(sql, params).fetchall()
            tables = {}
            tables_list = []
            for row in rows:
                table = row
                try:
                    res = self.execute("SELECT COUNT(*) AS count FROM %s" %
                                       table["name"], log=False)
                    table["rows"] = res.fetchone()["count"]
                except sqlite3.DatabaseError:
                    table["rows"] = 0
                    main.log("Error getting %s row count for %s.\n\n%s",
                             table, self.filename, traceback.format_exc())
                # Here and elsewhere in this module - table names are turned to
                # lowercase when used as keys.
                tables[table["name"].lower()] = table
                tables_list.append(table)
            if this_table:
                self.tables.update(tables)
                for t in self.tables_list or []:
                    if t["name"] == this_table:
                        self.tables_list.remove(t)
                if self.tables_list is None:
                    self.tables_list = []
                self.tables_list += tables_list
                self.tables_list.sort(key=lambda x: x["name"])
            else:
                self.tables = tables
                self.tables_list = tables_list

        return self.tables_list


    def get_general_statistics(self, full=True):
        """
        Get up-to-date general statistics raw from the database.

        @param   full  whether to return full statistics, or only tables
                       and last chat
        """
        result = collections.defaultdict(str)
        if self.account:
            result.update({"name": self.account.get("name"),
                           "skypename": self.account.get("skypename")})
        for k, table in [("chats", "Conversations"), ("messages", "Messages"),
                       ("contacts", "Contacts"), ("transfers", "Transfers")]:
            res = self.execute("SELECT COUNT(*) AS count FROM %s" % table)
            result[k] = next(res, {}).get("count")

        res = self.execute("SELECT m.*, COALESCE(NULLIF(c.displayname, ''), "
            "NULLIF(c.meta_topic, '')) AS chat_title, c.type AS chat_type "
            "FROM Messages m LEFT JOIN Conversations c ON m.convo_id = c.id "
            "WHERE m.type IN (2, 10, 12, 13, 30, 39, 51, 60, 61, 63, 64, 68) "
            "ORDER BY m.timestamp DESC LIMIT 1")
        msg_last = next(res, None)
        if msg_last:
            if msg_last.get("timestamp"):
                dt = datetime.datetime.fromtimestamp(msg_last["timestamp"])
                result["lastmessage_dt"] = dt.strftime("%Y-%m-%d %H:%M")
            result["lastmessage_from"] = msg_last["from_dispname"]
            result["lastmessage_skypename"] = msg_last["author"]
            title = ('"%s"' if CHATS_TYPE_SINGLE != msg_last["chat_type"]
                     else "chat with %s") % msg_last["chat_title"]
            result["lastmessage_chat"] = title
            result["lastmessage_chattype"] = msg_last["chat_type"]
        if not full:
            return result

        res = self.execute("SELECT m.*, COALESCE(NULLIF(c.displayname, ''), "
            "NULLIF(c.meta_topic, '')) AS chat_title, c.type AS chat_type "
            "FROM Messages m LEFT JOIN Conversations c ON m.convo_id = c.id "
            "WHERE m.type IN (2, 10, 12, 13, 30, 39, 51, 60, 61, 63, 64, 68) "
            "ORDER BY m.timestamp ASC LIMIT 1")
        msg_first = next(res, None)
        if msg_first:
            if msg_first.get("timestamp"):
                dt = datetime.datetime.fromtimestamp(msg_first["timestamp"])
                result["firstmessage_dt"] = dt.strftime("%Y-%m-%d %H:%M")
            result["firstmessage_from"] = msg_first["from_dispname"]
            result["firstmessage_skypename"] = msg_first["author"]
            title = ('"%s"' if CHATS_TYPE_SINGLE != msg_first["chat_type"]
                     else "chat with %s") % msg_first["chat_title"]
            result["firstmessage_chat"] = title
            result["firstmessage_chattype"] = msg_first["chat_type"]

        for i in range(2):
            row = self.execute("SELECT COUNT(*) AS count FROM Messages "
                "WHERE author %s= :skypename AND "
                "type IN (2, 10, 12, 13, 30, 39, 51, 60, 61, 63, 64, 68)"
                % "!="[i], result).fetchone()
            result["messages_" + ("to", "from")[i]] = row["count"]

        return result


    def get_messages(self, chat=None, ascending=True,
                     additional_sql=None, additional_params=None,
                     timestamp_from=None, use_cache=True):
        """
        Yields all the messages (or messages for the specified chat), as
        {"datetime": datetime, ..}, ordered from earliest to latest.
        Uses already retrieved cached values if possible, unless additional
        query parameters are used.

        @param   chat               as returned by get_conversations(), if any
        @param   ascending          specify message order, earliest to latest
                                    or latest to earliest
        @param   additional_sql     additional SQL string added to the end
        @param   additional_params  SQL parameter dict for additional_sql
        @param   timestamp_from     timestamp beyond which messages will start
        @param   use_cache          whether to use cached values if available.
                                    The LIKE keywords will be ignored if True.
        """
        if self.is_open() and "messages" in self.tables:
            if "messages" not in self.table_rows:
                self.table_rows["messages"] = {} # {convo_id: [{msg1},]}
            if not use_cache \
            or not (chat and chat["id"] in self.table_rows["messages"]):
                params = {}
                # Take only message types we can handle
                sql = "SELECT m.* FROM messages m "
                if additional_sql and " c." in additional_sql:
                    sql += "LEFT JOIN conversations c ON m.convo_id = c.id "
                # Take only known and supported types of messages.
                sql += "WHERE m.type IN " \
                       "(2, 10, 12, 13, 30, 39, 51, 60, 61, 63, 64, 68)"
                if chat:
                    sql += " AND m.convo_id = :convo_id"
                    params["convo_id"] = chat["id"]
                if timestamp_from:
                    sql += " AND m.timestamp %s :timestamp" % \
                           (">" if ascending else "<")
                    params["timestamp"] = timestamp_from
                if additional_sql:
                    sql += " AND (%s)" % additional_sql
                    params.update(additional_params or {})
                sql += " ORDER BY m.timestamp %s" \
                    % ("ASC" if ascending else "DESC")
                res = self.execute(sql, params)
                messages = []
                message = res.fetchone()
                while message:
                    message["datetime"] = None
                    if message["timestamp"]:
                        message["datetime"] = datetime.datetime.fromtimestamp(
                            message["timestamp"]
                        )
                    if chat and use_cache and len(params) == 1:
                        messages.append(message)
                    yield message
                    message = res.fetchone()
                if chat and use_cache and len(params) == 1:
                    # Only cache queries getting full range
                    self.table_rows["messages"][chat["id"]] = messages
            else:
                messages_sorted = sorted(
                    self.table_rows["messages"][chat["id"]],
                    key=lambda m: m["timestamp"], reverse=not ascending
                )
                if timestamp_from:
                    messages_sorted = filter(
                        lambda x: (x["timestamp"] > timestamp_from)
                        if ascending else
                        (x["timestamp"] < timestamp_from), messages_sorted
                    )
                for message in messages_sorted:
                    yield message


    def row_factory(self, cursor, row):
        """
        Creates dicts from resultset rows, with BLOB fields converted to
        strings.
        """
        result = {}
        for idx, col in enumerate(cursor.description):
            name = col[0]
            result[name] = row[idx]
        for name in result.keys():
            datatype = type(result[name])
            if datatype is buffer:
                result[name] = str(result[name]).decode("latin1")
            elif datatype is str or datatype is unicode:
                try:
                    result[name] = str(result[name]).decode("utf-8")
                except Exception:
                    result[name] = str(result[name]).decode("latin1")
        return result


    def get_conversations(self):
        """
        Returns all the chats and message rowcounts in the database, as
        [{"id": integer, "title": "chat title", "created_datetime": datetime,
          "title_long": "Group chat "chat_title"", "title_long_lc": "group..",
          "last_activity_datetime": datetime, "type_name": chat type name}, ..]
        Uses already retrieved cached values if possible.
        """
        conversations = []
        if self.is_open() and "conversations" in self.tables:
            if "conversations" not in self.table_rows:
                participants = {}
                if "contacts" in self.tables and "participants" in self.tables:
                    main.log("Conversations and participants: "
                             "retrieving all (%s).", self.filename)
                    self.get_contacts()
                    self.get_table_rows("participants")
                    for i in self.table_objects["participants"].values():
                        if i["convo_id"] not in participants:
                            participants[i["convo_id"]] = []
                        if i["identity"] == self.id:
                            i["contact"] = self.account
                        else:
                            # Fake a dummy contact object if no contact row
                            i["contact"] = self.table_objects["contacts"].get(
                                i["identity"], {"skypename":   i["identity"],
                                                "identity":    i["identity"],
                                                "name":        i["identity"],
                                                "fullname":    i["identity"],
                                                "displayname": i["identity"]}
                            )
                        participants[i["convo_id"]].append(i)
                [i.sort(key=lambda x: (x["contact"].get("name", "")).lower())
                 for i in participants.values()]
                rows = self.execute(
                    "SELECT *, "
                    "COALESCE(displayname, meta_topic, identity) AS title, "
                    "NULL AS created_datetime, NULL AS last_activity_datetime "
                    "FROM conversations WHERE displayname IS NOT NULL "
                    "ORDER BY last_activity_timestamp DESC"
                ).fetchall()
                conversations = []
                for chat in rows:
                    chat["title_long"] = ("Chat with %s"
                        if CHATS_TYPE_SINGLE == chat["type"]
                        else "Group chat \"%s\"") % chat["title"]
                    chat["title_long_lc"] = \
                        chat["title_long"][0].lower() + chat["title_long"][1:]
                    for k, v in [("creation_timestamp", "created_datetime"),
                    ("last_activity_timestamp", "last_activity_datetime")]:
                        if chat[k]:
                            chat[v] = datetime.datetime.fromtimestamp(chat[k])
                        
                    chat["type_name"] = CHATS_TYPENAMES.get(chat["type"],
                        "Unknown (%d)" % chat["type"])
                    # Set stats attributes presence
                    chat["message_count"] = None
                    chat["first_message_timestamp"] = None
                    chat["last_message_timestamp"] = None
                    chat["first_message_datetime"] = None
                    chat["last_message_datetime"] = None
                    chat["participants"] = participants.get(chat["id"], [])
                    conversations.append(chat)
                main.log("Conversations and participants retrieved "
                    "(%s chats, %s contacts, %s).",
                    len(conversations), len(self.table_rows["contacts"]),
                    self.filename
                )
                self.table_rows["conversations"] = conversations
            else:
                conversations = self.table_rows["conversations"]

        return conversations


    def get_conversations_stats(self, chats, log=True):
        """
        Collects statistics for all conversations and fills in the values:
        {"first_message_timestamp": int, "first_message_datetime": datetime,
         "last_message_timestamp": int, "last_message_datetime": datetime,
         "participants": [{row from Participants,
                           "contact": {row from Contacts}}, ],
         "message_count": message count, }.

        @param   chats  list of chats, as returned from get_conversations()
        """
        if log and chats:
            main.log("Statistics collection starting (%s).", self.filename)
        stats = []
        participants = {}
        if self.is_open() and "messages" in self.tables:
            and_str, and_val = "", []
            if chats and len(chats) == 1:
                and_str = " AND convo_id in (%s)" % \
                          ", ".join(["?"] * len(chats))
                and_val = [c["id"] for c in chats]
            rows_stat = self.execute(
                "SELECT convo_id AS id, COUNT(*) AS message_count, "
                "MIN(timestamp) AS first_message_timestamp, "
                "MAX(timestamp) AS last_message_timestamp, "
                "NULL AS first_message_datetime, "
                "NULL AS last_message_datetime "
                "FROM messages "
                "WHERE type IN (2, 10, 13, 51, 60, 61, 63, 64, 68) "
                + and_str +
                "GROUP BY convo_id", and_val).fetchall()
            stats = dict((i["id"], i) for i in rows_stat)
        for chat in chats:
            chat["message_count"] = 0
            if chat["id"] in stats:
                stamptodate = datetime.datetime.fromtimestamp
                data = stats[chat["id"]]
                if data["first_message_timestamp"]:
                    data["first_message_datetime"] = \
                        stamptodate(data["first_message_timestamp"])
                if data["last_message_timestamp"]:
                    data["last_message_datetime"] = \
                        stamptodate(data["last_message_timestamp"])
                chat.update(data)
        if log and chats:
            main.log("Statistics collected (%s).", self.filename)


    def get_contactgroups(self):
        """
        Returns the non-empty contact groups in the database.
        Uses already retrieved cached values if possible.
        """
        groups = []
        if self.is_open() and "contactgroups" in self.tables:
            if "contactgroups" not in self.table_rows:
                rows = self.execute(
                    "SELECT *, given_displayname AS name FROM contactgroups "
                    "WHERE members IS NOT NULL ORDER BY id").fetchall()
                self.table_objects["contactgroups"] = {}
                for group in rows:
                    groups.append(group)
                    self.table_objects["contactgroups"][group["id"]] = group
                self.table_rows["contactgroups"] = groups
            else:
                groups = self.table_rows["contactgroups"]

        return groups


    def get_contacts(self):
        """
        Returns all the contacts in the database, as
        [{"identity": skypename or pstnnumber,
          "name": displayname or fullname, },]
        Uses already retrieved cached values if possible.
        """
        contacts = []
        if self.is_open() and "contacts" in self.tables:
            if "contacts" not in self.table_rows:
                rows = self.execute(
                    "SELECT *, COALESCE(skypename, pstnnumber, '') "
                        "AS identity, "
                    "COALESCE(fullname, displayname, skypename, pstnnumber, '') "
                    "AS name FROM contacts ORDER BY name COLLATE NOCASE"
                ).fetchall()
                self.table_objects["contacts"] = {}
                for c in rows:
                    contacts.append(c)
                    self.table_objects["contacts"][c["identity"]] = c
                self.table_rows["contacts"] = contacts
            else:
                contacts = self.table_rows["contacts"]

        return contacts


    def get_contact_name(self, identity):
        """
        Returns the full name for the specified contact, or given identity if
        not set.

        @param   identity  skypename or pstnnumber
        """
        name = ""
        self.get_contacts()
        if identity == self.id:
            name = self.account["name"]
        elif identity in self.table_objects["contacts"]:
            name = self.table_objects["contacts"][identity]["name"]
        name = name or identity
        return name


    def get_table_rows(self, table):
        """
        Returns all the rows of the specified table.
        Uses already retrieved cached values if possible.
        """
        rows = []
        table = table.lower()
        if table in self.tables:
            if table not in self.table_rows:
                col_data = self.get_table_columns(table)
                pks = [c["name"] for c in col_data if c["pk"]]
                pk = pks[0] if len(pks) == 1 else None
                rows = self.execute("SELECT * FROM %s" % table).fetchall()
                self.table_rows[table] = rows
                self.table_objects[table] = {}
                if pk:
                    for row in rows:
                        self.table_objects[table][row[pk]] = row
            else:
                rows = self.table_rows[table]
        return rows


    def get_smses(self):
        """
        Returns all the SMSes in the database.
        Uses already retrieved cached values if possible.
        """
        transfers = []
        if self.is_open() and "smses" in self.tables:
            if "smses" not in self.table_rows:
                rows = self.execute(
                    "SELECT * FROM smses ORDER BY id").fetchall()
                smses = []
                for sms in rows:
                    smses.append(sms)
                self.table_rows["smses"] = smses
            else:
                smses = self.table_rows["smses"]

        return smses


    def get_transfers(self):
        """
        Returns all the transfers in the database.
        Uses already retrieved cached values if possible.
        """
        transfers = []
        if self.is_open() and "transfers" in self.tables:
            if "transfers" not in self.table_rows:
                rows = self.execute(
                    "SELECT * FROM transfers ORDER BY id").fetchall()
                transfers = []
                for transfer in rows:
                    transfers.append(transfer)
                self.table_rows["transfers"] = transfers
            else:
                transfers = self.table_rows["transfers"]

        return transfers


    def get_videos(self, chat=None):
        """
        Returns all valid video rows in the database (with a matching row in
        Calls). Uses already retrieved cached values if possible.

        @param   chat  if a row from get_conversations, returns only videos
                       under this chat
        """
        videos = []
        if self.is_open() and "videos" in self.tables:
            if "videos" not in self.table_rows:
                rows = self.execute(
                    "SELECT videos.* FROM videos "
                    "INNER JOIN calls ON videos.convo_id = calls.id "
                    "ORDER BY videos.id"
                ).fetchall()
                videos = []
                self.table_objects["videos"] = {}
                for video in rows:
                    videos.append(video)
                    self.table_objects["videos"][video["id"]] = video
                self.table_rows["videos"] = videos
            else:
                videos = self.table_rows["videos"]

        if chat:
            videos = [v for v in videos if v["convo_id"] == chat["id"]]
        return videos


    def get_calls(self, chat=None):
        """
        Returns all calls in the database.
        Uses already retrieved cached values if possible.

        @param   chat  if a row from get_conversations, returns only calls
                       under this chat
        """
        calls = []
        if self.is_open() and "calls" in self.tables:
            if "calls" not in self.table_rows:
                rows = self.execute(
                    "SELECT * FROM calls ORDER BY calls.id"
                ).fetchall()
                calls = []
                self.table_objects["calls"] = {}
                for call in rows:
                    calls.append(call)
                    self.table_objects["calls"][call["id"]] = call
                self.table_rows["calls"] = calls
            else:
                calls = self.table_rows["calls"]

        if chat:
            calls = [c for c in calls if c["conv_dbid"] == chat["id"]]
        return calls


    def get_conversation_participants(self, chat):
        """
        Returns the participants of the chat, as
        [{name, all Participant columns, "contact": {all Contact columns}}]
        (excluding database account owner).
        """
        participants = []
        if self.is_open() and "contacts" in self.tables:
            if "contacts" not in self.table_objects:
                # Retrieve and cache all contacts
                self.table_objects["contacts"] = {}
                rows = self.execute(
                    "SELECT *, COALESCE(skypename, pstnnumber, '') AS identity "
                    "FROM contacts").fetchall()
                for row in rows:
                    self.table_objects["contacts"][row["identity"]] = row
            rows = self.execute(
                "SELECT COALESCE(c.fullname, c.displayname, c.skypename, "
                                "c.pstnnumber, '') AS name, "
                "c.skypename, p.* "
                "FROM contacts AS c INNER JOIN participants AS p "
                "ON p.identity = c.skypename "
                "WHERE p.convo_id = :id AND c.skypename != :skypename "
                "ORDER BY name COLLATE NOCASE",
                {"id": chat["id"], "skypename": self.account["skypename"]}
            ).fetchall()
            for p in rows:
                p["contact"] = self.table_objects["contacts"].get(p["identity"])
                if not p["contact"]:
                    p["contact"] = self.get_contact(p["identity"])
                participants.append(p)

        return participants


    def get_contact(self, identity):
        """
        Returns the contact specified by the identity
        (skypename or pstnnumber).
        """
        contact = None
        if self.is_open() and "contacts" in self.tables:
            """Returns the specified contact row, using cache if possible."""
            if "contacts" not in self.table_objects:
                self.table_objects["contacts"] = {}
            contact = self.table_objects["contacts"].get(identity)
            if not contact:
                contact = self.execute(
                    "SELECT *, COALESCE(fullname, displayname, skypename, "
                                       "pstnnumber, '') AS name, "
                    "COALESCE(skypename, pstnnumber, '') AS identity "
                    "FROM contacts WHERE skypename = :identity "
                    "OR pstnnumber = :identity",
                    {"identity": identity}
                ).fetchone()
                self.table_objects["contacts"][identity] = contact

        return contact


    def get_table_columns(self, table):
        """
        Returns the columns of the specified table, as
        [{"name": "col1", "type": "INTEGER", }, ], or [] if not retrievable.
        """
        table = table.lower()
        table_columns = []
        if self.is_open() and self.tables_list is None:
            self.get_tables()
        if self.is_open() and table in self.tables:
            if "columns" in self.tables[table]:
                table_columns = self.tables[table]["columns"]
            else:
                table_columns = []
                try:
                    res = self.execute("PRAGMA table_info(%s)" % table, log=False)
                    for row in res.fetchall():
                        table_columns.append(row)
                except sqlite3.DatabaseError:
                    main.log("Error getting %s column data for %s.\n\n%s",
                             table, self.filename, traceback.format_exc())
                self.tables[table]["columns"] = table_columns
        return table_columns


    def update_fileinfo(self):
        """Updates database file size and modification information."""
        self.filesize = os.path.getsize(self.filename)
        mod_timestamp = os.path.getmtime(self.filename)
        self.last_modified = datetime.datetime.fromtimestamp(mod_timestamp)


    def ensure_backup(self):
        """Creates a backup file if configured so, and not already created."""
        if conf.DBDoBackup:
            if (not self.backup_created
            or not os.path.exists("%s.bak" % self.filename)):
                shutil.copyfile(self.filename, "%s.bak" % self.filename)
                self.backup_created = True


    def blobs_to_binary(self, values, list_columns, col_data):
        """
        Converts blob columns in the list to sqlite3.Binary, suitable
        for using as a query parameter.
        """
        result = []
        is_dict = isinstance(values, dict)
        list_values = [values[i] for i in list_columns] if is_dict else values
        map_columns = dict([(i["name"], i) for i in col_data])
        for i, val in enumerate(list_values):
            if "blob" == map_columns[list_columns[i]]["type"].lower() and val:
                if isinstance(val, unicode):
                    val = val.encode("latin1")
                val = sqlite3.Binary(val)
            result.append(val)
        if is_dict:
            result = dict([(list_columns[i], x) for i, x in enumerate(result)])
        return result


    def fill_missing_fields(self, data, fields):
        """Creates a copy of the data and adds any missing fields."""
        filled = data.copy()
        for field in fields:
            if field not in filled:
                filled[field] = None
        return filled


    def create_table(self, table, create_sql=None):
        """Creates the specified table and updates our column data."""
        table = table.lower()
        if create_sql or (table in self.CREATE_STATEMENTS):
            self.execute(create_sql or self.CREATE_STATEMENTS[table])
            self.connection.commit()
            row = self.execute("SELECT name, sql FROM sqlite_master "
                                "WHERE type = 'table' "
                                "AND LOWER(name) = ?", [table]).fetchone()
            self.tables[table] = row


    def insert_chat(self, chat, source_db):
        """Inserts the specified chat into the database and returns its ID."""
        if self.is_open() and not self.account and source_db.account:
            self.insert_account(source_db.account)
        if self.is_open() and "conversations" not in self.tables:
            self.create_table("conversations")
        if self.is_open() and "conversations" in self.tables:
            self.ensure_backup()
            col_data = self.get_table_columns("conversations")
            fields = [col["name"] for col in col_data if col["name"] != "id"]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)
            chat_filled = self.fill_missing_fields(chat, fields)
            chat_filled = self.blobs_to_binary(chat_filled, fields, col_data)

            cursor = self.execute("INSERT INTO conversations (%s) VALUES (%s)"
                                  % (str_cols, str_vals), chat_filled)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()
            return cursor.lastrowid


    def insert_messages(self, chat, messages, source_db, source_chat,
                        heartbeat=None, beatcount=None):
        """
        Inserts the specified messages under the specified chat in this
        database, includes related rows in Calls, Videos, Transfers and
        SMSes.

        @param    messages   list of messages, or message IDs from source_db
        @param    heartbeat  function called after every @beatcount
                             messages inserted
        @param    beatcount  number of messages after which to call heartbeat
        @return              a list of inserted message IDs
        """
        result = []
        if self.is_open() and not self.account and source_db.account:
            self.insert_account(source_db.account)
        if self.is_open() and "messages" not in self.tables:
            self.create_table("messages")
        if self.is_open() and "transfers" not in self.tables:
            self.create_table("transfers")
        if self.is_open() and "smses" not in self.tables:
            self.create_table("smses")
        if self.is_open() and "chats" not in self.tables:
            self.create_table("chats")
        if self.is_open() and "messages" in self.tables:
            main.log("Merging %s (%s) into %s.",
                     util.plural("chat message", messages),
                     chat["title_long_lc"], self.filename)
            self.ensure_backup()
            # Messages.chatname corresponds to Chats.name, and Chats entries
            # must exist for Skype application to be able to find the messages.
            chatrows_source = dict([(i["name"], i) for i in 
                source_db.execute("SELECT * FROM chats WHERE conv_dbid = ?",
                                  [source_chat["id"]])])
            chatrows_present = dict([(i["name"], 1)
                for i in self.execute("SELECT name FROM chats")])
            col_data = self.get_table_columns("messages")
            fields = [col["name"] for col in col_data if col["name"] != "id"]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)
            transfer_col_data = self.get_table_columns("transfers")
            transfer_fields = [col["name"] for col in transfer_col_data
                               if col["name"] != "id"]
            transfer_cols = ", ".join(transfer_fields)
            transfer_vals = ", ".join(["?"] * len(transfer_fields))
            sms_col_data = self.get_table_columns("smses")
            sms_fields = [col["name"] for col in sms_col_data
                          if col["name"] != "id"]
            sms_cols = ", ".join(sms_fields)
            sms_vals = ", ".join(["?"] * len(sms_fields))
            chat_col_data = self.get_table_columns("chats")
            chat_fields = [col["name"] for col in chat_col_data
                           if col["name"] != "id"]
            chat_cols = ", ".join(chat_fields)
            chat_vals = ", ".join(["?"] * len(chat_fields))
            timestamp_earliest = source_chat["creation_timestamp"] \
                                 or sys.maxsize

            for i, m in enumerate(source_db.message_iterator(messages)):
                # Insert corresponding Chats entry, if not present
                if (m["chatname"] not in chatrows_present
                and m["chatname"] in chatrows_source):
                    chatrowdata = chatrows_source[m["chatname"]]
                    chatrow = [chatrowdata.get(col, "") for col in chat_fields]
                    chatrow = self.blobs_to_binary(
                        chatrow, chat_fields, chat_col_data)
                    sql = "INSERT INTO chats (%s) VALUES (%s)" % \
                          (chat_cols, chat_vals)
                    self.execute(sql, chatrow)
                    chatrows_present[m["chatname"]] = 1
                m_filled = self.fill_missing_fields(m, fields)
                m_filled["convo_id"] = chat["id"]
                m_filled = self.blobs_to_binary(m_filled, fields, col_data)
                cursor = self.execute("INSERT INTO messages (%s) VALUES (%s)"
                                      % (str_cols, str_vals), m_filled)
                m_id = cursor.lastrowid
                if (m["chatmsg_type"] == 7 and m["type"] == 68
                and "transfers" in source_db.tables):
                    transfers = [t for t in source_db.get_transfers()
                                 if t.get("chatmsg_guid") == m["guid"]]
                    if transfers:
                        sql = "INSERT INTO transfers (%s) VALUES (%s)" % \
                              (transfer_cols, transfer_vals)
                        transfers.sort(key=lambda x: x.get("chatmsg_index"))
                        for t in transfers:
                            # pk_id and nodeid are troublesome, ditto in SMSes,
                            # because their meaning is unknown - will
                            # something go out of sync if their values differ?
                            row = [t.get(col, "") if col != "convo_id" else chat["id"]
                                   for col in transfer_fields]
                            row = self.blobs_to_binary(row, transfer_fields,
                                                       transfer_col_data)
                            self.execute(sql, row)
                if (m["chatmsg_type"] == 7 and m["type"] == 64
                and "smses" in source_db.tables):
                    smses = [s for s in source_db.get_smses()
                             if s.get("chatmsg_id") == m["id"]]
                    if smses:
                        sql = "INSERT INTO smses (%s) VALUES (%s)" % \
                              (sms_cols, sms_vals)
                        for sms in smses:
                            t = [sms.get(col, "") if col != "chatmsg_id" else m_id
                                 for col in sms_fields]
                            t = self.blobs_to_binary(t, sms_fields, sms_col_data)
                            self.execute(sql, t)
                timestamp_earliest = min(timestamp_earliest, m["timestamp"])
                result.append(m_id)
                if heartbeat and beatcount and i and not i % beatcount:
                    heartbeat()
            if (timestamp_earliest
            and chat["creation_timestamp"] > timestamp_earliest):
                # Conversations.creation_timestamp must not be later than the
                # oldest message, Skype will not show messages older than that.
                chat["creation_timestamp"] = timestamp_earliest
                chat["created_datetime"] = \
                    datetime.datetime.fromtimestamp(timestamp_earliest)
                self.execute("UPDATE conversations SET creation_timestamp = "
                             ":creation_timestamp WHERE id = :id", chat)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()
        return result


    def insert_participants(self, chat, participants, source_db):
        """
        Inserts the specified participants under the specified chat in this
        database.
        """
        if self.is_open() and not self.account and source_db.account:
            self.insert_account(source_db.account)
        if self.is_open() and "participants" not in self.tables:
            self.create_table("participants")
        if self.is_open() and "contacts" not in self.tables:
            self.create_table("contacts")
        if self.is_open() and "participants" in self.tables:
            main.log("Merging %d chat participants (%s) into %s.",
                len(participants), chat["title_long_lc"], self.filename
            )
            self.ensure_backup()
            col_data = self.get_table_columns("participants")
            fields = [col["name"] for col in col_data if col["name"] != "id"]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)

            for p in participants:
                p_filled = self.fill_missing_fields(p, fields)
                p_filled = self.blobs_to_binary(p_filled, fields, col_data)
                p_filled["convo_id"] = chat["id"]
                self.execute("INSERT INTO participants (%s) VALUES (%s)" % (
                    str_cols, str_vals
                ), p_filled)

            self.connection.commit()
            self.last_modified = datetime.datetime.now()


    def insert_account(self, account):
        """
        Inserts the specified account into this database and sets it as the
        current account.
        """
        if self.is_open() and "accounts" not in self.tables:
            self.create_table("accounts")
            self.get_tables(True, "accounts")
        if self.is_open() and "accounts" in self.tables:
            main.log("Inserting account \"%s\" into %s.",
                account["skypename"], self.filename
            )
            self.ensure_backup()
            col_data = self.get_table_columns("accounts")
            fields = [col["name"] for col in col_data if col["name"] != "id"]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)

            a_filled = self.fill_missing_fields(account, fields)
            del a_filled["id"]
            a_filled = self.blobs_to_binary(a_filled, fields, col_data)
            self.execute("INSERT INTO accounts (%s) VALUES (%s)" % (
                str_cols, str_vals
            ), a_filled)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()
            self.account = a_filled
            self.id = a_filled["skypename"]


    def insert_contacts(self, contacts, source_db):
        """
        Inserts the specified contacts into this database.
        """
        if self.is_open() and not self.account and source_db.account:
            self.insert_account(source_db.account)
        if self.is_open() and "contacts" not in self.tables:
            self.create_table("contacts")
        if self.is_open() and "contacts" in self.tables:
            main.log(
                "Merging %d contacts into %s.", len(contacts), self.filename
            )
            self.ensure_backup()
            col_data = self.get_table_columns("contacts")
            fields = [col["name"] for col in col_data if col["name"] != "id"]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)
            for c in contacts:
                c_filled = self.fill_missing_fields(c, fields)
                c_filled = self.blobs_to_binary(c_filled, fields, col_data)
                self.execute("INSERT INTO contacts (%s) VALUES (%s)" % (
                    str_cols, str_vals
                ), c_filled)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()


    def replace_contactgroups(self, groups, source_db):
        """
        Inserts or updates the specified contact groups in this database.
        """
        if self.is_open() and not self.account and source_db.account:
            self.insert_account(source_db.account)
        if self.is_open() and "contactgroups" not in self.tables:
            self.create_table("contactgroups")
        if self.is_open() and "contactgroups" in self.tables:
            main.log("Merging %d contact groups into %s.",
                len(groups), self.filename
            )
            self.ensure_backup()

            col_data = self.get_table_columns("contactgroups")
            pk = [c["name"] for c in col_data if c["pk"]][0]
            pk_key = "PK%s" % int(time.time())
            fields = [col["name"] for col in col_data if not col["pk"]]
            str_fields = ", ".join(["%s = :%s" % (col, col) for col in fields])
            existing = dict([(c["name"], c) for c in self.get_contactgroups()])
            for c in filter(lambda x: x["name"] in existing, groups):
                c_filled = self.fill_missing_fields(c, fields)
                c_filled[pk_key] = existing[c["name"]][pk]
                self.execute("UPDATE contactgroups SET %s WHERE %s = :%s" % (
                    str_fields, pk, pk_key
                ), c_filled)

            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)
            for c in filter(lambda x: x["name"] not in existing, groups):
                c_filled = self.fill_missing_fields(c, fields)
                c_filled = self.blobs_to_binary(c_filled, fields, col_data)
                self.execute("INSERT INTO contactgroups (%s) VALUES (%s)" % (
                    str_cols, str_vals
                ), c_filled)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()


    def message_iterator(self, lst):
        """
        Yields message rows from the list. If the list consists of message IDs,
        executes queries on the Messages table and yields result rows.
        """
        if not lst:
            return
        if isinstance(lst[0], dict):
            for m in lst:
                yield m
        else:
            for ids in [lst[i:i+999] for i in range(0, len(lst), 999)]:
                # Divide into chunks: SQLite can take up to 999 parameters.
                idstr = ", ".join(":id%s" % (j+1) for j in range(len(ids)))
                s = "id IN (%s)" % idstr
                p = dict(("id%s" % (j+1), x) for j, x in enumerate(ids))
                res = self.get_messages(additional_sql=s, additional_params=p)
                for m in res:
                    yield m


    def save_row(self, table, row):
        """
        Updates the row in the database or inserts it if not existing.

        @return  ID of the inserted row
        """
        if self.is_open():
            self.ensure_backup()
            table = table.lower()
            col_data = self.get_table_columns(table)
            pk = [c["name"] for c in col_data if c["pk"]][0]
            exists = self.execute(
                "SELECT * FROM %s WHERE %s = :%s" % (table, pk, pk), row
            ).fetchone()
            if exists:
                return self.update_row(table, row)
            else:
                return self.insert_row(table, row)


    def update_row(self, table, row, original_row):
        """
        Updates the table row in the database, identified by its primary key
        in its original values.
        """
        if self.is_open():
            table = table.lower()
            main.log("Updating 1 row in table %s, %s.",
                self.tables[table]["name"], self.filename
            )
            self.ensure_backup()
            col_data = self.get_table_columns(table)
            pk = [c["name"] for c in col_data if c["pk"]][0]
            fields = ", ".join([
                "%(name)s = :%(name)s" % col
                    for col in col_data
            ])
            pk_key = "PK%s" % int(time.time())
            values = row.copy()
            values[pk_key] = original_row[pk]
            self.execute("UPDATE %s SET %s WHERE %s = :%s" % (
                table, fields, pk, pk_key
            ), values)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()
            return row[pk]


    def insert_row(self, table, row):
        """
        Inserts the new table row in the database.

        @return  ID of the inserted row
        """
        if self.is_open():
            table = table.lower()
            main.log("Inserting 1 row into table %s, %s.",
                self.tables[table]["name"], self.filename
            )
            self.ensure_backup()
            col_data = self.get_table_columns(table)
            fields = [col["name"] for col in col_data]
            str_cols = ", ".join(fields)
            str_vals = ":" + ", :".join(fields)
            row = self.blobs_to_binary(row, fields, col_data)
            cursor = self.execute("INSERT INTO %s (%s) VALUES (%s)"
                                  % (table, str_cols, str_vals), row)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()
            return cursor.lastrowid


    def delete_row(self, table, row):
        """
        Deletes the table row from the database. Row is identified by its
        primary key.
        """
        if self.is_open():
            table = table.lower()
            main.log("Deleting 1 row from table %s, %s.",
                     self.tables[table]["name"], self.filename)
            self.ensure_backup()
            col_data = self.get_table_columns(table)
            pk = [c["name"] for c in col_data if c["pk"]][0]
            self.execute("DELETE FROM %s WHERE %s = :%s" % (table, pk, pk), row)
            self.connection.commit()
            self.last_modified = datetime.datetime.now()



class MessageParser(object):
    """A Skype message parser, able to collect statistics from its input."""

    """
    Maximum line width in characters for text output.
    """
    TEXT_MAXWIDTH = 79

    """HTML entities in the body to be replaced before feeding to xml.etree."""
    REPLACE_ENTITIES = {"&apos;": "'"}

    """Regex for checking if string ends with any HTML entity, like "&lt;"."""
    ENTITY_CHECKBEHIND_RGX = re.compile(".*(&[#\\w]{2,};)$")

    """Regex for checking if string starts with any HTML entity, like "&lt;"."""
    ENTITY_CHECKAHEAD_RGX = re.compile("^(&[#\\w]{2,};).*")

    """Regex for replacing raw emoticon texts with emoticon tags."""
    EMOTICON_RGX = re.compile("(%s)" % "|".join(
                              s for i in emoticons.EmoticonData.values()
                              for s in map(re.escape, i["strings"])))

    # Regexes for checking if an emoticon is preceded or followed by
    # a non-alphanumeric character or a smiley or an empty string.
    EMOTICON_CHECKBEHIND_RGX = re.compile("(\\W)|(%s)|(^)$" % "|".join(
                               s for i in emoticons.EmoticonData.values()
                               for s in map(re.escape, i["strings"])),
                               re.UNICODE)
    EMOTICON_CHECKAHEAD_RGX  = re.compile("^(\\W)|(%s)|(^)$" % "|".join(
                               s for i in emoticons.EmoticonData.values()
                               for s in map(re.escape, i["strings"])),
                               re.UNICODE)

    """
    Replacer callback for raw emoticon text. Must check whether the preceding
    text up to the first or following text from the last emoticon char is not
    an HTML entity, e.g. "(&lt;)" or ":&quot;", and whether emoticon start and
    preceding text or emoticon end and following text is not alphanumeric.
    """
    EMOTICON_REPL = lambda self, m: ("<ss type=\"%s\">%s</ss>" % 
        (emoticons.EmoticonStrings[m.group(1)], m.group(1))
        if m.group(1) in emoticons.EmoticonStrings
        and (m.group(1)[:1] != ";" # Check HTML entity end, like '&lt;('
             or not MessageParser.ENTITY_CHECKBEHIND_RGX.match(
                m.string[max(0, m.start(1) - 7):m.start(1) + 1]))
        and (m.group(1)[-1:] != "&" # Check for HTML entity start, like ':&gt;'
             or not MessageParser.ENTITY_CHECKAHEAD_RGX.match(
                m.string[m.end(1) - 1:m.end(1) + 5]))
        and (m.group(1)[:1] not in string.ascii_letters
             # Letter at start: check for not being the end a word, like 'max('
             or MessageParser.EMOTICON_CHECKBEHIND_RGX.match(
                m.string[max(0, m.start(1) - 16):m.start(1)]))
        and (m.group(1)[-1:] not in string.ascii_letters
             # Letter at end: check for not being the start a word, like ':psi'
             or MessageParser.EMOTICON_CHECKAHEAD_RGX.match(
                m.string[m.start(1) + len(m.group(1)):m.start(1) + 32]))
        else m.group(1))

    """Regex for checking the existence of any character all emoticons have."""
    EMOTICON_CHARS_RGX = re.compile("[:|()/]")

    """Regex for replacing low bytes unparseable in XML (\x00 etc)."""
    SAFEBYTE_RGX = re.compile("[\x00-\x08,\x0B-\x0C,\x0E-x1F,\x7F]")

    """Replacer callback for low bytes unusable in XML (\x00 etc)."""
    SAFEBYTE_REPL = lambda self, m: m.group(0).encode("unicode-escape")

    """Mapping known failure reason codes to """
    FAILURE_REASONS = {"1": "Failed", "4": "Not enough Skype Credit."}


    def __init__(self, db, chat=None, stats=False, wrapfunc=None):
        """
        @param   db        SkypeDatabase instance for additional queries
        @param   chat      chat being parsed
        @param   stats     whether to collect message statistics
        @param   wrapfunc  multi-line text wrap function, if any
        """
        self.db = db
        self.chat = chat
        self.stats = None
        self.emoticons_unique = set()
        self.wrapfunc = wrapfunc
        self.textwrapfunc = textwrap.TextWrapper(width=self.TEXT_MAXWIDTH,
            expand_tabs=False, replace_whitespace=False,
            break_long_words=False, break_on_hyphens=False
        ).wrap # Text format output is wrapped with a fixed-width font
        if stats:
            self.stats = {"smses": 0, "transfers": [], "calls": 0,
                          "messages": 0, "counts": {}, "total": 0,
                          "startdate": None, "enddate": None, "wordcloud": [],
                          "cloudtext": "", "links": [], "last_message": "",
                          "chars": 0, "smschars": 0, "files": 0, "bytes": 0,
                          "calldurations": 0, "info_items": []}


    def parse(self, message, rgx_highlight=None, output=None):
        """
        Parses the specified Skype message and returns the message body as
        DOM, HTML or TXT.

        @param   message        message data dict
        @param   rgx_highlight  regex for finding text to highlight, if any
        @param   output         dict with output options:
                                "format": "html" returns an HTML string 
                                                 including author and timestamp
                                "format": "text" returns message body plaintext
                                "wrap": False    whether to wrap long lines
                                "export": False  whether output is for export,
                                                 using another content template
        @return                 a string if html or text specified, 
                                or xml.etree.cElementTree.Element containing
                                message body, with "xml" as the root tag and
                                any number of subtags:
                                (a|b|quote|quotefrom|msgstatus|bodystatus),
        """
        result = None
        dom = None
        is_html = output and "html" == output.get("format")

        if "dom" in message:
            dom = message["dom"] # Cached DOM already exists
        if dom is None:
            dom = self.parse_message_dom(message)
            message["dom"] = dom # Cache DOM

        if dom is not None and is_html: # Create a copy, HTML will mutate dom
            dom = copy.deepcopy(dom)
        if dom is not None and rgx_highlight and is_html:
            self.highlight_text(dom, rgx_highlight)

        if dom is not None and is_html:
            result = self.dom_to_html(dom, output)
        elif dom is not None and output and "text" == output.get("format"):
            result = self.dom_to_text(dom)
            if output.get("wrap"):
                linelists = map(self.textwrapfunc, result.split("\n"))
                ll = "\n".join(j if j else "" for i in linelists for j in i)
                # Force DOS linefeeds
                result = re.sub("([^\r])\n", lambda m: m.group(1) + "\r\n", ll)
        else:
            result = dom

        self.stats and self.collect_message_stats(message)
        return result


    def parse_message_dom(self, message):
        """
        Parses the body of the Skype message according to message type.

        @param   message  message data dict
        @return           ElementTree instance
        """
        body = message["body_xml"] or ""

        for entity, value in self.REPLACE_ENTITIES.items():
            body = body.replace(entity, value)
        body = body.encode("utf-8")
        if (message["type"] == MESSAGES_TYPE_MESSAGE and "<" not in body
        and self.EMOTICON_CHARS_RGX.search(body)):
            # Replace emoticons with <ss> tags if message appears to
            # have no XML (probably in older format).
            body = self.EMOTICON_RGX.sub(self.EMOTICON_REPL, body)
        dom = self.make_xml(body, message)

        if MESSAGES_TYPE_SMS == message["type"]:
            # SMS body can be plaintext, or can be XML. Relevant tags:
            # <sms alt="It's hammer time."><status>6</status>
            # <failurereason>0</failurereason><targets>
            # <target status="6">+555011235</target></targets><body>
            # <chunk id="0">te</chunk><chunk id="1">xt</chunk></body>
            # <encoded_body>text</encoded_body></sms>
            if dom.find("sms") is not None: # Body is XML data
                if dom.find("*/encoded_body") is not None:
                    # Message has all content in a single element
                    elem = dom.find("*/encoded_body")
                    encoded_body = xml.etree.cElementTree.tostring(elem)
                    body = encoded_body[14:-15] # Drop <encoded_body> tags
                elif dom.find("*/body/chunk") is not None:
                    # Message content is in <body>/<chunk> elements
                    chunks = {}
                    for c in dom.findall("*/body/chunk"):
                        chunks[int(c.get("id"))] = c.text
                    body = "".join([v for k, v in sorted(chunks.items())])
                else:
                    # Fallback, message content is in <sms alt="content"
                    body = dom.find("sms").get("alt")
                body = body.encode("utf-8")
            # Replace text emoticons with <ss>-tags if body not XML.
            if "<" not in body and self.EMOTICON_CHARS_RGX.search(body):
                body = self.EMOTICON_RGX.sub(self.EMOTICON_REPL, body)
            status_text = " SMS"
            status = dom.find("*/failurereason")
            if status is not None and status.text in self.FAILURE_REASONS:
                status_text += ": %s" % self.FAILURE_REASONS[status.text]
            dom = self.make_xml("<msgstatus>%s</msgstatus>%s" %
                                (status_text, body), message)
        elif MESSAGES_TYPE_FILE == message["type"] \
        or (MESSAGES_TYPE_INFO == message["type"]
        and "<files" in message["body_xml"]):
            transfers = self.db.get_transfers()
            files = dict((f["chatmsg_index"], f) for f in transfers
                         if f["chatmsg_guid"] == message["guid"])
            if not files:
                # No rows in Transfers, try to find data from message body
                # and create replacements for Transfers fields
                for f in dom.findall("*/file"):
                    files[int(f.get("index"))] = {
                        "filename": f.text, "filepath": "",
                        "filesize": f.get("size"),
                        "partner_handle": message["author"],
                        "partner_dispname": message["from_dispname"],
                        "starttime": message["timestamp"],
                        "type": (TRANSFER_TYPE_OUTBOUND 
                                 if message["author"] == self.db.id
                                 else TRANSFER_TYPE_INBOUND)}
            message["__files"] = [f for i, f in sorted(files.items())]
            dom.clear()
            dom.text = "sent " if MESSAGES_TYPE_INFO == message["type"] \
                       else "Sent "
            dom.text += ("files " if len(files) > 1 else "file ")
            a = None
            for i in sorted(files.keys()):
                if len(dom) > 0:
                    a.tail = ", "
                f = files[i]
                h = util.path_to_url(f["filepath"] or f["filename"])
                a = xml.etree.cElementTree.SubElement(dom, "a", {"href": h})
                a.text = f["filename"]
            if a is not None:
                a.tail = "."
        elif MESSAGES_TYPE_CONTACTS == message["type"]:
            self.db.get_contacts()
            get_name = self.db.get_contact_name
            contacts = sorted([get_name(i.get("f") or i.get("s"))
                               for i in dom.findall("*/c")])
            dom.clear()
            dom.text = "Sent contact" + (len(contacts) > 1 and "s " or " ")
            for i in contacts:
                if len(dom) > 0:
                    b.tail = ", "
                b = xml.etree.cElementTree.SubElement(dom, "b")
                b.text = i["name"] if type(i) is dict else i
            b.tail = "."
        elif MESSAGES_TYPE_TOPIC == message["type"]:
            if dom.text:
                dom.text = "Changed the conversation topic to \"%s\"." \
                           % dom.text
                if not dom.text.endswith("."):
                    dom.text += "."
            else:
                dom.text = "Changed the conversation picture."
        elif MESSAGES_TYPE_CALL == message["type"]:
            for elem in dom.getiterator("part"):
                identity = elem.get("identity")
                duration = elem.findtext("duration")
                if identity and duration:
                    calldurations = message.get("__calldurations", {})
                    try:
                        calldurations[identity] = int(duration)
                        message["__calldurations"] = calldurations
                    except (TypeError, ValueError):
                        pass
            dom.clear()
            elm_stat = xml.etree.cElementTree.SubElement(dom, "msgstatus")
            elm_stat.text = " Call"
        elif MESSAGES_TYPE_CALL_END == message["type"]:
            dom.clear()
            elm_stat = xml.etree.cElementTree.SubElement(dom, "msgstatus")
            elm_stat.text = " Call ended"
        elif MESSAGES_TYPE_LEAVE == message["type"]:
            dom.text = "%s has left the conversation." \
                        % message["from_dispname"]
        elif message["type"] in [MESSAGES_TYPE_PARTICIPANTS,
        MESSAGES_TYPE_REMOVE, MESSAGES_TYPE_SHARE_DETAIL]:
            names = sorted([self.db.get_contact_name(i)
                            for i in message["identities"].split(" ")])
            dom.clear()
            dom.text = "Added "
            if MESSAGES_TYPE_SHARE_DETAIL == message["type"]:
                dom.text = "Has shared contact details with "
            for i in names:
                if len(dom) > 0:
                    b.tail = ", "
                b = xml.etree.cElementTree.SubElement(dom, "b")
                b.text = i["name"] if type(i) is dict else i
            b.tail = "."
            if MESSAGES_TYPE_REMOVE == message["type"]:
                dom.text = "Removed "
                b.tail = " from this conversation."
        elif message["type"] in [MESSAGES_TYPE_INFO, MESSAGES_TYPE_MESSAGE]:
            if message["edited_timestamp"] and not message["body_xml"]:
                elm_sub = xml.etree.cElementTree.SubElement(dom, "bodystatus")
                elm_sub.text = MESSAGE_REMOVED_TEXT

        # Process Skype message quotation tags, assembling a simple
        # <quote>text<special>footer</special></quote> element.
        # element
        for quote in dom.findall("quote"):
            quote.text = quote.text or ""
            for i in quote.findall("legacyquote"):
                # <legacyquote> contains preformatted timestamp and author
                if i.tail:
                    quote.text += i.tail
                quote.remove(i)
            footer = quote.get("authorname") or ""
            if quote.get("timestamp"):
                footer += (", %s" if footer else "%s") % \
                    datetime.datetime.fromtimestamp(
                        int(quote.get("timestamp"))
                    ).strftime("%d.%m.%Y %H:%M")
            if footer:
                elm_sub = xml.etree.cElementTree.SubElement(quote, "quotefrom")
                elm_sub.text = footer
            quote.attrib.clear() # Drop the numerous data attributes
        return dom


    def make_xml(self, text, message):
        """Returns a new xml.etree.cElementTree node from the text."""
        result = None
        TAG = "<xml>%s</xml>"
        try:
            result = xml.etree.cElementTree.fromstring(TAG % text)
        except Exception:
            text = self.SAFEBYTE_RGX.sub(self.SAFEBYTE_REPL, text)
            try:
                result = xml.etree.cElementTree.fromstring(TAG % text)
            except Exception:
                try:
                    text = text.replace("&", "&amp;")
                    result = xml.etree.cElementTree.fromstring(TAG % text)
                except Exception as e:
                    result = xml.etree.cElementTree.fromstring(TAG % "")
                    result.text = text
                    main.log("Error parsing message %s, body \"%s\" (%s).", 
                             message["id"], text, e)
        return result


    def highlight_text(self, dom, rgx_highlight):
        """Wraps text matching regex in any dom element in <b> nodes."""
        parent_map = dict((c, p) for p in dom.getiterator() for c in p)
        rgx_highlight_split = re.compile("<b>")
        repl_highlight = lambda x: "<b>%s<b>" % x.group(0) 
        # Highlight substrings in <b>-tags
        for i in dom.getiterator():
            if "b" == i.tag:
                continue # continue for i in dom.getiterator()
            for j, t in enumerate([i.text, i.tail]):
                if not t:
                    continue # continue for j, t in enumerate(..)
                highlighted = rgx_highlight.sub(repl_highlight, t)
                parts = rgx_highlight_split.split(highlighted)
                if len(parts) < 2:
                    continue # continue for j, t in enumerate(..)
                index_insert = (list(parent_map[i]).index(i) + 1) if j else 0
                setattr(i, "tail" if j else "text", "")
                b = None
                for k, part in enumerate(parts):
                    if k % 2: # Text to highlight, wrap in <b>
                        b = xml.etree.cElementTree.Element("b")
                        b.text = part
                        if j: # Processing i.tail
                            parent_map[i].insert(index_insert, b)
                        else: # Processing i.text
                            i.insert(index_insert, b)
                        index_insert += 1
                    else: # Other text, append to tail/text
                        if j: # Processing i.tail
                            if b is not None: #
                                b.tail = part
                            else:
                                i.tail = (i.tail or "") + part
                        else: # Processing i.text
                            if b is not None:
                                b.tail = part
                            else:
                                i.text = part


    def dom_to_html(self, dom, output):
        """Returns an HTML representation of the message body."""
        greytag, greyattr, greyval = "font", "color", conf.HistoryGreyColour
        if output.get("export"):
            greytag, greyattr, greyval = "span", "class", "grey"
        for elem in dom.getiterator():
            index = 0
            for subelem in elem:
                if "quote" == subelem.tag:
                    elem_quotefrom = subelem.find("quotefrom")
                    # Replace quote tags with a formatted subtable
                    templ = step.Template(templates.MESSAGE_QUOTE)
                    template = templ.expand(export=output.get("export"))
                    template = template.replace("\n", " ").strip()
                    table = xml.etree.cElementTree.fromstring(template)
                    # Select last, content cell
                    cell = table.findall("*/td")[-1]
                    cell.find(greytag).text += elem_quotefrom.text
                    subelem.remove(elem_quotefrom)
                    cell.text = subelem.text
                    # Insert all children before the last font element
                    len_orig = len(cell)
                    [cell.insert(len(cell) - len_orig, i) for i in subelem]
                    table.tail = subelem.tail
                    elem[index] = table # Replace <quote> element in parent
                elif "ss" == subelem.tag: # Emoticon
                    if output.get("export"):
                        emot, emot_type = subelem.text, subelem.get("type")
                        template, vals = "<span>%s</span>", [emot]
                        if hasattr(emoticons, emot_type):
                            data = emoticons.EmoticonData[emot_type]
                            title = data["title"]
                            if data["strings"][0] != data["title"]:
                                title += " " + data["strings"][0]
                            template = "<span class=\"emoticon %s\" " \
                                       "title=\"%s\">%s</span>"
                            vals = [emot_type, title, emot]
                        span_str = template % tuple(map(cgi.escape, vals))
                        span = xml.etree.cElementTree.fromstring(span_str)
                        span.tail = subelem.tail
                        elem[index] = span # Replace <ss> element in parent
                elif subelem.tag in ["msgstatus", "bodystatus"]:
                    subelem.tag = greytag
                    subelem.set(greyattr, greyval)
                    # Add whitespace before next content
                    subelem.tail = " " + (subelem.tail or "")
                elif "a" == subelem.tag:
                    subelem.set("target", "_blank")
                    if output.get("export"):
                        href = subelem.get("href").encode("utf-8")
                        subelem.set("href", urllib.quote(href, ":/=?&#"))
                    else: # Wrap content in system link colour
                        t = "<font color='%s'></font>" % conf.SkypeLinkColour
                        span = xml.etree.cElementTree.fromstring(t)
                        span.text = subelem.text
                        for i in list(subelem):
                            span.append(i), subelem.remove(i)
                        subelem.text = ""
                        subelem.append(span)
                index += 1
            if not self.wrapfunc:
                continue # continue for elem in dom.getiterator()
            for i, v in enumerate([elem.text, elem.tail]):
                v and setattr(elem, "tail" if i else "text", self.wrapfunc(v))
        try:
            # Discard <?xml ..?><xml> tags from start, </xml> from end
            result = xml.etree.cElementTree.tostring(dom, "UTF-8")[44:-6]
        except Exception as e:
            # If ElementTree.tostring fails, try converting all text
            # content from UTF-8 to Unicode.
            main.log("Exception for %s: %s", message["body_xml"], e)
            for elem in dom.findall("*"):
                for attr in ["text", "tail"]:
                    val = getattr(elem, attr)
                    if val and isinstance(val, str):
                        try:
                            setattr(elem, attr, val.decode("utf-8"))
                        except Exception as e:
                            main.log("Error decoding %s value \"%s\" (type %s)"
                                     " of %s for \"%s\": %s", attr, val,
                                     type(val), elem, message["body_xml"], e)
            try:
                result = xml.etree.cElementTree.tostring(dom, "UTF-8")[44:-6]
            except Exception:
                main.log("Failed to parse the message \"%s\" from %s.",
                         message["body_xml"], message["author"])
                raise
        # emdash workaround, cElementTree won't handle unknown entities
        result = result.replace("{EMDASH}", "&mdash;") \
                       .replace("\n", "<br />")
        return result


    def dom_to_text(self, dom, tails_new=None):
        """Returns a plaintext representation of the message DOM."""
        fulltext = ""
        to_skip = {} # {element to skip: True, }
        for elem in dom.getiterator():
            if elem in to_skip:
                continue
            text = elem.text or ""
            tail = elem.tail or ""
            subitems = []
            if "quote" == elem.tag:
                text = "\"" + text
                subitems = elem.getchildren()
            elif "quotefrom" == elem.tag:
                text = "\"\r\n%s\r\n" % text
            elif "msgstatus" == elem.tag:
                text = "[%s]\r\n" % text.strip()
            elif "ss" == elem.tag:
                text = elem.text
            if text:
                fulltext += text
            for i in subitems:
                fulltext += self.dom_to_text(i)
                to_skip[i] = True
            if tail:
                fulltext += tail
        return fulltext


    def add_dict_text(self, dictionary, key, text, inter=" "):
        """Adds text to an entry in the dictionary."""
        dictionary[key] += (inter if dictionary[key] else "") + text


    def collect_message_stats(self, message):
        """Adds message statistics to accumulating data."""
        author_stats = collections.defaultdict(lambda: 0)
        self.stats["startdate"] = self.stats["startdate"] or message["datetime"]
        self.stats["enddate"] = message["datetime"]
        self.stats["total"] += 1
        self.stats["last_message"] = ""
        if message["type"] in [MESSAGES_TYPE_SMS, MESSAGES_TYPE_MESSAGE]:
            self.collect_dom_stats(message["dom"])
            message["body_txt"] = self.stats["last_message"] # Export kludge
        author, len_msg = message["author"], len(self.stats["last_message"])
        if (message["type"] in [MESSAGES_TYPE_SMS, MESSAGES_TYPE_CALL,
            MESSAGES_TYPE_FILE, MESSAGES_TYPE_MESSAGE]
        and author not in self.stats["counts"]):
            self.stats["counts"][author] = author_stats.copy()

        if MESSAGES_TYPE_SMS == message["type"]:
            self.stats["smses"] += 1
            self.stats["counts"][author]["smses"] += 1
            self.stats["counts"][author]["smschars"] += len_msg
        elif MESSAGES_TYPE_CALL == message["type"]:
            self.stats["calls"] += 1
            self.stats["counts"][author]["calls"] += 1
            calldurations = message.get("__calldurations", {})
            for identity, duration in calldurations.items():
                if identity not in self.stats["counts"]:
                    self.stats["counts"][identity] = author_stats.copy()
                self.stats["counts"][identity]["calldurations"] += duration
            self.stats["calldurations"] += max(calldurations.values() or [0])
        elif MESSAGES_TYPE_FILE == message["type"]:
            files = message.get("__files")
            if files is None:
                transfers = self.db.get_transfers()
                filedict = dict((f["chatmsg_index"], f) for f in transfers
                                if f["chatmsg_guid"] == message["guid"])
                files = [f for i, f in sorted(filedict.items)]
                message["__files"] = files
            self.stats["transfers"].extend(files)
            self.stats["counts"][author]["files"] += len(files)
            size_files = sum([int(i["filesize"]) for i in files])
            self.stats["counts"][author]["bytes"] += size_files
        elif MESSAGES_TYPE_MESSAGE == message["type"]:
            self.stats["messages"] += 1
            self.stats["counts"][author]["messages"] += 1
            self.stats["counts"][author]["chars"] += len_msg


    def collect_dom_stats(self, dom, tails_new=None):
        """Updates current statistics with data from the message DOM."""
        to_skip = {} # {element to skip: True, }
        tails_new = {} if tails_new is None else tails_new
        for elem in dom.getiterator():
            if elem in to_skip:
                continue
            text = elem.text or ""
            tail = tails_new[elem] if elem in tails_new else (elem.tail or "")
            if type(text) is str:
                text = text.decode("utf-8")
            if type(tail) is str:
                tail = tail.decode("utf-8")
            subitems = []
            if "quote" == elem.tag:
                self.add_dict_text(self.stats, "cloudtext", text)
                self.add_dict_text(self.stats, "last_message", text)
                subitems = elem.getchildren()
            elif "a" == elem.tag:
                self.stats["links"].append(text)
                self.add_dict_text(self.stats, "last_message", text)
            elif "ss" == elem.tag:
                self.emoticons_unique.add(elem.get("type"))
            elif "quotefrom" == elem.tag:
                self.add_dict_text(self.stats, "last_message", text)
            elif elem.tag in ["xml", "b"]:
                self.add_dict_text(self.stats, "cloudtext", text)
                self.add_dict_text(self.stats, "last_message", text)
            for i in subitems:
                self.collect_dom_stats(i, tails_new)
                to_skip[i] = True
            if tail:
                self.add_dict_text(self.stats, "cloudtext", tail)
                self.add_dict_text(self.stats, "last_message", tail)


    def get_collected_stats(self):
        """
        Returns the statistics collected during message parsing.

        @return  dict with statistics entries, or empty dict if not collecting
        """
        if not self.stats:
            return {}
        stats = self.stats
        for k in ["chars", "smschars", "files", "bytes", "calls"]:
            stats[k] = sum(i[k] for i in stats["counts"].values())

        del stats["info_items"][:]
        delta_date = None
        if stats["enddate"] and stats["startdate"]:
            delta_date = stats["enddate"] - stats["startdate"]
            if delta_date.days:
                period_value = "%s - %s (%s)" % \
                               (stats["startdate"].strftime("%d.%m.%Y"),
                                stats["enddate"].strftime("%d.%m.%Y"),
                                util.plural("day", delta_date.days))
            else:
                period_value = stats["startdate"].strftime("%d.%m.%Y")
            stats["info_items"].append(("Time period", period_value))
        if stats["messages"]:
            msgs_value  = "%d (%s)" % (stats["messages"],
                          util.plural("character", stats["chars"]))
            stats["info_items"].append(("Messages", msgs_value))
        if stats["smses"]:
            smses_value  = "%d (%s)" % (stats["smses"],
                           util.plural("character", stats["smschars"]))
            stats["info_items"].append(("SMSes", smses_value))
        if stats["calls"]:
            calls_value  = "%d (%s)" % (stats["calls"],
                           util.format_seconds(stats["calldurations"]))
            stats["info_items"].append(("Calls", calls_value))
        if stats["transfers"]:
            files_value  = "%d (%s)" % (len(stats["transfers"]),
                           util.format_bytes(stats["bytes"]))
            stats["info_items"].append(("Files", files_value))

        if delta_date is not None:
            per_day = util.safedivf(stats["messages"], delta_date.days + 1)
            per_day = ("%d" if per_day == int(per_day) else "%.1f") % per_day
            stats["info_items"].append(("Messages per day", per_day))

        cloud = wordcloud.get_cloud(stats["cloudtext"], stats["links"])
        stats["wordcloud"] = cloud
        return stats


def is_sqlite_file(filename, path=None):
    """Returns whether the file looks to be an SQLite database file."""
    result = filename.lower().endswith(".db")
    if result:
        try:
            fullpath = os.path.join(path, filename) if path else filename
            result = bool(os.path.getsize(fullpath))
            if result:
                result = False
                SQLITE_HEADER = "SQLite format 3\00"
                with open(fullpath, "rb") as f:
                    result = (f.read(len(SQLITE_HEADER)) == SQLITE_HEADER)
        except Exception:
            pass
    return result


def detect_databases():
    """
    Tries to detect Skype database files on the current computer, looking
    under "Documents and Settings", and other potential locations.

    @yield   each value is a list of detected database paths
    """
    # First, search system directories for main.db files.
    if "nt" == os.name:
        search_paths = [os.path.join(os.getenv("APPDATA"), "Skype")]
        c = os.getenv("SystemDrive") or "C:"
        for path in ["%s\\Users" % c, "%s\\Documents and Settings" % c]:
            if os.path.exists(path):
                search_paths.append(path)
                break # break for path in [..]
    else:
        search_paths = [os.getenv("HOME"),
                        "/Users" if "mac" == os.name else "/home"]
    search_paths = map(util.to_unicode, search_paths)

    WINDOWS_APPDIRS = ["application data", "roaming"]
    for search_path in filter(os.path.exists, search_paths):
        main.log("Looking for Skype databases under %s.", search_path)
        for root, dirs, files in os.walk(search_path):
            if os.path.basename(root).lower() in WINDOWS_APPDIRS:
                # Skip all else under "Application Data" or "AppData\Roaming".
                dirs[:] = filter(lambda x: "skype" == x.lower(), dirs)
            results = []
            for f in files:
                if "main.db" == f.lower() and is_sqlite_file(f, root):
                    results.append(os.path.realpath(os.path.join(root, f)))
            if results: yield results

    # Then search current working directory for *.db files.
    search_path = util.to_unicode(os.getcwd())
    main.log("Looking for Skype databases under %s.", search_path)
    for root, dirs, files in os.walk(search_path):
        results = []
        for f in filter(lambda f: is_sqlite_file(f, root), files):
            results.append(os.path.realpath(os.path.join(root, f)))
        if results: yield results


def find_databases(folder):
    """Yields a list of all Skype databases under the specified folder."""
    for root, dirs, files in os.walk(folder):
        for f in filter(lambda f: is_sqlite_file(f, root), files):
            yield os.path.join(root, f)


def import_contacts_file(filename):
    """
    Returns contacts found in the CSV file, as [{"name", "e-mail", "phone"}].
    """
    contacts = []
    # GMail CSVs can contain mysterious NULL bytes
    lines_raw = [line.replace('\x00', '') for line in open(filename, "rb")]
    lines = list(csv.reader(lines_raw))
    header, items = lines[0], lines[1:]
    titlemap = dict((title, i) for i, title in enumerate(header))

    # By default, assume MSN/Outlook type of values
    FIRST, MIDDLE, LAST = "First Name", "Middle Name", "Last Name"
    PHONE_FIELDS, EMAIL_FIELDS = ["Mobile Phone"], ["E-mail Address"]
    if "Given Name" in titlemap: # Looks like GMail type of values
        FIRST, MIDDLE, LAST = "Given Name", "Additional Name", "Family Name"
        PHONE_FIELDS = [("Phone %s - Value" % i) for i in range(1, 5)]
        EMAIL_FIELDS = [("E-mail %s - Value" % i) for i in range(1, 3)]

    for row in filter(None, items):
        row = [i.strip().decode("latin1") for i in row]
        values = dict((t, row[i]) for t, i in titlemap.items())

        # Assemble full name from partial fields
        contact = {"name": values.get(FIRST, ""), "phone": "", "e-mail": ""}
        for title in filter(lambda x: values.get(x, ""), [MIDDLE, LAST]):
            contact["name"] += " " + values[title]

        # Phone data can contain arbitrary whitespace: remove it
        for title in filter(lambda x: values.get(x, ""), PHONE_FIELDS):
            values[title] = re.sub(r"\s+", "", values[title])

        # Gather phone and e-mail information
        for t, fields in [("phone", PHONE_FIELDS), ("e-mail", EMAIL_FIELDS)]:
            for title in filter(lambda x: values.get(x, ""), fields):
                if contact[t]: # Value already filled: make new record
                    contacts.append(contact)
                    contact = contact.copy()
                contact[t] = values[title]

        if any(contact.values()):
            contacts.append(contact)
    return contacts


def get_avatar_pil(datadict, size=None, keep_aspect_ratio=True):
    """
    Returns a PIL.Image for the contact/account avatar, if any.

    @param   datadict           row from Contacts or Accounts
    @param   size               (width, height) to resize image to, if any
    @param   keep_aspect_ratio  if True, keeps image aspect ratio is on
                                resizing, filling the outside in white
    """
    result = None
    raw = datadict.get("avatar_image") or datadict.get("profile_attachments")
    if raw:
        try:
            data = fix_image_raw(raw)
            imgparser = ImageFile.Parser(); imgparser.feed(data)
            img = imgparser.close()

            if size and list(size) != list(img.size):
                size2, align_pos = list(size), None
                if img.size[0] < size[0] and img.size[1] < size[1]:
                    size2 = img.size
                    align_pos = [(a - b) / 2 for a, b in zip(size, size2)]
                elif keep_aspect_ratio:
                    ratio = util.safedivf(img.size[0], img.size[1])
                    size2[ratio > 1] *= ratio if ratio < 1 else 1 / ratio
                    align_pos = [(a - b) / 2 for a, b in zip(size, size2)]
                if img.size[0] > size[0] or img.size[1] > size[1]:
                    img.thumbnail(tuple(map(int, size2)), Image.ANTIALIAS)
                if align_pos:
                    img, img0 = Image.new(img.mode, size, "white"), img
                    img.paste(img0, tuple(map(int, align_pos)))
            result = img
        except Exception as e:
            main.log("Error loading avatar image for %s (%s).",
                     datadict["skypename"], e)
    return result


def get_avatar(datadict, size=None, keep_aspect_ratio=True):
    """
    Returns a wx.Bitmap for the contact/account avatar, if any.

    @param   datadict           row from Contacts or Accounts
    @param   size               (width, height) to resize image to, if any
    @param   keep_aspect_ratio  if True, keeps image aspect ratio is on
                                resizing, filling the outside in white
    """
    result = None
    raw = datadict.get("avatar_image") or datadict.get("profile_attachments")
    if raw:
        try:
            data = fix_image_raw(raw)
            img = wx.ImageFromStream(cStringIO.StringIO(data))

            if size and list(size) != list(img.GetSize()):
                align_pos, size2 = None, list(size)
                if keep_aspect_ratio:
                    ratio = util.safedivf(img.Width, img.Height)
                    size2[ratio > 1] *= ratio if ratio < 1 else 1 / ratio
                    align_pos = [(a - b) / 2 for a, b in zip(size, size2)]
                img = img.ResampleBox(*size2)
                if align_pos:
                    img.Resize(size, align_pos, 255, 255, 255)
            result = wx.BitmapFromImage(img)
        except Exception as e:
            main.log("Error loading avatar image for %s (%s).",
                     datadict["skypename"], e)
    return result


def get_avatar_raw(datadict, size=None, keep_aspect_ratio=True, format="PNG"):
    """
    Returns the contact/account avatar image, if any, as raw encoded image.

    @param   datadict           row from Contacts or Accounts
    @param   size               (width, height) to resize larger image down to,
                                if any
    @param   keep_aspect_ratio  if True, keeps image aspect ratio is on
                                resizing, filling the outside in white
    @param   format             image format type as supported by PIL
    """
    result = ""
    try:
        img = get_avatar_pil(datadict, size, keep_aspect_ratio)
        if img:
            stream = cStringIO.StringIO()
            img.save(stream, format)
            result = stream.getvalue()
    except Exception as e:
        main.log("Error creating avatar JPG for %s (%s).",
                 datadict["skypename"], e)
    return result


def fix_image_raw(raw):
    """Returns the raw image bytestream with garbage removed from front."""
    JPG_HEADER = "\xFF\xD8\xFF\xE0\x00\x10JFIF"
    PNG_HEADER = "\x89PNG\r\n\x1A\n"
    if isinstance(raw, unicode):
        raw = raw.encode("latin1")
    if JPG_HEADER in raw:
        raw = raw[raw.index(JPG_HEADER):]
    elif PNG_HEADER in raw:
        raw = raw[raw.index(PNG_HEADER):]
    elif raw.startswith("\0"):
        raw = raw[1:]
        if raw.startswith("\0"):
            raw = "\xFF" + raw[1:]
    return raw



"""
Information on Skype database tables (unreliable, mostly empirical):

Accounts       - one row with user profile information
Alerts         - alerts from Skype payments, Facebook etc
CallMembers    - participants in Skype calls
Calls          - Skype phone calls
ChatMembers    - may be unused, migration from old *.dbb files on Skype upgrade
Chats          - some sort of a bridge between Conversations and Messages
ContactGroups  - user-defined contact groups
Contacts       - all Skype contacts, also including plain phone numbers
Conversations  - all conversations, both single and group chats
DbMeta         - Skype internal metainformation
LegacyMessages - seems unused
Messages       - all conversation messages, including Skype internals
Participants   - conversation participants
SMSes          - SMSes sent from Skype, connected to Messages. Can have
                 several rows per one message
Transfers      - file transfers, connected to Messages
Videos         - video calls, connected to Calls
Voicemails     - voicemail information


Information collected on some table fields (an incomplete list):

Contacts:
  about                  "About" field in profile
  assigned_phone1        1st of 3 self-assigned phone numbers per contact
  assigned_phone2        2nd of 3 self-assigned phone numbers per contact
  assigned_phone3        3rd of 3 self-assigned phone numbers per contact
  assigned_phone1_label  0: Home, 1: Office, 2: Mobile, 3: Other
  assigned_phone2_label  0: Home, 1: Office, 2: Mobile, 3: Other
  assigned_phone3_label  0: Home, 1: Office, 2: Mobile, 3: Other
  birthday               birth date as YYYYMMDD in integer field
  city                   City field in profile
  country                "Country/Region" in profile, contains 2-char code
  fullname               exists for most if not all active Skype contacts
  gender                 1: male, 2: female, NULL: undefined
  displayname            contact display name, is set also for single phone numbers
  emails                 "Email" field in profile, contains space-separated list
  homepage               "Website" field in profile
  languages              "Language" field in profile, contains 2-char code
  mood_text              plaintext of the "Mood" field in profile
  phone_home             "Home phone" field in profile
  phone_office           "Office phone" field in profile
  phone_mobile           "Mobile phone" field in profile
  province               "State/Province" field in profile
  pstnnumber             contains the number for single phone number contacts
  rich_mood_text         "Mood" field in profile, can contain XML
                         (e.g. flag/video tags)
  skypename              skype account name, blank for added pstnnumbers

Conversations:
  type            1: single, 2: group
  identity        unique global identifier, skypename of other correspondent
                  for single chats and a complex value for multichats
  displayname     name of other correspondent for single chats, and
                  given/assigned name for multichats
  meta_topic      topic set to the conversation


Messages:
  chatmsg_type    NULL: (type 4, 30, 39, 50, 53, 68, 110)
                  1:    add participant (type 10),
                        identities has space-separated list)
                  2:    type 10: add participant (identities has
                        space-separated list)
                        type 100: notice that a file transfer was offered
                  3:    ordinary message (type 61)
                  4:    "%name has left" (type 13)
                  5:    set conversation topic (type 2)
                  6:    file accepting (type 100)
                  7:    file transfer, SMS, or "/me laughs" (type 60, 64, 68)
                        if transfer, Messages.guid == Transfers.chatmsg_guid
                  8:    sent contacts (body_xml has contacts XML) (type 63)
                  11:   "%name removed %name from this conversation." (type 12)
                  15:   "%name% has changed the conversation picture" (type 2)
                  18:   different call/contact things (type 30, 39, 51)

  type            2:    set topic or picture (chatmsg_type 5, 15)
                  4:    "#author created a group conversation with #identities.
                        Show group conversation" (chatmsg_type NULL)
                  10:   added participant (chatmsg_type 1, 2)
                  12:   sent contacts (chatmsg_type 11)
                  13:   "%name has left" (chatmsg_type 4)
                  30:   call (chatmsg_type 18, NULL). body_xml can have
                        participants XML.
                  39:   call ended (chatmsg_type 18, NULL)
                  50:   intro message, "wish to add you to my contacts"
                        (chatmsg_type NULL). body_xml can have display message.
                        Seems received when one or other adds on request?
                  51:   "%name has shared contact details with %myname."
                        (chatmsg_type 18)
                  53:   blocking contacts in #identities
                  60:   various info messages (chatmsg_type 7),
                        e.g. "has sent a file to x, y, ..", or "/me laughs"
                  61:   ordinary message (chatmsg_type 7)
                  63:   sent contacts (chatmsg_type 8)
                  64:   SMS (chatmsg_type 7)
                  68:   file transfer (chatmsg_type 7)
                  100:  file sending and accepting (chatmsg_type 2, 6)
                  110:  birthday alert (chatmsg_type NULL)
  edited_timestamp      if set, message has been edited; if body_xml is empty,
                        message has been deleted

SMSes:
  chatmsg_id      if set, refers to the Messages.id entry showing this SMS
  failurereason   0:    no failure
                  1:    general
                  4:    not enough Skype credit
  status          3:    unknown
                  5:    unknown
                  6:    delivered
                  7:    unknown
                  8:    failed

Transfers:
  chatmsg_guid    if set, refers to Messages.guid WHERE chatmsg_type = 7
  chatmsg_index   index of the file in the chat message (for batch transfers)
  convo_id        if set, refers to the Conversations entry
  failurereason   0:    cancelled
                  2:    delivered
                  5:    sending failed
                  8:    sending failed
                  10:   file isn't available
  status          7:    cancelled
                  8:    delivered
                  9:    failed
                  10:   file isn't available
                  11:   file isn't available on this computer
                  12:   delivered
  type            1:    partner_handle is sending
                  2:    partner_handle is receiving


Videos:
  convo_id        foreign key on Calls.id
"""

########NEW FILE########
__FILENAME__ = skyperious
# -*- coding: utf-8 -*-
"""
Skyperious UI application main window class and project-specific UI classes.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     26.11.2011
@modified    12.05.2014
------------------------------------------------------------------------------
"""
import ast
import base64
import collections
import copy
import cStringIO
import datetime
import hashlib
import inspect
import math
import os
import re
import shutil
import sys
import textwrap
import time
import traceback
import urllib
import webbrowser

import wx
import wx.gizmos
import wx.grid
import wx.html
import wx.lib
import wx.lib.agw.fmresources
import wx.lib.agw.genericmessagedialog
import wx.lib.agw.labelbook
import wx.lib.agw.flatmenu
import wx.lib.agw.flatnotebook
import wx.lib.agw.ultimatelistctrl
import wx.lib.newevent
import wx.lib.scrolledpanel
import wx.stc

# Core functionality can work without these modules
try:
    import Skype4Py
except ImportError:
    Skype4Py = None
try:
    from dateutil.relativedelta import relativedelta
except ImportError:
    relativedelta = None

from third_party import step

import conf
import controls
import export
import guibase
import images
import main
import skypedata
import support
import templates
import util
import workers


"""Custom application events for worker results."""
WorkerEvent, EVT_WORKER = wx.lib.newevent.NewEvent()
ContactWorkerEvent, EVT_CONTACT_WORKER = wx.lib.newevent.NewEvent()
DetectionWorkerEvent, EVT_DETECTION_WORKER = wx.lib.newevent.NewEvent()
OpenDatabaseEvent, EVT_OPEN_DATABASE = wx.lib.newevent.NewEvent()


class MainWindow(guibase.TemplateFrameMixIn, wx.Frame):
    """Skyperious main window."""

    TRAY_ICON = (images.Icon16x16_32bit if "linux2" != sys.platform 
                 else images.Icon24x24_32bit)

    def __init__(self):
        wx.Frame.__init__(self, parent=None, title=conf.Title, size=conf.WindowSize)
        guibase.TemplateFrameMixIn.__init__(self)

        self.init_colours()
        self.db_filename = None # Current selected file in main list
        self.db_filenames = {}  # added DBs {filename: {size, last_modified,
                                #            account, chats, messages, error},}
        self.dbs = {}           # Open databases {filename: SkypeDatabase, }
        self.db_pages = {}      # {DatabasePage: SkypeDatabase, }
        self.merger_pages = {}  # {MergerPage: (SkypeDatabase, SkypeDatabase),}
        self.page_merge_latest = None # Last opened merger page
        self.page_db_latest = None    # Last opened database page
        # List of Notebook pages user has visited, used for choosing page to
        # show when closing one.
        self.pages_visited = []
        self.db_drag_start = None

        icons = images.get_appicons()
        self.SetIcons(icons)

        panel = self.panel_main = wx.Panel(self)
        sizer = panel.Sizer = wx.BoxSizer(wx.VERTICAL)

        self.frame_console.SetIcons(icons)

        notebook = self.notebook = wx.lib.agw.flatnotebook.FlatNotebook(
            parent=panel, style=wx.NB_TOP,
            agwStyle=wx.lib.agw.flatnotebook.FNB_NODRAG |
                     wx.lib.agw.flatnotebook.FNB_NO_X_BUTTON |
                     wx.lib.agw.flatnotebook.FNB_MOUSE_MIDDLE_CLOSES_TABS |
                     wx.lib.agw.flatnotebook.FNB_NO_TAB_FOCUS |
                     wx.lib.agw.flatnotebook.FNB_FF2)

        self.create_page_main(notebook)
        self.page_log = self.create_log_panel(notebook)
        notebook.AddPage(self.page_log, "Log")
        notebook.RemovePage(self.notebook.GetPageCount() - 1) # Hide log window
        # Kludge for being able to close log window repeatedly, as DatabasePage
        # or MergerPage get automatically deleted on closing.
        self.page_log.is_hidden = True

        sizer.Add(notebook, proportion=1, flag=wx.GROW | wx.RIGHT | wx.BOTTOM)
        self.create_menu()

        self.dialog_selectfolder = wx.DirDialog(
            parent=self,
            message="Choose a directory where to search for Skype databases",
            defaultPath=os.getcwd(),
            style=wx.DD_DIR_MUST_EXIST | wx.RESIZE_BORDER)
        self.dialog_savefile = wx.FileDialog(
            parent=self, defaultDir=os.getcwd(), defaultFile="",
            style=wx.FD_SAVE | wx.RESIZE_BORDER)
        self.dialog_search = controls.EntryDialog(
            parent=self, title="Find in %s" % conf.Title, label="Search:",
            emptyvalue="Find in last database..",
            tooltip="Find in last database..")
        self.dialog_search.Bind(wx.EVT_COMMAND_ENTER, self.on_tray_search)
        if conf.SearchHistory and conf.SearchHistory[-1:] != [""]:
            self.dialog_search.Value = conf.SearchHistory[-1]
        self.dialog_search.SetChoices(list(filter(None, conf.SearchHistory)))
        self.dialog_search.SetIcons(icons)

        self.skype_handler = SkypeHandler() if Skype4Py else None
        # Memory file system for showing images in wx.HtmlWindow
        self.memoryfs = {"files": {}, "handler": wx.MemoryFSHandler()}
        wx.FileSystem_AddHandler(self.memoryfs["handler"])
        abouticon = "skyperious.png" # Program icon shown in About window
        raw = base64.b64decode(images.Icon48x48_32bit.data)
        self.memoryfs["handler"].AddFile(abouticon, raw, wx.BITMAP_TYPE_PNG)
        self.memoryfs["files"][abouticon] = 1
        # Screenshots look better with colouring if system has off-white colour
        tint_colour = wx.NamedColour(conf.BgColour)
        tint_factor = [((4 * x) % 256) / 255. for x in tint_colour]
        # Images shown on the default search content page
        for name in ["Search", "Chats", "Info", "Tables", "SQL", "Contacts"]:
            bmp = getattr(images, "Help" + name, None)
            if not bmp: continue # Continue for name in [..]
            bmp = bmp.Image.AdjustChannels(*tint_factor)
            raw = util.wx_bitmap_to_raw(bmp)
            filename = "Help%s.png" % name
            self.memoryfs["handler"].AddFile(filename, raw, wx.BITMAP_TYPE_PNG)
            self.memoryfs["files"][filename] = 1

        self.worker_detection = \
            workers.DetectDatabaseThread(self.on_detect_databases_callback)
        self.Bind(EVT_DETECTION_WORKER, self.on_detect_databases_result)
        self.Bind(EVT_OPEN_DATABASE, self.on_open_database_event)

        self.Bind(wx.EVT_CLOSE, self.on_exit)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOVE, self.on_move)
        notebook.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.on_change_page)
        notebook.Bind(wx.lib.agw.flatnotebook.EVT_FLATNOTEBOOK_PAGE_CLOSING,
                      self.on_close_page)
        # Register Ctrl-F4 and Ctrl-W close handlers
        id_close = wx.NewId()
        def on_close_hotkey(event):
            notebook and notebook.DeletePage(notebook.GetSelection())
        notebook.SetAcceleratorTable(wx.AcceleratorTable([
            (wx.ACCEL_CTRL, k, id_close) for k in (ord('W'), wx.WXK_F4)]))
        notebook.Bind(wx.EVT_MENU, on_close_hotkey, id=id_close)


        class FileDrop(wx.FileDropTarget):
            """A simple file drag-and-drop handler for application window."""
            def __init__(self, window):
                wx.FileDropTarget.__init__(self)
                self.window = window

            def OnDropFiles(self, x, y, filenames):
                # CallAfter to allow UI to clear up the dragged icons
                wx.CallAfter(self.ProcessFiles, filenames)

            def ProcessFiles(self, filenames):
                for filename in filenames:
                    self.window.update_database_list(filename)
                for filename in filenames:
                    self.window.load_database_page(filename)

        self.DropTarget = FileDrop(self)
        self.notebook.DropTarget = FileDrop(self)

        self.MinSize = conf.MinWindowSize
        if conf.WindowPosition and conf.WindowSize:
            if [-1, -1] != conf.WindowSize:
                self.Size = conf.WindowSize
                if not conf.WindowIconized:
                    self.Position = conf.WindowPosition
            else:
                self.Maximize()
        else:
            self.Center(wx.HORIZONTAL)
            self.Position.top = 50
        if self.list_db.GetItemCount() > 1:
            self.list_db.SetFocus()
        else:
            self.button_detect.SetFocus()

        self.trayicon = wx.TaskBarIcon()
        if conf.TrayIconEnabled:
            self.trayicon.SetIcon(self.TRAY_ICON.Icon, conf.Title)
        self.trayicon.Bind(wx.EVT_TASKBAR_LEFT_DCLICK, self.on_toggle_iconize)
        self.trayicon.Bind(wx.EVT_TASKBAR_LEFT_DOWN, self.on_open_tray_search)
        self.trayicon.Bind(wx.EVT_TASKBAR_RIGHT_DOWN, self.on_open_tray_menu)

        if conf.WindowIconized:
            conf.WindowIconized = False
            wx.CallAfter(self.on_toggle_iconize)
        else:
            self.Show(True)
        wx.CallLater(20000, self.update_check)


    def init_colours(self):
        """Update configuration colours with current system theme values."""
        colourhex = lambda index: (wx.SystemSettings.GetColour(index)
                                   .GetAsString(wx.C2S_HTML_SYNTAX))
        conf.FgColour = colourhex(wx.SYS_COLOUR_BTNTEXT)
        conf.BgColour = colourhex(wx.SYS_COLOUR_WINDOW)
        conf.DisabledColour = colourhex(wx.SYS_COLOUR_GRAYTEXT)
        conf.WidgetColour = colourhex(wx.SYS_COLOUR_BTNFACE)
        if "#FFFFFF" != conf.BgColour: # Potential default colour mismatch
            conf.DBListForegroundColour = conf.FgColour
            conf.DBListBackgroundColour = conf.BgColour
            conf.LinkColour = colourhex(wx.SYS_COLOUR_HOTLIGHT)
            conf.SkypeLinkColour = colourhex(wx.SYS_COLOUR_HOTLIGHT)
            conf.ListOpenedBgColour = colourhex(wx.SYS_COLOUR_INFOBK)
            conf.DBTableOpenedColour = colourhex(wx.SYS_COLOUR_INFOBK)
            conf.MainBgColour = conf.WidgetColour
            conf.MessageTextColour = conf.FgColour
            conf.HelpCodeColour = colourhex(wx.SYS_COLOUR_HIGHLIGHT)
            conf.HelpBorderColour = colourhex(wx.SYS_COLOUR_ACTIVEBORDER)
            conf.MergeHtmlBackgroundColour = conf.BgColour

            # Hack: monkey-patch FlatImageBook with non-hardcoded background
            class HackContainer(wx.lib.agw.labelbook.ImageContainer):
                BRUSH1, BRUSH2 = wx.WHITE_BRUSH, wx.Brush(conf.BgColour)
                def OnPaint(self, event):
                    wx.WHITE_BRUSH = HackContainer.BRUSH2
                    try: result = HackContainer.__base__.OnPaint(self, event)
                    finally: wx.WHITE_BRUSH = HackContainer.BRUSH1
                    return result
            wx.lib.agw.labelbook.ImageContainer = HackContainer


    def update_check(self):
        """
        Checks for an updated Skyperious version if sufficient time
        from last check has passed, and opens a dialog for upgrading
        if new version available. Schedules a new check on due date.
        """
        if not conf.UpdateCheckAutomatic: 
            return
        interval = datetime.timedelta(days=conf.UpdateCheckInterval)
        due_date = datetime.datetime.now() - interval
        if not (conf.WindowIconized or support.update_window) \
        and conf.LastUpdateCheck < due_date.strftime("%Y%m%d"):
            callback = lambda resp: self.on_check_update_callback(resp, False)
            support.check_newest_version(callback)
        elif not support.update_window:
            try:
                dt = datetime.datetime.strptime(conf.LastUpdateCheck, "%Y%m%d")
                interval = (dt + interval) - datetime.datetime.now()
            except (TypeError, ValueError):
                pass
        # Schedule a check for due date, should the program run that long.
        wx.CallLater(util.timedelta_seconds(interval) * 1000, self.update_check)


    def on_tray_search(self, event):
        """Handler for searching from tray dialog, launches search."""
        if self.dialog_search.Value.strip():
            self.dialog_search.Hide()
            if self.IsIconized() and not self.Shown:
                self.on_toggle_iconize()
            else:
                self.Iconize(False), self.Show(), self.Raise()
            page = self.page_db_latest
            if not page:
                if self.db_filename: # Load database focused in dblist
                    page = self.load_database_page(self.db_filename)
                elif self.dbs: # Load an open database
                    page = self.load_database_page(list(self.dbs)[0])
                elif conf.RecentFiles:
                    page = self.load_database_page(conf.RecentFiles[0])
            if page:
                page.edit_searchall.Value = self.dialog_search.Value
                page.on_searchall(None)
                for i in range(self.notebook.GetPageCount()):
                    if self.notebook.GetPage(i) == page:
                        if self.notebook.GetSelection() != i:
                            self.notebook.SetSelection(i)
                            self.update_notebook_header()
                        break # break for i in range(self.notebook.GetPage..
            else:
                wx.MessageBox("No database to search from.", conf.Title)


    def on_toggle_iconize(self, event=None):
        """Handler for toggling main window to tray and back."""
        self.dialog_search.Hide()
        conf.WindowIconized = not conf.WindowIconized
        if conf.WindowIconized:
            self.Iconize(), self.Hide()
            conf.WindowPosition = self.Position[:]
            if not conf.TrayIconEnabled:
                conf.TrayIconEnabled = True
                self.trayicon.SetIcon(self.TRAY_ICON.Icon, conf.Title)
        else:
            self.Iconize(False), self.Show(), self.Raise()


    def on_toggle_trayicon(self, event=None):
        """
        Handler for toggling tray icon, removes or adds it to the tray area.

        @param   event  if not given or false, tray icon is toggled on
        """
        conf.TrayIconEnabled = event.IsChecked() if event else True
        self.menu_tray.Check(conf.TrayIconEnabled)
        if conf.TrayIconEnabled:
            self.trayicon.SetIcon(self.TRAY_ICON.Icon, conf.Title)
        else:
            self.trayicon.RemoveIcon()
        if conf.WindowIconized:
            self.on_toggle_iconize()


    def on_open_tray_search(self, event):
        """Opens the search entry dialog."""
        self.dialog_search.Show(not self.dialog_search.Shown)


    def on_open_tray_menu(self, event):
        """Creates and opens a popup menu for the tray icon."""
        menu = wx.Menu()
        item_search = wx.MenuItem(menu, -1, "&Search for..")
        font = item_search.Font
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        font.SetFaceName(self.Font.FaceName)
        font.SetPointSize(self.Font.PointSize)
        item_search.Font = font
        label = ["Minimize to", "Restore from"][conf.WindowIconized] + " &tray"
        item_toggle = wx.MenuItem(menu, -1, label)
        item_icon = wx.MenuItem(menu, -1, kind=wx.ITEM_CHECK,
                                text="Show &icon in notification area")
        item_console = wx.MenuItem(menu, -1, kind=wx.ITEM_CHECK,
                                   text="Show Python &console")
        item_exit = wx.MenuItem(menu, -1, "E&xit %s" % conf.Title)

        menu.AppendItem(item_search)
        menu.AppendItem(item_toggle)
        menu.AppendSeparator()
        menu.AppendItem(item_icon)
        menu.AppendItem(item_console)
        menu.AppendSeparator()
        menu.AppendItem(item_exit)
        item_icon.Check(True)
        item_console.Check(self.frame_console.Shown)

        menu.Bind(wx.EVT_MENU, self.on_open_tray_search, id=item_search.GetId())
        menu.Bind(wx.EVT_MENU, self.on_toggle_iconize, id=item_toggle.GetId())
        menu.Bind(wx.EVT_MENU, self.on_toggle_trayicon, id=item_icon.GetId())
        menu.Bind(wx.EVT_MENU, self.on_showhide_console, id=item_console.GetId())
        menu.Bind(wx.EVT_MENU, self.on_exit, id=item_exit.GetId())
        self.trayicon.PopupMenu(menu)


    def on_change_page(self, event):
        """
        Handler for changing a page in the main Notebook, remembers the visit.
        """
        p = self.notebook.GetPage(self.notebook.GetSelection())
        if not self.pages_visited or self.pages_visited[-1] != p:
            self.pages_visited.append(p)
        self.update_notebook_header()
        if event: event.Skip() # Pass event along to next handler


    def on_size(self, event):
        """Handler for window size event, tweaks controls and saves size."""
        conf.WindowSize = [-1, -1] if self.IsMaximized() else self.Size[:]
        conf.save()
        event.Skip()
        l, p = self.list_db, self.panel_db_main.Parent # Right panel scroll
        fn = lambda: self and (p.Layout(), l.SetColumnWidth(0, l.Size[1] - 5))
        wx.CallAfter(fn)


    def on_move(self, event):
        """Handler for window move event, saves position."""
        conf.WindowPosition = event.Position[:]
        conf.save()
        event.Skip()


    def update_notebook_header(self):
        """
        Removes or adds X to notebook tab style, depending on whether current
        page can be closed.
        """
        if not self:
            return
        p = self.notebook.GetPage(self.notebook.GetSelection())
        style = self.notebook.GetAGWWindowStyleFlag()
        if isinstance(p, (DatabasePage, MergerPage)):
            if p.ready_to_close \
            and not (style & wx.lib.agw.flatnotebook.FNB_X_ON_TAB):
                style |= wx.lib.agw.flatnotebook.FNB_X_ON_TAB
            elif not p.ready_to_close \
            and (style & wx.lib.agw.flatnotebook.FNB_X_ON_TAB):
                style ^= wx.lib.agw.flatnotebook.FNB_X_ON_TAB
        elif self.page_log == p:
            style |= wx.lib.agw.flatnotebook.FNB_X_ON_TAB
        elif style & wx.lib.agw.flatnotebook.FNB_X_ON_TAB: # Hide close box
            style ^= wx.lib.agw.flatnotebook.FNB_X_ON_TAB  # on main page
        if style != self.notebook.GetAGWWindowStyleFlag():
            self.notebook.SetAGWWindowStyleFlag(style)


    def on_dragstop_list_db(self, event):
        """Handler for stopping drag in the database list, rearranges list."""
        start, stop = self.db_drag_start, max(1, event.GetIndex())
        if start and start != stop:
            filename = self.list_db.GetItemText(start)
            self.list_db.DeleteItem(start)
            idx = stop if start > stop else stop - 1
            self.list_db.InsertImageStringItem(idx, filename, [1])
            fgcolour = wx.NamedColour(conf.DBListForegroundColour)
            bgcolour = wx.NamedColour(conf.DBListBackgroundColour)
            self.list_db.SetItemBackgroundColour(idx, bgcolour)
            self.list_db.SetItemTextColour(idx, fgcolour)
            self.list_db.Select(idx)
        self.db_drag_start = None


    def on_dragstart_list_db(self, event):
        """Handler for dragging items in the database list, cancels dragging."""
        if event.GetIndex():
            self.db_drag_start = event.GetIndex()
        else:
            self.db_drag_start = None
            self.on_cancel_drag_list_db(event)


    def on_cancel_drag_list_db(self, event):
        """Handler for dragging items in the database list, cancels dragging."""
        class HackEvent(object): # UltimateListCtrl hack to cancel drag.
            def __init__(self, pos=wx.Point()): self._position = pos
            def GetPosition(self): return self._position
        try:
            wx.CallAfter(self.list_db.Children[0].DragFinish, HackEvent())
        except: raise


    def create_page_main(self, notebook):
        """Creates the main page with database list and buttons."""
        page = self.page_main = wx.Panel(notebook)
        page.BackgroundColour = conf.MainBgColour
        notebook.AddPage(page, "Databases")
        sizer = page.Sizer = wx.BoxSizer(wx.HORIZONTAL)

        agw_style = (wx.LC_REPORT | wx.LC_NO_HEADER |
                     wx.LC_SINGLE_SEL | wx.BORDER_NONE)
        if hasattr(wx.lib.agw.ultimatelistctrl, "ULC_USER_ROW_HEIGHT"):
            agw_style |= wx.lib.agw.ultimatelistctrl.ULC_USER_ROW_HEIGHT
        list_db = self.list_db = wx.lib.agw.ultimatelistctrl. \
            UltimateListCtrl(parent=page, agwStyle=agw_style)
        list_db.MinSize = 400, -1 # Maximize-restore would resize width to 100
        list_db.InsertColumn(0, "")
        il = wx.ImageList(*images.ButtonHome.Bitmap.Size)
        il.Add(images.ButtonHome.Bitmap)
        il.Add(images.ButtonListDatabase.Bitmap)
        list_db.AssignImageList(il, wx.IMAGE_LIST_SMALL)
        list_db.InsertImageStringItem(0, "Home", [0])
        list_db.TextColour = wx.NamedColour(conf.DBListForegroundColour)
        list_bgcolour = wx.NamedColour(conf.DBListBackgroundColour)
        list_db.BackgroundColour = list_bgcolour
        list_db.SetItemBackgroundColour(0, list_bgcolour)
        if hasattr(list_db, "SetUserLineHeight"):
            h = images.ButtonListDatabase.Bitmap.Size[1]
            list_db.SetUserLineHeight(int(h * 1.5))
        list_db.Select(0)

        panel_right = wx.lib.scrolledpanel.ScrolledPanel(page)
        panel_right.Sizer = wx.BoxSizer(wx.HORIZONTAL)

        panel_main = self.panel_db_main = wx.Panel(panel_right)
        panel_detail = self.panel_db_detail = wx.Panel(panel_right)
        panel_main.Sizer = wx.BoxSizer(wx.VERTICAL)
        panel_detail.Sizer = wx.BoxSizer(wx.VERTICAL)

        # Create main page label and buttons
        label_main = wx.StaticText(panel_main,
                                   label="Welcome to %s" % conf.Title)
        label_main.SetForegroundColour(conf.SkypeLinkColour)
        label_main.Font = wx.Font(14, wx.FONTFAMILY_SWISS,
            wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, face=self.Font.FaceName)
        BUTTONS_MAIN = [
            ("opena", "&Open a database..", images.ButtonOpenA, 
             "Choose a Skype database from your computer to open."),
            ("detect", "Detect databases", images.ButtonDetect,
             "Auto-detect Skype databases from user folders."),
            ("folder", "&Import from folder.", images.ButtonFolder,
             "Select a folder where to look for Skype SQLite databases "
             "(*.db files)."),
            ("missing", "Remove missing", images.ButtonRemoveMissing,
             "Remove non-existing files from the database list."),
            ("clear", "C&lear list", images.ButtonClear,
             "Clear the current database list."), ]
        for name, label, img, note in BUTTONS_MAIN:
            button = controls.NoteButton(panel_main, label, note, img.Bitmap)
            setattr(self, "button_" + name, button)
            exec("button_%s = self.button_%s" % (name, name)) in {}, locals()
        button_missing.Hide(); button_clear.Hide()

        # Create detail page labels, values and buttons
        label_db = self.label_db = wx.TextCtrl(parent=panel_detail, value="",
            style=wx.NO_BORDER | wx.TE_MULTILINE | wx.TE_RICH)
        label_db.Font = wx.Font(12, wx.FONTFAMILY_SWISS,
            wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, face=self.Font.FaceName)
        label_db.BackgroundColour = panel_detail.BackgroundColour
        label_db.SetEditable(False)

        sizer_labels = wx.FlexGridSizer(cols=2, vgap=3, hgap=10)
        LABELS = [("path", "Location"), ("size", "Size"),
                  ("modified", "Last modified"), ("account", "Skype user"),
                  ("chats", "Conversations"), ("messages", "Messages")]
        for field, title in LABELS:
            lbltext = wx.StaticText(parent=panel_detail, label="%s:" % title)
            valtext = wx.TextCtrl(parent=panel_detail, value="",
                                  size=(300, -1), style=wx.NO_BORDER)
            valtext.BackgroundColour = panel_detail.BackgroundColour
            valtext.SetEditable(False)
            lbltext.ForegroundColour = conf.DisabledColour
            sizer_labels.Add(lbltext, border=5, flag=wx.LEFT)
            sizer_labels.Add(valtext, proportion=1, flag=wx.GROW)
            setattr(self, "label_" + field, valtext)

        BUTTONS_DETAIL = [
            ("open", "&Open", images.ButtonOpen, 
             "Open the database for searching and exploring."),
            ("compare", "Compare and &merge", images.ButtonCompare,
             "Choose another database to compare with, in order to merge "
             "their differences."),
            ("export", "&Export messages", images.ButtonExport,
             "Export all conversations from the database as "
             "HTML, text or spreadsheet."),
            ("saveas", "Save &as..", images.ButtonSaveAs,
             "Save a copy of the database under another name."),
            ("remove", "Remove", images.ButtonRemove,
             "Remove this database from the list."), ]
        for name, label, img, note in BUTTONS_DETAIL:
            button = controls.NoteButton(panel_detail, label, note, img.Bitmap)
            setattr(self, "button_" + name, button)
            exec("button_%s = self.button_%s" % (name, name)) # Hack local name

        for c in list(panel_main.Children) + list(panel_detail.Children) + \
        [panel_main, panel_detail]:
           c.BackgroundColour = page.BackgroundColour 
        panel_right.SetupScrolling(scroll_x=False)
        panel_detail.Hide()

        list_db.Bind(wx.EVT_LIST_ITEM_SELECTED,  self.on_select_list_db)
        list_db.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_open_from_list_db)
        list_db.Bind(wx.EVT_CHAR_HOOK,           self.on_list_db_key)
        list_db.Bind(wx.lib.agw.ultimatelistctrl.EVT_LIST_BEGIN_DRAG,
                     self.on_dragstart_list_db)
        list_db.Bind(wx.lib.agw.ultimatelistctrl.EVT_LIST_END_DRAG,
                     self.on_dragstop_list_db)
        list_db.Bind(wx.lib.agw.ultimatelistctrl.EVT_LIST_BEGIN_RDRAG,
                     self.on_cancel_drag_list_db)
        button_opena.Bind(wx.EVT_BUTTON,         self.on_open_database)
        button_detect.Bind(wx.EVT_BUTTON,        self.on_detect_databases)
        button_folder.Bind(wx.EVT_BUTTON,        self.on_add_from_folder)
        button_missing.Bind(wx.EVT_BUTTON,       self.on_remove_missing)
        button_clear.Bind(wx.EVT_BUTTON,         self.on_clear_databases)
        button_open.Bind(wx.EVT_BUTTON,          self.on_open_current_database)
        button_compare.Bind(wx.EVT_BUTTON,       self.on_compare_databases)
        button_export.Bind(wx.EVT_BUTTON,        self.on_export_database_menu)
        button_saveas.Bind(wx.EVT_BUTTON,        self.on_save_database_as)
        button_remove.Bind(wx.EVT_BUTTON,        self.on_remove_database)

        panel_main.Sizer.Add(label_main, border=10, flag=wx.ALL)
        panel_main.Sizer.Add((0, 10))
        panel_main.Sizer.Add(button_opena, flag=wx.GROW)
        panel_main.Sizer.Add(button_detect, flag=wx.GROW)
        panel_main.Sizer.Add(button_folder, flag=wx.GROW)
        panel_main.Sizer.AddStretchSpacer()
        panel_main.Sizer.Add(button_missing, flag=wx.GROW)
        panel_main.Sizer.Add(button_clear, flag=wx.GROW)
        panel_detail.Sizer.Add(label_db, border=10, flag=wx.ALL | wx.GROW)
        panel_detail.Sizer.Add(sizer_labels, border=10, flag=wx.ALL | wx.GROW)
        panel_detail.Sizer.Add((0, 10))
        panel_detail.Sizer.Add(button_open, flag=wx.GROW)
        panel_detail.Sizer.Add(button_compare, flag=wx.GROW)
        panel_detail.Sizer.Add(button_export, flag=wx.GROW)
        panel_detail.Sizer.AddStretchSpacer()
        panel_detail.Sizer.Add(button_saveas, flag=wx.GROW)
        panel_detail.Sizer.Add(button_remove, flag=wx.GROW)
        panel_right.Sizer.Add(panel_main, proportion=1, flag=wx.GROW)
        panel_right.Sizer.Add(panel_detail, proportion=1, flag=wx.GROW)
        sizer.Add(list_db, border=10, proportion=6, flag=wx.ALL | wx.GROW)
        sizer.Add(panel_right, border=10, proportion=4, flag=wx.ALL | wx.GROW)
        for filename in conf.DBFiles:
            self.update_database_list(filename)


    def create_menu(self):
        """Creates the program menu."""
        menu = wx.MenuBar()
        self.SetMenuBar(menu)

        menu_file = wx.Menu()
        menu.Append(menu_file, "&File")

        menu_open_database = self.menu_open_database = menu_file.Append(
            id=wx.NewId(), text="&Open database...\tCtrl-O",
            help="Choose a Skype database file to open."
        )
        menu_recent = self.menu_recent = wx.Menu()
        menu_file.AppendMenu(id=wx.NewId(), text="&Recent databases",
            submenu=menu_recent, help="Recently opened databases.")
        menu_file.AppendSeparator()
        menu_options = self.menu_options = \
            menu_file.Append(id=wx.NewId(), text="&Advanced options",
                help="Edit advanced program options")
        menu_iconize = self.menu_iconize = \
            menu_file.Append(id=wx.NewId(), text="Minimize to &tray",
                help="Minimize %s window to notification area" % conf.Title)
        menu_exit = self.menu_exit = \
            menu_file.Append(id=wx.NewId(), text="E&xit\tAlt-X", help="Exit")

        menu_help = wx.Menu()
        menu.Append(menu_help, "&Help")

        menu_update = self.menu_update = menu_help.Append(id=wx.NewId(),
            text="Check for &updates",
            help="Check whether a new version of %s is available" % conf.Title)
        menu_feedback = self.menu_feedback = menu_help.Append(id=wx.NewId(),
            text="Send &feedback",
            help="Send feedback or report a problem to program author")
        menu_homepage = self.menu_homepage = menu_help.Append(id=wx.NewId(),
            text="Go to &homepage",
            help="Open the %s homepage, %s" % (conf.Title, conf.HomeUrl))
        menu_help.AppendSeparator()
        menu_log = self.menu_log = menu_help.Append(id=wx.NewId(),
            kind=wx.ITEM_CHECK, text="Show &log window",
            help="Show/hide the log messages window")
        menu_console = self.menu_console = menu_help.Append(id=wx.NewId(),
            kind=wx.ITEM_CHECK, text="Show Python &console\tCtrl-E",
            help="Show/hide a Python shell environment window")
        menu_help.AppendSeparator()
        menu_tray = self.menu_tray = menu_help.Append(id=wx.NewId(),
            kind=wx.ITEM_CHECK, text="Display &icon in notification area",
            help="Show/hide %s icon in system tray" % conf.Title)
        menu_autoupdate_check = self.menu_autoupdate_check = menu_help.Append(
            id=wx.NewId(), kind=wx.ITEM_CHECK,
            text="Automatic up&date check",
            help="Automatically check for program updates periodically")
        menu_error_reporting = self.menu_error_reporting = menu_help.Append(
            id=wx.NewId(), kind=wx.ITEM_CHECK,
            text="Automatic &error reporting",
            help="Automatically report software errors to program author")
        menu_help.AppendSeparator()
        menu_about = self.menu_about = menu_help.Append(
            id=wx.NewId(), text="&About %s" % conf.Title,
            help="Show program information and copyright")

        self.history_file = wx.FileHistory(conf.MaxRecentFiles)
        self.history_file.UseMenu(menu_recent)
        # Reverse list, as FileHistory works like a stack
        [self.history_file.AddFileToHistory(f) for f in conf.RecentFiles[::-1]]
        wx.EVT_MENU_RANGE(self, wx.ID_FILE1, wx.ID_FILE1 + conf.MaxRecentFiles,
                          self.on_recent_file)
        menu_tray.Check(conf.TrayIconEnabled)
        menu_autoupdate_check.Check(conf.UpdateCheckAutomatic)
        menu_error_reporting.Check(conf.ErrorReportsAutomatic)

        self.Bind(wx.EVT_MENU, self.on_open_database, menu_open_database)
        self.Bind(wx.EVT_MENU, self.on_open_options, menu_options)
        self.Bind(wx.EVT_MENU, self.on_exit, menu_exit)
        self.Bind(wx.EVT_MENU, self.on_toggle_iconize, menu_iconize)
        self.Bind(wx.EVT_MENU, self.on_check_update, menu_update)
        self.Bind(wx.EVT_MENU, self.on_open_feedback, menu_feedback)
        self.Bind(wx.EVT_MENU, self.on_menu_homepage, menu_homepage)
        self.Bind(wx.EVT_MENU, self.on_showhide_log, menu_log)
        self.Bind(wx.EVT_MENU, self.on_showhide_console, menu_console)
        self.Bind(wx.EVT_MENU, self.on_toggle_trayicon, menu_tray)
        self.Bind(wx.EVT_MENU, self.on_toggle_autoupdate_check,
                  menu_autoupdate_check)
        self.Bind(wx.EVT_MENU, self.on_toggle_error_reporting,
                  menu_error_reporting)
        self.Bind(wx.EVT_MENU, self.on_about, menu_about)


    def on_toggle_error_reporting(self, event):
        """Handler for toggling automatic error reporting, changes conf."""
        conf.ErrorReportsAutomatic = event.IsChecked()
        conf.save()


    def on_toggle_autoupdate_check(self, event):
        """Handler for toggling automatic update checking, changes conf."""
        conf.UpdateCheckAutomatic = event.IsChecked()
        conf.save()


    def on_list_db_key(self, event):
        """
        Handler for pressing a key in dblist, loads selected database on Enter
        and removes from list on Delete.
        """
        if self.list_db.GetFirstSelected() > 0 and not event.AltDown() \
        and event.KeyCode in [wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER]:
            self.load_database_page(self.db_filename)
        elif event.KeyCode in [wx.WXK_DELETE] and self.db_filename:
            self.on_remove_database(None)
        event.Skip()


    def on_open_feedback(self, event):
        """Handler for clicking to send feedback, opens the feedback form."""
        if support.feedback_window:
            if not support.feedback_window.Shown:
                support.feedback_window.Show()
            support.feedback_window.Raise()
        else:
            support.feedback_window = support.FeedbackDialog(self)


    def on_menu_homepage(self, event):
        """Handler for opening Skyperious webpage from menu,"""
        webbrowser.open(conf.HomeUrl)


    def on_about(self, event):
        """
        Handler for clicking "About Skyperious" menu, opens a small info frame.
        """
        text = step.Template(templates.ABOUT_TEXT).expand()
        AboutDialog(self, text).ShowModal()


    def on_check_update(self, event):
        """
        Handler for checking for updates, starts a background process for
        checking for and downloading the newest version.
        """
        if not support.update_window:
            main.status("Checking for new version of %s.", conf.Title)
            wx.CallAfter(support.check_newest_version,
                         self.on_check_update_callback)
        elif hasattr(support.update_window, "Raise"):
            support.update_window.Raise()


    def on_check_update_callback(self, check_result, full_response=True):
        """
        Callback function for processing update check result, offers new
        version for download if available.

        @param   full_response  if False, show message only if update available
        """
        if not self:
            return
        support.update_window = True
        main.status("")
        if check_result:
            version, url, changes = check_result
            MAX = 1000
            changes = changes[:MAX] + ".." if len(changes) > MAX else changes
            main.status_flash("New %s version %s available.",
                              conf.Title, version)
            if wx.OK == wx.MessageBox(
                "Newer version (%s) available. You are currently on "
                "version %s.%s\nDownload and install %s %s?" %
                (version, conf.Version, "\n\n%s\n" % changes,
                 conf.Title, version),
                "Update information", wx.OK | wx.CANCEL | wx.ICON_INFORMATION
            ):
                wx.CallAfter(support.download_and_install, url)
        elif full_response and check_result is not None:
            wx.MessageBox("You are using the latest version of %s, %s.\n\n " %
                (conf.Title, conf.Version), "Update information",
                wx.OK | wx.ICON_INFORMATION)
        elif full_response:
            wx.MessageBox("Could not contact download server.",
                          "Update information", wx.OK | wx.ICON_WARNING)
        if check_result is not None:
            conf.LastUpdateCheck = datetime.date.today().strftime("%Y%m%d")
            conf.save()
        support.update_window = None


    def on_detect_databases(self, event):
        """
        Handler for clicking to auto-detect Skype databases, starts the
        detection in a background thread.
        """
        if self.button_detect.FindFocus() == self.button_detect:
            self.list_db.SetFocus()
        main.logstatus("Searching local computer for Skype databases..")
        self.button_detect.Enabled = False
        self.worker_detection.work(True)


    def on_detect_databases_callback(self, result):
        """Callback for DetectDatabaseThread, posts the data to self."""
        if self: # Check if instance is still valid (i.e. not destroyed by wx)
            wx.PostEvent(self, DetectionWorkerEvent(result=result))


    def on_detect_databases_result(self, event):
        """
        Handler for getting results from database detection thread, adds the
        results to the database list.
        """
        result = event.result
        if "filenames" in result:
            for f in result["filenames"]:
                if self.update_database_list(f):
                    main.log("Detected Skype database %s.", f)
        if "count" in result:
            main.logstatus_flash("Detected %d%s Skype database%s.",
                result["count"],
                " additional" if not (result["count"]) else "",
                "" if result["count"] == 1 else "s"
            )
        if result.get("done", False):
            self.button_detect.Enabled = True
            wx.Bell()


    def update_database_list(self, filename=""):
        """
        Inserts the database into the list, if not there already, and updates
        UI buttons.

        @param   filename  possibly new filename, if any
        @return            True if was file was new or changed, False otherwise
        """
        result, count_initial = False, self.list_db.GetItemCount() - 1
        # Insert into database lists, if not already there
        if filename:
            filename = util.to_unicode(filename)
            if filename not in conf.DBFiles:
                conf.DBFiles.append(filename)
                conf.save()
            data = collections.defaultdict(lambda: None)
            if os.path.exists(filename):
                data["size"] = os.path.getsize(filename)
                data["last_modified"] = datetime.datetime.fromtimestamp(
                                        os.path.getmtime(filename))
            data_old = self.db_filenames.get(filename)
            if not data_old or data_old["size"] != data["size"] \
            or data_old["last_modified"] != data["last_modified"]:
                if filename not in self.db_filenames:
                    self.db_filenames[filename] = data
                    idx = self.list_db.GetItemCount()
                    self.list_db.InsertImageStringItem(idx, filename, [1])
                    fgcolour = wx.NamedColour(conf.DBListForegroundColour)
                    bgcolour = wx.NamedColour(conf.DBListBackgroundColour)
                    self.list_db.SetItemBackgroundColour(idx, bgcolour)
                    self.list_db.SetItemTextColour(idx, fgcolour)
                    # self is not shown: form creation time, reselect last file
                    if not self.Shown and filename in conf.LastSelectedFiles:
                        self.list_db.Select(idx)
                        def scroll_to_selected():
                            if idx < self.list_db.GetCountPerPage(): return
                            lh = self.list_db.GetUserLineHeight()
                            dy = (idx - self.list_db.GetCountPerPage() / 2) * lh
                            self.list_db.ScrollList(0, dy)
                        wx.CallAfter(lambda: self and scroll_to_selected())
                    result = True

        self.button_missing.Shown = (self.list_db.GetItemCount() > 1)
        self.button_clear.Shown = (self.list_db.GetItemCount() > 1)
        if self.Shown:
            self.list_db.SetColumnWidth(0, self.list_db.Size.width - 5)
        return result


    def on_clear_databases(self, event):
        """Handler for clicking to clear the database list."""
        if (self.list_db.GetItemCount() > 1) and wx.OK == wx.MessageBox(
            "Are you sure you want to clear the list of all databases?",
            conf.Title, wx.OK | wx.CANCEL | wx.ICON_QUESTION
        ):
            while self.list_db.GetItemCount() > 1:
                self.list_db.DeleteItem(1)
            del conf.DBFiles[:]
            del conf.LastSelectedFiles[:]
            del conf.RecentFiles[:]
            conf.LastSearchResults.clear()
            while self.history_file.Count:
                self.history_file.RemoveFileFromHistory(0)
            self.db_filenames.clear()
            conf.save()
            self.update_database_list()


    def on_save_database_as(self, event):
        """Handler for clicking to save a copy of a database in the list."""
        original = self.db_filename
        if not os.path.exists(original):
            wx.MessageBox(
                "The file \"%s\" does not exist on this computer." % original,
                conf.Title, wx.OK | wx.ICON_INFORMATION
            )
            return

        dialog = wx.FileDialog(parent=self, message="Save a copy..",
            defaultDir=os.path.split(original)[0],
            defaultFile=os.path.basename(original),
            style=wx.FD_OVERWRITE_PROMPT | wx.FD_SAVE | wx.RESIZE_BORDER
        )
        if wx.ID_OK == dialog.ShowModal():
            wx.YieldIfNeeded() # Allow UI to refresh
            newpath = dialog.GetPath()
            success = False
            try:
                shutil.copyfile(original, newpath)
                success = True
            except Exception as e:
                main.log("%s when trying to copy %s to %s.",
                         e, original, newpath)
                if self.skype_handler and self.skype_handler.is_running():
                    response = wx.MessageBox(
                        "Could not save a copy of \"%s\" as \"%s\".\n\n"
                        "Probably because Skype is running. "
                        "Close Skype and try again?" % (original, newpath),
                        conf.Title, wx.OK | wx.CANCEL | wx.ICON_WARNING)
                    if wx.OK == response:
                        self.skype_handler.shutdown()
                        func = lambda: shutil.copyfile(original, newpath)
                        success, _ = util.try_until(func, count=3)
                        if not success:
                            wx.MessageBox(
                                "Still could not copy \"%s\" to \"%s\"." %
                                (original, newpath), conf.Title,
                                wx.OK | wx.ICON_WARNING)
                else:
                    wx.MessageBox("Failed to copy \"%s\" to \"%s\"." %
                                  (original, newpath), conf.Title,
                                  wx.OK | wx.ICON_WARNING)
            if success:
                main.logstatus_flash("Saved a copy of %s as %s.",
                                     original, newpath)
                self.update_database_list(newpath)


    def on_remove_database(self, event):
        """Handler for clicking to remove an item from the database list."""
        filename = self.db_filename
        if filename and wx.OK == wx.MessageBox(
            "Remove %s from database list?" % filename,
            conf.Title, wx.OK | wx.CANCEL | wx.ICON_QUESTION
        ):
            if filename in conf.DBFiles:
                conf.DBFiles.remove(filename)
            if filename in conf.LastSelectedFiles:
                conf.LastSelectedFiles.remove(filename)
            if filename in conf.LastSearchResults:
                del conf.LastSearchResults[filename]
            if filename in self.db_filenames:
                del self.db_filenames[filename]
            for i in range(self.list_db.GetItemCount()):
                if self.list_db.GetItemText(i) == filename:
                    self.list_db.DeleteItem(i)
                    break # break for i in range(self.list_db..
            # Remove from recent file history
            historyfiles = [(i, self.history_file.GetHistoryFile(i))
                            for i in range(self.history_file.Count)]
            for i in [i for i, f in historyfiles if f == filename]:
                self.history_file.RemoveFileFromHistory(i)
            self.db_filename = None
            self.list_db.Select(0)
            self.update_database_list()
            conf.save()


    def on_remove_missing(self, event):
        """Handler to remove nonexistent files from the database list."""
        selecteds = range(1, self.list_db.GetItemCount())
        filter_func = lambda i: not os.path.exists(self.list_db.GetItemText(i))
        selecteds = list(filter(filter_func, selecteds))
        filenames = list(map(self.list_db.GetItemText, selecteds))
        for i in range(len(selecteds)):
            # - i, as item count is getting smaller one by one
            selected = selecteds[i] - i
            filename = self.list_db.GetItemText(selected)
            if filename in conf.DBFiles:
                conf.DBFiles.remove(filename)
            if filename in conf.LastSelectedFiles:
                conf.LastSelectedFiles.remove(filename)
            if filename in self.db_filenames:
                del self.db_filenames[filename]
            self.list_db.DeleteItem(selected)
        # Remove from recent file history
        historyfiles = [(i, self.history_file.GetHistoryFile(i))
                        for i in range(self.history_file.Count)]
        for i, f in historyfiles[::-1]: # Work upwards to have unchanged index
            if f in filenames: self.history_file.RemoveFileFromHistory(i)
        conf.save()
        self.update_database_list()


    def on_showhide_log(self, event):
        """Handler for clicking to show/hide the log window."""
        if self.notebook.GetPageIndex(self.page_log) < 0:
            self.notebook.AddPage(self.page_log, "Log")
            self.page_log.is_hidden = False
            self.page_log.Show()
            self.notebook.SetSelection(self.notebook.GetPageCount() - 1)
            self.on_change_page(None)
        else:
            self.page_log.is_hidden = True
            self.notebook.RemovePage(self.notebook.GetPageIndex(self.page_log))
        self.menu_log.Check(not self.page_log.is_hidden)


    def on_export_database_menu(self, event):
        if not export.xlsxwriter:
            return self.on_export_database(None)

        menu = wx.lib.agw.flatmenu.FlatMenu()
        item_sel = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
               "Export into separate files in one folder "
               "(HTML, text, Excel, or CSV)")
        menu.AppendItem(item_sel)
        item_all = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
               "Export into a single Excel workbook, with separate sheets")
        menu.AppendItem(item_all)
        for item in menu.GetMenuItems():
            self.Bind(wx.EVT_MENU, self.on_export_database, item)

        sz_btn, pt_btn = event.EventObject.Size, event.EventObject.Position
        pt_btn = event.EventObject.Parent.ClientToScreen(pt_btn)
        menu.SetOwnerHeight(sz_btn.y)
        if menu.Size.width < sz_btn.width:
            menu.Size = sz_btn.width, menu.Size.height
        menu.Popup(pt_btn, self)


    def on_export_database(self, event):
        """
        Handler for clicking to export a whole database, lets the user
        specify a directory where to save chat files and exports all chats.
        """
        do_singlefile = False
        if event:
            nitems = enumerate(event.EventObject.GetMenuItems())
            index = next((i for i, m in nitems if m.GetId() == event.Id), None)
            do_singlefile = index > 0

        focused_control = self.FindFocus()
        self.button_export.Enabled = False
        self.dialog_savefile.Message = "Choose folder where to save chat files"
        self.dialog_savefile.Filename = "Filename will be ignored"
        self.dialog_savefile.Wildcard = export.CHAT_WILDCARD
        self.dialog_savefile.WindowStyle ^= wx.FD_OVERWRITE_PROMPT
        if do_singlefile:
            db = self.load_database(self.db_filename)
            formatargs = collections.defaultdict(str)
            formatargs["skypename"] = os.path.basename(self.db_filename)
            if db and db.account: formatargs.update(db.account)
            default = util.safe_filename(conf.ExportDbTemplate % formatargs)
            self.dialog_savefile.Filename = default
            self.dialog_savefile.Message = "Save chats file"
            self.dialog_savefile.Wildcard = export.CHAT_WILDCARD_SINGLEFILE
            self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT

        if wx.ID_OK == self.dialog_savefile.ShowModal():
            db, files, count, error, errormsg = None, [], 0, False, None

            db = self.load_database(self.db_filename)
            dirname = os.path.dirname(self.dialog_savefile.GetPath())
            if not db:
                error = True
            elif "conversations" not in db.tables:
                error = True
                errormsg = "Cannot export %s. Not a valid Skype database?" % db
            if not error and not do_singlefile:
                extname = export.CHAT_EXTS[self.dialog_savefile.FilterIndex]
                format = extname
                formatargs = collections.defaultdict(str)
                formatargs["skypename"] = os.path.basename(self.db_filename)
                if db.account: formatargs.update(db.account)
                folder = util.safe_filename(conf.ExportDbTemplate % formatargs)
                export_dir = util.unique_path(os.path.join(dirname, folder))
                try:
                    os.mkdir(export_dir)
                except Exception:
                    errormsg = "Failed to create directory %s:\n\n%s" % \
                               (export_dir, traceback.format_exc())
                    error = True
            elif not error:
                index = self.dialog_savefile.FilterIndex
                extname = export.CHAT_EXTS_SINGLEFILE[index]
                format = os.path.basename(self.dialog_savefile.GetPath())
                export_dir = dirname


            if not error:
                chats = db.get_conversations()
                busy = controls.BusyPanel(
                    self, "Exporting all %s from \"%s\"\nas %s\nunder %s." %
                    (util.plural("chat", chats), db.filename,
                    extname.upper(), export_dir))
                wx.SafeYield() # Allow UI to refresh
                if not db.has_consumers():
                    db.get_conversations_stats(chats)
                try:
                    progressfunc = lambda *args: wx.SafeYield()
                    result = export.export_chats(chats, export_dir, format, db,
                                                 progress=progressfunc)
                    files, count = result
                except Exception:
                    errormsg = "Error exporting chats:\n\n%s" % \
                               traceback.format_exc()
                    error = True
                busy.Close()
            if not error:
                main.logstatus_flash("Exported %s from %s as %s "
                    "under %s.", util.plural("chat", count), db.filename,
                    extname.upper(), export_dir)
            elif errormsg:
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)
            if db and not db.has_consumers():
                del self.dbs[db.filename]
                db.close()
            if db and not error:
                util.start_file(export_dir if len(files) > 1 else files[0])
        self.button_export.Enabled = True
        if focused_control: focused_control.SetFocus()
            


    def on_compare_menu(self, event):
        """
        Handler for choosing a file from the compare popup menu, loads both
        databases and opens the merger page.
        """
        filename1, filename2 = self.db_filename, None
        # Find menuitem index and label from original menu by event ID
        nitems = enumerate(event.EventObject.GetMenuItems())
        indexitem = [(i, m) for i, m in nitems if m.GetId() == event.Id]
        i, item = indexitem[0] if indexitem else (-1, None)
        if i > 0 and item:
            filename2 = item.GetLabel()
        elif not i: # First menu item: open a file from computer
            dialog = wx.FileDialog(
                parent=self, message="Open", defaultFile="",
                wildcard="Skype database (*.db)|*.db|All files|*.*",
                style=wx.FD_FILE_MUST_EXIST | wx.FD_OPEN | wx.RESIZE_BORDER)
            dialog.ShowModal()
            filename2 = dialog.GetPath()
        if filename1 == filename2:
            wx.MessageBox("Cannot compare %s with itself." % (filename1),
                          conf.Title, wx.OK | wx.ICON_WARNING)
        else:
            self.compare_databases(filename1, filename2)


    def compare_databases(self, filename1, filename2):
        """Opens the two databases for comparison, if possible."""
        db1, db2, page = None, None, None
        if filename1 and filename2:
            db1 =  self.load_database(filename1)
        if db1:
            db2 = self.load_database(filename2)
        if db1 and db2:
            dbset = set((db1, db2))
            pp = list(filter(lambda i: i and set([i.db1, i.db2]) == dbset,
                             self.merger_pages))
            page = pp[0] if pp else None
            if not page:
                f1, f2 = filename1, filename2
                main.log("Merge page for %s and %s.", db1, db2)
                page = MergerPage(self.notebook, db1, db2,
                       self.get_unique_tab_title("Database comparison"))
                self.merger_pages[page] = (db1, db2)
                self.UpdateAccelerators()
                conf.save()
        elif db1 or db2:
            # Close DB with no owner
            for db in filter(None, [db1, db2]):
                if not db.has_consumers():
                    main.log("Closed database %s." % db.filename)
                    del self.dbs[db.filename]
                    db.close()
        if page:
            for i in range(self.notebook.GetPageCount()):
                if self.notebook.GetPage(i) == page:
                    self.notebook.SetSelection(i)
                    self.update_notebook_header()
                    break # break for i in range(self.notebook..


    def on_compare_databases(self, event):
        """
        Handler for clicking to compare a selected database with another, shows
        a popup menu for choosing the second database file.
        """
        menu = wx.lib.agw.flatmenu.FlatMenu()
        item = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
               "Select a file from your computer..")
        menu.AppendItem(item)
        recents = [f for f in conf.RecentFiles if f != self.db_filename][:5]
        others = [f for f in conf.DBFiles
                  if f not in recents and f != self.db_filename]
        if recents or others:
            menu.AppendSeparator()
        if recents:
            item = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
                                                    "Recent files")
            item.Enable(False)
            menu.AppendItem(item)
            for f in recents:
                i = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(), f)
                menu.AppendItem(i)
            if others:
                menu.AppendSeparator()
                item = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
                                                        "Rest of list")
                item.Enable(False)
                menu.AppendItem(item)
        for f in sorted(others):
            item = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(), f)
            menu.AppendItem(item)
        for item in menu.GetMenuItems():
            self.Bind(wx.EVT_MENU, self.on_compare_menu, item)

        sz_btn, pt_btn = event.EventObject.Size, event.EventObject.Position
        pt_btn = event.EventObject.Parent.ClientToScreen(pt_btn)
        menu.SetOwnerHeight(sz_btn.y)
        if menu.Size.width < sz_btn.width:
            menu.Size = sz_btn.width, menu.Size.height
        menu.Popup(pt_btn, self)


    def on_open_options(self, event):
        """
        Handler for opening advanced options, creates the property dialog
        and saves values.
        """
        dialog = controls.PropertyDialog(self, title="Advanced options")
        def get_field_doc(name, tree=ast.parse(inspect.getsource(conf))):
            """Returns the docstring immediately before name assignment."""
            for i, node in enumerate(tree.body):
                if i and ast.Assign == type(node) and node.targets[0].id == name:
                    prev = tree.body[i - 1]
                    if ast.Expr == type(prev) and ast.Str == type(prev.value):
                        return prev.value.s.strip()
            return ""

        for name in sorted(conf.OptionalFileDirectives):
            value, help = getattr(conf, name, None), get_field_doc(name)
            default = conf.OptionalFileDirectiveDefaults.get(name)
            if value is None and default is None:
                continue # continue for name
            kind = wx.Size if isinstance(value, (tuple, list)) else type(value)
            dialog.AddProperty(name, value, help, default, kind)
        dialog.Realize()

        if wx.ID_OK == dialog.ShowModal():
            [setattr(conf, k, v) for k, v in dialog.GetProperties()]
            conf.save()
            self.MinSize = conf.MinWindowSize


    def on_open_database(self, event):
        """
        Handler for open database menu or button, displays a file dialog and
        loads the chosen database.
        """
        dialog = wx.FileDialog(
            parent=self, message="Open", defaultFile="",
            wildcard="Skype database (*.db)|*.db|All files|*.*",
            style=wx.FD_FILE_MUST_EXIST | wx.FD_OPEN | wx.RESIZE_BORDER
        )
        if wx.ID_OK == dialog.ShowModal():
            filename = dialog.GetPath()
            if filename:
                self.update_database_list(filename)
                self.load_database_page(filename)


    def on_open_database_event(self, event):
        """
        Handler for OpenDatabaseEvent, updates db list and loads the event
        database.
        """
        filename = os.path.realpath(event.file)
        self.update_database_list(filename)
        self.load_database_page(filename)


    def on_recent_file(self, event):
        """Handler for clicking an entry in Recent Files menu."""
        filename = self.history_file.GetHistoryFile(event.Id - wx.ID_FILE1)
        self.update_database_list(filename)
        self.load_database_page(filename)


    def on_add_from_folder(self, event):
        """
        Handler for clicking to select folder where to search Skype databases,
        adds found databases to database lists.
        """
        if self.dialog_selectfolder.ShowModal() == wx.ID_OK:
            folder = self.dialog_selectfolder.GetPath()
            main.logstatus("Detecting Skype databases under %s.", folder)
            count = 0
            for filename in skypedata.find_databases(folder):
                if filename not in self.db_filenames:
                    main.log("Detected Skype database %s.", filename)
                    self.update_database_list(filename)
                    count += 1
            main.logstatus_flash("Detected %s under %s.",
                util.plural("new Skype database", count), folder)


    def on_open_current_database(self, event):
        """Handler for clicking to open selected files from database list."""
        if self.db_filename:
            self.load_database_page(self.db_filename)


    def on_open_from_list_db(self, event):
        """Handler for clicking to open selected files from database list."""
        if event.GetIndex() > 0:
            self.load_database_page(event.GetText())


    def update_database_stats(self, filename):
        """Opens the database and updates main page UI with database info."""
        db = None
        try:
            db = self.dbs.get(filename) or skypedata.SkypeDatabase(filename)
        except Exception as e:
            self.label_account.Value = "(database not readable)"
            self.label_messages.Value = "Error text: %s" % e
            self.label_account.ForegroundColour = conf.LabelErrorColour 
            self.label_chats.ForegroundColour = conf.LabelErrorColour
            main.log("Error opening %s.\n\n%s", filename,
                     traceback.format_exc())
            return
        try:
            stats = db.get_general_statistics(full=False)
            if "name" in stats and "skypename" in stats:
                self.label_account.Value = "%(name)s (%(skypename)s)" % stats
            text = "%(chats)s" % stats
            if "lastmessage_chat" in stats:
                text += ", latest %(lastmessage_chat)s" % stats
            self.label_chats.Value = text
            text = "%(messages)s" % stats
            if "lastmessage_dt" in stats:
                text += ", last at %(lastmessage_dt)s" % stats
            self.label_messages.Value = text
            data = self.db_filenames.get(filename, {})
            data["account"] = self.label_account.Value
            data["chats"] = self.label_chats.Value
            data["messages"] = self.label_messages.Value
        except Exception as e:
            if not self.label_account.Value:
                self.label_account.Value = "(not recognized as a Skype database)"
                self.label_account.ForegroundColour = conf.LabelErrorColour
            self.label_chats.Value = "Error text: %s" % e
            self.label_chats.ForegroundColour = conf.LabelErrorColour
            main.log("Error loading data from %s.\n\n%s", filename,
                     traceback.format_exc())


    def on_select_list_db(self, event):
        """Handler for selecting an item in main list, updates info panel."""
        if event.GetIndex() > 0 \
        and event.GetText() != self.db_filename:
            filename = self.db_filename = event.GetText()
            path, tail = os.path.split(filename)
            self.label_db.Value = tail
            self.label_path.Value = path
            self.label_size.Value = self.label_modified.Value = ""
            self.label_account.Value = self.label_chats.Value = ""
            self.label_messages.Value = ""
            self.label_account.ForegroundColour = self.ForegroundColour
            self.label_size.ForegroundColour = self.ForegroundColour
            self.label_chats.ForegroundColour = self.ForegroundColour
            if not self.panel_db_detail.Shown:
                self.panel_db_main.Hide()
                self.panel_db_detail.Show()
                self.panel_db_detail.Parent.Layout()
            if os.path.exists(filename):
                sz = os.path.getsize(filename)
                dt = datetime.datetime.fromtimestamp(os.path.getmtime(filename))
                self.label_size.Value = util.format_bytes(sz)
                self.label_modified.Value = dt.strftime("%Y-%m-%d %H:%M:%S")
                data = self.db_filenames[filename]
                if data["size"] == sz and data["last_modified"] == dt \
                and data["messages"]:
                    # File does not seem changed: use cached values
                    self.label_account.Value = data["account"]
                    self.label_chats.Value = data["chats"]
                    self.label_messages.Value = data["messages"]
                else:
                    wx.CallLater(10, self.update_database_stats, filename)
            else:
                self.label_size.Value = "File does not exist."
                self.label_size.ForegroundColour = conf.LabelErrorColour
        elif event.GetIndex() == 0 and not self.panel_db_main.Shown:
            self.db_filename = None
            self.panel_db_main.Show()
            self.panel_db_detail.Hide()
            self.panel_db_main.Parent.Layout()
        # Save last selected files in db lists, to reselect them on rerun
        del conf.LastSelectedFiles[:]
        selected = self.list_db.GetFirstSelected()
        while selected > 0:
            filename = self.list_db.GetItemText(selected)
            conf.LastSelectedFiles.append(filename)
            selected = self.list_db.GetNextSelected(selected)


    def on_exit(self, event):
        """
        Handler on application exit, asks about unsaved changes, if any.
        """
        do_exit = True
        unsaved_pages = {} # {DatabasePage: filename, }
        merging_pages = [] # [MergerPage title, ]
        for page, db in self.db_pages.items():
            if page.get_unsaved_grids():
                unsaved_pages[page] = db.filename
        if unsaved_pages:
            response = wx.MessageBox(
                "There are unsaved changes in data grids\n(%s). "
                "Save changes before closing?" %
                "\n".join(textwrap.wrap(", ".join(unsaved_pages.values()))),
                conf.Title, wx.YES | wx.NO | wx.CANCEL | wx.ICON_INFORMATION
            )
            if wx.YES == response:
                for page in unsaved_pages:
                    page.save_unsaved_grids()
            do_exit = (wx.CANCEL != response)
        if do_exit:
            merging_pages = filter(lambda x: x.is_merging, self.merger_pages)
            merging_pages = [p.title for p in merging_pages]
        if merging_pages:
            response = wx.MessageBox(
                "Merging is currently in progress in %s.\nExit anyway? "
                "This can result in corrupt data." % 
                "\n".join(textwrap.wrap(", ".join(merging_pages))),
                conf.Title, wx.OK | wx.CANCEL | wx.ICON_WARNING)
            do_exit = (wx.CANCEL != response)
        if do_exit:
            for page in self.db_pages:
                active_idx = page.notebook.Selection
                if active_idx:
                    conf.LastActivePage[page.db.filename] = active_idx
                elif page.db.filename in conf.LastActivePage:
                    del conf.LastActivePage[page.db.filename]
                page.save_page_conf()

            # Save last selected files in db lists, to reselect them on rerun
            conf.DBFiles = [self.list_db.GetItemText(i)
                            for i in range(1, self.list_db.GetItemCount())]
            del conf.LastSelectedFiles[:]
            selected = self.list_db.GetFirstSelected()
            while selected > 0:
                filename = self.list_db.GetItemText(selected)
                conf.LastSelectedFiles.append(filename)
                selected = self.list_db.GetNextSelected(selected)
            if not conf.WindowIconized:
                conf.WindowPosition = self.Position[:]
            conf.WindowSize = [-1, -1] if self.IsMaximized() else self.Size[:]
            conf.save()
            self.trayicon.Destroy()
            self.Destroy()


    def on_close_page(self, event):
        """
        Handler for closing a page, asks the user about saving unsaved data,
        if any, removes page from main notebook and updates accelerators.
        """
        if event.EventObject == self.notebook:
            page = self.notebook.GetPage(event.GetSelection())
        else:
            page = event.EventObject
            page.Show(False)
        if self.page_log == page:
            if not self.page_log.is_hidden:
                event.Veto() # Veto delete event
                self.on_showhide_log(None) # Fire remove event
            pages2 = list(filter(lambda x: x != page, self.pages_visited))
            self.pages_visited = pages2
            self.page_log.Show(False)
            return
        elif (not isinstance(page, (DatabasePage, MergerPage))
        or not page.ready_to_close):
            return event.Veto()

        # Remove page from MainWindow data structures
        if isinstance(page, DatabasePage):
            do_close = True
            unsaved = page.get_unsaved_grids()
            if unsaved:
                response = wx.MessageBox(
                    "Some tables in %s have unsaved data (%s).\n\n"
                    "Save changes before closing?" % (
                        page.db, ", ".join(sorted(x.table for x in unsaved))
                    ), conf.Title,
                    wx.YES | wx.NO | wx.CANCEL | wx.ICON_INFORMATION
                )
                if wx.YES == response:
                    page.save_unsaved_grids()
                elif wx.CANCEL == response:
                    do_close = False
            if not do_close:
                return event.Veto()

            if page.notebook.Selection:
                conf.LastActivePage[page.db.filename] = page.notebook.Selection
            elif page.db.filename in conf.LastActivePage:
                del conf.LastActivePage[page.db.filename]

            [i.stop() for i in page.workers_search.values()]
            page.save_page_conf()

            if page in self.db_pages:
                del self.db_pages[page]
            page_dbs = [page.db]
            main.log("Closed database tab for %s." % page.db)
            conf.save()
        else:
            if page.is_merging:
                response = wx.MessageBox(
                    "Merging is currently in progress in %s.\n\nClose anyway? "
                    "This can result in corrupt data." % page.title,
                    conf.Title, wx.OK | wx.CANCEL | wx.ICON_WARNING)
                if wx.CANCEL == response:
                    return event.Veto()

            if page in self.merger_pages:
                del self.merger_pages[page]
            page_dbs = [page.db1, page.db2]
            page.worker_merge.stop()
            page.worker_merge.join()
            main.log("Closed comparison tab for %s and %s.",
                     page.db1, page.db2)

        # Close databases, if not used in any other page
        for db in page_dbs:
            db.unregister_consumer(page)
            if not db.has_consumers():
                if db.filename in self.dbs:
                    del self.dbs[db.filename]
                db.close()
                main.log("Closed database %s." % db)
        # Remove any dangling references
        if self.page_merge_latest == page:
            self.page_merge_latest = None
        if self.page_db_latest == page:
            self.page_db_latest = next((i for i in self.pages_visited[::-1]
                                        if isinstance(i, DatabasePage)), None)
        self.SendSizeEvent() # Multiline wx.Notebooks need redrawing
        self.UpdateAccelerators() # Remove page accelerators

        # Remove page from visited pages order
        self.pages_visited = list(filter(lambda x: x != page,
                                         self.pages_visited))
        index_new = 0
        if self.pages_visited:
            for i in range(self.notebook.GetPageCount()):
                if self.notebook.GetPage(i) == self.pages_visited[-1]:
                    index_new = i
                    break
        self.notebook.SetSelection(index_new)


    def on_clear_searchall(self, event):
        """
        Handler for clicking to clear search history in a database page,
        confirms action and clears history globally.
        """
        choice = wx.MessageBox("Clear search history?", conf.Title,
                               wx.OK | wx.CANCEL | wx.ICON_WARNING)
        if wx.OK == choice:
            conf.SearchHistory = []
            for page in self.db_pages:
                page.edit_searchall.SetChoices(conf.SearchHistory)
                page.edit_searchall.ShowDropDown(False)
            self.dialog_search.SetChoices(conf.SearchHistory)
            conf.save()


    def get_unique_tab_title(self, title):
        """
        Returns a title that is unique for the current notebook - if the
        specified title already exists, appends a counter to the end,
        e.g. "Database comparison (1)". Title is shortened from the left
        if longer than allowed.
        """
        if len(title) > conf.MaxTabTitleLength:
            title = "..%s" % title[-conf.MaxTabTitleLength:]
        unique = title_base = title
        all_titles = [self.notebook.GetPageText(i)
                      for i in range(self.notebook.GetPageCount())]
        i = 1 # Start counter from 1
        while unique in all_titles:
            unique = "%s (%d)" % (title_base, i)
            i += 1
        return unique


    def load_database(self, filename):
        """
        Tries to load the specified database, if not already open, and returns
        it.
        """
        db = self.dbs.get(filename)
        if not db:
            db = None
            if os.path.exists(filename):
                try:
                    db = skypedata.SkypeDatabase(filename)
                except Exception:
                    is_accessible = False
                    try:
                        with open(filename, "rb") as f:
                            is_accessible = True
                    except Exception as e:
                        pass
                    if not is_accessible and self.skype_handler \
                    and self.skype_handler.is_running():
                        response = wx.MessageBox(
                            "Could not open %s.\n\n"
                            "Probably because Skype is running. "
                            "Close Skype and try again?" % filename,
                            conf.Title, wx.OK | wx.CANCEL | wx.ICON_WARNING)
                        if wx.OK == response:
                            self.skype_handler.shutdown()
                            try_result, db = util.try_until(lambda:
                                skypedata.SkypeDatabase(filename, False),
                                count=3)
                            if not try_result:
                                wx.MessageBox(
                                    "Still could not open %s." % filename,
                                    conf.Title, wx.OK | wx.ICON_WARNING)
                    elif not is_accessible:
                        wx.MessageBox(
                            "Could not open %s.\n\n"
                            "Some other process may be using the file."
                            % filename, conf.Title, wx.OK | wx.ICON_WARNING)
                    else:
                        wx.MessageBox(
                            "Could not open %s.\n\n"
                            "Not a valid SQLITE database?" % filename,
                            conf.Title, wx.OK | wx.ICON_WARNING)
                if db:
                    main.log("Opened %s (%s).", db, util.format_bytes(
                             db.filesize))
                    main.status_flash("Reading Skype database file %s.", db)
                    self.dbs[filename] = db
                    # Add filename to Recent Files menu and conf, if needed
                    if filename in conf.RecentFiles:
                        idx = conf.RecentFiles.index(filename)
                        self.history_file.RemoveFileFromHistory(idx)
                    self.history_file.AddFileToHistory(filename)
                    util.add_unique(conf.RecentFiles, filename, -1,
                                    conf.MaxRecentFiles)
                    conf.save()
                    self.check_future_dates(db)
            else:
                wx.MessageBox("Nonexistent file: %s." % filename,
                              conf.Title, wx.OK | wx.ICON_WARNING)
        return db


    def load_database_page(self, filename):
        """
        Tries to load the specified database, if not already open, create a
        subpage for it, if not already created, and focuses the subpage.

        @return  database page instance
        """
        db = None
        page = None
        if filename in self.dbs:
            db = self.dbs[filename]
        if db and db in self.db_pages.values():
            pp = list(filter(lambda i: i and (i.db == db), self.db_pages))
            page = pp[0] if pp else None
        if not page:
            if not db:
                db = self.load_database(filename)
            if db:
                main.status_flash("Opening Skype database file %s." % db)
                tab_title = self.get_unique_tab_title(db.filename)
                page = DatabasePage(self.notebook, tab_title, db,
                                    self.memoryfs, self.skype_handler)
                self.db_pages[page] = db
                self.UpdateAccelerators()
                conf.save()
                self.Bind(wx.EVT_LIST_DELETE_ALL_ITEMS,
                          self.on_clear_searchall, page.edit_searchall)
        if page:
            for i in range(1, self.list_db.GetItemCount()):
                if self.list_db.GetItemText(i) == filename:
                    self.list_db.Select(i); break # break for i
            for i in range(self.notebook.GetPageCount()):
                if self.notebook.GetPage(i) == page:
                    self.notebook.SetSelection(i)
                    self.update_notebook_header()
                    break # break for i in range(self.notebook..)
        return page


    def check_future_dates(self, db):
        """
        Checks the database for messages with a future date and asks the user
        about fixing them.
        """
        future_count, max_datetime = db.check_future_dates()
        if future_count:
            delta = datetime.datetime.now() - max_datetime
            dialog = DayHourDialog(parent=self,
                message="The database has %s with a "
                "future timestamp (last being %s).\nThis can "
                "happen if the computer\"s clock has been set "
                "to a future date when the messages were "
                "received.\n\n"
                "If you want to fix these messages, "
                "enter how many days/hours to move them:" %
                  (util.plural("message", future_count), max_datetime),
                caption=conf.Title, days=delta.days, hours=0)
            dialog_result = dialog.ShowModal()
            days, hours = dialog.GetValues()
            if (wx.ID_OK == dialog_result) and (days or hours):
                db.move_future_dates(days, hours)
                wx.MessageBox(
                    "Set timestamp of %s %s%s back." % (
                        util.plural("message", future_count),
                        util.plural("day", days) if days else "",
                        (" and " if days else "") +
                        util.plural("hour", hours) if hours else "",
                    ),
                    conf.Title, wx.OK)



class DatabasePage(wx.Panel):
    """
    A wx.Notebook page for managing a single database file, has its own
    Notebook with a number of pages for searching, browsing chat history and
    database tables, information and contact import.
    """

    def __init__(self, parent_notebook, title, db, memoryfs, skype_handler):
        wx.Panel.__init__(self, parent=parent_notebook)
        self.parent_notebook = parent_notebook
        self.title = title

        self.pageorder = {} # {page: notebook index, }
        self.ready_to_close = False
        self.db = db
        self.db.register_consumer(self)
        self.db_grids = {} # {"tablename": GridTableBase, }
        self.memoryfs = memoryfs
        self.skype_handler = skype_handler
        parent_notebook.InsertPage(1, self, title)
        busy = controls.BusyPanel(self, "Loading \"%s\"." % db.filename)

        self.chat = None # Currently viewed chat
        self.chats = []  # All chats in database
        self.chat_filter = { # Filter for currently shown chat history
            "daterange": None,      # Current date range
            "startdaterange": None, # Initial date range
            "text": "",             # Text in message content
            "participants": None    # Messages from [skype name, ]
        }
        self.stats_sort_field = "name"

        # Create search structures and threads
        self.Bind(EVT_WORKER, self.on_searchall_result)
        self.Bind(EVT_CONTACT_WORKER, self.on_search_contacts_result)
        self.workers_search = {} # {search ID: workers.SearchThread, }
        self.worker_search_contacts = \
            workers.ContactSearchThread(self.on_search_contacts_callback)
        self.search_data_contact = {"id": None} # Current contacts search data

        sizer = self.Sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_header = wx.BoxSizer(wx.HORIZONTAL)
        label_title = self.label_title = wx.StaticText(parent=self, label="")
        sizer_header.Add(label_title, flag=wx.ALIGN_CENTER_VERTICAL)
        sizer_header.AddStretchSpacer()


        self.label_search = wx.StaticText(self, -1, "&Search in messages:")
        sizer_header.Add(self.label_search, border=5,
                         flag=wx.RIGHT | wx.ALIGN_CENTER_VERTICAL)
        edit_search = self.edit_searchall = controls.TextCtrlAutoComplete(
            self, description=conf.HistorySearchDescription,
            size=(300, -1), style=wx.TE_PROCESS_ENTER)
        self.Bind(wx.EVT_TEXT_ENTER, self.on_searchall, edit_search)
        tb = self.tb_search = wx.ToolBar(parent=self,
                                         style=wx.TB_FLAT | wx.TB_NODIVIDER)

        bmp = wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD, wx.ART_TOOLBAR,
                                       (16, 16))
        tb.SetToolBitmapSize(bmp.Size)
        tb.AddLabelTool(wx.ID_FIND, "", bitmap=bmp, shortHelp="Start search")
        tb.Realize()
        self.Bind(wx.EVT_TOOL, self.on_searchall, id=wx.ID_FIND)
        sizer_header.Add(edit_search, border=5,
                     flag=wx.RIGHT | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL)
        sizer_header.Add(tb, flag=wx.ALIGN_RIGHT | wx.GROW)
        sizer.Add(sizer_header,
                  border=5, flag=wx.LEFT | wx.RIGHT | wx.TOP | wx.GROW)
        sizer.Layout() # To avoid searchbox moving around during page creation

        bookstyle = wx.lib.agw.fmresources.INB_LEFT
        if (wx.version().startswith("2.8") and sys.version.startswith("2.")
        and sys.version[:5] < "2.7.3"):
            # wx 2.8 + Python below 2.7.3: labelbook can partly cover tab area
            bookstyle |= wx.lib.agw.fmresources.INB_FIT_LABELTEXT
        notebook = self.notebook = wx.lib.agw.labelbook.FlatImageBook(
            parent=self, agwStyle=bookstyle, style=wx.BORDER_STATIC)

        il = wx.ImageList(32, 32)
        idx1 = il.Add(images.PageSearch.Bitmap)
        idx2 = il.Add(images.PageChats.Bitmap)
        idx3 = il.Add(images.PageInfo.Bitmap)
        idx4 = il.Add(images.PageTables.Bitmap)
        idx5 = il.Add(images.PageSQL.Bitmap)
        idx6 = il.Add(images.PageContacts.Bitmap)
        notebook.AssignImageList(il)

        self.create_page_search(notebook)
        self.create_page_chats(notebook)
        self.create_page_info(notebook)
        self.create_page_tables(notebook)
        self.create_page_sql(notebook)
        self.create_page_contacts(notebook)

        notebook.SetPageImage(0, idx1)
        notebook.SetPageImage(1, idx2)
        notebook.SetPageImage(2, idx3)
        notebook.SetPageImage(3, idx4)
        notebook.SetPageImage(4, idx5)
        notebook.SetPageImage(5, idx6)

        sizer.Add(notebook,proportion=1, border=5, flag=wx.GROW | wx.ALL)

        self.dialog_savefile = wx.FileDialog(
            parent=self,
            defaultDir=os.getcwd(),
            defaultFile="",
            style=wx.FD_SAVE | wx.RESIZE_BORDER)
        self.dialog_importfile = wx.FileDialog(
            parent=self,
            message="Select contacts file",
            defaultDir=os.getcwd(),
            wildcard="CSV spreadsheet (*.csv)|*.csv|All files (*.*)|*.*",
            style=wx.FD_FILE_MUST_EXIST | wx.FD_OPEN | wx.RESIZE_BORDER
        )

        self.TopLevelParent.page_db_latest = self
        self.TopLevelParent.run_console(
            "page = self.page_db_latest # Database tab")
        self.TopLevelParent.run_console("db = page.db # Skype database")

        self.Layout()
        self.toggle_filter(True)
        # Hack to get info-page multiline TextCtrls to layout without quirks.
        self.notebook.SetSelection(self.pageorder[self.page_info])
        # Hack to get chats-page filter split window to layout without quirks.
        self.notebook.SetSelection(self.pageorder[self.page_chats])
        self.notebook.SetSelection(self.pageorder[self.page_search])
        # Restore last active page
        if db.filename in conf.LastActivePage \
        and conf.LastActivePage[db.filename] != self.notebook.Selection:
            self.notebook.SetSelection(conf.LastActivePage[db.filename])

        try:
            self.load_data()
        finally:
            busy.Close()
        self.edit_searchall.SetFocus()
        wx.CallAfter(self.edit_searchall.SelectAll)
        if "linux2" == sys.platform and wx.version().startswith("2.8"):
            wx.CallAfter(self.split_panels)


    def create_page_chats(self, notebook):
        """Creates a page for listing and reading chats."""
        page = self.page_chats = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Chats")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
        splitter = self.splitter_chats = wx.SplitterWindow(
            parent=page, style=wx.BORDER_NONE
        )
        splitter.SetMinimumPaneSize(100)

        panel1 = self.panel_chats1 = wx.Panel(parent=splitter)
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_top = wx.BoxSizer(wx.HORIZONTAL)
        sizer_top.Add(
            wx.StaticText(panel1, label="A&ll chat entries in database:"),
            proportion=1, border=5, flag=wx.ALIGN_BOTTOM)
        list_chats = self.list_chats = controls.SortableListView(
            parent=panel1, style=wx.LC_REPORT)
        columns = [("title", "Chat"), ("message_count", "Messages"),
                   ("created_datetime", "Created"),
                   ("first_message_datetime", "First message"),
                   ("last_message_datetime", "Last message"),
                   ("type_name", "Type"), ("people", "People"), ]
        frmt = lambda r, c: r[c].strftime("%Y-%m-%d %H:%M") if r.get(c) else ""
        frmt_dt = lambda r, c: r[c].strftime("%Y-%m-%d") if r.get(c) else ""
        formatters = {"created_datetime": frmt_dt,
                      "first_message_datetime": frmt,
                      "last_message_datetime": frmt, }
        list_chats.SetColumns(columns)
        list_chats.SetColumnFormatters(formatters)
        list_chats.SetColumnsMaxWidth(300)
        label_filter = wx.StaticText(panel1, label="Filter ch&ats:")
        sizer_top.Add(label_filter, flag=wx.ALIGN_CENTER | wx.RIGHT, border=5)
        edit_chatfilter = self.edit_chatfilter = wx.TextCtrl(
            parent=panel1, size=(75, -1))
        filter_tooltip = "Filter items in chat list"
        label_filter.SetToolTipString(filter_tooltip)
        edit_chatfilter.SetToolTipString(filter_tooltip)
        self.Bind(wx.EVT_TEXT, self.on_change_chatfilter, edit_chatfilter)
        sizer_top.Add(edit_chatfilter, flag=wx.RIGHT, border=15)
        button_export_chats = self.button_export_chats = \
            wx.Button(parent=panel1, label="Exp&ort chats")
        sizer_top.Add(button_export_chats, flag=wx.ALIGN_CENTER_HORIZONTAL)
        self.Bind(wx.EVT_BUTTON, self.on_export_chats_menu, button_export_chats)
        sizer1.Add(sizer_top, border=5,
                   flag=wx.RIGHT | wx.LEFT | wx.BOTTOM | wx.GROW)

        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED,
                  self.on_change_list_chats, list_chats)
        sizer1.Add(list_chats, proportion=1, border=5,
                   flag=wx.GROW | wx.LEFT | wx.RIGHT)

        panel2 = self.panel_chats2 = wx.Panel(parent=splitter)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)

        splitter_stc = self.splitter_stc = \
            wx.SplitterWindow(parent=panel2, style=wx.BORDER_NONE)
        splitter_stc.SetMinimumPaneSize(100)
        panel_stc1 = self.panel_stc1 = wx.Panel(parent=splitter_stc)
        panel_stc2 = self.panel_stc2 = wx.Panel(parent=splitter_stc)
        sizer_stc1 = panel_stc1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_stc2 = panel_stc2.Sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_header = wx.BoxSizer(wx.HORIZONTAL)
        label_chat = self.label_chat = wx.StaticText(
            parent=panel_stc1, label="&Chat:", name="chat_history_label")

        tb = self.tb_chat = \
            wx.ToolBar(parent=panel_stc1, style=wx.TB_FLAT | wx.TB_NODIVIDER)
        tb.SetToolBitmapSize((24, 24))
        tb.AddCheckTool(wx.ID_ZOOM_100,
                        bitmap=images.ToolbarMaximize.Bitmap,
                        shortHelp="Maximize chat panel  (Alt-M)")
        tb.AddCheckTool(wx.ID_PROPERTIES,
                        bitmap=images.ToolbarStats.Bitmap,
                        shortHelp="Toggle chat statistics  (Alt-I)")
        tb.AddCheckTool(wx.ID_MORE, bitmap=images.ToolbarFilter.Bitmap,
                        shortHelp="Toggle filter panel  (Alt-G)")
        tb.Realize()
        self.Bind(wx.EVT_TOOL, self.on_toggle_maximize, id=wx.ID_ZOOM_100)
        self.Bind(wx.EVT_TOOL, self.on_toggle_stats,    id=wx.ID_PROPERTIES)
        self.Bind(wx.EVT_TOOL, self.on_toggle_filter,   id=wx.ID_MORE)

        button_export = self.button_export_chat = \
            wx.Button(parent=panel_stc1, label="&Export messages to file")
        button_export.SetToolTipString(
            "Export currently shown messages to a file")
        self.Bind(wx.EVT_BUTTON, self.on_export_chat, button_export)
        sizer_header.Add(label_chat, proportion=1, border=5, flag=wx.LEFT |
                         wx.ALIGN_BOTTOM)
        sizer_header.Add(tb, flag=wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT)
        sizer_header.Add(button_export, border=15, flag=wx.LEFT |
                         wx.ALIGN_CENTER_VERTICAL)

        stc = self.stc_history = ChatContentSTC(
            parent=panel_stc1, style=wx.BORDER_STATIC, name="chat_history")
        stc.SetDatabasePage(self)
        html_stats = self.html_stats = wx.html.HtmlWindow(parent=panel_stc1)
        html_stats.Bind(wx.html.EVT_HTML_LINK_CLICKED,
                        self.on_click_html_stats)
        html_stats.Bind(wx.EVT_SCROLLWIN, self.on_scroll_html_stats)
        html_stats.Bind(wx.EVT_SIZE, self.on_size_html_stats)
        html_stats.Hide()

        sizer_stc1.Add(sizer_header, border=5, flag=wx.GROW | wx.RIGHT |
                       wx.BOTTOM)
        sizer_stc1.Add(stc, proportion=1, border=5, flag=wx.GROW)
        sizer_stc1.Add(html_stats, proportion=1, flag=wx.GROW)

        label_filter = \
            wx.StaticText(parent=panel_stc2, label="Find messages with &text:")
        edit_filter = self.edit_filtertext = wx.TextCtrl(
            parent=panel_stc2, size=(100, -1), style=wx.TE_PROCESS_ENTER)
        self.Bind(wx.EVT_TEXT_ENTER, self.on_filter_chat, edit_filter)
        edit_filter.SetToolTipString("Find messages containing the exact text")
        label_range = wx.StaticText(
            parent=panel_stc2, label="Show messages from time period:")
        range_date = self.range_date = \
            controls.RangeSlider(parent=panel_stc2, fmt="%Y-%m-%d")
        range_date.SetRange(None, None)
        label_list = \
            wx.StaticText(parent=panel_stc2, label="Sho&w messages from:")
        agw_style = (wx.LC_REPORT | wx.LC_NO_HEADER | wx.LC_SINGLE_SEL |
                     wx.lib.agw.ultimatelistctrl.ULC_NO_HIGHLIGHT |
                     wx.lib.agw.ultimatelistctrl.ULC_HRULES |
                     wx.lib.agw.ultimatelistctrl.ULC_SHOW_TOOLTIPS)
        if hasattr(wx.lib.agw.ultimatelistctrl, "ULC_USER_ROW_HEIGHT"):
            agw_style |= wx.lib.agw.ultimatelistctrl.ULC_USER_ROW_HEIGHT
        list_participants = self.list_participants = \
            wx.lib.agw.ultimatelistctrl.UltimateListCtrl(parent=panel_stc2,
                                                         agwStyle=agw_style)
        list_participants.InsertColumn(0, "")
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_select_participant,
                  list_participants)
        list_participants.EnableSelectionGradient()
        if hasattr(list_participants, "SetUserLineHeight"):
            list_participants.SetUserLineHeight(conf.AvatarImageSize[1] + 2)
        sizer_filter_buttons = wx.BoxSizer(wx.HORIZONTAL)
        button_filter_apply = self.button_chat_applyfilter = \
            wx.Button(parent=panel_stc2, label="A&pply filter")
        button_filter_export = self.button_chat_exportfilter = \
            wx.Button(parent=panel_stc2, label="Expo&rt filter")
        button_filter_reset = self.button_chat_unfilter = \
            wx.Button(parent=panel_stc2, label="Restore i&nitial")
        self.Bind(wx.EVT_BUTTON, self.on_filter_chat, button_filter_apply)
        self.Bind(wx.EVT_BUTTON, self.on_filterexport_chat,
                  button_filter_export)
        self.Bind(wx.EVT_BUTTON, self.on_filterreset_chat, button_filter_reset)
        button_filter_apply.SetToolTipString(
            "Filters the conversation by the specified text, "
            "date range and participants.")
        button_filter_export.SetToolTipString(
            "Exports filtered messages straight to file, "
            "without showing them (showing thousands of messages gets slow).")
        button_filter_reset.SetToolTipString(
            "Restores filter controls to initial values.")
        sizer_filter_buttons.Add(button_filter_apply)
        sizer_filter_buttons.AddSpacer(5)
        sizer_filter_buttons.Add(button_filter_export)
        sizer_filter_buttons.AddSpacer(5)
        sizer_filter_buttons.Add(button_filter_reset)
        sizer_filter_buttons.AddSpacer(5)
        sizer_stc2.Add(label_filter, border=5, flag=wx.LEFT)
        sizer_stc2.Add(edit_filter, border=5, flag=wx.GROW | wx.LEFT)
        sizer_stc2.AddSpacer(5)
        sizer_stc2.Add(label_range, border=5, flag=wx.LEFT)
        sizer_stc2.Add(range_date, border=5, flag=wx.GROW | wx.LEFT)
        sizer_stc2.AddSpacer(5)
        sizer_stc2.Add(label_list, border=5, flag=wx.LEFT)
        sizer_stc2.Add(list_participants, proportion=1, border=5,
                       flag=wx.GROW | wx.LEFT)
        sizer_stc2.AddSpacer(5)
        sizer_stc2.Add(sizer_filter_buttons, proportion=0, border=5,
                       flag=wx.GROW | wx.LEFT | wx.RIGHT)

        splitter_stc.SplitVertically(panel_stc1, panel_stc2, sashPosition=0)
        splitter_stc.Unsplit(panel_stc2) # Hide filter panel
        sizer2.Add(splitter_stc, proportion=1, border=5, flag=wx.GROW | wx.ALL)

        sizer.AddSpacer(10)
        sizer.Add(splitter, proportion=1, flag=wx.GROW)
        splitter.SplitHorizontally(panel1, panel2, sashPosition=self.Size[1]/3)
        panel2.Enabled = False


    def create_page_search(self, notebook):
        """Creates a page for searching chats."""
        page = self.page_search = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Search")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_top = wx.BoxSizer(wx.HORIZONTAL)

        label_html = self.label_html = \
            wx.html.HtmlWindow(page, style=wx.html.HW_SCROLLBAR_NEVER)
        label_html.SetFonts(normal_face=self.Font.FaceName,
                            fixed_face=self.Font.FaceName, sizes=[8] * 7)
        label_html.SetPage(step.Template(templates.SEARCH_HELP_SHORT).expand())

        tb = self.tb_search_settings = \
            wx.ToolBar(parent=page, style=wx.TB_FLAT | wx.TB_NODIVIDER)
        tb.MinSize = (195, -1)
        tb.SetToolBitmapSize((24, 24))
        tb.AddRadioTool(wx.ID_INDEX, bitmap=images.ToolbarMessage.Bitmap,
            shortHelp="Search in message body")
        tb.AddRadioTool(wx.ID_PREVIEW, bitmap=images.ToolbarContact.Bitmap,
            shortHelp="Search in contact information")
        tb.AddRadioTool(wx.ID_ABOUT, bitmap=images.ToolbarTitle.Bitmap,
            shortHelp="Search in chat title and participants")
        tb.AddRadioTool(wx.ID_STATIC, bitmap=images.ToolbarTables.Bitmap,
            shortHelp="Search in all columns of all database tables")
        tb.AddSeparator()
        tb.AddCheckTool(wx.ID_NEW, bitmap=images.ToolbarTabs.Bitmap,
            shortHelp="New tab for each search  (Alt-N)", longHelp="")
        tb.AddSimpleTool(wx.ID_STOP, bitmap=images.ToolbarStopped.Bitmap,
            shortHelpString="Stop current search, if any")
        tb.Realize()
        tb.ToggleTool(wx.ID_INDEX, conf.SearchInMessages)
        tb.ToggleTool(wx.ID_ABOUT, conf.SearchInChatInfo)
        tb.ToggleTool(wx.ID_PREVIEW, conf.SearchInContacts)
        tb.ToggleTool(wx.ID_STATIC, conf.SearchInTables)
        tb.ToggleTool(wx.ID_NEW, conf.SearchUseNewTab)
        for id in [wx.ID_INDEX, wx.ID_ABOUT, wx.ID_PREVIEW, wx.ID_STATIC,
                   wx.ID_NEW]:
            self.Bind(wx.EVT_TOOL, self.on_searchall_toggle_toolbar, id=id)
        self.Bind(wx.EVT_TOOL, self.on_searchall_stop, id=wx.ID_STOP)

        if conf.SearchInChatInfo:
            self.label_search.Label = "&Search in chat info:"
        elif conf.SearchInContacts:
            self.label_search.Label = "&Search in contacts:"
        elif conf.SearchInTables:
            self.label_search.Label = "&Search in all tables:"

        html = self.html_searchall = controls.TabbedHtmlWindow(parent=page)
        default = step.Template(templates.SEARCH_WELCOME_HTML).expand()
        html.SetDefaultPage(default)
        html.SetDeleteCallback(self.on_delete_tab_callback)
        label_html.Bind(wx.html.EVT_HTML_LINK_CLICKED,
                        self.on_click_searchall_result)
        html.Bind(wx.html.EVT_HTML_LINK_CLICKED,
                  self.on_click_searchall_result)
        html.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.on_change_searchall_tab)
        html.Bind(controls.EVT_TAB_LEFT_DCLICK, self.on_dclick_searchall_tab)
        html.SetTabAreaColour(tb.BackgroundColour)
        html.Font.PixelSize = (0, 8)

        label_html.BackgroundColour = tb.BackgroundColour
        
        sizer_top.Add(label_html, proportion=1, flag=wx.GROW)
        sizer_top.Add(tb, border=5, flag=wx.TOP | wx.RIGHT |
                      wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT)
        sizer.Add(sizer_top, border=5, flag=wx.TOP | wx.RIGHT | wx.GROW)
        sizer.Add(html, border=5, proportion=1,
                  flag=wx.GROW | wx.LEFT | wx.RIGHT | wx.BOTTOM)
        wx.CallAfter(label_html.Show)


    def create_page_tables(self, notebook):
        """Creates a page for listing and browsing tables."""
        page = self.page_tables = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Data tables")
        sizer = page.Sizer = wx.BoxSizer(wx.HORIZONTAL)
        splitter = self.splitter_tables = wx.SplitterWindow(
            parent=page, style=wx.BORDER_NONE
        )
        splitter.SetMinimumPaneSize(100)

        panel1 = wx.Panel(parent=splitter)
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_topleft = wx.BoxSizer(wx.HORIZONTAL)
        sizer_topleft.Add(wx.StaticText(parent=panel1, label="&Tables:"),
                          flag=wx.ALIGN_CENTER_VERTICAL)
        button_refresh = self.button_refresh_tables = \
            wx.Button(panel1, label="Refresh")
        sizer_topleft.AddStretchSpacer()
        sizer_topleft.Add(button_refresh)
        tree = self.tree_tables = wx.gizmos.TreeListCtrl(
            parent=panel1,
            style=wx.TR_DEFAULT_STYLE
            #| wx.TR_HAS_BUTTONS
            #| wx.TR_TWIST_BUTTONS
            #| wx.TR_ROW_LINES
            #| wx.TR_COLUMN_LINES
            #| wx.TR_NO_LINES
            | wx.TR_FULL_ROW_HIGHLIGHT
        )
        tree.AddColumn("Table")
        tree.AddColumn("Info")
        tree.AddRoot("Loading data..")
        tree.SetMainColumn(0)
        tree.SetColumnAlignment(1, wx.ALIGN_RIGHT)
        self.Bind(wx.EVT_BUTTON, self.on_refresh_tables, button_refresh)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_change_tree_tables, tree)

        sizer1.Add(sizer_topleft, border=5, flag=wx.GROW | wx.LEFT | wx.TOP)
        sizer1.Add(tree, proportion=1,
                   border=5, flag=wx.GROW | wx.LEFT | wx.TOP | wx.BOTTOM)

        panel2 = wx.Panel(parent=splitter)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_tb = wx.BoxSizer(wx.HORIZONTAL)
        tb = self.tb_grid = wx.ToolBar(
            parent=panel2, style=wx.TB_FLAT | wx.TB_NODIVIDER)
        bmp_tb = images.ToolbarInsert.Bitmap
        tb.SetToolBitmapSize(bmp_tb.Size)
        tb.AddLabelTool(id=wx.ID_ADD, label="Insert new row.",
                        bitmap=bmp_tb, shortHelp="Add new row.")
        tb.AddLabelTool(id=wx.ID_DELETE, label="Delete current row.",
            bitmap=images.ToolbarDelete.Bitmap, shortHelp="Delete row.")
        tb.AddSeparator()
        tb.AddLabelTool(id=wx.ID_SAVE, label="Commit",
                        bitmap=images.ToolbarCommit.Bitmap,
                        shortHelp="Commit changes to database.")
        tb.AddLabelTool(id=wx.ID_UNDO, label="Rollback",
            bitmap=images.ToolbarRollback.Bitmap,
            shortHelp="Rollback changes and restore original values.")
        tb.EnableTool(wx.ID_ADD, False)
        tb.EnableTool(wx.ID_DELETE, False)
        tb.EnableTool(wx.ID_UNDO, False)
        tb.EnableTool(wx.ID_SAVE, False)
        self.Bind(wx.EVT_TOOL, handler=self.on_insert_row, id=wx.ID_ADD)
        self.Bind(wx.EVT_TOOL, handler=self.on_delete_row, id=wx.ID_DELETE)
        self.Bind(wx.EVT_TOOL, handler=self.on_commit_table, id=wx.ID_SAVE)
        self.Bind(wx.EVT_TOOL, handler=self.on_rollback_table, id=wx.ID_UNDO)
        tb.Realize() # should be called after adding tools
        label_table = self.label_table = wx.StaticText(parent=panel2, label="")
        button_reset = self.button_reset_grid_table = \
            wx.Button(parent=panel2, label="&Reset filter/sort")
        button_reset.SetToolTipString("Resets all applied sorting "
                                      "and filtering.")
        button_reset.Bind(wx.EVT_BUTTON, self.on_button_reset_grid)
        button_reset.Enabled = False
        button_export = self.button_export_table = \
            wx.Button(parent=panel2, label="&Export to file")
        button_export.MinSize = (100, -1)
        button_export.SetToolTipString("Export rows to a file.")
        button_export.Bind(wx.EVT_BUTTON, self.on_button_export_grid)
        button_export.Enabled = False
        sizer_tb.Add(label_table, flag=wx.ALIGN_CENTER_VERTICAL)
        sizer_tb.AddStretchSpacer()
        sizer_tb.Add(button_reset, border=5, flag=wx.BOTTOM | wx.RIGHT |
                     wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL)
        sizer_tb.Add(button_export, border=5, flag=wx.BOTTOM | wx.RIGHT |
                     wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL)
        sizer_tb.Add(tb, flag=wx.ALIGN_RIGHT)
        grid = self.grid_table = wx.grid.Grid(parent=panel2)
        grid.SetToolTipString("Double click on column header to sort, "
                              "right click to filter.")
        grid.Bind(wx.grid.EVT_GRID_LABEL_LEFT_DCLICK, self.on_sort_grid_column)
        grid.GridWindow.Bind(wx.EVT_MOTION, self.on_mouse_over_grid)
        grid.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK,
                  self.on_filter_grid_column)
        grid.Bind(wx.grid.EVT_GRID_CELL_CHANGE, self.on_change_table)
        label_help = wx.StaticText(panel2, wx.NewId(),
            "Double-click on column header to sort, right click to filter.")
        label_help.ForegroundColour = "grey"
        sizer2.Add(sizer_tb, border=5, flag=wx.GROW | wx.LEFT | wx.TOP)
        sizer2.Add(grid, border=5, proportion=2,
                   flag=wx.GROW | wx.LEFT | wx.RIGHT)
        sizer2.Add(label_help, border=5, flag=wx.LEFT | wx.TOP)

        sizer.Add(splitter, proportion=1, flag=wx.GROW)
        splitter.SplitVertically(panel1, panel2, 270)


    def create_page_sql(self, notebook):
        """Creates a page for executing arbitrary SQL."""
        page = self.page_sql = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "SQL window")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
        splitter = self.splitter_sql = \
            wx.SplitterWindow(parent=page, style=wx.BORDER_NONE)
        splitter.SetMinimumPaneSize(100)

        panel1 = self.panel_sql1 = wx.Panel(parent=splitter)
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        label_stc = wx.StaticText(parent=panel1, label="SQ&L:")
        stc = self.stc_sql = controls.SQLiteTextCtrl(parent=panel1,
            style=wx.BORDER_STATIC | wx.TE_PROCESS_TAB | wx.TE_PROCESS_ENTER)
        stc.Bind(wx.EVT_KEY_DOWN, self.on_keydown_sql)
        stc.SetText(conf.SQLWindowTexts.get(self.db.filename, ""))
        sizer1.Add(label_stc, border=5, flag=wx.ALL)
        sizer1.Add(stc, border=5, proportion=1, flag=wx.GROW | wx.LEFT)

        panel2 = self.panel_sql2 = wx.Panel(parent=splitter)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)
        label_help = wx.StaticText(panel2, label=
            "Ctrl-Space shows autocompletion list. Alt-Enter runs the query "
            "contained in currently selected text or on the current line.")
        label_help.ForegroundColour = "grey"
        sizer_buttons = wx.BoxSizer(wx.HORIZONTAL)
        button_sql = self.button_sql = wx.Button(panel2, label="Execute S&QL")
        self.Bind(wx.EVT_BUTTON, self.on_button_sql, button_sql)
        button_reset = self.button_reset_grid_sql = \
            wx.Button(parent=panel2, label="&Reset filter/sort")
        button_reset.SetToolTipString("Resets all applied sorting "
                                      "and filtering.")
        button_reset.Bind(wx.EVT_BUTTON, self.on_button_reset_grid)
        button_reset.Enabled = False
        button_export = self.button_export_sql = \
            wx.Button(parent=panel2, label="&Export to file")
        button_export.SetToolTipString("Export result to a file.")
        button_export.Bind(wx.EVT_BUTTON, self.on_button_export_grid)
        button_export.Enabled = False
        sizer_buttons.Add(button_sql, flag=wx.ALIGN_LEFT)
        sizer_buttons.AddStretchSpacer()
        sizer_buttons.Add(button_reset, border=5,
                          flag=wx.ALIGN_RIGHT | wx.RIGHT)
        sizer_buttons.Add(button_export, flag=wx.ALIGN_RIGHT)
        grid = self.grid_sql = wx.grid.Grid(parent=panel2)
        grid.Bind(wx.grid.EVT_GRID_LABEL_LEFT_DCLICK,
                  self.on_sort_grid_column)
        grid.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK,
                  self.on_filter_grid_column)
        grid.Bind(wx.EVT_SCROLLWIN, self.on_scroll_grid_sql)
        grid.Bind(wx.EVT_SCROLL_THUMBRELEASE, self.on_scroll_grid_sql)
        grid.Bind(wx.EVT_SCROLL_CHANGED, self.on_scroll_grid_sql)
        grid.Bind(wx.EVT_KEY_DOWN, self.on_scroll_grid_sql)
        grid.GridWindow.Bind(wx.EVT_MOTION, self.on_mouse_over_grid)
        label_help_grid = wx.StaticText(panel2, wx.NewId(),
            "Double-click on column header to sort, right click to filter.")
        label_help_grid.ForegroundColour = "grey"

        sizer2.Add(label_help, border=5, flag=wx.GROW | wx.LEFT | wx.BOTTOM)
        sizer2.Add(sizer_buttons, border=5, flag=wx.GROW | wx.ALL)
        sizer2.Add(grid, border=5, proportion=2,
                   flag=wx.GROW | wx.LEFT | wx.RIGHT)
        sizer2.Add(label_help_grid, border=5, flag=wx.GROW | wx.LEFT | wx.TOP)

        sizer.Add(splitter, proportion=1, flag=wx.GROW)
        sash_pos = self.Size[1] / 3
        splitter.SplitHorizontally(panel1, panel2, sashPosition=sash_pos)


    def create_page_contacts(self, notebook):
        """Creates a page for importing contacts from file."""
        page = self.page_contacts = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Contacts+")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
        splitter = self.splitter_import = wx.SplitterWindow(
            parent=page, style=wx.BORDER_NONE)
        splitter.SetMinimumPaneSize(100)

        panel1 = wx.Panel(parent=splitter)
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_header = wx.BoxSizer(wx.HORIZONTAL)
        sizer_top1 = wx.BoxSizer(wx.HORIZONTAL)

        label_header = wx.StaticText(parent=panel1, 
            label="Import people to your Skype contacts from a CSV file, "
                  "like ones exported from MSN or GMail.\n"
                  "Skype needs to be running and logged in.\n\n"
                  "For exporting your MSN contacts, log in to hotmail.com "
                  "with your MSN account and find \"Export contacts\" under "
                  "Options.\n"
                  "For exporting your GMail contacts, log in to gmail.com and "
                  "find \"Export...\" under \"Contacts\" -> \"More\".")
        label_header.ForegroundColour = "grey"
        button_import = self.button_import_file = \
            wx.Button(panel1, label="Se&lect contacts file")
        button_import.Bind(wx.EVT_BUTTON, self.on_choose_import_file)
        sizer_header.Add(button_import, border=10,
                         flag=wx.RIGHT | wx.ALIGN_CENTER_VERTICAL)
        sizer_header.Add(label_header, border=60, flag=wx.LEFT)

        label_source = self.label_import_source = \
            wx.StaticText(parent=panel1, label="C&ontacts in source file:")
        sizer_top1.Add(label_source, flag=wx.ALIGN_BOTTOM)
        sizer_top1.AddStretchSpacer()
        label_filter = wx.StaticText(panel1, label="Filter c&ontacts:")
        sizer_top1.Add(label_filter, flag=wx.ALIGN_CENTER | wx.ALIGN_RIGHT | 
                       wx.RIGHT, border=5)
        edit_contactfilter = self.edit_contactfilter = wx.TextCtrl(
            parent=panel1, size=(75, -1))
        filter_tooltip = "Filter items in contact list"
        label_filter.SetToolTipString(filter_tooltip)
        edit_contactfilter.SetToolTipString(filter_tooltip)
        self.Bind(wx.EVT_TEXT, self.on_change_import_sourcefilter,
                  edit_contactfilter)
        sizer_top1.Add(edit_contactfilter, flag=wx.ALIGN_RIGHT)

        sourcelist = self.list_import_source = \
            controls.SortableListView(parent=panel1, style=wx.LC_REPORT)
        cols = [("name", "Name"), ("e-mail", "E-mail"), ("phone", "Phone")]
        sourcelist.SetColumns(cols)
        sourcelist.Bind(wx.EVT_LIST_ITEM_SELECTED,
                        self.on_select_import_sourcelist)
        sourcelist.Bind(wx.EVT_LIST_ITEM_DESELECTED,
                        self.on_select_import_sourcelist)
        sourcelist.Bind(wx.EVT_LIST_ITEM_ACTIVATED,
                        self.on_import_search)

        sizer1.Add(sizer_header, border=5, flag=wx.ALL)
        sizer1.Add(sizer_top1, border=5, flag=wx.ALL | wx.GROW)
        sizer1.Add(sourcelist, border=5, proportion=1,
                   flag=wx.GROW | wx.LEFT | wx.RIGHT)

        panel2 = wx.Panel(parent=splitter)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_buttons = wx.BoxSizer(wx.HORIZONTAL)
        button_search_selected = self.button_import_search_selected = \
            wx.Button(panel2, label="Search for selected contacts in Skype")
        button_select_all = self.button_import_select_all = \
            wx.Button(panel2, label="Select all")
        self.Bind(wx.EVT_BUTTON, self.on_import_search, button_search_selected)
        self.Bind(wx.EVT_BUTTON, self.on_import_select_all, button_select_all)
        button_search_selected.SetToolTipString("Search for the selected "
            "contacts through the running Skype application.")
        button_search_selected.Enabled = button_select_all.Enabled = False
        label_search = wx.StaticText(parent=panel2,
                                     label="Skype use&rbase search:")
        edit_search = self.edit_import_search_free = wx.TextCtrl(
            parent=panel2, size=(100, -1), style=wx.TE_PROCESS_ENTER)
        button_search_free = self.button_import_search_free = \
            wx.Button(panel2, label="Search in Skype")
        self.Bind(wx.EVT_TEXT_ENTER, self.on_import_search, edit_search)
        self.Bind(wx.EVT_BUTTON, self.on_import_search, button_search_free)
        for control in [label_search, edit_search, button_search_free]:
            control.SetToolTipString("Search for the entered value in "
                                     "Skype userbase.")

        sizer_buttons.Add(button_search_selected, flag=wx.ALIGN_LEFT)
        sizer_buttons.Add(button_select_all, border=5, flag=wx.LEFT)
        sizer_buttons.AddStretchSpacer()
        sizer_buttons.Add(label_search, flag=wx.ALIGN_CENTER_VERTICAL)
        sizer_buttons.Add(edit_search, border=5, flag=wx.LEFT)
        sizer_buttons.Add(button_search_free, border=5, flag=wx.LEFT)

        label_searchinfo = wx.StaticText(parent=panel2,
            label="Skype will be launched if not already running. Might bring "
                  "up a notification screen in Skype to allow access for "
                  "%s.\nSearching for many contacts at once can "
                  "take a long time." % conf.Title)
        label_searchinfo.ForegroundColour = "grey"

        sizer_resultlabel = wx.BoxSizer(wx.HORIZONTAL)
        label_result = self.label_import_result = \
            wx.StaticText(parent=panel2, label="Contacts found in Sk&ype:")
        resultlist = self.list_import_result = \
            controls.SortableListView(parent=panel2, style=wx.LC_REPORT)
        result_columns = [("#", "#"), ("FullName", "Name"),
            ("Handle", "Skype handle"), ("IsAuthorized", "Already added"),
            ("PhoneMobile", "Phone"), ("City", "City"), ("Country", "Country"),
            ("Sex", "Gender"), ("Birthday", "Birthday"),
            ("Language", "Language")]
        resultlist.SetColumns(result_columns)

        resultlist.Bind(
            wx.EVT_LIST_ITEM_SELECTED,   self.on_select_import_resultlist)
        resultlist.Bind(
            wx.EVT_LIST_ITEM_DESELECTED, self.on_select_import_resultlist)
        resultlist.Bind(wx.EVT_LIST_ITEM_ACTIVATED,self.on_import_add_contacts)

        sizer_footer = wx.BoxSizer(wx.HORIZONTAL)
        button_add = self.button_import_add = \
            wx.Button(panel2, label="Add the selected to your Skype contacts")

        label_filter = wx.StaticText(panel2, label="Filter res&ults:")
        edit_resultfilter = wx.TextCtrl(parent=panel2, size=(75, -1))
        filter_tooltip = "Filter items in Skype results list"
        label_filter.SetToolTipString(filter_tooltip)
        edit_resultfilter.SetToolTipString(filter_tooltip)
        self.Bind(wx.EVT_TEXT, self.on_change_import_resultfilter,
                  edit_resultfilter)
        button_clear = self.button_import_clear = \
            wx.Button(panel2, label="Clear selected from list")
        self.Bind(wx.EVT_BUTTON, self.on_import_add_contacts, button_add)
        self.Bind(wx.EVT_BUTTON, self.on_import_clear_contacts, button_clear)
        button_add.SetToolTipString("Opens an authorization request in Skype")
        button_add.Enabled = button_clear.Enabled = False
        sizer_footer.Add(button_add, flag=wx.ALIGN_LEFT)
        sizer_footer.AddStretchSpacer()
        sizer_footer.Add(label_filter, flag=wx.ALIGN_CENTER | wx.RIGHT, border=5)
        sizer_footer.Add(edit_resultfilter, flag=wx.wx.ALIGN_TOP)
        sizer_footer.Add(button_clear, flag=wx.ALIGN_RIGHT | wx.LEFT, border=20)

        sizer2.Add(sizer_buttons, border=5, flag=wx.GROW | wx.ALL)
        sizer_resultlabel.Add(label_result, flag=wx.ALIGN_BOTTOM)
        sizer_resultlabel.Add(label_searchinfo, border=60, flag=wx.LEFT)
        sizer2.Add(sizer_resultlabel, border=5, flag=wx.ALL)
        sizer2.Add(resultlist, border=5, proportion=1,
                   flag=wx.GROW | wx.LEFT | wx.RIGHT)
        sizer2.Add(sizer_footer, border=5, flag=wx.GROW | wx.ALL)

        sizer.Add(splitter, proportion=1, flag=wx.GROW)
        splitter.SplitHorizontally(panel1, panel2,
                                   sashPosition=self.Size[1]*2/5)


    def create_page_info(self, notebook):
        """Creates a page for seeing general database information."""
        page = self.page_info = wx.lib.scrolledpanel.ScrolledPanel(notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Information")
        sizer = page.Sizer = wx.BoxSizer(wx.HORIZONTAL)

        panel1 = self.panel_accountinfo = wx.Panel(parent=page)
        panel2 = wx.Panel(parent=page)
        panel1.BackgroundColour = panel2.BackgroundColour = conf.BgColour
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_account = wx.BoxSizer(wx.HORIZONTAL)
        label_account = wx.StaticText(parent=panel1,
                                      label="Main account information")
        label_account.Font = wx.Font(10, wx.FONTFAMILY_SWISS,
            wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, face=self.Font.FaceName)
        sizer1.Add(label_account, border=5, flag=wx.ALL)

        account = self.db.account or {}
        bmp_panel = wx.Panel(parent=panel1)
        bmp_panel.Sizer = wx.BoxSizer(wx.VERTICAL)
        bmp = images.AvatarDefaultLarge.Bitmap
        bmp_static = self.bmp_account = wx.StaticBitmap(bmp_panel, bitmap=bmp)
        sizer_accountinfo = wx.FlexGridSizer(cols=2, vgap=3, hgap=10)
        self.sizer_accountinfo = sizer_accountinfo
        sizer_accountinfo.AddGrowableCol(1, 1)

        bmp_panel.Sizer.Add(bmp_static, border=2, flag=wx.GROW | wx.TOP)
        sizer_account.Add(bmp_panel, border=10, flag=wx.LEFT | wx.RIGHT)
        sizer_account.Add(sizer_accountinfo, proportion=1, flag=wx.GROW)
        sizer1.Add(sizer_account, border=20, proportion=1,
                   flag=wx.TOP | wx.GROW)

        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_file = wx.FlexGridSizer(cols=2, vgap=3, hgap=10)
        label_file = wx.StaticText(parent=panel2, label="Database information")
        label_file.Font = wx.Font(10, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL,
                                  wx.FONTWEIGHT_BOLD, face=self.Font.FaceName)
        sizer2.Add(label_file, border=5, flag=wx.ALL)

        names = ["edit_info_chats", "edit_info_contacts",
                 "edit_info_transfers", "edit_info_messages",
                 "edit_info_lastmessage", "edit_info_firstmessage", "",
                 "edit_info_path", "edit_info_size", "edit_info_modified",
                 "edit_info_sha1", "edit_info_md5", ]
        labels = ["Conversations", "Contacts", "File transfers", "Messages",
                  "Last message", "First message", "", 
                  "Full path", "File size", "Last modified",
                  "SHA-1 checksum", "MD5 checksum",  ]
        for name, label in zip(names, labels):
            if not name and not label:
                sizer_file.AddSpacer(20), sizer_file.AddSpacer(20)
                continue # continue for i, (name, label) in enumerate(..
            labeltext = wx.StaticText(parent=panel2, label="%s:" % label)
            labeltext.ForegroundColour = wx.Colour(102, 102, 102)
            valuetext = wx.TextCtrl(parent=panel2, value="Analyzing..",
                style=wx.NO_BORDER | wx.TE_MULTILINE | wx.TE_RICH)
            valuetext.MinSize = (-1, 35)
            valuetext.BackgroundColour = panel2.BackgroundColour
            valuetext.SetEditable(False)
            sizer_file.Add(labeltext, border=5, flag=wx.LEFT)
            sizer_file.Add(valuetext, proportion=1, flag=wx.GROW)
            setattr(self, name, valuetext)
        self.edit_info_path.Value = self.db.filename

        button_check = self.button_check_integrity = \
            wx.Button(parent=panel2, label="Check for corruption")
        button_refresh = self.button_refresh_fileinfo = \
            wx.Button(parent=panel2, label="Refresh")
        button_check.Enabled = button_refresh.Enabled = False
        button_check.SetToolTipString("Check database integrity for "
                                      "corruption and recovery.")
        sizer_file.Add(button_check)
        sizer_file.Add(button_refresh, border=15,
                       flag=wx.ALIGN_RIGHT | wx.RIGHT)
        self.Bind(wx.EVT_BUTTON, self.on_check_integrity, button_check)
        self.Bind(wx.EVT_BUTTON, lambda e: self.update_info_page(),
                  button_refresh)

        sizer_file.AddGrowableCol(1, 1)
        sizer2.Add(sizer_file, border=20, proportion=1, flag=wx.TOP | wx.GROW)

        sizer.Add(panel1, proportion=1, border=5,
                  flag=wx.LEFT  | wx.TOP | wx.BOTTOM | wx.GROW)
        sizer.Add(panel2, proportion=1, border=5,
                  flag=wx.RIGHT | wx.TOP | wx.BOTTOM | wx.GROW)
        self.update_accountinfo()
        page.SetupScrolling()


    def on_check_integrity(self, event):
        """
        Handler for checking database integrity, offers to save a fixed
        database if corruption detected.
        """
        msg = "Checking integrity of %s." % self.db.filename
        main.logstatus_flash(msg)
        busy = controls.BusyPanel(self, msg)
        wx.YieldIfNeeded()
        try:
            errors = self.db.check_integrity()
        except Exception as e:
            errors = [e.message]
        busy.Close()
        main.status_flash("")
        if not errors:
            wx.MessageBox("No database errors detected.",
                          conf.Title, wx.ICON_INFORMATION)
        else:
            err = "\n- ".join(errors)
            main.log("Errors found in %s: %s", self.db, err)
            err = err[:500] + ".." if len(err) > 500 else err
            msg = "A number of errors were found in %s:\n\n- %s\n\n" \
                  "Recover as much as possible to a new database?" % \
                  (self.db, err)
            if wx.YES == wx.MessageBox(msg, conf.Title,
                                       wx.ICON_INFORMATION | wx.YES | wx.NO):
                directory, filename = os.path.split(self.db.filename)
                base = os.path.splitext(filename)[0]
                self.dialog_savefile.Directory = directory
                self.dialog_savefile.Filename = "%s (recovered)" % base
                self.dialog_savefile.Message = "Save recovered data as"
                self.dialog_savefile.Wildcard = "Skype database (*.db)|*.db"
                self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT
                if wx.ID_OK == self.dialog_savefile.ShowModal():
                    newfile = self.dialog_savefile.GetPath()
                    if not newfile.lower().endswith(".db"): newfile += ".db"
                    if newfile != self.db.filename:
                        main.status_flash("Recovering data from %s to %s.",
                                          self.db.filename, newfile)
                        m = "Recovering data from %s\nto %s."
                        busy = controls.BusyPanel(self, m % (self.db, newfile))
                        wx.YieldIfNeeded()
                        try:
                            copyerrors = self.db.recover_data(newfile)
                        finally:
                            busy.Close()
                        err = ("\n\nErrors occurred during the recovery, "
                              "more details in log window:\n\n- "
                              + "\n- ".join(copyerrors)) if copyerrors else ""
                        err = err[:500] + ".." if len(err) > 500 else err
                        main.status_flash("Recovery to %s complete." % newfile)
                        wx.MessageBox("Recovery to %s complete.%s" %
                                      (newfile, err), conf.Title,
                                      wx.ICON_INFORMATION)
                        util.start_file(os.path.dirname(newfile))
                    else:
                        wx.MessageBox("Cannot recover data from %s to itself."
                                      % self.db, conf.Title, wx.ICON_WARNING)


    def update_accountinfo(self):
        """Updates the account information page, clearing its former data."""
        sizer, panel = self.sizer_accountinfo, self.panel_accountinfo
        panel.Freeze()
        account = self.db.account or {}
        bmp = skypedata.get_avatar(account) or images.AvatarDefaultLarge.Bitmap
        self.bmp_account.SetBitmap(bmp)
        [sizer.Remove(0) for i in sizer.Children]

        fields = ["fullname", "skypename", "mood_text", "phone_mobile",
                  "phone_home", "phone_office", "emails", "country",
                  "province", "city", "homepage", "gender", "birthday",
                  "languages", "nrof_authed_buddies", "about",
                  "skypeout_balance", ]

        for field in fields:
            if field in account and account[field]:
                value = account[field]
                if "emails" == field:
                    value = ", ".join(value.split(" "))
                elif "gender" == field:
                    value = {1: "male", 2: "female"}.get(value, "")
                elif "birthday" == field:
                    try:
                        value = str(value)
                        value = "-".join([value[:4], value[4:6], value[6:]])
                    except Exception as e:
                        pass
                if value:
                    if "skypeout_balance" == field:
                        value = value / (
                                10.0 ** account.get("skypeout_precision", 2))
                        value = "%s %s" % (value,
                                account.get("skypeout_balance_currency", ""))
                    if not isinstance(value, basestring):
                        value = str(value) 
                    title = skypedata.ACCOUNT_FIELD_TITLES.get(field, field)
                    lbltext = wx.StaticText(parent=panel, label="%s:" % title)
                    valtext = wx.TextCtrl(parent=panel, value=value,
                        style=wx.NO_BORDER | wx.TE_MULTILINE | wx.TE_RICH)
                    valtext.BackgroundColour = panel.BackgroundColour
                    valtext.MinSize = (-1, 35)
                    valtext.SetEditable(False)
                    lbltext.ForegroundColour = wx.Colour(102, 102, 102)
                    sizer.Add(lbltext, border=5, flag=wx.LEFT)
                    sizer.Add(valtext, proportion=1, flag=wx.GROW)
        panel.Layout()
        panel.Thaw()


    def save_page_conf(self):
        """Saves page last configuration like search text and results."""

        # Save search box state
        if conf.SearchHistory[-1:] == [""]: # Clear empty search flag
            conf.SearchHistory = conf.SearchHistory[:-1]
        util.add_unique(conf.SearchHistory, self.edit_searchall.Value,
                        1, conf.MaxSearchHistory)

        # Save last search results HTML
        search_data = self.html_searchall.GetActiveTabData()
        if search_data:
            info = {}
            if search_data.get("info"):
                info["map"] = search_data["info"].get("map")
                info["text"] = search_data["info"].get("text")
            data = {"content": search_data["content"],
                    "id": search_data["id"], "info": info,
                    "title": search_data["title"], }
            conf.LastSearchResults[self.db.filename] = data
        elif self.db.filename in conf.LastSearchResults:
            del conf.LastSearchResults[self.db.filename]

        # Save page SQL window content, if changed from previous value
        sql_text = self.stc_sql.Text
        if sql_text != conf.SQLWindowTexts.get(self.db.filename, ""):
            if sql_text:
                conf.SQLWindowTexts[self.db.filename] = sql_text
            elif self.db.filename in conf.SQLWindowTexts:
                del conf.SQLWindowTexts[self.db.filename]


    def split_panels(self):
        """
        Splits all SplitterWindow panels. To be called after layout in
        Linux wx 2.8, as otherwise panels do not get sized properly.
        """
        if not self:
            return
        sash_pos = self.Size[1] / 3
        panel1, panel2 = self.splitter_chats.Children
        self.splitter_chats.Unsplit()
        self.splitter_chats.SplitHorizontally(panel1, panel2, sash_pos)
        panel1, panel2 = self.splitter_tables.Children
        self.splitter_tables.Unsplit()
        self.splitter_tables.SplitVertically(panel1, panel2, 270)
        panel1, panel2 = self.splitter_sql.Children
        self.splitter_sql.Unsplit()
        self.splitter_sql.SplitHorizontally(panel1, panel2, sash_pos)
        panel1, panel2 = self.splitter_import.Children
        self.splitter_import.Unsplit()
        self.splitter_import.SplitHorizontally(panel1, panel2, sash_pos)
        wx.CallLater(1000, lambda: self and 
                     (self.tree_tables.SetColumnWidth(0, -1),
                      self.tree_tables.SetColumnWidth(1, -1)))


    def update_info_page(self, reload=True):
        """Updates the Information page with current data."""
        if reload:
            self.db.clear_cache()
            self.db.update_fileinfo()
            self.db.update_accountinfo()
            self.update_accountinfo()
        for name in ["chats", "contacts", "messages", "transfers",
        "lastmessage", "firstmessage", "size", "modified", "sha1", "md5"]:
            getattr(self, "edit_info_%s" % name).Value = ""
        stats = {}
        try:
            stats = self.db.get_general_statistics()
        except Exception: pass
        if stats:
            self.edit_info_chats.Value = "%(chats)s" % stats
            self.edit_info_contacts.Value = "%(contacts)s" % stats
            self.edit_info_messages.Value = "%(messages)s" % stats
            self.edit_info_transfers.Value = "%(transfers)s" % stats
        if "messages_from" in stats:
            self.edit_info_messages.Value += " (%s sent and %s received)" % \
                (stats.get("messages_from"), stats.get("messages_to"))
        text = ""
        if "lastmessage_dt" in stats:
            text = "%(lastmessage_dt)s %(lastmessage_from)s" % stats
        if stats and (stats.get("lastmessage_skypename") == self.db.id
        or skypedata.CHATS_TYPE_SINGLE != stats.get("lastmessage_chattype")):
            text += " in %(lastmessage_chat)s" % stats
        self.edit_info_lastmessage.Value = text
        text = ""
        if "firstmessage_dt" in stats:
            text = "%(firstmessage_dt)s %(firstmessage_from)s" % stats
        if stats and (stats.get("firstmessage_skypename") == self.db.id
        or skypedata.CHATS_TYPE_SINGLE != stats.get("firstmessage_chattype")):
            text += " in %(firstmessage_chat)s" % stats
        self.edit_info_firstmessage.Value = text

        self.edit_info_size.Value = "%s (%s)" % \
            (util.format_bytes(self.db.filesize),
             util.format_bytes(self.db.filesize, max_units=False))
        self.edit_info_modified.Value = \
            self.db.last_modified.strftime("%Y-%m-%d %H:%M:%S")
        BLOCKSIZE = 1048576
        sha1, md5 = hashlib.sha1(), hashlib.md5()
        try:
            with open(self.db.filename, "rb") as f:
                buf = f.read(BLOCKSIZE)
                while len(buf):
                    sha1.update(buf), md5.update(buf)
                    buf = f.read(BLOCKSIZE)
            self.edit_info_sha1.Value = sha1.hexdigest()
            self.edit_info_md5.Value = md5.hexdigest()
        except Exception as e:
            self.edit_info_sha1.Value = self.edit_info_md5.Value = u"%s" % e
        self.button_check_integrity.Enabled = True
        self.button_refresh_fileinfo.Enabled = True


    def on_refresh_tables(self, event):
        """
        Refreshes the table tree and open table data. Asks for confirmation
        if there are uncommitted changes.
        """
        do_refresh, unsaved = True, self.get_unsaved_grids()
        if unsaved:
            response = wx.MessageBox("Some tables have unsaved data (%s).\n\n"
                "Save before refreshing (changes will be lost otherwise)?"
                % (", ".join(sorted(x.table for x in unsaved))), conf.Title,
                wx.YES | wx.NO | wx.CANCEL | wx.ICON_INFORMATION)
            if wx.YES == response:
                self.save_unsaved_grids()
            elif wx.CANCEL == response:
                do_refresh = False
        if do_refresh:
            self.db.clear_cache()
            self.db_grids.clear()
            self.load_tables_data()
            if self.grid_table.Table:
                grid, table_name = self.grid_table, self.grid_table.Table.table
                scrollpos = map(grid.GetScrollPos, [wx.HORIZONTAL, wx.VERTICAL])
                cursorpos = grid.GridCursorCol, grid.GridCursorRow
                self.on_change_table(None)
                grid.Table = wx.grid.PyGridTableBase() # Clear grid visually
                grid.Freeze()
                grid.Table = None # Reset grid data to empty

                tableitem = None
                table_name = table_name.lower()
                table = next((t for t in self.db.get_tables()
                              if t["name"].lower() == table_name), None)
                item = self.tree_tables.GetNext(self.tree_tables.RootItem)
                while table and item and item.IsOk():
                    table2 = self.tree_tables.GetItemPyData(item)
                    if table2 and table2.lower() == table["name"].lower():
                        tableitem = item
                        break # break while table and item and itek.IsOk()
                    item = self.tree_tables.GetNextSibling(item)
                if tableitem:
                    # Only way to create state change in wx.gizmos.TreeListCtrl
                    class HackEvent(object):
                        def __init__(self, item): self._item = item
                        def GetItem(self):        return self._item
                    self.on_change_tree_tables(HackEvent(tableitem))
                    self.tree_tables.SelectItem(tableitem)
                    grid.Scroll(*scrollpos)
                    grid.SetGridCursor(*cursorpos)
                else:
                    self.label_table.Label = ""
                    for x in [wx.ID_ADD, wx.ID_DELETE, wx.ID_UNDO, wx.ID_SAVE]:
                        self.tb_grid.EnableTool(x, False)
                    self.button_reset_grid_table.Enabled = False
                    self.button_export_table.Enabled = False
                grid.Thaw()
                self.page_tables.Refresh()


    def on_change_import_resultfilter(self, event):
        """
        Handler for changing text in contacts import result filter box,
        filters Skype userbase results list.
        """
        self.list_import_result.SetFilter(event.String.strip())
        


    def on_change_chatfilter(self, event):
        """Handler for changing text in chat filter box, filters chat list."""
        self.list_chats.SetFilter(event.String.strip())


    def on_change_import_sourcefilter(self, event):
        """
        Handler for changing text in contacts import source filter box,
        filters contacts source list.
        """
        self.list_import_source.SetFilter(event.String.strip())


    def on_change_import_resultfilter(self, event):
        """
        Handler for changing text in contacts import result filter box,
        filters contacts found in Skype.
        """
        self.list_import_result.SetFilter(event.String.strip())


    def on_choose_import_file(self, event):
        """Handler for clicking to choose a CSV file for contact import."""
        contacts = None
        if wx.ID_OK == self.dialog_importfile.ShowModal():
            filename = self.dialog_importfile.GetPath()
            try:
                contacts = skypedata.import_contacts_file(filename)
            except Exception as e:
                errormsg = "Error reading \"%s\".\n\n%s" % (filename, e)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)
        if contacts is not None:
            self.list_import_result.DeleteAllItems()
            self.list_import_source.Populate(contacts)
            self.button_import_add.Enabled = False
            self.button_import_clear.Enabled = False
            self.button_import_search_selected.Enabled = False
            self.label_import_source.Label = \
                "C&ontacts in source file %s [%s]:" % (filename, len(contacts))
            self.label_import_result.Label = "Contacts found in Sk&ype:"
            self.button_import_select_all.Enabled = len(contacts)
            main.logstatus_flash("Found %s in file %s.",
                                 util.plural("contact", contacts), filename)


    def on_select_import_sourcelist(self, event):
        """
        Handler when a row is selected in the import contacts source list,
        enables UI buttons.
        """
        count = self.list_import_source.GetSelectedItemCount()
        self.button_import_search_selected.Enabled = (count > 0)


    def on_select_import_resultlist(self, event):
        """
        Handler when a row is selected in the import contacts result list,
        enables UI buttons.
        """
        count = self.list_import_result.GetSelectedItemCount()
        self.button_import_add.Enabled = (count > 0)
        self.button_import_clear.Enabled = (count > 0)


    def on_import_select_all(self, event):
        """Handler for clicking to select all imported contacts."""
        [self.list_import_source.Select(i)
         for i in range(self.list_import_source.ItemCount)]
        self.list_import_source.SetFocus()


    def on_import_search(self, event):
        """
        Handler for choosing to search Skype for contacts in the import source
        list.
        """
        if not self.skype_handler:
            msg = "Skype4Py not installed, cannot search."
            return wx.MessageBox(msg, conf.Title, wx.OK | wx.ICON_WARNING)
        search_values = []
        lst, lst2 = self.list_import_source, self.list_import_result
        if event.EventObject in [self.button_import_search_free,
                                 self.edit_import_search_free]:
            value = self.edit_import_search_free.Value.strip()
            if value:
                search_values.append(value)
                infotext = "Searching Skype userbase for \"%s\"." % value
        else:
            values_unique, contacts_unique = set(), set()
            selected = lst.GetFirstSelected()
            while selected >= 0:
                contact = lst.GetItemMappedData(selected)
                for key in ["name", "phone", "e-mail"]:
                    if contact[key] and contact[key] not in values_unique:
                        search_values.append(contact[key])
                        values_unique.add(contact[key])
                        contacts_unique.add(id(contact))
                selected = lst.GetNextSelected(selected)
            info = "\"%s\"" % "\", \"".join(search_values)
            if len(info) > 60:
                info = info[:60] + ".."
            infotext = "Searching Skype userbase for %s (%s)." \
                        % (util.plural("contact", contacts_unique), info)
        if search_values:
            main.logstatus_flash(infotext)
            lst2.DeleteAllItems()
            self.button_import_add.Enabled = False
            self.button_import_clear.Enabled = False

            found = {} # { Skype handle: user data, }
            data = {"id": wx.NewId(), "handler": self.skype_handler,
                    "values": search_values}
            self.search_data_contact.update(data)
            self.worker_search_contacts.work(data)
            self.label_import_result.Label = "Contacts found in Sk&ype:"


    def on_search_contacts_result(self, event):
        """
        Handler for getting results from contact search thread, adds the
        results to the import list.
        """
        result = event.result
        # If search ID is different, results are from the previous search still
        lst2 = self.list_import_result
        if result["search"]["id"] == self.search_data_contact["id"]:
            lst2.Freeze()
            scrollpos = lst2.GetScrollPos(wx.VERTICAL)

            for user in result["results"]:
                data = {"user": user, "#": lst2.GetItemCountFull() + 1, }
                for k in ["FullName", "Handle", "IsAuthorized", "PhoneMobile",
                          "City", "Country", "Sex", "Birthday", "Language"]:
                    val = getattr(user, k)
                    if "IsAuthorized" == k:
                        val = "Yes" if val else "No"
                    elif "Sex" == k:
                        val = "" if ("UNKNOWN" == val) else val.lower()
                    data[k] = val
                lst2.AppendRow(data)
                if user.IsAuthorized:
                    lst2.SetItemTextColour(lst2.ItemCount - 1, "gray")

            lst2.SetScrollPos(wx.VERTICAL, scrollpos)
            lst2.Thaw()
            self.label_import_result.Label = \
                "Contacts found in Sk&ype [%s]:" % lst2.ItemCount
            if "done" in result:
                wx.Bell()
                main.logstatus_flash("Found %s in Skype userbase.",
                                     util.plural("contact", lst2.ItemCount))
            lst2.Update()


    def on_import_add_contacts(self, event):
        """
        Handler for adding an imported contact in Skype, opens an authorization
        request window in Skype.
        """
        lst = self.list_import_result
        selected, contacts = lst.GetFirstSelected(), []
        while selected >= 0:
            contacts.append(lst.GetItemMappedData(selected))
            selected = lst.GetNextSelected(selected)
        info = ", ".join([c["Handle"] for c in contacts])
        if len(info) > 60:
            info = info[:60] + ".."
        msg = "Add %s to your Skype contacts (%s)?" % (
              util.plural("person", contacts), info)
        if self.skype_handler and wx.OK == wx.MessageBox(msg,
            conf.Title, wx.OK | wx.CANCEL | wx.ICON_QUESTION
        ):
            busy = controls.BusyPanel(self,
                "Adding %s to your Skype contacts."
                % util.plural("person", contacts)
            )
            try:
                self.skype_handler.add_to_contacts(c["user"] for c in contacts)
                main.logstatus_flash("Added %s to your Skype contacts (%s).",
                                     util.plural("person", contacts), info)
            except Exception as e:
                msg = "Error adding contacts:\n\n%s" % traceback.format_exc()
                main.logstatus_flash(msg)
                wx.MessageBox(msg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, msg)
            finally:
                busy.Close()


    def on_import_clear_contacts(self, event):
        """
        Handler for clicking to remove selected items from contact import
        result list.
        """
        selected, selecteds = self.list_import_result.GetFirstSelected(), []
        while selected >= 0:
            selecteds.append(selected)
            selected = self.list_import_result.GetNextSelected(selected)
        for i in range(len(selecteds)):
            # - i, as item count is getting smaller one by one
            selected = selecteds[i] - i
            data = self.list_import_result.GetItemMappedData(selected)
            self.list_import_result.DeleteItem(selected)
        self.label_import_result.Label = "Contacts found in Sk&ype [%s]:" \
                                         % self.list_import_result.ItemCount
        self.button_import_add.Enabled = False
        self.button_import_clear.Enabled = False


    def on_export_chat(self, event):
        """
        Handler for clicking to export a chat, displays a save file dialog and
        saves the current messages to file.
        """
        formatargs = collections.defaultdict(str); formatargs.update(self.chat)
        default = util.safe_filename(conf.ExportChatTemplate % formatargs)
        self.dialog_savefile.Filename = default
        self.dialog_savefile.Message = "Save chat"
        self.dialog_savefile.Wildcard = export.CHAT_WILDCARD
        self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT
        if wx.ID_OK == self.dialog_savefile.ShowModal():
            filepath = self.dialog_savefile.GetPath()
            dirname = os.path.dirname(filepath)
            filename = os.path.basename(filepath)
            extname = export.CHAT_EXTS[self.dialog_savefile.FilterIndex]
            if not filename.lower().endswith(".%s" % extname):
                filename += ".%s" % extname
                filepath = os.path.join(dirname, filename)
            busy = controls.BusyPanel(
                self, "Exporting \"%s\"." % self.chat["title"]
            )
            main.status_flash("Exporting to %s.", filepath)
            try:
                messages = self.stc_history.GetMessages()
                progressfunc = lambda *args: wx.SafeYield()
                export.export_chats([self.chat], dirname, filename, self.db,
                    messages=messages, skip=False, progress=progressfunc)
                main.status_flash("Exported %s.", filepath)
                util.start_file(filepath)
            except Exception as e:
                errormsg = "Error saving %s:\n\n%s" % \
                           (filepath, traceback.format_exc())
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)
            finally:
                busy.Close()


    def on_export_chats_menu(self, event):
        """
        Handler for clicking to export selected or all chats, displays a 
        submenu with choices to export selected chats or all chats.
        """
        selected, selecteds = self.list_chats.GetFirstSelected(), []
        while selected >= 0:
            selecteds.append(selected)
            selected = self.list_chats.GetNextSelected(selected)

        menu = wx.lib.agw.flatmenu.FlatMenu()
        item_sel = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
               "Export selected chats into individual files")
        item_sel.Enable(len(selecteds))
        menu.AppendItem(item_sel)
        if export.xlsxwriter:
            item_sel2 = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
                "Export selected into a single Excel workbook, "
                "with separate sheets")
            item_sel2.Enable(len(selecteds))
            menu.AppendItem(item_sel2)
        menu.AppendSeparator()
        item_all = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
               "Export all chats into individual files")
        item_all.Enable(len(self.chats))
        menu.AppendItem(item_all)
        if export.xlsxwriter:
            item_all2 = wx.lib.agw.flatmenu.FlatMenuItem(menu, wx.NewId(),
                "Export all into a single Excel workbook, "
                "with separate sheets")
            item_all2.Enable(len(self.chats))
            menu.AppendItem(item_all2)
        for item in menu.GetMenuItems():
            self.Bind(wx.EVT_MENU, self.on_export_chats, item)

        sz_btn, pt_btn = event.EventObject.Size, event.EventObject.Position
        pt_btn = event.EventObject.Parent.ClientToScreen(pt_btn)
        menu.SetOwnerHeight(sz_btn.y)
        if menu.Size.width < sz_btn.width:
            menu.Size = sz_btn.width, menu.Size.height
        menu.Popup(pt_btn, self)


    def on_export_chats(self, event):
        """
        Handler for clicking to export selected or all chats, displays a select
        folder dialog and exports chats to individual files under the folder.
        """
        chats = [self.list_chats.GetItemMappedData(i)
                 for i in range(self.list_chats.ItemCount)]

        # Find menuitem index and label from original menu by event ID
        nitems = enumerate(event.EventObject.GetMenuItems())
        index = next((i for i, m in nitems if m.GetId() == event.Id), None)
        do_all = index > 1
        do_singlefile = index in [1, 4]

        if not do_all:
            selected, chats = self.list_chats.GetFirstSelected(), []
            while selected >= 0:
                chats.append(self.list_chats.GetItemMappedData(selected))
                selected = self.list_chats.GetNextSelected(selected)
        self.dialog_savefile.Message = "Choose folder where to save chat files"
        self.dialog_savefile.Filename = "Filename will be ignored"
        self.dialog_savefile.Wildcard = export.CHAT_WILDCARD
        self.dialog_savefile.WindowStyle ^= wx.FD_OVERWRITE_PROMPT
        if chats and do_singlefile:
            formatargs = collections.defaultdict(str)
            formatargs["skypename"] = os.path.basename(self.db.filename)
            formatargs.update(self.db.account or {})
            default = util.safe_filename(conf.ExportDbTemplate % formatargs)
            self.dialog_savefile.Filename = default
            self.dialog_savefile.Message = "Save chats file"
            self.dialog_savefile.Wildcard = export.CHAT_WILDCARD_SINGLEFILE
            self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT
        if chats and wx.ID_OK == self.dialog_savefile.ShowModal():
            dirname = os.path.dirname(self.dialog_savefile.GetPath())
            if do_singlefile:
                index = self.dialog_savefile.FilterIndex
                extname = export.CHAT_EXTS_SINGLEFILE[index]
                format = os.path.basename(self.dialog_savefile.GetPath())
            else:
                extname = export.CHAT_EXTS[self.dialog_savefile.FilterIndex]
                format = extname

            msg = "Exporting %s from \"%s\"\nas %s under %s." % \
                (util.plural("chat", chats), self.db.filename,
                 extname.upper(), dirname)
            busy = controls.BusyPanel(self, msg)
            main.logstatus(msg)
            files, count, errormsg = [], 0, None
            try:
                progressfunc = lambda *args: wx.SafeYield()
                files, count = export.export_chats(chats, dirname, format,
                    self.db, skip=do_all, progress=progressfunc)
            except Exception:
                errormsg = "Error exporting chats:\n\n%s" % \
                           traceback.format_exc()
            busy.Close()
            if not errormsg:
                main.logstatus_flash("Exported %s from %s as %s under %s.",
                                     util.plural("chat", count), self.db,
                                     extname.upper(), dirname)
                util.start_file(dirname if len(files) > 1 else files[0])
            else:
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)


    def on_filterexport_chat(self, event):
        """
        Handler for clicking to export a chat filtering straight to file,
        displays a save file dialog and saves all filtered messages to file.
        """
        formatargs = collections.defaultdict(str); formatargs.update(self.chat)
        default = conf.ExportChatTemplate % formatargs
        self.dialog_savefile.Filename = util.safe_filename(default)
        self.dialog_savefile.Message = "Save chat"
        self.dialog_savefile.Wildcard = export.CHAT_WILDCARD
        self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT
        if wx.ID_OK == self.dialog_savefile.ShowModal():
            filepath = self.dialog_savefile.GetPath()
            filename = os.path.basename(filepath)
            dirname = os.path.dirname(filepath)
            extname = export.CHAT_EXTS[self.dialog_savefile.FilterIndex]
            if not filename.lower().endswith(".%s" % extname):
                filename += ".%s" % extname
                filepath = os.path.join(dirname, extname)

            busy = controls.BusyPanel(self,
                   "Filtering and exporting \"%s\"." % self.chat["title"])
            try:
                filter_new = self.build_filter()
                filter_backup = self.stc_history.GetFilter()
                self.stc_history.SetFilter(filter_new)
                self.stc_history.RetrieveMessagesIfNeeded()
                messages_all = self.stc_history.GetRetrievedMessages()
                messages = [m for m in messages_all
                            if not self.stc_history.IsMessageFilteredOut(m)]
                self.stc_history.SetFilter(filter_backup)
                if messages:
                    main.logstatus("Filtering and exporting to %s.", filepath)
                    progressfunc = lambda *args: wx.SafeYield()
                    export.export_chats([self.chat], dirname, filename, self.db,
                        messages=messages, progress=progressfunc)
                    main.logstatus_flash("Exported %s.", filepath)
                    util.start_file(filepath)
                else:
                    wx.MessageBox("Current filter leaves no data to export.",
                                  conf.Title, wx.OK | wx.ICON_INFORMATION)
            except Exception:
                errormsg = "Error saving %s:\n\n%s" % \
                           (filepath, traceback.format_exc())
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)
            finally:
                busy.Close()


    def on_size_html_stats(self, event):
        """Handler for sizing html_stats, sets new scroll position based
        previously stored one (HtmlWindow loses its scroll position on resize).
        """
        html = self.html_stats
        if hasattr(html, "_last_scroll_pos"):
            for i in range(2):
                orient = wx.VERTICAL if i else wx.HORIZONTAL
                # Division can be > 1 on first resizings, bound it to 1.
                ratio = min(1, util.safedivf(html._last_scroll_pos[i],
                    html._last_scroll_range[i]
                ))
                html._last_scroll_pos[i] = ratio * html.GetScrollRange(orient)
            # Execute scroll later as something resets it after this handler
            scroll_func = lambda: html and html.Scroll(*html._last_scroll_pos)
            wx.CallLater(50, scroll_func)
        event.Skip() # Allow event to propagate wx handler


    def on_select_participant(self, event):
        """
        Handler for selecting an item the in the participants list, toggles
        its checked state.
        """
        idx = event.GetIndex()
        if idx < self.list_participants.GetItemCount():
            c = self.list_participants.GetItem(idx)
            c.Check(not c.IsChecked())
            self.list_participants.SetItem(c)
            self.list_participants.Refresh() # Notify list of data change


    def on_scroll_grid_sql(self, event):
        """
        Handler for scrolling the SQL grid, seeks ahead if nearing the end of
        retrieved rows.
        """
        event.Skip()
        # Execute seek later, to give scroll position time to update
        wx.CallLater(50, self.seekahead_grid_sql)


    def seekahead_grid_sql(self):
        """Seeks ahead on the SQL grid if scroll position nearing the end."""
        SEEKAHEAD_POS_RATIO = 0.8
        scrollpos = self.grid_sql.GetScrollPos(wx.VERTICAL)
        scrollrange = self.grid_sql.GetScrollRange(wx.VERTICAL)
        if scrollpos > scrollrange * SEEKAHEAD_POS_RATIO:
            scrollpage = self.grid_sql.GetScrollPageSize(wx.VERTICAL)
            to_end = (scrollpos + scrollpage == scrollrange)
            # Seek to end if scrolled to the very bottom
            self.grid_sql.Table.SeekAhead(to_end)


    def on_scroll_html_stats(self, event):
        """
        Handler for scrolling the HTML stats, stores scroll position
        (HtmlWindow loses it on resize).
        """
        wx.CallAfter(self.store_html_stats_scroll)
        event.Skip() # Allow event to propagate wx handler


    def store_html_stats_scroll(self):
        """
        Stores the statistics HTML scroll position, needed for getting around
        its quirky scroll updating.
        """
        if not self:
            return
        self.html_stats._last_scroll_pos = [
            self.html_stats.GetScrollPos(wx.HORIZONTAL),
            self.html_stats.GetScrollPos(wx.VERTICAL)
        ]
        self.html_stats._last_scroll_range = [
            self.html_stats.GetScrollRange(wx.HORIZONTAL),
            self.html_stats.GetScrollRange(wx.VERTICAL)
        ]
        

    def on_click_html_stats(self, event):
        """
        Handler for clicking a link in chat history statistics, scrolls to
        anchor if anchor link, sorts the statistics if sort link, otherwise
        shows the history and finds the word clicked in the word cloud.
        """
        href = event.GetLinkInfo().Href
        if href.startswith("#") and self.html_stats.HasAnchor(href[1:]):
            self.html_stats.ScrollToAnchor(href[1:])
            wx.CallAfter(self.store_html_stats_scroll)
        elif href.startswith("file://"):
            filepath = urllib.url2pathname(href[5:])
            if filepath and os.path.exists(filepath):
                util.start_file(filepath)
            else:
                messageBox(
                    "The file \"%s\" cannot be found on this computer."
                    % (filepath),
                    conf.Title, wx.OK | wx.ICON_INFORMATION
                )
        elif href.startswith("sort://"):
            self.stats_sort_field = href[7:]
            self.populate_chat_statistics()
        else:
            self.stc_history.SearchBarVisible = True
            self.show_stats(False)
            self.stc_history.Search(href, flags=wx.stc.STC_FIND_WHOLEWORD)
            self.stc_history.SetFocusSearch()


    def on_click_searchall_result(self, event):
        """
        Handler for clicking a link in HtmlWindow, opens the link in default
        browser.
        """
        href = event.GetLinkInfo().Href
        link_data, tab_data = None, None
        if event.EventObject != self.label_html:
            tab_data = self.html_searchall.GetActiveTabData()
        if tab_data and tab_data.get("info"):
            link_data = tab_data["info"]["map"].get(href, {})
        if link_data or href.startswith("file://"):
            chat_id = link_data.get("chat")
            message_id = link_data.get("message")
            file = link_data.get("file")
            table_name, row = link_data.get("table"), link_data.get("row")
            if file or href.startswith("file://"):
                if file:
                    filename = file["filepath"] or file["filename"]
                    path = file["filepath"]
                else:
                    filename = path = filepath = urllib.url2pathname(href[5:])

                if path and os.path.exists(path):
                    util.start_file(path)
                else:
                    messageBox(
                        "The file \"%s\" cannot be found on this computer." %
                        filename, conf.Title, wx.OK | wx.ICON_INFORMATION)
            elif chat_id:
                self.notebook.SetSelection(self.pageorder[self.page_chats])
                c = next((c for c in self.chats if chat_id == c["id"]), None)
                if c:
                    self.load_chat(c, center_message_id=message_id)
                    self.show_stats(False)
                    self.stc_history.SetFocus()
            elif table_name and row:
                tableitem = None
                table_name = table_name.lower()
                table = next((t for t in self.db.get_tables()
                              if t["name"].lower() == table_name), None)
                item = self.tree_tables.GetNext(self.tree_tables.RootItem)
                while table and item and item.IsOk():
                    table2 = self.tree_tables.GetItemPyData(item)
                    if table2 and table2.lower() == table["name"].lower():
                        tableitem = item
                        break # break while table and item and itek.IsOk()
                    item = self.tree_tables.GetNextSibling(item)
                if tableitem:
                    self.notebook.SetSelection(self.pageorder[self.page_tables])
                    wx.YieldIfNeeded()
                    # Only way to create state change in wx.gizmos.TreeListCtrl
                    class HackEvent(object):
                        def __init__(self, item): self._item = item
                        def GetItem(self):        return self._item
                    self.on_change_tree_tables(HackEvent(tableitem))
                    if self.tree_tables.Selection != tableitem:
                        self.tree_tables.SelectItem(tableitem)
                        wx.YieldIfNeeded()
                    grid = self.grid_table
                    if grid.Table.filters:
                        grid.Table.ClearSort(refresh=False)
                        grid.Table.ClearFilter()
                    # Search for matching row and scroll to it.
                    table["columns"] = self.db.get_table_columns(table_name)
                    id_fields = [c["name"] for c in table["columns"]
                                 if c.get("pk_id")]
                    if not id_fields: # No primary key fields: take all
                        id_fields = [c["name"] for c in table["columns"]]
                    row_id = [row[c] for c in id_fields]
                    for i in range(grid.Table.GetNumberRows()):
                        row2 = grid.Table.GetRow(i)
                        row2_id = [row2[c] for c in id_fields]
                        if row_id == row2_id:
                            grid.MakeCellVisible(i, 0)
                            grid.SelectRow(i)
                            pagesize = grid.GetScrollPageSize(wx.VERTICAL)
                            pxls = grid.GetScrollPixelsPerUnit()
                            cell_coords = grid.CellToRect(i, 0)
                            y = cell_coords.y / (pxls[1] or 15)
                            x, y = 0, y - pagesize / 2
                            grid.Scroll(x, y)
                            break # break for i in range(self.grid_table..
        elif href.startswith("page:"):
            page = href[5:]
            if "#help" == page:
                html = self.html_searchall
                if html.GetTabDataByID(0):
                    html.SetActiveTabByID(0)
                else:
                    h = step.Template(templates.SEARCH_HELP_LONG).expand()
                    html.InsertTab(html.GetTabCount(), "Search help", 0,
                                   h, None)
            elif "#search" == page:
                self.edit_searchall.SetFocus()
            else:
                thepage = getattr(self, "page_" + page, None)
                if thepage:
                    self.notebook.SetSelection(self.pageorder[thepage])
        elif not (href.startswith("chat:") or href.startswith("message:")
        or href.startswith("file:")):
            webbrowser.open(href)


    def on_searchall_toggle_toolbar(self, event):
        """Handler for toggling a setting in search toolbar."""
        if wx.ID_INDEX == event.Id:
            conf.SearchInMessages = True
            conf.SearchInTables = False
            conf.SearchInChatInfo = conf.SearchInContacts = False
            self.label_search.Label = "&Search in messages:"
        elif wx.ID_ABOUT == event.Id:
            conf.SearchInChatInfo = True
            conf.SearchInTables = False
            conf.SearchInMessages = conf.SearchInContacts = False
            self.label_search.Label = "&Search in chat info:"
        elif wx.ID_PREVIEW == event.Id:
            conf.SearchInContacts = True
            conf.SearchInTables = False
            conf.SearchInMessages = conf.SearchInChatInfo = False
            self.label_search.Label = "&Search in contacts:"
        elif wx.ID_STATIC == event.Id:
            conf.SearchInTables = True
            conf.SearchInContacts = False
            conf.SearchInMessages = conf.SearchInChatInfo = False
            self.label_search.Label = "&Search in tables:"
        self.label_search.ContainingSizer.Layout()
        if wx.ID_NEW == event.Id:
            conf.SearchUseNewTab = event.EventObject.GetToolState(event.Id)
        elif not event.EventObject.GetToolState(event.Id):
            # All others are radio tools and state might be toggled off by
            # shortkey key adapter
            event.EventObject.ToggleTool(event.Id, True)


    def on_searchall_stop(self, event):
        """
        Handler for clicking to stop a search, signals the search thread to
        close.
        """
        tab_data = self.html_searchall.GetActiveTabData()
        if tab_data and tab_data["id"] in self.workers_search:
            self.tb_search_settings.SetToolNormalBitmap(
                wx.ID_STOP, images.ToolbarStopped.Bitmap)
            self.workers_search[tab_data["id"]].stop_work(drop_results=True)
            self.workers_search[tab_data["id"]].stop()
            del self.workers_search[tab_data["id"]]


    def on_change_searchall_tab(self, event):
        """Handler for changing a tab in search window, updates stop button."""
        tab_data = self.html_searchall.GetActiveTabData()
        if tab_data and tab_data["id"] in self.workers_search:
            self.tb_search_settings.SetToolNormalBitmap(
                wx.ID_STOP, images.ToolbarStop.Bitmap)
        else:
            self.tb_search_settings.SetToolNormalBitmap(
                wx.ID_STOP, images.ToolbarStopped.Bitmap)


    def on_dclick_searchall_tab(self, event):
        """
        Handler for double-clicking a search tab header, sets the search box
        value to tab text.
        """
        text = event.Data.get("info", {}).get("text")
        if text:
            self.edit_searchall.Value = text
            self.edit_searchall.SetFocus()


    def on_searchall_result(self, event):
        """
        Handler for getting results from search thread, adds the results to
        the search window.
        """
        result = event.result
        search_id, search_done = result.get("search", {}).get("id"), False
        tab_data = self.html_searchall.GetTabDataByID(search_id)
        if tab_data:
            tab_data["info"]["map"].update(result.get("map", {}))
            tab_data["info"]["partial_html"] += result.get("output", "")
            html = tab_data["info"]["partial_html"]
            if "done" in result:
                search_done = True
            else:
                html += "</table></font>"
            text = tab_data["info"]["text"]
            title = text[:50] + ".." if len(text) > 50 else text
            title += " (%s)" % result.get("count", 0)
            self.html_searchall.SetTabDataByID(search_id, title, html,
                                               tab_data["info"])
        if search_done:
            main.status_flash("Finished searching for \"%s\" in %s.",
                result["search"]["text"], self.db.filename
            )
            self.tb_search_settings.SetToolNormalBitmap(
                wx.ID_STOP, images.ToolbarStopped.Bitmap)
            if search_id in self.workers_search:
                self.workers_search[search_id].stop()
                del self.workers_search[search_id]
        if "error" in result:
            main.log("Error searching %s:\n\n%s", self.db, result["error"])
            errormsg = "Error searching %s:\n\n%s" % \
                       (self.db, result.get("error_short", result["error"]))
            wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
            wx.CallAfter(support.report_error, errormsg)


    def on_searchall_callback(self, result):
        """Callback function for SearchThread, posts the data to self."""
        if self: # Check if instance is still valid (i.e. not destroyed by wx)
            wx.PostEvent(self, WorkerEvent(result=result))


    def on_search_contacts_callback(self, result):
        """Callback function for ContactSearchThread, posts result to self."""
        if self: # Check if instance is still valid (i.e. not destroyed by wx)
            wx.PostEvent(self, ContactWorkerEvent(result=result))


    def on_searchall(self, event):
        """
        Handler for clicking to global search the database.
        """
        text = self.edit_searchall.Value
        if text.strip():
            main.status_flash("Searching for \"%s\" in %s.",
                              text, self.db.filename)
            html = self.html_searchall
            data = {"id": wx.NewId(), "db": self.db, "text": text, "map": {},
                    "width": html.Size.width * 5/9, "table": "",
                    "partial_html": ""}
            fromtext = "" # "Searching for "text" in fromtext"
            if conf.SearchInMessages:
                data["table"] = "messages"
                fromtext = "messages"
            elif conf.SearchInChatInfo:
                data["table"] = "conversations"
                fromtext = "chat information"
            elif conf.SearchInContacts:
                data["table"] = "contacts"
                fromtext = "contact information"
            elif conf.SearchInTables:
                fromtext = data["table"] = "all tables"
            # Partially assembled HTML for current results
            template = step.Template(templates.SEARCH_HEADER_HTML)
            data["partial_html"] = template.expand(locals())

            worker = workers.SearchThread(self.on_searchall_callback)
            self.workers_search[data["id"]] = worker
            worker.work(data)
            bmp = images.ToolbarStop.Bitmap
            self.tb_search_settings.SetToolNormalBitmap(wx.ID_STOP, bmp)

            title = text[:50] + ".." if len(text) > 50 else text
            content = data["partial_html"] + "</table></font>"
            if conf.SearchUseNewTab or not html.GetTabCount():
                html.InsertTab(0, title, data["id"], content, data)
            else:
                # Set new ID for the existing reused tab
                html.SetTabDataByID(html.GetActiveTabData()["id"], title,
                                    content, data, data["id"])

            self.notebook.SetSelection(self.pageorder[self.page_search])
            util.add_unique(conf.SearchHistory, text.strip(), 1,
                            conf.MaxSearchHistory)
            self.TopLevelParent.dialog_search.Value = conf.SearchHistory[-1]
            self.TopLevelParent.dialog_search.SetChoices(conf.SearchHistory)
            self.edit_searchall.SetChoices(conf.SearchHistory)
            self.edit_searchall.SetFocus()
            conf.save()


    def on_delete_tab_callback(self, tab):
        """
        Function called by html_searchall after deleting a tab, stops the
        ongoing search, if any.
        """
        tab_data = self.html_searchall.GetActiveTabData()
        if tab_data and tab_data["id"] == tab["id"]:
            self.tb_search_settings.SetToolNormalBitmap(
                wx.ID_STOP, images.ToolbarStopped.Bitmap)
        if tab["id"] in self.workers_search:
            self.workers_search[tab["id"]].stop()
            del self.workers_search[tab["id"]]


    def on_mouse_over_grid(self, event):
        """
        Handler for moving the mouse over a grid, shows datetime tooltip for
        UNIX timestamp cells.
        """
        tip = ""
        grid = event.EventObject.Parent
        prev_cell = getattr(grid, "_hovered_cell", None)
        x, y = grid.CalcUnscrolledPosition(event.X, event.Y)
        row, col = grid.XYToCell(x, y)
        if row >= 0 and col >= 0:
            value = grid.Table.GetValue(row, col)
            col_name = grid.Table.GetColLabelValue(col).lower()
            if type(value) is int and value > 100000000 \
            and ("time" in col_name or "history" in col_name):
                try:
                    tip = datetime.datetime.fromtimestamp(value).strftime(
                        "%Y-%m-%d %H:%M:%S")
                except Exception:
                    tip = unicode(value)
            else:
                tip = unicode(value)
            tip = tip if len(tip) < 1000 else tip[:1000] + ".."
        if (row, col) != prev_cell or not (event.EventObject.ToolTip) \
        or event.EventObject.ToolTip.Tip != tip:
            event.EventObject.SetToolTipString(tip)
        grid._hovered_cell = (row, col)


    def on_participants_dclick(self, event):
        """
        Handler for double-clicking an item in the participants list,
        checks/unchecks (CheckListBox checks only when clicking on the
        checkbox icon itself).
        """
        checkeds = list(event.EventObject.Checked)
        do_check = not event.EventObject.IsChecked(event.Selection)
        if do_check and event.Selection not in checkeds:
            checkeds.append(event.Selection)
        elif not do_check and event.Selection in checkeds:
            checkeds.remove(event.Selection)
        event.EventObject.SetChecked(checkeds)


    def on_filterreset_chat(self, event):
        """
        Handler for clicking to reset current chat history filter, restores
        initial values to filter controls.
        """
        for i in range(self.list_participants.GetItemCount()):
            c = self.list_participants.GetItem(i)
            c.Check(True)
            self.list_participants.SetItem(c)
        self.edit_filtertext.Value = ""
        self.range_date.SetValues(*self.chat_filter["startdaterange"])
        self.list_participants.Refresh()


    def on_filter_chat(self, event):
        """
        Handler for clicking to filter current chat history, applies the
        current filter to the chat messages.
        """
        new_filter, old_filter = self.build_filter(), self.stc_history.Filter
        current_filter = dict((t, old_filter) for t in new_filter)
        self.current_filter = current_filter
        self.new_filter = new_filter
        if new_filter != current_filter:
            self.chat_filter.update(new_filter)
            busy = controls.BusyPanel(self, "Filtering messages.")
            try:
                self.stc_history.SetFilter(self.chat_filter)
                self.stc_history.RefreshMessages()
                self.populate_chat_statistics()
            finally:
                busy.Close()
            has_messages = self.chat["message_count"] > 0
            self.tb_chat.EnableTool(wx.ID_MORE, has_messages)


    def build_filter(self):
        """Builds chat filter data from current control state."""
        # At least one participant must be selected: reset to previously
        # selected participants instead if nothing selected
        reselecteds = []
        for i in range(self.list_participants.GetItemCount()):
            # UltimateListCtrl does not expose checked state, have to
            # query it from each individual row
            if not self.list_participants.GetItem(i).IsChecked():
                identity = self.list_participants.GetItemData(i)["identity"]
                if identity in self.chat_filter["participants"]:
                    reselecteds.append(i)
        if reselecteds:
            for i in range(self.list_participants.GetItemCount()):
                identity = self.list_participants.GetItemData(i)["identity"]
                if identity in reselecteds:
                    c = self.list_participants.GetItem(i)
                    c.Check(True)
                    self.list_participants.SetItem(i, c)
            self.list_participants.Refresh()
        participants = []
        for i in range(self.list_participants.GetItemCount()):
            if self.list_participants.IsItemChecked(i):
                identity = self.list_participants.GetItemData(i)["identity"]
                participants.append(identity)
        filterdata = {
            "daterange": self.range_date.Values,
            "text": self.edit_filtertext.Value,
            "participants": participants
        }
        return filterdata


    def on_toggle_filter(self, event):
        """Handler for clicking to show/hide chat filter."""
        self.toggle_filter(not self.splitter_stc.IsSplit())


    def on_toggle_stats(self, event):
        """
        Handler for clicking to show/hide statistics for chat, toggles display
        between chat history window and statistics window.
        """
        html, stc = self.html_stats, self.stc_history
        self.show_stats(not html.Shown)
        (html if html.Shown else stc).SetFocus()


    def on_toggle_maximize(self, event):
        """Handler for toggling to maximize chat window and hide chat list."""
        splitter = self.splitter_chats
        if splitter.IsSplit():
            splitter._sashPosition = splitter.SashPosition
            splitter.Unsplit(self.panel_chats1)
            shorthelp = "Restore chat panel to default size  (Alt-M)"
        else:
            pos = getattr(splitter, "_sashPosition", self.Size[1] / 3)
            splitter.SplitHorizontally(self.panel_chats1, self.panel_chats2,
                                       sashPosition=pos)
            shorthelp = "Maximize chat panel  (Alt-M)"
        self.tb_chat.SetToolShortHelp(wx.ID_ZOOM_100, shorthelp)


    def toggle_filter(self, on):
        """Toggles the chat filter panel on/off."""
        if self.splitter_stc.IsSplit() and not on:
            self.splitter_stc._sashPosition = self.splitter_stc.SashPosition
            self.splitter_stc.Unsplit(self.panel_stc2)
        elif not self.splitter_stc.IsSplit() and on:
            p = getattr(self.splitter_stc, "_sashPosition",
                self.splitter_stc.Size.width - self.panel_stc2.BestSize.width)
            self.splitter_stc.SplitVertically(self.panel_stc1, self.panel_stc2,
                                              sashPosition=p)
            list_participants = self.list_participants
            list_participants.SetColumnWidth(0, list_participants.Size.width)


    def show_stats(self, show=True):
        """Shows or hides the statistics window."""
        html, stc = self.html_stats, self.stc_history
        changed = False
        focus = False
        for i in [html, stc]:
            focus = focus or (i.Shown and i.FindFocus() == i)
        if not stc.Shown != show:
            stc.Show(not show)
            changed = True
        if html.Shown != show:
            html.Show(show)
            changed = True
        if changed:
            stc.ContainingSizer.Layout()
        if focus: # Switch focus to the other control if previous had focus
            (html if show else stc).SetFocus()
        if show:
            if hasattr(html, "_last_scroll_pos"):
                html.Scroll(*html._last_scroll_pos)
            elif html.HasAnchor(html.OpenedAnchor):
                html.ScrollToAnchor(html.OpenedAnchor)
        self.tb_chat.ToggleTool(wx.ID_PROPERTIES, show)


    def on_button_reset_grid(self, event):
        """
        Handler for clicking to remove sorting and filtering on a grid,
        resets the grid and its view.
        """
        grid = self.grid_table \
            if event.EventObject == self.button_reset_grid_table \
            else self.grid_sql
        if grid.Table and isinstance(grid.Table, GridTableBase):
            grid.Table.ClearSort(refresh=False)
            grid.Table.ClearFilter()
            grid.ContainingSizer.Layout() # React to grid size change


    def on_button_export_grid(self, event):
        """
        Handler for clicking to export wx.Grid contents to file, allows the
        user to select filename and type and creates the file.
        """
        grid_source = self.grid_table
        sql = ""
        table = ""
        if event.EventObject is self.button_export_sql:
            grid_source = self.grid_sql
            sql = getattr(self, "last_sql", "")
        if grid_source.Table:
            if grid_source is self.grid_table:
                table = self.db.tables[grid_source.Table.table.lower()]["name"]
                namebase = "table \"%s\"" % table
                self.dialog_savefile.Wildcard = export.TABLE_WILDCARD
            else:
                namebase = "SQL query"
                self.dialog_savefile.Wildcard = export.QUERY_WILDCARD
                grid_source.Table.SeekAhead(True)
            title = "Skype - %s" % namebase
            self.dialog_savefile.Filename = util.safe_filename(title)
            self.dialog_savefile.Message = "Save table as"
            self.dialog_savefile.WindowStyle |= wx.FD_OVERWRITE_PROMPT
            if wx.ID_OK == self.dialog_savefile.ShowModal():
                filename = self.dialog_savefile.GetPath()
                exts = export.TABLE_EXTS if grid_source is self.grid_table \
                       else export.QUERY_EXTS
                extname = exts[self.dialog_savefile.FilterIndex]
                if not filename.lower().endswith(".%s" % extname):
                    filename += ".%s" % extname
                busy = controls.BusyPanel(self, "Exporting \"%s\"." % filename)
                main.status("Exporting \"%s\".", filename)
                try:
                    export.export_grid(grid_source, filename, title,
                                       self.db, sql, table)
                    main.logstatus_flash("Exported %s.", filename)
                    util.start_file(filename)
                except Exception:
                    msg = "Error saving %s:\n\n%s" % \
                          (filename, traceback.format_exc())
                    main.logstatus_flash(msg)
                    wx.MessageBox(msg, conf.Title, wx.OK | wx.ICON_WARNING)
                    wx.CallAfter(support.report_error, msg)
                finally:
                    busy.Close()


    def on_keydown_sql(self, event):
        """
        Handler for pressing a key in SQL editor, listens for Alt-Enter and
        executes the currently selected line, or currently active line.
        """
        stc = event.GetEventObject()
        if event.AltDown() and wx.WXK_RETURN == event.KeyCode:
            sql = (stc.SelectedText or stc.CurLine[0]).strip()
            if sql:
                self.execute_sql(sql)
        event.Skip() # Allow to propagate to other handlers


    def on_button_sql(self, event):
        """
        Handler for clicking to run an SQL query, runs the selected text or
        whole contents, displays its results, if any, and commits changes 
        done, if any.
        """
        sql = self.stc_sql.SelectedText.strip() or self.stc_sql.Text.strip()
        if sql:
            self.execute_sql(sql)


    def execute_sql(self, sql):
        """Executes the SQL query and populates the SQL grid with results."""
        try:
            grid_data = None
            if sql.lower().startswith(("select", "pragma", "explain")):
                # SELECT statement: populate grid with rows
                grid_data = GridTableBase.from_query(self.db, sql)
                self.grid_sql.SetTable(grid_data)
                self.button_reset_grid_sql.Enabled = True
                self.button_export_sql.Enabled = True
            else:
                # Assume action query
                affected_rows = self.db.execute_action(sql)
                self.grid_sql.SetTable(None)
                self.grid_sql.CreateGrid(1, 1)
                self.grid_sql.SetColLabelValue(0, "Affected rows")
                self.grid_sql.SetCellValue(0, 0, str(affected_rows))
                self.button_reset_grid_sql.Enabled = False
                self.button_export_sql.Enabled = False
            main.logstatus_flash("Executed SQL \"%s\" (%s).", sql, self.db)
            size = self.grid_sql.Size
            self.grid_sql.Fit()
            # Jiggle size by 1 pixel to refresh scrollbars
            self.grid_sql.Size = size[0], size[1]-1
            self.grid_sql.Size = size[0], size[1]
            self.last_sql = sql
            self.grid_sql.SetColMinimalAcceptableWidth(100)
            if grid_data:
                col_range = range(grid_data.GetNumberCols())
                [self.grid_sql.AutoSizeColLabelSize(x) for x in col_range]
        except Exception as e:
            wx.MessageBox(unicode(e).capitalize(), conf.Title,
                          wx.OK | wx.ICON_WARNING)


    def get_unsaved_grids(self):
        """
        Returns a list of GridTableBase grids where changes have not been
        saved after changing.
        """
        return [g for g in self.db_grids.values() if g.IsChanged()]


    def save_unsaved_grids(self):
        """Saves all data in unsaved table grids."""
        [g.SaveChanges() for g in self.db_grids.values() if g.IsChanged()]


    def on_change_table(self, event):
        """
        Handler when table grid data is changed, refreshes icons,
        table lists and database display.
        """
        grid_data = self.grid_table.Table
        # Enable/disable commit and rollback icons
        self.tb_grid.EnableTool(wx.ID_SAVE, grid_data.IsChanged())
        self.tb_grid.EnableTool(wx.ID_UNDO, grid_data.IsChanged())
        # Highlight changed tables in the table list
        colour = conf.DBTableChangedColour if grid_data.IsChanged() \
                 else self.tree_tables.ForegroundColour
        item = self.tree_tables.GetNext(self.tree_tables.RootItem)
        while item and item.IsOk():
            list_table = self.tree_tables.GetItemPyData(item)
            if list_table:
                if list_table.lower() == grid_data.table.lower():
                    self.tree_tables.SetItemTextColour(item, colour)
                    break # break while item and item.IsOk()
            item = self.tree_tables.GetNextSibling(item)

        # Mark database as changed/pristine in the parent notebook tabs
        for i in range(self.parent_notebook.GetPageCount()):
            if self.parent_notebook.GetPage(i) == self:
                suffix = "*" if self.get_unsaved_grids() else ""
                title = self.title + suffix
                if self.parent_notebook.GetPageText(i) != title:
                    self.parent_notebook.SetPageText(i, title)
                break # break for i in range(self.parent_notebook..


    def on_commit_table(self, event):
        """Handler for clicking to commit the changed database table."""
        info = self.grid_table.Table.GetChangedInfo()
        if wx.OK == wx.MessageBox(
            "Are you sure you want to commit these changes (%s)?" %
            info, conf.Title, wx.OK | wx.CANCEL | wx.ICON_QUESTION
        ):
            main.log("Committing %s in table %s (%s).", info,
                     self.grid_table.Table.table, self.db)
            self.grid_table.Table.SaveChanges()
            self.on_change_table(None)
            # Refresh tables list with updated row counts
            tablemap = dict((t["name"], t) for t in self.db.get_tables(True))
            item = self.tree_tables.GetNext(self.tree_tables.RootItem)
            while item and item.IsOk():
                table = self.tree_tables.GetItemPyData(item)
                if table:
                    self.tree_tables.SetItemText(item, "%d row%s" % (
                        tablemap[table]["rows"],
                        "s" if tablemap[table]["rows"] != 1 else " "
                    ), 1)
                    if table == self.grid_table.Table.table:
                        self.tree_tables.SetItemTextColour(
                            item,
                            conf.DBTableChangedColour
                            if self.grid_table.Table.IsChanged() else "black")
                item = self.tree_tables.GetNextSibling(item)


    def on_rollback_table(self, event):
        """Handler for clicking to rollback the changed database table."""
        self.grid_table.Table.UndoChanges()
        self.on_change_table(None)
        # Refresh scrollbars; without CallAfter wx 2.8 can crash
        wx.CallAfter(self.grid_table.ContainingSizer.Layout)


    def on_insert_row(self, event):
        """
        Handler for clicking to insert a table row, lets the user edit a new
        grid line.
        """
        self.grid_table.InsertRows(pos=0, numRows=1)
        self.grid_table.SetGridCursor(0, self.grid_table.GetGridCursorCol())
        self.grid_table.Scroll(self.grid_table.GetScrollPos(wx.HORIZONTAL), 0)
        self.grid_table.Refresh()
        self.on_change_table(None)
        # Refresh scrollbars; without CallAfter wx 2.8 can crash
        wx.CallAfter(self.grid_table.ContainingSizer.Layout)


    def on_delete_row(self, event):
        """
        Handler for clicking to delete a table row, removes the row from grid.
        """
        selected_rows = self.grid_table.GetSelectedRows()
        cursor_row = self.grid_table.GetGridCursorRow()
        if cursor_row >= 0:
            selected_rows.append(cursor_row)
        for row in selected_rows:
            self.grid_table.DeleteRows(row)
        self.grid_table.ContainingSizer.Layout() # Refresh scrollbars
        self.on_change_table(None)


    def on_update_grid_table(self, event):
        """Refreshes the table grid UI components, like toolbar icons."""
        self.tb_grid.EnableTool(wx.ID_SAVE, self.grid_table.Table.IsChanged())
        self.tb_grid.EnableTool(wx.ID_UNDO, self.grid_table.Table.IsChanged())


    def on_change_tree_tables(self, event):
        """
        Handler for selecting an item in the tables list, loads the table data
        into the table grid.
        """
        table = None
        item = event.GetItem()
        if item and item.IsOk():
            table = self.tree_tables.GetItemPyData(item)
            lower = table.lower() if table else None
        if table and \
        (not self.grid_table.Table
         or self.grid_table.Table.table.lower() != lower):
            i = self.tree_tables.GetNext(self.tree_tables.RootItem)
            while i:
                text = self.tree_tables.GetItemText(i).lower()
                bgcolour = (conf.DBTableOpenedColour if text == lower
                            else conf.BgColour)
                self.tree_tables.SetItemBackgroundColour(i, bgcolour)
                i = self.tree_tables.GetNextSibling(i)
            main.log("Loading table %s (%s).", table, self.db)
            busy = controls.BusyPanel(self, "Loading table \"%s\"." % table)
            try:
                grid_data = self.db_grids.get(lower)
                if not grid_data:
                    grid_data = GridTableBase.from_table(self.db, table)
                    self.db_grids[lower] = grid_data
                self.label_table.Label = "Table \"%s\":" % table
                self.grid_table.SetTable(grid_data)
                self.page_tables.Layout() # React to grid size change
                self.grid_table.Scroll(0, 0)
                self.grid_table.SetColMinimalAcceptableWidth(100)
                col_range = range(grid_data.GetNumberCols())
                [self.grid_table.AutoSizeColLabelSize(x) for x in col_range]
                self.on_change_table(None)
                self.tb_grid.EnableTool(wx.ID_ADD, True)
                self.tb_grid.EnableTool(wx.ID_DELETE, True)
                self.button_export_table.Enabled = True
                self.button_reset_grid_table.Enabled = True
                busy.Close()
            except Exception as e:
                busy.Close()
                errormsg = "Could not load table %s.\n\n%s" % \
                           (table, traceback.format_exc())
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)


    def on_change_list_chats(self, event):
        """
        Handler for selecting an item in the chats list, loads the
        messages into the message log.
        """
        self.load_chat(self.list_chats.GetItemMappedData(event.Index))


    def load_chat(self, chat, center_message_id=None):
        """Loads history of the specified chat (as returned from db)."""
        if chat and (chat != self.chat or center_message_id):
            busy = None
            if chat != self.chat:
                # Update chat list colours and scroll to the opened chat
                main.log("Opening %s.", chat["title_long_lc"])
                self.list_chats.Freeze()
                scrollpos = self.list_chats.GetScrollPos(wx.VERTICAL)
                index_selected = -1
                for i in range(self.list_chats.ItemCount):
                    if self.list_chats.GetItemMappedData(i) == self.chat:
                        self.list_chats.SetItemBackgroundColour(
                            i, self.list_chats.BackgroundColour)
                    elif self.list_chats.GetItemMappedData(i) == chat:
                        index_selected = i
                        self.list_chats.SetItemBackgroundColour(
                            i, conf.ListOpenedBgColour)
                if index_selected >= 0:
                    delta = index_selected - scrollpos
                    if delta < 0 or abs(delta) >= self.list_chats.CountPerPage:
                        nudge = -self.list_chats.CountPerPage / 2
                        self.list_chats.ScrollLines(delta + nudge)
                self.list_chats.Thaw()
                wx.YieldIfNeeded() # Allow display to refresh
                # Add shortcut key flag to chat label
                self.label_chat.Label = chat["title_long"].replace(
                    "chat", "&chat"
                ).replace("Chat", "&Chat") + ":"
                self.label_chat.Parent.Layout()

            dates_range  = [None, None] # total available date range
            dates_values = [None, None] # currently filtered date range
            if chat != self.chat or (center_message_id
            and not self.stc_history.IsMessageShown(center_message_id)):
                busy = controls.BusyPanel(self, "Loading history for %s."
                                              % chat["title_long_lc"])
                # Refresh last message timestamps, in case database has updated
                self.db.get_conversations_stats([chat], log=False)
                self.edit_filtertext.Value = self.chat_filter["text"] = ""
                date_range = [
                    chat["first_message_datetime"].date()
                    if chat["first_message_datetime"] else None,
                    chat["last_message_datetime"].date()
                    if chat["last_message_datetime"] else None
                ]
                self.chat_filter["daterange"] = date_range
                self.chat_filter["startdaterange"] = date_range
                dates_range = dates_values = date_range
                avatar_default = images.AvatarDefault.Bitmap
                if chat != self.chat:
                    # If chat has changed, load avatar images for the contacts
                    self.list_participants.ClearAll()
                    self.list_participants.InsertColumn(0, "")
                    sz_avatar = conf.AvatarImageSize
                    il = wx.ImageList(*sz_avatar)
                    il.Add(avatar_default)
                    self.list_participants.AssignImageList(
                        il, wx.IMAGE_LIST_SMALL)
                    index = 0
                    # wx will open a warning dialog on image error otherwise
                    nolog = wx.LogNull()
                    for p in chat["participants"]:
                        b = 0
                        if not p["contact"].get("avatar_bitmap"):
                            bmp = skypedata.get_avatar(p["contact"], sz_avatar)
                            if bmp:
                                p["contact"]["avatar_bitmap"] = bmp
                        if "avatar_bitmap" in p["contact"]:
                            b = il.Add(p["contact"]["avatar_bitmap"])
                        self.list_participants.InsertImageStringItem(
                            index, p["contact"]["name"], b, it_kind=1)
                        c = self.list_participants.GetItem(index)
                        c.Check(True)
                        self.list_participants.SetItem(c)
                        self.list_participants.SetItemData(index, p)
                        index += 1
                    del nolog # Restore default wx message logger
                    self.list_participants.SetColumnWidth(0, wx.LIST_AUTOSIZE)
                self.chat_filter["participants"] = [
                    p["identity"] for p in chat["participants"]]

            if center_message_id and self.chat == chat:
                if not self.stc_history.IsMessageShown(center_message_id):
                    self.stc_history.SetFilter(self.chat_filter)
                    self.stc_history.RefreshMessages(center_message_id)
                else:
                    self.stc_history.FocusMessage(center_message_id)
            else:
                self.stc_history.SetFilter(self.chat_filter)
                self.stc_history.Populate(chat, self.db,
                    center_message_id=center_message_id
                )
            if self.stc_history.GetMessage(0):
                values = [self.stc_history.GetMessage(0)["datetime"],
                    self.stc_history.GetMessage(-1)["datetime"]
                ]
                dates_values = tuple(i.date() for i in values)
                if not any(filter(None, dates_range)):
                    dates_range2 = list(dates_range)
                    dates_range = [
                        chat["first_message_datetime"].date()
                        if chat["first_message_datetime"] else None,
                        chat["last_message_datetime"].date()
                        if chat["last_message_datetime"] else None
                    ]
                if not any(filter(None, dates_range)):
                    dates_range = dates_values
                self.chat_filter["daterange"] = dates_range
                self.chat_filter["startdaterange"] = dates_values
            self.range_date.SetRange(*dates_range)
            self.range_date.SetValues(*dates_values)
            has_messages = bool(self.stc_history.GetMessage(0))
            self.tb_chat.EnableTool(wx.ID_MORE, has_messages)
            if not self.chat:
                # Very first load, toggle filter tool button on
                self.tb_chat.ToggleTool(wx.ID_MORE, self.splitter_stc.IsSplit())
            if self.chat != chat:
                self.chat = chat
            if busy:
                busy.Close()
            self.panel_chats2.Enabled = True
            self.populate_chat_statistics()
            if self.html_stats.Shown:
                self.show_stats(True) # To restore scroll position


    def populate_chat_statistics(self):
        """Populates html_stats with chat statistics and word cloud."""
        stats_html = self.stc_history.GetStatisticsHtml(self.stats_sort_field)
        if stats_html:
            fs, fn = self.memoryfs, "avatar__default.jpg"
            if fn not in fs["files"]:
                bmp = images.AvatarDefault.Bitmap
                fs["handler"].AddFile(fn, bmp, wx.BITMAP_TYPE_BMP)
                fs["files"][fn] = 1

            for p in self.chat["participants"]:
                if "avatar_bitmap" in p["contact"]:
                    vals = (self.db.filename.encode("utf-8"), p["identity"])
                    fn = "%s_%s.jpg" % tuple(map(urllib.quote, vals))
                    if fn not in fs["files"]:
                        bmp = p["contact"]["avatar_bitmap"]
                        fs["handler"].AddFile(fn, bmp, wx.BITMAP_TYPE_BMP)
                        fs["files"][fn] = 1

        previous_anchor = self.html_stats.OpenedAnchor
        previous_scrollpos = getattr(self.html_stats, "_last_scroll_pos", None)
        self.html_stats.Freeze()
        self.html_stats.SetPage(stats_html)
        self.html_stats.BackgroundColour = conf.BgColour
        if previous_scrollpos:
            self.html_stats.Scroll(*previous_scrollpos)
        elif previous_anchor and self.html_stats.HasAnchor(previous_anchor):
            self.html_stats.ScrollToAnchor(previous_anchor)
        self.html_stats.Thaw()


    def on_sort_grid_column(self, event):
        """
        Handler for clicking a table grid column, sorts table by the column.
        """
        grid = event.GetEventObject()
        if grid.Table and isinstance(grid.Table, GridTableBase):
            row, col = event.GetRow(), event.GetCol()
            # Remember scroll positions, as grid update loses them
            scroll_hor = grid.GetScrollPos(wx.HORIZONTAL)
            scroll_ver = grid.GetScrollPos(wx.VERTICAL)
            if row < 0: # Only react to clicks in the header
                grid.Table.SortColumn(col)
            grid.ContainingSizer.Layout() # React to grid size change
            grid.Scroll(scroll_hor, scroll_ver)


    def on_filter_grid_column(self, event):
        """
        Handler for right-clicking a table grid column, lets the user
        change the column filter.
        """
        grid = event.GetEventObject()
        if grid.Table and isinstance(grid.Table, GridTableBase):
            row, col = event.GetRow(), event.GetCol()
            # Remember scroll positions, as grid update loses them
            scroll_hor = grid.GetScrollPos(wx.HORIZONTAL)
            scroll_ver = grid.GetScrollPos(wx.VERTICAL)
            if row < 0: # Only react to clicks in the header
                grid_data = grid.Table
                current_filter = unicode(grid_data.filters[col]) \
                                 if col in grid_data.filters else ""
                dialog = wx.TextEntryDialog(self,
                    "Filter column \"%s\" by:" % grid_data.columns[col]["name"],
                    "Filter", defaultValue=current_filter,
                    style=wx.OK | wx.CANCEL)
                if wx.ID_OK == dialog.ShowModal():
                    new_filter = dialog.GetValue()
                    if len(new_filter):
                        busy = controls.BusyPanel(self.page_tables,
                            "Filtering column \"%s\" by \"%s\"." % (
                                grid_data.columns[col]["name"], new_filter
                        ))
                        grid_data.AddFilter(col, new_filter)
                        busy.Close()
                    else:
                        grid_data.RemoveFilter(col)
            grid.ContainingSizer.Layout() # React to grid size change


    def load_data(self):
        """Loads data from our SkypeDatabase."""
        self.label_title.Label = "Database \"%s\":" % self.db

        try:
            # Restore last search text, if any
            if conf.SearchHistory and conf.SearchHistory[-1] != "":
                self.edit_searchall.Value = conf.SearchHistory[-1]
            if conf.SearchHistory and conf.SearchHistory[-1] == "":
                # Clear the empty search flag
                conf.SearchHistory = conf.SearchHistory[:-1]
            self.edit_searchall.SetChoices(conf.SearchHistory)

            # Restore last cached search results page
            last_search = conf.LastSearchResults.get(self.db.filename)
            if last_search:
                title = last_search.get("title", "")
                html = last_search.get("content", "")
                info = last_search.get("info")
                tabid = wx.NewId() if 0 != last_search.get("id") else 0
                self.html_searchall.InsertTab(0, title, tabid, html, info)

            # Populate the chats list
            self.chats = self.db.get_conversations()
            for c in self.chats:
                c["people"] = "" # Set empty data, stats will come later
            self.list_chats.Populate(self.chats)

            wx.CallLater(100, self.load_later_data)
        except Exception as e:
            wx.CallAfter(self.update_tabheader)
            errormsg = "Could not load chat list from %s.\n\n%s" % \
                       (self.db, traceback.format_exc())
            main.logstatus_flash(errormsg)
            wx.CallAfter(support.report_error, errormsg)
        wx.CallLater(500, self.update_info_page, False)
        wx.CallLater(200, self.load_tables_data)


    def load_later_data(self):
        """
        Loads later data from the database, like table metainformation and
        statistics for all chats, used as a background callback to speed
        up page opening.
        """
        try:
            # Load chat statistics and update the chat list
            self.db.get_conversations_stats(self.chats)
            for c in self.chats:
                people = sorted([p["identity"] for p in c["participants"]])
                if skypedata.CHATS_TYPE_SINGLE != c["type"]:
                    c["people"] = "%s (%s)" % (len(people), ", ".join(people))
                else:
                    people = [p for p in people if p != self.db.id]
                    c["people"] = ", ".join(people)

            if self.chat:
                # If the user already opened a chat while later data
                # was loading, update the date range control values.
                date_range = [self.chat["first_message_datetime"].date()
                              if self.chat["first_message_datetime"] else None,
                              self.chat["last_message_datetime"].date()
                              if self.chat["last_message_datetime"] else None ]
                self.range_date.SetRange(*date_range)
            main.status_flash("Opened Skype database %s.", self.db)
        except Exception as e:
            if self:
                errormsg = "Error loading additional data from %s.\n\n%s" % \
                           (self.db, traceback.format_exc())
                main.logstatus_flash(errormsg)
                wx.CallAfter(support.report_error, errormsg)
        if self:
            # Refresh list from loaded data, sort by last message datetime
            sortfunc = lambda l: l and (l.ResetColumnWidths(), l.RefreshRows(),
                                        l.SortListItems(4, 0))
            wx.CallLater(0, sortfunc, self.list_chats)
            wx.CallAfter(self.update_tabheader)


    def load_tables_data(self):
        """Loads table data into table tree and SQL editor."""
        try:
            tables = self.db.get_tables()
            # Fill table tree with information on row counts and columns
            self.tree_tables.DeleteAllItems()
            root = self.tree_tables.AddRoot("SQLITE")
            child = None
            for table in tables:
                child = self.tree_tables.AppendItem(root, table["name"])
                self.tree_tables.SetItemText(child, "%d row%s" % (
                    table["rows"], "s" if table["rows"] != 1 else " "
                ), 1)
                self.tree_tables.SetItemPyData(child, table["name"])

                for col in self.db.get_table_columns(table["name"]):
                    subchild = self.tree_tables.AppendItem(child, col["name"])
                    self.tree_tables.SetItemText(subchild, col["type"], 1)
            self.tree_tables.Expand(root)
            if child:
                # Nudge columns to fit and fill the header exactly.
                self.tree_tables.Expand(child)
                self.tree_tables.SetColumnWidth(0, -1)
                self.tree_tables.SetColumnWidth(1, min(70,
                    self.tree_tables.Size.width -
                    self.tree_tables.GetColumnWidth(0) - 5))
                self.tree_tables.Collapse(child)

            # Add table and column names to SQL editor autocomplete
            for t in tables:
                coldata = self.db.get_table_columns(t["name"])
                fields = [c["name"] for c in coldata]
                self.stc_sql.AutoCompAddSubWords(t["name"], fields)
        except Exception as e:
            if self:
                errormsg = "Error loading table data from %s.\n\n%s" % \
                           (self.db, traceback.format_exc())
                main.log(errormsg)
                wx.CallAfter(support.report_error, errormsg)


    def update_tabheader(self):
        """Updates page tab header with option to close page."""
        if self:
            self.ready_to_close = True
        if self:
            self.TopLevelParent.update_notebook_header()



class MergerPage(wx.Panel):
    """
    A wx.Notebook page for comparing two Skype databases, has its own Notebook
    with one page for diffing/merging chats, and another for contacts.
    """

    """Notes for merge buttons where note changes with data."""
    MERGE_BUTTON_NOTE = ("Scan through the left database, find messages not "
                         "present on the right, and copy them to the database "
                         "on the right.")
    MERGE_CHAT_BUTTON_NOTE = "Copy new messages to the database on the right."

    def __init__(self, parent_notebook, db1, db2, title):
        wx.Panel.__init__(self, parent=parent_notebook)
        self.pageorder = {} # {page: notebook index, }
        self.parent_notebook = parent_notebook
        self.ready_to_close = False
        self.is_merging = False # Whether merging is currently underway
        self.is_scanning = False # Whether scanning is currently underway
        self.is_scanned = False # Whether global scan has been run
        self.db1 = db1
        self.db2 = db2
        main.status("Opening Skype databases %s and %s.", self.db1, self.db2)
        self.db1.register_consumer(self)
        self.db2.register_consumer(self)
        self.title = title
        parent_notebook.InsertPage(1, self, title)
        busy = controls.BusyPanel(
            self, "Comparing \"%s\"\n and \"%s\"." % (db1, db2))

        self.chats1 = None        # [chats in left database]
        self.chats2 = None        # [chats in right database]
        self.chat = None          # Chat opened on chats page
        self.chat_diff = None     # Open diff {"messages": [], "participants": []}
        self.compared = None      # Chat list, left-right data in keys "c1" & "c2"
        self.con1difflist = None  # Contact and contact group differences
        self.con2difflist = None  # Contact and contact group differences
        self.con1diff = None      # Contact differences for left
        self.con2diff = None      # Contact differences for right
        self.congroup1diff = None # Contact group differences for left
        self.congroup2diff = None # Contact group differences for right
        self.chats_nodiff = {}    # {identity of unchanged chat: {chat}, }
        # {identity of changed chat: {"chat": {}, "diff": [message ID, ]}, }
        self.chats_diffdata = {}

        self.contacts_list_columns = [
            ("identity", "Account"), ("name", "Name"),
            ("phone_mobile_normalized", "Mobile phone"),
            ("country", "Country"), ("city", "City"), ("about", "About"),
            ("__type", "Type"), ]
        self.chats_list_columns = [
            ("title", "Chat"), ("messages1", "Messages in left"),
            ("messages2", "Messages in right"),
            ("last_message_datetime1", "Last message in left"),
            ("last_message_datetime2", "Last message in right"),
            ("type_name", "Type"), ("people", "People"), ]
        self.Bind(EVT_WORKER, self.on_worker_merge_result)
        self.worker_merge = workers.MergeThread(self.on_worker_merge_callback)

        sizer = self.Sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_header = wx.BoxSizer(wx.HORIZONTAL)
        label = self.html_dblabel = wx.html.HtmlWindow(parent=self,
            size=(-1, 36), style=wx.html.HW_SCROLLBAR_NEVER)
        label.SetFonts(normal_face=self.Font.FaceName,
                       fixed_face=self.Font.FaceName, sizes=[8] * 7)
        self.Bind(wx.html.EVT_HTML_LINK_CLICKED, self.on_link_db, label)
        button_swap = self.button_swap = \
            wx.Button(parent=self, label="S&wap left-right")
        button_swap.Enabled = False
        button_swap.SetToolTipString("Swaps left and right database, "
                                     "changing merge direction.")
        self.Bind(wx.EVT_BUTTON, self.on_swap, button_swap)
        sizer_header.Add(label, border=5, proportion=1,
                         flag=wx.GROW | wx.TOP | wx.BOTTOM)
        sizer_header.Add(button_swap, border=5, flag=wx.LEFT | wx.RIGHT | 
                         wx.ALIGN_CENTER_VERTICAL)
        sizer.Add(sizer_header, flag=wx.GROW)
        sizer.Layout() # To avoid header moving around during page creation

        bookstyle = wx.lib.agw.fmresources.INB_LEFT
        if (wx.version().startswith("2.8") and sys.version.startswith("2.")
        and sys.version[:5] < "2.7.3"):
            # wx 2.8 + Python below 2.7.3: labelbook can partly cover tab area
            bookstyle |= wx.lib.agw.fmresources.INB_FIT_LABELTEXT
        notebook = self.notebook = wx.lib.agw.labelbook.FlatImageBook(
            parent=self, agwStyle=bookstyle,
            style=wx.BORDER_STATIC)
        sizer.Add(notebook, proportion=10, border=5,
                  flag=wx.GROW | wx.LEFT | wx.RIGHT | wx.BOTTOM)

        il = wx.ImageList(32, 32)
        idx1 = il.Add(images.PageMergeAll.Bitmap)
        idx2 = il.Add(images.PageMergeChats.Bitmap)
        idx3 = il.Add(images.PageContacts.Bitmap)
        notebook.AssignImageList(il)

        self.create_page_merge_all(notebook)
        self.create_page_merge_chats(notebook)
        self.create_page_merge_contacts(notebook)

        notebook.SetPageImage(0, idx1)
        notebook.SetPageImage(1, idx2)
        notebook.SetPageImage(2, idx3)

        self.TopLevelParent.page_merge_latest = self
        self.TopLevelParent.run_console(
            "page12 = self.page_merge_latest # Merger tab")
        self.TopLevelParent.run_console(
            "db1, db2 = page12.db1, page12.db2 # Chosen Skype databases")

        self.Layout()
        self.load_data()
        busy.Close()


    def create_page_merge_all(self, notebook):
        """Creates a page for merging all chats at once."""
        page = self.page_merge_all = wx.lib.scrolledpanel.ScrolledPanel(notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Merge all")

        panel = wx.Panel(page, style=wx.BORDER_STATIC)
        label1 = self.label_all1 = wx.StaticText(panel, style=wx.ALIGN_RIGHT,
            label="%s\n\nAnalyzing..%s" % (self.db1.filename, "\n" * 7))
        bmp_arrow = wx.StaticBitmap(panel, bitmap=images.MergeToRight.Bitmap)
        label2 = self.label_all2 = wx.StaticText(panel,
            label="%s\n\nAnalyzing..%s" % (self.db2.filename, "\n" * 7))
        button_scan = self.button_scan_all = controls.NoteButton(panel,
            label="&Scan and report", note="Scan through the left database "
            "and find messages not present on the right.",
            bmp=images.ButtonScanDiff.Bitmap)
        button_merge = self.button_merge_all = controls.NoteButton(panel,
            label="&Merge to the right", note=self.MERGE_BUTTON_NOTE,
            bmp=images.ButtonMergeLeftMulti.Bitmap)
        panel_gauge = self.panel_gauge = wx.Panel(panel)
        label_gauge = self.label_gauge = wx.StaticText(panel_gauge, label="")
        gauge = self.gauge_progress = wx.Gauge(panel_gauge, size=(400, 15),
                                      style=wx.GA_HORIZONTAL | wx.PD_SMOOTH)
        html = self.html_report = \
            controls.ScrollingHtmlWindow(panel, style=wx.BORDER_SUNKEN)

        for c in [panel, button_scan, button_merge, panel_gauge]:
            c.BackgroundColour = conf.BgColour
        gauge.ForegroundColour = conf.GaugeColour
        button_scan.Enabled = button_merge.Enabled = False
        button_scan.MinSize = button_merge.MinSize = (400, -1)
        html.SetFonts(normal_face=self.Font.FaceName,
                      fixed_face=self.Font.FaceName, sizes=[8] * 7)
        html.BackgroundColour = conf.MergeHtmlBackgroundColour
        html.Hide()
        panel_gauge.Hide()

        page.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer = panel.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_top = wx.GridBagSizer(vgap=5, hgap=30)
        panel_gauge.Sizer = wx.BoxSizer(wx.VERTICAL)

        page.Sizer.Add(panel, proportion=1, border=5, flag=wx.GROW | wx.LEFT)
        sizer_top.Add(label1, flag=wx.ALIGN_RIGHT, pos=(0, 0))
        sizer_top.Add(bmp_arrow, flag=wx.ALIGN_CENTER, pos=(0, 1))
        sizer_top.Add(label2, pos=(0, 2))
        sizer_top.Add(button_scan, border=25, flag=wx.TOP | wx.GROW, pos=(1, 1), span=(1, 2))
        sizer_top.Add(button_merge, flag=wx.GROW, pos=(2, 1), span=(1, 2))
        panel_gauge.Sizer.Add(label_gauge, flag=wx.ALIGN_CENTER)
        panel_gauge.Sizer.Add(gauge, flag=wx.ALIGN_CENTER)
        sizer.Add(sizer_top, border=10, flag=wx.ALL | wx.ALIGN_CENTER)
        sizer.Add(panel_gauge, border=10, flag=wx.ALL | wx.GROW)
        sizer.Add(html, proportion=1, border=30, flag=wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.GROW)
        sizer_top.AddGrowableCol(0)
        sizer_top.AddGrowableCol(2)
        page.SetupScrolling()

        button_scan.Bind(wx.EVT_BUTTON, self.on_scan_all)
        button_merge.Bind(wx.EVT_BUTTON, self.on_merge_all)
        html.Bind(wx.html.EVT_HTML_LINK_CLICKED, self.on_click_htmldiff)


    def create_page_merge_chats(self, notebook):
        """Creates a page for seeing and merging differing chats."""
        page = self.page_merge_chats = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Chats")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
        splitter = self.splitter_merge = wx.SplitterWindow(
            parent=page, style=wx.BORDER_NONE
        )
        splitter.SetMinimumPaneSize(100)
        panel1 = wx.Panel(parent=splitter)
        panel2 = wx.Panel(parent=splitter)
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_top = wx.BoxSizer(wx.HORIZONTAL)

        sizer_top.Add(wx.StaticText(parent=panel1, label="&Chat comparison:",
                      name="chats_label"), flag=wx.ALIGN_CENTER)
        sizer_top.AddStretchSpacer()
        label_filter = wx.StaticText(panel1, label="Filter ch&ats:")
        sizer_top.Add(label_filter, flag=wx.ALL, border=5)
        edit_chatfilter = self.edit_chatfilter = wx.TextCtrl(
            parent=panel1, size=(75, -1))
        filter_tooltip = "Filter items in chat list"
        label_filter.SetToolTipString(filter_tooltip)
        edit_chatfilter.SetToolTipString(filter_tooltip)
        self.Bind(wx.EVT_TEXT, self.on_change_chatfilter, edit_chatfilter)
        sizer_top.Add(edit_chatfilter, flag=wx.BOTTOM | wx.ALIGN_TOP, border=5)
        sizer_top.AddSpacer(20)
        self.button_merge_chats = wx.Button(panel1, label="Merge &selected")
        chats_tooltip = "Merge differences in selected chats to the right"
        self.button_merge_chats.SetToolTipString(chats_tooltip)
        self.button_merge_chats.Enabled = False
        sizer_top.Add(self.button_merge_chats, flag=wx.ALIGN_TOP | wx.BOTTOM,
                      border=5)
        self.Bind(wx.EVT_BUTTON, self.on_merge_chats, self.button_merge_chats)
        sizer1.Add(sizer_top, flag=wx.GROW)

        list_chats = self.list_chats = controls.SortableListView(
            parent=panel1, style=wx.LC_REPORT, name="chats")
        list_chats.SetColumns(self.chats_list_columns)
        list_chats.SetColumnsMaxWidth(300)
        list_chats.SortListItems(3, 0) # Sort by last message in left
        list_chats.Enabled = False
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_change_list_chats,
                  list_chats)
        sizer1.Add(list_chats, proportion=1, flag=wx.GROW)

        label_chat = self.label_merge_chat = \
            wx.StaticText(parent=panel2, label="")
        splitter_diff = self.splitter_diff = wx.SplitterWindow(
            parent=panel2, style=wx.BORDER_NONE)
        splitter_diff.SetMinimumPaneSize(350)
        panel_stc1 = self.panel_stc1 = wx.Panel(parent=splitter_diff)
        panel_stc2 = self.panel_stc2 = wx.lib.scrolledpanel.ScrolledPanel(splitter_diff)
        panel_stc2.BackgroundColour = conf.BgColour
        sizer_stc1 = panel_stc1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer_stc2 = panel_stc2.Sizer = wx.BoxSizer(wx.VERTICAL)

        stc1 = self.stc_diff1 = ChatContentSTC(
            parent=panel_stc1, style=wx.BORDER_STATIC)
        stc1.SetAutoRetrieve(False)
        stc1.TEXT_NO_MESSAGES = "\nNo new messages to show."

        button_merge = self.button_merge_chat = controls.NoteButton(
            panel_stc2, label="&Merge to the right",
            note=self.MERGE_CHAT_BUTTON_NOTE, bmp=images.ButtonMergeLeft.Bitmap)
        button_export = self.button_export_chat = controls.NoteButton(
            panel_stc2, label="&Export messages",
            note="Export detected messages as HTML, text or spreadsheet.",
            bmp=images.ButtonExport.Bitmap)
        button_merge.Bind(wx.EVT_BUTTON, self.on_merge_chat)
        button_export.Bind(wx.EVT_BUTTON, self.on_export_chat)
        button_merge.BackgroundColour = conf.BgColour
        button_export.BackgroundColour = conf.BgColour
        button_merge.Enabled = button_export.Enabled = False

        sizer_stc1.Add(stc1, proportion=1, flag=wx.GROW)
        sizer_stc2.AddStretchSpacer()
        sizer_stc2.Add(button_merge, border=5, flag=wx.ALIGN_CENTER_VERTICAL | 
                       wx.ALL | wx.GROW)
        sizer_stc2.Add(button_export, border=5, flag=wx.ALIGN_CENTER_VERTICAL | 
                       wx.ALL | wx.GROW)
        sizer_stc2.AddStretchSpacer()
        sizer2.Add(label_chat, border=5, flag=wx.ALL)
        sizer2.Add(splitter_diff, proportion=1, flag=wx.GROW)

        sizer.AddSpacer(5)
        sizer.Add(splitter, border=5, proportion=1, flag=wx.GROW | wx.ALL)
        splitter_diff.SetSashGravity(0.5)
        splitter_diff.SplitVertically(panel_stc1, panel_stc2,
                                      sashPosition=self.Size.width)
        splitter.SplitHorizontally(panel1, panel2,
                                   sashPosition=self.Size.height / 3)
        panel_stc2.SetupScrolling()


    def create_page_merge_contacts(self, notebook):
        """Creates a page for seeing and merging differing contacts."""
        page = self.page_merge_contacts = wx.Panel(parent=notebook)
        self.pageorder[page] = len(self.pageorder)
        notebook.AddPage(page, "Contacts")
        sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)

        splitter = self.splitter_contacts = wx.SplitterWindow(
            parent=page, style=wx.BORDER_NONE
        )
        splitter.SetMinimumPaneSize(350)
        panel1 = wx.Panel(parent=splitter)
        panel2 = wx.lib.scrolledpanel.ScrolledPanel(splitter)
        panel2.BackgroundColour = conf.BgColour
        sizer1 = panel1.Sizer = wx.BoxSizer(wx.VERTICAL)
        sizer2 = panel2.Sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_top = wx.BoxSizer(wx.HORIZONTAL)
        lbl = wx.StaticText(parent=panel1, label="New &contacts on the left:",
                            name="contact_list_label")
        sizer_top.Add(lbl, flag=wx.ALIGN_BOTTOM)
        sizer_top.AddStretchSpacer()
        label_filter = wx.StaticText(panel1, label="Filter c&ontacts:")
        sizer_top.Add(label_filter, flag=wx.ALIGN_CENTER | wx.ALIGN_RIGHT | 
                      wx.RIGHT, border=5)
        edit_contactfilter = self.edit_contactfilter = wx.TextCtrl(
            parent=panel1, size=(75, -1))
        filter_tooltip = "Filter items in contact lists"
        label_filter.SetToolTipString(filter_tooltip)
        edit_contactfilter.SetToolTipString(filter_tooltip)
        self.Bind(wx.EVT_TEXT, self.on_change_contactfilter,
                  edit_contactfilter)
        sizer_top.Add(edit_contactfilter)

        list1 = self.list_contacts = controls.SortableListView(
            parent=panel1,  style=wx.LC_REPORT, name="contact_list")
        list1.SetColumns(self.contacts_list_columns)
        list1.SetColumnsMaxWidth(300)
        self.Bind(
            wx.EVT_LIST_ITEM_SELECTED, self.on_select_list_contacts, list1)
        self.Bind(
            wx.EVT_LIST_ITEM_DESELECTED, self.on_select_list_contacts, list1)
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_merge_contacts, list1)

        button1 = self.button_merge_contacts = controls.NoteButton(
            panel2, label="&Merge selected to the right",
            note="Copy selected contacts to the database on the right.",
            bmp=images.ButtonMergeLeft.Bitmap)
        button_all1 = self.button_merge_allcontacts = controls.NoteButton(
            panel2, label="Merge &all to the right",
            note="Copy all contacts to the database on the right.",
            bmp=images.ButtonMergeLeftMulti.Bitmap)
        button1.BackgroundColour = button_all1.BackgroundColour = conf.BgColour
        button1.Bind(wx.EVT_BUTTON, self.on_merge_contacts)
        button_all1.Bind(wx.EVT_BUTTON, self.on_merge_contacts)
        button1.Enabled = button_all1.Enabled = False
        sizer1.Add(sizer_top, flag=wx.GROW | wx.BOTTOM | wx.RIGHT, border=5)
        sizer1.Add(list1, proportion=1, flag=wx.GROW | wx.BOTTOM | wx.RIGHT,
                   border=5)
        sizer2.AddStretchSpacer()
        sizer2.Add(button1, flag=wx.ALIGN_CENTER_VERTICAL | wx.ALL | wx.GROW,
                   border=5)
        sizer2.Add(button_all1, flag=wx.ALIGN_CENTER_VERTICAL | wx.ALL | 
                   wx.GROW, border=5)
        sizer2.AddStretchSpacer()

        splitter.SplitVertically(panel1, panel2, sashPosition=self.Size.width)

        sizer.AddSpacer(10)
        sizer.Add(splitter, proportion=1, border=5,
                  flag=wx.GROW | wx.LEFT | wx.RIGHT)
        panel2.SetupScrolling()


    def split_panels(self):
        """
        Splits all SplitterWindow panels. To be called after layout in
        Linux wx 2.8, as otherwise panels do not get sized properly.
        """
        if not self:
            return
        sash_pos = self.Size[1] / 3
        panel1, panel2 = self.splitter_merge.Children
        self.splitter_merge.Unsplit()
        self.splitter_merge.SplitHorizontally(panel1, panel2, sash_pos)
        sash_pos = self.page_merge_contacts.Size[0] / 2
        panel1, panel2 = self.splitter_contacts.Children
        self.splitter_contacts.Unsplit()
        self.splitter_contacts.SplitVertically(panel1, panel2, sash_pos)


    def on_export_chat(self, event):
        """
        Handler for clicking to export a chat diff, displays a save file dialog
        and saves the current messages to file.
        """
        formatargs = collections.defaultdict(str); formatargs.update(self.chat)
        default = "Diff of %s" % conf.ExportChatTemplate % formatargs
        dialog = wx.FileDialog(parent=self, message="Save new messages",
            defaultDir=os.getcwd(), defaultFile=util.safe_filename(default),
            style=wx.FD_OVERWRITE_PROMPT | wx.FD_SAVE | wx.RESIZE_BORDER
        )
        dialog.Wildcard = export.CHAT_WILDCARD
        if wx.ID_OK == dialog.ShowModal():
            filepath = dialog.GetPath()
            dirname = os.path.dirname(filepath)
            filename = os.path.basename(filepath)
            extname = export.CHAT_EXTS[dialog.FilterIndex]
            if not filename.lower().endswith(".%s" % extname):
                filename += ".%s" % extname
                filepath = os.path.join(dirname, filename)
            busy = controls.BusyPanel(
                self, "Exporting \"%s\"." % self.chat["title"]
            )
            main.logstatus("Exporting to %s.", filepath)
            try:
                messages = self.db1.message_iterator(self.chat_diff["messages"])
                progressfunc = lambda *args: wx.SafeYield()
                export.export_chats([self.chat], dirname, filename,
                    self.db1, messages=messages, progress=progressfunc)
                main.logstatus_flash("Exported %s.", filepath)
                util.start_file(filepath)
            except Exception as e:
                errormsg = "Error saving %s:\n\n%s" % \
                           (filepath, traceback.format_exc())
                main.logstatus_flash(errormsg)
                wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
                wx.CallAfter(support.report_error, errormsg)
            finally:
                busy.Close()


    def on_click_htmldiff(self, event):
        """
        Handler for clicking a chat link in diff overview, opens the chat
        comparison in Chats page.
        """
        href = event.GetLinkInfo().Href
        chat = None
        for c in self.compared:
            if c["identity"] == href:
                chat = c
                break # break for c in self.compared
        if chat and self.page_merge_chats.Enabled:
            self.on_change_list_chats(chat=chat)
            self.notebook.SetSelection(self.pageorder[self.page_merge_chats])


    def on_worker_merge_result(self, event):
        """Handler for worker_merge result callback, updates UI and texts."""
        if event.result.get("type") in ["merge_left", "diff_merge_left"]:
            self.on_merge_all_result(event)
        elif "diff_left" == event.result.get("type"):
            self.on_scan_all_result(event)


    def on_worker_merge_callback(self, result):
        """Callback function for MergeThread, posts the data to self."""
        if self: # Check if instance is still valid (i.e. not destroyed by wx)
            wx.PostEvent(self, WorkerEvent(result=result))


    def on_swap(self, event):
        """
        Handler for clicking to swap left and right databases, changes data
        structures and UI content.
        """
        self.db1, self.db2 = self.db2, self.db1
        namespace = {"db1": self.db1, "db2": self.db2}
        label_title = step.Template(templates.MERGE_DB_LINKS).expand(namespace)
        self.html_dblabel.SetPage(label_title)
        self.html_dblabel.BackgroundColour = conf.WidgetColour
        self.con1diff, self.con2diff = self.con2diff, self.con1diff
        self.con1difflist, self.con2difflist = \
            self.con2difflist, self.con1difflist
        self.congroup1diff, self.congroup2diff = \
            self.congroup1diff, self.congroup2diff
        self.chats1, self.chats2 = self.chats2, self.chats1
        self.chats_diffdata.clear()
        self.chats_nodiff.clear()
        self.chat = None
        self.chat_diff = None
        self.is_scanned = False 

        for a, b in [(self.label_all1, self.label_all2)]:
            a.Label, b.Label = b.Label, a.Label

        self.label_merge_chat.Label = ""
        self.stc_diff1.ClearAll()
        self.button_merge_chat.Enabled = False
        self.button_export_chat.Enabled = False
        self.button_merge_chat.Note = self.MERGE_CHAT_BUTTON_NOTE

        # Swap left and right in data structures.
        for lst in [self.compared, self.con1diff, self.con2diff,
                    self.congroup1diff, self.congroup2diff]:
            for item in lst or []:
                for t in ["c", "messages", "g"]:
                    key1, key2 = "%s1" % t, "%s2" % t
                    if key1 in item and key2 in item:
                        item[key1], item[key2] = item[key2], item[key1]

        # Repopulate chat and contact lists
        self.list_contacts.Populate(self.con1difflist or [])
        self.list_chats.Populate(self.compared or [])

        # Update button states
        self.button_scan_all.Enabled = self.button_merge_all.Enabled = True
        self.button_merge_all.Note = self.MERGE_BUTTON_NOTE
        self.button_merge_contacts.Enabled = False
        self.button_merge_allcontacts.Enabled = self.list_contacts.ItemCount

        self.panel_gauge.Hide()
        self.html_report.Hide()

        self.Refresh()
        self.page_merge_all.Layout()
        self.Layout()


    def on_merge_chats(self, event):
        """Handler on choosing to merge the chats selected in chat list."""
        selected, selecteds = self.list_chats.GetFirstSelected(), []
        while selected >= 0:
            selecteds.append(self.list_chats.GetItemMappedData(selected)["c1"])
            selected = self.list_chats.GetNextSelected(selected)
        if selecteds:
            action = "Merge" if self.is_scanned else "Scan and merge"
            info = util.plural("selected chat", selecteds)
            message = ("%s differences in %s\n\nfrom %s\n\ninto %s?" %
                       (action, info, self.db1, self.db2))
            if wx.OK == wx.MessageBox(message, conf.Title,
            wx.ICON_INFORMATION | wx.CANCEL):
                self.button_swap.Enabled = False
                self.button_merge_chats.Enabled = False
                self.button_scan_all.Enabled = False
                self.button_merge_all.Enabled = False
                self.page_merge_chats.Enabled = False
                self.page_merge_contacts.Enabled = False
                self.update_gauge(self.gauge_progress, 0,
                                  "%s 0%% complete." % action)
                if not self.html_report.Shown:
                    self.html_report.Show()
                    self.html_report.ContainingSizer.Layout()
                self.html_report.SetPage("<body bgcolor='%s'><b>%s progress:"
                    "</b><br />" % (conf.MergeHtmlBackgroundColour, action))
                db1, db2 = self.db1, self.db2
                chats = list(filter(None, selecteds))
                if self.is_scanned:
                    type = "merge_left"
                    cc = [self.chats_diffdata.get(c["identity"]) for c in chats]
                    chats = list(filter(None, cc))
                else:
                    type = "diff_merge_left"
                params = locals()
                self.worker_merge.work(params)
                self.is_merging = True
                main.logstatus("Merging %s from %s to %s.", info, db1, db2)
                self.notebook.SetSelection(0)


    def on_link_db(self, event):
        """Handler on clicking a database link, opens the database tab."""
        self.TopLevelParent.load_database_page(event.GetLinkInfo().Href)


    def on_select_list_contacts(self, event):
        """
        Handler for changing selection in contacts list, updates button states.
        """
        lst = self.list_contacts
        self.button_merge_contacts.Enabled = lst.SelectedItemCount


    def on_click_link(self, event):
        """
        Handler for clicking a link in chat history, opens the link in system
        browser.
        """
        stc = event.EventObject
        if stc.GetStyleAt(event.Position) == self.stc_styles["link"]:
            # Go back and forth from position and get URL range.
            url_range = {-1: -1, 1: -1} # { start and end positions }
            for step in url_range:
                pos = event.Position
                while stc.GetStyleAt(pos + step) == self.stc_styles["link"]:
                    pos += step
                url_range[step] = pos
            url = stc.GetTextRange(url_range[-1], url_range[1] + 1)
            webbrowser.open(url)


    def on_change_chatfilter(self, event):
        """Handler for changing text in chat filter box, filters chat list."""
        self.list_chats.SetFilter(event.String.strip())


    def on_change_contactfilter(self, event):
        """
        Handler for changing text in chat filter box, filters contact lists.
        """
        lst = self.list_contacts
        lst.SetFilter(event.String.strip())
        self.button_merge_contacts.Enabled = lst.SelectedItemCount
        self.button_merge_allcontacts.Enabled = lst.ItemCount


    def on_change_list_chats(self, event=None, chat=None):
        """
        Handler for activating an item in the differing chats list,
        goes through all messages of the chat in both databases and shows
        those messages that are missing or different, for both left and
        right.
        """
        c = chat or self.list_chats.GetItemMappedData(event.Index)
        if not self.chat or c["identity"] != self.chat["identity"]:
            self.label_merge_chat.Label = "New in %s:" \
                % c["title_long_lc"]
            main.log("Comparing %s (%s vs %s).", c["title_long_lc"],
                     self.db1, self.db2)
            scrollpos = self.list_chats.GetScrollPos(wx.VERTICAL)
            index_selected = -1
            # Update item background in chats list
            for i in range(self.list_chats.ItemCount):
                if self.list_chats.GetItemMappedData(i) == self.chat:
                    self.list_chats.SetItemBackgroundColour(
                        i, self.list_chats.BackgroundColour)
                elif self.list_chats.GetItemMappedData(i) == c:
                    index_selected = i
                    self.list_chats.SetItemBackgroundColour(
                        i, conf.ListOpenedBgColour)
            if index_selected >= 0:
                delta = index_selected - scrollpos
                if delta < 0 or abs(delta) >= self.list_chats.CountPerPage:
                    nudge = -self.list_chats.CountPerPage / 2
                    self.list_chats.ScrollLines(delta + nudge)
            busy = controls.BusyPanel(
                self, "Diffing messages for %s." % c["title_long_lc"])

            try:
                diff = {"messages": [], "participants": []}
                data = self.chats_diffdata.get(c["identity"])
                if data:
                    diff = data["diff"] # Use cached diff if available
                elif not self.is_scanned \
                and c["identity"] not in self.chats_nodiff:
                    diff = self.worker_merge.get_chat_diff_left(c, self.db1,
                                                                self.db2)
                    data = {"chat": c, "diff": diff}
                    if any(diff.values()): # Cache new diff
                        self.chats_diffdata[c["identity"]] = data
                    else:
                        self.chats_nodiff[c["identity"]] = c
                elif c["identity"] not in self.chats_nodiff:
                    data = {"chat": c, "diff": diff}
                    self.chats_nodiff[c["identity"]] = data
                messages = list(self.db1.message_iterator(diff["messages"]))
                self.chat = c
                self.chat_diff = diff
                self.button_merge_chat.Enabled = len(messages)
                self.button_merge_chat.Note = self.MERGE_CHAT_BUTTON_NOTE
                self.button_export_chat.Enabled = len(messages)
                if messages:
                    self.button_merge_chat.Note = (
                        "Copy %s to the database on the right." % 
                        util.plural("chat message", messages))
                    self.button_merge_chat.ContainingSizer.Layout()
                idx = -conf.MaxHistoryInitialMessages
                self.stc_diff1.Populate(c, self.db1, messages, from_index=idx)
                textlength = self.stc_diff1.TextLength
                self.stc_diff1.SetSelection(textlength, textlength)
            finally:
                busy.Close()


    def on_merge_contacts(self, event):
        """
        Handler for clicking to merge contacts from one database to the other,
        either selected or all contacts, depending on button clicked.
        """
        button = event.EventObject
        db_target, db_source = self.db2, self.db1
        list_source = self.list_contacts
        source = 0
        contacts, contactgroups, indices = [], [], []
        if button is self.button_merge_allcontacts:
            for i in range(list_source.ItemCount):
                data = list_source.GetItemMappedData(i)
                if "Contact" == data["__type"]:
                    contacts.append(data["__data"])
                else:
                    contactgroups.append(data["__data"])
                indices.append(i)
        else:
            selected = list_source.GetFirstSelected()
            while selected >= 0:
                data = list_source.GetItemMappedData(selected)
                if "Contact" == data["__type"]:
                    contacts.append(data["__data"])
                else:
                    contactgroups.append(data["__data"])
                indices.append(selected)
                selected = list_source.GetNextSelected(selected)
        # Contacts and contact groups are shown in the same list. If a contact
        # group is chosen, it can include contacts not yet in target database.
        contacts_target_final = dict([(c["identity"], c) for c in contacts])
        contacts_target_final.update(dict((c["identity"], c) 
                                          for c in db_target.get_contacts()))
        contacts_source = dict((c['identity'], c)
                               for c in db_source.get_contacts())
        for group in contactgroups:
            members = set(group["members"].split(" "))
            for new in members.difference(contacts_target_final):
                contacts.append(contacts_source[new])
        text_add = ""
        if contacts:
            text_add += util.plural("contact", contacts)
        if contactgroups:
            text_add += (" and " if contacts else "") \
                       + util.plural("contact group", contactgroups)
        if (contacts or contactgroups) and wx.OK == wx.MessageBox(
                "Copy %s\n\nfrom %s\n\ninto %s?" %
                (text_add, self.db1, self.db2),
                conf.Title, wx.OK | wx.CANCEL | wx.ICON_INFORMATION):
            self.is_merging = True
            try:
                if contacts:
                    db_target.insert_contacts(contacts, db_source)
                if contactgroups:
                    db_target.replace_contactgroups(contactgroups, db_source)
            finally:
                self.is_merging = False
            for i in sorted(indices)[::-1]:
                list_source.DeleteItem(i)
            condiff = [self.con1diff, self.con2diff][source]
            cgdiff = [self.congroup1diff, self.congroup1diff][source]
            difflist = [self.con1difflist, self.con1difflist][source]
            for c in [contacts, contactgroups]:
                [l.remove(c) for l in [condiff, cgdiff, difflist] if c in l]
            db_target.clear_cache()
            self.button_merge_contacts.Enabled = False
            self.button_merge_allcontacts.Enabled = list_source.ItemCount
            main.log("Copied %s from %s into %s.", text_add, self.db1, self.db2)
            wx.MessageBox("Copied %s\n\nfrom %s\n\ninto %s." % (text_add,
                self.db1, self.db2), conf.Title, wx.OK | wx.ICON_INFORMATION)


    def on_scan_all(self, event):
        """
        Handler for clicking to scan for differences with the left database,
        starts scanning process.
        """
        main.logstatus("Scanning differences between %s and %s.",
                       self.db1, self.db2)
        self.chats_diffdata.clear()
        self.button_merge_all.Enabled = False
        self.button_scan_all.Enabled = False
        self.button_swap.Enabled = False
        self.button_merge_chats.Enabled = False
        if not self.html_report.Shown:
            self.html_report.Show()
            self.html_report.ContainingSizer.Layout()
        html = ("<body bgcolor='%s'><font color='%s'<b>Scan results:</b>"
                "<br /><br />" %
                (conf.MergeHtmlBackgroundColour, conf.FgColour))
        self.html_report.SetPage(html)
        self.update_gauge(self.gauge_progress, 0, "Scanning messages.")
        params = {"db1": self.db1, "db2": self.db2, "type": "diff_left"}
        self.worker_merge.work(params)
        self.is_scanning = True


    def on_scan_all_result(self, event):
        """
        Handler for getting diff results from worker thread, adds the results
        to the diff windows.
        """
        result = event.result
        for d in result["chats"]:
            self.chats_diffdata[d["chat"]["identity"]] = d
        if result.get("output") and "done" not in result:
            self.html_report.Freeze()
            scrollpos = self.html_report.GetScrollPos(wx.VERTICAL)
            self.html_report.AppendToPage(result["output"])
            self.html_report.Scroll(0, scrollpos)
            self.html_report.Thaw()
        if "status" in result:
            main.status_flash(result["status"])
        i, count = result["index"] + 1, len(self.chats1)
        percent = math.ceil(100 * util.safedivf(i, count))
        msg = "Scan %d%% complete (%s of %s)." % \
              (percent, i + 1, util.plural("conversation", count))
        self.update_gauge(self.gauge_progress, percent, msg)
        if "done" in result:
            self.is_scanning = False
            self.is_scanned = True
            s1 = util.plural("differing chat", self.chats_diffdata)
            main.logstatus_flash("Found %s in %s.", s1, self.db1)
            self.button_swap.Enabled = True
            self.button_merge_chats.Enabled = True
            fields = ["chat", "message"]
            if self.chats_diffdata:
                count_msgs = util.plural(
                    "message", sum(len(d["diff"]["messages"])
                                   for d in self.chats_diffdata.values()))
                count_chats = util.plural("chat", self.chats_diffdata)
                noteinfo = "%s from %s" % (count_msgs, count_chats)
                self.button_merge_all.Note = (
                    "Copy %s to the database on the right." % noteinfo)
                self.button_merge_all.Enabled = True
                self.html_report.AppendToPage(
                    "<br /><br />New in %s: %s in %s." % 
                    (self.db1, count_msgs, count_chats))
                scrollpos = (0, self.html_report.GetScrollRange(wx.VERTICAL))
                self.html_report.Scroll(*scrollpos)
            else:
                self.html_report.SetPage("<body bgcolor='%s'>No new messages."
                    "</body>" % conf.MergeHtmlBackgroundColour)
            self.update_gauge(self.gauge_progress, 100, "Scan complete.")
            wx.Bell()


    def on_merge_all(self, event):
        """
        Handler for clicking to copy all the differences to the other
        database, asks for final confirmation and executes.
        """
        db1, db2 = self.db1, self.db2
        if self.is_scanned:
            count_msgs = util.plural(
                "message", sum(len(d["diff"]["messages"])
                               for d in self.chats_diffdata.values()))
            count_chats = util.plural("chat", self.chats_diffdata)
            info = "%s in %s" % (count_msgs, count_chats)
            message = "Copy %s\n\nfrom %s\n\ninto %s?" % (info, db1, db2)
            type = "merge_left"
            chats = list(self.chats_diffdata.values())
        else:
            info = "any differences"
            message = ("Scan and merge chat differences\n\nfrom %s\n\ninto %s?"
                       % (db1, db2))
            type = "diff_merge_left"
        response = wx.MessageBox(message, conf.Title,
                                 wx.OK | wx.CANCEL | wx.ICON_INFORMATION)
        if wx.OK == response:
            self.update_gauge(self.gauge_progress, 0, "Merge 0% complete.")
            self.button_swap.Enabled = False
            self.button_merge_chats.Enabled = False
            self.button_scan_all.Enabled = self.button_merge_all.Enabled = False
            if not self.html_report.Shown:
                self.html_report.Show()
                self.html_report.ContainingSizer.Layout()
            self.html_report.SetPage("<body bgcolor='%s'><b>Merge progress:"
                "</b><br />" % conf.MergeHtmlBackgroundColour)
            self.page_merge_chats.Enabled = False
            self.page_merge_contacts.Enabled = False
            main.logstatus("Merging %s from %s to %s.", info, db1, db2)
            params = locals()
            self.worker_merge.work(params)
            self.is_merging = True


    def on_merge_all_result(self, event):
        """
        Handler for getting merge results from worker thread, refreshes texts
        and UI controls.
        """
        result = event.result
        action = ("Merge" if "merge_left" == result["type"]
                  else "Scan and merge")
        if "index" in result:
            i, count = result["index"] + 1, result["count"]
            percent = math.ceil(100 * util.safedivf(i, count))
            msg = "%s %d%% complete (%s of %s)." % \
                  (action, percent, i, util.plural("conversation", count))
            self.update_gauge(self.gauge_progress, percent, msg)
            for chat in result.get("chats", []):
                if chat["identity"] in self.chats_diffdata:
                    del self.chats_diffdata[chat["identity"]]
        if "error" in result:
            self.is_merging = False
            self.update_gauge(self.gauge_progress, 0, "%s error." % action)
            main.log("%s error.\n\n%s", action, result["error"])
            msg = "%s error.\n\n%s" % (action, 
                  result.get("error_short", result["error"]))
            scrollpos = (0, self.html_report.GetScrollPos(wx.VERTICAL))
            self.html_report.AppendToPage("<br /> <b>Error merging chats:</b>"
                                          + result["error"])
            self.html_report.Scroll(*scrollpos)
            wx.MessageBox(msg, conf.Title, wx.OK | wx.ICON_WARNING)
            wx.CallAfter(support.report_error, result["error"])
        if "status" in result:
            main.status_flash(result["status"])
        if "done" in result:
            self.is_merging = False
            self.page_merge_chats.Enabled = True
            self.page_merge_contacts.Enabled = True
            self.db2.clear_cache()
            self.stc_diff1.ClearAll()
            self.list_chats.DeleteAllItems()
            self.list_contacts.DeleteAllItems()
            self.label_merge_chat.Label = ""
            self.chat = None
            self.chat_diff = None
            self.chats2 = self.db2.get_conversations()
            info = result["output"]
            if "error" not in result:
                main.logstatus_flash(info)
                self.update_gauge(self.gauge_progress, 100, "Merge complete.")
                text = "<br /><br /> %s" % result["output"]
                self.html_report.Freeze()
                self.html_report.AppendToPage(text)
                scrollpos = (0, self.html_report.GetScrollRange(wx.VERTICAL))
                self.html_report.Scroll(*scrollpos)
                self.html_report.Thaw()
                wx.MessageBox(info, conf.Title, wx.OK | wx.ICON_INFORMATION)
            self.button_merge_all.Note = self.MERGE_BUTTON_NOTE
            self.button_swap.Enabled = True
            self.button_merge_chats.Enabled = True
            wx.CallLater(20, self.load_later_data)
            if self.is_scanned and self.chats_diffdata:
                count_msgs = util.plural(
                    "message", sum(len(d["diff"]["messages"])
                                   for d in self.chats_diffdata.values()))
                count_chats = util.plural("chat", self.chats_diffdata)
                noteinfo = "%s from %s" % (count_msgs, count_chats)
                self.button_merge_all.Note = (
                    "Copy %s to the database on the right." % noteinfo)
                self.button_merge_all.Enabled = True
        elif "output" in result and result["output"]:
            scrollpos = (0, self.html_report.GetScrollPos(wx.VERTICAL))
            self.html_report.Freeze()
            self.html_report.AppendToPage("<br /> %s" % result["output"])
            self.html_report.Scroll(*scrollpos)
            self.html_report.Thaw()


    def update_gauge(self, gauge, value, message=""):
        """
        Updates the gauge value and message on page_merge_all. If value is
        None, hides gauge panel.
        """
        if value is None:
            gauge.Hide()
        else:
            gauge.Value = value
            for c in gauge.Parent.Children:
                if isinstance(c, wx.StaticText):
                    c.Label = message
                    break # break for c in gauge..
            gauge.Parent.Sizer.Layout()
            if not gauge.Parent.Shown:
                gauge.Parent.Show()
                gauge.Parent.ContainingSizer.Layout()


    def on_merge_chat(self, event):
        """
        Handler for clicking to merge a chat from left side db to the right
        side db.
        """
        if self.is_scanning or self.is_merging:
            wx.MessageBox("Global %(t)s is currently underway: single chat "
                          "merge temporarily disabled for data safety.\n\n"
                          "Please wait until the global %(t)s is finished."
                          % {"t": "merge" if self.is_merging else "scan"},
                          conf.Title, wx.OK | wx.ICON_WARNING)
            return
        db1, db2 = self.db1, self.db2
        chat, chat2 = self.chat["c1"], self.chat["c2"]
        messages = self.chat_diff["messages"]
        participants = self.chat_diff["participants"]
        condiff = self.con1diff
        contacts2 = []

        if messages or participants:
            info = ""
            parts = []
            new_chat = not chat2
            newstr = "" if new_chat else "new "
            if new_chat:
                info += "new chat with "
            if messages:
                parts.append(util.plural("%smessage" % newstr, messages))
            if participants:
                # Add to contacts those that are new
                cc2 = [db1.id, db2.id] + \
                    [i["identity"] for i in db2.get_contacts()]
                contacts2 = [i["contact"] for i in participants
                    if "id" in i["contact"] and i["identity"] not in cc2]
                if contacts2:
                    parts.append(util.plural("new contact", contacts2))
                parts.append(util.plural("%sparticipant" % newstr,
                                         participants))
            for i in parts:
                info += ("" if i == parts[0] else (
                         " and " if i == parts[-1] else ", ")) + i

            proceed = wx.OK == wx.MessageBox(
                "Copy %s\n\nfrom %s\n\ninto %s?" % (info, db1, db2),
                conf.Title, wx.OK | wx.CANCEL | wx.ICON_INFORMATION)
            if proceed:
                self.is_merging = True
                try:
                    if not chat2:
                        chat2 = chat.copy()
                        self.chat["c2"] = chat2
                        chat2["id"] = db2.insert_chat(chat2, db1)
                    if participants:
                        if contacts2:
                            db2.insert_contacts(contacts2, db1)
                        for p in participants:
                            if p in condiff:
                                condiff.remove(p)
                        db2.insert_participants(chat2, participants, db1)
                        del participants[:]
                    if messages:
                        db2.insert_messages(chat2, messages, db1, chat)
                        del messages[:]
                finally:
                    self.is_merging = False
                if chat["identity"] in self.chats_diffdata:
                    del self.chats_diffdata[chat["identity"]]
                db2.clear_cache()
                self.stc_diff1.ClearAll()
                self.button_merge_chat.Enabled = False
                self.button_export_chat.Enabled = False
                main.logstatus_flash("Merged %s of chat \"%s\" from %s to %s.",
                                     info, chat2["title"], db1, db2)
                # Update chat list
                db2.get_conversations_stats([chat2], log=False)
                self.chat["messages2"] = chat2["message_count"]
                self.chat["last_message_datetime2"] = \
                    chat2["last_message_datetime"]
                for i in range(self.list_chats.ItemCount):
                    chat_i = self.list_chats.GetItemMappedData(i)
                    if chat_i == self.chat:
                        self.list_chats.SetItemBackgroundColour(
                            i, self.list_chats.BackgroundColour)
                self.list_chats.RefreshRows() # Update from loaded data
                infomsg = "Merged %s of chat \"%s\"\n\nfrom %s\n\nto %s." % \
                          (info, chat2["title"], db1, db2)
                wx.MessageBox(infomsg, conf.Title, wx.OK | wx.ICON_INFORMATION)


    def update_tabheader(self):
        """Updates page tab header with option to close page."""
        if self:
            self.ready_to_close = True
        if self:
            self.TopLevelParent.update_notebook_header()


    def load_data(self):
        """Loads data from our SkypeDatabases."""
        namespace = {"db1": self.db1, "db2": self.db2}
        label_title = step.Template(templates.MERGE_DB_LINKS).expand(namespace)
        self.html_dblabel.SetPage(label_title)
        self.html_dblabel.BackgroundColour = conf.WidgetColour

        try:
            # Populate the chat comparison list
            chats1 = self.db1.get_conversations()
            chats2 = self.db2.get_conversations()
            c1map = dict((c["identity"], c) for c in chats1)
            c2map = dict((c["identity"], c) for c in chats2)
            compared = []
            for c1 in chats1:
                c1["c1"], c1["c2"] = c1.copy(), c2map.get(c1["identity"])
                compared.append(c1)
            for c2 in chats2:
                if c2["identity"] not in c1map:
                    c2["c1"], c2["c2"] = None, c2.copy()
                    compared.append(c2)
            for c in compared:
                c["last_message_datetime1"] = None
                c["last_message_datetime2"] = None
                c["messages1"] = c["messages2"] = c["people"] = None

            self.list_chats.Populate(compared)
            self.list_chats.SortListItems(3, 0) # Sort by last message in left
            self.compared = compared
            self.chats1 = chats1
            self.chats2 = chats2
            wx.CallLater(200, self.load_later_data)
        except Exception as e:
            wx.CallAfter(self.update_tabheader)
            errormsg = "Could not load chat lists from %s and %s.\n\n%s" % \
                       (self.db1, self.db2, traceback.format_exc())
            main.logstatus_flash(errormsg)
            wx.MessageBox(errormsg, conf.Title, wx.OK | wx.ICON_WARNING)
            wx.CallAfter(support.report_error, errormsg)


    def load_later_data(self):
        """
        Loads later data from the databases, like message counts and compared
        contacts, used as a background callback to speed up page opening.
        """
        try:
            chats1, chats2 = self.chats1, self.chats2
            self.db1.get_conversations_stats(chats1)
            self.db2.get_conversations_stats(chats2)
            c1map = dict((c["identity"], c) for c in chats1)
            c2map = dict((c["identity"], c) for c in chats2)

            if self.compared is None:
                compared = []
                for c1 in chats1:
                    c1["c1"], c1["c2"] = c1.copy(), c2map.get(c1["identity"])
                    compared.append(c1)
                for c2 in chats2:
                    if c2["identity"] not in c1map:
                        c2["c1"], c2["c2"] = None, c2.copy()
                        compared.append(c2)
                for c in compared:
                    c["last_message_datetime1"] = None
                    c["last_message_datetime2"] = None
                    c["messages1"] = c["messages2"] = c["people"] = None
            for c in self.compared:
                for i in range(2):
                    cmap = c2map if i else c1map
                    if c["c%s" % (i + 1)] and c["identity"] in cmap:
                        c["messages%s" % (i + 1)] = \
                            cmap[c["identity"]]["message_count"]
                        c["last_message_datetime%s" % (i + 1)] = \
                            cmap[c["identity"]]["last_message_datetime"]
                people = sorted([p["identity"] for p in c["participants"]])
                if skypedata.CHATS_TYPE_SINGLE != c["type"]:
                    c["people"] = "%s (%s)" % (len(people), ", ".join(people))
                else:
                    people = [p for p in people if p != self.db1.id]
                    c["people"] = ", ".join(people)

            self.list_chats.Enabled = True
            self.list_chats.Populate(self.compared)

            # Populate the contact comparison list
            contacts1 = self.db1.get_contacts()
            contacts2 = self.db2.get_contacts()
            contactgroups1 = self.db1.get_contactgroups()
            contactgroups2 = self.db2.get_contactgroups()
            con1map = dict((c["identity"], c) for c in contacts1)
            con2map = dict((c["identity"], c) for c in contacts2)
            con1diff, con2diff = [], []
            con1new, con2new = {}, {} # New contacts for dbs {skypename:row, }
            cg1diff, cg2diff = [], []
            cg1map = dict((g["name"], g) for g in contactgroups1)
            cg2map = dict((g["name"], g) for g in contactgroups2)
            for c1 in contacts1:
                c2 = con2map.get(c1["identity"])
                if not c2 and c1["identity"] not in con1new:
                    c = c1.copy()
                    c["c1"], c["c2"] = c1, c2
                    con1diff.append(c)
                    con1new[c1["identity"]] = True
            for c2 in contacts2:
                c1 = con1map.get(c2["identity"])
                if not c1 and c2["identity"] not in con2new:
                    c = c2.copy()
                    c["c1"], c["c2"] = c1, c2
                    con2diff.append(c)
                    con2new[c2["identity"]] = True
            for g1 in contactgroups1:
                g2 = cg2map.get(g1["name"])
                if not g2 or g2["members"] != g1["members"]:
                    g = g1.copy()
                    g["g1"] = g1
                    g["g2"] = g2
                    cg1diff.append(g)
            for g2 in contactgroups2:
                g1 = cg1map.get(g2["name"])
                if not g1 or g1["members"] != g2["members"]:
                    g = g2.copy()
                    g["g1"] = g1
                    g["g2"] = g2
                    cg2diff.append(g)
            dummy = {"__type": "Group", "phone_mobile_normalized": "",
                "country": "", "city": "", "about": "About"}
            con1difflist = [c.copy() for c in con1diff]
            [c.update({"__type": "Contact", "__data": c}) for c in con1difflist]
            for g in cg1diff:
                c = g.copy()
                c.update(dummy)
                c["identity"], c["__data"] = c["members"], g
                con1difflist.append(c)
            con2difflist = [c.copy() for c in con2diff]
            [c.update({"__type":"Contact", "__data": c}) for c in con2difflist]
            for g in cg2diff:
                c = g.copy()
                c.update(dummy)
                c["identity"], c["__data"] = c["members"], g
                con2difflist.append(c)
            self.list_contacts.Populate(con1difflist)
            self.button_merge_allcontacts.Enabled = self.list_contacts.ItemCount
            self.con1diff = con1diff
            self.con2diff = con2diff
            self.con1difflist = con1difflist
            self.con2difflist = con2difflist
            self.congroup1diff = cg1diff
            self.congroup2diff = cg2diff

            for i in range(2):
                db = self.db2 if i else self.db1
                db.update_fileinfo()
                label = self.label_all2 if i else self.label_all1
                label.Label = "%s.\n\nSize %s.\nLast modified %s.\n" % (
                              db, util.format_bytes(db.filesize),
                              db.last_modified.strftime("%Y-%m-%d %H:%M:%S"))
            for i in range(2):
                db = self.db2 if i else self.db1
                tables = db.get_tables()
                condiff = self.con2diff if i else self.con1diff
                contacts = contacts2 if i else contacts1
                db.update_fileinfo()
                label = self.label_all2 if i else self.label_all1
                label.Label = "%s.\n\nSize %s.\nLast modified %s.\n" % (
                              db, util.format_bytes(db.filesize),
                              db.last_modified.strftime("%Y-%m-%d %H:%M:%S"))
                chats = chats2 if i else chats1
                if chats:
                    t1 = list(filter(
                         None, [c["message_count"] for c in chats]))
                    count_messages = sum(t1) if t1 else 0
                    t2 = list(filter(
                         None, [c["first_message_datetime"] for c in chats]))
                    datetime_first = min(t2) if t2 else None
                    t3 = list(filter(
                         None, [c["last_message_datetime"] for c in chats]))
                    datetime_last = max(t3) if t3 else None
                    datetext_first = "" if not datetime_first \
                        else datetime_first.strftime("%Y-%m-%d %H:%M:%S")
                    datetext_last = "" if not datetime_last \
                        else datetime_last.strftime("%Y-%m-%d %H:%M:%S")
                    contacttext = util.plural("contact", contacts)
                    if condiff:
                        contacttext += " (%d not present on the %s)" % (
                                       len(condiff), ["right", "left"][i])
                    label.Label += "%s.\n%s.\n%s.\nFirst message at %s.\n" \
                                   "Last message at %s." % (
                                   util.plural("conversation", chats),
                                   util.plural("message", count_messages), 
                                   contacttext, datetext_first, datetext_last)
        except Exception as e:
            # Database access can easily fail if the user closes the tab before
            # the later data has been loaded.
            if self:
                main.log("Error loading additional data from %s or %s.\n\n%s",
                         self.db1, self.db2, traceback.format_exc())
                wx.MessageBox("Error loading additional data from %s or %s."
                              "\n\nError: %s." % (self.db1, self.db2, e),
                              conf.Title, wx.OK | wx.ICON_WARNING)

        if self:
            self.button_swap.Enabled = True
            self.button_merge_chats.Enabled = True
            if not self.is_scanned:
                self.button_scan_all.Enabled = True
                self.button_merge_all.Enabled = True
            main.status_flash("Opened Skype databases %s and %s.",
                              self.db1, self.db2)
            self.page_merge_all.Layout()
            self.Refresh()
            if "linux2" == sys.platform and wx.version().startswith("2.8"):
                wx.CallAfter(self.split_panels)
            wx.CallAfter(self.update_tabheader)



class ChatContentSTC(controls.SearchableStyledTextCtrl):
    """A StyledTextCtrl for showing and filtering chat messages."""

    TEXT_NO_MESSAGES = "\nNo messages to show."

    def __init__(self, *args, **kwargs):
        controls.SearchableStyledTextCtrl.__init__(self, *args, **kwargs)
        self.SetUndoCollection(False)

        self._parser = None     # Current skypedata.MessageParser instance
        self._chat = None       # Currently shown chat
        self._db = None         # Database for currently shown messages
        self._page = None       # DatabasePage/MergerPage for action callbacks
        self._messages = None   # All retrieved messages (collections.deque)
        self._messages_current = None  # Currently shown (collections.deque)
        self._message_positions = {} # {msg id: (start index, end index)}
        # If set, range is centered around the message with the specified ID
        self._center_message_id =    -1
        # Index of the centered message in _messages
        self._center_message_index = -1
        self._filelinks = {} # {link end position: file path}
        self._datelinks = {} # {link end position: two dates, }
        self._datelink_last = None # Title of clicked date link, if any
        # Currently set message filter {"daterange": (datetime, datetime),
        # "text": text in message, "participants": [skypename1, ],
        # "message_id": message ID to show, range shown will be centered
        # around it}
        self._filter = {}
        self._filtertext_rgx = None # Cached regex for filter["text"]
        self._auto_retrieve = True # Whether new messages retrieved on refresh

        self._styles = {"default": 10, "bold": 11, "timestamp": 12,
            "remote": 13, "local": 14, "link": 15, "tiny": 16,
            "special": 17, "bolddefault": 18, "boldlink": 19,
            "boldspecial": 20, "remoteweak": 21, "localweak": 22,
        }
        stylespecs = {
            "default":      "face:%s,size:%d,fore:%s,back:%s" %
                            (conf.HistoryFontName, conf.HistoryFontSize,
                             conf.MessageTextColour, conf.BgColour),
            "bolddefault": "bold",
            "bold":        "bold",
            "timestamp":   "fore:%s" % conf.HistoryTimestampColour,
            "remote":      "fore:%s,bold" % conf.HistoryRemoteAuthorColour,
            "local":       "fore:%s,bold" % conf.HistoryLocalAuthorColour,
            "remoteweak":  "fore:%s" % conf.HistoryRemoteAuthorColour,
            "localweak":   "fore:%s" % conf.HistoryLocalAuthorColour,
            "link":        "fore:%s" % conf.SkypeLinkColour,
            "boldlink":    "fore:%s,bold" % conf.SkypeLinkColour,
            "tiny":        "size:1",
            "special":     "fore:%s" % conf.HistoryGreyColour,
            "boldspecial": "fore:%s,bold" % conf.HistoryGreyColour,
        }
        self.StyleSetSpec(wx.stc.STC_STYLE_DEFAULT, stylespecs["default"])
        self.StyleClearAll() # Apply the new default style to all styles
        for style, spec in stylespecs.items():
            self.StyleSetSpec(self._styles[style], spec)
        self.StyleSetHotSpot(self._styles["link"], True)
        self.StyleSetHotSpot(self._styles["boldlink"], True)
        self.SetWrapMode(True)
        self.SetMarginLeft(10)
        self.SetReadOnly(True)
        self.Bind(wx.stc.EVT_STC_HOTSPOT_CLICK, self.OnUrl)
        # Hide caret
        self.SetCaretForeground(conf.BgColour)
        self.SetCaretWidth(0)


    def SetDatabasePage(self, page):
        self._page = page


    def OnUrl(self, event):
        """
        Handler for clicking a link in chat history, opens the link in system
        browser.
        """
        stc = event.EventObject
        styles_link = [self._styles["link"], self._styles["boldlink"]]
        if stc.GetStyleAt(event.Position) in styles_link:
            # Go back and forth from position and get URL range.
            url_range = {-1: -1, 1: -1} # { start and end positions }
            for step in url_range:
                pos = event.Position
                while stc.GetStyleAt(pos + step) in styles_link:
                    pos += step
                url_range[step] = pos
            url_range[1] += 1
            url = stc.GetTextRange(url_range[-1], url_range[1])
            function, params = None, []
            if url_range[-1] in self._filelinks:
                def start_file(url):
                    if os.path.exists(url):
                        util.start_file(url)
                    else:
                        messageBox("The file \"%s\" cannot be found "
                                   "on this computer." % url,
                                   conf.Title, wx.OK | wx.ICON_INFORMATION)
                function, params = start_file, [self._filelinks[url_range[-1]]]
            elif url_range[-1] in self._datelinks:
                def filter_range(label, daterange):
                    busy = controls.BusyPanel(self._page or self.Parent,
                                              "Filtering messages.")
                    try:
                        self._datelink_last = label
                        if self._page:
                            self._page.chat_filter["daterange"] = daterange
                            self._page.range_date.SetValues(*daterange)
                        newfilter = self.Filter
                        newfilter["daterange"] = daterange
                        self.Filter = newfilter
                        self.RefreshMessages(), self.ScrollToLine(0)
                        if self._page:
                            self._page.populate_chat_statistics()
                    finally:
                        busy.Close()
                function = filter_range
                params = [url, self._datelinks[url_range[-1]]]
            elif url:
                function, params = webbrowser.open, [url]
            if function:
                # Calling function here immediately will cause STC to lose
                # MouseUp, resulting in autoselect mode from click position.
                wx.CallLater(50, function, *params)
        event.StopPropagation()


    def SetAutoRetrieve(self, retrieve):
        """Sets whether to auto-retrieve more messages."""
        self._auto_retrieve = retrieve


    def RetrieveMessagesIfNeeded(self):
        """
        Retrieves more messages if needed, for example if current filter
        specifies a larger date range than currently available.
        """

        if not self._messages_current and "daterange" in self._filter \
        and self._filter["daterange"][0]:
            # If date filtering was just applied, check if we need to
            # retrieve more messages from earlier (messages are retrieved
            # starting from latest).
            if not self._messages[0]["datetime"] \
            or self._messages[0]["datetime"].date() \
            >= self._filter["daterange"][0]:
                m_iter = self._db.get_messages(self._chat,
                    ascending=False,
                    timestamp_from=self._messages[0]["timestamp"]
                )
                while m_iter:
                    try:
                        m = m_iter.next()
                        self._messages.appendleft(m)
                        if m["datetime"].date() < self._filter["daterange"][0]:
                            m_iter = None
                    except StopIteration as e:
                        m_iter = None
        last_dt = self._chat.get("last_message_datetime")
        if self._messages and last_dt \
        and self._messages[-1]["datetime"] < last_dt:
            # Last message timestamp is earlier than chat's last message
            # timestamp: new messages have arrived
            m_iter = self._db.get_messages(self._chat,
                ascending=True, use_cache=False,
                timestamp_from=self._messages[-1]["timestamp"]
            )
            while m_iter:
                try:
                    m = m_iter.next()
                    self._messages.append(m)
                except StopIteration as e:
                    m_iter = None


    def RefreshMessages(self, center_message_id=None):
        """
        Clears content and redisplays messages of current chat.

        @param   center_message_id  if specified, message with the ID is
                                    focused and message range will center
                                    around it, staying within max number
        """
        self.SetReadOnly(False) # Can't modify while read-only
        self.ClearAll()
        self._parser = skypedata.MessageParser(self._db, self._chat, stats=True)
        if self._messages:
            if self._auto_retrieve:
                self.RetrieveMessagesIfNeeded()
            self.AppendText("Formatting messages..\n")
            self.Refresh()
            self.Freeze()
            self.ClearAll()

            if center_message_id:
                index = 0
                for m in self._messages:
                    if m["id"] == center_message_id:
                        self._center_message_id = center_message_id
                        self._center_message_index = index
                        break
                    index += 1

            colourmap = collections.defaultdict(lambda: "remote")
            colourmap[self._db.id] = "local"
            self._message_positions.clear()
            previous_day = datetime.date.fromtimestamp(0)
            count = 0
            focus_message_id = None
            self._filelinks.clear()
            self._datelinks.clear()
            # For accumulating various statistics
            rgx_highlight = re.compile(
                "(%s)" % re.escape(self._filter["text"]), re.I
            ) if ("text" in self._filter and self._filter["text"]) else None
            self._messages_current = collections.deque()

            # Assemble messages to show
            for m in self._messages:
                count += 1
                if self.IsMessageFilteredOut(m):
                    continue
                if self._center_message_index >= 0 \
                and count < self._center_message_index \
                - conf.MaxHistoryInitialMessages / 2:
                    # Skip messages before the range centered around a message
                    continue
                if self._center_message_index >= 0 \
                and count > self._center_message_index \
                + conf.MaxHistoryInitialMessages / 2:
                    # Skip messages after the range centered around a message
                    break # break for m in self._messages

                self._messages_current.append(m)

            # Add date and count information, links like "6 months"
            self._append_text("\n")
            if self._messages_current:
                m1, m2 = self._messages_current[0], self._messages_current[-1]
                self._append_text("History of  ")
                self._append_text(m1["datetime"].strftime("%d.%m.%Y"), "bold")
                if m1["datetime"].date() != m2["datetime"].date():
                    self._append_text(" to ")
                    self._append_text(
                        m2["datetime"].strftime("%d.%m.%Y"), "bold")
                self._append_text("  (%s).  " % util.plural(
                                  "message", self._messages_current))
            if self._chat["message_count"]:
                self._append_text("\nShow from:  ")
                date_first = self._chat["first_message_datetime"].date()
                date_last = self._chat["last_message_datetime"].date()
                date_until = datetime.date.today()
                dates_filter = self._filter.get("daterange")
                from_items = [] # [(title, [date_first, date_last])]
                if relativedelta:
                    for unit, count in [("day", 7), ("week", 2), ("day", 30),
                    ("month", 3), ("month", 6), ("year", 1), ("year", 2)]:
                        date_from = date_until - relativedelta(
                            **{util.plural(unit, with_items=False): count})
                        if date_from >= date_first and date_from <= date_last:
                            title = util.plural(unit, count)
                            from_items.append((title, [date_from, date_last]))
                    if date_until - relativedelta(years=2) > date_first:
                        # Warning: possible mis-showing here if chat < 4 years.
                        title = "2 to 4 years"
                        daterange = [date_until - relativedelta(years=4),
                                     date_until - relativedelta(years=2)]
                        from_items.append((title, daterange))
                    if date_until - relativedelta(years=4) > date_first:
                        title = "4 years and older"
                        daterange = [date_first,
                                     date_until - relativedelta(years=4)]
                        from_items.append((title, daterange))
                daterange = [date_first, date_last]
                from_items.append(("From the beginning", daterange))
                for i, (title, daterange) in enumerate(from_items):
                    is_active = center_message_id is None \
                                and ((title == self._datelink_last) 
                                     or (daterange == dates_filter))
                    if i:
                        self._append_text(u"  \u2022  ", "special") # bullet
                    if not is_active:
                        self._datelinks[self.STC.Length] = daterange
                    self._append_text(title, "bold" if is_active else "link")
            self._datelink_last = None
            self._append_text("\n\n")

            for i, m in enumerate(self._messages_current):
                if m["datetime"].date() != previous_day:
                    # Day has changed: insert a date header
                    previous_day = m["datetime"].date()
                    weekday, weekdate = util.get_locale_day_date(previous_day)
                    self._append_text("\n%s" % weekday, "bold")
                    self._append_text(", %s\n\n" % weekdate)

                dom = self._parser.parse(m)
                length_before = self.STC.Length
                time_value = m["datetime"].strftime("%H:%M")
                displayname = m["from_dispname"]
                special_text = "" # Special text after name, e.g. " SMS"
                body = m["body_xml"] or ""
                special_tag = dom.find("msgstatus")
                # Info messages like "/me is thirsty" -> author on same line.
                is_info = (skypedata.MESSAGES_TYPE_INFO == m["type"])

                if is_info:
                    stylebase = colourmap[m["author"]]
                    self._append_text(time_value, stylebase)
                    self._append_text("\n%s " % displayname, stylebase + "weak")
                elif special_tag is None:
                    self._append_text("%s %s\n" % (time_value, displayname),
                                                   colourmap[m["author"]])
                else:
                    self._append_text("%s %s" % (time_value, displayname),
                                                 colourmap[m["author"]])
                    self._append_text("%s\n" % special_tag.text, "special")

                self._write_element(dom, rgx_highlight)

                # Store message position for FocusMessage()
                length_after = self.STC.Length
                self._message_positions[m["id"]] = (
                    length_before, length_after - 2
                )
                if self._center_message_id == m["id"]:
                    focus_message_id = m["id"]
                if i and not i % conf.MaxHistoryInitialMessages:
                    wx.YieldIfNeeded() # To have responsive GUI

            # Reset the centered message data, as filtering should override it
            self._center_message_index = -1
            self._center_message_id = -1
            if focus_message_id:
                self.FocusMessage(focus_message_id)
            else:
                self.ScrollToLine(self.LineCount)
            self.Thaw()
        else:
            # No messages to show
            self.ClearAll()
            self._append_text(self.TEXT_NO_MESSAGES, "special")
        self.SetReadOnly(True)



    def _write_element(self, dom, rgx_highlight=None, tails_new=None):
        """
        Appends the message body to the StyledTextCtrl.

        @param   dom            xml.etree.cElementTree.Element instance
        @param   rgx_highlight  if set, substrings matching the regex are added
                                in highlighted style
        @param   tails_new      internal use, {element: modified tail str}
        """
        tagstyle_map = {"a": "link", "b": "bold", "quotefrom": "special",
                        "bodystatus": "special", "ss": "default", }
        to_skip = {} # {element to skip: True, }
        parent_map = dict((c, p) for p in dom.getiterator() for c in p)
        tails_new = {} if tails_new is None else tails_new
        linefeed_final = "\n\n" # Decreased if quotefrom is last

        for e in dom.getiterator():
            # Possible tags: a|b|bodystatus|quote|quotefrom|msgstatus|
            #                special|xml|font|blink
            if e in to_skip:
                continue
            style = tagstyle_map.get(e.tag, "default")
            text = e.text or ""
            tail = tails_new[e] if e in tails_new else (e.tail or "")
            children = []
            if type(text) is str:
                text = text.decode("utf-8")
            if type(tail) is str:
                tail = tail.decode("utf-8")
            href = None
            if "a" == e.tag:
                href = e.get("href")
                if href.startswith("file:"):
                    pathname = urllib.url2pathname(e.get("href")[5:])
                    self._filelinks[self.STC.Length] = pathname
                linefeed_final = "\n\n"
            elif "ss" == e.tag:
                text = e.text
            elif "quote" == e.tag:
                text = "\"" + text
                children = e.getchildren()
                if len(children) > 1:
                    # Last element is always quotefrom
                    childtail = children[-2].tail if children[-2].tail else ""
                    tails_new[children[-2]] = childtail + "\""
                else:
                    text += "\""
                linefeed_final = "\n"
            elif "quotefrom" == e.tag:
                text = "\n%s\n" % text
            elif e.tag in ["xml", "b"]:
                linefeed_final = "\n\n"
            elif e.tag not in ["blink", "font", "bodystatus"]:
                text = ""
            if text:
                self._append_text(text, style, rgx_highlight)
            for i in children:
                self._write_element(i, rgx_highlight, tails_new)
                to_skip[i] = True
            if tail:
                self._append_text(tail, "default", rgx_highlight)
                linefeed_final = "\n\n"
        if "xml" == dom.tag:
            self._append_text(linefeed_final)


    def _append_text(self, text, style="default", rgx_highlight=None):
        """
        Appends text to the StyledTextCtrl in the specified style.

        @param   rgx_highlight  if set, substrings matching the regex are added
                                in highlighted style
        """
        text = text or ""
        if type(text) is unicode:
            text = text.encode("utf-8")
        text_parts = rgx_highlight.split(text) if rgx_highlight else [text]
        bold = "bold%s" % style if "bold%s" % style in self._styles else style
        len_self = self.GetTextLength()
        self.STC.AppendTextUTF8(text)
        self.STC.StartStyling(pos=len_self, mask=0xFF)
        self.STC.SetStyling(length=len(text), style=self._styles[style])
        for i, t in enumerate(text_parts):
            if i % 2:
                self.STC.StartStyling(pos=len_self, mask=0xFF)
                self.STC.SetStyling(length=len(t), style=self._styles[bold])
            len_self += len(t)


    def _append_multiline(self, text, indent):
        """
        Appends text with new lines indented at the specified level.
        """
        if "\n" in text:
            for line in text.split("\n"):
                self._append_text("%s\n" % line)
                if self.USE_COLUMNS:
                    self.SetLineIndentation(self.LineCount - 1, indent)
            if self.USE_COLUMNS:
                self.SetLineIndentation(self.LineCount - 1, 0)
        else:
            self._append_text(text)


    def Populate(self, chat, db, messages=None, center_message_id=None,
                 from_index=None):
        """
        Populates the chat history with messages from the specified chat.

        @param   chat               chat data, as returned from SkypeDatabase
        @param   db                 SkypeDatabase to use
        @param   messages           messages to show (if set, messages are not
                                    retrieved from database)
        @param   center_message_id  if set, specifies the message around which
                                    to center other messages in the shown range
        @param   from_index         index of message to show from, if messages given
        """
        self.ClearAll()
        self.Refresh()
        self._center_message_index = -1
        self._center_message_id = -1

        if messages is not None:
            messages_current = collections.deque(messages)
            message_range = list(messages)
            if from_index is not None:
                messages_current = collections.deque(messages[from_index:])
        else:
            m_iter = db.get_messages(chat, ascending=False)

            i = 0
            message_show_limit = conf.MaxHistoryInitialMessages
            messages_current = collections.deque()
            try:
                iterate = (i < message_show_limit)
                while iterate:
                    m = m_iter.next()
                    if m:
                        i += 1
                        messages_current.appendleft(m)
                        if m["id"] == center_message_id:
                            self._center_message_index = len(messages_current)
                            self._center_message_id = center_message_id
                    else:
                        break # break while iterate
                    if center_message_id:
                        c = self._center_message_index + message_show_limit / 2
                        iterate = ((self._center_message_index < 0) or
                                   (len(messages_current) < c))
                    else:
                        iterate = (i < message_show_limit)
            except StopIteration:
                m_iter = None
            message_range = copy.copy(messages_current)
            if self._center_message_index >= 0:
                self._center_message_index = \
                    len(messages_current) - self._center_message_index

        self._chat = chat
        self._db = db
        self._messages_current = messages_current
        self._messages = message_range
        self._filter["daterange"] = [
            messages_current[0]["datetime"].date() if messages_current else None,
            messages_current[-1]["datetime"].date() if messages_current else None
        ]
        self.RefreshMessages(center_message_id)


    def FocusMessage(self, message_id):
        """Selects and scrolls the specified message into view."""
        if message_id in self._message_positions:
            padding = -50 # So that selection does not finish at visible edge
            for p in self._message_positions[message_id]:
                # Ensure that both ends of the selection are visible
                self.STC.CurrentPos = p + padding
                self.EnsureCaretVisible()
                padding = abs(padding)
            self.STC.SetSelection(*self._message_positions[message_id])


    def IsMessageFilteredOut(self, message):
        """
        Returns whether the specified message does not pass the current filter.
        """
        result = False
        if (self._filter.get("participants")
        and message["author"] not in self._filter["participants"]
        and message["author"]
        in [p["identity"] for p in self._chat["participants"]]):
            # Last check among chat participants is for cases where contact is
            # not listed among chat participants at all (e.g. left at once)
            result = True
        elif ("daterange" in self._filter
        and not (self._filter["daterange"][0] <= message["datetime"].date()
        <= self._filter["daterange"][1])):
            result = True
        elif "text" in self._filter and self._filter["text"]:
            if not self._filtertext_rgx:
                escaped = re.escape(self._filter["text"])
                self._filtertext_rgx = re.compile(escaped, re.IGNORECASE)
            if (not message["body_xml"]
            or not self._filtertext_rgx.search(message["body_xml"])):
                result = True
        return result


    def IsMessageShown(self, message_id):
        """Returns whether the specified message is currently shown."""
        return (message_id in self._message_positions)


    def GetMessage(self, index):
        """
        Returns the message at the specified index in the currently shown
        messages.

        @param   index  list index (negative starts from end)
        """
        if self._messages_current and index < 0:
            index += len(self._messages_current)
        in_len = self._messages_current and index < len(self._messages_current)
        m = self._messages_current[index] if in_len else None
        return m


    def GetMessages(self):
        """Returns a list of all the currently shown messages."""
        result = []
        if self._messages_current:
            result = list(self._messages_current)
        return result


    def GetRetrievedMessages(self):
        """Returns a list of all retrieved messages."""
        result = []
        if self._messages:
            result = list(self._messages)
        return result


    def SetFilter(self, filter_data):
        """
        Sets the filter to use for the current chat. Does not refresh messages.

        @param   filter_data  None or {"daterange":
                              (datetime, datetime), "text": text in message,
                              "participants": [skypename1, ]}
        """
        filter_data = filter_data or {}
        if not util.cmp_dicts(self._filter, filter_data):
            self._filter = copy.deepcopy(filter_data)
            self._filtertext_rgx = None
            self._messages_current = None
    def GetFilter(self):
        return copy.deepcopy(self._filter)
    Filter = property(GetFilter, SetFilter, doc=\
        """
        The filter to use for the current chat. {"daterange":
        (datetime, datetime), "text": text in message,
        "participants": [skypename1, ]}
        """
    )


    def GetStatisticsHtml(self, sort_field="name"):
        """
        Returns the statistics collected during last Populate as HTML, or "".
        """
        result = ""
        stats = self._parser and self._parser.get_collected_stats()
        if stats:
            participants = [p["contact"] for p in self._chat["participants"]]
            data = {"db": self._db, "participants": participants,
                    "chat": self._chat, "sort_by": sort_field, "stats": stats }
            result = step.Template(templates.STATS_HTML).expand(data)
        return result


    def ClearAll(self):
        """Delete all text in the document."""
        readonly_state = self.GetReadOnly()
        self.SetReadOnly(False)
        wx.stc.StyledTextCtrl.ClearAll(self.STC)
        self.SetReadOnly(readonly_state)



class GridTableBase(wx.grid.PyGridTableBase):
    """
    Table base for wx.grid.Grid, can take its data from a single table, or from
    the results of any SELECT query.
    """

    """How many rows to seek ahead for query grids."""
    SEEK_CHUNK_LENGTH = 100

    @classmethod
    def from_query(cls, db, sql):
        """
        Constructs a GridTableBase instance from a full SQL query.

        @param   db   SkypeDatabase instance
        @param   sql  the SQL query to execute
        """
        self = cls()
        self.is_query = True
        self.db = db
        self.sql = sql
        self.row_iterator = self.db.execute(sql)
        # Fill column information
        self.columns = []
        for idx, col in enumerate(self.row_iterator.description or []):
            coldata = {"name": col[0], "type": "TEXT"}
            self.columns.append(coldata)

        # Doing some trickery here: we can only know the row count when we have
        # retrieved all the rows, which is preferrable not to do at first,
        # since there is no telling how much time it can take. Instead, we
        # update the row count chunk by chunk.
        self.row_count = self.SEEK_CHUNK_LENGTH
        # ID here is a unique value identifying rows in this object,
        # no relation to table data
        self.idx_all = [] # An ordered list of row identifiers in rows_all
        self.rows_all = {} # Unfiltered, unsorted rows {id: row, }
        self.rows_current = [] # Currently shown (filtered/sorted) rows
        self.iterator_index = -1
        self.sort_ascending = False
        self.sort_column = None # Index of column currently sorted by
        self.filters = {} # {col: value, }
        self.attrs = {} # {"new": wx.grid.GridCellAttr, }
        try:
            self.SeekToRow(self.SEEK_CHUNK_LENGTH - 1)
        except Exception as e:
            pass
        # Seek ahead on rows and get column information from there
        if self.rows_current:
            for coldata in self.columns:
                name = coldata["name"]
                if type(self.rows_current[0][name]) in [int, long, bool]:
                    coldata["type"] = "INTEGER"
                elif type(self.rows_current[0][name]) in [float]:
                    coldata["type"] = "REAL"
        return self


    @classmethod
    def from_table(cls, db, table, where="", order=""):
        """
        Constructs a GridTableBase instance from a single table.

        @param   db     SkypeDatabase instance
        @param   table  name of table
        @param   where  SQL WHERE clause, without "where" (e.g. "a=b AND c<3")
        @param   order  full SQL ORDER clause (e.g. "ORDER BY a DESC, b ASC")
        """
        self = cls()
        self.is_query = False
        self.db = db
        self.table = table
        self.where = where
        self.order = order
        self.columns = db.get_table_columns(table)
        self.row_count = list(db.execute(
            "SELECT COUNT(*) AS rows FROM %s %s %s" % (table, where, order)
        ))[0]["rows"]
        # ID here is a unique value identifying rows in this object,
        # no relation to table data
        self.idx_all = [] # An ordered list of row identifiers in rows_all
        self.rows_all = {} # Unfiltered, unsorted rows {id: row, }
        self.rows_current = [] # Currently shown (filtered/sorted) rows
        self.idx_changed = set() # set of indices for changed rows in rows_all
        self.rows_backup = {} # For changed rows {id: original_row, }
        self.idx_new = [] # Unsaved added row indices
        self.rows_deleted = {} # Uncommitted deleted rows {id: deleted_row, }
        self.row_iterator = db.execute(
            "SELECT * FROM %s %s %s"
            % (table, "WHERE %s" % where if where else "", order)
        )
        self.iterator_index = -1
        self.sort_ascending = False
        self.sort_column = None # Index of column currently sorted by
        self.filters = {} # {col: value, }
        self.attrs = {} # {"new": wx.grid.GridCellAttr, }
        return self


    def GetColLabelValue(self, col):
        label = self.columns[col]["name"]
        if col == self.sort_column:
            label += u" " if self.sort_ascending else u" "
        if col in self.filters:
            if "TEXT" == self.columns[col]["type"]:
                label += "\nlike \"%s\"" % self.filters[col]
            else:
                label += "\n= %s" % self.filters[col]
        return label


    def GetNumberRows(self):
        result = self.row_count
        if self.filters:
            result = len(self.rows_current)
        return result


    def GetNumberCols(self):
        return len(self.columns)


    def SeekAhead(self, to_end=False):
        """
        Seeks ahead on the query cursor, by the chunk length or until the end.

        @param   to_end  if True, retrieves all rows
        """
        seek_count = self.row_count + self.SEEK_CHUNK_LENGTH - 1
        if to_end:
            seek_count = sys.maxsize
        self.SeekToRow(seek_count)


    def SeekToRow(self, row):
        """Seeks ahead on the row iterator to the specified row."""
        rows_before = len(self.rows_all)
        row_initial = row
        while self.row_iterator and (self.iterator_index < row):
            rowdata = None
            try:
                rowdata = self.row_iterator.next()
            except Exception as e:
                pass
            if rowdata:
                idx = id(rowdata)
                rowdata["__id__"] = idx
                rowdata["__changed__"] = False
                rowdata["__new__"] = False
                rowdata["__deleted__"] = False
                self.rows_all[idx] = rowdata
                self.rows_current.append(rowdata)
                self.idx_all.append(idx)
                self.iterator_index += 1
            else:
                self.row_iterator = None
        if self.is_query:
            if (self.row_count != self.iterator_index + 1):
                self.row_count = self.iterator_index + 1
                self.NotifyViewChange(rows_before)


    def GetValue(self, row, col):
        value = None
        if row < self.row_count:
            self.SeekToRow(row)
            if row < len(self.rows_current):
                value = self.rows_current[row][self.columns[col]["name"]]
                if type(value) is buffer:
                    value = str(value).decode("latin1")
        if value and "BLOB" == self.columns[col]["type"]:
            # Blobs need special handling, as the text editor does not
            # support control characters or null bytes.
            value = value.encode("unicode-escape")
        return value if value is not None else ""


    def GetRow(self, row):
        """Returns the data dictionary of the specified row."""
        value = None
        if row < self.row_count:
            self.SeekToRow(row)
            if row < len(self.rows_current):
                value = self.rows_current[row]
        return value


    def SetValue(self, row, col, val):
        if not (self.is_query) and (row < self.row_count):
            accepted = False
            col_value = None
            if "INTEGER" == self.columns[col]["type"]:
                if not val: # Set column to NULL
                    accepted = True
                else:
                    try:
                        # Allow user to enter a comma for decimal separator.
                        valc = val.replace(",", ".")
                        col_value = float(valc) if ("." in valc) else int(val)
                        accepted = True
                    except Exception:
                        pass
            elif "BLOB" == self.columns[col]["type"]:
                # Blobs need special handling, as the text editor does not
                # support control characters or null bytes.
                try:
                    col_value = val.decode("unicode-escape")
                    accepted = True
                except UnicodeError: # Text is not valid escaped Unicode
                    pass
            else:
                col_value = val
                accepted = True
            if accepted:
                self.SeekToRow(row)
                data = self.rows_current[row]
                idx = data["__id__"]
                if not data["__new__"]:
                    if idx not in self.rows_backup:
                        # Backup only existing rows, new rows will be dropped
                        # on rollback anyway.
                        self.rows_backup[idx] = data.copy()
                    data["__changed__"] = True
                    self.idx_changed.add(idx)
                data[self.columns[col]["name"]] = col_value
                if self.View: self.View.Refresh()


    def IsChanged(self):
        """Returns whether there is uncommitted changed data in this grid."""
        lengths = map(len, [self.idx_changed, self.idx_new, self.rows_deleted])
        return any(lengths)


    def GetChangedInfo(self):
        """Returns an info string about the uncommited changes in this grid."""
        infolist = []
        values = {"new": len(self.idx_new), "changed": len(self.idx_changed),
                  "deleted": len(self.rows_deleted), }
        for label, count in values.items():
            if count:
                infolist.append("%s %s row%s"
                    % (count, label, "s" if count != 1 else ""))
        return ", ".join(infolist)


    def GetAttr(self, row, col, kind):
        if not self.attrs:
            for n in ["new", "default", "row_changed", "cell_changed",
            "newblob", "defaultblob", "row_changedblob", "cell_changedblob"]:
                self.attrs[n] = wx.grid.GridCellAttr()
            for n in ["new", "newblob"]:
                self.attrs[n].SetBackgroundColour(conf.GridRowInsertedColour)
            for n in ["row_changed", "row_changedblob"]:
                self.attrs[n].SetBackgroundColour(conf.GridRowChangedColour)
            for n in ["cell_changed", "cell_changedblob"]:
                self.attrs[n].SetBackgroundColour(conf.GridCellChangedColour)
            for n in ["newblob", "defaultblob",
            "row_changedblob", "cell_changedblob"]:
                self.attrs[n].SetEditor(wx.grid.GridCellAutoWrapStringEditor())
        # Sanity check, UI controls can still be referring to a previous table
        col = min(col, len(self.columns) - 1)

        blob = "blob" if (self.columns[col]["type"].lower() == "blob") else ""
        attr = self.attrs["default%s" % blob]
        if row < len(self.rows_current):
            if self.rows_current[row]["__changed__"]:
                idx = self.rows_current[row]["__id__"]
                value = self.rows_current[row][self.columns[col]["name"]]
                backup = self.rows_backup[idx][self.columns[col]["name"]]
                if backup != value:
                    attr = self.attrs["cell_changed%s" % blob]
                else:
                    attr = self.attrs["row_changed%s" % blob]
            elif self.rows_current[row]["__new__"]:
                attr = self.attrs["new%s" % blob]
        attr.IncRef()
        return attr


    def InsertRows(self, row, numRows):
        """Inserts new, unsaved rows at position 0 (row is ignored)."""
        rows_before = len(self.rows_current)
        for i in range(numRows):
            # Construct empty dict from column names
            rowdata = dict((col["name"], None) for col in self.columns)
            idx = id(rowdata)
            rowdata["__id__"] = idx
            rowdata["__changed__"] = False
            rowdata["__new__"] = True
            rowdata["__deleted__"] = False
            # Insert rows at the beginning, so that they can be edited
            # immediately, otherwise would need to retrieve all rows first.
            self.idx_all.insert(0, idx)
            self.rows_current.insert(0, rowdata)
            self.rows_all[idx] = rowdata
            self.idx_new.append(idx)
        self.row_count += numRows
        self.NotifyViewChange(rows_before)


    def DeleteRows(self, row, numRows):
        """Deletes rows from a specified position."""
        if row + numRows - 1 < self.row_count:
            self.SeekToRow(row + numRows - 1)
            rows_before = len(self.rows_current)
            for i in range(numRows):
                data = self.rows_current[row]
                idx = data["__id__"]
                del self.rows_current[row]
                if idx in self.rows_backup:
                    # If row was changed, switch to its backup data
                    data = self.rows_backup[idx]
                    del self.rows_backup[idx]
                    self.idx_changed.remove(idx)
                if not data["__new__"]:
                    # Drop new rows on delete, rollback can't restore them.
                    data["__changed__"] = False
                    data["__deleted__"] = True
                    self.rows_deleted[idx] = data
                else:
                    self.idx_new.remove(idx)
                    self.idx_all.remove(idx)
                    del self.rows_all[idx]
                self.row_count -= numRows
            self.NotifyViewChange(rows_before)


    def NotifyViewChange(self, rows_before):
        """
        Notifies the grid view of a change in the underlying grid table if
        current row count is different.
        """
        if self.View:
            args = None
            rows_now = len(self.rows_current)
            if rows_now < rows_before:
                args = [self, wx.grid.GRIDTABLE_NOTIFY_ROWS_DELETED,
                        rows_now, rows_before - rows_now]
            elif rows_now > rows_before:
                args = [self, wx.grid.GRIDTABLE_NOTIFY_ROWS_APPENDED,
                        rows_now - rows_before]
            if args:
                self.View.ProcessTableMessage(wx.grid.GridTableMessage(*args))



    def AddFilter(self, col, val):
        """
        Adds a filter to the grid data on the specified column. Ignores the
        value if invalid for the column (e.g. a string for an integer column).

        @param   col   column index
        @param   val   a simple value for filtering. For numeric columns, the
                       value is matched exactly, and for text columns,
                       matched by substring.
        """
        accepted_value = None
        if "INTEGER" == self.columns[col]["type"]:
            try:
                # Allow user to enter a comma for decimal separator.
                accepted_value = float(val.replace(",", ".")) \
                                 if ("." in val or "," in val) \
                                 else int(val)
            except ValueError:
                pass
        else:
            accepted_value = val
        if accepted_value is not None:
            self.filters[col] = accepted_value
            self.Filter()


    def RemoveFilter(self, col):
        """Removes filter on the specified column, if any."""
        if col in self.filters:
            del self.filters[col]
        self.Filter()


    def ClearFilter(self, refresh=True):
        """Clears all added filters."""
        self.filters.clear()
        if refresh:
            self.Filter()


    def ClearSort(self, refresh=True):
        """Clears current sort."""
        self.sort_column = None
        if refresh:
            self.rows_current[:].sort(
                key=lambda x: self.idx_all.index(x["__id__"])
            )
            if self.View:
                self.View.ForceRefresh()


    def Filter(self):
        """
        Filters the grid table with the currently added filters.
        """
        self.SeekToRow(self.row_count - 1)
        rows_before = len(self.rows_current)
        del self.rows_current[:]
        for idx in self.idx_all:
            row = self.rows_all[idx]
            if not row["__deleted__"] and self._is_row_unfiltered(row):
                self.rows_current.append(row)
        if self.sort_column is not None:
            pass#if self.View: self.View.Fit()
        else:
            self.sort_ascending = not self.sort_ascending
            self.SortColumn(self.sort_column)
        self.NotifyViewChange(rows_before)


    def SortColumn(self, col):
        """
        Sorts the grid data by the specified column, reversing the previous
        sort order, if any.
        """
        self.SeekToRow(self.row_count - 1)
        self.sort_ascending = not self.sort_ascending
        self.sort_column = col
        compare = cmp
        if 0 <= col < len(self.columns):
            col_name = self.columns[col]["name"]
            def compare(a, b):
                aval, bval = a[col_name], b[col_name]
                aval = aval.lower() if hasattr(aval, "lower") else aval
                bval = bval.lower() if hasattr(bval, "lower") else bval
                return cmp(aval, bval)
        self.rows_current.sort(cmp=compare, reverse=self.sort_ascending)
        if self.View:
            self.View.ForceRefresh()


    def SaveChanges(self):
        """
        Saves the rows that have been changed in this table. Undo information
        is destroyed.
        """
        # Save all existing changed rows
        for idx in self.idx_changed.copy():
            row = self.rows_all[idx]
            self.db.update_row(self.table, row, self.rows_backup[idx])
            row["__changed__"] = False
            self.idx_changed.remove(idx)
            del self.rows_backup[idx]
        # Save all newly inserted rows
        pk = [c["name"] for c in self.columns if c["pk"]][0]
        for idx in self.idx_new[:]:
            row = self.rows_all[idx]
            row[pk] = self.db.insert_row(self.table, row)
            row["__new__"] = False
            self.idx_new.remove(idx)
        # Deleted all newly deleted rows
        for idx, row in self.rows_deleted.copy().items():
            self.db.delete_row(self.table, row)
            del self.rows_deleted[idx]
            del self.rows_all[idx]
            self.idx_all.remove(idx)
        if self.View: self.View.Refresh()


    def UndoChanges(self):
        """Undoes the changes made to the rows in this table."""
        rows_before = len(self.rows_current)
        # Restore all changed row data from backup
        for idx in self.idx_changed.copy():
            row = self.rows_backup[idx]
            row["__changed__"] = False
            self.rows_all[idx].update(row)
            self.idx_changed.remove(idx)
            del self.rows_backup[idx]
        # Discard all newly inserted rows
        for idx in self.idx_new[:]:
            row = self.rows_all[idx]
            del self.rows_all[idx]
            if row in self.rows_current: self.rows_current.remove(row)
            self.idx_new.remove(idx)
            self.idx_all.remove(idx)
        # Undelete all newly deleted items
        for idx, row in self.rows_deleted.items():
            row["__deleted__"] = False
            del self.rows_deleted[idx]
            if self._is_row_unfiltered(row):
                self.rows_current.append(row)
            self.row_count += 1
        self.NotifyViewChange(rows_before)
        if self.View: self.View.Refresh()


    def _is_row_unfiltered(self, rowdata):
        """
        Returns whether the row is not filtered out by the current filtering
        criteria, if any.
        """
        is_unfiltered = True
        for col, filter_value in self.filters.items():
            column_data = self.columns[col]
            if "INTEGER" == column_data["type"]:
                is_unfiltered &= (filter_value == rowdata[column_data["name"]])
            elif "TEXT" == column_data["type"]:
                str_value = (rowdata[column_data["name"]] or "").lower()
                is_unfiltered &= str_value.find(filter_value.lower()) >= 0
        return is_unfiltered



class DayHourDialog(wx.Dialog):
    """Popup dialog for entering two values, days and hours."""

    def __init__(self, parent, message, caption, days, hours):
        wx.Dialog.__init__(self, parent=parent, title=caption, size=(250, 200))

        vbox = self.Sizer = wx.BoxSizer(wx.VERTICAL)

        self.text_days = wx.SpinCtrl(parent=self, style=wx.ALIGN_LEFT,
            size=(200, -1), value=str(days), min=-sys.maxsize, max=sys.maxsize
        )
        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.AddStretchSpacer()
        hbox1.Add(wx.StaticText(parent=self, label="Days:"),
            flag=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL)
        hbox1.Add(self.text_days, border=5, flag=wx.LEFT | wx.ALIGN_RIGHT)

        self.text_hours = wx.SpinCtrl(parent=self, style=wx.ALIGN_LEFT,
           size=(200, -1), value=str(hours), min=-sys.maxsize, max=sys.maxsize)
        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.AddStretchSpacer()
        hbox2.Add(wx.StaticText(parent=self, label="Hours:"),
                  flag=wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL)
        hbox2.Add(self.text_hours, border=5, flag=wx.LEFT | wx.ALIGN_RIGHT)

        button_ok = wx.Button(self, label="OK")
        button_cancel = wx.Button(self, label="Cancel", id=wx.ID_CANCEL)
        hbox3 = wx.BoxSizer(wx.HORIZONTAL)
        hbox3.AddStretchSpacer()
        hbox3.Add(button_ok, border=5, flag=wx.RIGHT)
        hbox3.Add(button_cancel, border=5, flag=wx.RIGHT)

        vbox.Add(
            wx.StaticText(parent=self, label=message), border=10, flag=wx.ALL)
        vbox.AddSpacer(5)
        vbox.Add(
            hbox1, border=5, flag=wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.GROW)
        vbox.Add(
            hbox2, border=5, flag=wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.GROW)
        vbox.Add(wx.StaticLine(self), border=5, proportion=1,
                 flag=wx.LEFT | wx.RIGHT | wx.GROW)
        vbox.Add(hbox3, border=5, flag=wx.ALL | wx.GROW)

        button_ok.SetDefault()
        button_ok.Bind(wx.EVT_BUTTON, lambda e: self.EndModal(wx.ID_OK))
        button_cancel.Bind(wx.EVT_BUTTON, lambda e:self.EndModal(wx.ID_CANCEL))

        self.Layout()
        self.Size = self.GetEffectiveMinSize()
        self.CenterOnParent()


    def GetValues(self):
        """Returns the entered days and hours as a tuple of integers."""
        days = self.text_days.Value
        hours = self.text_hours.Value
        return days, hours



class SkypeHandler(Skype4Py.Skype if Skype4Py else object):
    """A convenience wrapper around Skype4Py functionality."""

    def shutdown(self):
        """Posts a message to the running Skype application to close itself."""
        self.Client.Shutdown()


    def is_running(self):
        """Returns whether Skype is currently running."""
        return self.Client.IsRunning


    def launch(self):
        """Tries to launch Skype."""
        self.Client.Start()


    def search_users(self, value):
        """
        Searches for users with the specified value (either name, phone or
        e-mail) in the currently running Skype application.
        """
        if not self.is_running():
            self.launch()
        self.FriendlyName = conf.Title
        self.Attach() # Should open a confirmation dialog in Skype

        result = list(self.SearchForUsers(value))
        return result


    def add_to_contacts(self, users):
        """
        Adds the specified Skype4Py.User instances to Skype contacts in the
        currently running Skype application.
        """
        if not self.is_running():
            self.launch()
        self.FriendlyName = conf.Title
        self.Attach() # Should open a confirmation dialog in Skype
        for user in users:
            user.BuddyStatus = Skype4Py.enums.budPendingAuthorization
        self.Client.Focus()



class AboutDialog(wx.Dialog):
 
    def __init__(self, parent, content):
        wx.Dialog.__init__(self, parent, title="About %s" % conf.Title,
                           style=wx.CAPTION | wx.CLOSE_BOX)
        html = self.html = wx.html.HtmlWindow(self)
        button_update = wx.Button(self, label="Check for &updates")

        html.SetPage(content)
        html.BackgroundColour = conf.BgColour
        html.Bind(wx.html.EVT_HTML_LINK_CLICKED,
                  lambda e: webbrowser.open(e.GetLinkInfo().Href))
        button_update.Bind(wx.EVT_BUTTON, parent.on_check_update)

        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        self.Sizer.Add(html, proportion=1, flag=wx.GROW)
        sizer_buttons = self.CreateButtonSizer(wx.OK)
        sizer_buttons.Insert(0, button_update, border=150, flag=wx.RIGHT)
        self.Sizer.Add(sizer_buttons, border=8, flag=wx.ALIGN_CENTER | wx.ALL)
        self.Layout()
        self.Size = (self.Size[0], html.VirtualSize[1] + 60)
        self.CenterOnParent()



def messageBox(message, title, style):
    """
    Shows a non-native message box, with no bell sound for any style, returning
    the message box result code."""
    dlg = wx.lib.agw.genericmessagedialog.GenericMessageDialog(
        None, message, title, style
    )
    result = dlg.ShowModal()
    dlg.Destroy()
    return result

########NEW FILE########
__FILENAME__ = support
# -*- coding: utf-8 -*-
"""
Updates and error reporting.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     16.04.2013
@modified    08.04.2014
------------------------------------------------------------------------------
"""
import base64
import datetime
import hashlib
import HTMLParser
import os
import re
import sys
import tempfile
import time
import traceback
import urllib
import urllib2
import wx

import conf
import controls
import main
import util
import wx_accel

"""Current update dialog window, if any, for avoiding concurrent updates."""
update_window = None

"""Feedback window reusable instance."""
feedback_window = None

"""URL-opener with Skyperious useragent."""
url_opener = urllib2.build_opener()


def check_newest_version(callback=None):
    """
    Queries the Skyperious download page for available newer releases.

    @param   callback  function to call with check result, if any
             @result   (version, url, changes) if new version up,
                       () if up-to-date, None if query failed
    """
    global update_window, url_opener
    result = ()
    update_window = True
    try:
        main.log("Checking for new version at %s.", conf.DownloadURL)
        html = url_opener.open(conf.DownloadURL).read()
        links = re.findall("<a[^>]*\shref=['\"](.+)['\"][^>]*>", html, re.I)
        links = [urllib.basejoin(conf.DownloadURL, x) for x in links[:3]]
        if links:
            # Determine release types
            linkmap = {} # {"src": link, "x86": link, "x64": link}
            for link in links:
                link_text = link.lower()
                if link_text.endswith(".zip"):
                    linkmap["src"] = link
                elif link_text.endswith(".exe") and "_x64" in link_text:
                    linkmap["x64"] = link
                elif link_text.endswith(".exe"):
                    linkmap["x86"] = link

            install_type = get_install_type()
            link = linkmap[install_type]
            # Extract version number like 1.3.2a from skyperious_1.3.2a_x64.exe
            version = (re.findall("(\d[\da-z.]+)", link) + [None])[0]
            main.log("Newest %s version is %s.", install_type, version)
            try:
                if (version != conf.Version
                and canonic_version(conf.Version) >= canonic_version(version)):
                    version = None
            except Exception: pass
            if version and version != conf.Version:
                changes = ""
                try:
                    main.log("Reading changelog from %s.", conf.ChangelogURL)
                    html = url_opener.open(conf.ChangelogURL).read()
                    match = re.search("<h4[^>]*>(v%s,.*)</h4\s*>" % version,
                                      html, re.I)
                    if match:
                        ul = html[match.end(0):html.find("</ul", match.end(0))]
                        lis = re.findall("(<li[^>]*>(.+)</li\s*>)+", ul, re.I)
                        items = [re.sub("<[^>]+>", "", x[1]) for x in lis]
                        items = map(HTMLParser.HTMLParser().unescape, items)
                        changes = "\n".join("- " + i.strip() for i in items)
                        if changes:
                            title = match.group(1)
                            changes = "Changes in %s\n\n%s" % (title, changes)
                except Exception:
                    main.log("Failed to read changelog.\n\n%s.",
                             traceback.format_exc())
                url = urllib.basejoin(conf.DownloadURL, link)
                result = (version, url, changes)
    except Exception:
        main.log("Failed to retrieve new version from %s.\n\n%s",
                 conf.DownloadURL, traceback.format_exc())
        result = None
    update_window = None
    if callback:
        callback(result)
    return result


def download_and_install(url):
    """
    Downloads and launches the specified file.
    """
    global update_window, url_opener
    try:
        is_cancelled = False
        parent = wx.GetApp().TopWindow
        filename, tmp_dir = os.path.split(url)[-1], tempfile.mkdtemp()
        dlg_progress = \
            controls.ProgressWindow(parent, "Downloading %s" % filename)
        dlg_progress.SetGaugeForegroundColour(conf.GaugeColour)
        dlg_progress.Position = (
            parent.Position.x + parent.Size.width  - dlg_progress.Size.width,
            parent.Position.y + parent.Size.height - dlg_progress.Size.height)
        update_window = dlg_progress
        urlfile = url_opener.open(url)
        filepath = os.path.join(tmp_dir, filename)
        main.log("Downloading %s to %s.", url, filepath)
        filesize = int(urlfile.headers.get("content-length", sys.maxint))
        with open(filepath, "wb") as f:
            BLOCKSIZE = 65536
            bytes_downloaded = 0
            buf = urlfile.read(BLOCKSIZE)
            while len(buf):
                f.write(buf)
                bytes_downloaded += len(buf)
                percent = 100 * bytes_downloaded / filesize
                msg = "%d%% of %s" % (percent, util.format_bytes(filesize))
                is_cancelled = not dlg_progress.Update(percent, msg)
                if is_cancelled:
                    break # break while len(buf)
                wx.YieldIfNeeded()
                buf = urlfile.read(BLOCKSIZE)
        dlg_progress.Destroy()
        update_window = None
        if is_cancelled:
            main.log("Upgrade cancelled, erasing temporary file %s.", filepath)
            util.try_until(lambda: os.unlink(filepath))
            util.try_until(lambda: os.rmdir(tmp_dir))
        else:
            main.log("Successfully downloaded %s of %s.",
                     util.format_bytes(filesize), filename)
            dlg_proceed = controls.NonModalOKDialog(parent,
                "Update information",
                "Ready to open %s. You should close %s before upgrading."
                % (filename, conf.Title))
            def proceed_handler(event):
                global update_window
                update_window = None
                dlg_proceed.Destroy()
                util.start_file(filepath)
            update_window = dlg_proceed
            dlg_proceed.Bind(wx.EVT_CLOSE, proceed_handler)
    except Exception:
        main.log("Failed to download new version from %s.\n\n%s", url,
                 traceback.format_exc())



def reporting_write(write):
    """
    Decorates a write(str) method with a handler that collects written text
    and queues reporting errors in the background.
    """
    cached = []
    def handle_error():
        text = "".join(cached)[:100000]
        if text:
            text = "An unexpected error has occurred:\n\n%s" % text
            main.log(text)
            report_error(text)
        del cached[:]
    def cache_text(string):
        if not cached:
            # CallLater fails if not called from main thread
            wx.CallAfter(wx.CallLater, 500, handle_error)
        cached.append(string)
        return write(string)
    return cache_text



def take_screenshot():
    """Returns a wx.Bitmap screenshot taken of the whole screen."""
    wx.YieldIfNeeded()

    rect = wx.Rect(0, 0, *wx.DisplaySize())
    bmp = wx.EmptyBitmap(rect.width, rect.height)
    dc = wx.ScreenDC()
    dc_bmp = wx.MemoryDC()
    dc_bmp.SelectObject(bmp)
    dc_bmp.Blit(0, 0, rect.width, rect.height, dc, rect.x, rect.y)
    dc_bmp.SelectObject(wx.NullBitmap)
    # Hack to drop screen transparency, wx issue when blitting from screen
    bmp = wx.BitmapFromIcon(wx.IconFromBitmap(bmp))
    return bmp


def report_error(text):
    """Reports the error, if error reporting is enabled and below limit."""
    if conf.ErrorReportsAutomatic:
        # Set severe constraints on error sending to avoid creating
        # a busy idiot.
        today = datetime.date.today().strftime("%Y%m%d")
        conf.ErrorsReportedOnDay = conf.ErrorsReportedOnDay or {}
        reports_today = conf.ErrorsReportedOnDay.get(today, 0)
        text_hashed = "%s\n\n%s" % (conf.Version, text)
        sha1 = hashlib.sha1(text_hashed.encode("latin1", errors="ignore"))
        hash = sha1.hexdigest()
        if hash not in conf.ErrorReportHashes \
        and reports_today < conf.ErrorReportsPerDay:
            reports_today += 1
            conf.ErrorReportHashes.append(hash)
            conf.ErrorsReportedOnDay[today] = reports_today
            # Keep configuration in reasonable size
            if len(conf.ErrorReportHashes) > conf.ErrorsStoredMax:
                conf.ErrorReportHashes = \
                    conf.ErrorReportHashes[-conf.ErrorHashesMax:]
            if len(conf.ErrorsReportedOnDay) > conf.ErrorsStoredMax:
                days = sorted(conf.ErrorsReportedOnDay.keys())
                # Prune older days from dictionary
                for day in days[:len(days) - conf.ErrorsStoredMax]:
                    del conf.ErrorsReportedOnDay[day]
            conf.save()
            send_report(text, "error")


def send_report(content, type, screenshot=""):
    """
    Posts feedback or error data to the report web service.
    
    @return    True on success, False on failure
    """
    global url_opener
    try:
        data = {"content": content.encode("utf-8"), "type": type,
                "screenshot": base64.b64encode(screenshot),
                "version": "%s-%s" % (conf.Version, get_install_type())}
        url_opener.open(conf.ReportURL, urllib.urlencode(data))
        main.log("Sent %s report to %s (%s).", type, conf.ReportURL, content)
        result = True
    except Exception:
        main.log("Failed to send %s to %s.\n\n%s", type, conf.ReportURL,
                 traceback.format_exc())
        result = False
    return result


def get_install_type():
    """Returns the current Skyperious installation type (src|x64|x86)."""
    prog_text = sys.argv[0].lower()
    if not prog_text.endswith(".exe"):
        result = "src"
    elif util.is_os_64bit() and "program files\\" in prog_text:
        result = "x64"
    else:
        result = "x86"
    return result


def canonic_version(v):
    """Returns a numeric version representation: "1.3.2a" to 10301,99885."""
    nums = [int(re.sub("[^\d]", "", x)) for x in v.split(".")][::-1]
    nums[0:0] = [0] * (3 - len(nums)) # Zero-pad if version like 1.4 or just 2
    # Like 1.4a: subtract 1 and add fractions to last number to make < 1.4
    if re.findall("\d+([\D]+)$", v):
        ords = map(ord, re.findall("\d+([\D]+)$", v)[0])
        nums[0] += sum(x / (65536. ** (i + 1)) for i, x in enumerate(ords)) - 1
    return sum((x * 100 ** i) for i, x in enumerate(nums))



class FeedbackDialog(wx_accel.AutoAcceleratorMixIn, wx.Dialog):
    """
    A non-modal dialog for sending feedback with an optional screenshot,
    stays on top of parent.
    """
    THUMB_SIZE = (250, 150)

    """
    Dialog for entering a message to send to author, can include a screenshot.
    """
    def __init__(self, parent):
        wx.Dialog.__init__(self, parent=parent, title="Send feedback",
                          style=wx.CAPTION | wx.CLOSE_BOX |
                                wx.FRAME_FLOAT_ON_PARENT | wx.RESIZE_BORDER)
        wx_accel.AutoAcceleratorMixIn.__init__(self)
        self.MinSize = (460, 460)
        self.Sizer = wx.BoxSizer(wx.VERTICAL)
        panel = self.panel = wx.Panel(self)
        sizer = self.panel.Sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_upper = wx.BoxSizer(wx.HORIZONTAL)
        label = self.label_message = wx.StaticText(panel,
            label="Opinions, ideas for improvement, problems?")
        label_info = self.label_info = wx.StaticText(panel,
            label="For reply, include a contact e-mail.")
        label_info.ForegroundColour = "grey"
        sizer_upper.Add(label, flag=wx.GROW)
        sizer_upper.AddStretchSpacer()
        sizer_upper.Add(label_info, flag=wx.ALIGN_RIGHT)
        sizer.Add(sizer_upper, border=8, flag=wx.GROW | wx.ALL)

        edit = self.edit_text = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        sizer.Add(edit, proportion=2, border=8,
                  flag=wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.GROW)

        sizer_lower = wx.BoxSizer(wx.HORIZONTAL)
        bmp = self.bmp = wx.StaticBitmap(panel, size=self.THUMB_SIZE)
        sizer_lower.Add(bmp)
        sizer_controls = wx.GridBagSizer(vgap=8, hgap=8)
        self.button_ok = wx.Button(panel, label="&Confirm")
        self.button_cancel = wx.Button(panel, label="Cancel", id=wx.ID_CANCEL)
        sizer_controls.Add(self.button_ok, pos=(0, 0))
        sizer_controls.Add(self.button_cancel, pos=(0, 1))
        cb = self.cb_bmp = wx.CheckBox(panel, label="Include &screenshot")
        sizer_controls.Add(cb, pos=(1, 0), span=(1, 2))
        sizer_lower.AddStretchSpacer()
        sizer_lower.Add(sizer_controls, flag=wx.ALIGN_RIGHT | wx.ALIGN_BOTTOM)
        sizer.Add(sizer_lower, border=8, flag=wx.LEFT | wx.RIGHT |
                  wx.BOTTOM | wx.ALIGN_BOTTOM | wx.GROW)

        self.Sizer.Add(panel, proportion=1, flag=wx.GROW)
        self.Bind(wx.EVT_CHECKBOX, self.OnToggleScreenshot, self.cb_bmp)
        self.Bind(wx.EVT_BUTTON, self.OnSend, self.button_ok)
        self.Bind(wx.EVT_BUTTON, self.OnCancel, self.button_cancel)
        self.Bind(wx.EVT_CLOSE, self.OnCancel)

        self.SetScreenshot(None)
        self.Layout()
        self.Refresh()
        self.Size = self.Size # Touch to force correct size
        self.Show()


    def _SendReport(self, report_kwargs):
        """Tries to send report in the background, shows result message."""
        try_count = 0
        while try_count < 3 and not send_report(**report_kwargs):
            try_count += 1
        if try_count < 3:
            self.edit_text.Value = ""
            self.edit_text.SetFocus()
            self.SetScreenshot(None)
            text, style = "Feedback sent, thank you!", wx.OK
        else:        
            text = "Could not post feedback. Connection problems?"
            style = wx.OK | wx.ICON_WARNING
        main.status("")
        wx.CallLater(500, wx.MessageBox, text, self.Title, style)


    def SetScreenshot(self, bitmap=None):
        """Sets the screenshot bitmap, if any."""
        self.screenshot = bitmap
        thumb = wx.NullBitmap
        if bitmap:
            img = wx.ImageFromBitmap(bitmap)
            img = img.ResampleBox(*self.THUMB_SIZE)
            # wx.BitmapFromImage/img.ConvertToBitmap can yield buggy bitmaps
            thumb = wx.BitmapFromBuffer(img.Width, img.Height, img.Data)
        self.cb_bmp.Value = bool(bitmap)
        self.bmp.SetBitmap(thumb)
        self.bmp.Show(self.cb_bmp.Value)


    def OnToggleScreenshot(self, event):
        """Handler for toggling screenshot on/off."""
        if self.cb_bmp.Value:
            pos = self.Position
            self.Hide() # Dialog window can interfere with screen copy
            screenshot = take_screenshot()
            self.Show()
            self.Position = pos # Can lose position on hide in Linux
            self.SetScreenshot(screenshot)
        self.bmp.Show(self.cb_bmp.Value)
        self.Layout()


    def OnSend(self, event):
        """
        Handler for clicking to send feedback, hides the dialog and posts data
        to feedback web service.
        """
        text = self.edit_text.Value.strip()
        text_short = text[:500] + ".." if len(text) > 500 else text
        bmp = self.cb_bmp.Value and self.screenshot
        if text:
            ok = wx.MessageBox("Send the entered text%s?\n\n\"%s\"" % (
                               " and screenshot" if bmp else "", text_short),
                               self.Title, wx.OK | wx.CANCEL | 
                               wx.ICON_INFORMATION)
            text = (text if wx.OK == ok else "")
        if text:
            self.Hide()
            kwargs = {"type": "feedback", "content": text}
            if bmp: kwargs["screenshot"] = util.wx_bitmap_to_raw(bmp)
            main.status("Submitting feedback..")
            wx.CallAfter(self._SendReport, kwargs)


    def OnCancel(self, event):
        """Handler for cancelling sending feedback, hides the dialog."""
        self.Hide()


url_opener.addheaders = [("User-agent", "%s %s (%s)" % (conf.Title, conf.Version, get_install_type()))]

########NEW FILE########
__FILENAME__ = templates
# -*- coding: utf-8 -*-
"""
HTML and TXT templates for exports and statistics.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     09.05.2013
@modified    10.04.2014
------------------------------------------------------------------------------
"""
import re

# Modules imported inside templates:
#import base64, datetime, os, re, string, sys, urllib, wx
#import conf, emoticons, images, skypedata, util

"""Regex for replacing low bytes unusable in wx.HtmlWindow (\x00 etc)."""
SAFEBYTE_RGX = re.compile("[\x00-\x08,\x0B-\x0C,\x0E-x1F,\x7F]")

"""Replacer callback for low bytes unusable in wx.HtmlWindow (\x00 etc)."""
SAFEBYTE_REPL = lambda m: m.group(0).encode("unicode-escape")

"""HTML chat history export template."""
CHAT_HTML = """<%
import base64, datetime, urllib
import conf, emoticons, images, skypedata, util
%>
<!DOCTYPE HTML><html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="Author" content="{{conf.Title}}">
  <title>Skype {{chat["title_long_lc"]}}</title>
  <link rel="shortcut icon" type="image/png" href="data:image/ico;base64,{{images.Icon16x16_8bit.data}}"/>
  <style>
    .highlight1  { background-color: #FFFF66; }
    .highlight2  { background-color: #A0FFFF; }
    .highlight3  { background-color: #99FF99; }
    .highlight4  { background-color: #FF9999; }
    .highlight5  { background-color: #FF66FF; }
    .highlight6  { background-color: #DE8C00; }
    .highlight7  { background-color: #00AA00; }
    .highlight8  { background-color: #BDC75A; }
    .highlight9  { background-color: #82C0FF; }
    .highlight10 { background-color: #9F8CFF; }
    body {
      font-family: {{conf.HistoryFontName}};
      font-size: 11px;
      background: {{conf.HistoryBackgroundColour}};
      margin: 0 10px 0 10px;
    }
    #body_table {
      margin-left: auto;
      margin-right: auto;
      border-spacing: 0 10px;
    }
    #body_table > tbody > tr > td {
      background: white;
      width: 800px;
      font-family: {{conf.HistoryFontName}};
      font-size: 11px;
      border-radius: 10px;
      padding: 10px;
    }
    #content_table {
      empty-cells: show;
      border-spacing: 0;
      width: 100%;
    }
    #content_table td {
      text-align: left;
      vertical-align: top;
      line-height: 1.5em;
      padding-bottom: 4px;
      padding-top: 3px;
    }
    #content_table table.quote td {
      padding-bottom: 0px;
    }
    table.quote {
      padding-bottom: 5px;
    }
    table.quote td:first-child {
      vertical-align: top;
      border-right: 1px solid #C0C0C0;
      padding: 0 3px 0 0;
    }
    table.quote td:first-child span {
      position: relative;
      top: 15px;
      left: -2px;
      font-size: 4em;
      color: #999;
      font-family: Courier;
    }
    table.quote td:last-child {
      padding: 0 0 0 5px;
    }
    span.grey {
      color: #999;
    }
    a, a.visited { color: {{conf.ExportLinkColour}}; text-decoration: none; cursor: pointer; }
    a:hover, a.visited:hover { text-decoration: underline; }
    #footer {
      text-align: center;
      padding-bottom: 10px;
      color: #666;
    }
    #header { font-size: 1.1em; font-weight: bold; color: {{conf.ExportLinkColour}}; }
    #header_table {
      width: 100%;
    }
    #header_table td {
      vertical-align: top;
    }
    #header_left {
      width: 145px;
      text-align: left;
    }
    #header_center a {
      text-decoration: underline;
      font-weight: bold;
    }
    #header_center a.statistics {
      float: right;
      margin-right: 10px;
    }
    #header_right {
      width: 100%;
    }
    #header_left div, #header_right div {
      width: 100px;
      text-align: center;
    }
    #header_right {
      width: 100px;
      text-align: right;
    }
    #participants {
      padding: 5px;
      display: none;
    }
    #participants > span {
      float: left;
      margin: 2px;
      width: 200px;
      border: 1px solid #99BBFF;
      border-radius: 5px;
      padding: 5px;
    }
    #participants span.avatar_large {
      margin-right: 5px;
    }
    #statistics {
      padding: 5px;
      margin: 7px;
      display: none;
      border: 1px solid #99BBFF;
      border-radius: 5px;
    }
    #sort_header {
      margin-top: 10px;
      margin-bottom: 5px;
    }
    #sort_header a {
      text-decoration: underline;
      margin-left: 10px;
    }
    #sort_header a.selected {
      text-decoration: none;
      color: gray;
      cursor: default;
    }
    span.avatar_large {
      height: 96px;
      width: 96px;
      display: block;
      float: left;
      border: 1px solid lightgray;
    }
    span.avatar {
      height: 32px;
      width: 32px;
      display: block;
      margin-right: 10px;
    }
    .participants span.avatar_large {
      margin-right: 4px;
      display: inline;
    }
    #content_table td.day {
      border-top: 1px solid {{conf.HistoryLineColour}};
      border-bottom: 1px solid {{conf.HistoryLineColour}};
      padding-top: 3px; padding-bottom: 4px;
    }
    #content_table .weekday { font-weight: bold; }
    #content_table .timestamp {
      color: {{conf.HistoryTimestampColour}};
      text-align: left;
      width: 30px;
    }
    #content_table .timestamp span {
      position: relative;
      left: 5px;
      top: -1px;
      width: 11px;
      height: 11px;
    }
    #content_table .timestamp span.edited {
      background: url("data:image/png;base64,{{images.ExportEdited.data}}")
                  center center no-repeat;
    }
    #content_table .timestamp span.removed {
      background: url("data:image/png;base64,{{images.ExportRemoved.data}}")
                  center center no-repeat;
    }
    #content_table tr.shifted td.author, #content_table tr.shifted td.timestamp { 
      padding-top: 10px;
    }
    #content_table .author { min-width: 90px; text-align: right; }
    #content_table .remote { color: {{conf.HistoryRemoteAuthorColour}}; }
    #content_table .local { color: {{conf.HistoryLocalAuthorColour}}; }
    #content_table .t1 { width: 50px; }
    #content_table .t2 { width: 40px; }
    #content_table .t3 { width: 15px; min-width: 15px; }
    #content_table .day.t3 {
      padding: 5px;
      background: url("data:image/png;base64,{{images.ExportClock.data}}")
                  center center no-repeat;
    }
    #content_table .message_content {
      min-width: 500px;
      max-width: 635px;
      word-wrap: break-word;
    }
    #stats_data {
      width: 100%;
    }
    #stats_data > tbody > tr > td {
      padding: 0;
    }
    #stats_data > tbody > tr > td:first-child {
      vertical-align: top;
      width: 150px;
    }
    #stats_data > tbody > tr.stats_row > td:last-child {
      padding-left: 5px;
      line-height: 16px;
      white-space: nowrap;
    }
    .identity {
      color: gray;
    }
    #stats_data .name {
      vertical-align: middle;
    }
    #stats_data .avatar {
      float: left;
      padding: 0 5px 5px 0;
    }
    table.plot_table {
      white-space: nowrap;
      border-collapse: collapse;
      width: 100%;
    }
    table.plot_table > tbody > tr > td:first-child {
      width: 100%;
    }
    table.plot_table > tbody > tr > td {
      padding: 0;
    }
    table.plot_row {
      border-collapse: collapse;
      min-width: 100px;
      width: 100%;
      font-size: 0.9em;
      text-align: center;
      font-weight: bold;
    }
    table.plot_row td {
      padding: 0;
      height: 16px;
    }
    table.plot_row td:first-child {
      color: white;
    }
    table.plot_row.messages td:first-child {
      background-color: {{conf.PlotMessagesColour}};
    }
    table.plot_row.smses td:first-child {
      background-color: {{conf.PlotSMSesColour}};
    }
    table.plot_row.calls td:first-child {
      background-color: {{conf.PlotCallsColour}};
    }
    table.plot_row.files td:first-child {
      background-color: {{conf.PlotFilesColour}};
    }
    table.plot_row td:nth-child(2) {
      background-color: {{conf.PlotBgColour}};
      color: {{conf.PlotMessagesColour}};
    }
    #wordcloud {
      border-top: 1px solid #99BBFF;
      margin-top: 10px;
      padding-top: 5px;
      font-family: Arial, Helvetica, sans-serif;
    }
    #wordcloud span {
      color: blue;
      padding-right: 5px;
    }
    #wordcloud span a {
      font-size: 1em;
      color: blue;
    }
    #transfers {
      margin-top: 10px;
      padding-top: 5px;
      border-top: 1px solid #99BBFF;
    }
    #transfers table td {
      vertical-align: top;
      white-space: nowrap;
    }
    #transfers table a {
      color: blue;
    }
    #transfers table td:first-child {
      text-align: right;
      color: {{conf.HistoryLocalAuthorColour}};
      white-space: normal;
    }
    #transfers table td.remote:first-child {
      color: {{conf.HistoryRemoteAuthorColour}};
    }
    #transfers table td:last-child {
      text-align: right;
    }
    #transfers span {
      font-weight: bold;
      padding: 5px 0 10px 0;
      display: block;
      font-size: 1.1em;
    }
    span.avatar_large__default {
      background: url("data:image/png;base64,{{images.AvatarDefaultLarge.data}}")
                  center center no-repeat;
    }
    span.avatar__default {
      background: url("data:image/png;base64,{{images.AvatarDefault.data}}")
                  center center no-repeat;
    }
%for p in participants:
<%
p["avatar_class"] = "avatar__default"
p["avatar_class_large"] = "avatar_large__default"
%>
%if p["avatar_raw_large"]:
<%
id_csssafe = urllib.quote(p["identity"]).replace("%", "___").replace(".", "___").replace("/", "___")
p["avatar_class_large"] = "avatar_large__" + id_csssafe
%>
    span.{{p["avatar_class_large"]}} {
      background: url("data:image/png;base64,{{base64.b64encode(p["avatar_raw_large"])}}")
                  center center no-repeat;
    }
%endif
%if p["avatar_raw_small"]:
<%
p["avatar_class"] = "avatar__" + id_csssafe
%>
    span.{{p["avatar_class"]}} {
      background: url("data:image/png;base64,{{base64.b64encode(p["avatar_raw_small"])}}")
                  center center no-repeat;
    }
%endif
%endfor
    #chat_picture {
%if skypedata.CHATS_TYPE_SINGLE == chat["type"]:
      display: none;
%elif chat_picture_raw:
      background: url("data:image/png;base64,{{base64.b64encode(chat_picture_raw)}}") center center no-repeat;
      margin: 0 10px 0 10px;
      display: block;
      width: {{chat_picture_size[0]}}px;
      height: {{chat_picture_size[1]}}px;
%endif
    }
%if emoticons_used:
    span.emoticon {
      margin-top: 1px;
      display: inline-block;
      height: 19px;
      width: 19px;
      color: rgba(255, 255, 255, 0);
      text-align: center;
      word-wrap: normal;
      line-height: 30px;
    }
%endif
%for e in emoticons_used:
    span.emoticon.{{e}} {
      background: url("data:image/gif;base64,{{getattr(emoticons, e).data}}")
                  center center no-repeat;
    }
%endfor
  </style>
  <script>
    var HIGHLIGHT_STYLES = 10;
    var style_counter = 0;
    var hilite_counter = 0;

    function toggle_element(id, id_hide) {
      var el = document.getElementById(id);
      el.style.visibility = "visible";
      el.style.display = el.style.display != "block" ? "block" : "none";
      if (el.style.display == "block") {
        var el_hide = document.getElementById(id_hide);
        if (el_hide) {
          el_hide.style.display = "none";
        }
      }
      return false;
    }

    function highlight(keyword, elements, style) {
      var last = elements.length;
      for (var i = 0; i < last; i++) {
        var cn = elements[i];
        if ("undefined" != typeof(cn)) {
          if (3 == cn.nodeType) {
            addHighlight(keyword, cn, style);
          } else if (0 < cn.childNodes.length && "a" != cn.tagName.toLowerCase()) {
            highlight(keyword, cn.childNodes, style);
          }
        }
      }
    }

    function addHighlight(keyword, container, style) {
      var val = container.nodeValue;
      if (-1 == val.toLowerCase().indexOf(keyword)) return;
      // As JavaScript regex character classes are not Unicode aware,
      // match word boundaries on non-word and non-Unicode characters.
      pattern = new RegExp("(^|[^\\\\\\\\w\\\\\\\\u0081-\\\\\\\\uFFFF])(" + keyword + ")([^\\\\\\\\w\\\\\\\\u0081-\\\\\\\\uFFFF]|$)", "ig");
      replaceWith = '$1<span class="' + style + '">$2</span>$3';
      html = val.replace(pattern, replaceWith);
      found = (html != val);
      if (found) {
        var textnode = document.createElement("text");
        textnode.innerHTML = html;
        try {
          var p = container.parentNode;
          p.replaceChild(textnode, container);
        } catch (e) {}
      }
    }

    function unhighlight(container, style) {
      if (container) {
        var content = container.innerHTML; 
        var re = new RegExp("<span class=['\\"]" + style + "['\\"]>(.*?)<\/span>", "ig");
        content = content.replace(re, "$1"); 
        container.innerHTML = content;
      }
    }

    function hilite(link) {
      if (link.className.indexOf("highlight") < 0) {
        var base_style = "highlight" + (style_counter % HIGHLIGHT_STYLES + 1);
        var style = "highlight_id" + hilite_counter + " " + base_style;
        link.title = "Unhighlight '" + link.textContent + "'";
        link.className = style;
        var elements = document.getElementsByClassName("message_content");
        highlight(link.textContent, elements, style);
        var highlights = document.getElementsByClassName(style);
        if (highlights.length > 1) {
          highlights[1].scrollIntoView(); // 0-th element is link
        }
        hilite_counter++;
        style_counter++;
      } else {
        link.title = "Highlight '" + link.textContent + "' and go to first occurrence";
        unhighlight(document.getElementById("content_table"), link.className);
        link.className = "";
        style_counter--;
      }
      return false;
    }

    function getInnerText(el) {
      if (typeof el == "string") return el;
      if (typeof el == "undefined") { return el };
      if (el.innerText) return el.innerText;
      var str = "";
      
      var cs = el.childNodes;
      var l = cs.length;
      for (var i = 0; i < l; i++) {
        switch (cs[i].nodeType) {
          case 1: //ELEMENT_NODE
            str += getInnerText(cs[i]);
            break;
          case 3:	//TEXT_NODE
            str += cs[i].nodeValue;
            break;
        }
      }
      return str;
    }

    function sort_stats(link, type) {
      if (link.className.indexOf("selected") >= 0) {
        return false;
      }
      var rowlist = document.getElementsByClassName("stats_row");
      var rows = [];
      for (var i = 0, ll = rowlist.length; i != ll; rows.push(rowlist[i++]));
      var sortfn = function(a, b) {
        var aa = "", bb = "";
        var name1 = getInnerText(a.children[0]).toLowerCase();
        var name2 = getInnerText(b.children[0]).toLowerCase();
        switch (type) {
          case "name":
            aa = name1;
            bb = name2;
            break;
          case "callduration":
            var a_rows = a.children[1].children[0].children[0];
            for (var i = 0; i < a_rows.children.length; i++) {
              if (a_rows.children[i].className.indexOf("callduration") != -1) {
                aa = -parseFloat(a_rows.children[i].title);
                break;
              }
            }
            var b_rows = b.children[1].children[0].children[0];
            for (var i = 0; i < b_rows.children.length; i++) {
              if (b_rows.children[i].className.indexOf("callduration") != -1) {
                bb = -parseFloat(b_rows.children[i].title);
                break;
              }
            }
            break;
          default: // messages characters sms smschars calls files
            for (var i = 0; i < a.children[2].children.length; i++) {
              if (type == a.children[2].children[i].className) {
                aa = -parseInt(getInnerText(a.children[2].children[i]), 10);
              }
            }
            for (var i = 0; i < b.children[2].children.length; i++) {
              if (type == b.children[2].children[i].className) {
                bb = -parseInt(getInnerText(b.children[2].children[i]), 10);
              }
            }
            break;
        }
        if (("" == aa) && ("" == bb)) {
          aa = name1;
          bb = name2;
        }
        if (aa == bb) return 0;
        if (aa <  bb) return -1;
        return 1;
      }
      rows.sort(sortfn);
      var table = document.getElementById("stats_data");
      for (var i = 0; i < rows.length; i++) {
        table.tBodies[0].appendChild(rows[i]);
      }
      var linklist = document.getElementsByClassName("selected");
      for (var i = 0; i < linklist.length; i++) {
        linklist[i].className = "";
      }
      link.className = "selected";
      return false;
    }
  </script>
</head>
<body>
<table id="body_table">
<tr><td>
  <table id="header_table">
  <tr>
    <td id="header_left">
%if skypedata.CHATS_TYPE_SINGLE == chat["type"]:
%for p in filter(lambda p: p["identity"] != db.id, participants):
      <div><span class="avatar_large header {{p["avatar_class_large"]}}" title="{{p["name"]}}{{(" (%s)" % p["identity"]) if p["name"] != p["identity"] else ""}}"></span><br />{{p["name"]}}
%if p["name"] != p["identity"]:
      <br /><span class="identity">{{p["identity"]}}</span>
%endif
      </div>
%endfor
%elif chat_picture_size:
      <span id="chat_picture" title="{{chat["title"]}}"></span>
%endif
    </td>
    <td id="header_center">
      <div id="header">{{chat["title_long"]}}.</div><br />
      Showing {{util.plural("message", message_count)}}
%if date1 and date2:
      from <b>{{date1}}</b> to <b>{{date2}}</b>
%endif
      .<br />
%if chat["created_datetime"]:
      Chat created on <b>{{chat["created_datetime"].strftime("%d.%m.%Y")}}</b>,
%else:
      Chat has
%endif
      <b>{{util.plural("message", chat["message_count"] or 0)}}</b> in total.<br />
      Source: <b>{{db.filename}}</b>.<br /><br />
%if skypedata.CHATS_TYPE_SINGLE != chat["type"]:
        <a title="Click to show/hide participants" href="javascript:;" onclick="return toggle_element('participants', 'statistics')">Participants</a>
%endif
%if stats and (stats["counts"] or stats["info_items"]):
        <a title="Click to show/hide statistics and wordcloud" class="statistics" href="javascript:;" onclick="return toggle_element('statistics', 'participants')">Statistics</a>
%endif
    </td>
    <td id="header_right">
%if skypedata.CHATS_TYPE_SINGLE == chat["type"]:
%for p in filter(lambda p: p["identity"] == db.id, participants):
      <div><span class="avatar_large header {{p["avatar_class_large"]}}" title="{{p["name"]}}{{(" (%s)" % p["identity"]) if p["name"] != p["identity"] else ""}}"></span><br />{{p["name"]}}
%if p["name"] != p["identity"]:
      <br /><span class="identity">{{p["identity"]}}</span>
%endif
      </div>
%endfor
%endif
    </td>
  </tr></table>

%if skypedata.CHATS_TYPE_SINGLE != chat["type"]:
  <div id="participants">
%for p in sorted(participants, key=lambda p: p["name"]):
    <span><span class="avatar_large {{p["avatar_class_large"]}}" title="{{p["name"]}} ({{p["identity"]}})"></span>{{p["name"]}}<br /><span class="identity">{{p["identity"]}}</span></span>
%endfor
  </div>
%endif

  <div id="statistics">
    <table id="stats_data">
%for label, value in stats["info_items"]:
      <tr><td>{{label}}:</td><td colspan="2">{{value}}</td></tr>
%endfor
%if len(stats["counts"]) > 1:
      <tr><td></td><td><div id="sort_header"><b>Sort by:</b>
        <a title="Sort statistics by name" href="#" onClick="return sort_stats(this, 'name');" class="selected">Name</a>
%if stats["messages"]:
        <a title="Sort statistics by messages" href="#" onClick="return sort_stats(this, 'message');">Messages</a>
        <a title="Sort statistics by characters" href="#" onClick="return sort_stats(this, 'character');">Characters</a>
%endif
%if stats["smses"]:
        <a title="Sort statistics by SMS messages" href="#" onClick="return sort_stats(this, 'SMS message');">SMSes</a>
        <a title="Sort statistics by SMS characters" href="#" onClick="return sort_stats(this, 'SMS character');">SMS characters</a>
%endif
%if stats["calls"]:
        <a title="Sort statistics by calls" href="#" onClick="return sort_stats(this, 'call');">Calls</a>
        <a title="Sort statistics by call duration" href="#" onClick="return sort_stats(this, 'callduration');">Call duration</a>
%endif
%if stats["transfers"]:
        <a title="Sort statistics by files sent" href="#" onClick="return sort_stats(this, 'file');">Files</a>
%endif
      </div></td><td></td></tr>
%endif
%for p in filter(lambda p: p["identity"] in stats["counts"], participants):
      <tr class="stats_row">
        <td><table><tr><td><span class="avatar header {{p["avatar_class"]}}" title="{{p["name"]}}"></span></td><td><span>{{p["name"]}}<br /><span class="identity">{{p["identity"]}}</span></span></td></tr></table></td>
        <td><table class="plot_table">
<%
stat_rows = [] # [(type, label, count, total)]
if stats["counts"][p["identity"]]["messages"]:
  stat_rows.append(("messages", "message", stats["counts"][p["identity"]]["messages"], stats["messages"]))
  stat_rows.append(("messages", "character", stats["counts"][p["identity"]]["chars"], stats["chars"]))
if stats["counts"][p["identity"]]["smses"]:
  stat_rows.append(("smses", "SMS message", stats["counts"][p["identity"]]["smses"], stats["smses"]))
  stat_rows.append(("smses", "SMS character", stats["counts"][p["identity"]]["smschars"], stats["smschars"]))
if stats["counts"][p["identity"]]["calls"]:
  stat_rows.append(("calls", "call", stats["counts"][p["identity"]]["calls"], stats["calls"]))
if stats["counts"][p["identity"]]["calldurations"]:
  stat_rows.append(("calls", "callduration", stats["counts"][p["identity"]]["calldurations"], stats["calldurations"]))
if stats["counts"][p["identity"]]["files"]:
  stat_rows.append(("files", "file", stats["counts"][p["identity"]]["files"], stats["files"]))
  stat_rows.append(("files", "byte", stats["counts"][p["identity"]]["bytes"], stats["bytes"]))
%>
%for type, label, count, total in stat_rows:
<%
percent = util.safedivf(count * 100, total)
text_cell1 = "%d%%" % round(percent) if (round(percent) > 9) else ""
text_cell2 = "" if text_cell1 else "%d%%" % round(percent)
if "byte" == label:
  text_total = util.format_bytes(total)
elif "callduration" == label:
  text_total = util.format_seconds(total)
else:
  text_total = util.plural(label, total)
%>
          <tr title="{{util.round_float(percent)}}% of {{text_total}} in total" class="{{label}}"><td>
            <table class="plot_row {{type}}"><tr><td style="width: {{"%.2f" % percent}}%;">{{text_cell1}}</td><td style="width: {{"%.2f" % (100 - percent)}}%;">{{text_cell2}}</td></tr></table>
          </td></tr>
%endfor
        </table></td><td>
%for type, label, count, total in stat_rows:
<%
if "byte" == label:
  text = util.format_bytes(count)
elif "callduration" == label:
  text = util.format_seconds(count, "call")
else:
  text = util.plural(label, count)
%>
          <div class="{{label}}">{{text}}</div>
%endfor
        </td>
      </tr>
%endfor
    </table>

%if stats["wordcloud"]:
    <div id="wordcloud">
<%
sizes = {7: "2.5em;", 6: "2.1em;", 5: "1.75em;", 4: "1.5em;", 3: "1.3em;", 2: "1.1em;", 1: "0.85em", 0: "0.8em;"}
%>
%for word, count, size in stats["wordcloud"]:
      <span style="font-size: {{sizes[size]}}"><a title="Highlight '{{word}}' and go to first occurrence" href="#" onClick="return hilite(this);">{{word}}</a> ({{count}})</span> 
%endfor
    </div>
%endif

%if stats["transfers"]:
    <div id="transfers">
      <span>Sent and received files:</span>
      <table style="width: 100%">
%for f in stats["transfers"]:
<%
from_remote = (f["partner_handle"] == db.id and skypedata.TRANSFER_TYPE_INBOUND == f["type"]) or \
              (f["partner_handle"] != db.id and skypedata.TRANSFER_TYPE_OUTBOUND == f["type"])
partner = f["partner_dispname"] or db.get_contact_name(f["partner_handle"])
f_datetime = datetime.datetime.fromtimestamp(f["starttime"]).strftime("%Y-%m-%d %H:%M") if f.get("starttime") else ""
%>
        <tr><td{{" class='remote'" if from_remote else ""}}>{{partner if from_remote else db.account["name"]}}</td><td>
          <a href="{{util.path_to_url(f["filepath"] or f["filename"])}}" target="_blank">{{f["filepath"] or f["filename"]}}</a>
        </td><td>
          {{util.format_bytes(int(f["filesize"]))}}
        </td><td>
          {{f_datetime}}
        </td></tr>
%endfor
      </table>
    </div>
%endif
  </div>
</td></tr>
<tr><td>
  <table id="content_table">
<%
for chunk in message_buffer:
    echo(chunk)
%>
  </table>
</td></tr></table>
<div id="footer">Exported with {{conf.Title}} on {{datetime.datetime.now().strftime("%d.%m.%Y %H:%M")}}.</div>
</body>
</html>
"""


"""HTML chat history export template for the messages part."""
CHAT_MESSAGES_HTML = """<%
import datetime
import skypedata, util

previous_day = datetime.date.fromtimestamp(0)
previous_author = None
%>
%for m in messages:
%if m["datetime"].date() != previous_day:
<%
# Day has changed: insert a date header
day = m["datetime"].date()
weekday, weekdate = util.get_locale_day_date(day)
previous_author = None
%>
  <tr>
    <td class="t1"></td>
    <td class="day t2"></td>
    <td class="day t3"></td>
    <td class="day" colspan="2"><span class="weekday">{{weekday}}</span>, {{weekdate}}</td>
  </tr>
%endif
<%
text = parser.parse(m, output={"format": "html", "export": True})
from_name = m["from_dispname"] if previous_author != m["author"] else ""
# Info messages like "/me is thirsty" -> author on same line.
is_info = (skypedata.MESSAGES_TYPE_INFO == m["type"])
# Kludge to get single-line messages with an emoticon to line up correctly
# with the author, as emoticons have an upper margin pushing the row higher
text_plain = m.get("body_txt", text)
emot_start = '<span class="emoticon '
shift_row = emot_start in text and (("<br />" not in text and len(text_plain) < 140) or text.index(emot_start) < 140)
author_class = "remote" if m["author"] != db.id else "local"
%>
  <tr{{' class="shifted"' if shift_row else ""}}>
    <td class="author {{author_class}}" colspan="2">{{from_name if not is_info else ""}}</td>
    <td class="t3"></td>
    <td class="message_content"><div>
%if is_info:
    <span class="{{author_class}}">{{m["from_dispname"]}}</span>
%endif
    {{text}}
    </div></td>
    <td class="timestamp" title="{{m["datetime"].strftime("%Y-%m-%d %H:%M:%S")}}">
%if m["edited_timestamp"]:
    {{m["datetime"].strftime("%H:%M")}}<span class="{{"edited" if m["body_xml"] else "removed"}}" title="{{"Edited" if m["body_xml"] else "Removed"}} {{datetime.datetime.fromtimestamp(m["edited_timestamp"]).strftime("%H:%M:%S")}}">&nbsp;&nbsp;&nbsp;</span>
%else:
    {{m["datetime"].strftime("%H:%M")}}
%endif
    </td>
  </tr>
<%
previous_day = m["datetime"].date()
previous_author = m["author"]
%>
%endfor
"""



"""TXT chat history export template."""
CHAT_TXT = """<%
import datetime
import conf, skypedata, util
%>History of Skype {{chat["title_long_lc"]}}.
Showing {{util.plural("message", message_count)}}{{" from %s to %s" % (date1, date2) if (date1 and date2) else ""}}.
Chat {{"created on %s, " % chat["created_datetime"].strftime("%d.%m.%Y") if chat["created_datetime"] else ""}}{{util.plural("message", chat["message_count"] or 0)}} in total.
Source: {{db.filename}}.
Exported with {{conf.Title}} on {{datetime.datetime.now().strftime("%d.%m.%Y %H:%M")}}.
-------------------------------------------------------------------------------

<%
for chunk in message_buffer:
    echo(chunk)
%>
"""


"""TXT chat history export template for the messages part."""
CHAT_MESSAGES_TXT = """<%
import datetime
import skypedata, util

previous_day = datetime.date.fromtimestamp(0)
%>
%for m in messages:
%if m["datetime"].date() != previous_day:
<%
# Day has changed: insert a date header
day = m["datetime"].date()
weekday, weekdate = util.get_locale_day_date(day)
previous_day = m["datetime"].date()
%>

{{weekday}}, {{weekdate}}
----------------------------------------

%endif
%if skypedata.MESSAGES_TYPE_INFO == m["type"]:
{{m["datetime"].strftime("%H:%M")}}
{{m["from_dispname"]}} {{parser.parse(m, output={"format": "text", "wrap": True})}}
%else:
{{m["datetime"].strftime("%H:%M")}} {{m["from_dispname"]}}:
{{parser.parse(m, output={"format": "text", "wrap": True})}}
%endif

%endfor
"""


"""HTML data grid export template."""
GRID_HTML = """<%
import datetime
import conf, images, util
%><!DOCTYPE HTML><html>
<head>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
    <meta name="Author" content="{{conf.Title}}">
    <title>{{title}}</title>
    <link rel="shortcut icon" type="image/png" href="data:image/ico;base64,{{images.Icon16x16_8bit.data}}"/>
    <style>
        * { font-family: {{conf.HistoryFontName}}; font-size: 11px; }
        body {
            background: {{conf.HistoryBackgroundColour}};
            margin: 0px 10px 0px 10px;
        }
        .header { font-size: 1.1em; font-weight: bold; color: {{conf.ExportLinkColour}}; }
        .header_table {
            width: 100%;
        }
        .header_left {
            width: 145px;
            text-align: left;
        }
        table.body_table {
            margin-left: auto;
            margin-right: auto;
            border-spacing: 0px 10px;
        }
        table.body_table > tbody > tr > td {
            background: white;
            width: 800px;
            font-family: {{conf.HistoryFontName}};
            font-size: 11px;
            border-radius: 10px;
            padding: 10px;
        }
        table.content_table {
            empty-cells: show;
            border-spacing: 2px;
        }
        table.content_table td {
            line-height: 1.5em;
            padding: 5px;
            border: 1px solid #C0C0C0;
        }
        a, a.visited { color: conf.ExportLinkColour; text-decoration: none; }
        a:hover, a.visited:hover { text-decoration: underline; }
        .footer {
          text-align: center;
          padding-bottom: 10px;
          color: #666;
        }
        .header { font-size: 1.1em; font-weight: bold; color: conf.ExportLinkColour; }
        td { text-align: left; vertical-align: top; }
    </style>
</head>
<body>
<table class="body_table">
<tr><td><table class="header_table">
    <tr>
        <td class="header_left"></td>
        <td>
            <div class="header">{{title}}</div><br />
            Source: <b>{{db_filename}}</b>.<br />
            <b>{{row_count}}</b> {{util.plural("row", row_count, with_items=False)}} in results.<br />
%if sql:
            <b>SQL:</b> {{escape(sql)}}
%endif
        </td>
    </tr></table>
</td></tr><tr><td><table class='content_table'>
<tr><th>#</th>
%for col in columns:
<th>{{col}}</th>
%endfor
</tr>
%for i, row in enumerate(rows):
<tr>
<td>{{i + 1}}</td>
%for col in columns:
<td>{{escape("" if row[col] is None else row[col])}}</td>
%endfor
</tr>
%endfor
</table>
</td></tr></table>
<div class='footer'>Exported with {{conf.Title}} on {{datetime.datetime.now().strftime("%d.%m.%Y %H:%M")}}.</div>
</body>
</html>
"""


"""TXT SQL insert statements export template."""
SQL_TXT = """<%
import datetime, re, string
import conf

UNPRINTABLES = "".join(set(unichr(i) for i in range(128)).difference(string.printable))
RE_UNPRINTABLE = re.compile("[%s]" % "".join(map(re.escape, UNPRINTABLES)))
str_cols = ", ".join(columns)
%>-- {{title}}.
-- Source: {{db_filename}}.
-- Exported with {{conf.Title}} on {{datetime.datetime.now().strftime("%d.%m.%Y %H:%M")}}.
%if sql:
-- SQL: {{sql}}
%endif
%if table:
{{create_sql}}
%endif

%for row in rows:
<%
values = []
%>
%for col in columns:
<%
value = row[col]
if isinstance(value, basestring):
    if RE_UNPRINTABLE.search(value):
        if isinstance(value, unicode):
            try:
                value = value.encode("latin1")
            except UnicodeError:
                value = value.encode("utf-8", errors="replace")
        value = "X'%s'" % value.encode("hex").upper()
    else:
        if isinstance(value, unicode):
            value = value.encode("utf-8")
        value = '"%s"' % (value.encode("string-escape").replace('\"', '""'))
elif value is None:
    value = "NULL"
else:
    value = str(value)
values.append(value)
%>
%endfor
INSERT INTO {{table}} ({{str_cols}}) VALUES ({{", ".join(values)}});
%endfor
"""



"""HTML statistics template, for use with HtmlWindow."""
STATS_HTML = """<%
import datetime, urllib
import conf, skypedata, util
%>
<font color="{{conf.FgColour}}">
<table cellpadding="0" cellspacing="0" width="100%"><tr>
  <td><a name="top"><b>Statistics for currently shown messages in {{chat["title_long_lc"]}}:</b></a></td>
%if stats.get("wordcloud"):
  <td align="right"><a href="#cloud"><font color="{{conf.LinkColour}}">Jump to word cloud</font></a></td>
%endif
</tr><tr><td><font size="0">&nbsp;</font></td></tr></table>
<br />
<table>
%for label, value in stats["info_items"]:
  <tr><td width="200" valign="top">{{label}}:</td><td valign="top">{{value}}</td></tr>
%endfor

%if len(stats["counts"]) > 1:
  <tr><td><br /><br /></td><td valign="bottom"><font size="2">
    <table cellpadding="0" cellspacing="0"><tr>
      <td nowrap="nowrap"><b>Sort by:&nbsp;&nbsp;&nbsp;</b></td>
%for name, label in [("name", "Name"), ("messages", "Messages"), ("chars", "Characters"), ("smses", "SMS messages"), ("smschars", "SMS characters"), ("calls", "Calls"), ("calldurations", "Call duration"), ("files", "Files")]:
%if "name" == name or stats[name]:
%if sort_by == name:
      <td><font color="gray">{{label}}</font>&nbsp;&nbsp;&nbsp;&nbsp;</td>
%else:
      <td><a href="sort://{{name}}"><font color="{{conf.LinkColour}}">{{label}}</font></a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
%endif
%endif
%endfor
    </tr></table>
  </font></td></tr>
%endif

<%
colormap = {"messages": conf.PlotMessagesColour, "smses": conf.PlotSMSesColour, "calls": conf.PlotCallsColour, "files": conf.PlotFilesColour}
sort_key = lambda p: -stats["counts"][p["identity"]].get(sort_by, 0) if "name" != sort_by else p["name"]
participants_sorted = sorted(filter(lambda p: p["identity"] in stats["counts"], participants), key=sort_key)
%>

%for p in participants_sorted:
<%
avatar_filename = "avatar__default.jpg"
if "avatar_bitmap" in p:
    avatar_filename = "%s_%s.jpg" % tuple(map(urllib.quote, (db.filename.encode("utf-8"), p["identity"])))
stat_rows = [] # [(type, label, count, total)]
if stats["counts"][p["identity"]]["messages"]:
  stat_rows.append(("messages", "message", stats["counts"][p["identity"]]["messages"], stats["messages"]))
  stat_rows.append(("messages", "character", stats["counts"][p["identity"]]["chars"], stats["chars"]))
if stats["counts"][p["identity"]]["smses"]:
  stat_rows.append(("smses", "SMS message", stats["counts"][p["identity"]]["smses"], stats["smses"]))
  stat_rows.append(("smses", "SMS character", stats["counts"][p["identity"]]["smschars"], stats["smschars"]))
if stats["counts"][p["identity"]]["calls"]:
  stat_rows.append(("calls", "call", stats["counts"][p["identity"]]["calls"], stats["calls"]))
if stats["counts"][p["identity"]]["calldurations"]:
  stat_rows.append(("calls", "callduration", stats["counts"][p["identity"]]["calldurations"], stats["calldurations"]))
if stats["counts"][p["identity"]]["files"]:
  stat_rows.append(("files", "file", stats["counts"][p["identity"]]["files"], stats["files"]))
  stat_rows.append(("files", "byte", stats["counts"][p["identity"]]["bytes"], stats["bytes"]))
%>
  <tr>
    <td valign="top">
      <table cellpadding="0" cellspacing="0"><tr>
        <td valign="top"><img src="memory:{{avatar_filename}}"/>&nbsp;&nbsp;</td>
        <td valign="center">{{p["name"]}}<br /><font size="2" color="gray">{{p["identity"]}}</font></td>
      </tr></table>
    </td><td valign="top">
%for type, label, count, total in stat_rows:
<%
percent = int(round(util.safedivf(count * 100, total)))
text_cell1 = "&nbsp;%d%%&nbsp;" % round(percent) if (round(percent) > 9) else ""
text_cell2 = "" if text_cell1 else "&nbsp;%d%%&nbsp;" % percent
if "byte" == label:
  text_cell3 = util.format_bytes(count)
elif "callduration" == label:
  text_cell3 = util.format_seconds(count, "call")
else:
  text_cell3 = util.plural(label, count)
%>
      <table cellpadding="0" width="100%" cellspacing="0"><tr>
        <td bgcolor="{{colormap[type]}}" width="{{percent * conf.StatisticsPlotWidth / 100}}" align="center"><font color="#FFFFFF" size="2"><b>{{text_cell1}}</b></font></td>
        <td bgcolor="{{conf.PlotBgColour}}" width="{{(100 - percent) * conf.StatisticsPlotWidth / 100}}" align="center"><font color="{{conf.PlotMessagesColour}}" size="2"><b>{{text_cell2}}</b></font></td>
        <td nowrap="nowrap">&nbsp;{{text_cell3}}</td>
      </tr></table>
%endfor
    </td>
  </tr>
%endfor
  
</table>

%if stats.get("wordcloud"):
<br /><hr />
<table cellpadding="0" cellspacing="0" width="100%"><tr>
  <td><a name="cloud"><b>Word cloud for currently shown messages:</b></a></td>
  <td align="right"><a href="#top"><font color="{{conf.LinkColour}}">Back to top</font></a></td>
</tr></table>
<br /><br />
%for word, count, size in stats["wordcloud"]:
<font color="{{conf.LinkColour}}" size="{{size}}"><a href="{{word}}"><font color="{{conf.LinkColour}}">{{word}}</font></a> ({{count}}) </font>
%endfor
%endif

%if stats.get("transfers"):
<br /><hr /><table cellpadding="0" cellspacing="0" width="100%"><tr><td><a name="transfers"><b>Sent and received files:</b></a></td><td align="right"><a href="#top"><font color="{{conf.LinkColour}}">Back to top</font></a></td></tr></table><br /><br />
<table width="100%">
%for f in stats["transfers"]:
<%
from_remote = (f["partner_handle"] == db.id and skypedata.TRANSFER_TYPE_INBOUND == f["type"]) or \
              (f["partner_handle"] != db.id and skypedata.TRANSFER_TYPE_OUTBOUND == f["type"])
partner = f["partner_dispname"] or db.get_contact_name(f["partner_handle"])
f_datetime = datetime.datetime.fromtimestamp(f["starttime"]).strftime("%Y-%m-%d %H:%M") if f.get("starttime") else ""
%>
  <tr>
    <td align="right" nowrap="" valign="top"><font size="2" face="{{conf.HistoryFontName}}" color="{{conf.HistoryRemoteAuthorColour if from_remote else conf.HistoryLocalAuthorColour}}">{{partner if from_remote else db.account["name"]}}</font></td>
    <td nowrap="" valign="top"><font size="2" face="{{conf.HistoryFontName}}"><a href="{{util.path_to_url(f["filepath"] or f["filename"])}}"><font color="{{conf.LinkColour}}">{{f["filepath"] or f["filename"]}}</font></a></font></td>
    <td align="right" valign="top"><font size="2" face="{{conf.HistoryFontName}}">{{util.format_bytes(int(f["filesize"]))}}</font></td>
    <td nowrap="" valign="top"><font size="2" face="{{conf.HistoryFontName}}">{{f_datetime}}</font></td>
  </tr>
%endfor
</table>
%endif
</font>
"""


"""HTML template for search result row for a matched chat, HTML table row."""
SEARCH_ROW_CHAT_HTML = """<%
import re
import conf

title = chat["title"]
if title_matches:
    title = pattern_replace.sub(lambda x: "<b>%s</b>" % x.group(0), title)
%>
<tr>
  <td align="right" valign="top">
    <font color="{{conf.HistoryGreyColour}}">{{result_count}}</font>
  </td><td colspan="2">
    <a href="chat:{{chat["id"]}}">
    <font color="{{conf.SkypeLinkColour}}">{{title}}</font></a><br />
%if title_matches:
    Title matches.<br />
%endif
%if matching_authors:
    Participant matches: 
%for i, c in enumerate(matching_authors):
<%
name = c["fullname"] or c["displayname"]
name_replaced = pattern_replace.sub(wrap_b, name)
identity_replaced = "" if (c["identity"] == name) else " (%s)" % pattern_replace.sub(wrap_b, c["identity"])
%>
{{", " if i else ""}}{{name_replaced}}{{identity_replaced}}{{"." if i == len(matching_authors) - 1 else ""}}
%endfor
<br />
%endif
</td></tr>
"""


"""TXT template for search result row for a matched chat."""
SEARCH_ROW_CHAT_TXT = """<%
import re
import conf

title = chat["title"]
if title_matches:
    title = pattern_replace.sub(lambda x: "**%s**" % x.group(0), title)
%>
{{"%3d" % result_count}}. {{title}}
%if title_matches:
    Title matches.
%endif
%if matching_authors:
    Participant matches: 
%for i, c in enumerate(matching_authors):
<%
name = c["fullname"] or c["displayname"]
name_replaced = pattern_replace.sub(wrap_b, name)
identity_replaced = "" if (c["identity"] == name) else " (%s)" % pattern_replace.sub(wrap_b, c["identity"])
%>
{{", " if i else ""}}{{name_replaced}}{{identity_replaced}}{{"." if i == len(matching_authors) - 1 else ""}}
%endfor
%endif
"""


"""HTML template for search result row of a matched contact, HTML table row."""
SEARCH_ROW_CONTACT_HTML = """<%
import conf, skypedata
%>
%if count <= 1 and result_count > 1:
<tr><td colspan='3'><hr /></td></tr>
%endif
<tr>
  <td align="right" valign="top">
    <font color="{{conf.DisabledColour}}">{{result_count}}</font>
  </td><td colspan="2">
    <font color="{{conf.DisabledColour}}">{{pattern_replace.sub(wrap_b, contact["name"])}}</font>
    <br /><table>
%for field in filter(lambda x: x in fields_filled, match_fields):
      <tr>
        <td nowrap valign="top"><font color="{{conf.DisabledColour}}">{{skypedata.CONTACT_FIELD_TITLES[field]}}</font></td>
        <td>&nbsp;</td><td>{{fields_filled[field]}}</td>
      </tr>
%endfor
</table><br /></td></tr>
"""


"""TXT template for search result row of a matched contact."""
SEARCH_ROW_CONTACT_TXT = """<%
import conf, skypedata
%>
%if count <= 1 and result_count > 1:
-------------------------------------------------------------------------------
%endif
{{"%3d" % result_count}}. {{title}}
{{pattern_replace.sub(wrap_b, contact["name"])}}
%for field in filter(lambda x: x in fields_filled, match_fields):
  {{"15%s" % skypedata.CONTACT_FIELD_TITLES[field]}}: {{fields_filled[field]}}
%endfor
"""


"""HTML template for search result of chat messages, HTML table row."""
SEARCH_ROW_MESSAGE_HTML = """<%
import datetime
import conf, skypedata
%>
%if count <= 1 and result_count > 1:
<tr><td colspan='3'><hr /></td></tr>
%endif
<tr>
  <td align="right" valign="top">
    <font color="{{conf.HistoryGreyColour}}">{{result_count}}</font>
  </td><td valign="top">
<%
after = ""
if (skypedata.CHATS_TYPE_SINGLE != chat["type"]):
  after = " in %s" % chat["title_long_lc"]
elif m["author"] == search["db"].id:
  after = " to %s" % chat["title"]
%>
    <a href="message:{{m["id"]}}"><font color="{{conf.SkypeLinkColour}}">{{m["from_dispname"]}}{{after}}</font></a>
  </td><td align="right" nowrap>
    &nbsp;&nbsp;<font color="{{conf.HistoryTimestampColour}}">{{datetime.datetime.fromtimestamp(m["timestamp"]).strftime("%d.%m.%Y %H:%M")}}</font>
  </td>
</tr>
<tr><td></td>
  <td width="100%" valign="top" colspan="2">
%if skypedata.MESSAGES_TYPE_INFO == m["type"]:
    <font color="{{conf.HistoryRemoteAuthorColour if m["author"] == search["db"].id else conf.HistoryLocalAuthorColour}}">{{m["from_dispname"]}}</font>
%endif
  {{body}}<br /></td>
</tr>
"""


"""TXT template for search result item for chat messages."""
SEARCH_ROW_MESSAGE_TXT = """<%
import datetime
import conf, skypedata

after = ""
if skypedata.CHATS_TYPE_SINGLE != chat["type"]:
  after = " in %s" % chat["title_long_lc"]
elif m["author"] == search["db"].id:
  after = " to %s" % chat["title"]
%>
{{datetime.datetime.fromtimestamp(m["timestamp"]).strftime("%d.%m.%Y %H:%M")}} {{m["from_dispname"]}}{{after}}: {{body}}
"""


"""HTML template for search results header, start of HTML table."""
SEARCH_HEADER_HTML = """<%
import conf
%>
<font size="2" face="{{conf.HistoryFontName}}" color="{{conf.FgColour}}">
Results for "{{escape(text)}}" from {{fromtext}}:
%if "all tables" != fromtext:
<br /><br />
<table width="600" cellpadding="2" cellspacing="0">
%endif
"""


"""HTML template for table search results header, start of HTML table."""
SEARCH_ROW_TABLE_HEADER_HTML = """
<br /><br /><b>Table {{table["name"]}}:</b><br />
<table border="1" cellpadding="4" cellspacing="0" width="1000">
<tr>
<th>#</th>
%for col in table["columns"]:
<th>{{escape(col["name"])}}</th>
%endfor
</tr>
"""


"""TXT template for table search results header."""
SEARCH_ROW_TABLE_HEADER_TXT = """
Table {{table["name"]}}:
%for col in ["#"] + table["columns"]:
{{col["name"]}}    
%endfor
"""


"""HTML template for search result of DB table row, HTML table row."""
SEARCH_ROW_TABLE_HTML = """<%
import re
import conf, templates
%>
<tr>
<td align="right" valign="top"><a href="table:{{escape(table["name"])}}:{{count}}">{{count}}</a></td>
%for col in table["columns"]:
<%
value = row[col["name"]]
value = value if value is not None else ""
value = templates.SAFEBYTE_RGX.sub(templates.SAFEBYTE_REPL, unicode(value))
%>
<td valign="top">{{pattern_replace.sub(wrap_b, escape(value))}}</td>
%endfor
</tr>
"""


"""TXT template for search result of DB table row."""
SEARCH_ROW_TABLE_TXT = """<%
import re
import conf, templates
%>
<tr>
{{count}}
%for col in table["columns"]:
<%
value = row[col["name"]]
value = value if value is not None else ""
value = templates.SAFEBYTE_RGX.sub(templates.SAFEBYTE_REPL, unicode(value))
%>
{{pattern_replace.sub(wrap_b, escape(value))}}
%endfor
"""


"""Text shown in Help -> About dialog (HTML content)."""
ABOUT_TEXT = """<%
import sys
import conf
%>
<font size="2" face="Tahoma" color="{{conf.FgColour}}">
<table cellpadding="0" cellspacing="0"><tr><td valign="top">
<img src="memory:skyperious.png" /></td><td width="10"></td><td valign="center">
<b>{{conf.Title}} version {{conf.Version}}</b>, {{conf.VersionDate}}.<br /><br />

{{conf.Title}} is written in Python, released as free open source software
under the MIT License.
</td></tr></table><br /><br />


&copy; 2011-2014, Erki Suurjaak.
<a href="{{conf.HomeUrl}}"><font color="{{conf.LinkColour}}">suurjaak.github.com/Skyperious</font></a><br /><br /><br />



{{conf.Title}} has been built using the following open source software:
<ul>
  <li>wxPython{{" 3.0.0" if getattr(sys, 'frozen', False) else ""}},
      <a href="http://wxpython.org"><font color="{{conf.LinkColour}}">wxpython.org</font></a></li>
  <li>Pillow{{" 2.3.0" if getattr(sys, 'frozen', False) else ""}},
      <a href="https://pypi.python.org/pypi/Pillow/"><font color="{{conf.LinkColour}}">pypi.python.org/pypi/Pillow</font></a></li>
  <li>step, Simple Template Engine for Python,
      <a href="https://github.com/dotpy/step"><font color="{{conf.LinkColour}}">github.com/dotpy/step</font></a></li>
      <li>pyparsing{{" 2.0.1" if getattr(sys, 'frozen', False) else ""}}, 
      <a href="http://pyparsing.wikispaces.com/"><font color="{{conf.LinkColour}}">pyparsing.wikispaces.com</font></a></li>
  <li>XlsxWriter{{" 0.5.3" if getattr(sys, 'frozen', False) else ""}},
      <a href="https://github.com/jmcnamara/XlsxWriter"><font color="{{conf.LinkColour}}">
          github.com/jmcnamara/XlsxWriter</font></a></li>
  <li>dateutil{{" 2.2" if getattr(sys, 'frozen', False) else ""}}, <a href="https://pypi.python.org/pypi/python-dateutil">
      <font color="{{conf.LinkColour}}">pypi.python.org/pypi/python-dateutil</font></a></li>
  <li>Skype4Py, <a href="https://github.com/awahlig/skype4py">
      <font color="{{conf.LinkColour}}">github.com/awahlig/skype4py</font></a></li>
%if getattr(sys, 'frozen', False):
  <li>Python 2.7.6, <a href="http://www.python.org"><font color="{{conf.LinkColour}}">www.python.org</font></a></li>
  <li>PyInstaller 2.1, <a href="http://www.pyinstaller.org">
      <font color="{{conf.LinkColour}}">www.pyinstaller.org</font></a></li>
%endif
</ul><br /><br /><br />



Emoticons in HTML export are property of Skype Limited, &copy; 2004-2006,
released under the Skype Component License 1.0.<br /><br />


Default avatar icon from Fancy Avatars, &copy; 2009 Brandon Mathis<br />
<a href="http://brandonmathis.com/projects/fancy-avatars/">
<font color="{{conf.LinkColour}}">brandonmathis.com/projects/fancy-avatars</font></a><br /><br />


Several icons from Fugue Icons, &copy; 2010 Yusuke Kamiyamane<br />
<a href="http://p.yusukekamiyamane.com/"><font color="{{conf.LinkColour}}">p.yusukekamiyamane.com</font></a>
<br /><br />
Includes fonts Carlito Regular and Carlito bold,
<a href="https://fedoraproject.org/wiki/Google_Crosextra_Carlito_fonts"><font color="{{conf.LinkColour}}">fedoraproject.org/wiki/Google_Crosextra_Carlito_fonts</font></a>
%if getattr(sys, 'frozen', False):
<br /><br />
Installer created with Nullsoft Scriptable Install System 3.0a2,
<a href="http://nsis.sourceforge.net/"><font color="{{conf.LinkColour}}">nsis.sourceforge.net</font></a>
%endif

</font>
"""



"""Contents of the default page on search page."""
SEARCH_WELCOME_HTML = """<%
import conf
%>
<font face="{{conf.HistoryFontName}}" size="2" color="{{conf.FgColour}}">
<center>
<h5><font color="{{conf.SkypeLinkColour}}">Explore the database</font></h5>
<table cellpadding="10" cellspacing="0">
<tr>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <img src="memory:HelpSearch.png" />
      </td><td width="10"></td><td valign="center">
        Search over all Skype messages using a simple Google-like <a href="page:#help"><font color="{{conf.LinkColour}}">syntax</font></a>.<br />
        <br />
        Or choose other search targets from the toolbar: <br />
        search in contact information, or in chat information, <br />
        or across all database tables.
      </td></tr><tr><td nowrap align="center">
        <b><font color="{{conf.FgColour}}">Search</font></b><br />
    </td></tr></table>
  </td>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <a href="page:tables"><img src="memory:HelpTables.png" /></a>
      </td><td width="10"></td><td valign="center">
        Browse, filter and change database tables,<br />
        export as HTML, SQL INSERT-statements or spreadsheet.
      </td></tr><tr><td nowrap align="center">
        <a href="page:tables"><b><font color="{{conf.FgColour}}">Data tables</font></b></a><br />
    </td></tr></table>
  </td>
</tr>
<tr>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <a href="page:chats"><img src="memory:HelpChats.png" /></a>
      </td><td width="10"></td><td valign="center">
        Read Skype chats,
        view statistics and word clouds, <br />
        filter by content, date or author,<br />
        export as HTML, TXT or spreadsheet.
      </td></tr><tr><td nowrap align="center">
        <a href="page:chats"><b><font color="{{conf.FgColour}}">Chats</font></b></a><br />
    </td></tr></table>
  </td>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <a href="page:sql"><img src="memory:HelpSQL.png" /></a>
      </td><td width="10"></td><td valign="center">
        Make direct SQL queries in the database,<br />
        export results as HTML or spreadsheet.
      </td></tr><tr><td nowrap align="center">
        <a href="page:sql"><b><font color="{{conf.FgColour}}">SQL window</font></b></a><br />
    </td></tr></table>
  </td>
</tr>
<tr>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <a href="page:info"><img src="memory:HelpInfo.png" /></a>
      </td><td width="10"></td><td valign="center">
        See information about the Skype account in this file,<br />
        view general database statistics,<br />
        check database integrity for corruption and recovery.
      </td></tr><tr><td nowrap align="center">
        <a href="page:info"><b><font color="{{conf.FgColour}}">Information</font></b></a>
    </td></tr></table>
  </td>
  <td>
    <table cellpadding="0" cellspacing="2"><tr><td>
        <a href="page:contacts"><img src="memory:HelpContacts.png" /></a>
      </td><td width="10"></td><td valign="center">
        Import contacts to Skype from a CSV file,<br />
        like ones exported from MSN or GMail.
      </td></tr><tr><td nowrap align="center">
        <a href="page:contacts"><b><font color="{{conf.FgColour}}">Contacts+</font></b></a>
    </td></tr></table>
  </td>
</tr>
</table>
</center>
</font>
"""


"""Long help text shown in a separate tab on search page."""
SEARCH_HELP_LONG = """<%
import conf
%>
<font size="2" face="{{conf.HistoryFontName}}" color="{{conf.FgColour}}">

{{conf.Title}} supports a Google-like syntax for searching messages:<br /><br />
<table><tr><td width="500">
  <table border="0" cellpadding="5" cellspacing="1" bgcolor="{{conf.HelpBorderColour}}"
   valign="top" width="500">
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search for exact word or phrase</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>"do re mi"</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      Use quotes (<font color="{{conf.HelpCodeColour}}"><code>"</code></font>) to search for
      an exact phrase or word. Quoted text is searched exactly as entered,
      leaving whitespace as-is and ignoring any wildcard characters.
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search for either word</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>this OR that</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      To find messages containing at least one of several words,
      include <font color="{{conf.HelpCodeColour}}"><code>OR</code></font> between the words.
      <font color="{{conf.HelpCodeColour}}"><code>OR</code></font> works also
      for phrases and grouped words (but not keywords).
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Group words together</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>(these two) OR this<br/>
      -(none of these)</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      Surround words with round brackets to group them for <code>OR</code>
      queries or for excluding from results.
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search for partially matching text</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>bas*ball</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      Use an asterisk (<font color="{{conf.HelpCodeColour}}"><code>*</code></font>) to make a
      wildcard query: the wildcard will match any text between its front and
      rear characters (including other words).
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search within specific chats</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>chat:office<br />
      chat:"coffee &amp; cig"</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      To find messages from specific chats only, use the keyword
      <font color="{{conf.HelpCodeColour}}"><code>chat:name</code></font>.<br /><br />
      Search from more than one chat by adding more 
      <font color="{{conf.HelpCodeColour}}"><code>chat:</code></font> keywords.
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search from specific authors</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>from:maria<br />
      from:"john smith"</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      To find messages from specific authors only, use the keyword
      <font color="{{conf.HelpCodeColour}}"><code>from:name</code></font>.<br /><br />
      Search from more than one author by adding more
      <font color="{{conf.HelpCodeColour}}"><code>from:</code></font> keywords.
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Search from specific time periods</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>date:2008<br />date:2009-01<br />
      date:2005-12-24..2007</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      To find messages from specific time periods, use the keyword
      <font color="{{conf.HelpCodeColour}}"><code>date:period</code></font> or
      <font color="{{conf.HelpCodeColour}}"><code>date:periodstart..periodend</code></font>.
      For the latter, either start or end can be omitted.<br /><br />
      A date period can be year, year-month, or year-month-day. Additionally,
      <font color="{{conf.HelpCodeColour}}"><code>date:period</code></font> can use a wildcard
      in place of any part, so
      <font color="{{conf.HelpCodeColour}}"><code>date:*-12-24</code></font> would search for
      all messages from the 24th of December.<br /><br />
      Search from a more narrowly defined period by adding more
      <font color="{{conf.HelpCodeColour}}"><code>date:</code></font> keywords.
      <br />
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>Exclude words or keywords</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>-notthisword<br />-"not this phrase"<br />
      -(none of these)<br/>-chat:notthischat<br/>-from:notthisauthor<br />
      -date:2013</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      To exclude certain messages, add a dash
      (<font color="{{conf.HelpCodeColour}}"><code>-</code></font>) in front of words,
      phrases, grouped words or keywords.
    </td>
  </tr>
  <tr>
    <td bgcolor="{{conf.BgColour}}" width="150">
      <b>SPECIAL: search specific tables</b><br /><br />
      <font color="{{conf.HelpCodeColour}}"><code>table:fromthistable<br />
      -table:notfromthistable</code></font>
      <br />
    </td>
    <td bgcolor="{{conf.BgColour}}">
      <br /><br />
      When performing search on all columns of all database tables
      (the fourth option on the search toolbar),
      use the keyword <font color="{{conf.HelpCodeColour}}"><code>table:name</code></font>
      to constrain results to specific tables only.<br /><br />
      Search from more than one table by adding more
      <font color="{{conf.HelpCodeColour}}"><code>table:</code></font> keywords, or exclude certain
      tables by adding a <font color="{{conf.HelpCodeColour}}"><code>-table:</code></font> keyword.
      <br />
    </td>
  </tr>
  </table>

</td><td valign="top" align="left">

  <b><font size="3">Examples</font></b><br /><br />

  <ul>
    <li>search for "flickr.com" from John or Jane in chats named "links":
        <br /><br />
        <font color="{{conf.HelpCodeColour}}">
        <code>flickr.com from:john from:jane chat:links</code></font><br />
    </li>
    <li>search from John Smith up to 2011:<br /><br />
        <font color="{{conf.HelpCodeColour}}"><code>from:"john smith" date:..2011</code></font>
        <br />
    </li>
    <li>search for either "John" and "my side" or "Stark" and "your side":
        <br /><br />
        <font color="{{conf.HelpCodeColour}}">
        <code>(john "my side") OR (stark "your side")</code></font><br />
    </li>
    <li>search for either "barbecue" or "grill" in 2012,
        except from June to August:<br /><br />
        <font color="{{conf.HelpCodeColour}}">
        <code>barbecue OR grill date:2012 -date:2012-06..2012-08</code>
        </font><br />
    </li>
    <li>search for "TPS report" in chats named "office"
        (but not named "backoffice") on the first day of the month in 2012:
        <br /><br />
        <font color="{{conf.HelpCodeColour}}">
        <code>"tps report" chat:office -chat:backoffice date:2012-*-1</code>
        </font><br />
    </li>
  </ul>

  <br /><br /><br />
  Search is made on raw Skype message body, so there can be results which do not
  seem to match the query - Skype messages contain more than plain text.<br />
  For example, searching for <font color="{{conf.HelpCodeColour}}"><code>href</code></font> will match a message with body
  <code><font color="{{conf.HelpCodeColour}}">&lt;a href="http://lmgtfy.com/"&gt;lmgtfy.com&lt;/a&gt;</font></code>,<br />
  displayed as <a href="http://lmgtfy.com/"><font color="{{conf.LinkColour}}">lmgtfy.com</font></a>.<br /><br />
  This can be used for finding specific type of messages, for example
  <font color="{{conf.HelpCodeColour}}"><code>&lt;sms</code></font> finds SMS messages, 
  <font color="{{conf.HelpCodeColour}}"><code>&lt;file</code></font> finds transfers, 
  <font color="{{conf.HelpCodeColour}}"><code>&lt;quote</code></font> finds quoted messages,
  and <font color="{{conf.HelpCodeColour}}"><code>&lt;ss</code></font> finds messages with emoticons.

</td></tr></table>
</font>
"""


"""Short help text shown on search page."""
SEARCH_HELP_SHORT = """<%
import os
import conf
helplink = "Search help"
if "nt" == os.name: # In Windows, wx.HtmlWindow shows link whitespace quirkily
    helplink = helplink.replace(" ", "_")
%>
<font size="2" face="{{conf.HistoryFontName}}" color="{{conf.DisabledColour}}">
For searching messages from specific chats, add "chat:name", and from specific contacts, add "from:name".
&nbsp;&nbsp;<a href=\"page:#help\"><font color="{{conf.LinkColour}}">{{helplink}}</font></a>.
</font>
"""


"""Database links on merge page."""
MERGE_DB_LINKS = """<%
import conf
%>
<font color="{{conf.FgColour}}">From <a href="{{db1.filename}}"><font color="{{conf.LinkColour}}">{{db1.filename}}</font></a> into <a href="{{db2.filename}}"><font color="{{conf.LinkColour}}">{{db2.filename}}</font></a>:</font>
"""


"""HTML template for quote elements in message body."""
MESSAGE_QUOTE = """
%if export:
<table class="quote"><tr>
    <td><span>&#8223;</span></td>
    <td><br /><span class="grey">{EMDASH} </span></td>
</tr></table>
%else:
<%
import conf
%>
<table cellpadding="0" cellspacing="0"><tr>
    <td valign="top"><font color="{{conf.DisabledColour}}" size="7">&quot;|</font></td>
    <td><br /><font color="{{conf.DisabledColour}}">{EMDASH} </font></td>
</tr></table>
%endif
"""


"""Chat row in database diff results list."""
DIFF_RESULT_ITEM = """<%
import conf
%>
<a href="{{chat["identity"]}}"><font color="{{conf.LinkColour}}">{{chat["title_long"]}}</font></a>
"""

########NEW FILE########
__FILENAME__ = step
"""
A light and fast template engine.

Copyright (c) 2012, Daniele Mazzocchio  
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
* Neither the name of the developer nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import re


class Template(object):

    COMPILED_TEMPLATES = {} # {template string: code object, }
    # Regex for stripping all leading, trailing and interleaving whitespace.
    RE_STRIP = re.compile("(^[ \t]+|[ \t]+$|(?<=[ \t])[ \t]+|\A[\r\n]+|[ \t\r\n]+\Z)", re.M)

    def __init__(self, template, strip=True):
        """Initialize class"""
        super(Template, self).__init__()
        self.template = template
        self.options  = {"strip": strip}
        self.builtins = {"escape": lambda s: escape_html(s),
                         "setopt": lambda k, v: self.options.update({k: v}), }
        if template in Template.COMPILED_TEMPLATES:
            self.code = Template.COMPILED_TEMPLATES[template]
        else:
            self.code = self._process(self._preprocess(self.template))
            Template.COMPILED_TEMPLATES[template] = self.code

    def expand(self, namespace={}, **kw):
        """Return the expanded template string"""
        output = []
        namespace.update(kw, **self.builtins)
        namespace["echo"]  = lambda s: output.append(s)
        namespace["isdef"] = lambda v: v in namespace

        eval(compile(self.code, "<string>", "exec"), namespace)
        return self._postprocess("".join(map(to_unicode, output)))

    def stream(self, buffer, namespace={}, encoding="utf-8", **kw):
        """Expand the template and stream it to a file-like buffer."""

        def write_buffer(s, flush=False, cache = [""]):
            # Cache output as a single string and write to buffer.
            cache[0] += to_unicode(s)
            if flush and cache[0] or len(cache[0]) > 65536:
                buffer.write(postprocess(cache[0]))
                cache[0] = ""

        namespace.update(kw, **self.builtins)
        namespace["echo"]  = write_buffer
        namespace["isdef"] = lambda v: v in namespace
        postprocess = lambda s: s.encode(encoding)
        if self.options["strip"]:
            postprocess = lambda s: Template.RE_STRIP.sub("", s).encode(encoding)

        eval(compile(self.code, "<string>", "exec"), namespace)
        write_buffer("", flush=True) # Flush any last cached bytes

    def _preprocess(self, template):
        """Modify template string before code conversion"""
        # Replace inline ('%') blocks for easier parsing
        o = re.compile("(?m)^[ \t]*%((if|for|while|try).+:)")
        c = re.compile("(?m)^[ \t]*%(((else|elif|except|finally).*:)|(end\w+))")
        template = c.sub(r"<%:\g<1>%>", o.sub(r"<%\g<1>%>", template))

        # Replace ({{x}}) variables with '<%echo(x)%>'
        v = re.compile("\{\{(.*?)\}\}")
        template = v.sub(r"<%echo(\g<1>)%>\n", template)

        return template

    def _process(self, template):
        """Return the code generated from the template string"""
        code_blk = re.compile(r"<%(.*?)%>\n?", re.DOTALL)
        indent = 0
        code = []
        for n, blk in enumerate(code_blk.split(template)):
            # Replace '<\%' and '%\>' escapes
            blk = re.sub(r"<\\%", "<%", re.sub(r"%\\>", "%>", blk))
            # Unescape '%{}' characters
            blk = re.sub(r"\\(%|{|})", "\g<1>", blk)

            if not (n % 2):
                # Escape double-quote characters
                blk = re.sub(r"\"", "\\\"", blk)
                blk = (" " * (indent*4)) + 'echo("""{0}""")'.format(blk)
            else:
                blk = blk.rstrip()
                if blk.lstrip().startswith(":"):
                    if not indent:
                        err = "unexpected block ending"
                        raise SyntaxError("Line {0}: {1}".format(n, err))
                    indent -= 1
                    if blk.startswith(":end"):
                        continue
                    blk = blk.lstrip()[1:]

                blk = re.sub("(?m)^", " " * (indent * 4), blk)
                if blk.endswith(":"):
                    indent += 1

            code.append(blk)

        if indent:
            err = "Reached EOF before closing block"
            raise EOFError("Line {0}: {1}".format(n, err))

        return "\n".join(code)

    def _postprocess(self, output):
        """Modify output string after variables and code evaluation"""
        if self.options["strip"]:
            output = Template.RE_STRIP.sub("", output)
        return output


def escape_html(x):
    """Escape HTML special characters &<> and quotes "'."""
    CHARS, ENTITIES = "&<>\"'", ["&amp;", "&lt;", "&gt;", "&quot;", "&#39;"]
    string = x if isinstance(x, basestring) else str(x)
    for c, e in zip(CHARS, ENTITIES): string = string.replace(c, e)
    return string


def to_unicode(x, encoding="utf-8"):
    """Convert anything to Unicode."""
    if not isinstance(x, unicode):
        x = unicode(str(x), encoding, errors="replace")
    return x

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf-8 -*-
"""
Miscellaneous utility functions.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     16.02.2012
@modified    12.05.2014
------------------------------------------------------------------------------
"""
import cStringIO
import ctypes
import locale
import math
import os
import re
import string
import subprocess
import sys
import tempfile
import time
import urllib

from PIL import Image
try:
    import wx
except ImportError:
    pass # Most functionality works without wx


def m(o, name, case_insensitive=True):
    """Returns the members of the object or dict, filtered by name."""
    members = o.keys() if isinstance(o, dict) else dir(o)
    if case_insensitive:
        return [i for i in members if name.lower() in i.lower()]
    else:
        return [i for i in members if name in i]


def safedivf(a, b):
    """A zero-safe division, returns 0.0 if b is 0, a / float(b) otherwise."""
    return a / float(b) if b else 0.0


def safe_filename(filename):
    return re.sub(r"[\/\\\:\*\?\"\<\>\|]", "", filename)


def format_bytes(size, precision=2, max_units=True):
    """
    Returns a formatted byte size (e.g. "421.45 MB" or "421,451,273 bytes").

    @param   precision  number of decimals to leave after converting to
                        maximum units
    @param   max_units  whether to convert value to corresponding maximum
                        unit, or leave as bytes and add thousand separators
    """
    formatted = "0 bytes"
    size = int(size)
    if size:
        byteunit = "byte" if 1 == size else "bytes"
        if max_units:
            UNITS = [byteunit, "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
            log = min(len(UNITS) - 1, math.floor(math.log(size, 1024)))
            formatted = "%.*f" % (precision, size / math.pow(1024, log))
            while formatted.endswith("0"): formatted = formatted[:-1]
            if formatted.endswith("."): formatted = formatted[:-1]
            formatted += " " + UNITS[int(log)]
        else:
            formatted = "".join([x + ("," if i and not i % 3 else "")
                                 for i, x in enumerate(str(size)[::-1])][::-1])
            formatted += " " + byteunit
    return formatted


def format_seconds(seconds, insert=""):
    """
    Returns nicely formatted seconds, e.g. "25 hours, 12 seconds".

    @param   insert  text inserted between count and unit, e.g. "4 call hours"
    """
    insert = insert + " " if insert else ""
    formatted = "0 %sseconds" % insert
    seconds = int(seconds)
    if seconds:
        formatted, inter = "", ""
        for unit, count in zip(["hour", "minute", "second"], [3600, 60, 1]):
            if seconds >= count:
                label = "%s%s" % (insert if not formatted else "", unit)
                formatted += inter + plural(label, seconds / count)
                seconds %= count
                inter = ", "
    return formatted


def plural(word, items=None, with_items=True):
    """
    Returns the word as 'count words', or '1 word' if count is 1,
    or 'words' if count omitted.

    @param   items       item collection or count,
                         or None to get just the plural of the word
             with_items  if False, count is omitted from final result
    """
    count = items or 0
    if hasattr(items, "__len__"):
        count = len(items)
    result = word + ("" if 1 == count else "s")
    if with_items and items is not None:
        result = "%s %s" % (count, result)
    return result


def cmp_dicts(dict1, dict2):
    """Returns True if dict2 has all the keys and matching values as dict1."""
    result = True
    index = 0
    for key, val in dict1.items():
        if key not in dict2:
            result = False
        elif dict2[key] != val:
            result = False
        if not result:
            break # break for key, val
    return result


def cmp_dictlists(list1, list2):
    """Returns the two dictionary lists with matching dictionaries removed."""

    # Items different in list1, items different in list2
    result = ([], [])
    for d1 in list1:
        match = False
        for d2 in list2:
            if cmp_dicts(d1, d2):
                match = True
                break # break for d2 in list2
        if not match:
            result[0].append(d1)
    for d2 in list2:
        match = False
        for d1 in list1:
            if cmp_dicts(d2, d1):
                match = True
                break # break for d1 in list1
        if not match:
            result[1].append(d2)
    return result


def try_until(func, count=1, sleep=0.5):
    """
    Tries to execute the specified function a number of times.

    @param    func   callable to execute
    @param    count  number of times to try (default 1)
    @param    sleep  seconds to sleep after failed attempts, if any
                     (default 0.5)
    @return          (True, func_result) if success else (False, None)
    """
    tries = 0
    result = False
    func_result = None
    while tries < count:
        tries += 1
        try:
            func_result = func()
            result = True
        except Exception as e:
            if tries < count and sleep:
                time.sleep(sleep)
    return result, func_result


def to_int(value):
    """Returns the value as integer, or None if not integer."""
    try:
        result = int(value)
    except ValueError as e:
        result = None
    return result


def unique_path(pathname):
    """
    Returns a unique version of the path. If a file or directory with the
    same name already exists, returns a unique version
    (e.g. "C:\config (2).sys" if ""C:\config.sys" already exists).
    """
    result = pathname
    if "linux2" == sys.platform and isinstance(result, unicode) \
    and "utf-8" != sys.getfilesystemencoding():
        result = result.encode("utf-8") # Linux has trouble if locale not UTF-8
    path, name = os.path.split(result)
    base, ext = os.path.splitext(name)
    if len(name) > 255: # Filesystem limitation
        name = base[:255 - len(ext) - 2] + ".." + ext
        result = os.path.join(path, name)
    counter = 2
    while os.path.exists(result):
        suffix = " (%s)%s" % (counter, ext)
        name = base + suffix
        if len(name) > 255:
            name = base[:255 - len(suffix) - 2] + ".." + suffix
        result = os.path.join(path, name)
        counter += 1
    return result


def start_file(filepath):
    """
    Tries to open the specified file.

    @return  (success, error message)
    """
    success, error = True, ""
    try:
        if "nt" == os.name:
            try:
                os.startfile(filepath)
            except WindowsError as e:
                if 1155 == e.winerror: # ERROR_NO_ASSOCIATION
                    cmd = "Rundll32.exe SHELL32.dll, OpenAs_RunDLL %s"
                    os.popen(cmd % filepath)
                else:
                    raise
        elif "mac" == os.name:
            subprocess.call(("open", filepath))
        elif "posix" == os.name:
            subprocess.call(("xdg-open", filepath))
    except Exception as e:
        success, error = False, repr(e)
    return success, error


def is_os_64bit():
    """Returns whether the operating system is 64-bit (Windows-only)."""
    if 'PROCESSOR_ARCHITEW6432' in os.environ:
        return True
    return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')


def htmltag(name, attrs=None, content=None, utf=True):
    """
    Returns an HTML tag string for the specified name, attributes and content.

    @param   name     HTML tag name, like 'a'
    @param   attrs    tag attributes dict
    @param   content  tag content string
    @param   utf      whether to convert all values to UTF-8
    """
    SELF_CLOSING_TAGS = ["img", "br", "meta", "hr", "base", "basefont",
                         "input", "area", "link"]
    tag = "<%s" % name
    if attrs:
        tag += " " + " ".join(["%s='%s'" % (k, escape_html(v, utf=utf))
                               for k, v in attrs.items()])
    if name not in SELF_CLOSING_TAGS:
    #or (content is not None and str(content)):
        tag += ">%s</%s>" % (escape_html(content, utf=utf), name)
    else:
        tag += " />"
    return tag


def escape_html(value, utf=True):
    """
    Escapes the value for HTML content (converts "'< to &quot;&#39;&lt;).

    @param   value  string or unicode value
    @param   utf    whether to encode result into UTF-8 (True by default)
    """
    strval = value if isinstance(value, basestring) \
             else (str(value) if value is not None else "")
    result = strval.replace("<",    "&lt;").replace(">", "&gt;") \
                   .replace("\"", "&quot;").replace("'", "&#39;")
    if utf:
        result = result.encode("utf-8")
    return result


def round_float(value, precision=1):
    """
    Returns the float as a string, rounded to the specified precision and
    with trailing zeroes (and . if no decimals) removed.
    """
    result = str(round(value, precision)).rstrip("0").rstrip(".")
    return result


def divide_delta(td1, td2):
    """Divides two timedeltas and returns the integer result."""
    us1 = td1.microseconds + 1000000 * (td1.seconds + 86400 * td1.days)
    us2 = td2.microseconds + 1000000 * (td2.seconds + 86400 * td2.days)
    # Integer division, fractional division would be float(us1) / us2
    return us1 / us2


def pil_to_wx_image(pil_image, copy_alpha=True):
    """Converts a PIL.Image to wx.Image."""
    wx_image = wx.EmptyImage(*pil_image.size)
    wx_image.SetData(pil_image.convert("RGB").tostring())
    if copy_alpha and ("A" == pil_image.mode[-1]):
        wx_image.SetAlphaData(pil_image.tostring()[3::4])
    return wx_image


def wx_image_to_pil(wx_image, copy_alpha=True):
    """Converts a wx.Image to PIL.Image."""
    pil_image = Image.new("RGB", wx_image.GetSize())
    pil_image.fromstring(wx_image.Data)
    if wx_image.HasAlpha() and copy_alpha:
        pil_image = pil_image.convert("RGBA")
        alpha = Image.fromstring("L", wx_image.GetSize(), wx_image.AlphaData)
        pil_image.putalpha(alpha)
    return pil_image


def wx_bitmap_to_raw(wx_bitmap, format="PNG"):
    """Returns the wx.Bitmap or wx.Image as raw data of specified type."""
    stream = cStringIO.StringIO()
    img = wx_bitmap if isinstance(wx_bitmap, wx.Image) \
          else wx_bitmap.ConvertToImage()
    wx_image_to_pil(img).save(stream, format)
    result = stream.getvalue()
    return result


def timedelta_seconds(timedelta):
    """Returns the total timedelta duration in seconds."""
    if hasattr(timedelta, "total_seconds"):
        result = timedelta.total_seconds()
    else: # Python 2.6 compatibility
        result = timedelta.days * 24 * 3600 + timedelta.seconds + \
                 timedelta.microseconds / 1000000.
    return result


def add_unique(lst, item, direction=1, maxlen=sys.maxint):
    """
    Adds the item to the list from start or end. If item is already in list,
    removes it first. If list is longer than maxlen, shortens it.

    @param   direction  side from which item is added, -1/1 for start/end
    @param   maxlen     maximum length list is allowed to grow to before
                        shortened from the other direction
    """
    if item in lst:
        lst.remove(item)
    lst.insert(0, item) if (direction < 0) else lst.append(item)
    if len(lst) > maxlen:
        lst[:] = lst[:maxlen] if (direction < 0) else lst[-maxlen:]
    return lst


def get_locale_day_date(dt):
    """Returns a formatted (weekday, weekdate) in current locale language."""
    weekday = dt.strftime("%A")
    weekdate = dt.strftime("%d. %B %Y")
    if locale.getpreferredencoding():
        try:
            weekday = weekday.decode(locale.getpreferredencoding())
            weekdate = weekdate.decode(locale.getpreferredencoding())
        except Exception:
            try:
                weekday = weekday.decode("latin1")
                weekdate = weekdate.decode("latin1")
            except Exception:
                pass
    weekday = weekday.capitalize()
    return weekday, weekdate


def path_to_url(path, encoding="utf-8"):
    """
    Returns the local file path as a URL, e.g. "file:///C:/path/file.ext".
    """
    if isinstance(path, unicode):
        path = path.encode(encoding)

    if not ":" in path:
        # No drive specifier, just convert slashes and quote the name
        if path[:2] == "\\\\":
            path = "\\\\" + path
        url = urllib.quote("/".join(path.split("\\")))
    else:
        parts = path.split(":")
        url = ""

        if len(parts[0]) == 1: # Looks like a proper drive, e.g. C:\
            url = "///" + urllib.quote(parts[0].upper()) + ":"
            parts = parts[1:]
        components = ":".join(parts).split("\\")
        for part in filter(None, components):
            url += "/" + urllib.quote(part)

    url = "file:%s%s" % ("" if url.startswith("///") else "///" , url)
    return url


def to_unicode(value):
    """Returns the value as a Unicode string."""
    result = value
    if not isinstance(value, unicode):
        if isinstance(value, str):
            try:
                result = unicode(value, locale.getpreferredencoding())
            except Exception:
                result = unicode(value, "utf-8", errors="replace")
        else:
            result = unicode(str(value), errors="replace")
    return result


def longpath(path):
    """Returns the path in long Windows form (not shortened to PROGRA~1)."""
    result = path
    try:
        buf = ctypes.create_unicode_buffer(65536)
        GetLongPathNameW = ctypes.windll.kernel32.GetLongPathNameW
        if GetLongPathNameW(unicode(path), buf, 65536):
            result = buf.value
        else:
            head, tail = os.path.split(path)
            if GetLongPathNameW(unicode(head), buf, 65536):
                result = os.path.join(buf.value, tail)
    except Exception: pass
    return result

########NEW FILE########
__FILENAME__ = wordcloud
# -*- coding: utf-8 -*-
"""
A very simple word cloud analyzer, provides only word size calculation and no
layout.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     17.01.2012
@modified    10.04.2014
------------------------------------------------------------------------------
"""
import collections
import re

import conf

"""Default language for common words."""
DEFAULT_LANGUAGE = "en"

"""Maximum amount of words to include."""
WORDS_MAX = 100

"""Minimum count for words to be included."""
COUNT_MIN = 2

"""Minimum length for words to be included."""
LENGTH_MIN = 2

"""Minimum font size for words (for wx.html.HtmlWindow)."""
FONTSIZE_MIN = 0

"""Maximum font size for words (for wx.html.HtmlWindow)."""
FONTSIZE_MAX = 7

"""A map of languages and common words."""
COMMON_WORDS = {
    "en": u"""
        i me my myself we us our ours ourselves you your yours yourself
        yourselves he him his himself she her hers herself it its itself they
        them their theirs themselves what which who whom whose this that these
        those am is are was were be been being have has had having do does did
        doing will would should can could ought i'm you're he's she's it's
        we're they're i've  you've we've they've i'd you'd he'd she'd we'd
        they'd i'll you'll he'll she'll we'll they'll isn't aren't wasn't
        weren't hasn't  haven't hadn't doesn't don't didn't won't wouldn't
        werent hasnt havent hadnt doesnt dont didnt wont wouldnt
        shan't shouldn't can't cannot couldn't mustn't let's that's who's
        shant shouldnt cant cannot couldnt mustnt lets thats whos
        what's here's there's when's where's why's how's a an the and but if or
        because as until while of at by for with about against between into
        through during before after above below to from up upon down in out on
        off over under again further then once here there when where why how
        all any both each few more most other some such no nor not only own
        same so than too very say says said shall just ok now much like also
        well really probably still hey hi around quite one two yeah many see
        get go
        """,
    "et": u"""
        a aga aha ahaa ainult alates all alla alles alt asemel ciao edasi ees 
        eest ega ehk ehkki ei eile elik enam end endale ennast enne ennem 
        ennist ent eriti et ette hea hei heip hetkel hiljuti hm hmm hmmm hmmmm 
        hoi homme hoopis hsti iga ikka ilma ilmselt ise isegi ja jah jahh 
        jaoks jap japp jees jep jepp jmt jne ju juba just juurde juures jlle 
        jrel jrele jrelt jrgi ka kaasa kas keegi kes keskel keski 
        kindlasti kinni kle kohe kohta kokku koos kuhu kuhugi kui kuid kuidas 
        kuigi kuna kunagi kuni kus kuskil kuskile kusagil kusagile kust kuule 
        kik krval krvale krvalt ktte kll ligi lihtsalt liiga lbi 
        lhemal lhemale lhemalt ma maha me meid meie meil meile mh mhh mhmh 
        mida midagi miks millal mina mind mingeid mingi mingit minna minu minus
        mis miski mitte mitu mm mmm mu muidu muidugi mujal mujale mujalt mul 
        mulle mus naa nad nagu nagunii natuke need neid neil neis nemad nii 
        niisama ning no noh nojah niteks nd og ogi ok oki okei ole oled 
        oleks olema oleme olen olevat olgu olid olime olin olla oli olid oligi 
        olin  on ongi oma omad omal omale omas ometi paiku pakaa palju peab 
        peaks peal peale pealt pigem pihta pole pool poole praegu phjal prast
        pris rohkem sa saa saab saaks samas sageli sau sauh seal sealt see 
        sees seda sellal selle sellega selleks sellel sellelt selles sellest 
        selline sellist sest siin siis siiski siit sina sind sinna sinu sinul 
        sisse su suht suhtes sul sulle sult sl slt ta taga tagant tagasi 
        talle te tea tead teda tegelikult tegelt teha teie teid teil tema 
        temale tere terv tervist tol tollal too tsau tshau tau tuleb tulla 
        tundub tna tpselt yo umbes vahel vaid vaja vara varem vast vastu vbl 
        veel veidi vist vi vib vib-olla vibolla vid viks vga vhe vhem 
        vhemalt vlja vljas vljast ite kki ra ks ldse le les mber 
        mbert sna yle yo and in is of the to you
    """,
    "ru": u"""
                               
                         
                       
                      
                      
                     
                    
                  
                     
                    
                    
                   
                    
                     
                   
                   
                   
                    
                     
                  
                    
                     
                     
                   
                    
                 
                
                     
                     
                    
                     
                  
                    
                  
                
                   
                  
                     
                    
                   
                  
                  
                   
                   
                 
                    
                   
                    
                      
                       
                     
                      
             - - - - 
        - - - - - - - 
        - - - - -- - .. .. .. 
        .. .. aga budem budet budu byl byla byli bylo byt chto da davai 
        davaj dykk ee emu esli est est' eta eto gde ili kak ne net nu ok on 
        ona oni my mne menya mozhet mozhno privet ya tak tam togda tolko 
        tol'ko tebe uzhe ty vy vam 
    """
}



def get_cloud(text, additions=None):
    """
    Returns the word cloud for the specified text. Language of the text is
    autodetected from among English (default), Estonian and Russian, and
    pre-defined common words (like 'at') are removed.

    @param   text       text to analyze
    @param   additions  a pre-parsed list of additional words to add
    @return             in descending order of relevance, as
                        [('word', count, font size), ]
    """
    result = []
    words = re.findall("\w{%s,}" % LENGTH_MIN, text.lower(), re.UNICODE) \
            + (additions or [])
    commons = set(get_common_words(words))
    cloud = collections.defaultdict(lambda: 0)
    # Add and count all non-common and not wholly numeric words
    for i in filter(lambda x: x not in commons and re.search("\D", x), words):
        cloud[i] += 1
    # Drop rare words and limit the number of words
    count_last = COUNT_MIN
    if len(cloud) > WORDS_MAX:
        count_last = max(count_last, sorted(cloud.values())[WORDS_MAX - 1])
    cloud = dict((i, cloud[i]) for i in cloud if cloud[i] >= count_last)
    count_min = min(cloud.values()) if cloud else -1
    count_max = max(cloud.values()) if cloud else -1
    for word, count in cloud.items():
        size = get_word_size(count, count_min, count_max)
        result.append((word, count, size))
    result.sort(key=lambda x: x[1], reverse=True) # Sort by count
    result = result[:WORDS_MAX]
    return result


def get_word_size(count, count_min, count_max):
    """
    Returns the font size for a word.

    @param   count      count of the word in the text
    @param   count_min  minimum word count in the text
    @param   count_max  maximum word count in the text
    @return             FONTSIZE_MIN..FONTSIZE_MAX
    """
    result = FONTSIZE_MAX
    if count_min != count_max:
        lo, hi = FONTSIZE_MIN, FONTSIZE_MAX
        ratio = count / float(count_max - count_min)
        result = int(lo + (hi - lo) * min(1, ratio ** 0.2))
    return result


def get_common_words(words):
    """
    Returns the defined common words for the specified words, in the language
    that matches best the given words.

    @param   words  a list of words
    @return         a list of common words
    """
    best_matches = []
    max_matches = 0

    for language, text in COMMON_WORDS.items():
        commons = set(re.findall("\w+", text, re.UNICODE))
        match_count = len(commons.intersection(words))

        if match_count > max_matches:
            best_matches = commons
            max_matches = match_count

    return best_matches

########NEW FILE########
__FILENAME__ = workers
# -*- coding: utf-8 -*-
"""
Background workers for potentially long-running tasks like searching and
diffing.

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     10.01.2012
@modified    27.04.2014
------------------------------------------------------------------------------
"""
import datetime
import Queue
import re
import threading
import time
import traceback

try:
    import wx
except ImportError:
    pass # Most functionality works without wx

from third_party import step

import conf
import main
import searchparser
import skypedata
import templates
import util


class WorkerThread(threading.Thread):
    """Base class for worker threads."""

    def __init__(self, callback):
        """
        @param   callback  function to call with result chunks
        """
        threading.Thread.__init__(self)
        self.daemon = True # Daemon threads do not keep application running
        self._callback = callback
        self._is_running = False
        self._stop_work = False   # Flag to stop the current work
        self._drop_results = False # Flag to not post back obtained results
        self._queue = Queue.Queue()
        self.start()


    def work(self, data):
        """
        Registers new work to process. Stops current work, if any.

        @param   data  a dict with work data
        """
        self._stop_work = True
        self._queue.put(data)


    def stop(self):
        """Stops the worker thread."""
        self._is_running = False
        self._drop_results = True
        self._stop_work = True
        self._queue.put(None) # To wake up thread waiting on queue


    def stop_work(self, drop_results=False):
        """
        Signals to stop the currently ongoing work, if any. Obtained results
        will be posted back, unless drop_results is True.
        """
        self._stop_work = True
        self._drop_results = drop_results


    def postback(self, data):
        # Check whether callback is still bound to a valid object instance
        if getattr(self._callback, "__self__", True):
            self._callback(data)


    def yield_ui(self):
        """Allows UI to respond to user input."""
        try: wx.YieldIfNeeded()
        except Exception: pass



class SearchThread(WorkerThread):
    """
    Search background thread, searches the database on demand, yielding
    results back to main thread in chunks.
    """


    def match_all(self, text, words):
        """Returns whether the text contains all the specified words."""
        text_lower = text.lower()
        result = all(w in text_lower for w in words)
        return result


    def run(self):
        self._is_running = True
        # For identifying "chat:xxx" and "from:xxx" keywords
        query_parser = searchparser.SearchQueryParser()
        result = None
        while self._is_running:
            try:
                search = self._queue.get()
                if not search:
                    continue # continue while self._is_running

                is_text_output = ("text" == search.get("output"))
                wrap_html = None # MessageParser wrap function, for HTML output
                if is_text_output:
                    TEMPLATES = {
                        "chat":    templates.SEARCH_ROW_CHAT_TXT, 
                        "contact": templates.SEARCH_ROW_CONTACT_TXT,
                        "message": templates.SEARCH_ROW_MESSAGE_TXT,
                        "table":   templates.SEARCH_ROW_TABLE_HEADER_TXT,
                        "row":     templates.SEARCH_ROW_TABLE_TXT, }
                    wrap_b = lambda x: "**%s**" % x.group(0)
                    output = {"format": "text"}
                else:
                    TEMPLATES = {
                        "chat":    templates.SEARCH_ROW_CHAT_HTML, 
                        "contact": templates.SEARCH_ROW_CONTACT_HTML,
                        "message": templates.SEARCH_ROW_MESSAGE_HTML,
                        "table":   templates.SEARCH_ROW_TABLE_HEADER_HTML,
                        "row":     templates.SEARCH_ROW_TABLE_HTML, }
                    wrap_b = lambda x: "<b>%s</b>" % x.group(0)
                    output = {"format": "html"}
                    width = search.get("width", -1)
                    if width > 0:
                        dc = wx.MemoryDC()
                        dc.SetFont(wx.Font(8, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, 
                            wx.FONTWEIGHT_NORMAL, face=conf.HistoryFontName))
                        wrap_html = lambda x: wx.lib.wordwrap.wordwrap(x, width, dc)
                        output["wrap"] = True
                main.log("Searching for \"%(text)s\" in %(table)s (%(db)s)." %
                         search)
                self._stop_work = False
                self._drop_results = False

                parser = skypedata.MessageParser(search["db"],
                                                 wrapfunc=wrap_html)
                # {"output": text with results, "map": link data map}
                # map data: {"contact:666": {"contact": {contact data}}, }
                result_type, result_count, count = None, 0, 0
                result = {"output": "", "map": {},
                          "search": search, "count": 0}
                sql, params, match_words = query_parser.Parse(search["text"])

                # Turn wildcard characters * into regex-compatible .*
                match_words_re = [".*".join(map(re.escape, w.split("*")))
                                  for w in match_words]
                patt = "(%s)" % "|".join(match_words_re)
                # For replacing matching words with <b>words</b>
                pattern_replace = re.compile(patt, re.IGNORECASE)

                # Find chats with a matching title or matching participants
                chats = []
                if search["table"] in ["conversations", "messages"]:
                    chats = search["db"].get_conversations()
                    chats.sort(key=lambda x: x["title"])
                    chat_map = {} # {chat id: {chat data}}
                    template_chat = step.Template(TEMPLATES["chat"])
                for chat in chats:
                    chat_map[chat["id"]] = chat
                    if "conversations" == search["table"] and match_words:
                        title_matches = False
                        matching_authors = []
                        if self.match_all(chat["title"], match_words):
                            title_matches = True
                        for participant in chat["participants"]:
                            contact = participant["contact"]
                            if contact:
                                for n in filter(None, [contact["fullname"],
                                contact["displayname"], contact["identity"]]):
                                    if self.match_all(n, match_words) \
                                    and contact not in matching_authors:
                                        matching_authors.append(contact)

                        if title_matches or matching_authors:
                            count += 1
                            result_count += 1
                            result["output"] += template_chat.expand(locals())
                            key = "chat:%s" % chat["id"]
                            result["map"][key] = {"chat": chat["id"]}
                            if not count % conf.SearchResultsChunk \
                            and not self._drop_results:
                                result["count"] = result_count
                                self.postback(result)
                                result = {"output": "", "map": {},
                                          "search": search, "count": 0}
                    if self._stop_work:
                        break # break for chat in chats
                if result["output"] and not self._drop_results:
                    result["count"] = result_count
                    self.postback(result)
                    result = {"output": "", "map": {}, "search": search,
                              "count": 0}

                # Find contacts with a matching name
                if not self._stop_work and "contacts" == search["table"] \
                and match_words:
                    count = 0
                    contacts = search["db"].get_contacts()
                    # Possibly more: country (ISO code, need map), birthday
                    # (base has YYYYMMDD in integer field).
                    match_fields = [
                        "displayname", "skypename", "province", "city",
                        "pstnnumber", "phone_home", "phone_office",
                        "phone_mobile", "homepage", "emails", "about",
                        "mood_text",
                    ]
                    template_contact = step.Template(TEMPLATES["contact"])
                    for contact in contacts:
                        match = False
                        fields_filled = {}
                        for field in match_fields:
                            if contact[field]:
                                val = contact[field]
                                if self.match_all(val, match_words):
                                    match = True
                                    val = pattern_replace.sub(wrap_b, val)
                                fields_filled[field] = val
                        if match:
                            count += 1
                            result_count += 1
                            result["output"] += template_contact.expand(locals())
                            if not (self._drop_results
                            or count % conf.SearchResultsChunk):
                                result["count"] = result_count
                                self.postback(result)
                                result = {"output": "", "map": {},
                                          "search": search, "count": 0}
                        if self._stop_work:
                            break # break for contact in contacts
                if result["output"] and not self._drop_results:
                    result["count"] = result_count
                    self.postback(result)
                    result = {"output": "", "map": {},
                              "search": search, "count": 0}

                # Find messages with a matching body
                if not self._stop_work and "messages" == search["table"]:
                    template_message = step.Template(TEMPLATES["message"])
                    count, result_type = 0, "messages"
                    chat_messages = {} # {chat id: [message, ]}
                    chat_order = []    # [chat id, ]
                    messages = search["db"].get_messages(
                        additional_sql=sql, additional_params=params,
                        ascending=False, use_cache=False)
                    for m in messages:
                        chat = chat_map.get(m["convo_id"])
                        body = parser.parse(m, pattern_replace if match_words 
                                            else None, output)
                        count += 1
                        result_count += 1
                        result["output"] += template_message.expand(locals())
                        key = "message:%s" % m["id"]
                        result["map"][key] = {"chat": chat["id"],
                                              "message": m["id"]}
                        if is_text_output or (not self._drop_results
                        and not count % conf.SearchResultsChunk):
                            result["count"] = result_count
                            self.postback(result)
                            result = {"output": "", "map": {},
                                      "search": search, "count": 0}
                        if self._stop_work or (not is_text_output
                        and count >= conf.MaxSearchMessages):
                            break # break for m in messages

                infotext = search["table"]
                if not self._stop_work and "all tables" == search["table"]:
                    infotext, result_type = "", "table row"
                    # Search over all fields of all tables.
                    template_table = step.Template(TEMPLATES["table"])
                    template_row = step.Template(TEMPLATES["row"])
                    for table in search["db"].get_tables():
                        table["columns"] = search["db"].get_table_columns(
                            table["name"])
                        sql, params, words = \
                            query_parser.Parse(search["text"], table)
                        if not sql:
                            continue # continue for table in search["db"]..
                        infotext += (", " if infotext else "") + table["name"]
                        rows = search["db"].execute(sql, params)
                        row = rows.fetchone()
                        if not row:
                            continue # continue for table in search["db"]..
                        result["output"] = template_table.expand(locals())
                        count = 0
                        while row:
                            count += 1
                            result_count += 1
                            result["output"] += template_row.expand(locals())
                            key = "table:%s:%s" % (table["name"], count)
                            result["map"][key] = {"table": table["name"],
                                                  "row": row}
                            if not count % conf.SearchResultsChunk \
                            and not self._drop_results:
                                result["count"] = result_count
                                self.postback(result)
                                result = {"output": "", "map": {},
                                          "search": search, "count": 0}
                            if self._stop_work or (not is_text_output
                            and result_count >= conf.MaxSearchTableRows):
                                break # break while row
                            row = rows.fetchone()
                        if not self._drop_results:
                            if not is_text_output:
                                result["output"] += "</table>"
                            result["count"] = result_count
                            self.postback(result)
                            result = {"output": "", "map": {},
                                      "search": search, "count": 0}
                        infotext += " (%s)" % util.plural("result", count)
                        if self._stop_work or (not is_text_output
                        and result_count >= conf.MaxSearchTableRows):
                            break # break for table in search["db"]..
                    single_table = ("," not in infotext)
                    infotext = "table%s: %s" % \
                               ("" if single_table else "s", infotext)
                    if not single_table:
                        infotext += "; %s in total" % \
                                    util.plural("result", result_count)
                final_text = "No matches found."
                if self._drop_results:
                    result["output"] = ""
                if result_count:
                    final_text = "Finished searching %s." % infotext

                if self._stop_work:
                    final_text += " Stopped by user."
                elif "messages" == result_type and not is_text_output \
                and count >= conf.MaxSearchMessages:
                    final_text += " Stopped at %s limit %s." % \
                                  (result_type, conf.MaxSearchMessages)
                elif "table row" == result_type and not is_text_output \
                and count >= conf.MaxSearchTableRows:
                    final_text += " Stopped at %s limit %s." % \
                                  (result_type, conf.MaxSearchTableRows)

                result["output"] += "</table><br /><br />%s</font>" % final_text
                if is_text_output: result["output"] = ""
                result["done"] = True
                result["count"] = result_count
                self.postback(result)
                main.log("Search found %(count)s results." % result)
            except Exception as e:
                if not result:
                    result = {}
                result["done"], result["error"] = True, traceback.format_exc()
                result["error_short"] = "%s: %s" % (type(e).__name__, e.message)
                self.postback(result)



class MergeThread(WorkerThread):
    """
    Merge background thread, compares conversations in two databases, yielding
    results back to main thread in chunks, or merges compared differences.
    """

    # Difftext to compare will be assembled from other fields for these types.
    MESSAGE_TYPES_IGNORE_BODY = [
        skypedata.MESSAGES_TYPE_GROUP, skypedata.MESSAGES_TYPE_PARTICIPANTS,
        skypedata.MESSAGES_TYPE_REMOVE, skypedata.MESSAGES_TYPE_LEAVE,
        skypedata.MESSAGES_TYPE_SHARE_DETAIL
    ]
    # Number of iterations between allowing a UI refresh
    REFRESH_COUNT = 20000


    def run(self):
        self._is_running = True
        while self._is_running:
            params = self._queue.get()
            self._stop_work = False
            self._drop_results = False
            if params and "diff_left" == params.get("type"):
                self.work_diff_left(params)
            elif params and "diff_merge_left" == params.get("type"):
                self.work_diff_merge_left(params)
            elif params and "merge_left" == params.get("type"):
                self.work_merge_left(params)


    def work_diff_left(self, params):
        """
        Worker branch that compares all chats on the left side for differences,
        posting results back to application.
        """
        # {"output": "html result for db1, db2",
        #  "index": currently processed chat index,
        #  "chats": [differing chats in db1]}
        result = {"output": "", "chats": [],
                  "params": params, "index": 0, "type": "diff_left"}
        db1, db2 = params["db1"], params["db2"]
        chats1 = params.get("chats") or db1.get_conversations()
        chats2 = db2.get_conversations()
        c1map = dict((c["identity"], c) for c in chats1)
        c2map = dict((c["identity"], c) for c in chats2)
        compared = []
        for c1 in chats1:
            c2 = c2map.get(c1["identity"])
            c = c1.copy()
            c["messages1"] = c1["message_count"] or 0
            c["messages2"] = c2["message_count"] or 0 if c2 else 0
            c["c1"], c["c2"] = c1, c2
            compared.append(c)
        compared.sort(key=lambda x: x["title"].lower())
        info_template = step.Template(templates.DIFF_RESULT_ITEM)

        for index, chat in enumerate(compared):
            diff = self.get_chat_diff_left(chat, db1, db2)
            if self._stop_work:
                break # break for index, chat in enumerate(compared)
            if diff["messages"] \
            or (chat["message_count"] and diff["participants"]):
                new_chat = not chat["c2"]
                newstr = "" if new_chat else "new "
                info = info_template.expand(chat=chat)
                if new_chat:
                    info += " - new chat"
                if diff["messages"]:
                   info += ", %s" % util.plural("%smessage" % newstr,
                                                diff["messages"])
                else:
                    info += ", no messages"
                if diff["participants"] and not new_chat:
                        info += ", %s" % (
                            util.plural("%sparticipant" % newstr,
                                        diff["participants"]))
                info += ".<br />"
                result["output"] += info
                result["chats"].append({"chat": chat, "diff": diff})
            result["index"] = index
            if not self._drop_results:
                if index < len(compared) - 1:
                    result["status"] = ("Scanning %s." % 
                                        compared[index + 1]["title_long_lc"])
                self.postback(result)
                result = {"output": "", "chats": [], "index": index,
                          "params": params, "type": "diff_left"}
        if not self._drop_results:
            result["done"] = True
            self.postback(result)



    def work_diff_merge_left(self, params):
        """
        Worker branch that compares all chats on the left side for differences,
        copies them over to the right, posting progress back to application.
        """
        result = {"output": "", "index": 0, "params": params, "chats": [],
                  "count": 0, "type": "diff_merge_left", }
        error, e = None, None
        compared = []
        db1, db2 = params["db1"], params["db2"]
        try:
            chats1 = params.get("chats") or db1.get_conversations()
            chats2 = db2.get_conversations()
            c1map = dict((c["identity"], c) for c in chats1)
            c2map = dict((c["identity"], c) for c in chats2)
            for c1 in chats1:
                c2 = c2map.get(c1["identity"])
                c = c1.copy()
                c["messages1"] = c1["message_count"] or 0
                c["messages2"] = c2["message_count"] or 0 if c2 else 0
                c["c1"], c["c2"] = c1, c2
                compared.append(c)
            compared.sort(key=lambda x: x["title"].lower())
            result["count"] = len(compared)
            count_messages = 0
            count_participants = 0
            for index, chat in enumerate(compared):
                diff = self.get_chat_diff_left(chat, db1, db2)
                if self._stop_work:
                    break # break for index, chat in enumerate(compared)
                if diff["messages"] \
                or (chat["message_count"] and diff["participants"]):
                    chat1 = chat["c1"]
                    chat2 = chat["c2"]
                    new_chat = not chat2
                    if new_chat:
                        chat2 = chat1.copy()
                        chat["c2"] = chat2
                        chat2["id"] = db2.insert_chat(chat2, db1)
                    if diff["participants"]:
                        db2.insert_participants(chat2, diff["participants"],
                                                db1)
                        count_participants += len(diff["participants"])
                    if diff["messages"]:
                        db2.insert_messages(chat2, diff["messages"], db1, chat1,
                                            self.yield_ui, self.REFRESH_COUNT)
                        count_messages += len(diff["messages"])

                    newstr = "" if new_chat else "new "
                    info = "Merged %s" % chat["title_long_lc"]
                    if new_chat:
                        info += " - new chat"
                    if diff["messages"]:
                        info += ", %s" % util.plural("%smessage" % newstr,
                                                     diff["messages"])
                    else:
                        info += ", no messages"
                    result["output"] = info + "."
                    result["diff"] = diff
                result["index"] = index
                result["chats"].append(chat)
                if not self._drop_results:
                    if index < len(compared) - 1:
                        result["status"] = ("Scanning %s." % 
                                            compared[index+1]["title_long_lc"])
                    self.postback(result)
                    result = {"output": "", "index": index, "params": params,
                              "count": len(compared), "type": "diff_merge_left",
                              "chats": [], }
        except Exception as e:
            error = traceback.format_exc()
        finally:
            if not self._drop_results:
                if compared:
                    info = "Merged %s" % util.plural("new message",
                                                     count_messages)
                    if count_participants:
                        info += " and %s" % util.plural("new participant",
                                                        count_participants)
                    info += " \n\nto %s." % db2
                else:
                    info = "Nothing new to merge from %s to %s." % (db1, db2)
                result = {"type": "diff_merge_left", "done": True,
                          "output": info, "params": params, "chats": [] }
                if error:
                    result["error"] = error
                    if e:
                        result["error_short"] = "%s: %s" % (
                                                type(e).__name__, e.message)
                self.postback(result)


    def work_merge_left(self, params):
        """
        Worker branch that merges differences given in params, posting progress
        back to application.
        """
        error, e = None, None
        db1, db2 = params["db1"], params["db2"]
        chats = params["chats"]
        chats1_count = len(db1.get_conversations())
        count_messages = 0
        count_participants = 0
        try:
            for index, chat_data in enumerate(chats):
                if self._stop_work:
                    break # break for i, chat_data in enumerate(chats)
                chat1 = chat_data["chat"]["c1"]
                chat2 = chat_data["chat"]["c2"]
                messages = chat_data["diff"]["messages"]
                participants = chat_data["diff"]["participants"]
                html = "Merged %s" % chat1["title_long_lc"]
                if not chat2:
                    html += " - new chat"
                if messages:
                    newstr = "" if not chat2 else "new "
                    html += ", %s" % util.plural("%smessage" % newstr, messages)
                else:
                    html += ", no messages"
                html += "."
                if not chat2:
                    chat2 = chat1.copy()
                    chat_data["chat"]["c2"] = chat2
                    chat2["id"] = db2.insert_chat(chat2, db1)
                if participants:
                    db2.insert_participants(chat2, participants, db1)
                    count_participants += len(participants)
                if messages:
                    db2.insert_messages(chat2, messages, db1, chat1,
                                        self.yield_ui, self.REFRESH_COUNT)
                    count_messages += len(messages)
                if not self._drop_results:
                    result = {"type": "merge_left", "index": index,
                              "output": html, "count": chats1_count,
                              "params": params, "chats": [chat_data["chat"]] }
                    if index < len(chats) - 1:
                        result["status"] = ("Merging %s."
                            % chats[index + 1]["chat"]["title_long_lc"])
                    self.postback(result)
        except Exception as e:
            error = traceback.format_exc()
        finally:
            if chats:
                html = "Merged %s" % util.plural("new message",
                                                 count_messages)
                if count_participants:
                    html += " and %s" % util.plural("new participant",
                                                    count_participants)
                html += " \n\nto %s." % db2
            if not self._drop_results:
                result = {"type": "merge_left", "done": True, "output": html,
                          "params": params}
                if error:
                    result["error"] = error
                    if e:
                        result["error_short"] = "%s: %s" % (
                                                type(e).__name__, e.message)
                self.postback(result)


    def get_chat_diff(self, chat, db1, db2):
        """
        Compares the chat in the two databases and returns the differences as
          {"messages": [[IDs of messages different in db1], [..db2]],
           "participants": [[participants different in db1], [..db2]]}.
        """
        c = chat
        messages1 = db1.get_messages(c["c1"], use_cache=False) \
                    if c["c1"] else []
        messages2 = db2.get_messages(c["c2"], use_cache=False) \
                    if c["c2"] else []
        c1m_diff = [] # Messages different in chat 1
        c2m_diff = [] # Messages different in chat 2
        participants1 = c["c1"]["participants"] if c["c1"] else []
        participants2 = c["c2"]["participants"] if c["c2"] else []
        c1p_diff = [] # Participants different in chat 1
        c2p_diff = [] # Participants different in chat 2
        c1p_map = dict((p["identity"], p) for p in participants1)
        c2p_map = dict((p["identity"], p) for p in participants2)

        m1map = {} # {remote_id: [(id, datetime), ], }
        m2map = {} # {remote_id: [(id, datetime), ], }
        m1_no_remote_ids = [] # [(id, datetime), ] with a NULL remote_id
        m2_no_remote_ids = [] # [(id, datetime), ] with a NULL remote_id
        m1bodymap = {} # {author+type+body: [(id, datetime), ], }
        m2bodymap = {} # {author+type+body: [(id, datetime), ], }
        difftexts = {} # {(id, datetime): text, }

        # Skip comparing messages if one side is completely empty
        parser1, parser2 = None, None
        if not messages1:
            c2m_diff = [(m["id"], m.get("datetime")) for m in messages2]
            messages1, messages2 = [], []
        elif not messages2:
            c1m_diff = [(m["id"], m.get("datetime")) for m in messages1]
            messages1, messages2 = [], []
        else:
            parser1 = skypedata.MessageParser(db1)
            parser2 = skypedata.MessageParser(db2)

        # Assemble maps by remote_id and create diff texts. remote_id is
        # not unique and can easily have duplicates.
        things = [(messages1, m1map, m1_no_remote_ids, m1bodymap, parser1),
                  (messages2, m2map, m2_no_remote_ids, m2bodymap, parser2)]
        for messages, idmap, noidmap, bodymap, parser in things:
            for i, m in enumerate(messages):
                # Avoid keeping whole messages in memory, can easily run out.
                m_cache = (m["id"], m.get("datetime"))
                if m["remote_id"]:
                    if m["remote_id"] not in idmap:
                        idmap[m["remote_id"]] = []
                    idmap[m["remote_id"]].append(m_cache)
                else:
                    noidmap.append(m_cache)
                # In these messages, parsed body can differ even though
                # message is the same: contact names are taken from current
                # database values. Using raw values instead.
                if m["type"] in self.MESSAGE_TYPES_IGNORE_BODY:
                    t = m["identities"]
                    if skypedata.MESSAGES_TYPE_LEAVE == m["type"]:
                        t = m["author"]
                else:
                    t = parser.parse(m, output={"format": "text"})
                t = t if isinstance(t, str) else t.encode("utf-8")
                author = (m["author"] or "").encode("utf-8")
                difftext = "%s-%s-%s" % (author, m["type"], t)
                difftexts[m_cache]  = difftext
                if difftext not in bodymap: bodymap[difftext] = []
                bodymap[difftext].append(m_cache)
                if i and not i % self.REFRESH_COUNT:
                    self.yield_ui()

        # Compare assembled remote_id maps between databases and see if there
        # are no messages with matching body in the other database.
        remote_id_maps = [(m1map, m2map, c1m_diff), (m2map, m1map, c2m_diff)]
        for map1, map2, output in remote_id_maps:
            remote_id_messages = [(r, j) for r, i in map1.items() for j in i]
            for i, (remote_id, m) in enumerate(remote_id_messages):
                if remote_id in map2:
                    is_match = lambda x: difftexts[m] == difftexts[x]
                    if not any(filter(is_match, map2[remote_id])):
                        output.append(m) # Nothing with same remote_id and body
                else:
                    output.append(m)
                if i and not i % self.REFRESH_COUNT:
                    self.yield_ui()
            

        # For messages with no remote_id-s, compare by author-type-body key
        # and see if there are no matching messages sufficiently close in time.
        no_remote_ids =  [(m1_no_remote_ids, c1m_diff, m2bodymap),
                          (m2_no_remote_ids, c2m_diff, m1bodymap)]
        for m_no_remote_ids, output, mbodymap in no_remote_ids:
            for i, m in enumerate(m_no_remote_ids):
                potential_matches = mbodymap.get(difftexts[m], [])
                if not [m2 for m2 in potential_matches
                        if self.match_time(m[1], m2[1], 180)]:
                    output.append(m)
                if i and not i % self.REFRESH_COUNT:
                    self.yield_ui()
        for p in participants1:
            if p["identity"] not in c2p_map:
                c1p_diff.append(p)
        for p in participants2:
            if p["identity"] not in c1p_map:
                c2p_diff.append(p)

        c1m_diff.sort(lambda a, b: cmp(a[1], b[1]))
        c2m_diff.sort(lambda a, b: cmp(a[1], b[1]))
        message_ids1 = [m[0] for m in c1m_diff]
        message_ids2 = [m[0] for m in c2m_diff]

        result = { "messages": [message_ids1, message_ids2],
                   "participants": [c1p_diff, c2p_diff] }
        return result


    def get_chat_diff_left(self, chat, db1, db2):
        """
        Compares the chat in the two databases and returns the differences from
        the left as {"messages": [message IDs different in db1],
                     "participants": [participants different in db1] }.
        """
        c = chat
        participants1 = c["c1"]["participants"] if c["c1"] else []
        participants2 = c["c2"]["participants"] if c["c2"] else []
        c2p_map = dict((p["identity"], p) for p in participants2)
        c1p_diff = [p for p in participants1 if p["identity"] not in c2p_map]
        c1m_diff = [] # [(id, datetime), ] messages different in chat 1

        if not c["messages1"]:
            messages1, messages2 = [], [] # Left side empty, skip all messages
        elif not c["messages2"]:
            messages1, messages2 = [], [] # Right side empty, take whole left
            messages_all = db1.get_messages(c["c1"], use_cache=False)
            c1m_diff = [(m["id"], m["datetime"]) for m in messages_all]
        else:
            messages1 = db1.get_messages(c["c1"], use_cache=False)
            messages2 = db2.get_messages(c["c2"], use_cache=False)
            parser1 = skypedata.MessageParser(db1)
            parser2 = skypedata.MessageParser(db2)

            m1map = {} # {remote_id: [(id, datetime), ], }
            m2map = {} # {remote_id: [(id, datetime), ], }
            m1_no_remote_ids = [] # [(id, datetime), ] with a NULL remote_id
            m2_no_remote_ids = [] # [(id, datetime), ] with a NULL remote_id
            m1bodymap = {} # {author+type+body: [(id, datetime), ], }
            m2bodymap = {} # {author+type+body: [(id, datetime), ], }
            difftexts = {} # {(id, datetime): text, }

            # Assemble maps by remote_id and create diff texts. remote_id is
            # not unique and can easily have duplicates.
            things = [(messages1, m1map, m1_no_remote_ids, m1bodymap, parser1),
                      (messages2, m2map, m2_no_remote_ids, m2bodymap, parser2)]
            for messages, idmap, noidmap, bodymap, parser in things:
                for i, m in enumerate(messages):
                    # Avoid keeping whole messages in memory, can run out.
                    m_cache = (m["id"], m.get("datetime"))
                    if m["remote_id"]:
                        if m["remote_id"] not in idmap:
                            idmap[m["remote_id"]] = []
                        idmap[m["remote_id"]].append(m_cache)
                    else:
                        noidmap.append(m_cache)
                    # In these messages, parsed body can differ even though
                    # message is the same: contact names are taken from current
                    # database values. Using raw values instead.
                    if m["type"] in self.MESSAGE_TYPES_IGNORE_BODY:
                        t = m["identities"]
                        if skypedata.MESSAGES_TYPE_LEAVE == m["type"]:
                            t = m["author"]
                    else:
                        t = parser.parse(m, output={"format": "text"})
                    t = t if isinstance(t, str) else t.encode("utf-8")
                    author = (m["author"] or "").encode("utf-8")
                    difftext = "%s-%s-%s" % (author, m["type"], t)
                    difftexts[m_cache]  = difftext
                    if difftext not in bodymap: bodymap[difftext] = []
                    bodymap[difftext].append(m_cache)
                    if i and not i % self.REFRESH_COUNT:
                        self.yield_ui()

            # Compare assembled remote_id maps between databases and see if
            # there are no messages with matching body in the other database.
            remote_id_messages = [(r, j) for r, i in m1map.items() for j in i]
            for i, (remote_id, m) in enumerate(remote_id_messages):
                if remote_id in m2map:
                    is_match = lambda x: (difftexts[m] == difftexts[x])
                    if not any(filter(is_match, m2map[remote_id])):
                        c1m_diff.append(m) # Nothing with same remote_id+body
                else:
                    c1m_diff.append(m)
                if i and not i % self.REFRESH_COUNT:
                    self.yield_ui()

            # For messages with no remote_id-s, compare by author-type-body key
            # and see if there are no matching messages close in time.
            for i, m in enumerate(m1_no_remote_ids):
                potential_matches = m2bodymap.get(difftexts[m], [])
                if not [m2 for m2 in potential_matches
                        if self.match_time(m[1], m2[1], 180)]:
                    c1m_diff.append(m)
                if i and not i % self.REFRESH_COUNT:
                    self.yield_ui()

        message_ids1 = [m[0] for m in sorted(c1m_diff, key=lambda x: x[1])]
        result = { "messages": message_ids1, "participants": c1p_diff }
        return result


    def match_time(self, d1, d2, leeway_seconds=0):
        """Whether datetimes might be same but from different timezones."""
        result = False
        d1, d2 = (d1, d2) if d1 and d2 and (d1 < d2) else (d2, d1)
        delta = d2 - d1 if d1 and d2 else datetime.timedelta()
        if util.timedelta_seconds(delta) > 24 * 3600:
            delta = datetime.timedelta() # Skip if not even within same day
        for hour in range(int(util.timedelta_seconds(delta) / 3600) + 1):
            d1plus = d1 + datetime.timedelta(hours=hour)
            result = util.timedelta_seconds(d2 - d1plus) < leeway_seconds
            if result:
                break # break for hour in range(..
        return result



class ContactSearchThread(WorkerThread):
    """
    Contact search background thread, uses a running Skype application to
    search Skype userbase for contacts, yielding results back to main thread
    in chunks.
    """

    def run(self):
        self._is_running = True
        while self._is_running:
            search = self._queue.get()
            self._stop_work = False
            self._drop_results = False
            found = {} # { Skype handle: 1, }
            result = {"search": search, "results": []}
            if search and search["handler"]:
                for i, value in enumerate(search["values"]):
                    main.log("Searching Skype contact directory for '%s'.",
                             value)

                    try:
                        for user in search["handler"].search_users(value):
                            if user.Handle not in found:
                                result["results"].append(user)
                                found[user.Handle] = 1

                            if not (self._drop_results 
                            or len(result["results"]) % conf.SearchContactsChunk):
                                self.postback(result)
                                result = {"search": search, "results": []}

                            if self._stop_work:
                                break # break for user in search["handler"].searc..
                    except Exception as e:
                        main.log("Error searching Skype contacts:\n\n%s",
                                 traceback.format_exc())

                    if result["results"] and not self._drop_results:
                        self.postback(result)
                        result = {"search": search, "results": []}

                    if self._stop_work:
                        break # break for i, value in enumerate(search_values)

                if not self._drop_results:
                    result["done"] = True
                    self.postback(result)



class DetectDatabaseThread(WorkerThread):
    """
    Skype database detection background thread, goes through potential
    directories and yields database filenames back to main thread one by one.
    """

    def run(self):
        self._is_running = True
        while self._is_running:
            search = self._queue.get()
            self._stop_work = self._drop_results = False
            if search:
                all_filenames = set() # To handle potential duplicates
                for filenames in skypedata.detect_databases():
                    filenames = all_filenames.symmetric_difference(filenames)
                    if not self._drop_results:
                        result = {"filenames": filenames}
                        self.postback(result)
                    all_filenames.update(filenames)
                    if self._stop_work:
                        break # break for filename in skypedata.detect_data...

                result = {"done": True, "count": len(all_filenames)}
                self.postback(result)

########NEW FILE########
__FILENAME__ = wx_accel
# -*- coding: utf-8 -*-
"""
Functionality for binding wx control label shortcut keys to events
automatically. In wx, a button with a label "E&xit" would be displayed as
having the label "Exit" with "x" underlined, indicating a keyboard shortcut,
but wx does not bind these shortcuts automatically, requiring constructing
the acceleration table piecemeal.

Supported controls:
- wx.Button       click handler called
- wx.CheckBox     value is reversed, control focused, change handler called
- wx.TextCtrl     control focused, all text selected
- wx.RadioButton  control focused, value selected
- wx.Control      control focused
- wx.ToolBar      tool event is called, if the tool shorthelp includes a
                  parseable shortcut key like (Alt-S)
- wx.ToggleButton ToggleButton handler called

Uses primitive heuristic analysis to detect connected label-control pairs:
- wx.StaticTexts whose next sibling is a focusable control
- wx.StaticTexts that have an Id one less from a focusable control (created
  immediately before creating the control)
- wx.StaticTexts that have the same Name as a control with "label" appended or
  prepended,
  e.g. "iptext" and "iptext_label"|"iptext.label"|"iptext label"|"labeliptext"

------------------------------------------------------------------------------
This file is part of Skyperious - a Skype database viewer and merger.
Released under the MIT License.

@author      Erki Suurjaak
@created     19.11.2011
@modified    19.02.2014
------------------------------------------------------------------------------
"""
import functools
import re
import wx

DEBUG = False


class AutoAcceleratorMixIn(object):
    """
    A windowed control that assigns global keyboard shortcuts to all its
    controls that have a shortcut key defined in their label (e.g. a button'
    labeled "E&xit" gets assigned the shortcut Alt-X).
    Accelerator table is autocreated on first showing; if changing controls
    afterwards, call UpdateAccelerators().

    @param   use_heuristics  whether to use heuristic analysis to detect
                             connected label-control pairs
    """
    def __init__(self, use_heuristics=True):
        """
        @param   use_heuristics  whether to use heuristic analysis to detect
                                 connected label-control pairs
        """
        self.__use_heuristics = use_heuristics
        self.__shortcuts = None # {shortcut char: target control, }


    def Show(self, *args, **kwargs):
        """
        Initializes the shortcut keys from child controls, if not already
        created, and calls parent.Show.
        """
        if not hasattr(self, "__shortcuts"):
            self.__shortcuts = None # {shortcut char: target control, }
        if self.__shortcuts is None:
            self.UpdateAccelerators()
        super(AutoAcceleratorMixIn, self).Show(*args, **kwargs)


    def UpdateAccelerators(self, use_heuristics=True):
        """
        Rebuilds the control shortcut keys in this frame.

        @param   use_heuristics  whether to use heuristic analysis to detect
                                 connected label-control pairs (sticky)
        """
        if not hasattr(self, "__shortcuts"):
            self.__shortcuts = None # {shortcut char: target control, }
        self.__use_heuristics = use_heuristics
        self.__shortcuts = accelerate(self, self.__use_heuristics)



def collect_shortcuts(control, use_heuristics=True):
    """
    Returns a map of detected shortcut keys and target controls under the
    specified control.

    @param   control         the control to start from
    @param   use_heuristics  whether to use heuristic analysis to detect
                             connected label-control pairs
    @return                  a map of detected shortcut chars and a list of
                             their target controls (there can be several
                             controls with one shortcut, e.g. controls on
                             different pages of a Notebook)
    """

    result  = {} # {char: control, }
    nameds  = {} # collected controls with Name {name: control, }
    statics = {} # collected StaticTexts with a shortcut {control: char, }

    def parse_shortcuts(ctrl):
        """
        Parses the shortcut keys from the control label, if any.

        @return    [keys]
        """
        result = []
        # wx.TextCtrl.Label is the same as its value, so must not use that
        if isinstance(ctrl, wx.ToolBar):
            toolsmap = dict()
            for i in range(ctrl.GetToolsCount() + 1):
                # wx 2.8 has no functionality for getting tools by index, so
                # need to gather them by layout position
                tool = ctrl.FindToolForPosition(i * ctrl.ToolSize[0], 0)
                toolsmap[repr(tool)] = tool
            for tool in filter(None, toolsmap.values()):
                text = ctrl.GetToolShortHelp(tool.GetId())
                parts = re.split("\(Alt-(.)\)", text, maxsplit=1)
                if len(parts) > 1:
                    result.append(parts[1].lower())
        elif hasattr(ctrl, "Label") and not isinstance(ctrl, wx.TextCtrl):
            for part in filter(len, ctrl.Label.split("&")[1:]):
                # Labels have potentially multiple ampersands - find one that
                # is usable (preceding a valid character. 32 and lower are
                # spaces, punctuation, control characters, etc).
                key = part[0].lower()
                if ord(key) > 32:
                    result.append(key)
                    if (DEBUG) and key:
                        print("Parsed '%s' in label '%s'." % (key, ctrl.Label))
                    break # break for part in filter
        return result


    def collect_recurse(ctrl, result, nameds, statics):
        """
        Goes through the control and all its children and collects accelerated
        controls.

        @return    {key: control, }
        """
        if hasattr(ctrl, "GetChildren"):
            children = ctrl.GetChildren()
            for i in range(len(children)):
                collect_recurse(children[i], result, nameds, statics)

        keys = parse_shortcuts(ctrl)
        for key in keys:
            if isinstance(ctrl, wx.StaticText):
                statics[ctrl] = key
            else:
                if key not in result:
                    result[key] = []
                if ctrl not in result[key]:
                    result[key].append(ctrl)
                    if (DEBUG): print("Selected '%s' for '%s' (%s.Id=%s)." %
                                      (key, ctrl.Label, ctrl.ClassName,
                                       ctrl.GetId()))
        if ctrl.Name:
            if DEBUG: print("Found named control %s %s." % (ctrl.Name, ctrl))
            nameds[ctrl.Name] = ctrl


    collect_recurse(control, result, nameds, statics)
    result_values = [j for i in result.values() for j in i]
    if use_heuristics:
        for ctrl, key in statics.items():
            # For wx.StaticTexts, see if the next sibling, or control with the
            # next ID, or control sitting next in the sizer  is focusable -
            # shortcut will set focus to the control.
            chosen = None
            next_sibling = hasattr(ctrl, "GetNextSibling") \
                           and ctrl.GetNextSibling()
            # Do not include buttons, as buttons have their own shortcut keys.
            if next_sibling and not isinstance(next_sibling, wx.Button) \
            and (not next_sibling.Enabled or next_sibling.AcceptsFocus()
            or getattr(next_sibling, "CanAcceptFocus", lambda: False)()):
                chosen = next_sibling
                if (DEBUG):
                    print("Selected '%s' by previous sibling wxStaticText "
                          "'%s' (%s.ID=%s)." %
                          (key, ctrl.Label, chosen.ClassName, chosen.Id))
            if not chosen:
                # Try to see if the item with the next ID is focusable.
                next_ctrl = wx.FindWindowById(ctrl.Id - 1)
                # Disabled controls might return False for AcceptsFocus).
                if next_ctrl and not isinstance(next_ctrl, wx.Button) \
                and (not next_ctrl.Enabled or next_ctrl.AcceptsFocus()
                or getattr(next_ctrl, "CanAcceptFocus", lambda: False)()):
                    chosen = next_ctrl
                    if (DEBUG):
                        print("Selected '%s' by previous ID wxStaticText "
                              "'%s' (%s.ID=%s)." %
                              (key, ctrl.Label, chosen.ClassName, chosen.Id))
            if not chosen and ctrl.ContainingSizer:
                # Try to see if the item next in the same sizer is focusable
                sizer_items = []
                while True:
                    try:
                        item = ctrl.ContainingSizer.GetItem(len(sizer_items))
                        sizer_items.append(item.Window)
                    except:
                        break # Reached item limit
                index = sizer_items.index(ctrl)
                if index < len(sizer_items) - 1:
                    next_ctrl = sizer_items[index + 1]
                    if (next_ctrl and not isinstance(next_ctrl, wx.Button)
                    and (not next_ctrl.Enabled or next_ctrl.AcceptsFocus()
                    or getattr(next_ctrl, "CanAcceptFocus", lambda: False)())):
                        chosen = next_ctrl
                        if (DEBUG):
                            print("Selected '%s' by previous in sizer "
                                  "wxStaticText '%s' (%s.ID=%s)." %
                                  (key, ctrl.Label, chosen.ClassName, chosen.Id))
            if chosen and chosen not in result_values:
                if key not in result:
                    result[key] = []
                result[key].append(chosen)
                result_values.append(chosen)

        for name, ctrl in nameds.items():
            # For named controls, see if there is another control with the same
            # name, but "label" appended or prepended.
            if (DEBUG): print("Going through named %s '%s'." % (ctrl, name))
            match_found = False
            label_regex = re.compile("(^label[_ \.]*%s$)|(^%s[_ \.]*label$)"
                                     % tuple([name] * 2), re.IGNORECASE)
            for potential_name, potential in nameds.items():
                if label_regex.match(potential_name):
                    keys = parse_shortcuts(potential)
                    for key in keys:
                        if (DEBUG):
                            print("Name %s matches potential %s, key=%s." % (
                                  name, potential_name, key))
                        if key and (ctrl not in result_values):
                            match_found = True
                            if key not in result:
                                result[key] = []
                            if ctrl not in result[key]:
                                result[key].append(ctrl)
                            result_values.append(ctrl)
                            if (DEBUG):
                                print("Selected '%s' by named StaticText "
                                      "'%s' (%s.ID=%s, %s.Name=%s, "
                                      "wxStaticText.Name=%s)." %
                                      (key, potential.Label, ctrl.ClassName,
                                       ctrl.ClassName, ctrl.Id, ctrl.Name,
                                       potential.Name))
                            break # break for key in keys
                    if match_found:
                        break # break for potential_name, potential in nameds
    return result



def accelerate(window, use_heuristics=True):
    """
    Assigns global keyboard shortcuts to all controls under the specified
    wx.Window that have a shortcut key defined in their label (e.g. a button
    labeled "E&xit" gets assigned the shortcut Alt-X). Resets previously
    set accelerators, if any.

    @param   control         the wx.Window instance to process, gets its
                             accelerator table reset
    @param   use_heuristics  whether to use heuristic analysis to detect
                             connected label-control pairs
    @return                  a map of detected shortcut chars and their target
                             controls
    """

    def shortcut_handler(targets, key, shortcut_event):
        """
        Shortcut event handler, calls the appropriate event on the target.

        @param   targets         list of target controls. If there is more than
                                 one target control, the first non-disabled
                                 and visible is chosen.
        @param   key             the event shortcut key, like 's'
        @param   shortcut_event  menu event generated by the accelerator table
        """
        if (DEBUG):
            print("Handling target %s" %
                  [(type(t), t.Id, t.Label) for t in targets])
        event = None
        for target in targets:
            if (isinstance(target, wx.Control) # has not been destroyed
            and target.IsShownOnScreen()       # visible on current panel
            and target.Enabled):
                if isinstance(target, wx.Button):
                    # Buttons do not get focus on shortcuts by convention
                    event = wx.CommandEvent(wx.EVT_BUTTON.typeId, target.Id)
                    event.SetEventObject(target)
                elif isinstance(target, wx.ToggleButton):
                    # Buttons do not get focus on shortcuts by convention
                    event = wx.CommandEvent(wx.EVT_TOGGLEBUTTON.typeId,
                                            target.Id)
                    event.SetEventObject(target)
                    # Need to change value, as event goes directly to handler
                    target.Value = not target.Value
                elif isinstance(target, wx.CheckBox):
                    event = wx.CommandEvent(wx.EVT_CHECKBOX.typeId, target.Id)
                    # Need to change value, as event goes directly to handler
                    target.Value = not target.Value
                    target.SetFocus()
                elif isinstance(target, wx.ToolBar):
                    # Toolbar shortcuts are defined in their shorthelp texts
                    toolsmap, tb = dict(), target
                    for i in range(tb.GetToolsCount() + 1):
                        tool = tb.FindToolForPosition(i * tb.ToolSize[0], 0)
                        toolsmap[repr(tool)] = tool
                    for tool in filter(None, toolsmap.values()):
                        id = tool.GetId()
                        text = tb.GetToolShortHelp(id)
                        parts = re.split("\(Alt-(%s)\)" % key, text,
                                         maxsplit=1, flags=re.IGNORECASE)
                        if len(parts) > 1:
                            event = wx.CommandEvent(wx.EVT_TOOL.typeId, id)
                            event.SetEventObject(target)
                            target.ToggleTool(id, not target.GetToolState(id))
                            break # break for i in range(target.GetToolsCount)
                else:
                    target.SetFocus()
                    if isinstance(target, wx.TextCtrl):
                        target.SelectAll()
                break # break for target in targets
        if event:
            if (DEBUG): print("Chose target %s." % (target.Label or target))

            wx.PostEvent(target.GetEventHandler(), event)
        else:
            shortcut_event.Skip(True) # Not handled by us: propagate

    if hasattr(window, "__ampersand_shortcut_menu"):
        # Remove previously created menu, if any
        for menu_item in window.__ampersand_shortcut_menu.MenuItems:
            if (DEBUG): print("Removing dummy menu item '%s'" % menu_item.Label)
            window.Unbind(wx.EVT_MENU, menu_item)
        del window.__ampersand_shortcut_menu
    shortcuts = collect_shortcuts(window, use_heuristics)
    if shortcuts:
        accelerators = []
        dummy_menu = wx.Menu()
        for key, targets in shortcuts.items():
            event_id = wx.NewId()
            if (DEBUG): print("Binding %s to targets %s." %
                              (key, [type(t) for t in targets]))
            menu_item = dummy_menu.Append(id=event_id, text="&%s" % key)
            window.Bind(wx.EVT_MENU,
                        functools.partial(shortcut_handler, targets, key),
                        menu_item)
            accelerators.append((wx.ACCEL_ALT, ord(key), event_id))
        window.SetAcceleratorTable(wx.AcceleratorTable(accelerators))
        window.__ampersand_shortcut_menu = dummy_menu
    return shortcuts

########NEW FILE########
