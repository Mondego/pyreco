__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# provy documentation build configuration file, created by
# sphinx-quickstart on Sun Jan 20 04:54:01 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
provy_dir = os.path.abspath('../../')
#this_dir = os.path.abspath(os.path.dirname(__file__))
#sys.path.insert(0, this_dir)
sys.path.insert(0, provy_dir)


import provy


# Workaround to avoid M2Crypto loading when generating the docs
os.environ['BYPASS_M2CRYPTO'] = '1'


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'provy'
copyright = u'2013, Bernardo Heynemann'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = provy.major_version
# The full version, including alpha/beta/rc tags.
release = provy.version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'provy'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'provydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'provy.tex', u'provy Documentation',
     u'Bernardo Heynemann', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'provy', u'provy Documentation',
     [u'Bernardo Heynemann'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'provy', u'provy Documentation',
     u'Bernardo Heynemann', 'provy', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = docs
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from os.path import exists, join, abspath, sep, splitext, dirname
from json import dumps

from provy.core import Role

import os
import fnmatch
import inspect


class RoleDoc(object):
    def __init__(self, role, name, module, docs):
        self.role = role
        self.name = name
        self.module = module
        self.fullname = "%s.%s" % (module, name)
        self.docs = docs
        self.methods = []
        self.parse_methods(role)

    def parse_methods(self, role):
        for name, member in inspect.getmembers(role):
            if not inspect.ismethod(member) or name.startswith('_'):
                continue
            if not member.__module__ == role.__module__:
                continue
            if not member.__doc__:
                print "Warning: Method %s of role %s does not have docstring." % (name, role.__name__)
            self.add_method(NameDoc(name, member.__doc__))

    def add_method(self, method_doc):
        self.methods.append(method_doc)

    def to_dict(self):
        obj = {
            '__name__': self.name,
            '__fullName__': self.fullname,
            '__module__': self.module,
            '__doc__': self.docs and self.docs.strip() or None,
            '__methods__': []
        }
        for method in self.methods:
            obj['__methods__'].append(method.to_dict())

        return obj


class NameDoc(object):
    def __init__(self, name, doc):
        self.name = name
        self.doc = doc

    def to_dict(self):
        return {
            '__name__': self.name,
            '__doc__': self.doc and self.doc.strip() or None
        }


def main():
    path = "/tmp/docs.json"
    source_path = join(os.curdir, 'provy', 'more')

    if not exists(dirname(path)):
        os.makedirs(dirname(path))

    root_namespace = 'provy.more'

    roles_to_document = {
        'Role': RoleDoc(Role, 'Role', 'provy.core.roles', Role.__doc__)
    }

    for root, dirs, files in os.walk(source_path):
        for file_name in files:
            if file_name == "__init__.py":
                continue
            if not fnmatch.fnmatch(file_name, '*.py'):
                continue

            module_path = '%s.%s.%s' % (root_namespace,
                                        get_namespace_for(root),
                                        splitext(file_name)[0])

            module = import_module(module_path)

            for name, member in inspect.getmembers(module):
                if not inspect.isclass(member) or not issubclass(member, Role):
                    continue
                if member.__module__ != module_path:
                    continue

                if not member.__doc__:
                    print "Warning: Role %s.%s does not have docstring." % (member.__module__, name)

                roles_to_document[module_path] = RoleDoc(member,
                                                         name,
                                                         member.__module__,
                                                         member.__doc__)

    tree = {}

    for full_name, role_doc in roles_to_document.iteritems():
        role = role_doc.role
        name = role_doc.name
        current = tree
        module = __import__(role.__module__)
        for part in role.__module__.split('.'):
            if hasattr(module, part):
                module = getattr(module, part)
            if not part in current:
                if not module.__doc__:
                    print "Warning: Module %s does not have docstring." % module.__name__

                current[part] = {
                    '__name__': module.__name__,
                    '__doc__': module.__doc__ and module.__doc__.strip() or None
                }
            if part == role.__module__.split('.')[-1]:
                current[part][role_doc.name] = role_doc.to_dict()
            current = current[part]

    contents = dumps(tree, sort_keys=True, separators=(',', ':'))
    with open(path, 'w') as f:
        f.write(contents)


def import_module(module_path):
    module = __import__(module_path)
    return reduce(getattr, module_path.split('.')[1:], module)


def get_namespace_for(directory):
    source_path = abspath(join(os.curdir, 'provy', 'more'))
    diff = abspath(directory).replace(source_path, '')
    namespace = '.'.join([module for module in diff.split(sep) if module])
    return namespace

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = console
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# provy provisioning
# https://github.com/python-provy/provy

# Licensed under the MIT license:
# http://www.opensource.org/licenses/mit-license
# Copyright (c) 2011 Bernardo Heynemann heynemann@gmail.com

import sys
import os
import re
from os.path import exists, abspath, splitext
from optparse import OptionParser

from provy.core import run
from provy.core.utils import provyfile_path_from


class Messages(object):
    role = """Role to provision the specified servers with. This is a recursive
    option"""
    server = """Servers to provision with the specified role. This is a
    recursive option."""
    password = """Password to use for authentication with servers.
    If passwords differ from server to server this does not work."""


def __get_extra_options():
    extra_options = {}
    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            match = re.match('(?P<key>.+?)=(?P<value>.+)', arg)
            if match:
                extra_options[match.groupdict()['key']] = match.groupdict()['value']
                sys.argv.remove(arg)

    return extra_options


def __get_arguments():
    parser = OptionParser()
    parser.add_option("-s", "--server", dest="server", help=Messages.server)
    parser.add_option("-p", "--password", dest="password", default=None,
                      help=Messages.password)

    (options, args) = parser.parse_args()

    return (options, args)


def __get_provy_file_path(provyfile_name):
    path = abspath(provyfile_name)
    if not exists(path):
        return None
    return splitext(path.replace(abspath('.'), '').lstrip('/').rstrip('/'))[0]


def main():
    sys.path.insert(0, os.curdir)

    extra_options = __get_extra_options()
    (options, args) = __get_arguments()

    provyfile_path = provyfile_path_from(args)

    if options.server is None and provyfile_path:
        # TODO: Improve this code to 'find' the set of servers defined in the
        # provyfile and run with the defined server set (if only one is defined)
        print "\nInfo: Provy is running using the 'test' set of servers.\n"
        options.server = 'test'

    run(provyfile_path, options.server, options.password, extra_options)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = errors
#!/usr/bin/python
# -*- coding: utf-8 -*-


class ConfigurationError(RuntimeError):
    '''Raised when there's a configuration error in the provyfile.'''

########NEW FILE########
__FILENAME__ = roles
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Module responsible for the base Role and its operations.
'''
import re
import codecs
from contextlib import contextmanager
import os
from os.path import exists, split, dirname, isabs
from datetime import datetime
from tempfile import gettempdir, NamedTemporaryFile

import fabric.api
from jinja2 import Environment, PackageLoader, FileSystemLoader
import uuid
from StringIO import StringIO


class UsingRole(object):
    '''
    This is the contextmanager that allows using :class:`Roles <Role>` in other :class:`Roles <Role>`, in a nested manner.

    Don't use this directly; Instead, use the base :class:`Role`'s :meth:`using <Role.using>` method.
    '''
    def __init__(self, role, prov, context):
        self.role = role
        self.prov = prov
        self.context = context

    def __enter__(self):
        if self.role in self.context['used_roles']:
            self.role_instance = self.context['used_roles'][self.role]
        else:
            self.role_instance = self.role(self.prov, self.context)
            self.context['used_roles'][self.role] = self.role_instance
        self.role_instance.provision()
        self.context['roles_in_context'][self.role] = self.role_instance
        return self.role_instance

    def __exit__(self, exc_type, exc_value, traceback):
        role = self.role(self.prov, self.context)
        if self.role in self.context['roles_in_context']:
            del self.context['roles_in_context'][self.role]
        role.schedule_cleanup()


class Role(object):
    '''
    Base Role class. This is the class that is inherited by all provy's roles.

    This class provides many utility methods for interacting with the remote server.

    Example:
    ::

        from provy.core import Role

        class MySampleRole(Role):
            def provision(self):
                self.register_template_loader('my.full.namespace')
                self.execute('ls /home/myuser', sudo=False, stdout=False)
    '''
    def __init__(self, prov, context):
        if 'used_roles' not in context:
            context['used_roles'] = {}
        if 'roles_in_context' not in context:
            context['roles_in_context'] = {}
        self._paths_to_remove = set()
        self.prov = prov
        self.context = context
        self.__distro_info = None

    def register_template_loader(self, package_name):
        '''
        Register the ``package_name`` module as a valid source for templates in `Jinja2 <http://jinja.pocoo.org/>`_.

        `Jinja2 <http://jinja.pocoo.org/>`_ will look inside a folder called *templates* in the specified module.

        It is paramount that this module can be imported by python. The path must be well-known or be a sub-path of the provyfile.py directory.

        :param package_name: Full name of the module that `Jinja2 <http://jinja.pocoo.org/>`_ will try to import.
        :type package_name: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.register_template_loader('my.full.namespace')
        '''
        if package_name not in self.context['registered_loaders']:
            self.context['loader'].loaders.append(PackageLoader(package_name))
            self.context['registered_loaders'].append(package_name)

    def log(self, msg):
        '''
        Logs a message to the console with the hour prepended.

        :param msg: Message to log.
        :type msg: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.log('Hello World')
        '''
        print '[%s] %s' % (datetime.now().strftime('%H:%M:%S'), msg)

    @property
    def roles_in_context(self):
        return self.context.get("roles_in_context", tuple([]))

    def schedule_cleanup(self):
        '''
        Makes sure that this role will be cleaned up properly after the server has been provisioned. Call this method in your provision method if you need your role's cleanup method to be called.

        .. note:: If you are using the proper ways of calling roles (:meth:`provision_role`, :meth:`using`) in your role, you do not need to call this method.

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.schedule_cleanup()
        '''
        has_role = False
        for role in self.context['cleanup']:
            if role.__class__ == self.__class__:
                has_role = True

        if not has_role:
            self.context['cleanup'].append(self)

    def provision_role(self, role):
        '''
        Provisions a role inside your role. This method is the way to call other roles if you don't need to call any methods other than provision.

        ``provision_role`` keeps the context and lifecycle for the current server when calling the role and makes sure it is disposed correctly.

        .. note:: There's no need to call this method, if you're using the :meth:`using` as a context manager.

        :param role: The role to be provisioned.
        :type role: :class:`Role`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(SomeOtherRole)
        '''
        instance = role(self.prov, self.context)
        instance.provision()
        instance.schedule_cleanup()

    def provision(self):
        '''
        Base provision method. This is meant to be overriden and does not do anything.

        The ``provision`` method of each ``Role`` is what provy calls on to provision servers.

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    pass
        '''
        pass

    def cleanup(self):
        '''
        Base cleanup method. This is meant to be overriden and does not do anything.

        The ``cleanup`` method is the method that provy calls after all ``Roles`` have been provisioned and is meant to allow ``Roles`` to perform any cleaning of resources or finish any pending operations.

        Please note that when overriding this method you should call
        `super` method.

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def cleanup(self):
                    pass
        '''
        for path in self._paths_to_remove:
            try:
                self.remove_dir(path, True, True)
            except Exception:
                self.log("Couldn't clean path {}".format(path))

    @contextmanager
    def __showing_command_output(self, show=True):
        if show:
            yield
        else:
            with fabric.api.settings(
                fabric.api.hide('warnings', 'running', 'stdout', 'stderr')
            ):
                yield

    @contextmanager
    def __cd(self, cd=None):
        """
            If cd is not none will use fabric.api.cd else this is a noop.
        """
        if cd is not None:
            with fabric.api.cd(cd):
                yield
        else:
            yield

    def execute(self, command, stdout=True, sudo=False, user=None, cwd=None):
        '''
        This method is the bread and butter of provy and is a base for most other methods that interact with remote servers.

        It allows you to perform any shell action in the remote server.
        It is an abstraction over `fabric <https://fabric.readthedocs.org/en/latest/>`_
        `run <https://fabric.readthedocs.org/en/latest/api/core/operations.html#fabric.operations.run>`_
        and `sudo <https://fabric.readthedocs.org/en/latest/api/core/operations.html#fabric.operations.sudo>`_ methods.

        :param command: The command to be executed.
        :type command: :class:`str`
        :param stdout: If you specify this argument as False, the standard output of the command execution will not be displayed in the console. Defaults to True.
        :type stdout: :class:`bool`
        :param sudo: Specifies whether this command needs to be run as the super-user. Doesn't need to be provided if the "user" parameter (below) is provided. Defaults to False.
        :type sudo: :class:`bool`
        :param user: If specified, will be the user with which the command will be executed. Defaults to None.
        :type user: :class:`str`
        :param cwd: Represents a directory on remote server.If specified we will
             cd into that directory before executing command. Current path will be
             *unchanged* after the call.
        :type cwd: :class:`str`

        :return: The execution result
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.execute('ls /', stdout=False, sudo=True)
                    self.execute('ls /', stdout=False, user='vip')
        '''
        with self.__showing_command_output(stdout):
            with self.__cd(cwd):
                return self.__execute_command(command, sudo=sudo, user=user)

    def __execute_command(self, command, sudo=False, user=None):
        if sudo or (user is not None):
            return fabric.api.sudo(command, user=user)
        return fabric.api.run(command)

    def execute_local(self, command, stdout=True, sudo=False, user=None):
        '''
        Allows you to perform any shell action in the local machine. It is an abstraction over the `fabric.api.local <https://fabric.readthedocs.org/en/latest/api/core/operations.html#fabric.operations.local>`_ method.

        :param command: The command to be executed.
        :type command: :class:`str`
        :param stdout: If you specify this argument as False, the standard output of the command execution will not be displayed in the console. Defaults to :class:`True`.
        :type stdout: :class:`bool`
        :param sudo: Specifies whether this command needs to be run as the super-user. Doesn't need to be provided if the "user" parameter (below) is provided. Defaults to :class:`False`.
        :type sudo: :class:`bool`
        :param user: If specified, will be the user with which the command will be executed. Defaults to :class:`None`.
        :type user: :class:`str`

        :return: The execution result
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.execute_local('ls /', stdout=False, sudo=True)
                    self.execute_local('ls /', stdout=False, user='vip')
        '''
        with self.__showing_command_output(stdout):
            return self.__execute_local_command(command, sudo=sudo, user=user)

    def __execute_local_command(self, command, sudo=False, user=None):
        if user is not None:
            command = 'sudo -u %s %s' % (user, command)
        elif sudo:
            command = 'sudo %s' % command
        return fabric.api.local(command, capture=True)

    def execute_python(self, command, stdout=True, sudo=False):
        '''
        Just an abstraction over execute. This method executes the python code that is passed with python -c.

        :param command: The command to be executed.
        :type command: :class:`str`
        :param stdout: If you specify this argument as False, the standard output of the command execution will not be displayed in the console. Defaults to :class:`True`.
        :type stdout: :class:`bool`
        :param sudo: Specifies whether this command needs to be run as the super-user. Doesn't need to be provided if the "user" parameter (below) is provided. Defaults to :class:`False`.
        :type sudo: :class:`bool`

        :return: The execution result
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.python_execute('import os; print os.curdir', stdout=False, sudo=True)
        '''
        return self.execute('''python -c "%s"''' % command, stdout=stdout, sudo=sudo)

    def execute_python_script(self, script, stdout=True, sudo=False):
        """
        Executes python script on remote server. Difference with
        :meth:`execute_python` is that this implementation uploads a file
        with script to remote server and then executes it, so we have no
        problems with shell expansion.

        :param script: Script to be executed on remote server. Can be either a string or a (opened) file like object.
        :type script: `string or an opened file`
        :param stdout: If you specify this argument as False, the standard output of the command execution will not be displayed in the console. Defaults to :class:`True`.
        :type stdout: :class:`bool`
        :param sudo: Specifies whether this command needs to be run as the super-user. Doesn't need to be provided if the "user" parameter (below) is provided. Defaults to :class:`False`.
        :type sudo: :class:`bool`

        :return: stdout of script
        """
        script_file = self.create_remote_temp_file("script", "py")

        if isinstance(script, basestring):
            script = StringIO(script)

        self.put_file(script, script_file, sudo, False)

        return self.execute('python "{}"'.format(script_file), stdout, sudo)

    def remote_list_directory(self, path):
        """
        Lists contents of remote directory and returns them as a python
        list.

        :param str path: Path to list on the remote side.

        :return: Remote directory lisitng.

        :rtype: list
        """
        import json  # in case someone uses python 2.6
        result = self.execute_python('''import os, json; print json.dumps(os.listdir('{}'))'''.format(path), False, True)
        contents = json.loads(result)
        return contents

    def get_logged_user(self):
        '''
        Returns the currently logged user in the remote server.

        :return: The logged user
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.context['my-user'] = self.get_logged_user()
        '''
        return self.execute('whoami', stdout=False)

    def local_exists(self, file_path):
        '''
        Returns True if the file exists locally.

        :param file_path: The path to check.
        :type file_path: :class:`str`

        :return: Whether the file exists or not
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.local_exists('/tmp/my-file'):
                        pass
        '''
        return exists(file_path)

    def remote_exists(self, file_path):
        '''
        Returns True if the file exists in the remote server.

        :param file_path: The path to check.
        :type file_path: :class:`str`

        :return: Whether the file exists or not
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.remote_exists('/tmp/my-file'):
                        pass
        '''
        return self.execute('test -f %s; echo $?' % file_path, stdout=False, sudo=True) == '0'

    def remote_exists_dir(self, file_path):
        '''
        Returns True if the directory exists in the remote server.

        :param file_path: The path to check.
        :type file_path: :class:`str`

        :return: Whether the directory exists or not
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.remote_exists_dir('/tmp'):
                        pass
        '''
        return self.execute('test -d %s; echo $?' % file_path, stdout=False, sudo=True) == '0'

    def local_temp_dir(self):
        '''
        Returns the path of a temporary directory in the local machine.

        :return: The temp dir path
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.context['source_dir'] = self.local_temp_dir()
        '''
        return gettempdir()

    def remote_temp_dir(self):
        '''
        Returns the path of a temporary directory in the remote server.

        :return: The temp dir path
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.context['target_dir'] = self.remote_temp_dir()
        '''
        return self.execute_python('from tempfile import gettempdir; print gettempdir()', stdout=False)

    def create_remote_temp_file(self, prefix='', suffix='', cleanup=True):
        """
        Creates random unique file name in the remote server temp dir.

        This file is not uploaded by server, but because it is generated
        by :class:`uuid.uuid4` you can be sure no other process will
        clash with it.

        :param prefix: Optional prefix to the file name.
        :type prefix: :class:`str`
        :param suffix: Optional suffix to the file name. Usefull
            to provide extensions.
        :type suffix: :class:`str`
        :param bool cleanup: If True file will be deleted during cleanup
            phase. Default: :data:`True`.
        :type cleanup: :class:`bool`

        :return: Created file name.
        :rtype: str
        """
        file_name = "{}/{}{}.{}".format(self.remote_temp_dir(), prefix,
                                        str(uuid.uuid4()), suffix)
        if cleanup:
            self._paths_to_remove.add(file_name)
        return file_name

    def create_remote_temp_dir(self, dirname=None, owner=None, chmod=None, cleanup=True):
        """

        Creates temporary directory on remote server. This directory will be
        stored in temporary directory on remote server.

        :param dirname: Name of the directory. If None random name will be
            choosen. Defaults to None.
        :type dirname: :class:`str`
        :param owner: Username of user who will own this directory.
            Defaults to :data:`None` which in turns means current remote user.
        :type owner: :class:`str`
        :param chmod: File modifiers specified for this directory.   Defaults
            to :data:`None` which in turns means leave default chmod specified
            by the remote OS.
        :type chmod: :class:`str`
        :param cleanup: If True directory will be deleted during cleanup
            phase. Default: :data:`True`.
        :type cleanup: :class:`bool`

        :return: Created directory name.

        :rtype: str
        """

        if dirname is None:
            dirname = str(uuid.uuid4())  # NOQA

        prepared_dirname = "{}/{}".format(self.remote_temp_dir(), dirname)

        self.ensure_dir(prepared_dirname, owner, owner is not None)

        if chmod is not None:
            self.change_path_mode(prepared_dirname, chmod)

        if cleanup:
            self._paths_to_remove.add(prepared_dirname)

        return prepared_dirname

    def ensure_dir(self, directory, owner=None, sudo=False):
        '''
        Make sure the specified directory exists in the remote server.

        :param directory: Directory to be created if it does not exist.
        :type directory: :class:`str`
        :param owner: If specified, the directory will be created under this user, otherwise the currently logged user is the owner.
        :type owner: :class:`str`
        :param sudo: If specified, the directory is created under the super-user. This is particularly useful in conjunction with the owner parameter, to create folders for the owner where only the super-user can write.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.ensure_dir('/etc/my-path', owner='myuser', sudo=True)
        '''
        if owner:
            sudo = True

        if not self.remote_exists_dir(directory):
            self.execute('mkdir -p %s' % directory, stdout=False, sudo=sudo)

        if owner:
            self.change_path_owner(directory, owner)

    def change_path_owner(self, path, owner):
        '''
        Changes the owner of a given path. Please be advised that this method is recursive, so if the path is a directory, all contents of it will belong to the specified owner.

        :param path: Path to have its owner changed.
        :type path: :class:`str`
        :param owner: User that should own this path.
        :type owner: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.change_path_owner(path='/etc/my-path', owner='someuser')
        '''
        self.execute('chown -R %s %s' % (owner, path), stdout=False, sudo=True)

    def get_object_mode(self, path):
        '''
        Returns the permission mode of a given object. Raises IOError if the path doesn't exist.

        :param path: Path of the given object.
        :type path: :class:`str`

        :return: The path permission mode
        :rtype: :class:`int`

        :raise: :class:`IOError` if the path doesn't exist

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.get_object_mode('/home/user/logs') == 644:
                        pass
        '''
        if not self.remote_exists(path) and not self.remote_exists_dir(path):
            raise IOError('The file at path %s does not exist' % path)
        return int(self.execute('stat -c %%a %s' % path, stdout=False, sudo=True))

    def change_path_mode(self, path, mode, recursive=False):
        '''
        Changes the mode of a given path.

        :param path: Path to have its mode changed.
        :type path: :class:`str`
        :param mode: Mode to change to.
        :type mode: :class:`int`
        :param recursive: Indicates if the mode of the objects in the path should be changed recursively. Defaults to :class:`False`.
        :type recursive: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.change_path_mode(directory='/home/user/logs', mode=644, recursive=True)
        '''
        options = ""
        if recursive:
            options += "-R "

        previous_mode = self.get_object_mode(path)
        if previous_mode != mode or recursive:
            self.execute('chmod %s%s %s' % (options, mode, path), stdout=False, sudo=True)
            self.log("Path %s had mode %s. Changed it %sto %s." % (path, previous_mode, recursive and "recursively " or "", mode))

    def md5_local(self, path):
        '''
        Calculates an md5 hash for a given file in the local system. Returns :class:`None` if file does not exist.

        :param path: Path of the local file.
        :type path: :class:`str`

        :return: The hash generated, or :class:`None` if `path` doesn't exist.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    hash = self.md5_local('/tmp/my-file')
        '''
        if not self.local_exists(path):
            return None

        result = self.execute_local(self.__md5_hash_command(path), stdout=False, sudo=True)
        return result.strip()

    def md5_remote(self, path):
        '''
        Calculates an md5 hash for a given file in the remote system. Returns :class:`None` if file does not exist.

        :param path: Path of the remote file.
        :type path: :class:`str`

        :return: The hash generated, or None if `path` doesn't exist.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    hash = self.md5_remote('/tmp/my-file')
        '''
        if not self.remote_exists(path):
            return None

        result = self.execute(self.__md5_hash_command(path), stdout=False, sudo=True)
        return result.strip()

    def __md5_hash_command(self, path):
        return 'md5sum %s | cut -d " " -f 1' % path

    def remove_dir(self, path, sudo=False, recursive=False, stdout=True):
        '''
        Removes a directory in the remote server. Returns :data:`True` in the event of the directory actually been removed. :data:`False` otherwise.

        :param path: Path of the remote directory.
        :type path: :class:`str`
        :param sudo: Indicates whether the directory should be removed by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`
        :param recursive: Indicates whether the directory should be removed recursively or not. Defaults to :data:`False`.
        :type recursive: :class:`bool`

        :return: Whether the directory had to be removed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.remove_dir('/tmp/my-dir', sudo=True, recursive=True)
        '''
        if self.remote_exists_dir(path):
            if recursive:
                command = 'rm -rf %s'
            else:
                command = 'rmdir %s'
            self.execute(command % path, stdout=False, sudo=sudo)
            if stdout:
                self.log('%s removed!' % path)
            return True
        return False

    def remove_file(self, path, sudo=False):
        '''
        Removes a file in the remote server. Returns :data:`True` in the event of the file actually been removed. :data:`False` otherwise.

        :param path: Path of the remote file.
        :type path: :class:`str`
        :param sudo: Indicates whether the file should be removed by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`

        :return: Whether the file had to be removed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.remove_file('/tmp/my-file', sudo=True)
        '''

        if self.remote_exists(path):
            self.execute('rm -f %s' % path, stdout=False, sudo=sudo)
            self.log('%s removed!' % path)
            return True
        return False

    def remote_symlink(self, from_file, to_file, sudo=False):
        '''
        Creates a symlink in the remote server.

        :param from_file: Symlink source.
        :type from_file: :class:`str`
        :param to_file: Symlink target.
        :type to_file: :class:`str`
        :param sudo: Indicates whether the symlink should be created by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.remote_symlink('/home/user/my-app', '/etc/init.d/my-app', sudo=True)
        '''
        if not self.remote_exists(from_file):
            raise RuntimeError("The file to create a symlink from (%s) was not found!" % from_file)

        command = 'ln -sf %s %s' % (from_file, to_file)
        if self.remote_exists(to_file):
            result = self.execute('ls -la %s' % to_file, stdout=False, sudo=sudo)
            if '->' in result:
                path = result.split('->')[-1].strip()
                if path != from_file:
                    self.log('Symlink has different path(%s). Syncing...' % path)
                    self.execute(command, stdout=False, sudo=sudo)
        else:
            self.log('Symlink not found at %s! Creating...' % from_file)
            self.execute(command, stdout=False, sudo=sudo)

    def __extend_context(self, options):
        extended = {}
        for key, value in self.context.iteritems():
            extended[key] = value
        for key, value in options.iteritems():
            extended[key] = value
        return extended

    def put_file(self, from_file, to_file, sudo=False, stdout=True):
        '''
        Puts a file to the remote server.

        :param from_file: Source file in the local system.
        :type from_file: :class:`str`
        :param to_file: Target path in the remote server.
        :type to_file: :class:`str`
        :param sudo: Indicates whether the file should be created by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.put_file('/home/user/my-app', '/etc/init.d/my-app', sudo=True)
        '''

        with self.__showing_command_output(stdout):
            fabric.api.put(from_file, to_file, use_sudo=sudo)

    def update_file(self, from_file, to_file, owner=None, options={}, sudo=None):
        '''
        One of the most used methods in provy. This method renders a template, then if the contents differ from the remote server (or the file does not exist at the remote server), it sends the results there.

        Again, combining the parameters sudo and owner you can have files that belong to an user that is not a super-user in places that only a super-user can reach.

        Returns True if the file was updated, False otherwise.

        :param from_file: Template file in the local system.
        :type from_file: :class:`str`
        :param to_file: Target path in the remote server.
        :type to_file: :class:`str`
        :param owner: Owner for the file in the remote server.
        :type owner: :class:`str`
        :param options: Dictionary of options that can be used in the template.
        :type options: :class:`dict`
        :param sudo: Indicates whether the file should be created by the super-user. Defaults to :data:`None`.
        :type sudo: :class:`bool`

        :return: Whether the file was updated or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.update_file('/home/user/my-app', '/etc/init.d/my-app', owner='my-user',
                                     {
                                        'option_a': 1,
                                        'option_b': 2
                                     },
                                     sudo=True)
        '''
        update_data = None
        try:
            update_data = self._build_update_data(from_file, options, to_file)
            return self._update_file_with_data(to_file, update_data, from_file, sudo, owner)
        finally:
            if update_data and update_data.local_temp_path and exists(update_data.local_temp_path):
                os.remove(update_data.local_temp_path)

    def _update_file_with_data(self, to_file, update_data, from_file, sudo, owner):
        should_create = not self.remote_exists(to_file)
        contents_differ = self._contents_differ(update_data.to_md5, update_data.from_md5)

        if not should_create and contents_differ:
            self.log('Hashes differ %s => %s! Copying %s to server %s!' % (update_data.from_md5, update_data.to_md5, from_file, self.context['host']))

        if should_create or contents_differ:
            self._force_update_file(to_file, sudo, update_data.local_temp_path, owner)
            return True
        return False

    def _build_update_data(self, from_file, options, to_file):
        template = self.render(from_file, options)
        local_temp_path = self.write_to_temp_file(template)
        from_md5 = self.md5_local(local_temp_path)
        to_md5 = self.md5_remote(to_file)

        update_data = UpdateData(local_temp_path, from_md5, to_md5)
        return update_data

    def _contents_differ(self, to_md5, from_md5):
        return self._clean_md5(from_md5) != self._clean_md5(to_md5)

    def _clean_md5(self, md5):
        if md5 is None:
            return None
        return md5.strip()

    def _force_update_file(self, to_file, sudo, local_temp_path, owner):
        if sudo is None and owner is not None:
            sudo = True
        elif sudo is None and owner is None:
            sudo = False

        self.put_file(local_temp_path, to_file, sudo)

        if owner:
            self.change_path_owner(to_file, owner)

    def write_to_temp_file(self, text):
        '''
        Writes some text to a temporary file and returns the file path.

        :param text: Text to be written to the temp file.
        :type text: :class:`str`

        :return: Temp file path.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    path = self.write_to_temp_file('some random text')
                    self.put_file(path, '/tmp/some-file')
        '''
        local_temp_path = ''
        with NamedTemporaryFile(delete=False) as f:
            content = codecs.encode(text, 'utf-8')
            f.write(content)
            local_temp_path = f.name

        return local_temp_path

    def read_remote_file(self, path, sudo=True):
        '''
        Returns the contents of a remote file.

        :param path: File path on the remote server.
        :type path: :class:`str`
        :param sudo: Indicates whether the file should be read by a super-user. Defaults to :data:`True`.
        :type sudo: :class:`bool`

        :return: The contents of the file.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    last_update = self.read_remote_file('/tmp/last-update')
        '''
        result = self.execute_python("import codecs; print codecs.open('%s', 'r', 'utf-8').read()" % path, stdout=False, sudo=sudo)
        return result

    def render(self, template_file, options={}):
        '''
        Renders a template with the given options and returns the rendered text.

        The :data:`template_file` parameter should be just the name of the file and not the file path. `Jinja2 <http://jinja.pocoo.org/>`_ will look for templates at the files directory in the provyfile path,
        as well as in the templates directory of any registered module (check the :meth:`register_template_loader` method).

        The options parameter will extend the server context, so all context variables (including per-server options) are available to the renderer.

        :param template_file: Template file path in the local system.
        :type template_file: :class:`str`
        :param options: Options to be passed to the template, as a dictionary. Defaults to empty :class:`dict`.
        :type options: :class:`dict`

        :return: The contents of the file.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    contents = self.render('my-template', { 'user': 'heynemann' })
        '''

        if isabs(template_file):
            env = Environment(loader=FileSystemLoader(dirname(template_file)))
            template_path = split(template_file)[-1]
        else:
            env = Environment(loader=self.context['loader'])
            template_path = template_file
        template = env.get_template(template_path)

        return template.render(**self.__extend_context(options))

    def is_process_running(self, process, sudo=False):
        '''
        Returns :data:`True` if the given process is running (listed in the process listing), :data:`False` otherwise.

        :param process: Regular expression string that specifies the process name.
        :type process: :class:`str`
        :param sudo: Indicates if the process listing should be done by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`

        :return: Whether the process is running or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.is_process_running('nginx', sudo=True):
                        self.execute('pkill nginx', stdout=False, sudo=True)
        '''
        return_code = self.execute('ps aux | egrep %s | egrep -v egrep > /dev/null;echo $?' % process, stdout=False, sudo=sudo)
        return int(return_code) == 0

    def has_line(self, line, file_path):
        '''
        Returns :data:`True` if the given line of text is present in the given file. Returns :data:`False` otherwise (even if the file does not exist).

        :param line: Line of text to verify in the given file.
        :type line: :class:`str`
        :param file_path: Complete path of the remote file.
        :type file_path: :class:`str`

        :return: Whether the line exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    if self.has_line('127.0.0.1 localhost', '/etc/hosts'):
                        pass
        '''
        if not self.remote_exists(file_path):
            return False

        contents = self.read_remote_file(file_path).split('\n')

        stripped_line = re.sub("\s+", '', line)

        for current_line in contents:
            if stripped_line == re.sub("\s+", '', current_line):
                return True
        return False

    def ensure_line(self, line, file_path, owner=None, sudo=False):
        '''
        Ensures that the given line exists in the given file_path. Adds it if it doesn't exist, and creates the file if it doesn't exist.

        :param line: Line of text to verify in the given file.
        :type line: :class:`str`
        :param file_path: Complete path of the remote file.
        :type file_path: :class:`str`
        :param owner: The user that owns the file. Defaults to :data:`None` (the context user is used in this case).
        :type owner: :class:`str`
        :param sudo: Indicates whether the file should be managed by the super-user. Defaults to :data:`False`.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    self.ensure_line('127.0.0.1     localhost', '/etc/hosts')
        '''
        if not self.has_line(line, file_path):

            remote_file = self.create_remote_temp_file()
            self.put_file(StringIO(line), remote_file, bool(sudo or owner), stdout=False)

            self.execute('cat {line} >> {target} && echo >> {target}'.format(line=remote_file, target=file_path), stdout=False, sudo=sudo, user=owner)
            self.log('Line "%s" not found in %s. Adding it.' % (line, file_path))

    def using(self, role):
        '''
        This method should be used when you want to use a different Role inside your own Role methods.

        It returns a ContextManager object, so this is meant to go inside a `with` block.

        :param role: Role to be used.
        :type role: :class:`Role`

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.ensure_package_installed('nginx')
        '''
        return UsingRole(role, self.prov, self.context)

    def get_distro_info(self):
        '''
        Returns a :class:`DistroInfo` with valuable information regarding the distribution of the server.

        In the backgrounds, what it does is to run

        .. code-block:: sh

            $ lsb_release -a

        in the server, so you might want to check which results are usual for your distribution.

        .. warning::

            The distribution info is requested to the server only once per Role instance, which means you won't get the new distro info if it changes remotely.

        Example:
        ::

            from provy.core import Role

            class MySampleRole(Role):
                def provision(self):
                    distro_info = self.role.get_distro_info()

                    # Supposing the server is a Debian Squeeze, the following statements will probably be true:
                    distro_info.distributor_id == 'Debian'
                    distro_info.description == 'Debian GNU/Linux 6.0.5 (squeeze)'
                    distro_info.release == '6.0.5'
                    distro_info.codename == 'squeeze'

                    # Supposing the server is a Ubuntu Precise Pangolin, the following statements will probably be true:
                    distro_info.distributor_id == 'Ubuntu'
                    distro_info.description == 'Ubuntu 12.04.1 LTS'
                    distro_info.release == '12.04'
                    distro_info.codename == 'precise'

                    # Supposing the server is a CentOS, the following statements may be true:
                    distro_info.lsb_version == ':core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch'
                    distro_info.distributor_id == 'CentOS'
                    distro_info.description == 'CentOS release 5.8 (Final)'
                    distro_info.release == '5.8'
                    distro_info.codename == 'Final'
        '''
        if self.__distro_info is None:
            raw_distro_info = self.execute('lsb_release -a')
            distro_info_lines = raw_distro_info.split('\n')
            distro_info = DistroInfo()

            for line in distro_info_lines:
                if ':' in line:
                    key, value = line.split(':', 1)
                    info_property = key.lower().replace(' ', '_')
                    setattr(distro_info, info_property, value.strip())

            self.__distro_info = distro_info

        return self.__distro_info


class DistroInfo(object):
    '''
    Value object used to contain distribution information.

    Refer to :meth:`Role.get_distro_info` usage.
    '''
    lsb_version = None
    distributor_id = None
    description = None
    release = None
    codename = None


class UpdateData(object):
    '''
    Value object used in the update_file method.
    '''
    def __init__(self, local_temp_path, from_md5, to_md5):
        self.local_temp_path = local_temp_path
        self.from_md5 = from_md5
        self.to_md5 = to_md5

########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
This is the internal module responsible for running provy over the provyfile that was provided.

It's recommended not to tinker with this module, as it might prevent your provyfile from working.
'''

from os.path import abspath, dirname, join

from fabric.context_managers import settings as _settings

from provy.core.utils import import_module, AskFor, provyfile_module_from
from provy.core.errors import ConfigurationError
from jinja2 import FileSystemLoader, ChoiceLoader


def run(provfile_path, server_name, password, extra_options):
    module_name = provyfile_module_from(provfile_path)
    prov = import_module(module_name)
    servers = get_servers_for(prov, server_name)

    build_prompt_options(servers, extra_options)

    for server in servers:
        provision_server(server, provfile_path, password, prov)


def print_header(msg):
    print
    print "*" * len(msg)
    print msg
    print "*" * len(msg)


def provision_server(server, provfile_path, password, prov):
    host_string = "%s@%s" % (server['user'], server['address'].strip())

    context = {
        'abspath': dirname(abspath(provfile_path)),
        'path': dirname(provfile_path),
        'owner': server['user'],
        'cleanup': [],
        'registered_loaders': []
    }

    aggregate_node_options(server, context)

    loader = ChoiceLoader([
        FileSystemLoader(join(context['abspath'], 'files'))
    ])
    context['loader'] = loader

    print_header("Provisioning %s..." % host_string)

    settings_dict = dict(host_string=host_string, password=password)
    if 'ssh_key' in server and server['ssh_key']:
        settings_dict['key_filename'] = server['ssh_key']

    with _settings(**settings_dict):
        context['host'] = server['address']
        context['user'] = server['user']
        role_instances = []

        try:
            for role in server['roles']:
                context['role'] = role
                instance = role(prov, context)
                role_instances.append(instance)
                instance.provision()
        finally:
            for role in role_instances:
                role.cleanup()

            for role in context['cleanup']:
                role.cleanup()

    print_header("%s provisioned!" % host_string)


def aggregate_node_options(server, context):
    for key, value in server.get('options', {}).iteritems():
        context[key] = value


def build_prompt_options(servers, extra_options):
    for server in servers:
        for option_name, option in server.get('options', {}).iteritems():
            if isinstance(option, AskFor):
                if option.key in extra_options:
                    value = extra_options[option.key]
                else:
                    value = option.get_value(server)
                server['options'][option_name] = value


def get_servers_for(prov, server_name):
    return get_items(prov, server_name, 'servers', lambda item: isinstance(item, dict) and 'address' in item)


def get_items(prov, item_name, item_key, test_func):
    if not hasattr(prov, item_key):
        raise ConfigurationError('The %s collection was not found in the provyfile file.' % item_key)

    items = getattr(prov, item_key)

    for item_part in item_name.split('.'):
        items = items[item_part]

    found_items = []
    recurse_items(items, test_func, found_items)
    return found_items


def recurse_items(col, test_func, found_items):
    if not isinstance(col, dict):
        return

    if test_func(col):
        found_items.append(col)
    else:
        for key, val in col.iteritems():
            if test_func(val):
                found_items.append(val)
            else:
                recurse_items(val, test_func, found_items)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Core utilities.

Provides the :class:`AskFor` class, which is used to prompt for a password.
'''

from getpass import getpass
import os


def provyfile_path_from(args):
    if args:
        path = args[0]
        if not os.path.exists(path):
            raise IOError('provy file "%s" does not exist.' % path)
        if os.path.isabs(path):
            raise ValueError('provy file "%s" is absolute. Please provide a path that is relative to the current working directory.')
        return path
    elif os.path.exists('provyfile.py'):
        return 'provyfile.py'
    elif os.path.exists('provy_file.py'):
        return 'provy_file.py'
    raise IOError('No provyfile was found. Please specify an existant provyfile path, or create either a "provyfile.py" or "provy_file.py"')


def provyfile_module_from(path):
    (base, ext) = os.path.splitext(path)
    base = base.replace('/', '.')
    return base


def import_module(module_name):
    module = __import__(module_name)
    if '.' in module_name:
        return reduce(getattr, module_name.split('.')[1:], module)
    return module


class AskFor(object):
    '''
    Responsible for prompting for a password to the user.

    You may pass an instance of it, instead of a plain value, in the ``servers`` dictionary, so that you require the user to enter a value.
    '''
    def __init__(self, key, question):
        self.key = key
        self.question = question

    def get_value(self, server):
        value = getpass("[Server at %s] - %s: " % (server['address'], self.question))
        return value

########NEW FILE########
__FILENAME__ = postgresql
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `PostgreSQL <http://www.postgresql.org/>`_ database management utilities.
'''

from provy.core import Role


class BasePostgreSQLRole(Role):
    def provision(self):
        '''
        This method should be implemented by the concrete PostgreSQLRole classes, according to each provisioning steps for each distribution.

        :raise: NotImplementedError
        '''
        raise NotImplementedError

    def _execute(self, command, stdout=True):
        return self.execute(command, stdout=stdout, sudo=True, user='postgres')

    def create_user(self, username, ask_password=True, is_superuser=False, can_create_databases=False, can_create_roles=False):
        '''
        Creates a user for the database.

        :param username: Name of the user to be created.
        :type username: :class:`str`
        :param ask_password: If :data:`False`, doesn't ask for the user password now. Defaults to :data:`True`, which makes the role prompt for the password.
        :type ask_password: :class:`bool`
        :param is_superuser: If :data:`True`, creates as a superuser and ignores can_create_databases and can_create_roles arguments (as they would be implicit).
            Defaults to :data:`False`.
        :type is_superuser: :class:`bool`
        :param can_create_databases: If :data:`True`, gives database creation privilege to the user. Defaults to :data:`False`.
        :type can_create_databases: :class:`bool`
        :param can_create_roles: If :data:`True`, gives this user privilege to create other users. Defaults to :data:`False`.
        :type can_create_roles: :class:`bool`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.create_user("john", ask_password=False)
        '''
        creation_args = self.__collect_user_creation_args(ask_password, is_superuser, can_create_databases, can_create_roles)
        return self._execute("createuser -%s %s" % (''.join(creation_args), username))

    def __collect_user_creation_args(self, ask_password, is_superuser, can_create_databases, can_create_roles):
        creation_args = []
        if ask_password:
            creation_args.append('P')
        creation_args.append('S' if not is_superuser else 's')
        if not is_superuser:
            creation_args.append('D' if not can_create_databases else 'd')
            creation_args.append('R' if not can_create_roles else 'r')
        return creation_args

    def drop_user(self, username):
        '''
        Drops a user from the database.

        :param username: Name of the user to be dropped.
        :type username: :class:`str`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.drop_user("john")
        '''
        return self._execute("dropuser %s" % username)

    def user_exists(self, username):
        '''
        Checks if a user exists in the database.

        :param username: Name of the user to be checked.
        :type username: :class:`str`

        :return: Whether the user exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.user_exists("john") # True or False
        '''
        return bool(self._execute("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='%s'\"" % username, stdout=False))

    def ensure_user(self, username, ask_password=True, is_superuser=False, can_create_databases=False, can_create_roles=False):
        '''
        Ensures that a user exists in the database. If it doesn't, create it.

        :param username: Name of the user to be checked/created.
        :type username: :class:`str`
        :param ask_password: If :data:`False`, doesn't ask for the user password now. Defaults to :data:`True`, which makes the role prompt for the password.
        :type ask_password: :class:`bool`
        :param is_superuser: If :data:`True`, creates as a superuser and ignores can_create_databases and can_create_roles arguments (as they would be implicit).
            Defaults to :data:`False`.
        :type is_superuser: :class:`bool`
        :param can_create_databases: If :data:`True`, gives database creation privilege to the user. Defaults to :data:`False`.
        :type can_create_databases: :class:`bool`
        :param can_create_roles: If :data:`True`, gives this user privilege to create other users. Defaults to :data:`False`.
        :type can_create_roles: :class:`bool`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.ensure_user("john", ask_password=False)
        '''
        if not self.user_exists(username):
            self.log('User "%s" does not exist yet. Creating...' % username)
            return self.create_user(username, ask_password, is_superuser, can_create_databases, can_create_roles)
        return True

    def create_database(self, database, owner=None):
        '''
        Creates a database.

        :param database: Name of the database to be created.
        :type database: :class:`str`
        :param owner: The database owner. If not provided, will be the Postgres default.
        :type owner: :class:`str`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.create_database("foo", owner="john")
        '''
        owner_arg = " -O %s" % owner if owner is not None else ""
        return self._execute("createdb %s%s" % (database, owner_arg))

    def drop_database(self, database):
        '''
        Drops a database.

        :param database: Name of the database to be dropped.
        :type database: :class:`str`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.drop_database("foo")
        '''
        return self._execute("dropdb %s" % database)

    def database_exists(self, database):
        '''
        Checks if a database exists.

        :param database: Name of the database to be checked.
        :type database: :class:`str`

        :return: Whether the database exists.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.database_exists("foo") # True or False
        '''
        return bool(self._execute('psql -tAc "SELECT 1 from pg_database WHERE datname=\'%s\'"' % database, stdout=False))

    def ensure_database(self, database, owner=None):
        '''
        Ensures that a database exists. If it doesn't, create it.

        :param database: Name of the database to be checked/created.
        :type database: :class:`str`
        :param owner: The database owner. If not provided, will be the Postgres default.
        :type owner: :class:`str`

        :return: The result output of the execution.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PostgreSQLRole) as role:
                        role.ensure_database("foo", owner="john")
        '''
        if not self.database_exists(database):
            self.log('Database "%s" does not exist yet. Creating...' % database)
            return self.create_database(database, owner)
        return True

########NEW FILE########
__FILENAME__ = mysql
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `MySQL <http://www.mysql.com/>`_ database management utilities for CentOS distributions.
'''

import re

from provy.core import Role
from provy.more.centos.package.yum import YumRole


class MySQLRole(Role):
    '''
    This role provides `MySQL <http://www.mysql.com/>`_ database management utilities for CentOS distributions.

    This role uses two context keys: `mysql_root_user` and `mysql_root_pass`. If none are found, it uses 'root' and empty password.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import MySQLRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(MySQLRole) as role:
                    role.ensure_user(username=self.context['mysql_user'], identified_by=self.context['mysql_password'])
                    role.ensure_database(self.context['mysql_database'], owner=self.context['mysql_user'])
    '''
    def __init__(self, prov, context):
        super(MySQLRole, self).__init__(prov, context)
        self.mysql_root_user = 'mysql_root_user' in self.context and self.context['mysql_root_user'] or 'root'
        self.mysql_root_pass = 'mysql_root_pass' in self.context and self.context['mysql_root_pass'] or ''

    def provision(self):
        '''
        Installs `MySQL <http://www.mysql.com/>`_ Server and its dependencies.
        This method should be called upon if overriden in base classes, or MySQL won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(MySQLRole) # no need to call this if using with block.
        '''
        with self.using(YumRole) as role:

            role.ensure_up_to_date()

            result = role.ensure_package_installed('mysql-server')
            role.ensure_package_installed('mysql-devel')
            role.ensure_package_installed('mysql-libs')

            if result:
                self.log("setting root user %s password..." % self.mysql_root_user)
                self.execute("mysqladmin -u %s -p'temppass' password '%s'" % (self.mysql_root_user, self.mysql_root_pass), stdout=False, sudo=True)

    def __execute_non_query(self, query):
        pass_string = ""
        if self.mysql_root_pass:
            pass_string = '--password="%s" ' % self.mysql_root_pass

        self.execute('mysql -u %s %s-e "%s" mysql' % (self.mysql_root_user, pass_string, query), stdout=False, sudo=True)

    def __execute_query(self, query):
        pass_string = ""
        if self.mysql_root_pass:
            pass_string = '--password="%s" ' % self.mysql_root_pass

        result = self.execute('mysql -u %s %s-E -e "%s" mysql' % (self.mysql_root_user, pass_string, query), stdout=False, sudo=True)
        rows = self.__get_rows(result)

        return rows

    def __get_rows(self, result):
        index_re = re.compile('(\d+)[.]')
        items = []
        item = None
        for line in result.split('\n'):
            if not line.strip():
                continue
            if line.startswith('*'):
                if item:
                    items.append(item)
                item = {
                    'index': index_re.search(line).groups()[0]
                }
            else:
                key, value = line.split(':', 1)
                item[key.strip()] = value.strip()
        if item:
            items.append(item)

        return items

    def get_user_hosts(self, username):
        '''
        Returns all the available hosts that this user can login from.

        :param username: Name of the user to be verified.
        :type username: :class:`str`
        :return: The user hosts.
        :rtype: :class:`list`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if not '%' in role.get_user_hosts('someuser'):
                            pass
        '''
        users = self.__execute_query("select Host from mysql.user where LOWER(User)='%s'" % username.lower())
        hosts = []
        if users:
            for user in users:
                hosts.append(user['Host'])

        return hosts

    def user_exists(self, username, login_from='%'):
        '''
        Returns :data:`True` if the given user exists for the given location in mysql server.

        :param username: Name of the user to be verified.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: Whether the user exists.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if not role.user_exists('someuser'):
                            pass
        '''
        return login_from in self.get_user_hosts(username)

    def ensure_user(self, username, identified_by, login_from='%'):
        '''
        Ensure the given user is created in the database and can login from the specified location.

        :param username: Name of the user to be created.
        :type username: :class:`str`
        :param identified_by: Password that the user will use to login to mysql server.
        :type identified_by: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: Whether the user had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_user('someuser', 'somepass', 'localhost')
        '''
        if not self.user_exists(username, login_from):
            self.__execute_non_query("CREATE USER '%s'@'%s' IDENTIFIED BY '%s';" % (username, login_from, identified_by))
            self.log("User %s not found with login access for %s. User created!" % (username, login_from))
            return True

        return False

    def is_database_present(self, database_name):
        '''
        Returns :data:`True` if the database is already created.

        :param database_name: Database to verify.
        :type database_name: :class:`str`
        :return: Whether the database is present or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.is_database_present('database'):
                            pass
        '''
        result = self.__execute_query('SHOW DATABASES')
        is_there = False
        if result:
            for row in result:
                if row['Database'].lower() == database_name.lower():
                    is_there = True

        return is_there

    def ensure_database(self, database_name):
        '''
        Creates the database if it does not exist.

        :param database_name: Database to create.
        :type database_name: :class:`str`
        :return: Whether the database had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_database('database')
        '''
        if not self.is_database_present(database_name):
            self.__execute_non_query('CREATE DATABASE %s' % database_name)
            self.log("Database %s not found. Database created!" % database_name)
            return True
        return False

    def get_user_grants(self, username, login_from='%'):
        '''
        Returns all grants for the given user at the given location.

        :param username: Name of the user to be verify.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: The user grants.
        :rtype: :class:`list`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.get_user_grants('user', login_from='%'):
                            pass
        '''
        grants = self.__execute_query("SHOW GRANTS FOR '%s'@'%s';" % (username, login_from))
        only_grants = []
        for grant in grants:
            filtered_grants = filter(lambda x: x.startswith('GRANT '), grant.itervalues())
            only_grants.extend(filtered_grants)

        return only_grants

    def has_grant(self, privileges, on, username, login_from, with_grant_option):
        '''
        Returns :data:`True` if the user has the specified privileges on the specified object in the given location.

        :param privileges: Privileges that are being verified.
        :type privileges: :class:`str`
        :param on: Database object that the user holds privileges on.
        :type on: :class:`str`
        :param username: Name of the user to be verify.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :param with_grant_option: Indicates if we are verifying against grant option.
        :type with_grant_option: :class:`bool`
        :return: Whether the user has the privileges or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.has_grant('ALL PRIVILEGES',
                                          'database',
                                          'user',
                                          login_from='%',
                                          with_grant_option=True):
                            pass
        '''

        grants = self.get_user_grants(username, login_from)
        grant_option_string = self._get_grant_option_string(with_grant_option)
        privileges = self._get_privileges(privileges)
        grant_strings = self._get_possible_grant_strings(on, username, privileges, login_from, grant_option_string)

        for grant_string in grant_strings:
            if grant_string in grants:
                return True

        return False

    def _get_privileges(self, privileges):
        privileges = privileges.upper()
        if privileges == 'ALL':
            privileges = 'ALL PRIVILEGES'
        return privileges

    def _get_grant_option_string(self, with_grant_option):
        grant_option_string = ""
        if with_grant_option:
            grant_option_string = " WITH GRANT OPTION"
        return grant_option_string

    def _get_possible_grant_strings(self, on, username, privileges, login_from, grant_option_string):
        # These possible "ON" tokens are used because MySQL can behave differently depending on the version and system
        possible_on_tokens = [
            '`%s`.*' % on,
            '`%s`.`*`' % on,
            '%s.*' % on,
        ]
        grant_strings = ["GRANT %s ON %s TO '%s'@'%s'%s" % (privileges, on_token, username, login_from, grant_option_string)
                         for on_token in possible_on_tokens]
        return grant_strings

    def ensure_grant(self, privileges, on, username, login_from="%", with_grant_option=False):
        '''
        Ensures that the given user has the given privileges on the specified location.

        :param privileges: Privileges to assign to user (e.g.: "ALL PRIVILEGES").
        :type privileges: :class:`str`
        :param on: Object to assign privileges to. If only the name is supplied, '.*' will be appended to the name. If you want all databases pass '*.*'.
        :type on: :class:`str`
        :param username: User to grant the privileges to.
        :type username: :class:`str`
        :param login_from: Location where the user gets the grants. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :param with_grant_option: If :data:`True`, indicates that this user may grant other users the same privileges. Defaults to :data:`False`.
        :type with_grant_option: :class:`bool`
        :return: Whether the grant had to be added or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_grant('ALL PRIVILEGES',
                                          on='database',
                                          username='backend',
                                          login_from='%',
                                          with_grant_option=True)
        '''

        if self.has_grant(privileges, on, username, login_from, with_grant_option):
            return False

        grant_option_string = ""
        if with_grant_option:
            grant_option_string = " WITH GRANT OPTION"

        if not '.' in on:
            on = '%s.*' % on

        grant_string = "GRANT %s ON %s TO '%s'@'%s'%s" % (privileges, on, username, login_from, grant_option_string)
        self.__execute_non_query(grant_string)
        self.log("User %s@%s did not have grant '%s' on %s. Privileges granted!" % (username, login_from, privileges, on))

        return True

########NEW FILE########
__FILENAME__ = postgresql
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `PostgreSQL <http://www.postgresql.org/>`_ database management utilities for CentOS distributions.
'''
import re

import fabric

from provy.more.base.database import BasePostgreSQLRole
from provy.more.centos.package.yum import YumRole


class PostgreSQLRole(BasePostgreSQLRole):
    '''
    This role provides `PostgreSQL <http://www.postgresql.org/>`_ database management utilities for CentOS distributions.

    Take a look at :class:`provy.more.base.database.postgresql.BasePostgreSQLRole` for more available methods.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import PostgreSQLRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(PostgreSQLRole) as role:
                    role.ensure_user("john")
                    role.ensure_database("foo", owner="john")
    '''
    def provision(self):
        '''
        Installs `PostgreSQL <http://www.postgresql.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or PostgreSQL won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PostgreSQLRole) # no need to call this if using with block.
        '''
        with self.using(YumRole) as role:
            role.ensure_package_installed('postgresql-server')
            role.ensure_package_installed('postgresql-devel')

        self._ensure_initialized()
        self._ensure_running()
        self._run_on_startup()

    def _execute(self, *args, **kwargs):
        with fabric.api.cd('/var/lib/pgsql'):
            return super(PostgreSQLRole, self)._execute(*args, **kwargs)

    def _is_db_initialized(self):
        pgdata = '/var/lib/pgsql/data'
        return self.execute('ls -A %s' % pgdata, sudo=True, stdout=False)

    def _ensure_initialized(self):
        if not self._is_db_initialized():
            return(self.execute("service postgresql initdb", sudo=True))
        return True

    def _is_running(self):
        with fabric.api.settings(warn_only=True):
            status = self.execute('service postgresql status', sudo=True, stdout=False)
            return 'running' in status

    def _ensure_running(self):
        if not self._is_running():
            return self.execute('service postgresql start', sudo=True)
        return True

    def _will_start_on_boot(self):
        pkg_list = self.execute('chkconfig --list', sudo=True, stdout=False)
        return re.search(r'postgresql.*\t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off', pkg_list)

    def _run_on_startup(self):
        if not self._will_start_on_boot():
            self.execute('chkconfig --add postgresql', sudo=True)
            self.execute('chkconfig postgresql on', sudo=True)
            return True
        return False

########NEW FILE########
__FILENAME__ = rabbitmq
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `RabbitMQ <http://www.rabbitmq.com/>`_ utilities methods within CentOS distributions.
'''

from provy.core import Role
from provy.more.centos.package.yum import YumRole

from fabric.utils import warn


GUEST_USER_WARNING = ('It is advisable to delete the guest user or change the'
                      ' password to something private, particularly if your broker'
                      ' is accessible publicly.')


class RabbitMqRole(Role):
    '''
    This role provides utility methods for `RabbitMQ <http://www.rabbitmq.com/>`_ utilities within CentOS distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import RabbitMqRole
        from provy.more.centos import HostNameRole

        class MySampleRole(Role):
            def provision(self):

                with self.using(HostNameRole) as role:
                    # From rabbitmq docs [1]:
                    # "RabbitMQ names the database directory using the current
                    # hostname of the system. If the hostname changes, a new empty
                    # database is created.  To avoid data loss it's crucial to set
                    # up a fixed and resolvable hostname"
                    #
                    # [1] http://www.rabbitmq.com/ec2.html

                    role.ensure_hostname('rabbit')

                with self.using(RabbitMqRole) as role:
                    role.delete_user('guest')
                    role.ensure_user(
                        self.context['rabbit_user'],
                        self.context['rabbit_password'],
                    )
                    role.ensure_vhost(self.context['rabbit_vhost'])
                    role.ensure_permission(
                        self.context['rabbit_vhost'],
                        self.context['rabbit_user'],
                        '".*" ".*" ".*"',
                    )
    '''
    def provision(self):
        '''
        Installs `RabbitMQ <http://www.rabbitmq.com/>`_ and dependencies.
        This method should be called upon if overriden in base classes, or RabbitMQ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import HgRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(RabbitMqRole)
        '''
        with self.using(YumRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('rabbitmq-server')

        # Start rabbitmq at startup, TODO: add chkconfig role
        self.execute('chkconfig --add rabbitmq-server', stdout=False,
                     sudo=True)
        self.execute('chkconfig rabbitmq-server on', stdout=False, sudo=True)

        # Make sure rabbit is running:
        if not self.is_process_running('rabbitmq-server'):
            self.execute(
                'service rabbitmq-server start', stdout=False, sudo=True,
            )

        if self.user_exists('guest'):
            warn(GUEST_USER_WARNING)

    def user_exists(self, username):
        '''
        Checks if the RabbitMQ user exists.

        :param username: Name of the user to be checked.
        :type username: :class:`str`

        :return: Whether the user exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.user_exists('johndoe')
        '''
        cmd = 'rabbitmqctl list_users'
        users = self.execute(cmd, stdout=False, sudo=True)
        return username in users

    def vhost_exists(self, vhost):
        '''
        Checks if the RabbitMQ vhost exists.

        :param vhost: Name of the vhost to be checked.
        :type vhost: :class:`str`

        :return: Whether the vhost exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.vhost_exists('foobarhost')
        '''
        vhs = self.execute('rabbitmqctl list_vhosts', stdout=False, sudo=True)
        vhs = vhs.split('\r\n')[1:-1]
        return vhost in vhs

    def ensure_user(self, username, password, is_admin=False):
        '''
        Ensure the given user is created in the database and can authenticate with RabbitMQ.

        :param username: Name of the user to be created.
        :type username: :class:`str`
        :param password: Password that the user will use to authenticate to RabbitMQ.
        :type password: :class:`str`

        :return: Whether the user had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_user(some_user, some_pass)
        '''
        if not self.user_exists(username):
            self.log('Setting up user %s and password' % username)

            cmd = 'rabbitmqctl add_user %s %s' % (username, password)
            self.execute(cmd, sudo=True)

            if is_admin:
                cmd = 'rabbitmqctl set_user_tags %s administrator' % (username)
                self.execute(cmd, sudo=True)

            self.log('User %s added!' % username)
            return True

        return False

    def delete_user(self, user):
        '''
        Delete user from rabbitmq if exists

        :param user: Name of the user to be deleted.
        :type user: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.delete_user('guest', some_pass)
        '''
        if self.user_exists(user):
            self.log('User %s exists, deleting')

            cmd = 'rabbitmqctl delete_user %s' % user
            self.execute(cmd, stdout=False, sudo=True)

            self.log('User %s deleted' % user)

    def ensure_vhost(self, vhost):
        '''
        Ensure the given vhost is created.

        :param vhost: Name of the vhost to be checked/created.
        :type vhost: :class:`str`

        :return: Whether the vhost had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_vhost('/some_vhost')
        '''
        if not self.vhost_exists(vhost):
            self.log('Adding vhost %s' % vhost)

            self.execute('rabbitmqctl add_vhost %s' % vhost, sudo=True)

            self.log('vhost %s added!' % vhost)
            return True
        return False

    def ensure_permission(self, vhost, username, perms):
        '''
        Ensure the given user has the given permissions on the specified vhost

        :param vhost: Virtual host name to assign the permissions at.
        :type vhost: :class:`str`
        :param username: User to assign permissions to.
        :type username: :class:`str`
        :param perms: Permissions to assign to user (e.g.: '".*" ".*" ".*"').
        :type perms: :class:`str`

        :return: Whether the permissions could be assigned or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_permission(
                            'previous_created_vhost',
                            'previous_created_user',
                            '".*" ".*" ".*"',
                        )
        '''
        if not self.user_exists(username):
            msg = 'Cannot set permission: User %s doesn\'t exist' % username
            self.log(msg)
            return False

        if not self.vhost_exists(vhost):
            self.log('Cannot set permission: vhost %s doesn\'t exist' % vhost)
            return False

        msg = 'Setting up permissions for user %s on vhost %s'
        msg = msg % (username, vhost)
        self.log(msg)

        args = (vhost, username, perms)
        cmd = 'rabbitmqctl set_permissions -p %s %s %s' % args
        self.execute(cmd, stdout=False, sudo=True)

        return True

########NEW FILE########
__FILENAME__ = hosts
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide hosts management operations for centos distributions.
'''

from provy.more.linux.networking.hosts import HostsRole as Hosts


class HostsRole(Hosts):
    '''
    This role provides hosts file management utilities for centos distributions.

    This is just a class wrapper over :class:`provy.more.linux.networking.hosts.HostsRole`

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import HostsRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(HostsRole) as role:
                    role.ensure_host('localhost', '127.0.0.1')
    '''

########NEW FILE########
__FILENAME__ = pip
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the `PIP <http://www.pip-installer.org/>`_ package manager for CentOS distributions.
'''

import xmlrpclib

from fabric.api import settings

from provy.core import Role
from provy.more.centos.package.yum import YumRole


class PipRole(Role):
    '''
    This role provides package management operations with `PIP <http://www.pip-installer.org/>`_ within CentOS distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import PipRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(PipRole) as role:
                    role.ensure_package_installed('django', version='1.1.1')
    '''

    use_sudo = True
    user = None

    def provision(self):
        '''
        Installs pip dependencies. This method should be called upon if overriden in base classes, or PIP won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PipRole) # does not need to be called if using with block.
        '''

        with self.using(YumRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('python-setuptools')
            role.ensure_package_installed('python-devel')
            role.ensure_package_installed('gcc')
        self.execute("easy_install pip", sudo=True, stdout=False, user=None)

    def extract_package_data_from_input(self, input_line):
        package_constraint = None
        input_line = input_line.strip()
        package_info = {
            "name": input_line
        }

        if input_line.startswith("-e") and "#egg=" in input_line:
            data = input_line.split("#egg=")
            package_info["name"] = data[1]
        elif "==" in input_line:
            package_constraint = "=="
        elif '>=' in input_line:
            package_constraint = ">="

        if package_constraint:
            package_info['version_constraint'] = package_constraint
            data = input_line.split(package_constraint)
            package_info["name"] = data[0]
            package_info["version"] = data[1]

        return package_info

    def is_package_installed(self, package_name, version=None):
        '''
        Returns :data:`True` if the given package is installed via pip in the remote server, :data:`False` otherwise.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :param version: Version to check for. Defaults to :data:`None`, which makes it check for any version.
        :type version: :class:`str`
        :return: Whether the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        if role.is_package_installed('django', version='1.1.1'):
                            pass
        '''
        with settings(warn_only=True):
            package_info = self.extract_package_data_from_input(package_name)
            if not version:
                package_name = package_info['name']
            package_string = self.execute("pip freeze | tr '[A-Z]' '[a-z]' | grep %s" % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            if package_name in package_string:
                installed_version = package_string.split('==')[-1]
                if 'version' in package_info:
                    if '>=' == package_info['version_constraint']:
                        if installed_version < package_info['version']:
                            return False
                elif version and installed_version != version:
                    return False
                return True

    def get_package_remote_version(self, package_name):
        '''
        Returns the version of the package currently installed via PIP in the remote server. If package is not installed, returns :data:`None`.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: The package version.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        version = role.get_package_remote_version('django')
                        if version and version == '1.1.1':
                            pass
        '''
        with settings(warn_only=True):
            result = self.execute("pip freeze | tr '[A-Z]' '[a-z]' | grep %s" % package_name.lower(), stdout=False, sudo=self.use_sudo, user=self.user)
            if result:
                package, version = result.split('==')
                return version

            return None

    def get_package_latest_version(self, package_name):
        '''
        Returns the latest available version of the package at the Python Package Index. If package is not available, returns :data:`None`.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: The package version.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        version = role.get_package_remote_version('django')
                        latest = role.get_package_latest_version('django')
                        if version != latest:
                            pass
                            # this check is not needed if you use ensure_package_up_to_date.
        '''
        pypi = xmlrpclib.ServerProxy('http://pypi.python.org/pypi')
        available = pypi.package_releases(package_name)
        if not available:
            # Try to capitalize pkg name
            available = pypi.package_releases(package_name.capitalize())

        if not available:
            return None

        return available[0]

    def package_can_be_updated(self, package_name):
        '''
        Returns :data:`True` if there is an update for the given package in the Python Package Index, False otherwise.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: Whether the package can be updated.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        if role.package_can_be_updated('django'):
                            pass
                            # this check is not needed if you use ensure_package_up_to_date.
        '''
        remote_version = self.get_package_remote_version(package_name)
        latest_version = self.get_package_latest_version(package_name)

        return remote_version != latest_version

    def ensure_package_installed(self, package_name, version=None):
        '''
        Makes sure the package is installed with the specified version (latest if :data:`None` specified).
        This method does not verify and upgrade the package on subsequent provisions, though. Use :meth:`ensure_package_up_to_date` for this purpose instead.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`
        :param version: If specified, installs this version of the package. Installs latest version otherwise. You can use >= or <= before version number to ensure package version.
        :type version: :class:`str`
        :return: Whether the package had to be installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django', version='1.1.1')
        '''
        if version:
            package_info = self.extract_package_data_from_input(version)
            version_constraint = package_info.get('version_constraint', '==')
            version = package_info.get('version', version)
            if not self.is_package_installed(package_name, version):
                self.log('%s version %s should be installed (via pip)! Rectifying that...' % (package_name, version))
                self.execute('pip install %s%s%s' % (package_name, version_constraint, version), stdout=False, sudo=self.use_sudo, user=self.user)
                self.log('%s version %s installed!' % (package_name, version))
                return True
        elif not self.is_package_installed(package_name):
            self.log('%s is not installed (via pip)! Installing...' % package_name)
            self.execute('pip install %s' % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            self.log('%s installed!' % package_name)
            return True

        return False

    def ensure_requirements_installed(self, requirements_file_name):
        '''
        Makes sure the requirements file provided is installed.

        :param requirements_file_name: Path to the requirements file (can be provided as absolute path or relative to the directory where provy is run from).
        :type requirements_file_name: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_requirements_installed('/path/to/requirements.txt')
        '''

        with open(requirements_file_name, 'r') as requirements_file:
            for requirement in requirements_file.readlines():
                self.ensure_package_installed(requirement.strip())

    def ensure_package_up_to_date(self, package_name):
        '''
        Makes sure the package is installed and up-to-date with the latest version.
        This method verifies if there is a newer version for this package every time the server is provisioned. If a new version is found, it is installed.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_is_up_to_date('django')
        '''
        is_installed = self.is_package_installed(package_name)

        if is_installed and self.package_can_be_updated(package_name):
            self.log('%s is installed (via pip)! Updating...' % package_name)
            self.execute('pip install -U --no-dependencies %s' % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            self.log('%s updated!' % package_name)
            return True
        elif not is_installed:
            self.ensure_package_installed(package_name)
            return True

        self.log('%s is up to date (via pip).' % package_name)
        return False

    def set_user(self, user):
        '''
        Prepares the pip role instance to run its commands as a specific user.

        :param user: The username with which the role should run its commands.
        :type user: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django') # runs as sudo
                        role.set_user('johndoe')
                        role.ensure_package_installed('django') # runs as "johndoe" user
        '''

        self.user = user
        self.use_sudo = False

    def set_sudo(self):
        '''
        Prepares the pip role instance to run its commands with sudo; This is useful when you had previously set a user, and want it to run back as sudo.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django') # runs as sudo
                        role.set_user('johndoe')
                        role.ensure_package_installed('django') # runs as "johndoe" user
                        role.set_sudo()
                        role.ensure_package_installed('django') # runs as sudo
        '''

        self.user = None
        self.use_sudo = True

########NEW FILE########
__FILENAME__ = yum
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the Yum package manager for CentOS distributions.
'''

from os.path import join
from datetime import datetime, timedelta

from provy.core import Role


class YumRole(Role):
    '''
    This role provides package management operations with Yum within CentOS distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import YumRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(YumRole) as role:
                    role.ensure_package_installed('nginx')
    '''

    time_format = "%d-%m-%y %H:%M:%S"
    key = 'yum-up-to-date'

    def provision(self):
        '''
        Installs Yum dependencies. This method should be called upon if overriden in base classes, or Yum won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(YumRole) # does not need to be called if using with block.
        '''
        self.ensure_up_to_date()
        self.ensure_package_installed('curl')

    def ensure_gpg_key(self, url):
        '''
        Ensures that the specified gpg key is imported into rpm.

        :param url: URL of the gpg key file.
        :type url: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.ensure_gpg_key('http://some.url.com/to/key.gpg')
        '''
        command = "curl %s | rpm --import -" % url
        self.execute(command, stdout=False, sudo=True)

    def has_source(self, source_string):
        '''
        Ensures that the specified repository is in yum's list of repositories.

        :param source_string: Repository string.
        :type source_string: :class:`str`

        :return: Whether the repository is already configured or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        if role.has_source('some-path-to-a-repo'):
                            pass
        '''
        return source_string in self.execute('cat /etc/yum.repos.d/CentOS-Base.repo', stdout=False, sudo=True)

    def ensure_yum_source(self, source_string):
        '''
        Ensures that the specified repository is in yum's list of repositories.

        :param source_string: Repository string.
        :type source_string: :class:`str`

        :return: Whether the repository had to be added or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.ensure_yum_source('some-path-to-a-repo')
        '''
        if self.has_source(source_string):
            return False

        self.log("Yum source %s not found! Adding it..." % source_string)
        command = 'echo "%s" >> /etc/yum.repos.d/CentOS-Base.repo' % source_string
        self.execute(command, stdout=False, sudo=True)
        return True

    @property
    def update_date_file(self):
        '''
        Returns the path for the file that contains the last update date to yum's list of packages.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        file_path = role.update_date_file
        '''
        return join(self.remote_temp_dir(), 'last_yum_update')

    def store_update_date(self):
        '''
        Updates the date in the :meth:`update_date_file`.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.store_update_date()
        '''

        self.execute('echo "%s" > %s' % (datetime.now().strftime(self.time_format), self.update_date_file), stdout=False)

    def get_last_update_date(self):
        '''
        Returns the date in the :meth:`update_date_file`.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        last_update = role.get_last_update_date()
        '''
        if not self.remote_exists(self.update_date_file):
            return None

        date = datetime.strptime(self.read_remote_file(self.update_date_file), self.time_format)
        return date

    def ensure_up_to_date(self):
        '''
        Makes sure Yum's repository is updated if it hasn't been updated in the last 30 minutes.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.ensure_up_to_date()
        '''

        last_updated = self.get_last_update_date()
        if not self.key in self.context and (not last_updated or (datetime.now() - last_updated > timedelta(minutes=30))):
            self.force_update()

    def force_update(self):
        '''
        Forces an update to Yum's repository.

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.force_update()
        '''
        self.log('Updating yum sources...')
        self.execute('yum clean all', stdout=False, sudo=True)
        self.store_update_date()
        self.log('Yum sources up-to-date')
        self.context[self.key] = True

    def is_package_installed(self, package_name):
        '''
        Returns :data:`True` if the given package is installed via Yum, :data:`False` otherwise.

        :param package_name: The name of the package to check.
        :type package_name: :class:`str`

        :return: Whether the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        if role.is_package_installed('nginx'):
                            pass
        '''
        package = self.execute(
            'rpm -qa %s' % package_name, stdout=False, sudo=True,
        )
        return bool(package)

    def ensure_package_installed(self, package_name):
        '''
        Ensures that the given package is installed via Yum.

        :param package_name: The name of the package to install.
        :type package_name: :class:`str`

        :return: Whether the package had to be installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.ensure_package_installed('nginx')
        '''
        if not self.is_package_installed(package_name):
            self.__check_before_install(package_name)
            self.log('%s is not installed (via yum)! Installing...' % package_name)
            self.execute('yum install -y %s' % package_name, stdout=False, sudo=True)
            self.log('%s is installed (via yum).' % package_name)
            return True
        return False

    def __check_before_install(self, package_name):
        if not self.package_exists(package_name):
            raise PackageNotFound('Package "%s" not found in repositories' % package_name)

    def package_exists(self, package):
        '''
        Checks if the given package exists.

        :param package: Name of the package to check.
        :type package: :class:`str`
        :return: Whether the package exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import YumRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(YumRole) as role:
                        role.package_exists('nginx') # True
        '''
        try:
            return bool(self.execute('yum info -q %s' % package, stdout=False))
        except SystemExit:
            return False


class PackageNotFound(Exception):
    '''Should be raised when a package doesn't exist.'''

########NEW FILE########
__FILENAME__ = user
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''Roles in this namespace are meant to provide user management operations for CentOS distributions.'''

from provy.core import Role


class UserRole(Role):
    '''
    This role provides many utility methods for user management operations within CentOS distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import UserRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(UserRole) as role:
                    role.ensure_user('myuser', identified_by='mypass', is_admin=True)
    '''

    def group_exists(self, group_name):
        '''
        Returns :data:`True` if the given group exist, :data:`False` otherwise.

        :param group_name: Name of the group to verify.
        :type group_name: :class:`str`
        :return: Whether the group exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.group_exists('usersgroup'):
                            pass
        '''
        values = self.__first_values_from('group')
        return group_name in values

    def __first_values_from(self, basename):
        values = self.execute("cat /etc/%s | cut -d ':' -f 1" % basename, stdout=False, sudo=True)
        values = values.strip().split()
        return values

    def user_exists(self, username):
        '''
        Returns :data:`True` if the given user exist, :data:`False` otherwise.

        :param username: Name of the user to verify.
        :type username: :class:`str`
        :return: Whether the user exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.user_exists('myuser'):
                            pass
        '''
        values = self.__first_values_from('passwd')
        return username in values

    def user_in_group(self, username, group_name):
        '''
        Returns :data:`True` if the given user is in the given group, :data:`False` otherwise.

        :param username: Name of the user to verify.
        :type username: :class:`str`
        :param group_name: Name of the group to verify.
        :type group_name: :class:`str`
        :return: Whether the user pertains to the group or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.user_in_group('myuser', 'mygroup'):
                            pass
        '''
        raw_groups = self.execute('groups %s' % username, sudo=True, stdout=False).strip()
        if not raw_groups.startswith(username):
            raise ValueError("User '%s' doesn't exist" % username)
        groups_string = raw_groups.replace('%s : ' % username, '')
        groups = groups_string.split()
        return group_name in groups

    def ensure_group(self, group_name, group_id=None):
        '''
        Ensures that a given user group is present in the remote server.

        :param group_name: Name of the group to create.
        :type group_name: :class:`str`
        :param group_id: GID of the group. Defaults to :data:`None`, which assigns the next available GID.
        :type group_id: :class:`int`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        role.ensure_group('users-group')
        '''
        if not self.group_exists(group_name):
            self.log("Group %s not found! Creating..." % group_name)
            if not group_id:
                self.execute('groupadd %s' % group_name, stdout=False, sudo=True)
            else:
                self.execute('groupadd --gid %s %s' % (group_id, group_name), stdout=False, sudo=True)
            self.log("Group %s created!" % group_name)

    def ensure_user_groups(self, username, groups=[]):
        for user_group in groups:
            if not self.user_in_group(username, user_group):
                self.log("User %s should be in group %s! Rectifying that..." % (username, user_group))
                self.execute('usermod -G %s %s' % (user_group, username), stdout=False, sudo=True)
                self.log("User %s is in group %s now!" % (username, user_group))

    def ensure_user(self, username, identified_by=None, home_folder=None, default_script="/bin/bash", groups=[], is_admin=False):
        '''
        Ensures that a given user is present in the remote server.

        :param username: Name of the user.
        :type username: :class:`str`
        :param identified_by: Password that the user will use to login to the remote server. If set to :data:`None`, the user will not have a password.
        :type identified_by: :class:`str`
        :param user_id: UID of the user. Defaults to :data:`None`, which assigns the next available UID.
        :type user_id: :class:`str`
        :param home_folder: Specifies the user's home folder. Defaults to `/home/<username>`.
        :type home_folder: :class:`str`
        :param default_script: Sets the user's default script, the one that will execute commands per default when logging in. Defaults to `/bin/sh`.
        :type default_script: :class:`str`
        :param groups: Groups that this user belongs to. If the groups do not exist they are created prior to user creation. Defaults to the name of the user.
        :type groups: :class:`iterable`
        :param is_admin: If set to :data:`True` the user is added to the 'wheel' user group as well. Defaults to :data:`False`.
        :type is_admin: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        role.ensure_user('myuser', identified_by='mypass', is_admin=True)
        '''

        admin_group = self.__get_admin_group()
        self.__ensure_initial_groups(groups, username)

        if not self.user_exists(username):
            self.__create_new_user(username, home_folder, groups, identified_by, default_script, is_admin)
        elif is_admin and not self.user_in_group(username, admin_group):
            self.__set_user_as_admin(username, admin_group)

        self.ensure_user_groups(username, groups)

        if identified_by:
            self.execute('echo "%s:%s" | chpasswd' % (username, identified_by), stdout=False, sudo=True)

        self.context['owner'] = username

    def __set_user_as_admin(self, username, admin_group):
        self.log("User %s should be administrator! Rectifying that..." % username)
        self.execute('usermod -G %s %s' % (admin_group, username), stdout=False, sudo=True)
        self.log("User %s is administrator now!" % username)

    def __create_new_user(self, username, home_folder, groups, identified_by, default_script, is_admin):
        is_admin_command = " -G {}".format(self.__get_admin_group())
        command = "useradd -g %(group)s%(is_admin_command)s -s %(default_script)s -p %(password)s -d %(home_folder)s -m %(username)s"
        home_folder = home_folder or '/home/%s' % username
        group = groups and groups[0] or username
        self.log("User %s not found! Creating..." % username)
        self.execute(command % {
            'group': group or username,
            'is_admin_command': is_admin and is_admin_command or '',
            'password': identified_by or 'none',
            'home_folder': home_folder,
            'default_script': default_script,
            'username': username
        }, stdout=False, sudo=True)
        self.log("User %s created!" % username)

    def __ensure_initial_groups(self, groups, username):

        for user_group in groups:
            self.ensure_group(user_group)
        if not groups:
            self.ensure_group(username)

    def __get_admin_group(self):
        return 'wheel'

########NEW FILE########
__FILENAME__ = hostname
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide hostname utilities methods within CentOS distributions.
'''
from fabric.contrib.files import sed
from fabric.api import settings, hide

from provy.core import Role


class HostNameRole(Role):
    def ensure_hostname(self, hostname):

        '''
        Ensure a fixed hostname is configured in the server.

        :param hostname: Hostname to be created.
        :type hostname: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(HostNameRole) as role:
                        role.ensure_hostname('rabbit')
        '''

        if hostname == self.execute('hostname'):
            return False

        path = '/etc/sysconfig/network'

        file = self.read_remote_file(path)
        hostname_line = 'HOSTNAME={0}'.format(hostname)

        self.log('Setting up hostname')

        if 'HOSTNAME' not in file:
            self.ensure_line(hostname_line, stdout=False, sudo=True)
        else:
            with settings(hide('warnings', 'running', 'stdout')):
                sed(path, 'HOSTNAME=.*', hostname_line, use_sudo=True)

        self.execute(
            'hostname "{0}"'.format(hostname), stdout=False, sudo=True,
        )
        self.log('Hostname %s added' % hostname)
        return True

########NEW FILE########
__FILENAME__ = git
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Git <http://git-scm.com/>`_ repository creation operations within CentOS distributions.
'''

from provy.core import Role
from provy.more.centos.package.yum import YumRole


class GitRole(Role):
    '''
    This role provides utility methods for `Git <http://git-scm.com/>`_ repositories management within CentOS distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.centos import GitRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(GitRole) as role:
                    role.ensure_repository('git://github.com/python-provy/provy.git', '/home/user/provy',
                                           owner='user', branch='some-branch')
    '''

    def provision(self):
        '''
        Installs `Git <http://git-scm.com/>`_ dependencies.
        This method should be called upon if overriden in base classes, or `Git <http://git-scm.com/>`_ won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(GitRole) # does not need to be called if using with block.
        '''
        with self.using(YumRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('git-core')

    def ensure_repository(self, repo, path, owner=None, branch=None, sudo=True):
        '''
        Makes sure the repository is create in the remote server.
        This method does not update the repository or perform any operations in it. It is merely used to ensure that the repository exists in the specified path.

        :param repo: Git repository url.
        :type repo: :class:`str`
        :param path: Path to create the local repository.
        :type path: :class:`str`
        :param owner: User that owns the repository directory. Defaults to :data:`None`, using the current one in the remote server.
        :type owner: :class:`str`
        :param branch: If specified, the given branch will be checked-out, otherwise it stays in the master branch.
        :type branch: :class:`str`
        :param sudo: If :data:`False`, won't sudo when creating the repository. Defaults to :data:`True`.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.centos import GitRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(GitRole) as role:
                        role.ensure_repository('git://github.com/python-provy/provy.git', '/home/user/provy',
                                               owner='user', branch='some-branch')
        '''
        self.__clone_repository(path, repo, sudo, owner)
        self.__checkout_branch(branch, path, repo, sudo, owner)
        self.__normalize_ownership(owner, path)

    def __normalize_ownership(self, owner, path):
        if owner:
            self.change_path_owner(path, owner)

    def __checkout_branch(self, branch, path, repo, sudo, owner):
        branch_name = "# On branch %s" % branch
        if branch and not branch_name in self.execute("git --git-dir=\"%s/.git\" --work-tree=\"%s\" status" % (path, path),
                                                      sudo=True, stdout=False):
            self.log("Repository for %s is not in branch %s ! Switching..." % (repo, branch))
            self.execute('git --git-dir="%s/.git" --work-tree="%s" checkout %s' % (path, path, branch), sudo=sudo, user=owner)
            self.log("Repository %s currently in branch %s!" % (repo, branch))

    def __clone_repository(self, path, repo, sudo, owner):
        if not self.remote_exists_dir(path):
            self.log("Repository for %s does not exist! Cloning..." % repo)
            self.execute("git clone %s %s" % (repo, path), sudo=sudo, stdout=False, user=owner)
            self.log("Repository %s cloned!" % repo)

########NEW FILE########
__FILENAME__ = memcached
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Memcached <http://memcached.org/>`_ configuration and execution utilities within Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class MemcachedRole(Role):
    '''
    This role provides utility methods for `Memcached <http://memcached.org/>`_ configuration and execution within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import Memcached

        class MySampleRole(Role):
            def provision(self):
                with self.using(MemcachedRole) as role:
                    role.ensure_conf(verbose_level=2)
    '''

    def provision(self):
        '''
        Installs `Memcached <http://memcached.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or `Memcached <http://memcached.org/>`_ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MemcachedRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(MemcachedRole) # does not need to be called if using with block.
        '''

        self.register_template_loader('provy.more.debian.cache')

        with self.using(AptitudeRole) as role:
            role.ensure_package_installed('memcached')
            role.ensure_package_installed('libmemcached-dev')

    def ensure_conf(self,
                    owner=None,
                    log_folder='/var/log/memcached',
                    verbose_level=0,
                    memory_in_mb=64,
                    host='127.0.0.1',
                    port=11211,
                    user='nobody',
                    simultaneous_connections=1024,
                    lock_down=False,
                    error_when_memory_exhausted=False,
                    maximize_core_file_limit=False,
                    conf_path='/etc/memcached.conf'
                    ):
        '''
        Ensures that Memcached's configuration file at the specified path is up-to-date.

        :param owner: Owner of the config file. Defaults to root.
        :type owner: :class:`str`
        :param log_folder: Log memcached's output. Defaults to `/var/log/memcached`.
        :type log_folder: :class:`str`
        :param verbose_level: `0` for no verbosity, `1` for verbose, `2` for extra-verbose. Defaults to `0`.
        :type verbose_level: :class:`int`
        :param memory_in_mb: Start with a cap of 64 megs of memory. It's reasonable, and the daemon default.
            Note that the daemon will grow to this size, but does not start out holding this much memory.
        :type memory_in_mb: :class:`int`
        :param host: Specify which IP address to listen on. The default is to listen on all IP addresses.
            This parameter is one of the only security measures that memcached has, so make sure it's listening on a firewalled interface. Defaults to `127.0.0.1`.
        :type host: :class:`str`
        :param port: Default connection port is `11211`.
        :type port: :class:`int`
        :param user: Run the daemon as this user. Defaults to "nobody".
        :type user: :class:`str`
        :param simultaneous_connections: Limit the number of simultaneous incoming connections. The default is `1024`.
        :type simultaneous_connections: :class:`int`
        :param lock_down: Whether it should lock down all paged memory. Consult with the Memcached README and homepage before you do this. Defaults to :data:`False`.
        :type lock_down: :class:`bool`
        :param error_when_memory_exhausted: Whether it should return error when memory is exhausted (rather than removing items). Defaults to :data:`False`.
        :type error_when_memory_exhausted: :class:`bool`
        :param maximize_core_file_limit: Whether it should maximize core file limit. Defaults to :data:`False`.
        :type maximize_core_file_limit: :class:`bool`
        :param conf_path: The path that the configuration file will be in the remote server. Defaults to `/etc/memcached.conf`.
        :type conf_path: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MemcachedRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MemcachedRole) as role:
                        role.ensure_conf()
        '''

        if owner is None:
            owner = self.context['owner']

        options = {
            'log_folder': log_folder.rstrip('/'),
            'verbose_level': verbose_level,
            'memory_in_mb': memory_in_mb,
            'host': host,
            'port': port,
            'user': user,
            'simultaneous_connections': simultaneous_connections,
            'lock_down': lock_down,
            'error_when_memory_exhausted': error_when_memory_exhausted,
            'maximize_core_file_limit': maximize_core_file_limit
        }

        result = self.update_file('memcached.conf.template', conf_path, options=options, owner=owner, sudo=True)
        if result:
            self.log('memcached conf updated!')
            self.ensure_restart()

    def cleanup(self):
        '''
        Restarts memcached if it needs to be restarted (any changes made during this server's provisioning).

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MemcachedRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MemcachedRole) as role:
                        role.cleanup() # No need to call this if using a with block.
        '''
        super(MemcachedRole, self).cleanup()
        if 'must-restart-memcached' in self.context and self.context['must-restart-memcached']:
            self.restart()

    def ensure_restart(self):
        '''
        Ensures that Memcached is restarted on cleanup phase.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MemcachedRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MemcachedRole) as role:
                        role.ensure_restart() # No need to call this if using a with block.
        '''
        self.context['must-restart-memcached'] = True

    def restart(self):
        '''
        Forcefully restarts Memcached in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MemcachedRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MemcachedRole) as role:
                        if not self.is_process_running('memcached'):
                            role.restart()
        '''
        command = '/etc/init.d/memcached restart'
        self.execute(command, sudo=True)

########NEW FILE########
__FILENAME__ = varnish
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Varnish <https://www.varnish-cache.org/>`_ configuration and execution utilities within Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class VarnishRole(Role):
    '''
    This role provides utility methods for Varnish configuration and execution within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import VarnishRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(VarnishRole) as role:
                    role.ensure_vcl('default.vcl', owner='user')
                    role.ensure_conf('default_varnish', owner='user')
    '''

    def provision(self):
        '''
        Installs `Varnish <https://www.varnish-cache.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or Varnish won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(VarnishRole) # does not need to be called if using with block.
        '''

        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('varnish')

    def ensure_vcl(self, template, varnish_vcl_path='/etc/varnish/default.vcl', options={}, owner=None):
        '''
        Ensures that the VCL file at the specified path is up-to-date.

        :param template: The name of the VCL template file.
        :type template: :class:`str`
        :param varnish_vcl_path: The path that the VCL file will be in the remote server. Defaults to `/etc/varnish/default.vcl`.
        :type varnish_vcl_path: :class:`str`
        :param options: Dictionary of options to pass to the VCL template file. Extends context.
        :type options: :class:`dict`
        :param owner: Owner of the VCL file at the remote server. Defaults to :data:`None`.
        :type owner: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VarnishRole) as role:
                        role.ensure_vcl('default.vcl', owner='user')
        '''

        result = self.update_file(template, varnish_vcl_path, options=options, sudo=True, owner=owner)
        if result:
            self.log('varnish vcl updated!')
            self.ensure_restart()

    def ensure_conf(self, template, varnish_conf_path='/etc/default/varnish', options={}, owner=None):
        '''
        Ensures that Varnish's configuration file at the specified path is up-to-date.

        :param template: The name of the VCL template file.
        :type template: :class:`str`
        :param varnish_conf_path: The path that the configuration file will be in the remote server. Defaults to `/etc/default/varnish`.
        :type varnish_conf_path: :class:`str`
        :param options: Dictionary of options to pass to the configuration template file. Extends context.
        :type options: :class:`dict`
        :param owner: Owner of the configuration file at the remote server. Defaults to :data:`None`.
        :type owner: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VarnishRole) as role:
                        role.ensure_conf('default_varnish', owner='user')
        '''

        result = self.update_file(template, varnish_conf_path, options=options, sudo=True, owner=owner)
        if result:
            self.log('varnish conf updated!')
            self.ensure_restart()

    def cleanup(self):
        '''
        Restarts Varnish if it needs to be restarted (any changes made during this server's provisioning).

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VarnishRole) as role:
                        role.cleanup() # No need to call this if using a with block.
        '''
        super(VarnishRole, self).cleanup()
        if 'must-restart-varnish' in self.context and self.context['must-restart-varnish']:
            self.restart()

    def ensure_restart(self):
        '''
        Ensures that Varnish is restarted on cleanup phase.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VarnishRole) as role:
                        role.ensure_restart() # No need to call this if using a with block.
        '''
        self.context['must-restart-varnish'] = True

    def restart(self):
        '''
        Forcefully restarts Varnish in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VarnishRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VarnishRole) as role:
                        if not self.is_process_running('varnishd'):
                            role.restart()
        '''
        command = 'START=yes /etc/init.d/varnish restart'
        self.execute(command, sudo=True)

########NEW FILE########
__FILENAME__ = mongodb
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `MongoDB <http://www.mongodb.org/>`_ database management utilities for Debian distributions.
'''

from cStringIO import StringIO

from configobj import ConfigObj

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class MongoDBRole(Role):
    '''
    This role provides `MongoDB <http://www.mongodb.org/>`_ database management utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import MongoDBRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(MongoDBRole) as role:
                    role.restart()
    '''
    def provision(self):
        '''
        Installs `MongoDB <http://www.mongodb.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or MongoDB won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MongoDBRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(MongoDBRole) # no need to call this if using with block.
        '''
        distro_info = self.get_distro_info()

        self.log('Installing MongoDB via packages')

        if distro_info.distributor_id == 'Ubuntu':
            self.provision_to_ubuntu()
        else:
            self.provision_to_debian()

        self.log('MongoDB installed')

    def provision_to_debian(self):
        '''
        Installs MongoDB and its dependencies via Debian-specific repository.
        It's not recommended that you use this method directly; Instead, provision this role directly and it will find out the best way to provision.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MongoDBRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MongoDBRole) as mongo:
                        mongo.provision_to_debian()
        '''
        initialization_type = 'debian-sysvinit'
        self.__provision_with_init_type(initialization_type)

    def provision_to_ubuntu(self):
        '''
        Installs MongoDB and its dependencies via Ubuntu-specific repository.
        It's not recommended that you use this method directly; Instead, provision this role directly and it will find out the best way to provision.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MongoDBRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MongoDBRole) as mongo:
                        mongo.provision_to_ubuntu()
        '''
        initialization_type = 'ubuntu-upstart'
        self.__provision_with_init_type(initialization_type)

    def __provision_with_init_type(self, initialization_type):
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_gpg_key('http://docs.mongodb.org/10gen-gpg-key.asc')
            aptitude.ensure_aptitude_source('deb http://downloads-distro.mongodb.org/repo/%s dist 10gen' % initialization_type)
            aptitude.force_update()
            aptitude.ensure_package_installed('mongodb-10gen')

    def restart(self):
        '''
        Restarts the MongoDB database.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MongoDBRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MongoDBRole) as mongo:
                        mongo.restart()
        '''
        self.execute('service mongodb restart', sudo=True)

    def configure(self, configuration):
        '''
        Configures the MongoDB database according to a dictionary.

        .. note::
            Some important details about this method:

            * It will leave configuration items untouched if they're not changed;
            * It will create a new configuration item if it doesn't exist yet;
            * It will overwrite the configuration items defined in the original configuration by the ones defined in the `configuration` argument, if they have the same name;
            * It will convert boolean items to lowercase (like :data:`True` to "true"), when writing, to follow the `mongodb.conf` conventions;
            * It will leave file comments untouched, to avoid losing potentially important information;

        :param configuration: The intended configuration items.
        :type configuration: :class:`dict`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import MongoDBRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MongoDBRole) as mongo:
                        mongo.configure({
                            'port': 9876,
                            'replSet': 'my_replica_set',
                        })
        '''
        mongodb_config_path = '/etc/mongodb.conf'

        config = self.__config_from_remote(mongodb_config_path)
        self.__set_config_items(configuration, config)
        tmp_file = self.__tmp_file_with_config(config)

        self.put_file(from_file=tmp_file, to_file=mongodb_config_path, sudo=True)

    def __tmp_file_with_config(self, config):

        output_buffer = StringIO()
        config.write(output_buffer)
        tmp_file = self.write_to_temp_file(output_buffer.getvalue())
        return tmp_file

    def __config_from_remote(self, mongodb_config_path):

        config_content = self.read_remote_file(mongodb_config_path, sudo=True)
        config_buffer = StringIO(config_content)
        config = ConfigObj(infile=config_buffer)
        return config

    def __set_config_items(self, configuration, config):

        for key, value in configuration.items():
            if isinstance(value, bool):
                value = str(value).lower()
            config[key] = value

########NEW FILE########
__FILENAME__ = mysql
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `MySQL <http://www.mysql.com/>`_ database management utilities for Debian distributions.
'''

import re

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class MySQLRole(Role):
    '''
    This role provides `MySQL <http://www.mysql.com/>`_ database management utilities for Debian distributions.

    This role uses two context keys: `mysql_root_user` and `mysql_root_pass`. If none are found, it uses 'root' and empty password.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import MySQLRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(MySQLRole) as role:
                    role.ensure_user(username=self.context['mysql_user'], identified_by=self.context['mysql_password'])
                    role.ensure_database(self.context['mysql_database'], owner=self.context['mysql_user'])
    '''
    def __init__(self, prov, context):
        super(MySQLRole, self).__init__(prov, context)
        self.mysql_root_user = self.context.get('mysql_root_user', 'root')
        self.mysql_root_pass = self.context.get('mysql_root_pass', '')

    def provision(self):
        '''
        Installs `MySQL <http://www.mysql.com/>`_ Server and its dependencies.
        This method should be called upon if overriden in base classes, or MySQL won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(MySQLRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as role:
            self.execute('echo "mysql-server mysql-server/root_password select temppass" | debconf-set-selections',
                         stdout=False,
                         sudo=True)
            self.execute('echo "mysql-server mysql-server/root_password_again select temppass" | debconf-set-selections',
                         stdout=False,
                         sudo=True)
            result = role.ensure_package_installed('mysql-server')
            role.ensure_package_installed('mysql-client')
            role.ensure_package_installed('libmysqlclient-dev')

            if result:
                self.log("setting root user %s password..." % self.mysql_root_user)
                self.execute("mysqladmin -u %s -p'temppass' password '%s'" % (self.mysql_root_user, self.mysql_root_pass), stdout=False, sudo=True)

    def __execute_non_query(self, query):
        pass_string = ""
        if self.mysql_root_pass:
            pass_string = '--password="%s" ' % self.mysql_root_pass

        self.execute('mysql -u %s %s-e "%s" mysql' % (self.mysql_root_user, pass_string, query), stdout=False, sudo=True)

    def __execute_query(self, query):
        pass_string = ""
        if self.mysql_root_pass:
            pass_string = '--password="%s" ' % self.mysql_root_pass

        result = self.execute('mysql -u %s %s-E -e "%s" mysql' % (self.mysql_root_user, pass_string, query), stdout=False, sudo=True)
        rows = self.__get_rows(result)

        return rows

    def __get_rows(self, result):
        index_re = re.compile('(\d+)[.]')
        items = []
        item = None
        for line in result.split('\n'):
            if not line.strip():
                continue
            if line.startswith('*'):
                if item:
                    items.append(item)
                item = {
                    'index': index_re.search(line).groups()[0]
                }
            else:
                key, value = line.split(':', 1)
                item[key.strip()] = value.strip()
        if item:
            items.append(item)

        return items

    def get_user_hosts(self, username):
        '''
        Returns all the available hosts that this user can login from.

        :param username: Name of the user to be verified.
        :type username: :class:`str`
        :return: The user hosts.
        :rtype: :class:`list`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if not '%' in role.get_user_hosts('someuser'):
                            pass
        '''
        users = self.__execute_query("select Host from mysql.user where LOWER(User)='%s'" % username.lower())
        hosts = []
        if users:
            for user in users:
                hosts.append(user['Host'])

        return hosts

    def user_exists(self, username, login_from='%'):
        '''
        Returns :data:`True` if the given user exists for the given location in mysql server.

        :param username: Name of the user to be verified.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: Whether the user exists.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if not role.user_exists('someuser'):
                            pass
        '''
        return login_from in self.get_user_hosts(username)

    def ensure_user(self, username, identified_by, login_from='%'):
        '''
        Ensure the given user is created in the database and can login from the specified location.

        :param username: Name of the user to be created.
        :type username: :class:`str`
        :param identified_by: Password that the user will use to login to mysql server.
        :type identified_by: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: Whether the user had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_user('someuser', 'somepass', 'localhost')
        '''
        if not self.user_exists(username, login_from):
            self.__execute_non_query("CREATE USER '%s'@'%s' IDENTIFIED BY '%s';" % (username, login_from, identified_by))
            self.log("User %s not found with login access for %s. User created!" % (username, login_from))
            return True

        return False

    def is_database_present(self, database_name):
        '''
        Returns :data:`True` if the database is already created.

        :param database_name: Database to verify.
        :type database_name: :class:`str`
        :return: Whether the database is present or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.is_database_present('database'):
                            pass
        '''
        result = self.__execute_query('SHOW DATABASES')
        is_there = False
        if result:
            for row in result:
                if row['Database'].lower() == database_name.lower():
                    is_there = True

        return is_there

    def ensure_database(self, database_name):
        '''
        Creates the database if it does not exist.

        :param database_name: Database to create.
        :type database_name: :class:`str`
        :return: Whether the database had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_database('database')
        '''
        if not self.is_database_present(database_name):
            self.__execute_non_query('CREATE DATABASE %s' % database_name)
            self.log("Database %s not found. Database created!" % database_name)
            return True
        return False

    def get_user_grants(self, username, login_from='%'):
        '''
        Returns all grants for the given user at the given location.

        :param username: Name of the user to be verify.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :return: The user grants.
        :rtype: :class:`list`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.get_user_grants('user', login_from='%'):
                            pass
        '''
        grants = self.__execute_query("SHOW GRANTS FOR '%s'@'%s';" % (username, login_from))
        only_grants = []
        for grant in grants:
            filtered_grants = filter(lambda x: x.startswith('GRANT '), grant.itervalues())
            only_grants.extend(filtered_grants)

        return only_grants

    def has_grant(self, privileges, on, username, login_from, with_grant_option):
        '''
        Returns :data:`True` if the user has the specified privileges on the specified object in the given location.

        :param privileges: Privileges that are being verified.
        :type privileges: :class:`str`
        :param on: Database object that the user holds privileges on.
        :type on: :class:`str`
        :param username: Name of the user to be verify.
        :type username: :class:`str`
        :param login_from: Locations that this user can login from. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :param with_grant_option: Indicates if we are verifying against grant option.
        :type with_grant_option: :class:`bool`
        :return: Whether the user has the privileges or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        if role.has_grant('ALL PRIVILEGES',
                                          'database',
                                          'user',
                                          login_from='%',
                                          with_grant_option=True):
                            pass
        '''

        grants = self.get_user_grants(username, login_from)
        grant_option_string = self._get_grant_option_string(with_grant_option)
        privileges = self._get_privileges(privileges)
        grant_strings = self._get_possible_grant_strings(on, username, privileges, login_from, grant_option_string)

        for grant_string in grant_strings:
            if grant_string in grants:
                return True

        return False

    def _get_privileges(self, privileges):
        privileges = privileges.upper()
        if privileges == 'ALL':
            privileges = 'ALL PRIVILEGES'
        return privileges

    def _get_grant_option_string(self, with_grant_option):
        grant_option_string = ""
        if with_grant_option:
            grant_option_string = " WITH GRANT OPTION"
        return grant_option_string

    def _get_possible_grant_strings(self, on, username, privileges, login_from, grant_option_string):
        # These possible "ON" tokens are used because MySQL can behave differently depending on the version and system
        possible_on_tokens = [
            '`%s`.*' % on,
            '`%s`.`*`' % on,
            '%s.*' % on,
        ]
        grant_strings = ["GRANT %s ON %s TO '%s'@'%s'%s" % (privileges, on_token, username, login_from, grant_option_string)
                         for on_token in possible_on_tokens]
        return grant_strings

    def ensure_grant(self, privileges, on, username, login_from="%", with_grant_option=False):
        '''
        Ensures that the given user has the given privileges on the specified location.

        :param privileges: Privileges to assign to user (e.g.: "ALL PRIVILEGES").
        :type privileges: :class:`str`
        :param on: Object to assign privileges to. If only the name is supplied, '.*' will be appended to the name. If you want all databases pass '*.*'.
        :type on: :class:`str`
        :param username: User to grant the privileges to.
        :type username: :class:`str`
        :param login_from: Location where the user gets the grants. Defaults to '%' (anywhere).
        :type login_from: :class:`str`
        :param with_grant_option: If :data:`True`, indicates that this user may grant other users the same privileges. Defaults to :data:`False`.
        :type with_grant_option: :class:`bool`
        :return: Whether the grant had to be added or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(MySQLRole) as role:
                        role.ensure_grant('ALL PRIVILEGES',
                                          on='database',
                                          username='backend',
                                          login_from='%',
                                          with_grant_option=True)
        '''

        if self.has_grant(privileges, on, username, login_from, with_grant_option):
            return False

        grant_option_string = ""
        if with_grant_option:
            grant_option_string = " WITH GRANT OPTION"

        if not '.' in on:
            on = '%s.*' % on

        grant_string = "GRANT %s ON %s TO '%s'@'%s'%s" % (privileges, on, username, login_from, grant_option_string)
        self.__execute_non_query(grant_string)
        self.log("User %s@%s did not have grant '%s' on %s. Privileges granted!" % (username, login_from, privileges, on))

        return True

########NEW FILE########
__FILENAME__ = postgresql
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `PostgreSQL <http://www.postgresql.org/>`_ database management utilities for Debian distributions.
'''

from provy.more.base.database.postgresql import BasePostgreSQLRole
from provy.more.debian.package.aptitude import AptitudeRole


class PostgreSQLRole(BasePostgreSQLRole):
    '''
    This role provides `PostgreSQL <http://www.postgresql.org/>`_ database management utilities for Debian distributions.

    Take a look at :class:`provy.more.base.database.postgresql.BasePostgreSQLRole` for more available methods.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import PostgreSQLRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(PostgreSQLRole) as role:
                    role.ensure_user("john")
                    role.ensure_database("foo", owner="john")
    '''
    def provision(self):
        '''
        Installs `PostgreSQL <http://www.postgresql.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or PostgreSQL won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PostgreSQLRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as role:
            role.ensure_package_installed('postgresql')
            role.ensure_package_installed('postgresql-server-dev-%s' % self.__get_version())

    def __get_version(self):
        distro = self.get_distro_info()
        if distro.distributor_id.lower() == 'ubuntu':
            version = '9.2'
        else:
            version = '8.4'
        return version

########NEW FILE########
__FILENAME__ = redis
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Redis <http://redis.io/>`_ key-value store management utilities for Debian distributions.
'''

from provy.core import Role
from provy.more.debian import AptitudeRole


class RedisRole(Role):
    '''
    This role provides `Redis <http://redis.io/>`_ key-value store management utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import RedisRole

        class MySampleRole(Role):
            def provision(self):
                self.provision_role(RedisRole)
    '''

    def provision(self):
        '''
        Installs `Redis <http://redis.io/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or Redis won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(RedisRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('redis-server')
            aptitude.ensure_package_installed('python-redis')

########NEW FILE########
__FILENAME__ = rabbitmq
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `RabbitMQ <http://www.rabbitmq.com/>`_ utilities methods within Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

from fabric.utils import warn


GUEST_USER_WARNING = ('It is advisable to delete the guest user or change the'
                      ' password to something private, particularly if your broker'
                      ' is accessible publicly.')


class RabbitMqRole(Role):
    '''
    This role provides utility methods for `RabbitMQ <http://www.rabbitmq.com/>`_ utilities within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import RabbitMqRole
        from provy.more.debian import HostNameRole

        class MySampleRole(Role):
            def provision(self):

                with self.using(HostNameRole) as role:
                    # From rabbitmq docs [1]:
                    # "RabbitMQ names the database directory using the current
                    # hostname of the system. If the hostname changes, a new empty
                    # database is created.  To avoid data loss it's crucial to set
                    # up a fixed and resolvable hostname"
                    #
                    # [1] http://www.rabbitmq.com/ec2.html

                    role.ensure_hostname('rabbit')

                with self.using(RabbitMqRole) as role:
                    role.delete_user('guest')
                    role.ensure_user(
                        self.context['rabbit_user'],
                        self.context['rabbit_password'],
                    )
                    role.ensure_vhost(self.context['rabbit_vhost'])
                    role.ensure_permission(
                        self.context['rabbit_vhost'],
                        self.context['rabbit_user'],
                        '".*" ".*" ".*"',
                    )
    '''
    def provision(self):
        '''
        Installs `RabbitMQ <http://www.rabbitmq.com/>`_ and dependencies.
        This method should be called upon if overriden in base classes, or RabbitMQ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import HgRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(RabbitMqRole)
        '''
        with self.using(AptitudeRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('rabbitmq-server')

        # Start rabbitmq at startup, TODO: add update-rc.d role
        self.execute('update-rc.d rabbitmq-server defaults', stdout=False,
                     sudo=True)
        self.execute('update-rc.d rabbitmq-server enable', stdout=False, sudo=True)

        # Make sure rabbit is running:
        if not self.is_process_running('rabbitmq-server'):
            self.execute(
                'service rabbitmq-server start', stdout=False, sudo=True,
            )

        if self.user_exists('guest'):
            warn(GUEST_USER_WARNING)

    def user_exists(self, username):
        '''
        Checks if the RabbitMQ user exists.

        :param username: Name of the user to be checked.
        :type username: :class:`str`

        :return: Whether the user exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.user_exists('johndoe')
        '''
        cmd = 'rabbitmqctl list_users'
        users = self.execute(cmd, stdout=False, sudo=True)
        return username in users

    def vhost_exists(self, vhost):
        '''
        Checks if the RabbitMQ vhost exists.

        :param vhost: Name of the vhost to be checked.
        :type vhost: :class:`str`

        :return: Whether the vhost exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.vhost_exists('foobarhost')
        '''
        vhs = self.execute('rabbitmqctl list_vhosts', stdout=False, sudo=True)
        vhs = vhs.split('\r\n')[1:-1]
        return vhost in vhs

    def ensure_user(self, username, password, is_admin=False):
        '''
        Ensure the given user is created in the database and can authenticate with RabbitMQ.

        :param username: Name of the user to be created.
        :type username: :class:`str`
        :param password: Password that the user will use to authenticate to RabbitMQ.
        :type password: :class:`str`

        :return: Whether the user had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_user(some_user, some_pass)
        '''
        if not self.user_exists(username):
            self.log('Setting up user %s and password' % username)

            cmd = 'rabbitmqctl add_user %s %s' % (username, password)
            self.execute(cmd, sudo=True)

            if is_admin:
                cmd = 'rabbitmqctl set_user_tags %s administrator' % (username)
                self.execute(cmd, sudo=True)

            self.log('User %s added!' % username)
            return True

        return False

    def delete_user(self, user):
        '''
        Delete user from rabbitmq if exists

        :param user: Name of the user to be deleted.
        :type user: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.delete_user('guest', some_pass)
        '''
        if self.user_exists(user):
            self.log('User %s exists, deleting')

            cmd = 'rabbitmqctl delete_user %s' % user
            self.execute(cmd, stdout=False, sudo=True)

            self.log('User %s deleted' % user)

    def ensure_vhost(self, vhost):
        '''
        Ensure the given vhost is created.

        :param vhost: Name of the vhost to be checked/created.
        :type vhost: :class:`str`

        :return: Whether the vhost had to be created or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_vhost('/some_vhost')
        '''
        if not self.vhost_exists(vhost):
            self.log('Adding vhost %s' % vhost)

            self.execute('rabbitmqctl add_vhost %s' % vhost, sudo=True)

            self.log('vhost %s added!' % vhost)
            return True
        return False

    def ensure_permission(self, vhost, username, perms):
        '''
        Ensure the given user has the given permissions on the specified vhost

        :param vhost: Virtual host name to assign the permissions at.
        :type vhost: :class:`str`
        :param username: User to assign permissions to.
        :type username: :class:`str`
        :param perms: Permissions to assign to user (e.g.: '".*" ".*" ".*"').
        :type perms: :class:`str`

        :return: Whether the permissions could be assigned or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RabbitMqRole) as role:
                        role.ensure_permission(
                            'previous_created_vhost',
                            'previous_created_user',
                            '".*" ".*" ".*"',
                        )
        '''
        if not self.user_exists(username):
            msg = 'Cannot set permission: User %s doesn\'t exist' % username
            self.log(msg)
            return False

        if not self.vhost_exists(vhost):
            self.log('Cannot set permission: vhost %s doesn\'t exist' % vhost)
            return False

        msg = 'Setting up permissions for user %s on vhost %s'
        msg = msg % (username, vhost)
        self.log(msg)

        args = (vhost, username, perms)
        cmd = 'rabbitmqctl set_permissions -p %s %s %s' % args
        self.execute(cmd, stdout=False, sudo=True)

        return True

########NEW FILE########
__FILENAME__ = supervisor
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Supervisor <http://supervisord.org/>`_ monitoring utility methods for Debian distributions.
'''

from os.path import join

from provy.core import Role
from provy.more.debian.package.pip import PipRole

PROGRAMS_KEY = 'supervisor-programs'
CONFIG_KEY = 'supervisor-config'
MUST_UPDATE_CONFIG_KEY = 'must-update-supervisor-config'
MUST_RESTART_KEY = 'must-restart-supervisor'


class WithProgram(object):
    '''
    This class acts as the context manager for the :meth:`SupervisorRole.with_program` method.

    Don't use it directly; Instead, use the :meth:`SupervisorRole.with_program` method.
    '''
    def __init__(self, supervisor, name):
        self.supervisor = supervisor
        self.name = name
        self.directory = None
        self.command = None

        self.process_name = name + '-%(process_num)s'
        self.number_of_processes = 1
        self.priority = 100
        self.user = self.supervisor.context['owner']

        self.auto_start = True
        self.auto_restart = True
        self.start_retries = 3
        self.stop_signal = 'TERM'

        self.log_folder = '/var/log'
        self.log_file_max_mb = 1
        self.log_file_backups = 10

        self.environment = {}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if not self.directory or not self.command:
            raise RuntimeError('[Supervisor] Both directory and command properties must be specified for program %s' % self.name)

        if PROGRAMS_KEY not in self.supervisor.context:
            self.supervisor.context[PROGRAMS_KEY] = []

        env = []
        for key, value in self.environment.iteritems():
            env.append('%s="%s"' % (key, value))
        env = ",".join(env)

        self.supervisor.context[PROGRAMS_KEY].append({
            'name': self.name,
            'directory': self.directory,
            'command': self.command,
            'process_name': self.process_name,
            'number_of_processes': self.number_of_processes,
            'priority': self.priority,
            'user': self.user,
            'auto_start': self.auto_start,
            'auto_restart': self.auto_restart,
            'start_retries': self.start_retries,
            'stop_signal': self.stop_signal,
            'log_folder': self.log_folder,
            'log_file_max_mb': self.log_file_max_mb,
            'log_file_backups': self.log_file_backups,
            'environment': env
        })


class SupervisorRole(Role):
    '''
    This role provides `Supervisor <http://supervisord.org/>`_ monitoring utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import SupervisorRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(SupervisorRole) as role:
                    role.config(
                        config_file_directory='/home/backend',
                        log_folder='/home/backend/logs',
                        user=self.context['supervisor-user']
                    )

                    with role.with_program('website') as program:
                        program.directory = '/home/backend/provy/tests/functional'
                        program.command = 'python website.py 800%(process_num)s'
                        program.number_of_processes = 4

                        program.log_folder = '/home/backend/logs'
    '''

    def provision(self):
        '''
        Installs `Supervisor <http://supervisord.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or `Supervisor <http://supervisord.org/>`_ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(SupervisorRole) # no need to call this if using with block.
        '''
        self.register_template_loader('provy.more.debian.monitoring')

        with self.using(PipRole) as pip:
            pip.set_sudo()
            pip.ensure_package_installed('supervisor')

    def update_init_script(self, config_file_path):
        '''
        Creates a supervisord `/etc/init.d` script that points to the specified config file path.

        :param config_file_path: Path to the `supervisord.conf` at the server.
        :type config_file_path: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        role.update_init_script('/etc/supervisord.conf')
        '''

        options = {'config_file': join(config_file_path, 'supervisord.conf')}
        result = self.update_file('supervisord.init.template', '/etc/init.d/supervisord', owner=self.context['owner'], options=options, sudo=True)

        if result:
            self.execute('chmod +x /etc/init.d/supervisord', stdout=False, sudo=True)
            self.execute('update-rc.d supervisord defaults', stdout=False, sudo=True)
            self.ensure_restart()

    def ensure_config_update(self):
        '''
        Makes sure that the config file is updated upon cleanup.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        role.ensure_config_update()
        '''

        self.context[MUST_UPDATE_CONFIG_KEY] = True

    def config(self,
               config_file_directory=None,
               log_folder='/var/log',
               log_file_max_mb=50,
               log_file_backups=10,
               log_level='info',
               pidfile='/var/run/supervisord.pid',
               user=None):
        '''
        Configures supervisor by creating a supervisord.conf file at the specified location.

        :param config_file_directory: Directory to create the supervisord.conf file at the server.
        :type config_file_directory: :class:`str`
        :param log_folder: Path where log files will be created by supervisor. Defaults to `/var/log` (if you use the default, make sure your user has access).
        :type log_folder: :class:`str`
        :param log_file_max_mb: Maximum size of log file in megabytes. Defaults to 50.
        :type log_file_max_mb: :class:`int`
        :param log_file_backups: Number of log backups that supervisor keeps. Defaults to 10.
        :type log_file_backups: :class:`int`
        :param log_level: Level of logging for supervisor. Defaults to 'info'.
        :type log_level: :class:`str`
        :param pidfile: Path for the pidfile that supervisor creates for itself. Defaults to `/var/run/supervisor.pid` (if you use the default, make sure your user has access).
        :type pidfile: :class:`str`
        :param user: User that runs supervisor. Defaults to :data:`None`, which means the last created user.
        :type user: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        role.config(
                            config_file_directory='/home/backend',
                            log_folder='/home/backend/logs',
                            pidfile='/home/backend/supervisord.pid',
                            user='backend'
                        )
        '''
        self.log_folder = log_folder
        self.config_file_directory = config_file_directory,
        self.log_folder = log_folder
        self.log_file_max_mb = log_file_max_mb
        self.log_file_backups = log_file_backups
        self.log_level = log_level
        self.pidfile = pidfile
        self.user = user

        if config_file_directory is None:
            config_file_directory = '/home/%s' % self.context['owner']
        if user is None:
            user = self.context['owner']

        self.context[CONFIG_KEY] = {
            'config_file_directory': config_file_directory,
            'log_file': join(log_folder, 'supervisord.log'),
            'log_file_max_mb': log_file_max_mb,
            'log_file_backups': log_file_backups,
            'log_level': log_level,
            'pidfile': pidfile,
            'user': user
        }

        self.ensure_config_update()

    def with_program(self, name):
        '''
        Enters a with block with a :data:`program` variable that allows you to configure a program entry in supervisord.conf.

        :param name: Name of the program being supervised.
        :type name: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        with role.with_program('website') as program:
                            program.directory = '/home/backend/provy/tests/functional'
                            program.command = 'python website.py 800%(process_num)s'
                            program.number_of_processes = 4
                            program.log_folder = '/home/backend/logs'
        '''
        return WithProgram(self, name)

    def update_config_file(self):
        '''
        Updates the config file to match the configurations done under the :meth:`config` method.

        There's no need to call this method after :meth:`config`, since :meth:`SupervisorRole.cleanup` will call it for you.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        role.update_config_file()
        '''
        if CONFIG_KEY in self.context or PROGRAMS_KEY in self.context:
            if CONFIG_KEY not in self.context:
                self.config()

            config = self.context[CONFIG_KEY]

            conf_path = join(config['config_file_directory'], 'supervisord.conf')
            options = config

            if PROGRAMS_KEY in self.context:
                options['programs'] = self.context[PROGRAMS_KEY]

            result = self.update_file('supervisord.conf.template', conf_path, options=options, owner=self.context['owner'], sudo=True)

            if result:
                self.ensure_restart()

    def cleanup(self):
        '''
        Updates the config file and/or init files and restarts supervisor if needed.

        There's no need to call this method since provy's lifecycle will make sure it is called.
        '''
        super(SupervisorRole, self).cleanup()

        if MUST_UPDATE_CONFIG_KEY in self.context and self.context[MUST_UPDATE_CONFIG_KEY]:
            self.update_init_script(self.context[CONFIG_KEY]['config_file_directory'])
            self.update_config_file()

        if MUST_RESTART_KEY in self.context and self.context[MUST_RESTART_KEY]:
            self.restart()

    def ensure_restart(self):
        '''
        Makes sure supervisor is restarted on cleanup.

        There's no need to call this method since it will be called when changes occur by the other methods.
        '''

        self.context[MUST_RESTART_KEY] = True

    def restart(self):
        '''
        Forcefully restarts supervisor.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SupervisorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SupervisorRole) as role:
                        role.restart()
        '''
        if not self.is_process_running('supervisord'):
            command = '/etc/init.d/supervisord start'
        else:
            command = '/etc/init.d/supervisord restart'
        self.execute(command, sudo=True)

########NEW FILE########
__FILENAME__ = hosts
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide hosts management operations for debian distributions.
'''

from provy.more.linux.networking.hosts import HostsRole as Hosts


class HostsRole(Hosts):
    '''
    This role provides hosts file management utilities for debian distributions.

    This is just a class wrapper over :class:`provy.more.linux.networking.hosts.HostsRole`

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import HostsRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(HostsRole) as role:
                    role.ensure_host('localhost', '127.0.0.1')
    '''

########NEW FILE########
__FILENAME__ = aptitude
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the Aptitude package manager for Debian distributions.
'''

from base64 import b64encode
from os.path import join
from datetime import datetime, timedelta
import re
from urlparse import urlparse

from fabric.api import settings
from provy.core import Role


class AptitudeRole(Role):
    '''
    This role provides package management operations with Aptitude within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import AptitudeRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(AptitudeRole) as role:
                    role.ensure_package_installed('nginx')
    '''

    time_format = "%d-%m-%y %H:%M:%S"
    key = 'aptitude-up-to-date'
    aptitude = 'aptitude'

    def provision(self):
        '''
        Installs Aptitude dependencies. This method should be called upon if overriden in base classes, or Aptitude won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(AptitudeRole) # does not need to be called if using with block.
        '''

        if not self.is_package_installed('aptitude'):
            self.execute('apt-get install aptitude -y', stdout=False, sudo=True)

        self.ensure_up_to_date()
        self.ensure_package_installed('curl')

    def ensure_gpg_key(self, url):
        '''
        Ensures that the specified gpg key is imported into aptitude.

        :param url: URL of the gpg key file.
        :type url: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.ensure_gpg_key('http://some.url.com/to/key.gpg')
        '''
        command = "curl %s | apt-key add -" % url
        self.execute(command, stdout=False, sudo=True)

    def has_source(self, source_string):
        '''
        Returns :data:`True` if the specified repository is in aptitude's list of repositories.

        :param source_string: Repository string.
        :type source_string: :class:`str`
        :return: Whether the repository string is present or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        if role.has_source('deb http://www.las.ic.unicamp.br/pub/ubuntu/ natty main restricted'):
                            pass
        '''

        result = self.execute('grep -ilR \'^%s\' /etc/apt/sources.list /etc/apt/sources.list.d | wc -l' % source_string, stdout=False, sudo=True)
        return int(result) != 0

    def ensure_aptitude_source(self, source_string):
        '''
        Ensures that the specified repository is in aptitude's list of repositories.

        :param source_string: Repository string.
        :type source_string: :class:`str`
        :return: Whether the repository had to be added or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.ensure_aptitude_source('deb http://www.las.ic.unicamp.br/pub/ubuntu/ natty main restricted')
        '''
        if self.has_source(source_string):
            return False

        self.log("Aptitude source %s not found! Adding it..." % source_string)

        url = self.__parse_source_string(source_string)['uri']
        domain = urlparse(url).netloc
        source_file = '%s_%s' % (b64encode(source_string)[:12], domain)

        command = 'echo "%s" >> /etc/apt/sources.list.d/%s.list' % (source_string, source_file)
        self.execute(command, stdout=False, sudo=True)
        return True

    def __parse_source_string(self, source_string):
        parts = re.split('\s+', source_string, 3)
        return {'type': parts[0], 'uri': parts[1], 'distribution': parts[2], 'components': parts[3]}

    @property
    def update_date_file(self):
        '''
        Returns the path for the file that contains the last update date to aptitudes's list of packages.

        :return: The path to the file.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        file_path = role.update_date_file
        '''
        return join(self.remote_temp_dir(), 'last_aptitude_update')

    def store_update_date(self):
        '''
        Updates the date in the :meth:`update_date_file`.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.store_update_date()
        '''
        self.execute('echo "%s" > %s' % (datetime.now().strftime(self.time_format), self.update_date_file), stdout=False)

    def get_last_update_date(self):
        '''
        Returns the date in the :meth:`update_date_file`.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        last_update = role.get_last_update_date()
        '''
        if not self.remote_exists(self.update_date_file):
            return None

        date = datetime.strptime(self.read_remote_file(self.update_date_file), self.time_format)
        return date

    def ensure_up_to_date(self):
        '''
        Makes sure aptitude's repository is updated if it hasn't been updated in the last 30 minutes.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.ensure_up_to_date()
        '''
        last_updated = self.get_last_update_date()
        if not self.key in self.context and (not last_updated or (datetime.now() - last_updated > timedelta(minutes=30))):
            self.force_update()

    def force_update(self):
        '''
        Forces an update to aptitude's repository.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.force_update()
        '''
        self.log('Updating aptitude sources...')
        self.execute('%s update' % self.aptitude, stdout=False, sudo=True)
        self.store_update_date()
        self.log('Aptitude sources up-to-date')
        self.context[self.key] = True

    def is_package_installed(self, package_name):
        '''
        Returns :data:`True` if the given package is installed via aptitude, :data:`False` otherwise.

        :param package_name: Name of the package to verify.
        :type package_name: :class:`str`
        :return: Whether the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        if role.is_package_installed('nginx'):
                            pass
        '''
        with settings(warn_only=True):
            return package_name in self.execute("dpkg -l | egrep 'ii[ ]*%s\\b'" % package_name, stdout=False, sudo=True)

    def ensure_package_installed(self, package_name, stdout=False, sudo=True):
        '''
        Ensures that the given package is installed via aptitude.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`
        :param stdout: Indicates whether install progress should be shown to stdout. Defaults to :data:`False`.
        :type stdout: :class:`bool`
        :param sudo: Indicates whether the package should be installed with the super user. Defaults to :data:`True`.
        :type sudo: :class:`bool`
        :return: Whether the package had to be installed or not.
        :rtype: :class:`bool`
        :raise: :class:`provy.more.debian.PackageNotFound <provy.more.debian.package.aptitude.PackageNotFound>` if the package is not found in the repositories.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.ensure_package_installed('nginx')
        '''

        if not self.is_package_installed(package_name):
            self.__check_before_install(package_name)
            self.log('%s is not installed (via aptitude)! Installing...' % package_name)
            self.execute('%s install -y %s' % (self.aptitude, package_name), stdout=stdout, sudo=sudo)
            self.log('%s is installed (via aptitude).' % package_name)
            return True
        return False

    def __check_before_install(self, package_name):
        if not self.package_exists(package_name):
            raise PackageNotFound('Package "%s" not found in repositories' % package_name)

    def package_exists(self, package):
        '''
        Checks if the given package exists.

        :param package: Name of the package to check.
        :type package: :class:`str`
        :return: Whether the package exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AptitudeRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AptitudeRole) as role:
                        role.package_exists('nginx') # True
        '''
        try:
            return bool(self.execute('%s show %s' % (self.aptitude, package), stdout=False))
        except SystemExit:
            return False


class PackageNotFound(Exception):
    '''Should be raised when a package doesn't exist.'''

########NEW FILE########
__FILENAME__ = gem
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the `gem <http://docs.rubygems.org/>`_ package manager for Debian distributions.
'''

from fabric.api import settings

from provy.core import Role


UPDATE_ALTERNATIVES_COMMAND = """
update-alternatives --force --install /usr/bin/gem gem /usr/bin/gem{version} {priority} \
  --slave   /usr/share/man/man1/gem.1.gz gem.1.gz /usr/share/man/man1/gem{version}.1.gz
"""


class GemRole(Role):
    '''
    This role provides package management operations with `gem <http://docs.rubygems.org/>`_ within Debian distributions.

    If you wish to use a different Ruby version other than the default in provy, remember to set `version` and `priority` in the
    :class:`RubyRole <provy.more.debian.programming.ruby.RubyRole>` class.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import GemRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(GemRole) as role:
                    role.ensure_package_installed('activerecord', version='3.1.1')
    '''

    use_sudo = True

    def provision(self):
        '''
        Installs gem dependencies. This method should be called upon if overriden in base classes, or gem won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import PipRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PipRole) # does not need to be called if using with block.
        '''
        from provy.more.debian.programming.ruby import RubyRole
        self.provision_role(RubyRole)

        update_alternatives_command = UPDATE_ALTERNATIVES_COMMAND.format(
            version=RubyRole.version,
            priority=RubyRole.priority,
        )
        completion_command = 'ln - sf /etc/bash_completion.d/gem{version} /etc/alternatives/bash_completion_gem'.format(version=RubyRole.version)

        self.execute(update_alternatives_command, sudo=True)
        self.execute(completion_command, sudo=True)

    def is_package_installed(self, package_name, version=None):
        '''
        Returns :data:`True` if the given package is installed via gem in the remote server, :data:`False` otherwise.

        :param package_name: Name of the package to verify.
        :type package_name: :class:`str`
        :param version: Version to check for. Defaults to :data:`None`, which makes it check for any version.
        :type version: :class:`str`
        :return: Wheter the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import GemRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(GemRole) as role:
                        if role.is_package_installed('activerecord', version='3.1.1'):
                            pass
        '''
        with settings(warn_only=True):
            package_string = self.execute("gem list --local | tr '[A-Z]' '[a-z]' | grep %s%s" %
                                          (package_name, version and '(%s)' % version or ''),
                                          stdout=False, sudo=self.use_sudo)
            return package_name in package_string

    def ensure_package_installed(self, package_name, version=None):
        '''
        Makes sure the package is installed with the specified version (latest if :data:`None` specified).
        This method does not verify and upgrade the package on subsequent provisions, though.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`
        :param version: If specified, installs this version of the package. Installs latest version otherwise.
        :type version: :class:`str`

        Example::
        ::

            from provy.core import Role
            from provy.more.debian import GemRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(GemRole) as role:
                        role.ensure_package_installed('activerecord', version='3.1.1')
        '''
        if not self.is_package_installed(package_name):
            version_str = version and '(%s)' % version or ''
            self.log('%s is not installed (via gem)! Installing...' % package_name)
            self.execute('gem install %s%s' % (package_name, version_str), stdout=False, sudo=self.use_sudo)
            self.log('%s installed!' % package_name)
            return True

        return False

########NEW FILE########
__FILENAME__ = npm
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the `NPM <https://npmjs.org/>`_ package manager for Debian distributions.
'''

from fabric.api import settings
from provy.core import Role

from provy.more.debian.programming.nodejs import NodeJsRole


class NPMRole(Role):
    '''
    This role provides package management operations with `NPM <https://npmjs.org/>`_ within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import NPMRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(NPMRole) as role:
                    role.ensure_package_installed('socket.io', '0.6.17')
    '''

    time_format = "%d-%m-%y %H:%M:%S"
    key = 'npm-up-to-date'

    def provision(self):
        '''
        Installs NPM. This method should be called upon if overriden in base classes, or NPM won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NPMRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(NPMRole) # no need to call this if using with block.
        '''

        self.provision_role(NodeJsRole)

    def is_package_installed(self, package_name, version=None):
        '''
        Returns :data:`True` if the given package is installed via NPM, :data:`False` otherwise.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :param version: Version to check for. Defaults to :data:`None`, which makes it check for any version.
        :type version: :class:`str`
        :return: Whether the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NPMRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NPMRole) as role:
                        if role.is_package_installed('socket.io', '0.6.17'):
                            pass
        '''

        with settings(warn_only=True):
            if version:
                package_name = "%s@%s" % (package_name, version)
            return package_name in self.execute("npm --global list | egrep '%s'" % package_name, stdout=False, sudo=True)

    def ensure_package_installed(self, package_name, version=None, stdout=False, sudo=True):
        '''
        Ensures that the given package in the given version is installed via NPM.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`
        :param version: If specified, installs this version of the package. Installs latest version otherwise.
        :type version: :class:`str`
        :param stdout: Indicates whether install progress should be shown to stdout. Defaults to :data:`False`.
        :type stdout: :class:`bool`
        :param sudo: Indicates whether the package should be installed with the super user. Defaults to :data:`True`.
        :type sudo: :class:`bool`
        :return: Whether the package had to be installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NPMRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NPMRole) as role:
                        role.ensure_package_installed('socket.io', '0.6.17')
        '''

        if not self.is_package_installed(package_name, version):
            if version:
                package_name = "%s@%s" % (package_name, version)

            self.log('%s is not installed (via NPM)! Installing...' % package_name)
            self.execute('npm install --global %s' % package_name, stdout=stdout, sudo=sudo)
            self.log('%s is installed (via NPM).' % package_name)
            return True
        return False

########NEW FILE########
__FILENAME__ = pip
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provision packages installed via the `PIP <http://www.pip-installer.org/>`_ package manager for Debian distributions.
'''

from fabric.api import settings

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

import xmlrpclib


class PipRole(Role):
    '''
    This role provides package management operations with `PIP <http://www.pip-installer.org/>`_ within Debian distributions.

    By default, all commands executed with this role will be executed with sudo, unless you set a different user (refer to the :meth:`set_user` method below).

    You can also change the class parameters below in the class directly to have a global effect (use carefully!).

    :var use_sudo: If :data:`False`, the packages will be installed as normal user. Defaults to :data:`True`.
    :type use_sudo: :class:`bool`
    :var user: User through which the packages will be installed. Defaults to :data:`None`, which means that, using together with the default use_sudo, will install packages globally.
    :type user: :class:`str`

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import PipRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(PipRole) as role:
                    role.ensure_package_installed('django', version='1.1.1')
    '''

    use_sudo = True
    user = None

    def provision(self):
        '''
        Installs pip dependencies. This method should be called upon if overriden in base classes, or PIP won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PipRole) # does not need to be called if using with block.
        '''
        with self.using(AptitudeRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('python-setuptools')
            role.ensure_package_installed('python-dev')
        self.execute("easy_install pip", sudo=True, stdout=False, user=None)

    def extract_package_data_from_input(self, input_line):
        package_constraint = None
        input_line = input_line.strip()
        package_info = {
            "name": input_line
        }

        if input_line.startswith("-e") and "#egg=" in input_line:
            data = input_line.split("#egg=")
            package_info["name"] = data[1]
        elif "==" in input_line:
            package_constraint = "=="
        elif '>=' in input_line:
            package_constraint = ">="

        if package_constraint:
            package_info['version_constraint'] = package_constraint
            data = input_line.split(package_constraint)
            package_info["name"] = data[0]
            package_info["version"] = data[1]

        return package_info

    def is_package_installed(self, package_name, version=None):
        '''
        Returns :data:`True` if the given package is installed via pip in the remote server, :data:`False` otherwise.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :param version: Version to check for. Defaults to :data:`None`, which makes it check for any version.
        :type version: :class:`str`
        :return: Whether the package is installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        if role.is_package_installed('django', version='1.1.1'):
                            pass
        '''
        with settings(warn_only=True):
            package_info = self.extract_package_data_from_input(package_name)
            if not version:
                package_name = package_info['name']
            package_string = self.execute("pip freeze | tr '[A-Z]' '[a-z]' | grep %s" % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            if package_name in package_string:
                installed_version = package_string.split('==')[-1]
                if 'version' in package_info:
                    if '>=' == package_info['version_constraint']:
                        if installed_version < package_info['version']:
                            return False
                elif version and installed_version != version:
                    return False
                return True

    def get_package_remote_version(self, package_name):
        '''
        Returns the version of the package currently installed via PIP in the remote server. If package is not installed, returns :data:`None`.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: The package version.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        version = role.get_package_remote_version('django')
                        if version and version == '1.1.1':
                            pass
        '''
        with settings(warn_only=True):
            result = self.execute("pip freeze | tr '[A-Z]' '[a-z]' | grep %s" % package_name.lower(), stdout=False, sudo=self.use_sudo, user=self.user)
            if result:
                package, version = result.split('==')
                return version

            return None

    def get_package_latest_version(self, package_name):
        '''
        Returns the latest available version of the package at the Python Package Index. If package is not available, returns :data:`None`.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: The package version.
        :rtype: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        version = role.get_package_remote_version('django')
                        latest = role.get_package_latest_version('django')
                        if version != latest:
                            pass
                            # this check is not needed if you use ensure_package_up_to_date.
        '''
        pypi = xmlrpclib.ServerProxy('http://pypi.python.org/pypi')
        available = pypi.package_releases(package_name)
        if not available:
            # Try to capitalize pkg name
            available = pypi.package_releases(package_name.capitalize())

        if not available:
            return None

        return available[0]

    def package_can_be_updated(self, package_name):
        '''
        Returns :data:`True` if there is an update for the given package in the Python Package Index, False otherwise.

        :param package_name: Name of the package to verify
        :type package_name: :class:`str`
        :return: Whether the package can be updated.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        if role.package_can_be_updated('django'):
                            pass
                            # this check is not needed if you use ensure_package_up_to_date.
        '''
        remote_version = self.get_package_remote_version(package_name)
        latest_version = self.get_package_latest_version(package_name)

        return remote_version != latest_version

    def ensure_package_installed(self, package_name, version=None):
        '''
        Makes sure the package is installed with the specified version (latest if :data:`None` specified).
        This method does not verify and upgrade the package on subsequent provisions, though. Use :meth:`ensure_package_up_to_date` for this purpose instead.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`
        :param version: If specified, installs this version of the package. Installs latest version otherwise. You can use >= or <= before version number to ensure package version.
        :type version: :class:`str`
        :return: Whether the package had to be installed or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django', version='1.1.1')
        '''
        if version:
            package_info = self.extract_package_data_from_input(version)
            version_constraint = package_info.get('version_constraint', '==')
            version = package_info.get('version', version)
            if not self.is_package_installed(package_name, version):
                self.log('%s version %s should be installed (via pip)! Rectifying that...' % (package_name, version))
                self.execute('pip install %s%s%s' % (package_name, version_constraint, version), stdout=False, sudo=self.use_sudo, user=self.user)
                self.log('%s version %s installed!' % (package_name, version))
                return True
        elif not self.is_package_installed(package_name):
            self.log('%s is not installed (via pip)! Installing...' % package_name)
            self.execute('pip install %s' % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            self.log('%s installed!' % package_name)
            return True

        return False

    def ensure_requirements_installed(self, requirements_file_name):
        '''
        Makes sure the requirements file provided is installed.

        :param requirements_file_name: Path to the requirements file (can be provided as absolute path or relative to the directory where provy is run from).
        :type requirements_file_name: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_requirements_installed('/path/to/requirements.txt')
        '''

        with open(requirements_file_name, 'r') as requirements_file:
            for requirement in requirements_file.readlines():
                self.ensure_package_installed(requirement.strip())

    def ensure_package_up_to_date(self, package_name):
        '''
        Makes sure the package is installed and up-to-date with the latest version.
        This method verifies if there is a newer version for this package every time the server is provisioned. If a new version is found, it is installed.

        :param package_name: Name of the package to install.
        :type package_name: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_is_up_to_date('django')
        '''
        is_installed = self.is_package_installed(package_name)

        if is_installed and self.package_can_be_updated(package_name):
            self.log('%s is installed (via pip)! Updating...' % package_name)
            self.execute('pip install -U --no-dependencies %s' % package_name, stdout=False, sudo=self.use_sudo, user=self.user)
            self.log('%s updated!' % package_name)
            return True
        elif not is_installed:
            self.ensure_package_installed(package_name)
            return True

        self.log('%s is up to date (via pip).' % package_name)
        return False

    def set_user(self, user):
        '''
        Prepares the pip role instance to run its commands as a specific user.

        :param user: The username with which the role should run its commands.
        :type user: :class:`str`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django') # runs as sudo
                        role.set_user('johndoe')
                        role.ensure_package_installed('django') # runs as "johndoe" user
        '''

        self.user = user
        self.use_sudo = False

    def set_sudo(self):
        '''
        Prepares the pip role instance to run its commands with sudo; This is useful when you had previously set a user, and want it to run back as sudo.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(PipRole) as role:
                        role.ensure_package_installed('django') # runs as sudo
                        role.set_user('johndoe')
                        role.ensure_package_installed('django') # runs as "johndoe" user
                        role.set_sudo()
                        role.ensure_package_installed('django') # runs as sudo
        '''

        self.user = None
        self.use_sudo = True

########NEW FILE########
__FILENAME__ = virtualenv
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide virtual environments and run commands inside a `virtualenv <http://www.virtualenv.org/>`_, for Debian distributions.
'''

from contextlib import contextmanager
import os

from provy.core import Role


class VirtualenvRole(Role):
    '''
    This role provides `virtualenv <http://www.virtualenv.org/>`_ management.
    It also provides `virtualenvwrapper <http://www.doughellmann.com/projects/virtualenvwrapper/>`_ provisioning, although it's not internally used in this role.

    When using the object as a context manager (that is, using a `with` block) it will make sure that the virtual environment is created and that the commands
    that run inside it run within this same virtual environment (which affects, for example, the `python` and `pip` commands).

    If the virtual environment already exists, it just bypasses the creation procedure.

    :param env_name: Name of the virtual environment to be created and to keep activated when running commands inside the context manager.
    :type env_name: :class:`str`
    :param system_site_packages: If :data:`True`, will include system-wide site-packages in the virtual environment. Defaults to :data:`False`.
    :type system_site_packages: :class:`bool`
    :ivar base_directory: (:class:`str`) Directory where the virtual environment subdirectory will be put at.
        For example, if you set it as "/home/johndoe/my_envs", and use venv("some_env"), it will create a virtual environment at "/home/johndoe/my_envs/some_env".
        Defaults to $HOME/.virtualenvs (or :attr:`venv.user` `/.virtualenvs`, if the user is explicitly set - see below -).
    :ivar user: (:class:`str`) The user with which the virtual environment should be created. Defaults to the context user.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import VirtualenvRole

        class MySampleRole(Role):
            def provision(self):

                # this example uses the defaults provided
                with self.using(PipRole) as pip, self.using(VirtualenvRole) as venv, venv('fancylib'):
                    pip.ensure_package_installed('django')

                # this is when you want to set a different base virtualenv directory and user, and include the system-wide site-packages.
                with self.using(PipRole) as pip, self.using(VirtualenvRole) as venv:
                    venv.base_directory = '/home/johndoe/Envs'
                    venv.user = 'johndoe'
                    with venv('fancylib2', system_site_packages=True):
                        pip.ensure_package_installed('tornado')
    '''

    def __init__(self, prov, context):
        super(VirtualenvRole, self).__init__(prov, context)
        self.user = context['user']
        self.base_directory = None

    def get_base_directory(self):
        '''
        Gets the base directory that will be used to create the virtual environment.

        By default, it returns a subdir under the current venv user home and ".virtualenvs".
        If you wish to change the directory where it gets created, just set :attr:`role.base_directory <base_directory>`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VirtualenvRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VirtualenvRole) as venv:
                        venv.user = 'johndoe'
                        venv.get_base_directory() # "/home/johndoe/.virtualenvs"
                        venv.base_directory = '/home/johndoe/Envs'
                        venv.get_base_directory() # "/home/johndoe/Envs"
        '''
        return self.base_directory or os.path.join(self.__get_user_dir(), '.virtualenvs')

    def __get_user_dir(self):
        if self.user == 'root':
            return '/root'
        else:
            return '/home/%s' % self.user

    def env_dir(self, env_name):
        '''
        Gets the virtual environment directory for a given environment name.

        Please note that this doesn't check if the env actually exists.

        :param env_name: Name of the virtual environment to be used to build a directory string.
        :type env_name: :class:`str`
        :return: The directory to be used.
        :rtype: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VirtualenvRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VirtualenvRole) as venv, venv('fancylib'):
                        venv.env_dir('fancylib')
        '''
        return os.path.join(self.get_base_directory(), env_name)

    @contextmanager
    def __call__(self, env_name, system_site_packages=False):
        from fabric.api import prefix

        if not self.env_exists(env_name):
            self.create_env(env_name, system_site_packages=system_site_packages)

        with prefix('source %s/bin/activate' % self.env_dir(env_name)):
            yield

    def provision(self):
        '''
        Installs virtualenv and virtualenvwrapper, and their dependencies.
        This method should be called upon if overriden in base classes, or virtualenv won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VirtualenvRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(VirtualenvRole) # does not need to be called if using with block.
        '''

        from provy.more.debian import PipRole

        with self.using(PipRole) as pip:
            pip.ensure_package_installed('virtualenv')
            pip.ensure_package_installed('virtualenvwrapper')

    def create_env(self, env_name, system_site_packages=False):
        '''
        Creates a virtual environment.

        :param env_name: Name of the virtual environment to be created.
        :type env_name: :class:`str`
        :param system_site_packages: If :data:`True`, will include system-wide site-packages in the virtual environment. Defaults to :data:`False`.
        :type system_site_packages: :class:`bool`

        Examples:
        ::

            from provy.core import Role
            from provy.more.debian import VirtualenvRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VirtualenvRole) as venv:
                        env_dir = venv.create_env('fancylib') # will return the directory where the virtual environment was created
        '''
        env_dir = self.env_dir(env_name)
        site_packages_arg = '--system-site-packages ' if system_site_packages else ''
        self.execute('virtualenv %s%s' % (site_packages_arg, env_dir), user=self.user)
        return env_dir

    def env_exists(self, env_name):
        '''
        Checks if a virtual environment exists.

        :param env_name: Name of the virtual environment to be checked.
        :type env_name: :class:`str`
        :return: Whether the virtual environment exists.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import VirtualenvRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(VirtualenvRole) as venv:
                        venv.env_exists('fancylib') # True or False
        '''
        return self.remote_exists_dir(self.env_dir(env_name))

########NEW FILE########
__FILENAME__ = nodejs
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Node.js <http://nodejs.org/>`_ utility methods for Debian and Ubuntu distributions.
'''

import re

from fabric.api import cd, settings

from provy.core import Role
from provy.more.debian import AptitudeRole


class NodeJsRole(Role):
    '''
    This role provides `Node.js <http://nodejs.org/>`_ utilities for Debian and Ubuntu distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import NodeJsRole

        class MySampleRole(Role):
            def provision(self):
                self.provision_role(NodeJsRole)
    '''

    def provision(self):
        '''
        Installs `Node.js <http://nodejs.org/>`_, `NPM <https://npmjs.org/>`_ and their dependencies.
        This method should be called upon if overriden in base classes, or Node won't work properly in the remote server.

        If the server is a Debian, will install via source packages, if it's Ubuntu, will install via
        `Chris Lea's official PPA repository <https://launchpad.net/~chris-lea/+archive/node.js/>`_.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NodeJsRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(NodeJsRole) # no need to call this if using with block.
        '''
        if self.is_already_installed():
            return

        distro_info = self.get_distro_info()

        if distro_info.distributor_id == 'Ubuntu':
            self.log('Installing Node.JS and NPM via PPA packages')
            self.provision_to_ubuntu()
        else:
            self.log('Installing Node.JS and NPM via source packages')
            self.provision_to_debian()

        self.log('Node.JS and NPM installed')

    def provision_to_debian(self):
        '''
        Installs `Node.js <http://nodejs.org/>`_, `NPM <https://npmjs.org/>`_ and their dependencies via source packages.

        It's not recommended that you use this method directly; Instead, provision this role directly and it will find out the best way to provision.

        Also, this method doesn't check if Node.js is already installed before provisioning it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NodeJsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NodeJsRole) as nodejs:
                        nodejs.provision_to_debian()
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('g++')

        installer_directory = '/tmp/nodejs'

        self.ensure_dir(installer_directory, sudo=True)

        with cd(installer_directory):
            self.execute('wget -N http://nodejs.org/dist/node-latest.tar.gz', sudo=True)
            self.execute('tar xzvf node-latest.tar.gz && cd `ls -rd node-v*` && ./configure && make install', sudo=True)

    def provision_to_ubuntu(self):
        '''
        Installs `Node.js <http://nodejs.org/>`_, `NPM <https://npmjs.org/>`_ and their dependencies via
        `Chris Lea's official PPA repository <https://launchpad.net/~chris-lea/+archive/node.js/>`_.

        It's not recommended that you use this method directly; Instead, provision this role directly and it will find out the best way to provision.

        Also, this method doesn't check if Node.js is already installed before provisioning it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NodeJsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NodeJsRole) as nodejs:
                        nodejs.provision_to_ubuntu()
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('python-software-properties')

        self.execute('add-apt-repository ppa:chris-lea/node.js', sudo=True)

        aptitude.force_update()
        aptitude.ensure_package_installed('nodejs')
        aptitude.ensure_package_installed('npm')
        aptitude.ensure_package_installed('nodejs-dev')

    def is_already_installed(self):
        '''
        Checks if Node.js is already installed on the server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NodeJsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NodeJsRole) as nodejs:
                        nodejs.is_already_installed() # True or False
        '''
        with settings(warn_only=True):
            result = self.execute('node --version')

        if not result:
            return False

        return bool(re.match(r'v[\d]', result))

########NEW FILE########
__FILENAME__ = php
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `PHP <http://php.net/>`_ utilities for Debian and Ubuntu distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class PHPRole(Role):
    '''
    This role provides `PHP <http://php.net/>`_ utilities for Debian distributions.

    Additionally, installs php5-dev (PHP source libraries), php-pear (PHP package management) and php5-fpm (FastCGI implementation for PHP which can be used with Nginx).

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import PHPRole

        class MySampleRole(Role):
            def provision(self):
                self.provision_role(PHPRole)
    '''

    def provision(self):
        '''
        Installs PHP 5 (probably 5.3, depending on your server) and its dependencies.

        If your server is a Debian (non-derived) machine, it also adds the `dotdeb <http://www.dotdeb.org/about/>`_ repositories for PHP 5.3,
        so that you can use them with :class:`AptitudeRole <provy.more.debian.package.aptitude.AptitudeRole>` to install what you need.

        This method should be called upon if overriden in base classes, or PHP won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import PHPRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(PHPRole) # no need to call this if using with block.
        '''

        with self.using(AptitudeRole) as aptitude:
            self.__prepare_repositories(aptitude)

            aptitude.ensure_package_installed('php5-dev')
            aptitude.ensure_package_installed('php5-fpm')
            aptitude.ensure_package_installed('php-pear')

    def __prepare_repositories(self, aptitude):
        distro_info = self.get_distro_info()
        if distro_info.distributor_id == 'Debian':
            aptitude.ensure_aptitude_source('deb http://packages.dotdeb.org squeeze all')
            aptitude.ensure_aptitude_source('deb-src http://packages.dotdeb.org squeeze all')

            aptitude.ensure_gpg_key('http://www.dotdeb.org/dotdeb.gpg')
            aptitude.force_update()

########NEW FILE########
__FILENAME__ = ruby
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Ruby <http://www.ruby-lang.org/>`_ utility methods for Debian distributions.
'''

from provy.core import Role
from provy.more.debian import AptitudeRole


UPDATE_ALTERNATIVES_COMMAND = """
update-alternatives --force --install /usr/bin/ruby ruby /usr/bin/ruby{version} {priority} \
  --slave   /usr/share/man/man1/ruby.1.gz ruby.1.gz /usr/share/man/man1/ruby{version}.1.gz \
  --slave   /usr/bin/ri ri /usr/bin/ri{version} \
  --slave   /usr/share/man/man1/ri.1.gz ri.1.gz /usr/share/man/man1/ri{version}.1.gz \
  --slave   /usr/bin/irb irb /usr/bin/irb{version} \
  --slave   /usr/share/man/man1/irb.1.gz irb.1.gz /usr/share/man/man1/irb{version}.1.gz \
  --slave   /usr/bin/erb erb /usr/bin/erb{version} \
  --slave   /usr/share/man/man1/erb.1.gz erb.1.gz /usr/share/man/man1/erb{version}.1.gz \
  --slave   /usr/bin/rdoc rdoc /usr/bin/rdoc{version} \
  --slave   /usr/share/man/man1/rdoc.1.gz rdoc.1.gz /usr/share/man/man1/rdoc{version}.1.gz \
  --slave   /usr/bin/testrb testrb /usr/bin/testrb{version} \
  --slave   /usr/share/man/man1/testrb.1.gz testrb.1.gz /usr/share/man/man1/testrb{version}.1.gz
"""


class RubyRole(Role):
    '''
    This role provides `Ruby <http://www.ruby-lang.org/>`_ utilities for Debian distributions.

    :var version: Ruby version to install. By default, install package "1.9.1" - which, in effect, refers to "1.9.2" (only uses the "1.9.1" name for compatibility reasons).
    :type version: :class:`str`
    :var priority: Priority to attribute to this Ruby version in the server. By default, it's 400 - which is already higher than the default Ruby installation in some Debian-like systems -.
    :type priority: :class:`int`

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import RubyRole

        class MySampleRole(Role):
            def provision(self):
                self.provision_role(RubyRole)

                # Now, suppose we want the new Ruby installed, but not as the default one:
                RubyRole.version = 1.8
                RubyRole.priority = 10
                self.provision_role(RubyRole)
                RubyRole.version = 1.9.1
                RubyRole.priority = 1
                self.provision_role(RubyRole)
                # As priority 10 wins over 1, Ruby 1.8 will be used as the default "ruby" executable.
    '''

    version = '1.9.1'
    priority = 400

    def provision(self):
        '''
        Installs `Ruby <http://www.ruby-lang.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or Ruby won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RubyRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(RubyRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_up_to_date()
            aptitude.ensure_package_installed('ruby{version}-full'.format(version=self.version))

            update_alternatives_command = UPDATE_ALTERNATIVES_COMMAND.format(
                version=self.version,
                priority=self.priority,
            )
            self.execute(update_alternatives_command, sudo=True)

########NEW FILE########
__FILENAME__ = apparmor
from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

'''
Roles in this namespace are meant to provide `AppArmor <http://wiki.apparmor.net/>`_ management utilities for Debian distributions.
'''


class AppArmorRole(Role):
    '''
    This role provides `AppArmor <http://wiki.apparmor.net/>`_ utilities for Debian distributions.

    .. warning::

        If you're provisioning a Debian Wheezy server or older, it's highly recommended you use :class:`SELinuxRole <provy.more.debian.security.selinux.SELinuxRole>` instead of this one.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import AppArmorRole

        class MySampleRole(Role):
            def provision(self):

                with self.using(AppArmorRole) as apparmor:
                    apparmor.disable("/bin/ping", "/sbin/dhclient")

                with self.using(AppArmorRole) as apparmor:
                    apparmor.create("/usr/sbin/nginx", policy_groups=['networking', 'user-application'],
                                    read=["/srv/my-site"], read_and_write=["/srv/my-site/uploads"])
    '''

    def provision(self):
        '''
        Installs AppArmor profiles and utilities.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(AppArmorRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('apparmor-profiles')
            aptitude.ensure_package_installed('apparmor-utils')

    def __execute_batch(self, command, executables):
        arguments = ' '.join(executables)
        command += ' %s' % arguments
        self.execute(command, stdout=False, sudo=True)

    def disable(self, *executables):
        '''
        Disables executables in AppArmor, removing them from confinement - that is, they will not be under vigilance anymore -.

        :param executables: The executables to change.
        :type executables: positional arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AppArmorRole) as apparmor:
                        apparmor.disable("/bin/ping", "/sbin/dhclient")
        '''
        self.__execute_batch('aa-disable', executables)

    def complain(self, *executables):
        '''
        Puts the executables to complain mode - the policies are not enforced, but when they're broken, the action gets logged -.

        :param executables: The executables to change.
        :type executables: positional arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AppArmorRole) as apparmor:
                        apparmor.complain("/bin/ping", "/sbin/dhclient")
        '''
        self.__execute_batch('aa-complain', executables)

    def enforce(self, *executables):
        '''
        Puts the executables to enforce mode - the policies are enforced, but only break attempts will be logged -.

        :param executables: The executables to change.
        :type executables: positional arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AppArmorRole) as apparmor:
                        apparmor.enforce("/bin/ping", "/sbin/dhclient")
        '''
        self.__execute_batch('aa-enforce', executables)

    def audit(self, *executables):
        '''
        Puts the executables to audit mode - the policies are enforced, and all actions (legal and ilegal ones) will be logged -.

        :param executables: The executables to change.
        :type executables: positional arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AppArmorRole) as apparmor:
                        apparmor.audit("/bin/ping", "/sbin/dhclient")
        '''
        self.__execute_batch('aa-audit', executables)

    def create(self, executable, template=None, policy_groups=None, abstractions=None, read=[], read_and_write=[]):
        '''
        Creates a profile for an executable. Please refer to the `aa-easyprof manual pages <http://manpages.ubuntu.com/manpages/precise/man8/aa-easyprof.8.html>`_ for more documentation.

        :param executable: The executable to be referenced by the profile being created.
        :type executable: :class:`str`
        :param template: If provided, will be used instead of the "default" one. Defaults to :data:`None`.
        :type template: :class:`str`
        :param policy_groups: If provided, use its items as the policy groups. Defaults to :data:`None`.
        :type policy_groups: :data:`iterable`
        :param abstractions: If provided, use its items as the abstractions. Defaults to :data:`None`.
        :type abstractions: :data:`iterable`
        :param read: If provided, paths to be readable by the executable. Defaults to :data:`[]` (empty list).
        :type read: :data:`iterable`
        :param read_and_write: If provided, paths to be readable and writable by the executable (there's no need to provide the "read" argument in this case). Defaults to :data:`[]` (empty list).
        :type read_and_write: :data:`iterable`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import AppArmorRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(AppArmorRole) as apparmor:
                        apparmor.create("/usr/sbin/nginx", policy_groups=['networking', 'user-application'],
                                        read=["/srv/my-site"], read_and_write=["/srv/my-site/uploads"])
        '''
        command = 'aa-easyprof'
        if template is not None:
            command += ' -t %s' % template
        if policy_groups is not None:
            groups = ','.join(policy_groups)
            command += ' -p %s' % groups
        if abstractions is not None:
            abstr = ','.join(abstractions)
            command += ' -a %s' % abstr
        for path in read:
            command += ' -r %s' % path
        for path in read_and_write:
            command += ' -w %s' % path
        command += ' %s' % executable
        self.execute(command, stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = iptables
from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

'''
Roles in this namespace are meant to provide `iptables <http://www.netfilter.org/>`_ management utilities for Debian distributions.
'''


class IPTablesRole(Role):
    '''
    This role provides `iptables <http://www.netfilter.org/>`_ utilities for Debian distributions.

    .. note::

        There are two important behaviors to notice:

        1. Right after iptables is installed, this role allows TCP incoming connections to port 22, so that provy can still continue to provision the server through SSH.

        2. Right before exiting the `with using(IPTablesRole)` block, it blocks all other ports and protocols, so that the server is secure by default.

        So, when using this role, remember to allow all the ports with protocols that you need, otherwise you might not be able to connect to the services you provision later on.

    :param block_on_finish: If :data:`False`, doesn't block other ports and protocols when finishing the usage of this role. Defaults to :data:`True`.
    :type block_on_finish: :class:`bool`

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import IPTablesRole

        class MySampleRole(Role):
            def provision(self):

                # this example allows only incoming HTTP connections
                with self.using(IPTablesRole) as iptables:
                    iptables.allow('http')

                # this example allows any incoming connections, but block SSH outgoing connections
                with self.using(IPTablesRole) as iptables:
                    iptables.block_on_finish = False
                    iptables.reject(22, direction="out") # here we used a number, but could be "ssh" as well

                # this example allows established sessions in interface eth0
                with self.using(IPTablesRole) as iptables:
                    iptables.allow(interface='eth0', match='state', state='ESTABLISHED,RELATED')
    '''

    DIRECTION_TO_CHAIN_MAP = {
        "in": "INPUT",
        "out": "OUTPUT",
        "forward": "FORWARD",
    }

    def __init__(self, prov, context):
        super(IPTablesRole, self).__init__(prov, context)
        self.block_on_finish = True

    def provision(self):
        '''
        Installs iptables and its dependencies, if they're not already installed (though this is usually the case).

        Also, it adds an `ACCEPT` rule for SSH (TCP/22), so that provy can continue to provision the server, and the user doesn't get locked out of it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(IPTablesRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('iptables')
            self.allow('ssh')

    def list_rules(self):
        '''
        Lists the currently configured rules and returns them as a multiline string. Equivalent to running:

        .. code-block:: sh

            $ sudo iptables -L

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        iptables.list_rules()
        '''
        return self.execute('iptables -L', stdout=True, sudo=True)

    def list_rules_with_commands(self):
        '''
        Like :meth:`list_rules`, but showing the rules as executable commands. Equivalent to running:

        .. code-block:: sh

            $ sudo iptables-save

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        iptables.list_rules_with_commands()
        '''
        return self.execute('iptables-save', stdout=True, sudo=True)

    def schedule_cleanup(self):
        '''
        Apart from the core cleanup, this one also blocks other ports and protocols not allowed earlier ("catch-all" as the last rule)
        and saves the iptables rules to the iptables config file, so that it's not lost upon restart.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        self.schedule_cleanup() # no need to call this explicitly
        '''
        super(IPTablesRole, self).schedule_cleanup()
        if self.block_on_finish:
            self.reject()
        self.execute("iptables-save > /etc/iptables.rules", stdout=False, sudo=True)

    def __change_rule(self, policy, port, direction, protocol, interface, match=None, **options):
        chain = self.DIRECTION_TO_CHAIN_MAP[direction]
        command = "iptables -A %s -j %s -p %s" % (chain, policy, protocol)
        if interface is not None:
            command += " -i %s" % interface
        if port is not None:
            command += " --dport %s" % port
        if match is not None:
            command += " -m %s" % match
        for option_name in options:
            command += " --%s %s" % (option_name, options[option_name])
        self.execute(command, stdout=False, sudo=True)

    def allow(self, port=None, direction="in", protocol="tcp", interface=None, match=None, **options):
        '''
        Allows connections to be made to or from the server.

        :param port: Port to be used. Defaults to None, which means all ports will be allowed. Defaults to :data:`None`.
        :type port: :class:`int` or :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server), "out" (connections coming from the server to the outside) or "forward" (packet routing). Defaults to "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by iptables (like "udp", "icmp" etc). Defaults to "tcp".
        :type protocol: :class:`str`
        :param interface: The network interface to which the rule is bound to. Defaults to :data:`None` (bound to all).
        :type interface: :class:`str`
        :param match: Match filter. Defaults to :data:`None`.
        :type match: :class:`str`
        :param options: Arbitrary of arbitrary options that will be used in conjunction to the match filters.
        :type options: Keyword arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        iptables.allow(port=11211, direction="out", protocol="udp") # allow UDP connections to an external Memcached server.
        '''
        self.__change_rule("ACCEPT", port, direction, protocol, interface, match, **options)

    def reject(self, port=None, direction="in", protocol="all", interface=None, match=None, **options):
        '''
        Rejects connections to be made to or from the server, responding with a "connection refused" packet.

        :param port: Port to be used. Defaults to None, which means all ports will be allowed.
        :type port: :class:`int` or :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server), "out" (connections coming from the server to the outside) or "forward" (packet routing). Defaults to "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by iptables (like "udp", "icmp" etc). Defaults to "all".
        :type protocol: :class:`str`
        :param interface: The network interface to which the rule is bound to. Defaults to :data:`None` (bound to all).
        :type interface: :class:`str`
        :param match: Match filter. Defaults to :data:`None`.
        :type match: :class:`str`
        :param options: Arbitrary of arbitrary options that will be used in conjunction to the match filters.
        :type options: Keyword arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        iptables.reject(port=11211, direction="out", protocol="udp") # reject UDP connections to an external Memcached server.
        '''
        self.__change_rule("REJECT", port, direction, protocol, interface, match, **options)

    def drop(self, port=None, direction="in", protocol="all", interface=None, match=None, **options):
        '''
        Drop connections to be made to or from the server, without responding anything to the client (drop packets on the ground).

        :param port: Port to be used. Defaults to None, which means all ports will be allowed.
        :type port: :class:`int` or :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server), "out" (connections coming from the server to the outside) or "forward" (packet routing). Defaults to "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by iptables (like "udp", "icmp" etc). Defaults to "all".
        :type protocol: :class:`str`
        :param interface: The network interface to which the rule is bound to. Defaults to :data:`None` (bound to all).
        :type interface: :class:`str`
        :param match: Match filter. Defaults to :data:`None`.
        :type match: :class:`str`
        :param options: Arbitrary of arbitrary options that will be used in conjunction to the match filters.
        :type options: Keyword arguments of :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import IPTablesRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(IPTablesRole) as iptables:
                        iptables.drop(port=11211, direction="out", protocol="udp") # drop UDP connections to an external Memcached server.
        '''
        self.__change_rule("DROP", port, direction, protocol, interface, match, **options)

########NEW FILE########
__FILENAME__ = selinux
import fabric.api

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

'''
Roles in this namespace are meant to provide `SELinux <http://selinuxproject.org/>`_ management utilities for Debian distributions.
'''


class SELinuxRole(Role):
    '''
    This role provides `SELinux <http://selinuxproject.org/>`_ utilities for Debian distributions.

    .. warning::

        If you're provisioning a Ubuntu server, it's highly recommended you use :class:`AppArmorRole <provy.more.debian.security.apparmor.AppArmorRole>` instead of this one.

        Please note that, for SELinux to be installed from scratch, you have to reboot the server so that it relabels all the files in the system for SELinux.
        So it's also highly recommended that you provision a server that has SELinux installed and activated already.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import SELinuxRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(SELinuxRole) as selinux:
                    selinux.ensure_login_mapping("foo")
                    selinux.map_login("foo", "staff_u")
                    selinux.map_role("foo", ["staff_r", "sysadm_r"])
    '''

    def __init__(self, prov, context):
        super(SELinuxRole, self).__init__(prov, context)

    def __distro_is_ubuntu(self):
        distro_info = self.get_distro_info()
        return distro_info.distributor_id.lower() == 'ubuntu'

    def provision(self):
        '''
        Installs SELinux, its dependencies, its utilities and the `Audit framework <https://www.wzdftpd.net/docs/selinux/audit.html>`_.

        Also, it activates SELinux after installing the packages, puts the system in enforce mode and puts the generic users into confinement for enhanced security.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(SELinuxRole) # no need to call this if using with block.
        '''
        self.install_packages()
        self.activate()

        self.log('''SELinux provisioned. Don't forget to reboot the server if it didn't have SELinux already installed and activated.''')

    def install_packages(self):
        '''
        Installs the necessary packages to provision SELinux.

        This is executed during provisioning, so you can ignore this method.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.install_packages() # no need to call this directly.
        '''
        with self.using(AptitudeRole) as aptitude:
            if self.__distro_is_ubuntu():
                aptitude.ensure_package_installed('selinux')
            else:
                aptitude.ensure_package_installed('selinux-basics')
                aptitude.ensure_package_installed('selinux-policy-default')
            aptitude.ensure_package_installed('selinux-utils')
            aptitude.ensure_package_installed('auditd')
            aptitude.ensure_package_installed('audispd-plugins')

    def activate(self):
        '''
        Activates SELinux, confines generic users and puts the system into enforce mode.

        This is executed during provisioning, so you can ignore this method.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.activate() # no need to call this directly.
        '''
        if not self.__distro_is_ubuntu():
            self.execute('selinux-activate', stdout=False, sudo=True)
        self.__confine_generic_users()
        self.enforce()

    def __confine_generic_users(self):
        self.execute("semanage login -m -s 'user_u' -r s0 __default__", stdout=False, sudo=True)

    def enforce(self):
        '''
        Puts the system into enforce mode.

        This is executed during provisioning, so you can ignore this method.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.enforce() # no need to call this directly.
        '''
        with fabric.api.settings(warn_only=True):
            self.execute('setenforce 1', stdout=False, sudo=True)
            self.ensure_line('SELINUX=enforcing', '/etc/selinux/config', sudo=True)

    def ensure_login_mapping(self, user_or_group):
        '''
        Makes sure that a mapping exists for a login user to an SELinux user (if creating one now, sets it to the "user_u" SELinux user).

        :param user_or_group: The user or group to be changed. If providing a group, pass it with an "@" before the group name (like "@my-group").
        :type user_or_group: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.ensure_login_mapping("foo")
                        selinux.ensure_login_mapping("@bar")
        '''
        with fabric.api.settings(warn_only=True):
            self.execute('semanage login -a %s' % user_or_group, stdout=False, sudo=True)

    def map_login(self, user_or_group, selinux_user):
        '''
        Maps a login user to an SELinux user.

        If the login user has no mapping yet, the role creates one.

        :param user_or_group: The user or group to be changed. If providing a group, pass it with an "@" before the group name (like "@my-group").
        :type user_or_group: :class:`str`
        :param selinux_user: The SELinux user to be referenced.
        :type selinux_user: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.map_login("foo", "staff_u")
        '''
        self.ensure_login_mapping(user_or_group)
        self.execute('semanage login -m -s %s %s' % (selinux_user, user_or_group), stdout=False, sudo=True)

    def map_role(self, user_or_group, selinux_roles):
        '''
        Maps a login user to one or more SELinux roles.

        If the login user has no mapping yet, the role creates one.

        :param user_or_group: The user or group to be changed. If providing a group, pass it with an "@" before the group name (like "@my-group").
        :type user_or_group: :class:`str`
        :param selinux_roles: The roles to be referenced.
        :type selinux_roles: :class:`iterable`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SELinuxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SELinuxRole) as selinux:
                        selinux.map_role("foo", ["staff_r", "sysadm_r"])
        '''
        self.ensure_login_mapping(user_or_group)
        roles_as_string = ' '.join(selinux_roles)
        self.execute("semanage user -m -R '%s' %s" % (roles_as_string, user_or_group), stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = ufw
from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole

'''
Roles in this namespace are meant to provide `UncomplicatedFireWall <https://help.ubuntu.com/community/UFW>`_ management utilities for Debian distributions.
'''


class UFWRole(Role):
    '''
    This role provides `UncomplicatedFireWall <https://help.ubuntu.com/community/UFW>`_ utilities for Debian distributions.

    .. note::
        There are two important behaviors to notice:

        1. Right after ufw is installed, this role allows TCP and UDP (in and out) connections to port 22, so that provy can still continue to provision the server through SSH.
        2. Right before exiting the "with using(UFWRole)" block, it enables ufw, which blocks all other ports and protocols, so that the server is secure by default.

        So, when using this role, remember to allow all the ports with protocols that you need, otherwise you might not be able to connect to the services you provision later on.

    :param block_on_finish: If :data:`False`, doesn't block other ports and protocols when finishing the usage of this role. Defaults to :data:`True`.
    :type block_on_finish: :class:`bool`

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import UFWRole

        class MySampleRole(Role):
            def provision(self):

                # this example allows only incoming HTTP connections
                with self.using(UFWRole) as ufw:
                    ufw.allow('http')

                # this example blocks SSH outgoing connections
                with self.using(UFWRole) as ufw:
                    ufw.reject(22, direction="out") # here we used a number, but could be "ssh" as well
    '''

    def provision(self):
        '''
        Installs ufw and its dependencies, if they're not already installed.

        Also, it allows ssh (TCP+UDP/22), so that provy can continue to provision the server, and the user doesn't get locked out of it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UFWRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(UFWRole) # no need to call this if using with block.
        '''
        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('ufw')

        self.execute('ufw allow ssh', stdout=False, sudo=True)

    def schedule_cleanup(self):
        '''
        Apart from the core cleanup, this one also enables the firewall.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UFWRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UFWRole) as ufw:
                        self.schedule_cleanup() # no need to call this explicitly
        '''
        super(UFWRole, self).schedule_cleanup()
        self.execute("ufw --force enable", stdout=False, sudo=True)

    def __change(self, action_name, direction, port_or_query, protocol):
        command = 'ufw %s ' % action_name
        if direction is not None:
            command += '%s ' % direction
        command += str(port_or_query)
        if protocol is not None:
            command += '/%s' % protocol
        self.execute(command, stdout=False, sudo=True)

    def allow(self, port_or_query, protocol=None, direction=None):
        '''
        Allows connections to be made to or from the server.

        :param port_or_query: Port to be used, or a full query specification. If you use a full query, there's no sense in providing the other arguments.
        :type port_or_query: :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server) or "out" (connections coming from the server to the outside). Defaults to :data:`None`, making ufw use the default of "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by ufw (like "udp", "icmp" etc). By default, it changes for "tcp" and "udp".
        :type protocol: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UFWRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UFWRole) as ufw:
                        ufw.allow(11211, protocol="udp", direction="out") # allow UDP connections to an external Memcached server.
        '''
        self.__change('allow', direction, port_or_query, protocol)

    def drop(self, port_or_query, protocol=None, direction=None):
        '''
        Drop connections to be made to or from the server, without responding anything to the client (drop packets on the ground).

        :param port_or_query: Port to be used, or a full query specification. If you use a full query, there's no sense in providing the other arguments.
        :type port_or_query: :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server) or "out" (connections coming from the server to the outside). Defaults to :data:`None`, making ufw use the default of "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by ufw (like "udp", "icmp" etc). By default, it changes for "tcp" and "udp".
        :type protocol: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UFWRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UFWRole) as ufw:
                        ufw.drop(port=11211, direction="out", protocol="udp") # drop UDP connections to an external Memcached server.
        '''
        self.__change('deny', direction, port_or_query, protocol)

    def reject(self, port_or_query, protocol=None, direction=None):
        '''
        Rejects connections to be made to or from the server, responding with a "connection refused" packet.

        :param port_or_query: Port to be used, or a full query specification. If you use a full query, there's no sense in providing the other arguments.
        :type port_or_query: :class:`str`
        :param direction: Direction of the connection related to the server. Can be either "in" (connections coming into the server) or "out" (connections coming from the server to the outside). Defaults to :data:`None`, making ufw use the default of "in".
        :type direction: :class:`str`
        :param protocol: Protocol to be used - choose one that is understandable by ufw (like "udp", "icmp" etc). By default, it changes for "tcp" and "udp".
        :type protocol: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UFWRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UFWRole) as ufw:
                        ufw.reject(port=11211, direction="out", protocol="udp") # reject UDP connections to an external Memcached server.
        '''
        self.__change('reject', direction, port_or_query, protocol)

########NEW FILE########
__FILENAME__ = passwd_utils
# -*- coding: utf-8 -*-

import crypt
from random import SystemRandom


def random_salt_function(salt_len=12):
    """
    Creates random salt for password.

    :param salt_len: Length of salt. Default :data:`12`
    :type param: :class:`int`

    :return: Computed salt
    :rtype: str
    """
    charset = "abcdefghijklmnopqrstuxyz"
    charset = charset + charset.upper() + '1234567890'
    chars = []
    rand = SystemRandom()
    for _ in range(salt_len):
        chars.append(rand.choice(charset))
    return "".join(chars)


def hash_password_function(password, salt=None, magic="6"):
    """
    Hashes password using `crypt` function on local machine (which is not harmfull,
    since these hashes are well-specified.

    :param password: Plaintext password to be hashed.
    :type password: :class:`str`
    :param salt: Salt to be used with this password, if None will
        use random password.
    :type salt: :class:`str`
    :param magic: Specifies salt type. Default :data:`6` which means
        use `sha-512`. For all appropriate values refer
        to http://man7.org/linux/man-pages/man3/crypt.3.html#NOTES, or
        (even better) consult `man 3 crypt` on your system.
    :type salt: :class:`str` or :class:`int`

    :return: remote password
    """

    magic = str(magic)

    if salt is None:
        salt = random_salt_function()

    salt = "${magic}${salt}".format(magic=magic, salt=salt)

    return crypt.crypt(password, salt)

########NEW FILE########
__FILENAME__ = ssh
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide SSH keygen utilities for Debian distributions.
'''

from os.path import join

from Crypto.PublicKey import RSA

from provy.core import Role


class SSHRole(Role):
    '''
    This role provides SSH keygen utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import SSHRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(SSHRole) as role:
                    role.ensure_ssh_key(user='someuser', private_key_file="private-key")
    '''

    def ensure_ssh_key(self, user, private_key_file):
        '''
        Ensures that the specified private ssh key is present in the remote server. Also creates the public key for this private key.

        The private key file must be a template and be accessible to the :meth:`Role.render <provy.core.roles.Role.render>` method.

        :param user: Owner of the keys.
        :type user: :class:`str`
        :param private_key_file: Template file for the private key.
        :type private_key_file: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import SSHRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(SSHRole) as role:
                        role.ensure_ssh_key(user='someuser', private_key_file="private-key")

        '''
        path = '/home/%s' % user
        ssh_path = join(path, '.ssh')
        self.ensure_dir(ssh_path, sudo=True, owner=user)
        private_key = self.render(private_key_file)

        key = RSA.importKey(private_key)
        public_key = key.publickey().exportKey(format='OpenSSH')

        self.__write_keys(user, private_key, public_key)

    def __write_keys(self, user, private_key, public_key):
        path = '/home/%s' % user
        ssh_path = join(path, '.ssh')
        pub_path = join(ssh_path, 'id_rsa.pub')
        priv_path = join(ssh_path, 'id_rsa')

        host = self.execute_python('import os; print os.uname()[1]', stdout=False)
        host_str = "%s@%s" % (user, host)

        pub_text = "%s %s" % (public_key, host_str)
        pub_file = self.write_to_temp_file(pub_text)
        priv_file = self.write_to_temp_file(private_key)
        result_pub = self.update_file(pub_file, pub_path, sudo=True, owner=user)
        result_priv = self.update_file(priv_file, priv_path, sudo=True, owner=user)

        if result_pub or result_priv:
            self.log("SSH keys generated at server!")
            self.log("Public key:")
            self.log(pub_text)

########NEW FILE########
__FILENAME__ = user
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''Roles in this namespace are meant to provide user management operations for Debian distributions.'''


import StringIO

from provy.core import Role


class UserRole(Role):
    '''
    This role provides many utility methods for user management operations within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import UserRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(UserRole) as role:
                    role.ensure_user('myuser', identified_by='mypass', is_admin=True)
    '''

    def group_exists(self, group_name):
        '''
        Returns :data:`True` if the given group exist, :data:`False` otherwise.

        :param group_name: Name of the group to verify.
        :type group_name: :class:`str`
        :return: Whether the group exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.group_exists('usersgroup'):
                            pass
        '''
        values = self.__first_values_from('group')
        return group_name in values

    def __first_values_from(self, basename):
        values = self.execute("cat /etc/%s | cut -d ':' -f 1" % basename, stdout=False, sudo=True)
        values = values.strip().split()
        return values

    def user_exists(self, username):
        '''
        Returns :data:`True` if the given user exist, :data:`False` otherwise.

        :param username: Name of the user to verify.
        :type username: :class:`str`
        :return: Whether the user exists or not.
        :rtype: :class:`bool`

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.user_exists('myuser'):
                            pass
        '''
        values = self.__first_values_from('passwd')
        return username in values

    def user_in_group(self, username, group_name):
        '''
        Returns :data:`True` if the given user is in the given group, :data:`False` otherwise.

        :param username: Name of the user to verify.
        :type username: :class:`str`
        :param group_name: Name of the group to verify.
        :type group_name: :class:`str`
        :return: Whether the user pertains to the group or not.
        :rtype: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        if role.user_in_group('myuser', 'mygroup'):
                            pass
        '''
        raw_groups = self.execute('groups %s' % username, sudo=True, stdout=False).strip()
        if not raw_groups.startswith(username):
            raise ValueError("User '%s' doesn't exist" % username)
        groups_string = raw_groups.replace('%s : ' % username, '')
        groups = groups_string.split()
        return group_name in groups

    def ensure_group(self, group_name, group_id=None):
        '''
        Ensures that a given user group is present in the remote server.

        :param group_name: Name of the group to create.
        :type group_name: :class:`str`
        :param group_id: GID of the group. Defaults to :data:`None`, which assigns the next available GID.
        :type group_id: :class:`int`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        role.ensure_group('users-group')
        '''
        if not self.group_exists(group_name):
            self.log("Group %s not found! Creating..." % group_name)
            if not group_id:
                self.execute('groupadd %s' % group_name, stdout=False, sudo=True)
            else:
                self.execute('groupadd --gid %s %s' % (group_id, group_name), stdout=False, sudo=True)
            self.log("Group %s created!" % group_name)

    def ensure_user_groups(self, username, groups=[]):
        for user_group in groups:
            if not self.user_in_group(username, user_group):
                self.log("User %s should be in group %s! Rectifying that..." % (username, user_group))
                self.execute('usermod -G %s %s' % (user_group, username), stdout=False, sudo=True)
                self.log("User %s is in group %s now!" % (username, user_group))

    def ensure_user(self, username, identified_by=None, home_folder=None,
                    default_script="/bin/bash", groups=[], is_admin=False, password_encrypted=False):
        '''
        Ensures that a given user is present in the remote server.

        :param username: Name of the user.
        :type username: :class:`str`
        :param identified_by: Password that the user will use to login to the remote server. If set to :data:`None`, the user will not have a password.
        :type identified_by: :class:`str`
        :param home_folder: Specifies the user's home folder. Defaults to `/home/<username>`.
        :type home_folder: :class:`str`
        :param default_script: Sets the user's default script, the one that will execute commands per default when logging in. Defaults to `/bin/sh`.
        :type default_script: :class:`str`
        :param groups: Groups that this user belongs to. If the groups do not exist they are created prior to user creation. Defaults to the name of the user.
        :type groups: :class:`iterable`
        :param is_admin: If set to :data:`True` the user is added to the 'admin' (or 'sudo' if provisioning to Ubuntu) user group as well. Defaults to :data:`False`.
        :type is_admin: :class:`bool`
        :param password_encrypted:
            If set to :data:`True` password is considered to be in ecrypted form
            (as found in /etc/shadow). To generate encrypted form of password you
            may use :func:`provy.more.debian.users.passwd_utils.hash_password_function`.
            defaults to :data:`False`
        :type password_encrypted: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import UserRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(UserRole) as role:
                        role.ensure_user('myuser', identified_by='mypass', is_admin=True)
        '''

        admin_group = self.__get_admin_group()
        self.__ensure_initial_groups(groups, username)

        if not self.user_exists(username):
            self.__create_new_user(username, home_folder, groups, default_script, is_admin)
        elif is_admin and not self.user_in_group(username, admin_group):
            self.__set_user_as_admin(username, admin_group)

        self.ensure_user_groups(username, groups)

        self.set_user_password(username, identified_by, password_encrypted)

        self.context['owner'] = username

    def __set_user_as_admin(self, username, admin_group):
        self.log("User %s should be administrator! Rectifying that..." % username)
        self.execute('usermod -G %s %s' % (admin_group, username), stdout=False, sudo=True)
        self.log("User %s is administrator now!" % username)

    def __create_new_user(self, username, home_folder, groups, default_script, is_admin):
        is_admin_command = " -G {}".format(self.__get_admin_group())
        command = "useradd -g %(group)s%(is_admin_command)s -s %(default_script)s -d %(home_folder)s -m %(username)s"
        home_folder = home_folder or '/home/%s' % username
        group = groups and groups[0] or username
        self.log("User %s not found! Creating..." % username)
        self.execute(command % {
            'group': group or username,
            'is_admin_command': is_admin and is_admin_command or '',
            'home_folder': home_folder,
            'default_script': default_script,
            'username': username
        }, stdout=False, sudo=True)
        self.log("User %s created!" % username)

    def __ensure_initial_groups(self, groups, username):

        for user_group in groups:
            self.ensure_group(user_group)
        if not groups:
            self.ensure_group(username)

    def __get_admin_group(self):

        distro_info = self.get_distro_info()
        if distro_info.distributor_id == 'Ubuntu':
            admin_group = 'sudo'
        else:
            admin_group = 'admin'
        return admin_group

    def set_user_password(self, username, password, encrypted=False):
        """
        Sets user password.

        :param username: Name of user for which to update password
        :type username: :class:`str`
        :param password: Password to set
        :type password: :class:`str`
        :param encrypted: If :data:`True` it meas that `password` is encrypted,
            (that is in hashed format), else it means password is in plaintext.
        :type encrypted: :class:`bool`

        """

        tmp_file = self.create_remote_temp_file()

        password_line = "{username}:{password}".format(
            username=username,
            password=password
        )

        self.put_file(StringIO.StringIO(password_line), tmp_file, sudo=True, stdout=False)

        command = 'cat "{tmp_file}" | chpasswd {encrypted}'.format(
            encrypted="-e" if encrypted else "",
            tmp_file=tmp_file
        )

        self.execute(command, stdout=False, sudo=True)

        self.remove_file(tmp_file, sudo=True)

########NEW FILE########
__FILENAME__ = git
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Git <http://git-scm.com/>`_ repository creation operations within Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class GitRole(Role):
    '''
    This role provides utility methods for `Git <http://git-scm.com/>`_ repositories management within Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import GitRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(GitRole) as role:
                    role.ensure_repository('git://github.com/python-provy/provy.git', '/home/user/provy',
                                           owner='user', branch='some-branch')
    '''

    def provision(self):
        '''
        Installs `Git <http://git-scm.com/>`_ dependencies.
        This method should be called upon if overriden in base classes, or `Git <http://git-scm.com/>`_ won't work properly in the remote server.

        Example:
        ::

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(GitRole) # does not need to be called if using with block.
        '''
        with self.using(AptitudeRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('git-core')

    def ensure_repository(self, repo, path, owner=None, branch=None, sudo=True):
        '''
        Makes sure the repository is create in the remote server.
        This method does not update the repository or perform any operations in it. It is merely used to ensure that the repository exists in the specified path.

        :param repo: Git repository url.
        :type repo: :class:`str`
        :param path: Path to create the local repository.
        :type path: :class:`str`
        :param owner: User that owns the repository directory. Defaults to :data:`None`, using the current one in the remote server.
        :type owner: :class:`str`
        :param branch: If specified, the given branch will be checked-out, otherwise it stays in the master branch.
        :type branch: :class:`str`
        :param sudo: If :data:`False`, won't sudo when creating the repository. Defaults to :data:`True`.
        :type sudo: :class:`bool`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import GitRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(GitRole) as role:
                        role.ensure_repository('git://github.com/python-provy/provy.git', '/home/user/provy',
                                               owner='user', branch='some-branch')
        '''
        self.__clone_repository(path, repo, sudo, owner)
        self.__checkout_branch(branch, path, repo, sudo, owner)
        self.__normalize_ownership(owner, path)

    def __normalize_ownership(self, owner, path):
        if owner:
            self.change_path_owner(path, owner)

    def __checkout_branch(self, branch, path, repo, sudo, owner):
        branch_name = "# On branch %s" % branch
        if branch and not branch_name in self.execute("git --git-dir=\"%s/.git\" --work-tree=\"%s\" status" % (path, path),
                                                      sudo=True, stdout=False):
            self.log("Repository for %s is not in branch %s ! Switching..." % (repo, branch))
            self.execute('git --git-dir="%s/.git" --work-tree="%s" checkout %s' % (path, path, branch), sudo=sudo, user=owner)
            self.log("Repository %s currently in branch %s!" % (repo, branch))

    def __clone_repository(self, path, repo, sudo, owner):
        if not self.remote_exists_dir(path):
            self.log("Repository for %s does not exist! Cloning..." % repo)
            self.execute("git clone %s %s" % (repo, path), sudo=sudo, stdout=False, user=owner)
            self.log("Repository %s cloned!" % repo)

########NEW FILE########
__FILENAME__ = apache
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Apache HTTP Server <http://httpd.apache.org/>`_ utility methods for Debian distributions.
'''

from fabric.api import settings

from provy.core.roles import Role
from provy.more.debian import AptitudeRole


class ApacheRole(Role):
    '''
    This role provides `Apache HTTP Server <http://httpd.apache.org/>`_ management utilities for Debian distributions.

    Provisions with apache2 as default, that is, it uses the apache2-mpm-worker variant.

    If you want to use the apache2-mpm-prefork variant, just use install this package with :class:`AptitudeRole <provy.more.debian.package.aptitude.AptitudeRole>` and restart Apache.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import ApacheRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(ApacheRole) as role:
                    role.ensure_mod('php5') # Installs and enables mod_php
                    role.ensure_site_disabled('default')
                    role.create_site(site='my-site', template='my-site')
                    role.ensure_site_enabled('my-site')
    '''

    def __available_site_for(self, name):
        return '/etc/apache2/sites-available/%s' % name

    def __enabled_site_for(self, name):
        return '/etc/apache2/sites-enabled/%s' % name

    def __init__(self, prov, context):
        super(ApacheRole, self).__init__(prov, context)
        self.must_restart = False

    def provision(self):
        '''
        Installs `Apache <http://httpd.apache.org/>`_ dependencies. This method should be called upon if overriden in base classes, or Apache won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(ApacheRole) # does not need to be called if using with block.
        '''

        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('apache2')

    def cleanup(self):
        '''
        Restarts Apache if any changes have been made.

        There's no need to call this method manually.
        '''
        super(ApacheRole, self).cleanup()
        if self.must_restart:
            self.restart()

    def ensure_mod(self, mod):
        '''
        Installs the module package and enables it in Apache.

        :param mod: Name of the module to enable.
        :type mod: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.ensure_mod('php5') # Installs "libapache2-mod-php5" and enables it
        '''

        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('libapache2-mod-%s' % mod)

        self.execute('a2enmod %s' % mod, sudo=True)
        self.ensure_restart()

    def create_site(self, site, template, options={}):
        '''
        Adds a website with the specified template to Apache list of available sites.

        .. warning::

            Do not forget to call :meth:`ensure_site_enabled` after a call to create_site, or your site won't be enabled.

        :param site: Name of the site to enable.
        :type site: :class:`str`
        :param template: Site configuration template.
        :type template: :class:`str`
        :param options: Options to pass to the template. Defaults to empty dict (:data:`{}`).
        :type options: :class:`dict`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.create_site(site='my-site', template='my-site', options={
                            "foo": "bar"
                        })
        '''

        self.update_file(template, self.__available_site_for(site), options=options, sudo=True)
        self.ensure_restart()

    def ensure_site_enabled(self, site):
        '''
        Ensures that a symlink is created for the specified site at the Apache list of enabled sites from the list of available sites.

        :param site: Name of the site to enable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.ensure_site_enabled('my-site')
        '''

        with settings(warn_only=True):
            self.remote_symlink(from_file=self.__available_site_for(site), to_file=self.__enabled_site_for(site), sudo=True)
        self.ensure_restart()

    def ensure_site_disabled(self, site):
        '''
        Ensures that the specified site is removed from the Apache list of enabled sites.

        :param site: Name of the site to disable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.ensure_site_disabled('default')
        '''

        with settings(warn_only=True):
            self.remove_file(self.__enabled_site_for(site), sudo=True)
        self.ensure_restart()

    def ensure_restart(self):
        '''
        Ensures that Apache gets restarted on cleanup. There's no need to call this method as any changes to Apache will trigger it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.ensure_restart()
        '''

        self.must_restart = True

    def restart(self):
        '''
        Forcefully restarts Apache.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import ApacheRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(ApacheRole) as role:
                        role.restart()
        '''

        self.execute('service apache2 restart', sudo=True)
        self.must_restart = False

########NEW FILE########
__FILENAME__ = django
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Django <https://www.djangoproject.com/>`_ app server utility methods for Debian distributions.
'''

from os.path import dirname, join, splitext, split

from provy.core import Role
from provy.more.debian.package.pip import PipRole
from provy.more.debian.package.aptitude import AptitudeRole
from provy.more.debian.monitoring.supervisor import SupervisorRole

SITES_KEY = 'django-sites'
MUST_RESTART_KEY = 'restart-django-sites'


class WithSite(object):
    def __init__(self, django, name):
        self.django = django
        self.auto_start = True
        self.daemon = True
        self.name = name
        self.settings_path = None
        self.host = '0.0.0.0'
        self.pid_file_path = '/var/run'
        self.threads = 1
        self.processes = 1
        self.starting_port = 8000
        self.user = None
        if SupervisorRole in self.django.context['roles_in_context']:
            self.use_supervisor = True
            self.supervisor_log_folder = self.django.context['roles_in_context'][SupervisorRole].log_folder
        else:
            self.use_supervisor = False
            self.supervisor_log_folder = '/var/log'

        self.settings = {}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if not self.settings_path:
            raise RuntimeError('[Django] The path to the site must be specified and should correspond to the directory where the settings.py file is for site %s.' % self.name)

        if SITES_KEY not in self.django.context:
            self.django.context[SITES_KEY] = []

        if self.use_supervisor:
            self.daemon = False
            self.auto_start = False
            self.django.restart_supervisor_on_changes = True

        self.django.context[SITES_KEY].append(self)


class DjangoRole(Role):
    '''
    This role provides `Django <https://www.djangoproject.com/>`_ management utilities for Debian distributions.

    When running `Django <https://www.djangoproject.com/>`_ under supervisor, remember to set :meth:`restart_supervisor_on_changes` to :data:`True`.

    If you choose to automatically include supervisor support in your sites, don't forget to call
    :meth:`SupervisorRole.config <provy.more.debian.monitoring.supervisor.SupervisorRole.config>` method.

    When creating a new site using `with role.create_site('somesite') as site` these are the properties available in the site object:

    :var auto_start: (:class:`bool`) Indicates whether the site should be automatically started by the operating system. Defaults to :data:`True`.
        If using supervisor, explicitly set this to :data:`False`.
    :var daemon: (:class:`bool`) Indicates whether the `init.d` command for the website should daemonize itself. Defaults to :data:`True`.
        If using supervisor, explicitly set this to :data:`False`.
    :var settings_path: (:class:`str`) This is the only mandatory argument. This is the full path to Django's `settings.py` file.
    :var host: (:class:`str`) The host IP address that django will listen to incoming requests. Defaults to `0.0.0.0`.
    :var starting_port: (:class:`int`) The first port that Django will be started in the event that more than one process is used. Defaults to `8000`.
    :var processes: (:class:`int`) The number of processes that will have commands created at the server.
        As an example, if this is set to 2 and the name of the site is 'website', two commands will be created: `/etc/init.d/website-8000` and `/etc/init.d/website-8001`. Defaults to 1.
    :var pid_file_path: (:class:`str`) Path to create the pid file. Defaults to `/var/run`.
    :var threads: (:class:`int`) Number of worker threads that Green Unicorn will use when spawning Django. Defaults to `1`.
    :var user: (:class:`str`) User that gunicorn will run under. Defaults to the last created user.
        When using supervisor it is **VERY** important that this user is the same user as supervisor's.
    :var use_supervisor: (:class:`bool`) Whether supervisor configuration for these django website should be automatically included.
    :var supervisor_log_folder: (:class:`str`) Log folder that supervisor will store the configurations for this site.
    :var settings: (:class:`dict`) Dictionary with settings that will overwrite Django's defaults.
        These settings will be included in a `local_settings.py` module that imports the original settings as `KEY=value` pairs.
        All values included here will have their string representation used in the `local_settings`.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import DjangoRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(SupervisorRole) as role:
                    role.config(
                        config_file_directory='/home/someuser',
                        log_file='/home/someuser/logs/supervisord.log',
                        user='myuser'
                    )

                with self.using(DjangoRole) as role:
                    role.restart_supervisor_on_changes = True
                    with role.create_site('mysite') as site:
                        site.path = '/some/folder/with/settings.py'
                        site.use_supervisor = True
                        site.supervisor_log_path = '/some/folder/to/log'
                        site.threads = 4
                        site.processes = 2
                        site.user = 'myuser'
                        # settings that override the website defaults.
                        site.settings = {

                        }
    '''
    def __init__(self, prov, context):
        super(DjangoRole, self).__init__(prov, context)
        self.restart_supervisor_on_changes = False

    def provision(self):
        '''
        Installs `Django <https://www.djangoproject.com/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or `Django <https://www.djangoproject.com/>`_ won't work properly in the remote server.

        If you set a value to django-version in the context, that version of Django will be installed instead of latest.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import DjangoRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(DjangoRole) # no need to call this if using with block.

            # or
            class MySampleRole(Role):
                def provision(self):
                    self.context['django-version'] = '1.1.1'
                    self.provision_role(DjangoRole) # no need to call this if using with block.
                    # now django 1.1.1 is installed.
        '''
        self.register_template_loader('provy.more.debian.web')

        with self.using(AptitudeRole) as aptitude:
            aptitude.ensure_package_installed('python-mysqldb')

        with self.using(PipRole) as pip:
            if 'django-version' in self.context:
                pip.ensure_package_installed('django', version=self.context['django-version'])
            else:
                pip.ensure_package_installed('django')

            pip.ensure_package_installed('gunicorn')

    def create_site(self, name):
        '''
        Enters a with block with a Site variable that allows you to configure a django website.

        :param name: Name of the website.
        :type name: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import DjangoRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(DjangoRole) as role:
                        with role.create_site('website') as site:
                            site.path = '/some/folder/with/settings.py'
                            site.threads = 4
                            # settings that override the website defaults.
                            site.settings = {

                            }
        '''
        return WithSite(self, name)

    def cleanup(self):
        '''
        Updates the website and/or init files and restarts websites if needed.

        There's no need to call this method since provy's lifecycle will make sure it is called.
        '''
        super(DjangoRole, self).cleanup()

        if SITES_KEY in self.context:
            for website in self.context[SITES_KEY]:
                updated = self._update_init_script(website)
                settings_updated = self._update_settings(website)
                if website.use_supervisor:
                    self._update_supervisor_program(website)
                if updated or settings_updated:
                    self._ensure_restart(website)

        if MUST_RESTART_KEY in self.context and self.context[MUST_RESTART_KEY]:
            if self.restart_supervisor_on_changes:
                with self.using(SupervisorRole) as role:
                    role.ensure_restart()
            for site in self.context[MUST_RESTART_KEY]:
                self._restart(site)

    def _update_supervisor_program(self, website):
        with self.using(SupervisorRole) as role:
            for process_number in range(website.processes):
                self._update_supervisor_program_for_process(website, process_number, role)

    def _update_supervisor_program_for_process(self, website, process_number, role):
        port = website.starting_port + process_number
        script_name = "%s-%d" % (website.name, port)
        with role.with_program(script_name) as program:
            program.directory = dirname(website.settings_path)
            program.command = '/etc/init.d/%s start' % script_name
            program.name = script_name
            program.number_of_processes = 1
            program.user = website.user
            program.log_folder = website.supervisor_log_folder

    def _ensure_restart(self, website):
        if not MUST_RESTART_KEY in self.context:
            self.context[MUST_RESTART_KEY] = []
        self.context[MUST_RESTART_KEY].append(website)

    def _restart(self, website):
        if not website.auto_start:
            return
        for process_number in range(website.processes):
            port = website.starting_port + process_number
            script_name = "%s-%d" % (website.name, port)
            if self.remote_exists(join(website.pid_file_path.rstrip('/'), '%s_%s.pid' % (website.name, port))):
                self.execute('/etc/init.d/%s stop' % script_name, stdout=False, sudo=True)
            self.execute('/etc/init.d/%s start' % script_name, stdout=False, sudo=True)

    def _update_settings(self, website):
        local_settings_path = join(dirname(website.settings_path), 'local_settings.py')
        options = {
            'settings_file': splitext(split(website.settings_path)[-1])[0],
            'settings': website.settings
        }
        result = self.update_file('local.settings.template', local_settings_path, owner=website.user, options=options, sudo=True)
        return result

    def _update_init_script(self, website):
        at_least_one_updated = False
        for process_number in range(website.processes):
            port = website.starting_port + process_number
            options = {
                'name': website.name,
                'pid_file_path': website.pid_file_path.rstrip('/'),
                'user': website.user,
                'host': website.host,
                'port': port,
                'threads': website.threads,
                'daemon': website.daemon,
                'user': website.user,
                'settings_directory': dirname(website.settings_path)
            }
            script_name = '%s-%d' % (website.name, port)
            result = self.update_file('website.init.template', '/etc/init.d/%s' % script_name, owner=website.user, options=options, sudo=True)

            if result:
                at_least_one_updated = True
                self.execute('chmod +x /etc/init.d/%s' % script_name, stdout=False, sudo=True)
                if website.auto_start:
                    self.execute('update-rc.d %s defaults' % script_name, stdout=False, sudo=True)

        return at_least_one_updated

########NEW FILE########
__FILENAME__ = nginx
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Nginx <http://wiki.nginx.org/Main>`_ web server utility methods for Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole


class NginxRole(Role):
    '''
    This role provides `Nginx <http://wiki.nginx.org/Main>`_ web server management utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import NginxRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(NginxRole) as role:
                    role.ensure_conf(conf_template='nginx.conf')
                    role.ensure_site_disabled('default')
                    role.create_site(site='my-site', template='my-site')
                    role.ensure_site_enabled('my-site')
    '''

    def __available_site_for(self, name):
        return '/etc/nginx/sites-available/%s' % name

    def __enabled_site_for(self, name):
        return '/etc/nginx/sites-enabled/%s' % name

    def provision(self):
        '''
        Installs `Nginx <http://wiki.nginx.org/Main>`_ dependencies.
        This method should be called upon if overriden in base classes, or `Nginx <http://wiki.nginx.org/Main>`_ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(NginxRole) # does not need to be called if using with block.
        '''
        with self.using(AptitudeRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('nginx')

    def cleanup(self):
        '''
        Restarts nginx if any changes have been made.
        There's no need to call this method manually.
        '''
        super(NginxRole, self).cleanup()
        if 'must-restart-nginx' in self.context and self.context['must-restart-nginx']:
            self.restart()

    def ensure_conf(self, conf_template, options={}, nginx_conf_path='/etc/nginx/nginx.conf'):
        '''
        Ensures that nginx configuration is up-to-date with the specified template.

        :param conf_template: Name of the template for nginx.conf.
        :type conf_template: :class:`str`
        :param options: Dictionary of options passed to template. Extends context.
        :type options: :class:`dict`
        :param nginx_conf_path: Path of the nginx configuration file. Defaults to /etc/nginx/nginx.conf.
        :type nginx_conf_path: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.ensure_conf(conf_template='nginx.conf')
        '''

        result = self.update_file(conf_template,
                                  nginx_conf_path,
                                  options=options,
                                  sudo=True)
        if result:
            self.log('nginx conf updated!')
            self.ensure_restart()

    def ensure_site_disabled(self, site):
        '''
        Ensures that the specified site is removed from nginx list of enabled sites.

        :param site: Name of the site to disable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.ensure_site_disabled('default')
        '''
        result = self.remove_file(self.__enabled_site_for(site), sudo=True)
        if result:
            self.log('%s nginx site is disabled!' % site)
            self.ensure_restart()

    def ensure_site_enabled(self, site):
        '''
        Ensures that a symlink is created for the specified site at nginx list of enabled sites from the list of available sites.

        :param site: Name of the site to enable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.ensure_site_enabled('my-site')
        '''

        result = self.remote_symlink(self.__available_site_for(site),
                                     self.__enabled_site_for(site),
                                     sudo=True)
        if result:
            self.log('%s nginx site is enabled!' % site)
            self.ensure_restart()

    def create_site(self, site, template, options={}):
        '''
        Adds a website with the specified template to Nginx list of available sites.

        Warning: Do not forget to call :meth:`ensure_site_enabled` after a call to `create_site`, or your site won't be enabled.

        :param site: Name of the site to enable.
        :type site: :class:`str`
        :param template: Site configuration template.
        :type template: :class:`str`
        :param options: Options to pass to the template.
        :type options: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.create_site(site='my-site', template='my-site', options={
                            "user": "me"
                        })
        '''

        result = self.update_file(template,
                                  self.__available_site_for(site),
                                  options=options, sudo=True)
        if result:
            self.log('%s nginx site created!' % site)
            self.ensure_restart()

    def ensure_restart(self):
        '''
        Ensures that nginx gets restarted on cleanup. There's no need to call this method as any changes to Nginx will trigger it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.ensure_restart()
        '''
        self.context['must-restart-nginx'] = True

    def restart(self):
        '''
        Forcefully restarts Nginx.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import NginxRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(NginxRole) as role:
                        role.restart()
        '''
        command = '/etc/init.d/nginx restart'
        self.execute(command, sudo=True)

########NEW FILE########
__FILENAME__ = rails
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Ruby on Rails <http://rubyonrails.org/>`_ applications utility methods for Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole
from provy.more.debian.package.gem import GemRole
from provy.more.debian.web.nginx import NginxRole


PACKAGES_TO_INSTALL = (
    'build-essential',
    'zlib1g-dev',
    'libssl-dev',
    'libpq-dev',
    'subversion',
    'libcurl4-openssl-dev',
    'libmysqlclient-dev',
    'libpcre3-dev',
    'libxslt1-dev',
    'libperl-dev',
    'libgcrypt11-dev',
    'libcrypto++-dev',
    'sqlite3',
    'libsqlite3-dev',
)


class RailsRole(Role):
    '''
    This role provides `Ruby on Rails <http://rubyonrails.org/>`_ application utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import RailsRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(RailsRole) as role:
                    role.ensure_site_disabled('default')
                    role.create_site(site='my-site', path='/home/myuser/my-site')
                    role.ensure_site_enabled('my-site')
    '''

    def __available_site_for(self, name):
        return '/etc/nginx/sites-available/%s' % name

    def provision(self):
        '''
        Installs `Ruby on Rails <http://rubyonrails.org/>`_ dependencies.
        This method should be called upon if overriden in base classes, or Rails won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(RailsRole) # does not need to be called if using with block.
        '''
        self.register_template_loader('provy.more.debian.web')

        self.__install_system_packages()
        self.__install_gem_packages()
        self.__install_nginx_module()
        self.__create_nginx_configurations()
        self.__create_nginx_directories()

    def __create_nginx_directories(self):
        self.ensure_dir('/etc/nginx/sites-available', sudo=True)
        self.ensure_dir('/etc/nginx/sites-enabled', sudo=True)
        self.ensure_dir('/etc/nginx/conf.d', sudo=True)

    def __create_nginx_configurations(self):
        self.update_file('rails.nginx.conf.template', '/etc/nginx/conf/nginx.conf', sudo=True)
        self.update_file('rails.nginx.init.template', '/etc/init.d/nginx', sudo=True)
        self.change_path_mode('/etc/init.d/nginx', 755)

    def __install_gem_packages(self):
        with self.using(GemRole) as role:
            role.ensure_package_installed('bundler')
            role.ensure_package_installed('passenger')

    def __install_system_packages(self):
        with self.using(AptitudeRole) as role:
            for package in PACKAGES_TO_INSTALL:
                role.ensure_package_installed(package)

    def __install_nginx_module(self):
        if not self.remote_exists_dir('/etc/nginx'):
            self.ensure_dir('/var/log/nginx', sudo=True)
            self.log("passenger-nginx not found! Installing...")
            self.execute('passenger-install-nginx-module --auto --auto-download --prefix=/etc/nginx', sudo=True, stdout=False)
            self.log("passenger-nginx installed.")

    def cleanup(self):
        '''
        Restarts nginx if any changes have been made.

        There's no need to call this method manually.
        '''
        super(RailsRole, self).cleanup()
        if 'must-restart-nginx' in self.context and self.context['must-restart-nginx']:
            self.restart()

    def ensure_site_disabled(self, site):
        '''
        Ensures that the specified site is removed from Nginx list of enabled sites.

        :param site: Name of the site to disable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RailsRole) as role:
                        role.ensure_site_disabled('default')
        '''
        with self.using(NginxRole) as nginx:
            nginx.ensure_site_disabled(site)

    def ensure_site_enabled(self, site):
        '''
        Ensures that a symlink is created for the specified site at Nginx list of enabled sites from the list of available sites.

        :param site: Name of the site to enable.
        :type site: :class:`str`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RailsRole) as role:
                        role.ensure_site_enabled('my-site')
        '''
        with self.using(NginxRole) as nginx:
            nginx.ensure_site_enabled(site)

    def create_site(self, site, host, path, port=80, options={}):
        '''
        Adds a website with the specified template to Nginx list of available sites.

        .. warning::

            Do not forget to call :meth:`ensure_site_enabled` after a call to create_site, or your site won't be enabled.

        :param site: Name of the site to enable.
        :type site: :class:`str`
        :param host: Server domain that Nginx should respond by.
        :type host: :class:`str`
        :param path: Path of the rails app.
        :type path: :class:`str`
        :param port: Port that Nginx will listen in. Defaults to `80`.
        :type port: :class:`int`
        :param options: Options to pass to the Nginx template. Defaults to empty dict (`{}`).
        :type options: :class:`int`

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RailsRole) as role:
                        role.create_site(site='my-site', host='localhost www.mysite.com',
                                         port=8888, path='/home/myuser/my-rails-site')
        '''

        template = "rails-nginx.template"
        options['host'] = host
        options['path'] = path
        result = self.update_file(template,
                                  self.__available_site_for(site),
                                  options=options, sudo=True)

        self.execute('cd %s && bundle install --without development test --deployment' % path, user=self.context['owner'], stdout=True)
        if result:
            self.log('Installing gems with bundler')
            self.log('%s nginx site created!' % site)
            self.ensure_restart()

    def ensure_restart(self):
        '''
        Ensures that Nginx gets restarted on cleanup. There's no need to call this method as any changes to Nginx will trigger it.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RailsRole) as role:
                        role.ensure_restart()
        '''
        self.context['must-restart-nginx'] = True

    def restart(self):
        '''
        Forcefully restarts nginx.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import RailsRole

            class MySampleRole(Role):
                def provision(self):
                    with self.using(RailsRole) as role:
                        role.restart()
        '''
        with self.using(NginxRole) as nginx:
            nginx.restart()

########NEW FILE########
__FILENAME__ = tornado
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide `Tornado <http://www.tornadoweb.org/>`_ app server utility methods for Debian distributions.
'''

from provy.core import Role
from provy.more.debian.package.aptitude import AptitudeRole
from provy.more.debian.package.pip import PipRole


class TornadoRole(Role):
    '''
    This role provides `Tornado <http://www.tornadoweb.org/>`_ app server management utilities for Debian distributions.

    Example:
    ::

        from provy.core import Role
        from provy.more.debian import TornadoRole

        class MySampleRole(Role):
            def provision(self):
                self.provision_role(TornadoRole)
    '''

    def provision(self):
        '''
        Installs `Tornado <http://www.tornadoweb.org/>`_ and its dependencies.
        This method should be called upon if overriden in base classes, or `Tornado <http://www.tornadoweb.org/>`_ won't work properly in the remote server.

        Example:
        ::

            from provy.core import Role
            from provy.more.debian import TornadoRole

            class MySampleRole(Role):
                def provision(self):
                    self.provision_role(TornadoRole)
        '''

        with self.using(AptitudeRole) as role:
            role.ensure_up_to_date()
            role.ensure_package_installed('python-pycurl')

        with self.using(PipRole) as role:
            role.ensure_package_installed('tornado')

########NEW FILE########
__FILENAME__ = hosts
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Roles in this namespace are meant to provide hosts management operations.
'''

from provy.core import Role


class HostsRole(Role):
    '''
    This role provides hosts file management utilities.

    Example:
    ::

        from provy.core import Role
        from provy.more.linux import HostsRole

        class MySampleRole(Role):
            def provision(self):
                with self.using(HostsRole) as role:
                    role.ensure_host('localhost', '127.0.0.1')
    '''

    def ensure_host(self, host_name, ip):
        '''
        Makes sure that a certain host is configured in the hosts file.

        :param host_name: The hostname.
        :type host_name: :class:`str`
        :param ip: The IP to which the :data:`host_name` will point to.
        :type ip: :class:`str`
        '''
        self.ensure_line('%s        %s' % (ip, host_name), '/etc/hosts', sudo=True)

########NEW FILE########
__FILENAME__ = website
#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import tornado.ioloop
import tornado.web


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")


application = tornado.web.Application([
    (r"/", MainHandler),
])


if __name__ == "__main__":
    port = int(sys.argv[1])
    application.listen(port, '0.0.0.0')
    print ">> Website running at http://0.0.0.0:%d" % port
    tornado.ioloop.IOLoop.instance().start()

########NEW FILE########
__FILENAME__ = provyfile
# -*- coding: utf-8 -*-

import os

from provy.core import Role
from provy.more.debian import UserRole, TornadoRole, SupervisorRole, NginxRole


class FrontEnd(Role):
    def provision(self):
        with self.using(UserRole) as role:
            role.ensure_user('frontend', identified_by='pass', is_admin=True)

        with self.using(NginxRole) as role:
            role.ensure_conf(conf_template='nginx.conf', options={'user': 'frontend'})
            role.ensure_site_disabled('default')
            role.create_site(site='website', template='website', options={
                'host': os.environ['PROVY_HOST'],
                'port': os.environ['PROVY_PORT'],
            })
            role.ensure_site_enabled('website')


class BackEnd(Role):
    def provision(self):
        with self.using(UserRole) as role:
            role.ensure_user('backend', identified_by='pass', is_admin=True)

        self.update_file('website.py', '/home/backend/website.py', owner='backend', sudo=True)

        self.provision_role(TornadoRole)

        # make sure we have a folder to store our logs
        self.ensure_dir('/home/backend/logs', owner='backend')

        with self.using(SupervisorRole) as role:
            role.config(
                config_file_directory='/home/backend',
                log_folder='/home/backend/logs/',
                user='backend'
            )

            with role.with_program('website') as program:
                program.directory = '/home/backend'
                program.command = 'python website.py 800%(process_num)s'
                program.number_of_processes = 4

                program.log_folder = '/home/backend/logs'


servers = {
    'end-to-end': {
        'frontend': {
            'address': os.environ['PROVY_HOST'],
            'user': os.environ['PROVY_USERNAME'],
            'roles': [
                FrontEnd
            ]
        },
        'backend': {
            'address': os.environ['PROVY_HOST'],
            'user': os.environ['PROVY_USERNAME'],
            'roles': [
                BackEnd
            ]
        }
    }
}

########NEW FILE########
__FILENAME__ = test
#!/usr/bin/env python

import os
from unittest import TestCase

from nose.tools import istest
import requests


class EndToEndTests(TestCase):
    @istest
    def gets_response_from_tornado(self):
        response = requests.get('http://{}:{}'.format(os.environ['PROVY_HOST'], os.environ['PROVY_PORT']))

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, 'Hello, world')

########NEW FILE########
__FILENAME__ = test_runner
import os

from mock import patch
from nose.tools import istest

from provy.core.runner import run
import provy.core.utils
from tests.unit.tools.helpers import ProvyTestCase
from tests.functional.fixtures.provyfile import (
    provisions,
    cleanups,
    contexts,
    Role1,
    Role2,
    Role3,
    Role4,
)


class RunnerTest(ProvyTestCase):
    @istest
    def runs_normal_provisioning(self):
        provfile_path = os.path.join('tests', 'functional', 'fixtures', 'provyfile')
        password = 'some-pass'
        extra_options = {
            'password': 'another pass',
        }

        with patch.object(provy.core.utils, 'getpass') as mock_getpass:
            mock_getpass.return_value = 'some-password'
            run(provfile_path, 'test', password, extra_options)
            run(provfile_path, 'test2', password, extra_options)

        self.assertIn(Role1, provisions)
        self.assertIn(Role2, provisions)
        self.assertIn(Role3, provisions)
        self.assertIn(Role4, provisions)

        self.assertIn(Role1, cleanups)
        self.assertIn(Role2, cleanups)
        self.assertIn(Role3, cleanups)
        self.assertIn(Role4, cleanups)

        self.assertIn('foo', contexts[Role1])
        self.assertIn('bar', contexts[Role2])
        self.assertIn('baz', contexts[Role2])
        self.assertIn('bar', contexts[Role3])
        self.assertIn('baz', contexts[Role3])
        self.assertIn('foo', contexts[Role4])

########NEW FILE########
__FILENAME__ = provyfile
#!/usr/bin/python
# -*- coding: utf-8 -*-

from provy.core import Role, AskFor


provisions = []
cleanups = []
contexts = {}


class Role1(Role):
    def provision(self):
        provisions.append(self.__class__)
        contexts[self.__class__] = self.context
        self.context['cleanup'].extend([
            Role2(self.prov, self.context),
            Role3(self.prov, self.context),
        ])

    def cleanup(self):
        super(Role1, self).cleanup()
        cleanups.append(self.__class__)


class Role2(Role):
    def provision(self):
        provisions.append(self.__class__)
        contexts[self.__class__] = self.context

    def cleanup(self):
        super(Role2, self).cleanup()
        cleanups.append(self.__class__)


class Role3(Role):
    def provision(self):
        provisions.append(self.__class__)
        contexts[self.__class__] = self.context

    def cleanup(self):
        super(Role3, self).cleanup()
        cleanups.append(self.__class__)


class Role4(Role):
    def provision(self):
        provisions.append(self.__class__)
        contexts[self.__class__] = self.context

    def cleanup(self):
        super(Role4, self).cleanup()
        cleanups.append(self.__class__)

servers = {
    'test': {
        'role1': {
            'address': '33.33.33.33',
            'user': 'vagrant',
            'roles': [
                Role1,
            ],
            'options': {
                'foo': 'FOO',
                'password': AskFor('password', 'Provide a password'),
                'another-password': AskFor('another-password', 'Provide another password'),
            },
            'ssh_key': '/some/key.pub',
        },
        'roles2and3': {
            'address': '33.33.33.34',
            'user': 'vagrant',
            'roles': [
                Role2,
                Role3,
            ],
            'options': {
                'bar': 'BAR',
                'baz': 'BAZ',
            },
        },
    },
    'test2': {
        'address': '33.33.33.35',
        'user': 'vagrant',
        'roles': [
            Role4,
        ],
        'options': {
            'foo': 'FOO',
        },
    },
}

########NEW FILE########
__FILENAME__ = test_roles
# -*- coding: utf-8 -*-
from StringIO import StringIO

from contextlib import contextmanager
import os
import tempfile

from jinja2 import ChoiceLoader, FileSystemLoader
from mock import MagicMock, patch, call, ANY, Mock, DEFAULT
from nose.tools import istest

from provy.core.roles import Role, UsingRole, UpdateData
from tests.unit.tools.helpers import PROJECT_ROOT, ProvyTestCase


class FileContentMatcher(object):

    """
    Can be used to match first argument of put_file if we expected call like::

        role.put_file(StringIO("foobar"), "/tmp/foo")

    """

    def __init__(self, test, file_contents):
        self.test = test
        self.file_contents = file_contents

    def __eq__(self, other):
        self.test.assertIsInstance(other, StringIO)
        self.test.assertEqual(other.read(), self.file_contents)
        return True


class RoleTest(ProvyTestCase):
    def setUp(self):
        loader = ChoiceLoader([
            FileSystemLoader(os.path.join(PROJECT_ROOT, 'files'))
        ])
        context = {
            'owner': 'foo',
            'registered_loaders': [],
            'loader': loader,
            'cleanup': [],
            'host': 'localhost',
        }
        self.role = Role(prov=None, context=context)
        self.update_data = UpdateData('/tmp/some-file.ext', 'some local md5', 'some remote md5')

    @contextmanager
    def mock_update_data(self):
        with self.mock_role_method('_build_update_data'):
            self.role._build_update_data.return_value = self.update_data
            yield

    @istest
    def checks_if_a_remote_directory_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = '0'
            self.assertTrue(self.role.remote_exists_dir('/some_path'))

            execute.assert_called_with('test -d /some_path; echo $?', stdout=False, sudo=True)

    @istest
    def checks_if_a_remote_directory_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = '1'
            self.assertFalse(self.role.remote_exists_dir('/some_path'))

            execute.assert_called_with('test -d /some_path; echo $?', stdout=False, sudo=True)

    @istest
    def doesnt_create_directory_if_it_already_exists(self):
        with self.mock_role_method('remote_exists_dir') as remote_exists_dir, self.execute_mock() as execute:
            remote_exists_dir.return_value = True
            self.role.ensure_dir('/some_path')
            self.assertFalse(execute.called)

    @istest
    def creates_the_directory_if_it_doesnt_exist(self):
        with self.mock_role_method('remote_exists_dir') as remote_exists_dir, self.execute_mock() as execute:
            remote_exists_dir.return_value = False
            self.role.ensure_dir('/some_path')
            execute.assert_called_with('mkdir -p /some_path', stdout=False, sudo=False)

    @istest
    def gets_distro_info_for_debian(self):
        with self.execute_mock() as execute:
            execute.return_value = 'No LSB modules are available.\nDistributor ID:\tDebian\nDescription:\tDebian GNU/Linux 6.0.5 (squeeze)\nRelease:\t6.0.5\nCodename:\tsqueeze'
            distro_info = self.role.get_distro_info()
            execute.assert_called_with('lsb_release -a')
            self.assertEqual(distro_info.distributor_id, 'Debian')
            self.assertEqual(distro_info.description, 'Debian GNU/Linux 6.0.5 (squeeze)')
            self.assertEqual(distro_info.release, '6.0.5')
            self.assertEqual(distro_info.codename, 'squeeze')

    @istest
    def gets_distro_info_for_ubuntu(self):
        with self.execute_mock() as execute:
            execute.return_value = 'No LSB modules are available.\r\nDistributor ID:\tUbuntu\r\nDescription:\tUbuntu 12.04.1 LTS\r\nRelease:\t12.04\r\nCodename:\tprecise'
            distro_info = self.role.get_distro_info()
            execute.assert_called_with('lsb_release -a')
            self.assertEqual(distro_info.distributor_id, 'Ubuntu')
            self.assertEqual(distro_info.description, 'Ubuntu 12.04.1 LTS')
            self.assertEqual(distro_info.release, '12.04')
            self.assertEqual(distro_info.codename, 'precise')

    @istest
    def gets_distro_info_for_centos(self):
        with self.execute_mock() as execute:
            execute.return_value = 'LSB Version:\t:core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch\nDistributor ID:\tCentOS\nDescription:\tCentOS release 5.8 (Final)\nRelease:\t5.8\nCodename:\tFinal'
            distro_info = self.role.get_distro_info()
            execute.assert_called_with('lsb_release -a')
            self.assertEqual(distro_info.lsb_version, ':core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch')
            self.assertEqual(distro_info.distributor_id, 'CentOS')
            self.assertEqual(distro_info.description, 'CentOS release 5.8 (Final)')
            self.assertEqual(distro_info.release, '5.8')
            self.assertEqual(distro_info.codename, 'Final')

    @istest
    def doesnt_hit_the_server_twice_to_get_distro_info(self):
        with self.execute_mock() as execute:
            execute.return_value = 'No LSB modules are available.\r\nDistributor ID:\tUbuntu\r\nDescription:\tUbuntu 12.04.1 LTS\r\nRelease:\t12.04\r\nCodename:\tprecise'

            distro_info1 = self.role.get_distro_info()
            distro_info2 = self.role.get_distro_info()

            execute.assert_called_once_with('lsb_release -a')
            self.assertEqual(distro_info1, distro_info2)

    @istest
    def ignores_line_if_already_exists_in_file(self):
        with self.mock_role_methods("has_line", "put_file", "execute") as mocked:
            has_line, _, execute = mocked
            has_line.return_value = True
            self.role.ensure_line('this line in', '/some/file')
            self.assertFalse(execute.called)

    @istest
    def inserts_line_if_it_doesnt_exist_yet(self):

        LINE_CONTENTS = 'this line in'
        REMOTE_TMP_FILE = "/tmp/foo"
        with self.mock_role_methods("has_line", "put_file", "execute", "create_remote_temp_file") as mocked:
            has_line, put_file, execute, create_remote_temp_file = mocked
            create_remote_temp_file.return_value = REMOTE_TMP_FILE
            has_line.return_value = False
            self.role.ensure_line(LINE_CONTENTS, "/some/file")
            put_file.assert_called_with(FileContentMatcher(self, LINE_CONTENTS), REMOTE_TMP_FILE, False, stdout=False)
            execute.assert_called_with('cat {} >> /some/file && echo >> /some/file'.format(REMOTE_TMP_FILE), stdout=False, sudo=False, user=None)

    @istest
    def inserts_line_if_it_doesnt_exist_yet_with_sudo(self):

        LINE_CONTENTS = 'this line in'
        REMOTE_TMP_FILE = "/tmp/foo"
        with self.mock_role_methods("has_line", "put_file", "execute", "create_remote_temp_file") as mocked:
            has_line, put_file, execute, create_remote_temp_file = mocked
            create_remote_temp_file.return_value = REMOTE_TMP_FILE
            has_line.return_value = False
            self.role.ensure_line(LINE_CONTENTS, "/some/file", sudo=True)
            put_file.assert_called_with(FileContentMatcher(self, LINE_CONTENTS), REMOTE_TMP_FILE, True, stdout=False)
            execute.assert_called_with('cat {} >> /some/file && echo >> /some/file'.format(REMOTE_TMP_FILE), stdout=False, sudo=True, user=None)

    @istest
    def inserts_line_if_it_doesnt_exist_yet_with_user(self):

        LINE_CONTENTS = 'this line in'
        REMOTE_TMP_FILE = "/tmp/foo"
        with self.mock_role_methods("has_line", "put_file", "execute", "create_remote_temp_file") as mocked:
            has_line, put_file, execute, create_remote_temp_file = mocked
            create_remote_temp_file.return_value = REMOTE_TMP_FILE
            has_line.return_value = False
            self.role.ensure_line(LINE_CONTENTS, "/some/file", owner="foo")
            put_file.assert_called_with(FileContentMatcher(self, LINE_CONTENTS), REMOTE_TMP_FILE, True, stdout=False)
            execute.assert_called_with('cat {} >> /some/file && echo >> /some/file'.format(REMOTE_TMP_FILE), stdout=False, sudo=False, user="foo")

    @istest
    def registers_a_template_loader(self):
        package_name = 'provy.more.debian.monitoring'

        self.assertNotIn(package_name, self.role.context['registered_loaders'])
        self.role.register_template_loader(package_name)
        self.assertIn(package_name, self.role.context['registered_loaders'])

        choice_loader = self.role.context['loader']
        package_loader = choice_loader.loaders[1]
        self.assertIn('monitoring', package_loader.provider.module_path)

    @istest
    def doesnt_register_a_template_loader_twice(self):
        package_name = 'provy.more.debian.monitoring'

        self.assertNotIn(package_name, self.role.context['registered_loaders'])
        self.role.register_template_loader(package_name)
        self.role.register_template_loader(package_name)
        self.assertIn(package_name, self.role.context['registered_loaders'])

        self.assertEqual(self.role.context['registered_loaders'], ['provy.more.debian.monitoring'])

    @istest
    def appends_role_instance_to_cleanup_list_when_scheduling_cleanup(self):
        self.assertEqual(self.role.context['cleanup'], [])
        self.role.schedule_cleanup()
        self.assertEqual(self.role.context['cleanup'], [self.role])

    @istest
    def doesnt_append_again_if_role_is_already_in_cleanup_list(self):
        same_class_instance = Role(None, {})
        self.role.context['cleanup'] = [same_class_instance]
        self.role.schedule_cleanup()
        self.assertEqual(self.role.context['cleanup'], [same_class_instance])

    @istest
    def appends_role_instance_to_cleanup_list_when_same_class_doesnt_exist_yet(self):
        class DummyRole(Role):
            pass

        same_class_instance = DummyRole(None, {})
        self.role.context['cleanup'] = [same_class_instance]
        self.role.schedule_cleanup()
        self.assertEqual(self.role.context['cleanup'], [same_class_instance, self.role])

    @istest
    def provisions_role(self):
        role_instance = MagicMock()

        def StubRole(prov, context):
            return role_instance

        self.role.provision_role(StubRole)

        role_instance.provision.assert_called_with()

    @istest
    def schedules_cleanup_when_provisioning(self):
        role_instance = MagicMock()

        def StubRole(prov, context):
            return role_instance

        self.role.provision_role(StubRole)

        role_instance.schedule_cleanup.assert_called_with()

    @istest
    def can_call_cleanup_safely(self):
        self.role.cleanup()

    @istest
    def executes_command_with_stdout_and_same_user(self):
        with patch('fabric.api.run') as run:
            self.role.execute('some command', stdout=True)

            run.assert_called_with('some command')

    @istest
    def executes_command_with_stdout_and_sudo(self):
        with patch('fabric.api.sudo') as sudo:
            self.role.execute('some command', stdout=True, sudo=True)

            sudo.assert_called_with('some command', user=None)

    @istest
    def executes_command_with_stdout_and_another_user(self):
        with patch('fabric.api.sudo') as sudo:
            self.role.execute('some command', stdout=True, user='foo')

            sudo.assert_called_with('some command', user='foo')

    @istest
    def executes_command_without_stdout_but_same_user(self):
        with patch('fabric.api.run') as run, patch('fabric.api.hide') as hide:
            self.role.execute('some command', stdout=False)

            run.assert_called_with('some command')
            hide.assert_called_with('warnings', 'running', 'stdout', 'stderr')

    @istest
    def executes_command_without_stdout_but_sudo(self):
        with patch('fabric.api.sudo') as sudo, patch('fabric.api.hide') as hide:
            self.role.execute('some command', stdout=False, sudo=True)

            sudo.assert_called_with('some command', user=None)
            hide.assert_called_with('warnings', 'running', 'stdout', 'stderr')

    @istest
    def executes_command_without_stdout_but_another_user(self):
        with patch('fabric.api.sudo') as sudo, patch('fabric.api.hide') as hide:
            self.role.execute('some command', stdout=False, user='foo')

            sudo.assert_called_with('some command', user='foo')
            hide.assert_called_with('warnings', 'running', 'stdout', 'stderr')

    @istest
    def execute_command_check_cd_called_if_cwd_arg(self):
        with patch('fabric.api.run'):
            with patch('fabric.api.cd') as cd:
                self.role.execute("some command", cwd="/some/dir")
        cd.assert_called_once_with("/some/dir")

    @istest
    def execute_command_check_cd_called_if_no_cwd_arg(self):
        with patch('fabric.api.run'):
            with patch('fabric.api.cd') as cd:
                self.role.execute("some command")
        self.assertFalse(cd.called)

    @istest
    def executes_a_local_command_with_stdout_and_same_user(self):
        with patch('fabric.api.local') as local:
            local.return_value = 'some result'
            self.assertEqual(self.role.execute_local('some command', stdout=True), 'some result')

            local.assert_called_with('some command', capture=True)

    @istest
    def executes_a_local_command_with_stdout_and_sudo(self):
        with patch('fabric.api.local') as local:
            local.return_value = 'some result'
            self.assertEqual(self.role.execute_local('some command', stdout=True, sudo=True), 'some result')

            local.assert_called_with('sudo some command', capture=True)

    @istest
    def executes_a_local_command_with_stdout_and_another_user(self):
        with patch('fabric.api.local') as local:
            local.return_value = 'some result'
            self.assertEqual(self.role.execute_local('some command', stdout=True, user='foo'), 'some result')

            local.assert_called_with('sudo -u foo some command', capture=True)

    @istest
    def executes_a_local_command_without_stdout_and_another_user(self):
        with patch('fabric.api.local') as local, patch('fabric.api.hide') as hide:
            local.return_value = 'some result'
            self.assertEqual(self.role.execute_local('some command', stdout=False, user='foo'), 'some result')

            local.assert_called_with('sudo -u foo some command', capture=True)
            hide.assert_called_with('warnings', 'running', 'stdout', 'stderr')

    @istest
    def executes_a_python_command(self):
        with self.execute_mock() as execute:
            self.role.execute_python('some command', stdout='is stdout?', sudo='is sudo?')

            execute.assert_called_with('python -c "some command"', stdout='is stdout?', sudo='is sudo?')

    @istest
    def gets_logged_user(self):
        with self.execute_mock() as execute:
            execute.return_value = 'some user'
            user = self.role.get_logged_user()

            self.assertEqual(user, 'some user')
            execute.assert_called_with('whoami', stdout=False)

    @istest
    def verifies_that_remote_file_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = '0'

            self.assertTrue(self.role.remote_exists('/some.path'))
            execute.assert_called_with('test -f /some.path; echo $?', stdout=False, sudo=True)

    @istest
    def verifies_that_remote_file_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = '1'

            self.assertFalse(self.role.remote_exists('/some.path'))
            execute.assert_called_with('test -f /some.path; echo $?', stdout=False, sudo=True)

    @istest
    def verifies_that_a_local_file_exists(self):
        file_to_verify = os.path.abspath(__file__)
        self.assertTrue(self.role.local_exists(file_to_verify))

    @istest
    def verifies_that_a_local_file_doesnt_exist(self):
        file_to_verify = '/some/sneaky.file'
        self.assertFalse(self.role.local_exists(file_to_verify))

    @istest
    def creates_a_local_temp_dir(self):
        self.assertTrue(self.role.local_temp_dir().startswith(tempfile.gettempdir()))

    @istest
    def creates_a_remote_temp_dir(self):
        with self.mock_role_method('execute_python') as execute_python:
            execute_python.return_value = '/some/remote/temp/dir'
            directory = self.role.remote_temp_dir()
            self.assertEqual(directory, '/some/remote/temp/dir')
            execute_python.assert_called_with('from tempfile import gettempdir; print gettempdir()', stdout=False)

    @istest
    def changes_the_owner_of_a_path(self):
        with self.execute_mock() as execute:
            self.role.change_path_owner('/some/path', 'foo')

            execute.assert_called_with('chown -R foo /some/path', stdout=False, sudo=True)

    @istest
    def creates_a_directory_when_it_doesnt_exist_yet(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = False

            self.role.ensure_dir('/some/dir')

            execute.assert_called_with('mkdir -p /some/dir', stdout=False, sudo=False)

    @istest
    def creates_a_directory_with_sudo_when_it_doesnt_exist_yet(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = False

            self.role.ensure_dir('/some/dir', sudo=True)

            execute.assert_called_with('mkdir -p /some/dir', stdout=False, sudo=True)

    @istest
    def creates_a_directory_with_specific_user_when_it_doesnt_exist_yet(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir, self.mock_role_method('change_path_owner') as change_path_owner:
            remote_exists_dir.return_value = False

            self.role.ensure_dir('/some/dir', owner='foo')

            execute.assert_called_with('mkdir -p /some/dir', stdout=False, sudo=True)
            change_path_owner.assert_called_with('/some/dir', 'foo')

    @istest
    def gets_object_mode_from_remote_file(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = True
            execute.return_value = '755\n'

            self.assertEqual(self.role.get_object_mode('/some/file.ext'), 755)
            execute.assert_called_with('stat -c %a /some/file.ext', stdout=False, sudo=True)

    @istest
    def cannot_get_mode_if_file_doesnt_exist(self):
        with self.execute_mock(), self.mock_role_method('remote_exists') as remote_exists, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists.return_value = False
            remote_exists_dir.return_value = False

            self.assertRaises(IOError, self.role.get_object_mode, '/some/file.ext')

    @istest
    def changes_the_mode_of_a_path_if_its_different(self):
        with self.execute_mock() as execute, self.mock_role_method('get_object_mode') as get_object_mode:
            get_object_mode.return_value = 644

            self.role.change_path_mode('/some/path', 755)

            execute.assert_called_with('chmod 755 /some/path', stdout=False, sudo=True)

    @istest
    def recursively_changes_the_mode_of_a_path_if_its_different(self):
        with self.execute_mock() as execute, self.mock_role_method('get_object_mode') as get_object_mode:
            get_object_mode.return_value = 644

            self.role.change_path_mode('/some/path', 755, recursive=True)

            execute.assert_called_with('chmod -R 755 /some/path', stdout=False, sudo=True)

    @istest
    def doesnt_change_path_mode_if_its_the_same(self):
        with self.execute_mock() as execute, self.mock_role_method('get_object_mode') as get_object_mode:
            get_object_mode.return_value = 755

            self.role.change_path_mode('/some/path', 755)

            self.assertFalse(execute.called)

    @istest
    def recursively_changes_the_mode_of_a_path_even_if_the_mode_of_the_parent_path_is_the_same(self):
        with self.execute_mock() as execute, self.mock_role_method('get_object_mode') as get_object_mode:
            get_object_mode.return_value = 755

            self.role.change_path_mode('/some/path', 755, recursive=True)

            execute.assert_called_with('chmod -R 755 /some/path', stdout=False, sudo=True)

    @istest
    def gets_the_md5_hash_of_a_local_file(self):
        with self.mock_role_method('execute_local') as execute_local, self.mock_role_method('local_exists') as local_exists:
            local_exists.return_value = True
            execute_local.return_value = 'some-hash\n'

            self.assertEqual(self.role.md5_local('/some/path'), 'some-hash')
            execute_local.assert_called_with('md5sum /some/path | cut -d " " -f 1', stdout=False, sudo=True)

    @istest
    def returns_none_if_local_file_doesnt_exist_for_md5_hash(self):
        with self.mock_role_method('execute_local') as execute_local, self.mock_role_method('local_exists') as local_exists:
            local_exists.return_value = False

            self.assertIsNone(self.role.md5_local('/some/path'))
            self.assertFalse(execute_local.called)

    @istest
    def gets_the_md5_hash_of_a_remote_file(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = True
            execute.return_value = 'some-hash\n'

            self.assertEqual(self.role.md5_remote('/some/path'), 'some-hash')
            execute.assert_called_with('md5sum /some/path | cut -d " " -f 1', stdout=False, sudo=True)

    @istest
    def returns_none_if_remote_file_doesnt_exist_for_md5_hash(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = False

            self.assertIsNone(self.role.md5_remote('/some/path'))
            self.assertFalse(execute.called)

    @istest
    def removes_a_directory_if_it_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = True

            self.assertTrue(self.role.remove_dir('/some/dir'))
            execute.assert_called_with('rmdir /some/dir', stdout=False, sudo=False)

    @istest
    def doesnt_remove_a_directory_if_it_doesnt_exist(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = False

            self.assertFalse(self.role.remove_dir('/some/dir'))
            self.assertFalse(execute.called)

    @istest
    def removes_a_directory_recursively_if_it_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = True

            self.assertTrue(self.role.remove_dir('/some/dir', recursive=True))
            execute.assert_called_with('rm -rf /some/dir', stdout=False, sudo=False)

    @istest
    def removes_a_directory_as_sudo_if_it_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = True

            self.assertTrue(self.role.remove_dir('/some/dir', sudo=True))
            execute.assert_called_with('rmdir /some/dir', stdout=False, sudo=True)

    @istest
    def removes_dir_silently_if_requested(self):
        with self.execute_mock():
            with self.mock_role_method('log') as log:
                with self.mock_role_method('remote_exists_dir') as exists:
                    exists.return_value = True
                    self.role.remove_dir('/some/dir', sudo=True, stdout=False)
        self.assertFalse(log.called)

    @istest
    def removes_dir_logging_if_requested(self):
        with self.execute_mock():
            with self.mock_role_method('log') as log:
                with self.mock_role_method('remote_exists_dir') as exists:
                    exists.return_value = True
                    self.role.remove_dir('/some/dir', sudo=True, stdout=True)
        self.assertEqual(len(log.mock_calls), 1)

    @istest
    def puts_file_silently_if_requested(self):
        with patch("fabric.api.put"):
            with self.mock_role_method("_Role__showing_command_output") as showing:
                self.role.put_file("foo", "bar", stdout=False)
        showing.assert_called_once_with(False)

    @istest
    def puts_file_chatting_if_requested(self):
        with patch("fabric.api.put"):
            with self.mock_role_method("_Role__showing_command_output") as showing:
                self.role.put_file("foo", "bar", stdout=True)
        showing.assert_called_once_with(True)

    @istest
    def removes_a_file_if_it_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = True

            self.assertTrue(self.role.remove_file('/some/file.ext'))
            execute.assert_called_with('rm -f /some/file.ext', stdout=False, sudo=False)

    @istest
    def doesnt_remove_a_file_if_it_doesnt_exist(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = False

            self.assertFalse(self.role.remove_file('/some/dir'))
            self.assertFalse(execute.called)

    @istest
    def removes_a_file_as_sudo_if_it_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            remote_exists.return_value = True

            self.assertTrue(self.role.remove_file('/some/file.ext', sudo=True))
            execute.assert_called_with('rm -f /some/file.ext', stdout=False, sudo=True)

    @istest
    def puts_a_file_in_the_remote_path(self):
        with patch('fabric.api.put') as put:
            self.role.put_file('/from/file', '/to/file')

            put.assert_called_with('/from/file', '/to/file', use_sudo=False)

    @istest
    def puts_a_file_as_sudo_in_the_remote_path(self):
        with patch('fabric.api.put') as put:
            self.role.put_file('/from/file', '/to/file', sudo=True)

            put.assert_called_with('/from/file', '/to/file', use_sudo=True)

    @istest
    def creates_a_remote_symbolic_link_if_it_doesnt_exist_yet(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            from_file = '/from/file'
            to_file = '/to/file'
            remote_from_exists = True
            remote_to_exists = False
            sudo = 'is it sudo?'
            remote_exists.side_effect = (remote_from_exists, remote_to_exists)

            self.role.remote_symlink(from_file, to_file, sudo=sudo)

            self.assertEqual(remote_exists.mock_calls, [
                call(from_file),
                call(to_file),
            ])
            execute.assert_called_with('ln -sf %s %s' % (from_file, to_file), sudo=sudo, stdout=False)

    @istest
    def creates_a_remote_symbolic_link_if_it_exists_but_with_different_path(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            from_file = '/from/file'
            to_file = '/to/file'
            another_from_file = '/another/from/file'
            remote_from_exists = True
            remote_to_exists = True
            sudo = 'is it sudo?'
            remote_exists.side_effect = (remote_from_exists, remote_to_exists)
            execute.side_effect = ('-rw-rw-r-- 1 foo foo 4490 Dez 11 22:24 %s -> %s' % (to_file, another_from_file), None)

            self.role.remote_symlink(from_file, to_file, sudo=sudo)

            self.assertEqual(remote_exists.mock_calls, [
                call(from_file),
                call(to_file),
            ])
            self.assertEqual(execute.mock_calls, [
                call('ls -la %s' % to_file, stdout=False, sudo=sudo),
                call('ln -sf %s %s' % (from_file, to_file), sudo=sudo, stdout=False),
            ])

    @istest
    def doesnt_create_symlink_if_file_with_same_name_already_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            from_file = '/from/file'
            to_file = '/to/file'
            remote_from_exists = True
            remote_to_exists = True
            sudo = 'is it sudo?'
            remote_exists.side_effect = (remote_from_exists, remote_to_exists)
            execute.side_effect = ('-rw-rw-r-- 1 foo foo 4490 Dez 11 22:24 %s' % to_file, None)

            self.role.remote_symlink(from_file, to_file, sudo=sudo)

            self.assertEqual(remote_exists.mock_calls, [
                call(from_file),
                call(to_file),
            ])
            self.assertEqual(execute.mock_calls, [
                call('ls -la %s' % to_file, stdout=False, sudo=sudo),
            ])

    @istest
    def doesnt_create_symlink_if_symlink_with_same_name_already_exists(self):
        with self.execute_mock() as execute, self.mock_role_method('remote_exists') as remote_exists:
            from_file = '/from/file'
            to_file = '/to/file'
            remote_from_exists = True
            remote_to_exists = True
            sudo = 'is it sudo?'
            remote_exists.side_effect = (remote_from_exists, remote_to_exists)
            execute.side_effect = ('-rw-rw-r-- 1 foo foo 4490 Dez 11 22:24 %s -> %s' % (to_file, from_file), None)

            self.role.remote_symlink(from_file, to_file, sudo=sudo)

            self.assertEqual(remote_exists.mock_calls, [
                call(from_file),
                call(to_file),
            ])
            self.assertEqual(execute.mock_calls, [
                call('ls -la %s' % to_file, stdout=False, sudo=sudo),
            ])

    @istest
    def raises_exception_if_remote_file_doesnt_exist(self):
        with self.mock_role_method('remote_exists') as remote_exists:
            from_file = '/from/file'
            to_file = '/to/file'
            remote_from_exists = False
            remote_exists.side_effect = (remote_from_exists, )

            self.assertRaises(RuntimeError, self.role.remote_symlink, from_file, to_file)

    @istest
    def renders_a_template_based_on_absolute_path(self):
        template_file = os.path.join(PROJECT_ROOT, 'tests', 'unit', 'fixtures', 'some_template.txt')
        options = {'foo': 'FOO!'}

        content = self.role.render(template_file, options)

        self.assertIn('foo=FOO!', content)

    @istest
    def renders_a_template_based_on_filename(self):
        template_dir = os.path.join(PROJECT_ROOT, 'tests', 'unit', 'fixtures')
        self.role.context['loader'] = FileSystemLoader(template_dir)
        template_file = 'some_template.txt'
        options = {'foo': 'FOO!'}

        content = self.role.render(template_file, options)

        self.assertIn('foo=FOO!', content)

    @istest
    def writes_ascii_content_to_a_temp_file(self):
        content = 'some content'

        temp_file = self.role.write_to_temp_file(content)
        try:
            self.assertEqual(os.path.dirname(temp_file), tempfile.gettempdir())
            self.assertTrue(os.path.isfile(temp_file))

            with open(temp_file) as f:
                saved_content = f.read().strip()
                self.assertEqual(saved_content, content)
        finally:
            os.remove(temp_file)

    @istest
    def writes_utf8_content_to_a_temp_file(self):
        content = u'Tarek Ziad'

        temp_file = self.role.write_to_temp_file(content)

        try:
            self.assertEqual(os.path.dirname(temp_file), tempfile.gettempdir())
            self.assertTrue(os.path.isfile(temp_file))

            with open(temp_file) as f:
                saved_content = f.read().decode('utf-8').strip()
                self.assertEqual(saved_content, content)
        finally:
            os.remove(temp_file)

    @istest
    def creates_a_new_file_when_remote_doesnt_exist_during_update(self):
        to_file = '/etc/foo.conf'
        sudo = 'is it sudo?'
        owner = 'foo'

        with self.mock_update_data(), self.mock_role_methods('_force_update_file', 'remote_exists'):
            self.role.remote_exists.return_value = False

            self.assertTrue(self.role.update_file('some template', to_file, options='some options', sudo=sudo, owner=owner))
            self.role._force_update_file.assert_called_with(to_file, sudo, self.update_data.local_temp_path, owner)

    @istest
    def updates_file_with_sudo_when_user_is_passed_but_sudo_not(self):
        to_file = '/etc/foo.conf'
        owner = 'foo'

        with self.mock_update_data(), self.mock_role_methods('put_file', 'change_path_owner', 'remote_exists'):
            self.role.remote_exists.return_value = False

            self.assertTrue(self.role.update_file('some template', to_file, options='some options', owner=owner))
            self.role.put_file.assert_called_with(self.update_data.local_temp_path, to_file, True)

    @istest
    def doesnt_use_sudo_implicitly_if_owner_not_passed(self):
        to_file = '/etc/foo.conf'

        with self.mock_update_data(), self.mock_role_methods('put_file', 'change_path_owner', 'remote_exists'):
            self.role.remote_exists.return_value = False

            self.assertTrue(self.role.update_file('some template', to_file, options='some options'))
            self.role.put_file.assert_called_with(self.update_data.local_temp_path, to_file, False)

    @istest
    def updates_file_when_remote_exists_but_is_different(self):
        to_file = '/etc/foo.conf'
        sudo = 'is it sudo?'
        owner = 'foo'

        with self.mock_update_data(), self.mock_role_methods('_force_update_file', 'remote_exists'):
            self.role.remote_exists.return_value = True
            self.update_data.from_md5 = 'some local md5'
            self.update_data.to_md5 = 'some remote md5'

            self.assertTrue(self.role.update_file('some template', to_file, options='some options', sudo=sudo, owner=owner))
            self.role._force_update_file.assert_called_with(to_file, sudo, self.update_data.local_temp_path, owner)

    @istest
    def cleans_temp_file_after_updating(self):
        to_file = '/etc/foo.conf'
        sudo = 'is it sudo?'
        owner = 'foo'

        with open(self.update_data.local_temp_path, 'w') as f:
            f.write('foo')

        with self.mock_update_data(), self.mock_role_methods('_force_update_file', 'remote_exists'):
            self.role.remote_exists.return_value = True

            self.role.update_file('some template', to_file, options='some options', sudo=sudo, owner=owner)

            self.assertFalse(os.path.exists(self.update_data.local_temp_path))

    @istest
    def doesnt_update_file_when_content_is_the_same(self):
        to_file = '/etc/foo.conf'
        sudo = 'is it sudo?'
        owner = 'foo'

        with self.mock_update_data(), self.mock_role_methods('_force_update_file', 'remote_exists'):
            self.role.remote_exists.return_value = True
            self.update_data.from_md5 = 'same md5'
            self.update_data.to_md5 = 'same md5'

            result = self.role.update_file('some template', to_file, options='some options', sudo=sudo, owner=owner)

            self.assertFalse(result)
            self.assertFalse(self.role._force_update_file.called)

    @istest
    def builds_update_data(self):
        from_file = os.path.join(PROJECT_ROOT, 'tests', 'unit', 'fixtures', 'some_template.txt')
        to_file = '/etc/foo.conf'
        options = {'foo': 'FOO!'}
        local_temp_path = '/tmp/template-to-update'
        md5_local = 'some local md5'
        md5_remote = 'some remote md5'

        with self.mock_role_methods('write_to_temp_file', 'md5_local', 'md5_remote'):
            self.role.write_to_temp_file.return_value = local_temp_path
            self.role.md5_local.return_value = md5_local
            self.role.md5_remote.return_value = md5_remote

            update_data = self.role._build_update_data(from_file, options, to_file)

            self.assertEqual(update_data.local_temp_path, local_temp_path)
            self.assertEqual(update_data.from_md5, md5_local)
            self.assertEqual(update_data.to_md5, md5_remote)

    @istest
    def really_updates_file_without_owner(self):
        to_file = '/etc/foo.conf'
        local_temp_path = '/tmp/template-to-update'
        sudo = 'is it sudo?'
        owner = None

        with self.mock_role_method('put_file'):
            self.role._force_update_file(to_file, sudo, local_temp_path, owner)

            self.role.put_file.assert_called_with(local_temp_path, to_file, sudo)

    @istest
    def really_updates_file_with_owner(self):
        to_file = '/etc/foo.conf'
        local_temp_path = '/tmp/template-to-update'
        sudo = 'is it sudo?'
        owner = 'foo'

        with self.mock_role_methods('put_file', 'change_path_owner'):
            self.role._force_update_file(to_file, sudo, local_temp_path, owner)

            self.role.put_file.assert_called_with(local_temp_path, to_file, sudo)
            self.role.change_path_owner.assert_called_with(to_file, owner)

    @istest
    def checks_that_content_differs_when_md5_is_different(self):
        self.assertTrue(self.role._contents_differ('some local md5', 'some remote md5'))

    @istest
    def checks_that_content_doesnt_differ_when_md5_is_the_same(self):
        self.assertFalse(self.role._contents_differ('same md5', 'same md5'))

    @istest
    def checks_that_content_doesnt_differ_when_md5_is_the_same_even_with_spaces(self):
        self.assertFalse(self.role._contents_differ('same md5      ', '  same md5'))

    @istest
    def checks_that_content_differs_when_a_md5_is_none(self):
        self.assertTrue(self.role._contents_differ(None, 'some md5'))
        self.assertTrue(self.role._contents_differ('some md5', None))
        self.assertFalse(self.role._contents_differ(None, None))

    @istest
    def reads_a_remote_file(self):
        path = '/some/path'
        sudo = 'is it sudo?'
        content = 'some content'
        with self.mock_role_method('execute_python') as execute_python:
            execute_python.return_value = content

            self.assertEqual(self.role.read_remote_file(path, sudo), content)

            execute_python.assert_called_with("import codecs; print codecs.open('%s', 'r', 'utf-8').read()" % path, stdout=False, sudo=sudo)

    @istest
    def checks_that_a_process_is_running(self):
        process = 'nginx'
        sudo = 'is it sudo?'

        with self.execute_mock() as execute:
            execute.return_value = '0'

            self.assertTrue(self.role.is_process_running(process, sudo=sudo))
            execute.assert_called_with('ps aux | egrep %s | egrep -v egrep > /dev/null;echo $?' % process, stdout=False, sudo=sudo)

    @istest
    def checks_that_a_process_is_not_running(self):
        process = 'nginx'
        sudo = 'is it sudo?'

        with self.execute_mock() as execute:
            execute.return_value = '1'

            self.assertFalse(self.role.is_process_running(process, sudo=sudo))
            execute.assert_called_with('ps aux | egrep %s | egrep -v egrep > /dev/null;echo $?' % process, stdout=False, sudo=sudo)

    @istest
    def checks_that_a_file_has_a_certain_line(self):
        content = """
        some content
        127.0.0.1    localhost
        some other content
        """
        file_path = '/some/path'
        line = '127.0.0.1 localhost'

        with self.mock_role_methods('remote_exists', 'read_remote_file'):
            self.role.remote_exists.return_value = True
            self.role.read_remote_file.return_value = content

            self.assertTrue(self.role.has_line(line, file_path))

            self.role.remote_exists.assert_called_with(file_path)
            self.role.read_remote_file.assert_called_with(file_path)

    @istest
    def checks_that_a_file_has_a_certain_line_metachars(self):
        content = "some content\r\n127.0.0.1    localhost\r\nsome other content"
        file_path = '/some/path'
        line = '127.0.0.1 localhost'

        with self.mock_role_methods('remote_exists', 'read_remote_file'):
            self.role.remote_exists.return_value = True
            self.role.read_remote_file.return_value = content

            self.assertTrue(self.role.has_line(line, file_path))

            self.role.remote_exists.assert_called_with(file_path)
            self.role.read_remote_file.assert_called_with(file_path)

    @istest
    def checks_that_a_file_doesnt_have_a_certain_line(self):
        content = """
        some content
        127.0.0.1    localhost
        some other content
        """
        file_path = '/some/path'
        line = '192.168.0.1 my-gateway'

        with self.mock_role_methods('remote_exists', 'read_remote_file'):
            self.role.remote_exists.return_value = True
            self.role.read_remote_file.return_value = content

            self.assertFalse(self.role.has_line(line, file_path))

            self.role.remote_exists.assert_called_with(file_path)
            self.role.read_remote_file.assert_called_with(file_path)

    @istest
    def checks_that_a_file_doesnt_have_a_certain_line_when_file_doesnt_exist(self):
        file_path = '/some/path'
        line = '192.168.0.1 my-gateway'

        with self.mock_role_methods('remote_exists', 'read_remote_file'):
            self.role.remote_exists.return_value = False

            self.assertFalse(self.role.has_line(line, file_path))

            self.role.remote_exists.assert_called_with(file_path)
            self.assertFalse(self.role.read_remote_file.called)

    @istest
    def uses_role_context_manager(self):
        manager = self.role.using('some role')
        self.assertEqual(manager.role, 'some role')
        self.assertEqual(manager.context, self.role.context)
        self.assertEqual(manager.prov, self.role.prov)

    @istest
    def test_roles_in_context(self):
        dir = {}
        self.role.context["roles_in_context"] = dir
        self.assertIs(self.role.roles_in_context, dir)

    @istest
    def removes_paths_if_in_paths_to_remove(self):

        self.role._paths_to_remove.add("foo")
        with self.mock_role_method("remove_dir") as remove:
            self.role.cleanup()
        remove.assert_called_once_with("foo", True, True)

    @istest
    def assert_paths_to_remove_empty_on_creation(self):
        self.assertEqual(len(self.role._paths_to_remove), 0)

    @istest
    def assert_no_exception_on_error_while_deleting(self):
        self.role._paths_to_remove.add("foo")
        with patch("provy.core.roles.Role.remove_dir", Mock(side_effect=IOError)):
            self.role.cleanup()

    @istest
    def assert_error_logged_on_deleting(self):
        self.role._paths_to_remove.add("foo")
        with patch("provy.core.roles.Role.remove_dir", Mock(side_effect=IOError)):
            with self.mock_role_method("log") as log:
                self.role.cleanup()
        self.assertEqual(len(log.mock_calls), 1)

    @istest
    def test_remote_list_dir(self):
        with self.mock_role_method("execute_python") as execute:
            execute.return_value = "{}"
            self.role.remote_list_directory("/some/path")
        execute.assert_called_once_with('''import os, json; print json.dumps(os.listdir('/some/path'))''', False, True)

    @istest
    def puts_file_when_executing_python_script(self):
        sudo = 'is it sudo?'
        stdout = 'should it stdout?'
        with self.mock_role_methods('execute', 'create_remote_temp_file', 'put_file') as (execute, create_remote_temp_file, put_file):
            create_remote_temp_file.return_value = "/tmp/scriptfoo.py"

            self.role.execute_python_script("script", stdout, sudo)

            put_file.assert_called_once_with(ANY, "/tmp/scriptfoo.py", sudo, False)
            execute.assert_called_once_with(
                'python "{}"'.format("/tmp/scriptfoo.py"),
                stdout,
                sudo
            )

    @istest
    def test_script_converted(self):
        with patch.multiple("provy.core.roles.Role", execute=DEFAULT,
                            create_remote_temp_file=DEFAULT,
                            put_file=DEFAULT) as values:
            values['create_remote_temp_file'].return_value = "/tmp/scriptfoo.py"
            self.role.execute_python_script("script", False, False)

        self.assertTrue(isinstance(values['put_file'].mock_calls[0][1][0], StringIO))

    @istest
    def test_script_file_not_converted(self):
        script = Mock(spec=file)
        with patch.multiple("provy.core.roles.Role", execute=DEFAULT,
                            create_remote_temp_file=DEFAULT,
                            put_file=DEFAULT) as values:
            values['create_remote_temp_file'].return_value = "/tmp/scriptfoo.py"
            self.role.execute_python_script(script, False, False)

        self.assertIs(values['put_file'].mock_calls[0][1][0], script)


class UsingRoleTest(ProvyTestCase):
    def any_context(self):
        return {'used_roles': {}}

    @istest
    def returns_role_instance_for_with_block(self):
        class DummyRole(Role):
            def schedule_cleanup(self):
                pass
        with UsingRole(DummyRole, None, self.any_context()) as role:
            self.assertIsInstance(role, DummyRole)

    @istest
    def doesnt_fail_if_role_is_cleaned_up_before_exiting(self):
        class DummyRole(Role):
            def schedule_cleanup(self):
                pass
        with UsingRole(DummyRole, None, self.any_context()) as role:
            del role.context['roles_in_context'][DummyRole]

    @istest
    def provisions_role_when_entering_with_block(self):
        sentinel = MagicMock()

        class DummyRole(Role):
            def schedule_cleanup(self):
                pass

            def provision(self):
                sentinel()

        with UsingRole(DummyRole, None, self.any_context()):
            self.assertTrue(sentinel.called)

    @istest
    def triggers_schedule_cleanup_when_exiting_with_block(self):
        sentinel = MagicMock()

        class DummyRole(Role):
            def schedule_cleanup(self):
                sentinel()

        with UsingRole(DummyRole, None, self.any_context()):
            self.assertFalse(sentinel.called)
        self.assertTrue(sentinel.called)

    @istest
    def reuses_role_if_already_in_use(self):
        class DummyRole(Role):
            def schedule_cleanup(self):
                pass
        context = self.any_context()
        instance = DummyRole(None, context)
        context['used_roles'][DummyRole] = instance

        using = UsingRole(DummyRole, None, context)

        with using:
            self.assertEqual(using.role_instance, instance)


class RemoteTempFileTests(ProvyTestCase):

    def any_context(self):
        return {'used_roles': {}}

    def setUp(self):
        super(RemoteTempFileTests, self).setUp()
        self.instance = Role(None, self.any_context())
        self.patcher = patch("provy.core.roles.Role.remote_temp_dir", Mock(return_value="/tmp"))
        self.patcher.start()
        self.ensure_dir_patcher = patch("provy.core.roles.Role.ensure_dir", Mock(return_value="/tmp"))
        self.ensure_dir_patcher.start()

    def tearDown(self):
        self.patcher.stop()
        self.ensure_dir_patcher.stop()

    @istest
    def file_created_in_tempdir(self):
        file = self.instance.create_remote_temp_file("foo")
        self.assertTrue(file.startswith("/tmp"))

    @istest
    def directory_created_with_proper_name(self):
        dir = self.instance.create_remote_temp_dir("foobar")
        self.assertEqual("/tmp/foobar", dir)
        self.assertEqual(list(self.instance._paths_to_remove)[0], '/tmp/foobar')

    @istest
    def directory_created_without_cleanup(self):
        dir = self.instance.create_remote_temp_dir("foobar", cleanup=False)
        self.assertEqual("/tmp/foobar", dir)
        self.assertEqual(self.instance._paths_to_remove, set())

    @istest
    def file_created_with_proper_suffix(self):
        file = self.instance.create_remote_temp_file(suffix="sql")
        self.assertEqual(file[-3:], "sql")

    @istest
    def files_will_be_deleted_on_cleanup_if_requested(self):
        file = self.instance.create_remote_temp_file(cleanup=True)
        self.assertIn(file, self.instance._paths_to_remove)

    @istest
    def directories_will_be_deleted_on_cleanup_if_requested(self):
        directory = self.instance.create_remote_temp_dir(cleanup=True)
        self.assertIn(directory, self.instance._paths_to_remove)

    @istest
    def files_will_not_be_deleted_on_cleanup_if_requested(self):
        file = self.instance.create_remote_temp_file(cleanup=False)
        self.assertNotIn(file, self.instance._paths_to_remove)

    @istest
    def directories_will_not_be_deleted_on_cleanup_if_requested(self):
        dirs = self.instance.create_remote_temp_file(cleanup=False)
        self.assertNotIn(dirs, self.instance._paths_to_remove)

    @istest
    def check_if_random_files_have_different_names(self):
        dirs = set()
        for _ in range(100):
            dirs.add(self.instance.create_remote_temp_file())
        self.assertEqual(len(dirs), 100)

    @istest
    def check_if_random_directories_have_different_names(self):
        dirs = set()
        for _ in range(100):
            dirs.add(self.instance.create_remote_temp_dir())
        self.assertEqual(len(dirs), 100)

    @istest
    def check_if_directories_have_proper_mode(self):
        mode = "666"
        with self.mock_role_method("change_path_mode") as change_path_mode:
            dir = self.instance.create_remote_temp_dir(chmod=mode)
        change_path_mode.assert_called_once_with(dir, mode)

    @istest
    def check_if_directories_have_proper_owner(self):
        owner = "user"
        self.instance.create_remote_temp_dir(owner=owner)
        self.instance.ensure_dir.assert_called_once_with(ANY, owner, ANY)

########NEW FILE########
__FILENAME__ = test_runner
from nose.tools import istest

from provy.core.errors import ConfigurationError
from provy.core.runner import get_items, recurse_items
from tests.unit.tools.helpers import ProvyTestCase


class RunnerTest(ProvyTestCase):
    @istest
    def cannot_get_items_if_prov_doesnt_have_required_attribute(self):
        self.assertRaises(ConfigurationError, get_items, 'some prov variable', 'inexistant_item_name', 'inexistant_item_key', 'some test func')

    @istest
    def builds_items_list_after_recursing_over_a_dict(self):

        def foo_macher(item):
            return 'foo' in item

        found_items = []

        collection = {
            'my name': 'foo name',
            'personal stuff': {
                'car': 'some foo truck',
                'books': ['foo', 'bar'],
                'bar': 'something with iron, just ignore',
                'others': {
                    'foo': 'something undescribable',
                },
            },
        }

        recurse_items(collection, foo_macher, found_items)

        expected_items = [
            'foo name',
            'some foo truck',
            ['foo', 'bar'],
            {
                'foo': 'something undescribable',
            },
        ]
        self.assertListEqual(sorted(found_items), sorted(expected_items), found_items)

########NEW FILE########
__FILENAME__ = test_utils
import os

from mock import patch
from nose.tools import istest

from provy.core.utils import provyfile_path_from, provyfile_module_from, import_module
from tests.unit.tools.helpers import ProvyTestCase


class UtilsTest(ProvyTestCase):
    @istest
    def gets_provyfile_path_from_args(self):
        existing_file = 'path/to/provyfile.py'

        with patch.object(os.path, 'exists') as exists:
            exists.return_value = True

            self.assertEqual(provyfile_path_from(args=[existing_file]), existing_file)

    @istest
    def raises_exception_if_file_given_but_not_existant(self):
        existing_file = 'path/to/provyfile.py'

        with patch.object(os.path, 'exists') as exists:
            exists.return_value = False

            self.assertRaises(IOError, provyfile_path_from, args=[existing_file])

    @istest
    def raises_exception_if_file_given_is_absolute(self):
        existing_file = '/path/to/provyfile.py'

        with patch.object(os.path, 'exists') as exists:
            exists.return_value = True

            self.assertRaises(ValueError, provyfile_path_from, args=[existing_file])

    @istest
    def gets_provyfile_as_default_value_if_existant(self):
        with patch.object(os.path, 'exists') as exists:
            exists.side_effect = [True]

            self.assertEqual(provyfile_path_from(args=[]), 'provyfile.py')

    @istest
    def gets_provy_file_as_default_value_if_existant(self):
        with patch.object(os.path, 'exists') as exists:
            exists.side_effect = [False, True]

            self.assertEqual(provyfile_path_from(args=[]), 'provy_file.py')

    @istest
    def raises_exception_if_no_provyfile_is_found(self):
        with patch.object(os.path, 'exists') as exists:
            exists.side_effect = [False, False]

            self.assertRaises(IOError, provyfile_path_from, args=[])

    @istest
    def gets_provyfile_module_from_simple_path(self):
        self.assertEqual(provyfile_module_from('provyfile.py'), 'provyfile')

    @istest
    def gets_provyfile_module_from_nested_path(self):
        self.assertEqual(provyfile_module_from('some/dir/provyfile.py'), 'some.dir.provyfile')

    @istest
    def gets_provyfile_module_from_nested_path_without_extenstion(self):
        self.assertEqual(provyfile_module_from('some/dir/provyfile'), 'some.dir.provyfile')

    @istest
    def imports_a_module_with_dotted_notation(self):
        class foo_package:
            class bar_package:
                class baz_module:
                    pass

        with patch('__builtin__.__import__') as import_:
            import_.return_value = foo_package

            module = import_module('foo_package.bar_package.baz_module')

            self.assertEqual(module, foo_package.bar_package.baz_module)

    @istest
    def imports_a_module_with_simple_notation(self):
        class foo_module:
            pass

        with patch('__builtin__.__import__') as import_:
            import_.return_value = foo_module

            module = import_module('foo_module')

            self.assertEqual(module, foo_module)

########NEW FILE########
__FILENAME__ = test_postgresql
from contextlib import contextmanager

from mock import MagicMock, patch
from nose.tools import istest

from provy.more.base import BasePostgreSQLRole
from tests.unit.tools.helpers import ProvyTestCase


class PostgreSQLRoleTestCase(ProvyTestCase):
    def setUp(self):
        super(PostgreSQLRoleTestCase, self).setUp()
        self.role = BasePostgreSQLRole(prov=None, context={})
        self.execute = MagicMock(side_effect=self.return_execution_result)
        self.execution_results = []
        self.execution_count = -1
        self.assertion_count = -1

    def successful_execution(self, query, user='postgres'):
        return self.execution(True, query, user)

    def failed_execution(self, query, user='postgres'):
        return self.execution(False, query, user)

    def return_execution_result(self, *args, **kwargs):
        self.execution_count += 1
        return self.execution_results[self.execution_count]

    @contextmanager
    def execution(self, return_value, query, user='postgres'):
        self.execution_results.append(return_value)
        with patch('provy.core.roles.Role.execute', self.execute):
            yield
            self.assert_executed(query, user)

    def assert_executed(self, query, user):
        name, e_args, e_kwargs = self.execute.mock_calls[self.assertion_count]
        self.assertion_count -= 1
        self.assertEqual(e_args[0], query)
        self.assertEqual(e_kwargs.get('user'), user)


class PostgreSQLRoleTest(PostgreSQLRoleTestCase):
    @istest
    def nested_test(self):
        """This test is to guarantee that the execution results go from the outer to the inner context managers."""
        with self.successful_execution("1"), self.failed_execution("2"):
            self.assertTrue(self.execute("1", stdout=False, user='postgres'))
            self.assertFalse(self.execute("2", stdout=False, user='postgres'))

    @istest
    def creates_a_user_prompting_for_password(self):
        with self.successful_execution("createuser -PSDR foo"):
            self.assertTrue(self.role.create_user("foo"))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def creates_a_user_without_password(self):
        with self.successful_execution("createuser -SDR foo"):
            self.assertTrue(self.role.create_user("foo", ask_password=False))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def creates_a_superuser(self):
        with self.successful_execution("createuser -Ps foo"):
            self.assertTrue(self.role.create_user("foo", is_superuser=True))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def creates_a_user_that_can_create_databases(self):
        with self.successful_execution("createuser -PSdR foo"):
            self.assertTrue(self.role.create_user("foo", can_create_databases=True))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def creates_a_user_that_can_create_roles(self):
        with self.successful_execution("createuser -PSDr foo"):
            self.assertTrue(self.role.create_user("foo", can_create_roles=True))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def drops_the_user(self):
        with self.successful_execution("dropuser foo"):
            self.assertTrue(self.role.drop_user("foo"))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def verifies_that_the_user_exists(self):
        with self.successful_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='foo'\""):
            self.assertTrue(self.role.user_exists("foo"))

    @istest
    def verifies_that_the_user_doesnt_exist(self):
        with self.failed_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='bar'\""):
            self.assertFalse(self.role.user_exists("bar"))

    @istest
    def ensures_user_is_created_if_it_doesnt_exist_yet(self):
        with self.failed_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='bar'\""):
            with self.successful_execution("createuser -PSDR bar"):
                self.assertTrue(self.role.ensure_user("bar"))

    @istest
    def ensures_user_is_created_without_password_if_it_doesnt_exist_yet(self):
        with self.failed_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='bar'\""):
            with self.successful_execution("createuser -SDR bar"):
                self.assertTrue(self.role.ensure_user("bar", ask_password=False))

    @istest
    def doesnt_create_user_if_it_already_exists(self):
        with self.successful_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='baz'\""):
            self.assertTrue(self.role.ensure_user("baz"))

    @istest
    def ensures_superuser_is_created_if_it_doesnt_exist_yet(self):
        with self.failed_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='bar'\""):
            with self.successful_execution("createuser -Ps bar"):
                self.assertTrue(self.role.ensure_user("bar", is_superuser=True))

    @istest
    def ensures_user_with_more_privileges_is_created_if_it_doesnt_exist_yet(self):
        with self.failed_execution("psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='bar'\""):
            with self.successful_execution("createuser -PSdr bar"):
                self.assertTrue(self.role.ensure_user("bar", can_create_databases=True, can_create_roles=True))

    @istest
    def creates_a_database(self):
        with self.successful_execution("createdb foo"):
            self.assertTrue(self.role.create_database("foo"))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def creates_a_database_with_a_particular_owner(self):
        with self.successful_execution("createdb foo -O bar"):
            self.assertTrue(self.role.create_database("foo", owner="bar"))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def drops_the_database(self):
        with self.successful_execution("dropdb foo"):
            self.assertTrue(self.role.drop_database("foo"))
            name, e_args, e_kwargs = self.execute.mock_calls[0]
            self.assertEqual(e_kwargs['stdout'], True)

    @istest
    def verifies_that_the_database_exists(self):
        with self.successful_execution('psql -tAc "SELECT 1 from pg_database WHERE datname=\'foo\'"'):
            self.assertTrue(self.role.database_exists("foo"))

    @istest
    def verifies_that_the_database_doesnt_exist(self):
        with self.failed_execution('psql -tAc "SELECT 1 from pg_database WHERE datname=\'foo\'"'):
            self.assertFalse(self.role.database_exists("foo"))

    @istest
    def creates_database_if_it_doesnt_exist_yet(self):
        with self.failed_execution('psql -tAc "SELECT 1 from pg_database WHERE datname=\'bar\'"'):
            with self.successful_execution("createdb bar"):
                self.assertTrue(self.role.ensure_database("bar"))

    @istest
    def creates_database_with_particular_owner_if_it_doesnt_exist_yet(self):
        with self.failed_execution('psql -tAc "SELECT 1 from pg_database WHERE datname=\'bar\'"'):
            with self.successful_execution("createdb bar -O baz"):
                self.assertTrue(self.role.ensure_database("bar", owner="baz"))

    @istest
    def doesnt_create_database_if_it_already_exists(self):
        with self.successful_execution('psql -tAc "SELECT 1 from pg_database WHERE datname=\'bar\'"'):
            self.assertTrue(self.role.ensure_database("bar"))

    @istest
    def provision_should_raise_not_implemented_error(self):
        self.assertRaises(NotImplementedError, self.role.provision)

########NEW FILE########
__FILENAME__ = fixtures
FOO_DB_WITH_JOHN_GRANTS = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'
*************************** 2. row ***************************
Grants for john@%: GRANT ALL PRIVILEGES ON `foo`.* TO 'john'@'%'
"""


FOO_DB_WITHOUT_JOHN_GRANTS = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'
"""


FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19'
*************************** 2. row ***************************
Grants for john@%: GRANT ALL PRIVILEGES ON `foo`.* TO 'john'@'%' WITH GRANT OPTION
"""


HOSTS_FOR_USER = """
*************************** 1. row ***************************
Host: 127.0.0.1
*************************** 2. row ***************************
Host: ::1
*************************** 3. row ***************************
Host: my-desktop
*************************** 4. row ***************************
Host: localhost
"""


DATABASES = """
*************************** 1. row ***************************
Database: information_schema
*************************** 2. row ***************************
Database: mysql
*************************** 3. row ***************************
Database: performance_schema
*************************** 4. row ***************************
Database: test
"""

########NEW FILE########
__FILENAME__ = test_mysql
from mock import call, patch
from nose.tools import istest

from .fixtures import (
    FOO_DB_WITH_JOHN_GRANTS,
    FOO_DB_WITHOUT_JOHN_GRANTS,
    FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION,
    HOSTS_FOR_USER,
    DATABASES,
)
from provy.more.centos import YumRole, MySQLRole
from tests.unit.tools.helpers import ProvyTestCase


class MySQLRoleTest(ProvyTestCase):
    def setUp(self):
        super(MySQLRoleTest, self).setUp()
        self.role = MySQLRole(prov=None, context={})

    @istest
    def has_no_grant_if_not_granted(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITHOUT_JOHN_GRANTS
            self.assertFalse(self.role.has_grant('ALL', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('ALL', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_with_grant_option(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION
            self.assertTrue(self.role.has_grant('ALL', 'foo', 'john', '%', True))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_even_if_provided_full(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('ALL PRIVILEGES', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_even_if_provided_as_lowercase_string(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('all', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def can_get_user_grants(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITHOUT_JOHN_GRANTS
            expected = ["GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'"]
            self.assertEqual(expected, self.role.get_user_grants('john', '%'))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(YumRole) as mock_yum, self.execute_mock() as execute:
            mock_yum.ensure_package_installed.return_value = 'some result'

            self.role.provision()

            self.assertEqual(execute.mock_calls, [
                call("mysqladmin -u %s -p'temppass' password '%s'" % (self.role.mysql_root_user, self.role.mysql_root_pass),
                     stdout=False, sudo=True),
            ])
            self.assertEqual(mock_yum.ensure_package_installed.mock_calls, [
                call('mysql-server'),
                call('mysql-devel'),
                call('mysql-libs'),
            ])

    @istest
    def installs_necessary_packages_to_provision_again(self):
        with self.using_stub(YumRole) as mock_yum, self.execute_mock() as execute:
            mock_yum.ensure_package_installed.return_value = False

            self.role.provision()

            self.assertFalse(execute.called)
            self.assertEqual(mock_yum.ensure_package_installed.mock_calls, [
                call('mysql-server'),
                call('mysql-devel'),
                call('mysql-libs'),
            ])

    @istest
    def gets_user_hosts(self):
        with self.execute_mock() as execute:
            execute.return_value = HOSTS_FOR_USER

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [
                '127.0.0.1',
                '::1',
                'my-desktop',
                'localhost',
            ])
            execute.assert_called_with('''mysql -u root -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def gets_user_hosts_using_password(self):
        with self.execute_mock() as execute:
            execute.return_value = HOSTS_FOR_USER
            self.role.mysql_root_pass = 'mypass'

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [
                '127.0.0.1',
                '::1',
                'my-desktop',
                'localhost',
            ])
            execute.assert_called_with('''mysql -u root --password="mypass" -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def gets_empty_user_hosts(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [])
            execute.assert_called_with('''mysql -u root -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def checks_that_a_user_exists(self):
        with patch.object(self.role, 'get_user_hosts') as get_user_hosts:
            get_user_hosts.return_value = ['localhost']

            self.assertTrue(self.role.user_exists('johndoe', 'localhost'))

            get_user_hosts.assert_called_with('johndoe')

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with patch.object(self.role, 'get_user_hosts') as get_user_hosts:
            get_user_hosts.return_value = ['localhost']

            self.assertFalse(self.role.user_exists('johndoe', 'somewhere-else'))

            get_user_hosts.assert_called_with('johndoe')

    @istest
    def creates_a_user_if_it_doesnt_exist_yet(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = False

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertTrue(result)
            execute.assert_called_with("""mysql -u root -e "CREATE USER 'johndoe'@'localhost' IDENTIFIED BY 'mypass';" mysql""", sudo=True, stdout=False)

    @istest
    def doesnt_create_user_if_it_already_exists(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = True

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertFalse(result)
            self.assertFalse(execute.called)

    @istest
    def creates_a_user_with_mysql_password(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = False
            self.role.mysql_root_pass = 'otherpass'

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertTrue(result)
            execute.assert_called_with("""mysql -u root --password="otherpass" -e "CREATE USER 'johndoe'@'localhost' IDENTIFIED BY 'mypass';" mysql""",
                                       sudo=True, stdout=False)

    @istest
    def checks_that_a_database_is_present(self):
        with self.execute_mock() as execute:
            execute.return_value = DATABASES

            result = self.role.is_database_present('performance_schema')

            self.assertTrue(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def checks_that_a_database_is_not_present(self):
        with self.execute_mock() as execute:
            execute.return_value = DATABASES

            result = self.role.is_database_present('bad_bad_database')

            self.assertFalse(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def checks_that_a_database_is_not_present_when_there_is_none(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            result = self.role.is_database_present('performance_schema')

            self.assertFalse(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def creates_a_database_if_it_doesnt_exist_yet(self):
        with patch.object(self.role, 'is_database_present') as is_database_present, self.execute_mock() as execute:
            is_database_present.return_value = False

            result = self.role.ensure_database('my_data')

            self.assertTrue(result)
            execute.assert_called_with('mysql -u root -e "CREATE DATABASE my_data" mysql', sudo=True, stdout=False)

    @istest
    def doesnt_create_a_database_if_it_already_exists(self):
        with patch.object(self.role, 'is_database_present') as is_database_present, self.execute_mock() as execute:
            is_database_present.return_value = True

            result = self.role.ensure_database('my_data')

            self.assertFalse(result)
            self.assertFalse(execute.called)

    @istest
    def grants_privilege_if_not_granted_yet(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=False)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.* TO 'john'@'%'" mysql''', stdout=False, sudo=True)

    @istest
    def grants_privilege_if_not_granted_yet_for_table(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo.bar', username='john', login_from='%', with_grant_option=False)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.bar TO 'john'@'%'" mysql''', stdout=False, sudo=True)

    @istest
    def grants_privilege_with_grant_option_if_not_granted_yet(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=True)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.* TO 'john'@'%' WITH GRANT OPTION" mysql''', stdout=False, sudo=True)

    @istest
    def doesnt_grant_privilege_if_already_granted(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = True

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=True)

            self.assertFalse(result)
            self.assertFalse(execute.called)

########NEW FILE########
__FILENAME__ = test_postgresql
from mock import call, patch
from nose.tools import istest

from provy.more.centos import YumRole, PostgreSQLRole
from tests.unit.more.base.database import test_postgresql


class PostgreSQLRoleTestCase(test_postgresql.PostgreSQLRoleTestCase):
    def setUp(self):
        super(PostgreSQLRoleTestCase, self).setUp()
        self.role = PostgreSQLRole(prov=None, context={})


class PostgreSQLRoleTest(PostgreSQLRoleTestCase):
    @istest
    def ensure_initialized(self):
        with self.failed_execution('ls -A /var/lib/pgsql/data', None):
            with self.successful_execution('service postgresql initdb', None):
                self.assertTrue(self.role._ensure_initialized())

        with self.successful_execution('ls -A /var/lib/pgsql/data', None):
            self.assertTrue(self.role._ensure_initialized())

    @istest
    def verifies_db_is_initialized(self):
        with self.successful_execution('ls -A /var/lib/pgsql/data', None):
            self.assertTrue(self.role._is_db_initialized())

    @istest
    def verifies_db_is_not_initialized(self):
        with self.failed_execution('ls -A /var/lib/pgsql/data', None):
            self.assertFalse(self.role._is_db_initialized())

    @istest
    def ensures_postegres_is_running(self):
        with self.execution('..stopped..', 'service postgresql status', None):
            with self.successful_execution('service postgresql start', None):
                self.assertTrue(self.role._ensure_running())

    @istest
    def ensures_postegres_is_not_running(self):
        with self.execution('..running..', 'service postgresql status', None):
            self.assertTrue(self.role._ensure_running())

    @istest
    def ensures_postgres_on_startup(self):
        with self.execution('......', 'chkconfig --list', None):
            with self.execution('', 'chkconfig --add postgresql', None):
                with self.execution('', 'chkconfig postgresql on', None):
                    self.assertTrue(self.role._run_on_startup())

    @istest
    def ensures_postgres_not_on_startup(self):
        with self.execution('..\r\npostgresql     \t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off\r\n..', 'chkconfig --list', None):
            self.assertFalse(self.role._run_on_startup())

    @istest
    def change_directory_to_postgres_data_dir(self):
        with patch('fabric.api.cd') as cd_mock, self.execute_mock() as execute:
            self.role._execute('ls')
            self.assertEqual(cd_mock.call_args, call('/var/lib/pgsql'))
            self.assertEqual(
                execute.call_args, call('ls', sudo=True, stdout=True, user='postgres')
            )

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(YumRole) as mock_yum, self.mock_role_methods('_run_on_startup', '_ensure_running', '_ensure_initialized'):
            print mock_yum
            self.role.provision()
            install_calls = mock_yum.ensure_package_installed.mock_calls
            self.assertEqual(
                install_calls,
                [call('postgresql-server'), call('postgresql-devel')],
            )

            self.assertTrue(self.role._run_on_startup.called)
            self.assertTrue(self.role._ensure_running.called)
            self.assertTrue(self.role._ensure_initialized.called)

########NEW FILE########
__FILENAME__ = test_rabbitmq
from mock import call, patch
from nose.tools import istest

from provy.more.centos import RabbitMqRole, YumRole
from provy.more.centos.messaging.rabbitmq import GUEST_USER_WARNING
from tests.unit.tools.helpers import ProvyTestCase


class RabbitMqRoleTest(ProvyTestCase):
    def setUp(self):
        super(RabbitMqRoleTest, self).setUp()
        self.role = RabbitMqRole(prov=None, context={})

    def output_list_vhosts(self, vhosts):
        all_strings = ['Listing vhosts ...'] + vhosts + ['...done.']
        return '\r\n'.join(all_strings)

    @istest
    def checks_that_a_user_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = ['john', 'jack']

            result = self.role.user_exists('john')

            self.assertTrue(result)
            execute.assert_called_with('rabbitmqctl list_users', sudo=True, stdout=False)

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = ['john', 'jack']

            result = self.role.user_exists('brian')

            self.assertFalse(result)
            execute.assert_called_with('rabbitmqctl list_users', sudo=True, stdout=False)

    @istest
    def installs_necessary_packages_to_provision(self, **mocks):
        with self.using_stub(YumRole) as mock_yum, self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = False

            self.role.provision()

            mock_yum.ensure_up_to_date.assert_called_with()
            mock_yum.ensure_package_installed.assert_called_with('rabbitmq-server')

    @istest
    def executes_the_correct_commands_to_provision(self, **mocks):
        with self.using_stub(YumRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = False
            self.role.user_exists.return_value = False

            self.role.provision()

            self.assertEqual(self.role.execute.mock_calls, [
                call('chkconfig --add rabbitmq-server', stdout=False, sudo=True),
                call('chkconfig rabbitmq-server on', stdout=False, sudo=True),
                call('service rabbitmq-server start', stdout=False, sudo=True),
            ])

    @istest
    def doesnt_start_rabbit_if_already_started_during_provisioning(self, **mocks):
        with self.using_stub(YumRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = False

            self.role.provision()

            self.assertEqual(self.role.execute.mock_calls, [
                call('chkconfig --add rabbitmq-server', stdout=False, sudo=True),
                call('chkconfig rabbitmq-server on', stdout=False, sudo=True),
            ])

    @istest
    def warns_about_guest_user(self, **mocks):
        with self.using_stub(YumRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'), patch('provy.more.centos.messaging.rabbitmq.warn') as warn:
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = True

            self.role.provision()

            warn.assert_called_once_with(GUEST_USER_WARNING)

    @istest
    def checks_that_a_vhost_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = self.output_list_vhosts([
                'foo',
                'bar',
            ])

            self.assertTrue(self.role.vhost_exists('foo'))
            execute.assert_called_once_with('rabbitmqctl list_vhosts', stdout=False, sudo=True)

    @istest
    def checks_that_a_vhost_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = self.output_list_vhosts([
                'foo',
                'bar',
            ])

            self.assertFalse(self.role.vhost_exists('baz'))
            execute.assert_called_once_with('rabbitmqctl list_vhosts', stdout=False, sudo=True)

    @istest
    def ensures_user_is_created_if_it_doesnt_exist_yet(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            result = self.role.ensure_user('foo-user', 'foo-pass')

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_once_with('rabbitmqctl add_user foo-user foo-pass', sudo=True)

    @istest
    def add_administrator_user(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            result = self.role.ensure_user('foo-user', 'foo-pass', True)

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_with('rabbitmqctl set_user_tags foo-user administrator', sudo=True)

    @istest
    def doesnt_create_user_if_it_already_exists(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = True

            result = self.role.ensure_user('foo-user', 'foo-pass')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def deletes_user_if_it_exists(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = True

            self.role.delete_user('foo-user')

            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_once_with('rabbitmqctl delete_user foo-user', sudo=True, stdout=False)

    @istest
    def doesnt_delete_user_if_it_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.delete_user('foo-user')

            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_vhost_is_created_if_it_doesnt_exist_yet(self):
        with self.mock_role_methods('vhost_exists', 'execute'):
            self.role.vhost_exists.return_value = False

            result = self.role.ensure_vhost('foo-vhost')

            self.assertTrue(result)
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.role.execute.assert_called_once_with('rabbitmqctl add_vhost foo-vhost', sudo=True)

    @istest
    def doesnt_create_vhost_if_it_already_exists(self):
        with self.mock_role_methods('vhost_exists', 'execute'):
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_vhost('foo-vhost')

            self.assertFalse(result)
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_permission_is_given(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = True
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.role.execute.assert_called_once_with('rabbitmqctl set_permissions -p foo-vhost foo-user foo bar', sudo=True, stdout=False)

    @istest
    def doesnt_give_permission_if_user_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = False
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def doesnt_give_permission_if_vhost_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = True
            self.role.vhost_exists.return_value = False

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.assertFalse(self.role.execute.called)

########NEW FILE########
__FILENAME__ = test_pip
from contextlib import contextmanager

from mock import patch, call
from nose.tools import istest

from provy.more.centos import YumRole, PipRole
from tests.unit.tools.helpers import ProvyTestCase


# This seems silly, but it actually helps with test readability ;-)
NOTHING = None


class PipRoleTestCase(ProvyTestCase):
    @contextmanager
    def executing(self, command, returning=None, user=None):
        with self.execute_mock() as execute:
            execute.return_value = returning
            yield execute
            if command is not None:
                execute.assert_called_with(command, sudo=True, stdout=False, user=user)
            else:
                self.assertFalse(execute.called)

    @contextmanager
    def checking_that_package(self, is_installed=True, can_be_updated=None):
        with self.mock_role_method('is_package_installed') as is_package_installed:
            is_package_installed.return_value = is_installed
            if can_be_updated is not None:
                with self.mock_role_method('package_can_be_updated') as package_can_be_updated:
                    package_can_be_updated.return_value = can_be_updated
                    yield
            else:
                yield
            self.assertTrue(is_package_installed.called)

    @contextmanager
    def remote_version_as(self, version):
        with self.mock_role_method('get_package_remote_version') as get_package_remote_version:
            get_package_remote_version.return_value = version
            yield

    @contextmanager
    def latest_version_as(self, version):
        with self.mock_role_method('get_package_latest_version') as get_package_latest_version:
            get_package_latest_version.return_value = version
            yield

    @contextmanager
    def installing(self, package):
        with self.mock_role_method('ensure_package_installed') as ensure_package_installed:
            yield
            if package is not None:
                ensure_package_installed.assert_called_with(package)
            else:
                self.assertFalse(ensure_package_installed.called)


class PipRoleTest(PipRoleTestCase):
    def setUp(self):
        super(PipRoleTest, self).setUp()
        self.role = PipRole(prov=None, context={'user': 'johndoe'})

    @istest
    def extracts_package_name_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input('django'), {'name': 'django'})

    @istest
    def extracts_package_name_version_and_equal_to_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input('django==1.2.3'), {"name": "django", "version": "1.2.3", "version_constraint": "=="})

    @istest
    def extracts_package_name_version_and_greater_or_equal_to_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input("django>=1.2.3"), {"name": "django", "version": "1.2.3", "version_constraint": ">="})

    @istest
    def extracts_package_name_from_specific_repository_path(self):
        self.assertEqual(self.role.extract_package_data_from_input('-e hg+http://bitbucket.org/bkroeze/django-keyedcache/#egg=django-keyedcache'),
                         {"name": "django-keyedcache"})

    @istest
    def extracts_package_name_from_specific_repository_path_without_egg(self):
        self.assertEqual(self.role.extract_package_data_from_input('-e hg+http://bitbucket.org/bkroeze/django-keyedcache/'),
                         {"name": "-e hg+http://bitbucket.org/bkroeze/django-keyedcache/"})

    @istest
    def extracts_package_name_from_specific_repository_url(self):
        self.assertEqual(self.role.extract_package_data_from_input('http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz'),
                         {"name": "http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz"})

    @istest
    def checks_if_a_package_is_installed_by_name(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django"))

    @istest
    def checks_if_a_package_is_installed_by_name_and_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django==1.2.3"))

    @istest
    def fails_check_if_a_package_is_installed_by_greater_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertFalse(self.role.is_package_installed("django>=1.3.0"))

    @istest
    def fails_check_if_a_package_is_installed_by_lesser_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django>=1.1.0"))

    @istest
    def fails_check_if_a_package_is_installed_by_greater_version_through_parameter(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertFalse(self.role.is_package_installed("django", version="1.3.0"))

    @istest
    def fails_check_if_a_package_is_installed_when_package_doesnt_exist(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning=""):
            self.assertFalse(self.role.is_package_installed("django"))

    @istest
    def ensures_requirements_are_installed(self):
        from os.path import abspath, join, dirname
        with self.mock_role_method('ensure_package_installed') as ensure_package_installed:
            requirements_file_name = abspath(join(dirname(__file__), "../../../fixtures/for_testing.txt"))
            self.role.ensure_requirements_installed(requirements_file_name)
            ensure_package_installed.assert_has_calls([
                call('Django'),
                call('yolk==0.4.1'),
                call('http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz'),
                call('-e hg+http://bitbucket.org/bkroeze/django-threaded-multihost/#egg=django-threaded-multihost'),
            ])

    @istest
    def doesnt_install_a_package_if_its_already_installed_by_name(self):
        with self.checking_that_package(is_installed=True), self.executing(NOTHING):
            self.role.ensure_package_installed('django')

    @istest
    def doesnt_install_a_package_if_its_already_installed_by_name_and_version(self):
        with self.checking_that_package(is_installed=True), self.executing(NOTHING):
            self.role.ensure_package_installed('django', version='1.2.3')

    @istest
    def installs_a_package_by_name_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django'):
            self.role.ensure_package_installed('django')

    @istest
    def installs_a_package_with_a_different_user(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django', user='donjoe'):
            self.role.user = 'donjoe'
            self.role.ensure_package_installed('django')

    @istest
    def installs_a_package_by_name_and_equal_version_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django==1.2.3'):
            self.role.ensure_package_installed('django', version='1.2.3')

    @istest
    def installs_a_package_by_name_and_greater_equal_version_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django>=1.2.3'):
            self.role.ensure_package_installed('django', version='>=1.2.3')

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(YumRole) as mock_yum, self.executing('easy_install pip'):
            self.role.provision()
            install_calls = mock_yum.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('python-setuptools'), call('python-devel'), call('gcc')])

    @istest
    def gets_none_as_version_if_remote_doesnt_have_it_installed(self):
        with self.warn_only(), self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning=''):
            self.assertIsNone(self.role.get_package_remote_version('django'))

    @istest
    def gets_version_if_remote_has_it_installed(self):
        with self.warn_only(), self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning='django==1.2.3'):
            self.assertEqual(self.role.get_package_remote_version('django'), '1.2.3')

    @istest
    def gets_none_as_package_latest_version_if_no_such_package_exists(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            mock_server_proxy.package_releases.return_value = None

            self.assertIsNone(self.role.get_package_latest_version('django'))

    @istest
    def gets_package_latest_version_by_same_provided_name(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            mock_server_proxy.package_releases.return_value = ['1.3.0', '1.2.3']

            self.assertEqual(self.role.get_package_latest_version('django'), '1.3.0')
            mock_server_proxy.package_releases.assert_called_with('django')

    @istest
    def gets_package_latest_version_by_capitalized_provided_name_when_plain_name_is_not_found(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            returned_values = [
                None,
                ['1.3.0', '1.2.3']
            ]
            mock_server_proxy.package_releases.side_effect = returned_values

            self.assertEqual(self.role.get_package_latest_version('django'), '1.3.0')
            mock_server_proxy.package_releases.assert_called_with('Django')

    @istest
    def says_that_package_can_be_updated_when_its_older_than_latest(self):
        with self.remote_version_as('1.2.3'), self.latest_version_as('1.3.0'):
            self.assertTrue(self.role.package_can_be_updated('django'))

    @istest
    def says_that_package_cant_be_updated_when_its_equal_latest(self):
        with self.remote_version_as('1.3.0'), self.latest_version_as('1.3.0'):
            self.assertFalse(self.role.package_can_be_updated('django'))

    @istest
    def updates_package_if_its_out_of_date(self):
        with self.checking_that_package(is_installed=True, can_be_updated=True), self.executing('pip install -U --no-dependencies django'):
            self.role.ensure_package_up_to_date('django')

    @istest
    def installs_package_if_not_even_installed(self):
        with self.checking_that_package(is_installed=False), self.installing('django'):
            self.role.ensure_package_up_to_date('django')

    @istest
    def doesn_install_anything_if_package_is_already_up_to_date(self):
        with self.checking_that_package(is_installed=True, can_be_updated=False), self.executing(NOTHING), self.installing(NOTHING):
            self.role.ensure_package_up_to_date('django')

    @istest
    def sets_specific_user_for_operations(self):
        self.role.use_sudo = True
        self.role.user = None
        self.role.set_user('johndoe')

        self.assertFalse(self.role.use_sudo)
        self.assertEqual(self.role.user, 'johndoe')

    @istest
    def sets_back_to_sudo(self):
        self.role.use_sudo = False
        self.role.user = 'johndoe'
        self.role.set_sudo()

        self.assertTrue(self.role.use_sudo)
        self.assertEqual(self.role.user, None)

########NEW FILE########
__FILENAME__ = test_yum
from datetime import datetime, timedelta
import sys

from mock import patch, MagicMock
from nose.tools import istest

from provy.more.centos import YumRole, PackageNotFound
from provy.more.centos.package import yum
from tests.unit.tools.helpers import ProvyTestCase


class YumRoleTest(ProvyTestCase):
    def setUp(self):
        super(YumRoleTest, self).setUp()
        self.role = YumRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.mock_role_methods('ensure_up_to_date', 'ensure_package_installed'):
            self.role.provision()

            self.role.ensure_up_to_date.assert_called_once_with()
            self.role.ensure_package_installed.assert_called_once_with('curl')

    @istest
    def ensures_gpg_key_is_added(self):
        with self.execute_mock():
            self.role.ensure_gpg_key('http://some.repo')

            self.role.execute.assert_called_once_with('curl http://some.repo | rpm --import -', sudo=True, stdout=False)

    @istest
    def checks_that_repository_exists_in_yum_repos(self):
        with self.execute_mock() as execute:
            execute.return_value = '''
            some
            repo
            foo-bar
            '''

            result = self.role.has_source('foo-bar')

            self.assertTrue(result)
            execute.assert_called_once_with("cat /etc/yum.repos.d/CentOS-Base.repo", sudo=True, stdout=False)

    @istest
    def checks_that_repository_doesnt_exist_in_apt_source(self):
        with self.execute_mock() as execute:
            execute.return_value = 'some repo'

            result = self.role.has_source('foo-bar')

            self.assertFalse(result)

    @istest
    def ensures_a_source_string_is_added_to_the_repos(self):
        source_line = 'foo-bar-repo'
        with self.execute_mock() as execute, self.mock_role_method('has_source') as has_source:
            has_source.return_value = False

            self.assertTrue(self.role.ensure_yum_source(source_line))

            self.assertTrue(has_source.called)
            execute.assert_called_once_with('echo "{}" >> /etc/yum.repos.d/CentOS-Base.repo'.format(source_line), sudo=True, stdout=False)

    @istest
    def doesnt_add_source_if_it_already_exists(self):
        source_line = 'foo-bar-repo'
        with self.execute_mock() as execute, self.mock_role_method('has_source') as has_source:
            has_source.return_value = True

            self.assertFalse(self.role.ensure_yum_source(source_line))

            self.assertFalse(execute.called)

    @istest
    def gets_update_date_file_as_a_property(self):
        with self.mock_role_method('remote_temp_dir'):
            self.role.remote_temp_dir.return_value = '/foo/bar'

            self.assertEqual(self.role.update_date_file, '/foo/bar/last_yum_update')

    @istest
    def stores_update_date(self):
        with self.mock_role_methods('update_date_file', 'execute'), patch.object(yum, 'datetime') as mock_datetime:
            self.role.update_date_file = '/foo/bar'
            when = datetime.strptime('2013-01-01', '%Y-%m-%d')
            mock_datetime.now.return_value = when

            self.role.store_update_date()

            self.role.execute.assert_called_once_with('echo "01-01-13 00:00:00" > /foo/bar', stdout=False)

    @istest
    def gets_last_update_date(self):
        with self.mock_role_methods('remote_exists', 'update_date_file', 'read_remote_file'):
            self.role.update_date_file = '/foo/bar'
            self.role.remote_exists.return_value = True
            self.role.read_remote_file.return_value = '01-01-13 00:00:00'

            result = self.role.get_last_update_date()

            self.assertEqual(result, datetime.strptime('2013-01-01', '%Y-%m-%d'))
            self.role.remote_exists.assert_called_once_with(self.role.update_date_file)
            self.role.read_remote_file.assert_called_once_with(self.role.update_date_file)

    @istest
    def gets_none_as_last_update_if_there_was_no_update_yet(self):
        with self.mock_role_methods('remote_exists', 'update_date_file', 'read_remote_file'):
            self.role.update_date_file = '/foo/bar'
            self.role.remote_exists.return_value = False

            result = self.role.get_last_update_date()

            self.assertIsNone(result)
            self.assertFalse(self.role.read_remote_file.called)

    @istest
    def updates_yum_when_passed_time_limit(self):
        with patch.object(yum, 'datetime') as mock_datetime, self.mock_role_methods('get_last_update_date', 'force_update'):
            now = datetime.strptime('2013-01-01', '%Y-%m-%d')
            then = now - timedelta(minutes=31)
            mock_datetime.now.return_value = now
            self.role.get_last_update_date.return_value = then

            self.role.ensure_up_to_date()

            self.role.get_last_update_date.assert_called_once_with()
            self.role.force_update.assert_called_once_with()

    @istest
    def doesnt_update_if_not_passed_from_time_limit(self):
        with patch.object(yum, 'datetime') as mock_datetime, self.mock_role_methods('get_last_update_date', 'force_update'):
            now = datetime.strptime('2013-01-01', '%Y-%m-%d')
            then = now - timedelta(minutes=29)
            mock_datetime.now.return_value = now
            self.role.get_last_update_date.return_value = then

            self.role.ensure_up_to_date()

            self.assertFalse(self.role.force_update.called)

    @istest
    def forces_an_update(self):
        with self.mock_role_methods('execute', 'store_update_date'):
            self.role.force_update()

            self.assertTrue(self.role.context['yum-up-to-date'])
            self.role.execute.assert_called_once_with('yum clean all', stdout=False, sudo=True)
            self.role.store_update_date.assert_called_once_with()

    @istest
    def checks_that_a_package_is_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = '''yes'''

            self.assertTrue(self.role.is_package_installed('foo'))
            execute.assert_called_once_with('rpm -qa foo', sudo=True, stdout=False)

    @istest
    def checks_that_a_package_is_not_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = ''''''

            self.assertFalse(self.role.is_package_installed('baz'))
            execute.assert_called_once_with('rpm -qa baz', sudo=True, stdout=False)

    @istest
    def checks_that_a_package_exists(self):
        with self.execute_mock() as execute:
            self.assertTrue(self.role.package_exists('python'))
            execute.assert_called_with('yum info -q python', stdout=False)

    @istest
    def checks_that_a_package_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = False
            self.assertFalse(self.role.package_exists('phyton'))
            execute.assert_called_with('yum info -q phyton', stdout=False)

    @istest
    def traps_sys_exit_when_checking_if_a_package_exists(self):
        def exit(*args, **kwargs):
            sys.exit(1)

        execute = MagicMock(side_effect=exit)

        with patch('provy.core.roles.Role.execute', execute):
            self.assertFalse(self.role.package_exists('phyton'))

    @istest
    def checks_if_a_package_exists_before_installing(self):
        with self.execute_mock() as execute, self.mock_role_methods('package_exists', 'is_package_installed') as (package_exists, is_package_installed):
            is_package_installed.return_value = False
            package_exists.return_value = True

            result = self.role.ensure_package_installed('python')

            self.assertTrue(result)
            self.assertTrue(package_exists.called)
            execute.assert_called_with('yum install -y python', stdout=False, sudo=True)

    @istest
    def fails_to_install_package_if_it_doesnt_exist(self):
        with self.execute_mock(), self.mock_role_methods('package_exists', 'is_package_installed') as (package_exists, is_package_installed):
            is_package_installed.return_value = False
            package_exists.return_value = False

            self.assertRaises(PackageNotFound, self.role.ensure_package_installed, 'phyton')
            self.assertTrue(package_exists.called)

    @istest
    def doesnt_install_package_if_already_installed(self):
        with self.mock_role_method('is_package_installed'):
            self.role.is_package_installed.return_value = True

            result = self.role.ensure_package_installed('python')

            self.assertFalse(result)

########NEW FILE########
__FILENAME__ = test_user
from mock import call
from nose.tools import istest

from provy.more.centos import UserRole
from tests.unit.tools.helpers import ProvyTestCase


example_groups = """
root
daemon
bin
sys
adm
tty
disk
lp
mail
"""
example_users = """
root
daemon
bin
sys
sync
games
man
lp
mail
"""
example_groups_for_user = """
foo : foo adm cdrom sudo dip plugdev lpadmin sambashare
"""


class UserRoleTest(ProvyTestCase):
    def setUp(self):
        super(UserRoleTest, self).setUp()
        self.role = UserRole(None, {})

    @istest
    def checks_that_a_group_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertTrue(self.role.group_exists('daemon'))
            execute.assert_called_with("cat /etc/group | cut -d ':' -f 1", stdout=False, sudo=True)

    @istest
    def checks_that_a_group_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertFalse(self.role.group_exists('iis'))

    @istest
    def checks_group_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertFalse(self.role.group_exists('roo'))
            self.assertFalse(self.role.group_exists('roots'))

    @istest
    def checks_that_a_user_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertTrue(self.role.user_exists('daemon'))
            execute.assert_called_with("cat /etc/passwd | cut -d ':' -f 1", stdout=False, sudo=True)

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertFalse(self.role.user_exists('iis'))

    @istest
    def checks_user_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertFalse(self.role.user_exists('roo'))
            self.assertFalse(self.role.user_exists('roots'))

    @istest
    def checks_that_a_user_is_in_a_certain_group(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertTrue(self.role.user_in_group('foo', 'sudo'))
            execute.assert_called_with("groups foo", stdout=False, sudo=True)

    @istest
    def checks_that_a_user_is_not_in_a_certain_group(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertFalse(self.role.user_in_group('foo', 'root'))

    @istest
    def checks_that_a_user_is_in_a_certain_group_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertFalse(self.role.user_in_group('foo', 'sud'))
            self.assertFalse(self.role.user_in_group('foo', 'sudoer'))

    @istest
    def cannot_check_user_in_groups_if_username_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = 'groups: foo: User unexistant'

            self.assertRaises(ValueError, self.role.user_in_group, 'foo', 'bar')

    @istest
    def ensures_a_group_is_created(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = False

            self.role.ensure_group('foo')

            self.role.group_exists.assert_called_once_with('foo')
            self.role.execute.assert_called_once_with('groupadd foo', sudo=True, stdout=False)

    @istest
    def ensures_a_group_is_created_with_group_id(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = False

            self.role.ensure_group('foo', group_id=123)

            self.role.group_exists.assert_called_once_with('foo')
            self.role.execute.assert_called_once_with('groupadd --gid 123 foo', sudo=True, stdout=False)

    @istest
    def doesnt_create_group_if_it_already_exists(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = True

            self.role.ensure_group('foo')

            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_the_user_enters_the_provided_groups_when_not_there_already(self):
        with self.mock_role_methods('user_in_group', 'execute'):
            self.role.user_in_group.side_effect = [True, False]

            self.role.ensure_user_groups('foo', ['bar', 'baz'])

            self.assertEqual(self.role.user_in_group.mock_calls, [
                call('foo', 'bar'),
                call('foo', 'baz'),
            ])
            self.role.execute.assert_called_once_with('usermod -G baz foo', sudo=True, stdout=False)

    @istest
    def ensures_user_is_created_when_not_created_yet(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.ensure_user(username='foo-user', identified_by='foo-pass', groups=['foo-group', 'bar-group'])

            self.assertEqual(self.role.ensure_group.mock_calls, [
                call('foo-group'),
                call('bar-group'),
            ])
            self.assertEqual(self.role.execute.mock_calls, [
                call('useradd -g foo-group -s /bin/bash -p foo-pass -d /home/foo-user -m foo-user', stdout=False, sudo=True),
                call('echo "foo-user:foo-pass" | chpasswd', stdout=False, sudo=True),
            ])
            self.role.ensure_user_groups.assert_called_once_with('foo-user', ['foo-group', 'bar-group'])

    @istest
    def ensures_user_is_created_with_irrelevant_password(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.ensure_user(username='foo-user', groups=['foo-group', 'bar-group'])

            self.assertEqual(self.role.execute.mock_calls, [
                call('useradd -g foo-group -s /bin/bash -p none -d /home/foo-user -m foo-user', stdout=False, sudo=True),
            ])

    @istest
    def ensures_user_is_created_with_only_group_as_username(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.ensure_user(username='foo-user')

            self.assertEqual(self.role.execute.mock_calls, [
                call('useradd -g foo-user -s /bin/bash -p none -d /home/foo-user -m foo-user', stdout=False, sudo=True),
            ])

    @istest
    def ensures_user_is_created_with_different_home(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.ensure_user(username='foo-user', home_folder='/srv/bar')

            self.assertEqual(self.role.execute.mock_calls, [
                call('useradd -g foo-user -s /bin/bash -p none -d /srv/bar -m foo-user', stdout=False, sudo=True),
            ])

    @istest
    def doesnt_add_but_set_user_as_admin_when_it_already_exists_but_is_not_admin_yet(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'user_in_group', 'execute'):
            self.role.user_exists.return_value = True
            self.role.user_in_group.return_value = False

            self.role.ensure_user(username='foo-user', is_admin=True)

            self.role.user_in_group.assert_called_once_with('foo-user', 'wheel')
            self.assertEqual(self.role.execute.mock_calls, [
                call('usermod -G wheel foo-user', sudo=True, stdout=False),
            ])

    @istest
    def just_add_user_to_groups_if_its_already_admin(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'user_in_group', 'execute'):
            self.role.user_exists.return_value = True
            self.role.user_in_group.return_value = True

            self.role.ensure_user(username='foo-user', is_admin=True, groups=['foo-group', 'bar-group'])

            self.assertFalse(self.role.execute.called)
            self.role.ensure_user_groups.assert_called_once_with('foo-user', ['foo-group', 'bar-group'])

########NEW FILE########
__FILENAME__ = test_hostname
from mock import patch, call
from nose.tools import istest

from provy.more.centos import HostNameRole
from provy.more.centos.utils import hostname
from tests.unit.tools.helpers import ProvyTestCase


class HostNameRoleTest(ProvyTestCase):
    def setUp(self):
        super(HostNameRoleTest, self).setUp()
        self.role = HostNameRole(None, {})

    @istest
    def ensures_a_hostname_is_configured_when_not_existing(self):
        new_hostname = 'new-hostname'
        with self.mock_role_methods('read_remote_file', 'execute', 'ensure_line'), patch.object(hostname, 'sed') as sed:
            self.role.execute.return_value = 'previous-hostname'
            self.role.read_remote_file.return_value = '''
            some config
            HOSTNAME={}
            some other config
            '''.format(new_hostname)

            result = self.role.ensure_hostname(new_hostname)

            self.assertTrue(result)
            self.role.read_remote_file.assert_called_once_with('/etc/sysconfig/network')
            self.assertEqual(self.role.execute.mock_calls, [
                call('hostname'),
                call('hostname "{}"'.format(new_hostname), sudo=True, stdout=False),
            ])
            self.assertFalse(self.role.ensure_line.called)
            sed.assert_called_once_with('/etc/sysconfig/network', 'HOSTNAME=.*', 'HOSTNAME=new-hostname', use_sudo=True)

    @istest
    def ensures_a_hostname_is_configured_when_another_one_already_exists(self):
        new_hostname = 'new-hostname'
        with self.mock_role_methods('read_remote_file', 'execute', 'ensure_line'), patch.object(hostname, 'sed') as sed:
            self.role.execute.return_value = 'previous-hostname'
            self.role.read_remote_file.return_value = '''
            some config
            some other config
            '''.format(new_hostname)

            result = self.role.ensure_hostname(new_hostname)

            self.assertTrue(result)
            self.role.read_remote_file.assert_called_once_with('/etc/sysconfig/network')
            self.assertEqual(self.role.execute.mock_calls, [
                call('hostname'),
                call('hostname "{}"'.format(new_hostname), sudo=True, stdout=False),
            ])
            self.assertFalse(sed.called)
            self.role.ensure_line.assert_called_once_with('HOSTNAME={}'.format(new_hostname), sudo=True, stdout=False)

    @istest
    def doesnt_configure_the_hostname_if_same_as_server(self):
        new_hostname = 'new-hostname'
        with self.mock_role_methods('execute'):
            self.role.execute.return_value = new_hostname

            result = self.role.ensure_hostname(new_hostname)

            self.assertFalse(result)
            self.assertEqual(self.role.execute.mock_calls, [
                call('hostname'),
            ])

########NEW FILE########
__FILENAME__ = test_git
from mock import call
from nose.tools import istest

from provy.more.centos import YumRole, GitRole
from tests.unit.tools.helpers import ProvyTestCase


class GitRoleTest(ProvyTestCase):
    def setUp(self):
        super(GitRoleTest, self).setUp()
        self.role = GitRole(prov=None, context={})

    @istest
    def ensures_a_repository_is_cloned_as_sudo(self):
        with self.execute_mock() as execute:
            self.role.ensure_repository('some-repo-url', 'working-tree-path')

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=True, stdout=False, user=None)

    @istest
    def ensures_a_repository_is_cloned_as_non_sudo(self):
        with self.execute_mock() as execute:
            self.role.ensure_repository('some-repo-url', 'working-tree-path', sudo=False)

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=False, stdout=False, user=None)

    @istest
    def ensures_a_repository_is_cloned_as_specific_user(self):
        with self.execute_mock() as execute, self.mock_role_method('change_path_owner') as change_path_owner:
            self.role.ensure_repository('some-repo-url', 'working-tree-path', owner='joe', sudo=False)

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=False, stdout=False, user='joe')
            change_path_owner.assert_called_with('working-tree-path', 'joe')

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(YumRole) as yum:
            self.role.provision()

            yum.ensure_up_to_date.assert_called_once_with()
            yum.ensure_package_installed.assert_called_once_with('git-core')

    @istest
    def ensures_a_branch_is_checked_out_if_needed(self):
        sudo = 'is it sudo?'
        owner = 'foo-owner'
        branch = 'some-branch'
        with self.mock_role_methods('remote_exists_dir', 'execute', 'change_path_owner'):
            self.role.remote_exists_dir.return_value = True
            self.role.execute.return_value = '# On branch master'

            self.role.ensure_repository('some-repo-url', 'working-tree-path', sudo=sudo, branch=branch, owner=owner)

            self.assertEqual(self.role.execute.mock_calls, [
                call('git --git-dir="working-tree-path/.git" --work-tree="working-tree-path" status', sudo=True, stdout=False),
                call('git --git-dir="working-tree-path/.git" --work-tree="working-tree-path" checkout some-branch', sudo=sudo, user=owner),
            ])

########NEW FILE########
__FILENAME__ = test_memcached
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, MemcachedRole
from tests.unit.tools.helpers import ProvyTestCase


class MemcachedRoleTest(ProvyTestCase):
    def setUp(self):
        super(MemcachedRoleTest, self).setUp()
        self.role = MemcachedRole(prov=None, context={'owner': 'some-owner'})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.mock_role_method('register_template_loader'):
            self.role.provision()

            self.role.register_template_loader.assert_called_once_with('provy.more.debian.cache')
            self.assertEqual(aptitude.ensure_package_installed.mock_calls, [
                call('memcached'),
                call('libmemcached-dev'),
            ])

    @istest
    def ensures_configuration_with_defaults(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.ensure_conf()

            self.role.update_file.assert_called_once_with('memcached.conf.template', '/etc/memcached.conf', sudo=True, owner='some-owner',
                                                          options={
                                                              'host': '127.0.0.1',
                                                              'memory_in_mb': 64,
                                                              'verbose_level': 0,
                                                              'log_folder': '/var/log/memcached',
                                                              'simultaneous_connections': 1024,
                                                              'port': 11211,
                                                              'lock_down': False,
                                                              'user': 'nobody',
                                                              'maximize_core_file_limit': False,
                                                              'error_when_memory_exhausted': False
                                                          })
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def ensures_configuration_with_custom_config(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.ensure_conf(owner='root',
                                  log_folder='/foo/bar',
                                  verbose_level=123,
                                  memory_in_mb=234,
                                  host='192.168.1.1',
                                  port=12345,
                                  user='somebody',
                                  simultaneous_connections=65432,
                                  lock_down=True,
                                  error_when_memory_exhausted=True,
                                  maximize_core_file_limit=True,
                                  conf_path='/bar/foo.conf')

            self.role.update_file.assert_called_once_with('memcached.conf.template', '/bar/foo.conf', sudo=True, owner='root',
                                                          options={
                                                              'host': '192.168.1.1',
                                                              'memory_in_mb': 234,
                                                              'verbose_level': 123,
                                                              'log_folder': '/foo/bar',
                                                              'simultaneous_connections': 65432,
                                                              'port': 12345,
                                                              'lock_down': True,
                                                              'user': 'somebody',
                                                              'maximize_core_file_limit': True,
                                                              'error_when_memory_exhausted': True,
                                                          })
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_configuration_update_fails(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.ensure_conf()

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def doesnt_restart_if_not_necessary_upon_cleanup(self):
        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertFalse(self.role.restart.called)

    @istest
    def restart_if_necessary_upon_cleanup(self):
        self.role.context['must-restart-memcached'] = True

        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertTrue(self.role.restart.called)

    @istest
    def ensures_memcached_is_restarted(self):
        self.role.context['must-restart-memcached'] = False

        self.role.ensure_restart()

        self.assertTrue(self.role.context['must-restart-memcached'])

    @istest
    def restarts_memcached(self):
        with self.execute_mock():
            self.role.restart()

            self.role.execute.assert_called_once_with('/etc/init.d/memcached restart', sudo=True)

########NEW FILE########
__FILENAME__ = test_varnish
from nose.tools import istest

from provy.more.debian import AptitudeRole, VarnishRole
from tests.unit.tools.helpers import ProvyTestCase


class VarnishRoleTest(ProvyTestCase):
    def setUp(self):
        super(VarnishRoleTest, self).setUp()
        self.role = VarnishRole(prov=None, context={'owner': 'some-owner'})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude:
            self.role.provision()

            aptitude.ensure_package_installed.assert_called_once_with('varnish')

    @istest
    def updates_vcl_and_restarts(self):
        template = 'some-template'
        varnish_vcl_path = 'some-conf-path'
        options = {'foo': 'bar'}
        owner = 'some-owner'

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.ensure_vcl(template, varnish_vcl_path=varnish_vcl_path, options=options, owner=owner)

            self.role.update_file.assert_called_once_with(template, varnish_vcl_path, options=options, owner=owner, sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_vcl_wasnt_updated(self):
        template = 'some-template'
        varnish_vcl_path = 'some-conf-path'
        options = {'foo': 'bar'}
        owner = 'some-owner'

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.ensure_vcl(template, varnish_vcl_path=varnish_vcl_path, options=options, owner=owner)

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def updates_configuration_and_restarts(self):
        template = 'some-template'
        varnish_conf_path = 'some-conf-path'
        options = {'foo': 'bar'}
        owner = 'some-owner'

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.ensure_conf(template, varnish_conf_path=varnish_conf_path, options=options, owner=owner)

            self.role.update_file.assert_called_once_with(template, varnish_conf_path, options=options, owner=owner, sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_configuration_wasnt_updated(self):
        template = 'some-template'
        varnish_conf_path = 'some-conf-path'
        options = {'foo': 'bar'}
        owner = 'some-owner'

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.ensure_conf(template, varnish_conf_path=varnish_conf_path, options=options, owner=owner)

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def doesnt_restart_if_not_necessary_upon_cleanup(self):
        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertFalse(self.role.restart.called)

    @istest
    def restart_if_necessary_upon_cleanup(self):
        self.role.context['must-restart-varnish'] = True

        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertTrue(self.role.restart.called)

    @istest
    def ensures_varnish_is_restarted(self):
        self.role.context['must-restart-varnish'] = False

        self.role.ensure_restart()

        self.assertTrue(self.role.context['must-restart-varnish'])

    @istest
    def restarts_varnish(self):
        with self.execute_mock():
            self.role.restart()

            self.role.execute.assert_called_once_with('START=yes /etc/init.d/varnish restart', sudo=True)

########NEW FILE########
__FILENAME__ = fixtures
FOO_DB_WITH_JOHN_GRANTS = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'
*************************** 2. row ***************************
Grants for john@%: GRANT ALL PRIVILEGES ON `foo`.* TO 'john'@'%'
"""


FOO_DB_WITHOUT_JOHN_GRANTS = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'
"""


FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION = """
*************************** 1. row ***************************
Grants for john@%: GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19'
*************************** 2. row ***************************
Grants for john@%: GRANT ALL PRIVILEGES ON `foo`.* TO 'john'@'%' WITH GRANT OPTION
"""


HOSTS_FOR_USER = """
*************************** 1. row ***************************
Host: 127.0.0.1
*************************** 2. row ***************************
Host: ::1
*************************** 3. row ***************************
Host: my-desktop
*************************** 4. row ***************************
Host: localhost
"""


DATABASES = """
*************************** 1. row ***************************
Database: information_schema
*************************** 2. row ***************************
Database: mysql
*************************** 3. row ***************************
Database: performance_schema
*************************** 4. row ***************************
Database: test
"""

########NEW FILE########
__FILENAME__ = test_mongodb
from nose.tools import istest

from provy.more.debian import AptitudeRole, MongoDBRole
from tests.unit.tools.helpers import ProvyTestCase


class MongoDBRoleTest(ProvyTestCase):
    def setUp(self):
        super(MongoDBRoleTest, self).setUp()
        self.role = MongoDBRole(prov=None, context={})

    def content_from_list(self, list_):
        return '\n'.join(list_)

    @istest
    def installs_necessary_packages_to_provision_to_debian(self):
        with self.using_stub(AptitudeRole) as mock_aptitude:
            self.role.provision_to_debian()

            mock_aptitude.ensure_gpg_key.assert_called_with('http://docs.mongodb.org/10gen-gpg-key.asc')
            mock_aptitude.ensure_aptitude_source.assert_called_with('deb http://downloads-distro.mongodb.org/repo/debian-sysvinit dist 10gen')
            mock_aptitude.force_update.assert_called_with()
            mock_aptitude.ensure_package_installed.assert_called_with('mongodb-10gen')

    @istest
    def installs_necessary_packages_to_provision_to_ubuntu(self):
        with self.using_stub(AptitudeRole) as mock_aptitude:
            self.role.provision_to_ubuntu()

            mock_aptitude.ensure_gpg_key.assert_called_with('http://docs.mongodb.org/10gen-gpg-key.asc')
            mock_aptitude.ensure_aptitude_source.assert_called_with('deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen')
            mock_aptitude.force_update.assert_called_with()
            mock_aptitude.ensure_package_installed.assert_called_with('mongodb-10gen')

    @istest
    def provisions_to_debian_if_is_debian(self):
        with self.provisioning_to('debian'), self.mock_role_method('provision_to_debian') as provision_to_debian:
            self.role.provision()
            provision_to_debian.assert_called_with()

    @istest
    def provisions_to_ubuntu_if_is_ubuntu(self):
        with self.provisioning_to('ubuntu'), self.mock_role_method('provision_to_ubuntu') as provision_to_ubuntu:
            self.role.provision()
            provision_to_ubuntu.assert_called_with()

    @istest
    def restarts_the_server(self):
        with self.execute_mock() as execute:
            self.role.restart()

            execute.assert_called_with('service mongodb restart', sudo=True)

    @istest
    def appends_configuration_to_server_config(self):
        with self.mock_role_methods('read_remote_file', 'write_to_temp_file', 'put_file') as (read_remote_file, write_to_temp_file, put_file):
            read_remote_file.return_value = self.content_from_list([
                'foo=Foo',
            ])
            write_to_temp_file.return_value = '/some/tmp/path'

            self.role.configure({
                'bar': 'Bar',
            })

            read_remote_file.assert_called_with('/etc/mongodb.conf', sudo=True)
            write_to_temp_file.assert_called_with(self.content_from_list([
                'foo = Foo',
                'bar = Bar',
                '',  # newline in the end of the file
            ]))
            put_file.assert_called_with(from_file='/some/tmp/path', to_file='/etc/mongodb.conf', sudo=True)

    @istest
    def converts_boolean_config_from_input(self):
        with self.mock_role_methods('read_remote_file', 'write_to_temp_file', 'put_file') as (read_remote_file, write_to_temp_file, put_file):
            read_remote_file.return_value = self.content_from_list([
                'foo=Foo',
            ])
            write_to_temp_file.return_value = '/some/tmp/path'

            self.role.configure({
                'bar': True,
            })

            read_remote_file.assert_called_with('/etc/mongodb.conf', sudo=True)
            write_to_temp_file.assert_called_with(self.content_from_list([
                'foo = Foo',
                'bar = true',
                '',  # newline in the end of the file
            ]))
            put_file.assert_called_with(from_file='/some/tmp/path', to_file='/etc/mongodb.conf', sudo=True)

    @istest
    def overwrites_original_configuration_when_redefined(self):
        with self.mock_role_methods('read_remote_file', 'write_to_temp_file', 'put_file') as (read_remote_file, write_to_temp_file, put_file):
            read_remote_file.return_value = self.content_from_list([
                'foo=Foo',
            ])
            write_to_temp_file.return_value = '/some/tmp/path'

            self.role.configure({
                'foo': 'Baz',
                'bar': 'Bar',
            })

            read_remote_file.assert_called_with('/etc/mongodb.conf', sudo=True)
            write_to_temp_file.assert_called_with(self.content_from_list([
                'foo = Baz',
                'bar = Bar',
                '',  # newline in the end of the file
            ]))
            put_file.assert_called_with(from_file='/some/tmp/path', to_file='/etc/mongodb.conf', sudo=True)

########NEW FILE########
__FILENAME__ = test_mysql
from mock import call, patch
from nose.tools import istest

from .fixtures import (
    FOO_DB_WITH_JOHN_GRANTS,
    FOO_DB_WITHOUT_JOHN_GRANTS,
    FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION,
    HOSTS_FOR_USER,
    DATABASES,
)
from provy.more.debian import AptitudeRole, MySQLRole
from tests.unit.tools.helpers import ProvyTestCase


class MySQLRoleTest(ProvyTestCase):
    def setUp(self):
        super(MySQLRoleTest, self).setUp()
        self.role = MySQLRole(prov=None, context={})

    @istest
    def has_no_grant_if_not_granted(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITHOUT_JOHN_GRANTS
            self.assertFalse(self.role.has_grant('ALL', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('ALL', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_with_grant_option(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS_AND_GRANT_OPTION
            self.assertTrue(self.role.has_grant('ALL', 'foo', 'john', '%', True))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_even_if_provided_full(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('ALL PRIVILEGES', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def has_grant_if_granted_even_if_provided_as_lowercase_string(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITH_JOHN_GRANTS
            self.assertTrue(self.role.has_grant('all', 'foo', 'john', '%', False))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def can_get_user_grants(self):
        with self.execute_mock() as execute:
            execute.return_value = FOO_DB_WITHOUT_JOHN_GRANTS
            expected = ["GRANT USAGE ON *.* TO 'john'@'%' IDENTIFIED BY PASSWORD '*B9EE00DF55E7C816911C6DA56F1E3A37BDB31093'"]
            self.assertEqual(expected, self.role.get_user_grants('john', '%'))
            execute.assert_called_with('''mysql -u root -E -e "SHOW GRANTS FOR 'john'@'%';" mysql''', sudo=True, stdout=False)

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.execute_mock() as execute:
            mock_aptitude.ensure_package_installed.return_value = 'some result'

            self.role.provision()

            self.assertEqual(execute.mock_calls, [
                call('echo "mysql-server mysql-server/root_password select temppass" | debconf-set-selections',
                     stdout=False, sudo=True),
                call('echo "mysql-server mysql-server/root_password_again select temppass" | debconf-set-selections',
                     stdout=False, sudo=True),
                call("mysqladmin -u %s -p'temppass' password '%s'" % (self.role.mysql_root_user, self.role.mysql_root_pass),
                     stdout=False, sudo=True),
            ])
            self.assertEqual(mock_aptitude.ensure_package_installed.mock_calls, [
                call('mysql-server'),
                call('mysql-client'),
                call('libmysqlclient-dev'),
            ])

    @istest
    def installs_necessary_packages_to_provision_again(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.execute_mock() as execute:
            mock_aptitude.ensure_package_installed.return_value = False

            self.role.provision()

            self.assertEqual(execute.mock_calls, [
                call('echo "mysql-server mysql-server/root_password select temppass" | debconf-set-selections',
                     stdout=False, sudo=True),
                call('echo "mysql-server mysql-server/root_password_again select temppass" | debconf-set-selections',
                     stdout=False, sudo=True),
            ])
            self.assertEqual(mock_aptitude.ensure_package_installed.mock_calls, [
                call('mysql-server'),
                call('mysql-client'),
                call('libmysqlclient-dev'),
            ])

    @istest
    def gets_user_hosts(self):
        with self.execute_mock() as execute:
            execute.return_value = HOSTS_FOR_USER

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [
                '127.0.0.1',
                '::1',
                'my-desktop',
                'localhost',
            ])
            execute.assert_called_with('''mysql -u root -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def gets_user_hosts_using_password(self):
        with self.execute_mock() as execute:
            execute.return_value = HOSTS_FOR_USER
            self.role.mysql_root_pass = 'mypass'

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [
                '127.0.0.1',
                '::1',
                'my-desktop',
                'localhost',
            ])
            execute.assert_called_with('''mysql -u root --password="mypass" -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def gets_empty_user_hosts(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            hosts = self.role.get_user_hosts('root')

            self.assertEqual(hosts, [])
            execute.assert_called_with('''mysql -u root -E -e "select Host from mysql.user where LOWER(User)='root'" mysql''',
                                       sudo=True, stdout=False)

    @istest
    def checks_that_a_user_exists(self):
        with patch.object(self.role, 'get_user_hosts') as get_user_hosts:
            get_user_hosts.return_value = ['localhost']

            self.assertTrue(self.role.user_exists('johndoe', 'localhost'))

            get_user_hosts.assert_called_with('johndoe')

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with patch.object(self.role, 'get_user_hosts') as get_user_hosts:
            get_user_hosts.return_value = ['localhost']

            self.assertFalse(self.role.user_exists('johndoe', 'somewhere-else'))

            get_user_hosts.assert_called_with('johndoe')

    @istest
    def creates_a_user_if_it_doesnt_exist_yet(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = False

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertTrue(result)
            execute.assert_called_with("""mysql -u root -e "CREATE USER 'johndoe'@'localhost' IDENTIFIED BY 'mypass';" mysql""", sudo=True, stdout=False)

    @istest
    def doesnt_create_user_if_it_already_exists(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = True

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertFalse(result)
            self.assertFalse(execute.called)

    @istest
    def creates_a_user_with_mysql_password(self):
        with patch.object(self.role, 'user_exists') as user_exists, self.execute_mock() as execute:
            user_exists.return_value = False
            self.role.mysql_root_pass = 'otherpass'

            result = self.role.ensure_user('johndoe', 'mypass', 'localhost')

            self.assertTrue(result)
            execute.assert_called_with("""mysql -u root --password="otherpass" -e "CREATE USER 'johndoe'@'localhost' IDENTIFIED BY 'mypass';" mysql""",
                                       sudo=True, stdout=False)

    @istest
    def checks_that_a_database_is_present(self):
        with self.execute_mock() as execute:
            execute.return_value = DATABASES

            result = self.role.is_database_present('performance_schema')

            self.assertTrue(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def checks_that_a_database_is_not_present(self):
        with self.execute_mock() as execute:
            execute.return_value = DATABASES

            result = self.role.is_database_present('bad_bad_database')

            self.assertFalse(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def checks_that_a_database_is_not_present_when_there_is_none(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            result = self.role.is_database_present('performance_schema')

            self.assertFalse(result)
            execute.assert_called_with('mysql -u root -E -e "SHOW DATABASES" mysql', stdout=False, sudo=True)

    @istest
    def creates_a_database_if_it_doesnt_exist_yet(self):
        with patch.object(self.role, 'is_database_present') as is_database_present, self.execute_mock() as execute:
            is_database_present.return_value = False

            result = self.role.ensure_database('my_data')

            self.assertTrue(result)
            execute.assert_called_with('mysql -u root -e "CREATE DATABASE my_data" mysql', sudo=True, stdout=False)

    @istest
    def doesnt_create_a_database_if_it_already_exists(self):
        with patch.object(self.role, 'is_database_present') as is_database_present, self.execute_mock() as execute:
            is_database_present.return_value = True

            result = self.role.ensure_database('my_data')

            self.assertFalse(result)
            self.assertFalse(execute.called)

    @istest
    def grants_privilege_if_not_granted_yet(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=False)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.* TO 'john'@'%'" mysql''', stdout=False, sudo=True)

    @istest
    def grants_privilege_if_not_granted_yet_for_table(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo.bar', username='john', login_from='%', with_grant_option=False)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.bar TO 'john'@'%'" mysql''', stdout=False, sudo=True)

    @istest
    def grants_privilege_with_grant_option_if_not_granted_yet(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = False

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=True)

            self.assertTrue(result)
            execute.assert_called_with('''mysql -u root -e "GRANT ALL PRIVILEGES ON foo.* TO 'john'@'%' WITH GRANT OPTION" mysql''', stdout=False, sudo=True)

    @istest
    def doesnt_grant_privilege_if_already_granted(self):
        with patch.object(self.role, 'has_grant') as has_grant, self.execute_mock() as execute:
            has_grant.return_value = True

            result = self.role.ensure_grant('ALL PRIVILEGES', on='foo', username='john', login_from='%', with_grant_option=True)

            self.assertFalse(result)
            self.assertFalse(execute.called)

########NEW FILE########
__FILENAME__ = test_postgresql
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, PostgreSQLRole
from tests.unit.more.base.database import test_postgresql


class PostgreSQLRoleTestCase(test_postgresql.PostgreSQLRoleTestCase):
    def setUp(self):
        super(PostgreSQLRoleTestCase, self).setUp()
        self.role = PostgreSQLRole(prov=None, context={})


class PostgreSQLRoleTest(PostgreSQLRoleTestCase):
    @istest
    def installs_necessary_packages_to_provision_to_ubuntu(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.provisioning_to('ubuntu'):
            self.role.provision()
            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('postgresql'), call('postgresql-server-dev-9.2')])

    @istest
    def installs_necessary_packages_to_provision_to_debian(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.provisioning_to('debian'):
            self.role.provision()
            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('postgresql'), call('postgresql-server-dev-8.4')])

########NEW FILE########
__FILENAME__ = test_redis
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, RedisRole
from tests.unit.tools.helpers import ProvyTestCase


class RedisRoleTest(ProvyTestCase):
    def setUp(self):
        super(RedisRoleTest, self).setUp()
        self.role = RedisRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as mock_aptitude:
            self.role.provision()
            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('redis-server'), call('python-redis')])

########NEW FILE########
__FILENAME__ = test_rabbitmq
from mock import call, patch
from nose.tools import istest

from provy.more.debian import RabbitMqRole, AptitudeRole
from provy.more.debian.messaging.rabbitmq import GUEST_USER_WARNING
from tests.unit.tools.helpers import ProvyTestCase


class RabbitMqRoleTest(ProvyTestCase):
    def setUp(self):
        super(RabbitMqRoleTest, self).setUp()
        self.role = RabbitMqRole(prov=None, context={})

    def output_list_vhosts(self, vhosts):
        all_strings = ['Listing vhosts ...'] + vhosts + ['...done.']
        return '\r\n'.join(all_strings)

    @istest
    def checks_that_a_user_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = ['john', 'jack']

            result = self.role.user_exists('john')

            self.assertTrue(result)
            execute.assert_called_with('rabbitmqctl list_users', sudo=True, stdout=False)

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = ['john', 'jack']

            result = self.role.user_exists('brian')

            self.assertFalse(result)
            execute.assert_called_with('rabbitmqctl list_users', sudo=True, stdout=False)

    @istest
    def installs_necessary_packages_to_provision(self, **mocks):
        with self.using_stub(AptitudeRole) as mock_apt, self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = False

            self.role.provision()

            mock_apt.ensure_up_to_date.assert_called_with()
            mock_apt.ensure_package_installed.assert_called_with('rabbitmq-server')

    @istest
    def executes_the_correct_commands_to_provision(self, **mocks):
        with self.using_stub(AptitudeRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = False
            self.role.user_exists.return_value = False

            self.role.provision()

            self.assertEqual(self.role.execute.mock_calls, [
                call('update-rc.d rabbitmq-server defaults', stdout=False, sudo=True),
                call('update-rc.d rabbitmq-server enable', stdout=False, sudo=True),
                call('service rabbitmq-server start', stdout=False, sudo=True),
            ])

    @istest
    def doesnt_start_rabbit_if_already_started_during_provisioning(self, **mocks):
        with self.using_stub(AptitudeRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'):
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = False

            self.role.provision()

            self.assertEqual(self.role.execute.mock_calls, [
                call('update-rc.d rabbitmq-server defaults', stdout=False, sudo=True),
                call('update-rc.d rabbitmq-server enable', stdout=False, sudo=True),
            ])

    @istest
    def warns_about_guest_user(self, **mocks):
        with self.using_stub(AptitudeRole), self.mock_role_methods('is_process_running', 'user_exists', 'execute'), patch('provy.more.debian.messaging.rabbitmq.warn') as warn:
            self.role.is_process_running.return_value = True
            self.role.user_exists.return_value = True

            self.role.provision()

            warn.assert_called_once_with(GUEST_USER_WARNING)

    @istest
    def checks_that_a_vhost_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = self.output_list_vhosts([
                'foo',
                'bar',
            ])

            self.assertTrue(self.role.vhost_exists('foo'))
            execute.assert_called_once_with('rabbitmqctl list_vhosts', stdout=False, sudo=True)

    @istest
    def checks_that_a_vhost_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = self.output_list_vhosts([
                'foo',
                'bar',
            ])

            self.assertFalse(self.role.vhost_exists('baz'))
            execute.assert_called_once_with('rabbitmqctl list_vhosts', stdout=False, sudo=True)

    @istest
    def ensures_user_is_created_if_it_doesnt_exist_yet(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            result = self.role.ensure_user('foo-user', 'foo-pass')

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_once_with('rabbitmqctl add_user foo-user foo-pass', sudo=True)

    @istest
    def add_administrator_user(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            result = self.role.ensure_user('foo-user', 'foo-pass', True)

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_with('rabbitmqctl set_user_tags foo-user administrator', sudo=True)

    @istest
    def doesnt_create_user_if_it_already_exists(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = True

            result = self.role.ensure_user('foo-user', 'foo-pass')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def deletes_user_if_it_exists(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = True

            self.role.delete_user('foo-user')

            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.execute.assert_called_once_with('rabbitmqctl delete_user foo-user', sudo=True, stdout=False)

    @istest
    def doesnt_delete_user_if_it_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'execute'):
            self.role.user_exists.return_value = False

            self.role.delete_user('foo-user')

            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_vhost_is_created_if_it_doesnt_exist_yet(self):
        with self.mock_role_methods('vhost_exists', 'execute'):
            self.role.vhost_exists.return_value = False

            result = self.role.ensure_vhost('foo-vhost')

            self.assertTrue(result)
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.role.execute.assert_called_once_with('rabbitmqctl add_vhost foo-vhost', sudo=True)

    @istest
    def doesnt_create_vhost_if_it_already_exists(self):
        with self.mock_role_methods('vhost_exists', 'execute'):
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_vhost('foo-vhost')

            self.assertFalse(result)
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_permission_is_given(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = True
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertTrue(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.role.execute.assert_called_once_with('rabbitmqctl set_permissions -p foo-vhost foo-user foo bar', sudo=True, stdout=False)

    @istest
    def doesnt_give_permission_if_user_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = False
            self.role.vhost_exists.return_value = True

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.assertFalse(self.role.execute.called)

    @istest
    def doesnt_give_permission_if_vhost_doesnt_exist(self):
        with self.mock_role_methods('user_exists', 'vhost_exists', 'execute'):
            self.role.user_exists.return_value = True
            self.role.vhost_exists.return_value = False

            result = self.role.ensure_permission('foo-vhost', 'foo-user', 'foo bar')

            self.assertFalse(result)
            self.role.user_exists.assert_called_once_with('foo-user')
            self.role.vhost_exists.assert_called_once_with('foo-vhost')
            self.assertFalse(self.role.execute.called)

########NEW FILE########
__FILENAME__ = test_supervisor
from copy import deepcopy
import os

from mock import call
from nose.tools import istest

from provy.more.debian import PipRole, SupervisorRole
from provy.more.debian.monitoring.supervisor import MUST_UPDATE_CONFIG_KEY, CONFIG_KEY, PROGRAMS_KEY
from tests.unit.tools.helpers import ProvyTestCase


class SupervisorRoleTest(ProvyTestCase):
    def setUp(self):
        super(SupervisorRoleTest, self).setUp()
        self.role = SupervisorRole(prov=None, context={'owner': 'some-owner'})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(PipRole) as mock_pip, self.mock_role_method('register_template_loader'):
            self.role.provision()

            self.role.register_template_loader.assert_called_once_with('provy.more.debian.monitoring')
            mock_pip.ensure_package_installed.assert_called_once_with('supervisor')
            self.assertTrue(mock_pip.set_sudo.called)

    @istest
    def updates_init_script(self):
        config_file_path = '/foo/bar.conf'
        options = {'config_file': os.path.join(config_file_path, 'supervisord.conf')}

        with self.mock_role_methods('update_file', 'execute', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.update_init_script(config_file_path)

            self.role.update_file.assert_called_once_with('supervisord.init.template', '/etc/init.d/supervisord', owner='some-owner', options=options, sudo=True)
            self.assertEqual(self.role.execute.mock_calls, [
                call('chmod +x /etc/init.d/supervisord', sudo=True, stdout=False),
                call('update-rc.d supervisord defaults', sudo=True, stdout=False),
            ])
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_update_init_script_if_file_not_updated(self):
        config_file_path = '/foo/bar.conf'

        with self.mock_role_methods('update_file', 'execute', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.update_init_script(config_file_path)

            self.assertFalse(self.role.execute.called)
            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def ensures_config_will_be_updated(self):
        self.role.context[MUST_UPDATE_CONFIG_KEY] = False

        self.role.ensure_config_update()

        self.assertTrue(self.role.context[MUST_UPDATE_CONFIG_KEY])

    @istest
    def configures_supervisor(self):
        self.role.context[CONFIG_KEY] = None

        self.role.config()

        self.assertEqual(self.role.context[CONFIG_KEY], {
            'config_file_directory': '/home/some-owner',
            'log_file': '/var/log/supervisord.log',
            'log_file_backups': 10,
            'log_file_max_mb': 50,
            'log_level': 'info',
            'pidfile': '/var/run/supervisord.pid',
            'user': 'some-owner',
        })

    @istest
    def configures_supervisor_in_config_directory_with_specific_user(self):
        self.role.context[CONFIG_KEY] = None

        self.role.config(config_file_directory='/foo-dir', user='foo-user')

        self.assertEqual(self.role.context[CONFIG_KEY], {
            'config_file_directory': '/foo-dir',
            'log_file': '/var/log/supervisord.log',
            'log_file_backups': 10,
            'log_file_max_mb': 50,
            'log_level': 'info',
            'pidfile': '/var/run/supervisord.pid',
            'user': 'foo-user',
        })

    @istest
    def enters_a_new_program_context(self):
        with self.role.with_program('foo-program') as program:
            program.directory = '/foo/bar'
            program.command = 'baz.sh'
            program.environment['FOO1'] = 'BAR1'
            program.environment['FOO2'] = 'BAR2'

        self.assertEqual(program.name, 'foo-program')
        self.assertEqual(program.supervisor, self.role)
        self.role.context[PROGRAMS_KEY][0]['environment'] = 'FOO1="BAR1",FOO2="BAR2"'

    @istest
    def preserves_previous_programs_list_when_creating_a_new_program(self):
        with self.role.with_program('foo-program') as program:
            self.role.context[PROGRAMS_KEY] = ['foo']
            program.directory = '/foo/bar'
            program.command = 'baz.sh'

        self.assertEqual(len(self.role.context[PROGRAMS_KEY]), 2)
        self.assertEqual(self.role.context[PROGRAMS_KEY][0], 'foo')

    @istest
    def requires_directory_and_command_to_create_program(self):

        def create_program():
            with self.role.with_program('foo-program'):
                '''Forgot directory or command...'''

        self.assertRaises(RuntimeError, create_program)

    @istest
    def updates_config_file(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            with self.role.with_program('foo-program') as program:
                program.directory = '/foo/bar'
                program.command = 'baz.sh'

            self.role.config()
            options = deepcopy(self.role.context[CONFIG_KEY])
            options['programs'] = self.role.context[PROGRAMS_KEY]
            conf_path = os.path.join(options['config_file_directory'], 'supervisord.conf')

            self.role.update_config_file()

            self.role.update_file.assert_called_once_with('supervisord.conf.template', conf_path, options=options, owner=self.role.context['owner'], sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def configures_itself_if_needed_before_updating_config_file(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            with self.role.with_program('foo-program') as program:
                program.directory = '/foo/bar'
                program.command = 'baz.sh'

            self.assertNotIn(CONFIG_KEY, self.role.context)

            self.role.update_config_file()

            options = deepcopy(self.role.context[CONFIG_KEY])
            options['programs'] = self.role.context[PROGRAMS_KEY]
            conf_path = os.path.join(options['config_file_directory'], 'supervisord.conf')

            self.role.update_file.assert_called_once_with('supervisord.conf.template', conf_path, options=options, owner=self.role.context['owner'], sudo=True)

    @istest
    def doesnt_update_config_if_program_not_configured_yet(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_config_file()

            self.assertFalse(self.role.update_file.called)
            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def updates_config_file_without_programs(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.config()
            options = deepcopy(self.role.context[CONFIG_KEY])
            conf_path = os.path.join(options['config_file_directory'], 'supervisord.conf')

            self.role.update_config_file()

            self.role.update_file.assert_called_once_with('supervisord.conf.template', conf_path, options=options, owner=self.role.context['owner'], sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_updating_config_fails(self):
        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.config()

            self.role.update_config_file()

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def updates_files_upon_cleanup(self):
        with self.mock_role_methods('update_init_script', 'update_config_file'):
            self.role.config()
            self.role.ensure_config_update()

            self.role.cleanup()

            self.role.update_init_script.assert_called_once_with(self.role.context[CONFIG_KEY]['config_file_directory'])
            self.role.update_config_file.assert_called_once_with()

    @istest
    def restarts_upon_cleanup(self):
        with self.mock_role_methods('restart'):
            self.role.ensure_restart()

            self.role.cleanup()

            self.role.restart.assert_called_once_with()

    @istest
    def restarts_supervisor_if_already_running_upon_restart(self):
        with self.mock_role_methods('is_process_running', 'execute'):
            self.role.is_process_running.return_value = True

            self.role.restart()

            self.role.is_process_running.assert_called_once_with('supervisord')
            self.role.execute.assert_called_once_with('/etc/init.d/supervisord restart', sudo=True)

    @istest
    def starts_supervisor_if_not_running_yet_upon_restart(self):
        with self.mock_role_methods('is_process_running', 'execute'):
            self.role.is_process_running.return_value = False

            self.role.restart()

            self.role.is_process_running.assert_called_once_with('supervisord')
            self.role.execute.assert_called_once_with('/etc/init.d/supervisord start', sudo=True)

########NEW FILE########
__FILENAME__ = test_aptitude
from datetime import datetime, timedelta
import sys
from base64 import b64encode

from mock import MagicMock, patch
from nose.tools import istest

from provy.more.debian import AptitudeRole, PackageNotFound
from provy.more.debian.package import aptitude
from tests.unit.tools.helpers import ProvyTestCase


class AptitudeRoleTest(ProvyTestCase):
    def setUp(self):
        super(AptitudeRoleTest, self).setUp()
        self.role = AptitudeRole(prov=None, context={})

    @istest
    def checks_that_a_package_exists(self):
        with self.execute_mock() as execute:
            self.assertTrue(self.role.package_exists('python'))
            execute.assert_called_with('aptitude show python', stdout=False)

    @istest
    def checks_that_a_package_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = False
            self.assertFalse(self.role.package_exists('phyton'))
            execute.assert_called_with('aptitude show phyton', stdout=False)

    @istest
    def traps_sys_exit_when_checking_if_a_package_exists(self):
        def exit(*args, **kwargs):
            sys.exit(1)

        execute = MagicMock(side_effect=exit)

        with patch('provy.core.roles.Role.execute', execute):
            self.assertFalse(self.role.package_exists('phyton'))

    @istest
    def checks_that_a_package_is_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = '''
            foo
            bar
            '''

            self.assertTrue(self.role.is_package_installed('foo'))
            execute.assert_called_once_with("dpkg -l | egrep 'ii[ ]*foo\\b'", stdout=False, sudo=True)

    @istest
    def checks_that_a_package_is_not_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = '''
            foo
            bar
            '''

            self.assertFalse(self.role.is_package_installed('baz'))
            execute.assert_called_once_with("dpkg -l | egrep 'ii[ ]*baz\\b'", stdout=False, sudo=True)

    @istest
    def checks_if_a_package_exists_before_installing(self):
        with self.execute_mock() as execute, self.mock_role_method('package_exists') as package_exists:
            package_exists.return_value = True

            result = self.role.ensure_package_installed('python')

            self.assertTrue(result)
            self.assertTrue(package_exists.called)
            execute.assert_called_with('aptitude install -y python', stdout=False, sudo=True)

    @istest
    def fails_to_install_package_if_it_doesnt_exist(self):
        with self.execute_mock(), self.mock_role_method('package_exists') as package_exists:
            package_exists.return_value = False

            self.assertRaises(PackageNotFound, self.role.ensure_package_installed, 'phyton')
            self.assertTrue(package_exists.called)

    @istest
    def doesnt_install_package_if_already_installed(self):
        with self.mock_role_method('is_package_installed'):
            self.role.is_package_installed.return_value = True

            result = self.role.ensure_package_installed('python')

            self.assertFalse(result)

    @istest
    def ensure_source_must_generate_correct_source_file(self):
        source_line = 'deb http://example.org/pub/ubuntu natty main restricted'
        expected_file = '%s_%s' % (b64encode(source_line)[:12], 'example.org')
        with self.execute_mock() as execute, self.mock_role_method('has_source') as has_source:
            has_source.return_value = False
            self.role.ensure_aptitude_source(source_line)
            self.assertTrue(has_source.called)
            execute.assert_called_with('echo "%s" >> /etc/apt/sources.list.d/%s.list' % (source_line, expected_file), stdout=False, sudo=True)

    @istest
    def doesnt_add_source_if_it_already_exists(self):
        source_line = 'deb http://example.org/pub/ubuntu natty main restricted'
        with self.execute_mock() as execute, self.mock_role_method('has_source') as has_source:
            has_source.return_value = True

            self.assertFalse(self.role.ensure_aptitude_source(source_line))

            self.assertFalse(execute.called)

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.mock_role_methods('execute', 'ensure_up_to_date', 'ensure_package_installed', 'is_package_installed'):
            self.role.is_package_installed.return_value = False

            self.role.provision()

            self.role.is_package_installed.assert_called_once_with('aptitude')
            self.role.execute.assert_called_once_with('apt-get install aptitude -y', stdout=False, sudo=True)
            self.role.ensure_up_to_date.assert_called_once_with()
            self.role.ensure_package_installed.assert_called_once_with('curl')

    @istest
    def doesnt_install_aptitude_if_already_installed_when_provisioning(self):
        with self.mock_role_methods('execute', 'ensure_up_to_date', 'ensure_package_installed', 'is_package_installed'):
            self.role.is_package_installed.return_value = True

            self.role.provision()

            self.role.is_package_installed.assert_called_once_with('aptitude')
            self.assertFalse(self.role.execute.called)
            self.role.ensure_up_to_date.assert_called_once_with()
            self.role.ensure_package_installed.assert_called_once_with('curl')

    @istest
    def ensures_gpg_key_is_added(self):
        with self.execute_mock():
            self.role.ensure_gpg_key('http://some.repo')

            self.role.execute.assert_called_once_with('curl http://some.repo | apt-key add -', stdout=False, sudo=True)

    @istest
    def checks_that_repository_exists_in_apt_source(self):
        with self.execute_mock() as execute:
            execute.return_value = '1'

            result = self.role.has_source('foo-bar')

            self.assertTrue(result)
            execute.assert_called_once_with("grep -ilR '^foo-bar' /etc/apt/sources.list /etc/apt/sources.list.d | wc -l", sudo=True, stdout=False)

    @istest
    def checks_that_repository_doesnt_exist_in_apt_source(self):
        with self.execute_mock() as execute:
            execute.return_value = '0'

            result = self.role.has_source('foo-bar')

            self.assertFalse(result)

    @istest
    def gets_update_date_file_as_a_property(self):
        with self.mock_role_method('remote_temp_dir'):
            self.role.remote_temp_dir.return_value = '/foo/bar'

            self.assertEqual(self.role.update_date_file, '/foo/bar/last_aptitude_update')

    @istest
    def stores_update_date(self):
        with self.mock_role_methods('update_date_file', 'execute'), patch.object(aptitude, 'datetime') as mock_datetime:
            self.role.update_date_file = '/foo/bar'
            when = datetime.strptime('2013-01-01', '%Y-%m-%d')
            mock_datetime.now.return_value = when

            self.role.store_update_date()

            self.role.execute.assert_called_once_with('echo "01-01-13 00:00:00" > /foo/bar', stdout=False)

    @istest
    def gets_last_update_date(self):
        with self.mock_role_methods('remote_exists', 'update_date_file', 'read_remote_file'):
            self.role.update_date_file = '/foo/bar'
            self.role.remote_exists.return_value = True
            self.role.read_remote_file.return_value = '01-01-13 00:00:00'

            result = self.role.get_last_update_date()

            self.assertEqual(result, datetime.strptime('2013-01-01', '%Y-%m-%d'))
            self.role.remote_exists.assert_called_once_with(self.role.update_date_file)
            self.role.read_remote_file.assert_called_once_with(self.role.update_date_file)

    @istest
    def gets_none_as_last_update_if_there_was_no_update_yet(self):
        with self.mock_role_methods('remote_exists', 'update_date_file', 'read_remote_file'):
            self.role.update_date_file = '/foo/bar'
            self.role.remote_exists.return_value = False

            result = self.role.get_last_update_date()

            self.assertIsNone(result)
            self.assertFalse(self.role.read_remote_file.called)

    @istest
    def updates_aptitude_when_passed_time_limit(self):
        with patch.object(aptitude, 'datetime') as mock_datetime, self.mock_role_methods('get_last_update_date', 'force_update'):
            now = datetime.strptime('2013-01-01', '%Y-%m-%d')
            then = now - timedelta(minutes=31)
            mock_datetime.now.return_value = now
            self.role.get_last_update_date.return_value = then

            self.role.ensure_up_to_date()

            self.role.get_last_update_date.assert_called_once_with()
            self.role.force_update.assert_called_once_with()

    @istest
    def doesnt_update_if_not_passed_from_time_limit(self):
        with patch.object(aptitude, 'datetime') as mock_datetime, self.mock_role_methods('get_last_update_date', 'force_update'):
            now = datetime.strptime('2013-01-01', '%Y-%m-%d')
            then = now - timedelta(minutes=29)
            mock_datetime.now.return_value = now
            self.role.get_last_update_date.return_value = then

            self.role.ensure_up_to_date()

            self.assertFalse(self.role.force_update.called)

    @istest
    def forces_an_update(self):
        with self.mock_role_methods('execute', 'store_update_date'):
            self.role.force_update()

            self.assertTrue(self.role.context['aptitude-up-to-date'])
            self.role.execute.assert_called_once_with('aptitude update', stdout=False, sudo=True)
            self.role.store_update_date.assert_called_once_with()

########NEW FILE########
__FILENAME__ = test_gem
from mock import call
from nose.tools import istest

from provy.more.debian import GemRole, RubyRole
from provy.more.debian.package.gem import UPDATE_ALTERNATIVES_COMMAND
from tests.unit.tools.helpers import ProvyTestCase


class GemRoleTest(ProvyTestCase):
    def setUp(self):
        super(GemRoleTest, self).setUp()
        self.role = GemRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.mock_role_method('provision_role'), self.execute_mock() as execute:
            self.role.provision()

            update_alternatives_command = UPDATE_ALTERNATIVES_COMMAND.format(
                version=RubyRole.version,
                priority=RubyRole.priority,
            )
            completion_command = 'ln - sf /etc/bash_completion.d/gem{version} /etc/alternatives/bash_completion_gem'.format(version=RubyRole.version)

            self.role.provision_role.assert_called_once_with(RubyRole)
            self.assertEqual(execute.mock_calls, [
                call(update_alternatives_command, sudo=True),
                call(completion_command, sudo=True),
            ])

    @istest
    def checks_that_a_package_is_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = 'some foo is installed'

            result = self.role.is_package_installed('foo')

            self.assertTrue(result)
            execute.assert_called_once_with("gem list --local | tr '[A-Z]' '[a-z]' | grep foo", stdout=False, sudo=True)

    @istest
    def checks_that_a_package_is_not_installed(self):
        with self.execute_mock() as execute:
            execute.return_value = 'some bar is installed'

            result = self.role.is_package_installed('foo')

            self.assertFalse(result)

    @istest
    def checks_that_a_package_is_installed_with_version(self):
        with self.execute_mock() as execute:
            execute.return_value = 'some foo is installed'

            result = self.role.is_package_installed('foo', '1.8')

            self.assertTrue(result)
            execute.assert_called_once_with("gem list --local | tr '[A-Z]' '[a-z]' | grep foo(1.8)", stdout=False, sudo=True)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name(self):
        with self.execute_mock() as execute, self.mock_role_method('is_package_installed') as is_package_installed:
            is_package_installed.return_value = False

            result = self.role.ensure_package_installed('runit')

            self.assertTrue(result)
            execute.assert_called_with('gem install runit', stdout=False, sudo=True)

    @istest
    def doesnt_install_a_package_if_its_already_installed_yet_by_name(self):
        with self.execute_mock() as execute, self.mock_role_method('is_package_installed') as is_package_installed:
            is_package_installed.return_value = True

            result = self.role.ensure_package_installed('runit')

            self.assertFalse(result)
            self.assertFalse(execute.called)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name_and_version(self):
        with self.execute_mock() as execute, self.mock_role_method('is_package_installed') as is_package_installed:
            is_package_installed.return_value = False

            self.role.ensure_package_installed('runit', '123')

            execute.assert_called_with('gem install runit(123)', sudo=True, stdout=False)

########NEW FILE########
__FILENAME__ = test_npm
from mock import patch
from nose.tools import istest

from provy.more.debian import NodeJsRole, NPMRole
from tests.unit.tools.helpers import ProvyTestCase


class NPMRoleTest(ProvyTestCase):
    def setUp(self):
        super(NPMRoleTest, self).setUp()
        self.role = NPMRole(prov=None, context={})

    @istest
    def provisions_node_js_as_dependency(self):
        with self.mock_role_method('provision_role') as provision_role:
            self.role.provision()

            provision_role.assert_called_with(NodeJsRole)

    @istest
    def checks_that_a_package_is_installed_by_name(self):
        with self.execute_mock() as execute:
            execute.return_value = 'socket.io'

            self.assertTrue(self.role.is_package_installed('socket.io'))

            execute.assert_called_with("npm --global list | egrep 'socket.io'", stdout=False, sudo=True)

    @istest
    def checks_that_a_package_is_not_installed_by_name(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            self.assertFalse(self.role.is_package_installed('socket.io'))

            execute.assert_called_with("npm --global list | egrep 'socket.io'", stdout=False, sudo=True)

    @istest
    def checks_that_a_package_is_installed_by_name_and_version(self):
        with self.execute_mock() as execute:
            execute.return_value = 'socket.io@0.6.17'

            self.assertTrue(self.role.is_package_installed('socket.io', '0.6.17'))

            execute.assert_called_with("npm --global list | egrep 'socket.io@0.6.17'", stdout=False, sudo=True)

    @istest
    def checks_that_a_package_is_not_installed_by_name_and_version(self):
        with self.execute_mock() as execute:
            execute.return_value = ''

            self.assertFalse(self.role.is_package_installed('socket.io', '0.6.17'))

            execute.assert_called_with("npm --global list | egrep 'socket.io@0.6.17'", stdout=False, sudo=True)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name(self):
        with self.execute_mock() as execute, patch('provy.more.debian.NPMRole.is_package_installed') as is_package_installed:
            is_package_installed.return_value = False
            self.role.ensure_package_installed('socket.io')

            execute.assert_called_with('npm install --global socket.io', stdout=False, sudo=True)

    @istest
    def doesnt_install_a_package_if_its_already_installed_yet_by_name(self):
        with self.execute_mock() as execute, patch('provy.more.debian.NPMRole.is_package_installed') as is_package_installed:
            is_package_installed.return_value = True
            self.role.ensure_package_installed('socket.io')

            self.assertFalse(execute.called)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name_and_version(self):
        with self.execute_mock() as execute, patch('provy.more.debian.NPMRole.is_package_installed') as is_package_installed:
            is_package_installed.return_value = False
            self.role.ensure_package_installed('socket.io', '0.6.17')

            execute.assert_called_with('npm install --global socket.io@0.6.17', stdout=False, sudo=True)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name_and_version_with_stdout(self):
        with self.execute_mock() as execute, patch('provy.more.debian.NPMRole.is_package_installed') as is_package_installed:
            is_package_installed.return_value = False
            self.role.ensure_package_installed('socket.io', '0.6.17', stdout=True)

            execute.assert_called_with('npm install --global socket.io@0.6.17', stdout=True, sudo=True)

    @istest
    def installs_a_package_if_its_not_installed_yet_by_name_and_version_without_sudo(self):
        with self.execute_mock() as execute, patch('provy.more.debian.NPMRole.is_package_installed') as is_package_installed:
            is_package_installed.return_value = False
            self.role.ensure_package_installed('socket.io', '0.6.17', sudo=False)

            execute.assert_called_with('npm install --global socket.io@0.6.17', stdout=False, sudo=False)

########NEW FILE########
__FILENAME__ = test_pip
from contextlib import contextmanager

from mock import patch, call
from nose.tools import istest

from provy.more.debian import AptitudeRole, PipRole
from tests.unit.tools.helpers import ProvyTestCase


# This seems silly, but it actually helps with test readability ;-)
NOTHING = None


class PipRoleTestCase(ProvyTestCase):
    @contextmanager
    def executing(self, command, returning=None, user=None):
        with self.execute_mock() as execute:
            execute.return_value = returning
            yield execute
            if command is not None:
                execute.assert_called_with(command, sudo=True, stdout=False, user=user)
            else:
                self.assertFalse(execute.called)

    @contextmanager
    def checking_that_package(self, is_installed=True, can_be_updated=None):
        with self.mock_role_method('is_package_installed') as is_package_installed:
            is_package_installed.return_value = is_installed
            if can_be_updated is not None:
                with self.mock_role_method('package_can_be_updated') as package_can_be_updated:
                    package_can_be_updated.return_value = can_be_updated
                    yield
            else:
                yield
            self.assertTrue(is_package_installed.called)

    @contextmanager
    def remote_version_as(self, version):
        with self.mock_role_method('get_package_remote_version') as get_package_remote_version:
            get_package_remote_version.return_value = version
            yield

    @contextmanager
    def latest_version_as(self, version):
        with self.mock_role_method('get_package_latest_version') as get_package_latest_version:
            get_package_latest_version.return_value = version
            yield

    @contextmanager
    def installing(self, package):
        with self.mock_role_method('ensure_package_installed') as ensure_package_installed:
            yield
            if package is not None:
                ensure_package_installed.assert_called_with(package)
            else:
                self.assertFalse(ensure_package_installed.called)


class PipRoleTest(PipRoleTestCase):
    def setUp(self):
        super(PipRoleTest, self).setUp()
        self.role = PipRole(prov=None, context={'user': 'johndoe'})

    @istest
    def extracts_package_name_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input('django'), {'name': 'django'})

    @istest
    def extracts_package_name_version_and_equal_to_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input('django==1.2.3'), {"name": "django", "version": "1.2.3", "version_constraint": "=="})

    @istest
    def extracts_package_name_version_and_greater_or_equal_to_as_data_from_input(self):
        self.assertEqual(self.role.extract_package_data_from_input("django>=1.2.3"), {"name": "django", "version": "1.2.3", "version_constraint": ">="})

    @istest
    def extracts_package_name_from_specific_repository_path(self):
        self.assertEqual(self.role.extract_package_data_from_input('-e hg+http://bitbucket.org/bkroeze/django-keyedcache/#egg=django-keyedcache'),
                         {"name": "django-keyedcache"})

    @istest
    def extracts_package_name_from_specific_repository_path_without_egg(self):
        self.assertEqual(self.role.extract_package_data_from_input('-e hg+http://bitbucket.org/bkroeze/django-keyedcache/'),
                         {"name": "-e hg+http://bitbucket.org/bkroeze/django-keyedcache/"})

    @istest
    def extracts_package_name_from_specific_repository_url(self):
        self.assertEqual(self.role.extract_package_data_from_input('http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz'),
                         {"name": "http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz"})

    @istest
    def checks_if_a_package_is_installed_by_name(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django"))

    @istest
    def checks_if_a_package_is_installed_by_name_and_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django==1.2.3"))

    @istest
    def fails_check_if_a_package_is_installed_by_greater_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertFalse(self.role.is_package_installed("django>=1.3.0"))

    @istest
    def fails_check_if_a_package_is_installed_by_lesser_version(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertTrue(self.role.is_package_installed("django>=1.1.0"))

    @istest
    def fails_check_if_a_package_is_installed_by_greater_version_through_parameter(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning="django==1.2.3"):
            self.assertFalse(self.role.is_package_installed("django", version="1.3.0"))

    @istest
    def fails_check_if_a_package_is_installed_when_package_doesnt_exist(self):
        with self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning=""):
            self.assertFalse(self.role.is_package_installed("django"))

    @istest
    def ensures_requirements_are_installed_using_correctly_spelled_method_name(self):
        from os.path import abspath, join, dirname
        with self.mock_role_method('ensure_package_installed') as ensure_package_installed:
            requirements_file_name = abspath(join(dirname(__file__), "../../../fixtures/for_testing.txt"))
            self.role.ensure_requirements_installed(requirements_file_name)
            ensure_package_installed.assert_has_calls([
                call('Django'),
                call('yolk==0.4.1'),
                call('http://www.satchmoproject.com/snapshots/trml2pdf-1.2.tar.gz'),
                call('-e hg+http://bitbucket.org/bkroeze/django-threaded-multihost/#egg=django-threaded-multihost'),
            ])

    @istest
    def doesnt_install_a_package_if_its_already_installed_by_name(self):
        with self.checking_that_package(is_installed=True), self.executing(NOTHING):
            self.role.ensure_package_installed('django')

    @istest
    def doesnt_install_a_package_if_its_already_installed_by_name_and_version(self):
        with self.checking_that_package(is_installed=True), self.executing(NOTHING):
            self.role.ensure_package_installed('django', version='1.2.3')

    @istest
    def installs_a_package_by_name_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django'):
            self.role.ensure_package_installed('django')

    @istest
    def installs_a_package_with_a_different_user(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django', user='donjoe'):
            self.role.user = 'donjoe'
            self.role.ensure_package_installed('django')

    @istest
    def installs_a_package_by_name_and_equal_version_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django==1.2.3'):
            self.role.ensure_package_installed('django', version='1.2.3')

    @istest
    def installs_a_package_by_name_and_greater_equal_version_if_its_not_installed(self):
        with self.checking_that_package(is_installed=False), self.executing('pip install django>=1.2.3'):
            self.role.ensure_package_installed('django', version='>=1.2.3')

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.executing('easy_install pip'):
            self.role.provision()
            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('python-setuptools'), call('python-dev')])

    @istest
    def gets_none_as_version_if_remote_doesnt_have_it_installed(self):
        with self.warn_only(), self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning=''):
            self.assertIsNone(self.role.get_package_remote_version('django'))

    @istest
    def gets_version_if_remote_has_it_installed(self):
        with self.warn_only(), self.executing("pip freeze | tr '[A-Z]' '[a-z]' | grep django", returning='django==1.2.3'):
            self.assertEqual(self.role.get_package_remote_version('django'), '1.2.3')

    @istest
    def gets_none_as_package_latest_version_if_no_such_package_exists(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            mock_server_proxy.package_releases.return_value = None

            self.assertIsNone(self.role.get_package_latest_version('django'))

    @istest
    def gets_package_latest_version_by_same_provided_name(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            mock_server_proxy.package_releases.return_value = ['1.3.0', '1.2.3']

            self.assertEqual(self.role.get_package_latest_version('django'), '1.3.0')
            mock_server_proxy.package_releases.assert_called_with('django')

    @istest
    def gets_package_latest_version_by_capitalized_provided_name_when_plain_name_is_not_found(self):
        with patch('xmlrpclib.ServerProxy') as MockServerProxy:
            mock_server_proxy = MockServerProxy.return_value
            returned_values = [
                None,
                ['1.3.0', '1.2.3']
            ]
            mock_server_proxy.package_releases.side_effect = returned_values

            self.assertEqual(self.role.get_package_latest_version('django'), '1.3.0')
            mock_server_proxy.package_releases.assert_called_with('Django')

    @istest
    def says_that_package_can_be_updated_when_its_older_than_latest(self):
        with self.remote_version_as('1.2.3'), self.latest_version_as('1.3.0'):
            self.assertTrue(self.role.package_can_be_updated('django'))

    @istest
    def says_that_package_cant_be_updated_when_its_equal_latest(self):
        with self.remote_version_as('1.3.0'), self.latest_version_as('1.3.0'):
            self.assertFalse(self.role.package_can_be_updated('django'))

    @istest
    def updates_package_if_its_out_of_date(self):
        with self.checking_that_package(is_installed=True, can_be_updated=True), self.executing('pip install -U --no-dependencies django'):
            self.role.ensure_package_up_to_date('django')

    @istest
    def installs_package_if_not_even_installed(self):
        with self.checking_that_package(is_installed=False), self.installing('django'):
            self.role.ensure_package_up_to_date('django')

    @istest
    def doesn_install_anything_if_package_is_already_up_to_date(self):
        with self.checking_that_package(is_installed=True, can_be_updated=False), self.executing(NOTHING), self.installing(NOTHING):
            self.role.ensure_package_up_to_date('django')

    @istest
    def sets_specific_user_for_operations(self):
        self.role.use_sudo = True
        self.role.user = None
        self.role.set_user('johndoe')

        self.assertFalse(self.role.use_sudo)
        self.assertEqual(self.role.user, 'johndoe')

    @istest
    def sets_back_to_sudo(self):
        self.role.use_sudo = False
        self.role.user = 'johndoe'
        self.role.set_sudo()

        self.assertTrue(self.role.use_sudo)
        self.assertEqual(self.role.user, None)

########NEW FILE########
__FILENAME__ = test_virtualenv
from contextlib import contextmanager
import os

from mock import MagicMock, patch, call
from nose.tools import istest

from provy.more.debian import PipRole, VirtualenvRole
from tests.unit.tools.helpers import ProvyTestCase


class VirtualenvRoleTest(ProvyTestCase):
    def setUp(self):
        super(VirtualenvRoleTest, self).setUp()
        self.role = VirtualenvRole(prov=None, context={'user': 'johndoe'})

    @contextmanager
    def env_exists(self, env_name):
        with patch('provy.more.debian.VirtualenvRole.env_exists') as env_exists:
            yield env_exists

    @istest
    def refers_to_specific_subdir_at_user_home(self):
        role = VirtualenvRole(prov=None, context={'user': 'johndoe'})

        self.assertEqual(role.get_base_directory(), '/home/johndoe/.virtualenvs')

    @istest
    def refers_to_specific_subdir_at_root_home(self):
        role = VirtualenvRole(prov=None, context={'user': 'root'})

        self.assertEqual(role.get_base_directory(), '/root/.virtualenvs')

    @istest
    def refers_to_custom_subdir(self):
        role = VirtualenvRole(prov=None, context={'user': 'johndoe'})

        role.base_directory = '/somewhere/else'

        self.assertEqual(role.get_base_directory(), '/somewhere/else')

    @istest
    def installs_virtualenv_harness_when_provisioned(self):
        with self.using_stub(PipRole) as mock_role:
            self.role.provision()
            install_calls = mock_role.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('virtualenv'), call('virtualenvwrapper')])

    @istest
    def creates_a_virtual_environment(self):
        with self.execute_mock() as execute:
            env_dir = self.role.create_env('foo_env')
            self.assertEqual(env_dir, '/home/johndoe/.virtualenvs/foo_env')
            execute.assert_called_with('virtualenv /home/johndoe/.virtualenvs/foo_env', user='johndoe')

    @istest
    def creates_a_virtual_environment_for_a_specific_user(self):
        with self.execute_mock() as execute:
            self.role.user = 'jackisback'
            env_dir = self.role.create_env('foo_env')
            self.assertEqual(env_dir, '/home/jackisback/.virtualenvs/foo_env')
            execute.assert_called_with('virtualenv /home/jackisback/.virtualenvs/foo_env', user='jackisback')

    @istest
    def creates_a_virtual_environment_with_system_site_packages(self):
        with self.execute_mock() as execute:
            self.role.create_env('foo_env', system_site_packages=True)
            execute.assert_called_with('virtualenv --system-site-packages /home/johndoe/.virtualenvs/foo_env', user='johndoe')

    @istest
    def checks_that_a_virtual_env_exists(self):
        with self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = True
            self.assertTrue(self.role.env_exists('fancylib'))
            virtual_env_dir = os.path.join(self.role.get_base_directory(), 'fancylib')
            remote_exists_dir.assert_called_with(virtual_env_dir)

    @istest
    def checks_that_a_virtual_env_doesnt_exist(self):
        with self.mock_role_method('remote_exists_dir') as remote_exists_dir:
            remote_exists_dir.return_value = False
            self.assertFalse(self.role.env_exists('fancylib'))
            virtual_env_dir = os.path.join(self.role.get_base_directory(), 'fancylib')
            remote_exists_dir.assert_called_with(virtual_env_dir)

    @istest
    def wraps_the_env_usage_with_creation_activation_and_deactivation(self):
        execute = MagicMock()

        @contextmanager
        def prefix(command):
            execute('called before prefix')
            execute('prefix: "%s"' % command)
            yield
            execute('called after prefix')

        with patch('provy.core.roles.Role.execute', execute), patch('fabric.api.prefix', prefix), self.env_exists('fancylib') as env_exists:
            venv = VirtualenvRole(prov=None, context={'user': 'johndoe'})
            env_exists.return_value = False

            with venv('fancylib'):
                execute('some command')
                execute('some command 2')

            env_exists.assert_called_with('fancylib')

            env_creation_call = call('virtualenv %s/fancylib' % venv.get_base_directory(), user='johndoe')
            activation_prefix_call = call('prefix: "source %s/fancylib/bin/activate"' % venv.get_base_directory())

            expected_executes = [
                env_creation_call,
                call('called before prefix'),
                activation_prefix_call,
                call('some command'),
                call('some command 2'),
                call('called after prefix'),
            ]
            execute.assert_has_calls(expected_executes)

    @istest
    def doesnt_create_env_if_it_already_exists(self):
        execute = MagicMock()

        @contextmanager
        def prefix(command):
            execute('called before prefix')
            execute('prefix: "%s"' % command)
            yield
            execute('called after prefix')

        with patch('provy.core.roles.Role.execute', execute), patch('fabric.api.prefix', prefix), self.env_exists('fancylib') as env_exists:
            venv = VirtualenvRole(prov=None, context={'user': 'johndoe'})
            env_exists.return_value = True

            with venv('fancylib'):
                execute('some command')
                execute('some command 2')

            env_exists.assert_called_with('fancylib')

            activation_prefix_call = call('prefix: "source %s/fancylib/bin/activate"' % venv.get_base_directory())

            expected_executes = [
                call('called before prefix'),
                activation_prefix_call,
                call('some command'),
                call('some command 2'),
                call('called after prefix'),
            ]
            self.assertEqual(execute.mock_calls, expected_executes)

    @istest
    def wraps_the_env_usage_creating_system_site_packages(self):
        with self.execute_mock() as execute:
            with self.role('fancylib', system_site_packages=True):
                pass
            execute.assert_any_call('virtualenv --system-site-packages %s/fancylib' % self.role.get_base_directory(), user='johndoe')

########NEW FILE########
__FILENAME__ = test_nodejs
from contextlib import contextmanager

from mock import patch, call
from nose.tools import istest

from provy.more.debian import AptitudeRole, NodeJsRole
from tests.unit.tools.helpers import ProvyTestCase


class NodeJsRoleTest(ProvyTestCase):
    def setUp(self):
        super(NodeJsRoleTest, self).setUp()
        self.role = NodeJsRole(prov=None, context={})

    @contextmanager
    def node_method(self, method_name):
        with patch('provy.more.debian.NodeJsRole.%s' % method_name) as mock:
            yield mock

    @istest
    def adds_repositories_and_installs_necessary_sources_to_provision_to_debian(self):
        with self.execute_mock() as execute, self.using_stub(AptitudeRole) as mock_aptitude, self.mock_role_method('ensure_dir') as ensure_dir:
            self.role.provision_to_debian()

            mock_aptitude.ensure_package_installed.assert_called_with('g++')
            ensure_dir.assert_called_with('/tmp/nodejs', sudo=True)

            execute.assert_has_calls([
                call('wget -N http://nodejs.org/dist/node-latest.tar.gz', sudo=True),
                call('tar xzvf node-latest.tar.gz && cd `ls -rd node-v*` && ./configure && make install', sudo=True),
            ])

    @istest
    def adds_repositories_and_installs_necessary_packages_to_provision_to_ubuntu(self):
        with self.execute_mock() as execute, self.using_stub(AptitudeRole) as mock_aptitude:
            self.role.provision_to_ubuntu()

            mock_aptitude.ensure_package_installed.assert_any_call('python-software-properties')
            execute.assert_called_with('add-apt-repository ppa:chris-lea/node.js', sudo=True)
            self.assertTrue(mock_aptitude.force_update.called)
            mock_aptitude.ensure_package_installed.assert_any_call('nodejs')
            mock_aptitude.ensure_package_installed.assert_any_call('npm')
            mock_aptitude.ensure_package_installed.assert_any_call('nodejs-dev')

    @istest
    def checks_that_node_is_already_installed(self):
        with self.execute_mock() as execute, self.warn_only():
            execute.return_value = 'v0.8.10'
            self.assertTrue(self.role.is_already_installed())

    @istest
    def checks_that_node_is_not_installed_yet_by_output_string(self):
        with self.execute_mock() as execute, self.warn_only():
            execute.return_value = 'command not found'
            self.assertFalse(self.role.is_already_installed())

    @istest
    def checks_that_node_is_not_installed_yet_by_stranger_output_string(self):
        with self.execute_mock() as execute, self.warn_only():
            execute.return_value = 'verbose error: command not found'
            self.assertFalse(self.role.is_already_installed())

    @istest
    def checks_that_node_is_not_installed_yet_by_output_as_none(self):
        with self.execute_mock() as execute, self.warn_only():
            execute.return_value = None
            self.assertFalse(self.role.is_already_installed())

    @istest
    def provisions_to_debian_if_is_debian(self):
        with self.provisioning_to('debian'), self.node_method('provision_to_debian') as provision_to_debian, self.node_method('is_already_installed') as is_already_installed:
            is_already_installed.return_value = False
            self.role.provision()
            provision_to_debian.assert_called_with()

    @istest
    def provisions_to_ubuntu_if_is_ubuntu(self):
        with self.provisioning_to('ubuntu'), self.node_method('provision_to_ubuntu') as provision_to_ubuntu, self.node_method('is_already_installed') as is_already_installed:
            is_already_installed.return_value = False
            self.role.provision()
            provision_to_ubuntu.assert_called_with()

    @istest
    def doesnt_provision_if_already_installed(self):
        with self.provisioning_to('ubuntu'), self.node_method('provision_to_ubuntu') as provision_to_ubuntu, self.node_method('is_already_installed') as is_already_installed:
            is_already_installed.return_value = True
            self.role.provision()
            self.assertFalse(provision_to_ubuntu.called)

########NEW FILE########
__FILENAME__ = test_php
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, PHPRole
from tests.unit.tools.helpers import ProvyTestCase


class PHPRoleTest(ProvyTestCase):
    def setUp(self):
        super(PHPRoleTest, self).setUp()
        self.role = PHPRole(prov=None, context={})

    @istest
    def adds_repositories_and_installs_necessary_packages_to_provision_to_debian(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.provisioning_to('debian'):
            self.role.provision()

            source_calls = mock_aptitude.ensure_aptitude_source.mock_calls
            self.assertEqual(source_calls, [
                call('deb http://packages.dotdeb.org squeeze all'),
                call('deb-src http://packages.dotdeb.org squeeze all'),
            ])

            mock_aptitude.ensure_gpg_key.assert_called_with('http://www.dotdeb.org/dotdeb.gpg')
            self.assertTrue(mock_aptitude.force_update.called)

            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('php5-dev'), call('php5-fpm'), call('php-pear')])

    @istest
    def provisions_to_ubuntu_without_adding_repositories(self):
        with self.using_stub(AptitudeRole) as mock_aptitude, self.provisioning_to('ubuntu'):
            self.role.provision()

            self.assertFalse(mock_aptitude.ensure_aptitude_source.called)
            self.assertFalse(mock_aptitude.ensure_gpg_key.called)
            self.assertFalse(mock_aptitude.force_update.called)

            install_calls = mock_aptitude.ensure_package_installed.mock_calls
            self.assertEqual(install_calls, [call('php5-dev'), call('php5-fpm'), call('php-pear')])

########NEW FILE########
__FILENAME__ = test_ruby
from nose.tools import istest

from provy.more.debian import AptitudeRole, RubyRole
from provy.more.debian.programming.ruby import UPDATE_ALTERNATIVES_COMMAND
from tests.unit.tools.helpers import ProvyTestCase


class RubyRoleTest(ProvyTestCase):
    def setUp(self):
        super(RubyRoleTest, self).setUp()
        self.role = RubyRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.execute_mock() as execute:
            self.role.provision()

            update_alternatives_command = UPDATE_ALTERNATIVES_COMMAND.format(
                version=self.role.version,
                priority=self.role.priority,
            )
            aptitude.ensure_up_to_date.assert_called_once_with()
            aptitude.ensure_package_installed.assert_called_once_with('ruby{version}-full'.format(version=self.role.version))
            execute.assert_called_once_with(update_alternatives_command, sudo=True)

########NEW FILE########
__FILENAME__ = test_apparmor
from nose.tools import istest

from provy.more.debian import AptitudeRole, AppArmorRole
from tests.unit.tools.helpers import ProvyTestCase


class AppArmorRoleTest(ProvyTestCase):
    def setUp(self):
        super(AppArmorRoleTest, self).setUp()
        self.role = AppArmorRole(prov=None, context={'cleanup': []})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.execute_mock():
            self.role.provision()

            aptitude.ensure_package_installed.assert_any_call('apparmor-profiles')
            aptitude.ensure_package_installed.assert_any_call('apparmor-utils')

    @istest
    def disables_executables(self):
        with self.execute_mock() as execute:
            self.role.disable('/some/bin1', '/some/bin2')

            execute.assert_called_with('aa-disable /some/bin1 /some/bin2', stdout=False, sudo=True)

    @istest
    def puts_executables_to_complain_mode(self):
        with self.execute_mock() as execute:
            self.role.complain('/some/bin1', '/some/bin2')

            execute.assert_called_with('aa-complain /some/bin1 /some/bin2', stdout=False, sudo=True)

    @istest
    def puts_executables_to_enforce_mode(self):
        with self.execute_mock() as execute:
            self.role.enforce('/some/bin1', '/some/bin2')

            execute.assert_called_with('aa-enforce /some/bin1 /some/bin2', stdout=False, sudo=True)

    @istest
    def puts_executables_to_audit_mode(self):
        with self.execute_mock() as execute:
            self.role.audit('/some/bin1', '/some/bin2')

            execute.assert_called_with('aa-audit /some/bin1 /some/bin2', stdout=False, sudo=True)

    @istest
    def creates_a_profile_for_an_executable(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin')

            execute.assert_called_with('aa-easyprof /some/bin', stdout=False, sudo=True)

    @istest
    def creates_a_profile_with_another_template(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin', template='another-template')

            execute.assert_called_with('aa-easyprof -t another-template /some/bin', stdout=False, sudo=True)

    @istest
    def creates_a_profile_with_policy_groups(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin', policy_groups=['networking', 'user-application'])

            execute.assert_called_with('aa-easyprof -p networking,user-application /some/bin', stdout=False, sudo=True)

    @istest
    def creates_a_profile_with_abstractions(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin', abstractions=['python', 'apache2-common'])

            execute.assert_called_with('aa-easyprof -a python,apache2-common /some/bin', stdout=False, sudo=True)

    @istest
    def creates_a_profile_with_read_permissions(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin', read=['/var/log/somebin.log', '/srv/somebin/'])

            execute.assert_called_with('aa-easyprof -r /var/log/somebin.log -r /srv/somebin/ /some/bin', stdout=False, sudo=True)

    @istest
    def creates_a_profile_with_read_and_write_permissions(self):
        with self.execute_mock() as execute:
            self.role.create('/some/bin', read_and_write=['/var/log/somebin.log', '/srv/somebin/'])

            execute.assert_called_with('aa-easyprof -w /var/log/somebin.log -w /srv/somebin/ /some/bin', stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = test_iptables
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, IPTablesRole
from tests.unit.tools.helpers import ProvyTestCase


class IPTablesRoleTest(ProvyTestCase):
    def setUp(self):
        super(IPTablesRoleTest, self).setUp()
        self.role = IPTablesRole(prov=None, context={'cleanup': []})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.execute_mock():
            self.role.provision()

            aptitude.ensure_package_installed.assert_any_call('iptables')

    @istest
    def allows_ssh_connection_during_provisioning(self):
        with self.using_stub(AptitudeRole), self.execute_mock() as execute:
            self.role.provision()

            execute.assert_any_call('iptables -A INPUT -j ACCEPT -p tcp --dport ssh', stdout=False, sudo=True)

    @istest
    def lists_all_available_chains_and_rules(self):
        with self.execute_mock() as execute:
            execute.return_value = "some rules"

            result = self.role.list_rules()

            execute.assert_called_with('iptables -L', stdout=True, sudo=True)
            self.assertEqual(result, "some rules")

    @istest
    def lists_all_available_chains_and_rules_with_commands(self):
        with self.execute_mock() as execute:
            execute.return_value = "some rules"

            result = self.role.list_rules_with_commands()

            execute.assert_called_with('iptables-save', stdout=True, sudo=True)
            self.assertEqual(result, "some rules")

    @istest
    def saves_configurations_when_finishing_provisioning(self):
        with self.execute_mock() as execute:
            self.role.schedule_cleanup()

            execute.assert_any_call("iptables-save > /etc/iptables.rules", stdout=False, sudo=True)

    @istest
    def blocks_all_other_ports_when_finishing_provisioning(self):
        with self.execute_mock() as execute:
            self.role.schedule_cleanup()

            execute.assert_any_call("iptables -A INPUT -j REJECT -p all", stdout=False, sudo=True)

    @istest
    def leaves_others_unblocked_when_finishing_provisioning_if_desired(self):
        with self.execute_mock() as execute:
            self.role.block_on_finish = False
            self.role.schedule_cleanup()

            call_to_avoid = call("iptables -A INPUT -j REJECT -p all", stdout=False, sudo=True)
            self.assertNotIn(call_to_avoid, execute.mock_calls)

    @istest
    def allows_incoming_tcp_in_all_ports(self):
        with self.execute_mock() as execute:
            self.role.allow()

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p tcp', stdout=False, sudo=True)

    @istest
    def allows_incoming_tcp_in_a_specific_port(self):
        with self.execute_mock() as execute:
            self.role.allow(port=80)

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p tcp --dport 80', stdout=False, sudo=True)

    @istest
    def allows_incoming_tcp_in_a_specific_port_by_name(self):
        with self.execute_mock() as execute:
            self.role.allow(port='ssh')

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p tcp --dport ssh', stdout=False, sudo=True)

    @istest
    def allows_incoming_tcp_in_a_specific_interface(self):
        with self.execute_mock() as execute:
            self.role.allow(interface='eth0')

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p tcp -i eth0', stdout=False, sudo=True)

    @istest
    def allows_outgoing_tcp_in_all_ports(self):
        with self.execute_mock() as execute:
            self.role.allow(direction="out")

            execute.assert_called_with('iptables -A OUTPUT -j ACCEPT -p tcp', stdout=False, sudo=True)

    @istest
    def allows_forward_tcp_in_all_ports(self):
        with self.execute_mock() as execute:
            self.role.allow(direction="forward")

            execute.assert_called_with('iptables -A FORWARD -j ACCEPT -p tcp', stdout=False, sudo=True)

    @istest
    def allows_incoming_udp_in_all_ports(self):
        with self.execute_mock() as execute:
            self.role.allow(protocol="udp")

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p udp', stdout=False, sudo=True)

    @istest
    def allows_incoming_tcp_in_all_ports_with_a_match_filter(self):
        with self.execute_mock() as execute:
            self.role.allow(match="state", state="ESTABLISHED,RELATED")

            execute.assert_called_with('iptables -A INPUT -j ACCEPT -p tcp -m state --state ESTABLISHED,RELATED', stdout=False, sudo=True)

    @istest
    def rejects_incoming_connections_in_all_ports_and_protocols(self):
        with self.execute_mock() as execute:
            self.role.reject()

            execute.assert_called_with('iptables -A INPUT -j REJECT -p all', stdout=False, sudo=True)

    @istest
    def rejects_tcp_connections_in_all_ports(self):
        with self.execute_mock() as execute:
            self.role.reject(protocol="tcp")

            execute.assert_called_with('iptables -A INPUT -j REJECT -p tcp', stdout=False, sudo=True)

    @istest
    def rejects_tcp_connections_in_a_specific_port(self):
        with self.execute_mock() as execute:
            self.role.reject(port=80, protocol="tcp")

            execute.assert_called_with('iptables -A INPUT -j REJECT -p tcp --dport 80', stdout=False, sudo=True)

    @istest
    def rejects_outgoing_connections(self):
        with self.execute_mock() as execute:
            self.role.reject(direction="out")

            execute.assert_called_with('iptables -A OUTPUT -j REJECT -p all', stdout=False, sudo=True)

    @istest
    def rejects_incoming_connections_in_all_ports_with_a_match_filter(self):
        with self.execute_mock() as execute:
            self.role.reject(match="state", state="ESTABLISHED,RELATED")

            execute.assert_called_with('iptables -A INPUT -j REJECT -p all -m state --state ESTABLISHED,RELATED', stdout=False, sudo=True)

    @istest
    def drops_incoming_connections_in_all_ports_and_protocols(self):
        with self.execute_mock() as execute:
            self.role.drop()

            execute.assert_called_with('iptables -A INPUT -j DROP -p all', stdout=False, sudo=True)

    @istest
    def drops_tcp_connections_in_a_specific_port(self):
        with self.execute_mock() as execute:
            self.role.drop(port=80, protocol="tcp")

            execute.assert_called_with('iptables -A INPUT -j DROP -p tcp --dport 80', stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = test_selinux
from mock import call, patch
from nose.tools import istest

from provy.more.debian import AptitudeRole, SELinuxRole
from tests.unit.tools.helpers import ProvyTestCase


class SELinuxRoleTest(ProvyTestCase):
    def setUp(self):
        super(SELinuxRoleTest, self).setUp()
        self.role = SELinuxRole(prov=None, context={'cleanup': []})

    @istest
    def provisions_correctly(self):
        with self.mock_role_methods('install_packages', 'activate'):
            self.role.provision()

            self.role.install_packages.assert_called_with()
            self.role.activate.assert_called_with()

    @istest
    def installs_packages_in_debian(self):
        with self.using_stub(AptitudeRole) as aptitude, self.provisioning_to('debian'):
            self.role.install_packages()

            expected_packages = [
                call('selinux-basics'),
                call('selinux-policy-default'),
                call('selinux-utils'),
                call('auditd'),
                call('audispd-plugins'),
            ]
            self.assertEqual(aptitude.ensure_package_installed.mock_calls, expected_packages)

    @istest
    def installs_packages_in_ubuntu(self):
        with self.using_stub(AptitudeRole) as aptitude, self.provisioning_to('ubuntu'):
            self.role.install_packages()

            expected_packages = [
                call('selinux'),
                call('selinux-utils'),
                call('auditd'),
                call('audispd-plugins'),
            ]
            self.assertEqual(aptitude.ensure_package_installed.mock_calls, expected_packages)

    @istest
    def activates_on_debian(self):
        with self.execute_mock() as execute, self.provisioning_to('debian'), patch.object(self.role, 'enforce'):
            self.role.activate()

            expected_calls = [
                call('selinux-activate', stdout=False, sudo=True),
                call("semanage login -m -s 'user_u' -r s0 __default__", stdout=False, sudo=True),
            ]
            self.assertEqual(execute.mock_calls, expected_calls)
            self.role.enforce.assert_called_with()

    @istest
    def activates_on_ubuntu(self):
        with self.execute_mock() as execute, self.provisioning_to('ubuntu'), patch.object(self.role, 'enforce'):
            self.role.activate()

            expected_calls = [
                call("semanage login -m -s 'user_u' -r s0 __default__", stdout=False, sudo=True),
            ]
            self.assertEqual(execute.mock_calls, expected_calls)
            self.role.enforce.assert_called_with()

    @istest
    def puts_environment_in_enforce_mode(self):
        with self.execute_mock(), self.mock_role_method('ensure_line'), self.warn_only():
            self.role.enforce()

            self.role.execute.assert_called_with('setenforce 1', stdout=False, sudo=True)
            self.role.ensure_line.assert_called_with('SELINUX=enforcing', '/etc/selinux/config', sudo=True)

    @istest
    def ensures_that_a_login_mapping_exists(self):
        with self.execute_mock() as execute, self.warn_only():
            self.role.ensure_login_mapping('foo')

            execute.assert_called_with('semanage login -a foo', stdout=False, sudo=True)

    @istest
    def maps_a_login_user_to_an_selinux_user(self):
        with self.execute_mock() as execute, patch.object(self.role, 'ensure_login_mapping'):
            self.role.map_login('foo', 'staff_u')

            self.role.ensure_login_mapping.assert_called_with('foo')
            execute.assert_called_with('semanage login -m -s staff_u foo', stdout=False, sudo=True)

    @istest
    def maps_a_login_user_to_selinux_roles(self):
        with self.execute_mock() as execute, patch.object(self.role, 'ensure_login_mapping'):
            self.role.map_role('foo', ['staff_r', 'sysadm_r'])

            self.role.ensure_login_mapping.assert_called_with('foo')
            execute.assert_called_with("semanage user -m -R 'staff_r sysadm_r' foo", stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = test_ufw
from nose.tools import istest

from provy.more.debian import AptitudeRole, UFWRole
from tests.unit.tools.helpers import ProvyTestCase


class UFWRoleTest(ProvyTestCase):
    def setUp(self):
        super(UFWRoleTest, self).setUp()
        self.role = UFWRole(prov=None, context={'cleanup': []})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.execute_mock():
            self.role.provision()

            aptitude.ensure_package_installed.assert_any_call('ufw')

    @istest
    def allows_ssh_connection_during_provisioning(self):
        with self.using_stub(AptitudeRole), self.execute_mock() as execute:
            self.role.provision()

            execute.assert_any_call('ufw allow ssh', stdout=False, sudo=True)

    @istest
    def enables_when_finishing_provisioning(self):
        with self.execute_mock() as execute:
            self.role.schedule_cleanup()

            execute.assert_any_call("ufw --force enable", stdout=False, sudo=True)

    @istest
    def allows_a_certain_port_by_application_name(self):
        with self.execute_mock() as execute:
            self.role.allow('http')

            execute.assert_called_with('ufw allow http', stdout=False, sudo=True)

    @istest
    def allows_a_certain_port_by_number(self):
        with self.execute_mock() as execute:
            self.role.allow(8000)

            execute.assert_called_with('ufw allow 8000', stdout=False, sudo=True)

    @istest
    def allows_a_certain_port_by_number_and_protocol(self):
        with self.execute_mock() as execute:
            self.role.allow(8000, protocol='tcp')

            execute.assert_called_with('ufw allow 8000/tcp', stdout=False, sudo=True)

    @istest
    def allows_a_certain_port_by_number_and_direction(self):
        with self.execute_mock() as execute:
            self.role.allow(8000, direction='in')

            execute.assert_called_with('ufw allow in 8000', stdout=False, sudo=True)

    @istest
    def allows_a_certain_port_by_number_and_protocol_and_direction(self):
        with self.execute_mock() as execute:
            self.role.allow(8000, protocol='tcp', direction='in')

            execute.assert_called_with('ufw allow in 8000/tcp', stdout=False, sudo=True)

    @istest
    def drops_a_certain_port_by_number_and_protocol_and_direction(self):
        with self.execute_mock() as execute:
            self.role.drop(8000, protocol='tcp', direction='in')

            execute.assert_called_with('ufw deny in 8000/tcp', stdout=False, sudo=True)

    @istest
    def rejects_a_certain_port_by_number_and_protocol_and_direction(self):
        with self.execute_mock() as execute:
            self.role.reject(8000, protocol='tcp', direction='in')

            execute.assert_called_with('ufw reject in 8000/tcp', stdout=False, sudo=True)

    @istest
    def allows_with_a_custom_query(self):
        with self.execute_mock() as execute:
            self.role.allow('proto tcp to any port 80')

            execute.assert_called_with('ufw allow proto tcp to any port 80', stdout=False, sudo=True)

########NEW FILE########
__FILENAME__ = test_passwd_utils
# -*- coding: utf-8 -*-

import unittest
from nose.tools import istest
from mock import patch
from provy.more.debian.users.passwd_utils import random_salt_function, hash_password_function


class PasswdUtilsTest(unittest.TestCase):

    @istest
    def check_if_two_generated_salts_are_different(self):
        """
        Instead of checking if output is truly random, we'll just check if
        in two conseutive calls different functions will be returned
        """
        self.assertNotEqual(random_salt_function(), random_salt_function())

    @istest
    def check_random_add_function_output_is_as_specified(self):
        self.assertEqual(len(random_salt_function(salt_len=125)), 125)

    @istest
    def check_crypt_function_gives_expected_output_for_known_magic_and_salt(self):
        password = "foobarbaz"
        expected_hash = "$6$SqAoXRvk$spgLlL/WL/vcb16ZZ4cMdF5uN90IjH0PpYKdMhqyW.BxXJEVc5RyvnpWcT.OKKJO2vsp32.CWDEd45K6r05bL0"
        salt = "SqAoXRvk"

        self.assertEqual(expected_hash, hash_password_function(password, salt))

    @istest
    def check_crypt_function_uses_random_salt(self):
        password = "foobarbaz"
        expected_hash = "$6$SqAoXRvk$spgLlL/WL/vcb16ZZ4cMdF5uN90IjH0PpYKdMhqyW.BxXJEVc5RyvnpWcT.OKKJO2vsp32.CWDEd45K6r05bL0"
        salt = "SqAoXRvk"

        with patch("provy.more.debian.users.passwd_utils.random_salt_function") as rnd:
            rnd.return_value = salt
            self.assertEqual(expected_hash, hash_password_function(password))
            self.assertTrue(rnd.called)

########NEW FILE########
__FILENAME__ = test_ssh
import os

from nose.tools import istest
from mock import call
from jinja2 import FileSystemLoader

from provy.more.debian import SSHRole
from tests.unit.tools.helpers import ProvyTestCase, PROJECT_ROOT


class SSHRoleTest(ProvyTestCase):
    def setUp(self):
        super(SSHRoleTest, self).setUp()
        self.role = SSHRole(None, {})

        template_dir = os.path.join(PROJECT_ROOT, 'tests', 'unit', 'fixtures')
        self.role.context['loader'] = FileSystemLoader(template_dir)

        self.test_pub_key = open(os.path.join(template_dir, 'test_public_key')).read()
        self.test_private_key = self.role.render('test_private_key.pem')

    @istest
    def ensures_ssh_key(self):
        with self.mock_role_methods('_SSHRole__write_keys', 'ensure_dir') as (mock_write, ensure_dir):
            self.role.ensure_ssh_key('user', 'test_private_key.pem')

            ensure_dir.assert_called_with(
                '/home/user/.ssh', owner='user', sudo=True,
            )
            mock_write.assert_called_with(
                'user', self.test_private_key, self.test_pub_key,
            )

    @istest
    def writes_keys(self):
        with self.mock_role_methods('execute_python', 'write_to_temp_file', 'update_file') as (execute_python, write_to_temp_file, update_file):
            self.role._SSHRole__write_keys('user', '..private..', '..public..')

            self.assertEqual(
                execute_python.call_args,
                call('import os; print os.uname()[1]', stdout=False)
            )

            write_to_temp_file.assert_has_calls([
                call('..public.. user@' + str(execute_python.return_value)),
                call('..private..'),
            ])

            update_file.assert_has_calls([
                call(
                    write_to_temp_file.return_value,
                    '/home/user/.ssh/id_rsa.pub', sudo=True, owner='user',
                ),
                call(
                    write_to_temp_file.return_value,
                    '/home/user/.ssh/id_rsa', sudo=True, owner='user',
                ),
            ])

    @istest
    def doesnt_log_if_updating_keys_files_fails(self):
        with self.mock_role_methods('execute_python', 'write_to_temp_file', 'update_file', 'log') as (execute_python, write_to_temp_file, update_file, log):
            update_file.return_value = False

            self.role._SSHRole__write_keys('user', '..private..', '..public..')

            self.assertFalse(log.called)

########NEW FILE########
__FILENAME__ = test_user
from mock import call, ANY
from nose.tools import istest

from provy.more.debian import UserRole
from tests.unit.tools.helpers import ProvyTestCase

example_groups = """
root
daemon
bin
sys
adm
tty
disk
lp
mail
"""
example_users = """
root
daemon
bin
sys
sync
games
man
lp
mail
"""
example_groups_for_user = """
foo : foo adm cdrom sudo dip plugdev lpadmin sambashare
"""


class UserRoleTest(ProvyTestCase):
    def setUp(self):
        super(UserRoleTest, self).setUp()
        self.role = UserRole(None, {})

    @istest
    def checks_that_a_group_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertTrue(self.role.group_exists('daemon'))
            execute.assert_called_with("cat /etc/group | cut -d ':' -f 1", stdout=False, sudo=True)

    @istest
    def checks_that_a_group_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertFalse(self.role.group_exists('iis'))

    @istest
    def checks_group_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups

            self.assertFalse(self.role.group_exists('roo'))
            self.assertFalse(self.role.group_exists('roots'))

    @istest
    def checks_that_a_user_exists(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertTrue(self.role.user_exists('daemon'))
            execute.assert_called_with("cat /etc/passwd | cut -d ':' -f 1", stdout=False, sudo=True)

    @istest
    def checks_that_a_user_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertFalse(self.role.user_exists('iis'))

    @istest
    def checks_user_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_users

            self.assertFalse(self.role.user_exists('roo'))
            self.assertFalse(self.role.user_exists('roots'))

    @istest
    def checks_that_a_user_is_in_a_certain_group(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertTrue(self.role.user_in_group('foo', 'sudo'))
            execute.assert_called_with("groups foo", stdout=False, sudo=True)

    @istest
    def checks_that_a_user_is_not_in_a_certain_group(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertFalse(self.role.user_in_group('foo', 'root'))

    @istest
    def checks_that_a_user_is_in_a_certain_group_by_exact_name(self):
        with self.execute_mock() as execute:
            execute.return_value = example_groups_for_user

            self.assertFalse(self.role.user_in_group('foo', 'sud'))
            self.assertFalse(self.role.user_in_group('foo', 'sudoer'))

    @istest
    def cannot_check_user_in_groups_if_username_doesnt_exist(self):
        with self.execute_mock() as execute:
            execute.return_value = 'groups: foo: User unexistant'

            self.assertRaises(ValueError, self.role.user_in_group, 'foo', 'bar')

    @istest
    def ensures_a_group_is_created(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = False

            self.role.ensure_group('foo')

            self.role.group_exists.assert_called_once_with('foo')
            self.role.execute.assert_called_once_with('groupadd foo', sudo=True, stdout=False)

    @istest
    def ensures_a_group_is_created_with_group_id(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = False

            self.role.ensure_group('foo', group_id=123)

            self.role.group_exists.assert_called_once_with('foo')
            self.role.execute.assert_called_once_with('groupadd --gid 123 foo', sudo=True, stdout=False)

    @istest
    def doesnt_create_group_if_it_already_exists(self):
        with self.mock_role_methods('group_exists', 'execute'):
            self.role.group_exists.return_value = True

            self.role.ensure_group('foo')

            self.assertFalse(self.role.execute.called)

    @istest
    def ensures_the_user_enters_the_provided_groups_when_not_there_already(self):
        with self.mock_role_methods('user_in_group', 'execute'):
            self.role.user_in_group.side_effect = [True, False]

            self.role.ensure_user_groups('foo', ['bar', 'baz'])

            self.assertEqual(self.role.user_in_group.mock_calls, [
                call('foo', 'bar'),
                call('foo', 'baz'),
            ])
            self.role.execute.assert_called_once_with('usermod -G baz foo', sudo=True, stdout=False)

    @istest
    def ensures_user_is_created_when_not_created_yet(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute', 'set_user_password'):
            with self.provisioning_to('debian'):
                self.role.user_exists.return_value = False

                self.role.ensure_user(username='foo-user', identified_by='foo-pass', groups=['foo-group', 'bar-group'])

                self.assertEqual(self.role.ensure_group.mock_calls, [
                    call('foo-group'),
                    call('bar-group'),
                ])
                self.assertEqual(self.role.execute.mock_calls, [
                    call('useradd -g foo-group -s /bin/bash -d /home/foo-user -m foo-user', stdout=False, sudo=True)
                ])
                self.role.set_user_password.assert_called_once_with(
                    'foo-user', 'foo-pass', False
                )
                self.role.ensure_user_groups.assert_called_once_with('foo-user', ['foo-group', 'bar-group'])

    @istest
    def ensures_user_is_created_with_only_group_as_username(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute', 'set_user_password'):
            with self.provisioning_to('debian'):
                self.role.user_exists.return_value = False

                self.role.ensure_user(username='foo-user')

                self.assertEqual(self.role.execute.mock_calls, [
                    call('useradd -g foo-user -s /bin/bash -d /home/foo-user -m foo-user', stdout=False, sudo=True),
                ])

    @istest
    def ensures_user_is_created_with_different_home(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'execute', 'set_user_password'):
            with self.provisioning_to('debian'):
                self.role.user_exists.return_value = False

                self.role.ensure_user(username='foo-user', home_folder='/srv/bar')

                self.assertEqual(self.role.execute.mock_calls, [
                    call('useradd -g foo-user -s /bin/bash -d /srv/bar -m foo-user', stdout=False, sudo=True),
                ])

    @istest
    def doesnt_add_but_set_user_as_admin_for_debian_when_it_already_exists_but_is_not_admin_yet(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'user_in_group', 'execute', "set_user_password"):
            with self.provisioning_to('debian'):
                self.role.user_exists.return_value = True
                self.role.user_in_group.return_value = False

                self.role.ensure_user(username='foo-user', is_admin=True)

                self.role.user_in_group.assert_called_once_with('foo-user', 'admin')
                self.assertEqual(self.role.execute.mock_calls, [
                    call('usermod -G admin foo-user', sudo=True, stdout=False),
                ])

    @istest
    def doesnt_add_but_set_user_as_admin_for_ubuntu_when_it_already_exists_but_is_not_admin_yet(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'user_in_group', 'execute', 'set_user_password'):
            with self.provisioning_to('ubuntu'):
                self.role.user_exists.return_value = True
                self.role.user_in_group.return_value = False

                self.role.ensure_user(username='foo-user', is_admin=True)

                self.role.user_in_group.assert_called_once_with('foo-user', 'sudo')
                self.assertEqual(self.role.execute.mock_calls, [
                    call('usermod -G sudo foo-user', sudo=True, stdout=False),
                ])

    @istest
    def just_add_user_to_groups_if_its_already_admin(self):
        with self.mock_role_methods('ensure_group', 'ensure_user_groups', 'user_exists', 'user_in_group', 'execute', 'set_user_password'):
            with self.provisioning_to('ubuntu'):
                self.role.user_exists.return_value = True
                self.role.user_in_group.return_value = True

                self.role.ensure_user(username='foo-user', is_admin=True, groups=['foo-group', 'bar-group'])

                self.assertFalse(self.role.execute.called)
                self.role.ensure_user_groups.assert_called_once_with('foo-user', ['foo-group', 'bar-group'])

    @istest
    def check_set_user_password_when_password_is_encrypted(self):
        encrypted_password = "$6$SqAoXRvk$spgLlL/WL/vcb16ZZ4cMdF5uN90IjH0PpYKdMhqyW.BxXJEVc5RyvnpWcT.OKKJO2vsp32.CWDEd45K6r05bL0"
        with self.mock_role_methods("create_remote_temp_file", 'put_file', 'execute', "remove_file"):
            self.role.create_remote_temp_file.return_value = "/tmp/random"
            self.role.set_user_password("foo", encrypted_password, encrypted=True)
            self.role.put_file.assert_called_once_with(
                ANY,
                "/tmp/random",
                sudo=True,
                stdout=False
            )
            self.assertIn(
                call('cat "/tmp/random" | chpasswd -e', sudo=True, stdout=False),
                self.role.execute.mock_calls
            )

    @istest
    def check_set_user_password_when_password_is_not_encrypted(self):
        with self.mock_role_methods("create_remote_temp_file", 'put_file', 'execute', "remove_file"):
            self.role.create_remote_temp_file.return_value = "/tmp/random"
            self.role.set_user_password("foo", "foo-pass")
            self.role.put_file.assert_called_once_with(
                ANY,
                "/tmp/random",
                sudo=True,
                stdout=False
            )
            self.assertIn(
                call('cat "/tmp/random" | chpasswd ', sudo=True, stdout=False),
                self.role.execute.mock_calls
            )

########NEW FILE########
__FILENAME__ = test_git
from mock import call
from nose.tools import istest

from provy.more.debian import AptitudeRole, GitRole
from tests.unit.tools.helpers import ProvyTestCase


class GitRoleTest(ProvyTestCase):
    def setUp(self):
        super(GitRoleTest, self).setUp()
        self.role = GitRole(prov=None, context={})

    @istest
    def ensures_a_repository_is_cloned_as_sudo(self):
        with self.execute_mock() as execute:
            self.role.ensure_repository('some-repo-url', 'working-tree-path')

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=True, stdout=False, user=None)

    @istest
    def ensures_a_repository_is_cloned_as_non_sudo(self):
        with self.execute_mock() as execute:
            self.role.ensure_repository('some-repo-url', 'working-tree-path', sudo=False)

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=False, stdout=False, user=None)

    @istest
    def ensures_a_repository_is_cloned_as_specific_user(self):
        with self.execute_mock() as execute, self.mock_role_method('change_path_owner') as change_path_owner:
            self.role.ensure_repository('some-repo-url', 'working-tree-path', owner='joe', sudo=False)

            execute.assert_called_with('git clone some-repo-url working-tree-path', sudo=False, stdout=False, user='joe')
            change_path_owner.assert_called_with('working-tree-path', 'joe')

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude:
            self.role.provision()

            aptitude.ensure_up_to_date.assert_called_once_with()
            aptitude.ensure_package_installed.assert_called_once_with('git-core')

    @istest
    def ensures_a_branch_is_checked_out_if_needed(self):
        sudo = 'is it sudo?'
        owner = 'foo-owner'
        branch = 'some-branch'
        with self.mock_role_methods('remote_exists_dir', 'execute', 'change_path_owner'):
            self.role.remote_exists_dir.return_value = True
            self.role.execute.return_value = '# On branch master'

            self.role.ensure_repository('some-repo-url', 'working-tree-path', sudo=sudo, branch=branch, owner=owner)

            self.assertEqual(self.role.execute.mock_calls, [
                call('git --git-dir="working-tree-path/.git" --work-tree="working-tree-path" status', sudo=True, stdout=False),
                call('git --git-dir="working-tree-path/.git" --work-tree="working-tree-path" checkout some-branch', sudo=sudo, user=owner),
            ])

########NEW FILE########
__FILENAME__ = test_apache
from mock import patch
from nose.tools import istest

from provy.more.debian import ApacheRole, AptitudeRole
from tests.unit.tools.helpers import ProvyTestCase


class ApacheRoleTest(ProvyTestCase):
    def setUp(self):
        super(ApacheRoleTest, self).setUp()
        self.role = ApacheRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude:
            self.role.provision()

            aptitude.ensure_package_installed.assert_called_with('apache2')

    @istest
    def ensures_module_is_installed_and_enabled(self):
        with self.using_stub(AptitudeRole) as aptitude, self.execute_mock() as execute:
            self.role.ensure_mod('foo')

            aptitude.ensure_package_installed.assert_called_with('libapache2-mod-foo')
            execute.assert_called_with('a2enmod foo', sudo=True)
            self.assertTrue(self.role.must_restart)

    @istest
    def ensures_site_is_available_from_template(self):
        with self.execute_mock(), self.mock_role_method('update_file') as update_file, self.mock_role_method('remote_symlink'):
            self.role.create_site('bar-website', template='/local/path/to/bar-website')

            update_file.assert_called_with('/local/path/to/bar-website', '/etc/apache2/sites-available/bar-website', options={}, sudo=True)
            self.assertTrue(self.role.must_restart)

    @istest
    def ensures_site_is_available_from_template_and_options(self):
        with self.execute_mock(), self.mock_role_method('update_file') as update_file, self.mock_role_method('remote_symlink'):
            self.role.create_site('bar-website', template='/local/path/to/bar-website', options={'foo': 'Baz'})

            update_file.assert_called_with('/local/path/to/bar-website', '/etc/apache2/sites-available/bar-website', options={'foo': 'Baz'}, sudo=True)
            self.assertTrue(self.role.must_restart)

    @istest
    def ensures_that_a_website_is_enabled(self):
        with self.mock_role_method('remote_symlink') as remote_symlink:
            self.role.ensure_site_enabled('bar-website')

            remote_symlink.assert_called_with(from_file='/etc/apache2/sites-available/bar-website', to_file='/etc/apache2/sites-enabled/bar-website', sudo=True)
            self.assertTrue(self.role.must_restart)

    @istest
    def ensures_that_a_website_is_disabled(self):
        with self.mock_role_method('remove_file') as remove_file:
            self.role.ensure_site_disabled('bar-website')

            remove_file.assert_called_with('/etc/apache2/sites-enabled/bar-website', sudo=True)
            self.assertTrue(self.role.must_restart)

    @istest
    def can_be_restarted(self):
        with self.execute_mock() as execute:
            self.role.restart()

            execute.assert_called_with('service apache2 restart', sudo=True)

    @istest
    def ensures_that_it_must_be_restarted(self):

        self.assertFalse(self.role.must_restart)

        self.role.ensure_restart()

        self.assertTrue(self.role.must_restart)

    @istest
    def must_not_restart_again_if_already_restarted(self):
        with self.execute_mock():
            self.role.ensure_restart()
            self.role.restart()

            self.assertFalse(self.role.must_restart)

    @istest
    def restarts_on_cleanup_if_must_be_restarted(self):
        with patch('provy.more.debian.ApacheRole.restart') as restart:
            self.role.ensure_restart()
            self.role.cleanup()

            self.assertTrue(restart.called)

    @istest
    def doesnt_restart_on_cleanup_if_doesnt_need_to_be_restarted(self):
        with patch('provy.more.debian.ApacheRole.restart') as restart:
            self.role.cleanup()

            self.assertFalse(restart.called)

########NEW FILE########
__FILENAME__ = test_django
from mock import call, MagicMock
from nose.tools import istest

from provy.more.debian import DjangoRole, AptitudeRole, PipRole, SupervisorRole
from provy.more.debian.web.django import SITES_KEY
from tests.unit.tools.helpers import ProvyTestCase


class DjangoRoleTest(ProvyTestCase):
    def setUp(self):
        super(DjangoRoleTest, self).setUp()
        self.role = DjangoRole(prov=None, context={'owner': 'some-owner'})
        self.supervisor_role = SupervisorRole(prov=None, context=self.role.context)

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.mock_role_method('register_template_loader'), self.using_stub(PipRole) as pip:
            self.role.provision()

            self.role.register_template_loader.assert_called_with('provy.more.debian.web')
            aptitude.ensure_package_installed.assert_called_with('python-mysqldb')
            self.assertEqual(pip.ensure_package_installed.mock_calls, [
                call('django'),
                call('gunicorn'),
            ])

    @istest
    def installs_necessary_packages_to_provision_with_version(self):
        with self.using_stub(AptitudeRole) as aptitude, self.mock_role_method('register_template_loader'), self.using_stub(PipRole) as pip:
            self.role.context['django-version'] = '1.5.1'
            self.role.provision()

            self.role.register_template_loader.assert_called_with('provy.more.debian.web')
            aptitude.ensure_package_installed.assert_called_with('python-mysqldb')
            self.assertEqual(pip.ensure_package_installed.mock_calls, [
                call('django', version=self.role.context['django-version']),
                call('gunicorn'),
            ])

    @istest
    def requires_a_settings_path_to_create_site(self):

        def create_site():
            with self.role.create_site('some-site') as site:
                site.settings_path = None

        self.assertRaises(RuntimeError, create_site)

    @istest
    def prepares_site_under_supervisor(self):
        with self.using_stub(SupervisorRole), self.role.using(SupervisorRole) as supervisor_role:
            supervisor_role.log_folder = '/supervisor/log/folder'
            with self.role.create_site('some-site') as site:
                site.settings_path = '/some/settings.path'

        self.assertTrue(site.use_supervisor)
        self.assertEqual(site.supervisor_log_folder, supervisor_role.log_folder)
        self.assertFalse(site.daemon)
        self.assertFalse(site.auto_start)

    @istest
    def prepares_site_without_supervisor(self):
        with self.role.create_site('some-site') as site:
            site.settings_path = '/some/settings.path'

        self.assertFalse(site.use_supervisor)
        self.assertEqual(site.supervisor_log_folder, '/var/log')
        self.assertTrue(site.daemon)
        self.assertTrue(site.auto_start)

    @istest
    def guarantees_that_site_is_prepared_for_supervisor(self):
        with self.using_stub(SupervisorRole), self.role.using(SupervisorRole) as supervisor_role:
            supervisor_role.log_folder = '/supervisor/log/folder'
            with self.role.create_site('some-site') as site:
                site.settings_path = '/some/settings.path'

        self.assertIn(site, self.role.context[SITES_KEY])
        self.assertTrue(self.role.restart_supervisor_on_changes)

    @istest
    def guarantees_that_site_is_prepared_for_standalone(self):
        with self.role.create_site('some-site') as site:
            site.settings_path = '/some/settings.path'

        self.assertIn(site, self.role.context[SITES_KEY])
        self.assertFalse(self.role.restart_supervisor_on_changes)

    @istest
    def does_nothing_on_cleanup_if_nothing_done(self):
        '''This is just a dumb test to see if cleanup() doesn't break when there's nothing to cleanup.'''

        self.role.cleanup()

    @istest
    def installs_each_configured_site(self):
        with self.using_stub(SupervisorRole), self.role.using(SupervisorRole) as supervisor_role:
            supervisor_role.log_folder = '/supervisor/log/folder'

            with self.role.create_site('foo_site') as foo_site:
                foo_site.settings_path = '/some/settings.path'

            with self.role.create_site('bar_site') as bar_site:
                bar_site.settings_path = '/some/settings.path'

        with self.mock_role_methods('_update_init_script', '_update_settings', '_update_supervisor_program', '_restart'), self.using_stub(SupervisorRole) as supervisor_role:
            self.role._update_init_script.return_value = True
            self.role._update_settings.return_value = True

            self.role.cleanup()

            self.assertEqual(self.role._update_init_script.mock_calls, [call(foo_site), call(bar_site)])
            self.assertEqual(self.role._update_settings.mock_calls, [call(foo_site), call(bar_site)])
            self.assertEqual(self.role._update_supervisor_program.mock_calls, [call(foo_site), call(bar_site)])
            self.assertEqual(self.role._restart.mock_calls, [call(foo_site), call(bar_site)])

            supervisor_role.ensure_restart.assert_called_with()

    @istest
    def installs_each_configured_site_without_supervisor(self):
        with self.role.create_site('foo_site') as foo_site:
            foo_site.settings_path = '/some/settings.path'

        with self.mock_role_methods('_update_init_script', '_update_settings', '_update_supervisor_program', '_restart'), self.using_stub(SupervisorRole) as supervisor_role:
            self.role._update_init_script.return_value = True
            self.role._update_settings.return_value = True

            self.role.cleanup()

            self.role._restart.assert_called_once_with(foo_site)

            self.assertFalse(self.role._update_supervisor_program.called)
            self.assertFalse(supervisor_role.ensure_restart.called)

    @istest
    def doesnt_restart_on_cleanup_if_settings_not_updated(self):
        with self.role.create_site('foo_site') as foo_site:
            foo_site.settings_path = '/some/settings.path'

        with self.mock_role_methods('_update_init_script', '_update_settings', '_restart'):
            self.role._update_init_script.return_value = False
            self.role._update_settings.return_value = False

            self.role.cleanup()

            self.assertFalse(self.role._restart.called)

    @istest
    def updates_supervisor_program_with_site(self):
        website = self.role.create_site('foo-site')
        website.starting_port = 8000
        website.processes = 2
        website.settings_path = '/some/settings/path/settings.conf'
        website.user = 'some-user'
        website.supervisor_log_folder = '/some/log/folder'

        programs = [MagicMock(), MagicMock()]

        with self.using_stub(SupervisorRole) as supervisor_role:
            mock_with_program = supervisor_role.with_program.return_value
            mock_with_program.__enter__.side_effect = programs

            self.role._update_supervisor_program(website)

            self.assertEqual(programs[0].directory, '/some/settings/path')
            self.assertEqual(programs[0].command, '/etc/init.d/foo-site-8000 start')
            self.assertEqual(programs[0].name, 'foo-site-8000')
            self.assertEqual(programs[0].number_of_processes, 1)
            self.assertEqual(programs[0].user, website.user)
            self.assertEqual(programs[0].log_folder, website.supervisor_log_folder)

            self.assertEqual(programs[1].directory, '/some/settings/path')
            self.assertEqual(programs[1].command, '/etc/init.d/foo-site-8001 start')
            self.assertEqual(programs[1].name, 'foo-site-8001')
            self.assertEqual(programs[1].number_of_processes, 1)
            self.assertEqual(programs[1].user, website.user)
            self.assertEqual(programs[1].log_folder, website.supervisor_log_folder)

    @istest
    def restarts_site_when_running(self):
        website = self.role.create_site('bar-site')
        website.pid_file_path = '/foo/'

        with self.mock_role_methods('execute', 'remote_exists'):
            self.role.remote_exists.return_value = True

            self.role._restart(website)

            self.assertEqual(self.role.remote_exists.mock_calls, [
                call('/foo/bar-site_8000.pid'),
            ])
            self.assertEqual(self.role.execute.mock_calls, [
                call('/etc/init.d/bar-site-8000 stop', stdout=False, sudo=True),
                call('/etc/init.d/bar-site-8000 start', stdout=False, sudo=True),
            ])

    @istest
    def restarts_site_when_not_running(self):
        website = self.role.create_site('bar-site')
        website.pid_file_path = '/foo/'

        with self.mock_role_methods('execute', 'remote_exists'):
            self.role.remote_exists.return_value = False

            self.role._restart(website)

            self.assertEqual(self.role.remote_exists.mock_calls, [
                call('/foo/bar-site_8000.pid'),
            ])
            self.assertEqual(self.role.execute.mock_calls, [
                call('/etc/init.d/bar-site-8000 start', stdout=False, sudo=True),
            ])

    @istest
    def doesnt_restart_when_not_autostarting(self):
        website = self.role.create_site('bar-site')
        website.auto_start = False

        with self.mock_role_methods('execute', 'remote_exists'):
            self.role._restart(website)

            self.assertFalse(self.role.remote_exists.called)
            self.assertFalse(self.role.execute.called)

    @istest
    def updates_settings(self):
        with self.role.create_site('bar-site') as website:
            website.settings_path = '/foo/settings.py'

        with self.mock_role_method('update_file'):
            self.role.update_file.return_value = 'some result'

            result = self.role._update_settings(website)

            self.assertEqual(result, 'some result')
            self.role.update_file.assert_called_once_with('local.settings.template', '/foo/local_settings.py', owner=None, sudo=True, options={'settings': {}, 'settings_file': 'settings'})

    @istest
    def updates_init_script(self):
        with self.role.create_site('bar-site') as website:
            website.settings_path = '/foo/settings.py'

        with self.mock_role_methods('execute', 'update_file'):
            self.role.update_file.return_value = True

            result = self.role._update_init_script(website)

            self.assertTrue(result)
            self.role.update_file.assert_called_once_with('website.init.template', '/etc/init.d/bar-site-8000', options={
                'pid_file_path': '/var/run',
                'name': 'bar-site',
                'threads': 1,
                'host': '0.0.0.0',
                'settings_directory': '/foo',
                'port': 8000,
                'user': None,
                'daemon': True
            }, sudo=True, owner=None)
            self.assertEqual(self.role.execute.mock_calls, [
                call('chmod +x /etc/init.d/bar-site-8000', sudo=True, stdout=False),
                call('update-rc.d bar-site-8000 defaults', sudo=True, stdout=False),
            ])

    @istest
    def updates_init_script_without_auto_start(self):
        with self.role.create_site('bar-site') as website:
            website.settings_path = '/foo/settings.py'
            website.auto_start = False

        with self.mock_role_methods('execute', 'update_file'):
            self.role.update_file.return_value = True

            result = self.role._update_init_script(website)

            self.assertTrue(result)
            self.role.update_file.assert_called_once_with('website.init.template', '/etc/init.d/bar-site-8000', options={
                'pid_file_path': '/var/run',
                'name': 'bar-site',
                'threads': 1,
                'host': '0.0.0.0',
                'settings_directory': '/foo',
                'port': 8000,
                'user': None,
                'daemon': True
            }, sudo=True, owner=None)
            self.assertEqual(self.role.execute.mock_calls, [
                call('chmod +x /etc/init.d/bar-site-8000', sudo=True, stdout=False),
            ])

    @istest
    def doesnt_update_init_script_if_update_file_fails(self):
        with self.role.create_site('bar-site') as website:
            website.settings_path = '/foo/settings.py'

        with self.mock_role_methods('execute', 'update_file'):
            self.role.update_file.return_value = False

            result = self.role._update_init_script(website)

            self.assertFalse(result)
            self.role.update_file.assert_called_once_with('website.init.template', '/etc/init.d/bar-site-8000', options={
                'pid_file_path': '/var/run',
                'name': 'bar-site',
                'threads': 1,
                'host': '0.0.0.0',
                'settings_directory': '/foo',
                'port': 8000,
                'user': None,
                'daemon': True
            }, sudo=True, owner=None)
            self.assertFalse(self.role.execute.called)

########NEW FILE########
__FILENAME__ = test_nginx
from nose.tools import istest

from provy.more.debian import AptitudeRole, NginxRole
from tests.unit.tools.helpers import ProvyTestCase


class NginxRoleTest(ProvyTestCase):
    def setUp(self):
        super(NginxRoleTest, self).setUp()
        self.role = NginxRole(prov=None, context={'owner': 'some-owner'})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude:
            self.role.provision()

            aptitude.ensure_up_to_date.assert_called_once_with()
            aptitude.ensure_package_installed.assert_called_once_with('nginx')

    @istest
    def doesnt_restart_if_not_necessary_upon_cleanup(self):
        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertFalse(self.role.restart.called)

    @istest
    def restart_if_necessary_upon_cleanup(self):
        self.role.context['must-restart-nginx'] = True

        with self.mock_role_method('restart'):
            self.role.cleanup()

            self.assertTrue(self.role.restart.called)

    @istest
    def updates_configuration_and_restarts(self):
        conf_template = 'some-template'
        nginx_conf_path = 'some-conf-path'
        options = {'foo': 'bar'}

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.ensure_conf(conf_template, options, nginx_conf_path)

            self.role.update_file.assert_called_once_with(conf_template, nginx_conf_path, options=options, sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_configuration_wasnt_updated(self):
        conf_template = 'some-template'
        nginx_conf_path = 'some-conf-path'
        options = {'foo': 'bar'}

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.ensure_conf(conf_template, options, nginx_conf_path)

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def ensures_site_is_disabled_and_restarted(self):
        site = 'some-site'

        with self.mock_role_methods('remove_file', 'ensure_restart'):
            self.role.remove_file.return_value = True

            self.role.ensure_site_disabled(site)

            self.role.remove_file.assert_called_once_with('/etc/nginx/sites-enabled/some-site', sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_site_wasnt_disabled(self):
        site = 'some-site'

        with self.mock_role_methods('remove_file', 'ensure_restart'):
            self.role.remove_file.return_value = False

            self.role.ensure_site_disabled(site)

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def ensures_site_is_enabled_and_restarted(self):
        site = 'some-site'

        with self.mock_role_methods('remote_symlink', 'ensure_restart'):
            self.role.remote_symlink.return_value = True

            self.role.ensure_site_enabled(site)

            self.role.remote_symlink.assert_called_once_with('/etc/nginx/sites-available/some-site', '/etc/nginx/sites-enabled/some-site', sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_site_wasnt_enabled(self):
        site = 'some-site'

        with self.mock_role_methods('remote_symlink', 'ensure_restart'):
            self.role.remote_symlink.return_value = False

            self.role.ensure_site_enabled(site)

            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def ensures_site_is_created_and_restarted(self):
        site = 'some-site'
        template = 'some-template'
        options = {'foo': 'bar'}

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = True

            self.role.create_site(site, template, options=options)

            self.role.update_file.assert_called_once_with('some-template', '/etc/nginx/sites-available/some-site', options={'foo': 'bar'}, sudo=True)
            self.role.ensure_restart.assert_called_once_with()

    @istest
    def doesnt_restart_if_site_wasnt_created(self):
        site = 'some-site'
        template = 'some-template'
        options = {'foo': 'bar'}

        with self.mock_role_methods('update_file', 'ensure_restart'):
            self.role.update_file.return_value = False

            self.role.create_site(site, template, options=options)

            self.role.update_file.assert_called_once_with('some-template', '/etc/nginx/sites-available/some-site', options={'foo': 'bar'}, sudo=True)
            self.assertFalse(self.role.ensure_restart.called)

    @istest
    def ensures_nginx_is_restarted(self):
        self.role.context['must-restart-nginx'] = False

        self.role.ensure_restart()

        self.assertTrue(self.role.context['must-restart-nginx'])

    @istest
    def restarts_nginx(self):
        with self.execute_mock():
            self.role.restart()

            self.role.execute.assert_called_once_with('/etc/init.d/nginx restart', sudo=True)

########NEW FILE########
__FILENAME__ = test_rails
from mock import call, patch
from nose.tools import istest

from provy.more.debian import RailsRole, AptitudeRole, GemRole, SupervisorRole, NginxRole
from provy.more.debian.web.rails import PACKAGES_TO_INSTALL
from tests.unit.tools.helpers import ProvyTestCase


class RailsRoleTest(ProvyTestCase):
    def setUp(self):
        super(RailsRoleTest, self).setUp()
        self.role = RailsRole(prov=None, context={'owner': 'some-owner'})
        self.supervisor_role = SupervisorRole(prov=None, context=self.role.context)

    @istest
    def installs_necessary_packages_to_provision(self):
        methods_to_mock = (
            'execute',
            'register_template_loader',
            'remote_exists_dir',
            'update_file',
            'change_path_mode',
            'ensure_dir',
        )
        with self.using_stub(AptitudeRole) as aptitude, self.using_stub(GemRole) as gem, self.mock_role_methods(*methods_to_mock):
            self.role.remote_exists_dir.return_value = False

            self.role.provision()

            self.role.register_template_loader.assert_called_once_with('provy.more.debian.web')
            self.assertEqual(aptitude.ensure_package_installed.mock_calls, [call(package) for package in PACKAGES_TO_INSTALL])
            self.assertEqual(gem.ensure_package_installed.mock_calls, [call('bundler'), call('passenger')])
            self.role.remote_exists_dir.assert_called_once_with('/etc/nginx')
            self.assertEqual(self.role.ensure_dir.mock_calls, [
                call('/var/log/nginx', sudo=True),
                call('/etc/nginx/sites-available', sudo=True),
                call('/etc/nginx/sites-enabled', sudo=True),
                call('/etc/nginx/conf.d', sudo=True),
            ])
            self.role.execute.assert_called_once_with('passenger-install-nginx-module --auto --auto-download --prefix=/etc/nginx', sudo=True, stdout=False)
            self.assertEqual(self.role.update_file.mock_calls, [
                call('rails.nginx.conf.template', '/etc/nginx/conf/nginx.conf', sudo=True),
                call('rails.nginx.init.template', '/etc/init.d/nginx', sudo=True),
            ])
            self.role.change_path_mode.assert_called_once_with('/etc/init.d/nginx', 755)

    @istest
    def provisions_even_if_nginx_already_exists(self):
        methods_to_mock = (
            'register_template_loader',
            'remote_exists_dir',
            'update_file',
            'change_path_mode',
            'ensure_dir',
        )
        with self.using_stub(AptitudeRole), self.using_stub(GemRole), self.mock_role_methods(*methods_to_mock):
            self.role.remote_exists_dir.return_value = True

            self.role.provision()

            self.assertEqual(self.role.ensure_dir.mock_calls, [
                call('/etc/nginx/sites-available', sudo=True),
                call('/etc/nginx/sites-enabled', sudo=True),
                call('/etc/nginx/conf.d', sudo=True),
            ])

    @istest
    def restarts_on_cleanup_if_must_be_restarted(self):
        with patch('provy.more.debian.RailsRole.restart') as restart:
            self.role.ensure_restart()
            self.role.cleanup()

            self.assertTrue(restart.called)

    @istest
    def doesnt_restart_on_cleanup_if_doesnt_need_to_be_restarted(self):
        with patch('provy.more.debian.RailsRole.restart') as restart:
            self.role.cleanup()

            self.assertFalse(restart.called)

    @istest
    def ensures_site_is_disabled(self):
        site = 'some-site'

        with self.using_stub(NginxRole) as nginx:
            self.role.ensure_site_disabled(site)

            nginx.ensure_site_disabled.assert_called_once_with(site)

    @istest
    def ensures_site_is_enabled(self):
        site = 'some-site'

        with self.using_stub(NginxRole) as nginx:
            self.role.ensure_site_enabled(site)

            nginx.ensure_site_enabled.assert_called_once_with(site)

    @istest
    def ensures_site_is_created_and_restarted(self):
        owner = self.role.context['owner']
        site = 'some-site'
        host = 'some-host'
        path = 'some-path'
        options = {'foo': 'bar'}
        expected_options = {'foo': 'bar', 'host': host, 'path': path}

        with self.mock_role_methods('update_file', 'ensure_restart', 'execute'):
            self.role.update_file.return_value = True

            self.role.create_site(site, host, path, options=options)

            self.role.update_file.assert_called_once_with('rails-nginx.template', '/etc/nginx/sites-available/some-site', options=expected_options, sudo=True)
            self.role.ensure_restart.assert_called_once_with()
            self.role.execute.assert_called_once_with('cd some-path && bundle install --without development test --deployment', stdout=True, user=owner)

    @istest
    def ensures_site_is_created_without_restart_when_already_existant(self):
        owner = self.role.context['owner']
        site = 'some-site'
        host = 'some-host'
        path = 'some-path'
        options = {'foo': 'bar'}
        expected_options = {'foo': 'bar', 'host': host, 'path': path}

        with self.mock_role_methods('update_file', 'ensure_restart', 'execute'):
            self.role.update_file.return_value = False

            self.role.create_site(site, host, path, options=options)

            self.role.update_file.assert_called_once_with('rails-nginx.template', '/etc/nginx/sites-available/some-site', options=expected_options, sudo=True)
            self.assertFalse(self.role.ensure_restart.called)
            self.role.execute.assert_called_once_with('cd some-path && bundle install --without development test --deployment', stdout=True, user=owner)

    @istest
    def restarts_nginx(self):
        with self.using_stub(NginxRole) as nginx:
            self.role.restart()

            nginx.restart.assert_called_once_with()

########NEW FILE########
__FILENAME__ = test_tornado
from nose.tools import istest

from provy.more.debian import TornadoRole, AptitudeRole, PipRole
from tests.unit.tools.helpers import ProvyTestCase


class TornadoRoleTest(ProvyTestCase):
    def setUp(self):
        super(TornadoRoleTest, self).setUp()
        self.role = TornadoRole(prov=None, context={})

    @istest
    def installs_necessary_packages_to_provision(self):
        with self.using_stub(AptitudeRole) as aptitude, self.using_stub(PipRole) as pip:
            self.role.provision()

            aptitude.ensure_up_to_date.assert_called_once_with()
            aptitude.ensure_package_installed.assert_called_once_with('python-pycurl')
            pip.ensure_package_installed.assert_called_once_with('tornado')

########NEW FILE########
__FILENAME__ = test_hosts
from nose.tools import istest

from provy.more.linux.networking.hosts import HostsRole
from tests.unit.tools.helpers import ProvyTestCase


class HostsRoleTest(ProvyTestCase):
    def setUp(self):
        super(HostsRoleTest, self).setUp()
        self.role = HostsRole(prov=None, context={})

    @istest
    def ensures_a_host_line_exists_in_the_hosts_file(self):
        with self.mock_role_method('ensure_line') as ensure_line:
            self.role.ensure_host('my-server', '0.0.0.0')

            ensure_line.assert_called_once_with('0.0.0.0        my-server', '/etc/hosts', sudo=True)

########NEW FILE########
__FILENAME__ = helpers
from contextlib import contextmanager
from os.path import abspath, dirname, join
from unittest import TestCase

from mock import MagicMock, patch, DEFAULT

from provy.core.roles import DistroInfo, Role


PROJECT_ROOT = abspath(join(dirname(__file__), '..', '..', '..'))


class ProvyTestCase(TestCase):
    def setUp(self):
        self.role = Role(prov=None, context={})
        self.using_mocks = {}

    @contextmanager
    def using_stub(self, role):
        mock_role = MagicMock(spec=role)
        self.using_mocks[role] = mock_role
        self.role.context.setdefault('roles_in_context', {})

        @contextmanager
        def stub_using(inner_self, klass):
            role_instance = self.using_mocks[klass]
            self.role.context['roles_in_context'][klass] = role_instance
            yield role_instance
            del self.role.context['roles_in_context'][klass]

        with patch('provy.core.roles.Role.using', stub_using):
            yield mock_role

    @contextmanager
    def execute_mock(self):
        with patch('provy.core.roles.Role.execute') as execute:
            yield execute

    @contextmanager
    def mock_role_method(self, method):
        '''
        Mocks a method in the current role instance's class - i.e., not necessarily provy.core.roles.Role, depends on the object that self.role holds.
        '''
        with patch.object(self.role.__class__, method) as mock:
            yield mock

    @contextmanager
    def mock_role_methods(self, *methods):
        '''
        Same as mock_role_method, except that several methods can be provided.
        '''
        methods_to_mock = dict((method, DEFAULT) for method in methods)
        with patch.multiple(self.role.__class__, **methods_to_mock) as mocks:
            yield tuple(mocks[method] for method in methods)

    def debian_info(self):
        distro_info = DistroInfo()
        distro_info.distributor_id = 'Debian'
        distro_info.description = 'Debian GNU/Linux 6.0.5 (squeeze)'
        distro_info.release = '6.0.5'
        distro_info.codename = 'squeeze'
        return distro_info

    def ubuntu_info(self):
        distro_info = DistroInfo()
        distro_info.distributor_id = 'Ubuntu'
        distro_info.description = 'Ubuntu 12.04.1 LTS'
        distro_info.release = '12.04'
        distro_info.codename = 'precise'
        return distro_info

    @contextmanager
    def provisioning_to(self, distro):
        with self.mock_role_method('get_distro_info') as get_distro_info:
            if distro == 'ubuntu':
                distro_info = self.ubuntu_info()
            else:
                distro_info = self.debian_info()
            get_distro_info.return_value = distro_info
            yield

    @contextmanager
    def warn_only(self):
        test_case = self

        @contextmanager
        def settings(warn_only):
            test_case.assertTrue(warn_only)
            yield

        with patch('fabric.api.settings', settings):
            yield

########NEW FILE########
