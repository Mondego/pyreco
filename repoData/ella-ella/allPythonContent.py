__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Ella CMS documentation build configuration file, created by
# sphinx-quickstart on Thu Feb  2 04:38:37 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.


from django.conf import settings

import ella

settings.configure(
    DATABASES={
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': ':memory:',
        }
    },
)


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Ella CMS'
copyright = u'2012, Ella team'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(map(str, ella.__version__[:-1]))
# The full version, including alpha/beta/rc tags.
release = ella.__versionstr__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build', '.build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'EllaCMSdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('a', 'EllaCMS.tex', u'Ella CMS Documentation',
   u'Ella team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('a', 'ellacms', u'Ella CMS Documentation',
     [u'Ella team'], 1)
]

########NEW FILE########
__FILENAME__ = conf
from ella.utils.settings import Settings

# master API switch
ENABLED = False

# photo formats to be included when serializing Publishables
PUBLISHABLE_PHOTO_FORMATS = []

# default formats that should be serialized for each Photo
DEFAULT_PHOTO_FORMATS = []

api_settings = Settings('ella.api.conf', 'API')

########NEW FILE########
__FILENAME__ = middleware
from django.core.exceptions import MiddlewareNotUsed
from django.utils.cache import patch_vary_headers

from ella.api.conf import api_settings


class VaryOnAcceptMiddleware(object):
    def __init__(self):
        if not api_settings.ENABLED:
            raise MiddlewareNotUsed()

    def process_response(self, request, response):
        patch_vary_headers(response, ('Accept', ))
        return response

########NEW FILE########
__FILENAME__ = register
from ella.api import serializers

########NEW FILE########
__FILENAME__ = serialization
import logging

from django.http import HttpResponse


__all__ = ['response_serializer', 'object_serializer', 'FULL', 'PARTIAL']

log = logging.getLogger('ella.api.serialization')


FULL = object()
PARTIAL = object()


class ResponseSerializer(object):
    def __init__(self):
        self._registry = {}

    def register(self, mimetype, serializer):
        self._registry[mimetype] = serializer

    def serializable(self, mimetype):
        return mimetype in self._registry

    def serialize(self, data, mimetype):
        return HttpResponse(self._registry[mimetype](data), content_type=mimetype)


class ObjectSerializer(object):
    def __init__(self):
        self._registry = {}

    def register(self, cls, serializer, context=PARTIAL):
        self._registry.setdefault(cls, {})[context] = serializer

    def serialize(self, request, data, context=PARTIAL):
        # collect relevant registries
        rs = []
        for c in data.__class__.mro():
            if c in self._registry:
                rs.append(self._registry[c])
        if not rs:
            return data

        # registered context
        for r in rs:
            if context in r:
                return r[context](request, data)

        # fall back to PARTIAL context
        if context is not PARTIAL:
            for r in rs:
                if PARTIAL in r:
                    return r[PARTIAL](request, data)

        return data

response_serializer = ResponseSerializer()
object_serializer = ObjectSerializer()

########NEW FILE########
__FILENAME__ = serializers
from ella.api import object_serializer, response_serializer, FULL
from ella.api.conf import api_settings
from ella.core.models import Category, Publishable, Listing, Author, Source
from ella.photos.models import FormatedPhoto, Photo
from ella.core.conf import core_settings

from django.core.paginator import Page, Paginator
from django.utils import simplejson
from django.http import Http404
from ella.utils.timezone import to_timestamp



def serialize_list(request, l):
    return [object_serializer.serialize(request, o) for o in l]


def serialize_dict(request, d):
    return dict((k, object_serializer.serialize(request, v)) for k, v in d.iteritems())


def serialize_page(request, page):
    return {
        'total': page.paginator.count,
        'per_page': page.paginator.per_page,
        'num_pages': page.paginator.num_pages,
        'current_page': page.number,
        'objects': serialize_list(request, page.object_list),
    }


def serialize_full_category(request, category):
    page_no = 1
    if 'p' in request.GET and request.GET['p'].isdigit():
        page_no = int(request.GET['p'])
    return object_serializer.serialize(request, {'category': category, 'listings': category.app_data.ella.get_listings_page(page_no)})


def serialize_category(request, category):
    return {
        'id': category.pk,
        'title': category.title,
        'url': category.get_absolute_url(),
    }


def serialize_full_author(request, author):
    page_no = 1
    if 'p' in request.GET and request.GET['p'].isdigit():
        page_no = int(request.GET['p'])
    paginator = Paginator(author.recently_published(), core_settings.CATEGORY_LISTINGS_PAGINATE_BY)
    if page_no > paginator.num_pages or page_no < 1:
        raise Http404('Invalid page number %r' % page_no)
    return object_serializer.serialize(request, {'author': author, 'listings': paginator.page(page_no)})


def serialize_author(request, author):
    return {
        'name': author.name,
        'url': author.get_absolute_url(),
        'photo': serialize_photo(request, author.photo, formats=api_settings.PUBLISHABLE_PHOTO_FORMATS) if author.photo_id else None,
    }



def serialize_source(request, source):
    return {
        'name': source.name,
        'description': source.description,
        'url': source.url,
    }


def serialize_photo(request, photo, formats=None):
    if formats is None:
        formats = api_settings.DEFAULT_PHOTO_FORMATS
    return dict((f, FormatedPhoto.objects.get_photo_in_format(photo, f, False)) for f in formats)


def serialize_publishable(request, publishable):
    return {
        'id': publishable.id,
        'url': publishable.get_absolute_url(),
        'title': publishable.title,
        'publish_from': to_timestamp(publishable.publish_from) * 1000,
        'content_type': publishable.content_type.name,
        'description': publishable.description,
        'photo': serialize_photo(request, publishable.photo, formats=api_settings.PUBLISHABLE_PHOTO_FORMATS) if publishable.photo_id else None,
        'authors': [serialize_author(request, a) for a in publishable.authors.all()],
        'source': serialize_source(request, publishable.source) if publishable.source_id else None
    }


def serialize_listing(request, listing):
    return object_serializer.serialize(request, listing.publishable)


response_serializer.register('application/json', simplejson.dumps)


object_serializer.register(list, serialize_list)
object_serializer.register(dict, serialize_dict)
object_serializer.register(tuple, serialize_list)
object_serializer.register(Page, serialize_page)
object_serializer.register(Author, serialize_full_author, FULL)
object_serializer.register(Author, serialize_author)
object_serializer.register(Source, serialize_source)
object_serializer.register(Category, serialize_category)
object_serializer.register(Category, serialize_full_category, FULL)
object_serializer.register(Photo, serialize_photo)
object_serializer.register(Publishable, serialize_publishable)
object_serializer.register(Listing, serialize_listing)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from ella.core.admin import PublishableAdmin, ListingInlineAdmin, RelatedInlineAdmin
from ella.articles.models import Article


class ArticleAdmin(PublishableAdmin):
    ordering = ('-publish_from',)
    fieldsets = (
        (_("Article heading"), {'fields': ('title', 'slug')}),
        (_("Article contents"), {'fields': ('description', 'content')}),
        (_("Metadata"), {'fields': ('category', 'authors', 'source', 'photo')}),
        (_("Publication"), {'fields': (('publish_from', 'publish_to'), 'published', 'static')}),
    )
    inlines = [ListingInlineAdmin, RelatedInlineAdmin]


admin.site.register(Article, ArticleAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial

from south.db import db
from django.db import models
import datetime
from south.v2 import SchemaMigration
from ella.core.models import Publishable

class Migration(SchemaMigration):

    depends_on = (
        ("core", "0002_initial_publishable"),
    )

    def forwards(self, orm):
        # Adding model 'Article'
        db.create_table('articles_article', (
            ('publishable_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=Publishable, unique=True, primary_key=True)),
            ('upper_title', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now, db_index=True)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
        ))
        db.send_create_signal('articles', ['Article'])

        # Adding model 'ArticleContents'
        db.create_table('articles_articlecontents', (
            ('id', models.AutoField(primary_key=True)),
            ('article', models.ForeignKey(orm['articles.Article'], verbose_name=_('Article'))),
            ('title', models.CharField(_('Title'), max_length=200, blank=True)),
            ('content', models.TextField(_('Content'))),
        ))
        db.send_create_signal('articles', ['ArticleContents'])

        # Adding model 'InfoBox'
        db.create_table('articles_infobox', (
            ('id', models.AutoField(primary_key=True)),
            ('title', models.CharField(_('Title'), max_length=255)),
            ('created', models.DateTimeField(_('Created'), default=datetime.datetime.now, editable=False)),
            ('updated', models.DateTimeField(_('Updated'), null=True, blank=True)),
            ('content', models.TextField(_('Content'))),
        ))
        db.send_create_signal('articles', ['InfoBox'])

        # Adding ManyToManyField 'Article.authors'
        db.create_table('articles_article_authors', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('article', models.ForeignKey(orm.Article, null=False)),
            ('author', models.ForeignKey(orm['core.Author'], null=False))
        ))



    def backwards(self, orm):

        # Deleting model 'ArticleContents'
        db.delete_table('articles_articlecontents')

        # Deleting model 'InfoBox'
        db.delete_table('articles_infobox')

        # Deleting model 'Article'
        db.delete_table('articles_article')

        # Dropping ManyToManyField 'Article.authors'
        db.delete_table('articles_article_authors')



    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.category': {
            'Meta': {'ordering': "('site','tree_path',)", 'unique_together': "(('site','tree_path'),)"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'articles.articlecontents': {
            'article': ('models.ForeignKey', ["orm['articles.Article']"], {'verbose_name': "_('Article')"}),
            'content': ('models.TextField', ["_('Content')"], {}),
            'id': ('models.AutoField', [], {'primary_key': 'True'}),
            'title': ('models.CharField', ["_('Title')"], {'max_length': '200', 'blank': 'True'})
        },
        'articles.infobox': {
            'Meta': {'ordering': "('-created',)"},
            'content': ('models.TextField', ["_('Content')"], {}),
            'created': ('models.DateTimeField', ["_('Created')"], {'default': 'datetime.datetime.now', 'editable': 'False'}),
            'id': ('models.AutoField', [], {'primary_key': 'True'}),
            'title': ('models.CharField', ["_('Title')"], {'max_length': '255'}),
            'updated': ('models.DateTimeField', ["_('Updated')"], {'null': 'True', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        },
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'upper_title': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'ordering': "('name',)"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        },
        'core.author': {
            'Meta': {'ordering': "('name','slug',)"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['articles']

########NEW FILE########
__FILENAME__ = 0002_add_field_article_content
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from django.contrib.contenttypes.models import ContentType


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Article.content'
        db.add_column('articles_article', 'content', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)

        if not db.dry_run:
            source_text_ct = orm['contenttypes.ContentType'].objects.filter(app_label='djangomarkup', model='sourcetext')
            article_ct = ContentType.objects.get_for_model(orm['articles.Article'])
            if source_text_ct.count():
                source_text_ct = source_text_ct[0]
            else:
                source_text_ct = None
            for ac in orm['articles.ArticleContents'].objects.all():
                a = ac.article
                if a.content:
                    a.content += '\n\n'
                a.content += ac.content
                a.save()
                if source_text_ct:
                    orm['djangomarkup.SourceText'].objects.filter(content_type=source_text_ct, object_id=ac.id, field='content').update(content_type=article_ct, object_id=a.id)

    def backwards(self, orm):

        # Deleting field 'Article.content'
        db.delete_column('articles_article', 'content')

    models = {
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'upper_title': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'articles.articlecontents': {
            'article': ('models.ForeignKey', ["orm['articles.Article']"], {'verbose_name': "_('Article')"}),
            'content': ('models.TextField', ["_('Content')"], {}),
            'id': ('models.AutoField', [], {'primary_key': 'True'}),
            'title': ('models.CharField', ["_('Title')"], {'max_length': '200', 'blank': 'True'})
        },
        'articles.infobox': {
            'Meta': {'object_name': 'InfoBox'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'djangomarkup.textprocessor': {
            'Meta': {'object_name': 'TextProcessor'},
            'function': ('django.db.models.fields.CharField', [], {'max_length':'96', 'unique':'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length':'96', 'blank':'True'}),
            'processor_options': ('django.db.models.fields.CharField', [], {'max_length':'255', 'blank':'True'}),
        },
        'djangomarkup.sourcetext': {
            'Meta': {'object_name': 'SourceText', 'unique_together': "(('content_type', 'object_id', 'field'),)",},
            'processor': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['djangomarkup.TextProcessor']"}),
            'content_type' : ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'object_id' : ('django.db.models.fields.PositiveIntegerField', [], {}),
            'field' : ('django.db.models.fields.CharField', [], {'max_length': "64"}),
            'modification_time' : ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True'}),
            'content' : ('django.db.models.fields.TextField', [], {}),
        },
    }

    complete_apps = ['articles']

########NEW FILE########
__FILENAME__ = 0003_remove_contents
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        db.delete_table('articles_articlecontents')


    def backwards(self, orm):
        pass


    models = {
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'upper_title': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'articles.infobox': {
            'Meta': {'object_name': 'InfoBox'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['articles', 'articles']

########NEW FILE########
__FILENAME__ = 0004_remove_infobox
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration

class Migration(SchemaMigration):

    def forwards(self, orm):
        db.delete_table('articles_infobox')


    def backwards(self, orm):
        pass


    models = {
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'upper_title': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['articles', 'articles']

########NEW FILE########
__FILENAME__ = 0005_move_updated_to_publishable
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):
    depends_on = [
        ('core', '0008_add_last_updated'),
    ]

    needed_by = [
        ('core', '0009_auto__chg_field_publishable_last_updated'),
    ]

    def forwards(self, orm):
        "Write your forwards methods here."
        for a in orm.Article.objects.all():
            if a.updated:
                a.last_updated = a.updated
                a.save(force_update=True)


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'upper_title': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 44, 15, 55281)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 44, 15, 55193)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['articles']

########NEW FILE########
__FILENAME__ = 0006_auto__del_field_article_updated__del_field_article_created__del_field_
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Deleting field 'Article.updated'
        db.delete_column('articles_article', 'updated')

        # Deleting field 'Article.created'
        db.delete_column('articles_article', 'created')

        # Deleting field 'Article.upper_title'
        db.delete_column('articles_article', 'upper_title')


    def backwards(self, orm):

        # Adding field 'Article.updated'
        db.add_column('articles_article', 'updated', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True), keep_default=False)

        # User chose to not deal with backwards NULL issues for 'Article.created'
        raise RuntimeError("Cannot reverse this migration. 'Article.created' and its values cannot be restored.")

        # Adding field 'Article.upper_title'
        db.add_column('articles_article', 'upper_title', self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True), keep_default=False)


    models = {
        'articles.article': {
            'Meta': {'object_name': 'Article', '_ormbases': ['core.Publishable']},
            'content': ('django.db.models.fields.TextField', [], {'default': "''"}),
            'publishable_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['core.Publishable']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 13, 41, 41, 218702)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 13, 41, 41, 218611)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['articles']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

from ella.core.models import Publishable


class Article(Publishable):
    """
    ``Article`` is the most common publishable object. It can be used for
    news on internet news pages, blog posts on smaller blogs or even for
    news on an organization's home page.
    """
    content = models.TextField(_('Content'), default='')

    class Meta:
        verbose_name = _('Article')
        verbose_name_plural = _('Articles')

########NEW FILE########
__FILENAME__ = newman_admin
from django.utils.translation import ugettext_lazy as _

from ella.core.newman_admin import ListingInlineAdmin, PublishableAdmin,\
    RelatedInlineAdmin
from ella.articles.models import Article
import ella_newman


class ArticleAdmin(PublishableAdmin):
    fieldsets = (
        (_("Article heading"), {'fields': ('title', )}),
        (_("Updated, slug"), {'fields': ('last_updated', 'slug',), 'classes': ('collapsed',)}),
        (_("Metadata"), {'fields': ('photo', 'category', 'authors', 'source')}),
        (_("Dates"), {'fields': (('publish_from', 'publish_to'), 'static')}),
        (_("Content"), {'fields': ('description', 'content')}),
    )

    inlines = [ListingInlineAdmin, RelatedInlineAdmin]
    rich_text_fields = {'small': ('description',), None: ('content',)}


ella_newman.site.register(Article, ArticleAdmin)

########NEW FILE########
__FILENAME__ = admin
from app_data.admin import AppDataModelAdmin
from django.contrib import admin
from django.forms import models as modelforms

from ella.core.models import Author, Source, Category, Listing, Related


class ListingForm(modelforms.ModelForm):
    class Meta:
        model = Listing


class ListingInlineAdmin(admin.TabularInline):
    model = Listing
    extra = 2
    fieldsets = ((None, {'fields': ('category', 'publish_from', 'publish_to', 'commercial',)}),)


class RelatedInlineAdmin(admin.TabularInline):
    model = Related
    extra = 3
#    raw_id_fields = ('publishable_id',)


class CategoryAdmin(AppDataModelAdmin):
    list_filter = ('site',)
    list_display = ('draw_title', 'tree_path', '__unicode__')
    search_fields = ('title', 'slug',)
    #ordering = ('site', 'tree_path',)
    prepopulated_fields = {'slug': ('title',)}
    declared_fieldsets = ((None, {'fields': ('title', 'slug',
                                             ('description', 'content'),
                                             'template', ('site', 'tree_parent'),
                                             'ella.paginate_by',
                                             'ella.first_page_count',
                                             'ella.propagate_listings')}),)


class AuthorAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name',)
    raw_id_fields = ('photo',)


class SourceAdmin(admin.ModelAdmin):
    list_display = ('name', 'url',)
    search_fields = ('name',)


class PublishableAdmin(AppDataModelAdmin):
    """ Default admin options for all publishables """

    list_display = ('title', 'category', 'publish_from')
    list_filter = ('category', 'authors',)
    search_fields = ('title', 'description', 'slug', 'authors__name', 'authors__slug',) # FIXME: 'tags__tag__name',)
    raw_id_fields = ('photo',)
    prepopulated_fields = {'slug': ('title',)}
    rich_text_fields = {None: ('description',)}

    suggest_fields = {
        'category': ('tree_path', 'title', 'slug',),
        'authors': ('name', 'slug', 'email',),
        'source': ('name', 'url',),
    }


class ListingAdmin(admin.ModelAdmin):
    date_hierarchy = 'publish_from'
    list_display = ('__unicode__', 'publish_from', 'publish_to',)
    list_filter = ('category',)
    search_fields = ('publishable__title', 'publishable__slug',
                     'publishable__description',)


admin.site.register(Category, CategoryAdmin)
admin.site.register(Source, SourceAdmin)
admin.site.register(Author, AuthorAdmin)
admin.site.register(Listing, ListingAdmin)

########NEW FILE########
__FILENAME__ = box
from django.template import loader
from django.utils.datastructures import MultiValueDict
from django.utils.encoding import smart_str
from django.db.models import Model
from django.core.cache import cache
from django.conf import settings
from django.contrib.contenttypes.models import ContentType

from ella.core.cache.utils import normalize_key, _get_key, KEY_PREFIX
from ella.core.conf import core_settings


class Box(object):
    """
    Base Class that handles the boxing mechanism.
    """
    can_double_render = False
    def __init__(self, obj, box_type, nodelist, template_name=None, model=None):
        """
        Params:

            obj - target object
            box_type - box name
            nodelist - contents of the pair tag
            template_name - override the template
        """
        self.obj = obj
        self.box_type = box_type
        self.nodelist = nodelist
        self.template_name = template_name


        if not model:
            model = obj.__class__

        self.name = model.__name__.lower()
        self.verbose_name = model.__name__
        self.verbose_name_plural = model.__name__

        self.is_model = issubclass(model, Model)
        if self.is_model:
            self.ct = ContentType.objects.get_for_model(model)

        if hasattr(model, '_meta'):
            self.name = str(model._meta)
            self.verbose_name = model._meta.verbose_name
            self.verbose_name_plural = model._meta.verbose_name_plural

    def resolve_params(self, text):
        " Parse the parameters into a dict. "
        params = MultiValueDict()
        for line in text.split('\n'):
            pair = line.split(':', 1)
            if len(pair) == 2:
                params.appendlist(pair[0].strip(), pair[1].strip())
        return params

    def prepare(self, context):
        """
        Do the pre-processing - render and parse the parameters and
        store them for further use in self.params.
        """
        self.params = {}

        # no params, not even a newline
        if not self.nodelist:
            return

        # just static text, no vars, assume one TextNode
        if not self.nodelist.contains_nontext:
            text = self.nodelist[0].s.strip()

        # vars in params, we have to render
        else:
            context.push()
            context['object'] = self.obj
            text = self.nodelist.render(context)
            context.pop()

        if text:
            self.params = self.resolve_params(text)

        # override the default template from the parameters
        if 'template_name' in self.params:
            self.template_name = self.params['template_name']

    def get_context(self):
        " Get context to render the template. "
        return {
                'content_type_name' : str(self.name),
                'content_type_verbose_name' : self.verbose_name,
                'content_type_verbose_name_plural' : self.verbose_name_plural,
                'object' : self.obj,
                'box' : self,
        }

    def render(self, context):
        self.prepare(context)
        " Cached wrapper around self._render(). "
        if getattr(settings, 'DOUBLE_RENDER', False) and self.can_double_render:
            if 'SECOND_RENDER' not in context:
                return self.double_render()
        key = self.get_cache_key()
        if key:
            rend = cache.get(key)
            if rend is None:
                rend = self._render(context)
                cache.set(key, rend, core_settings.CACHE_TIMEOUT)
        else:
            rend = self._render(context)
        return rend

    def double_render(self):
        return '''{%% box %(box_type)s for %(name)s with pk %(pk)s %%}%(params)s{%% endbox %%}''' % {
                'box_type' : self.box_type,
                'name' : self.name,
                'pk' : self.obj.pk,
                'params' : '\n'.join(('%s:%s' % item for item in self.params.items())),
        }

    def _get_template_list(self):
        " Get the hierarchy of templates belonging to the object/box_type given. "
        t_list = []
        if hasattr(self.obj, 'category_id') and self.obj.category_id:
            cat = self.obj.category
            base_path = 'box/category/%s/content_type/%s/' % (cat.path, self.name)
            if hasattr(self.obj, 'slug'):
                t_list.append(base_path + '%s/%s.html' % (self.obj.slug, self.box_type,))
            t_list.append(base_path + '%s.html' % (self.box_type,))
            t_list.append(base_path + 'box.html')

        base_path = 'box/content_type/%s/' % self.name
        if hasattr(self.obj, 'slug'):
            t_list.append(base_path + '%s/%s.html' % (self.obj.slug, self.box_type,))
        t_list.append(base_path + '%s.html' % (self.box_type,))
        t_list.append(base_path + 'box.html')

        t_list.append('box/%s.html' % self.box_type)
        t_list.append('box/box.html')

        return t_list

    def _render(self, context):
        " The main function that takes care of the rendering. "
        if self.template_name:
            t = loader.get_template(self.template_name)
        else:
            t_list = self._get_template_list()
            t = loader.select_template(t_list)

        context.update(self.get_context())
        resp = t.render(context)
        context.pop()
        return resp

    def get_cache_key(self):
        " Return a cache key constructed from the box's parameters. "
        if not self.is_model:
            return None

        pars = ''
        if self.params:
            pars = ','.join(':'.join((smart_str(key), smart_str(self.params[key]))) for key in sorted(self.params.keys()))

        return normalize_key('%s:box:%d:%s:%s' % (
                _get_key(KEY_PREFIX, self.ct, pk=self.obj.pk), settings.SITE_ID, str(self.box_type), pars
            ))


########NEW FILE########
__FILENAME__ = fields
from django.db.models import ObjectDoesNotExist
from django.db.models.fields.related import ForeignKey, ReverseSingleRelatedObjectDescriptor
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.generic import GenericForeignKey
from django.contrib.sites.models import SITE_CACHE, Site

from ella.core.cache.utils import get_cached_object

def generate_fk_class(name, retrieve_func, limit_to_model=None):
    class CustomForeignKey(ForeignKey):
        def __init__(self, *args, **kwargs):
            if limit_to_model:
                args = (limit_to_model,) + args
            super(CustomForeignKey, self).__init__(*args, **kwargs)

        def contribute_to_class(self, cls, name):
            super(CustomForeignKey, self).contribute_to_class(cls, name)
            setattr(cls, self.name, CachedReverseSingleRelatedObjectDescriptor(self))

        def south_field_triple(self):
            from south.modelsinspector import introspector
            args, kwargs = introspector(self)
            return ('django.db.models.fields.related.ForeignKey', args, kwargs)

    class CachedReverseSingleRelatedObjectDescriptor(ReverseSingleRelatedObjectDescriptor):
        def __get__(self, instance, instance_type=None):
            if instance is None:
                raise AttributeError, "%s must be accessed via instance" % self.field.name
            cache_name = self.field.get_cache_name()
            try:
                return getattr(instance, cache_name)
            except AttributeError:
                val = getattr(instance, self.field.attname)
                if val is None:
                    # If NULL is an allowed value, return it.
                    if self.field.null:
                        return None
                    raise self.field.rel.to.DoesNotExist
                rel_obj = retrieve_func(self.field.rel.to, val)
                setattr(instance, cache_name, rel_obj)
                return rel_obj

    CustomForeignKey.__name__ = name
    return CustomForeignKey

CachedForeignKey = generate_fk_class('CachedForeignKey', lambda m, pk: get_cached_object(m, pk=pk))

def get_site(model, pk):
    try:
        return SITE_CACHE[pk]
    except KeyError:
        SITE_CACHE[pk] = get_cached_object(model, pk=pk)
        return SITE_CACHE[pk]

SiteForeignKey = generate_fk_class('SiteForeignKey', get_site, Site)
ContentTypeForeignKey = generate_fk_class('ContentTypeForeignKey', lambda m, pk: m._default_manager.get_for_id(pk), ContentType)
CategoryForeignKey = generate_fk_class('CategoryForeignKey', lambda m, pk: m._default_manager.get_for_id(pk), 'core.Category')

class CachedGenericForeignKey(GenericForeignKey):
    def __get__(self, instance, instance_type=None):
        # Fix for django 1.0 Admin Validation
        if instance is None:
            # TODO: hotfixed
            #raise AttributeError, u"%s must be accessed via instance" % self.name
            return

        try:
            return getattr(instance, self.cache_attr)
        except AttributeError:
            rel_obj = None

            # Make sure to use ContentType.objects.get_for_id() to ensure that
            # lookups are cached (see ticket #5570). This takes more code than
            # the naive ``getattr(instance, self.ct_field)``, but has better
            # performance when dealing with GFKs in loops and such.
            f = self.model._meta.get_field(self.ct_field)
            ct_id = getattr(instance, f.get_attname(), None)
            if ct_id:
                ct = self.get_content_type(id=ct_id)
                try:
                    rel_obj = get_cached_object(ct, pk=getattr(instance, self.fk_field))
                except ObjectDoesNotExist:
                    pass
            setattr(instance, self.cache_attr, rel_obj)
            return rel_obj


########NEW FILE########
__FILENAME__ = redis
from __future__ import absolute_import

import logging
from datetime import date, timedelta
from hashlib import md5
from itertools import chain

from django.conf import settings
from django.db.models.loading import get_model

from ella.core.cache.utils import get_cached_objects, SKIP
from ella.core.managers import ListingHandler
from ella.core.conf import core_settings
from ella.utils.timezone import now, to_timestamp, from_timestamp

log = logging.getLogger('ella.core')

client = None

if hasattr(settings, 'LISTINGS_REDIS'):
    try:
        from redis import Redis
    except:
        log.error('Redis support requested but Redis client not installed.')
        client = None
    else:
        client = Redis(**getattr(settings, 'LISTINGS_REDIS'))



def ListingHandlerClass():
    return get_model('core', 'Listing').objects.get_listing_handler(core_settings.REDIS_LISTING_HANDLER)


def publishable_published(publishable, **kwargs):
    pipe = client.pipeline()
    listings = publishable.listing_set.all()

    for l in listings:
        ListingHandlerClass().add_publishable(
            l.category,
            publishable,
            publish_from=l.publish_from,
            pipe=pipe,
            commit=False
        )

    if len(listings) > 0:
        AuthorListingHandler.add_publishable(publishable, pipe=pipe, commit=False)

    pipe.execute()


def publishable_unpublished(publishable, **kwargs):
    pipe = client.pipeline()
    for l in publishable.listing_set.all():
        ListingHandlerClass().remove_publishable(
            l.category,
            publishable,
            pipe=pipe,
            commit=False
        )

    AuthorListingHandler.remove_publishable(publishable, pipe=pipe, commit=False)
    pipe.execute()


def listing_pre_delete(sender, instance, **kwargs):
    # prepare redis pipe for deletion...
    instance.__pipe = ListingHandlerClass().remove_publishable(
        instance.category,
        instance.publishable,
        commit=False
    )


def listing_post_delete(sender, instance, **kwargs):
    # but only delete it if the model delete went through
    pipe = instance.__pipe
    listings = instance.publishable.listing_set.all()

    if instance.publishable.published:
        for l in listings:
            ListingHandlerClass().add_publishable(
                l.category,
                instance.publishable,
                publish_from=l.publish_from,
                pipe=pipe,
                commit=False
            )

    # If this is the last Listing that is being deleted, delete from author too.
    if not listings.exists():
        AuthorListingHandler.remove_publishable(instance.publishable, pipe=pipe,
                                                commit=False)
    pipe.execute()


def listing_pre_save(sender, instance, **kwargs):
    if instance.pk:
        # prepare deletion of stale data
        old_listing = instance.__class__.objects.get(pk=instance.pk)
        instance.__pipe = ListingHandlerClass().remove_publishable(
            old_listing.category,
            old_listing.publishable,
            commit=False
        )


def listing_post_save(sender, instance, **kwargs):
    pipe = getattr(instance, '__pipe', client.pipeline())

    if instance.publishable.published:
        ListingHandlerClass().add_publishable(
            instance.category,
            instance.publishable,
            publish_from=instance.publish_from,
            pipe=pipe,
            commit=False
        )

        # This is the first listing being added.
        if instance.publishable.listing_set.count() == 1:
            AuthorListingHandler.add_publishable(instance.publishable, pipe=pipe,
                                                 commit=False)

        pipe.execute()


def update_authors(sender, action, instance, reverse, model, pk_set, **kwargs):
    if action == 'pre_remove':
        instance.__pipe = AuthorListingHandler.remove_publishable(instance, commit=False)
    elif action in ('post_remove', 'post_add') and instance.published and instance.listing_set.exists():
        AuthorListingHandler.add_publishable(instance, pipe=getattr(instance, '__pipe', None))

class RedisListingHandler(ListingHandler):
    PREFIX = 'listing'

    @classmethod
    def get_value(cls, publishable):
        return ':'.join((str(publishable.content_type_id), str(publishable.pk)))

    @classmethod
    def get_keys(cls, category, publishable):
        # main category
        keys = [':'.join((cls.PREFIX, str(category.id)))]
        keys.append(':'.join((cls.PREFIX, 'c', str(category.id))))
        keys.append(':'.join((cls.PREFIX, 'd', str(category.id))))

        # content_type
        keys.append(':'.join((cls.PREFIX, 'ct', str(publishable.content_type_id))))

        # category shouldn't be propagated
        if not category.app_data.ella.propagate_listings:
            return keys

        # children
        if category.tree_parent_id:
            keys.append(':'.join((cls.PREFIX, 'c', str(category.tree_parent_id))))

        # all children
        while category.tree_parent_id:
            category = category.tree_parent
            keys.append(':'.join((cls.PREFIX, 'd', str(category.id))))
            if not category.app_data.ella.propagate_listings:
                break

        return keys

    @classmethod
    def add_publishable(cls, category, publishable, score, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        for k in cls.get_keys(category, publishable):
            pipe.zadd(k, cls.get_value(publishable), score)

        if commit:
            pipe.execute()
        else:
            return pipe

    @classmethod
    def incr_score(cls, category, publishable, incr_by=1, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        v = cls.get_value(publishable)
        for k in cls.get_keys(category, publishable):
            pipe.zincrby(k, v, incr_by)

        if commit:
            pipe.execute()
        else:
            return pipe

    @classmethod
    def remove_publishable(cls, category, publishable, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        for k in cls.get_keys(category, publishable):
            pipe.zrem(k, cls.get_value(publishable))

        if commit:
            pipe.execute()
        else:
            return pipe

    def count(self):
        key, pipe = self._get_key()
        if pipe is None:
            pipe = client.pipeline()
        pipe = pipe.zcard(key)
        results = pipe.execute()
        return results[-1]

    def _get_listing(self, publishable, score):
        Listing = get_model('core', 'listing')
        return Listing(publishable=publishable, category=publishable.category)

    def _get_score_limits(self):
        max_score = None
        min_score = None

        if self.date_range:
            raise NotImplemented()
        return min_score, max_score

    def get_listings(self, offset=0, count=10):
        key, pipe = self._get_key()
        if pipe is None:
            pipe = client.pipeline()

        # get the score range based on the date range
        min_score, max_score = self._get_score_limits()

        # get all the relevant records
        if min_score or max_score:
            pipe = pipe.zrevrangebyscore(key,
                max_score, min_score,
                start=offset, num=count,
                withscores=True
            )
        else:
            pipe = pipe.zrevrange(key,
                start=offset, end=offset + count - 1,
                withscores=True
            )
        results = pipe.execute()

        # get the data from redis into proper format
        data = []
        ids = []
        for value, score in results[-1]:
            ct_id, pk = value.split(':')
            ids.append((int(ct_id), int(pk)))
            data.append(score)

        # and retrieve publishables from cache
        publishables = get_cached_objects(ids, missing=SKIP)

        # create mock Listing objects to return
        return map(lambda (p, score): self._get_listing(p, score), zip(publishables, data))

    def _union(self, union_keys, pipe):
        if len(union_keys) > 1:
            result_key = '%s:zus:%s' % (self.PREFIX, md5(','.join(union_keys)).hexdigest())
            pipe.zunionstore(result_key, union_keys, 'MAX')
            pipe.expire(result_key, 60)
            return result_key
        else:
            return union_keys[0]

    def _get_base_key(self):
        key_parts = [self.PREFIX]
        # get the proper key for category
        if self.children == ListingHandler.IMMEDIATE:
            key_parts.append('c')
        elif self.children == ListingHandler.ALL:
            key_parts.append('d')
        key_parts.append(str(self.category.id))

        key = ':'.join(key_parts)
        return key


    def _get_key(self):
        pipe = None
        if not hasattr(self, '_key'):
            key = self._get_base_key()
            # do everything in one pipeline
            pipe = client.pipeline()

            # store all the key sets we will want to ZUNIONSTORE
            ct_key = None
            if self.content_types:
                # get the union of all content_type listings
                ct_key = self._union([':'.join((self.PREFIX, 'ct', str(ct.pk))) for ct in self.content_types], pipe)


            # do the intersect if required and output a single key
            if ct_key:
                inter_key = '%s:zis:%s' % (self.PREFIX, md5(','.join((ct_key, key))).hexdigest())
                pipe.zinterstore(inter_key, (ct_key, key), 'MAX')
                pipe.expire(inter_key, 60)
                key = inter_key

            if self.exclude:
                v = '%d:%d' % (self.exclude.content_type_id, self.exclude.id)

                # we are using some existing key, copy it before removing stuff
                exclude_key = '%s:exclude:%s' % (key, v)
                pipe.zunionstore(exclude_key, (key,))
                pipe.zrem(exclude_key, v)
                pipe.expire(exclude_key, 60)
                key = exclude_key

            self._key = key
        return self._key, pipe


class TimeBasedListingHandler(RedisListingHandler):
    @classmethod
    def add_publishable(cls, category, publishable, score=None, publish_from=None, pipe=None, commit=True):
        if score is None:
            score = repr(to_timestamp(publish_from or now()))
        return super(TimeBasedListingHandler, cls).add_publishable(category, publishable, score, pipe=pipe, commit=commit)

    def _get_score_limits(self):
        max_score = repr(to_timestamp(now()))
        min_score = 0

        if self.date_range:
            max_score = repr(to_timestamp(min(self.date_range[1], now())))
            min_score = repr(to_timestamp(self.date_range[0]))
        return min_score, max_score

    def _get_listing(self, publishable, score):
        Listing = get_model('core', 'listing')
        publish_from = from_timestamp(score)
        return Listing(publishable=publishable, category=publishable.category, publish_from=publish_from)


class AuthorListingHandler(TimeBasedListingHandler):
    @classmethod
    def remove_publishable(cls, publishable, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        for k in cls.get_keys(publishable):
            pipe.zrem(k, cls.get_value(publishable))

        if commit:
            pipe.execute()
        else:
            return pipe

    @classmethod
    def add_publishable(cls, publishable, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        for k in cls.get_keys(publishable):
            pipe.zadd(k, cls.get_value(publishable), repr(to_timestamp(publishable.publish_from)))

        if commit:
            pipe.execute()
        else:
            return pipe

    @classmethod
    def get_keys(cls, publishable):
        return [':'.join((cls.PREFIX, 'a', str(a.pk))) for a in publishable.authors.all()]

    def __init__(self, author, **kwargs):
        self.author = author
        super(AuthorListingHandler, self).__init__(None, **kwargs)

    def _get_base_key(self):
        return ':'.join((self.PREFIX, 'a', str(self.author.pk)))


class SlidingListingHandler(RedisListingHandler):
    WINDOW_SIZE = 7
    REMOVE_OLD_SLOTS = True

    @classmethod
    def base_key_set(cls):
        return ':'.join((cls.PREFIX, 'KEYS'))

    @classmethod
    def window_key_zset(cls):
        return ':'.join((cls.PREFIX, 'WINDOWS'))

    @classmethod
    def get_keys(cls, category, publishable):
        base_keys = super(SlidingListingHandler, cls).get_keys(category, publishable)
        day = date.today().strftime('%Y%m%d')
        day_mask = '%%s:%s' % day
        day_keys = [day_mask % k for k in base_keys]

        # store all the keys somewhere so that we can construct windows
        pipe = client.pipeline()
        pipe.sadd(cls.base_key_set(), *base_keys)
        pipe.zadd(cls.window_key_zset(), **dict((k, day) for k in day_keys))
        pipe.execute()

        return base_keys + day_keys

    @classmethod
    def remove_publishable(cls, category, publishable, pipe=None, commit=True):
        if pipe is None:
            pipe = client.pipeline()

        days, last_day = cls._get_days()
        base_keys = super(SlidingListingHandler, cls).get_keys(category, publishable)

        v = cls.get_value(publishable)
        for k in chain(base_keys, ('%s:%s' % (k, day) for k in base_keys for day in days)):
            pipe.zrem(k, v)

        if commit:
            pipe.execute()
        else:
            return pipe

    @classmethod
    def _get_days(cls, today=None):
        if today is None:
            today = date.today()

        days = []
        last_day = None
        for d in xrange(cls.WINDOW_SIZE):
            last_day = (today - timedelta(days=d)).strftime('%Y%m%d')
            days.append(last_day)
        return days, last_day

    @classmethod
    def regenerate(cls, today=None):
        days, last_day = cls._get_days(today)

        pipe = client.pipeline()

        if cls.REMOVE_OLD_SLOTS:
            # get all the day keys older than last day requested
            to_remove = client.zrangebyscore(cls.window_key_zset(), 0, '(' + last_day)
            if to_remove:
                # delete those keys
                pipe.delete(*to_remove)
                # and remove them from the zset index
                pipe.zremrangebyscore(cls.window_key_zset(), 0, '(' + last_day)

        for k in client.smembers(cls.base_key_set()):
            # store the aggregate for all keys over WINDOW_SIZE days
            pipe.zunionstore(k, ['%s:%s' % (k, day) for day in days], aggregate='SUM')

        pipe.execute()


def connect_signals():
    from django.db.models.signals import pre_save, post_save, post_delete, pre_delete, m2m_changed
    from ella.core.signals import content_published, content_unpublished
    from ella.core.models import Listing, Publishable

    if not core_settings.USE_REDIS_FOR_LISTINGS:
        return
    # when redis is availible, use it for authors
    m2m_changed.connect(update_authors, sender=Publishable._meta.get_field('authors').rel.through)

    content_published.connect(publishable_published)
    content_unpublished.connect(publishable_unpublished)

    pre_save.connect(listing_pre_save, sender=Listing)
    post_save.connect(listing_post_save, sender=Listing)

    pre_delete.connect(listing_pre_delete, sender=Listing)
    post_delete.connect(listing_post_delete, sender=Listing)


########NEW FILE########
__FILENAME__ = utils
from hashlib import md5
import logging

from django.dispatch import receiver
from django.db.models import ObjectDoesNotExist
from django.db.models.loading import get_model
from django.db.models.signals import post_save, post_delete
from django.core.cache import cache
from django.core.cache.backends.dummy import DummyCache
from django.http import Http404
from django.contrib.contenttypes.models import ContentType
from django.utils.encoding import smart_str
from django.conf import settings


log = logging.getLogger('ella.core.cache.utils')

KEY_PREFIX = 'ella.obj'
CACHE_TIMEOUT = getattr(settings, 'CACHE_TIMEOUT', 10 * 60)


def invalidate_cache(sender, instance, **kwargs):
    invalidate_cache_for_object(instance)


def connect_invalidation_signals():
    post_save.connect(invalidate_cache)
    post_delete.connect(invalidate_cache)


def invalidate_cache_for_object(obj):
    key = _get_key(KEY_PREFIX, ContentType.objects.get_for_model(obj), pk=obj.pk, version_key=True)
    try:
        cache.incr(key)
    except ValueError:
        cache.set(key, 1, timeout=CACHE_TIMEOUT)


def normalize_key(key):
    if len(key) < 250:
        return key
    return md5(key).hexdigest()


def _get_key(start, model, pk=None, version_key=False, **kwargs):
    Publishable = get_model('core', 'publishable')
    if issubclass(model.model_class(), Publishable) and model.model_class() != Publishable:
        model = ContentType.objects.get_for_model(Publishable)

    if pk and not kwargs:
        key = ':'.join((
            start, str(model.pk), str(pk)
        ))
        if version_key:
            return key + ':VER'
        version = cache.get(key + ':VER') or '0'
        return '%s:%s' % (key, version)

    for key, val in kwargs.iteritems():
        if hasattr(val, 'pk'):
            kwargs[key] = val.pk

    return normalize_key(':'.join((
                start,
                str(model.pk),
                ','.join(':'.join((key, smart_str(kwargs[key]).replace(' ', '_'))) for key in sorted(kwargs.keys()))
    )))


def get_cached_object(model, timeout=CACHE_TIMEOUT, **kwargs):
    """
    Return a cached object. If the object does not exist in the cache, create it.

    Params:
        model - ContentType instance representing the model's class or the model class itself
        timeout - TTL for the item in cache, defaults to CACHE_TIMEOUT
        **kwargs - lookup parameters for content_type.get_object_for_this_type and for key creation

    Throws:
        model.DoesNotExist is propagated from content_type.get_object_for_this_type
    """
    if not isinstance(model, ContentType):
        model_ct = ContentType.objects.get_for_model(model)
    else:
        model_ct = model

    key = _get_key(KEY_PREFIX, model_ct, **kwargs)

    obj = cache.get(key)
    if obj is None:
        # if we are looking for a publishable, fetch just the actual content
        # type and then fetch the actual object
        if model_ct.app_label == 'core' and model_ct.model == 'publishable':
            actual_ct_id = model_ct.model_class()._default_manager.values('content_type_id').get(**kwargs)['content_type_id']
            model_ct = ContentType.objects.get_for_id(actual_ct_id)

        # fetch the actual object we want
        obj = model_ct.model_class()._default_manager.get(**kwargs)

        # since 99% of lookups are done via PK make sure we set the cache for
        # that lookup even if we retrieved it using a different one.
        if 'pk' in kwargs:
            cache.set(key, obj, timeout)
        elif not isinstance(cache, DummyCache):
            cache.set_many({key: obj, _get_key(KEY_PREFIX, model_ct, pk=obj.pk): obj}, timeout=timeout)

    return obj


RAISE, SKIP, NONE = 0, 1, 2


def get_cached_objects(pks, model=None, timeout=CACHE_TIMEOUT, missing=RAISE):
    """
    Return a list of objects with given PKs using cache.

    Params:
        pks - list of Primary Key values to look up or list of content_type_id, pk tuples
        model - ContentType instance representing the model's class or the model class itself
        timeout - TTL for the items in cache, defaults to CACHE_TIMEOUT

    Throws:
        model.DoesNotExist is propagated from content_type.get_object_for_this_type
    """
    if model is not None:
        if not isinstance(model, ContentType):
            model = ContentType.objects.get_for_model(model)
        pks = [(model, pk) for pk in pks]
    else:
        pks = [(ContentType.objects.get_for_id(ct_id), pk) for (ct_id, pk) in pks]

    keys = [_get_key(KEY_PREFIX, model, pk=pk) for (model, pk) in pks]

    cached = cache.get_many(keys)

    # keys not in cache
    keys_to_set = set(keys) - set(cached.keys())
    if keys_to_set:
        # build lookup to get model and pks from the key
        lookup = dict(zip(keys, pks))

        to_get = {}
        # group lookups by CT so we can do in_bulk
        for k in keys_to_set:
            ct, pk = lookup[k]
            to_get.setdefault(ct, {})[int(pk)] = k

        # take out all the publishables
        publishable_ct = ContentType.objects.get_for_model(get_model('core', 'publishable'))
        if publishable_ct in to_get:
            publishable_keys = to_get.pop(publishable_ct)
            models = publishable_ct.model_class()._default_manager.values('content_type_id', 'id').filter(id__in=publishable_keys.keys())
            for m in models:
                ct = ContentType.objects.get_for_id(m['content_type_id'])
                pk = m['id']
                # and put them back as their native content_type
                to_get.setdefault(ct, {})[pk] = publishable_keys[pk]

        to_set = {}
        # retrieve all the models from DB
        for ct, vals in to_get.items():
            models = ct.model_class()._default_manager.in_bulk(vals.keys())
            for pk, m in models.items():
                k = vals[pk]
                cached[k] = to_set[k] = m

        if not isinstance(cache, DummyCache):
            # write them into cache
            cache.set_many(to_set, timeout=timeout)

    out = []
    for k in keys:
        try:
            out.append(cached[k])
        except KeyError:
            if missing == NONE:
                out.append(None)
            elif missing == SKIP:
                pass
            elif missing == RAISE:
                ct = ContentType.objects.get_for_id(int(k.split(':')[1]))
                raise ct.model_class().DoesNotExist(
                    '%s matching query does not exist.' % ct.model_class()._meta.object_name)
    return out


def get_cached_object_or_404(model, timeout=CACHE_TIMEOUT, **kwargs):
    """
    Shortcut that will raise Http404 if there is no object matching the query

    see get_cached_object for params description
    """
    try:
        return get_cached_object(model, timeout=timeout, **kwargs)
    except ObjectDoesNotExist, e:
        raise Http404('Reason: %s' % str(e))


def cache_this(key_getter, timeout=CACHE_TIMEOUT):
    def wrapped_decorator(func):
        def wrapped_func(*args, **kwargs):
            key = key_getter(*args, **kwargs)
            if key is not None:
                result = cache.get(key)
            else:
                result = None
            if result is None:
                log.debug('cache_this(key=%s), object not cached.', key)
                result = func(*args, **kwargs)
                cache.set(key, result, timeout)
            return result

        wrapped_func.__dict__ = func.__dict__
        wrapped_func.__doc__ = func.__doc__
        wrapped_func.__name__ = func.__name__

        return wrapped_func
    return wrapped_decorator


########NEW FILE########
__FILENAME__ = conf
from ella.utils.settings import Settings
from ella.utils.timezone import utc_localize
from django.utils.datetime_safe import datetime

gettext = lambda s: s

# Caching-related
CACHE_TIMEOUT = 10 * 60
CACHE_TIMEOUT_LONG = 60 * 60

DOUBLE_RENDER = False
DOUBLE_RENDER_EXCLUDE_URLS = None

APP_DATA_CLASSES = {}

# Box
BOX_INFO = 'ella.core.box.BOX_INFO'
MEDIA_KEY = 'ella.core.box.MEDIA_KEY'

# Publishing configuration
CATEGORY_LISTINGS_PAGINATE_BY = 20
CATEGORY_LISTINGS_ON_FIRST_PAGE = CATEGORY_LISTINGS_PAGINATE_BY
CATEGORY_NO_HOME_LISTINGS = False
PUBLISH_FROM_WHEN_EMPTY = utc_localize(datetime(3000, 1, 1))

RELATED_FINDERS = {
    'default': (
        'ella.core.related_finders.directly_related',
        'ella.core.related_finders.related_by_category',
    ),
    'directly': (
        'ella.core.related_finders.directly_related',
    )
}

LISTING_HANDLERS = {
    'default': 'ella.core.managers.ModelListingHandler',
}
USE_REDIS_FOR_LISTINGS = False
REDIS_LISTING_HANDLER = 'default'

# Category settings
CATEGORY_TEMPLATES = (
    ('category.html', gettext('default (category.html)')),
)

# context_processor
MEDIA_URL = ''
STATIC_URL = MEDIA_URL
VERSION = 1
SERVER_INFO = {}

RSS_NUM_IN_FEED = 10
RSS_ENCLOSURE_PHOTO_FORMAT = None
RSS_DESCRIPTION_BOX_TYPE = 'rss_description'

# middlewares
ECACHE_INFO = 'ella.core.middleware.ECACHE_INFO'

# templates
ARCHIVE_TEMPLATE = 'listing.html'

core_settings = Settings('ella.core.conf', '')

########NEW FILE########
__FILENAME__ = context_processors
from django.contrib.sites.models import Site
from django.template.defaultfilters import slugify
from ella.core.conf import core_settings

current_site = Site.objects.get_current()
current_site_name = slugify(current_site.name)


def url_info(request):
    """
    Make MEDIA_URL and current HttpRequest object
    available in template code.
    """

    return {
        'MEDIA_URL' : core_settings.MEDIA_URL,
        'STATIC_URL': core_settings.STATIC_URL,
        'VERSION' : core_settings.VERSION,
        'SERVER_INFO' : core_settings.SERVER_INFO,
        'SITE_NAME' : current_site_name,
        'CURRENT_SITE': current_site,
    }

def cache(request):

    if not hasattr(request, '_cache_middleware_key'):
        return {}

    return {
        core_settings.ECACHE_INFO: getattr(request, '_cache_middleware_key'),
    }

########NEW FILE########
__FILENAME__ = custom_urls
import re

from django.http import Http404
from django.core.urlresolvers import RegexURLResolver

try:
    from django.conf.urls import patterns, url, include
except ImportError:
    from django.conf.urls.defaults import patterns, url, include


ALL = '__ALL__'


class CustomURLResolver(object):
    """
    Our custom url dispatcher that allows for custom actions on objects.

    Usage:
        Register your own view function for some specific URL that is appended to object's absolute url.
        This view will then be called when this URL is used. A small dictionary containing the object,
        it's category, content_type and content_type_name will be passed to the view.

    Example:
        dispatcher.register(urlpatterns, prefix='rate')
        will make the urlpatterns available under /rate/ after any object's URL...
    """
    def __init__(self):
        self._patterns = {}
        self.root_mapping = {}

    def has_custom_detail(self, obj):
        return obj.__class__ in self.root_mapping

    def _get_custom_detail_view(self, model):
        if model not in self.root_mapping:
            raise Http404()
        return self.root_mapping[model]

    def call_custom_detail(self, request, context):
        model = context['object'].__class__
        view = self._get_custom_detail_view(model)
        return view(request, context)

    def register_custom_detail(self, model, view):
        assert model not in self.root_mapping, "You can only register one function for model %r" % model.__name__
        self.root_mapping[model] = view

    def register(self, urlpatterns, prefix=None, model=None):
        key = str(model._meta) if model else ALL
        if prefix:
            urlpatterns = patterns('',
                    url('^%s/' % re.escape(prefix), include((urlpatterns, '', ''))),
                )
        self._patterns.setdefault(key, []).extend(urlpatterns)

    def _get_resolver(self, obj):
        return RegexURLResolver(r'^', self._patterns.get(str(obj._meta), []) + self._patterns.get(ALL, []))

    def resolve(self, obj, url_remainder):
        return self._get_resolver(obj).resolve(url_remainder)

    def reverse(self, obj, view_name, *args, **kwargs):
        return obj.get_absolute_url() + self._get_resolver(obj).reverse(view_name, *args, **kwargs)

    def call_custom_view(self, request, obj, url_remainder, context):
        view, args, kwargs = self.resolve(obj, url_remainder)
        return view(request, context, *args, **kwargs)

resolver = CustomURLResolver()

########NEW FILE########
__FILENAME__ = feeds
from mimetypes import guess_type

from django.contrib.syndication.views import Feed
from django.utils.feedgenerator import Atom1Feed
from django.http import Http404
from django.template import TemplateDoesNotExist, RequestContext, NodeList

from ella.core.models import Listing, Category
from ella.core.conf import core_settings
from ella.core.managers import ListingHandler
from ella.photos.models import Format, FormatedPhoto


class RSSTopCategoryListings(Feed):
    format_name = None

    def __init__(self, *args, **kwargs):
        super(RSSTopCategoryListings, self).__init__(*args, **kwargs)

        if core_settings.RSS_ENCLOSURE_PHOTO_FORMAT:
            self.format_name = core_settings.RSS_ENCLOSURE_PHOTO_FORMAT

        if self.format_name is not None:
            self.format = Format.objects.get_for_name(self.format_name)
        else:
            self.format = None

    def get_object(self, request, category=''):
        bits = category.split('/')
        try:
            cat = Category.objects.get_by_tree_path(u'/'.join(bits))
        except Category.DoesNotExist:
            raise Http404()

        self.box_context = RequestContext(request)

        return cat

    def items(self, obj):
        qset = Listing.objects.get_queryset_wrapper(category=obj, children=ListingHandler.ALL)
        return qset.get_listings(count=core_settings.RSS_NUM_IN_FEED)

    # Feed metadata
    ###########################################################################
    def title(self, obj):
        return obj.app_data.get('syndication', {}).get('title', obj.title)

    def link(self, obj):
        return obj.get_absolute_url()

    def description(self, obj):
        return obj.app_data.get('syndication', {}).get('description', obj.description)

    # Item metadata
    ###########################################################################
    def item_guid(self, item):
        return str(item.publishable.pk)

    def item_pubdate(self, item):
        return item.publish_from

    def item_title(self, item):
        return item.publishable.title

    def item_link(self, item):
        return item.get_absolute_url()

    def item_description(self, item):
        if not core_settings.RSS_DESCRIPTION_BOX_TYPE:
            return item.publishable.description

        p = item.publishable
        box = p.box_class(p, core_settings.RSS_DESCRIPTION_BOX_TYPE, NodeList())
        try:
            desc = box.render(self.box_context)
        except TemplateDoesNotExist:
            desc = None

        if not desc:
            desc = item.publishable.description
        return desc

    def item_author_name(self, item):
        return ', '.join(map(unicode, item.publishable.authors.all()))

    # Enclosure - Photo
    ###########################################################################
    def item_enclosure_url(self, item):
        if not hasattr(item, '__enclosure_url'):
            if hasattr(item.publishable, 'feed_enclosure'):
                item.__enclosure_url = item.publishable.feed_enclosure()['url']
            elif self.format is not None and item.publishable.photo_id:
                item.__enclosure_url = FormatedPhoto.objects.get_photo_in_format(item.publishable.photo_id, self.format)['url']
            else:
                item.__enclosure_url = None

        return item.__enclosure_url

    def item_enclosure_mime_type(self, item):
        enc_url = self.item_enclosure_url(item)
        if enc_url:
            return guess_type(enc_url)[0]

    def item_enclosure_length(self, item):
        # make sure get_photo_in_format was called
        if hasattr(item.publishable, 'feed_enclosure'):
            return item.publishable.feed_enclosure()['size']
        elif self.format:
            fp, created = FormatedPhoto.objects.get_or_create(photo=item.publishable.photo_id, format=self.format)
            return fp.image.size

class AtomTopCategoryListings(RSSTopCategoryListings):
    feed_type = Atom1Feed
    subtitle = RSSTopCategoryListings.description


########NEW FILE########
__FILENAME__ = generate_publish_signals
from django.core.management.base import NoArgsCommand

from ella.core.management import generate_publish_signals

class Command(NoArgsCommand):
    def handle_noargs(self, **options):
        generate_publish_signals()

########NEW FILE########
__FILENAME__ = regenerate_listing_handlers
from django.core.management.base import NoArgsCommand

from ella.core.management import regenerate_listing_handlers

class Command(NoArgsCommand):
    def handle_noargs(self, **options):
        regenerate_listing_handlers()

########NEW FILE########
__FILENAME__ = regenerate_publish_signals
from django.core.management.base import NoArgsCommand

from ella.core.management import regenerate_publish_signals


class Command(NoArgsCommand):
    def handle_noargs(self, **options):
        regenerate_publish_signals()

########NEW FILE########
__FILENAME__ = managers
from operator import attrgetter

from django.db import models
from django.core.exceptions import ImproperlyConfigured
from django.utils.encoding import smart_str
from django.db.models.loading import get_model
from django.conf import settings

from ella.core.cache import cache_this
from ella.core.conf import core_settings
from ella.utils import timezone, import_module_member


class PublishableManager(models.Manager):
    def current(self, now=None):
        now = timezone.now().replace(second=0, microsecond=0)

        return self.filter(
            models.Q(publish_to__isnull=True) | models.Q(publish_to__gt=now),
            published=True, publish_from__lte=now
        )


class CategoryManager(models.Manager):
    _cache = {}
    _hierarchy = {}

    def get_for_id(self, pk):
        try:
            return self.__class__._cache[settings.SITE_ID][pk]
        except KeyError:
            cat = self.get(pk=pk)
            self._add_to_cache(cat)
            return cat

    def get_by_tree_path(self, tree_path):
        try:
            return self.__class__._cache[settings.SITE_ID][tree_path]
        except KeyError:
            cat = self.get(site=settings.SITE_ID, tree_path=tree_path)
            self._add_to_cache(cat)
            return cat

    def _add_to_cache(self, category):
        cache = self.__class__._cache.setdefault(category.site_id, {})
        # pk and tree_path can never clash, safe to store in one dict
        cache[category.pk] = category
        cache[category.tree_path] = category

    def clear_cache(self):
        self.__class__._cache.clear()
        self.__class__._hierarchy.clear()

    def _load_hierarchy(self, site_id):
        cache = self.__class__._cache.setdefault(site_id, {})
        hierarchy = self.__class__._hierarchy.setdefault(site_id, {})
        for c in self.filter(site=site_id).order_by('title'):
            # make sure we are working with the instance already in cache
            c = cache.setdefault(c.id, c)
            hierarchy.setdefault(c.tree_parent_id, []).append(c)

    def _retrieve_children(self, category):
        if not self.__class__._hierarchy:
            self._load_hierarchy(category.site_id)
        return self.__class__._hierarchy[category.site_id].get(category.pk, [])

    def get_children(self, category, recursive=False):
        #make sure this is the instance stored in our cache
        self._add_to_cache(category)
        # copy the returned list. if recursive, we extend it below
        children = self._retrieve_children(category)[:]
        if recursive:
            to_process = children[:]
            while to_process:
                grand_children = self._retrieve_children(to_process.pop())
                children.extend(grand_children)
                to_process.extend(grand_children)
            children = sorted(children, key=attrgetter('tree_path'))
        return children


class RelatedManager(models.Manager):
    def collect_related(self, finder_funcs, obj, count, *args, **kwargs):
        """
        Collects objects related to ``obj`` using a list of ``finder_funcs``.
        Stops when required count is collected or the function list is
        exhausted.
        """
        collected = []
        for func in finder_funcs:
            gathered = func(obj, count, collected, *args, **kwargs)
            if gathered:
                collected += gathered
            if len(collected) >= count:
                return collected[:count]

        return collected

    def _get_finders(self, finder):
        if not hasattr(self, '_finders'):
            self._finders = {}
            for key, finders_modstr in core_settings.RELATED_FINDERS.items():
                # accept non-iterables too (single member named finders)
                if not hasattr(finders_modstr, '__iter__'):
                    finders_modstr = (finders_modstr,)

                # gather all functions before actual use to prevent import errors
                # during the real process
                finder_funcs = []
                for finder_modstr in finders_modstr:
                    finder_funcs.append(import_module_member(finder_modstr, 'related finder'))

                self._finders[key] = finder_funcs

        if finder is None:
            finder = 'default'

        if not finder in self._finders:
            raise ImproperlyConfigured('Named finder %r specified but cannot be '
                'found in RELATED_FINDERS settings.' % finder)
        return self._finders[finder]

    def get_related_for_object(self, obj, count, finder=None, mods=[], only_from_same_site=True):
        """
        Returns at most ``count`` publishable objects related to ``obj`` using
        named related finder ``finder``.

        If only specific type of publishable is prefered, use ``mods`` attribute
        to list required classes.

        Finally, use ``only_from_same_site`` if you don't want cross-site
        content.

        ``finder`` atribute uses ``RELATED_FINDERS`` settings to find out
        what finder function to use. If none is specified, ``default``
        is used to perform the query.
        """
        return self.collect_related(self._get_finders(finder), obj, count, mods, only_from_same_site)


class ListingHandler(object):
    NONE = 0
    IMMEDIATE = 1
    ALL = 2

    @classmethod
    def regenerate(cls, today=None):
        pass

    def __init__(self, category, children=NONE, content_types=[],
                 date_range=(), exclude=None, **kwargs):
        self.category = category
        self.children = children
        self.content_types = content_types
        self.date_range = date_range
        self.exclude = exclude
        self.kwargs = kwargs

    def __getitem__(self, k):
        if isinstance(k, int):
            return self.get_listing(k)

        if not isinstance(k, slice) or k.step:
            raise TypeError, '%s, %s' % (k.start, k.stop)

        offset = k.start or 0

        if offset < 0 or k.stop is None  or k.stop < offset:
            raise TypeError, '%s, %s' % (k.start, k.stop)

        count = k.stop - offset

        return self.get_listings(offset, count)

    def get_listings(self, offset=0, count=10):
        raise NotImplementedError

    def get_listing(self, i):
        return self.get_listings(i, i + 1)[0]

    def count(self):
        raise NotImplementedError

    def __len__(self):
        return self.count()


def get_listings_key(self, category=None, children=ListingHandler.NONE, count=10, offset=0, content_types=[], date_range=(), exclude=None, **kwargs):
    c = category and  category.id or ''

    return 'core.get_listing:%s:%d:%d:%d:%d:%s:%s:%s' % (
            c, count, offset, children, exclude.id if exclude else 0,
            ','.join(map(lambda ct: str(ct.pk), content_types)),
            ','.join(map(lambda d: d.strftime('%Y%m%d'), date_range)),
            ','.join(':'.join((k, smart_str(v))) for k, v in kwargs.items()),
    )


class ListingManager(models.Manager):
    def clean_listings(self):
        """
        Method that cleans the Listing model by deleting all listings that are no longer valid.
        Should be run periodicaly to purge the DB from unneeded data.
        """
        self.filter(publish_to__lt=timezone.now()).delete()

    def get_query_set(self, *args, **kwargs):
        # get all the fields you typically need to render listing
        qset = super(ListingManager, self).get_query_set(*args, **kwargs).select_related(
                'publishable',
                'publishable__category',
            )
        return qset

    def get_listing_queryset(self, category=None, children=ListingHandler.NONE, content_types=[], date_range=(), exclude=None, **kwargs):
        # give the database some chance to cache this query
        now = timezone.now().replace(second=0, microsecond=0)

        if date_range:
            qset = self.filter(publish_from__range=date_range, publishable__published=True, **kwargs)
        else:
            qset = self.filter(publish_from__lte=now, publishable__published=True, **kwargs)

        if category:
            if children == ListingHandler.NONE:
                # only this one category
                qset = qset.filter(category=category)
            elif children == ListingHandler.IMMEDIATE:
                # this category and its children
                qset = qset.filter(models.Q(category__tree_parent=category) | models.Q(category=category))

                for c in category.get_children():
                    if not c.app_data.ella.propagate_listings:
                        qset = qset.exclude(category=c)

            elif children == ListingHandler.ALL:
                # this category and all its descendants
                qset = qset.filter(category__tree_path__startswith=category.tree_path, category__site=category.site_id)

                for c in category.get_children(True):
                    if not c.app_data.ella.propagate_listings:
                        qset = qset.exclude(category__tree_path__startswith=c.tree_path)

            else:
                raise AttributeError('Invalid children value (%s) - should be one of (%s, %s, %s)' % (children, self.NONE, self.IMMEDIATE, self.ALL))

        # filtering based on Model classes
        if content_types:
            qset = qset.filter(publishable__content_type__in=content_types)

        # we were asked to omit certain Publishable
        if exclude:
            qset = qset.exclude(publishable=exclude)

        return qset.exclude(publish_to__lt=now).order_by('-publish_from')

    @cache_this(get_listings_key)
    def get_listing(self, category=None, children=ListingHandler.NONE, count=10, offset=0, content_types=[], date_range=(), exclude=None, **kwargs):
        """
        Get top objects for given category and potentionally also its child categories.

        Params:
            category - Category object to list objects for. None if any category will do
            count - number of objects to output, defaults to 10
            offset - starting with object number... 1-based
            content_types - list of ContentTypes to list, if empty, object from all models are included
            date_range - range for listing's publish_from field
            **kwargs - rest of the parameter are passed to the queryset unchanged
        """
        assert offset >= 0, "Offset must be a positive integer"
        assert count >= 0, "Count must be a positive integer"

        if not count:
            return []

        limit = offset + count

        qset = self.get_listing_queryset(category, children, content_types, date_range, exclude, **kwargs)

        # direct listings, we don't need to check for duplicates
        if children == ListingHandler.NONE:
            return qset[offset:limit]

        seen = set()
        out = []
        while len(out) < count:
            skip = 0
            # 2 i a reasonable value for padding, wouldn't you say dear Watson?
            for l in qset[offset:limit + 2]:
                if l.publishable_id not in seen:
                    seen.add(l.publishable_id)
                    out.append(l)
                    if len(out) == count:
                        break
                else:
                    skip += 1

            # no enough skipped, or not enough listings to work with, no need for another try
            if skip <= 2 or (len(out) + skip) < (count + 2):
                break

            # get another page to fill in the gaps
            offset += count
            limit += count

        return out

    def get_listing_handler(self, source, fallback=True):
        if not hasattr(self, '_listing_handlers'):
            self._listing_handlers = {}
            for k, v in core_settings.LISTING_HANDLERS.items():
                self._listing_handlers[k] = import_module_member(v, 'Listing Handler')

            if 'default' not in self._listing_handlers:
                raise ImproperlyConfigured('You didn\'t specify any default Listing Handler.')

        if source in self._listing_handlers:
            return self._listing_handlers[source]
        elif not fallback:
            return None

        if settings.DEBUG:
            raise ImproperlyConfigured('ListingHandler %s is not defined in settings.' % source)

        return self._listing_handlers['default']

    def get_queryset_wrapper(self, category, children=ListingHandler.NONE,
                             content_types=[], date_range=(), exclude=None,
                             source='default', **kwargs):
        ListingHandler = self.get_listing_handler(source)
        return ListingHandler(
            category, children, content_types, date_range, exclude, **kwargs
        )


class ModelListingHandler(ListingHandler):
    def get_listing(self, i):
        Listing = get_model('core', 'listing')
        return Listing.objects.get_listing_queryset(
                self.category,
                children=self.children,
                content_types=self.content_types,
                date_range=self.date_range,
                exclude=self.exclude
            )[i]

    def get_listings(self, offset=0, count=10):
        Listing = get_model('core', 'listing')
        return Listing.objects.get_listing(
                self.category,
                children=self.children,
                content_types=self.content_types,
                date_range=self.date_range,
                offset=offset,
                count=count,
                exclude=self.exclude
            )

    def count(self):
        if not hasattr(self, '_count'):
            Listing = get_model('core', 'listing')
            self._count = Listing.objects.get_listing_queryset(
                self.category,
                children=self.children,
                content_types=self.content_types,
                date_range=self.date_range,
                exclude=self.exclude
            ).count()
        return self._count


########NEW FILE########
__FILENAME__ = middleware
import time
import re
import logging
log = logging.getLogger('ella.core.middleware')

from django import template
from django.middleware.cache import CacheMiddleware as DjangoCacheMiddleware
from django.core.cache import cache
from django.utils.cache import get_cache_key, add_never_cache_headers, learn_cache_key
from django.conf import settings
from ella.core.conf import core_settings

class DoubleRenderMiddleware(object):

    def _get_excluded_urls(self):
        if hasattr(self, '_excluded_urls'):
            return self._excluded_urls

        if core_settings.DOUBLE_RENDER_EXCLUDE_URLS is None:
            self._excluded_urls = None
            return None

        self._excluded_urls = ()
        for url in core_settings.DOUBLE_RENDER_EXCLUDE_URLS:
            self._excluded_urls += (re.compile(url),)

        return self._excluded_urls

    def process_response(self, request, response):
        if response.status_code != 200 \
            or not response['Content-Type'].startswith('text') \
            or not core_settings.DOUBLE_RENDER:
            return response

        if self._get_excluded_urls() is not None:
            for pattern in self._get_excluded_urls():
                if pattern.match(request.path):
                    return response

        try:
            c = template.RequestContext(request, {'SECOND_RENDER': True})
            t = template.Template(response.content)
            response.content = t.render(c)
            response['Content-Length'] = len(response.content)
        except Exception, e:
            log.warning('Failed to double render on (%s)', unicode(e).encode('utf8'))

        return response

class CacheMiddleware(DjangoCacheMiddleware):
    def process_request(self, request):
        resp = super(CacheMiddleware, self).process_request(request)

        if resp is None:
            request._cache_middleware_key = get_cache_key(request, self.key_prefix)

        return resp

    def process_response(self, request, response):
        resp = super(CacheMiddleware, self).process_response(request, response)

        # never cache headers + ETag
        add_never_cache_headers(resp)

        return resp





class UpdateCacheMiddleware(object):
    """
    Response-phase cache middleware that updates the cache if the response is
    cacheable.

    Must be used as part of the two-part update/fetch cache middleware.
    UpdateCacheMiddleware must be the first piece of middleware in
    MIDDLEWARE_CLASSES so that it'll get called last during the response phase.
    """
    def __init__(self):
        self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS
        self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX
        self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)

    def process_response(self, request, response):
        """Sets the cache, if needed."""

        # never cache headers + ETag
        add_never_cache_headers(response)

        if not hasattr(request, '_cache_update_cache') or not request._cache_update_cache:
            # We don't need to update the cache, just return.
            return response
        if request.method != 'GET':
            # This is a stronger requirement than above. It is needed
            # because of interactions between this middleware and the
            # HTTPMiddleware, which throws the body of a HEAD-request
            # away before this middleware gets a chance to cache it.
            return response
        if not response.status_code == 200:
            return response

        # use the precomputed cache_key
        if request._cache_middleware_key:
            cache_key = request._cache_middleware_key
        else:
            cache_key = learn_cache_key(request, response, self.cache_timeout, self.key_prefix)

        # include the orig_time information within the cache
        cache.set(cache_key, (time.time(), response), self.cache_timeout)
        return response

class FetchFromCacheMiddleware(object):
    """
    Request-phase cache middleware that fetches a page from the cache.

    Must be used as part of the two-part update/fetch cache middleware.
    FetchFromCacheMiddleware must be the last piece of middleware in
    MIDDLEWARE_CLASSES so that it'll get called last during the request phase.
    """
    def __init__(self):
        self.cache_expire_timeout = settings.CACHE_MIDDLEWARE_SECONDS
        self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX
        self.cache_refresh_timeout = getattr(settings, 'CACHE_MIDDLEWARE_REFRESH_SECONDS', self.cache_expire_timeout / 2)
        self.timeout = getattr(settings, 'CACHE_MIDDLEWARE_REFRESH_TIMEOUT', 10)
        self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)

    def process_request(self, request):
        """
        Checks whether the page is already cached and returns the cached
        version if available.
        """
        if self.cache_anonymous_only:
            assert hasattr(request, 'user'), "The Django cache middleware with CACHE_MIDDLEWARE_ANONYMOUS_ONLY=True requires authentication middleware to be installed. Edit your MIDDLEWARE_CLASSES setting to insert 'django.contrib.auth.middleware.AuthenticationMiddleware' before the CacheMiddleware."

        if not request.method in ('GET', 'HEAD') or request.GET:
            request._cache_update_cache = False
            return None # Don't bother checking the cache.

        if self.cache_anonymous_only and request.user.is_authenticated():
            request._cache_update_cache = False
            return None # Don't cache requests from authenticated users.

        cache_key = get_cache_key(request, self.key_prefix)
        request._cache_middleware_key = cache_key

        if cache_key is None:
            request._cache_update_cache = True
            return None # No cache information available, need to rebuild.

        response = cache.get(cache_key, None)
        if response is None:
            request._cache_update_cache = True
            return None # No cache information available, need to rebuild.

        orig_time, response = response
        # time to refresh the cache
        if orig_time and  ((time.time() - orig_time) > self.cache_refresh_timeout):
            request._cache_update_cache = True
            # keep the response in the cache for just self.timeout seconds and mark it for update
            # other requests will continue werving this response from cache while I alone work on refreshing it
            cache.set(cache_key, (None, response), self.timeout)
            return None

        request._cache_update_cache = False
        return response

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Author'
        db.create_table('core_author', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'], null=True, blank=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=200, blank=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=255, db_index=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('text', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, blank=True)),
        ))
        db.send_create_signal('core', ['Author'])

        # Adding model 'Source'
        db.create_table('core_source', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('core', ['Source'])

        # Adding model 'Category'
        db.create_table('core_category', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('tree_parent', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Category'], null=True, blank=True)),
            ('tree_path', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('site', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sites.Site'])),
        ))
        db.send_create_signal('core', ['Category'])

        # Adding unique constraint on 'Category', fields ['site', 'tree_path']
        db.create_unique('core_category', ['site_id', 'tree_path'])

        # Adding model 'Dependency'
        db.create_table('core_dependency', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('target_ct', self.gf('django.db.models.fields.related.ForeignKey')(related_name='dependency_for_set', to=orm['contenttypes.ContentType'])),
            ('target_id', self.gf('django.db.models.fields.IntegerField')()),
            ('dependent_ct', self.gf('django.db.models.fields.related.ForeignKey')(related_name='depends_on_set', to=orm['contenttypes.ContentType'])),
            ('dependent_id', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('core', ['Dependency'])


    def backwards(self, orm):
        # Removing unique constraint on 'Category', fields ['site', 'tree_path']
        db.delete_unique('core_category', ['site_id', 'tree_path'])

        # Deleting model 'Author'
        db.delete_table('core_author')

        # Deleting model 'Source'
        db.delete_table('core_source')

        # Deleting model 'Category'
        db.delete_table('core_category')

        # Deleting model 'Dependency'
        db.delete_table('core_dependency')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'ordering': "('site__name', 'tree_path')", 'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'ordering': "('dependent_ct', 'dependent_id')", 'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0002_initial_publishable
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):
    depends_on = (
        ('photos', '0001_initial'),
    )

    def forwards(self, orm):
        # Adding model 'Publishable'
        db.create_table('core_publishable', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('category', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Category'])),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('source', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Source'], null=True, blank=True)),
            ('photo', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Photo'], null=True, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('publish_from', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(3000, 1, 1, 0, 0, 0, 2), db_index=True)),
        ))
        db.send_create_signal('core', ['Publishable'])

        # Adding M2M table for field authors on 'Publishable'
        db.create_table('core_publishable_authors', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('publishable', models.ForeignKey(orm['core.publishable'], null=False)),
            ('author', models.ForeignKey(orm['core.author'], null=False))
        ))
        db.create_unique('core_publishable_authors', ['publishable_id', 'author_id'])

        # Adding model 'Placement'
        db.create_table('core_placement', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('publishable', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Publishable'])),
            ('category', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Category'])),
            ('publish_from', self.gf('django.db.models.fields.DateTimeField')()),
            ('publish_to', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(db_index=True, max_length=255, blank=True)),
            ('static', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('core', ['Placement'])

        # Adding unique constraint on 'Placement', fields ['publishable', 'category']
        db.create_unique('core_placement', ['publishable_id', 'category_id'])

        # Adding model 'Listing'
        db.create_table('core_listing', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('placement', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Placement'])),
            ('category', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Category'])),
            ('publish_from', self.gf('django.db.models.fields.DateTimeField')(db_index=True)),
            ('publish_to', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('priority_from', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('priority_to', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('priority_value', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('commercial', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('core', ['Listing'])

        # Adding model 'HitCount'
        db.create_table('core_hitcount', (
            ('placement', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Placement'], primary_key=True)),
            ('last_seen', self.gf('django.db.models.fields.DateTimeField')()),
            ('hits', self.gf('django.db.models.fields.PositiveIntegerField')(default=1)),
        ))
        db.send_create_signal('core', ['HitCount'])

        # Adding model 'Related'
        db.create_table('core_related', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('publishable', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Publishable'])),
            ('related_ct', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('related_id', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('core', ['Related'])



    def backwards(self, orm):
        # Removing unique constraint on 'Placement', fields ['publishable', 'category']
        db.delete_unique('core_placement', ['publishable_id', 'category_id'])

        # Deleting model 'Publishable'
        db.delete_table('core_publishable')

        # Removing M2M table for field authors on 'Publishable'
        db.delete_table('core_publishable_authors')

        # Deleting model 'Placement'
        db.delete_table('core_placement')

        # Deleting model 'Listing'
        db.delete_table('core_listing')

        # Deleting model 'HitCount'
        db.delete_table('core_hitcount')

        # Deleting model 'Related'
        db.delete_table('core_related')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'ordering': "('site__name', 'tree_path')", 'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'ordering': "('dependent_ct', 'dependent_id')", 'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.hitcount': {
            'Meta': {'object_name': 'HitCount'},
            'hits': ('django.db.models.fields.PositiveIntegerField', [], {'default': '1'}),
            'last_seen': ('django.db.models.fields.DateTimeField', [], {}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']", 'primary_key': 'True'})
        },
        'core.listing': {
            'Meta': {'ordering': "('-publish_from',)", 'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']"}),
            'priority_from': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'priority_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'priority_value': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'core.placement': {
            'Meta': {'unique_together': "(('publishable', 'category'),)", 'object_name': 'Placement'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']


########NEW FILE########
__FILENAME__ = 0002_remove_shit_add_columns
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration

class Migration(SchemaMigration):
    depends_on = (
        ('core', '0002_initial_publishable'),
    )

    def forwards(self, orm):
        db.delete_column('core_listing', 'priority_from')
        db.delete_column('core_listing', 'priority_to')
        db.delete_column('core_listing', 'priority_value')

        # Adding field 'Publishable.publish_to'
        db.add_column('core_publishable', 'publish_to', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True), keep_default=False)
        # Adding field 'Publishable.static'
        db.add_column('core_publishable', 'static', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)
        # Adding field 'Listing.publishable'
        db.add_column('core_listing', 'publishable', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Publishable'], default=None, null=True), keep_default=False)


    def backwards(self, orm):
        pass


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'ordering': "('site__name', 'tree_path')", 'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'ordering': "('dependent_ct', 'dependent_id')", 'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.hitcount': {
            'Meta': {'object_name': 'HitCount'},
            'hits': ('django.db.models.fields.PositiveIntegerField', [], {'default': '1'}),
            'last_seen': ('django.db.models.fields.DateTimeField', [], {}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']", 'primary_key': 'True'})
        },
        'core.listing': {
            'Meta': {'ordering': "('-publish_from',)", 'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']"}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'core.placement': {
            'Meta': {'unique_together': "(('publishable', 'category'),)", 'object_name': 'Placement'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core', 'core']

########NEW FILE########
__FILENAME__ = 0002_remove_shit_data
# -*- coding: utf-8 -*-
from south.db import db
from south.v2 import DataMigration

class Migration(DataMigration):

    depends_on = (
        ('core', '0002_remove_shit_add_columns'),
    )

    def forwards(self, orm):
        "Write your forwards methods here."
        if not db.dry_run:
            for pl in orm['core.Placement'].objects.all():
                pl.listing_set.update(publishable=pl.publishable)
                publishable = pl.publishable
                publishable.publish_from = pl.publish_from
                publishable.static = pl.static
                publishable.publish_to = pl.publish_to
                publishable.save(force_update=True)

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'ordering': "('site__name', 'tree_path')", 'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'ordering': "('dependent_ct', 'dependent_id')", 'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.hitcount': {
            'Meta': {'object_name': 'HitCount'},
            'hits': ('django.db.models.fields.PositiveIntegerField', [], {'default': '1'}),
            'last_seen': ('django.db.models.fields.DateTimeField', [], {}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']", 'primary_key': 'True'})
        },
        'core.listing': {
            'Meta': {'ordering': "('-publish_from',)", 'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']", 'null': 'True'}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']"}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'core.placement': {
            'Meta': {'unique_together': "(('publishable', 'category'),)", 'object_name': 'Placement'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0002_remove_shit_schema_cleanup
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration

class Migration(SchemaMigration):
    depends_on = (
        ('core', '0002_remove_shit_data'),
    )

    def forwards(self, orm):
        db.alter_column('core_listing', 'publishable_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Publishable'], null=False))

        db.delete_column('core_listing', 'placement_id')
        db.delete_table('core_placement')
        db.delete_table('core_hitcount')


    def backwards(self, orm):
        pass


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'ordering': "('site__name', 'tree_path')", 'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'ordering': "('dependent_ct', 'dependent_id')", 'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.hitcount': {
            'Meta': {'object_name': 'HitCount'},
            'hits': ('django.db.models.fields.PositiveIntegerField', [], {'default': '1'}),
            'last_seen': ('django.db.models.fields.DateTimeField', [], {}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']", 'primary_key': 'True'})
        },
        'core.listing': {
            'Meta': {'ordering': "('-publish_from',)", 'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']", 'null': 'True'}),
            'placement': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Placement']"}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'core.placement': {
            'Meta': {'unique_together': "(('publishable', 'category'),)", 'object_name': 'Placement'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core', 'core']

########NEW FILE########
__FILENAME__ = 0003_add_field_publishable_published
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Publishable.published'
        db.add_column('core_publishable', 'published', self.gf('django.db.models.fields.BooleanField')(default=True), keep_default=False)




    def backwards(self, orm):
        # Deleting field 'Publishable.published'
        db.delete_column('core_publishable', 'published')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0004_add_field_category_app_data_add_field_publishable_app_data
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Category.app_data'
        db.add_column('core_category', 'app_data', self.gf('app_data.fields.AppDataField')(default='{}'), keep_default=True)
        if not db.dry_run:
            orm['core.Category'].objects.filter(app_data='').update(app_data='{}')

        # Adding field 'Publishable.app_data'
        db.add_column('core_publishable', 'app_data', self.gf('app_data.fields.AppDataField')(default='{}'), keep_default=True)
        if not db.dry_run:
            orm['core.Publishable'].objects.filter(app_data='').update(app_data='{}')


    def backwards(self, orm):
        # Deleting field 'Category.app_data'
        db.delete_column('core_category', 'app_data')

        # Deleting field 'Publishable.app_data'
        db.delete_column('core_publishable', 'app_data')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0005_auto__add_field_category_content__add_field_category_template
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Category.content'
        db.add_column('core_category', 'content', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)

        # Adding field 'Category.template'
        db.add_column('core_category', 'template', self.gf('django.db.models.fields.CharField')(default='category.html', max_length=100), keep_default=False)


    def backwards(self, orm):

        # Deleting field 'Category.content'
        db.delete_column('core_category', 'content')

        # Deleting field 'Category.template'
        db.delete_column('core_category', 'template')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0006_add_publishable_announced
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration

class Migration(SchemaMigration):

    def forwards(self, orm):
        db.add_column('core_publishable', 'announced', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        db.delete_column('core_publishable', 'announced')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('ella.core.cache.fields.CachedForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0007_auto__chg_field_category_site__chg_field_related_related_ct__chg_field
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Changing field 'Publishable.category'
        db.alter_column('core_publishable', 'category_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Category']))

        # Changing field 'Publishable.photo'
        db.alter_column('core_publishable', 'photo_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Photo'], null=True))


    def backwards(self, orm):
        # Changing field 'Publishable.category'
        db.alter_column('core_publishable', 'category_id', self.gf('ella.core.cache.fields.CachedForeignKey')(to=orm['core.Category']))

        # Changing field 'Publishable.photo'
        db.alter_column('core_publishable', 'photo_id', self.gf('ella.core.cache.fields.CachedForeignKey')(to=orm['photos.Photo'], null=True))


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 41, 29, 718089)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 41, 29, 718004)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0008_add_last_updated
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Publishable.last_updated'
        db.add_column('core_publishable', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True), keep_default=False)
        db.execute('UPDATE core_publishable SET last_updated = publish_from')


    def backwards(self, orm):
        # Deleting field 'Publishable.last_updated'
        db.delete_column('core_publishable', 'last_updated')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 43, 48, 731836)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 12, 43, 48, 731751)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0009_auto__chg_field_publishable_last_updated
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Changing field 'Publishable.last_updated'
        db.alter_column('core_publishable', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2012, 4, 18, 13, 34, 49, 495278)))


    def backwards(self, orm):
        # Changing field 'Publishable.last_updated'
        db.alter_column('core_publishable', 'last_updated', self.gf('django.db.models.fields.DateTimeField')(null=True))


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 13, 34, 49, 499815)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 4, 18, 13, 34, 49, 499730)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = 0010_add_field_author_photo
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Author.photo'
        db.add_column('core_author', 'photo',
                      self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Photo'], null=True, on_delete=models.SET_NULL, blank=True),
                      keep_default=False)


    def backwards(self, orm):

        # Deleting field 'Author.photo'
        db.delete_column('core_author', 'photo_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'on_delete': 'models.SET_NULL', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.category': {
            'Meta': {'unique_together': "(('site', 'tree_path'),)", 'object_name': 'Category'},
            'app_data': ('app_data.AppDataField', [], {'default': "'{}'"}),
            'content': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'}),
            'template': ('django.db.models.fields.CharField', [], {'default': "'category.html'", 'max_length': '100'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'tree_parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']", 'null': 'True', 'blank': 'True'}),
            'tree_path': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.dependency': {
            'Meta': {'object_name': 'Dependency'},
            'dependent_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'depends_on_set'", 'to': "orm['contenttypes.ContentType']"}),
            'dependent_id': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'target_ct': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'dependency_for_set'", 'to': "orm['contenttypes.ContentType']"}),
            'target_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.listing': {
            'Meta': {'object_name': 'Listing'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'commercial': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"})
        },
        'core.publishable': {
            'Meta': {'object_name': 'Publishable'},
            'announced': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'app_data': ('app_data.AppDataField', [], {'default': "'{}'"}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['core.Author']", 'symmetrical': 'False'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Category']"}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'blank': 'True'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']", 'null': 'True', 'on_delete': 'models.SET_NULL', 'blank': 'True'}),
            'publish_from': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(3000, 1, 1, 0, 0, 0, 2)', 'db_index': 'True'}),
            'publish_to': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'static': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'core.related': {
            'Meta': {'object_name': 'Related'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'publishable': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Publishable']"}),
            'related_ct': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'related_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.AppDataField', [], {'default': "'{}'"}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['core']

########NEW FILE########
__FILENAME__ = main
import re

from django.conf import settings
from django.core.urlresolvers import reverse
from django.core.validators import validate_slug, RegexValidator
from django.db import models
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from app_data import AppDataField

from ella.core.cache import CachedGenericForeignKey, SiteForeignKey, ContentTypeForeignKey, CategoryForeignKey, CachedForeignKey, redis
from ella.core.conf import core_settings
from ella.core.managers import CategoryManager, ListingHandler

if hasattr(settings, 'AUTH_USER_MODEL'):
    User = settings.AUTH_USER_MODEL
else:
    from django.contrib.auth.models import User


class Author(models.Model):
    """
    Describes an Author of the published content. Author can be:

    * Human
    * Organization
    * ...

    All the fields except for ``slug`` are optional to enable maximum of
    flexibility.
    """
    user = CachedForeignKey(User, verbose_name=_('User'), blank=True, null=True)
    name = models.CharField(_('Name'), max_length=200, blank=True)
    slug = models.SlugField(_('Slug'), max_length=255, unique=True, validators=[validate_slug])
    description = models.TextField(_('Description'), blank=True)
    text = models.TextField(_('Text'), blank=True)
    email = models.EmailField(_('Email'), blank=True)
    photo = CachedForeignKey('photos.Photo', blank=True, null=True,
                             on_delete=models.SET_NULL, verbose_name=_('Photo'))

    class Meta:
        app_label = 'core'
        verbose_name = _('Author')
        verbose_name_plural = _('Authors')

    def __unicode__(self):
        if not self.name:
            return self.slug
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('author_detail', [self.slug])

    def recently_published(self, **kwargs):
        if core_settings.USE_REDIS_FOR_LISTINGS:
            return redis.AuthorListingHandler(self)

        root = Category.objects.get_by_tree_path('')
        return root.app_data.ella.get_listings(children=ListingHandler.ALL, author=self, **kwargs)


class Source(models.Model):
    """
    A ``Source`` in oposition to ``Author`` is used for publishable content
    that was taken from other sites and it's purpose is mainly for legal matters.
    """
    name = models.CharField(_('Name'), max_length=200)
    url = models.URLField(_('URL'), blank=True)
    description = models.TextField(_('Description'), blank=True)

    class Meta:
        app_label = 'core'
        verbose_name = _('Source')
        verbose_name_plural = _('Sources')

    def __unicode__(self):
        return self.name

category_slug_validator = RegexValidator(re.compile('^(?:[0-9]+[^0-9-]|[a-z])[a-z0-9-]*$'), _('Please enter a valid slug composed of lowecase letter, numbers and hyphens. First character must be a letter.'), 'invalid')


class Category(models.Model):
    """
    ``Category`` is the **basic building block of Ella-based sites**. All the
    published content is divided into categories - every ``Publishable`` object
    has a ``ForeignKey`` to it's primary ``Category``. Primary category is then
    used to build up object's URL when using `Category.get_absolute_url` method.
    Besides that, objects can be published in other categories (aka "secondary"
    categories) via ``Listing``.

    Every site has exactly one root category (without a parent) that serve's as
    the sites's homepage.
    """
    template_choices = tuple((x, _(y)) for x, y in core_settings.CATEGORY_TEMPLATES)

    title = models.CharField(_("Title"), max_length=200)
    description = models.TextField(_("Description"), blank=True, help_text=_(
        'Description which can be used in link titles, syndication etc.'))
    content = models.TextField(_('Content'), default='', blank=True, help_text=_(
        'Optional content to use when rendering this category.'))
    template = models.CharField(_('Template'), max_length=100, help_text=_(
        'Template to use to render detail page of this category.'),
        choices=template_choices, default=template_choices[0][0])
    slug = models.SlugField(_('Slug'), max_length=255, validators=[category_slug_validator])
    tree_parent = CategoryForeignKey(null=True, blank=True,
        verbose_name=_("Parent category"))
    tree_path = models.CharField(verbose_name=_("Path from root category"),
        max_length=255, editable=False)
    site = SiteForeignKey()

    # generic JSON field to store app cpecific data
    app_data = AppDataField(_('Custom meta data'),
        help_text=_('If you need to define custom data for '
        'category objects, you can use this field to do so.'))

    objects = CategoryManager()

    class Meta:
        app_label = 'core'
        unique_together = (('site', 'tree_path'),)
        verbose_name = _('Category')
        verbose_name_plural = _('Categories')

    def __unicode__(self):
        return '%s/%s' % (self.site.name, self.tree_path)

    def save(self, **kwargs):
        "Override save() to construct tree_path based on the category's parent."
        old_tree_path = self.tree_path
        if self.tree_parent:
            if self.tree_parent.tree_path:
                self.tree_path = '%s/%s' % (self.tree_parent.tree_path, self.slug)
            else:
                self.tree_path = self.slug
        else:
            self.tree_path = ''
        Category.objects.clear_cache()
        super(Category, self).save(**kwargs)
        if old_tree_path != self.tree_path:
            # the tree_path has changed, update children
            children = Category.objects.filter(tree_parent=self)
            for child in children:
                child.save(force_update=True)

    def get_root_category(self):
        if '/' not in self.tree_path:
            return self
        path = self.tree_path.split('/')[0]
        return Category.objects.get_by_tree_path(path)

    def get_children(self, recursive=False):
        return Category.objects.get_children(self, recursive)

    @property
    def path(self):
        """
        Returns tree path of the category. Tree path is string that describes
        the whole path from the category root to the position of this category.

        @see: Category.tree_path
        """
        if self.tree_parent_id:
            return self.tree_path
        else:
            return self.slug

    def get_absolute_url(self):
        """
        Returns absolute URL for the category.
        """
        if not self.tree_parent_id:
            url = reverse('root_homepage')
        else:
            url = reverse('category_detail', kwargs={'category' : self.tree_path})
        if self.site_id != settings.SITE_ID:
            # prepend the domain if it doesn't match current Site
            return 'http://' + self.site.domain + url
        return url

    def draw_title(self):
        """
        Returns title indented by *&nbsp;* elements that can be used to show
        users a category tree.

        Examples:

        **Category with no direct parent (the category root)**
            TITLE

        **Category with one parent**
            &nsbp;TITLE

        **Category on third level of the tree**
            &nbsp;&nbsp;TITLE
        """
        return mark_safe(('&nbsp;&nbsp;' * self.tree_path.count('/')) + self.title)
    draw_title.allow_tags = True


class Dependency(models.Model):
    """
    Captures relations between objects to simplify finding out what other objects
    my object depend on.

    This sounds mysterious, but the common use case is quite simple: keeping
    information which objects have been embedded in article content using
    **boxes** for example (these might be photos, galleries, ...).
    """
    target_ct = ContentTypeForeignKey(related_name='dependency_for_set')
    target_id = models.IntegerField()
    target = CachedGenericForeignKey('target_ct', 'target_id')

    dependent_ct = ContentTypeForeignKey(related_name='depends_on_set')
    dependent_id = models.IntegerField()
    dependent = CachedGenericForeignKey('dependent_ct', 'dependent_id')

    class Meta:
        app_label = 'core'
        verbose_name = _('Dependency')
        verbose_name_plural = _('Dependencies')

    def __unicode__(self):
        return _(u'%(obj)s depends on %(dep)s') % {'obj': self.dependent, 'dep': self.target}


########NEW FILE########
__FILENAME__ = publishable
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _, ugettext
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse
from django.contrib.redirects.models import Redirect
from django.core.validators import validate_slug
from django.core.exceptions import ValidationError

from app_data import AppDataField

from ella.core.box import Box
from ella.core.cache import CachedGenericForeignKey, \
    CachedForeignKey, ContentTypeForeignKey, CategoryForeignKey
from ella.core.conf import core_settings
from ella.core.managers import ListingManager, RelatedManager, \
    PublishableManager
from ella.core.models.main import Author, Source
from ella.core.signals import content_published, content_unpublished
from ella.utils.timezone import now, localize


def PublishableBox(publishable, box_type, nodelist, model=None):
    "add some content type info of self.target"
    if not model:
        model = publishable.content_type.model_class()
    box_class = model.box_class

    if box_class == PublishableBox:
        box_class = Box
    return box_class(publishable, box_type, nodelist, model=model)


class Publishable(models.Model):
    """
    Base class for all objects that can be published in Ella.
    """
    box_class = staticmethod(PublishableBox)

    content_type = ContentTypeForeignKey(editable=False)
    target = CachedGenericForeignKey('content_type', 'id')

    category = CategoryForeignKey(verbose_name=_('Category'))

    # Titles
    title = models.CharField(_('Title'), max_length=255)
    slug = models.SlugField(_('Slug'), max_length=255, validators=[validate_slug])

    # Authors and Sources
    authors = models.ManyToManyField(Author, verbose_name=_('Authors'))
    source = CachedForeignKey(Source, blank=True, null=True,
        verbose_name=_('Source'), on_delete=models.SET_NULL)

    # Main Photo
    photo = CachedForeignKey('photos.Photo', blank=True, null=True, on_delete=models.SET_NULL,
        verbose_name=_('Photo'))

    # Description
    description = models.TextField(_('Description'), blank=True)

    # Publish data
    published = models.BooleanField(_('Published'))
    publish_from = models.DateTimeField(_('Publish from'),
        default=core_settings.PUBLISH_FROM_WHEN_EMPTY, db_index=True)
    publish_to = models.DateTimeField(_("End of visibility"), null=True, blank=True)
    static = models.BooleanField(_('static'), default=False)

    # Last updated
    last_updated = models.DateTimeField(_('Last updated'), blank=True)

    # generic JSON field to store app cpecific data
    app_data = AppDataField(default='{}', editable=False)

    # has the content_published signal been sent for this instance?
    announced = models.BooleanField(help_text='Publish signal sent', default=False, editable=False)

    objects = PublishableManager()

    class Meta:
        app_label = 'core'
        verbose_name = _('Publishable object')
        verbose_name_plural = _('Publishable objects')

    def __unicode__(self):
        return self.title

    def __eq__(self, other):
        return isinstance(other, Publishable) and self.pk == other.pk

    def get_absolute_url(self, domain=False):
        " Get object's URL. "
        category = self.category

        kwargs = {
            'slug': self.slug,
        }

        if self.static:
            kwargs['id'] = self.pk
            if category.tree_parent_id:
                kwargs['category'] = category.tree_path
                url = reverse('static_detail', kwargs=kwargs)
            else:
                url = reverse('home_static_detail', kwargs=kwargs)
        else:
            publish_from = localize(self.publish_from)
            kwargs.update({
                    'year': publish_from.year,
                    'month': publish_from.month,
                    'day': publish_from.day,
                })
            if category.tree_parent_id:
                kwargs['category'] = category.tree_path
                url = reverse('object_detail', kwargs=kwargs)
            else:
                url = reverse('home_object_detail', kwargs=kwargs)

        if category.site_id != settings.SITE_ID or domain:
            return 'http://' + category.site.domain + url
        return url

    def get_domain_url(self):
        return self.get_absolute_url(domain=True)

    def clean(self):
        if self.static or not self.published:
            return

        # fields are missing, validating uniqueness is pointless
        if not self.category_id or not self.publish_from or not self.slug:
            return

        qset = self.__class__.objects.filter(
                category=self.category,
                published=True,
                publish_from__day=self.publish_from.day,
                publish_from__month=self.publish_from.month,
                publish_from__year=self.publish_from.year,
                slug=self.slug
            )

        if self.pk:
            qset = qset.exclude(pk=self.pk)

        if qset:
            raise ValidationError(_('Another %s already published at this URL.') % self._meta.verbose_name)

    def save(self, **kwargs):
        # update the content_type if it isn't already set
        if not self.content_type_id:
            self.content_type = ContentType.objects.get_for_model(self)
        send_signal = None
        old_self = None
        if self.pk:
            try:
                old_self = self.__class__.objects.get(pk=self.pk)
            except Publishable.DoesNotExist:
                pass

        if old_self:
            old_path = old_self.get_absolute_url()
            new_path = self.get_absolute_url()

            # detect change in URL and not a static one
            if old_path != new_path and new_path and not old_self.static:
                # and create a redirect
                redirect = Redirect.objects.get_or_create(old_path=old_path,
                    site=self.category.site)[0]
                redirect.new_path = new_path
                redirect.save(force_update=True)
                # also update all potentially already existing redirects
                Redirect.objects.filter(new_path=old_path).exclude(
                    pk=redirect.pk).update(new_path=new_path)

            # detect change in publication status
            if old_self.is_published() != self.is_published():
                if self.is_published():
                    send_signal = content_published
                    self.announced = True
                else:
                    send_signal = content_unpublished
                    self.announced = False

            # @note: We also need to check for `published` flag even if both
            # old and new self `is_published()` method returns false.
            # This method can report false since we might be in time *before*
            # publication should take place but we still need to fire signal
            # that content has been unpublished.
            if old_self.published != self.published and self.published is False:
                send_signal= content_unpublished
                self.announced = False

            # changed publish_from and last_updated was default, change it too
            if old_self.last_updated == old_self.publish_from and self.last_updated == old_self.last_updated:
                self.last_updated = self.publish_from

            #TODO: shift Listing in case publish_(to|from) changes
        # published, send the proper signal
        elif self.is_published():
            send_signal = content_published
            self.announced = True

        if not self.last_updated:
            self.last_updated = self.publish_from

        super(Publishable, self).save(**kwargs)

        if send_signal:
            send_signal.send(sender=self.__class__, publishable=self)

    def delete(self):
        url = self.get_absolute_url()
        Redirect.objects.filter(new_path=url).delete()
        if self.announced:
            content_unpublished.send(sender=self.__class__, publishable=self)
        return super(Publishable, self).delete()

    def is_published(self):
        "Return True if the Publishable is currently active."
        cur_time = now()
        return self.published and cur_time > self.publish_from and \
            (self.publish_to is None or cur_time < self.publish_to)


def ListingBox(listing, *args, **kwargs):
    " Delegate the boxing to the target's Box class. "
    obj = listing.publishable
    return obj.box_class(obj, *args, **kwargs)


class Listing(models.Model):
    """
    Listing of an ``Publishable`` in a ``Category``. Each and every object that have it's
    own detail page must have a ``Listing`` object that is valid (not expired) and
    places it in the object's main category. Any object can be listed in any
    number of categories (but only once per category). Even if the object is
    listed in other categories besides its main category, its detail page's url
    still belongs to the main one.
    """
    box_class = staticmethod(ListingBox)

    publishable = CachedForeignKey(Publishable, verbose_name=_('Publishable'))
    category = CategoryForeignKey(verbose_name=_('Category'), db_index=True)

    publish_from = models.DateTimeField(_("Start of listing"), db_index=True)
    publish_to = models.DateTimeField(_("End of listing"), null=True, blank=True)

    commercial = models.BooleanField(_("Commercial"), default=False,
        help_text=_("Check this if the listing is of a commercial content."))

    objects = ListingManager()

    class Meta:
        app_label = 'core'
        verbose_name = _('Listing')
        verbose_name_plural = _('Listings')

    def __unicode__(self):
        try:
            return ugettext(u'%(pub)s listed in %(cat)s') % {'pub': self.publishable, 'cat': self.category}
        except:
            return ugettext('Broken listing')

    def clean(self):
        if not self.publishable:
            return

        if self.publish_from and self.publish_from < self.publishable.publish_from:
            raise ValidationError(_('A publishable cannot be listed before it\'s published.'))

        if self.publishable.publish_to:
            if not self.publish_to or self.publish_to > self.publishable.publish_to:
                raise ValidationError(_('A publishable cannot be listed longer than it\'s published.'))

    def get_absolute_url(self, domain=False):
        return self.publishable.get_absolute_url(domain)

    def get_domain_url(self):
        return self.get_absolute_url(domain=True)


class Related(models.Model):
    """
    Related objects - model for recording related ``Publishable`` objects.
    An example would be two articles sharing a similar topic. When something
    like this happens, a ``Related`` instance connecting the objects should
    be created.
    """
    publishable = models.ForeignKey(Publishable, verbose_name=_('Publishable'))

    related_ct = ContentTypeForeignKey(verbose_name=_('Content type'))
    related_id = models.IntegerField(_('Object ID'))
    related = CachedGenericForeignKey('related_ct', 'related_id')

    objects = RelatedManager()

    class Meta:
        app_label = 'core'
        verbose_name = _('Related')
        verbose_name_plural = _('Related')

    def __unicode__(self):
        return _(u'%(pub)s relates to %(rel)s') % {'pub': self.publishable, 'rel': self.related}



########NEW FILE########
__FILENAME__ = newman_admin
from django.core.urlresolvers import reverse
import time

from django.utils.translation import ugettext_lazy as _, ugettext
from django.forms import models as modelforms
from django.forms.util import ValidationError
from django.utils.safestring import mark_safe
from django.template.defaultfilters import date
from django.conf import settings

from ella.core.models import Author, Source, Category, Listing, Related, Publishable
from ella.utils.timezone import now

import ella_newman as newman
from ella_newman import options
from ella_newman.filterspecs import CustomFilterSpec, NewmanSiteFilter

class ListingForm(modelforms.ModelForm):
    def clean(self):
        d = super(ListingForm, self).clean()
        if not self.is_valid():
            return d
        if d['publish_to'] and d['publish_from'] > d['publish_to']:
            raise ValidationError(_('Publish to must be later than publish from.'))
        return d

    class Meta:
        model = Listing


class ListingInlineAdmin(newman.NewmanTabularInline):
    model = Listing
    extra = 2
    suggest_fields = {'category': ('__unicode__', 'title', 'slug',)}
    form = ListingForm
    fieldsets = ((None, {'fields' : ('category','publish_from', 'publish_to', 'commercial',)}),)
    template = 'newman/edit_inline/listing.html'



class ListingAdmin(newman.NewmanModelAdmin):
    form = ListingForm

class CategoryAdmin(newman.NewmanModelAdmin):
    list_display = ('__unicode__', 'title', 'tree_path')
    list_filter = ('site',)
    search_fields = ('title', 'slug',)
    prepopulated_fields = {'slug': ('title',)}
    ordering = ('site', 'tree_path',)
    suggest_fields = {'tree_parent': ('__unicode__', 'title', 'slug')}

class AuthorAdmin(newman.NewmanModelAdmin):
    list_display = ('name', 'user', 'email',)
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name', 'email',)

class SourceAdmin(newman.NewmanModelAdmin):
    list_display = ('name', 'url',)
    search_fields = ('name',)

class RelatedInlineAdmin(newman.NewmanTabularInline):
    extra = 3
    model = Related

class IsPublishedFilter(CustomFilterSpec):
    " Published/Nonpublished objects filter"
    lookup_var = 'publish_from'
    CAPTION_YES = _('Yes')
    CAPTION_NO = _('No')

    def title(self):
        return _('Is published?')

    def get_lookup_kwarg(self):
        for param in self.request_get:
            if param.startswith('%s__gt' % self.lookup_var) or param.startswith('%s__lt' % self.lookup_var):
                self.selected_lookup = param
                return param
        return ''

    def filter_func(self):
        # nepublikovany = nemaji placement (datum 3000) ci maji placement v budoucnu
        # ?publish_from__exact=2008-10-10
        lookup_var_not_published = '%s__gt' % self.lookup_var
        lookup_var_published = '%s__lte' % self.lookup_var
        lookup_var_has_placement = '%s__lt' % self.lookup_var
        now = time.strftime('%Y-%m-%d')
        link = ( self.CAPTION_NO, {lookup_var_not_published: now})
        self.links.append(link)
        link = ( self.CAPTION_YES, {lookup_var_published: now})
        self.links.append(link)
        self.remove_from_querystring = [lookup_var_published, lookup_var_not_published, lookup_var_has_placement]
        return True

    def generate_choice(self, **lookup_kwargs):
        param = self.get_lookup_kwarg()
        if not param:
            return None
        elif param.startswith('%s__gt' % self.lookup_var):
            return self.CAPTION_NO
        elif param.startswith('%s__lte' % self.lookup_var):
            return self.CAPTION_YES
        return None

class PublishFromFilter(CustomFilterSpec):
    " Publish from customized filter. "
    published_from_field_path = 'publish_from'

    def title(self):
        return _('Publish from')

    def get_lookup_kwarg(self):
        out = [
            '%s__day' % self.published_from_field_path,
            '%s__month' % self.published_from_field_path,
            '%s__year' % self.published_from_field_path,
        ]
        return out

    def filter_func(self):
        # SELECT created FROM qs._meta.dbtable  GROUP BY created
        #qs = fspec.model_admin.queryset(fspec.request)
        #dates =  qs.dates(fspec.field_path, 'day', 'DESC')[:365]
        # Article.objects.filter(placement__listing__publish_from__gte='2012-01-01')
        YEAR = 365*24*60*60
        ts = time.time() - YEAR
        last_year = time.strftime('%Y-%m-%d %H:%M', time.localtime(ts))
        qs = Listing.objects.filter(publish_from__gte=last_year)
        dates = qs.dates('publish_from', 'day', 'DESC')
        for date in dates:
            lookup_dict = dict()
            lookup_dict['%s__day' % self.published_from_field_path] = date.day
            lookup_dict['%s__month' % self.published_from_field_path] = date.month
            lookup_dict['%s__year' % self.published_from_field_path] = date.year
            link_text = '%d. %d. %d' % (date.day, date.month, date.year)
            link = ( link_text, lookup_dict)
            self.links.append(link)
        return True

    def generate_choice(self, **lookup_kwargs):
        args = self.get_lookup_kwarg()
        day = lookup_kwargs[args[0]]
        month = lookup_kwargs[args[1]]
        year = lookup_kwargs[args[2]]
        return u'%s. %s. %s' % (day, month, year)

class PublishableAdmin(newman.NewmanModelAdmin):
    """ Default admin options for all publishables """

    list_display = ('admin_link', 'category', 'photo_thumbnail', 'publish_from_nice', 'site_icon', 'fe_link',)
    list_filter = ('category', 'content_type')
    unbound_list_filter = (NewmanSiteFilter, PublishFromFilter, IsPublishedFilter,)
    search_fields = ('title', 'description', 'slug', 'authors__name', 'authors__slug',) # FIXME: 'tags__tag__name',)
    raw_id_fields = ('photo',)
    prepopulated_fields = {'slug' : ('title',)}
    rich_text_fields = {'small': ('description',)}
    ordering = ('-publish_from',)

    suggest_fields = {
        'category': ('__unicode__', 'title', 'slug', 'tree_path'),
        'authors': ('name', 'slug', 'email',),
        'source': ('name', 'url',),
    }

    inlines = [ListingInlineAdmin]

    def admin_link(self, object):
        ct = object.content_type
        return mark_safe('<a class="js-hashadr cl-publishable-link %s" href="/%s/%s/%s/">%s</a>' % (ct.model, ct.app_label, ct.model, object.pk, object))
    admin_link.allow_tags = True
    admin_link.short_description = _('Publishable object')

    def site_icon(self, object):
        return mark_safe('%s' % object.category.site.name)
    site_icon.short_description = _('site')
    site_icon.allow_tags = True

    def fe_link(self, obj):
        if obj.publish_from.year < 3000:
            kwargs = {'content_type_id': obj.content_type.id, 'object_id': obj.pk}
            return mark_safe(
                '<a href="%s" class="icn web js-nohashadr">www</a>' %
                reverse('newman:obj-redirect', kwargs=kwargs)
            )
        else:
            return '---'
    fe_link.short_description = _('WWW')
    fe_link.allow_tags = True

    def publish_from_nice(self, obj):
        span_str = '<span class="%s">%s</span>'
        date_str = date(obj.publish_from, settings.DATETIME_FORMAT)

        if obj.publish_from.year >= 3000:
            return mark_safe(span_str % ('unpublished', ugettext('No placement')))
        elif not obj.is_published():
            return span_str % ('unpublished', date_str)
        return span_str % ('published', date_str)
    publish_from_nice.short_description = _('Publish from')
    publish_from_nice.admin_order_field = 'publish_from'
    publish_from_nice.allow_tags = True

    def photo_thumbnail(self, object):
        if object.photo:
            return mark_safe(options.thumb_html(object.photo))
        else:
            return mark_safe('<span class="form-error-msg">%s</span>' % ugettext('No main photo!'))
    photo_thumbnail.allow_tags = True
    photo_thumbnail.short_description = _('Photo')

newman.site.register(Category, CategoryAdmin)
newman.site.register(Source, SourceAdmin)
newman.site.register(Author, AuthorAdmin)
#newman.site.register(Listing, ListingAdmin)
newman.site.register(Publishable, PublishableAdmin)



########NEW FILE########
__FILENAME__ = register
from django import forms
from django import template
from django.http import Http404
from django.utils.translation import ugettext_lazy as _

from app_data import app_registry, AppDataForm, AppDataContainer

from ella.core.models import Category, Listing
from ella.core.managers import ListingHandler
from ella.core.conf import core_settings
from ella.core.cache.redis import connect_signals
from ella.core.cache.utils import connect_invalidation_signals
from ella.utils.pagination import FirstPagePaginator


LISTING_CHOICES = (
    (ListingHandler.NONE, 'No Children'),
    (ListingHandler.IMMEDIATE, 'Immediate Children'),
    (ListingHandler.ALL, 'All Children'),
)


class CategoryAppForm(AppDataForm):
    archive_template = forms.CharField(initial=core_settings.ARCHIVE_TEMPLATE, required=False)
    no_home_listings = forms.BooleanField(initial=core_settings.CATEGORY_NO_HOME_LISTINGS, required=False)
    listing_handler = forms.CharField(initial='default', required=False)
    paginate_by = forms.IntegerField(label=_('Paginate by'),
        initial=core_settings.CATEGORY_LISTINGS_PAGINATE_BY, required=False,
        help_text=_('How many records to show on one listing page.'))
    first_page_count = forms.IntegerField(label=_('First page count'),
        initial=core_settings.CATEGORY_LISTINGS_ON_FIRST_PAGE, required=False,
        help_text=_('How many records to show on the first page only.'))
    propagate_listings = forms.BooleanField(label=_('Propagate listings'),
        initial=True, required=False, help_text=_('Should propagate listings '
        'from child categories?'))
    child_listings = forms.TypedChoiceField(choices=LISTING_CHOICES, coerce=int,
                                            required=False, initial=None,
                                            empty_value=None)


class EllaAppDataContainer(AppDataContainer):
    form_class = CategoryAppForm

    def get_listings(self, **kwargs):
        return Listing.objects.get_queryset_wrapper(self._instance, **kwargs)

    def get_listings_page(self, page_no, paginate_by=None, first_page_count=None, **kwargs):
        paginate_by = paginate_by or self.paginate_by
        first_page_count = first_page_count or self.first_page_count
        paginator = FirstPagePaginator(self.get_listings(**kwargs),
                                       paginate_by,
                                       first_page_count=first_page_count)

        if page_no > paginator.num_pages or page_no < 1:
            raise Http404(_('Invalid page number %r') % page_no)

        return paginator.page(page_no)

    @property
    def child_behavior(self):
        if self.child_listings is None:
            return ListingHandler.ALL if self._instance.tree_parent_id else ListingHandler.NONE
        return self.child_listings

app_registry.register('ella', EllaAppDataContainer, Category)


# connect redis listing handler signals
connect_signals()

# connect cache invalidation signals
connect_invalidation_signals()

# add core templatetags to builtin so that you don't have to invoke {% load core %} in every template
template.add_to_builtins('ella.core.templatetags.core')
# keep this here for backwards compatibility
template.add_to_builtins('ella.core.templatetags.related')
# and custom urls
template.add_to_builtins('ella.core.templatetags.custom_urls_tags')
# and the same for i18n
template.add_to_builtins('django.templatetags.i18n')
# and photos are always useful
template.add_to_builtins('ella.photos.templatetags.photos')

########NEW FILE########
__FILENAME__ = related_finders
from django.contrib.contenttypes.models import ContentType
from ella.core.cache.utils import get_cached_objects, SKIP

from ella.core.models import Related


def related_by_category(obj, count, collected_so_far, mods=[], only_from_same_site=True):
    """
    Returns other Publishable objects related to ``obj`` by using the same
    category principle. Returns up to ``count`` objects.
    """
    related = []
    # top objects in given category
    if count > 0:
        from ella.core.models import Listing
        cat = obj.category
        listings = Listing.objects.get_queryset_wrapper(
            category=cat,
            content_types=[ContentType.objects.get_for_model(m) for m in mods]
        )
        for l in listings[0:count + len(related)]:
            t = l.publishable
            if t != obj and t not in collected_so_far and t not in related:
                related.append(t)
                count -= 1

            if count <= 0:
                return related
    return related


def directly_related(obj, count, collected_so_far, mods=[], only_from_same_site=True):
    """
    Returns objects related to ``obj`` up to ``count`` by searching
    ``Related`` instances for the ``obj``.
    """
    # manually entered dependencies
    qset = Related.objects.filter(publishable=obj)

    if mods:
        qset = qset.filter(related_ct__in=[
            ContentType.objects.get_for_model(m).pk for m in mods])

    return get_cached_objects(qset.values_list('related_ct', 'related_id')[:count], missing=SKIP)




########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal

# Signal fired when a Publishable becomes live
content_published = Signal(providing_args=['publishable'])

# and when it's taken down
content_unpublished = Signal(providing_args=['publishable'])

# category or publishable is about to be rendered
object_rendering = Signal(providing_args=['request', 'category', 'publishable'])

# category or publishable was rendered
object_rendered = Signal(providing_args=['request', 'category', 'publishable'])

########NEW FILE########
__FILENAME__ = tasks
"""
If celery is installed, register our maintenance commands as periodic tasks to
avoid the requirement for external crond.
"""

try:
    from datetime import timedelta

    from celery.task import periodic_task

    from ella.core.management import generate_publish_signals, regenerate_listing_handlers

    periodic_task(run_every=timedelta(minutes=5))(generate_publish_signals)
    periodic_task(run_every=timedelta(hours=3))(regenerate_listing_handlers)
except ImportError:
    # celery not installed
    pass


########NEW FILE########
__FILENAME__ = authors
from django import template

register = template.Library()


class AuthorListingNode(template.Node):
    def __init__(self, obj_var, count, var_name, omit_var=None):
        self.obj_var = obj_var
        self.count = int(count)
        self.var_name = var_name
        self.omit_var = omit_var

    def render(self, context):
        try:
            author = template.Variable(self.obj_var).resolve(context)
        except template.VariableDoesNotExist:
            return ''

        if not author:
            return ''

        if self.omit_var is not None:
            try:
                omit = template.Variable(self.omit_var).resolve(context)
            except template.VariableDoesNotExist:
                return ''
        else:
            omit = None

        if omit is not None:
            published = author.recently_published(exclude=omit)
        else:
            published = author.recently_published()

        context[self.var_name] = published[:self.count]
        return ''


@register.tag('author_listing')
def do_author_listing(parser, token):
    """
    Get N listing objects that were published by given author recently and optionally
    omit a publishable object in results.

    **Usage**::

        {% author_listing <author> <limit> as <result> [omit <obj>] %}

    **Parameters**::
        ==================================  ================================================
        Option                              Description
        ==================================  ================================================
        ``author``                          Author to load objects for.
        ``limit``                           Maximum number of objects to store,
        ``result``                          Store the resulting list in context under given
                                            name.
        ==================================  ================================================

    **Examples**::

        {% author_listing object.authors.all.0 10 as article_listing %}
    """
    contents = token.split_contents()

    if len(contents) not in [5, 7]:
        raise template.TemplateSyntaxError('%r tag requires 4 or 6 arguments.' % contents[0])
    elif len(contents) == 5:
        tag, obj_var, count, fill, var_name = contents
        return AuthorListingNode(obj_var, count, var_name)
    else:
        tag, obj_var, count, fill, var_name, filll, omit_var = contents
        return AuthorListingNode(obj_var, count, var_name, omit_var)




########NEW FILE########
__FILENAME__ = core
import logging

from django import template
from django.db import models
from django.utils.encoding import smart_str
from django.utils.safestring import mark_safe
from django.template.defaultfilters import stringfilter
from django.contrib.contenttypes.models import ContentType

from ella.core.models import Listing, Category
from ella.core.managers import ListingHandler
from ella.core.cache.utils import get_cached_object
from ella.core.box import Box


log = logging.getLogger('ella.core.templatetags')
register = template.Library()


class ListingNode(template.Node):
    def __init__(self, var_name, parameters):
        self.var_name = var_name
        self.parameters = parameters

    def render(self, context):
        params = {}
        for key, value in self.parameters.items():
            if isinstance(value, template.Variable):
                value = value.resolve(context)
            params[key] = value

        if 'category' in params and isinstance(params['category'], basestring):
            params['category'] = Category.objects.get_by_tree_path(params['category'])

        limits = {}
        if 'offset' in params:
            # templates are 1-based, compensate
            limits['offset'] = params.pop('offset') - 1

        if 'count' in params:
            limits['count'] = params.pop('count')

        lh = Listing.objects.get_queryset_wrapper(**params)

        context[self.var_name] = lh.get_listings(**limits)
        return ''


@register.tag
def listing(parser, token):
    """
    Tag that will obtain listing of top objects for a given category and store them in context under given name.

    Usage::

        {% listing <limit>[ from <offset>][of <app.model>[, <app.model>[, ...]]][ for <category> ] [with children|descendents] [using listing_handler] as <result> %}

    Parameters:
        ==================================  ================================================
        Option                              Description
        ==================================  ================================================
        ``limit``                           Number of objects to retrieve.
        ``offset``                          Starting with number (1-based), starts from first
                                            if no offset specified.
        ``app.model``, ...                  List of allowed models, all if omitted.
        ``category``                        Category of the listing, all categories if not
                                            specified. Can be either string (tree path),
                                            or variable containing a Category object.
        ``children``                        Include items from direct subcategories.
        ``descendents``                     Include items from all descend subcategories.
        ``exclude``                         Variable including a ``Publishable`` to omit.
        ``using``                           Name of Listing Handler ro use
        ``result``                          Store the resulting list in context under given
                                            name.
        ==================================  ================================================

    Examples::

        {% listing 10 of articles.article for "home_page" as obj_list %}
        {% listing 10 of articles.article for category as obj_list %}
        {% listing 10 of articles.article for category with children as obj_list %}
        {% listing 10 of articles.article for category with descendents as obj_list %}
        {% listing 10 from 10 of articles.article as obj_list %}
        {% listing 10 of articles.article, photos.photo as obj_list %}

    """
    var_name, parameters = listing_parse(token.split_contents())
    return ListingNode(var_name, parameters)

LISTING_PARAMS = set(['of', 'for', 'from', 'as', 'using', 'with', 'without', ])

def listing_parse(input):
    params = {}
    if len(input) < 4:
        raise template.TemplateSyntaxError, "%r tag argument should have at least 4 arguments" % input[0]
    o = 1
    # limit
    params['count'] = template.Variable(input[o])
    o = 2

    params['category'] = Category.objects.get_by_tree_path('')
    while o < len(input):
        # offset
        if input[o] == 'from':
            params['offset'] = template.Variable(input[o + 1])
            o = o + 2

        # from - models definition
        elif input[o] == 'of':
            o = o + 1
            mods = []
            while input[o] not in LISTING_PARAMS:
                mods.append(input[o])
                o += 1

            l = []
            for mod in ''.join(mods).split(','):
                m = models.get_model(*mod.split('.'))
                if m is None:
                    raise template.TemplateSyntaxError, "%r tag cannot list objects of unknown model %r" % (input[0], mod)
                l.append(ContentType.objects.get_for_model(m))
            params['content_types'] = l

        # for - category definition
        elif input[o] == 'for':
            params['category'] = template.Variable(input[o + 1])
            o = o + 2

        # with
        elif input[o] == 'with':
            o = o + 1
            if input[o] == 'children':
                params['children'] = ListingHandler.IMMEDIATE
            elif input[o] == 'descendents':
                params['children'] = ListingHandler.ALL
            else:
                raise template.TemplateSyntaxError, "%r tag's argument 'with' required specification (with children|with descendents)" % input[0]
            o = o + 1

        # without (exclude publishable
        elif input[o] == 'without':
            params['exclude'] = template.Variable(input[o + 1])
            o = o + 2

        # using (isting handlers)
        elif input[o] == 'using':
            params['source'] = template.Variable(input[o + 1])
            o = o + 2

        # as
        elif input[o] == 'as':
            var_name = input[o + 1]
            o = o + 2
            break
        else:
            raise template.TemplateSyntaxError('Unknown param for %s: %r' % (input[0], input[o]))
    else:
        raise template.TemplateSyntaxError, "%r tag requires 'as' argument" % input[0]

    if o < len(input):
        raise template.TemplateSyntaxError, "%r tag requires 'as' as last argument" % input[0]

    return var_name, params

class EmptyNode(template.Node):
    def render(self, context):
        return u''

class ObjectNotFoundOrInvalid(Exception): pass

class BoxNode(template.Node):

    def __init__(self, box_type, nodelist, model=None, lookup=None, var=None):
        self.box_type, self.nodelist, self.var, self.lookup, self.model = box_type, nodelist, var, lookup, model

    def get_obj(self, context):
        if self.model and self.lookup:
            if isinstance(self.lookup[1], template.Variable):
                try:
                    lookup_val = self.lookup[1].resolve(context)
                except template.VariableDoesNotExist, e:
                    log.warning('BoxNode: Template variable does not exist. var_name=%s', self.lookup[1].var)
                    raise ObjectNotFoundOrInvalid()

            else:
                lookup_val = self.lookup[1]

            try:
                obj = get_cached_object(self.model, **{self.lookup[0] : lookup_val})
            except (models.ObjectDoesNotExist, AssertionError), e:
                log.warning('BoxNode: %s (%s : %s)', str(e), self.lookup[0], lookup_val)
                raise ObjectNotFoundOrInvalid()
        else:
            try:
                obj = self.var.resolve(context)
            except template.VariableDoesNotExist, e:
                log.warning('BoxNode: Template variable does not exist. var_name=%s', self.var.var)
                raise ObjectNotFoundOrInvalid()

            if not obj:
                raise ObjectNotFoundOrInvalid()
        return obj

    def render(self, context):

        try:
            obj = self.get_obj(context)
        except ObjectNotFoundOrInvalid:
            return ''

        box = getattr(obj, 'box_class', Box)(obj, self.box_type, self.nodelist)

        if not box or not box.obj:
            log.warning('BoxNode: Box does not exists.')
            return ''

        # render the box
        return box.render(context)

@register.tag('box')
def do_box(parser, token):
    """
    Tag Node representing our idea of a reusable box. It can handle multiple
    parameters in its body which will then be accessible via ``{{ box.params
    }}`` in the template being rendered.

    .. note::
        The inside of the box will be rendered only when redering the box in
        current context and the ``object`` template variable will be present
        and set to the target of the box.

    Author of any ``Model`` can specify it's own ``box_class`` which enables
    custom handling of some content types (boxes for polls for example need
    some extra information to render properly).

    Boxes, same as :ref:`core-views`, look for most specific template for a given
    object an only fall back to more generic template if the more specific one
    doesn't exist. The list of templates it looks for:

    * ``box/category/<tree_path>/content_type/<app>.<model>/<slug>/<box_name>.html``
    * ``box/category/<tree_path>/content_type/<app>.<model>/<box_name>.html``
    * ``box/category/<tree_path>/content_type/<app>.<model>/box.html``
    * ``box/content_type/<app>.<model>/<slug>/<box_name>.html``
    * ``box/content_type/<app>.<model>/<box_name>.html``
    * ``box/content_type/<app>.<model>/box.html``
    * ``box/<box_name>.html``
    * ``box/box.html``

    .. note::
        Since boxes work for all models (and not just ``Publishable`` subclasses),
        some template names don't exist for some model classes, for example
        ``Photo`` model doesn't have a link to ``Category`` so that cannot be used.

    Boxes are always rendered in current context with added variables:

    * ``object`` - object being represented
    * ``box`` - instance of ``ella.core.box.Box``

    Usage::

        {% box <boxtype> for <app.model> with <field> <value> %}
            param_name: value
            param_name_2: {{ some_var }}
        {% endbox %}

        {% box <boxtype> for <var_name> %}
            ...
        {% endbox %}

    Parameters:

        ==================================  ================================================
        Option                              Description
        ==================================  ================================================
        ``boxtype``                         Name of the box to use
        ``app.model``                       Model class to use
        ``field``                           Field on which to do DB lookup
        ``value``                           Value for DB lookup
        ``var_name``                        Template variable to get the instance from
        ==================================  ================================================

    Examples::

        {% box home_listing for articles.article with slug "some-slug" %}{% endbox %}

        {% box home_listing for articles.article with pk object_id %}
            template_name : {{object.get_box_template}}
        {% endbox %}

        {% box home_listing for article %}{% endbox %}
    """
    bits = token.split_contents()

    nodelist = parser.parse(('end' + bits[0],))
    parser.delete_first_token()
    return _parse_box(nodelist, bits)

def _parse_box(nodelist, bits):
    # {% box BOXTYPE for var_name %}                {% box BOXTYPE for content.type with PK_FIELD PK_VALUE %}
    if (len(bits) != 4 or bits[2] != 'for') and (len(bits) != 7 or bits[2] != 'for' or bits[4] != 'with'):
        raise template.TemplateSyntaxError, "{% box BOXTYPE for content.type with FIELD VALUE %} or {% box BOXTYPE for var_name %}"

    if len(bits) == 4:
        # var_name
        return BoxNode(bits[1], nodelist, var=template.Variable(bits[3]))
    else:
        model = models.get_model(*bits[3].split('.'))
        if model is None:
            return EmptyNode()

        lookup_val = template.Variable(bits[6])
        try:
            lookup_val = lookup_val.resolve({})
        except template.VariableDoesNotExist:
            pass
        return BoxNode(bits[1], nodelist, model=model, lookup=(smart_str(bits[5]), lookup_val))

class RenderNode(template.Node):
    def __init__(self, var):
        self.var = template.Variable(var)

    def render(self, context):
        try:
            text = self.var.resolve(context)
        except template.VariableDoesNotExist:
            return ''

        template_name = 'render-%s' % self.var
        return template.Template(text, name=template_name).render(context)

@register.tag('render')
def do_render(parser, token):
    """
    Renders a rich-text field using defined markup.

    Example::

        {% render some_var %}
    """
    bits = token.split_contents()

    if len(bits) != 2:
        raise template.TemplateSyntaxError()

    return RenderNode(bits[1])

@register.filter
@stringfilter
def ipblur(text): # brutalizer ;-)
    """ blurs IP address  """
    import re
    m = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.)\d{1,3}.*', text)
    if not m:
        return text
    return '%sxxx' % m.group(1)

@register.filter
@stringfilter
def emailblur(email):
    "Obfuscates e-mail addresses - only @ and dot"
    return mark_safe(email.replace('@', '&#64;').replace('.', '&#46;'))


########NEW FILE########
__FILENAME__ = custom_urls_tags
"""
Lot of what you see here has been stolen from Django's ``{% url %}`` tag.
"""
from django.core.urlresolvers import NoReverseMatch
from django.template import Node, TemplateSyntaxError, Library, Variable
from django.utils.encoding import smart_str

from ella.core import custom_urls

register = Library()

class CustomURLNode(Node):
    def __init__(self, obj, view_name, args, kwargs, asvar, resolver=None):
        self.obj = obj
        self.view_name = view_name
        self.args = args
        self.kwargs = kwargs
        self.asvar = asvar
        self.resolver = resolver or custom_urls.resolver

    def render(self, context):
        args = [arg.resolve(context) for arg in self.args]
        kwargs = dict([(smart_str(k, 'ascii'), v.resolve(context))
                       for k, v in self.kwargs.items()])
        obj = self.obj.resolve(context)

        if not obj:
            return

        url = ''
        try:
            url = self.resolver.reverse(obj, self.view_name, *args, **kwargs)
        except NoReverseMatch, e:
            if self.asvar is None:
                raise e

        if self.asvar:
            context[self.asvar] = url
            return ''
        else:
            return url

@register.tag
def custom_url(parser, token):
    """
    Get URL using Ella custom URL resolver and return it or save it in 
    context variable.
    
    Syntax::
    
        {% custom_url <FOR_VARIABLE> <VIEWNAME>[[[ <ARGS>] <KWARGS>] as <VAR>] %}
    
    Examples::
    
        {% custom_url object send_by_email %}
        {% custom_url object send_by_email 1 %}
        {% custom_url object send_by_email pk=1 %}
        {% custom_url object send_by_email pk=1 as saved_url %}
    
    """
    bits = token.split_contents()
    return _parse_custom_url(bits)

def _parse_custom_url(bits, resolver=None):
    if len(bits) < 3:
        raise TemplateSyntaxError("'%s' takes at least one argument"
                                  " (path to a view)" % bits[0])
    obj = Variable(bits[1])
    viewname = bits[2]
    args = []
    kwargs = {}
    asvar = None

    if len(bits) > 3:
        bits = iter(bits[3:])
        for bit in bits:
            if bit == 'as':
                asvar = bits.next()
                break
            else:
                for arg in bit.split(","):
                    if '=' in arg:
                        k, v = arg.split('=', 1)
                        k = k.strip()
                        kwargs[k] = Variable(v)
                    elif arg:
                        args.append(Variable(arg))
    return CustomURLNode(obj, viewname, args, kwargs, asvar, resolver=resolver)

########NEW FILE########
__FILENAME__ = pagination
from urllib import urlencode

from django import template
from django.template.loader import render_to_string
from django.utils.encoding import smart_str

register = template.Library()


def _do_paginator(context, adjacent_pages, template_name):
    if template_name is None:
        template_name = ('inclusion_tags/paginator.html',
                         'inc/paginator.html')
    else:
        template_name = ('inclusion_tags/paginator_%s.html' % template_name,
                         'inc/paginator_%s.html' % template_name)

    if not 'page' in context:
        # improper use of paginator tag, bail out
        return template_name, {}

    query_params = '?p='
    if 'request' in context:
        get = context['request'].GET
        query_params = '?%s&p=' % urlencode(dict((k, smart_str(v)) for (k, v) in get.iteritems() if k != 'p'))

    page = context['page']
    page_no = int(page.number)

    s = max(1, page_no - adjacent_pages - max(0, page_no + adjacent_pages -
        page.paginator.num_pages))
    page_numbers = range(s, min(page.paginator.num_pages, s + 2 * adjacent_pages) + 1)

    return template_name, {
        'query_params': query_params,
        'page': page,
        'results_per_page': page.paginator.per_page,
        'page_numbers': page_numbers,
        'show_first': 1 not in page_numbers,
        'show_last': page.paginator.num_pages not in page_numbers,
    }


@register.simple_tag(takes_context=True)
def paginator(context, adjacent_pages=2, template_name=None):
    """
    Renders a ``inclusion_tags/paginator.html`` or ``inc/paginator.html``
    template with additional pagination context. To be used in conjunction
    with the ``object_list`` generic
    view.

    If ``TEMPLATE_NAME`` parameter is given,
    ``inclusion_tags/paginator_TEMPLATE_NAME.html`` or 
    ``inc/paginator_TEMPLATE_NAME.html`` will be used instead.

    Adds pagination context variables for use in displaying first, adjacent pages and
    last page links in addition to those created by the ``object_list`` generic
    view.

    Taken from http://www.djangosnippets.org/snippets/73/

    Syntax::

        {% paginator [NUMBER_OF_ADJACENT_PAGES] [TEMPLATE_NAME] %}

    Examples::

        {% paginator %}
        {% paginator 5 %}
        {% paginator 5 "special" %}
        # with Django 1.4 and above you can also do:
        {% paginator template_name="special" %}
    """
    tname, context = _do_paginator(context, adjacent_pages, template_name)
    return render_to_string(tname, context)

########NEW FILE########
__FILENAME__ = related
from django import template
from django.db import models

from ella.core.models import Related

register = template.Library()

class RelatedNode(template.Node):
    def __init__(self, obj_var, count, var_name, models, finder):
        self.obj_var = obj_var
        self.count = count
        self.var_name = var_name
        self.models = models
        self.finder = finder

    def render(self, context):
        try:
            obj = template.Variable(self.obj_var).resolve(context)
        except template.VariableDoesNotExist:
            return ''
        related = Related.objects.get_related_for_object(obj, self.count,
            mods=self.models, finder=self.finder)
        context[self.var_name] = related
        return ''

def parse_related_tag(bits):
    if len(bits) < 6:
        raise template.TemplateSyntaxError, "{% related N [app_label.Model, ...] for object as var_name %}"

    if not bits[1].isdigit():
        raise template.TemplateSyntaxError, "Count must be an integer."

    if bits[-2] != 'as':
        raise template.TemplateSyntaxError, "Tag must end with as var_name "
    if bits[-4] != 'for':
        raise template.TemplateSyntaxError, "Tag must end with for object as var_name "

    if '.' in bits[2] or bits[2] == 'for':
        mod_index = 2
        finder = None
    else:
        mod_index = 3
        finder = bits[2]

    mods = []
    for m in bits[mod_index:-4]:
        if m == ',':
            continue
        if ',' in m:
            ms = m.split(',')
            for msm in ms:
                if not msm:
                    continue
                try:
                    mods.append(models.get_model(*msm.split('.')))
                except:
                    raise template.TemplateSyntaxError, "%r doesn't represent any model." % msm
        else:
            try:
                mods.append(models.get_model(*m.split('.')))
            except:
                raise template.TemplateSyntaxError, "%r doesn't represent any model." % m

    return bits[-3], int(bits[1]), bits[-1], mods, finder


@register.tag('related')
def do_related(parser, token):
    """
    Get N related models into a context variable optionally specifying a 
    named related finder.

    **Usage**::
    
        {% related <limit>[ query_type] [app.model, ...] for <object> as <result> %}
        
    **Parameters**::
        ==================================  ================================================
        Option                              Description
        ==================================  ================================================
        ``limit``                           Number of objects to retrieve.
        ``query_type``                      Named finder to resolve the related objects,
                                            falls back to ``settings.DEFAULT_RELATED_FINDER``
                                            when not specified.
        ``app.model``, ...                  List of allowed models, all if omitted.
        ``object``                          Object to get the related for.
        ``result``                          Store the resulting list in context under given
                                            name.
        ==================================  ================================================

    **Examples**::
    
        {% related 10 for object as related_list %}
        {% related 10 directly articles.article, galleries.gallery for object as related_list %}
    """
    bits = token.split_contents()
    obj_var, count, var_name, mods, finder = parse_related_tag(bits)
    return RelatedNode(obj_var, count, var_name, mods, finder)




########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.core.validators import slug_re
from django.template.defaultfilters import slugify
from django.utils.translation import ugettext_lazy as _

try:
    from django.conf.urls import patterns, include, url
except ImportError:
    from django.conf.urls.defaults import patterns, include, url

from ella.core.views import object_detail, list_content_type, category_detail, \
                            home, AuthorView


try:
    if settings.CUSTOM_VIEWS:
        views = settings.VIEWS
        temp = __import__(views, globals(), locals(), ['object_detail', 'list_content_type', 'category_detail', 'home', 'AuthorView'])
        object_detail = temp.object_detail
        list_content_type = temp.list_content_type
        category_detail = temp.category_detail
        home = temp.home
        AuthorView = temp.AuthorView
except:
    pass

from ella.core.feeds import RSSTopCategoryListings, AtomTopCategoryListings


res = {
    'ct': r'(?P<content_type>[a-z][a-z0-9-]+)',
    'cat': r'(?P<category>(?:(?:[0-9]+[^0-9-]|[a-z])[a-z0-9-]*/)*(?:[0-9]+[^0-9-]|[a-z])[a-z0-9-]*)',
    'slug': r'(?P<slug>%s)' % slug_re.pattern.strip('^$'),
    'year': r'(?P<year>\d{4})',
    'month': r'(?P<month>\d{1,2})',
    'day': r'(?P<day>\d{1,2})',
    'rest': r'(?P<url_remainder>.+/)',
    'id': r'(?P<id>\d+)',
    'author': slugify(_('author'))
}

urlpatterns = patterns('',
    # home page
    url(r'^$', home, name="root_homepage"),

    # author detail
    url(r'^%(author)s/%(slug)s/$' % res, AuthorView.as_view(), name='author_detail'),

    # export banners
    url(r'^export/xml/(?P<name>[a-z0-9-]+)/$', 'ella.core.views.export', { 'count' : 3, 'content_type' : 'text/xml' }, name="named_export_xml"),
    url(r'^export/$', 'ella.core.views.export', { 'count' : 3 }, name="export"),
    url(r'^export/(?P<name>[a-z0-9-]+)/$', 'ella.core.views.export', { 'count' : 3 }, name="named_export"),

    # list of objects regadless of category and content type
    url(r'^%(year)s/%(month)s/%(day)s/$' % res, list_content_type, name="list_day"),
    url(r'^%(year)s/%(month)s/$' % res, list_content_type, name="list_month"),
    url(r'^%(year)s/$' % res, list_content_type, name="list_year"),

    # object detail
    url(r'^%(cat)s/%(year)s/%(month)s/%(day)s/%(slug)s/$' % res, object_detail, name="object_detail"),
    url(r'^%(year)s/%(month)s/%(day)s/%(slug)s/$' % res, object_detail, { 'category' : '' }, name="home_object_detail"),

    # object detail with custom action
    url(r'^%(cat)s/%(year)s/%(month)s/%(day)s/%(slug)s/%(rest)s$' % res, object_detail, name="object_detail_action"),
    url(r'^%(year)s/%(month)s/%(day)s/%(slug)s/%(rest)s$' % res, object_detail, { 'category' : '' }, name="home_object_detail_action"),

    # category listings
    url(r'^%(cat)s/%(year)s/%(month)s/%(day)s/$' % res, list_content_type, name="category_list_day"),
    url(r'^%(cat)s/%(year)s/%(month)s/$' % res, list_content_type, name="category_list_month"),
    url(r'^%(cat)s/%(year)s/$' % res, list_content_type, name="category_list_year"),

    # static detail with custom action
    url(r'^%(cat)s/%(id)s-%(slug)s/%(rest)s$' % res, object_detail, name='static_detail_action'),
    url(r'^%(id)s-%(slug)s/%(rest)s$' % res, object_detail, { 'category' : '' }, name='home_static_detail_action'),

    # static detail
    url(r'^%(cat)s/%(id)s-%(slug)s/$' % res, object_detail, name='static_detail'),
    url(r'^%(id)s-%(slug)s/$' % res, object_detail, { 'category' : '' }, name='home_static_detail'),

    # rss feeds
    url(r'^feeds/$', RSSTopCategoryListings(), name='home_rss_feed'),
    url(r'^feeds/atom/$', AtomTopCategoryListings(), name='home_atom_feed'),
    url(r'^%(cat)s/feeds/$' % res, RSSTopCategoryListings(), name='rss_feed'),
    url(r'^%(cat)s/feeds/atom/$' % res, AtomTopCategoryListings(), name='atom_feed'),

    # category homepage
    url(r'^%(cat)s/$' % res, category_detail, name="category_detail"),

)

########NEW FILE########
__FILENAME__ = views
from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.http import Http404
from django.shortcuts import redirect, render
from django.template.defaultfilters import slugify
from django.template.response import TemplateResponse
from django.utils.translation import ugettext_lazy as _
from django.views.generic.list import ListView

from ella.core.models import Listing, Category, Publishable, Author
from ella.core.cache import get_cached_object_or_404, cache_this, get_cached_object
from ella.core import custom_urls
from ella.core.conf import core_settings
from ella.core.signals import object_rendering, object_rendered
from ella.api import render_as_api
from ella.utils.timezone import now, localize

__docformat__ = "restructuredtext en"

# local cache for get_content_type()
CONTENT_TYPE_MAPPING = {}


class AuthorView(ListView):
    model = Publishable
    context_object_name = 'listings'
    allow_empty = True
    paginate_by = core_settings.CATEGORY_LISTINGS_PAGINATE_BY
    template_name = 'page/author.html'

    def get(self, request, *args, **kwargs):
        if 'slug' not in kwargs:
            raise Http404

        # Compatibility with `paginator` tag.
        if 'p' in request.GET:
            self.kwargs.update({'page': request.GET['p']})

        self.author = get_cached_object_or_404(Author, slug=kwargs['slug'])

        response = render_as_api(request, self.author)
        if response:
            return response

        return super(AuthorView, self).get(request, *args, **kwargs)

    def get_queryset(self):
        return self.author.recently_published()

    def get_context_data(self, **kwargs):
        base = super(AuthorView, self).get_context_data(**kwargs)
        base.update({'object': self.author})

        # Compatibility with `paginator` tag.
        if base['page_obj']:
            base.update({'page': base['page_obj']})

        return base


class EllaCoreView(object):
    ' Base class for class-based views used in ella.core.views. '

    # name of the template to be passed into get_templates
    template_name = 'TEMPLATE'

    def get_context(self, request, **kwargs):
        """
        Return a dictionary that will be then passed into the template as context.

        :Parameters:
            - `request`: current request

        :Returns:
            Dictionary with all the data
        """
        raise NotImplementedError()

    def get_templates(self, context, template_name=None):
        " Extract parameters for `get_templates` from the context. "
        if not template_name:
            template_name = self.template_name

        kw = {}
        if 'object' in context:
            o = context['object']
            kw['slug'] = o.slug

        if context.get('content_type', False):
            ct = context['content_type']
            kw['app_label'] = ct.app_label
            kw['model_label'] = ct.model

        return get_templates(template_name, category=context['category'], **kw)

    def render(self, request, context, template):
        return TemplateResponse(request, template, context)

    def __call__(self, request, **kwargs):
        context = self.get_context(request, **kwargs)
        return self.render(request, context, self.get_templates(context))


class ObjectDetail(EllaCoreView):
    """
    Renders a page for publishable.  If ``url_remainder`` is specified, tries to
    locate custom view via :meth:`DetailDispatcher.call_view`. If
    :meth:`DetailDispatcher.has_custom_detail` returns ``True``, calls
    :meth:`DetailDispatcher.call_custom_detail`. Otherwise renders a template
    with context containing:

    * object: ``Publishable`` instance representing the URL accessed
    * category: ``Category`` of the ``object``
    * content_type_name: slugified plural verbose name of the publishable's content type
    * content_type: ``ContentType`` of the publishable

    The template is chosen based on the object in question (the first one that matches is used):

    * ``page/category/<tree_path>/content_type/<app>.<model>/<slug>/object.html``
    * ``page/category/<tree_path>/content_type/<app>.<model>/object.html``
    * ``page/category/<tree_path>/object.html``
    * ``page/content_type/<app>.<model>/object.html``
    * ``page/object.html``

    :param request: ``HttpRequest`` from Django
    :param category: ``Category.tree_path`` (empty if home category)
    :param year month day: date matching the `publish_from` field of the `Publishable` object
    :param slug: slug of the `Publishable`
    :param url_remainder: url after the object's url, used to locate custom views in `custom_urls.resolver`

    :raises Http404: if the URL is not valid and/or doesn't correspond to any valid `Publishable`
    """
    template_name = 'object.html'

    class WrongUrl(Http404): pass

    def __call__(self, request, category, slug, year=None, month=None, day=None, id=None, url_remainder=None):
        try:
            context = self.get_context(request, category, slug, year, month, day, id)
        except self.WrongUrl, e:
            message, obj = e.args
            url = obj.get_absolute_url()
            if url_remainder:
                url += url_remainder
            return redirect(url, permanent=True)

        obj = context['object']

        object_rendering.send(sender=context['object'].__class__, request=request, category=context['category'], publishable=context['object'])

        # check for custom actions
        if url_remainder:
            return custom_urls.resolver.call_custom_view(request, obj, url_remainder, context)
        response = render_as_api(request, obj)
        if response:
            return response

        if custom_urls.resolver.has_custom_detail(obj):
            return custom_urls.resolver.call_custom_detail(request, context)

        object_rendered.send(sender=context['object'].__class__, request=request, category=context['category'], publishable=context['object'])

        return self.render(request, context, self.get_templates(context))

    def get_context(self, request, category, slug, year, month, day, id):
        try:
            cat = Category.objects.get_by_tree_path(category)
        except Category.DoesNotExist:
            # non-static url, no way to recover
            if year:
                raise Http404("Category with tree_path '%s' doesn't exist." % category)
            else:
                cat = None

        if year:
            start_date = localize(datetime(int(year), int(month), int(day)))
            end_date = start_date + timedelta(days=1)

            lookup = {
                'publish_from__gte': start_date,
                'publish_from__lt': end_date,
                'category': cat,
                'slug': slug,
                'static': False
            }
            try:
                publishable = get_cached_object(Publishable, published=True, **lookup)
            except Publishable.DoesNotExist:
                # Fallback for staff members in case there are multiple
                # objects with same URL.
                if request.user.is_staff:
                    try:
                        # Make sure we return specific publishable subclass
                        # like when using `get_cached_object` if possible.
                        p = Publishable.objects.filter(published=False, **lookup)[0]
                        publishable = p.content_type.model_class()._default_manager.get(pk=p.pk)
                    except IndexError:
                        raise Http404
                else:
                    raise Http404
        else:
            publishable = get_cached_object_or_404(Publishable, pk=id)

        if not (publishable.is_published() or request.user.is_staff):
            # future publish, render if accessed by logged in staff member
            raise Http404

        if not year:
            if cat is None:
                raise self.WrongUrl('Category with tree_path %r does not exist.' % category, publishable)
            elif not publishable.static:
                raise self.WrongUrl('%s is not static.' % publishable, publishable)
            elif slug != publishable.slug:
                raise self.WrongUrl('Wrong slug in URL (%r).' % slug, publishable)
            elif publishable.category_id != cat.pk:
                raise self.WrongUrl('Wrong category for %s.' % publishable, publishable)

        # save existing object to preserve memory and SQL
        publishable.category = cat

        context = {
            'object': publishable,
            'category': cat,
            'content_type_name': slugify(publishable.content_type.model_class()._meta.verbose_name_plural),
            'content_type': publishable.content_type
        }

        return context


def archive_year_cache_key(self, category):
    return 'core.archive_year:%d' % category.pk


class ListContentType(EllaCoreView):
    """
    List objects' listings according to the parameters. If no filtering is
    applied (including pagination), the category's title page is rendered. The
    template used depends on ``template`` attribute for category being rendered.
    Default template is ``category.html``, so it would look like this:

    * ``page/category/<tree_path>/category.html``
    * ``page/category.html``

    If custom template is selected, let's say ``static_page.html``, it would
    result in:

    * ``page/category/<tree_path>/static_page.html``
    * ``page/static_page.html``

    If filtering is active, an archive template gets rendered:

    * ``page/category/<tree_path>/content_type/<app>.<model>/listing.html``
    * ``page/category/<tree_path>/listing.html``
    * ``page/content_type/<app>.<model>/listing.html``
    * ``page/listing.html``

    The context contains:

    * ``category``
    * ``listings``: list of ``Listing`` objects ordered by date

    * ``page``: ``django.core.paginator.Page`` instance
    * ``is_paginated``: ``True`` if there are more pages
    * ``results_per_page``: number of objects on one page

    * ``content_type``: ``ContentType`` of the objects, if filtered on content type
    * ``content_type_name``: name of the objects' type, if filtered on content type


    :param category: ``tree_path`` of the ``Category``, root category is used if empty
    :param year, month, day: date matching the ``publish_from`` field of the ``Listing`` object.
    :param content_type: slugified verbose_name_plural of the target model, if omitted all content_types are listed
    :param page_no: which page to display

    All parameters are optional, filtering is done on those supplied

    :raises Http404: if the specified category or content_type does not exist or if the given date is malformed.
    """
    empty_homepage_template_name = 'debug/empty_homepage.html'

    class EmptyHomepageException(Exception): pass

    def __call__(self, request, **kwargs):
        # get the category
        try:
            cat = self.get_category(request, kwargs.pop('category', ''))
        except self.EmptyHomepageException:
            return self.render(request, {}, self.empty_homepage_template_name)

        # mark it as being rendered
        object_rendering.send(sender=Category, request=request, category=cat, publishable=None)
        object_rendered.send(sender=Category, request=request, category=cat, publishable=None)

        # if API enabled and active, return a serialized category
        response = render_as_api(request, cat)
        if response:
            return response

        context = self.get_context(request, cat, **kwargs)

        # custom view for category
        if custom_urls.resolver.has_custom_detail(cat):
            # custom_urls depend on the main rendered object being stored as
            # 'object' in context
            context['object'] = cat
            return custom_urls.resolver.call_custom_detail(request, context)

        template_name = cat.template
        archive_template = cat.app_data.ella.archive_template

        if archive_template and not context.get('is_title_page'):
            template_name = archive_template

        return self.render(request, context, self.get_templates(context, template_name))

    @cache_this(archive_year_cache_key, timeout=60 * 60 * 24)
    def _archive_entry_year(self, category):
        " Return ARCHIVE_ENTRY_YEAR from settings (if exists) or year of the newest object in category "
        year = getattr(settings, 'ARCHIVE_ENTRY_YEAR', None)
        if not year:
            n = now()
            try:
                year = Listing.objects.filter(
                        category__site__id=settings.SITE_ID,
                        category__tree_path__startswith=category.tree_path,
                        publish_from__lte=n
                    ).values('publish_from')[0]['publish_from'].year
            except:
                year = n.year
        return year

    def get_category(self, request, category_path):
        try:
            cat = Category.objects.get_by_tree_path(category_path)
        except Category.DoesNotExist:
            # Homepage behaves differently on 404 with DEBUG mode to let user
            # know everything is fine instead of 404.
            if settings.DEBUG is True and not category_path:
                raise self.EmptyHomepageException()

            raise Http404(_('Category with tree path %(path)r does not exist on site %(site)s') %
                    {'path': category_path, 'site': settings.SITE_ID})
        return cat

    def get_context(self, request, category, year=None, month=None, day=None):

        ella_data = category.app_data.ella

        no_home_listings = ella_data.no_home_listings

        # pagination
        page_no = None
        if 'p' in request.GET and request.GET['p'].isdigit():
            page_no = int(request.GET['p'])

        # if we are not on the first page, display a different template
        category_title_page = (page_no is None or (not no_home_listings and page_no == 1)) and not year

        if page_no is None:
            page_no = 1

        kwa = {'children': ella_data.child_behavior}

        if 'using' in request.GET:
            kwa['source'] = request.GET['using']
        else:
            kwa['source'] = ella_data.listing_handler

        if day:
            try:
                start_day = datetime(int(year), int(month), int(day))
                kwa['date_range'] = (start_day, start_day + timedelta(seconds=24 * 3600 - 1))
            except (ValueError, OverflowError):
                raise Http404(_('Invalid day value %r') % day)
        elif month:
            try:
                start_day = datetime(int(year), int(month), 1)
                kwa['date_range'] = (start_day, (start_day + timedelta(days=32)).replace(day=1) - timedelta(seconds=1))
            except (ValueError, OverflowError):
                raise Http404(_('Invalid month value %r') % month)
        elif year:
            try:
                start_day = datetime(int(year), 1, 1)
                kwa['date_range'] = (start_day, (start_day + timedelta(days=370)).replace(day=1) - timedelta(seconds=1))
            except (ValueError, OverflowError):
                raise Http404(_('Invalid year value %r') % year)

        if 'date_range' in kwa:
            kwa['date_range'] = tuple(map(localize, kwa['date_range']))

        # basic context
        context = {
            'category' : category,
            'is_homepage': category_title_page and not category.tree_parent_id,
            'is_title_page': category_title_page,
            'archive_entry_year' : lambda: self._archive_entry_year(category),
        }

        # no listings wanted on title page
        if category_title_page and no_home_listings:
            return context

        # add pagination
        page = ella_data.get_listings_page(page_no, **kwa)
        context.update({
            'is_paginated': page.has_other_pages(),
            'results_per_page': page.paginator.per_page,
            'page': page,
            'listings': page.object_list,
        })

        return context

# backwards compatibility
object_detail = ObjectDetail()
home = category_detail = list_content_type = ListContentType()


def get_content_type(ct_name):
    """
    A helper function that returns ContentType object based on its slugified verbose_name_plural.

    Results of this function is cached to improve performance.

    :Parameters:
        - `ct_name`:  Slugified verbose_name_plural of the target model.

    :Exceptions:
        - `Http404`: if no matching ContentType is found
    """
    try:
        ct = CONTENT_TYPE_MAPPING[ct_name]
    except KeyError:
        for model in models.get_models():
            if ct_name == slugify(model._meta.verbose_name_plural):
                ct = ContentType.objects.get_for_model(model)
                CONTENT_TYPE_MAPPING[ct_name] = ct
                break
        else:
            raise Http404
    return ct



def get_templates(name, slug=None, category=None, app_label=None, model_label=None):
    """
    Returns templates in following format and order:

    * ``'page/category/%s/content_type/%s.%s/%s/%s' % (<CATEGORY_PART>, app_label, model_label, slug, name)``
    * ``'page/category/%s/content_type/%s.%s/%s' % (<CATEGORY_PART>, app_label, model_label, name)``
    * ``'page/category/%s/%s' % (<CATEGORY_PART>, name)``
    * ``'page/content_type/%s.%s/%s' % (app_label, model_label, name)``
    * ``'page/%s' % name``

    Where ``<CATEGORY_PART>`` is derived from ``path`` attribute by these rules:

    * When **no** parent exists (this is therfore root category) ``<CATEGORY_PART> = path``
    * When exactly **one** parent exists: ``<CATEGORY_PART> = path``
    * When multiple parent exist (category nestedN is deep in the tree)::

          <CATEGORY_PART> = (
              'nested1/nested2/../nestedN/',
              'nested1/nested2/../nestedN-1/',
              ...
              'nested1'
          )

    Examples. Three categories exist having slugs **ROOT**, **NESTED1**,
    **NESTED2** where **NESTED2**'s parent is **NESTED1**.::

        ROOT
           \
         NESTED1
             \
            NESTED2

    * For **ROOT**, ``<CATEGORY_PART>`` is only one - "ROOT".
    * For **NESTED1**, ``<CATEGORY_PART>`` is only one - "NESTED1".
    * For **NESTED2**, ``<CATEGORY_PART>`` has two elements: "NESTED1/NESTED2" and "NESTED1".
    """
    def category_templates(category, incomplete_template, params):
        paths = []
        parts = category.path.split('/')
        for i in reversed(range(1, len(parts) + 1)):
            params.update({'pth': '/'.join(parts[:i])})
            paths.append(incomplete_template % params)
        return paths

    FULL = 'page/category/%(pth)s/content_type/%(app_label)s.%(model_label)s/%(slug)s/%(name)s'
    FULL_NO_SLUG = 'page/category/%(pth)s/content_type/%(app_label)s.%(model_label)s/%(name)s'
    BY_CATEGORY = 'page/category/%(pth)s/%(name)s'
    BY_CONTENT_TYPE = 'page/content_type/%(app_label)s.%(model_label)s/%(name)s'

    templates = []
    params = {'name': name}

    if app_label and model_label:
        params.update({'app_label': app_label, 'model_label': model_label})

    if slug:
        params.update({'slug': slug})

    if category:
        if app_label and model_label:
            if slug:
                templates += category_templates(category, FULL, params)
            templates += category_templates(category, FULL_NO_SLUG, params)
        templates += category_templates(category, BY_CATEGORY, params)

    if app_label and model_label:
        templates.append(BY_CONTENT_TYPE % params)

    templates.append('page/%(name)s' % params)
    return templates


def get_templates_from_publishable(name, publishable):
    """
    Returns the same template list as `get_templates` but gets values from `Publishable` instance.
    """
    slug = publishable.slug
    category = publishable.category
    app_label = publishable.content_type.app_label
    model_label = publishable.content_type.model
    return get_templates(name, slug, category, app_label, model_label)


def get_export_key(request, count, name='', content_type=None):
    return 'core.export:%d:%d:%s:%s' % (
            settings.SITE_ID, count, name, content_type
        )

@cache_this(get_export_key, timeout=core_settings.CACHE_TIMEOUT_LONG)
def export(request, count, name='', content_type=None):
    """
    Export banners.

    :Parameters:
        - `count`: number of objects to pass into the template
        - `name`: name of the template ( page/export/banner.html is default )
        - `models`: list of Model classes to include
    """
    t_list = []
    if name:
        t_list.append('page/export/%s.html' % name)
    t_list.append('page/export/banner.html')

    try:
        cat = Category.objects.get_by_tree_path('')
    except Category.DoesNotExist:
        raise Http404()
    listing = Listing.objects.get_listing(count=count, category=cat)
    return render(
            request,
            t_list,
            { 'category' : cat, 'listing' : listing },
            content_type=content_type
        )


##
# Error handlers
##
def page_not_found(request):
    response = TemplateResponse(request, 'page/404.html', {})
    response.status_code = 404
    return response.render()

def handle_error(request):
    response = TemplateResponse(request, 'page/500.html', {})
    response.status_code = 500
    return response.render()

########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from django.conf import settings
from django.utils.translation import ugettext
from django.forms.util import ValidationError
from django.utils import simplejson
from django.utils.translation import ugettext_lazy as _
from django.utils.safestring import mark_safe
from django.http import HttpResponse

from ella.photos.models import FormatedPhoto, Format, Photo
from ella.core.cache.utils import get_cached_object


class FormatedPhotoForm(forms.BaseForm):
    def clean(self):
        """
        Validation function that checks the dimensions of the crop whether it fits into the original and the format.
        """
        data = self.cleaned_data
        photo = data['photo']
        if (
            (data['crop_left'] > photo.width) or
            (data['crop_top'] > photo.height) or
            ((data['crop_left'] + data['crop_width']) > photo.width) or
            ((data['crop_top'] + data['crop_height']) > photo.height)
        ):
            # raise forms.ValidationError, ugettext("The specified crop coordinates do not fit into the source photo.")
            raise ValidationError(ugettext("The specified crop coordinates do not fit into the source photo."))
        return data


class FormatForm(forms.ModelForm):
    class Meta:
        model = Format

    def clean(self):
        """
        Check format name uniqueness for sites

        :return: cleaned_data
        """

        data = self.cleaned_data
        formats = Format.objects.filter(name=data['name'])
        if self.instance:
            formats = formats.exclude(pk=self.instance.pk)

        exists_sites = []
        for f in formats:
            for s in f.sites.all():
                if s in data['sites']:
                    exists_sites.append(s.__unicode__())

        if len(exists_sites):
            raise ValidationError(ugettext("Format with this name exists for site(s): %s" % ", ".join(exists_sites)))

        return data


class FormatOptions(admin.ModelAdmin):
    form = FormatForm
    list_display = ('name', 'max_width', 'max_height', 'stretch', 'resample_quality',)
    list_filter = ('sites', 'stretch', 'nocrop',)
    search_fields = ('name',)


class FormatedPhotoInlineOptions(admin.TabularInline):
    model = FormatedPhoto


class PhotoOptions(admin.ModelAdmin):
    @property
    def thumb_format(self):
        if not hasattr(self, '_thumb_format'):
            if not hasattr(settings, 'PHOTOS_THUMB_FORMAT'):
                self._thumb_format = None
            else:
                self._thumb_format = get_cached_object(Format, id=settings.PHOTOS_THUMB_FORMAT)

        return self._thumb_format

    def thumb(self, photo):
        if not self.thumb_format:
            return ''

        thumb_info = FormatedPhoto.objects.get_photo_in_format(photo, self.thumb_format)

        return mark_safe("""
            <a href="%s" title="%s" target="_blank">
                <img src="%s" alt="Thumbnail %s" />
            </a>""" % (photo.image.url, photo.title, thumb_info['url'], photo.title))
    thumb.allow_tags = True

    inlines = [FormatedPhotoInlineOptions]
    list_display = ('title', 'width', 'height', 'thumb', )
    list_filter = ('created',)
    search_fields = ('title', 'image', 'description', 'id',)
    suggest_fields = {'authors': ('name', 'slug',), 'source': ('name', 'url',)}
    rich_text_fields = {'small': ('description',)}
    ordering = ('-id',)

    fieldsets = (
        (_("Photo core"), {'fields': ('title', 'image', 'authors')}),
        (_("Photo extra"), {'fields': ('description', 'source')}),
        (_("Metadata"), {'fields': (('important_top', 'important_left', 'important_bottom', 'important_right'),)}),
    )

    def __call__(self, request, url):
        if url and url.endswith('json'):
            return self.format_photo_json(request, *url.split('/')[-3:-1])
        return super(PhotoOptions, self).__call__(request, url)

    def format_photo_json(self, request, photo, format):
        "Used in admin image 'crop tool'."
        try:
            photo = get_cached_object(Photo, pk=photo)
            format = get_cached_object(Format, pk=format)
            content = {
                'error': False,
                'image':settings.MEDIA_URL + photo.image,
                'width':photo.width,
                'height': photo.height,
                'format_width':format.max_width,
                'format_height':format.max_height
            }
        except (Photo.DoesNotExist, Format.DoesNotExist):
            content = {'error':True}
        return HttpResponse(simplejson.dumps(content))


class FormatedPhotoOptions(admin.ModelAdmin):
    base_form = FormatedPhotoForm
    list_display = ('image', 'format', 'width', 'height')
    list_filter = ('format',)
    search_fields = ('image',)
    raw_id_fields = ('photo',)


admin.site.register(Format, FormatOptions)
admin.site.register(Photo, PhotoOptions)
admin.site.register(FormatedPhoto, FormatedPhotoOptions)


########NEW FILE########
__FILENAME__ = conf
from django.utils.translation import ugettext_lazy as _
from ella.utils.settings import Settings

# settings default
FORMAT_QUALITY_DEFAULT = (
    (45, _('Low')),
    (65, _('Medium')),
    (75, _('Good')),
    (85, _('Better')),
    (95, _('High')),
)


FORMAT_QUALITY = FORMAT_QUALITY_DEFAULT
CUSTOM_SUBDIR = ''
UPLOAD_TO = CUSTOM_SUBDIR and 'photos/%s/%%Y/%%m/%%d' % CUSTOM_SUBDIR or 'photos/%Y/%m/%d'
EMPTY_IMAGE_SITE_PREFIX = ''

TYPE_EXTENSION = {
    'JPEG': '.jpg',
    'PNG': '.png',
    'GIF': '.gif'
}

PHOTO_MIN_WIDTH = 150
PHOTO_MIN_HEIGHT = 150

DEFAULT_BG_COLOR = 'black'

FORMATED_PHOTO_FILENAME = None

DEBUG = False
DEBUG_PLACEHOLDER_PROVIDER_TEMPLATE = 'http://placehold.it/%(width)sx%(height)s'

photos_settings = Settings('ella.photos.conf', 'PHOTOS')


########NEW FILE########
__FILENAME__ = formatter
from PIL import Image, ExifTags

from ella.photos.conf import photos_settings

TAGS = dict((b,a) for a,b in ExifTags.TAGS.items())

class Formatter(object):
    def __init__(self, image, format, crop_box=None, important_box=None):
        self.image = image
        self.fmt = format
        self.crop_box = crop_box
        self.important_box = important_box

        # precompute and store a bunch of numbers
        f = format
        self.fw, self.fh = f.max_width, f.max_height
        self.format_ratio = float(self.fw) / self.fh

        iw, ih = self.image.size
        self.image_ratio = float(iw) / ih

    def format(self):
        """
        Crop and resize the supplied image. Return the image and the crop_box used.
        If the input format is JPEG and in EXIF there is information about rotation, use it and rotate resulting image.
        """
        if hasattr(self.image, '_getexif'):
            self.rotate_exif()
        crop_box = self.crop_to_ratio()
        self.resize()
        return self.image, crop_box

    def set_format(self):
        """
        Check if the format has a flexible height, if so check if the ratio
        of the flexible format is closer to the actual ratio of the image. If
        so use that instead of the default values (f.max_width, f.max_height).
        """
        f = self.fmt

        if f.flexible_height and f.flexible_max_height:
            flexw, flexh = self.fw, f.flexible_max_height
            flex_ratio = float(flexw) / flexh

            if abs(flex_ratio - self.image_ratio) < abs(self.format_ratio - self.image_ratio):
                self.fh = flexh
                self.format_ratio = flex_ratio

    def get_crop_box(self):
        """
        Get coordinates of the rectangle defining the new image boundaries. It
        takes into acount any specific wishes from the model (explicitely
        passed in crop_box), the desired format and it's options
        (flexible_height, nocrop) and mainly it's ratio. After dimensions of
        the format were specified (see set_format), crop the image to the same
        ratio.
        """

        # check if the flexible height option is active and applies
        self.set_format()


        if self.fmt.nocrop:
            # cropping not allowed
            return

        if self.crop_box:
            # crop coordinates passed in explicitely
            return self.crop_box

        iw, ih = self.image.size

        if iw <= self.fw and ih <= self.fh:
            # image fits in the target format, no need to crop
            return

        if self.image_ratio < self.format_ratio:
            # image taller than format
            diff = ih - (iw * self.fh / self.fw)
            return (0, diff // 2 , iw, ih - diff // 2)

        elif self.image_ratio > self.format_ratio:
            # image wider than format
            diff = iw - (ih * self.fw / self.fh)
            return (diff // 2, 0, iw - diff // 2, ih)

        else:
            # same ratio as format
            return

    def center_important_part(self, crop_box):
        """
        If important_box was specified, make sure it lies inside the crop box.
        """
        if not self.important_box:
            return crop_box

        # shortcuts
        ib = self.important_box
        cl, ct, cr, cb = crop_box
        iw, ih = self.image.size

        # compute the move of crop center onto important center
        move_horiz = (ib[0] + ib[2]) // 2 - (cl + cr) // 2
        move_verti = (ib[1] + ib[3]) // 2 - (ct + cb) // 2

        # make sure we don't get out of the image
        # ... horizontaly
        if move_horiz > 0:
            move_horiz = min(iw - cr, move_horiz)
        else:
            move_horiz = max(-cl, move_horiz)

        # .. and verticaly
        if move_verti > 0:
            move_verti = min(ih - cb, move_verti)
        else:
            move_verti = max(-ct, move_verti)

        # move the crop_box
        return (cl + move_horiz, ct + move_verti, cr + move_horiz, cb + move_verti)


    def crop_to_ratio(self):
        " Get crop coordinates and perform the crop if we get any. "
        crop_box = self.get_crop_box()

        if not crop_box:
            return

        crop_box = self.center_important_part(crop_box)

        iw, ih = self.image.size
        # see if we want to crop something from outside of the image
        out_of_photo = min(crop_box[0], crop_box[1]) < 0 or crop_box[2] > iw or crop_box[3] > ih
        # check whether there's transparent information in the image
        transparent = self.image.mode in ('RGBA', 'LA')

        if photos_settings.DEFAULT_BG_COLOR != 'black' and out_of_photo and not transparent:
            # if we do, just crop the image to the portion that will be visible
            updated_crop_box = (
                max(0, crop_box[0]), max(0, crop_box[1]), min(iw, crop_box[2]), min(ih, crop_box[3]),
            )
            cropped = self.image.crop(updated_crop_box)

            # create new image of the proper size and color
            self.image = Image.new('RGB', (crop_box[2] - crop_box[0], crop_box[3] - crop_box[1]), photos_settings.DEFAULT_BG_COLOR)
            # and paste the cropped part into it's proper position
            self.image.paste(cropped, (abs(min(crop_box[0], 0)), abs(min(crop_box[1], 0))))
        else:
            # crop normally if not the case
            self.image = self.image.crop(crop_box)
        return crop_box

    def get_resized_size(self):
        """
        Get target size for the stretched or shirnked image to fit within the
        target dimensions. Do not stretch images if not format.stretch.

        Note that this method is designed to operate on already cropped image.
        """
        f = self.fmt
        iw, ih = self.image.size

        if not f.stretch and iw <= self.fw and ih <= self.fh:
            return

        if self.image_ratio == self.format_ratio:
            # same ratio, just resize
            return (self.fw, self.fh)

        elif self.image_ratio < self.format_ratio:
            # image taller than format
            return (self.fh * iw / ih, self.fh)

        else: # self.image_ratio > self.format_ratio
            # image wider than format
            return (self.fw, self.fw * ih / iw)

    def resize(self):
        """
        Get target size for a cropped image and do the resizing if we got
        anything usable.
        """
        resized_size = self.get_resized_size()
        if not resized_size:
            return

        self.image = self.image.resize(resized_size, Image.ANTIALIAS)

    def rotate_exif(self):
        """
        Rotate image via exif information.
        Only 90, 180 and 270 rotations are supported.
        """
        exif = self.image._getexif() or {}
        rotation = exif.get(TAGS['Orientation'], 1)

        rotations = {
            6: -90,
            3: -180,
            8: -270,
        }
        if rotation not in rotations:
            return

        self.image = self.image.rotate(rotations[rotation])


########NEW FILE########
__FILENAME__ = check_photo_files_consistence
import re
import os
import sys
from optparse import make_option
from django.core.management.base import BaseCommand
from ella.photos.conf import photos_settings


class Command(BaseCommand):

    help = 'Check consistence between database records and coresponding image files'

    VERBOSITY_ERROR = 0
    VERBOSITY_WARNING = 1
    VERBOSITY_STAT = 1
    VERBOSITY_INFO = 2
    VERBOSITY_DEBUG = 3

    verbosity = VERBOSITY_STAT
    delete = False
    all = False
    extensions = None
    extensions_ic = True

    option_list = BaseCommand.option_list + (
        make_option('--delete',
            action='store_true',
            dest='delete',
            default=delete,
            help='Delete unlinked image files'),
        make_option('--all',
            action='store_true',
            dest='all',
            default=all,
            help='Delete all unlinked files'),
        make_option('--extensions',
            dest='extensions',
            default=extensions,
            help='Specify comma separated extensions (with ".") of photos'),
        make_option('--extensions-no-ignore-case',
            dest='extensions_ic',
            default=extensions_ic,
            help='Case sensitive comparation of extensions'),
        )

    def process_options(self, options):
        self.verbosity = int(options['verbosity'])
        self.delete = bool(options['delete'])
        self.all = bool(options['all'])
        self.extensions = options['extensions'] and options['extensions'].split(',')
        self.extensions_ic = options['extensions_ic']

    def print_message(self, message, level, fd=None):
        if level <= self.verbosity:
            if fd:
                try:
                    print >> fd, message
                except IOError:
                    pass
            else:
                print message

    def print_error(self, message):
        self.print_message(message, self.VERBOSITY_ERROR, sys.stderr)

    def print_warning(self, message):
        self.print_message(message, self.VERBOSITY_WARNING)

    def print_stat(self, message):
        self.print_message(message, self.VERBOSITY_STAT)

    def print_info(self, message):
        self.print_message(message, self.VERBOSITY_INFO)

    def print_debug(self, message):
        self.print_message(message, self.VERBOSITY_DEBUG)

    def handle(self, *args, **options):

        self.process_options(options)
        self.print_debug("Options: ")
        self.print_debug(options)

        subdir = re.sub(
            '[^('+re.escape(os.sep)+')]*%[^%].*',
            '',
            photos_settings.UPLOAD_TO
            ).strip(os.sep)

        from ella.photos.models import Photo
        storage = Photo().image.storage

        extensions = self.extensions or photos_settings.TYPE_EXTENSION.values()
        self.print_info('Accepted extensions: ' +str(extensions))
        photo_extension_re = re.compile(
                '(%s)$' % ('|'.join([re.escape(ex) for ex in extensions])),
                self.extensions_ic and re.IGNORECASE or 0)

        # breadth-first search
        files = []
        nodes = [subdir]
        while nodes:
            current = nodes.pop()
            self.print_debug("Entering directory '%s'" % current)
            current_dirs, current_files = storage.listdir(current)

            if not (current_dirs or current_files):
                self.print_info("Directory '%s' is empty" % current)
            else:
                nodes += [
                        '%s%s%s' % (current, os.sep, directory)
                        for directory in current_dirs]

                for current_file in current_files:
                    f = '%s%s%s' % (current, os.sep, current_file)
                    is_image = bool(photo_extension_re.search(current_file))
                    if not is_image:
                        self.print_info("File '%s' is not image" % f)
                    if is_image or self.all:
                        files.append(f)
                        self.print_debug("Appending file '%s'" % f)

            self.print_debug("Leaving directory '%s'" % current)

        photo_files_set = set(files)
        db_files_set = set([photo.image.url for photo in Photo.objects.all()])
        self.print_summarization(photo_files_set, db_files_set)

        if self.delete:
            self.delete_files(storage, photo_files_set -db_files_set)

    def print_summarization(self, photo_files_set, db_files_set):

        self.print_stat("Count of files on disk (selected extensions): %d"
                % len(photo_files_set))

        self.print_stat("Count of files in database (all extensions): %d"
                % len(db_files_set))

        only_in_database = db_files_set -photo_files_set
        self.print_info("Files only in database (all extensions):")
        self.print_info(only_in_database)
        self.print_stat("Count of files only in database (all extensions): %d"
                % len(only_in_database))

        only_on_disk = photo_files_set -db_files_set
        self.print_info("Files only on disk (selected extensions):")
        self.print_info(only_on_disk)
        self.print_stat("Count of files only on disk (selected extensions): %d"
                % len(only_on_disk))

        self.print_stat("Count of paired files (selected extensions): %d"
                % len(photo_files_set & db_files_set))


    def delete_files(self, storage, to_delete):
            for f in to_delete:
                self.print_info("Delete file '%s'" % f)
                storage.delete(f)
            self.print_stat("%d files are deleted" % len(to_delete))


########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):
    depends_on = (
        ('core', '0001_initial'),
    )


    def forwards(self, orm):
        
        # Adding model 'Photo'
        db.create_table('photos_photo', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('image', self.gf('django.db.models.fields.files.ImageField')(max_length=100)),
            ('width', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('height', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('important_top', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('important_left', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('important_bottom', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('important_right', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('source', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.Source'], null=True, blank=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
        ))
        db.send_create_signal('photos', ['Photo'])

        # Adding M2M table for field authors on 'Photo'
        db.create_table('photos_photo_authors', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('photo', models.ForeignKey(orm['photos.photo'], null=False)),
            ('author', models.ForeignKey(orm['core.author'], null=False))
        ))
        db.create_unique('photos_photo_authors', ['photo_id', 'author_id'])

        # Adding model 'Format'
        db.create_table('photos_format', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=80)),
            ('max_width', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('max_height', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('flexible_height', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('flexible_max_height', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('stretch', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('nocrop', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('resample_quality', self.gf('django.db.models.fields.IntegerField')(default=85)),
        ))
        db.send_create_signal('photos', ['Format'])

        # Adding M2M table for field sites on 'Format'
        db.create_table('photos_format_sites', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('format', models.ForeignKey(orm['photos.format'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('photos_format_sites', ['format_id', 'site_id'])

        # Adding model 'FormatedPhoto'
        db.create_table('photos_formatedphoto', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('photo', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Photo'])),
            ('format', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Format'])),
            ('image', self.gf('django.db.models.fields.files.ImageField')(max_length=300)),
            ('crop_left', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('crop_top', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('crop_width', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('crop_height', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('width', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('height', self.gf('django.db.models.fields.PositiveIntegerField')()),
        ))
        db.send_create_signal('photos', ['FormatedPhoto'])

        # Adding unique constraint on 'FormatedPhoto', fields ['photo', 'format']
        db.create_unique('photos_formatedphoto', ['photo_id', 'format_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'FormatedPhoto', fields ['photo', 'format']
        db.delete_unique('photos_formatedphoto', ['photo_id', 'format_id'])

        # Deleting model 'Photo'
        db.delete_table('photos_photo')

        # Removing M2M table for field authors on 'Photo'
        db.delete_table('photos_photo_authors')

        # Deleting model 'Format'
        db.delete_table('photos_format')

        # Removing M2M table for field sites on 'Format'
        db.delete_table('photos_format_sites')

        # Deleting model 'FormatedPhoto'
        db.delete_table('photos_formatedphoto')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.format': {
            'Meta': {'ordering': "('name', '-max_width')", 'object_name': 'Format'},
            'flexible_height': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flexible_max_height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'max_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '80'}),
            'nocrop': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'resample_quality': ('django.db.models.fields.IntegerField', [], {'default': '85'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'stretch': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'photos.formatedphoto': {
            'Meta': {'unique_together': "(('photo', 'format'),)", 'object_name': 'FormatedPhoto'},
            'crop_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_left': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_top': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'format': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '300'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']"}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'photos.photo': {
            'Meta': {'ordering': "('-created',)", 'object_name': 'Photo'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['photos']

########NEW FILE########
__FILENAME__ = 0002_add_field_photo_app_data
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Photo.app_data'
        db.add_column('photos_photo', 'app_data', self.gf('app_data.fields.AppDataField')(default='{}', blank=True), keep_default=False)


    def backwards(self, orm):

        # Deleting field 'Photo.app_data'
        db.delete_column('photos_photo', 'app_data')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.format': {
            'Meta': {'object_name': 'Format'},
            'flexible_height': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flexible_max_height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'max_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '80'}),
            'nocrop': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'resample_quality': ('django.db.models.fields.IntegerField', [], {'default': '85'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'stretch': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'photos.formatedphoto': {
            'Meta': {'unique_together': "(('photo', 'format'),)", 'object_name': 'FormatedPhoto'},
            'crop_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_left': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_top': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'format': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '300'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']"}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['photos']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_photo_created__chg_field_photo_image
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Photo.created'
        db.alter_column('photos_photo', 'created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True))

        # Changing field 'Photo.image'
        db.alter_column('photos_photo', 'image', self.gf('django.db.models.fields.files.ImageField')(max_length=255))


    def backwards(self, orm):

        # Changing field 'Photo.created'
        db.alter_column('photos_photo', 'created', self.gf('django.db.models.fields.DateTimeField')())

        # Changing field 'Photo.image'
        db.alter_column('photos_photo', 'image', self.gf('django.db.models.fields.files.ImageField')(max_length=100))


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.format': {
            'Meta': {'object_name': 'Format'},
            'flexible_height': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flexible_max_height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'max_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '80'}),
            'nocrop': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'resample_quality': ('django.db.models.fields.IntegerField', [], {'default': '85'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'stretch': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'photos.formatedphoto': {
            'Meta': {'unique_together': "(('photo', 'format'),)", 'object_name': 'FormatedPhoto'},
            'crop_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_left': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_top': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'crop_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'format': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '300'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']"}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['photos']

########NEW FILE########
__FILENAME__ = 0004_auto__chg_field_formatedphoto_crop_top__chg_field_formatedphoto_crop_l
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Changing field 'FormatedPhoto.crop_top'
        db.alter_column('photos_formatedphoto', 'crop_top', self.gf('django.db.models.fields.IntegerField')())

        # Changing field 'FormatedPhoto.crop_left'
        db.alter_column('photos_formatedphoto', 'crop_left', self.gf('django.db.models.fields.IntegerField')())

        # Changing field 'FormatedPhoto.crop_width'
        db.alter_column('photos_formatedphoto', 'crop_width', self.gf('django.db.models.fields.IntegerField')())

        # Changing field 'FormatedPhoto.crop_height'
        db.alter_column('photos_formatedphoto', 'crop_height', self.gf('django.db.models.fields.IntegerField')())


    def backwards(self, orm):
        # Changing field 'FormatedPhoto.crop_top'
        db.alter_column('photos_formatedphoto', 'crop_top', self.gf('django.db.models.fields.PositiveIntegerField')())

        # Changing field 'FormatedPhoto.crop_left'
        db.alter_column('photos_formatedphoto', 'crop_left', self.gf('django.db.models.fields.PositiveIntegerField')())

        # Changing field 'FormatedPhoto.crop_width'
        db.alter_column('photos_formatedphoto', 'crop_width', self.gf('django.db.models.fields.PositiveIntegerField')())

        # Changing field 'FormatedPhoto.crop_height'
        db.alter_column('photos_formatedphoto', 'crop_height', self.gf('django.db.models.fields.PositiveIntegerField')())


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 5, 9, 18, 4, 23, 194942)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 5, 9, 18, 4, 23, 194845)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'profile': ('app_data.fields.AppDataField', [], {'default': "'{}'"}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.format': {
            'Meta': {'object_name': 'Format'},
            'flexible_height': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flexible_max_height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'max_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '80'}),
            'nocrop': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'resample_quality': ('django.db.models.fields.IntegerField', [], {'default': '85'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'stretch': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'photos.formatedphoto': {
            'Meta': {'unique_together': "(('photo', 'format'),)", 'object_name': 'FormatedPhoto'},
            'crop_height': ('django.db.models.fields.IntegerField', [], {}),
            'crop_left': ('django.db.models.fields.IntegerField', [], {}),
            'crop_top': ('django.db.models.fields.IntegerField', [], {}),
            'crop_width': ('django.db.models.fields.IntegerField', [], {}),
            'format': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '300'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']"}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['photos']

########NEW FILE########
__FILENAME__ = 0005_auto__add_field_format_master
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Format.master'
        db.add_column('photos_format', 'master', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['photos.Format'], null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Format.master'
        db.delete_column('photos_format', 'master_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 5, 29, 22, 14, 28, 853865)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 5, 29, 22, 14, 28, 853780)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'core.author': {
            'Meta': {'object_name': 'Author'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'core.source': {
            'Meta': {'object_name': 'Source'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'blank': 'True'})
        },
        'photos.format': {
            'Meta': {'object_name': 'Format'},
            'flexible_height': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'flexible_max_height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'master': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']", 'null': 'True', 'blank': 'True'}),
            'max_height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'max_width': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '80'}),
            'nocrop': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'resample_quality': ('django.db.models.fields.IntegerField', [], {'default': '85'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'stretch': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'photos.formatedphoto': {
            'Meta': {'unique_together': "(('photo', 'format'),)", 'object_name': 'FormatedPhoto'},
            'crop_height': ('django.db.models.fields.IntegerField', [], {}),
            'crop_left': ('django.db.models.fields.IntegerField', [], {}),
            'crop_top': ('django.db.models.fields.IntegerField', [], {}),
            'crop_width': ('django.db.models.fields.IntegerField', [], {}),
            'format': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Format']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '300'}),
            'photo': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['photos.Photo']"}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'photos.photo': {
            'Meta': {'object_name': 'Photo'},
            'app_data': ('app_data.fields.AppDataField', [], {'default': "'{}'", 'blank': 'True'}),
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'photo_set'", 'symmetrical': 'False', 'to': "orm['core.Author']"}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '255'}),
            'important_bottom': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_left': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_right': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'important_top': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['core.Source']", 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['photos']

########NEW FILE########
__FILENAME__ = models
import logging
from PIL import Image
from os import path
from cStringIO import StringIO
import os.path
import string

from django.db import models
from django.db.models import signals
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import force_unicode, smart_str
from django.contrib.sites.models import Site
from django.core.files.base import ContentFile
from django.conf import settings
from django.template.defaultfilters import slugify

from app_data import AppDataField

from ella.core.models.main import Author, Source
from ella.core.cache.utils import get_cached_object
from ella.photos.conf import photos_settings
from ella.utils.timezone import now

from formatter import Formatter

__all__ = ("Format", "FormatedPhoto", "Photo")

log = logging.getLogger('ella.photos')

redis = None
REDIS_PHOTO_KEY = 'photo:%s'
REDIS_FORMATTED_PHOTO_KEY = 'photo:%s:%s'

if hasattr(settings, 'PHOTOS_REDIS'):
    try:
        from redis import Redis
    except:
        log.error('Redis support requested but Redis client not installed.')
        redis = None
    else:
        redis = Redis(**getattr(settings, 'PHOTOS_REDIS'))


def upload_to(instance, filename):
    name, ext = os.path.splitext(filename)
    if instance.slug:
        name = instance.slug
    ext = photos_settings.TYPE_EXTENSION.get(instance._get_image().format, ext.lower())
    instance.image.file.seek(0)

    return os.path.join(
        force_unicode(now().strftime(smart_str(photos_settings.UPLOAD_TO))),
        name + ext
    )


class Photo(models.Model):
    """
    Represents original (unformated) photo uploaded by user. Used as source
    object for all the formatting stuff and to keep the metadata common to
    all related ``FormatedPhoto`` objects.
    """
    title = models.CharField(_('Title'), max_length=200)
    description = models.TextField(_('Description'), blank=True)
    slug = models.SlugField(_('Slug'), max_length=255)
    # save it to YYYY/MM/DD structure
    image = models.ImageField(_('Image'), upload_to=upload_to,
        max_length=255, height_field='height', width_field='width')
    width = models.PositiveIntegerField(editable=False)
    height = models.PositiveIntegerField(editable=False)

    # important area
    important_top = models.PositiveIntegerField(null=True, blank=True)
    important_left = models.PositiveIntegerField(null=True, blank=True)
    important_bottom = models.PositiveIntegerField(null=True, blank=True)
    important_right = models.PositiveIntegerField(null=True, blank=True)

    # Authors and Sources
    authors = models.ManyToManyField(Author, verbose_name=_('Authors'), related_name='photo_set')
    source = models.ForeignKey(Source, blank=True, null=True, verbose_name=_('Source'), on_delete=models.SET_NULL)

    created = models.DateTimeField(auto_now_add=True)

    # generic JSON field to store app cpecific data
    app_data = AppDataField()

    class Meta:
        verbose_name = _('Photo')
        verbose_name_plural = _('Photos')

    def __unicode__(self):
        return self.title

    def get_absolute_url(self):
        return self.image.url

    def get_image_info(self):
        return {
            'url': self.image.url,
            'width': self.width,
            'height': self.height,
        }

    def _get_image(self):
        if not hasattr(self, '_pil_image'):
            self.image.open()
            self._pil_image = Image.open(self.image)
        return self._pil_image

    def save(self, **kwargs):
        """Overrides models.Model.save.

        - Generates slug.
        - Saves image file.
        """
        if not self.width or not self.height:
            self.width, self.height = self.image.width, self.image.height

        # prefill the slug with the ID, it requires double save
        if not self.id:
            img = self.image

            # store dummy values first...
            w, h = self.width, self.height
            self.image = ''
            self.width, self.height = w, h
            self.slug = ''

            super(Photo, self).save(force_insert=True)

            # ... so that we can generate the slug
            self.slug = str(self.id) + '-' + slugify(self.title)
            # truncate slug in order to fit in an ImageField and/or paths in Redirects
            self.slug = self.slug[:64]
            # .. tha will be used in the image's upload_to function
            self.image = img
            # and the image will be saved properly
            super(Photo, self).save(force_update=True)
        else:
            try:
                old = Photo.objects.get(pk=self.pk)

                force_update = True
                # delete formatedphotos if new image was uploaded
                if old.image != self.image:
                    for f_photo in self.formatedphoto_set.all():
                        f_photo.delete()
            except Photo.DoesNotExist:
                # somebody is just trying to create new model with given PK
                force_update = False

            super(Photo, self).save(force_update=force_update)

    def ratio(self):
        "Return photo's width to height ratio"
        if self.height:
            return float(self.width) / self.height
        else:
            return None

    def get_formated_photo(self, format):
        "Return formated photo"
        return FormatedPhoto.objects.get_photo_in_format(self, format)


FORMAT_CACHE = {}


class FormatManager(models.Manager):
    def get_for_name(self, name):
        try:
            return FORMAT_CACHE[name]
        except KeyError:
            FORMAT_CACHE[name] = format = get_cached_object(Format, name=name, sites__id=settings.SITE_ID)
        return format


class Format(models.Model):
    """
    Defines per-site photo sizes together with rules how to adhere to them.

    This includes:

    * maximum width and height
    * cropping settings
    * stretch (rescale) settings
    * sample quality
    """
    name = models.CharField(_('Name'), max_length=80)
    max_width = models.PositiveIntegerField(_('Max width'))
    max_height = models.PositiveIntegerField(_('Max height'))
    flexible_height = models.BooleanField(_('Flexible height'), help_text=_((
        'Determines whether max_height is an absolute maximum, or the formatted'
        'photo can vary from max_height to flexible_max_height.')))
    flexible_max_height = models.PositiveIntegerField(_('Flexible max height'),
        blank=True, null=True)
    stretch = models.BooleanField(_('Stretch'))
    nocrop = models.BooleanField(_('Do not crop'))
    resample_quality = models.IntegerField(_('Resample quality'),
        choices=photos_settings.FORMAT_QUALITY, default=85)
    sites = models.ManyToManyField(Site, verbose_name=_('Sites'))
    master = models.ForeignKey('self', verbose_name=_('Master'), null=True, blank=True, help_text=_((
        'When generating formatted image, use the image formatted to master format instead of the original.'
        'Useful when editors crop certain formats by hand and you wish to re-use those coordinates automatically.'
    )))

    objects = FormatManager()

    class Meta:
        verbose_name = _('Format')
        verbose_name_plural = _('Formats')

    def __unicode__(self):
        return  u"%s (%sx%s) " % (self.name, self.max_width, self.max_height)

    def get_blank_img(self):
        """
        Return fake ``FormatedPhoto`` object to be used in templates when an error
        occurs in image generation.
        """
        if photos_settings.DEBUG:
            return self.get_placeholder_img()

        out = {
            'blank': True,
            'width': self.max_width,
            'height': self.max_height,
            'url': photos_settings.EMPTY_IMAGE_SITE_PREFIX + 'img/empty/%s.png' % (self.name),
        }
        return out

    def get_placeholder_img(self):
        """
        Returns fake ``FormatedPhoto`` object grabbed from image placeholder
        generator service for the purpose of debugging when images
        are not available but we still want to see something.
        """
        pars = {
            'width': self.max_width,
            'height': self.max_height
        }
        out = {
            'placeholder': True,
            'width': self.max_width,
            'height': self.max_height,
            'url': photos_settings.DEBUG_PLACEHOLDER_PROVIDER_TEMPLATE % pars
        }
        return out

    def ratio(self):
        """Return photo's width to height ratio"""
        return float(self.max_width) / self.max_height

    def save(self, **kwargs):
        """Overrides models.Model.save.

        - Delete formatted photos if format save and not now created
          (because of possible changes)
        """

        if self.id:
            for f_photo in self.formatedphoto_set.all():
                f_photo.delete()

        super(Format, self).save(**kwargs)


class FormatedPhotoManager(models.Manager):
    def get_photo_in_format(self, photo, format, include_original=True):
        if isinstance(photo, Photo):
            photo_id = photo.id
        else:
            photo_id = photo
            photo = None

        if not isinstance(format, Format):
            format = Format.objects.get_for_name(format)

        if redis:
            p = redis.pipeline()
            p.hgetall(REDIS_PHOTO_KEY % photo_id)
            p.hgetall(REDIS_FORMATTED_PHOTO_KEY % (photo_id, format.id))
            original, formatted = p.execute()
            if formatted:
                if include_original:
                    formatted['original'] = original
                return formatted

        if not photo:
            try:
                photo = get_cached_object(Photo, pk=photo_id)
            except Photo.DoesNotExist:
                return format.get_blank_img()

        try:
            formated_photo = get_cached_object(FormatedPhoto, photo=photo, format=format)
        except FormatedPhoto.DoesNotExist:
            try:
                # use get or create because there is a possible race condition here
                # we don't want to JUST use get_or_create to go through cache 99.9% of the time
                formated_photo, _ = self.get_or_create(photo=photo, format=format)
            except (IOError, SystemError), e:
                log.warning("Cannot create formatted photo due to %s.", e)
                return format.get_blank_img()

        info = {
            'url': formated_photo.url,
            'width': formated_photo.width,
            'height': formated_photo.height,
        }
        if include_original:
            info['original'] = photo.get_image_info()

        return info


class FormatedPhoto(models.Model):
    """
    Cache-like container of specific photo of specific format. Besides
    the path to the generated image file, crop used is also stored together
    with new ``width`` and ``height`` attributes.
    """
    photo = models.ForeignKey(Photo)
    format = models.ForeignKey(Format)
    # save it to YYYY/MM/DD structure
    image = models.ImageField(upload_to=photos_settings.UPLOAD_TO,
        height_field='height', width_field='width', max_length=300)
    crop_left = models.IntegerField()
    crop_top = models.IntegerField()
    crop_width = models.IntegerField()
    crop_height = models.IntegerField()
    width = models.PositiveIntegerField(editable=False)
    height = models.PositiveIntegerField(editable=False)

    objects = FormatedPhotoManager()

    class Meta:
        verbose_name = _('Formated photo')
        verbose_name_plural = _('Formated photos')
        unique_together = (('photo', 'format'),)

    def __unicode__(self):
        return u"%s - %s" % (self.photo, self.format)

    @property
    def url(self):
        "Returns url of the photo file."
        return self.image.url

    def _generate_img(self):
        crop_box = None
        if self.crop_left:
            crop_box = (self.crop_left, self.crop_top, \
                    self.crop_left + self.crop_width, self.crop_top + self.crop_height)

        important_box = None
        if self.photo.important_top is not None:
            p = self.photo
            important_box = (p.important_left, p.important_top, p.important_right, p.important_bottom)

        image = None
        if crop_box is None and self.format.master_id:
            try:
                fp = FormatedPhoto.objects.get(format=self.format.master_id, photo=self.photo)
                image = Image.open(fp.image)
            except FormatedPhoto.DoesNotExist:
                pass

        if image is None:
            image = self.photo._get_image()
        formatter = Formatter(image, self.format, crop_box=crop_box, important_box=important_box)

        return formatter.format()

    def generate(self, save=True):
        """
        Generates photo file in current format.

        If ``save`` is ``True``, file is saved too.
        """
        stretched_photo, crop_box = self._generate_img()

        # set crop_box to (0,0,0,0) if photo not cropped
        if not crop_box:
            crop_box = 0, 0, 0, 0

        self.crop_left, self.crop_top, right, bottom = crop_box
        self.crop_width = right - self.crop_left
        self.crop_height = bottom - self.crop_top

        self.width, self.height = stretched_photo.size

        f = StringIO()
        imgf = (self.photo._get_image().format or
                Image.EXTENSION[path.splitext(self.photo.image.name)[1]])

        stretched_photo.save(f, format=imgf, quality=self.format.resample_quality)
        f.seek(0)

        self.image.save(self.file(), ContentFile(f.read()), save)

    def save(self, **kwargs):
        """Overrides models.Model.save

        - Removes old file from the FS
        - Generates new file.
        """
        self.remove_file()
        if not self.image:
            self.generate(save=False)
        else:
            self.image.name = self.file()
        super(FormatedPhoto, self).save(**kwargs)

    def delete(self):
        try:
            self.remove_file()
        except:
            log.warning('Error deleting FormatedPhoto %d-%s (%s).', self.photo_id, self.format.name, self.image.name)

        super(FormatedPhoto, self).delete()

    def remove_file(self):
        if self.image.name:
            self.image.delete()

    def file(self):
        """ Method returns formated photo path - derived from format.id and source Photo filename """
        if photos_settings.FORMATED_PHOTO_FILENAME is not None:
            return photos_settings.FORMATED_PHOTO_FILENAME(self)
        source_file = path.split(self.photo.image.name)
        return path.join(source_file[0], str(self.format.id) + '-' + source_file[1])

if redis:
    def store_photo(instance, **kwargs):
        if instance.image:
            redis.hmset(REDIS_PHOTO_KEY % instance.pk, instance.get_image_info())

    def remove_photo(instance, **kwargs):
        redis.delete(REDIS_PHOTO_KEY % instance.id)

    def store_formated_photo(instance, **kwargs):
        redis.hmset(
            REDIS_FORMATTED_PHOTO_KEY % (instance.photo_id, instance.format.id),
            {
                'url': instance.url,
                'width': instance.width,
                'height': instance.height,
            }
        )

    def remove_formated_photo(instance, **kwargs):
        redis.delete(REDIS_FORMATTED_PHOTO_KEY % (instance.photo_id, instance.format.id))

    signals.post_save.connect(store_photo, sender=Photo)
    signals.post_delete.connect(remove_photo, sender=Photo)
    signals.post_save.connect(store_formated_photo, sender=FormatedPhoto)
    signals.post_delete.connect(remove_formated_photo, sender=FormatedPhoto)

########NEW FILE########
__FILENAME__ = newman_admin
from django.conf.urls.defaults import patterns, url
from django.contrib.admin import helpers
from django.contrib.admin.util import flatten_fieldsets
from django.contrib.csrf.middleware import csrf_exempt
from django.contrib.sites.models import Site
from django.forms.models import modelform_factory
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.utils.functional import curry
from django.utils.translation import ugettext_lazy as _

import ella_newman as newman

from ella.photos.models import FormatedPhoto, Format, Photo
from ella_newman.utils import JsonResponse, JsonResponseError
from ella_newman.conf import newman_settings
from ella_newman.filterspecs import CustomFilterSpec

from django import forms

# Flash image uploader / editor
CSS_UPLOADIFY_LIB = 'css/uploadify.css'
JS_SWFOBJECT = 'js/swfobject.js'
JS_UPLOADIFY_LIB = 'js/jquery.uploadify.min.js'
SWF_FLASH_UPLOADER = 'swf/uploadify.swf'


class MassUploadForm(forms.ModelForm):
    image_file = forms.ImageField(label=_('Image files'))


    class Media:
        js = (
            newman_settings.MEDIA_PREFIX + JS_SWFOBJECT,
            newman_settings.MEDIA_PREFIX + JS_UPLOADIFY_LIB,
            newman_settings.MEDIA_PREFIX + SWF_FLASH_UPLOADER,
            )
        css = {
            'screen': (newman_settings.MEDIA_PREFIX + CSS_UPLOADIFY_LIB,),
        }


    class Meta:
        model = Photo
        exclude = (
            'image', 'important_top', 'important_left', 'important_bottom',
            'important_right')


class PhotoSizeFilter(CustomFilterSpec):
    lookup_w = 'width'
    lookup_h = 'height'

    def title(self):
        return _('Size')

    def get_lookup_kwarg(self):
        return [
            '%s__gt' % self.lookup_w,
            '%s__gt' % self.lookup_h
        ]

    def filter_func(self):
        for size in (100, 150, 200, 300, 500, 600, 700, 800):
            lookup_dict = {
                '%s__gt' % self.lookup_w: size,
                '%s__gt' % self.lookup_h: size
            }
            link_txt = "> %s" % size
            link = (link_txt, lookup_dict)
            self.links.append(link)
        return True

    def generate_choice(self, **lookup_kwargs):
        keys = self.get_lookup_kwarg()
        for key in keys:
            if key in lookup_kwargs:
                return u'>%spx' % lookup_kwargs[key]


class FormatAdmin(newman.NewmanModelAdmin):
    list_display = (
        'name', 'max_width', 'max_height', 'stretch', 'resample_quality',)
    list_filter = ('sites', 'stretch', 'nocrop', 'flexible_height',)
    search_fields = ('name',)


class FormatedPhotoInlineAdmin(newman.NewmanTabularInline):
    model = FormatedPhoto


class PhotoAdmin(newman.NewmanModelAdmin):
    list_display = ('title', 'size', 'thumb', 'pk',)
    list_filter = ('created',)
    unbound_list_filter = (PhotoSizeFilter,)
    search_fields = ('title', 'slug', 'id',)
    suggest_fields = {'authors': ('name', 'slug',),
                      'source': ('name', 'url',)}
    rich_text_fields = {'small': ('description',)}

    fieldsets = (
        (_("Heading"), {'fields': ('title',)}),
        (_("Description"), {'fields': ('description',)}),
        (_("Metadata"), {'fields': ('authors', 'source', 'image',)}),
        (_("Important area"), {'fields': (
            ('important_top', 'important_right'),
            ('important_bottom', 'important_left'),), 'classes': ('collapsed',)})
        )
    mass_upload_fieldsets = (
        (_("Heading"), {'fields': ('title',)}),
        (_("Description"), {'fields': ('description',)}),
        (_("Metadata"), {'fields': ('authors', 'source', 'image_file')}),
        )
    mass_upload2_fieldsets = (
        (_("Image Data"),
         {'fields': ('title', 'description', 'authors', 'source')}),
        )

    def size(self, obj):
        return "%dx%d px" % (obj.width, obj.height)

    size.short_description = _('Size')


    def thumb(self, obj):
        """
        Generates html and thumbnails for admin site.
        """
        format, created = Format.objects.get_or_create(name='newman_thumb',
                                                       defaults={
            'max_width': 100,
            'max_height': 100,
            'flexible_height': False,
            'stretch': False,
            'nocrop': True,
        })

        if created:
            format.sites = Site.objects.all()

        info = obj.get_formated_photo(format)

        return '<a href="%(href)s"><img src="%(src)s"></a>' % {
            'href': '%s/' % obj.pk,
            'src': info['url']
        }
    thumb.allow_tags = True


    def get_urls(self):
        urlpatterns = patterns('',
                               url(r'^(\d+)/thumb/$', self.json_photo_info,
                                   name='photo-json-info'),
                               url(r'^mass-upload/upload-file/$',
                                   self.upload_file_view,
                                   name='photo-mass-upload-file'),
                               url(r'^mass-upload/$', self.mass_upload_view,
                                   name='photo-mass-upload'),
        )
        urlpatterns += super(PhotoAdmin, self).get_urls()
        return urlpatterns

    def json_photo_info(self, request, object_id, extra_context=None):
        from ella_newman.conf import PHOTOS_THUMB_FORMAT

        obj = self.get_change_view_object(object_id)

        if obj is None:
            return JsonResponseError(
                _('Photo id %s does not exists.') % object_id,
                status=newman_settings.STATUS_OBJECT_NOT_FOUND)

        out = {
            'title': obj.title,
            'thumb_url': obj.get_formated_photo(PHOTOS_THUMB_FORMAT)['url']
        }

        return JsonResponse('', out)

    def get_mass_upload_context(self, request):
        model = self.model
        opts = model._meta
        self.register_newman_variables(request)

        # To enable admin-specific fields, we need to run the form class
        # through modelform_factory using curry
        FormClass = modelform_factory(Photo, form=MassUploadForm,
                                      fields=flatten_fieldsets(
                                          self.mass_upload_fieldsets),
                                      formfield_callback=curry(
                                          self.formfield_for_dbfield,
                                          request=request)
        )

        context = {}
        if request.method == 'POST':
            error_dict = {}
            # Unfortunately, FLASH uploader sends array data in weird format
            # so that Django doesn't recognize it as array of values, but
            # as one string with commas inside. The only way to expect it
            # and preprocess the values by ourselves.
            data = dict((key, val) for key, val in request.POST.items())
            form = FormClass(data, request.FILES)

            if form.is_valid():
                # To prevent newman from handling our field by common flash editor
                # we need to use a different mechanism
                new_object = form.save(commit=False)
                new_object.image = form.cleaned_data['image_file']
                new_object.save()
                form.save_m2m()
                context.update({'object': new_object})
            else:
                for e in form.errors:
                    error_dict[u"id_%s" % e] = [u"%s" % ee for ee in
                                                form.errors[e]]
                context.update({'error_dict': error_dict})
        else:
            form = FormClass()

        adminForm = helpers.AdminForm(form, list(self.mass_upload_fieldsets), self.prepopulated_fields)
        massUploadForm = helpers.AdminForm(form, list(self.mass_upload2_fieldsets), self.prepopulated_fields)
        media = self.media + adminForm.media

        context.update({
            'title': _('Mass upload'),
            'adminform': adminForm,
            'mass_upload2_form': massUploadForm,
            'is_popup': request.REQUEST.has_key('_popup'),
            'show_delete': False,
            'media': media,
            'inline_admin_formsets': [],
            'errors': helpers.AdminErrorList(form, ()),
            'root_path': self.admin_site.root_path,
            'app_label': opts.app_label,
            'opts': opts,
            'has_change_permission': self.has_change_permission(request,
                                                                None),
            'raw_form': form
        })
        return context

    @csrf_exempt    # as long as we don't use multipart for fileupload, no chance to send CSRF token along
    def upload_file_view(self, request):
        context = self.get_mass_upload_context(request)
        if 'error_dict' in context:
            return self.json_error_response(request, context)
        else:
            obj = context['object']
            return JsonResponse('', {'object_id': obj.id,
                                     'object_title': obj.title})

    def mass_upload_view(self, request):
        context = self.get_mass_upload_context(request)
        return render_to_response('newman/photos/photo/mass_upload.html',
            context, context_instance=RequestContext(request,
                                                     current_app=self.admin_site.name)
        )


class FormatedPhotoAdmin(newman.NewmanModelAdmin):
    list_display = ('image', 'format', 'width', 'height')
    list_filter = ('format',)
    search_fields = ('image',)
    raw_id_fields = ('photo',)


newman.site.register(Format, FormatAdmin)
newman.site.register(Photo, PhotoAdmin)
newman.site.register(FormatedPhoto, FormatedPhotoAdmin)

########NEW FILE########
__FILENAME__ = photos
import logging

from django import template
from django.conf import settings

from ella.photos.models import Photo, Format, FormatedPhoto
from ella.core.cache.utils import get_cached_object

log = logging.getLogger('ella.photos')

register = template.Library()

class ImageTag(template.Node):
    #{% image <photo_variable> in "format" as foobar %}
    def __init__(self, format, photo, var_name):
        self.format, self.photo, self.var_name = format, photo, var_name

    def render(self, context):
        if isinstance(self.format, template.Variable):
            try:
                format = self.format.resolve(context)
                if isinstance(format, basestring):
                    format = Format.objects.get_for_name(format)
            except (template.VariableDoesNotExist, Format.DoesNotExist):
                context[self.var_name] = None
                return ''
        else:
            format = self.format

        try:
            # try retrieving just the ID first to avoid DB lookup
            photo = template.Variable(self.photo + '_id').resolve(context)
        except template.VariableDoesNotExist:
            try:
                photo = template.Variable(self.photo).resolve(context)
            except template.VariableDoesNotExist:
                context[self.var_name] = None
                return ''

        formated_photo = FormatedPhoto.objects.get_photo_in_format(photo, format)
        context[self.var_name] = formated_photo
        return ''

def _parse_image(bits):
    if len(bits) != 6 or bits[2] != 'in' or bits[4] != 'as':
        raise template.TemplateSyntaxError('{% image <photo_variable> in "format" as foobar %}')

    format = template.Variable(bits[3])
    if format.literal is not None:
        try:
            format = Format.objects.get_for_name(format.literal)
        except Format.DoesNotExist:
            logmsg = "Format with name %r does not exist (for site id %d)" % (format.literal, settings.SITE_ID)
            log.error(logmsg)

            if not settings.TEMPLATE_DEBUG:
                return template.Node()

            raise template.TemplateSyntaxError(logmsg)

    return ImageTag(format, bits[1], bits[5])

@register.tag
def image(parser, token):
    """

    Generates thumbnails for ``Photo`` instances.

    syntax::

        {% image <photo> in <format> as <var_name> %}

    examples::

        {% image article.photo in "thumbnail" as thumb %}
        {% image article.photo in thumb_format as thumb %}

    """
    bits = token.split_contents()
    return _parse_image(bits)

class ImgTag(template.Node):
    def __init__(self, photo, format, var_name):
        self.photo, self.format, self.var_name = photo, format, var_name

    def render(self, context):
        if isinstance(self.photo, basestring):
            try:
                # try retrieving just the ID first to avoid DB lookup
                photo = template.Variable(self.photo + '_id').resolve(context)
            except template.VariableDoesNotExist:
                try:
                    photo = template.Variable(self.photo).resolve(context)
                except template.VariableDoesNotExist:
                    context[self.var_name] = None
                    return ''

            if not photo:
                context[self.var_name] = None
                return ''

            formated_photo = FormatedPhoto.objects.get_photo_in_format(photo, self.format)
        else:
            formated_photo = self.photo

        context[self.var_name] = formated_photo
        return ''

@register.tag
def img(parser, token):
    """

    Deprecated, use {% image %} instead. Generates thumbnails for ``Photo`` instances.

    syntax::

        {% img <format> for <var> as <var_name> %}
        {% img <format> with <field_value> as <var_name> %} 

    examples::

        {% img category_listing for object.photo as thumb %}
        {% img category_listing with pk 1150 as thumb %}

    """
    log.warning('You are using the deprecated {% img %} tag. please upgrade to {% image %}.')
    bits = token.split_contents()
    return _parse_img(bits)

def _parse_img(bits, legacy=True):
    if len(bits) < 2 or bits[-2] != 'as':
        raise template.TemplateSyntaxError, "{% img FORMAT for VAR as VAR_NAME %} or {% img FORMAT with FIELD VALUE as VAR_NAME %}"

    try:
        format = Format.objects.get_for_name(bits[1])
    except Format.DoesNotExist:
        logmsg = "Format with name %r does not exist (for site id %d)" % (bits[1], settings.SITE_ID)
        log.error(logmsg)

        if not settings.TEMPLATE_DEBUG:
            return template.Node()

        raise template.TemplateSyntaxError(logmsg)

    if len(bits) == 6:
        # img FORMAT for VAR_NAME
        if bits[2] != 'for':
            raise template.TemplateSyntaxError, "{% img FORMAT for VAR as VAR_NAME %}"
        formated_photo = bits[3]
    elif len(bits) == 7:
        # img FORMAT with FIELD VALUE
        if bits[2] != 'with':
            raise template.TemplateSyntaxError, "{% img FORMAT with FIELD VALUE as VAR_NAME %}"
        try:
            photo = get_cached_object(Photo, **{str(bits[3]) : bits[4]})
        except photo.DoesNotExist:
            raise template.TemplateSyntaxError, "Photo with %r of %r does not exist" % (bits[3], bits[4])

        formated_photo = FormatedPhoto.objects.get_photo_in_format(photo, format)
    else:
        raise template.TemplateSyntaxError, "{% img FORMAT for VAR as VAR_NAME %} or {% img FORMAT with FIELD VALUE as VAR_NAME %}"

    return ImgTag(formated_photo, format, bits[-1])


########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext, ugettext_lazy as _

from ella.positions.models import Position
from ella.utils import timezone


class PositionOptions(admin.ModelAdmin):
    def show_title(self, obj):
        if not obj.target:
            return '-- %s --' % ugettext('empty position')
        else:
            return u'%s [%s]' % (
                getattr(obj.target, 'title', obj.target),
                ugettext(obj.target_ct.name),
            )
    show_title.short_description = _('Title')

    def is_filled(self, obj):
        if obj.target:
            return True
        else:
            return False
    is_filled.short_description = _('Filled')
    is_filled.boolean = True

    def is_active(self, obj):
        if obj.disabled:
            return False
        now = timezone.now()
        active_from = not obj.active_from or obj.active_from <= now
        active_till = not obj.active_till or obj.active_till > now
        return active_from and active_till
    is_active.short_description = _('Active')
    is_active.boolean = True

    list_display = ('name', 'category', 'box_type', 'is_active', 'is_filled', 'show_title', 'disabled',)
    list_filter = ('category', 'name', 'disabled', 'active_from', 'active_till',)
    search_fields = ('box_type', 'text',)

#    suggest_fields = {'category': ('tree_path', 'title', 'slug',),}

admin.site.register(Position, PositionOptions)


########NEW FILE########
__FILENAME__ = 0001_initial

from south.db import db
from django.db import models
from ella.positions.models import *

class Migration:
    
    depends_on = (
        ("core", "0001_initial"),
    )
 
    def forwards(self, orm):
        
        # Adding model 'Position'
        db.create_table('positions_position', (
            ('id', models.AutoField(primary_key=True)),
            ('category', models.ForeignKey(orm['core.Category'], verbose_name=_('Category'))),
            ('name', models.CharField(_('Name'), max_length=200)),
            ('target_ct', models.ForeignKey(orm['contenttypes.ContentType'], null=True, verbose_name=_('Target content type'), blank=True)),
            ('target_id', models.PositiveIntegerField(_('Target id'), null=True, blank=True)),
            ('active_from', models.DateTimeField(_('Position active from'), null=True, blank=True)),
            ('active_till', models.DateTimeField(_('Position active till'), null=True, blank=True)),
            ('box_type', models.CharField(_('Box type'), max_length=200, blank=True)),
            ('text', models.TextField(_('Definition'), blank=True)),
            ('disabled', models.BooleanField(_('Disabled'), default=False)),
        ))
        db.send_create_signal('positions', ['Position'])
        
    
    
    def backwards(self, orm):
        
        # Deleting model 'Position'
        db.delete_table('positions_position')
        
    
    
    models = {
        'core.category': {
            'Meta': {'ordering': "('site','tree_path',)", 'unique_together': "(('site','tree_path'),)"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label','model'),)", 'db_table': "'django_content_type'"},
            '_stub': True,
            'id': ('models.AutoField', [], {'primary_key': 'True'})
        },
        'positions.position': {
            'active_from': ('models.DateTimeField', ["_('Position active from')"], {'null': 'True', 'blank': 'True'}),
            'active_till': ('models.DateTimeField', ["_('Position active till')"], {'null': 'True', 'blank': 'True'}),
            'box_type': ('models.CharField', ["_('Box type')"], {'max_length': '200', 'blank': 'True'}),
            'category': ('models.ForeignKey', ["orm['core.Category']"], {'verbose_name': "_('Category')"}),
            'disabled': ('models.BooleanField', ["_('Disabled')"], {'default': 'False'}),
            'id': ('models.AutoField', [], {'primary_key': 'True'}),
            'name': ('models.CharField', ["_('Name')"], {'max_length': '200'}),
            'target_ct': ('models.ForeignKey', ["orm['contenttypes.ContentType']"], {'null': 'True', 'verbose_name': "_('Target content type')", 'blank': 'True'}),
            'target_id': ('models.PositiveIntegerField', ["_('Target id')"], {'null': 'True', 'blank': 'True'}),
            'text': ('models.TextField', ["_('Definition')"], {'blank': 'True'})
        }
    }
    
    complete_apps = ['positions']

########NEW FILE########
__FILENAME__ = models
import logging

from django.utils.translation import ugettext_lazy as _
from django.db import models
from django.db.models import Q
from django.template import Template, TemplateSyntaxError
from django.core.exceptions import ValidationError

from ella.core.box import Box
from ella.core.cache import cache_this, CachedGenericForeignKey, \
    CategoryForeignKey, ContentTypeForeignKey, get_cached_object
from ella.utils import timezone


log = logging.getLogger('ella.positions.models')


def get_position_key(self, category, name, nofallback=False):
    return 'positions:%d:%s:%s' % (
            category.pk, name, nofallback and '1' or '0'
    )


class PositionManager(models.Manager):
    @cache_this(get_position_key)
    def get_active_position(self, category, name, nofallback=False):
        """
        Get active position for given position name.

        params:
            category - Category model to look for
            name - name of the position
            nofallback - if True than do not fall back to parent
                        category if active position is not found for category
        """
        now = timezone.now()
        lookup = (Q(active_from__isnull=True) | Q(active_from__lte=now)) & \
                 (Q(active_till__isnull=True) | Q(active_till__gt=now))

        while True:
            try:
                return self.get(lookup, category=category, name=name,
                    disabled=False)
            except Position.DoesNotExist:
                # if nofallback was specified, do not look into parent categories
                if nofallback:
                    return False

                # traverse the category tree to the top otherwise
                category = category.tree_parent

                # we reached the top and still haven't found the position - return
                if category is None:
                    return False


def PositionBox(position, *args, **kwargs):
    " Delegate the boxing. "
    obj = position.target
    return getattr(position.target, 'box_class', Box)(obj, *args, **kwargs)


class Position(models.Model):
    """
    Represents a position -- a placeholder -- on a page belonging to a certain
    category.
    """
    box_class = staticmethod(PositionBox)

    name = models.CharField(_('Name'), max_length=200)
    category = CategoryForeignKey(verbose_name=_('Category'))

    target_ct = ContentTypeForeignKey(verbose_name=_('Target content type'),
        null=True, blank=True)
    target_id = models.PositiveIntegerField(_('Target id'), null=True, blank=True)
    target = CachedGenericForeignKey('target_ct', 'target_id')
    text = models.TextField(_('Definition'), blank=True)
    box_type = models.CharField(_('Box type'), max_length=200, blank=True)

    active_from = models.DateTimeField(_('Position active from'), null=True,
        blank=True)
    active_till = models.DateTimeField(_('Position active till'), null=True,
        blank=True)
    disabled = models.BooleanField(_('Disabled'), default=False)

    objects = PositionManager()

    class Meta:
        verbose_name = _('Position')
        verbose_name_plural = _('Positions')

    def clean(self):
        if not self.category or not self.name:
            return

        if self.target_ct:
            try:
                get_cached_object(self.target_ct, pk=self.target_id)
            except self.target_ct.model_class().DoesNotExist:
                raise ValidationError(_('This position doesn\'t point to a valid object.'))

        qset = Position.objects.filter(category=self.category, name=self.name)

        if self.pk:
            qset = qset.exclude(pk=self.pk)

        if self.active_from:
            qset = qset.exclude(active_till__lte=self.active_from)

        if self.active_till:
            qset = qset.exclude(active_from__gt=self.active_till)

        if qset.count():
            raise ValidationError(_('There already is a postion for %(cat)s named %(name)s fo this time.') % {'cat': self.category, 'name': self.name})

    def __unicode__(self):
        return u'%s:%s' % (self.category, self.name)

    def render(self, context, nodelist, box_type):
        " Render the position. "
        if not self.target:
            if self.target_ct:
                # broken Generic FK:
                log.warning('Broken target for position with pk %r', self.pk)
                return ''
            try:
                return Template(self.text, name="position-%s" % self.name).render(context)
            except TemplateSyntaxError:
                log.error('Broken definition for position with pk %r', self.pk)
                return ''

        if self.box_type:
            box_type = self.box_type
        if self.text:
            nodelist = Template('%s\n%s' % (nodelist.render({}), self.text),
                name="position-%s" % self.name).nodelist

        b = self.box_class(self, box_type, nodelist)
        return b.render(context)

########NEW FILE########
__FILENAME__ = newman_admin
from datetime import datetime

from django import template
from django.conf.urls.defaults import patterns, url
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext_lazy as _, ugettext
from django.shortcuts import render_to_response
from django.contrib.admin import helpers
from django.contrib.contenttypes.models import ContentType

import ella_newman as newman

from ella_newman.utils import JsonResponse
from ella.positions.models import Position
from ella.core.models import Category
from django.forms.models import ModelForm
from django.forms.util import ValidationError

class PositionForm(ModelForm):

    def clean(self):
        cleaned_data = super(PositionForm, self).clean()
        if not self.is_valid():
            return cleaned_data
        if cleaned_data['active_from'] and cleaned_data['active_till']:
            if cleaned_data['active_from'] > cleaned_data['active_till']:
                raise ValidationError(_('Active till must be later than active from.'))
        return cleaned_data

    class Meta:
        model = Position

class PositionAdmin(newman.NewmanModelAdmin):
    form = PositionForm

    list_display = ('name', 'category', 'box_type', 'is_active', 'is_filled', 'show_title', 'disabled',)
    list_filter = ('category', 'disabled', 'active_from', 'active_till',)
    search_fields = ('name', 'box_type', 'text', 'category__title',)

    suggest_fields = {'category': ('__unicode__', 'title', 'slug', 'tree_path',),}

    def show_title(self, obj):
        if not obj.target:
            return '-- %s --' % ugettext('empty position')
        else:
            return u'%s [%s]' % (obj.target.title, ugettext(obj.target_ct.name),)
    show_title.short_description = _('Title')

    def is_filled(self, obj):
        if obj.target:
            return True
        else:
            return False
    is_filled.short_description = _('Filled')
    is_filled.boolean = True

    def is_active(self, obj):
        if obj.disabled:
            return False
        now = datetime.now()
        active_from = not obj.active_from or obj.active_from <= now
        active_till = not obj.active_till or obj.active_till > now
        return active_from and active_till
    is_active.short_description = _('Active')
    is_active.boolean = True


    def get_urls(self):
        urlpatterns = patterns('',
            url(r'^category/(\d+)/$',
                self.positions_by_category_view,
                name='positions-by-category'),
        )
        urlpatterns += super(PositionAdmin, self).get_urls()
        return urlpatterns

    def positions_by_category_view(self, request, category_id, extra_context=None):

        model = self.model
        self.user = request.user

        try:
            category = Category.objects.get(id=category_id)
        except Category.DoesNotExist:
            # FIXME: redirect
            return HttpResponseRedirect(reverse('newman:index'))

        names = ['featured_secondary_1', 'featured_secondary_2', 'featured_secondary_3', 'poll', 'tipoftheday',
                 'special', 'recipeoftheday', 'featured_small_1', 'featured_small_2',
                 'featured_small_3', ]

        positions = model.objects.filter(category=category_id, name__in=names)

        count = positions.count()

        PositionForm = self.get_form(request)

        if request.method == 'POST':
            forms = [PositionForm(request.POST, prefix=str(positions[x].id),
                                  instance=positions[x]) for x in range(count)]
            if all([form.is_valid() for form in forms]):
                for form in forms:
                    new_object = self.save_form(request, form, change=True)
                    self.save_model(request, new_object, form, change=True)
                    change_message = self.construct_change_message(request, form, None)
                    self.log_change(request, new_object, change_message)

                msg = unicode(_('Positions were changed successfully.'))

                return JsonResponse(msg, data={'category_id': category_id})
        else:
            forms = [PositionForm(prefix=str(positions[x].id),
                                  instance=positions[x]) for x in range(count)]

        adminForms = [helpers.AdminForm(forms[x], self.get_fieldsets(request, positions[x]),
                                self.prepopulated_fields) for x in range(count)]

        errors = []
        for form in forms:
            errors.extend(helpers.AdminErrorList(form, []))

        media = self.media
        if len(adminForms) > 0:
            media += adminForms[0].media

        raw_media = self.prepare_media(media)

        context = {
            'multiple_edit': True,
            'add': False,
            'title': _('Positions in %s') % category.title,
            'category': category,
            'adminforms': adminForms,
            'errors': errors,
            'media': raw_media,
            'is_popup': request.REQUEST.has_key('_popup'),
        }
        context.update(extra_context or {})

        # render change form
        opts = self.model._meta
        app_label = opts.app_label
        ordered_objects = opts.get_ordered_objects()

        context.update({
            'app_label': app_label,
            'change': True,
            'has_add_permission': False,
            'has_change_permission': True,
            'has_delete_permission': False,
            'has_file_field': False,
            'has_absolute_url': hasattr(self.model, 'get_absolute_url'),
            'ordered_objects': ordered_objects,
            'opts': opts,
            'content_type_id': ContentType.objects.get_for_model(self.model).id,
            'save_as': self.save_as,
            'save_on_top': self.save_on_top,
            'save_url': reverse('newman:positions-by-category', args=[category_id]),
        })
        return render_to_response("newman/%s/multi_change_form.html" % app_label,
                            context, context_instance=template.RequestContext(request))

newman.site.register(Position, PositionAdmin)

########NEW FILE########
__FILENAME__ = positions
from django import template
from django.template import TemplateSyntaxError

from ella.core.models import Category
from ella.positions.models import Position


register = template.Library()


def _get_category_from_pars_var(template_var, context):
    '''
    get category from template variable or from tree_path
    '''
    cat = template_var.resolve(context)
    if isinstance(cat, basestring):
        cat = Category.objects.get_by_tree_path(cat)
    return cat


@register.tag
def position(parser, token):
    """
    Render a given position for category.
    If some position is not defined for first category, position from its parent
    category is used unless nofallback is specified.

    Syntax::

        {% position POSITION_NAME for CATEGORY [nofallback] %}{% endposition %}
        {% position POSITION_NAME for CATEGORY using BOX_TYPE [nofallback] %}{% endposition %}

    Example usage::

        {% position top_left for category %}{% endposition %}
    """
    bits = token.split_contents()
    nodelist = parser.parse(('end' + bits[0],))
    parser.delete_first_token()
    return _parse_position_tag(bits, nodelist)


def _parse_position_tag(bits, nodelist):
    nofallback = False
    if bits[-1] == 'nofallback':
        nofallback = True
        bits.pop()

    if len(bits) == 4 and bits[2] == 'for':
        pos_name, category = bits[1], template.Variable(bits[3])
        box_type = None
    elif len(bits) == 6 and bits[2] == 'for' and bits[4] == 'using':
        pos_name, category, box_type = bits[1], template.Variable(bits[3]), bits[5]
    else:
        raise TemplateSyntaxError('Invalid syntax: {% position POSITION_NAME for CATEGORY [nofallback] %}')

    return PositionNode(category, pos_name, nodelist, box_type, nofallback)


class PositionNode(template.Node):
    def __init__(self, category, position, nodelist, box_type, nofallback):
        self.category, self.position = category, position
        self.nodelist, self.box_type = nodelist, box_type
        self.nofallback = nofallback

    def render(self, context):
        cat = _get_category_from_pars_var(self.category, context)
        pos = Position.objects.get_active_position(cat, self.position, self.nofallback)

        if pos:
            return pos.render(context, self.nodelist, self.box_type)

        return ''


@register.tag
def ifposition(parser, token):
    """
    Syntax::

        {% ifposition POSITION_NAME ... for CATEGORY [nofallback] %}
        {% else %}
        {% endifposition %}

    """
    bits = list(token.split_contents())
    end_tag = 'end' + bits[0]

    nofallback = False
    if bits[-1] == 'nofallback':
        nofallback = True
        bits.pop()

    if len(bits) >= 4 and bits[-2] == 'for':
        category = template.Variable(bits.pop())
        pos_names = bits[1:-1]
    else:
        raise TemplateSyntaxError('Invalid syntax: {% ifposition POSITION_NAME ... for CATEGORY [nofallback] %}')

    nodelist_true = parser.parse(('else', end_tag))
    token = parser.next_token()

    if token.contents == 'else':
        nodelist_false = parser.parse((end_tag,))
        parser.delete_first_token()
    else:
        nodelist_false = template.NodeList()

    return IfPositionNode(category, pos_names, nofallback, nodelist_true, nodelist_false)


class IfPositionNode(template.Node):
    def __init__(self, category, positions, nofallback, nodelist_true, nodelist_false):
        self.category, self.positions = category, positions
        self.nofallback, self.nodelist_true, self.nodelist_false = nofallback, nodelist_true, nodelist_false

    def render(self, context):
        cat = _get_category_from_pars_var(self.category, context)

        for pos in self.positions:
            if Position.objects.get_active_position(cat, pos, self.nofallback):
                return self.nodelist_true.render(context)

        return self.nodelist_false.render(context)

########NEW FILE########
__FILENAME__ = installedapps
from django.dispatch import Signal
from django.utils.itercompat import is_iterable
from django.conf import settings
from django.utils.importlib import import_module
from django.utils.module_loading import module_has_submodule

app_modules_loaded = Signal()

INSTALLED_APPS_REGISTER = {}

def register(app_name, modules):
    """
    simple module registering for later usage
    we don't want to import admin.py in models.py
    """
    global INSTALLED_APPS_REGISTER
    mod_list = INSTALLED_APPS_REGISTER.get(app_name, [])

    if isinstance(modules, basestring):
        mod_list.append(modules)
    elif is_iterable(modules):
        mod_list.extend(modules)

    INSTALLED_APPS_REGISTER[app_name] = mod_list


def call_modules(auto_discover=()):
    """
    this is called in project urls.py
    for registering desired modules (eg.: admin.py)
    """
    for app in settings.INSTALLED_APPS:
        modules = set(auto_discover)
        if app in INSTALLED_APPS_REGISTER:
            modules.update(INSTALLED_APPS_REGISTER[app])
        for module in modules:
            mod = import_module(app)
            try:
                import_module('%s.%s' % (app, module))
                inst = getattr(mod, '__install__', lambda: None)
                inst()
            except:
                if module_has_submodule(mod, module):
                    raise
    app_modules_loaded.send(sender=None)


########NEW FILE########
__FILENAME__ = middleware
import re

from django.shortcuts import redirect

from ella.core.urls import res

LEGACY_RES = map(re.compile,(
    r'^/%(cat)s/%(year)s/%(month)s/%(day)s/%(ct)s/%(slug)s/$' % res,
    r'^/%(year)s/%(month)s/%(day)s/%(ct)s/%(slug)s/$' % res,
    r'^/%(cat)s/%(year)s/%(month)s/%(day)s/%(ct)s/%(slug)s/%(rest)s$' % res,
    r'^/%(year)s/%(month)s/%(day)s/%(ct)s/%(slug)s/%(rest)s$' % res,

    r'^/%(cat)s/%(ct)s/%(id)s-%(slug)s/%(rest)s$' % res,
    r'^/%(ct)s/%(id)s-%(slug)s/%(rest)s$' % res,
    r'^/%(cat)s/%(ct)s/%(id)s-%(slug)s/$' % res,
    r'^/%(ct)s/%(id)s-%(slug)s/$' % res,
))

class LegacyRedirectMiddleware(object):
    def process_response(self, request, response):
        if response.status_code != 404:
            return response

        for r in LEGACY_RES:
            match = r.match(request.path)
            if match:
                d = match.groupdict()
                if 'day' in d:
                    # non-static urls
                    new_path = request.path.replace(
                        '/'.join(d[k] for k in ('year', 'month', 'day', 'content_type')),
                        '/'.join(d[k] for k in ('year', 'month', 'day')),
                    )
                else:
                    # static urls
                    new_path = request.path.replace(
                        '%s/%s-%s' % tuple(d[k] for k in ('content_type', 'id', 'slug')),
                        '%s-%s' % tuple(d[k] for k in ('id', 'slug')),
                    )

                return redirect(new_path, permanent=True)

        return response

########NEW FILE########
__FILENAME__ = pagination
from math import ceil

from django.core.paginator import Paginator, Page


class FirstPagePaginator(Paginator):
    """
    Extends standard django paginator by possibility of having different
    number of items on the first page.
    """
    def __init__(self, object_list, per_page, orphans=0,
                 allow_empty_first_page=True, first_page_count=None):
        super(FirstPagePaginator, self).__init__(object_list, per_page,
                                                 orphans,
                                                 allow_empty_first_page)
        self.first_page_count = first_page_count or per_page

    def page(self, number):
        number = self.validate_number(number)
        bottom = (number - 2) * self.per_page + self.first_page_count if number > 1 else 0
        top = bottom + (self.first_page_count if number == 1 else self.per_page)
        if top + self.orphans >= self.count:
            top = self.count
        return Page(self.object_list[bottom:top], number, self)

    def _get_num_pages(self):
        if self._num_pages is None:
            if self.count == 0 and not self.allow_empty_first_page:
                self._num_pages = 0
            else:
                hits = max(1, self.count - self.first_page_count - self.orphans)
                self._num_pages = (int(ceil(hits / float(self.per_page))) + 1
                                        if self.count > self.first_page_count
                                        else 1)
        return self._num_pages

    num_pages = property(_get_num_pages)

########NEW FILE########
__FILENAME__ = settings
from django.utils.importlib import import_module
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured


class Settings(object):
    """
    Simple wrapper around config. Read setting value from the projects'
    setting.py or from the given module. If you specify prefix, put
    setting in your projects' setting.py with prefix: PREFIX_<CONF_OPTION>.
    """

    def __init__(self, module_name, prefix=''):
        self.module = import_module(module_name)
        self.prefix = prefix

    def __getattr__(self, name):
        if self.prefix:
            p_name = '_'.join((self.prefix, name))
        else:
            p_name = name

        if hasattr(settings, p_name):
            return getattr(settings, p_name)

        try:
            return getattr(self.module, name)
        except AttributeError:
            raise ImproperlyConfigured("'%s' setting doesn't exist in your settings module '%s'." % (p_name, self.module.__name__))

    def __dir__(self):
        return dir(self.module) + dir(settings)

########NEW FILE########
__FILENAME__ = test_helpers
# -*- coding: utf-8 -*-
from datetime import datetime
from PIL import Image
from cStringIO import StringIO

from django.conf import settings
from django.core.files.uploadedfile import InMemoryUploadedFile
from django.template.defaultfilters import slugify

from ella.core.models import Category, Publishable
# choose Article as an example publishable
from ella.articles.models import Article
from ella.photos.models import Photo
from ella.utils.timezone import utc_localize

default_time = utc_localize(datetime(2008, 1, 10))

def create_category(title, tree_parent=None, **kwargs):
    defaults = {
        'site_id': getattr(settings, "SITE_ID", 1),
        'slug': slugify(title),
    }
    defaults.update(kwargs)
    if isinstance(tree_parent, basestring):
        tree_parent = Category.objects.get_by_tree_path(tree_parent)
    cat, created = Category.objects.get_or_create(tree_parent=tree_parent, title=title, defaults=defaults)
    return cat

def create_basic_categories(case):
    case.site_id = getattr(settings, "SITE_ID", 1)

    case.category = create_category(u" category",
        description=u"exmple testing category",
        slug=u"ni-hao-category",
    )

    case.category_nested = create_category(
        u"nested category",
        tree_parent=case.category,
        description=u"category nested in case.category",
    )

    case.category_nested_second = create_category(
        u" second nested category",
        tree_parent='nested-category',
        description=u"category nested in case.category_nested",
        slug=u"second-nested-category",
    )
    case.addCleanup(Category.objects.clear_cache)

def create_and_place_a_publishable(case, **kwargs):
    defaults = dict(
        title=u'First Article',
        slug=u'first-article',
        description=u'Some\nlonger\ntext',
        category=case.category_nested,
        publish_from=default_time,
        published=True,
        content='Some even longer test. \n' * 5
    )
    defaults.update(kwargs)
    case.publishable = Article.objects.create(**defaults)
    case.only_publishable = Publishable.objects.get(pk=case.publishable.pk)

def create_photo(case, color="black", size=(200, 100), **kwargs):
    # prepare image in temporary directory
    file = StringIO()
    case.image = Image.new('RGB', size, color)
    case.image.save(file, format="jpeg")


    f = InMemoryUploadedFile(
            file = file,
            field_name = 'image',
            name = 'example-photo.jpg',
            content_type = 'image/jpeg',
            size = len(file.getvalue()),
            charset = None
        )

    data = dict(
        title = u"Example  photo",
        slug = u"example-photo",
        height = size[0],
        width = size[1],
    )
    data.update(kwargs)

    case.photo = Photo(**data)
    image_field = Photo._meta.get_field('image')
    image_field.save_form_data(case.photo, f)

    case.photo.save()
    case.photo._pil_image = case.image

    return case.photo

########NEW FILE########
__FILENAME__ = timezone
import time
import calendar
from pytz import utc
from datetime import datetime

from django.conf import settings

use_tz = getattr(settings, 'USE_TZ', False)
try:
    # try import offset-aware datetime from Django >= 1.4
    from django.utils.timezone import now, localtime, get_current_timezone, make_aware
except ImportError:
    # backward compatibility with Django < 1.4 (offset-naive datetimes)
    from datetime import datetime
    now = datetime.now
    use_tz = False


def utc_localize(dtime):
    if use_tz:
        if dtime.tzinfo:
            return utc.normalize(dtime)
        else:
            return utc.localize(dtime)
    return dtime

def localize(dtime):
    if use_tz:
        if dtime.tzinfo:
            return localtime(dtime)
        else:
            return make_aware(dtime, get_current_timezone())
    return dtime

def to_timestamp(dtime):
    if use_tz:
        return calendar.timegm(dtime.utctimetuple()) + float(dtime.microsecond)/1000000
    return time.mktime(dtime.timetuple()) + float(dtime.microsecond)/1000000

def from_timestamp(tstamp):
    if use_tz:
        return datetime.fromtimestamp(float(tstamp), tz=utc)
    return datetime.fromtimestamp(float(tstamp))

########NEW FILE########
__FILENAME__ = cases
from django.test import TestCase

from ella.core.cache.redis import client

class RedisTestCase(TestCase):
    def tearDown(self):
        super(RedisTestCase, self).tearDown()
        client.flushdb()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python

import os
from os.path import join, pardir, abspath, dirname, split
import sys

from django.core.management import execute_from_command_line


# fix PYTHONPATH and DJANGO_SETTINGS for us
# django settings module
DJANGO_SETTINGS_MODULE = '%s.%s' % (split(abspath(dirname(__file__)))[1], 'settings')
# pythonpath dirs
PYTHONPATH = [
    abspath(join( dirname(__file__), pardir, pardir)),
    abspath(join( dirname(__file__), pardir)),
]

# inject few paths to pythonpath
for p in PYTHONPATH:
    if p not in sys.path:
        sys.path.insert(0, p)

# django needs this env variable
os.environ['DJANGO_SETTINGS_MODULE'] = DJANGO_SETTINGS_MODULE


if __name__ == "__main__":
    execute_from_command_line()


########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python

'''
simple shortcut for running nosetests via python
replacement for *.bat or *.sh wrappers
'''

import sys
import os

from os.path import abspath, dirname

import nose

def run_all(argv=None):
    os.environ['DJANGO_SETTINGS_MODULE'] = 'test_ella.settings'
    sys.exitfunc = lambda msg='Process shutting down...': sys.stderr.write(msg + '\n')

    # called by setuptools
    if argv is None:
        argv = ['nosetests']

    if len(argv) == 1:  # only the command itself is in argv
        argv += [
            '--with-coverage', '--cover-package=ella', '--cover-erase',
            '--with-xunit',
        ]

    nose.run_exit(
        argv=argv,
        defaultTest=abspath(dirname(__file__)),
    )

if __name__ == '__main__':
    run_all(sys.argv)


########NEW FILE########
__FILENAME__ = base
from os.path import dirname, join, normpath, pardir

FILE_ROOT = normpath(join(dirname(__file__), pardir))

USE_I18N = True

USE_TZ = True

MEDIA_ROOT = join(FILE_ROOT, 'static')

STATIC_URL = MEDIA_URL = '/static/'
ADMIN_MEDIA_PREFIX = '/static/admin/'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'test_ella.template_loader.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'test_ella.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    join(FILE_ROOT, 'templates'),

)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.media',
    'django.contrib.auth.context_processors.auth',
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.redirects',
    'django.contrib.admin',

    'ella.api',
    'ella.core',
    'ella.articles',
    'ella.photos',
    'ella.positions',
    'test_ella.test_app',
)

LISTING_HANDLERS = {
    'default': 'ella.core.managers.ModelListingHandler',
    'redis': 'ella.core.cache.redis.TimeBasedListingHandler',
}
LISTINGS_REDIS = {}
USE_REDIS_FOR_LISTINGS = True
REDIS_LISTING_HANDLER = 'redis'

DEFAULT_PAGE_ID = 1

VERSION = 1


CATEGORY_TEMPLATES = [
    ('category.html', ''),
    ('static_page.html', ''),
]

PHOTOS_DEFAULT_BG_COLOR = 'blue'

API_ENABLED = True

########NEW FILE########
__FILENAME__ = config
ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS


DEBUG = False
TEMPLATE_DEBUG = DEBUG
DISABLE_CACHE_TEMPLATE = DEBUG


DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

TEST_CORE_REDIS = PHOTOS_REDIS = {'db': 15}

TIME_ZONE = 'Europe/Prague'

LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# Make this unique, and don't share it with anybody.
SECRET_KEY = '88b-01f^x4lh$-s5-hdccnicekg07)niir2g6)93!0#k(=mfv$'

# TODO: Fix logging
# init logger
#LOGGING_CONFIG_FILE = join(dirname(testbed.__file__), 'settings', 'logger.ini')
#if isinstance(LOGGING_CONFIG_FILE, basestring) and isfile(LOGGING_CONFIG_FILE):
#    logging.config.fileConfig(LOGGING_CONFIG_FILE)

# we want to reset whole cache in test
# until we do that, don't use cache
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}

USE_PRIORITIES = True

########NEW FILE########
__FILENAME__ = local_example
"""
Rename to local.py and set variables from config.py that
You want to override.
"""
from test_ella.settings.base import TEMPLATE_LOADERS

TEMPLATE_LOADERS = list(TEMPLATE_LOADERS) + ['django.template.loaders.app_directories.Loader',]

DEBUG = True
TEMPLATE_DEBUG = DEBUG
DISABLE_CACHE_TEMPLATE = DEBUG

ROOT_URLCONF = 'test_ella.working_urls'

########NEW FILE########
__FILENAME__ = template_loader
from unittest import TestCase

from django.template import TemplateDoesNotExist

from nose import tools


templates = {}

def load_template_source(template_name, dirs=None):
    "Dummy template loader that returns templates from local templates dictionary."
    try:
        return templates[template_name], template_name
    except KeyError, e:
        raise TemplateDoesNotExist(e)
load_template_source.is_usable = True

class TestDummyTemplateLoader(TestCase):
    def tearDown(self):
        global templates
        templates = {}

    def test_simple(self):
        templates['anything.html'] = 'Something'
        source, name = load_template_source('anything.html')
        tools.assert_equals('anything.html', name)
        tools.assert_equals('Something', source)

    def test_empty(self):
        tools.assert_raises(TemplateDoesNotExist, load_template_source, 'anything.html')


########NEW FILE########
__FILENAME__ = test_serialization
from test_ella.cases import RedisTestCase as TestCase

from ella.api import object_serializer, FULL
from ella.core.models import Publishable
from ella.articles.models import Article

from nose import tools

class TestObjectSerialization(TestCase):
    def setUp(self):
        super(TestObjectSerialization, self).setUp()
        self.old_registry = object_serializer._registry
        object_serializer._registry = {}

    def tearDown(self):
        super(TestObjectSerialization, self).tearDown()
        object_serializer._registry = self.old_registry

    def test_article_is_properly_serialized(self):
        object_serializer.register(Publishable, lambda r, a: 'Publishable %s' % a.id)
        object_serializer.register(Article, lambda r, a: 'Article %s' % a.id, FULL)
        art = Article(id=42)
        tools.assert_equals('Publishable 42', object_serializer.serialize(None, art))


########NEW FILE########
__FILENAME__ = test_views
from django.utils import simplejson as json

from ella.api import object_serializer, FULL
from ella.articles.models import Article

from test_ella.test_core.test_views import ViewsTestCase

from nose import tools

class TestCategoryDetail(ViewsTestCase):
    def test_category_is_properly_serialized(self):
        response = self.client.get('/', HTTP_ACCEPT='application/json')
        tools.assert_equals(200, response.status_code)
        tools.assert_equals('application/json', response['Content-Type'])
        tools.assert_equals(
            {
                "category": {"url": "/", "id": 1, "title": u"\u4f60\u597d category"},
                "listings": {
                    u'current_page': 1,
                    u'num_pages': 1,
                    u'objects': [],
                    u'per_page': 20,
                    u'total': 0
                }
            },
            json.loads(response.content)
        )

class TestObjectDetail(ViewsTestCase):
    def setUp(self):
        super(TestObjectDetail, self).setUp()
        self.old_registry = object_serializer._registry.copy()
        object_serializer.register(Article, lambda r, a: 'Article %s' % a.pk, FULL)

    def tearDown(self):
        super(TestObjectDetail, self).tearDown()
        object_serializer._registry = self.old_registry

    def test_article_is_properly_serialized(self):
        response = self.client.get('/nested-category/2008/1/10/first-article/', HTTP_ACCEPT='application/json')
        tools.assert_equals(200, response.status_code)
        tools.assert_equals('application/json', response['Content-Type'])
        tools.assert_equals('Article 1', json.loads(response.content))

########NEW FILE########
__FILENAME__ = loadme
from ella.utils.installedapps import app_modules_loaded
run_log = []

def handle_stuff(*args, **kwargs):
    run_log.append((args, kwargs))
app_modules_loaded.connect(handle_stuff)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = test_boxes
# -*- coding: utf-8 -*-
from test_ella.cases import RedisTestCase as TestCase
from django.template import Context

from nose import tools

from ella.core.models import Publishable
from ella.core.box import Box
from ella.core.cache.utils import _get_key, KEY_PREFIX
from ella.articles.models import Article

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable
from test_ella import template_loader


class ArticleBox(Box):
    pass

class TestPublishableBox(TestCase):
    def setUp(self):
        super(TestPublishableBox, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)

    def tearDown(self):
        super(TestPublishableBox, self).tearDown()
        template_loader.templates = {}

    def test_box_works_for_any_class(self):
        class TestClass(object):
            title = 'Heyoo'
        test_obj = TestClass()
        test_box = Box(test_obj, 'box_type', [])

        tools.assert_equals([
            'box/content_type/testclass/box_type.html',
            'box/content_type/testclass/box.html',
            'box/box_type.html',
            'box/box.html'
        ], test_box._get_template_list())

        template_loader.templates['box/content_type/testclass/box_type.html'] = '{{ object.title}}'
        tools.assert_equals('Heyoo', test_box.render(Context({})))

    def test_box_cache_key_is_prefixed_by_objects_key(self):
        box = Box(self.publishable, 'box_type', [])
        # initialize the box's .params attribute
        box.prepare({})
        tools.assert_true(box.get_cache_key().startswith(_get_key(KEY_PREFIX, self.publishable.content_type, pk=self.publishable.pk)))

    def test_box_template_path_contains_correct_content_type(self):
        publishable = Publishable.objects.get(pk=self.publishable.pk)
        article = publishable.target

        box_publishable = publishable.box_class(publishable, 'box_type', [])
        box_article = Box(article, 'box_type', [])

        template_list = [
            'box/category/nested-category/content_type/articles.article/first-article/box_type.html',
            'box/category/nested-category/content_type/articles.article/box_type.html',
            'box/category/nested-category/content_type/articles.article/box.html',
            'box/content_type/articles.article/first-article/box_type.html',
            'box/content_type/articles.article/box_type.html',
            'box/content_type/articles.article/box.html',
            'box/box_type.html',
            'box/box.html',
        ]

        tools.assert_equals(template_list, box_publishable._get_template_list())
        tools.assert_equals(template_list, box_article._get_template_list())

    def test_box_class_is_specific_to_subclass(self):
        publishable = Publishable.objects.get(pk=self.publishable.pk)
        Article.box_class = ArticleBox
        box = publishable.box_class(publishable, 'box_type', [])
        tools.assert_equals(ArticleBox, box.__class__)


########NEW FILE########
__FILENAME__ = test_cache
import time
from datetime import date, datetime, timedelta

from django.core.cache import get_cache
from ella.core.cache.utils import normalize_key
from hashlib import md5
from test_ella.cases import RedisTestCase as TestCase
from django.test.client import RequestFactory
from django.contrib.sites.models import Site
from django.contrib.contenttypes.models import ContentType

from ella.core.cache import utils, redis
from ella.core.models import Listing, Publishable
from ella.core.views import ListContentType
from ella.core.managers import ListingHandler
from ella.articles.models import Article
from ella.utils.timezone import from_timestamp, now

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour

from nose import tools

class CacheTestCase(TestCase):
    def setUp(self):
        self.old_cache = utils.cache
        self.cache = get_cache('locmem://')
        utils.cache = self.cache
        super(CacheTestCase, self).setUp()

    def tearDown(self):
        super(CacheTestCase, self).tearDown()
        utils.cache = self.old_cache

class TestCacheUtils(CacheTestCase):
    def test_get_many_objects(self):
        ct_ct = ContentType.objects.get_for_model(ContentType)
        site_ct = ContentType.objects.get_for_model(Site)

        objs = utils.get_cached_objects([(ct_ct.id, ct_ct.id), (ct_ct.id, site_ct.id), (site_ct.id, 1)])

        tools.assert_equals([ct_ct, site_ct, Site.objects.get(pk=1)], objs)

    def test_get_many_publishables_will_respect_their_content_type(self):
        create_basic_categories(self)
        create_and_place_a_publishable(self)
        objs = utils.get_cached_objects([self.publishable.pk], Publishable)

        tools.assert_true(isinstance(objs[0], Article))

    def test_get_many_objects_raises_by_default(self):
        ct_ct = ContentType.objects.get_for_model(ContentType)
        site_ct = ContentType.objects.get_for_model(Site)

        tools.assert_raises(Site.DoesNotExist, utils.get_cached_objects, [(ct_ct.id, ct_ct.id), (ct_ct.id, site_ct.id), (site_ct.id, 1), (site_ct.id, 100)])

    def test_get_many_objects_can_replace_missing_with_none(self):
        ct_ct = ContentType.objects.get_for_model(ContentType)
        site_ct = ContentType.objects.get_for_model(Site)

        objs = utils.get_cached_objects([(ct_ct.id, ct_ct.id), (ct_ct.id, site_ct.id), (site_ct.id, 1), (site_ct.id, 100)], missing=utils.NONE)
        tools.assert_equals([ct_ct, site_ct, Site.objects.get(pk=1), None], objs)

    def test_get_many_objects_can_skip(self):
        ct_ct = ContentType.objects.get_for_model(ContentType)
        site_ct = ContentType.objects.get_for_model(Site)

        objs = utils.get_cached_objects([(ct_ct.id, ct_ct.id), (ct_ct.id, site_ct.id), (site_ct.id, 1), (site_ct.id, 100)], missing=utils.SKIP)
        tools.assert_equals([ct_ct, site_ct, Site.objects.get(pk=1)], objs)

    def test_get_publishable_returns_subclass(self):
        create_basic_categories(self)
        create_and_place_a_publishable(self)

        tools.assert_equals(self.publishable, utils.get_cached_object(Publishable, pk=self.publishable.pk))

    def test_get_article_uses_the_publishable_key_and_0_for_version(self):
        tools.assert_equals(
            ':'.join((utils.KEY_PREFIX, str(ContentType.objects.get_for_model(Publishable).pk), '123', '0')),
            utils._get_key(utils.KEY_PREFIX, ContentType.objects.get_for_model(Article), pk=123)
        )

    def test_get_article_uses_the_publishable_key_and_version_from_cache(self):
        key = utils._get_key(utils.KEY_PREFIX, ContentType.objects.get_for_model(Article), pk=123, version_key=True)
        self.cache.set(key, 3)
        tools.assert_equals(
            ':'.join((utils.KEY_PREFIX, str(ContentType.objects.get_for_model(Publishable).pk), '123', '3')),
            utils._get_key(utils.KEY_PREFIX, ContentType.objects.get_for_model(Article), pk=123)
        )

class TestCacheInvalidation(CacheTestCase):
    def test_save_invalidates_object(self):
        self.ct = ContentType.objects.get_for_model(ContentType)
        ct = utils.get_cached_object(self.ct, pk=self.ct.pk)

        tools.assert_equals(ct, self.ct)
        tools.assert_equals(self.ct, self.cache.get(utils._get_key(utils.KEY_PREFIX, self.ct, pk=self.ct.pk)))
        self.ct.save()
        tools.assert_equals(None, self.cache.get(utils._get_key(utils.KEY_PREFIX, self.ct, pkr=self.ct.pk)))

    def test_save_increases_version(self):
        self.ct = ContentType.objects.get_for_model(ContentType)
        key = utils._get_key(utils.KEY_PREFIX, self.ct, pk=self.ct.pk, version_key=True)

        self.ct.save()
        initial_version = self.cache.get(key)
        self.ct.save()
        new_version = self.cache.get(key)

        tools.assert_equals(new_version, initial_version + 1)


class TestRedisListings(TestCase):
    def setUp(self):
        super(TestRedisListings, self).setUp()
        create_basic_categories(self)
        create_and_place_more_publishables(self)

    def test_access_to_individual_listings(self):
        list_all_publishables_in_category_by_hour(self)
        lh = Listing.objects.get_queryset_wrapper(category=self.category, children=ListingHandler.ALL, source='redis')
        l = lh[0]

        tools.assert_equals(l.publishable, self.listings[0].publishable)

    def test_listings_dont_propagate_where_they_shouldnt(self):
        self.category_nested.app_data = {'ella': {'propagate_listings': False}}
        self.category_nested.save()

        # small hack to remove the cached category on Publishable
        for p in self.publishables:
            del p._category_cache

        list_all_publishables_in_category_by_hour(self)
        ct_id = self.publishables[0].content_type_id
        tools.assert_equals(['%d:1' % ct_id], redis.client.zrange('listing:d:1', 0, 100))
        tools.assert_equals(['%d:1' % ct_id], redis.client.zrange('listing:c:1', 0, 100))
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:c:2', 0, 100))
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:d:2', 0, 100))

    def test_listing_gets_removed_when_publishable_goes_unpublished(self):
        list_all_publishables_in_category_by_hour(self)
        p = self.publishables[0]
        p.published = False
        p.save()
        ct_id = p.content_type_id
        tools.assert_equals(set([
                'listing:2',
                'listing:3',

                'listing:c:1',
                'listing:c:2',
                'listing:c:3',

                'listing:d:1',
                'listing:d:2',
                'listing:d:3',

                'listing:ct:%d' % ct_id,
            ]),
            set(redis.client.keys())
        )
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:ct:%d' % ct_id, 0, 100))
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:d:1', 0, 100))
        tools.assert_equals(['%d:2' % ct_id], redis.client.zrange('listing:c:1', 0, 100))

    def test_listing_gets_removed_when_publishable_marked_unpublished_even_if_not_published_yet(self):
        future = now() + timedelta(days=1)

        p = self.publishables[0]
        p.publish_from = future
        p.save()

        list_all_publishables_in_category_by_hour(self)
        p.published = False
        p.save()
        ct_id = p.content_type_id
        tools.assert_equals(set([
                'listing:2',
                'listing:3',

                'listing:c:1',
                'listing:c:2',
                'listing:c:3',

                'listing:d:1',
                'listing:d:2',
                'listing:d:3',

                'listing:ct:%d' % ct_id,
            ]),
            set(redis.client.keys())
        )
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:ct:%d' % ct_id, 0, 100))
        tools.assert_equals(['%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:d:1', 0, 100))
        tools.assert_equals(['%d:2' % ct_id], redis.client.zrange('listing:c:1', 0, 100))

    def test_listing_save_adds_itself_to_relevant_zsets(self):
        list_all_publishables_in_category_by_hour(self)
        ct_id = self.publishables[0].content_type_id
        tools.assert_equals(set([
                'listing:1',
                'listing:2',
                'listing:3',

                'listing:c:1',
                'listing:c:2',
                'listing:c:3',

                'listing:d:1',
                'listing:d:2',
                'listing:d:3',

                'listing:ct:%d' % ct_id,
            ]),
            set(redis.client.keys())
        )
        tools.assert_equals(['%d:3' % ct_id], redis.client.zrange('listing:3', 0, 100))
        tools.assert_equals(['%d:1' % ct_id, '%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:ct:%d' % ct_id, 0, 100))
        tools.assert_equals(['%d:1' % ct_id, '%d:2' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:d:1', 0, 100))

    def test_listing_delete_removes_itself_from_redis(self):
        list_all_publishables_in_category_by_hour(self)
        self.listings[1].delete()
        ct_id = self.publishables[0].content_type_id
        tools.assert_equals(set([
                'listing:1',
                'listing:3',

                'listing:c:1',
                'listing:c:2',
                'listing:c:3',

                'listing:d:1',
                'listing:d:2',
                'listing:d:3',

                'listing:ct:%d' % ct_id,
            ]),
            set(redis.client.keys())
        )
        tools.assert_equals(['%d:3' % ct_id], redis.client.zrange('listing:3', 0, 100))
        tools.assert_equals(['%d:3' % ct_id], redis.client.zrange('listing:c:2', 0, 100))
        tools.assert_equals(['%d:3' % ct_id], redis.client.zrange('listing:d:2', 0, 100))
        tools.assert_equals(['%d:1' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:d:1', 0, 100))
        tools.assert_equals(['%d:1' % ct_id], redis.client.zrange('listing:c:1', 0, 100))
        tools.assert_equals(['%d:1' % ct_id, '%d:3' % ct_id], redis.client.zrange('listing:ct:%d' % ct_id, 0, 100))

    def test_get_listing_uses_data_from_redis(self):
        ct_id = self.publishables[0].content_type_id
        t1, t2 = time.time()-90, time.time()-100
        redis.client.zadd('listing:c:2', '%d:1' % ct_id, repr(t1))
        redis.client.zadd('listing:c:2', '%d:3' % ct_id, repr(t2))
        dt1, dt2 = from_timestamp(t1), from_timestamp(t2)

        lh = Listing.objects.get_queryset_wrapper(category=self.category_nested, children=ListingHandler.IMMEDIATE, source='redis')
        tools.assert_equals(2, lh.count())
        l1, l2 = lh.get_listings(0, 10)

        tools.assert_equals(l1.publishable, self.publishables[0])
        tools.assert_equals(l2.publishable, self.publishables[2])
        tools.assert_equals(l1.publish_from, dt1)
        tools.assert_equals(l2.publish_from, dt2)

    def test_get_listing_omits_excluded_publishable(self):
        ct_id = self.publishables[0].content_type_id
        t1, t2 = time.time()-90, time.time()-100
        redis.client.zadd('listing:c:2', '%d:1' % ct_id, repr(t1))
        redis.client.zadd('listing:c:2', '%d:3' % ct_id, repr(t2))
        dt1, dt2 = from_timestamp(t1), from_timestamp(t2)

        lh = Listing.objects.get_queryset_wrapper(category=self.category_nested, children=ListingHandler.IMMEDIATE, exclude=self.publishables[0], source='redis')
        tools.assert_equals(1, lh.count())
        l = lh.get_listings(0, 10)

        tools.assert_equals(l[0].publishable, self.publishables[2])
        tools.assert_equals(l[0].publish_from, dt2)

    def test_redis_listing_handler_used_from_view_when_requested(self):
        ct_id = self.publishables[0].content_type_id
        t1, t2 = time.time()-90, time.time()-100
        redis.client.zadd('listing:d:2', '%d:1' % ct_id, repr(t1))
        redis.client.zadd('listing:d:2', '%d:3' % ct_id, repr(t2))
        dt1, dt2 = from_timestamp(t1), from_timestamp(t2)

        rf = RequestFactory()
        request = rf.get(self.category_nested.get_absolute_url(), {'using': 'redis'})
        lct = ListContentType()

        context = lct.get_context(request, self.category_nested)
        tools.assert_equals(2, len(context['listings']))
        l1, l2 = context['listings']

        tools.assert_equals(l1.publishable, self.publishables[0])
        tools.assert_equals(l2.publishable, self.publishables[2])
        tools.assert_equals(l1.publish_from, dt1)
        tools.assert_equals(l2.publish_from, dt2)

    def test_get_listing_uses_data_from_redis_correctly_for_pagination(self):
        ct_id = self.publishables[0].content_type_id
        t1, t2, t3 = time.time()-90, time.time()-100, time.time() - 110
        redis.client.zadd('listing:c:2', '%d:1' % ct_id, repr(t1))
        redis.client.zadd('listing:c:2', '%d:3' % ct_id, repr(t2))
        redis.client.zadd('listing:c:2', '%d:2' % ct_id, repr(t3))

        lh = Listing.objects.get_queryset_wrapper(category=self.category_nested, children=ListingHandler.IMMEDIATE, source='redis')
        tools.assert_equals(3, lh.count())
        l = lh.get_listings(2, 1)

        tools.assert_equals(1, len(l))
        tools.assert_equals(l[0].publishable, self.publishables[1])

    def test_redis_lh_slicing(self):
        list_all_publishables_in_category_by_hour(self)
        # Instantiate the RedisListingHandler and have it fetch all children
        lh = redis.RedisListingHandler(self.category, ListingHandler.ALL)

        for offset, count in [(0, 10), (0, 1), (0, 2), (1, 2), (2, 3), (3, 3)]:
            partial = lh.get_listings(offset=offset, count=count)
            tools.assert_equals(
                [l.publishable for l in partial],
                [l.publishable for l in self.listings[offset:offset + count]]
            )

    def test_time_based_lh_slicing(self):
        list_all_publishables_in_category_by_hour(self)
        # Instantiate the RedisListingHandler and have it fetch all children
        lh = redis.TimeBasedListingHandler(self.category, ListingHandler.ALL)

        for offset, count in [(0, 10), (0, 1), (0, 2), (1, 2), (2, 3), (3, 3)]:
            partial = lh.get_listings(offset=offset, count=count)
            tools.assert_equals(
                [l.publishable for l in partial],
                [l.publishable for l in self.listings[offset:offset + count]]
            )


class TestAuthorLH(TestCase):
    def setUp(self):
        from ella.core.models import Author

        super(TestAuthorLH, self).setUp()

        create_basic_categories(self)
        create_and_place_more_publishables(self)

        self.author = Author.objects.create(slug='testauthor')

        for p in self.publishables:
            p.authors = [self.author]
            p.save()

    def test_listing_save_adds_itself_to_relevant_zsets(self):
        list_all_publishables_in_category_by_hour(self)
        ct_id = self.publishables[0].content_type_id
        tools.assert_equals(set([
            'listing:1',
            'listing:2',
            'listing:3',

            'listing:c:1',
            'listing:c:2',
            'listing:c:3',

            'listing:d:1',
            'listing:d:2',
            'listing:d:3',

            'listing:a:%d' % self.author.pk,

            'listing:ct:%d' % ct_id,

            ]),
            set(redis.client.keys())
        )
        tools.assert_equals(['%d:1' % ct_id, '%d:2' % ct_id, '%d:3' % ct_id],
                            redis.client.zrange('listing:a:1', 0, 100))

    def test_not_in_zsets_when_no_listings_present(self):
        ct_id = self.publishables[0].content_type_id
        tools.ok_('%d:1' % ct_id not in redis.client.zrange('listing:a:1', 0, 100))

    def test_gets_removed_when_last_listing_is_deleted(self):
        list_all_publishables_in_category_by_hour(self)
        ct_id = self.publishables[0].content_type_id

        while 1:
            listings = self.publishables[0].listing_set.all()

            if len(listings):
                tools.ok_('%d:1' % ct_id in redis.client.zrange('listing:a:1', 0, 100))
                listings[0].delete()
            else:
                tools.ok_('%d:1' % ct_id not in redis.client.zrange('listing:a:1', 0, 100))
                break

    def test_gets_added_when_first_listing_is_added(self):
        ct_id = self.publishables[0].content_type_id
        tools.ok_('%d:1' % ct_id not in redis.client.zrange('listing:a:1', 0, 100))

        Listing.objects.get_or_create(
            publishable=self.publishables[0],
            category=self.publishables[0].category,
            publish_from=self.publishables[0].publish_from,
        )[0]

        tools.ok_('%d:1' % ct_id in redis.client.zrange('listing:a:1', 0, 100))

    def test_not_added_when_not_published(self):
        ct_id = self.publishables[0].content_type_id

        self.publishables[0].published = False
        self.publishables[0].save()

        list_all_publishables_in_category_by_hour(self)

        tools.ok_('%d:1' % ct_id not in redis.client.zrange('listing:a:1', 0, 100))

        self.publishables[0].published = True
        self.publishables[0].save()

        tools.ok_('%d:1' % ct_id in redis.client.zrange('listing:a:1', 0, 100))

        self.publishables[0].published = False
        self.publishables[0].save()

        tools.ok_('%d:1' % ct_id not in redis.client.zrange('listing:a:1', 0, 100))


class SlidingLH(redis.SlidingListingHandler):
    PREFIX = 'sliding'


class TestSlidingListings(TestCase):
    def setUp(self):
        super(TestSlidingListings, self).setUp()
        create_basic_categories(self)
        create_and_place_more_publishables(self)
        self.ct_id = self.publishables[0].content_type_id

    def test_remove_publishable_clears_all_windows(self):
        SlidingLH.add_publishable(self.category, self.publishables[0], 10)
        SlidingLH.remove_publishable(self.category, self.publishables[0])
        tools.assert_equals(set(['sliding:KEYS', 'sliding:WINDOWS']), set(redis.client.keys(SlidingLH.PREFIX + '*')))

    def test_add_publishable_pushes_to_day_and_global_keys(self):
        SlidingLH.add_publishable(self.category, self.publishables[0], 10)
        day = date.today().strftime('%Y%m%d')
        expected_base = [
            'sliding:1',
            'sliding:c:1',
            'sliding:d:1',
            'sliding:ct:%s' % self.ct_id,
        ]
        expected = expected_base + [k + ':' + day for k in expected_base] + ['sliding:KEYS', 'sliding:WINDOWS']
        tools.assert_equals(set(expected), set(redis.client.keys(SlidingLH.PREFIX + '*')))
        tools.assert_equals(redis.client.zrange('sliding:d:1', 0, -1, withscores=True), redis.client.zrange('sliding:d:1' + ':' + day, 0, -1, withscores=True))

    def test_slide_windows_regenerates_aggregates(self):
        SlidingLH.add_publishable(self.category, self.publishables[0], 10)
        # register the keys that should exist
        redis.client.sadd('sliding:KEYS', 'sliding:1', 'sliding:c:1')

        redis.client.zadd('sliding:1:20101010', **{'17:1': 10, '17:2': 1})
        redis.client.zadd('sliding:1:20101009', **{'17:1': 9, '17:2': 2})
        redis.client.zadd('sliding:1:20101007', **{'17:1': 8, '17:2': 3, '17:3': 11})
        redis.client.zadd('sliding:1:20101001', **{'17:1': 8, '17:2': 3, '17:3': 11})


        SlidingLH.regenerate(date(2010, 10, 10))
        tools.assert_equals([('17:2', 6.0), ('17:3', 11.0), ('17:1', 27.0)], redis.client.zrange('sliding:1', 0, -1, withscores=True))

    def test_regenerate_removes_old_slots(self):
        redis.client.zadd('sliding:WINDOWS', **{
                'sliding:1:20101010': 20101010,
                'sliding:1:20101009': 20101009,
                'sliding:1:20101007': 20101007,
                'sliding:1:20101001': 20101001
            })
        redis.client.zadd('sliding:1:20101010', **{'17:1': 10, '17:2': 1})
        redis.client.zadd('sliding:1:20101009', **{'17:1': 9, '17:2': 2})
        redis.client.zadd('sliding:1:20101007', **{'17:1': 8, '17:2': 3, '17:3': 11})
        redis.client.zadd('sliding:1:20101001', **{'17:1': 8, '17:2': 3, '17:3': 11})

        SlidingLH.regenerate(date(2010, 10, 10))
        tools.assert_false(redis.client.exists('sliding:1:20101001'))
        tools.assert_true(redis.client.exists('sliding:1:20101007'))
        tools.assert_equals([
                ('sliding:1:20101007', 20101007),
                ('sliding:1:20101009', 20101009),
                ('sliding:1:20101010', 20101010)
            ],
            redis.client.zrange('sliding:WINDOWS', 0, -1, withscores=True)
        )
def test_normalize_key_doesnt_touch_short_key():
    key = "thisistest"
    tools.assert_equals(key,normalize_key(key))

def test_normalize_key_md5s_long_key():
    key = "0123456789" * 30
    tools.assert_equals(md5(key).hexdigest(),normalize_key(key))



########NEW FILE########
__FILENAME__ = test_category
# -*- coding: utf-8 -*-
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError

from ella.core.models import Category

from test_ella.test_core import create_basic_categories

class TestCategory(TestCase):

    def setUp(self):
        super(TestCategory, self).setUp()
        create_basic_categories(self)

    def test_slug_cannot_start_as_publishable_url(self):
        self.category_nested.slug = '123-slug'
        tools.assert_raises(ValidationError, self.category_nested.full_clean)

    def test_slug_can_start_with_number(self):
        self.category_nested.slug = '3d-slug'
        self.category_nested.full_clean()

    def test_get_children(self):
        tools.assert_equals([u'nested-category', ], [c.tree_path for c in self.category.get_children()])

    def test_get_children_recursive(self):
        tools.assert_equals(
            [u'nested-category', u'nested-category/second-nested-category'],
            [c.tree_path for c in self.category.get_children(recursive=True)]
        )

    def test_proper_root_path(self):
        tools.assert_equals("", self.category.tree_path)

    def test_proper_firstlevel_path(self):
        tools.assert_equals("nested-category", self.category_nested.tree_path)

    def test_category_rename_tree_path(self):
        self.category_nested.slug = u"new-nested-category"
        self.category_nested.save()
        tools.assert_equals("new-nested-category", self.category_nested.tree_path)

    def test_proper_secondlevel_path(self):
        tools.assert_equals(u"nested-category/second-nested-category", self.category_nested_second.tree_path)

    def test_category_rename_children(self):
        self.category_nested.slug = u"new-nested-category"
        self.category_nested.save()
        category_nested_second = Category.objects.get(pk=self.category_nested_second.pk)
        tools.assert_equals(u"new-nested-category/second-nested-category", category_nested_second.tree_path)

    def test_proper_parent(self):
        tools.assert_equals(self.category, self.category_nested.tree_parent)

    def test_main_parent_nested_second_level(self):
        tools.assert_equals(self.category_nested, self.category_nested_second.get_root_category())

    def test_main_parent_nested(self):
        tools.assert_equals(self.category_nested, self.category_nested.get_root_category())

    def test_main_parent_nested_third(self):
        category_nested_third = Category.objects.create(
            title=u"Third nested category",
            description=u"category nested in self.category_nested_second",
            tree_parent=self.category_nested_second,
            site_id = self.site_id,
            slug=u"third-nested-category",
        )
        tools.assert_equals(self.category_nested, category_nested_third.get_root_category())

    def test_root_url(self):
        url = reverse('root_homepage')
        tools.assert_equals(url, self.category.get_absolute_url())

    def test_category_url(self):
        url = reverse('category_detail', args=(self.category_nested.tree_path, ))
        tools.assert_equals(url, self.category_nested.get_absolute_url())


########NEW FILE########
__FILENAME__ = test_custom_urls
# -*- coding: utf-8 -*-

from unittest import TestCase as UnitTestCase
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from django.http import Http404, HttpResponse
from django.core.urlresolvers import NoReverseMatch
from django.template import Template, Context

try:
    from django.conf.urls import patterns, url
except ImportError:
    from django.conf.urls.defaults import patterns, url

from ella.core.custom_urls import CustomURLResolver
from ella.core import custom_urls
from ella.core.models import Category

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable
from test_ella import template_loader

# dummy functions to register as views
def view(request, bits, context):
    return u"OK"

def second_view(request, bits, context):
    return request, bits, context

def custom_view(request, context):
    return u"OK"

def dummy_view(request, *args, **kwargs):
    return HttpResponse('dummy_view:%r,%r' % (args, kwargs))


class CustomObjectDetailTestCase(TestCase):
    urlpatterns = patterns('',
        url(r'^$', dummy_view, {'kwarg_from_patterns': 42}, name='prefix'),
        url(r'^new/(\d+)/$', dummy_view, name='prefix-new'),
        url(r'^add/(?P<kwarg_from_url>\d+)/$', dummy_view, name='prefix-add'),
    )

    def setUp(self):
        super(CustomObjectDetailTestCase, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)

        self.url = self.publishable.get_absolute_url()
        self.old_resolver = custom_urls.resolver
        custom_urls.resolver = CustomURLResolver()

    def tearDown(self):
        super(CustomObjectDetailTestCase, self).tearDown()
        template_loader.templates = {}
        custom_urls.resolver = self.old_resolver

class TestCustomURLTemplateTag(CustomObjectDetailTestCase):
    def test_view_with_no_args_resolves(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')
        t = Template('{% load custom_urls_tags %}{% custom_url object prefix %}')

        tools.assert_equals(self.url + 'prefix/', t.render(Context({'object': self.publishable})))

    def test_view_with_args_resolves(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')
        t = Template('{% load custom_urls_tags %}{% custom_url object prefix-new some_id %}')

        tools.assert_equals(self.url + 'prefix/new/44/', t.render(Context({'object': self.publishable, 'some_id': 44})))

    def test_view_with_kwargs_resolves(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')
        t = Template('{% load custom_urls_tags %}{% custom_url object prefix-add kwarg_from_url=12 %}')

        tools.assert_equals(self.url + 'prefix/add/12/', t.render(Context({'object': self.publishable})))


class TestObjectDetail(CustomObjectDetailTestCase):
    def test_categories_can_also_have_custom_defail(self):
        def my_custom_view(request, context):
            return HttpResponse('OK')

        custom_urls.resolver.register_custom_detail(Category, my_custom_view)

        response = self.client.get('/')
        tools.assert_equals(200, response.status_code)
        tools.assert_equals('OK', response.content)

    def test_custom_detail_view_called_when_registered(self):
        def my_custom_view(request, context):
            return HttpResponse('OK')

        custom_urls.resolver.register_custom_detail(self.publishable.__class__, my_custom_view)

        response = self.client.get(self.url)
        tools.assert_equals(200, response.status_code)
        tools.assert_equals('OK', response.content)

    def test_404_returned_when_view_not_registered(self):
        template_loader.templates['404.html'] = ''
        response = self.client.get(self.url + 'prefix/')
        tools.assert_equals(404, response.status_code)

    def test_custom_view_called_when_registered(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        response = self.client.get(self.url + 'prefix/')
        tools.assert_equals(200, response.status_code)

    def test_custom_view_called_when_registered_witth_args(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        response = self.client.get(self.url + 'prefix/add/41/')
        tools.assert_equals(200, response.status_code)


class TestCustomDetailRegistration(UnitTestCase):
    def setUp(self):
        super(TestCustomDetailRegistration, self).setUp()

        self.context = {'object': self}
        self.request = object()
        self.resolver = CustomURLResolver()

    def test_no_view_available_without_registration(self):
        tools.assert_raises(Http404, self.resolver._get_custom_detail_view, self.__class__)

    def test_registration_success(self):
        self.resolver.register_custom_detail(self.__class__, custom_view)
        tools.assert_equals(custom_view, self.resolver._get_custom_detail_view(self.__class__))

    def test_call_custom_detail_simple_success(self):
        self.resolver.register_custom_detail(self.__class__, custom_view)
        tools.assert_equals(u"OK", self.resolver.call_custom_detail(request=object(), context=self.context))



class TestCustomObjectDetailCallView(CustomObjectDetailTestCase):
    def test_view_with_args_called_correctly(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        response = custom_urls.resolver.call_custom_view(object(), self.publishable, 'prefix/new/42/', {'context': 1})
        tools.assert_equals(200, response.status_code)
        tools.assert_equals("dummy_view:({'context': 1}, '42'),{}", response.content)

    def test_view_with_kwargs_called_correctly(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        response = custom_urls.resolver.call_custom_view(object, self.publishable, 'prefix/add/52/', {'context': 1})
        tools.assert_equals(200, response.status_code)
        tools.assert_equals("dummy_view:({'context': 1},),{'kwarg_from_url': '52'}", response.content)

    def test_view_with_no_args_called_correctly(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        response = custom_urls.resolver.call_custom_view(object, self.publishable, 'prefix/', {'context': 1})
        tools.assert_equals(200, response.status_code)
        tools.assert_equals("dummy_view:({'context': 1},),{'kwarg_from_patterns': 42}", response.content)

    def test_404_raised_for_nonexitant_url(self):
        tools.assert_raises(Http404, custom_urls.resolver.call_custom_view, object(), self.publishable, 'prefix/', {})


class TestCustomObjectDetailResolver(CustomObjectDetailTestCase):
    def test_resolves_empty_url(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        view, args, kwargs = custom_urls.resolver.resolve(self.publishable, 'prefix/')
        tools.assert_equals(dummy_view, view)
        tools.assert_equals((), args)
        tools.assert_equals({'kwarg_from_patterns': 42}, kwargs)


    def test_resolves_url_with_arg(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        view, args, kwargs = custom_urls.resolver.resolve(self.publishable, 'prefix/new/43/')
        tools.assert_equals(dummy_view, view)
        tools.assert_equals(('43',), args)
        tools.assert_equals({}, kwargs)


    def test_resolves_url_with_kwarg(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        view, args, kwargs = custom_urls.resolver.resolve(self.publishable, 'prefix/add/44/')
        tools.assert_equals(dummy_view, view)
        tools.assert_equals((), args)
        tools.assert_equals({'kwarg_from_url': '44'}, kwargs)

    def test_resolves_url_without_start(self):
        custom_urls.resolver.register(self.urlpatterns)

        view, args, kwargs = custom_urls.resolver.resolve(self.publishable, 'add/44/')
        tools.assert_equals(dummy_view, view)
        tools.assert_equals((), args)
        tools.assert_equals({'kwarg_from_url': '44'}, kwargs)


    def test_raises_404_for_incorrect_url(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        tools.assert_raises(Http404, custom_urls.resolver.resolve, self.publishable, 'not-prefix/')

    def test_resolves_url_registered_for_one_model(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix', model=self.publishable.__class__)

        view, args, kwargs = custom_urls.resolver.resolve(self.publishable, 'prefix/')
        tools.assert_equals(dummy_view, view)
        tools.assert_equals((), args)
        tools.assert_equals({'kwarg_from_patterns': 42}, kwargs)

    def test_raises_404_for_url_registered_for_different_model_only(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix', model=self.category.__class__)

        tools.assert_raises(Http404, custom_urls.resolver.resolve, self.publishable, 'prefix/')


class TestCustomObjectDetailReverse(CustomObjectDetailTestCase):
    def test_works_without_args(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        tools.assert_equals(self.url + 'prefix/', custom_urls.resolver.reverse(self.publishable, 'prefix'))

    def test_works_with_args(self):
        custom_urls.resolver.register(self.urlpatterns)

        tools.assert_equals(self.url + 'new/41/', custom_urls.resolver.reverse(self.publishable, 'prefix-new', 41))

    def test_works_with_kwargs(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix')

        tools.assert_equals(self.url + 'prefix/add/42/', custom_urls.resolver.reverse(self.publishable, 'prefix-add', kwarg_from_url=42))

    def test_works_if_registered_for_one_model(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix', model=self.publishable.__class__)

        tools.assert_equals(self.url + 'prefix/', custom_urls.resolver.reverse(self.publishable, 'prefix'))

    def test_doesnt_find_url_if_registered_for_different_model_only(self):
        custom_urls.resolver.register(self.urlpatterns, prefix='prefix', model=self.category.__class__)

        tools.assert_raises(NoReverseMatch,  custom_urls.resolver.reverse, self.publishable, 'prefix')


########NEW FILE########
__FILENAME__ = test_feeds
# -*- coding: utf-8 -*-
from test_ella.cases import RedisTestCase as TestCase

from nose import tools, SkipTest

from django.core.urlresolvers import reverse
from django.template import Context

from ella.core.models import Listing
from ella.core.feeds import RSSTopCategoryListings
from ella.photos.models import Format

from test_ella.test_core import create_basic_categories, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour
from test_ella import template_loader

class TestFeeds(TestCase):

    def setUp(self):
        try:
            import feedparser
        except ImportError:
            raise SkipTest()

        super(TestFeeds, self).setUp()
        create_basic_categories(self)
        create_and_place_more_publishables(self)
        list_all_publishables_in_category_by_hour(self)


        self._feeder = RSSTopCategoryListings()

    def tearDown(self):
        super(TestFeeds, self).tearDown()
        template_loader.templates.clear()

    def _set_photo(self):
        from test_ella.test_photos.fixtures import create_photo

        photo = create_photo(self)

        self.publishables[0].photo = photo
        self.publishables[0].save()
        # update the cache on the Listing object
        self.listings[0].publishable = self.publishables[0]

    def test_rss(self):
        import feedparser
        Listing.objects.all().update(category=self.category)
        url = reverse('home_rss_feed')
        c = self.client

        response = c.get(url)
        tools.assert_equals(200, response.status_code)
        d = feedparser.parse(response.content)

        tools.assert_equals(len(self.publishables), len(d['items']))

    def test_guids_set_properly_in_rss(self):
        import feedparser
        Listing.objects.all().update(category=self.category)
        url = reverse('home_atom_feed')
        c = self.client

        response = c.get(url)
        tools.assert_equals(200, response.status_code)
        d = feedparser.parse(response.content)

        tools.assert_equals(len(d['items']), len(set(i['guid'] for i in d['items'])))

    def test_atom(self):
        import feedparser
        Listing.objects.all().update(category=self.category)
        url = reverse('home_atom_feed')
        c = self.client

        response = c.get(url)
        tools.assert_equals(200, response.status_code)
        d = feedparser.parse(response.content)

        tools.assert_equals(len(self.publishables), len(d['items']))

    def test_title_defaults_to_category_title(self):
        tools.assert_true(self._feeder.title(self.category), self.category.title)

    def test_title_uses_app_data_when_set(self):
        self.category.app_data = {'syndication': {'title': 'SYNDICATION_TITLE'}}
        tools.assert_true(self._feeder.title(self.category), 'SYNDICATION_TITLE')

    def test_description_defaults_to_category_title(self):
        tools.assert_true(self._feeder.title(self.category), self.category.title)

    def test_description_uses_app_data_when_set(self):
        self.category.app_data = {'syndication': {'description': 'SYNDICATION_DESCRIPTION'}}
        tools.assert_true(self._feeder.description(self.category), 'SYNDICATION_DESCRIPTION')

    def test_no_enclosure_when_format_not_set(self):
        feeder = RSSTopCategoryListings()
        feeder.format = None
        self._set_photo()
        tools.assert_true(self.publishables[0].photo is not None)
        tools.assert_equals(None, feeder.item_enclosure_url(self.listings[0]))

    def test_get_enclosure_uses_optional_hook_on_publishable(self):
        class A(object):
            @property
            def publishable(self):
                return self

            def feed_enclosure(self):
                return {'url': 'URL', 'size': 1000}

        tools.assert_equals('URL', self._feeder.item_enclosure_url(A()))
        tools.assert_equals(1000, self._feeder.item_enclosure_length(A()))

    def test_get_enclosure_uses_formated_photo_when_format_available(self):
        f = Format.objects.create(name='enc_format', max_width=10, max_height=10,
            flexible_height=False, stretch=False, nocrop=False)

        feeder = RSSTopCategoryListings()
        feeder.format = f

        self._set_photo()
        tools.assert_true(self.publishables[0].photo is not None)
        original = self.publishables[0].photo.image
        new = self._feeder.item_enclosure_url(self.listings[0])
        tools.assert_not_equals(unicode(original), unicode(new))

    def test_get_enclosure_returns_none_when_no_image_set(self):
        tools.assert_equals(self._feeder.item_enclosure_url(self.listings[0]), None)

    def test_item_description_defaults_to_publishable_description(self):
        feeder = RSSTopCategoryListings()
        feeder.box_context = {}
        tools.assert_equals(self.publishables[-1].description, feeder.item_description(self.listings[0]))

    def test_box_rss_description_can_override_rss_description(self):
        template_loader.templates['box/rss_description.html'] = 'XXX'
        feeder = RSSTopCategoryListings()
        feeder.box_context = Context({})
        tools.assert_equals('XXX', feeder.item_description(self.listings[0]))

    def test_guid_is_set_properly(self):
        feeder = RSSTopCategoryListings()
        tools.assert_equals(str(self.publishables[-1].pk), feeder.item_guid(self.listings[0]))


########NEW FILE########
__FILENAME__ = test_listing
# -*- coding: utf-8 -*-
from datetime import timedelta

from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from ella.core.models import Listing, Category
from ella.core.managers import ListingHandler
from ella.utils.timezone import now

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour

class TestListing(TestCase):

    def setUp(self):
        super(TestListing, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)
        create_and_place_more_publishables(self)
        list_all_publishables_in_category_by_hour(self)

    def test_nested_listings(self):
        list_all_publishables_in_category_by_hour(self, category=self.category_nested_second)
        list_all_publishables_in_category_by_hour(self, category=self.category_nested)
        l = Listing.objects.get_listing(category=self.category_nested, children=ListingHandler.ALL)
        tools.assert_equals(self.listings, list(l))

    def test_get_listing_empty(self):
        c = Category.objects.create(
            title=u"third nested category",
            description=u"category nested in case.category_nested_second",
            tree_parent=self.category_nested_second,
            site_id = self.site_id,
            slug=u"third-nested-category",
        )

        l = Listing.objects.get_listing(category=c)
        tools.assert_equals(0, len(l))

    def test_get_listing_with_immediate_children(self):
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.IMMEDIATE)
        expected = [listing for listing in self.listings if listing.category in (self.category, self.category_nested)]
        tools.assert_equals(expected, l)

    def test_listing_only_contains_published_items(self):
        potential = [listing for listing in self.listings if listing.category in (self.category, self.category_nested)]
        actual = potential.pop()
        expected = [actual]
        for l in potential:
            if l.publishable != actual.publishable:
                l.publishable.published = False
                l.publishable.save()
            else:
                expected.append(l)
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.IMMEDIATE)
        tools.assert_equals(expected, l)


    def test_get_listing_with_immediate_children_no_duplicates(self):
        expected = [listing for listing in self.listings if listing.category in (self.category, self.category_nested)]

        listing = Listing.objects.create(
                publishable=expected[0].publishable,
                category=expected[0].category,
                publish_from=now() - timedelta(days=2),
            )
        expected[0] = listing
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.IMMEDIATE)
        tools.assert_equals(expected, l)

    def test_get_listing_with_all_children_no_duplicates(self):
        listing = Listing.objects.create(
                publishable=self.publishables[0],
                category=self.category_nested_second,
                publish_from=now() - timedelta(days=2),
            )

        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.ALL)
        tools.assert_equals(len(self.listings), len(l))
        tools.assert_equals(listing, l[0])

    def test_get_listing_IMMEDIATE_without_limited_categories(self):
        self.category_nested.app_data = {'ella': {'propagate_listings': False}}
        self.category_nested.save()
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.IMMEDIATE)
        tools.assert_equals(1, len(l))
        tools.assert_equals([listing for listing in self.listings if listing.category == self.category], l)

    def test_get_listing_ALL_without_limited_categories(self):
        self.category_nested.app_data = {'ella': {'propagate_listings': False}}
        self.category_nested.save()
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.ALL)
        tools.assert_equals(1, len(l))
        tools.assert_equals([listing for listing in self.listings if listing.category == self.category], l)

    def test_get_listing_with_all_children(self):
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.ALL)
        tools.assert_equals(self.listings, list(l))

    def test_inactive_listings_wont_show(self):
        l = self.listings[0]
        l.publish_to = now() - timedelta(days=1)
        l.save()

        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.ALL)

        tools.assert_equals(self.listings[1:], l)

    def test_excluded_publishable_wont_show(self):
        l = self.listings[0]
        l = Listing.objects.get_listing(category=self.category, children=ListingHandler.ALL, exclude=l.publishable)
        tools.assert_equals(self.listings[1:], l)

    def test_queryset_wrapper_can_get_individual_listings(self):
        lh = Listing.objects.get_queryset_wrapper(self.category, children=ListingHandler.ALL)
        l = lh[0]
        tools.assert_equals(self.listings[0], l)


########NEW FILE########
__FILENAME__ = test_publishable
# -*- coding: utf-8 -*-
from datetime import timedelta, datetime
import pytz

from test_ella.cases import RedisTestCase as TestCase
from django.contrib.sites.models import Site
from django.contrib.redirects.models import Redirect
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import ValidationError

from ella.core.models import Category, Publishable
from ella.core import signals
from ella.core.management import generate_publish_signals
from ella.utils import timezone

from nose import tools, SkipTest

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, default_time

class PublishableTestCase(TestCase):
    def setUp(self):
        super(PublishableTestCase, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)

class TestLastUpdated(PublishableTestCase):
    def test_last_updated_moved_if_default(self):
        now = timezone.now()
        self.publishable.publish_from = now
        self.publishable.save(force_update=True)
        tools.assert_equals(now, self.publishable.last_updated)

    def test_last_updated_isnt_moved_if_changed(self):
        now = timezone.now()
        self.publishable.last_updated = now + timedelta(days=1)
        self.publishable.publish_from = now
        self.publishable.save(force_update=True)
        tools.assert_equals(now + timedelta(days=1), self.publishable.last_updated)

class TestPublishableHelpers(PublishableTestCase):
    def test_url(self):
        tools.assert_equals('/nested-category/2008/1/10/first-article/', self.publishable.get_absolute_url())

    def test_tz_aware_url(self):
        if not timezone.use_tz:
            raise SkipTest()
        utc = pytz.timezone('UTC')
        self.publishable.publish_from = datetime(2008, 1, 9, 23, 50, 0, tzinfo=utc)
        tools.assert_equals('/nested-category/2008/1/10/first-article/', self.publishable.get_absolute_url())

    def test_domain_url(self):
        tools.assert_equals('http://example.com/nested-category/2008/1/10/first-article/', self.publishable.get_domain_url())

    def test_app_data(self):
        tools.assert_equals({}, self.publishable.app_data)
        self.publishable.app_data['core'] = 'testing'
        self.publishable.save()

        p = self.publishable.content_type.get_object_for_this_type(pk=self.publishable.pk)
        tools.assert_equals({'core': 'testing'}, self.publishable.app_data)

    def test_saving_base_publishable_does_not_update_content_type(self):
        publishable_ct = ContentType.objects.get_for_model(Publishable)
        current_ct = self.publishable.content_type
        tools.assert_not_equals(publishable_ct, current_ct)

        p = Publishable.objects.get(pk=self.publishable.pk)
        p.save()
        tools.assert_equals(current_ct, p.content_type)


class TestRedirects(PublishableTestCase):
    def test_url_change_creates_redirect(self):
        self.publishable.slug = 'old-article-new-slug'
        self.publishable.save()
        tools.assert_equals(1, Redirect.objects.count())
        r = Redirect.objects.all()[0]

        tools.assert_equals('/nested-category/2008/1/10/first-article/', r.old_path)
        tools.assert_equals('/nested-category/2008/1/10/old-article-new-slug/', r.new_path)
        tools.assert_equals(self.site_id, r.site_id)

    def test_url_change_updates_existing_redirects(self):
        r = Redirect.objects.create(site_id=self.site_id, new_path='/nested-category/2008/1/10/first-article/', old_path='some-path')
        self.publishable.slug = 'old-article-new-slug'
        self.publishable.save()
        tools.assert_equals(2, Redirect.objects.count())
        r = Redirect.objects.get(pk=r.pk)

        tools.assert_equals('some-path', r.old_path)
        tools.assert_equals('/nested-category/2008/1/10/old-article-new-slug/', r.new_path)
        tools.assert_equals(self.site_id, r.site_id)

    def test_ability_to_place_back_and_forth(self):
        self.publishable.slug = 'old-article-new-slug'
        self.publishable.save()
        self.publishable.slug = 'first-article'
        self.publishable.save()
        self.publishable.slug = 'old-article-new-slug'
        self.publishable.save()


class TestUrl(PublishableTestCase):
    def test_home_url(self):
        self.publishable.category = self.category
        self.publishable.save()
        tools.assert_equals('/2008/1/10/first-article/', self.publishable.get_absolute_url())

    def test_url(self):
        tools.assert_equals('/nested-category/2008/1/10/first-article/', self.publishable.get_absolute_url())

    def test_url_on_other_site(self):
        site = Site.objects.create(
            name='some site',
            domain='not-example.com'
        )

        category = Category.objects.create(
            title=u" category",
            description=u"example testing category, second site",
            site=site,
            slug=u'zai-jian-category',
        )

        self.publishable.category = category
        self.publishable.publish_from = default_time
        self.publishable.save()

        tools.assert_equals(u'http://not-example.com/2008/1/10/first-article/', self.publishable.get_absolute_url())

    def test_unique_url_validation(self):
        self.publishable.pk = None
        tools.assert_raises(ValidationError, self.publishable.full_clean)

    def test_url_is_tested_for_published_objects_only(self):
        self.publishable.pk = None
        self.publishable.published = False
        self.publishable.full_clean()


class TestSignals(TestCase):
    def setUp(self):
        super(TestSignals, self).setUp()
        signals.content_published.connect(self.publish)
        signals.content_unpublished.connect(self.unpublish)
        self._signal_clear()
        create_basic_categories(self)
        create_and_place_a_publishable(self)

    def tearDown(self):
        super(TestSignals, self).tearDown()
        signals.content_published.disconnect(self.publish)
        signals.content_unpublished.disconnect(self.unpublish)

    def _signal_clear(self):
        self.publish_received = []
        self.unpublish_received = []

    # signal handlers
    def publish(self, **kwargs):
        self.publish_received.append(kwargs)

    def unpublish(self, **kwargs):
        self.unpublish_received.append(kwargs)

    def test_publishable_is_announced_on_save(self):
        tools.assert_true(self.publishable.announced)
        tools.assert_equals(1, len(self.publish_received))
        tools.assert_equals(0, len(self.unpublish_received))
        tools.assert_equals(self.publishable, self.publish_received[0]['publishable'])

    def test_unpublish_sent_when_takedown_occurs(self):
        self._signal_clear()
        self.publishable.published = False
        self.publishable.save()
        tools.assert_false(self.publishable.announced)
        tools.assert_equals(0, len(self.publish_received))
        tools.assert_equals(1, len(self.unpublish_received))
        tools.assert_equals(self.publishable, self.unpublish_received[0]['publishable'])

    def test_generate_doesnt_issue_signal_twice(self):
        self._signal_clear()
        generate_publish_signals()
        tools.assert_equals(0, len(self.publish_received))
        tools.assert_equals(0, len(self.unpublish_received))

    def test_generate_picks_up_on_takedown(self):
        self.publishable.publish_to = timezone.now() + timedelta(days=1)
        self.publishable.save()
        self._signal_clear()
        generate_publish_signals(timezone.now() + timedelta(days=1, seconds=2))
        tools.assert_equals(0, len(self.publish_received))
        tools.assert_equals(1, len(self.unpublish_received))
        tools.assert_equals(self.publishable, self.unpublish_received[0]['publishable'].target)

    def test_generate_picks_up_on_publish(self):
        self.publishable.publish_from = timezone.now() + timedelta(days=1)
        self.publishable.save()
        self._signal_clear()
        generate_publish_signals(timezone.now() + timedelta(days=1, seconds=2))
        tools.assert_equals(1, len(self.publish_received))
        tools.assert_equals(0, len(self.unpublish_received))
        tools.assert_equals(self.publishable, self.publish_received[0]['publishable'].target)


########NEW FILE########
__FILENAME__ = test_related
# -*- coding: utf-8 -*-
from unittest import TestCase as UnitTestCase
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from ella.articles.models import Article
from ella.core.models import Related, Publishable
from ella.core.templatetags.related import parse_related_tag
from ella.photos.models import Photo

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour

class GetRelatedTestCase(TestCase):
    def setUp(self):
        super(GetRelatedTestCase, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)
        create_and_place_more_publishables(self)

        Publishable.objects.all().update(category=self.publishable.category)

        list_all_publishables_in_category_by_hour(self, category=self.publishable.category)

class TestDefaultRelatedFinder(GetRelatedTestCase):
    def test_returns_unique_objects_or_shorter_list_if_not_available(self):
        expected = map(lambda x: x.pk, reversed(self.publishables))
        tools.assert_equals(
                expected,
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, len(expected)*3)]
            )

    def test_returns_publishables_listed_in_same_cat_if_no_related(self):
        expected = map(lambda x: x.pk, reversed(self.publishables))
        tools.assert_equals(
                expected,
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, len(expected))]
            )


    def test_returns_at_most_count_objects(self):
        tools.assert_equals(
                [self.publishables[-1].pk],
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, 1)]
            )

    def test_returns_manual_objects_of_correct_model_type_first(self):
        r = Related(publishable=self.publishable)
        r.related = self.publishables[0]
        r.save()

        tools.assert_equals(
                [self.publishables[0].pk, self.publishables[-1].pk],
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, 2, mods=[self.publishable.__class__])]
            )

    def test_returns_manual_objects_first(self):
        r = Related(publishable=self.publishable)
        r.related = self.category
        r.save()

        tools.assert_equals(
                [self.category, self.publishables[-1]],
                Related.objects.get_related_for_object(self.publishable, 2)
            )

    def test_returns_only_manual_objects_when_direct_finder_specified(self):
        r = Related(publishable=self.publishable)
        r.related = self.publishables[0]
        r.save()

        tools.assert_equals(
                [self.publishables[0].pk],
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, 2, finder='directly')]
            )

    def test_returns_unique_objects(self):
        r = Related(publishable=self.publishable)
        r.related = self.publishables[-2]
        r.save()

        tools.assert_equals(
                [self.publishables[-2].pk, self.publishables[-1].pk, self.publishables[-3].pk],
                [p.pk for p in Related.objects.get_related_for_object(self.publishable, 3)]
            )

    def test_returns_empty_if_no_object_of_given_model_is_available(self):
        r = Related(publishable=self.publishables[0])
        r.related = self.publishable
        r.save()
        tools.assert_equals([], Related.objects.get_related_for_object(self.publishable, 3, mods=[Related]))


class TestRelatedTagParser(UnitTestCase):
    '''
    {% related N [app_label.Model, ...] for object as var_name %}
    '''
    def setUp(self):
        super(TestRelatedTagParser, self).setUp()
        self.minimal_args = ['related', '10', 'for', 'obj_var', 'as', 'some_var']

    def test_minimal_args(self):
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([], mods)
        tools.assert_equals(None, finder)

    def test_limit_bu_model(self):
        self.minimal_args.insert(2, 'articles.article')
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([Article], mods)
        tools.assert_equals(None, finder)

    def test_limit_bu_more_models(self):
        self.minimal_args.insert(2, 'articles.article,photos.photo')
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([Article, Photo], mods)
        tools.assert_equals(None, finder)

    def test_limit_bu_more_models_with_space(self):
        self.minimal_args.insert(2, 'articles.article,')
        self.minimal_args.insert(3, 'photos.photo')
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([Article, Photo], mods)
        tools.assert_equals(None, finder)

    def test_limit_bu_more_models_with_spaces_around_comma(self):
        self.minimal_args.insert(2, 'articles.article')
        self.minimal_args.insert(3, ',')
        self.minimal_args.insert(4, 'photos.photo')
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([Article, Photo], mods)
        tools.assert_equals(None, finder)

    def test_finder_is_defined_before_model_specs(self):
        self.minimal_args.insert(2, 'directly')
        self.minimal_args.insert(3, 'articles.article')
        self.minimal_args.insert(4, ',')
        self.minimal_args.insert(5, 'photos.photo')
        obj_var, count, var_name, mods, finder = parse_related_tag(self.minimal_args)
        tools.assert_equals('obj_var', obj_var)
        tools.assert_equals(10, count)
        tools.assert_equals('some_var', var_name)
        tools.assert_equals([Article, Photo], mods)
        tools.assert_equals("directly", finder)


########NEW FILE########
__FILENAME__ = test_templatetags
# -*- coding: utf-8 -*-
from unittest import TestCase as UnitTestCase

from nose import tools, SkipTest

import django
from django import template
from django.template import TemplateSyntaxError
from django.contrib.sites.models import Site
from django.contrib.contenttypes.models import ContentType
from django.core.paginator import Paginator
from django.test import RequestFactory

from ella.core.templatetags.core import listing_parse, _parse_box, BoxNode, EmptyNode
from ella.core.templatetags.pagination import _do_paginator
from ella.core.models import Category
from ella.core.managers import ListingHandler
from ella.articles.models import Article
from ella.photos.models import Photo

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour
from test_ella import template_loader
from test_ella.cases import RedisTestCase as TestCase

class TestPaginate(UnitTestCase):
    def setUp(self):
        super(TestPaginate, self).setUp()
        self.rf = RequestFactory()

    def tearDown(self):
        super(TestPaginate, self).tearDown()
        template_loader.templates = {}

    def test_all_querysting_is_included(self):
        req = self.rf.get('/', {'using': 'custom_lh', 'other': 'param with spaces'})
        page = Paginator(range(100), 10).page(2)

        context = {
            'request': req,
            'page': page
        }

        tools.assert_equals((('inclusion_tags/paginator.html', 'inc/paginator.html'), {
            'page': page,
            'page_numbers': [1, 2, 3, 4, 5],
            'query_params': '?using=custom_lh&other=param+with+spaces&p=',
            'results_per_page': 10,
            'show_first': False,
            'show_last': True
        }), _do_paginator(context, 2, None))

    def test_always_include_given_number_of_pages(self):
        page = Paginator(range(100), 9).page(1)
        tools.assert_equals((('inclusion_tags/paginator_special.html', 'inc/paginator_special.html'), {
            'page': page,
            'page_numbers': [1, 2, 3, 4, 5, 6, 7],
            'query_params': '?p=',
            'results_per_page': 9,
            'show_first': False,
            'show_last': True
        }), _do_paginator({'page': page}, 3, 'special'))

    def test_dont_fail_on_missing_page(self):
        tools.assert_equals((('inclusion_tags/paginator.html', 'inc/paginator.html'), {}), _do_paginator({}, 2, None))

    def test_proper_template_gets_rendered(self):
        template_loader.templates['inclusion_tags/paginator_special.html'] = 'special'
        t = template.Template('{% load pagination %}{% paginator 1 "special" %}')
        tools.assert_equals('special', t.render(template.Context()))

    def test_proper_template_gets_rendered_via_kwargs(self):
        if django.VERSION[:2] < (1, 4):
            raise SkipTest()
        template_loader.templates['inclusion_tags/paginator_special.html'] = 'special'
        t = template.Template('{% load pagination %}{% paginator template_name="special" %}')
        tools.assert_equals('special', t.render(template.Context()))

    def test_adjacent_places_get_passed_from_template(self):
        page = Paginator(range(100), 9).page(1)
        template_loader.templates['inclusion_tags/paginator.html'] = '{{ page_numbers|join:", "}}'
        t = template.Template('{% load pagination %}{% paginator 1 %}')
        tools.assert_equals('1, 2, 3', t.render(template.Context({'page': page})))




class TestRenderTag(UnitTestCase):
    def test_raises_error_on_no_args(self):
        t = '{% render %}'
        tools.assert_raises(template.TemplateSyntaxError, template.Template, t)

    def test_raises_error_on_more_args(self):
        t = '{% render 1 2 3 %}'
        tools.assert_raises(template.TemplateSyntaxError, template.Template, t)

    def test_fail_silently_on_empty_var(self):
        t = template.Template('{% render var_name %}')
        tools.assert_equals('', t.render(template.Context()))

    def test_renders_var(self):
        t = template.Template('{% render var %}')
        tools.assert_equals('XXX', t.render(template.Context({'var': 'XXX'})))

    def test_renders_nested_var(self):
        t = template.Template('{% render var.subvar.subsubvar %}')
        var = {'subvar': {'subsubvar': 'XXX'}}
        tools.assert_equals('XXX', t.render(template.Context({'var': var})))

    def test_renders_var_in_context(self):
        t = template.Template('{% render var %}')
        tools.assert_equals('YYY', t.render(template.Context({'var': '{{ other_var }}', 'other_var' : 'YYY'})))

    def test_does_not_escape_output(self):
        t = template.Template('{% render var %}')
        tools.assert_equals('<html> ""', t.render(template.Context({'var': '<html> ""'})))

class TestListingTag(TestCase):
    def setUp(self):
        super(TestListingTag, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)
        create_and_place_more_publishables(self)
        list_all_publishables_in_category_by_hour(self)

    def test_get_listing(self):
        t = template.Template('{% listing 10 for category as var %}{{ var|join:":" }}')
        expected = ':'.join([str(listing) for listing in self.listings if listing.category == self.category])
        tools.assert_equals(expected, t.render(template.Context({'category': self.category})))

    def test_get_listing_with_immediate_children(self):
        t = template.Template('{% listing 10 for category with children as var %}{{ var|join:":" }}')
        expected = ':'.join([str(listing) for listing in self.listings if listing.category in (self.category, self.category_nested)])
        tools.assert_equals(expected, t.render(template.Context({'category': self.category})))

    def test_get_listing_with_immediate_children_and_offset(self):
        t = template.Template('{% listing 10 from 2 for category with children as var %}{{ var|join:":" }}')
        expected = ':'.join([str(listing) for listing in self.listings if listing.category in (self.category, self.category_nested)][1:])
        tools.assert_equals(expected, t.render(template.Context({'category': self.category})))

    def test_get_listing_with_immediate_children_offset_and_count(self):
        t = template.Template('{% listing 1 from 2 for category with children as var %}{{ var|join:":" }}')
        expected = [str(listing) for listing in self.listings if listing.category in (self.category, self.category_nested)][1]
        tools.assert_equals(expected, t.render(template.Context({'category': self.category})))

    def test_get_listing_without_a_publishable(self):
        t = template.Template('{% listing 10 for category without p as var %}{{ var|join:":" }}')
        tools.assert_equals('', t.render(template.Context({'category': self.category, 'p': self.publishables[0]})))

class TestListingTagParser(TestCase):
    '''
    {% listing <limit>[ from <offset>][of <app.model>[, <app.model>[, ...]]][ for <category> ] [with children|descendents] as <result> %}
    '''

    def setUp(self):
        self.act = ContentType.objects.get_for_model(Article)
        self.pct = ContentType.objects.get_for_model(Photo)
        super(TestListingTagParser, self).setUp()
        create_basic_categories(self)

    def test_minimal_args(self):
        var_name, parameters = listing_parse(['listing', '1', 'as', 'var'])
        tools.assert_equals('var', var_name)
        tools.assert_equals(1, parameters['count'].literal)

    def test_offset(self):
        var_name, parameters = listing_parse(['listing', '1', 'from', '10', 'as', 'var'])
        tools.assert_equals(10, parameters['offset'].literal)

    def test_limit_by_model(self):
        var_name, parameters = listing_parse(['listing', '1', 'of', 'articles.article', 'as', 'var'])
        tools.assert_equals('var', var_name)
        tools.assert_equals(1, parameters['count'].literal)
        tools.assert_equals([self.act], parameters['content_types'])

    def test_limit_bu_more_models(self):
        var_name, parameters = listing_parse(['listing', '1', 'of', 'articles.article,photos.photo', 'as', 'var'])
        tools.assert_equals([self.act, self.pct], parameters['content_types'])

    def test_limit_bu_more_models_space(self):
        var_name, parameters = listing_parse(['listing', '1', 'of', 'articles.article,', 'photos.photo', 'as', 'var'])
        tools.assert_equals([self.act, self.pct], parameters['content_types'])

    def test_limit_bu_more_models_space_around_comma(self):
        var_name, parameters = listing_parse(['listing', '1', 'of', 'articles.article', ',', 'photos.photo', 'as', 'var'])
        tools.assert_equals([self.act, self.pct], parameters['content_types'])

    def test_limit_by_category(self):
        var_name, parameters = listing_parse(['listing', '1', 'for', 'category', 'as', 'var'])
        tools.assert_equals('category', parameters['category'].var)

    def test_limit_by_category_with_descendents(self):
        var_name, parameters = listing_parse(['listing', '1', 'for', 'category', 'with', 'descendents', 'as', 'var'])
        tools.assert_equals('category', parameters['category'].var)
        tools.assert_equals(ListingHandler.ALL, parameters['children'])

    def test_limit_by_category_with_children(self):
        var_name, parameters = listing_parse(['listing', '1', 'for', 'category', 'with', 'children', 'as', 'var'])
        tools.assert_equals('category', parameters['category'].var)
        tools.assert_equals(ListingHandler.IMMEDIATE, parameters['children'])

    def test_ct_with_desc_using(self):
        var_name, parameters = listing_parse("listing 10 of articles.article with descendents using 'most-viewed' as most_viewed_listings".split())
        tools.assert_equals(ListingHandler.ALL, parameters['children'])
        tools.assert_equals(Category.objects.get_by_tree_path(''), parameters['category'])

class TestBoxTag(UnitTestCase):

    def tearDown(self):
        super(TestBoxTag, self).tearDown()
        template_loader.templates = {}

    def test_renders_correct_template(self):
        template_loader.templates['box/box.html'] = '{{ object }}'
        t = template.Template('{% box name for sites.site with pk 1 %}{% endbox %}')
        tools.assert_equals('example.com', t.render(template.Context()))

    def test_params_are_parsed(self):
        template_loader.templates['box/box.html'] = '{% for k,v in box.params.items %}{{k}}:{{v}}|{% endfor %}'
        t = template.Template('''{% box name for sites.site with pk 1 %}
                level: 2
                some_other_param: xxx
            {% endbox %}''')
        tools.assert_equals('some_other_param:xxx|level:2|', t.render(template.Context()))

    def test_box_wirks_with_variable_instead_of_lookup(self):
        site = Site.objects.get(pk=1)
        template_loader.templates['box/box.html'] = '{{ object }}'
        t = template.Template('{% box name for var %}{% endbox %}')
        tools.assert_equals('example.com', t.render(template.Context({'var': site})))

    def test_box_for_empty_object_renders_empty(self):
        template_loader.templates['box/box.html'] = 'XXX'
        t = template.Template('{% box name for var %}{% endbox %}')
        tools.assert_equals('', t.render(template.Context({'var': None})))

class TestBoxTagParser(UnitTestCase):
    def test_parse_box_with_pk(self):
        node = _parse_box([], ['box', 'box_type', 'for', 'core.category', 'with', 'pk', '1'])
        tools.assert_true(isinstance(node, BoxNode))
        tools.assert_equals('box_type', node.box_type)
        tools.assert_equals(Category, node.model)
        tools.assert_equals(('pk', 1), node.lookup)

    def test_parse_box_for_varname(self):
        node = _parse_box([], ['box', 'other_box_type', 'for', 'var_name'])
        tools.assert_true(isinstance(node, BoxNode))
        tools.assert_equals('other_box_type', node.box_type)
        tools.assert_equals('var_name', node.var.var)

    def test_parse_box_with_slug(self):
        node = _parse_box([], ['box', 'box_type', 'for', 'sites.site', 'with', 'slug', '"home"'])
        tools.assert_true(isinstance(node, BoxNode))
        tools.assert_equals('box_type', node.box_type)
        tools.assert_equals(Site, node.model)
        tools.assert_equals(('slug', 'home'), node.lookup)

    def test_parse_raises_on_too_many_arguments(self):
        tools.assert_raises(TemplateSyntaxError, _parse_box, [], ['box', 'box_type', 'for', 'core.category', 'with', 'pk', '1', '2', 'extra'])

    def test_parse_raises_on_too_few_arguments(self):
        tools.assert_raises(TemplateSyntaxError, _parse_box, [], ['box', 'box_type', 'for'])

    def test_parse_raises_on_incorrect_arguments(self):
        tools.assert_raises(TemplateSyntaxError, _parse_box, [], ['box', 'box_type', 'not a for', 'core.category', 'with', 'pk', '1'])

    def test_parse_return_empty_node_on_incorrect_model(self):
        node = _parse_box([], ['box', 'box_type', 'for', 'not_app.not_model', 'with', 'pk', '1'])
        tools.assert_true(isinstance(node, EmptyNode))


########NEW FILE########
__FILENAME__ = test_views
# -*- coding: utf-8 -*-

from datetime import datetime
from test_ella.cases import RedisTestCase as TestCase

from nose import tools, SkipTest

from django.contrib.contenttypes.models import ContentType
from django.template.defaultfilters import slugify
from django.template import TemplateDoesNotExist

from ella.core.models import Listing
from ella.utils import timezone

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour
from test_ella import template_loader

from ella.core.models import Category, Author
from ella.core.views import get_templates
from ella.core.signals import object_rendering, object_rendered
from ella.core.cache import utils

class ViewsTestCase(TestCase):
    def setUp(self):
        super(ViewsTestCase, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)
        self.signals_received = {}
        object_rendering.connect(self.object_rendering)
        object_rendered.connect(self.object_rendered)

    def object_rendered(self, *args, **kwargs):
        self.signals_received.setdefault('object_rendered', []).append((args, kwargs))

    def object_rendering(self, *args, **kwargs):
        self.signals_received.setdefault('object_rendering', []).append((args, kwargs))

    def tearDown(self):
        super(ViewsTestCase, self).tearDown()
        template_loader.templates = {}
        object_rendering.disconnect(self.object_rendering)
        object_rendered.disconnect(self.object_rendered)
        utils.PUBLISHABLE_CT = None

class TestAuthorView(ViewsTestCase):
    def test_author_view(self):
        author = Author.objects.create(slug='some-author')
        create_and_place_more_publishables(self)
        for p in self.publishables:
            p.authors.add(author)
        list_all_publishables_in_category_by_hour(self)

        template_loader.templates['page/author.html'] = 'page/category.html'
        response = self.client.get(author.get_absolute_url())
        tools.assert_true('listings' in response.context)
        tools.assert_equals(set(p.pk for p in self.publishables), set(l.publishable.pk for l in response.context['listings']))

class TestCategoryDetail(ViewsTestCase):
    def test_fail_on_no_template(self):
        tools.assert_raises(TemplateDoesNotExist, self.client.get, '/')

    def test_template_overloading(self):
        template_loader.templates['page/category.html'] = 'page/category.html'
        template_loader.templates['page/category/ni-hao-category/%s' % self.category.template] = 'page/category/ni-hao-category/category.html'
        response = self.client.get('/')
        tools.assert_equals('page/category/ni-hao-category/category.html', response.content)

    def test_signals_fired_for_homepage(self):
        template_loader.templates['page/category.html'] = 'page/category.html'
        self.client.get('/')
        tools.assert_equals(1, len(self.signals_received['object_rendering']))
        tools.assert_equals(1, len(self.signals_received['object_rendered']))

        kwargs = self.signals_received['object_rendered'][0][1]
        tools.assert_equals(set(['sender', 'request', 'category', 'publishable', 'signal']), set(kwargs.keys()))
        tools.assert_equals(self.category, kwargs['category'])
        tools.assert_equals(Category, kwargs['sender'])
        tools.assert_equals(None, kwargs['publishable'])

    def test_second_nested_template_overloading(self):
        tp = 'nested-category/second-nested-category'
        ctp = self.category_nested_second.template
        template_loader.templates['page/category.html'] = 'page/category.html'
        template_loader.templates['page/category/%s/%s' % (tp, ctp)] = 'page/category/%s/category.html' % tp
        response = self.client.get('/%s/' % tp)
        tools.assert_equals('page/category/%s/category.html' % tp, response.content)

    def test_homepage_context(self):
        template_loader.templates['page/category.html'] = ''
        response = self.client.get('/')
        tools.assert_true('category' in response.context)
        tools.assert_equals(self.category, response.context['category'])

    def test_second_nested_category_view(self):
        template_loader.templates['page/category.html'] = ''
        response = self.client.get('/nested-category/second-nested-category/')
        tools.assert_true('category' in response.context)
        tools.assert_equals(self.category_nested_second, response.context['category'])

    def test_category_template_is_used_in_view(self):
        self.category.template = 'static_page.html'
        self.category.save()
        template_loader.templates['page/category.html'] = 'category.html'
        template_loader.templates['page/static_page.html'] = 'static_page.html'
        response = self.client.get('/')
        tools.assert_equals('static_page.html', response.content)


class TestEmptyHomepage(TestCase):
    def test_404_is_shown_on_debug_off(self):
        from django.conf import settings
        orig_debug = settings.DEBUG
        settings.DEBUG = False
        template_loader.templates['404.html'] = '404.html'
        response = self.client.get('/')
        tools.assert_equals('404.html', response.content)
        settings.DEBUG = orig_debug

    def test_welcome_page_is_shown_as_hompage_on_debug(self):
        from django.conf import settings
        orig_debug = settings.DEBUG
        settings.DEBUG = True
        template_loader.templates['debug/empty_homepage.html'] = 'empty_homepage.html'
        response = self.client.get('/')
        tools.assert_equals('empty_homepage.html', response.content)
        settings.DEBUG = orig_debug


class TestListContentType(ViewsTestCase):
    def setUp(self):
        super(TestListContentType, self).setUp()
        create_and_place_more_publishables(self)
        list_all_publishables_in_category_by_hour(self, category=self.category)

    def test_without_home_listings_first_page_is_an_archive(self):
        self.category_nested_second.app_data.setdefault('ella', {})['no_home_listings'] = True
        self.category_nested_second.save()
        template_loader.templates['page/listing.html'] = ''
        Listing.objects.all().update(category=self.category_nested_second)
        response = self.client.get('/nested-category/second-nested-category/?p=1')
        tools.assert_true('listings' in response.context)
        tools.assert_equals(self.listings, response.context['listings'])

    def test_only_nested_category_and_year_returns_all_listings(self):
        template_loader.templates['page/listing.html'] = ''
        Listing.objects.all().update(category=self.category_nested_second)
        response = self.client.get('/nested-category/second-nested-category/2008/')
        tools.assert_true('listings' in response.context)
        tools.assert_equals(self.listings, response.context['listings'])

    def test_incorrect_page_number_raises_404(self):
        template_loader.templates['404.html'] = ''
        response = self.client.get('/2008/', {'p': 200})
        tools.assert_equals(404, response.status_code)


class TestObjectDetailTemplateOverride(ViewsTestCase):
    def setUp(self):
        super(TestObjectDetailTemplateOverride, self).setUp()
        publ = self.publishable
        ct = publ._meta.app_label + '.' + publ._meta.module_name

        self.templates = (
            'page/object.html',
            'page/content_type/%s/object.html' % ct,
            'page/category/%s/object.html' % publ.category.path,
            'page/category/%s/content_type/%s/object.html' % (publ.category.path, ct),
            'page/category/%s/content_type/%s/%s/object.html' % (publ.category.path, ct, publ.slug)
        )
        for i, t in enumerate(self.templates):
            template_loader.templates[t] = i

        self.url = publ.get_absolute_url()

    def test_fallback(self):
        for t in self.templates[-4:]:
            del template_loader.templates[t]
        tools.assert_equals('0', self.client.get(self.url).content)

    def test_ct(self):
        for t in self.templates[-3:]:
            del template_loader.templates[t]
        tools.assert_equals('1', self.client.get(self.url).content)

    def test_category(self):
        for t in self.templates[-2:]:
            del template_loader.templates[t]
        tools.assert_equals('2', self.client.get(self.url).content)

    def test_category_ct(self):
        del template_loader.templates[self.templates[-1]]
        tools.assert_equals('3', self.client.get(self.url).content)

    def test_category_ct_slug(self):
        tools.assert_equals('4', self.client.get(self.url).content)

class TestObjectDetail(ViewsTestCase):
    def setUp(self):
        super(TestObjectDetail, self).setUp()
        template_loader.templates['page/object.html'] = ''

    def test_timezone_localized_url(self):
        if not timezone.use_tz:
            raise SkipTest()
        from test_ella import template_loader
        template_loader.templates['page/object.html'] = 'object.html'
        self.publishable.publish_from = timezone.localize(datetime(2013, 4, 25, 0, 0, 0))
        self.publishable.save()

        tools.assert_equals('/nested-category/2013/4/25/first-article/', self.publishable.get_absolute_url())
        tools.assert_equals(200, self.client.get('/nested-category/2013/4/25/first-article/').status_code)

    def test_signals_fired_for_detail(self):
        self.client.get('/nested-category/2008/1/10/first-article/')
        tools.assert_equals(1, len(self.signals_received['object_rendering']))
        tools.assert_equals(1, len(self.signals_received['object_rendered']))

        kwargs = self.signals_received['object_rendered'][0][1]
        tools.assert_equals(set(['sender', 'request', 'category', 'publishable', 'signal']), set(kwargs.keys()))
        tools.assert_equals(self.category_nested, kwargs['category'])
        tools.assert_equals(self.publishable.__class__, kwargs['sender'])
        tools.assert_equals(self.publishable, kwargs['publishable'])

    def test_object_detail(self):
        response = self.client.get('/nested-category/2008/1/10/first-article/')

        tools.assert_true('category' in response.context)
        tools.assert_equals(self.publishable.category, response.context['category'])

        tools.assert_true('object' in response.context)
        tools.assert_equals(self.publishable, response.context['object'])

        tools.assert_true('content_type' in response.context)
        tools.assert_equals(
                ContentType.objects.get_for_model(self.publishable),
                response.context['content_type']
        )

        tools.assert_true('content_type_name' in response.context)
        tools.assert_equals(
                slugify(self.publishable._meta.verbose_name_plural),
                response.context['content_type_name']
        )

    def test_static_object_detail_redirects_to_correct_url_on_wrong_slug(self):
        self.publishable.static = True
        self.publishable.save()
        response = self.client.get('/nested-category/%d-not-the-first-article/' % self.publishable.id)

        tools.assert_equals(301, response.status_code)
        tools.assert_equals(
            'http://testserver/nested-category/%d-first-article/' % self.publishable.id,
            response['Location']
        )

    def test_static_object_detail_redirects_to_correct_url_on_wrong_category(self):
        self.publishable.static = True
        self.publishable.save()
        response = self.client.get('/nested-category/second-nested-category/%d-%s/' % (self.publishable.id, self.publishable.slug))

        tools.assert_equals(301, response.status_code)
        tools.assert_equals(
            'http://testserver/nested-category/%d-first-article/' % self.publishable.id,
            response['Location']
        )

    def test_static_redirects_preserve_custom_url_remainder(self):
        self.publishable.static = True
        self.publishable.save()
        response = self.client.get('/nested-category/second-nested-category/%d-%s/some/custom/url/action/' % (self.publishable.id, self.publishable.slug))

        tools.assert_equals(301, response.status_code)
        tools.assert_equals(
            'http://testserver/nested-category/%d-first-article/some/custom/url/action/' % self.publishable.id,
            response['Location']
        )


    def test_static_object_detail(self):
        self.publishable.static = True
        self.publishable.save()
        response = self.client.get('/nested-category/%d-first-article/' % self.publishable.id)

        tools.assert_true('category' in response.context)
        tools.assert_equals(self.publishable.category, response.context['category'])

        tools.assert_true('object' in response.context)
        tools.assert_equals(self.publishable, response.context['object'])

        tools.assert_true('content_type' in response.context)
        tools.assert_equals(
                ContentType.objects.get_for_model(self.publishable),
                response.context['content_type']
        )

        tools.assert_true('content_type_name' in response.context)
        tools.assert_equals(
                slugify(self.publishable._meta.verbose_name_plural),
                response.context['content_type_name']
        )

    def test_multiple_same_publications_can_live_while_not_published(self):
        self.publishable.published = True
        self.publishable.save()
        orig_publishable = self.publishable
        create_and_place_a_publishable(self, published=False)
        self.client.get('/nested-category/%d-first-article/' % orig_publishable.id)


class TestGetTemplates(ViewsTestCase):
    def test_homepage_uses_only_path(self):
        tools.assert_equals(
            [u'page/category/ni-hao-category/category.html', u'page/category.html'],
            get_templates('category.html', category=self.category)
        )

    def test_first_nested_uses_only_path(self):
        tools.assert_equals(
            [u'page/category/nested-category/category.html', u'page/category.html'],
            get_templates('category.html', category=self.category_nested)
        )

    def test_more_nested_uses_fallback_to_parents(self):
        tools.assert_equals(
            [u'page/category/nested-category/second-nested-category/category.html', u'page/category/nested-category/category.html', u'page/category.html'],
            get_templates('category.html', category=self.category_nested_second)
        )

########NEW FILE########
__FILENAME__ = test_view_helpers
# -*- coding: utf-8 -*-
from unittest import TestCase as UnitTestCase
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from django.http import Http404
from django.db.models import get_models
from django.contrib.contenttypes.models import ContentType
from django.template.defaultfilters import slugify

from ella.core.views import ObjectDetail, get_content_type, ListContentType
from ella.core.models import Listing, Publishable

from test_ella.test_core import create_basic_categories, create_and_place_a_publishable, \
        create_and_place_more_publishables, list_all_publishables_in_category_by_hour

class ViewHelpersTestCase(TestCase):
    def setUp(self):
        super(ViewHelpersTestCase, self).setUp()
        create_basic_categories(self)
        create_and_place_a_publishable(self)

        # mock user
        self.user = self
        setattr(self.user, 'is_staff', False)

        # mock request
        self.request = self
        setattr(self.user, 'GET', {})

class TestGetContentType(UnitTestCase):
    def test_by_brute_force(self):
        for m in get_models():
            if issubclass(m, Publishable):
                ct = ContentType.objects.get_for_model(m)
                tools.assert_equals(ct, get_content_type(slugify(m._meta.verbose_name_plural)))

    def test_raises_404_on_non_existing_model(self):
        tools.assert_raises(Http404, get_content_type, '')

class TestCategoryDetail(ViewHelpersTestCase):
    def setUp(self):
        super(TestCategoryDetail, self).setUp()
        self.category_detail = ListContentType()

    def test_returns_category_by_tree_path(self):
        cat = self.category_detail.get_category(self.request, 'nested-category')
        c = self.category_detail.get_context(self.request, cat)
        tools.assert_equals(self.category_nested, c['category'])
        tools.assert_false(c['is_homepage'])

    def test_returns_home_page_with_no_args(self):
        cat = self.category_detail.get_category(self.request, '')
        c = self.category_detail.get_context(self.request, cat)
        tools.assert_equals(self.category, c['category'])
        tools.assert_true(c['is_homepage'])

    def test_returns_nested_category_by_tree_path(self):
        cat = self.category_detail.get_category(self.request, 'nested-category/second-nested-category')
        c = self.category_detail.get_context(self.request, cat)
        tools.assert_equals(self.category_nested_second, c['category'])
        tools.assert_false(c['is_homepage'])

class TestObjectDetail(ViewHelpersTestCase):
    def setUp(self):
        super(TestObjectDetail, self).setUp()
        self.correct_args = [self.request, 'nested-category', 'first-article', '2008', '1', '10', None]
        self.correct_static_args = self.correct_args[:3] + [None, None, None, self.publishable.id]
        self.object_detail = ObjectDetail()

    def test_raises_404_on_incorrect_category(self):
        self.correct_args[1] = 'not-an-existing-category'
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_raises_404_on_wrong_category(self):
        self.correct_args[1] = ''
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_raises_404_on_incorrect_slug(self):
        self.correct_args[2] = 'not-an-existing-slug'
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_raises_404_on_incorrect_date(self):
        self.correct_args[3] = '2000'
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_returns_correct_context(self):
        c = self.object_detail.get_context(*self.correct_args)

        tools.assert_equals(4, len(c.keys()))
        tools.assert_equals(self.publishable, c['object'])
        tools.assert_equals(self.category_nested, c['category'])
        tools.assert_equals('articles', c['content_type_name'])
        tools.assert_equals(self.publishable.content_type, c['content_type'])

    def test_doesnt_match_static_placement_if_date_is_supplied(self):
        self.publishable.static = True
        self.publishable.save()
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_doesnt_match_placement_if_date_is_not_supplied(self):
        self.correct_args = self.correct_args[:3] + [None, None, None, None]
        tools.assert_raises(Http404, self.object_detail.get_context, *self.correct_args)

    def test_matches_static_placement_if_date_is_not_supplied(self):
        self.publishable.static = True
        self.publishable.save()

        c = self.object_detail.get_context(*self.correct_static_args)

        tools.assert_equals(4, len(c.keys()))
        tools.assert_equals(self.publishable, c['object'])
        tools.assert_equals(self.category_nested, c['category'])
        tools.assert_equals('articles', c['content_type_name'])
        tools.assert_equals(self.publishable.content_type, c['content_type'])

    def test_raises_wrong_url_on_missing_category(self):
        self.publishable.static = True
        self.publishable.save()

        self.correct_static_args[1] = 'non-existent/category'
        tools.assert_raises(self.object_detail.WrongUrl, self.object_detail.get_context, *self.correct_static_args)

    def test_raises_wrong_url_on_wong_slug(self):
        self.publishable.static = True
        self.publishable.save()

        self.correct_static_args[2] = 'not a slug'
        tools.assert_raises(self.object_detail.WrongUrl, self.object_detail.get_context, *self.correct_static_args)

    def test_raises_wrong_url_on_not_static(self):
        tools.assert_raises(self.object_detail.WrongUrl, self.object_detail.get_context, *self.correct_static_args)

    def test_raises_wrong_url_on_wong_category(self):
        self.publishable.static = True
        self.publishable.save()

        self.correct_static_args[1] = ''
        tools.assert_raises(self.object_detail.WrongUrl, self.object_detail.get_context, *self.correct_static_args)

class TestListContentType(ViewHelpersTestCase):
    def setUp(self):
        super(TestListContentType, self).setUp()
        create_and_place_more_publishables(self)
        list_all_publishables_in_category_by_hour(self, category=self.category)
        self.list_content_type = ListContentType()

    def test_only_category_and_year_returns_all_listings(self):
        c = self.list_content_type.get_context(self.request, self.category, '2008')
        tools.assert_equals(self.listings, list(c['listings']))

    def test_only_nested_category_and_year_returns_all_listings(self):
        Listing.objects.all().update(category=self.category_nested_second)
        c = self.list_content_type.get_context(self.request, self.category_nested_second, '2008')
        tools.assert_equals(self.listings, list(c['listings']))

    def test_return_first_2_listings_if_paginate_by_2(self):
        self.category.app_data = {'ella': {'paginate_by': 2, 'first_page_count': 2}}
        self.category.save()
        c = self.list_content_type.get_context(self.request, self.category, '2008')
        tools.assert_equals(self.listings[:2], list(c['listings']))
        tools.assert_true(c['is_paginated'])

    def test_return_second_2_listings_if_paginate_by_2_and_page_2(self):
        self.category.app_data = {'ella': {'paginate_by': 2, 'first_page_count': 2}}
        self.category.save()
        self.request.GET['p'] = '2'
        c = self.list_content_type.get_context(self.request, self.category, '2008')
        tools.assert_equals(self.listings[2:4], list(c['listings']))
        tools.assert_true(c['is_paginated'])

    def test_returns_empty_list_if_no_listing_found(self):
        c = self.list_content_type.get_context(self.request, self.category, '2007')
        tools.assert_equals([], list(c['listings']))

    def test_raises404_for_incorrect_page(self):
        self.request.GET['p'] = '200'
        tools.assert_raises(Http404, self.list_content_type.get_context, self.request, self.category, '2008')

    def test_raises404_for_incorrect_category(self):
        tools.assert_raises(Http404, self.list_content_type.get_category, self.request, 'XXX')

    def test_raises404_for_incorrect_month(self):
        tools.assert_raises(Http404, self.list_content_type.get_context, self.request, self.category, '2008', '13')

    def test_raises404_for_incorrect_day(self):
        tools.assert_raises(Http404, self.list_content_type.get_context, self.request, self.category, '2008', '1', '42')

    def test_raises404_for_incorrect_date(self):
        tools.assert_raises(Http404, self.list_content_type.get_context, self.request, self.category, '2008', '2', '30')



########NEW FILE########
__FILENAME__ = fixtures
# -*- coding: utf-8 -*-

from django.conf import settings
from django.contrib.sites.models import Site

from ella.photos.models import Format
from ella.utils.test_helpers import create_photo

__all__ = ("create_photo_formats",)

def create_photo_formats(case):
    case.basic_format = Format(
        name = "basic",
        max_width = 20,
        max_height = 20,
        flexible_height = False,
        stretch = False,
        nocrop = False,
        resample_quality = 85,
    )
    case.basic_format.save()
    case.basic_format.sites.add(Site.objects.get(pk=getattr(settings, "SITE_ID", 1)))


########NEW FILE########
__FILENAME__ = test_forms
from django.contrib.sites.models import Site

from ella.photos.admin import FormatForm

from nose import tools

from test_ella.cases import RedisTestCase as TestCase
from test_ella.test_photos.fixtures import create_photo_formats

class TestFormatForm(TestCase):
    def setUp(self):
        super(TestFormatForm, self).setUp()
        create_photo_formats(self)
        self.other_site = Site.objects.create(name='other', domain='other.com')
        self.data = dict(
            name="basic",
            max_width=20,
            max_height=20,
            flexible_height=False,
            stretch=False,
            nocrop=False,
            resample_quality=85,
            sites=[]
        )

    def test_same_name_formats_allowed_if_in_different_sites(self):
        self.data['sites'] = [self.other_site.pk]
        form = FormatForm(self.data)

        tools.assert_true(form.is_valid())

    def test_same_name_not_allowed_on_same_site(self):
        self.data['sites'] = [self.other_site.pk, Site.objects.get_current().pk]
        form = FormatForm(self.data)

        tools.assert_false(form.is_valid())

########NEW FILE########
__FILENAME__ = test_photo
# -*- coding: utf-8 -*-
from PIL import Image

from django.core.files.base import ContentFile
from test_ella.cases import RedisTestCase as TestCase
from django.contrib.sites.models import Site

from nose import tools

from ella.photos.models import Format, FormatedPhoto, redis, REDIS_FORMATTED_PHOTO_KEY
from ella.photos.conf import photos_settings

from test_ella.test_photos.fixtures import create_photo_formats, create_photo


class TestPhoto(TestCase):

    def setUp(self):
        super(TestPhoto, self).setUp()

        # fixtures
        create_photo_formats(self)

        create_photo(self)

    def tearDown(self):
        photos_settings.FORMATED_PHOTO_FILENAME = None
        if self.photo.pk:
            self.photo.delete()
        super(TestPhoto, self).tearDown()
        if redis:
            redis.flushdb()

    def test_formated_photo_from_master_format_is_used(self):
        master_format = Format.objects.create(
            name='sample',
            max_width=300,
            max_height=200,
            flexible_height=False,
            stretch=False,
            nocrop=False
        )
        slave_format = Format.objects.create(
            name='slave',
            max_width=300,
            max_height=100,
            flexible_height=False,
            stretch=False,
            nocrop=False,
            master=master_format
        )
        master_fp = FormatedPhoto(photo=self.photo, format=master_format)
        p2 = create_photo(self, color=(123, 123, 123), size=(300, 200))
        p2.image.open()
        master_fp.image.save(p2.image.name, p2.image)
        master_fp.save()

        fp = FormatedPhoto(photo=self.photo, format=slave_format)
        fp.save()

        fp.image.open()
        i = Image.open(fp.image)
        tools.assert_equals((123, 123, 123), i.getpixel((10, 10)))
        tools.assert_equals((300, 100), i.size)
        p2.image.close()

    def test_formatted_photo_has_zero_crop_box_if_smaller_than_format(self):
        format = Format.objects.create(
            name='sample',
            max_width=300,
            max_height=300,
            flexible_height=False,
            stretch=False,
            nocrop=False
        )
        format.sites.add(Site.objects.get_current())

        fp = FormatedPhoto(photo=self.photo, format=format)
        fp.generate(False)
        tools.assert_equals((0, 0, 0, 0), (fp.crop_left, fp.crop_top, fp.crop_width, fp.crop_height))

    def test_formated_filename_can_be_overridden(self):
        photos_settings.FORMATED_PHOTO_FILENAME = lambda fp: 'XXX.jpg'
        formatted = FormatedPhoto.objects.get_photo_in_format(self.photo, self.basic_format)
        tools.assert_true('url' in formatted)
        tools.assert_true(formatted['url'].endswith('XXX.jpg'))

    def test_retrieving_formatted_photos_on_fly(self):
        formatted = FormatedPhoto.objects.get_photo_in_format(self.photo, self.basic_format)
        tools.assert_true('url' in formatted)
        if redis:
            expected = {
                'height': '20',
                'width': '20',
                'url': '/static/photos/2012/02/14/1-1-example-photo_12.jpg',
            }
            actual = redis.hgetall(REDIS_FORMATTED_PHOTO_KEY % (self.photo.id, self.basic_format.id))
            tools.assert_equals(expected.keys(), actual.keys())
            tools.assert_equals(expected['width'], actual['width'])
            tools.assert_equals(expected['height'], actual['height'])

    def test_formattedphoto_cleared_when_image_changed(self):
        FormatedPhoto.objects.get_photo_in_format(self.photo, self.basic_format)
        tools.assert_equals(1, len(self.photo.formatedphoto_set.all()))

        # let us create image again
        self.photo.image.open()
        file = ContentFile(self.photo.image.read())

        self.photo.image.save("newzaaah", file)
        self.photo.save()

        tools.assert_equals(0, len(self.photo.formatedphoto_set.all()))

    def test_formattedphoto_cleared_when_format_changed(self):
        FormatedPhoto.objects.get_photo_in_format(self.photo, self.basic_format)
        tools.assert_equals(1, len(self.basic_format.formatedphoto_set.all()))
        self.basic_format.nocrop = True
        self.basic_format.save()
        tools.assert_equals(0, len(self.basic_format.formatedphoto_set.all()))

    def test_retrieving_ratio(self):
        tools.assert_equals(2, self.photo.ratio())

########NEW FILE########
__FILENAME__ = test_resize
# -*- coding: utf-8 -*-
from unittest import TestCase
from os import path

from nose import tools

from PIL import Image

from ella.photos.models import Format
from ella.photos.formatter import Formatter

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)

class TestPhotoResize(TestCase):

    def setUp(self):
        super(TestPhotoResize, self).setUp()
        self.format = Format(max_height=100, max_width=100)

    def test_custom_bg_color_is_used_for_neg_coords(self):
        i = Image.new('RGB', (200, 200), RED)
        f = Formatter(i, self.format, crop_box=(-50, -50, 50, 50))

        i, crop_box = f.format()
        tools.assert_equals((-50, -50, 50, 50), crop_box)
        tools.assert_equals((100, 100), i.size)
        tools.assert_equals(BLUE, i.getpixel((0, 0)))
        tools.assert_equals(RED, i.getpixel((51, 51)))
        tools.assert_equals(RED, i.getpixel((50, 50)))
        tools.assert_equals(RED, i.getpixel((99, 99)))

    def test_taller_image_gets_cropped_to_ratio(self):
        i = Image.new('RGB', (100, 200), BLACK)
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals((0, 50, 100, 150), crop_box)
        tools.assert_equals((100, 100), i.size)

    def test_wider_image_gets_cropped_to_ratio(self):
        i = Image.new('RGB', (200, 100), BLACK)
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals((50, 0, 150, 100), crop_box)
        tools.assert_equals((100, 100), i.size)

    def test_bigger_image_gets_shrinked_without_cropping(self):
        i = Image.new('RGB', (200, 200), BLACK)
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((100, 100), i.size)

    def test_smaller_image_remains_untouched(self):
        i = Image.new('RGB', (100, 20), BLACK)
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((100, 20), i.size)

    def test_taller_image_gets_shrinked_to_ratio_with_nocrop(self):
        i = Image.new('RGB', (100, 200), BLACK)
        self.format.nocrop = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((50, 100), i.size)

    def test_wider_image_gets_shrinked_to_ratio_with_nocrop(self):
        i = Image.new('RGB', (200, 100), BLACK)
        self.format.nocrop = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((100, 50), i.size)

    def test_smaller_image_stretches_with_ratio_intact_with_stretch(self):
        i = Image.new('RGB', (20, 10), BLACK)
        self.format.stretch = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((100, 50), i.size)

    def test_flexible_height_doesnt_affect_wider_images(self):
        i = Image.new('RGB', (200, 100), BLACK)
        self.format.flexible_max_height = 200
        self.format.flexible_height = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals((50, 0, 150, 100), crop_box)
        tools.assert_equals((100, 100), i.size)

    def test_flexible_height_doesnt_raise_exception_no_max_height(self):
        i = Image.new('RGB', (200, 100), BLACK)
        self.format.flexible_max_height = None
        self.format.flexible_height = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals((100, 100), i.size)

    def test_flexible_height_saves_taller_images(self):
        i = Image.new('RGB', (100, 200), BLACK)
        self.format.flexible_max_height = 200
        self.format.flexible_height = True
        f = Formatter(i, self.format)

        i, crop_box = f.format()
        tools.assert_equals(None, crop_box)
        tools.assert_equals((100, 200), i.size)

    def test_custom_crop_box_is_used(self):
        i = Image.new('RGB', (200, 200), RED)
        f = Formatter(i, self.format, crop_box=(0,0,100,100))
        i.putpixel((99, 99), BLACK)

        i, crop_box = f.format()
        tools.assert_equals((0,0,100,100), crop_box)
        tools.assert_equals((100, 100), i.size)
        tools.assert_equals(BLACK, i.getpixel((99,99)))

    def test_important_box_is_used(self):
        i = Image.new('RGB', (200, 100), RED)
        f = Formatter(i, self.format, important_box=(0,0,100,100))
        i.putpixel((99, 99), BLACK)

        i, crop_box = f.format()
        tools.assert_equals((0,0,100,100), crop_box)
        tools.assert_equals((100, 100), i.size)
        tools.assert_equals(BLACK, i.getpixel((99,99)))

    def test_important_box_is_used_for_other_positive_x_motion_as_well(self):
        i = Image.new('RGB', (200, 100), RED)
        f = Formatter(i, self.format, important_box=(100,0,200,100))
        i.putpixel((100, 0), BLACK)

        i, crop_box = f.format()
        tools.assert_equals((100,0,200,100), crop_box)
        tools.assert_equals((100, 100), i.size)
        tools.assert_equals(BLACK, i.getpixel((0,0)))

    def test_important_box_is_used_for_positive_y_motion_as_well(self):
        i = Image.new('RGB', (100, 200), RED)
        f = Formatter(i, self.format, important_box=(0,100,100,200))
        i.putpixel((0, 100), BLACK)

        i, crop_box = f.format()
        tools.assert_equals((0,100,100,200), crop_box)
        tools.assert_equals((100, 100), i.size)
        tools.assert_equals(BLACK, i.getpixel((0,0)))

class TestPhotoResizeWithRotate(TestCase):

    def setUp(self):
        super(TestPhotoResizeWithRotate, self).setUp()
        self.base = path.dirname(path.abspath(__file__))
        self.format = Format(max_height=100, max_width=100)

    def get_image_and_formatter(self, name):
        o = Image.open(path.join(self.base, 'data', name))
        f = Formatter(o, self.format)
        return o, f

    def test_as_data_we_have_white_box_on_the_left_black_box_on_the_right(self):
        i, f = self.get_image_and_formatter('rotate1.jpeg')

        tools.assert_equals((20, 10), i.size)
        tools.assert_equals(WHITE, i.getpixel((5, 5)))
        tools.assert_equals(BLACK, i.getpixel((15, 5)))

    def test_plain_jpeg_is_not_rotated(self):
        o, f = self.get_image_and_formatter('rotate1.jpeg')
        i, c = f.format()

        tools.assert_equals((20, 10), i.size)
        tools.assert_equals(WHITE, i.getpixel((5, 5)))
        tools.assert_equals(BLACK, i.getpixel((15, 5)))

    def test_jpeg_with_exit_rotation_info_3_is_rotated_180_degrees(self):
        o, f = self.get_image_and_formatter('rotate3.jpeg')
        i, c = f.format()

        tools.assert_equals((20, 10), i.size)
        tools.assert_equals(BLACK, i.getpixel((5, 5)))
        tools.assert_equals(WHITE, i.getpixel((15, 5)))

    def test_jpeg_with_exit_rotation_info_6_is_rotated_90_degrees_clockwise(self):
        o, f = self.get_image_and_formatter('rotate6.jpeg')
        i, c = f.format()

        tools.assert_equals((10, 20), i.size)
        tools.assert_equals(WHITE, i.getpixel((5, 5)))
        tools.assert_equals(BLACK, i.getpixel((5, 15)))

    def test_jpeg_with_exit_rotation_info_8_is_rotated_90_degrees_counter_clockwise(self):
        o, f = self.get_image_and_formatter('rotate8.jpeg')
        i, c = f.format()

        tools.assert_equals((10, 20), i.size)
        tools.assert_equals(BLACK, i.getpixel((5, 5)))
        tools.assert_equals(WHITE, i.getpixel((5, 15)))


########NEW FILE########
__FILENAME__ = test_templatetags
from django.template import Node, Context
from test_ella.cases import RedisTestCase as TestCase
from django.conf import settings

from nose import tools, SkipTest

from ella.photos.templatetags.photos import _parse_img, ImgTag, _parse_image, ImageTag
from ella.photos.models import redis, REDIS_PHOTO_KEY, REDIS_FORMATTED_PHOTO_KEY

from test_ella.test_photos.fixtures import create_photo_formats

class TestImageParsing(TestCase):
    def setUp(self):
        super(TestImageParsing, self).setUp()
        create_photo_formats(self)

    def tearDown(self):
        super(TestImageParsing, self).tearDown()
        if redis:
            redis.flushdb()

    def test_format_is_resolved_if_literal_string(self):
        image_node = _parse_image('image some_photo in "basic" as var_name'.split())
        tools.assert_true(isinstance(image_node, ImageTag))
        tools.assert_equals(self.basic_format, image_node.format)

    def test_photo_id_and_format_picked_up_from_context(self):
        if not redis:
            raise SkipTest()
        redis.hmset(REDIS_FORMATTED_PHOTO_KEY % (42, self.basic_format.pk), {'sentinel': 42})
        redis.hmset(REDIS_PHOTO_KEY % 42, {'orig_sentinel': 42})

        c = Context({'article': {'photo_id': 42, 'photo': 'not-42'}, 'image_format': self.basic_format})
        image_node = _parse_image('image article.photo in image_format as var_name'.split())

        tools.assert_true(isinstance(image_node, ImageTag))
        tools.assert_equals('', image_node.render(c))
        tools.assert_true('var_name' in c)
        tools.assert_equals({'sentinel': '42', 'original': {'orig_sentinel': '42'}}, c['var_name'])


    def test_photo_and_format_name_picked_up_from_context(self):
        if not redis:
            raise SkipTest()
        redis.hmset(REDIS_FORMATTED_PHOTO_KEY % (42, self.basic_format.pk), {'sentinel': 42})
        redis.hmset(REDIS_PHOTO_KEY % 42, {'orig_sentinel': 42})

        c = Context({'article': {'photo': 42}, 'image_format': 'basic'})
        image_node = _parse_image('image article.photo in image_format as var_name'.split())

        tools.assert_true(isinstance(image_node, ImageTag))
        tools.assert_equals('', image_node.render(c))
        tools.assert_true('var_name' in c)
        tools.assert_equals({'sentinel': '42', 'original': {'orig_sentinel': '42'}}, c['var_name'])


class TestImgParsing(TestCase):
    def setUp(self):
        super(TestImgParsing, self).setUp()
        create_photo_formats(self)

    def test_node_gets_passed_correct_params(self):
        img_node = _parse_img('img basic for VAR as VAR_NAME'.split())
        tools.assert_true(isinstance(img_node, ImgTag))
        tools.assert_equals(self.basic_format, img_node.format)

    def test_return_empty_node_on_unknown_format(self):
        if settings.TEMPLATE_DEBUG:
            raise SkipTest()
        img_node = _parse_img('img unknownformat for VAR as VAR_NAME'.split())
        tools.assert_equals(Node, img_node.__class__)

########NEW FILE########
__FILENAME__ = test_admin
# -*- coding: utf-8 -*-
from unittest import TestCase

from nose import tools

from django.contrib import admin

from ella.core.models import Author
from ella.articles.models import Article
from ella.positions.admin import PositionOptions
from ella.positions.models import Position


class TestPositionAdmin(TestCase):

    def setUp(self):
        super(TestPositionAdmin, self).setUp()
        self.author = Author(slug='some-author')
        self.position_admin = PositionOptions(model=Position, admin_site=admin.site)

    def test_result_of_show_title_for_obj_with_title_attr(self):
        art = Article(title='Hello')
        p = Position()
        p.target = art
        tools.assert_equals(u'Hello [Article]', self.position_admin.show_title(p))

    def test_result_of_show_title_for_obj_without_title_attr(self):
        aut = Author(name='Hi!')
        p = Position()
        p.target = aut
        tools.assert_equals(u'Hi! [Author]', self.position_admin.show_title(p))

    def test_result_of_show_title_for_position_without_trget(self):
        p = Position()
        tools.assert_true(self.position_admin.show_title(p).startswith('--'))

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-
from datetime import datetime, timedelta
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from django.template import Context, NodeList
from django.contrib.contenttypes.models import ContentType
from django.db.models import Max
from django.core.exceptions import ValidationError

from test_ella.test_core import create_basic_categories

from ella.positions.models import Position
from ella.utils.timezone import now, utc_localize

class TestPosition(TestCase):

    def setUp(self):
        super(TestPosition, self).setUp()
        create_basic_categories(self)

    def test_validation_fails_for_globaly_active_positions(self):
        Position.objects.create(category=self.category, name='position-name', text='some text')
        p = Position(category=self.category, name='position-name', text='other text')
        tools.assert_raises(ValidationError, p.full_clean)

    def test_validation_fails_for_overlapping_positions(self):
        Position.objects.create(category=self.category, name='position-name', text='some text', active_till=utc_localize(datetime(2010, 10, 10)))
        p = Position(category=self.category, name='position-name', text='other text')
        tools.assert_raises(ValidationError, p.full_clean)

    def test_validation_fails_for_overlapping_positions2(self):
        Position.objects.create(category=self.category, name='position-name', text='some text', active_till=utc_localize(datetime(2010, 10, 10)))
        p = Position(category=self.category, name='position-name', text='other text', active_from=utc_localize(datetime(2010, 9, 10)))
        tools.assert_raises(ValidationError, p.full_clean)

    def test_validation_fails_for_overlapping_positions3(self):
        Position.objects.create(category=self.category, name='position-name', text='some text', active_from=utc_localize(datetime(2010, 10, 10)))
        p = Position(category=self.category, name='position-name', text='other text', active_till=utc_localize(datetime(2010, 10, 11)))
        tools.assert_raises(ValidationError, p.full_clean)

    def test_validation_passes_for_nonoverlapping_positions(self):
        Position.objects.create(category=self.category, name='position-name', text='some text', active_till=utc_localize(datetime(2010, 10, 10, 10, 10, 10)))
        p = Position(category=self.category, name='position-name', text='other text', active_from=utc_localize(datetime(2010, 10, 10, 10, 10, 10)))
        p.full_clean()

    def test_validation_fails_for_incorrect_generic_fk(self):
        p = Position(category=self.category, name='position-name', target_ct=ContentType.objects.get_for_model(Position), target_id=123455)
        tools.assert_raises(ValidationError, p.full_clean)

    def test_render_position_without_target_renders_txt(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text')
        tools.assert_equals('some text', p.render(Context({}), NodeList(), ''))

    def test_render_position_with_invalid_target_returns_empty(self):
        target_ct = ContentType.objects.get_for_model(ContentType)
        invalid_id = ContentType.objects.aggregate(Max('id'))['id__max'] + 1

        p = Position.objects.create(category=self.category, name='position-name', text='some text', target_ct=target_ct, target_id=invalid_id)
        tools.assert_equals('', p.render(Context({}), NodeList(), ''))

    def test_get_active_position(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text')
        tools.assert_equals(p, Position.objects.get_active_position(self.category, 'position-name'))

    def test_get_active_position_nofallback(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text')
        tools.assert_equals(p, Position.objects.get_active_position(self.category, 'position-name', nofallback=True))

    def test_get_active_position_inherit(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text')
        tools.assert_equals(p, Position.objects.get_active_position(self.category_nested, 'position-name'))

    def test_get_active_position_inherit_nofallback(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text')
        tools.assert_false(Position.objects.get_active_position(self.category_nested, 'position-name', nofallback=True))

    def test_get_active_position_empty(self):
        tools.assert_false(Position.objects.get_active_position(self.category, 'position-name'))

    def test_active_till_past(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', active_till=now()-timedelta(days=1))
        tools.assert_false(Position.objects.get_active_position(self.category, 'position-name'))

    def test_active_from_future(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', active_from=now()+timedelta(days=1))
        tools.assert_false(Position.objects.get_active_position(self.category, 'position-name'))

    def test_active_till_future(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', active_till=now()+timedelta(days=1))
        tools.assert_equals(p, Position.objects.get_active_position(self.category_nested, 'position-name'))

    def test_active_from_past(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', active_from=now()-timedelta(days=1))
        tools.assert_equals(p, Position.objects.get_active_position(self.category_nested, 'position-name'))

    def test_active_from_till_match(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text',
                active_from=now()-timedelta(days=1),
                active_till=now()+timedelta(days=1),
            )
        tools.assert_equals(p, Position.objects.get_active_position(self.category_nested, 'position-name'))

    def test_active_from_till_no_match(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text',
                active_from=now()-timedelta(days=3),
                active_till=now()-timedelta(days=1),
            )
        tools.assert_false(Position.objects.get_active_position(self.category, 'position-name'))

    def test_more_positions_one_active(self):
        n = now()
        p1 = Position.objects.create(category=self.category, name='position-name', text='some text',
                active_from=n-timedelta(days=1),
            )
        p2 = Position.objects.create(category=self.category, name='position-name', text='some text', active_till=n-timedelta(days=1))
        tools.assert_equals(p1, Position.objects.get_active_position(self.category_nested, 'position-name'))

    def test_not_disabled(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', disabled=False)
        tools.assert_equals(p, Position.objects.get_active_position(self.category, 'position-name'))

    def test_disabled(self):
        p = Position.objects.create(category=self.category, name='position-name', text='some text', disabled=True)
        tools.assert_false(Position.objects.get_active_position(self.category, 'position-name'))

    def test_position_with_broken_definition_dont_raise_big_500(self):
        p = Position.objects.create(category=self.category, name='position-name', text='{% load nonexistent_tags %}', disabled=False)
        tools.assert_equals('', p.render(Context({}), NodeList(), ''))


########NEW FILE########
__FILENAME__ = test_templatetags
# -*- coding: utf-8 -*-
from test_ella.cases import RedisTestCase as TestCase

from nose import tools

from django import template
from django.template import Context


from test_ella.test_core import create_basic_categories

from ella.core.models import Category
from ella.positions.models import Position
from ella.positions.templatetags.positions import (
                                                   _get_category_from_pars_var,
                                                   _parse_position_tag,
                                                   PositionNode,
                                                   )


class TestPositionParsing(TestCase):

    def setUp(self):
        super(TestPositionParsing, self).setUp()
        create_basic_categories(self)
        self.context = Context({'category': self.category})
        self.context_for_category_nested = Context({'category': self.category_nested})
        self.position = Position(
            category=self.category_nested,
            name='position-name',
            text='other text'
        )
        self.position.save()

    def test_getting_category_for_templatag_from_category_variable(self):
        tools.assert_equals(_get_category_from_pars_var(template.Variable('category'), self.context), self.category)

    def test_raising_exception_for_templatag_if_category_is_not_in_context(self):
        tools.assert_raises(template.VariableDoesNotExist, _get_category_from_pars_var, template.Variable('category'), Context({}))

    def test_getting_category_for_templatag_from_category_tree_path_in_variable(self):
        context = Context({'category': '%s' % (self.category.tree_path)})
        tools.assert_equals(_get_category_from_pars_var(template.Variable('category'), context), self.category)

    def test_raising_exception_for_templatag_if_no_category_for_tree_path_in_variable(self):
        context = Context({'category': '%s' % ("bad_three_path")})
        tools.assert_raises(Category.DoesNotExist, _get_category_from_pars_var, template.Variable('category'), context)

    def test_getting_category_for_templatag_from_category_tree_path(self):
        tools.assert_equals(_get_category_from_pars_var(template.Variable('"%s"' % (self.category.tree_path)), self.context), self.category)
        tools.assert_equals(_get_category_from_pars_var(template.Variable('"%s"' % (self.category_nested.tree_path)), self.context), self.category_nested)

    def test_raising_exception_for_templatag_if_no_category_for_tree_path(self):
        tools.assert_raises(Category.DoesNotExist, _get_category_from_pars_var, template.Variable('"bad_three_path"'), self.context)

    def test_parsing_position_tag(self):
        position_node = _parse_position_tag('position position-name for category'.split(), 'endposition')
        tools.assert_true(isinstance(position_node, PositionNode))
        tools.assert_true(isinstance(position_node.category, template.Variable))
        position_node = _parse_position_tag('position position-name for category nofallback'.split(), 'endposition')
        tools.assert_true(isinstance(position_node, PositionNode))
        tools.assert_true(isinstance(position_node.category, template.Variable))
        position_node = _parse_position_tag('position position-name for category using BOX_TYPE'.split(), 'endposition')
        tools.assert_true(isinstance(position_node, PositionNode))
        tools.assert_true(isinstance(position_node.category, template.Variable))
        position_node = _parse_position_tag('position position-name for category using BOX_TYPE nofallback'.split(), 'endposition')
        tools.assert_true(isinstance(position_node, PositionNode))
        tools.assert_true(isinstance(position_node.category, template.Variable))
        position_node = _parse_position_tag('position "position" for category'.split(), 'endposition')
        tools.assert_true(isinstance(position_node, PositionNode))
        tools.assert_true(isinstance(position_node.category, template.Variable))

    def test_position_templatetag_render_with_category_var(self):
        t = template.Template('{% load positions %}{% position position-name for category %}{% endposition %}')
        tools.assert_equals('other text', t.render(self.context_for_category_nested))

    def test_position_templatetag_render_with_category_tree_path(self):
        t = template.Template('{% load positions %}{% position position-name for "nested-category" %}{% endposition %}')
        tools.assert_equals('other text', t.render(self.context_for_category_nested))

    def test_empty_position_templatetag_render_with_category_var(self):
        t = template.Template('{% load positions %}{% position position-name for category %}{% endposition %}')
        tools.assert_equals('', t.render(self.context))

    def test_empty_position_templatetag_render_with_category_tree_path_if_position_does_not_exist(self):
        t = template.Template('{% load positions %}{% position position-namee for "nested-category" %}{% endposition %}')
        tools.assert_equals('', t.render(self.context))

    def test_raising_exception_position_templatetag_render_with_bad_category_tree_path(self):
        t = template.Template('{% load positions %}{% position position-name for "nested-categoryy" %}{% endposition %}')
        tools.assert_raises(Category.DoesNotExist, t.render, self.context_for_category_nested)

    def test_raising_exception_position_templatetag_render_with_category_not_defined(self):
        t = template.Template('{% load positions %}{% position position-name for category %}{% endposition %}')
        tools.assert_raises(template.VariableDoesNotExist, t.render, Context({}))

    def test_ifposition_templatetag_render_with_category_var(self):
        t = template.Template('{% load positions %}{% ifposition position-name for category %}IN{% else %}OUT{% endifposition %}')
        tools.assert_equals('IN', t.render(self.context_for_category_nested))

    def test_ifposition_templatetag_render_with_category_tree_path(self):
        t = template.Template('{% load positions %}{% ifposition position-name for "nested-category" %}IN{% else %}OUT{% endifposition %}')
        tools.assert_equals('IN', t.render(self.context_for_category_nested))

    def test_not_position_for_ifposition_templatetag_render_with_category_var(self):
        t = template.Template('{% load positions %}{% ifposition position-name for category %}IN{% else %}OUT{% endifposition %}')
        tools.assert_equals('OUT', t.render(self.context))

    def test_raising_exception_for_ifposition_templatetag_render_with_category_var_not_in_context(self):
        t = template.Template('{% load positions %}{% ifposition position-name for category %}IN{% else %}OUT{% endifposition %}')
        tools.assert_raises(template.VariableDoesNotExist, t.render, Context({}))

    def test_raising_exception_ifposition_templatetag_render_with_bad_category_tree_path(self):
        t = template.Template('{% load positions %}{% ifposition position-name for "nested-categoryy" %}IN{% else %}OUT{% endifposition %}')
        tools.assert_raises(Category.DoesNotExist, t.render, self.context)

########NEW FILE########
__FILENAME__ = test_installedapps
import sys

from ella.utils.installedapps import call_modules, app_modules_loaded

from nose import tools


def test_module_loaded_and_signal_fired():
    call_modules(('loadme',))

    tools.assert_true('test_ella.test_app.loadme' in sys.modules)
    loadme = sys.modules['test_ella.test_app.loadme']
    tools.assert_equals(1, len(loadme.run_log))
    tools.assert_equals(((), {'signal': app_modules_loaded, 'sender': None}), loadme.run_log[0])

########NEW FILE########
__FILENAME__ = test_middleware
from unittest import TestCase

from django.test.client import RequestFactory

from ella.utils.middleware import LegacyRedirectMiddleware

from nose import tools

class DummyResponse(object):
    def __init__(self, status):
        self.status_code = status

class TestLegacyRedirectMiddleware(TestCase):
    def setUp(self):
        self.rf = RequestFactory()
        self.m = LegacyRedirectMiddleware()
        super(TestLegacyRedirectMiddleware, self).setUp()

    def test_middleware_ignores_non_404_responses(self):
        request = self.rf.get('/articles/10-w-t-f/')
        response = DummyResponse(200)
        tools.assert_true(response is self.m.process_response(request, response))

    def test_middleware_ignores_valid_404_responses(self):
        request = self.rf.get('/this/url/does/not/exist/')
        response = DummyResponse(404)
        tools.assert_true(response is self.m.process_response(request, response))

    def test_middleware_redirects_static_home(self):
        request = self.rf.get('/articles/10-w-t-f/')
        response = DummyResponse(404)
        new_response = self.m.process_response(request, response)
        tools.assert_equals(301, new_response.status_code)
        tools.assert_equals('/10-w-t-f/', new_response['Location'])

    def test_middleware_redirects_static_in_cat(self):
        request = self.rf.get('/nested-category/articles/10-w-t-f/')
        response = DummyResponse(404)
        new_response = self.m.process_response(request, response)
        tools.assert_equals(301, new_response.status_code)
        tools.assert_equals('/nested-category/10-w-t-f/', new_response['Location'])

    def test_middleware_redirects_static_in_cat_name_as_ct(self):
        request = self.rf.get('/articles/articles/10-w-t-f/')
        response = DummyResponse(404)
        new_response = self.m.process_response(request, response)
        tools.assert_equals(301, new_response.status_code)
        tools.assert_equals('/articles/10-w-t-f/', new_response['Location'])

    def test_middleware_redirects_static_with_custom_urls(self):
        request = self.rf.get('/articles/articles/10-w-t-f/comments/add/')
        response = DummyResponse(404)
        new_response = self.m.process_response(request, response)
        tools.assert_equals(301, new_response.status_code)
        tools.assert_equals('/articles/10-w-t-f/comments/add/', new_response['Location'])

    def test_middleware_redirects_non_static_with_custom_urls(self):
        request = self.rf.get('/nested/articles/2010/10/10/articles/w-t-f/comments/add/')
        response = DummyResponse(404)
        new_response = self.m.process_response(request, response)
        tools.assert_equals(301, new_response.status_code)
        tools.assert_equals('/nested/articles/2010/10/10/w-t-f/comments/add/', new_response['Location'])


########NEW FILE########
__FILENAME__ = test_paginator
from unittest import TestCase

from nose import tools
from ella.utils.pagination import FirstPagePaginator


OBJECTS = ['1', '2', '3', '4', '5']


class TestPaginator(TestCase):
    def test_diffrerent_first_page(self):
        p = FirstPagePaginator(OBJECTS, first_page_count=1, per_page=2)

        tools.assert_equals(p.page(1).object_list, ['1'])

    def test_other_pages(self):
        p = FirstPagePaginator(OBJECTS, first_page_count=1, per_page=2)

        tools.assert_equals(p.page(2).object_list, ['2', '3'])
        tools.assert_equals(p.page(3).object_list, ['4', '5'])

    def test_all_pages_same(self):
        p = FirstPagePaginator(OBJECTS, per_page=2)

        tools.assert_equals(p.page(1).object_list, ['1', '2'])
        tools.assert_equals(p.page(2).object_list, ['3', '4'])

########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls import patterns, include
except ImportError:
    from django.conf.urls.defaults import patterns, include

urlpatterns = patterns('',
    (r'^', include('ella.core.urls')),
)

########NEW FILE########
__FILENAME__ = working_urls
from django.contrib import admin
from django.conf import settings

try:
    from django.conf.urls import *
except ImportError:
    from django.conf.urls.defaults import *

from test_ella.urls import urlpatterns

admin.autodiscover()

urlpatterns = patterns('',
    (r'^%s(?P<path>.*)$' % (settings.MEDIA_URL.lstrip('/')), 'django.views.static.serve', { 'document_root': settings.MEDIA_ROOT, }),
    (r'^admin/', include(admin.site.urls)),
) + urlpatterns

########NEW FILE########
