__FILENAME__ = test_client
import json
import logging
import urllib.parse

import asyncio
import websockets


logging.basicConfig(level=logging.WARNING)
#logging.getLogger('websockets').setLevel(logging.DEBUG)

SERVER = 'ws://127.0.0.1:8642'
AGENT = 'websockets'


class EchoClientProtocol(websockets.WebSocketClientProtocol):

    """WebSocket client protocol that echoes messages synchronously."""

    @asyncio.coroutine
    def read_message(self):
        msg = yield from super().read_message()
        if msg is not None:
            yield from self.send(msg)
        return msg


@asyncio.coroutine
def get_case_count(server):
    uri = server + '/getCaseCount'
    ws = yield from websockets.connect(uri)
    msg = yield from ws.recv()
    yield from ws.worker
    return json.loads(msg)


@asyncio.coroutine
def run_case(server, case, agent):
    uri = server + '/runCase?case={}&agent={}'.format(case, agent)
    ws = yield from websockets.connect(uri, klass=EchoClientProtocol)
    yield from ws.worker


@asyncio.coroutine
def update_reports(server, agent):
    uri = server + '/updateReports?agent={}'.format(agent)
    ws = yield from websockets.connect(uri)
    yield from ws.worker


@asyncio.coroutine
def run_tests(server, agent):
    cases = yield from get_case_count(server)
    for case in range(1, cases + 1):
        print("Running test case {} out of {}".format(case, cases), end="\r")
        yield from run_case(server, case, agent)
    print("Ran {} test cases               ".format(cases))
    yield from update_reports(server, agent)


main = run_tests(SERVER, urllib.parse.quote(AGENT))
asyncio.get_event_loop().run_until_complete(main)

########NEW FILE########
__FILENAME__ = test_server
import logging

import asyncio
import websockets


logging.basicConfig(level=logging.WARNING)
#logging.getLogger('websockets').setLevel(logging.DEBUG)


class EchoServerProtocol(websockets.WebSocketServerProtocol):

    """WebSocket server protocol that echoes messages synchronously."""

    @asyncio.coroutine
    def read_message(self):
        msg = yield from super().read_message()
        if msg is not None:
            yield from self.send(msg)
        return msg


@asyncio.coroutine
def noop(ws, path):
    yield from ws.worker


start_server = websockets.serve(noop, '127.0.0.1', 8642, klass=EchoServerProtocol)

try:
    asyncio.get_event_loop().run_until_complete(start_server)
    asyncio.get_event_loop().run_forever()
except KeyboardInterrupt:
    pass

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# websockets documentation build configuration file, created by
# sphinx-quickstart on Sun Mar 31 20:48:44 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'websockets'
copyright = '2013-2014, Aymeric Augustin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.1'
# The full version, including alpha/beta/rc tags.
release = '2.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pydoctheme'
html_theme_path = ['.']

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'websocketsdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'websockets.tex', 'websockets Documentation',
   'Aymeric Augustin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'websockets', 'websockets Documentation',
     ['Aymeric Augustin'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'websockets', 'websockets Documentation',
   'Aymeric Augustin', 'websockets', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/3/': None}

########NEW FILE########
__FILENAME__ = client
#!/usr/bin/env python

import asyncio
import websockets

@asyncio.coroutine
def hello():
    websocket = yield from websockets.connect('ws://localhost:8765/')
    name = input("What's your name? ")
    yield from websocket.send(name)
    print("> {}".format(name))
    greeting = yield from websocket.recv()
    print("< {}".format(greeting))

asyncio.get_event_loop().run_until_complete(hello())

########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python

import asyncio
import websockets

@asyncio.coroutine
def hello(websocket, path):
    name = yield from websocket.recv()
    print("< {}".format(name))
    greeting = "Hello {}!".format(name)
    print("> {}".format(greeting))
    yield from websocket.send(greeting)

start_server = websockets.serve(hello, 'localhost', 8765)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()

########NEW FILE########
__FILENAME__ = client
"""
The :mod:`websockets.client` module defines a simple WebSocket client API.
"""

__all__ = ['connect', 'WebSocketClientProtocol']

import asyncio

from .exceptions import InvalidHandshake
from .handshake import build_request, check_response
from .http import read_response, USER_AGENT
from .protocol import WebSocketCommonProtocol
from .uri import parse_uri


class WebSocketClientProtocol(WebSocketCommonProtocol):
    """
    Complete WebSocket client implementation as an asyncio protocol.

    This class inherits most of its methods from
    :class:`~websockets.protocol.WebSocketCommonProtocol`.
    """

    is_client = True
    state = 'CONNECTING'

    @asyncio.coroutine
    def handshake(self, wsuri, origin=None):
        """
        Perform the client side of the opening handshake.

        If provided, ``origin`` sets the HTTP Origin header.
        """
        headers = []
        set_header = lambda k, v: headers.append((k, v))
        if wsuri.port == (443 if wsuri.secure else 80):         # pragma: no cover
            set_header('Host', wsuri.host)
        else:
            set_header('Host', '{}:{}'.format(wsuri.host, wsuri.port))
        if origin is not None:
            set_header('Origin', origin)
        set_header('User-Agent', USER_AGENT)
        key = build_request(set_header)
        self.raw_request_headers = headers

        # Send handshake request. Since the URI and the headers only contain
        # ASCII characters, we can keep this simple.
        request = ['GET %s HTTP/1.1' % wsuri.resource_name]
        request.extend('{}: {}'.format(k, v) for k, v in headers)
        request.append('\r\n')
        request = '\r\n'.join(request).encode()
        self.writer.write(request)

        # Read handshake response.
        try:
            status_code, headers = yield from read_response(self.reader)
        except Exception as exc:
            raise InvalidHandshake("Malformed HTTP message") from exc
        if status_code != 101:
            raise InvalidHandshake("Bad status code: {}".format(status_code))
        self.raw_response_headers = list(headers.raw_items())
        get_header = lambda k: headers.get(k, '')
        check_response(get_header, key)

        self.state = 'OPEN'
        self.opening_handshake.set_result(True)


@asyncio.coroutine
def connect(uri, *,
            klass=WebSocketClientProtocol, origin=None, **kwds):
    """
    This coroutine connects to a WebSocket server.

    It accepts an ``origin`` keyword argument to set the Origin HTTP header.

    It's a thin wrapper around the event loop's `create_connection` method.
    Extra keyword arguments are passed to `create_server`.

    It returns a :class:`~websockets.client.WebSocketClientProtocol` which can
    then be used to send and receive messages.

    It raises :exc:`~websockets.uri.InvalidURI` if `uri` is invalid and
    :exc:`~websockets.handshake.InvalidHandshake` if the handshake fails.

    Clients shouldn't close the WebSocket connection. Instead, they should
    wait until the server performs the closing handshake by yielding from the
    protocol's :attr:`worker` attribute.

    :func:`connect` implements the sequence called "Establish a WebSocket
    Connection" in RFC 6455, except for the requirement that "there MUST be no
    more than one connection in a CONNECTING state."
    """
    wsuri = parse_uri(uri)
    if wsuri.secure:
        kwds.setdefault('ssl', True)
    elif 'ssl' in kwds:
        raise ValueError("connect() received a SSL context for a ws:// URI. "
                         "Use a wss:// URI to enable TLS.")
    factory = lambda: klass(host=wsuri.host, port=wsuri.port, secure=wsuri.secure)
    transport, protocol = yield from asyncio.get_event_loop().create_connection(
            factory, wsuri.host, wsuri.port, **kwds)

    try:
        yield from protocol.handshake(wsuri, origin=origin)
    except Exception:
        protocol.writer.close()
        raise

    return protocol

########NEW FILE########
__FILENAME__ = exceptions
__all__ = ['InvalidHandshake', 'InvalidState', 'InvalidURI']


class InvalidHandshake(Exception):
    """Exception raised when a handshake request or response is invalid."""


class InvalidState(Exception):
    """Exception raised when an operation is forbidden in the current state."""


class InvalidURI(Exception):
    """Exception raised when an URI is invalid."""


class WebSocketProtocolError(Exception):
    # Internal exception raised when the other end breaks the protocol.
    # It's private because it shouldn't leak outside of WebSocketCommonProtocol.
    pass

########NEW FILE########
__FILENAME__ = framing
"""
The :mod:`websockets.framing` module implements data framing as specified in
`section 5 of RFC 6455`_.

It deals with a single frame at a time. Anything that depends on the sequence
of frames is implemented in :mod:`websockets.protocol`.

.. _section 5 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-5
"""

import collections
import io
import random
import struct

import asyncio

from .exceptions import WebSocketProtocolError


__all__ = [
    'OP_CONT', 'OP_TEXT', 'OP_BINARY', 'OP_CLOSE', 'OP_PING', 'OP_PONG',
    'Frame', 'read_frame', 'write_frame', 'parse_close', 'serialize_close'
]

OP_CONT, OP_TEXT, OP_BINARY = range(0x00, 0x03)
OP_CLOSE, OP_PING, OP_PONG = range(0x08, 0x0b)

CLOSE_CODES = {
    1000: "OK",
    1001: "going away",
    1002: "protocol error",
    1003: "unsupported type",
    # 1004: - (reserved)
    # 1005: no status code (internal)
    # 1006: connection closed abnormally (internal)
    1007: "invalid data",
    1008: "policy violation",
    1009: "message too big",
    1010: "extension required",
    1011: "unexpected error",
    # 1015: TLS failure (internal)
}


Frame = collections.namedtuple('Frame', ('fin', 'opcode', 'data'))


@asyncio.coroutine
def read_frame(reader, mask):
    """
    Read a WebSocket frame and return a :class:`Frame` object.

    `reader` is a coroutine taking an integer argument and reading exactly this
    number of bytes, unless the end of file is reached.

    `mask` is a :class:`bool` telling whether the frame should be masked, ie.
    whether the read happens on the server side.

    This function validates the frame before returning it and raises
    :exc:`WebSocketProtocolError` if it contains incorrect values.
    """
    # Read the header
    data = yield from read_bytes(reader, 2)
    head1, head2 = struct.unpack('!BB', data)
    fin = bool(head1 & 0b10000000)
    if head1 & 0b01110000:
        raise WebSocketProtocolError("Reserved bits must be 0")
    opcode = head1 & 0b00001111
    if bool(head2 & 0b10000000) != mask:
        raise WebSocketProtocolError("Incorrect masking")
    length = head2 & 0b01111111
    if length == 126:
        data = yield from read_bytes(reader, 2)
        length, = struct.unpack('!H', data)
    elif length == 127:
        data = yield from read_bytes(reader, 8)
        length, = struct.unpack('!Q', data)
    if mask:
        mask_bits = yield from read_bytes(reader, 4)

    # Read the data
    data = yield from read_bytes(reader, length)
    if mask:
        data = bytes(b ^ mask_bits[i % 4] for i, b in enumerate(data))

    frame = Frame(fin, opcode, data)
    check_frame(frame)
    return frame


@asyncio.coroutine
def read_bytes(reader, n):
    # Undocumented utility function.
    try:
        return (yield from reader(n))
    except asyncio.IncompleteReadError:
        raise WebSocketProtocolError("Unexpected EOF")


def write_frame(frame, writer, mask):
    """
    Write a WebSocket frame.

    `frame` is the :class:`Frame` object to write.

    `writer` is a function accepting bytes.

    `mask` is a :class:`bool` telling whether the frame should be masked, ie.
    whether the write happens on the client side.

    This function validates the frame before sending it and raises
    :exc:`WebSocketProtocolError` if it contains incorrect values.
    """
    check_frame(frame)

    # Write the header
    header = io.BytesIO()
    head1 = 0b10000000 if frame.fin else 0
    head1 |= frame.opcode
    head2 = 0b10000000 if mask else 0
    length = len(frame.data)
    if length < 0x7e:
        header.write(struct.pack('!BB', head1, head2 | length))
    elif length < 0x10000:
        header.write(struct.pack('!BBH', head1, head2 | 126, length))
    else:
        header.write(struct.pack('!BBQ', head1, head2 | 127, length))
    if mask:
        mask_bits = struct.pack('!I', random.getrandbits(32))
        header.write(mask_bits)
    writer(header.getvalue())

    # Write the data
    if mask:
        data = bytes(b ^ mask_bits[i % 4] for i, b in enumerate(frame.data))
    else:
        data = frame.data
    writer(data)


def check_frame(frame):
    """
    Raise :exc:`WebSocketProtocolError` if the frame contains incorrect values.
    """
    if frame.opcode in (OP_CONT, OP_TEXT, OP_BINARY):
        return
    elif frame.opcode in (OP_CLOSE, OP_PING, OP_PONG):
        if len(frame.data) > 125:
            raise WebSocketProtocolError("Control frame too long")
        if not frame.fin:
            raise WebSocketProtocolError("Fragmented control frame")
    else:
        raise WebSocketProtocolError("Invalid opcode")


def parse_close(data):
    """
    Parse the data in a close frame.

    Return `(code, reason)` when `code` is an :class:`int` and `reason` a
    :class:`str`.

    Raise :exc:`WebSocketProtocolError` or :exc:`UnicodeDecodeError` if the
    data is invalid.
    """
    length = len(data)
    if length == 0:
        return 1005, ''
    elif length == 1:
        raise WebSocketProtocolError("Close frame too short")
    else:
        code, = struct.unpack('!H', data[:2])
        if not (code in CLOSE_CODES or 3000 <= code < 5000):
            raise WebSocketProtocolError("Invalid status code")
        reason = data[2:].decode('utf-8')
        return code, reason


def serialize_close(code, reason):
    """
    Serialize the data for a close frame.

    This is the reverse of :func:`parse_close`.
    """
    return struct.pack('!H', code) + reason.encode('utf-8')

########NEW FILE########
__FILENAME__ = handshake
"""
The :mod:`websockets.handshake` module deals with the WebSocket opening
handshake according to `section 4 of RFC 6455`_.

.. _section 4 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-4

It provides functions to implement the handshake with any existing HTTP
library. You must pass to these functions:

- A `set_header` function accepting a header name and a header value,
- A `get_header` function accepting a header name and returning the header
  value.

The inputs and outputs of `get_header` and `set_header` are :class:`str`
objects containing only ASCII characters.

Some checks cannot be performed because they depend too much on the
context; instead, they're documented below.

To accept a connection, a server must:

- Read the request, check that the method is GET, and check the headers with
  :func:`check_request`,
- Send a 101 response to the client with the headers created by
  :func:`build_response` if the request is valid; otherwise, send a 400.

To open a connection, a client must:

- Send a GET request to the server with the headers created by
  :func:`build_request`,
- Read the response, check that the status code is 101, and check the headers
  with :func:`check_response`.
"""

__all__ = [
    'build_request', 'check_request',
    'build_response', 'check_response',
]

import base64
import hashlib
import random

from .exceptions import InvalidHandshake


GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"


def build_request(set_header):
    """
    Build a handshake request to send to the server.

    Return the `key` which must be passed to :func:`check_response`.
    """
    rand = bytes(random.getrandbits(8) for _ in range(16))
    key = base64.b64encode(rand).decode()
    set_header('Upgrade', 'WebSocket')
    set_header('Connection', 'Upgrade')
    set_header('Sec-WebSocket-Key', key)
    set_header('Sec-WebSocket-Version', '13')
    return key


def check_request(get_header):
    """
    Check a handshake request received from the client.

    If the handshake is valid, this function returns the `key` which must be
    passed to :func:`build_response`.

    Otherwise, it raises an :exc:`InvalidHandshake` exception and the server
    must return an error, usually 400 Bad Request.

    This function doesn't verify that the request is an HTTP/1.1 or higher GET
    request and doesn't perform Host and Origin checks. These controls are
    usually performed earlier in the HTTP request handling code. They're the
    responsibility of the caller.
    """
    try:
        assert get_header('Upgrade').lower() == 'websocket'
        assert any(token.strip() == 'upgrade'
                for token in get_header('Connection').lower().split(','))
        key = get_header('Sec-WebSocket-Key')
        assert len(base64.b64decode(key.encode())) == 16
        assert get_header('Sec-WebSocket-Version') == '13'
        return key
    except (AssertionError, KeyError) as exc:
        raise InvalidHandshake("Invalid request") from exc


def build_response(set_header, key):
    """
    Build a handshake response to send to the client.

    `key` comes from :func:`check_request`.
    """
    set_header('Upgrade', 'WebSocket')
    set_header('Connection', 'Upgrade')
    set_header('Sec-WebSocket-Accept', accept(key))


def check_response(get_header, key):
    """
    Check a handshake response received from the server.

    `key` comes from :func:`build_request`.

    If the handshake is valid, this function returns ``None``.

    Otherwise, it raises an :exc:`InvalidHandshake` exception.

    This function doesn't verify that the response is an HTTP/1.1 or higher
    response with a 101 status code. These controls are the responsibility of
    the caller.
    """
    try:
        assert get_header('Upgrade').lower() == 'websocket'
        assert any(token.strip() == 'upgrade'
                for token in get_header('Connection').lower().split(','))
        assert get_header('Sec-WebSocket-Accept') == accept(key)
    except (AssertionError, KeyError) as exc:
        raise InvalidHandshake("Invalid response") from exc


def accept(key):
    sha1 = hashlib.sha1((key + GUID).encode()).digest()
    return base64.b64encode(sha1).decode()

########NEW FILE########
__FILENAME__ = http
"""
The :mod:`websockets.http` module provides HTTP parsing functions. They're
merely adequate for the WebSocket handshake messages. They're used by the
sample client and servers.

These functions cannot be imported from :mod:`websockets`; they must be
imported from :mod:`websockets.http`.
"""

__all__ = ['read_request', 'read_response', 'USER_AGENT']

import email.parser
import io
import sys

import asyncio

from .version import version as websockets_version


MAX_HEADERS = 256
MAX_LINE = 4096

USER_AGENT = ' '.join((
    'Python/{}'.format(sys.version[:3]),
    'websockets/{}'.format(websockets_version),
))


@asyncio.coroutine
def read_request(stream):
    """
    Read an HTTP/1.1 request from `stream`.

    Return `(path, headers)` where `path` is a :class:`str` and `headers` is a
    :class:`~email.message.Message`; `path` isn't URL-decoded.

    Raise an exception if the request isn't well formatted.

    The request is assumed not to contain a body.
    """
    request_line, headers = yield from read_message(stream)
    method, path, version = request_line[:-2].decode().split(None, 2)
    if method != 'GET':
        raise ValueError("Unsupported method")
    if version != 'HTTP/1.1':
        raise ValueError("Unsupported HTTP version")
    return path, headers


@asyncio.coroutine
def read_response(stream):
    """
    Read an HTTP/1.1 response from `stream`.

    Return `(status, headers)` where `status` is a :class:`int` and `headers`
    is a :class:`~email.message.Message`.

    Raise an exception if the request isn't well formatted.

    The response is assumed not to contain a body.
    """
    status_line, headers = yield from read_message(stream)
    version, status, reason = status_line[:-2].decode().split(None, 2)
    if version != 'HTTP/1.1':
        raise ValueError("Unsupported HTTP version")
    return int(status), headers


@asyncio.coroutine
def read_message(stream):
    """
    Read an HTTP message from `stream`.

    Return `(start_line, headers)` where `start_line` is :class:`bytes` and
    `headers` is a :class:`~email.message.Message`.

    The message is assumed not to contain a body.
    """
    start_line = yield from read_line(stream)
    header_lines = io.BytesIO()
    for num in range(MAX_HEADERS):
        header_line = yield from read_line(stream)
        header_lines.write(header_line)
        if header_line == b'\r\n':
            break
    else:
        raise ValueError("Too many headers")
    header_lines.seek(0)
    headers = email.parser.BytesHeaderParser().parse(header_lines)
    return start_line, headers


@asyncio.coroutine
def read_line(stream):
    """
    Read a single line from `stream`.
    """
    line = yield from stream.readline()
    if len(line) > MAX_LINE:
        raise ValueError("Line too long")
    if not line.endswith(b'\r\n'):
        raise ValueError("Line without CRLF")
    return line

########NEW FILE########
__FILENAME__ = protocol
"""
The :mod:`websockets.protocol` module handles WebSocket control and data
frames as specified in `sections 4 to 8 of RFC 6455`_.

.. _sections 4 to 8 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-4
"""

__all__ = ['WebSocketCommonProtocol']

import codecs
import collections
import logging
import random
import struct

import asyncio
from asyncio.queues import Queue, QueueEmpty

from .exceptions import InvalidState, WebSocketProtocolError
from .framing import *
from .handshake import *


logger = logging.getLogger(__name__)


class WebSocketCommonProtocol(asyncio.StreamReaderProtocol):
    """
    This class implements common parts of the WebSocket protocol.

    It assumes that the WebSocket connection is established. The handshake is
    managed in subclasses such as
    :class:`~websockets.server.WebSocketServerProtocol` and
    :class:`~websockets.client.WebSocketClientProtocol`.

    It runs a task that stores incoming data frames in a queue and deals with
    control frames automatically. It sends outgoing data frames and performs
    the closing handshake.

    The `host`, `port` and `secure` parameters are simply stored as attributes
    for handlers that need them.

    The `timeout` parameter defines the maximum wait time in seconds for
    completing the closing handshake and, only on the client side, for
    terminating the TCP connection. :meth:`close()` will complete in at most
    this time on the server side and twice this time on the client side.

    Once the connection is closed, the status code is available in the
    :attr:`close_code` attribute and the reason in :attr:`close_reason`.
    """

    # There are only two differences between the client-side and the server-
    # side behavior: masking the payload and closing the underlying TCP
    # connection. This class implements the server-side behavior by default.
    # To get the client-side behavior, set is_client = True.

    is_client = False
    state = 'OPEN'

    def __init__(self, *,
                 host=None, port=None, secure=None, timeout=10, loop=None):
        self.host = host
        self.port = port
        self.secure = secure

        self.timeout = timeout

        super().__init__(asyncio.StreamReader(), self.client_connected, loop)

        self.close_code = None
        self.close_reason = ''

        # Futures tracking steps in the connection's lifecycle.
        self.opening_handshake = asyncio.Future()
        self.closing_handshake = asyncio.Future()
        self.connection_closed = asyncio.Future()

        # Queue of received messages.
        self.messages = Queue()

        # Mapping of ping IDs to waiters, in chronological order.
        self.pings = collections.OrderedDict()

        # Task managing the connection.
        self.worker = asyncio.async(self.run())

        # In a subclass implementing the opening handshake, the state will be
        # CONNECTING at this point.
        if self.state == 'OPEN':
            self.opening_handshake.set_result(True)

    # Public API

    @property
    def open(self):
        """
        This property is ``True`` when the connection is usable.

        It may be used to handle disconnections gracefully.
        """
        return self.state == 'OPEN'

    @asyncio.coroutine
    def close(self, code=1000, reason=''):
        """
        This coroutine performs the closing handshake.

        This is the expected way to terminate a connection on the server side.

        It waits for the other end to complete the handshake. It doesn't do
        anything once the connection is closed.

        It's usually safe to wrap this coroutine in `asyncio.async()` since
        errors during connection termination aren't particularly useful.

        The `code` must be an :class:`int` and the `reason` a :class:`str`.
        """
        if self.state == 'OPEN':
            # 7.1.2. Start the WebSocket Closing Handshake
            self.close_code, self.close_reason = code, reason
            yield from self.write_frame(OP_CLOSE, serialize_close(code, reason))
            # 7.1.3. The WebSocket Closing Handshake is Started
            self.state = 'CLOSING'

        # If the connection doesn't terminate within the timeout, break out of
        # the worker loop.
        try:
            yield from asyncio.wait_for(self.worker, timeout=self.timeout)
        except asyncio.TimeoutError:
            self.worker.cancel()

        # The worker should terminate quickly once it has been cancelled.
        yield from self.worker

    @asyncio.coroutine
    def recv(self):
        """
        This coroutine receives the next message.

        It returns a :class:`str` for a text frame and :class:`bytes` for a
        binary frame.

        When the end of the message stream is reached, or when a protocol
        error occurs, :meth:`recv` returns ``None``, indicating that the
        connection is closed.
        """
        # Return any available message
        try:
            return self.messages.get_nowait()
        except QueueEmpty:
            pass

        # Wait for a message until the connection is closed
        next_message = asyncio.Task(self.messages.get())
        done, pending = yield from asyncio.wait(
                [next_message, self.worker],
                return_when=asyncio.FIRST_COMPLETED)
        if next_message in done:
            return next_message.result()

    @asyncio.coroutine
    def send(self, data):
        """
        This coroutine sends a message.

        It sends a :class:`str` as a text frame and :class:`bytes` as a binary
        frame.

        It raises a :exc:`TypeError` for other inputs and
        :exc:`InvalidState` once the connection is closed.
        """
        if isinstance(data, str):
            opcode = 1
            data = data.encode('utf-8')
        elif isinstance(data, bytes):
            opcode = 2
        else:
            raise TypeError("data must be bytes or str")
        yield from self.write_frame(opcode, data)

    @asyncio.coroutine
    def ping(self, data=None):
        """
        This coroutine sends a ping.

        It returns a Future which will be completed when the corresponding
        pong is received and which you may ignore if you don't want to wait.

        A ping may serve as a keepalive.
        """
        # Protect against duplicates if a payload is explicitly set.
        if data in self.pings:
            raise ValueError("Already waiting for a pong with the same data")
        # Generate a unique random payload otherwise.
        while data is None or data in self.pings:
            data = struct.pack('!I', random.getrandbits(32))

        self.pings[data] = asyncio.Future()
        yield from self.write_frame(OP_PING, data)
        return self.pings[data]

    @asyncio.coroutine
    def pong(self, data=b''):
        """
        This coroutine sends a pong.

        An unsolicited pong may serve as a unidirectional heartbeat.
        """
        yield from self.write_frame(OP_PONG, data)

    # Private methods - no guarantees.

    @asyncio.coroutine
    def run(self):
        # This coroutine guarantees that the connection is closed at exit.
        yield from self.opening_handshake
        while not self.closing_handshake.done():
            try:
                msg = yield from self.read_message()
                if msg is None:
                    break
                self.messages.put_nowait(msg)
            except asyncio.CancelledError:
                break
            except WebSocketProtocolError:
                yield from self.fail_connection(1002)
            except UnicodeDecodeError:
                yield from self.fail_connection(1007)
            except Exception:
                yield from self.fail_connection(1011)
                raise
        yield from self.close_connection()

    @asyncio.coroutine
    def read_message(self):
        # Reassemble fragmented messages.
        frame = yield from self.read_data_frame()
        if frame is None:
            return
        if frame.opcode == OP_TEXT:
            text = True
        elif frame.opcode == OP_BINARY:
            text = False
        else:   # frame.opcode == OP_CONT
            raise WebSocketProtocolError("Unexpected opcode")

        # Shortcut for the common case - no fragmentation
        if frame.fin:
            return frame.data.decode('utf-8') if text else frame.data

        # 5.4. Fragmentation
        chunks = []
        if text:
            decoder = codecs.getincrementaldecoder('utf-8')(errors='strict')
            append = lambda f: chunks.append(decoder.decode(f.data, f.fin))
        else:
            append = lambda f: chunks.append(f.data)
        append(frame)

        while not frame.fin:
            frame = yield from self.read_data_frame()
            if frame is None:
                raise WebSocketProtocolError("Incomplete fragmented message")
            if frame.opcode != OP_CONT:
                raise WebSocketProtocolError("Unexpected opcode")
            append(frame)

        return ('' if text else b'').join(chunks)

    @asyncio.coroutine
    def read_data_frame(self):
        # Deal with control frames automatically and return next data frame.
        # 6.2. Receiving Data
        while True:
            frame = yield from self.read_frame()
            # 5.5. Control Frames
            if frame.opcode == OP_CLOSE:
                self.close_code, self.close_reason = parse_close(frame.data)
                if self.state != 'CLOSING':
                    # 7.1.3. The WebSocket Closing Handshake is Started
                    self.state = 'CLOSING'
                    yield from self.write_frame(OP_CLOSE, frame.data, 'CLOSING')
                self.closing_handshake.set_result(True)
                return
            elif frame.opcode == OP_PING:
                # Answer pings.
                yield from self.pong(frame.data)
            elif frame.opcode == OP_PONG:
                # Do not acknowledge pings on unsolicited pongs.
                if frame.data in self.pings:
                    # Acknowledge all pings up to the one matching this pong.
                    ping_id = None
                    while ping_id != frame.data:
                        ping_id, waiter = self.pings.popitem(0)
                        if not waiter.cancelled():
                            waiter.set_result(None)
            # 5.6. Data Frames
            else:
                return frame

    @asyncio.coroutine
    def read_frame(self):
        is_masked = not self.is_client
        frame = yield from read_frame(self.reader.readexactly, is_masked)
        side = 'client' if self.is_client else 'server'
        logger.debug("%s << %s", side, frame)
        return frame

    @asyncio.coroutine
    def write_frame(self, opcode, data=b'', expected_state='OPEN'):
        # This may happen if a user attempts to write on a closed connection.
        if self.state != expected_state:
            raise InvalidState("Cannot write to a WebSocket "
                               "in the {} state".format(self.state))
        frame = Frame(True, opcode, data)
        side = 'client' if self.is_client else 'server'
        logger.debug("%s >> %s", side, frame)
        is_masked = self.is_client
        write_frame(frame, self.writer.write, is_masked)
        try:
            # Handle flow control automatically.
            yield from self.writer.drain()
        except ConnectionResetError:
            # Terminate the connection if the socket died.
            self.state = 'CLOSING'
            yield from self.fail_connection(1006)

    @asyncio.coroutine
    def close_connection(self):
        # 7.1.1. Close the WebSocket Connection
        if self.state == 'CLOSED':
            return

        # Defensive assertion for protocol compliance.
        if self.state != 'CLOSING':                         # pragma: no cover
            raise InvalidState("Cannot close a WebSocket connection "
                               "in the {} state".format(self.state))

        if self.is_client:
            try:
                yield from asyncio.wait_for(self.connection_closed,
                        timeout=self.timeout)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                pass

            if self.state == 'CLOSED':
                return

        # Attempt to terminate the TCP connection properly.
        # If the socket is already closed, this will crash.
        try:
            if self.writer.can_write_eof():
                self.writer.write_eof()
        except Exception:
            pass

        self.writer.close()

        try:
            yield from asyncio.wait_for(self.connection_closed,
                    timeout=self.timeout)
        except (asyncio.CancelledError, asyncio.TimeoutError):
            pass

    @asyncio.coroutine
    def fail_connection(self, code=1011, reason=''):
        # Losing the connection usually results in a protocol error.
        # Preserve the original error code in this case.
        if self.close_code != 1006:
            self.close_code, self.close_reason = code, reason
        # 7.1.7. Fail the WebSocket Connection
        logger.info("Failing the WebSocket connection: %d %s", code, reason)
        if self.state == 'OPEN':
            yield from self.write_frame(OP_CLOSE, serialize_close(code, reason))
            self.state = 'CLOSING'
        if not self.closing_handshake.done():
            self.closing_handshake.set_result(False)
        yield from self.close_connection()

    # asyncio StreamReaderProtocol methods

    def client_connected(self, reader, writer):
        self.reader = reader
        self.writer = writer

    def connection_lost(self, exc):
        # 7.1.4. The WebSocket Connection is Closed
        self.state = 'CLOSED'
        if not self.connection_closed.done():
            self.connection_closed.set_result(None)
        if self.close_code is None:
            self.close_code = 1006
        super().connection_lost(exc)

########NEW FILE########
__FILENAME__ = server
"""
The :mod:`websockets.server` module defines a simple WebSocket server API.
"""

__all__ = ['serve', 'WebSocketServerProtocol']

import logging

import asyncio

from .exceptions import InvalidHandshake
from .handshake import check_request, build_response
from .http import read_request, USER_AGENT
from .protocol import WebSocketCommonProtocol


logger = logging.getLogger(__name__)


class WebSocketServerProtocol(WebSocketCommonProtocol):
    """
    Complete WebSocket server implementation as an asyncio protocol.

    This class inherits most of its methods from
    :class:`~websockets.protocol.WebSocketCommonProtocol`.

    For the sake of simplicity, this protocol doesn't inherit a proper HTTP
    implementation. Its support for HTTP responses is very limited.
    """

    state = 'CONNECTING'

    def __init__(self, ws_handler=None, *, origins=None, **kwargs):
        self.ws_handler = ws_handler
        self.origins = origins
        super().__init__(**kwargs)

    def connection_made(self, transport):
        super().connection_made(transport)
        asyncio.async(self.handler())

    @asyncio.coroutine
    def handler(self):
        # Since this method doesn't have a caller able to handle exceptions,
        # it attemps to log relevant ones and close the connection properly.
        try:

            try:
                path = yield from self.handshake(origins=self.origins)
            except Exception as exc:
                logger.info("Exception in opening handshake: {}".format(exc))
                if isinstance(exc, InvalidHandshake):
                    response = 'HTTP/1.1 400 Bad Request\r\n\r\n' + str(exc)
                else:
                    response = ('HTTP/1.1 500 Internal Server Error\r\n\r\n'
                                'See server log for more information.')
                self.writer.write(response.encode())
                raise

            try:
                yield from self.ws_handler(self, path)
            except Exception:
                logger.info("Exception in connection handler", exc_info=True)
                yield from self.fail_connection(1011)
                raise

            try:
                yield from self.close()
            except Exception as exc:
                logger.info("Exception in closing handshake: {}".format(exc))
                raise

        except Exception:
            # Last-ditch attempt to avoid leaking connections on errors.
            try:
                self.writer.close()
            except Exception:                               # pragma: no cover
                pass



    @asyncio.coroutine
    def handshake(self, origins=None):
        """
        Perform the server side of the opening handshake.

        If provided, ``origins`` is a list of acceptable HTTP Origin values.
        Include ``''`` in the list if the lack of an origin is acceptable.

        Return the URI of the request.
        """
        # Read handshake request.
        try:
            path, headers = yield from read_request(self.reader)
        except Exception as exc:
            raise InvalidHandshake("Malformed HTTP message") from exc

        self.raw_request_headers = list(headers.raw_items())
        get_header = lambda k: headers.get(k, '')
        key = check_request(get_header)

        # Check origin in request.
        if origins is not None:
            origin = get_header('Origin')
            if not set(origin.split() or ('',))<= set(origins):
                raise InvalidHandshake("Bad origin: {}".format(origin))

        headers = []
        set_header = lambda k, v: headers.append((k, v))
        set_header('Server', USER_AGENT)
        build_response(set_header, key)
        self.raw_response_headers = headers

        # Send handshake response. Since the status line and headers only
        # contain ASCII characters, we can keep this simple.
        response = ['HTTP/1.1 101 Switching Protocols']
        response.extend('{}: {}'.format(k, v) for k, v in headers)
        response.append('\r\n')
        response = '\r\n'.join(response).encode()
        self.writer.write(response)

        self.state = 'OPEN'
        self.opening_handshake.set_result(True)

        return path


@asyncio.coroutine
def serve(ws_handler, host=None, port=None, *,
          klass=WebSocketServerProtocol, origins=None, **kwds):
    """
    This coroutine creates a WebSocket server.

    It's a thin wrapper around the event loop's `create_server` method.
    `host`, `port` as well as extra keyword arguments are passed to
    `create_server`.

    `ws_handler` is the WebSocket handler. It must be a coroutine accepting
    two arguments: a :class:`~websockets.server.WebSocketServerProtocol` and
    the request URI. `origin` is a list of acceptable Origin HTTP headers.

    It returns a `Server` object with a `close` method to stop the server.

    Whenever a client connects, the server accepts the connection, creates a
    :class:`~websockets.server.WebSocketServerProtocol`, performs the opening
    handshake, and delegates to the WebSocket handler. Once the handler
    completes, the server performs the closing handshake and closes the
    connection.
    """
    secure = kwds.get('ssl') is not None
    factory = lambda: klass(ws_handler,
                            host=host, port=port, secure=secure, origins=origins)
    return (yield from asyncio.get_event_loop().create_server(
            factory, host, port, **kwds))

########NEW FILE########
__FILENAME__ = test_client_server
import os
import ssl
import unittest
from unittest.mock import patch

import asyncio

from .client import *
from .exceptions import InvalidHandshake
from .http import read_response, USER_AGENT
from .server import *


testcert = os.path.join(os.path.dirname(__file__), 'testcert.pem')


@asyncio.coroutine
def handler(ws, path):
    if path == '/attributes':
        yield from ws.send(repr((ws.host, ws.port, ws.secure)))
    elif path == '/raw_headers':
        yield from ws.send(repr(ws.raw_request_headers))
        yield from ws.send(repr(ws.raw_response_headers))
    else:
        yield from ws.send((yield from ws.recv()))


class ClientServerTests(unittest.TestCase):

    secure = False

    def setUp(self):
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.start_server()

    def tearDown(self):
        self.stop_server()
        self.loop.close()

    def start_server(self):
        server = serve(handler, 'localhost', 8642)
        self.server = self.loop.run_until_complete(server)

    def start_client(self, path=''):
        client = connect('ws://localhost:8642/' + path)
        self.client = self.loop.run_until_complete(client)

    def stop_client(self):
        self.loop.run_until_complete(self.client.worker)

    def stop_server(self):
        self.server.close()
        self.loop.run_until_complete(self.server.wait_closed())

    def test_basic(self):
        self.start_client()
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, "Hello!")
        self.stop_client()

    def test_protocol_attributes(self):
        self.start_client('attributes')
        expected_attrs = ('localhost', 8642, self.secure)
        client_attrs = (self.client.host, self.client.port, self.client.secure)
        self.assertEqual(client_attrs, expected_attrs)
        server_attrs = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(server_attrs, repr(expected_attrs))
        self.stop_client()

    def test_protocol_raw_headers(self):
        self.start_client('raw_headers')
        client_req = self.client.raw_request_headers
        client_resp = self.client.raw_response_headers
        self.assertEqual(dict(client_req)['User-Agent'], USER_AGENT)
        self.assertEqual(dict(client_resp)['Server'], USER_AGENT)
        server_req = self.loop.run_until_complete(self.client.recv())
        server_resp = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(server_req, repr(client_req))
        self.assertEqual(server_resp, repr(client_resp))
        self.stop_client()

    @patch('websockets.server.read_request')
    def test_server_receives_malformed_request(self, _read_request):
        _read_request.side_effect = ValueError("read_request failed")

        with self.assertRaises(InvalidHandshake):
            self.start_client()

    @patch('websockets.client.read_response')
    def test_client_receives_malformed_response(self, _read_response):
        _read_response.side_effect = ValueError("read_response failed")

        with self.assertRaises(InvalidHandshake):
            self.start_client()

        # Now the server believes the connection is open. Run the event loop
        # once to make it notice the connection was closed. Interesting hack.
        self.loop.run_until_complete(asyncio.sleep(0))

    @patch('websockets.client.build_request')
    def test_client_sends_invalid_handshake_request(self, _build_request):
        def wrong_build_request(set_header):
            return '42'
        _build_request.side_effect = wrong_build_request

        with self.assertRaises(InvalidHandshake):
            self.start_client()

    @patch('websockets.server.build_response')
    def test_server_sends_invalid_handshake_response(self, _build_response):
        def wrong_build_response(set_header, key):
            return build_response(set_header, '42')
        _build_response.side_effect = wrong_build_response

        with self.assertRaises(InvalidHandshake):
            self.start_client()

    @patch('websockets.client.read_response')
    def test_server_does_not_switch_protocols(self, _read_response):
        @asyncio.coroutine
        def wrong_read_response(stream):
            code, headers = yield from read_response(stream)
            return 400, headers
        _read_response.side_effect = wrong_read_response

        with self.assertRaises(InvalidHandshake):
            self.start_client()

        # Now the server believes the connection is open. Run the event loop
        # once to make it notice the connection was closed. Interesting hack.
        self.loop.run_until_complete(asyncio.sleep(0))

    @patch('websockets.server.WebSocketServerProtocol.send')
    def test_server_handler_crashes(self, send):
        send.side_effect = ValueError("send failed")

        self.start_client()
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, None)
        self.stop_client()

        # Connection ends with an unexpected error.
        self.assertEqual(self.client.close_code, 1011)

    @patch('websockets.server.WebSocketServerProtocol.close')
    def test_server_close_crashes(self, close):
        close.side_effect = ValueError("close failed")

        self.start_client()
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, "Hello!")
        self.stop_client()

        # Connection ends with an abnormal closure.
        self.assertEqual(self.client.close_code, 1006)


@unittest.skipUnless(os.path.exists(testcert), "test certificate is missing")
class SSLClientServerTests(ClientServerTests):

    secure = True

    @property
    def server_context(self):
        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
        ssl_context.load_cert_chain(testcert)
        return ssl_context

    @property
    def client_context(self):
        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
        ssl_context.load_verify_locations(testcert)
        ssl_context.verify_mode = ssl.CERT_REQUIRED
        return ssl_context

    def start_server(self):
        server = serve(handler, 'localhost', 8642, ssl=self.server_context)
        self.server = self.loop.run_until_complete(server)

    def start_client(self, path=''):
        client = connect('wss://localhost:8642/' + path, ssl=self.client_context)
        self.client = self.loop.run_until_complete(client)

    def test_ws_uri_is_rejected(self):
        client = connect('ws://localhost:8642/', ssl=self.client_context)
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(client)

class ClientServerOriginTests(unittest.TestCase):

    def test_checking_origin_succeeds(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        server = loop.run_until_complete(
            serve(handler, 'localhost', 8642, origins=['http://localhost']))
        client = loop.run_until_complete(
            connect('ws://localhost:8642/', origin='http://localhost'))

        loop.run_until_complete(client.send("Hello!"))
        self.assertEqual(loop.run_until_complete(client.recv()), "Hello!")

        server.close()
        loop.run_until_complete(server.wait_closed())
        loop.run_until_complete(client.worker)
        loop.close()

    def test_checking_origin_fails(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        server = loop.run_until_complete(
            serve(handler, 'localhost', 8642, origins=['http://localhost']))
        with self.assertRaises(InvalidHandshake):
            loop.run_until_complete(
                connect('ws://localhost:8642/', origin='http://otherhost'))

        server.close()
        loop.run_until_complete(server.wait_closed())
        loop.close()

    def test_checking_lack_of_origin_succeeds(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        server = loop.run_until_complete(
            serve(handler, 'localhost', 8642, origins=['']))
        client = loop.run_until_complete(connect('ws://localhost:8642/'))

        loop.run_until_complete(client.send("Hello!"))
        self.assertEqual(loop.run_until_complete(client.recv()), "Hello!")

        server.close()
        loop.run_until_complete(server.wait_closed())
        loop.run_until_complete(client.worker)
        loop.close()

########NEW FILE########
__FILENAME__ = test_framing
import io
import unittest

import asyncio

from .exceptions import WebSocketProtocolError
from .framing import *


class FramingTests(unittest.TestCase):

    def setUp(self):
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

    def tearDown(self):
        self.loop.close()

    def decode(self, message, mask=False):
        self.stream = asyncio.StreamReader()
        self.stream.feed_data(message)
        self.stream.feed_eof()
        reader = self.stream.readexactly
        return self.loop.run_until_complete(read_frame(reader, mask))

    def encode(self, frame, mask=False):
        encoded = io.BytesIO()
        write_frame(frame, encoded.write, mask)
        return encoded.getvalue()

    def round_trip(self, message, expected, mask=False):
        decoded = self.decode(message, mask)
        self.assertEqual(decoded, expected)
        encoded = self.encode(decoded, mask)
        if mask:    # non-deterministic encoding
            decoded = self.decode(encoded, mask)
            self.assertEqual(decoded, expected)
        else:       # deterministic encoding
            self.assertEqual(encoded, message)

    def round_trip_close(self, data, code, reason):
        parsed = parse_close(data)
        self.assertEqual(parsed, (code, reason))
        serialized = serialize_close(code, reason)
        self.assertEqual(serialized, data)

    def test_text(self):
        self.round_trip(b'\x81\x04Spam', Frame(True, OP_TEXT, b'Spam'))

    def test_text_masked(self):
        self.round_trip(
                b'\x81\x84\x5b\xfb\xe1\xa8\x08\x8b\x80\xc5',
                Frame(True, OP_TEXT, b'Spam'), mask=True)

    def test_binary(self):
        self.round_trip(b'\x82\x04Eggs', Frame(True, OP_BINARY, b'Eggs'))

    def test_binary_masked(self):
        self.round_trip(
                b'\x82\x84\x53\xcd\xe2\x89\x16\xaa\x85\xfa',
                Frame(True, OP_BINARY, b'Eggs'), mask=True)

    def test_non_ascii_text(self):
        self.round_trip(
                b'\x81\x05caf\xc3\xa9',
                Frame(True, OP_TEXT, 'caf'.encode('utf-8')))

    def test_non_ascii_text_masked(self):
        self.round_trip(
                b'\x81\x85\x64\xbe\xee\x7e\x07\xdf\x88\xbd\xcd',
                Frame(True, OP_TEXT, 'caf'.encode('utf-8')), mask=True)

    def test_close(self):
        self.round_trip(b'\x88\x00', Frame(True, OP_CLOSE, b''))

    def test_ping(self):
        self.round_trip(b'\x89\x04ping', Frame(True, OP_PING, b'ping'))

    def test_pong(self):
        self.round_trip(b'\x8a\x04pong', Frame(True, OP_PONG, b'pong'))

    def test_long(self):
        self.round_trip(
                b'\x82\x7e\x00\x7e' + 126 * b'a',
                Frame(True, OP_BINARY, 126 * b'a'))

    def test_very_long(self):
        self.round_trip(
                b'\x82\x7f\x00\x00\x00\x00\x00\x01\x00\x00' + 65536 * b'a',
                Frame(True, OP_BINARY, 65536 * b'a'))

    def test_bad_reserved_bits(self):
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\xc0\x00')
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\xa0\x00')
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x90\x00')

    def test_bad_opcode(self):
        for opcode in list(range(0x00, 0x03)) + list(range(0x08, 0x0b)):
            self.decode(bytes([0x80 | opcode, 0]))
        for opcode in list(range(0x03, 0x08)) + list(range(0x0b, 0x10)):
            with self.assertRaises(WebSocketProtocolError):
                self.decode(bytes([0x80 | opcode, 0]))

    def test_bad_mask_flag(self):
        self.decode(b'\x80\x80\x00\x00\x00\x00', mask=True)
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x80\x80\x00\x00\x00\x00')
        self.decode(b'\x80\x00')
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x80\x00', mask=True)

    def test_control_frame_too_long(self):
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x88\x7e\x00\x7e' + 126 * b'a')

    def test_fragmented_control_frame(self):
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x08\x00')

    def test_truncated_message(self):
        with self.assertRaises(WebSocketProtocolError):
            self.decode(b'\x80\x01')

    def test_parse_close(self):
        self.round_trip_close(b'\x03\xe8', 1000, '')
        self.round_trip_close(b'\x03\xe8OK', 1000, 'OK')

    def test_parse_close_empty(self):
        self.assertEqual(parse_close(b''), (1005, ''))

    def test_parse_close_errors(self):
        with self.assertRaises(WebSocketProtocolError):
            parse_close(b'\x03')
        with self.assertRaises(WebSocketProtocolError):
            parse_close(b'\x03\xe7')
        with self.assertRaises(UnicodeDecodeError):
            parse_close(b'\x03\xe8\xff\xff')

########NEW FILE########
__FILENAME__ = test_handshake
import unittest

from .exceptions import InvalidHandshake
from .handshake import *
from .handshake import accept       # private API


class HandshakeTests(unittest.TestCase):

    def test_accept(self):
        # Test vector from RFC 6455
        key = "dGhlIHNhbXBsZSBub25jZQ=="
        acc = "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="
        self.assertEqual(accept(key), acc)

    def test_round_trip(self):
        request_headers = {}
        request_key = build_request(request_headers.__setitem__)
        response_key = check_request(request_headers.__getitem__)
        self.assertEqual(request_key, response_key)
        response_headers = {}
        build_response(response_headers.__setitem__, response_key)
        check_response(response_headers.__getitem__, request_key)

    def test_bad_request(self):
        headers = {}
        build_request(headers.__setitem__)
        del headers['Sec-WebSocket-Key']
        with self.assertRaises(InvalidHandshake):
            check_request(headers.__getitem__)

    def test_bad_response(self):
        headers = {}
        build_response(headers.__setitem__, 'blabla')
        del headers['Sec-WebSocket-Accept']
        with self.assertRaises(InvalidHandshake):
            check_response(headers.__getitem__, 'blabla')

########NEW FILE########
__FILENAME__ = test_http
import unittest

import asyncio

from .http import *
from .http import read_message      # private API


class HTTPTests(unittest.TestCase):

    def setUp(self):
        super().setUp()
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.stream = asyncio.StreamReader()

    def tearDown(self):
        self.loop.close()
        super().tearDown()

    def test_read_request(self):
        # Example from the protocol overview in RFC 6455
        self.stream.feed_data(
            b'GET /chat HTTP/1.1\r\n'
            b'Host: server.example.com\r\n'
            b'Upgrade: websocket\r\n'
            b'Connection: Upgrade\r\n'
            b'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n'
            b'Origin: http://example.com\r\n'
            b'Sec-WebSocket-Protocol: chat, superchat\r\n'
            b'Sec-WebSocket-Version: 13\r\n'
            b'\r\n'
        )
        path, hdrs = self.loop.run_until_complete(read_request(self.stream))
        self.assertEqual(path, '/chat')
        self.assertEqual(hdrs['Upgrade'], 'websocket')

    def test_read_response(self):
        # Example from the protocol overview in RFC 6455
        self.stream.feed_data(
            b'HTTP/1.1 101 Switching Protocols\r\n'
            b'Upgrade: websocket\r\n'
            b'Connection: Upgrade\r\n'
            b'Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\n'
            b'Sec-WebSocket-Protocol: chat\r\n'
            b'\r\n'
        )
        status, hdrs = self.loop.run_until_complete(read_response(self.stream))
        self.assertEqual(status, 101)
        self.assertEqual(hdrs['Upgrade'], 'websocket')

    def test_method(self):
        self.stream.feed_data(b'OPTIONS * HTTP/1.1\r\n\r\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_request(self.stream))

    def test_version(self):
        self.stream.feed_data(b'GET /chat HTTP/1.0\r\n\r\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_request(self.stream))
        self.stream.feed_data(b'HTTP/1.0 400 Bad Request\r\n\r\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_response(self.stream))

    def test_headers_limit(self):
        self.stream.feed_data(b'foo: bar\r\n' * 500 + b'\r\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_message(self.stream))

    def test_line_limit(self):
        self.stream.feed_data(b'a' * 5000 + b'\r\n\r\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_message(self.stream))

    def test_line_ending(self):
        self.stream.feed_data(b'GET / HTTP/1.1\n\n')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(read_message(self.stream))

########NEW FILE########
__FILENAME__ = test_protocol
import unittest
import unittest.mock

import asyncio

from .exceptions import InvalidState
from .framing import *
from .protocol import WebSocketCommonProtocol


MS = 0.001          # Unit for timeouts. May be increased on slow machines.


class CommonTests:

    def setUp(self):
        super().setUp()
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.protocol = WebSocketCommonProtocol()
        self.transport = unittest.mock.Mock()
        self.transport._conn_lost = 0               # checked by drain()
        self.transport.close = unittest.mock.Mock(
                side_effect=lambda: self.protocol.connection_lost(None))
        self.protocol.connection_made(self.transport)

    def tearDown(self):
        self.loop.close()
        super().tearDown()

    def feed(self, frame):
        """Feed a frame to the protocol."""
        mask = not self.protocol.is_client
        write_frame(frame, self.protocol.data_received, mask)

    @asyncio.coroutine
    def sent(self):
        """Read the next frame sent to the transport."""
        stream = asyncio.StreamReader()
        for (data,), kw in self.transport.write.call_args_list:
            stream.feed_data(data)
        self.transport.write.call_args_list = []
        stream.feed_eof()
        if not stream.at_eof():
            return read_frame(stream.readexactly, self.protocol.is_client)

    @asyncio.coroutine
    def echo(self):
        """Echo to the protocol the next frame sent to the transport."""
        self.feed((yield from self.sent()))

    @asyncio.coroutine
    def fast_connection_failure(self):
        """Ensure the connection failure terminates quickly."""
        self.protocol.eof_received()
        self.protocol.connection_lost(None)

    def process_control_frames(self):
        """Process control frames fed to the protocol."""
        self.feed(Frame(True, OP_TEXT, b''))
        self.loop.run_until_complete(self.protocol.recv())

    def assertFrameSent(self, fin, opcode, data):
        sent = self.loop.run_until_complete(self.sent())
        self.assertEqual(sent, Frame(fin, opcode, data))

    def assertNoFrameSent(self):
        sent = self.loop.run_until_complete(self.sent())
        self.assertIsNone(sent)

    def assertConnectionClosed(self, code, message):
        self.assertEqual(self.protocol.state, 'CLOSED')
        self.assertEqual(self.protocol.close_code, code)
        self.assertEqual(self.protocol.close_reason, message)

    def test_open(self):
        self.assertTrue(self.protocol.open)
        self.protocol.connection_lost(None)
        self.assertFalse(self.protocol.open)

    def test_connection_lost(self):
        self.protocol.connection_lost(None)
        self.assertConnectionClosed(1006, '')

    def test_recv_text(self):
        self.feed(Frame(True, OP_TEXT, 'caf'.encode('utf-8')))
        data = self.loop.run_until_complete(self.protocol.recv())
        self.assertEqual(data, 'caf')

    def test_recv_binary(self):
        self.feed(Frame(True, OP_BINARY, b'tea'))
        data = self.loop.run_until_complete(self.protocol.recv())
        self.assertEqual(data, b'tea')

    def test_recv_protocol_error(self):
        self.feed(Frame(True, OP_CONT, 'caf'.encode('utf-8')))
        self.loop.call_later(MS, asyncio.async, self.fast_connection_failure())
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        self.assertConnectionClosed(1002, '')

    def test_recv_unicode_error(self):
        self.feed(Frame(True, OP_TEXT, 'caf'.encode('latin-1')))
        self.loop.call_later(MS, asyncio.async, self.fast_connection_failure())
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        self.assertConnectionClosed(1007, '')

    def test_recv_other_error(self):
        @asyncio.coroutine
        def read_message():
            raise Exception("BOOM")
        self.protocol.read_message = read_message
        self.loop.call_later(MS, asyncio.async, self.fast_connection_failure())
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        with self.assertRaises(Exception):
            self.loop.run_until_complete(self.protocol.worker)
        self.assertConnectionClosed(1011, '')

    def test_recv_on_closed_connection(self):
        self.protocol.eof_received()
        self.protocol.connection_lost(None)
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))

    def test_send_text(self):
        self.loop.run_until_complete(self.protocol.send('caf'))
        self.assertFrameSent(True, OP_TEXT, 'caf'.encode('utf-8'))

    def test_send_binary(self):
        self.loop.run_until_complete(self.protocol.send(b'tea'))
        self.assertFrameSent(True, OP_BINARY, b'tea')

    def test_send_type_error(self):
        with self.assertRaises(TypeError):
            self.loop.run_until_complete(self.protocol.send(42))
        self.assertNoFrameSent()

    def test_send_on_closed_connection(self):
        self.protocol.eof_received()
        self.protocol.connection_lost(None)
        with self.assertRaises(InvalidState):
            self.loop.run_until_complete(self.protocol.send('foobar'))
        self.assertNoFrameSent()

    def test_answer_ping(self):
        self.feed(Frame(True, OP_PING, b'test'))
        self.process_control_frames()
        self.assertFrameSent(True, OP_PONG, b'test')

    def test_ignore_pong(self):
        self.feed(Frame(True, OP_PONG, b'test'))
        self.process_control_frames()
        self.assertNoFrameSent()

    def test_acknowledge_ping(self):
        ping = self.loop.run_until_complete(self.protocol.ping())
        self.assertFalse(ping.done())
        ping_frame = self.loop.run_until_complete(self.sent())
        pong_frame = Frame(True, OP_PONG, ping_frame.data)
        self.feed(pong_frame)
        self.process_control_frames()
        self.assertTrue(ping.done())

    def test_acknowledge_previous_pings(self):
        pings = [(
            self.loop.run_until_complete(self.protocol.ping()),
            self.loop.run_until_complete(self.sent()),
        ) for i in range(3)]
        # Unsolicited pong doesn't acknowledge pings
        self.feed(Frame(True, OP_PONG, b''))
        self.process_control_frames()
        self.assertFalse(pings[0][0].done())
        self.assertFalse(pings[1][0].done())
        self.assertFalse(pings[2][0].done())
        # Pong acknowledges all previous pings
        self.feed(Frame(True, OP_PONG, pings[1][1].data))
        self.process_control_frames()
        self.assertTrue(pings[0][0].done())
        self.assertTrue(pings[1][0].done())
        self.assertFalse(pings[2][0].done())

    def test_cancel_ping(self):
        ping = self.loop.run_until_complete(self.protocol.ping())
        ping_frame = self.loop.run_until_complete(self.sent())
        ping.cancel()
        pong_frame = Frame(True, OP_PONG, ping_frame.data)
        self.feed(pong_frame)
        self.process_control_frames()
        self.assertTrue(ping.cancelled())

    def test_duplicate_ping(self):
        self.loop.run_until_complete(self.protocol.ping(b'foobar'))
        self.assertFrameSent(True, OP_PING, b'foobar')
        with self.assertRaises(ValueError):
            self.loop.run_until_complete(self.protocol.ping(b'foobar'))
        self.assertNoFrameSent()

    def test_fragmented_text(self):
        self.feed(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
        self.feed(Frame(True, OP_CONT, 'f'.encode('utf-8')))
        data = self.loop.run_until_complete(self.protocol.recv())
        self.assertEqual(data, 'caf')

    def test_fragmented_binary(self):
        self.feed(Frame(False, OP_BINARY, b't'))
        self.feed(Frame(False, OP_CONT, b'e'))
        self.feed(Frame(True, OP_CONT, b'a'))
        data = self.loop.run_until_complete(self.protocol.recv())
        self.assertEqual(data, b'tea')

    def test_control_frame_within_fragmented_text(self):
        self.feed(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
        self.feed(Frame(True, OP_PING, b''))
        self.feed(Frame(True, OP_CONT, 'f'.encode('utf-8')))
        data = self.loop.run_until_complete(self.protocol.recv())
        self.assertEqual(data, 'caf')
        self.assertFrameSent(True, OP_PONG, b'')

    def test_unterminated_fragmented_text(self):
        self.feed(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
        # Missing the second part of the fragmented frame.
        self.feed(Frame(True, OP_BINARY, b'tea'))
        self.loop.call_later(MS, asyncio.async, self.fast_connection_failure())
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        self.assertConnectionClosed(1002, '')

    def test_close_handshake_in_fragmented_text(self):
        self.feed(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
        self.feed(Frame(True, OP_CLOSE, b''))
        self.loop.call_later(MS, asyncio.async, self.fast_connection_failure())
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        self.assertConnectionClosed(1002, '')

    def test_connection_close_in_fragmented_text(self):
        self.feed(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
        self.loop.call_later(MS, self.protocol.eof_received)
        self.loop.call_later(2 * MS, lambda: self.protocol.connection_lost(None))
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        self.assertConnectionClosed(1002, '')


class ServerTests(CommonTests, unittest.TestCase):

    def test_close(self):               # standard server-initiated close
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1000, 'because.')
        # Only one frame is emitted, and it's consumed by self.echo().
        self.assertNoFrameSent()
        # Closing the connection again is a no-op.
        self.loop.run_until_complete(self.protocol.close(reason='oh noes!'))
        self.assertConnectionClosed(1000, 'because.')
        self.assertNoFrameSent()

    def test_client_close(self):        # non standard client-initiated close
        frame = Frame(True, OP_CLOSE, serialize_close(1000, 'because.'))
        self.loop.call_later(MS, self.feed, frame)
        # The server is waiting for some data at this point, and won't get it.
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        # After recv() returns None, the connection is closed.
        self.assertConnectionClosed(1000, 'because.')
        self.assertFrameSent(*frame)
        # Closing the connection again is a no-op.
        self.loop.run_until_complete(self.protocol.close(reason='oh noes!'))
        self.assertConnectionClosed(1000, 'because.')
        self.assertNoFrameSent()

    def test_simultaneous_close(self):  # non standard close from both sides
        client_close = Frame(True, OP_CLOSE, serialize_close(1000, 'client'))
        server_close = Frame(True, OP_CLOSE, serialize_close(1000, 'server'))
        self.loop.call_later(MS, self.feed, client_close)
        self.loop.run_until_complete(self.protocol.close(reason='server'))
        self.assertConnectionClosed(1000, 'client')
        self.assertFrameSent(*server_close)
        self.assertNoFrameSent()

    def test_close_drops_frames(self):
        self.loop.call_later(MS, self.feed, Frame(True, OP_TEXT, b''))
        self.loop.call_later(2 * MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1000, 'because.')
        # Only one frame is emitted, and it's consumed by self.echo().
        self.assertNoFrameSent()

    def test_close_handshake_timeout(self):
        self.after = asyncio.Future()
        self.loop.call_later(2 * MS, self.after.cancel)
        self.before = asyncio.Future()
        self.loop.call_later(10 * MS, self.before.cancel)
        self.protocol.timeout = 5 * MS
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1000, 'because.')
        self.assertTrue(self.after.cancelled())
        self.assertFalse(self.before.cancelled())
        self.before.cancel()

    def test_close_timeout_before_connection_lost(self):
        # Prevent the connection from terminating.
        self.protocol.connection_lost = unittest.mock.Mock()

        self.after = asyncio.Future()
        self.loop.call_later(4 * MS, self.after.cancel)
        self.before = asyncio.Future()
        self.loop.call_later(8 * MS, self.before.cancel)
        self.protocol.timeout = 5 * MS
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertEqual(self.protocol.state, 'CLOSING')
        self.assertTrue(self.after.cancelled())
        self.assertFalse(self.before.cancelled())
        self.before.cancel()

    def test_close_protocol_error(self):
        self.loop.call_later(MS, self.feed, Frame(True, OP_CLOSE, b'\x00'))
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1002, '')

    def test_close_connection_lost(self):
        self.loop.call_later(MS, self.protocol.eof_received)
        self.loop.call_later(2 * MS, lambda: self.protocol.connection_lost(None))
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1002, '')

    def test_close_during_recv(self):
        recv = asyncio.async(self.protocol.recv())
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertIsNone(self.loop.run_until_complete(recv))

    def test_close_after_cancelled_recv(self):
        recv = asyncio.async(self.protocol.recv())
        self.loop.call_later(MS, recv.cancel)
        with self.assertRaises(asyncio.CancelledError):
            self.loop.run_until_complete(recv)
        # Closing the connection shouldn't crash.
        # I can't find a way to test this on the client side.
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))


class ClientTests(CommonTests, unittest.TestCase):

    def setUp(self):
        super().setUp()
        self.protocol.is_client = True

    def test_close(self):               # standard server-initiated close
        frame = Frame(True, OP_CLOSE, serialize_close(1000, 'because.'))
        self.loop.call_later(MS, self.feed, frame)
        self.loop.call_later(2 * MS, self.protocol.eof_received)
        self.loop.call_later(3 * MS, lambda: self.protocol.connection_lost(None))
        # The client is waiting for some data at this point, and won't get it.
        self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))
        # After recv() returns None, the connection is closed.
        self.assertConnectionClosed(1000, 'because.')
        self.assertFrameSent(*frame)
        # Closing the connection again is a no-op.
        self.loop.run_until_complete(self.protocol.close('oh noes!'))
        self.assertConnectionClosed(1000, 'because.')
        self.assertNoFrameSent()

    def test_client_close(self):        # non standard client-initiated close
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.call_later(2 * MS, self.protocol.eof_received)
        self.loop.call_later(3 * MS, lambda: self.protocol.connection_lost(None))
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        self.assertConnectionClosed(1000, 'because.')
        # Only one frame is emitted, and it's consumed by self.echo().
        self.assertNoFrameSent()
        # Closing the connection again is a no-op.
        self.loop.run_until_complete(self.protocol.close(reason='oh noes!'))
        self.assertConnectionClosed(1000, 'because.')
        self.assertNoFrameSent()

    def test_simultaneous_close(self):  # non standard close from both sides
        server_close = Frame(True, OP_CLOSE, serialize_close(1000, 'server'))
        client_close = Frame(True, OP_CLOSE, serialize_close(1000, 'client'))
        self.loop.call_later(MS, self.feed, server_close)
        self.loop.call_later(2 * MS, self.protocol.eof_received)
        self.loop.call_later(3 * MS, lambda: self.protocol.connection_lost(None))
        self.loop.run_until_complete(self.protocol.close(reason='client'))
        self.assertConnectionClosed(1000, 'server')
        self.assertFrameSent(*client_close)
        self.assertNoFrameSent()

    def test_close_timeout_before_eof_received(self):
        self.after = asyncio.Future()
        self.loop.call_later(4 * MS, self.after.cancel)
        self.before = asyncio.Future()
        self.loop.call_later(8 * MS, self.before.cancel)
        self.protocol.timeout = 5 * MS
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        # If the server doesn't drop the connection quickly, the client will.
        self.assertConnectionClosed(1000, 'because.')
        self.assertTrue(self.after.cancelled())
        self.assertFalse(self.before.cancelled())
        self.before.cancel()

    def test_close_timeout_before_connection_lost(self):
        # Prevent the connection from terminating.
        self.protocol.connection_lost = unittest.mock.Mock()

        self.after = asyncio.Future()
        self.loop.call_later(9 * MS, self.after.cancel)
        self.before = asyncio.Future()
        self.loop.call_later(13 * MS, self.before.cancel)
        self.protocol.timeout = 5 * MS
        self.loop.call_later(MS, asyncio.async, self.echo())
        self.loop.call_later(2 * MS, self.protocol.eof_received)
        self.loop.run_until_complete(self.protocol.close(reason='because.'))
        # If the server doesn't drop the connection quickly, the client will.
        self.assertEqual(self.protocol.state, 'CLOSING')
        self.assertTrue(self.after.cancelled())
        self.assertFalse(self.before.cancelled())
        self.before.cancel()

########NEW FILE########
__FILENAME__ = test_uri
import unittest

from .exceptions import InvalidURI
from .uri import *


VALID_URIS = (
    ('ws://localhost/', (False, 'localhost', 80, '/')),
    ('wss://localhost/', (True, 'localhost', 443, '/')),
    ('ws://localhost/path?query', (False, 'localhost', 80, '/path?query')),
)

INVALID_URIS = (
    'http://localhost/',
    'https://localhost/',
    'http://localhost/path#fragment'
)


class URITests(unittest.TestCase):

    def test_success(self):
        for uri, parsed in VALID_URIS:
            self.assertEqual(parse_uri(uri), parsed)

    def test_error(self):
        for uri in INVALID_URIS:
            with self.assertRaises(InvalidURI):
                parse_uri(uri)

########NEW FILE########
__FILENAME__ = uri
"""
The :mod:`websockets.uri` module implements parsing of WebSocket URIs
according to `section 3 of RFC 6455`_.

.. _section 3 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-3
"""

__all__ = ['parse_uri']

import collections
import urllib.parse

from .exceptions import InvalidURI


WebSocketURI = collections.namedtuple('WebSocketURI',
        ('secure', 'host', 'port', 'resource_name'))


def parse_uri(uri):
    """
    This function parses and validates a WebSocket URI.

    If the URI is valid, it returns a namedtuple `(secure, host, port,
    resource_name)`

    Otherwise, it raises an :exc:`InvalidURI` exception.
    """
    uri = urllib.parse.urlparse(uri)
    try:
        assert uri.scheme in ('ws', 'wss')
        assert uri.params == ''
        assert uri.fragment == ''
        assert uri.username is None
        assert uri.password is None
        assert uri.hostname is not None
    except AssertionError as exc:
        raise InvalidURI() from exc

    secure = uri.scheme == 'wss'
    host = uri.hostname
    port = uri.port or (443 if secure else 80)
    resource_name = uri.path or '/'
    if uri.query:
        resource_name += '?' + uri.query
    return WebSocketURI(secure, host, port, resource_name)

########NEW FILE########
__FILENAME__ = version
version = '2.1'

########NEW FILE########
