__FILENAME__ = filter_xml_output
#!/usr/bin/python
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Example to filter XML output.
Call with XML output filename as first argument.
Prints filtered result on standard output.
"""
import sys
from xml.etree.ElementTree import parse


def main (args):
    filename = args[0]
    with open(filename) as fd:
        tree = parse(fd)
        filter_tree(tree)
        tree.write(sys.stdout, encoding='utf-8')


def filter_tree(tree):
    """Filter all 401 errors."""
    to_remove = []
    for elem in tree.findall('urldata'):
        valid = elem.find('valid')
        if valid is not None and valid.text == '0' and \
           valid.attrib.get('result', '').startswith('401'):
            to_remove.append(elem)
    root = tree.getroot()
    for elem in to_remove:
        root.remove(elem)


if __name__ == '__main__':
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = __hooks__
# -*- coding: iso-8859-1 -*-
# Hook routines for the wok static site generator.
# Note that mediacompress is a local module.
import os


def compress_javascript(config, output_path):
    """Minify JS files."""
    try:
        from mediacompress import compress_js_files
    except ImportError:
        pass
    else:
        compress_js_files(output_path, excludes=("*.min.js",))


def compress_css(config, output_path):
    """Minify CSS files."""
    try:
        from mediacompress import compress_css_files
    except ImportError:
        pass
    else:
        compress_css_files(output_path)


def chmod(config):
    """Set correct file permissions."""
    output_dir = config["output_dir"]
    for dirpath, dirnames, filenames in os.walk(output_dir):
        for dirname in dirnames:
            os.chmod(os.path.join(dirpath, dirname), 0755)
        for filename in filenames:
            os.chmod(os.path.join(dirpath, filename), 0644)


hooks = {
    'site.output.post': [compress_javascript, compress_css],
    'site.done': [chmod],
}

########NEW FILE########
__FILENAME__ = ansicolor
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
ANSI Color definitions and functions. For Windows systems, the colorama module
uses ctypes and Windows DLLs to generate colored output.

From Term::ANSIColor, applies also to this module:

The codes output by this module are standard terminal control codes,
complying with ECMA-48 and ISO 6429 (generally referred to as ``ANSI color''
for the color codes). The non-color control codes (bold, dark, italic,
underline, and reverse) are part of the earlier ANSI X3.64 standard for
control sequences for video terminals and peripherals.

Note that not all displays are ISO 6429-compliant, or even X3.64-compliant
(or are even attempting to be so).

Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out::

              clear    bold     dark    under    blink   reverse  conceal
 ------------------------------------------------------------------------
 xterm         yes      yes      no      yes     bold      yes      yes
 linux         yes      yes      yes    bold      yes      yes      no
 rxvt          yes      yes      no      yes  bold/black   yes      no
 dtterm        yes      yes      yes     yes    reverse    yes      yes
 teraterm      yes    reverse    no      yes    rev/red    yes      no
 aixterm      kinda   normal     no      yes      no       yes      yes
 PuTTY         yes     color     no      yes      no       yes      no
 Windows       yes      no       no      no       no       yes      no
 Cygwin SSH    yes      yes      no     color    color    color     yes

SEE ALSO

ECMA-048 is available on-line (at least at the time of this writing) at
http://www.ecma-international.org/publications/standards/ECMA-048.HTM.

ISO 6429 is available from ISO for a charge; the author of this module does
not own a copy of it. Since the source material for ISO 6429 was ECMA-048
and the latter is available for free, there seems little reason to obtain
the ISO standard.
"""

import os
import logging
import types
from .fileutil import has_module, is_tty
if os.name == 'nt':
    from . import colorama

has_curses = has_module("curses")

# Color constants

# Escape for ANSI colors
AnsiEsc = "\x1b[%sm"

# Control constants
bold = 'bold'
light = 'light'
underline = 'underline'
blink = 'blink'
invert = 'invert'
concealed = 'concealed'

# Control numbers
AnsiControl = {
    None:      '',
    bold:      '1',
    light:     '2',
    #italic:   '3', # unsupported
    underline: '4',
    blink:     '5',
    #rapidblink: '6', # unsupported
    invert:    '7',
    concealed: '8',
    #strikethrough: '9', # unsupported
}

# Color constants
default = 'default'
black = 'black'
red = 'red'
green = 'green'
yellow = 'yellow'
blue = 'blue'
purple = 'purple'
cyan = 'cyan'
white = 'white'

# inverse colors
Black = 'Black'
Red = 'Red'
Green = 'Green'
Yellow = 'Yellow'
Blue = 'Blue'
Purple = 'Purple'
Cyan = 'Cyna'
White = 'White'

InverseColors = (Black, Red, Green, Yellow, Blue, Purple, Cyan, White)

# Ansi color numbers; capitalized colors are inverse
AnsiColor = {
    None:    '0',
    default: '0',
    black:   '30',
    red:     '31',
    green:   '32',
    yellow:  '33',
    blue:    '34',
    purple:  '35',
    cyan:    '36',
    white:   '37',
    Black:   '40',
    Red:     '41',
    Green:   '42',
    Yellow:  '43',
    Blue:    '44',
    Purple:  '45',
    Cyan:    '46',
    White:   '47',
}

if os.name == 'nt':
    # Windows color numbers; capitalized colors are used as background
    WinColor = {
        None:    None,
        default: colorama.GREY,
        black:   colorama.BLACK,
        red:     colorama.RED,
        green:   colorama.GREEN,
        yellow:  colorama.YELLOW,
        blue:    colorama.BLUE,
        purple:  colorama.MAGENTA,
        cyan:    colorama.CYAN,
        white:   colorama.GREY,
        Black:   colorama.BLACK,
        Red:     colorama.RED,
        Green:   colorama.GREEN,
        Yellow:  colorama.YELLOW,
        Blue:    colorama.BLUE,
        Purple:  colorama.MAGENTA,
        Cyan:    colorama.CYAN,
        White:   colorama.GREY,
    }

# pc speaker beep escape code
Beep = "\007"


def esc_ansicolor (color):
    """convert a named color definition to an escaped ANSI color"""
    control = ''
    if ";" in color:
        control, color = color.split(";", 1)
        control = AnsiControl.get(control, '')+";"
    cnum = AnsiColor.get(color, '0')
    return AnsiEsc % (control+cnum)

AnsiReset = esc_ansicolor(default)


def get_win_color(color):
    """Convert a named color definition to Windows console color foreground,
    background and style numbers."""
    foreground = background = style = None
    control = ''
    if ";" in color:
        control, color = color.split(";", 1)
        if control == bold:
            style = colorama.BRIGHT
    if color in InverseColors:
        background = WinColor[color]
    else:
        foreground = WinColor.get(color)
    return foreground, background, style


def has_colors (fp):
    """Test if given file is an ANSI color enabled tty."""
    # The is_tty() function ensures that we do not colorize
    # redirected streams, as this is almost never what we want
    if not is_tty(fp):
        return False
    if os.name == 'nt':
        return True
    elif has_curses:
        import curses
        try:
            curses.setupterm(os.environ.get("TERM"), fp.fileno())
            # More than 8 colors are good enough.
            return curses.tigetnum("colors") >= 8
        except curses.error:
            return False
    return False


def get_columns (fp):
    """Return number of columns for given file."""
    if not is_tty(fp):
        return 80
    if os.name == 'nt':
        return colorama.get_console_size().X
    if has_curses:
        import curses
        try:
            curses.setupterm(os.environ.get("TERM"), fp.fileno())
            return curses.tigetnum("cols")
        except curses.error:
           pass
    return 80


def _write_color_colorama (fp, text, color):
    """Colorize text with given color."""
    foreground, background, style = get_win_color(color)
    colorama.set_console(foreground=foreground, background=background,
      style=style)
    fp.write(text)
    colorama.reset_console()


def _write_color_ansi (fp, text, color):
    """Colorize text with given color."""
    fp.write(esc_ansicolor(color))
    fp.write(text)
    fp.write(AnsiReset)


if os.name == 'nt':
    write_color = _write_color_colorama
    colorama.init()
else:
    write_color = _write_color_ansi


class Colorizer (object):
    """Prints colored messages to streams."""

    def __init__ (self, fp):
        """Initialize with given stream (file-like object)."""
        super(Colorizer, self).__init__()
        self.fp = fp
        if has_colors(fp):
            self.write = self._write_color
        else:
            self.write = self._write

    def _write (self, text, color=None):
        """Print text as-is."""
        self.fp.write(text)

    def _write_color (self, text, color=None):
        """Print text with given color. If color is None, print text as-is."""
        if color is None:
            self.fp.write(text)
        else:
            write_color(self.fp, text, color)

    def __getattr__ (self, name):
        """Delegate attribute access to the stored stream object."""
        return getattr(self.fp, name)


class ColoredStreamHandler (logging.StreamHandler, object):
    """Send colored log messages to streams (file-like objects)."""

    def __init__ (self, strm=None):
        """Log to given stream (a file-like object) or to stderr if
        strm is None.
        """
        super(ColoredStreamHandler, self).__init__(strm)
        self.stream = Colorizer(self.stream)
        # standard log level colors (used by get_color)
        self.colors = {
            logging.WARN: 'bold;yellow',
            logging.ERROR: 'light;red',
            logging.CRITICAL: 'bold;red',
            logging.DEBUG: 'white',
        }

    def get_color (self, record):
        """Get appropriate color according to log level.
        """
        return self.colors.get(record.levelno, 'default')

    def emit (self, record):
        """Emit a record.

        If a formatter is specified, it is used to format the record.
        The record is then written to the stream with a trailing newline
        [N.B. this may be removed depending on feedback].
        """
        color = self.get_color(record)
        msg = self.format(record)
        if not hasattr(types, "UnicodeType"):
            # no unicode support
            self.stream.write("%s" % msg, color=color)
        else:
            try:
                self.stream.write("%s" % msg, color=color)
            except UnicodeError:
                self.stream.write("%s" % msg.encode("UTF-8"),
                                  color=color)
        self.stream.write(os.linesep)
        self.flush()

########NEW FILE########
__FILENAME__ = better_exchook2
# -*- coding: iso-8859-1 -*-
#
# Copyright (c) 2012, Albert Zeyer, www.az2000.de
# All rights reserved.
# file created 2011-04-15


# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


# This is a simple replacement for the standard Python exception handler (sys.excepthook).
# In addition to what the standard handler does, it also prints all referenced variables
# (no matter if local, global or builtin) of the code line of each stack frame.
# See below for some examples and some example output.

# https://github.com/albertz/py_better_exchook

from __future__ import print_function
import sys
import os

def parse_py_statement(line):
	state = 0
	curtoken = ""
	spaces = " \t\n"
	ops = ".,;:+-*/%&=|(){}[]^<>"
	i = 0
	def _escape_char(c):
		if c == "n": return "\n"
		elif c == "t": return "\t"
		else: return c
	while i < len(line):
		c = line[i]
		i += 1
		if state == 0:
			if c in spaces: pass
			elif c in ops: yield ("op", c)
			elif c == "#": state = 6
			elif c == "\"": state = 1
			elif c == "'": state = 2
			else:
				curtoken = c
				state = 3
		elif state == 1: # string via "
			if c == "\\": state = 4
			elif c == "\"":
				yield ("str", curtoken)
				curtoken = ""
				state = 0
			else: curtoken += c
		elif state == 2: # string via '
			if c == "\\": state = 5
			elif c == "'":
				yield ("str", curtoken)
				curtoken = ""
				state = 0
			else: curtoken += c
		elif state == 3: # identifier
			if c in spaces + ops + "#\"'":
				yield ("id", curtoken)
				curtoken = ""
				state = 0
				i -= 1
			else: curtoken += c
		elif state == 4: # escape in "
			curtoken += _escape_char(c)
			state = 1
		elif state == 5: # escape in '
			curtoken += _escape_char(c)
			state = 2
		elif state == 6: # comment
			curtoken += c
	if state == 3: yield ("id", curtoken)
	elif state == 6: yield ("comment", curtoken)


import keyword
pykeywords = set(keyword.kwlist)

def grep_full_py_identifiers(tokens):
	global pykeywords
	tokens = list(tokens)
	i = 0
	while i < len(tokens):
		tokentype, token = tokens[i]
		i += 1
		if tokentype != "id": continue
		while i+1 < len(tokens) and tokens[i] == ("op", ".") and tokens[i+1][0] == "id":
			token += "." + tokens[i+1][1]
			i += 2
		if token == "": continue
		if token in pykeywords: continue
		if token[0] in ".0123456789": continue
		yield token

def set_linecache(filename, source):
	import linecache
	linecache.cache[filename] = None, None, [line+'\n' for line in source.splitlines()], filename

def output(s, out=sys.stdout): print(s, file=out)

def output_limit():
	return 300

def pp_extra_info(obj, depthlimit = 3):
	s = []
	if hasattr(obj, "__len__"):
		try:
			if type(obj) in (str,unicode,list,tuple,dict) and len(obj) <= 5:
				pass # don't print len in this case
			else:
				s += ["len = " + str(obj.__len__())]
		except: pass
	if depthlimit > 0 and hasattr(obj, "__getitem__"):
		try:
			if type(obj) in (str,unicode):
				pass # doesn't make sense to get subitems here
			else:
				subobj = obj.__getitem__(0)
				extra_info = pp_extra_info(subobj, depthlimit - 1)
				if extra_info != "":
					s += ["_[0]: {" + extra_info + "}"]
		except: pass
	return ", ".join(s)
	
def pretty_print(obj):
	s = repr(obj)
	limit = output_limit()
	if len(s) > limit:
		s = s[:limit - 3] + "..."
	extra_info = pp_extra_info(obj)
	if extra_info != "": s += ", " + extra_info
	return s

def fallback_findfile(filename):
	mods = [ m for m in sys.modules.values() if m and hasattr(m, "__file__") and filename in m.__file__ ]
	if len(mods) == 0: return None
	altfn = mods[0].__file__
	if altfn[-4:-1] == ".py": altfn = altfn[:-1] # *.pyc or whatever
	return altfn

def better_exchook(etype, value, tb, out=sys.stdout):
	output('Traceback (most recent call last):', out=out)
	allLocals,allGlobals = {},{}
	try:
		import linecache
		limit = None
		if hasattr(sys, 'tracebacklimit'):
			limit = sys.tracebacklimit
		n = 0
		_tb = tb
		def _resolveIdentifier(namespace, id):
			obj = namespace[id[0]]
			for part in id[1:]:
				obj = getattr(obj, part)
			return obj
		def _trySet(old, prefix, func):
			if old is not None: return old
			try: return prefix + func()
			except KeyError: return old
			except Exception as e:
				return prefix + "!" + e.__class__.__name__ + ": " + str(e)
		while _tb is not None and (limit is None or n < limit):
			f = _tb.tb_frame
			allLocals.update(f.f_locals)
			allGlobals.update(f.f_globals)
			lineno = _tb.tb_lineno
			co = f.f_code
			filename = co.co_filename
			name = co.co_name
			output('  File "%s", line %d, in %s' % (filename,lineno,name), out=out)
			if not os.path.isfile(filename):
				altfn = fallback_findfile(filename)
				if altfn:
					output("    -- couldn't find file, trying this instead: " + altfn, out=out)
					filename = altfn
			linecache.checkcache(filename)
			line = linecache.getline(filename, lineno, f.f_globals)
			if line:
				line = line.strip()
				output('    line: ' + line, out=out)
				output('    locals:', out=out)
				alreadyPrintedLocals = set()
				for tokenstr in grep_full_py_identifiers(parse_py_statement(line)):
					splittedtoken = tuple(tokenstr.split("."))
					for token in map(lambda i: splittedtoken[0:i], range(1, len(splittedtoken) + 1)):
						if token in alreadyPrintedLocals: continue
						tokenvalue = None
						tokenvalue = _trySet(tokenvalue, "<local> ", lambda: pretty_print(_resolveIdentifier(f.f_locals, token)))
						tokenvalue = _trySet(tokenvalue, "<global> ", lambda: pretty_print(_resolveIdentifier(f.f_globals, token)))
						tokenvalue = _trySet(tokenvalue, "<builtin> ", lambda: pretty_print(_resolveIdentifier(f.f_builtins, token)))
						tokenvalue = tokenvalue or "<not found>"
						output('      ' + ".".join(token) + " = " + tokenvalue, out=out)
						alreadyPrintedLocals.add(token)
				if len(alreadyPrintedLocals) == 0: output("       no locals", out=out)
			else:
				output('    -- code not available --', out=out)
			_tb = _tb.tb_next
			n += 1

	except Exception:
		output("ERROR: cannot get more detailed exception info because:", out=out)
		import traceback
		for l in traceback.format_exc().split("\n"): output("   " + l, out=out)
		output("simple traceback:", out=out)
		traceback.print_tb(tb, None, out)

	import types
	def _some_str(value):
		try: return str(value)
		except: return '<unprintable %s object>' % type(value).__name__
	def _format_final_exc_line(etype, value):
		valuestr = _some_str(value)
		if value is None or not valuestr:
			line = "%s" % etype
		else:
			line = "%s: %s" % (etype, valuestr)
		return line
	if (isinstance(etype, BaseException) or
		(hasattr(types, "InstanceType") and isinstance(etype, types.InstanceType)) or
		etype is None or type(etype) is str):
		output(_format_final_exc_line(etype, value), out=out)
	else:
		output(_format_final_exc_line(etype.__name__, value), out=out)

def install():
	sys.excepthook = better_exchook

########NEW FILE########
__FILENAME__ = chrome
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import sys

# Windows filename encoding
nt_filename_encoding="mbcs"


def get_profile_dir ():
    """Return path where all profiles of current user are stored."""
    if os.name == 'nt':
        if "LOCALAPPDATA" in os.environ:
            basedir = unicode(os.environ["LOCALAPPDATA"], nt_filename_encoding)
        else:
            # read local appdata directory from registry
            from ..winutil import get_shell_folder
            try:
                basedir = get_shell_folder("Local AppData")
            except EnvironmentError:
                basedir = os.path.join(os.environ["USERPROFILE"], "Local Settings", "Application Data")
        dirpath = os.path.join(basedir, u"Google", u"Chrome", u"User Data")
    elif os.name == 'posix':
        basedir = unicode(os.environ["HOME"])
        if sys.platform == 'darwin':
            dirpath = os.path.join(basedir, u"Library", u"Application Support")
        else:
            dirpath = os.path.join(basedir, u".config")
        dirpath = os.path.join(dirpath, u"Google", u"Chrome")
    return dirpath


def find_bookmark_file (profile="Default"):
    """Return the bookmark file of the Default profile.
    Returns absolute filename if found, or empty string if no bookmark file
    could be found.
    """
    try:
        dirname = os.path.join(get_profile_dir(), profile)
        if os.path.isdir(dirname):
            fname = os.path.join(dirname, "Bookmarks")
            if os.path.isfile(fname):
                return fname
    except Exception:
        pass
    return u""


from .chromium import parse_bookmark_data, parse_bookmark_file

########NEW FILE########
__FILENAME__ = chromium
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import sys
import json


# Windows filename encoding
nt_filename_encoding="mbcs"


def get_profile_dir ():
    """Return path where all profiles of current user are stored."""
    if os.name == 'nt':
        if "LOCALAPPDATA" in os.environ:
            basedir = unicode(os.environ["LOCALAPPDATA"], nt_filename_encoding)
        else:
            # read local appdata directory from registry
            from ..winutil import get_shell_folder
            try:
                basedir = get_shell_folder("Local AppData")
            except EnvironmentError:
                basedir = os.path.join(os.environ["USERPROFILE"], "Local Settings", "Application Data")
        dirpath = os.path.join(basedir, u"Chromium", u"User Data")
    elif os.name == 'posix':
        basedir = unicode(os.environ["HOME"])
        if sys.platform == 'darwin':
            dirpath = os.path.join(basedir, u"Library", u"Application Support")
        else:
            dirpath = os.path.join(basedir, u".config")
        dirpath = os.path.join(dirpath, u"chromium")
    return dirpath


def find_bookmark_file (profile="Default"):
    """Return the bookmark file of the Default profile.
    Returns absolute filename if found, or empty string if no bookmark file
    could be found.
    """
    try:
        dirname = os.path.join(get_profile_dir(), profile)
        if os.path.isdir(dirname):
            fname = os.path.join(dirname, "Bookmarks")
            if os.path.isfile(fname):
                return fname
    except Exception:
        pass
    return u""


def parse_bookmark_data (data):
    """Parse data string.
    Return iterator for bookmarks of the form (url, name).
    Bookmarks are not sorted.
    """
    for url, name in parse_bookmark_json(json.loads(data)):
        yield url, name


def parse_bookmark_file (file):
    """Parse file object.
    Return iterator for bookmarks of the form (url, name).
    Bookmarks are not sorted.
    """
    for url, name in parse_bookmark_json(json.load(file)):
        yield url, name


def parse_bookmark_json (data):
    """Parse complete JSON data for Chromium Bookmarks."""
    for entry in data["roots"].values():
        for url, name in parse_bookmark_node(entry):
            yield url, name


def parse_bookmark_node (node):
    """Parse one JSON node of Chromium Bookmarks."""
    if node["type"] == "url":
        yield node["url"], node["name"]
    elif node["type"] == "folder":
        for child in node["children"]:
            for entry in parse_bookmark_node(child):
                yield entry

########NEW FILE########
__FILENAME__ = firefox
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Parser for FireFox bookmark file."""
import os
import glob
import re
try:
    import sqlite3
    has_sqlite = True
except ImportError:
    has_sqlite = False


extension = re.compile(r'/(?i)places.sqlite$')


# Windows filename encoding
nt_filename_encoding="mbcs"

def get_profile_dir ():
    """Return path where all profiles of current user are stored."""
    if os.name == 'nt':
        basedir = unicode(os.environ["APPDATA"], nt_filename_encoding)
        dirpath = os.path.join(basedir, u"Mozilla", u"Firefox", u"Profiles")
    elif os.name == 'posix':
        basedir = unicode(os.environ["HOME"])
        dirpath = os.path.join(basedir, u".mozilla", u"firefox")
    return dirpath


def find_bookmark_file (profile="*.default"):
    """Return the first found places.sqlite file of the profile directories
    ending with '.default' (or another given profile name).
    Returns absolute filename if found, or empty string if no bookmark file
    could be found.
    """
    try:
        for dirname in glob.glob(u"%s/%s" % (get_profile_dir(), profile)):
            if os.path.isdir(dirname):
                fname = os.path.join(dirname, "places.sqlite")
                if os.path.isfile(fname):
                    return fname
    except Exception:
        pass
    return u""


def parse_bookmark_file (filename):
    """Return iterator for bookmarks of the form (url, name).
    Bookmarks are not sorted.
    Returns None if sqlite3 module is not installed.
    """
    if not has_sqlite:
        return
    conn = sqlite3.connect(filename, timeout=0.5)
    try:
        c = conn.cursor()
        try:
            sql = """SELECT mp.url, mb.title
            FROM moz_places mp, moz_bookmarks mb
            WHERE mp.hidden=0 AND mp.url NOT LIKE 'place:%' AND
            mp.id=mb.fk"""
            c.execute(sql)
            for url, name in c:
                if not name:
                    name = url
                yield (url, name)
        finally:
            c.close()
    finally:
        conn.close()

########NEW FILE########
__FILENAME__ = opera
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import os

# Windows filename encoding
nt_filename_encoding="mbcs"

# List of possible Opera bookmark files.
OperaBookmarkFiles = (
  "bookmarks.adr", # for Opera >= 10.0
  "opera6.adr",
)


def get_profile_dir ():
    """Return path where all profiles of current user are stored."""
    if os.name == 'nt':
        basedir = unicode(os.environ["APPDATA"], nt_filename_encoding)
        dirpath = os.path.join(basedir, u"Opera", u"Opera")
    elif os.name == 'posix':
        basedir = unicode(os.environ["HOME"])
        dirpath = os.path.join(basedir, u".opera")
    return dirpath


def find_bookmark_file ():
    """Return the bookmark file of the Opera profile.
    Returns absolute filename if found, or empty string if no bookmark file
    could be found.
    """
    try:
        dirname = get_profile_dir()
        if os.path.isdir(dirname):
            for name in OperaBookmarkFiles:
                fname = os.path.join(dirname, name)
                if os.path.isfile(fname):
                    return fname
    except Exception:
        pass
    return u""


def parse_bookmark_data (data):
    """Return iterator for bookmarks of the form (url, name, line number).
    Bookmarks are not sorted.
    """
    name = None
    lineno = 0
    for line in data.splitlines():
        lineno += 1
        line = line.strip()
        if line.startswith("NAME="):
            name = line[5:]
        elif line.startswith("URL="):
            url = line[4:]
            if url and name is not None:
                yield (url, name, lineno)
        else:
            name = None

########NEW FILE########
__FILENAME__ = safari
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import sys
import plistlib
try:
    import biplist
    has_biplist = True
except ImportError:
    has_biplist = False


def get_profile_dir ():
    """Return path where all profiles of current user are stored."""
    basedir = unicode(os.environ["HOME"])
    return os.path.join(basedir, u"Library", u"Safari")


def find_bookmark_file ():
    """Return the bookmark file of the Default profile.
    Returns absolute filename if found, or empty string if no bookmark file
    could be found.
    """
    if sys.platform != 'darwin':
        return u""
    try:
        dirname = get_profile_dir()
        if os.path.isdir(dirname):
            fname = os.path.join(dirname, u"Bookmarks.plist")
            if os.path.isfile(fname):
                return fname
    except Exception:
        pass
    return u""


def parse_bookmark_file (filename):
    """Return iterator for bookmarks of the form (url, name).
    Bookmarks are not sorted.
    """
    return parse_plist(get_plist_data_from_file(filename))


def parse_bookmark_data (data):
    """Return iterator for bookmarks of the form (url, name).
    Bookmarks are not sorted.
    """
    return parse_plist(get_plist_data_from_string(data))


def get_plist_data_from_file (filename):
    """Parse plist data for a file. Tries biplist, falling back to
    plistlib."""
    if has_biplist:
        return biplist.readPlist(filename)
    # fall back to normal plistlist
    try:
        return plistlib.readPlist(filename)
    except Exception:
        # not parseable (eg. not well-formed, or binary)
        return {}


def get_plist_data_from_string (data):
    """Parse plist data for a string. Tries biplist, falling back to
    plistlib."""
    if has_biplist:
        return biplist.readPlistFromString(data)
    # fall back to normal plistlist
    try:
        return plistlib.readPlistFromString(data)
    except Exception:
        # not parseable (eg. not well-formed, or binary)
        return {}


# some key strings
KEY_URLSTRING = 'URLString'
KEY_URIDICTIONARY = 'URIDictionary'
KEY_CHILDREN = 'Children'
KEY_WEBBOOKMARKTYPE = 'WebBookmarkType'

def parse_plist(entry):
    """Parse a XML dictionary entry."""
    if is_leaf(entry):
        url = entry[KEY_URLSTRING]
        title = entry[KEY_URIDICTIONARY].get('title', url)
        yield (url, title)
    elif has_children(entry):
        for child in entry[KEY_CHILDREN]:
            for item in parse_plist(child):
                yield item


def is_leaf (entry):
    """Return true if plist entry is an URL entry."""
    return entry.get(KEY_WEBBOOKMARKTYPE) == 'WebBookmarkTypeLeaf'


def has_children (entry):
    """Return true if plist entry has children."""
    return entry.get(KEY_WEBBOOKMARKTYPE) == 'WebBookmarkTypeList'

########NEW FILE########
__FILENAME__ = results
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Cache check results.
"""
from ..decorators import synchronized
from ..lock import get_lock


# lock object
cache_lock = get_lock("results_cache_lock")


class ResultCache(object):
    """
    Thread-safe cache of UrlData.to_wire() results.
    the cache is limited in size since we rather recheck the same URL
    multiple times instead of running out of memory.
    format: {cache key (string) -> result (UrlData.towire())}
    """

    def __init__(self, max_size=100000):
        """Initialize result cache."""
        # mapping {URL -> cached result}
        self.cache = {}
        self.max_size = max_size

    @synchronized(cache_lock)
    def get_result(self, key):
        """Return cached result or None if not found."""
        return self.cache.get(key)

    @synchronized(cache_lock)
    def add_result(self, key, result):
        """Add result object to cache with given key.
        The request is ignored when the cache is already full or the key
        is None.
        """
        if len(self.cache) > self.max_size:
            return
        if key is not None:
            self.cache[key] = result

    def has_result(self, key):
        """Non-thread-safe function for fast containment checks."""
        return key in self.cache

    def __len__(self):
        """Get number of cached elements. This is not thread-safe and is
        likely to change before the returned value is used."""
        return len(self.cache)

########NEW FILE########
__FILENAME__ = robots_txt
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Cache robots.txt contents.
"""
from .. import robotparser2, configuration
from ..containers import LFUCache
from ..decorators import synchronized
from ..lock import get_lock


# lock objects
cache_lock = get_lock("robots.txt_cache_lock")
robot_lock = get_lock("robots.txt_robot_lock")


class RobotsTxt (object):
    """
    Thread-safe cache of downloaded robots.txt files.
    format: {cache key (string) -> robots.txt content (RobotFileParser)}
    """
    useragent = str(configuration.UserAgent)

    def __init__ (self):
        """Initialize per-URL robots.txt cache."""
        # mapping {URL -> parsed robots.txt}
        self.cache = LFUCache(size=100)
        self.hits = self.misses = 0
        self.roboturl_locks = {}

    def allows_url (self, url_data):
        """Ask robots.txt allowance."""
        roboturl = url_data.get_robots_txt_url()
        with self.get_lock(roboturl):
            return self._allows_url(url_data, roboturl)

    def _allows_url (self, url_data, roboturl):
        """Ask robots.txt allowance. Assumes only single thread per robots.txt
        URL calls this function."""
        user, password = url_data.get_user_password()
        with cache_lock:
            if roboturl in self.cache:
                self.hits += 1
                rp = self.cache[roboturl]
                return rp.can_fetch(self.useragent, url_data.url)
            self.misses += 1
        rp = robotparser2.RobotFileParser(proxy=url_data.proxy, user=user,
            password=password)
        rp.set_url(roboturl)
        rp.read()
        with cache_lock:
            self.cache[roboturl] = rp
        self.add_sitemap_urls(rp, url_data, roboturl)
        return rp.can_fetch(self.useragent, url_data.url)

    def add_sitemap_urls(self, rp, url_data, roboturl):
        """Add sitemap URLs to queue."""
        if not rp.sitemap_urls or not url_data.allows_simple_recursion():
            return
        for sitemap_url, line in rp.sitemap_urls:
            url_data.add_url(sitemap_url, line=line)

    @synchronized(robot_lock)
    def get_lock(self, roboturl):
        """Return lock for robots.txt url."""
        return self.roboturl_locks.setdefault(roboturl, get_lock(roboturl))

########NEW FILE########
__FILENAME__ = urlqueue
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle a queue of URLs to check.
"""
import threading
import collections
from time import time as _time
from .. import log, LOG_CACHE


class Timeout (StandardError):
    """Raised by join()"""
    pass

class Empty (StandardError):
    """Exception raised by get()."""
    pass


NUM_PUTS_CLEANUP = 10000

class UrlQueue (object):
    """A queue supporting several consumer tasks. The task_done() idea is
    from the Python 2.5 implementation of Queue.Queue()."""

    def __init__ (self, max_allowed_urls=None):
        """Initialize the queue state and task counters."""
        # Note: don't put a maximum size on the queue since it would
        # lead to deadlocks when all worker threads called put().
        self.queue = collections.deque()
        # mutex must be held whenever the queue is mutating.  All methods
        # that acquire mutex must release it before returning.  mutex
        # is shared between the two conditions, so acquiring and
        # releasing the conditions also acquires and releases mutex.
        self.mutex = threading.Lock()
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
        self.not_empty = threading.Condition(self.mutex)
        self.all_tasks_done = threading.Condition(self.mutex)
        self.unfinished_tasks = 0
        self.finished_tasks = 0
        self.in_progress = 0
        self.shutdown = False
        # Each put() decreases the number of allowed puts.
        # This way we can restrict the number of URLs that are checked.
        if max_allowed_urls is not None and max_allowed_urls <= 0:
            raise ValueError("Non-positive number of allowed URLs: %d" % max_allowed_urls)
        self.max_allowed_urls = max_allowed_urls
        self.num_puts = 0

    def qsize (self):
        """Return the approximate size of the queue (not reliable!)."""
        with self.mutex:
            return len(self.queue)

    def empty (self):
        """Return True if the queue is empty, False otherwise.
        Result is thread-safe, but not reliable since the queue could have
        been changed before the result is returned!"""
        with self.mutex:
            return self._empty()

    def _empty (self):
        """Return True if the queue is empty, False otherwise.
        Not thread-safe!"""
        return not self.queue

    def get (self, timeout=None):
        """Get first not-in-progress url from the queue and
        return it. If no such url is available return None.
        """
        with self.not_empty:
            return self._get(timeout)

    def _get (self, timeout):
        """Non thread-safe utility function of self.get() doing the real
        work."""
        if timeout is None:
            while self._empty():
                self.not_empty.wait()
        else:
            if timeout < 0:
                raise ValueError("'timeout' must be a positive number")
            endtime = _time() + timeout
            while self._empty():
                remaining = endtime - _time()
                if remaining <= 0.0:
                    raise Empty()
                self.not_empty.wait(remaining)
        self.in_progress += 1
        return self.queue.popleft()

    def put (self, item):
        """Put an item into the queue.
        Block if necessary until a free slot is available.
        """
        with self.mutex:
            self._put(item)
            self.not_empty.notify()

    def _put (self, url_data):
        """Put URL in queue, increase number of unfished tasks."""
        if self.shutdown or self.max_allowed_urls == 0:
            return
        log.debug(LOG_CACHE, "queueing %s", url_data.url)
        key = url_data.cache_url
        cache = url_data.aggregate.result_cache
        if url_data.has_result or cache.has_result(key):
            self.queue.appendleft(url_data)
        else:
            assert key is not None, "no result for None key: %s" % url_data
            if self.max_allowed_urls is not None:
                self.max_allowed_urls -= 1
            self.num_puts += 1
            if self.num_puts >= NUM_PUTS_CLEANUP:
                self.cleanup()
            self.queue.append(url_data)
        self.unfinished_tasks += 1

    def cleanup(self):
        """Move cached elements to top."""
        self.num_puts = 0
        cached = []
        for i, url_data in enumerate(self.queue):
            key = url_data.cache_url
            cache = url_data.aggregate.result_cache
            if cache.has_result(key):
                cached.append(i)
        for pos in cached:
            self._move_to_top(pos)

    def _move_to_top(self, pos):
        """Move element at given position to top of queue."""
        if pos > 0:
            self.queue.rotate(-pos)
            item = self.queue.popleft()
            self.queue.rotate(pos)
            self.queue.appendleft(item)

    def task_done (self, url_data):
        """
        Indicate that a formerly enqueued task is complete.

        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        """
        with self.all_tasks_done:
            log.debug(LOG_CACHE, "task_done %s", url_data.url)
            self.finished_tasks += 1
            self.unfinished_tasks -= 1
            self.in_progress -= 1
            if self.unfinished_tasks <= 0:
                if self.unfinished_tasks < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notifyAll()

    def join (self, timeout=None):
        """Blocks until all items in the Queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.

        When the count of unfinished tasks drops to zero, join() unblocks.
        """
        with self.all_tasks_done:
            if timeout is None:
                while self.unfinished_tasks:
                    self.all_tasks_done.wait()
            else:
                if timeout < 0:
                    raise ValueError("'timeout' must be a positive number")
                endtime = _time() + timeout
                while self.unfinished_tasks:
                    remaining = endtime - _time()
                    if remaining <= 0.0:
                        raise Timeout()
                    self.all_tasks_done.wait(remaining)

    def do_shutdown (self):
        """Shutdown the queue by not accepting any more URLs."""
        with self.mutex:
            unfinished = self.unfinished_tasks - len(self.queue)
            self.queue.clear()
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('shutdown is in error')
                self.all_tasks_done.notifyAll()
            self.unfinished_tasks = unfinished
            self.shutdown = True

    def status (self):
        """Get tuple (finished tasks, in progress, queue size)."""
        # no need to acquire self.mutex since the numbers are unreliable anyways.
        return (self.finished_tasks, self.in_progress, len(self.queue))

########NEW FILE########
__FILENAME__ = const
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Helper constants.
"""
import socket
import select
import nntplib
import ftplib
import requests
from .. import LinkCheckerError
from dns.exception import DNSException

# Catch these exception on syntax checks.
ExcSyntaxList = [
    LinkCheckerError,
]

# Catch these exceptions on content and connect checks. All other
# exceptions are internal or system errors
ExcCacheList = [
    IOError,
    OSError, # OSError is thrown on Windows when a file is not found
    LinkCheckerError,
    DNSException,
    socket.error,
    select.error,
    # nttp errors (including EOFError)
    nntplib.error_reply,
    nntplib.error_temp,
    nntplib.error_perm,
    nntplib.error_proto,
    EOFError,
    # http errors
    requests.exceptions.RequestException,
    # ftp errors
    ftplib.error_reply,
    ftplib.error_temp,
    ftplib.error_perm,
    ftplib.error_proto,
    # idna.encode(), called from socket.create_connection()
    UnicodeError,
]

# Exceptions that do not put the URL in the cache so that the URL can
# be checked again.
ExcNoCacheList = [
    socket.timeout,
]

# firefox bookmark file needs sqlite3 for parsing
try:
    import sqlite3
    ExcCacheList.append(sqlite3.Error)
except ImportError:
    pass

# pyOpenSSL errors
try:
    import OpenSSL
    ExcCacheList.append(OpenSSL.SSL.Error)
except ImportError:
    pass


ExcList = ExcCacheList + ExcNoCacheList

# Maximum URL length
# https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
URL_MAX_LENGTH = 2047

# the warnings
WARN_URL_EFFECTIVE_URL = "url-effective-url"
WARN_URL_ERROR_GETTING_CONTENT = "url-error-getting-content"
WARN_URL_CONTENT_SIZE_TOO_LARGE = "url-content-too-large"
WARN_URL_CONTENT_SIZE_ZERO = "url-content-size-zero"
WARN_URL_OBFUSCATED_IP = "url-obfuscated-ip"
WARN_URL_TOO_LONG = "url-too-long"
WARN_URL_WHITESPACE = "url-whitespace"
WARN_FILE_MISSING_SLASH = "file-missing-slash"
WARN_FILE_SYSTEM_PATH = "file-system-path"
WARN_FTP_MISSING_SLASH = "ftp-missing-slash"
WARN_HTTP_EMPTY_CONTENT = "http-empty-content"
WARN_HTTP_COOKIE_STORE_ERROR = "http-cookie-store-error"
WARN_IGNORE_URL = "ignore-url"
WARN_MAIL_NO_MX_HOST = "mail-no-mx-host"
WARN_NNTP_NO_SERVER = "nntp-no-server"
WARN_NNTP_NO_NEWSGROUP = "nntp-no-newsgroup"

# registered warnings
Warnings = {
    WARN_URL_EFFECTIVE_URL:
        _("The effective URL is different from the original."),
    WARN_URL_ERROR_GETTING_CONTENT:
        _("Could not get the content of the URL."),
    WARN_URL_CONTENT_SIZE_TOO_LARGE: _("The URL content size is too large."),
    WARN_URL_CONTENT_SIZE_ZERO: _("The URL content size is zero."),
    WARN_URL_TOO_LONG: _("The URL is longer than the recommended size."),
    WARN_URL_WHITESPACE: _("The URL contains leading or trailing whitespace."),
    WARN_FILE_MISSING_SLASH: _("The file: URL is missing a trailing slash."),
    WARN_FILE_SYSTEM_PATH:
        _("The file: path is not the same as the system specific path."),
    WARN_FTP_MISSING_SLASH: _("The ftp: URL is missing a trailing slash."),
    WARN_HTTP_EMPTY_CONTENT: _("The URL had no content."),
    WARN_HTTP_COOKIE_STORE_ERROR:
        _("An error occurred while storing a cookie."),
    WARN_IGNORE_URL: _("The URL has been ignored."),
    WARN_MAIL_NO_MX_HOST: _("The mail MX host could not be found."),
    WARN_NNTP_NO_SERVER: _("No NNTP server was found."),
    WARN_NNTP_NO_NEWSGROUP: _("The NNTP newsgroup could not be found."),
    WARN_URL_OBFUSCATED_IP: _("The IP is obfuscated."),
}

########NEW FILE########
__FILENAME__ = dnsurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle for dns: links.
"""

import socket

from . import urlbase


class DnsUrl (urlbase.UrlBase):
    """
    Url link with dns scheme.
    """

    def can_get_content (self):
        """
        dns: URLs do not have any content

        @return: False
        @rtype: bool
        """
        return False

    def check_connection(self):
        """Resolve hostname."""
        host = self.urlparts[1]
        addresses = socket.getaddrinfo(host, 80, 0, 0, socket.SOL_TCP)
        args = {'host': host}
        if addresses:
            args['ips'] = [x[4][0] for x in addresses]
            self.set_result(_('%(host)s resolved to IPs %(ips)s') % args, valid=True)
        else:
            self.set_result(_('%(host)r could not be resolved') % args, valid=False)

########NEW FILE########
__FILENAME__ = fileurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle local file: links.
"""

import re
import os
import urlparse
import urllib
import urllib2
from datetime import datetime

from . import urlbase, get_index_html
from .. import log, LOG_CHECK, fileutil, mimeutil, LinkCheckerError, url as urlutil
from ..bookmarks import firefox
from .const import WARN_FILE_MISSING_SLASH, WARN_FILE_SYSTEM_PATH


def get_files (dirname):
    """Get iterator of entries in directory. Only allows regular files
    and directories, no symlinks."""
    for entry in os.listdir(dirname):
        fullentry = os.path.join(dirname, entry)
        if os.path.islink(fullentry):
            continue
        if os.path.isfile(fullentry):
            yield entry
        elif os.path.isdir(fullentry):
            yield entry+"/"


def prepare_urlpath_for_nt (path):
    """
    URLs like 'file://server/path/' result in a path named '/server/path'.
    However urllib.url2pathname expects '////server/path'.
    """
    if '|' not in path:
        return "////"+path.lstrip("/")
    return path


def get_nt_filename (path):
    """Return case sensitive filename for NT path."""
    unc, rest = os.path.splitunc(path)
    head, tail = os.path.split(rest)
    if not tail:
        return path
    for fname in os.listdir(unc+head):
        if fname.lower() == tail.lower():
            return os.path.join(get_nt_filename(unc+head), fname)
    log.error(LOG_CHECK, "could not find %r in %r", tail, head)
    return path


def get_os_filename (path):
    """Return filesystem path for given URL path."""
    if os.name == 'nt':
        path = prepare_urlpath_for_nt(path)
    res = urllib.url2pathname(fileutil.pathencode(path))
    if os.name == 'nt' and res.endswith(':') and len(res) == 2:
        # Work around http://bugs.python.org/issue11474
        res += os.sep
    return res


def is_absolute_path (path):
    """Check if given path is absolute. On Windows absolute paths start
    with a drive letter. On all other systems absolute paths start with
    a slash."""
    if os.name == 'nt':
        if re.search(r"^[a-zA-Z]:", path):
            return True
        path = path.replace("\\", "/")
    return path.startswith("/")


class FileUrl (urlbase.UrlBase):
    """
    Url link with file scheme.
    """

    def init (self, base_ref, base_url, parent_url, recursion_level,
              aggregate, line, column, page, name, url_encoding, extern):
        """Initialize the scheme."""
        super(FileUrl, self).init(base_ref, base_url, parent_url,
         recursion_level, aggregate, line, column, page, name, url_encoding, extern)
        self.scheme = u'file'

    def build_base_url(self):
        """The URL is normed according to the platform:
         - the base URL is made an absolute file:// URL
         - under Windows platform the drive specifier is normed
        """
        if self.base_url is None:
            return
        base_url = self.base_url
        if not (self.parent_url or self.base_ref or base_url.startswith("file:")):
            base_url = os.path.expanduser(base_url)
            if not is_absolute_path(base_url):
                try:
                    base_url = os.getcwd()+"/"+base_url
                except OSError as msg:
                    # occurs on stale remote filesystems (eg. NFS)
                    errmsg = _("Could not get current working directory: %(msg)s") % dict(msg=msg)
                    raise LinkCheckerError(errmsg)
                if os.path.isdir(base_url):
                    base_url += "/"
            base_url = "file://"+base_url
        if os.name == "nt":
            base_url = base_url.replace("\\", "/")
            # transform c:/windows into /c|/windows
            base_url = re.sub("^file://(/?)([a-zA-Z]):", r"file:///\2|", base_url)
            # transform file://path into file:///path
            base_url = re.sub("^file://([^/])", r"file:///\1", base_url)
        self.base_url = unicode(base_url)

    def build_url (self):
        """
        Calls super.build_url() and adds a trailing slash to directories.
        """
        self.build_base_url()
        if self.parent_url is not None:
            # URL joining with the parent URL only works if the query
            # of the base URL are removed first.
            # Otherwise the join function thinks the query is part of
            # the file name.
            from .urlbase import url_norm
            # norm base url - can raise UnicodeError from url.idna_encode()
            base_url, is_idn = url_norm(self.base_url, self.encoding)
            urlparts = list(urlparse.urlsplit(base_url))
            # ignore query part for filesystem urls
            urlparts[3] = ''
            self.base_url = urlutil.urlunsplit(urlparts)
        super(FileUrl, self).build_url()
        # ignore query and fragment url parts for filesystem urls
        self.urlparts[3] = self.urlparts[4] = ''
        if self.is_directory() and not self.urlparts[2].endswith('/'):
            self.add_warning(_("Added trailing slash to directory."),
                           tag=WARN_FILE_MISSING_SLASH)
            self.urlparts[2] += '/'
        self.url = urlutil.urlunsplit(self.urlparts)

    def add_size_info (self):
        """Get size of file content and modification time from filename path."""
        if self.is_directory():
            # Directory size always differs from the customer index.html
            # that is generated. So return without calculating any size.
            return
        filename = self.get_os_filename()
        self.size = fileutil.get_size(filename)
        self.modified = datetime.utcfromtimestamp(fileutil.get_mtime(filename))

    def check_connection (self):
        """
        Try to open the local file. Under NT systems the case sensitivity
        is checked.
        """
        if (self.parent_url is not None and
           not self.parent_url.startswith(u"file:")):
            msg = _("local files are only checked without parent URL or when the parent URL is also a file")
            raise LinkCheckerError(msg)
        if self.is_directory():
            self.set_result(_("directory"))
        else:
            url = fileutil.pathencode(self.url)
            self.url_connection = urllib2.urlopen(url)
            self.check_case_sensitivity()

    def check_case_sensitivity (self):
        """
        Check if url and windows path name match cases
        else there might be problems when copying such
        files on web servers that are case sensitive.
        """
        if os.name != 'nt':
            return
        path = self.get_os_filename()
        realpath = get_nt_filename(path)
        if path != realpath:
            self.add_warning(_("The URL path %(path)r is not the same as the "
                            "system path %(realpath)r. You should always use "
                            "the system path in URLs.") % \
                            {"path": path, "realpath": realpath},
                               tag=WARN_FILE_SYSTEM_PATH)

    def read_content (self):
        """Return file content, or in case of directories a dummy HTML file
        with links to the files."""
        if self.is_directory():
            data = get_index_html(get_files(self.get_os_filename()))
            if isinstance(data, unicode):
                data = data.encode("iso8859-1", "ignore")
        else:
            data = super(FileUrl, self).read_content()
        return data

    def get_os_filename (self):
        """
        Construct os specific file path out of the file:// URL.

        @return: file name
        @rtype: string
        """
        return get_os_filename(self.urlparts[2])

    def get_temp_filename (self):
        """Get filename for content to parse."""
        return self.get_os_filename()

    def is_directory (self):
        """
        Check if file is a directory.

        @return: True iff file is a directory
        @rtype: bool
        """
        filename = self.get_os_filename()
        return os.path.isdir(filename) and not os.path.islink(filename)

    def is_parseable (self):
        """Check if content is parseable for recursion.

        @return: True if content is parseable
        @rtype: bool
        """
        if self.is_directory():
            return True
        if firefox.has_sqlite and firefox.extension.search(self.url):
            return True
        if self.content_type in self.ContentMimetypes:
            return True
        log.debug(LOG_CHECK, "File with content type %r is not parseable.", self.content_type)
        return False

    def set_content_type (self):
        """Return URL content type, or an empty string if content
        type could not be found."""
        if self.url:
            self.content_type = mimeutil.guess_mimetype(self.url, read=self.get_content)
        else:
            self.content_type = u""

    def get_intern_pattern (self, url=None):
        """Get pattern for intern URL matching.

        @return non-empty regex pattern or None
        @rtype String or None
        """
        if url is None:
            url = self.url
        if not url:
            return None
        if url.startswith('file://'):
            i = url.rindex('/')
            if i > 6:
                # remove last filename to make directory internal
                url = url[:i+1]
        return re.escape(url)

    def add_url (self, url, line=0, column=0, page=0, name=u"", base=None):
        """If a local webroot directory is configured, replace absolute URLs
        with it. After that queue the URL data for checking."""
        webroot = self.aggregate.config["localwebroot"]
        if webroot and url and url.startswith(u"/"):
            url = webroot + url[1:]
            log.debug(LOG_CHECK, "Applied local webroot `%s' to `%s'.", webroot, url)
        super(FileUrl, self).add_url(url, line=line, column=column, page=page, name=name, base=base)

########NEW FILE########
__FILENAME__ = ftpurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle FTP links.
"""

import ftplib
from cStringIO import StringIO

from .. import log, LOG_CHECK, LinkCheckerError, mimeutil
from . import proxysupport, httpurl, internpaturl, get_index_html
from .const import WARN_FTP_MISSING_SLASH


class FtpUrl (internpaturl.InternPatternUrl, proxysupport.ProxySupport):
    """
    Url link with ftp scheme.
    """

    def reset (self):
        """
        Initialize FTP url data.
        """
        super(FtpUrl, self).reset()
        # list of files for recursion
        self.files = []
        # last part of URL filename
        self.filename = None
        self.filename_encoding = 'iso-8859-1'

    def check_connection (self):
        """
        In case of proxy, delegate to HttpUrl. Else check in this
        order: login, changing directory, list the file.
        """
        # proxy support (we support only http)
        self.set_proxy(self.aggregate.config["proxy"].get(self.scheme))
        if self.proxy:
            # using a (HTTP) proxy
            http = httpurl.HttpUrl(self.base_url,
                  self.recursion_level,
                  self.aggregate,
                  parent_url=self.parent_url,
                  base_ref=self.base_ref,
                  line=self.line,
                  column=self.column,
                  name=self.name)
            http.build_url()
            return http.check()
        self.login()
        self.negotiate_encoding()
        self.filename = self.cwd()
        self.listfile()
        self.files = []
        return None

    def login (self):
        """Log into ftp server and check the welcome message."""
        self.url_connection = ftplib.FTP(timeout=self.aggregate.config["timeout"])
        if log.is_debug(LOG_CHECK):
            self.url_connection.set_debuglevel(1)
        try:
            self.url_connection.connect(self.host, self.port)
            _user, _password = self.get_user_password()
            if _user is None:
                self.url_connection.login()
            elif _password is None:
                self.url_connection.login(_user)
            else:
                self.url_connection.login(_user, _password)
            info = self.url_connection.getwelcome()
            if info:
                # note that the info may change every time a user logs in,
                # so don't add it to the url_data info.
                log.debug(LOG_CHECK, "FTP info %s", info)
                pass
            else:
                raise LinkCheckerError(_("Got no answer from FTP server"))
        except EOFError as msg:
            raise LinkCheckerError(
                      _("Remote host has closed connection: %(msg)s") % str(msg))

    def negotiate_encoding (self):
        """Check if server can handle UTF-8 encoded filenames.
        See also RFC 2640."""
        try:
            features = self.url_connection.sendcmd("FEAT")
        except ftplib.error_perm as msg:
            log.debug(LOG_CHECK, "Ignoring error when getting FTP features: %s" % msg)
            pass
        else:
            log.debug(LOG_CHECK, "FTP features %s", features)
            if " UTF-8" in features.splitlines():
                self.filename_encoding = "utf-8"

    def cwd (self):
        """
        Change to URL parent directory. Return filename of last path
        component.
        """
        path = self.urlparts[2].encode(self.filename_encoding, 'replace')
        dirname = path.strip('/')
        dirs = dirname.split('/')
        filename = dirs.pop()
        self.url_connection.cwd('/')
        for d in dirs:
            self.url_connection.cwd(d)
        return filename

    def listfile (self):
        """
        See if filename is in the current FTP directory.
        """
        if not self.filename:
            return
        files = self.get_files()
        log.debug(LOG_CHECK, "FTP files %s", str(files))
        if self.filename in files:
            # file found
            return
        # it could be a directory if the trailing slash was forgotten
        if "%s/" % self.filename in files:
            if not self.url.endswith('/'):
                self.add_warning(
                         _("Missing trailing directory slash in ftp url."),
                         tag=WARN_FTP_MISSING_SLASH)
                self.url += '/'
            return
        raise ftplib.error_perm("550 File not found")

    def get_files (self):
        """Get list of filenames in directory. Subdirectories have an
        ending slash."""
        files = []
        def add_entry (line):
            """Parse list line and add the entry it points to to the file
            list."""
            log.debug(LOG_CHECK, "Directory entry %r", line)
            from ..ftpparse import ftpparse
            fpo = ftpparse(line)
            if fpo is not None and fpo["name"]:
                name = fpo["name"]
                if fpo["trycwd"]:
                    name += "/"
                if fpo["trycwd"] or fpo["tryretr"]:
                    files.append(name)
        self.url_connection.dir(add_entry)
        return files

    def is_parseable (self):
        """See if URL target is parseable for recursion."""
        if self.is_directory():
            return True
        if self.content_type in self.ContentMimetypes:
            return True
        log.debug(LOG_CHECK, "URL with content type %r is not parseable.", self.content_type)
        return False

    def is_directory (self):
        """See if URL target is a directory."""
        # either the path is empty, or ends with a slash
        path = self.urlparts[2]
        return (not path) or path.endswith('/')

    def set_content_type (self):
        """Set URL content type, or an empty string if content
        type could not be found."""
        self.content_type = mimeutil.guess_mimetype(self.url, read=self.get_content)

    def read_content (self):
        """Return URL target content, or in case of directories a dummy HTML
        file with links to the files."""
        if self.is_directory():
            self.url_connection.cwd(self.filename)
            self.files = self.get_files()
            # XXX limit number of files?
            data = get_index_html(self.files)
        else:
            # download file in BINARY mode
            ftpcmd = "RETR %s" % self.filename
            buf = StringIO()
            def stor_data (s):
                """Helper method storing given data"""
                # limit the download size
                if (buf.tell() + len(s)) > self.max_size:
                    raise LinkCheckerError(_("FTP file size too large"))
                buf.write(s)
            self.url_connection.retrbinary(ftpcmd, stor_data)
            data = buf.getvalue()
            buf.close()
        return data

    def close_connection (self):
        """Release the open connection from the connection pool."""
        if self.url_connection is not None:
            try:
                self.url_connection.quit()
            except Exception:
                pass
            self.url_connection = None

########NEW FILE########
__FILENAME__ = httpurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle http links.
"""

import requests
from cStringIO import StringIO

from .. import (log, LOG_CHECK, strformat, mimeutil,
    url as urlutil, LinkCheckerError, httputil)
from . import (internpaturl, proxysupport)
from ..HtmlParser import htmlsax
from ..htmlutil import linkparse
# import warnings
from .const import WARN_HTTP_EMPTY_CONTENT
from requests.sessions import REDIRECT_STATI

# assumed HTTP header encoding
HEADER_ENCODING = "iso-8859-1"
HTTP_SCHEMAS = ('http://', 'https://')

# helper alias
unicode_safe = strformat.unicode_safe

class HttpUrl (internpaturl.InternPatternUrl, proxysupport.ProxySupport):
    """
    Url link with http scheme.
    """

    def reset (self):
        """
        Initialize HTTP specific variables.
        """
        super(HttpUrl, self).reset()
        # initialize check data
        self.headers = {}
        self.auth = None
        self.ssl_cipher = None
        self.ssl_cert = None

    def allows_robots (self, url):
        """
        Fetch and parse the robots.txt of given url. Checks if LinkChecker
        can get the requested resource content.

        @param url: the url to be requested
        @type url: string
        @return: True if access is granted, otherwise False
        @rtype: bool
        """
        return self.aggregate.robots_txt.allows_url(self)

    def content_allows_robots (self):
        """
        Return False if the content of this URL forbids robots to
        search for recursive links.
        """
        if not self.is_html():
            return True
        # construct parser object
        handler = linkparse.MetaRobotsFinder()
        parser = htmlsax.parser(handler)
        handler.parser = parser
        if self.charset:
            parser.encoding = self.charset
        # parse
        try:
            parser.feed(self.get_content())
            parser.flush()
        except linkparse.StopParse as msg:
            log.debug(LOG_CHECK, "Stopped parsing: %s", msg)
            pass
        # break cyclic dependencies
        handler.parser = None
        parser.handler = None
        return handler.follow

    def add_size_info (self):
        """Get size of URL content from HTTP header."""
        if self.headers and "Content-Length" in self.headers and \
           "Transfer-Encoding" not in self.headers:
            # Note that content-encoding causes size differences since
            # the content data is always decoded.
            try:
                self.size = int(self.getheader("Content-Length"))
            except (ValueError, OverflowError):
                pass
        else:
            self.size = -1

    def check_connection (self):
        """
        Check a URL with HTTP protocol.
        Here is an excerpt from RFC 1945 with common response codes:
        The first digit of the Status-Code defines the class of response. The
        last two digits do not have any categorization role. There are 5
        values for the first digit:
          - 1xx: Informational - Not used, but reserved for future use
          - 2xx: Success - The action was successfully received,
            understood, and accepted.
          - 3xx: Redirection - Further action must be taken in order to
            complete the request
          - 4xx: Client Error - The request contains bad syntax or cannot
            be fulfilled
          - 5xx: Server Error - The server failed to fulfill an apparently
            valid request
        """
        self.session = self.aggregate.get_request_session()
        # set the proxy, so a 407 status after this is an error
        self.set_proxy(self.aggregate.config["proxy"].get(self.scheme))
        self.construct_auth()
        # check robots.txt
        if not self.allows_robots(self.url):
            self.add_info(_("Access denied by robots.txt, checked only syntax."))
            self.set_result(_("syntax OK"))
            self.do_check_content = False
            return
        # check the http connection
        request = self.build_request()
        self.send_request(request)
        self._add_response_info()
        self.follow_redirections(request)
        self.check_response()
        if self.allows_simple_recursion():
            self.parse_header_links()

    def build_request(self):
        """Build a prepared request object."""
        clientheaders = {
            "User-Agent": self.aggregate.config["useragent"],
            "DNT": "1",
        }
        if (self.parent_url and
            self.parent_url.lower().startswith(HTTP_SCHEMAS)):
            clientheaders["Referer"] = self.parent_url
        kwargs = dict(
            method='GET',
            url=self.url,
            headers=clientheaders,
        )
        if self.auth:
            kwargs['auth'] = self.auth
        log.debug(LOG_CHECK, "Prepare request with %s", kwargs)
        request = requests.Request(**kwargs)
        return self.session.prepare_request(request)

    def send_request(self, request):
        """Send request and store response in self.url_connection."""
        # throttle the number of requests to each host
        self.aggregate.wait_for_host(self.urlparts[1])
        kwargs = self.get_request_kwargs()
        kwargs["allow_redirects"] = False
        self._send_request(request, **kwargs)

    def _send_request(self, request, **kwargs):
        """Send GET request."""
        log.debug(LOG_CHECK, "Send request with %s", kwargs)
        self.url_connection = self.session.send(request, **kwargs)
        self.headers = self.url_connection.headers
        self._add_ssl_info()

    def _add_response_info(self):
        """Set info from established HTTP(S) connection."""
        self.charset = httputil.get_charset(self.headers)
        self.set_content_type()
        self.add_size_info()

    def _get_ssl_sock(self):
        """Get raw SSL socket."""
        assert self.scheme == u"https", self
        raw_connection = self.url_connection.raw._connection
        if raw_connection.sock is None:
            # sometimes the socket is not yet connected
            # see https://github.com/kennethreitz/requests/issues/1966
            raw_connection.connect()
        return raw_connection.sock

    def _add_ssl_info(self):
        """Add SSL cipher info."""
        if self.scheme == u'https':
            sock = self._get_ssl_sock()
            if hasattr(sock, 'cipher'):
                self.ssl_cert = sock.getpeercert()
            else:
                # using pyopenssl
                cert = sock.connection.get_peer_certificate()
                self.ssl_cert = httputil.x509_to_dict(cert)
            log.debug(LOG_CHECK, "Got SSL certificate %s", self.ssl_cert)
        else:
            self.ssl_cert = None

    def construct_auth (self):
        """Construct HTTP Basic authentication credentials if there
        is user/password information available. Does not overwrite if
        credentials have already been constructed."""
        if self.auth:
            return
        _user, _password = self.get_user_password()
        if _user is not None and _password is not None:
            self.auth = (_user, _password)

    def set_content_type (self):
        """Return content MIME type or empty string."""
        self.content_type = httputil.get_content_type(self.headers)

    def is_redirect(self):
        """Check if current response is a redirect."""
        return ('location' in self.headers and
                self.url_connection.status_code in REDIRECT_STATI)

    def get_request_kwargs(self):
        """Construct keyword parameters for Session.request() and
        Session.resolve_redirects()."""
        kwargs = dict(stream=True, timeout=self.aggregate.config["timeout"])
        if self.scheme == u"https" and self.aggregate.config["sslverify"]:
            kwargs['verify'] = self.aggregate.config["sslverify"]
        else:
            kwargs['verify'] = False
        return kwargs

    def follow_redirections(self, request):
        """Follow all redirections of http response."""
        log.debug(LOG_CHECK, "follow all redirections")
        if self.is_redirect():
            # run plugins for old connection
            self.aggregate.plugin_manager.run_connection_plugins(self)
        kwargs = self.get_request_kwargs()
        response = None
        for response in self.session.resolve_redirects(self.url_connection, request, **kwargs):
            newurl = response.url
            log.debug(LOG_CHECK, "Redirected to %r", newurl)
            self.aliases.append(newurl)
            # XXX on redirect errors this is not printed
            self.add_info(_("Redirected to `%(url)s'.") % {'url': newurl})
            self.urlparts = strformat.url_unicode_split(newurl)
            self.build_url_parts()
            self.url_connection = response
            self.headers = response.headers
            self.url = urlutil.urlunsplit(self.urlparts)
            self.scheme = self.urlparts[0].lower()
            self._add_ssl_info()
            self._add_response_info()
            if self.is_redirect():
                # run plugins for old connection
                self.aggregate.plugin_manager.run_connection_plugins(self)

    def getheader (self, name, default=None):
        """Get decoded header value.

        @return: decoded header value or default of not found
        @rtype: unicode or type of default
        """
        value = self.headers.get(name)
        if value is None:
            return default
        return unicode_safe(value, encoding=HEADER_ENCODING)

    def check_response (self):
        """Check final result and log it."""
        if self.url_connection.status_code >= 400:
            self.set_result(u"%d %s" % (self.url_connection.status_code, self.url_connection.reason),
                            valid=False)
        else:
            if self.url_connection.status_code == 204:
                # no content
                self.add_warning(self.url_connection.reason,
                                 tag=WARN_HTTP_EMPTY_CONTENT)
            if self.url_connection.status_code >= 200:
                self.set_result(u"%r %s" % (self.url_connection.status_code, self.url_connection.reason))
            else:
                self.set_result(_("OK"))

    def read_content(self):
        """Return data and data size for this URL.
        Can be overridden in subclasses."""
        maxbytes = self.aggregate.config["maxfilesizedownload"]
        buf = StringIO()
        for data in self.url_connection.iter_content(chunk_size=self.ReadChunkBytes):
            if buf.tell() + len(data) > maxbytes:
                raise LinkCheckerError(_("File size too large"))
            buf.write(data)
        return buf.getvalue()

    def parse_header_links(self):
        """Parse Link: header URLs."""
        for linktype, linkinfo in self.url_connection.links.items():
            url = linkinfo["url"]
            name = u"Link: header %s" % linktype
            self.add_url(url, name=name)

    def is_parseable (self):
        """
        Check if content is parseable for recursion.

        @return: True if content is parseable
        @rtype: bool
        """
        if not self.valid:
            return False
        # some content types must be validated with the page content
        if self.content_type in ("application/xml", "text/xml"):
            rtype = mimeutil.guess_mimetype_read(self.get_content)
            if rtype is not None:
                # XXX side effect
                self.content_type = rtype
        if self.content_type not in self.ContentMimetypes:
            log.debug(LOG_CHECK, "URL with content type %r is not parseable", self.content_type)
            return False
        return True

    def get_robots_txt_url (self):
        """
        Get the according robots.txt URL for this URL.

        @return: robots.txt URL
        @rtype: string
        """
        return "%s://%s/robots.txt" % tuple(self.urlparts[0:2])

########NEW FILE########
__FILENAME__ = ignoreurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle ignored URLs.
"""

from . import unknownurl

class IgnoreUrl (unknownurl.UnknownUrl):
    """Always ignored URL."""

    def is_ignored (self):
        """Return True if this URL scheme is ignored."""
        return True

########NEW FILE########
__FILENAME__ = internpaturl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Intern URL pattern support.
"""
import re
from . import urlbase, absolute_url
from .. import strformat, url as urlutil


def get_intern_pattern (url):
    """Return intern pattern for given URL. Redirections to the same
    domain with or without "www." prepended are allowed."""
    parts = strformat.url_unicode_split(url)
    scheme = parts[0].lower()
    domain = parts[1].lower()
    domain, is_idn = urlutil.idna_encode(domain)
    # allow redirection www.example.com -> example.com and vice versa
    if domain.startswith('www.'):
        domain = domain[4:]
    if not (domain and scheme):
        return None
    path = urlutil.splitparams(parts[2])[0]
    segments = path.split('/')[:-1]
    path = "/".join(segments)
    if url.endswith('/'):
        path += '/'
    args = list(re.escape(x) for x in (scheme, domain, path))
    if args[0] in ('http', 'https'):
        args[0] = 'https?'
    args[1] = r"(www\.|)%s" % args[1]
    return "%s://%s%s" % tuple(args)


class InternPatternUrl (urlbase.UrlBase):
    """Class supporting an intern URL pattern."""

    def get_intern_pattern (self, url=None):
        """
        Get pattern for intern URL matching.

        @return non-empty regex pattern or None
        @rtype String or None
        """
        if url is None:
            url = absolute_url(self.base_url, self.base_ref, self.parent_url)
        if not url:
            return None
        return get_intern_pattern(url)

########NEW FILE########
__FILENAME__ = mailtourl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle for mailto: links.
"""

import re
import urllib
import urlparse
from email._parseaddr import AddressList

from . import urlbase
from .. import log, LOG_CHECK, strformat, url as urlutil
from dns import resolver
from ..network import iputil
from .const import WARN_MAIL_NO_MX_HOST


def getaddresses (addr):
    """Return list of email addresses from given field value."""
    parsed = [mail for name, mail in AddressList(addr).addresslist if mail]
    if parsed:
        addresses = parsed
    elif addr:
        # we could not parse any mail addresses, so try with the raw string
        addresses = [addr]
    else:
        addresses = []
    return addresses


def is_quoted (addr):
    """Return True iff mail address string is quoted."""
    return addr.startswith(u'"') and addr.endswith(u'"')


def is_literal (domain):
    """Return True iff domain string is a literal."""
    return domain.startswith(u'[') and domain.endswith(u']')


_remove_quoted = re.compile(ur'\\.').sub
_quotes = re.compile(ur'["\\]')
def is_missing_quote (addr):
    """Return True iff mail address is not correctly quoted."""
    return _quotes.match(_remove_quoted(u"", addr[1:-1]))


# list of CGI keys to search for email addresses
EMAIL_CGI_ADDRESS = ("to", "cc", "bcc")
EMAIL_CGI_SUBJECT = "subject"

class MailtoUrl (urlbase.UrlBase):
    """
    Url link with mailto scheme.
    """

    def build_url (self):
        """Call super.build_url(), extract list of mail addresses from URL,
        and check their syntax.
        """
        super(MailtoUrl, self).build_url()
        self.addresses = set()
        self.subject = None
        self.parse_addresses()
        if self.addresses:
            for addr in sorted(self.addresses):
                self.check_email_syntax(addr)
                if not self.valid:
                    break
        elif not self.subject:
            self.add_warning(_("No mail addresses or email subject found in `%(url)s'.") % \
                {"url": self.url})

    def parse_addresses (self):
        """Parse all mail addresses out of the URL target. Also parses
        optional CGI headers like "?to=foo@example.org".
        Stores parsed addresses in the self.addresses set.
        """
        # cut off leading mailto: and unquote
        url = urllib.unquote(self.base_url[7:])
        # search for cc, bcc, to and store in headers
        mode = 0 # 0=default, 1=quote, 2=esc
        quote = None
        i = 0
        for i, c in enumerate(url):
            if mode == 0:
                if c == '?':
                    break
                elif c in '<"':
                    quote = c
                    mode = 1
                elif c == '\\':
                    mode = 2
            elif mode==1:
                if c == '"' and quote == '"':
                    mode = 0
                elif c == '>' and quote == '<':
                    mode = 0
            elif mode == 2:
                mode = 0
        if i < (len(url) - 1):
            self.addresses.update(getaddresses(url[:i]))
            try:
                headers = urlparse.parse_qs(url[(i+1):], strict_parsing=True)
                for key, vals in headers.items():
                    if key.lower() in EMAIL_CGI_ADDRESS:
                        # Only the first header value is added
                        self.addresses.update(getaddresses(urllib.unquote(vals[0])))
                    if key.lower() == EMAIL_CGI_SUBJECT:
                        self.subject = vals[0]
            except ValueError as err:
                self.add_warning(_("Error parsing CGI values: %s") % str(err))
        else:
            self.addresses.update(getaddresses(url))
        log.debug(LOG_CHECK, "addresses: %s", self.addresses)

    def check_email_syntax (self, mail):
        """Check email syntax. The relevant RFCs:
        - How to check names (memo):
          http://tools.ietf.org/html/rfc3696
        - Email address syntax
          http://tools.ietf.org/html/rfc2822
        - SMTP protocol
          http://tools.ietf.org/html/rfc5321#section-4.1.3
        - IPv6
          http://tools.ietf.org/html/rfc4291#section-2.2
        - Host syntax
          http://tools.ietf.org/html/rfc1123#section-2
        """
        # length checks

        # restrict email length to 256 characters
        # http://www.rfc-editor.org/errata_search.php?eid=1003
        if len(mail) > 256:
            self.set_result(_("Mail address `%(addr)s' too long. Allowed 256 chars, was %(length)d chars.") % \
            {"addr": mail, "length": len(mail)}, valid=False, overwrite=False)
            return
        if "@" not in mail:
            self.set_result(_("Missing `@' in mail address `%(addr)s'.") % \
            {"addr": mail}, valid=False, overwrite=False)
            return
        # note: be sure to use rsplit since "@" can occur in local part
        local, domain = mail.rsplit("@", 1)
        if not local:
            self.set_result(_("Missing local part of mail address `%(addr)s'.") % \
            {"addr": mail}, valid=False, overwrite=False)
            return
        if not domain:
            self.set_result(_("Missing domain part of mail address `%(addr)s'.") % \
            {"addr": mail}, valid=False, overwrite=False)
            return
        if len(local) > 64:
            self.set_result(_("Local part of mail address `%(addr)s' too long. Allowed 64 chars, was %(length)d chars.") % \
            {"addr": mail, "length": len(local)}, valid=False, overwrite=False)
            return
        if len(domain) > 255:
            self.set_result(_("Domain part of mail address `%(addr)s' too long. Allowed 255 chars, was %(length)d chars.") % \
            {"addr": mail, "length": len(local)}, valid=False, overwrite=False)
            return

        # local part syntax check

        # Rules taken from http://tools.ietf.org/html/rfc3696#section-3
        if is_quoted(local):
            if is_missing_quote(local):
                self.set_result(_("Unquoted double quote or backslash in mail address `%(addr)s'.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
        else:
            if local.startswith(u"."):
                self.set_result(_("Local part of mail address `%(addr)s' may not start with a dot.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
            if local.endswith(u"."):
                self.set_result(_("Local part of mail address `%(addr)s' may not end with a dot.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
            if u".." in local:
                self.set_result(_("Local part of mail address `%(addr)s' may not contain two dots.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
            for char in u'@ \\",[]':
                if char in local.replace(u"\\%s"%char, u""):
                    self.set_result(_("Local part of mail address `%(addr)s' contains unquoted character `%(char)s.") % \
                    {"addr": mail, "char": char}, valid=False, overwrite=False)
                    return

        # domain part syntax check

        if is_literal(domain):
            # it's an IP address
            ip = domain[1:-1]
            if ip.startswith(u"IPv6:"):
                ip = ip[5:]
            if not iputil.is_valid_ip(ip):
                self.set_result(_("Domain part of mail address `%(addr)s' has invalid IP.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
        else:
            # it's a domain name
            if not urlutil.is_safe_domain(domain):
                self.set_result(_("Invalid domain part of mail address `%(addr)s'.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return
            if domain.endswith(".") or domain.split(".")[-1].isdigit():
                self.set_result(_("Invalid top level domain part of mail address `%(addr)s'.") % \
                {"addr": mail}, valid=False, overwrite=False)
                return

    def check_connection (self):
        """
        Verify a list of email addresses. If one address fails,
        the whole list will fail.

        For each mail address the MX DNS records are found.
        If no MX records are found, print a warning and try
        to look for A DNS records. If no A records are found either
        print an error.
        """
        for mail in sorted(self.addresses):
            self.check_smtp_domain(mail)
            if not self.valid:
                break

    def check_smtp_domain (self, mail):
        """
        Check a single mail address.
        """
        from dns.exception import DNSException
        log.debug(LOG_CHECK, "checking mail address %r", mail)
        mail = strformat.ascii_safe(mail)
        username, domain = mail.rsplit('@', 1)
        log.debug(LOG_CHECK, "looking up MX mailhost %r", domain)
        try:
            answers = resolver.query(domain, 'MX')
        except DNSException:
            answers = []
        if len(answers) == 0:
            self.add_warning(_("No MX mail host for %(domain)s found.") %
                            {'domain': domain},
                             tag=WARN_MAIL_NO_MX_HOST)
            try:
                answers = resolver.query(domain, 'A')
            except DNSException:
                answers = []
            if len(answers) == 0:
                self.set_result(_("No host for %(domain)s found.") %
                                 {'domain': domain}, valid=False,
                                 overwrite=True)
                return
            # set preference to zero
            mxdata = [(0, rdata.to_text(omit_final_dot=True))
                      for rdata in answers]
        else:
            from dns.rdtypes.mxbase import MXBase
            mxdata = [(rdata.preference,
                       rdata.exchange.to_text(omit_final_dot=True))
                       for rdata in answers if isinstance(rdata, MXBase)]
            if not mxdata:
                self.set_result(
                    _("Got invalid DNS answer %(answer)s for %(domain)s.") %
                    {'answer': answers, 'domain': domain}, valid=False,
                     overwrite=True)
                return
            # sort according to preference (lower preference means this
            # host should be preferred)
            mxdata.sort()
        # debug output
        log.debug(LOG_CHECK, "found %d MX mailhosts:", len(answers))
        for preference, host in mxdata:
            log.debug(LOG_CHECK, "MX host %r, preference %d", host, preference)
            pass
        self.set_result(_("Valid mail address syntax"))

    def set_cache_url(self):
        """
        The cache url is a comma separated list of emails.
        """
        emails = u",".join(sorted(self.addresses))
        self.cache_url = u"%s:%s" % (self.scheme, emails)

    def can_get_content (self):
        """
        mailto: URLs do not have any content

        @return: False
        @rtype: bool
        """
        return False

########NEW FILE########
__FILENAME__ = nntpurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle nntp: and news: links.
"""

import re
import time
import nntplib
import random

from . import urlbase
from .. import log, LinkCheckerError, LOG_CHECK
from .const import WARN_NNTP_NO_SERVER, WARN_NNTP_NO_NEWSGROUP

random.seed()

class NntpUrl (urlbase.UrlBase):
    """
    Url link with NNTP scheme.
    """

    def check_connection (self):
        """
        Connect to NNTP server and try to request the URL article
        resource (if specified).
        """
        nntpserver = self.host or self.aggregate.config["nntpserver"]
        if not nntpserver:
            self.add_warning(
                    _("No NNTP server was specified, skipping this URL."),
                    tag=WARN_NNTP_NO_SERVER)
            return
        nntp = self._connect_nntp(nntpserver)
        group = self.urlparts[2]
        while group[:1] == '/':
            group = group[1:]
        if '@' in group:
            # request article info (resp, number mid)
            number = nntp.stat("<"+group+">")[1]
            self.add_info(_('Article number %(num)s found.') % {"num": number})
        else:
            # split off trailing articel span
            group = group.split('/', 1)[0]
            if group:
                # request group info (resp, count, first, last, name)
                name = nntp.group(group)[4]
                self.add_info(_("News group %(name)s found.") % {"name": name})
            else:
                # group name is the empty string
                self.add_warning(_("No newsgroup specified in NNTP URL."),
                            tag=WARN_NNTP_NO_NEWSGROUP)

    def _connect_nntp (self, nntpserver):
        """
        This is done only once per checking task. Also, the newly
        introduced error codes 504 and 505 (both inclining "Too busy, retry
        later", are caught.
        """
        tries = 0
        nntp = None
        while tries < 2:
            tries += 1
            try:
                nntp = nntplib.NNTP(nntpserver, usenetrc=False)
            except nntplib.NNTPTemporaryError:
                self.wait()
            except nntplib.NNTPPermanentError as msg:
                if re.compile("^50[45]").search(str(msg)):
                    self.wait()
                else:
                    raise
        if nntp is None:
            raise LinkCheckerError(
               _("NNTP server too busy; tried more than %d times.") % tries)
        if log.is_debug(LOG_CHECK):
            nntp.set_debuglevel(1)
        self.add_info(nntp.getwelcome())
        return nntp

    def wait (self):
        """Wait some time before trying to connect again."""
        time.sleep(random.randrange(10, 30))

    def can_get_content (self):
        """
        NNTP urls have no content.

        @return: False
        @rtype: bool
        """
        return False

########NEW FILE########
__FILENAME__ = proxysupport
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Mixin class for URLs that can be fetched over a proxy.
"""
import urllib
import os
from .. import LinkCheckerError, log, LOG_CHECK, url as urlutil, httputil


class ProxySupport (object):
    """Get support for proxying and for URLs with user:pass@host setting."""

    def set_proxy (self, proxy):
        """Parse given proxy information and store parsed values.
        Note that only http:// proxies are supported, both for ftp://
        and http:// URLs.
        """
        self.proxy = proxy
        self.proxytype = "http"
        self.proxyauth = None
        if not self.proxy:
            return
        proxyargs = {"proxy": self.proxy}
        self.proxytype, self.proxy = urllib.splittype(self.proxy)
        if self.proxytype not in ('http', 'https'):
            # Note that invalid proxies might raise TypeError in urllib2,
            # so make sure to stop checking at this point, not later.
            msg = _("Proxy value `%(proxy)s' must start with 'http:' or 'https:'.") \
                 % proxyargs
            raise LinkCheckerError(msg)
        self.proxy = urllib.splithost(self.proxy)[0]
        self.proxyauth, self.proxy = urllib.splituser(self.proxy)
        if self.ignore_proxy_host():
            # log proxy without auth info
            log.debug(LOG_CHECK, "ignoring proxy %r", self.proxy)
            self.add_info(_("Ignoring proxy setting `%(proxy)s'.") % proxyargs)
            self.proxy = self.proxyauth = None
            return
        self.add_info(_("Using proxy `%(proxy)s'.") % proxyargs)
        if self.proxyauth is not None:
            if ":" not in self.proxyauth:
                self.proxyauth += ":"
            self.proxyauth = httputil.encode_base64(self.proxyauth)
            self.proxyauth = "Basic "+self.proxyauth
        log.debug(LOG_CHECK, "using proxy %r", self.proxy)

    def ignore_proxy_host (self):
        """Check if self.host is in the $no_proxy ignore list."""
        if urllib.proxy_bypass(self.host):
            return True
        no_proxy = os.environ.get("no_proxy")
        if no_proxy:
            entries = [parse_host_port(x) for x in no_proxy.split(",")]
            for host, port in entries:
                if host.lower() == self.host and port == self.port:
                    return True
        return False

    def get_netloc(self):
        """Determine scheme, host and port for this connection taking
        proxy data into account.
        @return: tuple (scheme, host, port)
        @rtype: tuple(string, string, int)
        """
        if self.proxy:
            scheme = self.proxytype
            host, port = urlutil.splitport(self.proxy)
        else:
            scheme = self.scheme
            host = self.host
            port = self.port
        return (scheme, host, port)


def parse_host_port (host_port):
    """Parse a host:port string into separate components."""
    host, port = urllib.splitport(host_port.strip())
    if port is not None:
        if urlutil.is_numeric_port(port):
            port = int(port)
    return host, port

########NEW FILE########
__FILENAME__ = telneturl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle telnet: links.
"""

import telnetlib
from . import urlbase
from .. import log, LOG_CHECK


def encode(s, encoding="iso-8859-1", errors="ignore"):
    """Encode telnet data like username and password."""
    return s.encode(encoding, errors)


class TelnetUrl (urlbase.UrlBase):
    """
    Url link with telnet scheme.
    """

    def build_url (self):
        """
        Call super.build_url(), set default telnet port and initialize
        the login credentials.
        """
        super(TelnetUrl, self).build_url()
        # default port
        if self.port is None:
            self.port = 23
        # set user/pass
        self.user, self.password = self.get_user_password()

    def local_check (self):
        """
        Warn about empty host names. Else call super.local_check().
        """
        if not self.host:
            self.set_result(_("Host is empty"), valid=False)
            return
        super(TelnetUrl, self).local_check()

    def check_connection (self):
        """
        Open a telnet connection and try to login. Expected login
        label is "login: ", expected password label is "Password: ".
        """
        self.url_connection = telnetlib.Telnet(timeout=self.aggregate.config["timeout"])
        if log.is_debug(LOG_CHECK):
            self.url_connection.set_debuglevel(1)
        self.url_connection.open(self.host, self.port)
        if self.user:
            self.url_connection.read_until("login: ", 10)
            self.url_connection.write(encode(self.user)+"\n")
            if self.password:
                self.url_connection.read_until("Password: ", 10)
                self.url_connection.write(encode(self.password)+"\n")
                # XXX how to tell if we are logged in??
        self.url_connection.write("exit\n")

    def can_get_content (self):
        """
        Telnet URLs have no content.

        @return: False
        @rtype: bool
        """
        return False

########NEW FILE########
__FILENAME__ = unknownurl
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2001-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle uncheckable URLs.
"""

import re
from . import urlbase


class UnknownUrl (urlbase.UrlBase):
    """Handle unknown or just plain broken URLs."""

    def build_url (self):
        """Only logs that this URL is unknown."""
        super(UnknownUrl, self).build_url()
        if self.is_ignored():
            self.add_info(_("%(scheme)s URL ignored.") %
                          {"scheme": self.scheme.capitalize()})
            self.set_result(_("ignored"))
        else:
            self.set_result(_("URL is unrecognized or has invalid syntax"),
                        valid=False)

    def is_ignored (self):
        """Return True if this URL scheme is ignored."""
        return is_unknown_scheme(self.scheme)

    def can_get_content (self):
        """Unknown URLs have no content.

        @return: False
        @rtype: bool
        """
        return False


# do not edit anything below since these entries are generated from scripts/update.sh
# DO NOT REMOVE

# from https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
ignored_schemes_permanent = r"""
|aaa        # Diameter Protocol
|aaas       # Diameter Protocol with Secure Transport
|about      # about
|acap       # application configuration access protocol
|acct       # acct
|cap        # Calendar Access Protocol
|cid        # content identifier
|coap       # coap
|coaps      # coaps
|crid       # TV-Anytime Content Reference Identifier
|data       # data
|dav        # dav
|dict       # dictionary service protocol
|dns        # Domain Name System
|geo        # Geographic Locations
|go         # go
|gopher     # The Gopher Protocol
|h323       # H.323
|iax        # Inter-Asterisk eXchange Version 2
|icap       # Internet Content Adaptation Protocol
|im         # Instant Messaging
|imap       # internet message access protocol
|info       # Information Assets with Identifiers in Public Namespaces
|ipp        # Internet Printing Protocol
|iris       # Internet Registry Information Service
|iris\.beep # iris.beep
|iris\.lwz  # iris.lwz
|iris\.xpc  # iris.xpc
|iris\.xpcs # iris.xpcs
|jabber     # jabber
|ldap       # Lightweight Directory Access Protocol
|mid        # message identifier
|msrp       # Message Session Relay Protocol
|msrps      # Message Session Relay Protocol Secure
|mtqp       # Message Tracking Query Protocol
|mupdate    # Mailbox Update (MUPDATE) Protocol
|nfs        # network file system protocol
|ni         # ni
|nih        # nih
|opaquelocktoken # opaquelocktokent
|pop        # Post Office Protocol v3
|pres       # Presence
|reload     # reload
|rtsp       # Real-time Streaming Protocol (RTSP)
|rtsps      # Real-time Streaming Protocol (RTSP) over TLS
|rtspu      # Real-time Streaming Protocol (RTSP) over unreliable datagram transport
|service    # service location
|session    # session
|shttp      # Secure Hypertext Transfer Protocol
|sieve      # ManageSieve Protocol
|sip        # session initiation protocol
|sips       # secure session initiation protocol
|sms        # Short Message Service
|snmp       # Simple Network Management Protocol
|soap\.beep # soap.beep
|soap\.beeps # soap.beeps
|stun       # stun
|stuns      # stuns
|tag        # tag
|tel        # telephone
|telnet     # Reference to interactive sessions
|tftp       # Trivial File Transfer Protocol
|thismessage # multipart/related relative reference resolution
|tip        # Transaction Internet Protocol
|tn3270     # Interactive 3270 emulation sessions
|turn       # turn
|turns      # turns
|tv         # TV Broadcasts
|urn        # Uniform Resource Names
|vemmi      # versatile multimedia interface
|ws         # WebSocket connections
|wss        # Encrypted WebSocket connections
|xcon       # xcon
|xcon\-userid # xcon-userid
|xmlrpc\.beep # xmlrpc.beep
|xmlrpc\.beeps # xmlrpc.beeps
|xmpp       # Extensible Messaging and Presence Protocol
|z39\.50r   # Z39.50 Retrieval
|z39\.50s   # Z39.50 Session
"""

ignored_schemes_provisional = r"""
|adiumxtra  # adiumxtra
|afp        # afp
|afs        # Andrew File System global file names
|aim        # aim
|apt        # apt
|attachment # attachment
|aw         # aw
|beshare    # beshare
|bitcoin    # bitcoin
|bolo       # bolo
|callto     # callto
|chrome     # chrome
|chrome\-extension # chrome-extension
|com\-eventbrite\-attendee # com-eventbrite-attendee
|content    # content
|cvs        # cvs
|dlna\-playcontainer # dlna-playcontainer
|dlna\-playsingle # dlna-playsingle
|dtn        # DTNRG research and development
|dvb        # dvb
|ed2k       # ed2k
|facetime   # facetime
|feed       # feed
|feedready  # feedready
|finger     # finger
|fish       # fish
|gg         # gg
|git        # git
|gizmoproject # gizmoproject
|gtalk      # gtalk
|ham        # ham
|hcp        # hcp
|icon       # icon
|ipn        # ipn
|irc        # irc
|irc6       # irc6
|ircs       # ircs
|itms       # itms
|jar        # jar
|jms        # Java Message Service
|keyparc    # keyparc
|lastfm     # lastfm
|ldaps      # ldaps
|magnet     # magnet
|maps       # maps
|market     # market
|message    # message
|mms        # mms
|ms\-help   # ms-help
|ms\-settings\-power # ms-settings-power
|msnim      # msnim
|mumble     # mumble
|mvn        # mvn
|notes      # notes
|oid        # oid
|palm       # palm
|paparazzi  # paparazzi
|pkcs11     # pkcs11
|platform   # platform
|proxy      # proxy
|psyc       # psyc
|query      # query
|res        # res
|resource   # resource
|rmi        # rmi
|rsync      # rsync
|rtmp       # rtmp
|secondlife # query
|sftp       # query
|sgn        # sgn
|skype      # skype
|smb        # smb
|soldat     # soldat
|spotify    # spotify
|ssh        # ssh
|steam      # steam
|svn        # svn
|teamspeak  # teamspeak
|things     # things
|udp        # udp
|unreal     # unreal
|ut2004     # ut2004
|ventrilo   # ventrilo
|view\-source # view-source
|webcal     # webcal
|wtai       # wtai
|wyciwyg    # wyciwyg
|xfire      # xfire
|xri        # xri
|ymsgr      # ymsgr
"""

ignored_schemes_historical = r"""
|fax        # fax
|mailserver # Access to data available from mail servers
|modem      # modem
|pack       # pack
|prospero   # Prospero Directory Service
|snews      # NNTP over SSL/TLS
|videotex   # videotex
|wais       # Wide Area Information Servers
|z39\.50    # Z39.50 information access
"""

ignored_schemes_other = r"""
|clsid      # Microsoft specific
|find       # Mozilla specific
|isbn       # ISBN (int. book numbers)
|javascript # JavaScript
"""

ignored_schemes = "^(%s%s%s%s)$" % (
    ignored_schemes_permanent,
    ignored_schemes_provisional,
    ignored_schemes_historical,
    ignored_schemes_other,
)
ignored_schemes_re = re.compile(ignored_schemes, re.VERBOSE)

is_unknown_scheme = ignored_schemes_re.match


########NEW FILE########
__FILENAME__ = urlbase
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Base URL handler.
"""
import sys
import os
import urlparse
import urllib2
import urllib
import time
import errno
import socket
import select
from cStringIO import StringIO

from . import absolute_url, get_url_from
from .. import (log, LOG_CHECK,
  strformat, LinkCheckerError, url as urlutil, trace, get_link_pat)
from ..network import iputil
from .const import (WARN_URL_EFFECTIVE_URL,
    WARN_URL_ERROR_GETTING_CONTENT, WARN_URL_OBFUSCATED_IP,
    WARN_URL_CONTENT_SIZE_ZERO, WARN_URL_CONTENT_SIZE_TOO_LARGE,
    WARN_URL_WHITESPACE, URL_MAX_LENGTH, WARN_URL_TOO_LONG,
    ExcList, ExcSyntaxList, ExcNoCacheList)

# helper alias
unicode_safe = strformat.unicode_safe

# schemes that are invalid with an empty hostname
scheme_requires_host = ("ftp", "http", "telnet")

def urljoin (parent, url):
    """
    If url is relative, join parent and url. Else leave url as-is.

    @return joined url
    """
    if urlutil.url_is_absolute(url):
        return url
    return urlparse.urljoin(parent, url)


def url_norm (url, encoding=None):
    """Wrapper for url.url_norm() to convert UnicodeError in
    LinkCheckerError."""
    try:
        return urlutil.url_norm(url, encoding=encoding)
    except UnicodeError:
        msg = _("URL has unparsable domain name: %(name)s") % \
            {"name": sys.exc_info()[1]}
        raise LinkCheckerError(msg)


class UrlBase (object):
    """An URL with additional information like validity etc."""

    # file types that can be parsed recursively
    ContentMimetypes = {
        "text/html": "html",
        "application/xhtml+xml": "html",
        # Include PHP file which helps when checking local .php files.
        # It does not harm other URL schemes like HTTP since HTTP servers
        # should not send this content type. They send text/html instead.
        "application/x-httpd-php": "html",
        "text/css": "css",
        "application/x-shockwave-flash": "swf",
        "application/msword": "word",
        "text/plain+linkchecker": "text",
        "text/plain+opera": "opera",
        "text/plain+chromium": "chromium",
        "application/x-plist+safari": "safari",
        "text/vnd.wap.wml": "wml",
        "application/xml+sitemap": "sitemap",
        "application/xml+sitemapindex": "sitemapindex",
        "application/pdf": "pdf",
        "application/x-pdf": "pdf",
    }

    # Read in 16kb chunks
    ReadChunkBytes = 1024*16

    def __init__ (self, base_url, recursion_level, aggregate,
                  parent_url=None, base_ref=None, line=-1, column=-1, page=-1,
                  name=u"", url_encoding=None, extern=None):
        """
        Initialize check data, and store given variables.

        @param base_url: unquoted and possibly unnormed url
        @param recursion_level: on what check level lies the base url
        @param aggregate: aggregate instance
        @param parent_url: quoted and normed url of parent or None
        @param base_ref: quoted and normed url of <base href=""> or None
        @param line: line number of url in parent content
        @param column: column number of url in parent content
        @param page: page number of url in parent content
        @param name: name of url or empty
        @param url_encoding: encoding of URL or None
        @param extern: None or (is_extern, is_strict)
        """
        self.reset()
        self.init(base_ref, base_url, parent_url, recursion_level,
                  aggregate, line, column, page, name, url_encoding, extern)
        self.check_syntax()
        if recursion_level == 0:
            self.add_intern_pattern()
        self.set_extern(self.url)
        if self.extern[0] and self.extern[1]:
            self.add_info(_("The URL is outside of the domain "
                          "filter, checked only syntax."))
            if not self.has_result:
                self.set_result(_("filtered"))

    def init (self, base_ref, base_url, parent_url, recursion_level,
              aggregate, line, column, page, name, url_encoding, extern):
        """
        Initialize internal data.
        """
        self.base_ref = base_ref
        if self.base_ref is not None:
            assert isinstance(self.base_ref, unicode), repr(self.base_ref)
        self.base_url = base_url.strip() if base_url else base_url
        if self.base_url is not None:
            assert isinstance(self.base_url, unicode), repr(self.base_url)
        self.parent_url = parent_url
        if self.parent_url is not None:
            assert isinstance(self.parent_url, unicode), repr(self.parent_url)
        self.recursion_level = recursion_level
        self.aggregate = aggregate
        self.line = line
        self.column = column
        self.page = page
        self.name = name
        assert isinstance(self.name, unicode), repr(self.name)
        self.encoding = url_encoding
        self.charset = None
        self.extern = extern
        if self.base_ref:
            assert not urlutil.url_needs_quoting(self.base_ref), \
                   "unquoted base reference URL %r" % self.base_ref
        if self.parent_url:
            assert not urlutil.url_needs_quoting(self.parent_url), \
                   "unquoted parent URL %r" % self.parent_url
        url = absolute_url(self.base_url, base_ref, parent_url)
        # assume file link if no scheme is found
        self.scheme = url.split(":", 1)[0].lower() or "file"
        if self.base_url != base_url:
            self.add_warning(_("Leading or trailing whitespace in URL `%(url)s'.") %
                               {"url": base_url}, tag=WARN_URL_WHITESPACE)

    def reset (self):
        """
        Reset all variables to default values.
        """
        # self.url is constructed by self.build_url() out of base_url
        # and (base_ref or parent) as absolute and normed url.
        # This the real url we use when checking so it also referred to
        # as 'real url'
        self.url = None
        # a splitted version of url for convenience
        self.urlparts = None
        # the scheme, host, port and anchor part of url
        self.scheme = self.host = self.port = self.anchor = None
        # the result message string and flag
        self.result = u""
        self.has_result = False
        # valid or not
        self.valid = True
        # list of warnings (without duplicates)
        self.warnings = []
        # list of infos
        self.info = []
        # content size
        self.size = -1
        # last modification time of content in HTTP-date format as specified in RFC2616 chapter 3.3.1
        self.modified = None
        # download time
        self.dltime = -1
        # check time
        self.checktime = 0
        # connection object
        self.url_connection = None
        # data of url content,  (data == None) means no data is available
        self.data = None
        # cache url is set by build_url() calling set_cache_url()
        self.cache_url = None
        # extern flags (is_extern, is_strict)
        self.extern = None
        # flag if the result should be cached
        self.caching = True
        # title is either the URL or parsed from content
        self.title = None
        # flag if content should be checked or not
        self.do_check_content = True
        # MIME content type
        self.content_type = u""
        # URLs seen through redirections
        self.aliases = []

    def set_result (self, msg, valid=True, overwrite=False):
        """
        Set result string and validity.
        """
        if self.has_result and not overwrite:
            log.warn(LOG_CHECK,
              "Double result %r (previous %r) for %s", msg, self.result, self)
        else:
            self.has_result = True
        if not isinstance(msg, unicode):
            log.warn(LOG_CHECK, "Non-unicode result for %s: %r", self, msg)
        elif not msg:
            log.warn(LOG_CHECK, "Empty result for %s", self)
        self.result = msg
        self.valid = valid
        # free content data
        self.data = None

    def get_title (self):
        """Return title of page the URL refers to.
        This is per default the filename or the URL."""
        if self.title is None:
            url = u""
            if self.base_url:
                url = self.base_url
            elif self.url:
                url = self.url
            self.title = url
            if "/" in url:
                title = url.rsplit("/", 1)[1]
                if title:
                    self.title = title
        return self.title

    def is_parseable (self):
        """
        Return True iff content of this url is parseable.
        """
        return False

    def is_html (self):
        """Return True iff content of this url is HTML formatted."""
        return self._is_ctype("html")

    def is_css (self):
        """Return True iff content of this url is CSS stylesheet."""
        return self._is_ctype("css")

    def _is_ctype(self, ctype):
        """Return True iff content is valid and of the given type."""
        if not self.valid:
            return False
        mime = self.content_type
        return self.ContentMimetypes.get(mime) == ctype

    def is_http (self):
        """Return True for http:// or https:// URLs."""
        return self.scheme in ("http", "https")

    def is_file (self):
        """Return True for file:// URLs."""
        return self.scheme == "file"

    def is_directory(self):
        """Return True if current URL represents a directory."""
        return False

    def is_local(self):
        """Return True for local (ie. file://) URLs."""
        return self.is_file()

    def add_warning (self, s, tag=None):
        """
        Add a warning string.
        """
        item = (tag, s)
        if item not in self.warnings and \
           tag not in self.aggregate.config["ignorewarnings"]:
            self.warnings.append(item)

    def add_info (self, s):
        """
        Add an info string.
        """
        if s not in self.info:
            self.info.append(s)

    def set_cache_url (self):
        """Set the URL to be used for caching."""
        # remove anchor from cached target url since we assume
        # URLs with different anchors to have the same content
        self.cache_url = urlutil.urlunsplit(self.urlparts[:4]+[u''])
        if self.cache_url is not None:
            assert isinstance(self.cache_url, unicode), repr(self.cache_url)

    def check_syntax (self):
        """
        Called before self.check(), this function inspects the
        url syntax. Success enables further checking, failure
        immediately logs this url. Syntax checks must not
        use any network resources.
        """
        log.debug(LOG_CHECK, "checking syntax")
        if self.base_url is None:
            self.set_result(_("URL is missing"), valid=False)
            return
        if not (self.base_url or self.parent_url):
            self.set_result(_("URL is empty"), valid=False)
            return
        try:
            self.build_url()
            self.check_url_warnings()
        except tuple(ExcSyntaxList) as msg:
            self.set_result(unicode_safe(msg), valid=False)
        else:
            self.set_cache_url()

    def check_url_warnings(self):
        """Check URL name and length."""
        effectiveurl = urlutil.urlunsplit(self.urlparts)
        if self.url != effectiveurl:
            self.add_warning(_("Effective URL %(url)r.") %
                             {"url": effectiveurl},
                             tag=WARN_URL_EFFECTIVE_URL)
            self.url = effectiveurl
        if len(self.url) > URL_MAX_LENGTH and self.scheme != u"data":
            args = dict(len=len(self.url), max=URL_MAX_LENGTH)
            self.add_warning(_("URL length %(len)d is longer than %(max)d.") % args, tag=WARN_URL_TOO_LONG)

    def build_url (self):
        """
        Construct self.url and self.urlparts out of the given base
        url information self.base_url, self.parent_url and self.base_ref.
        """
        # norm base url - can raise UnicodeError from url.idna_encode()
        base_url, is_idn = url_norm(self.base_url, self.encoding)
        # make url absolute
        if self.base_ref:
            # use base reference as parent url
            if ":" not in self.base_ref:
                # some websites have a relative base reference
                self.base_ref = urljoin(self.parent_url, self.base_ref)
            self.url = urljoin(self.base_ref, base_url)
        elif self.parent_url:
            # strip the parent url query and anchor
            urlparts = list(urlparse.urlsplit(self.parent_url))
            urlparts[4] = ""
            parent_url = urlutil.urlunsplit(urlparts)
            self.url = urljoin(parent_url, base_url)
        else:
            self.url = base_url
        # urljoin can unnorm the url path, so norm it again
        urlparts = list(urlparse.urlsplit(self.url))
        if urlparts[2]:
            urlparts[2] = urlutil.collapse_segments(urlparts[2])
        self.url = urlutil.urlunsplit(urlparts)
        # split into (modifiable) list
        self.urlparts = strformat.url_unicode_split(self.url)
        self.build_url_parts()
        # and unsplit again
        self.url = urlutil.urlunsplit(self.urlparts)

    def build_url_parts (self):
        """Set userinfo, host, port and anchor from self.urlparts.
        Also checks for obfuscated IP addresses.
        """
        # check userinfo@host:port syntax
        self.userinfo, host = urllib.splituser(self.urlparts[1])
        port = urlutil.default_ports.get(self.scheme, 0)
        host, port = urlutil.splitport(host, port=port)
        if port is None:
            raise LinkCheckerError(_("URL host %(host)r has invalid port") %
                    {"host": host})
        self.port = port
        # set host lowercase
        self.host = host.lower()
        if self.scheme in scheme_requires_host:
            if not self.host:
                raise LinkCheckerError(_("URL has empty hostname"))
            self.check_obfuscated_ip()
        if not self.port or self.port == urlutil.default_ports.get(self.scheme):
            host = self.host
        else:
            host = "%s:%d" % (self.host, self.port)
        if self.userinfo:
            self.urlparts[1] = "%s@%s" % (self.userinfo, host)
        else:
            self.urlparts[1] = host
        # safe anchor for later checking
        self.anchor = self.urlparts[4]
        if self.anchor is not None:
            assert isinstance(self.anchor, unicode), repr(self.anchor)

    def check_obfuscated_ip (self):
        """Warn if host of this URL is obfuscated IP address."""
        # check if self.host can be an IP address
        # check for obfuscated IP address
        if iputil.is_obfuscated_ip(self.host):
            ips = iputil.resolve_host(self.host)
            if ips:
                self.host = ips[0]
                self.add_warning(
                   _("URL %(url)s has obfuscated IP address %(ip)s") % \
                   {"url": self.base_url, "ip": ips[0]},
                          tag=WARN_URL_OBFUSCATED_IP)

    def check (self):
        """Main check function for checking this URL."""
        if self.aggregate.config["trace"]:
            trace.trace_on()
        try:
            self.local_check()
        except (socket.error, select.error):
            # on Unix, ctrl-c can raise
            # error: (4, 'Interrupted system call')
            etype, value = sys.exc_info()[:2]
            if etype == errno.EINTR:
                raise KeyboardInterrupt(value)
            else:
                raise

    def local_check (self):
        """Local check function can be overridden in subclasses."""
        log.debug(LOG_CHECK, "Checking %s", unicode(self))
        # strict extern URLs should not be checked
        assert not self.extern[1], 'checking strict extern URL'
        # check connection
        log.debug(LOG_CHECK, "checking connection")
        try:
            self.check_connection()
            self.set_content_type()
            self.add_size_info()
            self.aggregate.plugin_manager.run_connection_plugins(self)
        except tuple(ExcList) as exc:
            value = self.handle_exception()
            # make nicer error msg for unknown hosts
            if isinstance(exc, socket.error) and exc.args[0] == -2:
                value = _('Hostname not found')
            elif isinstance(exc, UnicodeError):
                # idna.encode(host) failed
                value = _('Bad hostname %(host)r: %(msg)s') % {'host': self.host, 'msg': str(value)}
            self.set_result(unicode_safe(value), valid=False)

    def check_content(self):
        """Check content of URL.
        @return: True if content can be parsed, else False
        """
        if self.do_check_content and self.valid:
            # check content and recursion
            try:
                if self.can_get_content():
                    self.aggregate.plugin_manager.run_content_plugins(self)
                if self.allows_recursion():
                    return True
            except tuple(ExcList):
                value = self.handle_exception()
                self.add_warning(_("could not get content: %(msg)s") %
                     {"msg": str(value)}, tag=WARN_URL_ERROR_GETTING_CONTENT)
        return False

    def close_connection (self):
        """
        Close an opened url connection.
        """
        if self.url_connection is None:
            # no connection is open
            return
        try:
            self.url_connection.close()
        except Exception:
            # ignore close errors
            pass
        self.url_connection = None

    def handle_exception (self):
        """
        An exception occurred. Log it and set the cache flag.
        """
        etype, evalue = sys.exc_info()[:2]
        log.debug(LOG_CHECK, "Error in %s: %s %s", self.url, etype, evalue, exception=True)
        # note: etype must be the exact class, not a subclass
        if (etype in ExcNoCacheList) or \
           (etype == socket.error and evalue.args[0]==errno.EBADF) or \
            not evalue:
            # EBADF occurs when operating on an already socket
            self.caching = False
        # format unicode message "<exception name>: <error message>"
        errmsg = unicode(etype.__name__)
        uvalue = strformat.unicode_safe(evalue)
        if uvalue:
            errmsg += u": %s" % uvalue
        # limit length to 240
        return strformat.limit(errmsg, length=240)

    def check_connection (self):
        """
        The basic connection check uses urllib2.urlopen to initialize
        a connection object.
        """
        self.url_connection = urllib2.urlopen(self.url)

    def add_size_info (self):
        """Set size of URL content (if any)..
        Should be overridden in subclasses."""
        maxbytes = self.aggregate.config["maxfilesizedownload"]
        if self.size > maxbytes:
            self.add_warning(
              _("Content size %(size)s is larger than %(maxbytes)s.") %
                  dict(size=strformat.strsize(self.size),
                       maxbytes=strformat.strsize(maxbytes)),
                tag=WARN_URL_CONTENT_SIZE_TOO_LARGE)

    def allows_simple_recursion(self):
        """Check recursion level and extern status."""
        rec_level = self.aggregate.config["recursionlevel"]
        if rec_level >= 0 and self.recursion_level >= rec_level:
            log.debug(LOG_CHECK, "... no, maximum recursion level reached.")
            return False
        if self.extern[0]:
            log.debug(LOG_CHECK, "... no, extern.")
            return False
        return True

    def allows_recursion (self):
        """
        Return True iff we can recurse into the url's content.
        """
        log.debug(LOG_CHECK, "checking recursion of %r ...", self.url)
        if not self.valid:
            log.debug(LOG_CHECK, "... no, invalid.")
            return False
        if not self.can_get_content():
            log.debug(LOG_CHECK, "... no, cannot get content.")
            return False
        if not self.allows_simple_recursion():
            return False
        if self.size > self.aggregate.config["maxfilesizeparse"]:
            log.debug(LOG_CHECK, "... no, maximum parse size.")
            return False
        if not self.is_parseable():
            log.debug(LOG_CHECK, "... no, not parseable.")
            return False
        if not self.content_allows_robots():
            log.debug(LOG_CHECK, "... no, robots.")
            return False
        log.debug(LOG_CHECK, "... yes, recursion.")
        return True

    def content_allows_robots(self):
        """Returns True: only check robots.txt on HTTP links."""
        return True

    def set_extern (self, url):
        """
        Match URL against extern and intern link patterns. If no pattern
        matches the URL is extern. Sets self.extern to a tuple (bool,
        bool) with content (is_extern, is_strict).

        @return: None
        """
        if self.extern:
            return
        if not url:
            self.extern = (1, 1)
            return
        for entry in self.aggregate.config["externlinks"]:
            match = entry['pattern'].search(url)
            if (entry['negate'] and not match) or \
               (match and not entry['negate']):
                log.debug(LOG_CHECK, "Extern URL %r", url)
                self.extern = (1, entry['strict'])
                return
        for entry in self.aggregate.config["internlinks"]:
            match = entry['pattern'].search(url)
            if (entry['negate'] and not match) or \
               (match and not entry['negate']):
                log.debug(LOG_CHECK, "Intern URL %r", url)
                self.extern = (0, 0)
                return
        if self.aggregate.config['checkextern']:
            self.extern = (1, 0)
        else:
            self.extern = (1, 1)

    def set_content_type (self):
        """Set content MIME type.
        Should be overridden in subclasses."""
        pass

    def can_get_content (self):
        """Indicate wether url get_content() can be called."""
        return self.size <= self.aggregate.config["maxfilesizedownload"]

    def get_content (self):
        """Precondition: url_connection is an opened URL."""
        if self.data is None:
            log.debug(LOG_CHECK, "Get content of %r", self.url)
            t = time.time()
            self.data = self.read_content()
            self.size = len(self.data)
            self.dltime = time.time() - t
            if self.size == 0:
                self.add_warning(_("Content size is zero."),
                             tag=WARN_URL_CONTENT_SIZE_ZERO)
            else:
                self.aggregate.add_downloaded_bytes(self.size)
        return self.data

    def read_content(self):
        """Return data for this URL. Can be overridden in subclasses."""
        buf = StringIO()
        data = self.read_content_chunk()
        while data:
            if buf.tell() + len(data) > self.aggregate.config["maxfilesizedownload"]:
                raise LinkCheckerError(_("File size too large"))
            buf.write(data)
            data = self.read_content_chunk()
        return buf.getvalue()

    def read_content_chunk(self):
        """Read one chunk of content from this URL."""
        return self.url_connection.read(self.ReadChunkBytes)

    def get_user_password (self):
        """Get tuple (user, password) from configured authentication.
        Both user and password can be None.
        """
        if self.userinfo:
            # URL itself has authentication info
            return urllib.splitpasswd(self.userinfo)
        return self.aggregate.config.get_user_password(self.url)

    def add_url (self, url, line=0, column=0, page=0, name=u"", base=None):
        """Add new URL to queue."""
        if base:
            base_ref = urlutil.url_norm(base)[0]
        else:
            base_ref = None
        url_data = get_url_from(url, self.recursion_level+1, self.aggregate,
            parent_url=self.url, base_ref=base_ref, line=line, column=column,
            page=page, name=name, parent_content_type=self.content_type)
        self.aggregate.urlqueue.put(url_data)

    def serialized (self, sep=os.linesep):
        """
        Return serialized url check data as unicode string.
        """
        return unicode_safe(sep).join([
            u"%s link" % self.scheme,
            u"base_url=%r" % self.base_url,
            u"parent_url=%r" % self.parent_url,
            u"base_ref=%r" % self.base_ref,
            u"recursion_level=%d" % self.recursion_level,
            u"url_connection=%s" % self.url_connection,
            u"line=%d" % self.line,
            u"column=%d" % self.column,
            u"page=%d" % self.page,
            u"name=%r" % self.name,
            u"anchor=%r" % self.anchor,
            u"cache_url=%s" % self.cache_url,
           ])

    def get_intern_pattern (self, url=None):
        """Get pattern for intern URL matching.

        @param url: the URL to set intern pattern for, else self.url
        @ptype url: unicode or None
        @return non-empty regex pattern or None
        @rtype String or None
        """
        return None

    def add_intern_pattern(self, url=None):
        """Add intern URL regex to config."""
        try:
            pat = self.get_intern_pattern(url=url)
            if pat:
                log.debug(LOG_CHECK, "Add intern pattern %r", pat)
                self.aggregate.config['internlinks'].append(get_link_pat(pat))
        except UnicodeError as msg:
            res = _("URL has unparsable domain name: %(domain)s") % \
                {"domain": msg}
            self.set_result(res, valid=False)

    def __unicode__(self):
        """
        Get URL info.

        @return: URL info
        @rtype: unicode
        """
        return self.serialized()

    def __str__(self):
        """
        Get URL info.

        @return: URL info, encoded with the output logger encoding
        @rtype: string
        """
        s = unicode(self)
        return self.aggregate.config['logger'].encode(s)

    def __repr__ (self):
        """
        Get URL info.

        @return: URL info
        @rtype: unicode
        """
        return u"<%s>" % self.serialized(sep=u", ")

    def to_wire_dict (self):
        """Return a simplified transport object for logging and caching.

        The transport object must contain these attributes:
        - url_data.valid: bool
          Indicates if URL is valid
        - url_data.result: unicode
          Result string
        - url_data.warnings: list of tuples (tag, warning message)
          List of tagged warnings for this URL.
        - url_data.name: unicode string or None
          name of URL (eg. filename or link name)
        - url_data.parent_url: unicode or None
          Parent URL
        - url_data.base_ref: unicode
          HTML base reference URL of parent
        - url_data.url: unicode
          Fully qualified URL.
        - url_data.domain: unicode
          URL domain part.
        - url_data.checktime: int
          Number of seconds needed to check this link, default: zero.
        - url_data.dltime: int
          Number of seconds needed to download URL content, default: -1
        - url_data.size: int
          Size of downloaded URL content, default: -1
        - url_data.info: list of unicode
          Additional information about this URL.
        - url_data.line: int
          Line number of this URL at parent document, or -1
        - url_data.column: int
          Column number of this URL at parent document, or -1
        - url_data.page: int
          Page number of this URL at parent document, or -1
        - url_data.cache_url: unicode
          Cache url for this URL.
        - url_data.content_type: unicode
          MIME content type for URL content.
        - url_data.level: int
          Recursion level until reaching this URL from start URL
        - url_data.last_modified: datetime
          Last modification date of retrieved page (or None).
        """
        return dict(valid=self.valid,
          extern=self.extern[0],
          result=self.result,
          warnings=self.warnings[:],
          name=self.name or u"",
          title=self.get_title(),
          parent_url=self.parent_url or u"",
          base_ref=self.base_ref or u"",
          base_url=self.base_url or u"",
          url=self.url or u"",
          domain=(self.urlparts[1] if self.urlparts else u""),
          checktime=self.checktime,
          dltime=self.dltime,
          size=self.size,
          info=self.info,
          line=self.line,
          column=self.column,
          page=self.page,
          cache_url=self.cache_url,
          content_type=self.content_type,
          level=self.recursion_level,
          modified=self.modified,
        )

    def to_wire (self):
        """Return compact UrlData object with information from to_wire_dict().
        """
        return CompactUrlData(self.to_wire_dict())


urlDataAttr = [
    'valid',
    'extern',
    'result',
    'warnings',
    'name',
    'title',
    'parent_url',
    'base_ref',
    'base_url',
    'url',
    'domain',
    'checktime',
    'dltime',
    'size',
    'info',
    'modified',
    'line',
    'column',
    'page',
    'cache_url',
    'content_type',
    'level',
]

class CompactUrlData (object):
    """Store selected UrlData attributes in slots to minimize memory usage."""
    __slots__ = urlDataAttr

    def __init__(self, wired_url_data):
        '''Set all attributes according to the dictionnary wired_url_data'''
        for attr in urlDataAttr:
            setattr(self, attr, wired_url_data[attr])

########NEW FILE########
__FILENAME__ = cmdline
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Utility functions suitable for command line clients.
"""
from __future__ import print_function
import sys
import argparse
from . import checker, fileutil, strformat, plugins
from .director import console


class LCArgumentParser(argparse.ArgumentParser):
    """Custom argument parser to format help text."""

    def print_help(self, file=None):
        """Print a help message to stdout."""
        msg = console.encode(self.format_help())
        if fileutil.is_tty(file):
            strformat.paginate(msg)
        else:
            print(msg, file=file)


def print_version(exit_code=0):
    """Print the program version and exit."""
    console.print_version()
    sys.exit(exit_code)


def print_plugins(folders, exit_code=0):
    """Print available plugins and exit."""
    modules = plugins.get_plugin_modules(folders)
    pluginclasses = sorted(plugins.get_plugin_classes(modules), key=lambda x: x.__name__)

    for pluginclass in pluginclasses:
        print(pluginclass.__name__)
        doc = strformat.wrap(pluginclass.__doc__, 80)
        print(strformat.indent(doc))
        print()
    sys.exit(exit_code)


def print_usage (msg, exit_code=2):
    """Print a program msg text to stderr and exit."""
    program = sys.argv[0]
    print(_("Error: %(msg)s") % {"msg": msg}, file=console.stderr)
    print(_("Execute '%(program)s -h' for help") % {"program": program}, file=console.stderr)
    sys.exit(exit_code)


def aggregate_url (aggregate, url, err_exit_code=2):
    """Append given commandline URL to input queue."""
    get_url_from = checker.get_url_from
    url = checker.guess_url(url)
    url_data = get_url_from(url, 0, aggregate, extern=(0, 0))
    aggregate.urlqueue.put(url_data)

########NEW FILE########
__FILENAME__ = colorama
# These functions are part of the python-colorama module
# They have been adjusted slightly for LinkChecker
#
# Copyright: (C) 2010 Jonathan Hartley <tartley@tartley.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name(s) of the copyright holders nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


# from winbase.h
STDOUT = -11
STDERR = -12

from ctypes import (windll, byref, Structure, c_char, c_short, c_uint32,
  c_ushort, ArgumentError, WinError)

handles = {
    STDOUT: windll.kernel32.GetStdHandle(STDOUT),
    STDERR: windll.kernel32.GetStdHandle(STDERR),
}

SHORT = c_short
WORD = c_ushort
DWORD = c_uint32
TCHAR = c_char

class COORD(Structure):
    """struct in wincon.h"""
    _fields_ = [
        ('X', SHORT),
        ('Y', SHORT),
    ]

class  SMALL_RECT(Structure):
    """struct in wincon.h."""
    _fields_ = [
        ("Left", SHORT),
        ("Top", SHORT),
        ("Right", SHORT),
        ("Bottom", SHORT),
    ]

class CONSOLE_SCREEN_BUFFER_INFO(Structure):
    """struct in wincon.h."""
    _fields_ = [
        ("dwSize", COORD),
        ("dwCursorPosition", COORD),
        ("wAttributes", WORD),
        ("srWindow", SMALL_RECT),
        ("dwMaximumWindowSize", COORD),
    ]
    def __str__(self):
        """Get string representation of console screen buffer info."""
        return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (
            self.dwSize.Y, self.dwSize.X
            , self.dwCursorPosition.Y, self.dwCursorPosition.X
            , self.wAttributes
            , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right
            , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X
        )

def GetConsoleScreenBufferInfo(stream_id=STDOUT):
    """Get console screen buffer info object."""
    handle = handles[stream_id]
    csbi = CONSOLE_SCREEN_BUFFER_INFO()
    success = windll.kernel32.GetConsoleScreenBufferInfo(
        handle, byref(csbi))
    if not success:
        raise WinError()
    return csbi


def SetConsoleTextAttribute(stream_id, attrs):
    """Set a console text attribute."""
    handle = handles[stream_id]
    return windll.kernel32.SetConsoleTextAttribute(handle, attrs)


# from wincon.h
BLACK   = 0
BLUE    = 1
GREEN   = 2
CYAN    = 3
RED     = 4
MAGENTA = 5
YELLOW  = 6
GREY    = 7

# from wincon.h
NORMAL = 0x00 # dim text, dim background
BRIGHT = 0x08 # bright text, dim background

_default_foreground = None
_default_background = None
_default_style = None


def init():
    """Initialize foreground and background attributes."""
    global _default_foreground, _default_background, _default_style
    try:
        attrs = GetConsoleScreenBufferInfo().wAttributes
    except (ArgumentError, WindowsError):
        _default_foreground = GREY
        _default_background = BLACK
        _default_style = NORMAL
    else:
        _default_foreground = attrs & 7
        _default_background = (attrs >> 4) & 7
        _default_style = attrs & BRIGHT


def get_attrs(foreground, background, style):
    """Get foreground and background attributes."""
    return foreground + (background << 4) + style


def set_console(stream=STDOUT, foreground=None, background=None, style=None):
    """Set console foreground and background attributes."""
    if foreground is None:
        foreground = _default_foreground
    if background is None:
        background = _default_background
    if style is None:
        style = _default_style
    attrs = get_attrs(foreground, background, style)
    SetConsoleTextAttribute(stream, attrs)


def reset_console(stream=STDOUT):
    """Reset the console."""
    set_console(stream=stream)


def get_console_size():
    """Get the console size."""
    return GetConsoleScreenBufferInfo().dwSize

########NEW FILE########
__FILENAME__ = confparse
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Parse configuration files"""

import ConfigParser
import os
from .. import LinkCheckerError, get_link_pat, LOG_CHECK, log, fileutil, plugins, logconf


def read_multiline (value):
    """Helper function reading multiline values."""
    for line in value.splitlines():
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        yield line


class LCConfigParser (ConfigParser.RawConfigParser, object):
    """
    Parse a LinkChecker configuration file.
    """

    def __init__ (self, config):
        """Initialize configuration."""
        super(LCConfigParser, self).__init__()
        self.config = config

    def read (self, files):
        """Read settings from given config files.

        @raises: LinkCheckerError on syntax errors in the config file(s)
        """
        assert isinstance(files, list), "Invalid file list %r" % files
        try:
            self.read_ok = super(LCConfigParser, self).read(files)
            if len(self.read_ok) < len(files):
                failed_files = set(files) - set(self.read_ok)
                log.warn(LOG_CHECK, "Could not read configuration files %s.", failed_files)
            # Read all the configuration parameters from the given files.
            self.read_checking_config()
            self.read_authentication_config()
            self.read_filtering_config()
            self.read_output_config()
            self.read_plugin_config()
        except Exception as msg:
            raise LinkCheckerError(
              _("Error parsing configuration: %s") % unicode(msg))

    def read_string_option (self, section, option, allowempty=False):
        """Read a string option."""
        if self.has_option(section, option):
            value = self.get(section, option)
            if not allowempty and not value:
                raise LinkCheckerError(_("invalid empty value for %s: %s\n") % (option, value))
            self.config[option] = value

    def read_boolean_option(self, section, option):
        """Read a boolean option."""
        if self.has_option(section, option):
            self.config[option] = self.getboolean(section, option)

    def read_int_option (self, section, option, key=None, min=None, max=None):
        """Read an integer option."""
        if self.has_option(section, option):
            num = self.getint(section, option)
            if min is not None and num < min:
                raise LinkCheckerError(
                    _("invalid value for %s: %d must not be less than %d") % (option, num, min))
            if max is not None and num < max:
                raise LinkCheckerError(
                    _("invalid value for %s: %d must not be greater than %d") % (option, num, max))
            if key is None:
                key = option
            self.config[key] = num

    def read_output_config (self):
        """Read configuration options in section "output"."""
        section = "output"
        from ..logger import LoggerClasses
        for c in LoggerClasses:
            key = c.LoggerName
            if self.has_section(key):
                for opt in self.options(key):
                    self.config[key][opt] = self.get(key, opt)
                if self.has_option(key, 'parts'):
                    val = self.get(key, 'parts')
                    parts = [f.strip().lower() for f in val.split(',')]
                    self.config[key]['parts'] = parts
        self.read_boolean_option(section, "warnings")
        if self.has_option(section, "verbose"):
            if self.getboolean(section, "verbose"):
                self.config["verbose"] = True
                self.config["warnings"] = True
        if self.has_option(section, "quiet"):
            if self.getboolean(section, "quiet"):
                self.config['output'] = 'none'
                self.config['quiet'] = True
        if self.has_option(section, "debug"):
            val = self.get(section, "debug")
            parts = [f.strip().lower() for f in val.split(',')]
            logconf.set_debug(parts)
        self.read_boolean_option(section, "status")
        if self.has_option(section, "log"):
            val = self.get(section, "log").strip().lower()
            self.config['output'] = val
        if self.has_option(section, "fileoutput"):
            loggers = self.get(section, "fileoutput").split(",")
            # strip names from whitespace
            loggers = (x.strip().lower() for x in loggers)
            # no file output for the blacklist and none Logger
            from ..logger import LoggerNames
            loggers = (x for x in loggers if x in LoggerNames and
                       x not in ("blacklist", "none"))
            for val in loggers:
                output = self.config.logger_new(val, fileoutput=1)
                self.config['fileoutput'].append(output)

    def read_checking_config (self):
        """Read configuration options in section "checking"."""
        section = "checking"
        self.read_int_option(section, "threads", min=-1)
        self.config['threads'] = max(0, self.config['threads'])
        self.read_int_option(section, "timeout", min=1)
        self.read_int_option(section, "aborttimeout", min=1)
        self.read_int_option(section, "recursionlevel", min=-1)
        self.read_string_option(section, "nntpserver")
        self.read_string_option(section, "useragent")
        self.read_int_option(section, "maxrequestspersecond", min=1)
        self.read_int_option(section, "maxnumurls", min=0)
        self.read_int_option(section, "maxfilesizeparse", min=1)
        self.read_int_option(section, "maxfilesizedownload", min=1)
        if self.has_option(section, "allowedschemes"):
            self.config['allowedschemes'] = [x.strip().lower() for x in \
                 self.get(section, 'allowedschemes').split(',')]
        self.read_boolean_option(section, "debugmemory")
        self.read_string_option(section, "cookiefile")
        self.read_string_option(section, "localwebroot")
        try:
            self.read_boolean_option(section, "sslverify")
        except ValueError:
            self.read_string_option(section, "sslverify")
        self.read_int_option(section, "maxrunseconds", min=0)

    def read_authentication_config (self):
        """Read configuration options in section "authentication"."""
        section = "authentication"
        password_fields = []
        if self.has_option(section, "entry"):
            for val in read_multiline(self.get(section, "entry")):
                auth = val.split()
                if len(auth) == 3:
                    self.config.add_auth(pattern=auth[0], user=auth[1],
                                         password=auth[2])
                    password_fields.append("entry/%s/%s" % (auth[0], auth[1]))
                elif len(auth) == 2:
                    self.config.add_auth(pattern=auth[0], user=auth[1])
                else:
                    raise LinkCheckerError(
                       _("missing auth part in entry %(val)r") % {"val": val})
        # read login URL and field names
        if self.has_option(section, "loginurl"):
            val = self.get(section, "loginurl").strip()
            if not (val.lower().startswith("http:") or
                    val.lower().startswith("https:")):
                raise LinkCheckerError(_("invalid login URL `%s'. Only " \
                  "HTTP and HTTPS URLs are supported.") % val)
            self.config["loginurl"] = val
        self.read_string_option(section, "loginuserfield")
        self.read_string_option(section, "loginpasswordfield")
        # read login extra fields
        if self.has_option(section, "loginextrafields"):
            for val in read_multiline(self.get(section, "loginextrafields")):
                name, value = val.split(":", 1)
                self.config["loginextrafields"][name] = value
        self.check_password_readable(section, password_fields)

    def check_password_readable(self, section, fields):
        """Check if there is a readable configuration file and print a warning."""
        if not fields:
            return
        # The information which of the  configuration files
        # included which option is not available. To avoid false positives,
        # a warning is only printed if exactly one file has been read.
        if len(self.read_ok) != 1:
            return
        fn = self.read_ok[0]
        if fileutil.is_accessable_by_others(fn):
            log.warn(LOG_CHECK, "The configuration file %s contains password information (in section [%s] and options %s) and the file is readable by others. Please make the file only readable by you.", fn, section, fields)
            if os.name == 'posix':
                log.warn(LOG_CHECK, _("For example execute 'chmod go-rw %s'.") % fn)
            elif os.name == 'nt':
                log.warn(LOG_CHECK, _("See http://support.microsoft.com/kb/308419 for more info on setting file permissions."))

    def read_filtering_config (self):
        """
        Read configuration options in section "filtering".
        """
        section = "filtering"
        if self.has_option(section, "ignorewarnings"):
            self.config['ignorewarnings'] = [f.strip().lower() for f in \
                 self.get(section, 'ignorewarnings').split(',')]
        if self.has_option(section, "ignore"):
            for line in read_multiline(self.get(section, "ignore")):
                pat = get_link_pat(line, strict=1)
                self.config["externlinks"].append(pat)
        if self.has_option(section, "nofollow"):
            for line in read_multiline(self.get(section, "nofollow")):
                pat = get_link_pat(line, strict=0)
                self.config["externlinks"].append(pat)
        if self.has_option(section, "internlinks"):
            pat = get_link_pat(self.get(section, "internlinks"))
            self.config["internlinks"].append(pat)
        self.read_boolean_option(section, "checkextern")

    def read_plugin_config(self):
        """Read plugin-specific configuration values."""
        folders = self.config["pluginfolders"]
        modules = plugins.get_plugin_modules(folders)
        for pluginclass in plugins.get_plugin_classes(modules):
            section = pluginclass.__name__
            if self.has_section(section):
                self.config["enabledplugins"].append(section)
                self.config[section] = pluginclass.read_config(self)

########NEW FILE########
__FILENAME__ = containers
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Special container classes.
"""

from collections import namedtuple

class AttrDict (dict):
    """Dictionary allowing attribute access to its elements if they
    are valid attribute names and not already existing methods."""

    def __getattr__ (self, name):
        """Return attribute name from dict."""
        return self[name]


class ListDict (dict):
    """A dictionary whose iterators reflect the order in which elements
    were added.
    """

    def __init__ (self):
        """Initialize sorted key list."""
        super(ListDict, self).__init__()
        # sorted list of keys
        self._keys = []

    def setdefault (self, key, *args):
        """Remember key order if key not found."""
        if key not in self:
            self._keys.append(key)
        return super(ListDict, self).setdefault(key, *args)

    def __setitem__ (self, key, value):
        """Add key,value to dict, append key to sorted list."""
        if key not in self:
            self._keys.append(key)
        super(ListDict, self).__setitem__(key, value)

    def __delitem__ (self, key):
        """Remove key from dict."""
        self._keys.remove(key)
        super(ListDict, self).__delitem__(key)

    def pop (self, key):
        """Remove key from dict and return value."""
        if key in self._keys:
            self._keys.remove(key)
        super(ListDict, self).pop(key)

    def popitem (self):
        """Remove oldest key from dict and return item."""
        if self._keys:
            k = self._keys[0]
            v = self[k]
            del self[k]
            return (k, v)
        raise KeyError("popitem() on empty dictionary")

    def values (self):
        """Return sorted list of values."""
        return [self[k] for k in self._keys]

    def items (self):
        """Return sorted list of items."""
        return [(k, self[k]) for k in self._keys]

    def keys (self):
        """Return sorted list of keys."""
        return self._keys[:]

    def itervalues (self):
        """Return iterator over sorted values."""
        for k in self._keys:
            yield self[k]

    def iteritems (self):
        """Return iterator over sorted items."""
        for k in self._keys:
            yield (k, self[k])

    def iterkeys (self):
        """Return iterator over sorted keys."""
        return iter(self._keys)

    def clear (self):
        """Remove all dict entries."""
        self._keys = []
        super(ListDict, self).clear()

    def get_true (self, key, default):
        """Return default element if key is not in the dict, or if self[key]
        evaluates to False. Useful for example if value is None, but
        default value should be an empty string.
        """
        if key not in self or not self[key]:
            return default
        return self[key]


class CaselessDict (dict):
    """A dictionary ignoring the case of keys (which must be strings)."""

    def __getitem__ (self, key):
        """Return lowercase key item."""
        assert isinstance(key, basestring)
        return dict.__getitem__(self, key.lower())

    def __delitem__ (self, key):
        """Remove lowercase key item."""
        assert isinstance(key, basestring)
        return dict.__delitem__(self, key.lower())

    def __setitem__ (self, key, value):
        """Set lowercase key item."""
        assert isinstance(key, basestring)
        dict.__setitem__(self, key.lower(), value)

    def __contains__ (self, key):
        """Check lowercase key item."""
        assert isinstance(key, basestring)
        return dict.__contains__(self, key.lower())

    def get (self, key, def_val=None):
        """Return lowercase key value."""
        assert isinstance(key, basestring)
        return dict.get(self, key.lower(), def_val)

    def setdefault (self, key, *args):
        """Set lowercase key value and return."""
        assert isinstance(key, basestring)
        return dict.setdefault(self, key.lower(), *args)

    def update (self, other):
        """Update this dict with lowercase key from other dict"""
        for k, v in other.items():
            dict.__setitem__(self, k.lower(), v)

    def fromkeys (cls, iterable, value=None):
        """Construct new caseless dict from given data."""
        d = cls()
        for k in iterable:
            dict.__setitem__(d, k.lower(), value)
        return d
    fromkeys = classmethod(fromkeys)

    def pop (self, key, *args):
        """Remove lowercase key from dict and return value."""
        assert isinstance(key, basestring)
        return dict.pop(self, key.lower(), *args)


class CaselessSortedDict (CaselessDict):
    """Caseless dictionary with sorted keys."""

    def keys (self):
        """Return sorted key list."""
        return sorted(super(CaselessSortedDict, self).keys())

    def items (self):
        """Return sorted item list."""
        return [(x, self[x]) for x in self.keys()]

    def iteritems (self):
        """Return sorted item iterator."""
        return ((x, self[x]) for x in self.keys())


class LFUCache (dict):
    """Limited cache which purges least frequently used items."""

    def __init__ (self, size=1000):
        """Initialize internal LFU cache."""
        super(LFUCache, self).__init__()
        if size < 1:
            raise ValueError("invalid cache size %d" % size)
        self.size = size

    def __setitem__ (self, key, val):
        """Store given key/value."""
        if key in self:
            # store value, do not increase number of uses
            super(LFUCache, self).__getitem__(key)[1] = val
        else:
            super(LFUCache, self).__setitem__(key, [0, val])
            # check for size limit
            if len(self) > self.size:
                self.shrink()

    def shrink (self):
        """Shrink ca. 5% of entries."""
        trim = int(0.05*len(self))
        if trim:
            items = super(LFUCache, self).items()
            # sorting function for items
            keyfunc = lambda x: x[1][0]
            values = sorted(items, key=keyfunc)
            for item in values[0:trim]:
                del self[item[0]]

    def __getitem__ (self, key):
        """Update key usage and return value."""
        entry = super(LFUCache, self).__getitem__(key)
        entry[0] += 1
        return entry[1]

    def uses (self, key):
        """Get number of uses for given key (without increasing the number of
        uses)"""
        return super(LFUCache, self).__getitem__(key)[0]

    def get (self, key, def_val=None):
        """Update key usage if found and return value, else return default."""
        if key in self:
            return self[key]
        return def_val

    def setdefault (self, key, def_val=None):
        """Update key usage if found and return value, else set and return
        default."""
        if key in self:
            return self[key]
        self[key] = def_val
        return def_val

    def items (self):
        """Return list of items, not updating usage count."""
        return [(key, value[1]) for key, value in super(LFUCache, self).items()]

    def iteritems (self):
        """Return iterator of items, not updating usage count."""
        for key, value in super(LFUCache, self).items():
            yield (key, value[1])

    def values (self):
        """Return list of values, not updating usage count."""
        return [value[1] for value in super(LFUCache, self).values()]

    def itervalues (self):
        """Return iterator of values, not updating usage count."""
        for value in super(LFUCache, self).values():
            yield value[1]

    def popitem (self):
        """Remove and return an item."""
        key, value = super(LFUCache, self).popitem()
        return (key, value[1])

    def pop (self):
        """Remove and return a value."""
        value = super(LFUCache, self).pop()
        return value[1]


def enum (*names):
    """Return an enum datatype instance from given list of keyword names.
    The enum values are zero-based integers.

    >>> Status = enum('open', 'pending', 'closed')
    >>> Status.open
    0
    >>> Status.pending
    1
    >>> Status.closed
    2
    """
    return namedtuple('Enum', ' '.join(names))(*range(len(names)))

########NEW FILE########
__FILENAME__ = cookies
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Parsing of cookies.
"""

import cookielib
import httplib
import requests
from cStringIO import StringIO


def from_file (filename):
    """Parse cookie data from a text file in HTTP header format.

    @return: list of tuples (headers, scheme, host, path)
    """
    entries = []
    with open(filename) as fd:
        lines = []
        for line in fd.readlines():
            line = line.rstrip()
            if not line:
                if lines:
                    entries.append(from_headers("\r\n".join(lines)))
                lines = []
            else:
                lines.append(line)
        if lines:
            entries.append(from_headers("\r\n".join(lines)))
        return entries


def from_headers (strheader):
    """Parse cookie data from a string in HTTP header (RFC 2616) format.

    @return: list of cookies
    @raises: ValueError for incomplete or invalid data
    """
    res = []
    fp = StringIO(strheader)
    headers = httplib.HTTPMessage(fp, seekable=True)
    if "Host" not in headers:
        raise ValueError("Required header 'Host:' missing")
    host = headers["Host"]
    path= headers.get("Path", "/")
    for header in headers.getallmatchingheaders("Set-Cookie"):
        headervalue = header.split(':', 1)[1]
        for pairs in cookielib.split_header_words([headervalue]):
            for name, value in pairs:
                cookie = requests.cookies.create_cookie(name, value,
                    domain=host, path=path)
                res.append(cookie)
    return res

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Simple decorators (usable in Python >= 2.4).

Example:

@synchronized(thread.allocate_lock())
def f ():
    "Synchronized function"
    print("i am synchronized:", f, f.__doc__)

@deprecated
def g ():
    "this function is deprecated"
    pass

@notimplemented
def h ():
    "todo"
    pass

"""
from __future__ import print_function
import warnings
import signal
import os
import sys
import time


def update_func_meta (fake_func, real_func):
    """Set meta information (eg. __doc__) of fake function to that
    of the real function.
    @return fake_func
    """
    fake_func.__module__ = real_func.__module__
    fake_func.__name__ = real_func.__name__
    fake_func.__doc__ = real_func.__doc__
    fake_func.__dict__.update(real_func.__dict__)
    return fake_func


def deprecated (func):
    """A decorator which can be used to mark functions as deprecated.
    It emits a warning when the function is called."""
    def newfunc (*args, **kwargs):
        """Print deprecated warning and execute original function."""
        warnings.warn("Call to deprecated function %s." % func.__name__,
                      category=DeprecationWarning)
        return func(*args, **kwargs)
    return update_func_meta(newfunc, func)


def signal_handler (signal_number):
    """From http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/410666

    A decorator to set the specified function as handler for a signal.
    This function is the 'outer' decorator, called with only the
    (non-function) arguments.
    If signal_number is not a valid signal (for example signal.SIGN),
    no handler is set.
    """
    # create the 'real' decorator which takes only a function as an argument
    def newfunc (function):
        """Register function as signal handler."""
        # note: actually the kill(2) function uses the signal number of 0
        # for a special case, but for signal(2) only positive integers
        # are allowed
        is_valid_signal = 0 < signal_number < signal.NSIG
        if is_valid_signal and os.name == 'posix':
            signal.signal(signal_number, function)
        return function
    return newfunc


def synchronize (lock, func, log_duration_secs=0):
    """Return synchronized function acquiring the given lock."""
    def newfunc (*args, **kwargs):
        """Execute function synchronized."""
        t = time.time()
        with lock:
            duration = time.time() - t
            if duration > log_duration_secs > 0:
                print("WARN:", func.__name__, "locking took %0.2f seconds" % duration, file=sys.stderr)
            return func(*args, **kwargs)
    return update_func_meta(newfunc, func)


def synchronized (lock):
    """A decorator calling a function with aqcuired lock."""
    return lambda func: synchronize(lock, func)


def notimplemented (func):
    """Raises a NotImplementedError if the function is called."""
    def newfunc (*args, **kwargs):
        """Raise NotImplementedError"""
        co = func.func_code
        attrs = (co.co_name, co.co_filename, co.co_firstlineno)
        raise NotImplementedError("function %s at %s:%d is not implemented" % attrs)
    return update_func_meta(newfunc, func)


def timeit (func, log, limit):
    """Print execution time of the function. For quick'n'dirty profiling."""

    def newfunc (*args, **kwargs):
        """Execute function and print execution time."""
        t = time.time()
        res = func(*args, **kwargs)
        duration = time.time() - t
        if duration > limit:
            print(func.__name__, "took %0.2f seconds" % duration, file=log)
            print(args, file=log)
            print(kwargs, file=log)
        return res
    return update_func_meta(newfunc, func)


def timed (log=sys.stderr, limit=2.0):
    """Decorator to run a function with timing info."""
    return lambda func: timeit(func, log, limit)


class memoized (object):
    """Decorator that caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned, and
    not re-evaluated."""

    def __init__(self, func):
        """Store function and initialize the cache."""
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        """Lookup and return cached result if found. Else call stored
        function with given arguments."""
        try:
            return self.cache[args]
        except KeyError:
            self.cache[args] = value = self.func(*args)
            return value
        except TypeError:
            # uncachable -- for instance, passing a list as an argument.
            # Better to not cache than to blow up entirely.
            return self.func(*args)

    def __repr__(self):
        """Return the function's docstring."""
        return self.func.__doc__


class curried (object):
    """Decorator that returns a function that keeps returning functions
    until all arguments are supplied; then the original function is
    evaluated."""

    def __init__(self, func, *a):
        """Store function and arguments."""
        self.func = func
        self.args = a

    def __call__(self, *a):
        """If all arguments function arguments are supplied, call it.
        Else return another curried object."""
        args = self.args + a
        if len(args) < self.func.func_code.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)

########NEW FILE########
__FILENAME__ = aggregator
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Aggregate needed object instances for checker threads.
"""
import threading
import thread
import requests
import time
import random
from .. import log, LOG_CHECK, strformat, cookies
from ..decorators import synchronized
from ..cache import urlqueue
from . import logger, status, checker, interrupt


_threads_lock = threading.RLock()
_hosts_lock = threading.RLock()
_downloadedbytes_lock = threading.RLock()

def new_request_session(config):
    """Create a new request session."""
    session = requests.Session()
    session.max_redirects = config["maxhttpredirects"]
    # XXX proxies
    if config["cookiefile"]:
        for cookie in cookies.from_file(config["cookiefile"]):
            session.cookies = requests.cookies.merge_cookies(session.cookies, cookie)
    return session


class Aggregate (object):
    """Store thread-safe data collections for checker threads."""

    def __init__ (self, config, urlqueue, robots_txt, plugin_manager,
                  result_cache):
        """Store given link checking objects."""
        self.config = config
        self.urlqueue = urlqueue
        self.logger = logger.Logger(config)
        self.threads = []
        self.request_sessions = {}
        self.robots_txt = robots_txt
        self.plugin_manager = plugin_manager
        self.result_cache = result_cache
        self.times = {}
        requests_per_second = config["maxrequestspersecond"]
        self.wait_time_min = 1.0 / requests_per_second
        self.wait_time_max = max(self.wait_time_min + 0.5, 0.5)
        self.downloaded_bytes = 0

    @synchronized(_threads_lock)
    def start_threads (self):
        """Spawn threads for URL checking and status printing."""
        if self.config["status"]:
            t = status.Status(self, self.config["status_wait_seconds"])
            t.start()
            self.threads.append(t)
        if self.config["maxrunseconds"]:
            t = interrupt.Interrupt(self.config["maxrunseconds"])
            t.start()
            self.threads.append(t)
        num = self.config["threads"]
        if num > 0:
            for dummy in range(num):
                t = checker.Checker(self.urlqueue, self.logger, self.add_request_session)
                self.threads.append(t)
                t.start()
        else:
            self.request_sessions[thread.get_ident()] = new_request_session(self.config)
            checker.check_urls(self.urlqueue, self.logger)

    @synchronized(_threads_lock)
    def add_request_session(self):
        """Add a request session for current thread."""
        session = new_request_session(self.config)
        self.request_sessions[thread.get_ident()] = session

    @synchronized(_threads_lock)
    def get_request_session(self):
        """Get the request session for current thread."""
        return self.request_sessions[thread.get_ident()]

    @synchronized(_hosts_lock)
    def wait_for_host(self, host):
        """Throttle requests to one host."""
        t = time.time()
        if host in self.times:
            due_time = self.times[host]
            if due_time > t:
                wait = due_time - t
                time.sleep(wait)
                t = time.time()
        wait_time = random.uniform(self.wait_time_min, self.wait_time_max)
        self.times[host] = t + wait_time

    @synchronized(_threads_lock)
    def print_active_threads (self):
        """Log all currently active threads."""
        debug = log.is_debug(LOG_CHECK)
        if debug:
            first = True
            for name in self.get_check_threads():
                if first:
                    log.info(LOG_CHECK, _("These URLs are still active:"))
                    first = False
                log.info(LOG_CHECK, name[12:])
        args = dict(
            num=len([x for x in self.threads if x.getName().startswith("CheckThread-")]),
            timeout=strformat.strduration_long(self.config["aborttimeout"]),
        )
        log.info(LOG_CHECK, _("%(num)d URLs are still active. After a timeout of %(timeout)s the active URLs will stop.") % args)

    @synchronized(_threads_lock)
    def get_check_threads(self):
        """Return iterator of checker threads."""
        for t in self.threads:
            name = t.getName()
            if name.startswith("CheckThread-"):
                yield name

    def cancel (self):
        """Empty the URL queue."""
        self.urlqueue.do_shutdown()

    def abort (self):
        """Print still-active URLs and empty the URL queue."""
        self.print_active_threads()
        self.cancel()
        timeout = self.config["aborttimeout"]
        try:
            self.urlqueue.join(timeout=timeout)
        except urlqueue.Timeout:
            log.warn(LOG_CHECK, "Abort timed out after %d seconds, stopping application." % timeout)
            raise KeyboardInterrupt()

    @synchronized(_threads_lock)
    def remove_stopped_threads (self):
        """Remove the stopped threads from the internal thread list."""
        self.threads = [t for t in self.threads if t.is_alive()]

    @synchronized(_threads_lock)
    def finish (self):
        """Wait for checker threads to finish."""
        if not self.urlqueue.empty():
            # This happens when all checker threads died.
            self.cancel()
        for t in self.threads:
            t.stop()

    @synchronized(_threads_lock)
    def is_finished (self):
        """Determine if checking is finished."""
        self.remove_stopped_threads()
        return self.urlqueue.empty() and not self.threads

    @synchronized(_downloadedbytes_lock)
    def add_downloaded_bytes(self, numbytes):
        """Add to number of downloaded bytes."""
        self.downloaded_bytes += numbytes

    def end_log_output(self, **kwargs):
        """Print ending output to log."""
        kwargs.update(dict(
            downloaded_bytes=self.downloaded_bytes,
            num_urls = len(self.result_cache),
        ))
        self.logger.end_log_output(**kwargs)

########NEW FILE########
__FILENAME__ = checker
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
URL checking functions.
"""
import copy
import time
from . import task
from ..cache import urlqueue
from .. import parser

# Interval in which each check thread looks if it's stopped.
QUEUE_POLL_INTERVALL_SECS = 1.0


def check_urls (urlqueue, logger):
    """Check URLs without threading."""
    while not urlqueue.empty():
        url_data = urlqueue.get()
        try:
            check_url(url_data, logger)
        finally:
            urlqueue.task_done(url_data)


def check_url(url_data, logger):
    """Check a single URL with logging."""
    if url_data.has_result:
        logger.log_url(url_data.to_wire())
    else:
        cache = url_data.aggregate.result_cache
        key = url_data.cache_url
        result = cache.get_result(key)
        if result is None:
            # check
            check_start = time.time()
            try:
                url_data.check()
                do_parse = url_data.check_content()
                url_data.checktime = time.time() - check_start
                # Add result to cache
                result = url_data.to_wire()
                cache.add_result(key, result)
                for alias in url_data.aliases:
                    # redirect aliases
                    cache.add_result(alias, result)
                # parse content recursively
                if do_parse:
                    parser.parse_url(url_data)
            finally:
                # close/release possible open connection
                url_data.close_connection()
        else:
            # copy data from cache and adjust it
            result = copy.copy(result)
            result.parent_url = url_data.parent_url
            result.base_ref = url_data.base_ref or u""
            result.base_url = url_data.base_url or u""
            result.line = url_data.line
            result.column = url_data.column
            result.level = url_data.recursion_level
            result.name = url_data.name
        logger.log_url(result)


class Checker(task.LoggedCheckedTask):
    """URL check thread."""

    def __init__ (self, urlqueue, logger, add_request_session):
        """Store URL queue and logger."""
        super(Checker, self).__init__(logger)
        self.urlqueue = urlqueue
        self.origname = self.getName()
        self.add_request_session = add_request_session

    def run_checked (self):
        """Check URLs in the queue."""
        # construct per-thread HTTP/S requests session
        self.add_request_session()
        while not self.stopped(0):
            self.check_url()

    def check_url (self):
        """Try to get URL data from queue and check it."""
        try:
            url_data = self.urlqueue.get(timeout=QUEUE_POLL_INTERVALL_SECS)
            if url_data is not None:
                try:
                    self.check_url_data(url_data)
                finally:
                    self.urlqueue.task_done(url_data)
                self.setName(self.origname)
        except urlqueue.Empty:
            pass
        except Exception:
            self.internal_error()

    def check_url_data (self, url_data):
        """Check one URL data instance."""
        if url_data.url is None:
            url = ""
        else:
            url = url_data.url.encode("ascii", "replace")
        self.setName("CheckThread-%s" % url)
        check_url(url_data, self.logger)

########NEW FILE########
__FILENAME__ = console
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Helpers for console output.
"""
from __future__ import print_function
import sys
import os
import time
from .. import i18n, configuration, strformat, better_exchook2

# Output to stdout and stderr, encoded with the default encoding
stderr = i18n.get_encoded_writer(out=sys.stderr)
stdout = i18n.get_encoded_writer()


def encode (text):
    """Encode text with default encoding if its Unicode."""
    if isinstance(text, unicode):
        return text.encode(i18n.default_encoding, 'ignore')
    return text


class StatusLogger (object):
    """Standard status logger. Default output is stderr."""

    def __init__ (self, fd=stderr):
        """Save file descriptor for logging."""
        self.fd = fd

    def log_status (self, checked, in_progress, queue, duration, num_urls):
        """Write status message to file descriptor."""
        msg = _n("%2d thread active", "%2d threads active", in_progress) % \
          in_progress
        self.write(u"%s, " % msg)
        msg = _n("%5d link queued", "%5d links queued", queue) % queue
        self.write(u"%s, " % msg)
        msg = _n("%4d link", "%4d links", checked) % checked
        self.write(u"%s" % msg)
        msg = _n("%3d URL", "%3d URLs", num_urls) % num_urls
        self.write(u" in %s checked, " % msg)
        msg = _("runtime %s") % strformat.strduration_long(duration)
        self.writeln(msg)
        self.flush()

    def write (self, msg):
        """Write message to file descriptor."""
        self.fd.write(msg)

    def writeln (self, msg):
        """Write status message and line break to file descriptor."""
        self.fd.write(u"%s%s" % (msg, unicode(os.linesep)))

    def flush (self):
        """Flush file descriptor."""
        self.fd.flush()


def internal_error (out=stderr, etype=None, evalue=None, tb=None):
    """Print internal error message (output defaults to stderr)."""
    print(os.linesep, file=out)
    print(_("""********** Oops, I did it again. *************

You have found an internal error in LinkChecker. Please write a bug report
at %s
and include the following information:
- the URL or file you are testing
- the system information below

When using the commandline client:
- your commandline arguments and any custom configuration files.
- the output of a debug run with option "-Dall"

Not disclosing some of the information above due to privacy reasons is ok.
I will try to help you nonetheless, but you have to give me something
I can work with ;) .
""") % configuration.SupportUrl, file=out)
    if etype is None:
        etype = sys.exc_info()[0]
    if evalue is None:
        evalue = sys.exc_info()[1]
    if tb is None:
        tb = sys.exc_info()[2]
    better_exchook2.better_exchook(etype, evalue, tb, out=out)
    print_app_info(out=out)
    print_proxy_info(out=out)
    print_locale_info(out=out)
    print(os.linesep,
      _("******** LinkChecker internal error, over and out ********"), file=out)


def print_env_info (key, out=stderr):
    """If given environment key is defined, print it out."""
    value = os.getenv(key)
    if value is not None:
        print(key, "=", repr(value), file=out)


def print_proxy_info (out=stderr):
    """Print proxy info."""
    for key in ("http_proxy", "ftp_proxy", "no_proxy"):
        print_env_info(key, out=out)


def print_locale_info (out=stderr):
    """Print locale info."""
    for key in ("LANGUAGE", "LC_ALL", "LC_CTYPE", "LANG"):
        print_env_info(key, out=out)
    print(_("Default locale:"), i18n.get_locale(), file=out)

# Environment variables influencing the interpreter execution
# See python(1) man page.
PYTHON_ENV_VARS = (
    'PYTHONHOME',
    'PYTHONPATH',
    'PYTHONSTARTUP',
    'PYTHONY2K',
    'PYTHONOPTIMIZE',
    'PYTHONDEBUG',
    'PYTHONDONTWRITEBYTECODE',
    'PYTHONINSPECT',
    'PYTHONIOENCODING',
    'PYTHONNOUSERSITE',
    'PYTHONUNBUFFERED',
    'PYTHONVERBOSE',
    'PYTHONWARNINGS',
    'PYTHONHASHSEED',
)
def print_app_info (out=stderr):
    """Print system and application info (output defaults to stderr)."""
    print(_("System info:"), file=out)
    print(configuration.App, file=out)
    print(_("Released on:"), configuration.ReleaseDate, file=out)
    print(_("Python %(version)s on %(platform)s") %
                    {"version": sys.version, "platform": sys.platform}, file=out)
    for key in PYTHON_ENV_VARS:
        print_env_info(key, out=out)
    for line in configuration.get_modules_info():
        print(line, file=out)
    stime = strformat.strtime(time.time())
    print(_("Local time:"), stime, file=out)
    print(_("sys.argv:"), sys.argv, file=out)


def print_version (out=stdout):
    """Print the program version (output defaults to stdout)."""
    print(configuration.App, _("released"),
          configuration.ReleaseDate, file=out)
    print(configuration.Copyright, file=out)

########NEW FILE########
__FILENAME__ = interrupt
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Status message handling"""
import time
from . import task
from .. import log, LOG_CHECK, strformat


class Interrupt (task.CheckedTask):
    """Thread that raises KeyboardInterrupt after a specified duration.
    This gives us a portable SIGALRM implementation.
    The duration is checked every 5 seconds.
    """
    WaitSeconds = 5

    def __init__ (self, duration):
        """Initialize the task.
        @param duration: raise KeyboardInterrupt after given number of seconds
        @ptype duration: int
        """
        super(Interrupt, self).__init__()
        self.duration = duration

    def run_checked (self):
        """Wait and raise KeyboardInterrupt after."""
        self.start_time = time.time()
        self.setName("Interrupt")
        while not self.stopped(self.WaitSeconds):
            duration = time.time() - self.start_time
            if duration > self.duration:
                log.warn(LOG_CHECK, "Interrupt after %s" % strformat.strduration_long(duration))
                raise KeyboardInterrupt()

########NEW FILE########
__FILENAME__ = logger
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Logger for aggregator instances"""
import threading
import thread
from ..decorators import synchronized
_lock = threading.Lock()


class Logger (object):
    """Thread safe multi-logger class used by aggregator instances."""

    def __init__ (self, config):
        """Initialize basic logging variables."""
        self.loggers = [config['logger']]
        self.loggers.extend(config['fileoutput'])
        self.verbose = config["verbose"]
        self.warnings = config["warnings"]

    def start_log_output (self):
        """
        Start output of all configured loggers.
        """
        for logger in self.loggers:
            logger.start_output()

    def end_log_output (self, **kwargs):
        """
        End output of all configured loggers.
        """
        for logger in self.loggers:
            logger.end_output(**kwargs)

    def do_print (self, url_data):
        """Determine if URL entry should be logged or not."""
        if self.verbose:
            return True
        if self.warnings and url_data.warnings:
            return True
        return not url_data.valid

    @synchronized(_lock)
    def log_url (self, url_data):
        """Send new url to all configured loggers."""
        self.check_active_loggers()
        do_print = self.do_print(url_data)
        # Only send a transport object to the loggers, not the complete
        # object instance.
        for log in self.loggers:
            log.log_filter_url(url_data, do_print)

    @synchronized(_lock)
    def log_internal_error (self):
        """Document that an internal error occurred."""
        for logger in self.loggers:
            logger.log_internal_error()

    def check_active_loggers(self):
        """Check if all loggers are deactivated due to I/O errors."""
        for logger in self.loggers:
            if logger.is_active:
                break
        else:
            thread.interrupt_main()

########NEW FILE########
__FILENAME__ = status
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Status message handling"""
import time
from . import task


class Status (task.LoggedCheckedTask):
    """Thread that gathers and logs the status periodically."""

    def __init__ (self, aggregator, wait_seconds):
        """Initialize the status logger task.
        @param urlqueue: the URL queue
        @ptype urlqueue: Urlqueue
        @param logger: the logger object to inform about status
        @ptype logger: console.StatusLogger
        @param wait_seconds: interval in seconds to report status
        @ptype wait_seconds: int
        """
        logger = aggregator.config.status_logger
        super(Status, self).__init__(logger)
        self.aggregator = aggregator
        self.wait_seconds = wait_seconds
        assert self.wait_seconds >= 1

    def run_checked (self):
        """Print periodic status messages."""
        self.start_time = time.time()
        self.setName("Status")
        # the first status should be after a second
        wait_seconds = 1
        first_wait = True
        while not self.stopped(wait_seconds):
            self.log_status()
            if first_wait:
                wait_seconds = self.wait_seconds
                first_wait = False

    def log_status (self):
        """Log a status message."""
        duration = time.time() - self.start_time
        checked, in_progress, queue = self.aggregator.urlqueue.status()
        num_urls = len(self.aggregator.result_cache)
        self.logger.log_status(checked, in_progress, queue, duration, num_urls)

########NEW FILE########
__FILENAME__ = task
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import thread
from ..decorators import notimplemented
from .. import threader
from . import console


class CheckedTask (threader.StoppableThread):
    """Stoppable URL check task, handling error conditions while running."""

    def run (self):
        """Handle keyboard interrupt and other errors."""
        try:
            self.run_checked()
        except KeyboardInterrupt:
            thread.interrupt_main()
        except Exception:
            self.internal_error()

    @notimplemented
    def run_checked (self):
        """Overload in subclass."""
        pass

    @notimplemented
    def internal_error (self):
        """Overload in subclass."""
        pass


class LoggedCheckedTask (CheckedTask):
    """URL check task with a logger instance and internal error handling."""

    def __init__ (self, logger):
        """Initialize super instance and store given logger."""
        super(CheckedTask, self).__init__()
        self.logger = logger

    def internal_error (self):
        """Log an internal error on console and the logger."""
        console.internal_error()
        self.logger.log_internal_error()

########NEW FILE########
__FILENAME__ = dummy
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Dummy objects.
"""

class Dummy (object):
    """A dummy object ignores all access to it. Useful for testing."""

    def __init__ (self, *args, **kwargs):
        """Return None"""
        pass

    def __call__ (self, *args, **kwargs):
        """Return self."""
        return self

    def __getattr__ (self, name):
        """Return self."""
        return self

    def __setattr__ (self, name, value):
        """Return None"""
        pass

    def __delattr__ (self, name):
        """Return None"""
        pass

    def __str__ (self):
        """Return 'dummy'"""
        return "dummy"

    def __repr__ (self):
        """Return '<dummy>'"""
        return "<dummy>"

    def __unicode__ (self):
        """Return u'dummy'"""
        return u"dummy"

    def __len__ (self):
        """Return zero"""
        return 0

    def __getitem__ (self, key):
        """Return self"""
        return self

    def __setitem__ (self, key, value):
        """Return None"""
        pass

    def __delitem__ (self, key):
        """Return None"""
        pass

    def __contains__ (self, key):
        """Return False"""
        return False


def dummy (*args, **kwargs):
    """Ignore any positional or keyword arguments, return None."""
    pass

########NEW FILE########
__FILENAME__ = fileutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
File and path utilities.
"""

import os
import locale
import stat
import fnmatch
import tempfile
import importlib
from distutils.spawn import find_executable

from .decorators import memoized

def write_file (filename, content, backup=False, callback=None):
    """Overwrite a possibly existing file with new content. Do this
    in a manner that does not leave truncated or broken files behind.
    @param filename: name of file to write
    @type filename: string
    @param content: file content to write
    @type content: string
    @param backup: if backup file should be left
    @type backup: bool
    @param callback: non-default storage function
    @type callback: None or function taking two parameters (fileobj, content)
    """
    # first write in a temp file
    f = file(filename+".tmp", 'wb')
    if callback is None:
        f.write(content)
    else:
        callback(f, content)
    f.close()
    # move orig file to backup
    if os.path.exists(filename):
        os.rename(filename, filename+".bak")
    # move temp file to orig
    os.rename(filename+".tmp", filename)
    # remove backup
    if not backup and os.path.exists(filename+".bak"):
        os.remove(filename+".bak")


def has_module (name, without_error=True):
    """Test if given module can be imported.
    @param without_error: True if module must not throw any errors when importing
    @return: flag if import is successful
    @rtype: bool
    """
    try:
        importlib.import_module(name)
        return True
    except ImportError:
        return False
    except Exception:
        # some modules raise errors when intitializing
        return not without_error


class GlobDirectoryWalker (object):
    """A forward iterator that traverses a directory tree."""

    def __init__ (self, directory, pattern="*"):
        """Set start directory and pattern matcher."""
        self.stack = [directory]
        self.pattern = pattern
        self.files = []
        self.index = 0

    def __getitem__ (self, index):
        """Search for next filename."""
        while True:
            try:
                filename = self.files[self.index]
                self.index += 1
            except IndexError:
                # Pop next directory from stack. This effectively
                # stops the iteration if stack is empty.
                self.directory = self.stack.pop()
                self.files = os.listdir(self.directory)
                self.index = 0
            else:
                # got a filename
                fullname = os.path.join(self.directory, filename)
                if os.path.isdir(fullname) and not os.path.islink(fullname):
                    self.stack.append(fullname)
                if fnmatch.fnmatch(filename, self.pattern):
                    return fullname

# alias
rglob = GlobDirectoryWalker


class Buffer (object):
    """Holds buffered data"""

    def __init__ (self, empty=''):
        """Initialize buffer."""
        self.empty = self.buf = empty
        self.tmpbuf = []
        self.pos = 0

    def __len__ (self):
        """Buffer length."""
        return self.pos

    def write (self, data):
        """Write data to buffer."""
        self.tmpbuf.append(data)
        self.pos += len(data)

    def flush (self, overlap=0):
        """Flush buffered data and return it."""
        self.buf += self.empty.join(self.tmpbuf)
        self.tmpbuf = []
        if overlap and overlap < self.pos:
            data = self.buf[:-overlap]
            self.buf = self.buf[-overlap:]
        else:
            data = self.buf
            self.buf = self.empty
        return data


def get_mtime (filename):
    """Return modification time of filename or zero on errors."""
    try:
        return os.path.getmtime(filename)
    except os.error:
        return 0


def get_size (filename):
    """Return file size in Bytes, or -1 on error."""
    try:
        return os.path.getsize(filename)
    except os.error:
        return -1


# http://developer.gnome.org/doc/API/2.0/glib/glib-running.html
if "G_FILENAME_ENCODING" in os.environ:
    FSCODING = os.environ["G_FILENAME_ENCODING"].split(",")[0]
    if FSCODING == "@locale":
        FSCODING = locale.getpreferredencoding()
elif "G_BROKEN_FILENAMES" in os.environ:
    FSCODING = locale.getpreferredencoding()
else:
    FSCODING = "utf-8"

def pathencode (path):
    """Encode a path string with the platform file system encoding."""
    if isinstance(path, unicode) and not os.path.supports_unicode_filenames:
        path = path.encode(FSCODING, "replace")
    return path


# cache for modified check {absolute filename -> mtime}
_mtime_cache = {}
def has_changed (filename):
    """Check if filename has changed since the last check. If this
    is the first check, assume the file is changed."""
    key = os.path.abspath(filename)
    mtime = get_mtime(key)
    if key not in _mtime_cache:
        _mtime_cache[key] = mtime
        return True
    return mtime > _mtime_cache[key]


def get_temp_file (mode='r', **kwargs):
    """Return tuple (open file object, filename) pointing to a temporary
    file."""
    fd, filename = tempfile.mkstemp(**kwargs)
    return os.fdopen(fd, mode), filename


def is_tty (fp):
    """Check if is a file object pointing to a TTY."""
    return (hasattr(fp, "isatty") and fp.isatty())


@memoized
def is_readable(filename):
    """Check if file is a regular file and is readable."""
    return os.path.isfile(filename) and os.access(filename, os.R_OK)


def is_accessable_by_others(filename):
    """Check if file is group or world accessable."""
    mode = os.stat(filename)[stat.ST_MODE]
    return mode & (stat.S_IRWXG | stat.S_IRWXO)


def is_writable_by_others(filename):
    """Check if file or directory is world writable."""
    mode = os.stat(filename)[stat.ST_MODE]
    return mode & stat.S_IWOTH


@memoized
def is_writable(filename):
    """Check if
    - the file is a regular file and is writable, or
    - the file does not exist and its parent directory exists and is
      writable
    """
    if not os.path.exists(filename):
        parentdir = os.path.dirname(filename)
        return os.path.isdir(parentdir) and os.access(parentdir, os.W_OK)
    return os.path.isfile(filename) and os.access(filename, os.W_OK)

########NEW FILE########
__FILENAME__ = ftpparse
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Python implementation of a part of Dan Bernstein's ftpparse library.

See also http://cr.yp.to/ftpparse.html
"""

months = ("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep",
          "oct", "nov", "dec")
def ismonth (txt):
    """Check if given text is a month name."""
    return txt.lower() in months


def ftpparse (line):
    """Parse a FTP list line into a dictionary with attributes:
    name - name of file (string)
    trycwd - False if cwd is definitely pointless, True otherwise
    tryretr - False if retr is definitely pointless, True otherwise

    If the line has no file information, None is returned
    """
    if len(line) < 2:
        # an empty name in EPLF, with no info, could be 2 chars
        return None
    info = dict(name=None, trycwd=False, tryretr=False)

    # EPLF format
    # http://pobox.com/~djb/proto/eplf.html
    # "+i8388621.29609,m824255902,/,\tdev"
    # "+i8388621.44468,m839956783,r,s10376,\tRFCEPLF"
    if line[0] == '+':
        if '\t' in line:
            flags, name = line.split('\t', 1)
            info['name'] = name
            flags = flags.split(',')
            info['trycwd'] = '/' in flags
            info['tryretr'] = 'r' in flags
        return info

    # UNIX-style listing, without inum and without blocks
    # "-rw-r--r--   1 root     other        531 Jan 29 03:26 README"
    # "dr-xr-xr-x   2 root     other        512 Apr  8  1994 etc"
    # "dr-xr-xr-x   2 root     512 Apr  8  1994 etc"
    # "lrwxrwxrwx   1 root     other          7 Jan 25 00:17 bin -> usr/bin"
    # Also produced by Microsoft's FTP servers for Windows:
    # "----------   1 owner    group         1803128 Jul 10 10:18 ls-lR.Z"
    # "d---------   1 owner    group               0 May  9 19:45 Softlib"
    # Also WFTPD for MSDOS:
    # "-rwxrwxrwx   1 noone    nogroup      322 Aug 19  1996 message.ftp"
    # Also NetWare:
    # "d [R----F--] supervisor            512       Jan 16 18:53    login"
    # "- [R----F--] rhesus             214059       Oct 20 15:27    cx.exe"
    # Also NetPresenz for the Mac:
    # "-------r--         326  1391972  1392298 Nov 22  1995 MegaPhone.sit"
    # "drwxrwxr-x               folder        2 May 10  1996 network"
    if line[0] in 'bcdlps-':
        if line[0] == 'd':
            info['trycwd'] = True
        if line[0] == '-':
            info['tryretr'] = True
        if line[0] == 'l':
            info['trycwd'] = info['tryretr'] = True
        parts = line.split()
        if len(parts) < 7:
            return None
        del parts[0] # skip permissions
        if parts[0] != 'folder':
            del parts[0] # skip nlink
        del parts[0] # skip uid
        del parts[0] # skip gid or size
        if not ismonth(parts[0]):
            del parts[0] # skip size
        if not ismonth(parts[0]):
            return None
        del parts[0] # skip month
        del parts[0] # skip day
        if not parts:
            return None
        del parts[0] # skip year or time
        name = " ".join(parts)
        # resolve links
        if line[0] == 'l' and ' -> ' in name:
            name = name.split(' -> ', 1)[1]
        # eliminate extra NetWare spaces
        if line[1] in ' [' and name.startswith('   '):
            name = name[3:]
        info["name"] = name
        return info

    # MultiNet (some spaces removed from examples)
    # "00README.TXT;1      2 30-DEC-1996 17:44 [SYSTEM] (RWED,RWED,RE,RE)"
    # "CORE.DIR;1          1  8-SEP-1996 16:09 [SYSTEM] (RWE,RWE,RE,RE)"
    # and non-MutliNet VMS:
    # "CII-MANUAL.TEX;1  213/216  29-JAN-1996 03:33:12  [ANONYMOU,ANONYMOUS]   (RWED,RWED,,)"
    i = line.find(';')
    if i != -1:
        name = line[:i]
        if name.endswith(".DIR"):
            name = name[:-4]
            info["trycwd"] = True
        else:
            info["tryretr"] = True
        info["name"] = name
        return info

    # MSDOS format
    # 04-27-00  09:09PM       <DIR>          licensed
    # 07-18-00  10:16AM       <DIR>          pub
    # 04-14-00  03:47PM                  589 readme.htm
    if line[0].isdigit():
        parts = line.split()
        if len(parts) != 4:
            return None
        info['name'] = parts[3]
        if parts[2][0] == '<':
            info['trycwd'] = True
        else:
            info['tryretr'] = True
        return info

    # Some useless lines, safely ignored:
    # "Total of 11 Files, 10966 Blocks." (VMS)
    # "total 14786" (UNIX)
    # "DISK$ANONFTP:[ANONYMOUS]" (VMS)
    # "Directory DISK$PCSA:[ANONYM]" (VMS)
    return None

########NEW FILE########
__FILENAME__ = checker
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2008-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
from PyQt4 import QtCore
from .. import director


class CheckerThread (QtCore.QThread):
    """Separate checker thread."""

    def __init__ (self, parent=None):
        """Reset check variables."""
        super(CheckerThread, self).__init__(parent)
        self.aggregate = None

    def check (self, aggregate):
        """Set check variables and start the thread."""
        self.aggregate = aggregate
        # setup the thread and call run()
        self.start()

    def cancel (self):
        """Reset check variables and set stop flag."""
        if self.aggregate is not None:
            aggregate = self.aggregate
            self.aggregate = None
            aggregate.cancel()

    def run (self):
        """Start checking."""
        assert self.aggregate.config["threads"] > 0
        director.check_urls(self.aggregate)

########NEW FILE########
__FILENAME__ = contextmenu
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
from PyQt4 import QtGui
import os
import urlparse
from linkcheck.checker.fileurl import get_os_filename

class ContextMenu (QtGui.QMenu):
    """Show context menu."""

    def __init__ (self, parent=None):
        """Add actions to context menu."""
        super(ContextMenu, self).__init__(parent)
        self.addAction(parent.actionViewOnline)
        self.addAction(parent.actionCopyToClipboard)
        self.addAction(parent.actionViewParentOnline)
        self.addAction(parent.actionViewParentSource)

    def enableFromItem (self, item):
        """Enable context menu actions depending on the item content."""
        parent = self.parentWidget()
        # data is an instance of CompactUrlData
        data = item.url_data
        # enable view online actions
        parent.actionViewOnline.setEnabled(bool(data.url))
        parent.actionViewParentOnline.setEnabled(bool(data.parent_url))
        # enable view source actions
        enable_parent_url_source = self.can_view_parent_source(data)
        parent.actionViewParentSource.setEnabled(enable_parent_url_source)

    def can_view_parent_source (self, url_data):
        """Determine if parent URL source can be retrieved."""
        if not url_data.valid:
            return False
        parent = url_data.parent_url
        if not parent:
            return False
        # Directory contents are dynamically generated, so it makes
        # no sense in viewing/editing them.
        if parent.startswith(u"file:"):
            path = urlparse.urlsplit(parent)[2]
            return not os.path.isdir(get_os_filename(path))
        if parent.startswith((u"ftp:", u"ftps:")):
            path = urlparse.urlsplit(parent)[2]
            return bool(path) and not path.endswith(u'/')
        # Only HTTP left
        return parent.startswith((u"http:", u"https:"))

########NEW FILE########
__FILENAME__ = debug
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from PyQt4 import QtCore, QtGui
from .linkchecker_ui_debug import Ui_DebugDialog


class LinkCheckerDebug (QtGui.QDialog, Ui_DebugDialog):
    """Show debug text."""

    log_msg_signal = QtCore.pyqtSignal(str)

    def __init__ (self, parent=None):
        """Setup the debug message dialog."""
        super(LinkCheckerDebug, self).__init__(parent)
        self.setupUi(self)
        font = QtGui.QFont("Consolas", 11)
        font.setFixedPitch(True)
        self.textEdit.document().setDefaultFont(font)
        self.log_msg_signal.connect(self.textEdit.appendPlainText)
        self.reset()

    def reset (self):
        """Clear all debug info."""
        self.textEdit.clear()

    def getText (self):
        """Get debug info as string."""
        return self.textEdit.toPlainText()

########NEW FILE########
__FILENAME__ = editor
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import urlparse
from PyQt4 import QtGui, QtCore
from .linkchecker_ui_editor import Ui_EditorDialog
from ..checker.fileurl import get_os_filename
try:
    from .editor_qsci import ContentTypeLexers, Editor
except ImportError:
    from .editor_qt import ContentTypeLexers, Editor

class EditorWindow (QtGui.QDialog, Ui_EditorDialog):
    """Editor window."""

    # emitted after successful save
    saved = QtCore.pyqtSignal(str)
    # emitted after successful load
    loaded = QtCore.pyqtSignal(str)

    def __init__ (self, parent=None):
        """Initialize the editor widget."""
        super(EditorWindow, self).__init__(parent)
        self.setupUi(self)
        # filename used for saving
        self.filename = None
        # the Scintilla editor widget
        self.editor = Editor(parent=self.frame)
        layout = QtGui.QVBoxLayout(self.frame)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.editor)
        # for debugging
        #self.setText(("1234567890"*8) + "\n<html><head>\n<title>x</title>\n</head>\n")
        #lexer = Qsci.QsciLexerHTML()
        #lexer.setFont(self.editor.font())
        #self.editor.setLexer(lexer)
        #self.editor.setCursorPosition(1, 1)
        #self.show()

    def setContentType (self, content_type):
        """Choose a lexer according to given content type."""
        lexerclass = ContentTypeLexers.get(content_type.lower())
        self.editor.highlight(lexerclass)

    def setText (self, text, line=1, col=1):
        """Set editor text and jump to given line and column."""
        self.editor.setText(text)
        self.editor.setCursorPosition(line-1, col-1)
        self.editor.setModified(False)

    def setUrl (self, url):
        """If URL is a file:// URL, store the filename of it as base
        directory for the "save as" dialog."""
        self.basedir = ""
        if url and url.startswith("file://"):
            urlparts = urlparse.urlsplit(url)
            path = get_os_filename(urlparts[2])
            if os.path.exists(path):
                self.basedir = path

    @QtCore.pyqtSlot()
    def on_actionSave_triggered (self):
        """Save changed editor contents."""
        if self.editor.isModified() or not self.filename:
            self.save()

    def closeEvent (self, e=None):
        """Save settings and remove registered logging handler"""
        if self.editor.isModified():
            # ask if user wants to save
            if self.wants_save():
                if self.save():
                    e.accept()
                else:
                    # saving error or user canceled
                    e.ignore()
            else:
                # discard changes
                e.accept()
        else:
            # unchanged
            e.accept()

    def wants_save (self):
        """Ask user if he wants to save changes. Return True if user
        wants to save, else False."""
        dialog = QtGui.QMessageBox(parent=self)
        dialog.setIcon(QtGui.QMessageBox.Question)
        dialog.setWindowTitle(_("Save file?"))
        dialog.setText(_("The document has been modified."))
        dialog.setInformativeText(_("Do you want to save your changes?"))
        dialog.setStandardButtons(QtGui.QMessageBox.Save |
                                  QtGui.QMessageBox.Discard)
        dialog.setDefaultButton(QtGui.QMessageBox.Save)
        return dialog.exec_() == QtGui.QMessageBox.Save

    def save (self):
        """Save editor contents to file."""
        if not self.filename:
            title = _("Save File As")
            res = QtGui.QFileDialog.getSaveFileName(self, title, self.basedir)
            if not res:
                # user canceled
                return
            self.filename = res
            self.setWindowTitle(self.filename)
        else:
            if not os.path.isfile(self.filename):
                return
            if not os.access(self.filename, os.W_OK):
                return
        fh = None
        saved = False
        try:
            try:
                fh = QtCore.QFile(self.filename)
                if not fh.open(QtCore.QIODevice.WriteOnly):
                    raise IOError(fh.errorString())
                stream = QtCore.QTextStream(fh)
                stream.setCodec("UTF-8")
                stream << self.editor.text()
                self.editor.setModified(False)
                saved = True
            except (IOError, OSError) as e:
                err = QtGui.QMessageBox(self)
                err.setText(str(e))
                err.exec_()
        finally:
            if fh is not None:
                fh.close()
        if saved:
            self.saved.emit(self.filename)
        return saved

    def load (self, filename):
        """Load editor contents from file."""
        if not os.path.isfile(filename):
            return
        if not os.access(filename, os.R_OK):
            return
        self.filename = filename
        if not os.access(filename, os.W_OK):
            title = u"%s (%s)" % (self.filename, _(u"readonly"))
        else:
            title = self.filename
        self.setWindowTitle(title)
        fh = None
        loaded = False
        try:
            try:
                fh = QtCore.QFile(self.filename)
                if not fh.open(QtCore.QIODevice.ReadOnly):
                    raise IOError(fh.errorString())
                stream = QtCore.QTextStream(fh)
                stream.setCodec("UTF-8")
                self.setText(stream.readAll())
                loaded = True
            except (IOError, OSError) as e:
                err = QtGui.QMessageBox(self)
                err.setText(str(e))
                err.exec_()
        finally:
            if fh is not None:
                fh.close()
        if loaded:
            self.loaded.emit(self.filename)

########NEW FILE########
__FILENAME__ = editor_qsci
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Text editor implemented with QScintilla
"""
from PyQt4 import QtGui, Qsci

# Map MIME type to Scintilla lexer class
ContentTypeLexers = {
    "application/x-shellscript": Qsci.QsciLexerBash,
    "application/x-sh": Qsci.QsciLexerBash,
    "application/x-msdos-program": Qsci.QsciLexerBatch,
    #"": Qsci.QsciLexerCMake,
    "text/x-c++src": Qsci.QsciLexerCPP,
    "text/css": Qsci.QsciLexerCSS,
    #"": Qsci.QsciLexerCSharp,
    #"": Qsci.QsciLexerCustom,
    "text/x-dsrc": Qsci.QsciLexerD,
    "text/x-diff": Qsci.QsciLexerDiff,
    #"": Qsci.QsciLexerFortran,
    #"": Qsci.QsciLexerFortran77,
    "text/html": Qsci.QsciLexerHTML,
    #"": Qsci.QsciLexerIDL,
    "text/x-java": Qsci.QsciLexerJava,
    "application/javascript": Qsci.QsciLexerJavaScript,
    #"": Qsci.QsciLexerLua,
    "text/x-makefile": Qsci.QsciLexerMakefile,
    #"": Qsci.QsciLexerPOV,
    "text/x-pascal": Qsci.QsciLexerPascal,
    "text/x-perl": Qsci.QsciLexerPerl,
    "application/postscript": Qsci.QsciLexerPostScript,
    "text/plain+ini": Qsci.QsciLexerProperties,
    "text/x-python": Qsci.QsciLexerPython,
    "application/x-ruby": Qsci.QsciLexerRuby,
    #"": Qsci.QsciLexerSQL,
    #"": Qsci.QsciLexerSpice,
    "application/x-tcl": Qsci.QsciLexerTCL,
    "application/x-latex": Qsci.QsciLexerTeX,
    #"": Qsci.QsciLexerVHDL,
    #"": Qsci.QsciLexerVerilog,
    "application/xml": Qsci.QsciLexerXML,
    #"": Qsci.QsciLexerYAML,
}

class Editor (Qsci.QsciScintilla):
    """Configured QsciScintilla widget."""

    def __init__ (self, parent=None):
        """Set Scintilla options for font, colors, etc."""
        super(Editor, self).__init__(parent)
        # Use Courier font with fixed width
        font = QtGui.QFont("Consolas", 11)
        font.setFixedPitch(True)

        # Set the default font of the editor
        # and take the same font for line numbers
        self.setFont(font)
        self.setMarginsFont(font)

        # line number margin for 4 digits (plus 2px extra space)
        margin = QtGui.QFontMetrics(font).width("0"*4)+2
        # Display line numbers, margin 0 is for line numbers
        self.setMarginWidth(0, margin)
        self.setMarginLineNumbers(0, True)

        # Show whitespace to help detect whitespace errors
        self.setWhitespaceVisibility(True)

        # Use boxes as folding visual
        self.setFolding(self.BoxedTreeFoldStyle)

        # Braces matching
        self.setBraceMatching(self.SloppyBraceMatch)

        # Editing line color
        self.setCaretLineVisible(True)
        self.setCaretLineBackgroundColor(QtGui.QColor("#e5e5cb"))

        # line numbers margin colors
        self.setMarginsBackgroundColor(QtGui.QColor("#e5e5e5"))
        self.setMarginsForegroundColor(QtGui.QColor("#333333"))

        # folding margin colors (foreground,background)
        self.setFoldMarginColors(QtGui.QColor("#f5f5dc"),
                                 QtGui.QColor("#aaaaaa"))

    def highlight (self, lexerclass):
        """Set syntax highlighter."""
        if lexerclass:
            lexer = lexerclass()
            lexer.setFont(self.font())
            self.setLexer(lexer)
        else:
            # use no styling
            self.setLexer()

########NEW FILE########
__FILENAME__ = editor_qt
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Text editor implemented with Qt
"""
from PyQt4 import QtGui, QtCore
from . import syntax

# Map MIME type to QSyntaxHighlighter class
ContentTypeLexers = {
    "text/html": syntax.HtmlHighlighter,
    "application/xml": syntax.XmlHighlighter,
    "text/plain+ini": syntax.IniHighlighter,
}

class LineNumberArea (QtGui.QWidget):
    """Display line numbers."""

    def sizeHint (self):
        """Return calculated width for line number area."""
        return QtCore.QSize(self.parentWidget().lineNumberAreaWidth(), 0)

    def paintEvent (self, event):
        """Call paint method of parent widget."""
        self.parentWidget().lineNumberAreaPaintEvent(event)


class Editor (QtGui.QPlainTextEdit):
    """Qt editor with line numbering."""

    def __init__ (self, parent):
        """Initialize line numbering."""
        super(Editor, self).__init__(parent)
        font = QtGui.QFont("Consolas", 11)
        font.setFixedPitch(True)
        self.document().setDefaultFont(font)
        self.lineNumberArea = LineNumberArea(self)
        self.blockCountChanged.connect(self.updateLineNumberAreaWidth)
        self.updateRequest.connect(self.updateLineNumberArea)
        self.cursorPositionChanged.connect(self.highlightCurrentLine)
        self.updateLineNumberAreaWidth(0)
        self.highlightCurrentLine()

    def highlight (self, lexerclass):
        """Set syntax highlighter."""
        if lexerclass:
            self.lexer = lexerclass(self.document())
        else:
            self.lexer = None

    def setText (self, text):
        """Set editor text."""
        return self.setPlainText(text)

    def text (self):
        """Return editor text."""
        return self.toPlainText()

    def setModified (self, flag):
        """Set modified flag of underlying document."""
        return self.document().setModified(flag)

    def isModified (self):
        """Return modified flag of underlying document."""
        return self.document().isModified()

    def setCursorPosition (self, line, column=0):
        """Move cursor to given line and column. Line counting starts
        with zero."""
        block = self.document().findBlockByNumber(line)
        if block.isValid():
            cursor = QtGui.QTextCursor(block)
            if column > 0:
                cursor.movePosition(QtGui.QTextCursor.Right,
                                    QtGui.QTextCursor.MoveAnchor, column)
            self.setTextCursor(cursor)
            self.centerCursor()

    def lineNumberAreaPaintEvent (self, event):
        """Paint line numbers."""
        painter = QtGui.QPainter(self.lineNumberArea)
        painter.fillRect(event.rect(), QtCore.Qt.lightGray)
        block = self.firstVisibleBlock()
        blockNumber = block.blockNumber()
        top =  self.blockBoundingGeometry(block).translated(self.contentOffset()).top()
        bottom = top + self.blockBoundingRect(block).height()
        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(blockNumber + 1)
                painter.setPen(QtCore.Qt.black)
                painter.drawText(0, top, self.lineNumberArea.width(),
                                 self.fontMetrics().height(),
                                 QtCore.Qt.AlignRight, number)
            block = block.next()
            top = bottom
            bottom = top + self.blockBoundingRect(block).height()
            blockNumber += 1

    def lineNumberAreaWidth (self):
        """Calculate line number area width."""
        digits = max(1, len(str(self.blockCount())))
        onecharwidth = self.fontMetrics().width('9')
        space = 3 + onecharwidth * digits
        return space

    def resizeEvent (self, event):
        """Resize line number area together with editor."""
        super(Editor, self).resizeEvent(event)
        cr = self.contentsRect()
        self.lineNumberArea.setGeometry(QtCore.QRect(cr.left(), cr.top(),
                                  self.lineNumberAreaWidth(), cr.height()))

    def updateLineNumberAreaWidth (self, newBlockCount):
        """Update the line number area width."""
        self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

    def highlightCurrentLine (self):
        """Highlight the current line."""
        extraSelections = []
        if not self.isReadOnly():
            selection = QtGui.QTextEdit.ExtraSelection()
            lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)
            selection.format.setBackground(lineColor)
            selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extraSelections.append(selection)
        self.setExtraSelections(extraSelections)

    def updateLineNumberArea (self, rect, dy):
        """Update the line number area."""
        if dy:
            self.lineNumberArea.scroll(0, dy)
        else:
            self.lineNumberArea.update(0, rect.y(),
                self.lineNumberArea.width(), rect.height())
        if rect.contains(self.viewport().rect()):
            self.updateLineNumberAreaWidth(0)

########NEW FILE########
__FILENAME__ = help
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from .. import configuration
from PyQt4 import QtCore, QtGui, QtHelp


class HelpWindow (QtGui.QDialog):
    """A custom help display dialog."""

    def __init__ (self, parent, qhcpath):
        """Initialize dialog and load qhc help project from given path."""
        super(HelpWindow, self).__init__(parent)
        self.engine = QtHelp.QHelpEngine(qhcpath, self)
        self.engine.setupData()
        self.setWindowTitle(u"%s Help" % configuration.AppName)
        self.build_ui()

    def build_ui (self):
        """Build UI for the help window."""
        splitter = QtGui.QSplitter()
        splitter.setOrientation(QtCore.Qt.Vertical)
        self.browser = HelpBrowser(splitter, self.engine)
        self.tree = self.engine.contentWidget()
        self.tree.setExpandsOnDoubleClick(False)
        self.tree.linkActivated.connect(self.browser.setSource)
        splitter.addWidget(self.tree)
        splitter.addWidget(self.browser)
        splitter.setSizes((70, 530))
        hlayout = QtGui.QHBoxLayout()
        hlayout.addWidget(splitter)
        self.setLayout(hlayout)
        self.resize(800, 600)

    def showDocumentation (self, url):
        """Show given URL in help browser."""
        self.tree.expandAll()
        self.browser.setSource(url)
        self.show()


class HelpBrowser (QtGui.QTextBrowser):
    """A QTextBrowser that can handle qthelp:// URLs."""

    def __init__ (self, parent, engine):
        """Initialize and store given HelpEngine instance."""
        super(HelpBrowser, self).__init__(parent)
        self.engine = engine

    def setSource (self, url):
        """Open HTTP URLs in external browser, else call base class
        implementation."""
        if url.scheme() == "http":
            import webbrowser
            webbrowser.open(str(url.toString()))
        else:
            QtGui.QTextBrowser.setSource(self, url)

    def loadResource (self, rtype, url):
        """Handle qthelp:// URLs, load content from help engine."""
        if url.scheme() == "qthelp":
            return QtCore.QVariant(self.engine.fileData(url))
        return QtGui.QTextBrowser.loadResource(self, rtype, url)

########NEW FILE########
__FILENAME__ = lineedit
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from PyQt4 import QtCore, QtGui

class LineEdit (QtGui.QLineEdit):
    """A line edit widget displaying a clear button if there is some text
    and a down-arrow button displaying a list of strings (eg. recent
    documents)."""

    def __init__ (self, parent=None):
        """Initialize buttons and size settings."""
        super(LineEdit, self).__init__(parent)
        self.listmodel = None
        self.listview = None
        self.setup_clear_button()
        self.setup_list_button()
        self.setup_size_metrics()

    def setup_clear_button (self):
        """Initialize the clear button."""
        self.clearButton = QtGui.QToolButton(self)
        pixmap = QtGui.QPixmap(":/icons/clear.png")
        self.clearButton.setIcon(QtGui.QIcon(pixmap))
        self.clearButton.setIconSize(pixmap.size())
        self.clearButton.setCursor(QtCore.Qt.ArrowCursor)
        style = "QToolButton { border: none; padding: 0px; }"
        self.clearButton.setStyleSheet(style)
        self.clearButton.hide()
        self.clearButton.clicked.connect(self.clear)
        self.textChanged.connect(self.updateCloseButton)

    def setup_list_button (self):
        """Initialize the dropdown list button."""
        self.listButton = QtGui.QToolButton(self)
        pixmap = QtGui.QPixmap(":/icons/arrow_down.png")
        self.listButton.setIcon(QtGui.QIcon(pixmap))
        self.listButton.setIconSize(pixmap.size())
        self.listButton.setCursor(QtCore.Qt.ArrowCursor)
        style = "QToolButton { border: none; padding: 0px; }"
        self.listButton.setStyleSheet(style)
        self.listButton.hide()
        self.listButton.clicked.connect(self.toggle_list)

    def setModel (self, model):
        """Set list model for list of recent documents."""
        self.listmodel = model
        self.listview = QtGui.QListView()
        self.listview.setModel(model)
        self.listview.setWindowFlags(QtCore.Qt.Popup)
        self.listview.setFocusPolicy(QtCore.Qt.NoFocus)
        self.listview.setFocusProxy(self)
        self.listview.setMouseTracking(True)
        self.listview.setUniformItemSizes(True)
        self.listview.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.listview.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
        self.listview.setFrameStyle(QtGui.QFrame.Box | QtGui.QFrame.Plain)
        self.listview.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.listview.installEventFilter(self)
        self.listview.clicked.connect(self.selectRecentDocument)
        self.listview.hide()
        updatefunc = lambda parent, start, end: self.updateListButton
        self.listmodel.rowsInserted.connect(updatefunc)
        self.listmodel.rowsRemoved.connect(updatefunc)
        self.updateListButton()

    def eventFilter(self, obj, event):
        """Handle events from the listview popup."""
        if obj != self.listview:
            return False

        if event.type() == QtCore.QEvent.MouseButtonPress:
            self.listview.hide()
            self.setFocus()
            return True

        if event.type() == QtCore.QEvent.KeyPress:
            consumed = False
            key = event.key()
            if key in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return):
                self.doneCompletion()
                consumed = True
            elif key == QtCore.Qt.Key_Escape:
                self.setFocus()
                self.listview.hide()
                consumed = True
            elif key in (QtCore.Qt.Key_Up, QtCore.Qt.Key_Down,
                         QtCore.Qt.Key_Home, QtCore.Qt.Key_End,
                         QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown):
                pass
            else:
                self.setFocus()
                self.event(event)
                self.listview.hide()
            return consumed
        return False

    def selectRecentDocument (self, index):
        """Select recent document text after click on the list view."""
        self.listview.hide()
        item = self.listmodel.data(index)
        text = unicode(item.toString())
        self.setText(text)

    def setup_size_metrics (self):
        """Set widget size including the buttons."""
        frameWidth = self.style().pixelMetric(QtGui.QStyle.PM_DefaultFrameWidth)
        padding_right = self.clearButton.sizeHint().width() + frameWidth + 1
        padding_left = self.listButton.sizeHint().width() + frameWidth + 1
        style = "QLineEdit { padding-left: %dpx; padding-right: %dpx } " % (
          padding_left, padding_right)
        self.setStyleSheet(style)
        # minimum width
        minSize = self.minimumSizeHint()
        buttonWidth = padding_left + padding_right
        minWidth = max(minSize.width(), buttonWidth)
        # minimum height
        buttonHeight = max(self.clearButton.sizeHint().height(),
                           self.listButton.sizeHint().height())
        minHeight = max(minSize.height(), buttonHeight + frameWidth*2)
        # set minimum size
        self.setMinimumSize(minWidth, minHeight)

    def resizeEvent (self, event):
        """Move the buttons due to resize event."""
        frameWidth = self.style().pixelMetric(QtGui.QStyle.PM_DefaultFrameWidth)
        bottom = self.rect().y() + self.rect().height()
        # clear button
        sizeHint = self.clearButton.sizeHint()
        x = self.rect().right() - frameWidth - sizeHint.width()
        y = (bottom - sizeHint.height()) / 2
        self.clearButton.move(x,y)
        # list button
        sizeHint = self.listButton.sizeHint()
        # add one to x and y since the button icon is a little off
        x = self.rect().left() + frameWidth + 1
        y = (bottom - sizeHint.height()) / 2 + 1
        self.listButton.move(x,y)

    def updateListButton (self):
        """Show or hide button for list of documents."""
        self.listButton.setVisible(bool(self.listmodel.rowCount()))

    def updateCloseButton (self, text):
        """Only display the clear button if there is some text."""
        self.clearButton.setVisible(bool(text))

    def toggle_list (self):
        """Show or hide list of documents."""
        if self.listview.isHidden():
            self.listview.adjustSize()
            point = self.mapToGlobal(QtCore.QPoint(0, self.height()))
            self.listview.move(point)
            self.listview.setFocus()
            self.listview.show()
        else:
            self.listview.hide()

    def addMenuEntries (self, menu):
        """Add browser bookmark actions to menu."""
        name = _("Insert %(browser)s bookmark file")
        if find_firefox():
            action = menu.addAction(name % {"browser": u"Firefox"})
            action.triggered.connect(lambda: self.setText(find_firefox()))
        if find_chrome():
            action = menu.addAction(name % {"browser": u"Google Chrome"})
            action.triggered.connect(lambda: self.setText(find_chrome()))
        if find_chromium():
            action = menu.addAction(name % {"browser": u"Chromium"})
            action.triggered.connect(lambda: self.setText(find_chromium()))
        if find_opera():
            action = menu.addAction(name % {"browser": u"Opera"})
            action.triggered.connect(lambda: self.setText(find_opera()))
        if find_safari():
            action = menu.addAction(name % {"browser": u"Safari"})
            action.triggered.connect(lambda: self.setText(find_safari()))

    def contextMenuEvent (self, event):
        """Handle context menu event."""
        menu = self.createStandardContextMenu()
        self.addMenuEntries(menu)
        menu.exec_(event.globalPos())


def find_firefox ():
    """Return Firefox bookmark filename or empty string if not found."""
    from ..bookmarks.firefox import find_bookmark_file
    return find_bookmark_file()


def find_chrome ():
    """Return Google Chrome bookmark filename or empty string if not found."""
    from ..bookmarks.chrome import find_bookmark_file
    return find_bookmark_file()


def find_chromium ():
    """Return Chromium bookmark filename or empty string if not found."""
    from ..bookmarks.chromium import find_bookmark_file
    return find_bookmark_file()


def find_opera ():
    """Return Opera bookmark filename or empty string if not found."""
    from ..bookmarks.opera import find_bookmark_file
    return find_bookmark_file()


def find_safari ():
    """Return Safari bookmark filename or empty string if not found."""
    from ..bookmarks.safari import find_bookmark_file
    return find_bookmark_file()

########NEW FILE########
__FILENAME__ = linkchecker_rc
# -*- coding: utf-8 -*-

# Resource object code
#
# Created: Wed May 11 00:26:36 2011
#      by: The Resource Compiler for PyQt (Qt v4.7.2)
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore

qt_resource_data = "\
\x00\x00\x01\xbc\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x0c\x00\x00\x00\x0c\x08\x06\x00\x00\x00\x56\x75\x5c\xe7\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x06\x62\x4b\x47\x44\x00\xff\x00\xff\x00\xff\xa0\xbd\xa7\x93\x00\
\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0d\x61\x00\x00\x0d\x3a\x01\
\x65\x6b\xe6\xb1\x00\x00\x00\x07\x74\x49\x4d\x45\x07\xdb\x05\x0a\
\x16\x19\x20\xab\xb5\x7f\x4a\x00\x00\x00\x19\x74\x45\x58\x74\x43\
\x6f\x6d\x6d\x65\x6e\x74\x00\x43\x72\x65\x61\x74\x65\x64\x20\x77\
\x69\x74\x68\x20\x47\x49\x4d\x50\x57\x81\x0e\x17\x00\x00\x01\x17\
\x49\x44\x41\x54\x28\xcf\xad\x91\x3d\x4e\x02\x61\x14\x45\xcf\xc7\
\x4c\xe5\x00\x56\xac\x00\x88\x83\x7b\x90\x15\xe0\x0e\xa4\x22\xa0\
\xb4\x6a\x2b\x09\x84\x0e\x4c\x24\x91\x1e\x1b\xcc\xb0\x01\x0a\x4a\
\x76\x41\x31\xb0\x00\xf9\x99\x38\x34\x30\xe4\x5a\x49\x20\xd2\x90\
\x78\xcb\xf7\xee\x79\xc5\x3b\x66\x36\xf5\x39\x27\x31\xce\xcc\x1e\
\xf0\x3c\x4f\x9e\xe7\x49\x92\x0e\x0b\x92\xf4\xd9\xef\xcb\x1b\x0c\
\x04\x60\x03\x84\x61\xa8\x56\xab\x05\xc0\x66\xbb\xa1\x78\x57\xdc\
\x03\xbd\xde\x07\xdd\xee\x3b\x00\xb7\x85\x82\x62\x00\x89\x44\x82\
\x52\xa9\x04\x40\xe7\xad\xc3\x68\x34\x12\xc0\x70\x38\xd4\x6f\xb9\
\x5c\xa9\xe0\x38\x0e\xcc\xa6\x3e\xb3\xa9\xcf\x72\xb1\xd0\x7d\xa5\
\xac\x6c\x26\xad\xeb\x9c\xab\x66\xb3\xa1\x9c\x7b\xa5\x6c\x26\xad\
\x6a\xf5\x41\xcb\xc5\x42\xb3\xa9\x8f\x39\xfc\x52\x32\x79\xa9\x5a\
\xed\x85\xc9\x64\xb2\x9f\xb9\xae\x4b\xbd\xde\x20\x08\x56\x06\x38\
\x06\x8c\x31\xba\x70\xe2\xbc\xb6\xdb\xcc\xe7\x5f\xa4\x52\x29\x1e\
\x9f\x9e\x59\x87\xdf\x48\xfa\x0b\x00\x58\x96\x25\xcb\xb6\x19\x8f\
\xc7\xe4\x6f\xf2\x44\xd1\x96\xdd\x6e\x67\xf6\x47\x4f\x89\xb3\x6d\
\x5b\x8e\x13\x27\x5c\x87\xec\xa2\xc8\x1c\xed\x4e\xc9\x89\xa2\xc8\
\x04\xc1\xea\x7f\x4c\xff\x00\xb4\xa0\x86\x57\x3b\x81\xd3\x82\x00\
\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x03\x23\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\
\x01\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x02\xa0\x49\x44\
\x41\x54\x78\xda\x75\x93\xdf\x4b\x14\x51\x14\xc7\xbf\x77\xe6\xce\
\xce\xfe\xd2\x4d\x13\x95\x7e\x2c\x61\x44\x04\x66\x8a\x3f\x88\x0a\
\x1f\x84\x42\xea\xb1\x87\x20\x24\x88\xac\xe8\x17\x59\x61\x84\x58\
\x19\x2b\xf4\x90\x69\x50\x20\xf6\xe0\x4b\xf4\x50\x7f\x40\x12\xd9\
\x4b\x61\x82\xa1\x0f\x45\x68\x92\x8a\x4b\x3d\xb4\x9b\xb3\xcd\xba\
\xce\xec\xce\xcc\xce\xed\xde\x5d\x56\x54\xf2\x03\x87\x7b\x39\xe7\
\x7c\xbf\x67\x0e\x33\x43\x18\x63\xd8\x00\xe1\xa1\x88\x18\x9d\x5a\
\x28\x97\x24\x42\x5a\x6a\x77\xc5\x01\xd8\x3c\x2c\x1e\x2e\xd6\xb0\
\xd1\x40\xbe\xf6\x74\xa4\x71\x3e\x66\x3c\x2e\xdd\x52\x5c\xbd\xb3\
\xb2\xb8\x28\xe0\x55\x48\x3c\x61\x1a\x5a\xd2\x98\xad\x2a\xf7\x77\
\xf4\xb4\x1d\x1e\x03\xe0\xfc\xcf\x40\x3a\x70\x6e\xb0\x4b\xf6\x15\
\x75\xb7\x1f\xaf\x57\xab\x2a\x43\x50\x15\x19\xa2\x6c\x39\x2e\x62\
\xba\x81\xb7\x93\x8b\x8e\xa6\x27\x06\x46\x22\x27\xbb\x84\xc9\x3a\
\x83\xb2\x13\xbd\xb7\xb6\x56\x6e\xef\xbb\x73\xba\x19\x5a\xca\x86\
\xbe\x62\xc3\xaf\xca\x10\x18\x99\x2c\x8a\x7c\x0a\xb6\x95\xaa\x78\
\xf9\x71\x16\x73\xf3\xd1\xfb\xdf\x87\xcf\x47\x00\xb0\x9c\x01\x69\
\xbc\xbe\x97\x96\x56\x4c\xdd\x6e\x6b\xf5\x9b\x16\xcb\x4d\x0d\xfa\
\x28\xee\x9e\xda\x0f\x41\xe4\xd5\x57\xa4\x4c\x07\x84\x00\x21\xbf\
\x82\x87\xaf\x3f\x98\x34\xa3\xd5\xa7\xde\xdc\x9b\x96\x20\xa0\x4a\
\x6f\x73\xdd\x3e\x7f\x5c\xb7\xf8\x64\x0b\x49\xc3\x82\x91\x76\x20\
\x4b\x44\x84\xb8\xf3\x5c\xbe\xf6\x73\xc9\xc0\x91\xea\x2a\xdf\x4a\
\x1a\x91\x9c\x14\x02\x82\x06\x22\xab\xf8\xcb\xb3\x05\x96\xcd\x0c\
\xae\x0e\x8e\x43\x3c\xa1\xc6\xd7\x59\x8b\x57\x51\x00\x89\xd6\xe7\
\x0c\x48\xcd\xe5\x12\x04\xfd\x61\x22\x11\x2e\xb2\x50\x60\xa4\xe7\
\x18\x0a\xb4\x3e\x18\x05\x61\x58\x7d\x83\xaa\x42\x00\xb0\x30\xa9\
\xb9\x52\x42\x91\xf5\x12\x30\x17\xc9\x94\x0d\xaa\x38\xc8\x21\x7b\
\x70\xa8\xfb\x1d\x3e\xf5\x1e\x85\x20\x95\xa5\x70\xdd\x2c\xf4\xe5\
\x0c\xf4\x64\x12\xb1\x84\x09\x64\x6d\xc0\x26\x12\x65\xdf\xfa\x35\
\x72\xf0\x66\x7c\x62\x66\xb1\x82\x28\x1e\x28\xde\x20\x68\x20\x00\
\x4a\x15\x24\x12\x09\x08\xc6\xa2\x26\xb8\x03\x17\x58\x80\xc5\x4f\
\x47\x88\x33\x71\x36\xfd\x6c\x89\x42\xe0\xb2\x1f\x70\xd2\x15\x8c\
\x8b\x2d\xc9\xc3\x7b\x54\xc0\x91\xb0\x0a\x55\x01\x22\xe5\x83\xb9\
\x40\x5a\x07\xec\xf4\x1c\x38\xf9\x2e\x89\x74\x22\x15\x73\x40\xe4\
\x7c\xb3\xa2\x42\xeb\x6f\x42\x01\xed\x51\x1d\xa0\xfa\x73\x79\x80\
\xf0\x44\x54\xec\xda\xb9\xee\x43\x22\x4d\x1d\x43\xf0\x85\x2e\x60\
\x47\x2d\x10\x2c\x03\xdf\x25\x2f\xa2\xfc\x74\xd2\xf9\x9d\xf5\xdf\
\xc0\xfc\x38\x60\xea\xcf\xd9\xc4\xc0\xc5\xf5\x06\x1c\x34\x76\x0c\
\x43\xa6\x67\x20\xd5\x4a\xd8\x13\x02\xec\xdd\xf9\xa9\x9e\x05\x60\
\xe6\x0f\x24\x67\xd2\x75\x1d\xfb\x05\x3e\x3f\x39\xcb\x38\xab\x06\
\x6b\x21\x0d\x37\x5a\x54\x1f\x1d\x02\x95\xc3\x56\xc6\xf1\x88\xaa\
\x12\xf0\xd8\x94\xe1\x97\x65\x5a\xed\xce\x58\xdf\xfb\x4d\xff\xc6\
\x8d\x48\x35\x97\xc2\xa2\xca\xbe\x0c\x46\xb1\x09\xff\x00\x97\x08\
\x2c\x5e\x2a\x10\x42\x0c\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\
\x60\x82\
\x00\x00\x01\xf3\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x04\x00\x00\x00\xb5\xfa\x37\xea\
\x00\x00\x00\x02\x73\x42\x49\x54\x08\x08\x55\xec\x46\x04\x00\x00\
\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\x01\x3a\
\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\x74\x77\
\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\x70\x65\
\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x01\x72\x49\x44\x41\x54\
\x28\xcf\x45\x91\x4f\x2b\x04\x71\x1c\xc6\xbf\xf3\x32\xe4\x6c\xde\
\x80\xa2\x44\x39\xbb\xec\x1f\xb3\x23\x6d\x9b\x25\x8b\x10\xfd\x76\
\x36\xec\xa2\x31\x89\x13\x0e\x2e\xca\xfb\x98\x4d\x7b\xf0\x12\xb4\
\x85\x83\x36\x17\x97\xb1\xa2\xe9\x47\xfd\x0e\x63\xb6\x8f\x83\xb5\
\x9e\xe7\xf6\xf4\xf4\x1c\x9e\x8f\x20\xbf\x3e\xb1\x8f\x83\x20\xf4\
\x23\x3f\x0a\xc2\xe3\xe0\xc4\xfe\xcb\x05\x41\x7c\xeb\x50\xd5\x4d\
\x95\x1a\x3e\x3e\x35\xaa\xd4\xcd\xa1\xf2\xad\x7e\xa1\x61\xd5\x9b\
\xdb\xec\xd2\xa2\xcd\x13\x1d\x1e\x68\xb1\xc3\x36\xf5\x66\xc3\x42\
\x04\xf1\xd4\x06\x17\xdc\xf3\x4a\xcc\x27\x5f\x68\xde\x78\xe6\x9c\
\x0d\x3c\x85\x88\xb2\x37\x8d\xc7\x23\x1f\x18\xbe\xe9\xd1\x23\x25\
\x41\xf3\x42\x8d\x4d\xa3\x6c\x59\x0f\x16\xb9\xe5\x1d\xc3\x15\x67\
\x1c\xa0\xd8\x42\x91\xa2\x69\xb3\xc8\xfa\x91\x54\xc2\x15\xee\xd0\
\xa4\x5c\xd2\xa0\x82\x4b\x8e\x59\x20\xa1\xcb\x1a\x95\x50\xca\x91\
\x47\x9b\x98\x94\x3d\x96\xc9\x31\xc5\x38\xd3\x40\x4a\xcc\x3e\xe5\
\x48\x4a\x51\x95\x47\x34\x3d\xb2\x8c\x32\x84\x30\xc4\x28\xd0\x43\
\x73\x40\x29\x92\x62\x58\xee\x2f\xb8\x4c\x30\xc2\x30\x23\x4c\xf4\
\x17\x96\x29\x86\x52\x0c\x1c\x6e\xe8\x92\xb0\xc4\x0c\x93\x8c\x31\
\xc9\x0c\x90\xd0\xc1\xa1\x78\x24\xf3\x76\xc1\xac\xf2\x8c\x26\xe5\
\x5f\x29\x1a\x8f\x82\x99\xb7\x05\x71\x55\x96\x53\x5e\xd0\x24\xa4\
\x83\x1f\xae\xc9\xe2\x2a\x44\x90\x39\xcb\x6d\x66\x58\xa3\x4d\x97\
\x18\x4d\x4c\x87\x2a\x19\xdc\xe6\x9c\xd5\x87\xe5\x5a\x8e\xca\x9b\
\x0c\x25\x76\xd8\x63\x81\x0c\x79\xe3\x28\xd7\x1a\xd0\x44\x90\x82\
\xed\x04\xf9\x30\x17\xe5\xa2\x7c\xe8\x04\x85\x01\xee\x1f\x8d\x42\
\x66\xb3\xf5\x8b\xfe\x99\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\
\x60\x82\
\x00\x00\x05\xb0\
\x47\
\x49\x46\x38\x39\x61\x10\x00\x10\x00\xf6\x00\x00\xff\xff\xff\x00\
\x00\x00\xfa\xfa\xfa\x92\x92\x92\x88\x88\x88\xee\xee\xee\xc8\xc8\
\xc8\xd8\xd8\xd8\x9e\x9e\x9e\x00\x00\x00\x8e\x8e\x8e\xc6\xc6\xc6\
\x32\x32\x32\x52\x52\x52\xec\xec\xec\xa6\xa6\xa6\x94\x94\x94\xf2\
\xf2\xf2\x82\x82\x82\x1c\x1c\x1c\xb2\xb2\xb2\xa4\xa4\xa4\x9a\x9a\
\x9a\xf4\xf4\xf4\xf8\xf8\xf8\xa8\xa8\xa8\xce\xce\xce\x44\x44\x44\
\x0c\x0c\x0c\x60\x60\x60\xde\xde\xde\xe8\xe8\xe8\xbc\xbc\xbc\x2a\
\x2a\x2a\x36\x36\x36\x46\x46\x46\xd4\xd4\xd4\xc4\xc4\xc4\x3c\x3c\
\x3c\x4e\x4e\x4e\x3e\x3e\x3e\x48\x48\x48\xd0\xd0\xd0\xca\xca\xca\
\x5a\x5a\x5a\xb4\xb4\xb4\xea\xea\xea\x70\x70\x70\xac\xac\xac\xb8\
\xb8\xb8\xba\xba\xba\x5e\x5e\x5e\x5c\x5c\x5c\x62\x62\x62\x86\x86\
\x86\xe0\xe0\xe0\x7e\x7e\x7e\xfc\xfc\xfc\xa2\xa2\xa2\x18\x18\x18\
\x2c\x2c\x2c\x56\x56\x56\x04\x04\x04\x50\x50\x50\xcc\xcc\xcc\x38\
\x38\x38\x58\x58\x58\x1a\x1a\x1a\xf0\xf0\xf0\xd6\xd6\xd6\x9c\x9c\
\x9c\xe2\xe2\xe2\xe6\xe6\xe6\x40\x40\x40\xaa\xaa\xaa\x24\x24\x24\
\x20\x20\x20\xae\xae\xae\x72\x72\x72\x4a\x4a\x4a\x34\x34\x34\x6a\
\x6a\x6a\xd2\xd2\xd2\xc0\xc0\xc0\x26\x26\x26\x7c\x7c\x7c\x42\x42\
\x42\x54\x54\x54\x0a\x0a\x0a\x08\x08\x08\xb0\xb0\xb0\xe4\xe4\xe4\
\x4c\x4c\x4c\xf6\xf6\xf6\xb6\xb6\xb6\x66\x66\x66\x68\x68\x68\xdc\
\xdc\xdc\xa0\xa0\xa0\x12\x12\x12\x22\x22\x22\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x21\xff\x0b\x4e\
\x45\x54\x53\x43\x41\x50\x45\x32\x2e\x30\x03\x01\x00\x00\x00\x21\
\xfe\x1a\x43\x72\x65\x61\x74\x65\x64\x20\x77\x69\x74\x68\x20\x61\
\x6a\x61\x78\x6c\x6f\x61\x64\x2e\x69\x6e\x66\x6f\x00\x21\xf9\x04\
\x09\x08\x00\x00\x00\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\
\x68\x80\x00\x82\x83\x20\x22\x26\x25\x83\x89\x00\x0b\x12\x1a\x00\
\x21\x09\x09\x28\x8a\x82\x06\x0c\x09\x1b\x1e\x97\x09\x29\x82\x11\
\x89\x04\x91\x1c\x16\x0b\x23\x27\x2a\x00\x18\x19\x9f\x82\x07\x0d\
\x13\x1d\x1f\x94\x18\x8a\x0e\x14\x05\x94\x8a\x02\x08\x0f\xb9\x94\
\x03\x91\x15\xbe\x00\x24\x88\xa1\x09\x16\xc3\xc5\x00\x05\x0a\x10\
\x17\xc3\xd1\xd2\xa9\xbe\xb4\x89\x11\x19\xd6\x89\xaa\xac\x83\xdd\
\x24\x24\xde\xd1\x25\x88\xd3\xd1\x81\x00\x21\xf9\x04\x09\x08\x00\
\x00\x00\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\x6b\x80\x00\
\x82\x83\x07\x34\x35\x37\x83\x89\x8a\x33\x09\x09\x2f\x39\x3a\x3d\
\x19\x39\x83\x2b\x2f\x1a\x17\x2f\x8d\x38\x10\x3b\x09\x3b\x30\x83\
\x2c\x09\x0d\x32\x2e\x12\x36\x05\x21\x8d\x09\x35\x83\x2d\x29\x31\
\x05\x89\x15\x3c\x3e\x3c\x32\x83\x2e\x30\xb3\x8a\x30\x3f\x20\x8a\
\xc2\xc3\x00\x25\x24\xc4\x82\x24\x25\x82\xc6\xc8\x00\xca\xce\xd1\
\xd2\x83\x18\xc4\xd5\x89\x11\x19\xd7\x89\x18\x19\x11\x8a\xdf\xc9\
\xc7\x82\xe1\xc4\x25\xcb\xd3\xc8\x81\x00\x21\xf9\x04\x09\x08\x00\
\x00\x00\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\x68\x80\x00\
\x82\x83\x02\x08\x0f\x83\x88\x89\x00\x03\x09\x09\x15\x00\x25\x12\
\x2a\x89\x11\x82\x04\x8d\x16\x40\x41\x09\x26\x45\x83\x11\x19\x18\
\x00\x05\x0a\x10\x17\x38\x3e\x8d\x46\x88\xa2\x89\x1e\x42\x43\x34\
\x47\x8a\x8a\x0e\x14\x44\xb4\xb4\x20\x22\x26\x25\x90\x24\xb9\x00\
\x21\x8d\x28\xbf\xc1\x0c\x8d\x29\xc1\x83\x0b\x23\x27\x93\xcb\xb9\
\xad\x8a\xd3\x82\xa0\xd5\x82\x18\x19\x95\x88\xdc\x00\x24\xc0\xd6\
\xcb\x25\xbe\xd1\xd1\x81\x00\x21\xf9\x04\x09\x08\x00\x00\x00\x2c\
\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\x67\x80\x00\x82\x83\x84\
\x85\x86\x82\x25\x25\x87\x83\x11\x83\x24\x24\x00\x44\x0b\x4e\x52\
\x84\x11\x19\x18\x85\x0f\x49\x09\x51\x85\x99\x85\x48\x4a\x4f\x53\
\x8b\x85\x1f\x30\x05\xa6\x85\x07\x34\x35\x37\x00\x25\x90\x8b\x33\
\x09\x09\x2f\xb1\xb3\x87\x2f\xb6\x38\xab\x82\x2e\x12\x36\xaa\xab\
\x46\x50\x0f\x9f\x86\x10\x4b\x09\x4c\x30\x8c\x98\x85\x21\xb6\x09\
\x35\x96\x8e\x90\x15\x4c\x09\x54\x32\x8b\x89\x82\x4d\x51\xde\xbf\
\x86\x81\x00\x21\xf9\x04\x09\x08\x00\x00\x00\x2c\x00\x00\x00\x00\
\x10\x00\x10\x00\x00\x07\x68\x80\x00\x82\x83\x84\x85\x86\x82\x25\
\x25\x87\x83\x11\x83\x24\x24\x8c\x85\x11\x19\x18\x86\x18\x19\x8d\
\x84\x95\x87\x9b\x8b\x9e\x9f\x82\x02\x08\x0f\x88\x90\x8b\x03\x09\
\x09\x15\x00\x25\xa6\x87\x04\xa9\x16\xa0\x00\x05\x0a\x10\x17\xa0\
\x0b\x4e\x45\x85\x9d\x83\x2b\x56\x58\x56\xbc\x82\x93\x95\x20\x22\
\x26\x25\x55\x3e\xa9\x46\x84\x99\x21\xa9\x28\x47\x57\x59\x42\x5b\
\x87\x0c\xa9\x29\x00\x47\x5a\x1f\x8b\x0b\x23\x27\x2a\x86\x81\x00\
\x21\xf9\x04\x09\x08\x00\x00\x00\x2c\x00\x00\x00\x00\x10\x00\x10\
\x00\x00\x07\x67\x80\x00\x82\x83\x84\x85\x86\x82\x25\x25\x87\x83\
\x11\x83\x24\x24\x8c\x85\x11\x19\x18\x86\x18\x19\x8d\x84\x95\x87\
\x9b\x8b\x9e\x9f\x87\x25\x90\x9e\x24\x8a\x00\xa2\x9f\xa5\xa0\x8b\
\x16\x50\x0f\x86\x5d\x20\x5d\x83\x46\x13\x09\x21\x19\x84\x44\x53\
\x2c\x1a\x83\x5c\x09\xc1\x29\x07\x34\x35\x37\x0f\x49\x09\x60\x83\
\x19\x43\x09\x3c\x32\x33\xc1\x2f\x1f\x5e\x5f\x0b\x84\x4d\x51\x32\
\x00\x2f\xc1\x38\xab\x2e\x12\x36\x05\x86\x81\x00\x21\xf9\x04\x09\
\x08\x00\x00\x00\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\x67\
\x80\x00\x82\x83\x84\x85\x86\x82\x25\x25\x87\x83\x11\x83\x24\x24\
\x8c\x85\x11\x19\x18\x86\x18\x19\x8d\x84\x95\x87\x9b\x8b\x9e\x20\
\x22\x26\x8a\x9e\x82\x21\x09\x09\x28\x9e\x24\x8a\x0c\xa7\x29\xaa\
\x8a\x0b\x23\x27\x2a\xa4\x84\x2b\x4e\x52\xb6\x00\x06\x41\x1c\x4f\
\x61\x96\x84\x36\xa7\x1c\x16\x02\x08\x0f\x82\x97\x99\x00\x61\x5c\
\x59\x33\x0e\x03\xa7\x15\x82\xcd\x82\x5b\x5a\x48\x00\x04\xa7\x16\
\xbb\x05\x0a\x10\x17\x86\x81\x00\x21\xf9\x04\x09\x08\x00\x00\x00\
\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00\x07\x68\x80\x00\x82\x83\
\x84\x85\x82\x02\x62\x3d\x4a\x82\x25\x25\x86\x82\x46\x63\x09\x4c\
\x19\x00\x24\x24\x83\x11\x84\x5c\x09\x9d\x4f\x85\x18\x19\x9a\x82\
\x19\x64\x3e\x22\x32\x86\x18\x85\x30\x3f\x31\x8f\x84\x07\x34\x35\
\x37\xb0\x84\x33\x9d\x2f\xb6\x24\x8e\x2f\x9d\x38\xbb\x8e\x2e\x12\
\x36\x05\xb6\x85\x11\x32\x02\xc7\x83\x25\x42\x2b\x5d\xaa\x85\x2c\
\x09\x0d\xaf\x84\xa1\xa3\x82\x53\x5f\x53\x44\x96\x98\x82\xda\x8f\
\x8d\xcc\xe6\x81\x00\x3b\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x03\x4a\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x06\x62\x4b\x47\x44\x00\xff\x00\xff\x00\xff\xa0\xbd\
\xa7\x93\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x03\x76\x00\x00\
\x03\x76\x01\x7d\xd5\x82\xcc\x00\x00\x00\x07\x74\x49\x4d\x45\x07\
\xd7\x0c\x1b\x16\x0a\x05\x13\x29\x78\x6f\x00\x00\x02\xd7\x49\x44\
\x41\x54\x78\xda\x8d\x92\xcf\x6b\x54\x57\x14\xc7\x3f\xf7\xbe\x37\
\x6f\x5e\x66\x32\x93\xa9\x24\x1d\x27\x89\x10\x75\x5c\x34\xb5\x3f\
\xd4\xaa\x7f\x81\x0b\x15\x17\xa1\xe8\x2a\xd0\x45\x6d\x17\x81\x2e\
\xda\x95\xbb\x4a\x76\x5d\x15\x04\x41\x8b\x36\x5d\x74\x91\x62\xe9\
\x1f\x10\x88\x6e\x5c\x88\xa0\xa8\xd8\x92\x90\x74\x88\x21\x93\xa8\
\x33\x31\x33\xe3\xcb\xcc\xbc\x5f\xf7\x79\x78\x74\x21\xd2\x85\x07\
\x0e\xe7\xbe\xfb\xee\xf7\x73\xbf\xe7\x70\x55\x6b\x7e\xfe\x68\xef\
\xee\xdd\x9b\xad\x85\x85\x7d\x00\xc9\x5b\x09\x60\x80\x77\xf7\x9d\
\xbd\x7b\xed\xca\xf4\xb4\xf7\x6a\x65\xe5\x8c\xaa\x5f\xba\x74\x2f\
\x3c\x70\xe0\x64\x57\x29\xde\x37\x12\xa5\xd0\xad\x16\x2f\xaf\x5f\
\xbb\xa3\x16\xb4\xde\xd8\x33\x3b\x3b\x66\x95\x4a\x24\x5a\xe3\x45\
\x11\x05\xa9\xff\x17\xaf\x8d\x21\x6f\xdb\x68\xa9\x96\xd4\xa7\x33\
\x33\x75\x1d\xc8\x47\xd0\xe9\x10\x78\x1e\xfe\xc1\x83\x94\x4f\x9d\
\xa2\x1d\x86\xf8\xed\x36\x6f\xa7\xec\xa5\xff\xc2\x6a\x95\x60\x77\
\x97\xb0\xdb\xc5\x17\xad\x0e\x21\x15\x27\x49\xc2\xe4\x89\x13\x94\
\x2b\x15\xc6\xcf\x9e\xa5\xa7\x35\x81\x08\x25\xd3\xf5\xe8\xe9\xd3\
\x8c\x94\xcb\x7c\x74\xfc\x38\x72\x36\x05\x44\x90\x02\x52\x07\xde\
\xb3\x67\xac\xcc\xcd\x61\xa4\x85\xa2\xb4\x33\x3e\x35\x45\x9c\x1b\
\x20\xca\xb9\x54\xce\x9d\x63\xb0\x58\x24\x0e\xc3\xf4\x8c\xb7\xb6\
\x46\x24\x80\x10\xb0\xa3\x8c\x9d\x3a\x40\x84\xcf\xef\xdf\x27\xdc\
\xf5\xd8\xff\xf5\x45\xdc\x7c\x9e\xd1\xf3\x17\xe4\x36\x83\x93\xcb\
\x61\x44\x5c\x9b\xbb\x49\xf3\xe9\xdf\x80\x22\x5b\x1a\x4a\x01\xd6\
\x54\x36\xf3\x43\xe0\x64\x8b\xb1\x00\x94\x89\x31\xcd\x3a\xf1\x46\
\x8d\xfc\x67\xc7\x30\x5a\x83\xb6\xd0\x62\x79\xe7\x8f\x5f\xe9\x3c\
\x79\x48\xaf\xd9\xa4\xbd\xbe\xc1\xfa\xe2\x22\x7e\xbf\xff\xda\x8e\
\x2c\x8b\xf6\xe3\xc7\x98\x24\xa6\x58\x74\x28\xed\x71\xe9\xf5\xb7\
\x51\x67\xbe\x64\xb0\xf4\x01\x91\x80\x77\x5e\x6d\xb3\xb9\xf0\x17\
\xc9\xf2\x3f\x78\x5d\xf0\xfa\x9a\xd8\x76\x09\x01\x1d\xdb\x16\x89\
\x02\xe9\x84\xac\x0e\x50\xfb\xc6\x99\xb8\x7c\x85\xd2\xf0\x08\x16\
\x06\x2b\x31\x64\x07\x0b\x7c\xf8\xe3\x55\x32\x93\x87\x91\x91\xe0\
\x66\x15\xb6\xad\x49\x01\xc6\x56\x0a\xad\x70\x6c\x70\x0f\x7f\xca\
\xc7\x57\xe7\x19\x19\x1b\xc7\xd1\x90\xbb\x3e\xc3\xd0\xdc\x77\xb2\
\x56\x0c\x09\x70\xe2\xa7\xdf\xc8\x7e\x72\x04\xc7\x01\x2b\xa3\xfe\
\x73\x90\xd1\x28\x0d\x45\x79\x03\x5f\xdc\xf8\x93\x91\x51\x11\x5b\
\xc2\xbc\xf2\x0d\xee\xf2\x6d\x0a\xff\xde\x61\xf8\xf7\xef\x29\xe6\
\x73\x0c\x8f\x8e\xf1\xf9\xb5\x5b\x14\xaa\x87\xb0\x05\x10\xa5\x0e\
\x84\x0e\xe0\x37\x1a\x38\xad\x06\x16\x32\xb0\xd9\xaf\xf0\x1f\x2e\
\x92\x00\x26\x81\xf8\xd1\x6d\xcc\xcf\xdf\x32\xe0\x64\xc8\xb4\x9a\
\x84\xdb\x0d\x94\x05\x06\x50\x37\x8e\x56\x9f\xf7\x6a\xf5\x72\x4e\
\xc7\x72\xc3\x10\x95\xc9\x2a\x6a\xed\x01\x85\x1c\x69\xbf\x96\x06\
\x3f\x00\xaf\x07\xf1\xc4\x31\x5e\x2e\xd5\xd8\x69\xb4\xe9\x3b\x05\
\x96\x6a\xdb\x75\xdb\x2d\xef\x5f\x37\x41\x54\x56\xdd\x0e\x3d\x13\
\xf3\x62\x75\x99\x01\x77\x10\x1f\x70\x22\x40\x41\x6c\x20\xd0\xd0\
\x5b\x59\xa6\x1b\x42\x24\x43\xf5\xfa\x03\xe2\xc2\x5a\xb5\xb7\x96\
\x56\xa7\x3b\x9b\x5b\xbf\x84\xbe\x5f\x4d\x78\xbf\x50\x5a\x23\xb9\
\x2a\xaf\xf6\xe2\x1b\x6a\x91\x52\x21\x98\x91\x3a\x79\x00\x00\x00\
\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x04\x3d\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x06\x62\x4b\x47\x44\x00\xff\x00\xff\x00\xff\xa0\xbd\
\xa7\x93\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x37\x5c\x00\x00\
\x37\x5c\x01\xcb\xc7\xa4\xb9\x00\x00\x03\xaf\x49\x44\x41\x54\x38\
\xcb\x05\xc1\x5b\x68\x1c\x55\x00\x06\xe0\xff\x9c\x33\x97\x9d\xd9\
\x5b\x92\xcd\x65\xd3\x24\xdd\x6e\xd2\xb4\x69\x62\x52\xa4\xd6\x34\
\xa2\x85\x16\x8b\x97\x97\x12\xa1\x16\x6c\x51\xfb\xa2\x14\xaa\x0f\
\x8a\x10\x2d\xf8\x52\x6b\x0b\x62\x14\x7c\x28\x4a\xa9\x50\x44\xa9\
\xa4\xe0\x8b\xb7\xb4\x18\x30\x92\x12\x42\xad\xb5\x95\x90\xd0\x68\
\x2f\xc9\xee\x26\xd9\xcb\xcc\xec\xcc\xec\xec\xcc\xec\x39\x7e\x1f\
\x99\xfc\x62\x06\xaa\x2a\xa1\x52\xae\x92\x03\x07\x87\xc8\x53\x7b\
\xb7\xf2\xb3\x67\x7e\xde\x56\x28\xd7\xf6\xd7\x82\xc6\x8e\x5c\xde\
\xc2\xed\x3b\xb9\xe5\xc0\xad\xff\x16\x2a\xea\x6a\xac\x49\x23\xa1\
\x1f\x82\x4a\x54\x40\x00\xd2\xd2\x72\x11\x94\x80\x3c\x58\x2c\x88\
\x6a\xc5\xef\x98\x99\x59\x3e\x1b\x69\x4b\x1c\xcd\x6c\x69\x89\x3e\
\xda\xb0\x45\x2e\xef\x40\xed\x6c\x26\xcc\xad\x5b\x81\xeb\x5f\xae\
\x6e\x98\x1f\x1a\x6b\xc5\x4a\xef\xe3\xbd\x44\x8d\x48\x82\xed\x1a\
\x3c\x4c\xec\x92\x23\xea\x10\xbd\x03\xbb\x7b\xa6\xb5\xee\xd4\x21\
\xaf\xbd\x45\x5a\x63\xb2\xc8\x87\x54\x74\x76\x26\x85\x1c\x8b\x40\
\x8b\x45\x14\x89\xd1\x51\xca\xe8\x61\x16\x51\x7f\x32\x2a\x6e\x85\
\x32\x4a\x08\x90\x05\xb0\x55\x3b\xfd\xd1\x07\xb3\xed\x03\x5d\x7b\
\xc2\x54\x34\x68\x6a\x92\x25\x08\x46\xfe\x7e\x68\x8a\xb5\x75\x07\
\x8a\x17\x90\xdc\x83\xa2\x08\x4c\x37\xac\x97\x6c\xd9\x33\x9c\x9b\
\x3a\x0f\x9f\x09\x3c\x5e\x63\x27\xdf\xb9\x84\x6d\xdb\x87\xde\xcd\
\x0c\xf5\xbc\x6a\xc3\x09\xe6\xaf\x7c\x2e\xaf\xcd\xfd\x8a\x1e\x6e\
\x92\x37\x5f\x1c\x25\x1d\x1a\x27\x4b\x79\x13\xd5\x3a\x81\x61\xd5\
\x98\xef\x87\x41\xe8\x85\xdd\x1c\xb0\x0d\x2f\xfc\x83\x5e\x98\x7c\
\x49\x76\x05\x39\x4e\x34\x05\x1b\x2e\x67\x85\x64\x3f\x6e\x45\x07\
\xc8\x95\x5b\xf7\xa1\x4a\x0c\xfb\xba\x22\x78\xb6\xb5\x84\xed\x69\
\x95\xc4\x12\x3a\x88\x2c\xb1\x78\x8b\x8e\x74\x47\xe2\xf5\x8d\xbc\
\xa9\xb3\x78\xe7\xe9\x21\xb9\x29\x36\xc1\xa3\xaa\x54\x95\x75\x44\
\xfb\x46\x48\xac\x6f\x04\x2f\x8f\x0d\x81\xaf\xdf\xc3\xf1\xb7\x26\
\x70\xfb\xcf\x05\x8c\x3f\x91\x86\x13\x2a\x58\x5a\xad\xe3\xe9\x91\
\x4e\xe2\x39\x7e\xb2\x62\x79\x3f\xb0\xfe\xe1\xf1\x11\xaa\x2b\x27\
\x2c\x50\x11\x4f\x28\x78\x64\x08\xf2\x64\xab\x8c\xe7\x52\x65\xbc\
\x71\xee\x22\xea\x7d\x87\x50\xd7\xba\xb0\x70\xed\x2a\x0c\x97\x80\
\xc6\x32\x30\x4a\x16\xca\x25\x87\x25\x74\x79\x4a\x8a\x46\x15\xcf\
\xf2\x42\xd0\x9a\x07\xd7\x51\x30\x1a\xbd\x86\x53\x3b\xbb\xf1\xf1\
\xe5\xff\x80\xfe\xe7\xb1\xb5\xf7\x31\xd4\x4c\x0b\x1b\x0d\x1d\x7a\
\x22\x85\xa4\x60\x28\xe6\xeb\x50\x01\x14\xcb\xae\x47\x63\x5a\x64\
\x85\xf0\xb0\x58\xb5\x08\xd1\xcc\x79\x9c\xdb\x7b\x01\x85\x1b\x27\
\x70\x63\x35\x44\x4b\x5b\x2f\xaa\x85\x02\x02\xdb\x81\xde\x9c\x05\
\x65\x51\xe8\x32\x90\xd4\x15\xe2\x38\xfe\xa6\x69\x7a\x2b\xf4\xe6\
\x66\x3c\xcf\xa8\xf2\xbb\xe2\x17\xf1\xde\x9e\x2f\xb9\xd4\xd8\xc4\
\x67\xd3\x7d\xe0\xb1\x11\xf8\xa6\x01\xdf\x09\x60\x1b\x35\x48\x81\
\x27\xba\x9a\x15\x90\x86\x68\x94\x4a\x36\xbc\x7a\x38\xab\xb5\xc6\
\xf3\xd4\xbc\xd3\x84\xbb\xff\x46\x3f\x39\x35\x76\x15\x63\x3b\x73\
\xe4\x9b\x69\xce\x57\xc4\x31\x34\x69\xba\x08\xac\x1a\xe4\x46\x03\
\xd9\x94\x26\x32\x29\x9d\x14\x72\x26\x7f\xb8\x5a\x21\x01\x87\x90\
\x64\xf6\xa9\x2e\x53\x48\xf7\xbf\x7e\x01\xf9\xa2\xe8\x1b\xde\xd5\
\x8e\xbf\xee\xda\xf8\x6a\xfe\x20\x51\xfb\x86\x79\x77\x94\x13\x9b\
\x52\x11\x51\x18\x1c\xd3\xc1\xe2\xaa\xd9\x88\xe8\x2a\xb8\xaa\x30\
\x1a\xf0\xf7\xa5\xa4\x3e\x87\x06\xa7\x74\xbd\xc4\x07\xb3\xd9\x8e\
\x49\xb7\xe6\xe1\xe2\x8f\xca\x9a\x9f\x7e\xa5\x1c\x4d\x37\x53\x57\
\x4f\x20\xd9\xdd\x4e\x0c\xa6\x92\x3c\x22\x48\x64\xb7\x30\xb5\x25\
\xe1\x53\x4a\xdf\xce\xee\x1f\x3a\xaf\x69\x0a\xc9\xf4\xa7\x39\xdb\
\xb7\x3b\x7e\xb4\xbd\x99\x1c\x99\x59\xa8\xd8\x67\x2e\x85\xaf\x85\
\x35\xe9\x3b\xdb\x32\x32\x65\xbb\xde\x52\xa8\x38\x0a\xe7\x75\x2e\
\x37\x2c\xd3\xdf\x5c\x99\xb5\xef\xcd\x9d\x54\xd2\xfd\xdf\x57\x56\
\x0a\x34\x77\xfd\x5b\x61\x98\x04\x04\x48\xd2\x23\x07\xcc\x09\xcb\
\x01\xff\x65\x1e\xe7\xe3\x3a\x3a\xec\x1a\xd2\x04\x74\x87\x1c\x49\
\x75\x06\x0d\x34\x44\x50\x5c\x05\xc4\x22\x08\x2b\xb4\x0d\x8e\xbb\
\x9b\xff\x4c\x85\x00\x70\x6c\x4a\xe0\x7f\x70\x2b\xc1\xc5\x00\xe2\
\xed\x86\x00\x00\x00\x22\x7a\x54\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x00\x78\xda\x2b\x2f\x2f\xd7\xcb\xcc\xcb\x2e\x4e\x4e\
\x2c\x48\xd5\xcb\x2f\x4a\x07\x00\x36\xd8\x06\x58\x10\x53\xca\x5c\
\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x01\xf5\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x04\x00\x00\x00\xb5\xfa\x37\xea\
\x00\x00\x00\x02\x73\x42\x49\x54\x08\x08\x55\xec\x46\x04\x00\x00\
\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\x01\x3a\
\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\x74\x77\
\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\x70\x65\
\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x01\x74\x49\x44\x41\x54\
\x18\x19\x05\xc1\x41\x4b\x53\x01\x1c\x00\xf0\xff\x3b\xf5\x11\xea\
\xda\xa1\x7d\x84\x2e\x5d\x3c\x46\x17\x75\x6d\xb3\x18\x96\x42\x9a\
\xa8\x20\x6f\x13\x6b\x96\xcc\x87\xe8\xcd\xba\x74\xea\x63\x04\x6f\
\x84\x41\x5f\xa0\xa8\x41\x79\x08\xf1\xe2\x65\x19\xc5\x7a\x06\xef\
\x30\xde\xf8\xf5\xfb\x85\x10\x42\x1c\xd6\x0e\xb2\x2c\xef\x8f\xfa\
\xa3\x2c\x3f\xc8\x0e\x6b\x42\x08\x11\x42\xf4\x93\xbd\xb4\x57\x76\
\x6c\xeb\xeb\xdb\xd6\xd1\x2b\xf7\xd2\x7e\x22\x44\x88\xdd\xa4\x37\
\xd8\xf2\xcc\x89\xa1\x1f\xce\x7c\x77\x62\xc7\x96\xde\x60\x37\x11\
\x21\xba\xe9\x86\x57\xbe\xf9\x69\xec\xca\x3f\x85\x5f\xce\x1d\xdb\
\xd0\x4d\x45\xa4\xb5\xcd\xb2\xeb\xd4\x1f\xa5\x77\xae\x4c\x55\x26\
\x0a\x17\xb6\x6d\x96\x69\x2d\xd6\xb3\x65\x1f\xfd\x56\x9a\x3a\x76\
\xe4\x2b\xa8\x14\x86\x96\xad\xef\xc7\x4a\xbe\xea\x8b\x42\x85\x3d\
\xab\x1e\x78\xed\x0a\x13\x97\xd6\xac\xe4\xb1\x34\xea\x1a\x1a\xab\
\xb0\x6a\xde\x8c\x19\x8f\x7c\x56\x19\x7b\x61\x69\x14\x8b\xa3\x8e\
\x53\x85\x29\x6e\xbb\xee\x9a\x5b\xee\xfb\x64\xaa\xf0\xd2\xe2\x28\
\xda\xf9\x92\xa1\xb1\x0a\x77\xdc\x74\x43\xc7\x5f\x54\xc6\x9e\x68\
\xe7\xd1\xce\x1a\xde\xbb\x34\xc1\x3d\x77\x7d\x00\x4c\x9c\x69\x68\
\xef\xc7\xc3\x5a\xb3\x7c\xea\x5c\xa1\xf2\x46\x01\xa8\x14\xba\x9a\
\xe5\xc3\x5a\x88\x56\x3a\xe7\xc8\x85\xc2\x44\x65\xaa\x32\x51\x78\
\x6b\x4e\x2b\x15\x21\x16\x92\xd6\x60\xd6\x9a\xa1\x4b\x63\x85\xb1\
\x33\x1d\xb3\x5a\x83\x85\x44\x84\x10\xad\xa4\x91\xd6\xcb\x59\x8b\
\x76\x3c\xf7\xd8\xac\x7a\xd9\x48\x5b\x89\x10\x21\x84\x10\xcd\x5a\
\x23\xab\xe7\xf3\xa3\xf9\x51\x3d\x6f\x64\xcd\x9a\x10\x42\xfc\x07\
\x7b\x2d\x6e\x9f\x2f\x2d\x37\x8c\x00\x00\x00\x00\x49\x45\x4e\x44\
\xae\x42\x60\x82\
\x00\x00\x01\xe5\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x06\x62\x4b\x47\x44\x00\xff\x00\xff\x00\xff\xa0\xbd\xa7\x93\x00\
\x00\x00\x09\x70\x48\x59\x73\x00\x00\x06\xec\x00\x00\x06\xec\x01\
\x1e\x75\x38\x35\x00\x00\x00\x07\x74\x49\x4d\x45\x07\xd8\x03\x14\
\x12\x23\x3b\xba\x62\x67\xa1\x00\x00\x01\x65\x49\x44\x41\x54\x78\
\xda\x95\x90\xcf\x4a\xc3\x40\x10\xc6\x67\x37\xa6\xa5\x81\x5e\x8a\
\xa7\x3c\x86\x78\xf1\x01\xd4\x1e\xac\x6f\xe0\xc5\x73\xbd\xd8\x53\
\x2d\xf8\x08\xbe\x4b\xcf\x3e\x80\xa0\x10\x3c\xfb\x00\x56\xda\x54\
\x4a\x82\x25\x7f\x77\x3a\xb3\x6c\xe8\x9a\x90\xa2\x1f\x7c\x7c\xbb\
\xec\xcc\x6f\x77\x56\x00\xc0\x80\x7c\x46\x16\x70\x58\x48\x7e\x21\
\x7f\x43\x4d\x57\xf8\x37\x31\x60\x04\x35\x1d\x55\x37\xaf\xc2\x10\
\xa4\x94\x20\x85\x00\x41\x29\x38\xd9\xa6\xb0\xdf\xef\x73\x88\x26\
\xc0\xc8\x71\x1c\x0d\x88\xa3\x08\x82\x20\x00\x2d\x0b\xd0\xed\x76\
\x39\x4e\xc8\xa9\x35\xd2\x2b\x2f\x46\x48\xda\x6c\x36\x18\xc5\x31\
\xce\xe7\x73\xfc\xc7\x48\xc3\xc6\x0b\xf8\x56\x56\xb8\x5e\x83\xc3\
\x23\x19\x0b\xb2\x3d\x92\xe7\x79\x1c\xb2\x02\xe8\x22\x0d\x31\x00\
\xdd\x4c\x7b\x9d\x55\x33\x67\xdb\x1f\x48\xab\xd0\xec\xf7\x10\xeb\
\x53\xa1\x15\x60\x15\xd9\x40\xa7\x06\xa6\x6c\x00\xea\x07\x36\x60\
\x0f\x3e\x0c\x68\x42\x44\xad\xb9\x28\x0a\x08\xc3\x10\x3a\x1d\x17\
\x7a\x3d\x0f\x14\x08\xa4\xb2\x82\x01\x8a\x0e\xd1\x75\x5d\x51\xdd\
\xac\xb3\x76\x2b\x37\xfb\xbe\x0f\xac\xed\xf6\x07\x1e\x67\xb3\x67\
\x5a\x06\xbc\x3f\x26\xdf\x90\x6f\x8d\x9f\x90\x94\x24\x09\x66\x59\
\x86\x0c\x2f\xcb\x12\x17\x5f\x0b\x54\x4a\x61\x1c\xc7\x38\xbe\x1b\
\xbf\x51\xdd\x29\xb4\x68\xc8\x80\x34\x4d\x31\xcf\x73\x06\xe8\xc6\
\xe5\x6a\xa9\x9b\x27\x93\xfb\x77\xaa\xb9\x26\xcb\x36\xc0\x05\x35\
\x2a\xb4\x94\x15\x25\x7e\x2e\x57\x38\x7d\x98\xf2\x93\x2f\x7f\x7d\
\x3e\x34\x35\x20\x9f\x9b\x22\x5b\x68\x66\xfe\x20\x2b\x30\xda\x01\
\x68\x0b\xe8\x88\x71\x7b\x2b\x7d\x00\x00\x00\x00\x49\x45\x4e\x44\
\xae\x42\x60\x82\
\x00\x00\x03\x47\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\
\x01\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x02\xc4\x49\x44\
\x41\x54\x78\xda\x9d\x93\x5b\x48\x53\x71\x1c\xc7\x3f\xe7\x6c\xe9\
\xa6\x36\x8f\xb5\x91\xa7\x48\x6c\x0b\x32\x8c\x08\xa4\xfb\x58\x2d\
\xbb\x88\xd5\x53\x62\x17\x8b\xae\xf3\xb5\xb2\x46\x17\x24\x28\xba\
\x47\x05\x41\x85\xbd\x44\x74\x2f\x0d\x2a\x95\x82\xc0\x82\x6e\x08\
\x25\xdd\x2f\x76\xa3\x8b\xb5\x6a\x73\xd3\xed\x2c\xdd\x39\xae\x79\
\x40\x5d\xf4\x12\x7d\xe1\xfb\x76\xbe\x1f\xbe\xbf\xef\x9f\x23\xc4\
\xe3\x71\xfe\x45\xd5\x6b\xe4\x41\x79\xcf\xf3\x1b\xd4\x48\xf4\x4d\
\x3f\x59\x2e\xcf\xaf\xae\xfe\x06\xa0\x03\xe6\xce\x99\xd3\xfa\xeb\
\x57\x87\xb4\x7a\xad\x97\x64\x09\x22\x80\x88\x40\x8c\x91\x6c\xe1\
\x63\xad\x84\xe5\xf2\x0b\x9e\x29\x0a\x17\x26\x4e\x0c\x5e\xa9\xab\
\xcb\x32\x02\x28\x11\x45\xca\x96\xb3\x71\x4d\x75\x13\x4f\x06\x74\
\x5b\x88\x13\x7d\xb4\x98\x1f\x3e\x91\x65\xf5\xaf\xf1\x48\x22\xb6\
\x9f\x61\xc4\xd6\xa0\x04\xa0\x03\xba\xba\xba\x30\xa5\x9a\x30\xa5\
\x18\x38\x79\xe3\x31\xc9\xca\xf4\x1d\x64\x8c\xf5\x15\x0b\x2b\x15\
\x04\xd5\x4f\x91\x37\x85\x9a\x9b\x23\x09\xbe\x35\xd2\x0b\xd0\x12\
\x00\x55\x55\x11\x45\x58\x5c\x38\x0a\x01\xf4\x26\xaf\x1a\xab\xc8\
\xb5\x3c\xa5\xb8\xa2\x03\xff\xcf\xef\x9c\xdd\x9a\x46\x28\x65\x1a\
\xb7\xdf\xb4\x24\x32\x1a\x00\x62\x4f\x03\x4d\xd3\x68\x8f\x76\x12\
\xed\x54\x51\x12\x7e\xff\xbc\x96\xbc\xd4\xe3\x94\x6d\xed\xe4\xdd\
\xc7\x00\x47\xd6\x9b\x21\x2d\x8f\xc6\x2f\x13\x30\x99\xcd\x00\xf4\
\x9d\xa0\x69\x7a\x83\x70\x02\x70\xfe\xda\x3d\x52\x63\xef\xf1\x4c\
\x7e\x4d\xf9\x2e\x81\x47\x2f\x43\x6c\x28\x53\xc9\xb0\x48\xec\xbe\
\x32\x8c\xd9\x33\x25\xa4\xcc\x4c\xda\xdb\xda\xfe\x6e\xd0\x16\x8e\
\xe2\x1a\x6d\xc5\x33\xc5\xcf\xe1\x73\x9f\xb8\xdb\x14\x62\xc9\xf4\
\x08\xee\x82\x74\x2e\x36\xcd\x20\x7f\xc4\x70\x0a\xc6\xbb\xba\xbf\
\xd7\x9d\x34\xa2\x86\xa6\xaa\x6c\x5b\xb7\x82\x03\xde\xa1\x9c\xbe\
\xfe\x95\xaa\xd3\x2f\x28\xc8\xfd\x4c\x59\xa1\x91\xe5\x7b\x44\x82\
\x91\x06\x1c\x0e\x07\x6f\x9f\x3c\xa0\x27\xd3\x37\xa2\x96\x20\x6a\
\x9d\x6c\x5c\xaa\x71\xeb\xc6\x25\xf6\x9e\xca\x22\x77\xa0\x8f\x1d\
\xe5\x06\x56\xed\x4b\xe3\xab\x3f\x8e\x7d\x58\x36\x46\x83\x41\x3f\
\xb5\x27\xf3\xc7\x06\x2b\xa7\x7f\xa0\xf5\x9b\x9f\xed\x67\x24\x06\
\x59\xda\x38\xe6\x85\xfd\x97\xed\x08\x19\x56\x36\x6e\x9a\x87\xcb\
\xe5\xa2\x74\x5e\x89\x7e\xaa\xc3\x6e\xd7\x33\xbd\x1b\x38\x0b\x72\
\x49\x4f\x37\x50\x71\xd4\x42\x7f\xb3\xca\xe1\xd5\xed\xec\x3a\xd5\
\x45\xc3\x03\x8d\x9c\x9c\x1c\x64\x59\xa6\xb9\xb9\x19\x79\xf0\x60\
\x44\xa3\x41\x7f\xf6\x98\xaa\xf6\x01\x0a\xdd\x93\x90\xc7\x6c\x27\
\xd3\x62\x62\x9f\xe7\x3b\x57\xef\x08\x9c\xa8\x8f\x61\xb3\xd9\x70\
\x3a\x9d\x84\x42\x21\xdd\xf1\xee\xf1\x12\xd5\xad\x56\x2b\xb1\x58\
\x0c\x1d\xb0\xad\x62\xbe\x71\xc8\x10\x1b\x4a\xa0\x91\x35\x0b\x24\
\xee\xbf\xb4\x72\xa8\x26\x8d\x01\x52\x16\xc5\xc5\xc5\x84\xc3\xe1\
\x5e\x40\x24\x12\xd1\x83\x51\x45\xd1\x47\x07\x30\xf6\x33\x65\x6c\
\xae\xdc\x59\xc5\xac\xb1\x16\xf5\x6c\xbd\xcf\xe8\x2e\x2a\x65\xf9\
\x4a\x03\x00\x81\x40\x80\x64\x7d\x69\x69\x01\xe2\x3c\x6c\x6a\x42\
\x34\x88\x41\x00\x2a\x56\x15\x2d\xf2\x94\x8c\x73\x74\xff\x95\xff\
\xe3\xdf\xfd\x96\x70\x9f\x9f\x28\xbe\x9f\x00\x00\x00\x00\x49\x45\
\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\x84\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x03\x00\x00\x00\x28\x2d\x0f\x53\
\x00\x00\x00\x03\x73\x42\x49\x54\x08\x08\x08\xdb\xe1\x4f\xe0\x00\
\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\x01\
\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\x74\
\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\x70\
\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x01\x35\x50\x4c\x54\
\x45\xff\xff\xff\x00\x00\x00\x3a\x42\x3a\x00\x00\x00\x2c\x32\x2c\
\x00\x00\x00\x20\x20\x20\x00\x00\x00\x15\x15\x12\x00\x00\x00\x05\
\x05\x05\x3d\x3e\x3c\x00\x00\x00\x3d\x3e\x3b\x63\x63\x63\x00\x00\
\x00\x01\x01\x01\x30\x31\x2f\x02\x02\x02\x24\x25\x24\x02\x02\x02\
\x18\x18\x17\x04\x04\x04\x0d\x0d\x0d\x01\x01\x01\x02\x02\x02\x04\
\x04\x04\x05\x05\x05\x06\x06\x06\x07\x07\x07\x08\x08\x08\x0c\x0c\
\x0c\x0d\x0d\x0d\x10\x10\x10\x14\x14\x13\x14\x14\x14\x19\x19\x19\
\x20\x20\x20\x21\x22\x21\x22\x22\x22\x27\x27\x26\x2f\x30\x2e\x31\
\x31\x31\x32\x33\x31\x37\x37\x37\x3a\x3a\x3a\x3d\x3e\x3b\x3f\x3f\
\x3f\x41\x41\x41\x41\x42\x3f\x44\x45\x43\x45\x45\x45\x47\x47\x47\
\x4a\x4a\x4a\x4a\x4b\x48\x4b\x4b\x4b\x4d\x4e\x4b\x4e\x4e\x4e\x4e\
\x4f\x4d\x50\x50\x50\x53\x53\x53\x54\x54\x54\x56\x56\x55\x56\x57\
\x54\x58\x59\x56\x59\x59\x59\x5b\x5b\x5b\x64\x64\x63\x64\x66\x62\
\x66\x68\x64\x68\x68\x68\x6a\x6a\x6a\x6a\x6b\x67\x71\x71\x71\x75\
\x75\x75\x79\x79\x79\x7a\x7a\x7a\x84\x84\x84\x86\x86\x86\x8a\x8a\
\x8a\x90\x90\x90\x9f\x9f\x9f\xac\xac\xac\xae\xae\xae\xb2\xb2\xb1\
\xb7\xb8\xb7\xc1\xc1\xc1\xc4\xc5\xc4\xc6\xc6\xc6\xcf\xd0\xcf\xd4\
\xd4\xd4\xde\xde\xde\xe1\xe1\xe1\xe7\xe7\xe7\xe9\xe9\xe9\xea\xea\
\xea\xed\xed\xed\xf0\xf0\xf0\xf3\xf3\xf3\xf4\xf4\xf4\xfa\xfa\xfa\
\xfb\xfb\xfb\xfc\xfc\xfc\x75\x4a\xf7\xaa\x00\x00\x00\x18\x74\x52\
\x4e\x53\x00\x1f\x1f\x2e\x2e\x3f\x3f\x54\x54\x65\x65\xb8\xca\xca\
\xd4\xe5\xe5\xe5\xf0\xf0\xf8\xf8\xfd\xfd\x0a\xa9\xac\x9a\x00\x00\
\x00\x9d\x49\x44\x41\x54\x18\x19\x9d\xc1\x03\x16\x02\x01\x00\x05\
\xc0\x9f\x6d\xdb\xb6\x6d\xdb\x76\x5b\x7b\xff\x23\x84\x3d\x40\xef\
\x35\x03\xfc\x89\x2e\x0a\x53\x04\xf8\x62\xca\xea\xe3\x41\xbf\x37\
\xec\xb4\x7d\xf8\x60\x2b\x8a\x33\x62\x52\x1f\x11\xf3\xa2\x1b\x6f\
\x5c\x55\xaa\xb6\x7f\xdc\x17\x04\x79\xc9\xd9\x01\xf0\x35\xd1\x4c\
\xb2\x74\x78\x3c\xc9\x5b\x21\x62\x04\x20\xf1\x47\x42\xc1\xe0\x94\
\x24\x9f\x53\x8f\x53\x0b\x80\xa7\xb6\x58\x6d\x89\xc3\xf5\x74\x3d\
\xe6\x74\x3a\xbc\x71\x94\x06\xfd\xf6\xbc\x29\xaf\xcf\x3b\x97\x1e\
\x1f\x2c\xb9\x23\xbe\xcc\xc7\x2a\xab\x46\xc0\x80\x2f\x86\xd4\x9b\
\xae\x36\xbb\xad\x6a\xd6\x04\x0a\x4d\x68\xa6\x88\xf1\xdb\x0b\x5c\
\x72\x1c\x18\xbd\x2b\x0f\x2f\x00\x00\x00\x00\x49\x45\x4e\x44\xae\
\x42\x60\x82\
\x00\x00\x02\xd2\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\
\x01\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x02\x4f\x49\x44\
\x41\x54\x78\xda\xa5\x93\xcb\x4f\x13\x51\x14\x87\xbf\x3b\x33\x1d\
\x5a\x5b\x0c\x19\xc0\x42\xa0\xe5\x61\x13\x17\x24\xa8\x71\x65\x8c\
\x1b\x8d\x89\x3b\x57\xee\x64\xa7\x0b\x1f\x7b\x48\x7c\x9b\xe0\x42\
\x4d\x8c\x8f\x3f\x42\x57\x2e\x5d\x68\x74\x61\x0a\xa8\x41\x40\x5d\
\xb0\xd0\x50\x1e\xa2\xb5\x0d\x8f\x4e\xa1\x32\x33\x9d\xeb\x1d\x26\
\x4e\x0a\x5b\x4f\x72\x72\xef\xe6\xfb\xf2\x3b\x77\xce\x08\x29\x25\
\xff\x53\x06\xbb\x6a\x4e\x88\xc1\x55\x78\x66\xe6\x72\xc9\xa6\x5c\
\x2e\x16\x4b\xa7\x75\xb7\x58\xac\x3b\xb3\xb3\xf6\x9e\x42\xe1\x6c\
\x9f\x94\x9f\x77\x08\x76\xc3\xa5\x6c\x36\xdf\x79\x77\x34\xd5\x64\
\x59\x08\xa1\x81\xa6\x21\x3d\x17\xa7\x62\x77\x2e\x0f\x0f\xe7\x11\
\xe2\x58\xa3\x24\x18\x21\x82\x17\xbb\xbb\xf2\x3d\x37\x6e\xa6\xcc\
\x8d\x2a\xb2\x5e\x07\xcf\xc3\x57\xa7\xef\xba\xd4\x7d\x1f\x69\xb5\
\xb2\x74\xff\x5e\x35\xf3\x63\x39\x92\x68\xff\xe0\xb9\x8e\xf4\x58\
\xcf\xed\x5b\x29\xbd\x5c\x42\x28\x48\x57\x2d\x2a\x15\x74\xd5\x86\
\x82\x0d\x29\x91\xdf\xbf\x91\x1d\x19\x4e\x15\x3a\x3a\xc6\x02\x86\
\x48\x60\x18\xcf\x7b\xaf\x5f\x4d\x6a\xf3\x0b\xe8\xbe\x4f\xdb\xb9\
\x21\x5a\x87\x86\xd4\x3d\x10\x79\xb4\x9f\xbf\x40\xe7\xc5\x4b\x98\
\x02\xdc\xc9\x49\x7a\xaf\x8d\x24\x03\x26\x7a\x83\x9a\xe7\x25\xaa\
\x1f\x26\x68\x69\x69\x43\x98\x26\x38\x0e\x46\x26\x83\x75\xf9\x0a\
\xc1\x88\x31\x75\x77\x0b\x73\xe8\xab\xab\x18\x2a\xd1\xc6\xfb\x89\
\x6d\x26\x4a\xe0\x80\x60\xb3\x8a\x56\x59\x47\x2f\xfe\x62\x65\xf4\
\x0e\xee\xc2\x3c\x46\x77\x46\xc1\x59\xdc\xc5\x05\xd6\x9f\x3c\x26\
\xae\x44\xcd\x03\x03\x18\xba\xd8\x66\xa2\x04\x1e\x88\x95\xfc\x5b\
\x9a\x8c\x66\xea\xc9\x24\x7a\x36\x1b\x3e\x22\x61\x49\xd7\x65\x63\
\xfa\x13\xde\xf4\x14\x75\xdb\x66\x2d\x11\x32\x8d\x09\x90\x9b\x36\
\xfc\x5c\xc6\x5d\x5f\xa3\xfd\xc1\x43\xcc\xbe\x7e\xfe\x7c\xfd\xb2\
\xdd\x66\xff\x7e\xd2\x8f\x9e\xe2\x27\xe2\x88\x00\xd2\x43\x26\x4a\
\x20\x61\xab\xa6\xb3\xa3\xb6\x14\xb8\x78\xfa\x24\xbe\xef\xd3\xf3\
\xf2\x35\x9a\x69\x22\x01\x01\x54\xf4\x90\x89\xf6\x60\x4a\x88\x83\
\xef\x62\x8c\x0f\x36\x93\xe8\xb2\x41\xdb\xd7\x1e\xda\x83\x4f\x0a\
\xb8\x96\x05\x7a\x0c\x7e\x17\x59\x4a\xc1\x8c\x4d\xed\xb8\xcb\xd1\
\xc3\x52\xce\x44\x8b\x14\x48\xde\x98\x8c\x1f\xd9\x4b\x22\x53\x21\
\x8c\x2a\xc2\x53\x02\xbe\x84\xa5\x16\xc1\xc7\x35\x59\x3b\xe1\x84\
\x70\xe3\x26\x46\x92\x57\x4a\x72\xc0\x57\x49\x52\x49\x62\xf1\x38\
\xba\x61\x50\xf7\x3c\xca\x08\x26\x57\xca\xb5\x53\x0d\xf0\x6e\x41\
\x24\x19\x87\x17\xea\x27\x4a\xc4\x2d\x4b\x0b\x66\xf7\x1d\x07\xaf\
\x54\xaa\x1d\x2a\x97\xcf\x44\x70\xa3\xe0\x7f\xea\x2f\xb2\x2a\x1f\
\x46\x55\x40\xa7\x1e\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
\x00\x00\x03\x60\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x06\x62\x4b\x47\x44\x00\xff\x00\xff\x00\xff\xa0\xbd\
\xa7\x93\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x37\x5c\x00\x00\
\x37\x5c\x01\xcb\xc7\xa4\xb9\x00\x00\x02\xd2\x49\x44\x41\x54\x78\
\xda\x95\x8e\x4d\x68\x9c\x45\x18\xc7\xff\xcf\xcc\xbc\xef\xec\xbb\
\xbb\x6f\xb2\xd9\xb4\x5b\x63\x3e\x68\x44\x5b\xac\x60\xab\xb4\xc5\
\x16\x3f\xa8\xe2\x41\x05\xaf\x16\xf1\xe3\xa0\x50\xf0\xd0\x5e\xea\
\xcd\x83\x17\x4f\x1e\x14\x0a\x82\x57\xd1\x8b\xe2\x51\x2f\xf5\x20\
\x88\x88\xa0\xd2\x58\x9b\x8a\xa9\x36\x9a\xa4\xc9\xa6\x26\xdb\xcd\
\xbb\xbb\xef\xee\xbe\x33\xcf\xe3\xec\xc5\xe6\x24\xf5\xf7\xe7\xcf\
\xcc\x30\xcc\x6f\x1e\x7a\xe2\xed\xeb\x38\x34\x13\xe9\x6a\xd9\xa0\
\xd7\x6a\xd3\x2c\x7a\xfe\x85\xd3\x47\xe4\xfc\x1b\x1f\xce\x4f\xcf\
\x34\x0e\x5f\x5f\x69\x15\x57\xae\xae\xfe\x38\xd1\xd8\xbf\x51\x29\
\x0d\xd4\xd2\xcf\x8b\x6c\x93\x32\x00\x82\x2b\x0a\x10\x02\xaf\x9f\
\xf9\x08\x14\xf2\xfb\x6f\xeb\x70\xec\xd2\xa7\x9f\x3d\xf6\x6e\x3a\
\x51\x79\xf9\xd2\x2f\xeb\xe5\x5e\x5e\x40\x11\x5a\x59\x77\xf8\xde\
\x17\x9f\xbc\xf2\xce\x85\x6f\x0b\x2c\x5e\x5e\x21\xd6\x31\x56\xb7\
\xbc\x1f\x4d\xa0\xef\x9b\x32\x67\x6c\xa4\xa6\x07\x03\x97\x25\xcb\
\x0b\xcf\x1d\x3d\x3a\xf7\x68\x65\x72\x8c\x3f\xfb\x72\x11\x36\xd6\
\xd4\x5c\xdb\xe6\xf1\x34\xd1\x1b\xcb\xcd\x0b\xc7\x9f\x7c\xe8\x6c\
\xe1\x98\xde\x7f\xf3\x84\xd4\xc7\x5f\x83\xb6\x87\xcf\xd6\x4f\x1c\
\x88\x3f\x7d\xf0\x9e\xe4\x99\x41\x73\xfd\xa9\xd4\xf8\xb9\x63\x27\
\xef\xe5\x5b\x03\x56\x9b\xb9\x57\x0b\xd7\x6e\xd2\xca\xcd\x0e\xda\
\x9d\x42\x14\xf0\x30\xaa\xf5\x7a\x32\x7f\xe0\x91\xcf\xbf\xdb\x3e\
\xd2\x38\x79\xea\x27\xa3\x15\x81\x45\x3c\x33\xe3\xf2\x0f\x4b\xae\
\x3e\x51\xd2\x03\x26\x6d\xcb\xb1\x24\xd5\x18\x79\xc9\x0a\x8d\x57\
\x15\x84\x65\xfa\xee\xbd\x26\xb5\xfe\xdc\x03\x33\x4a\xfd\xb9\xae\
\x36\x2f\x2d\x17\x1f\x9b\x5a\x19\xba\x3f\x64\xd3\xea\x14\xd8\xe9\
\x0c\xf5\x52\x33\x53\x07\x7f\x6d\xe2\x96\x13\xfa\xa3\x5b\x20\xbd\
\xab\x46\x7d\x21\x89\x85\x29\x2e\xc5\xe8\x65\x5d\x37\x74\x4e\x8d\
\x3e\x4d\x62\x68\x55\x29\x95\x7c\x5e\xb0\xb4\x07\x82\x28\x29\x21\
\xeb\xe4\xf8\xfa\xea\x26\x56\xc2\x39\xdd\x57\x83\xab\x55\x10\x4f\
\x56\x08\x5a\xf0\xfd\x37\x57\x48\xb4\xd1\xad\x1e\xa3\x37\x64\x5d\
\xb6\xd6\xeb\xf9\x53\x2f\xbd\x05\xf1\x8f\x6f\x65\x83\xd8\x69\x83\
\xc8\x5a\xb2\x13\x63\x98\x4c\x2b\x38\xb8\x27\x05\x39\x42\x04\x85\
\x88\xc3\x1a\x59\x54\xa6\xf6\xa1\xd5\xf7\xd4\xcd\x0b\x08\x67\x9a\
\x5e\xfd\xe0\x5a\xf7\xfe\xd9\xf1\x78\xe8\xd8\x04\xb9\x28\x02\xb9\
\xc2\x43\x00\xe8\x70\x88\x34\xc1\x79\x09\xe5\x20\x8f\xc0\x9e\x25\
\x94\x8c\x56\xb2\xb6\xd5\xe9\x9b\x9e\xb3\xab\x37\x32\x3b\xc7\xcc\
\x06\x01\x11\x81\x30\x01\x44\x28\x59\x0d\xcf\x82\x22\x08\x21\x1a\
\xd4\x55\x20\xd2\x18\xa1\x94\xe2\x8d\x9d\x7c\xcd\xd4\xaa\x51\x3e\
\x55\x37\xc6\x7b\x06\x11\x61\x84\x8c\x22\x08\x65\x00\x0a\x8a\xcc\
\xbf\x77\x80\x84\x40\x54\x30\xe5\xfd\x38\x37\x63\xe5\xa8\xdd\xa8\
\x69\xed\x99\x04\xbb\xa0\x10\xdc\x7e\x03\x09\xd9\xcd\x48\xf8\x77\
\xdb\xb4\x4d\x60\x3b\xb1\x20\x02\x79\xc1\x7f\x41\xbb\x77\xe2\x19\
\xc6\x68\xd3\x32\x73\x8d\xa4\x43\xda\x40\x04\x04\x40\xe1\x0e\x10\
\xc0\x13\x01\xb3\x7b\xd5\x8e\x71\x7f\x7d\x75\x71\x71\x21\x9b\x75\
\xce\x0d\x29\x70\x47\x82\x40\x98\xdc\xee\xa9\xa5\x17\x71\xe8\xb1\
\x17\x11\x88\x42\xed\xff\x6c\x74\xfc\xf9\x73\xf8\x07\x10\x7f\x4e\
\xbe\xda\xd6\x75\xe4\x00\x00\x00\x22\x7a\x54\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x00\x78\xda\x2b\x2f\x2f\xd7\xcb\xcc\xcb\
\x2e\x4e\x4e\x2c\x48\xd5\xcb\x2f\x4a\x07\x00\x36\xd8\x06\x58\x10\
\x53\xca\x5c\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\xac\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\
\x01\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x02\x29\x49\x44\
\x41\x54\x78\xda\x8d\x91\xbf\x4f\x13\x61\x1c\x87\x9f\xf7\xee\xfd\
\xd1\x16\x28\xad\x80\x0a\x8b\x89\xc1\x84\x41\x42\xc2\xe0\x64\xa2\
\xa6\xea\xe0\x22\x8b\x83\xc1\xc4\x18\xff\x01\x17\x9d\x8c\x8b\x31\
\x2e\x0c\x26\x0e\x2c\x98\xe8\x3f\x60\x5c\x4c\x1c\x30\xda\xd9\x01\
\x13\x14\xc2\x20\x1a\xa0\x44\x0c\xa5\xa5\x42\xef\xa0\x77\xf7\x7a\
\xb4\x56\x21\x5c\xa2\xcf\xf2\xe6\xfd\xde\x27\xcf\x7d\xbe\x77\xc2\
\x5a\x8b\xe8\x1b\x9e\x1a\xd0\x1b\xb7\x3d\xcf\xa3\x92\x3e\x05\xa7\
\xc7\xf9\x27\x7e\xed\xae\x2d\xde\x9f\x90\x34\x89\x06\xcf\x17\x2e\
\x72\xef\xc1\x63\xfe\x87\x17\xc5\x15\x9e\x4f\x2f\x8e\x01\xbf\x05\
\xeb\x73\xd5\xcf\xf3\xdd\x5c\xbb\x72\x81\xb0\x6f\x94\xcc\xc8\x0d\
\x1a\x61\xc4\x6e\x60\x69\xa3\xa5\x13\xdf\x23\x00\xc2\xa0\x81\x6a\
\xd4\xfb\x01\x24\x2d\x3e\xe6\x7a\xfb\xaf\x2e\x97\x77\xc8\x9a\x3c\
\xe9\xee\x3e\x2e\x0f\xe5\x18\x3d\x99\x25\x08\x2d\xd9\x8c\x4b\x67\
\x4a\x32\x35\xbd\xc2\x5c\xa9\x0e\xc0\xcf\xf2\xea\x32\x80\xc3\x3e\
\xa2\x20\xc0\x75\x1c\x72\x1d\x9a\x87\xd7\x07\x59\x58\xf5\x78\xfa\
\xa6\xc4\xa3\x97\x4b\x7c\xfd\xe1\xf3\xe4\xd6\x10\x19\xa3\x30\x4a\
\xa2\x94\xe2\xb0\x20\x0a\x71\x5d\x97\xb1\x33\xc7\xc8\x68\x27\x0e\
\xba\x18\xad\xd0\x71\xf8\xd5\x87\x0a\xc7\x73\x9a\x4b\x23\x3d\xcd\
\xbb\x54\x1a\x00\xc9\x3e\xac\xb5\xc8\xb8\xc1\xeb\x99\x2a\xbd\x5d\
\x9a\xd9\x25\x3f\x3e\x0d\x35\x2f\xa4\x30\x9c\x07\x01\x4b\xeb\x41\
\xab\x81\x4c\x10\x80\x8d\x1b\x38\x04\x91\xcb\xb3\xf7\x65\x00\x8c\
\x74\xe8\xe9\x92\xdc\x3c\x77\x34\x5e\x67\x8d\xb5\x5a\x44\x4a\xef\
\x35\x50\x87\x05\x0e\x20\xa5\x4b\x26\xa5\xd9\xcf\xf8\xd9\x3c\xd3\
\x9f\xb6\x78\x37\xef\x35\x9f\x09\x21\x50\xda\x24\x08\x9c\xbd\xbd\
\x35\x9d\xe9\x14\x6d\x3a\x8d\xc3\xc0\x11\xc3\xe4\xdb\x2a\xd9\x78\
\x1e\x01\x02\xd0\x09\x82\x66\xad\x5c\x3e\x4f\x47\xda\xd0\xe6\x44\
\xaf\x64\xb6\x14\xc6\x6f\x4e\x01\x96\xc8\x5a\x40\xa0\x75\xc2\x37\
\x50\xae\x24\x1d\x07\x33\xc6\xfc\x9d\x49\x87\x95\x8a\x25\xa5\x35\
\xae\xd8\x13\x08\x2c\x16\xa5\x92\x1a\x48\x89\x63\x2d\x69\xa3\x69\
\xd3\x88\xc0\x0a\x68\x97\x12\xc2\x36\x07\x2a\xa9\x81\x2b\x5d\x7c\
\xbf\x8e\x8c\x4f\x80\x0e\x03\x77\x0a\x82\x8d\x6d\x98\x2c\xda\x96\
\xe0\x4f\x36\xe1\x2f\x20\x1c\xfc\x1d\x9f\x9d\xdd\x46\x2b\x04\x94\
\x2a\x2a\x5e\x21\x8a\x67\xe1\xc1\xa8\x70\x0f\x08\xbe\x6d\xd5\xaa\
\x78\xdb\x9b\x94\x37\x36\x59\xf8\xb2\x48\x9b\x99\x79\x0e\xb1\x1b\
\x06\xd4\x3d\xef\x3b\xc0\x2f\xbb\xd9\xb9\x56\x43\x7d\x15\xe6\x00\
\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x03\xc9\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xbb\x00\x00\x01\xbb\
\x01\x3a\xec\xe3\xe2\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x03\x46\x49\x44\
\x41\x54\x38\x8d\x65\x93\xcd\x6f\x14\x65\x00\xc6\x7f\xef\xbc\x3b\
\x3b\x3b\xfb\xc5\x2e\xb6\x9b\x52\x1a\x96\xd2\x8a\x21\x6d\x15\xaa\
\x50\xa3\x05\x8c\x36\x0a\x18\x48\x8c\x9a\x18\x0f\x8d\x1a\x0f\x06\
\x13\x0f\x22\xff\x00\x1c\x4c\x4c\x53\xc3\xc1\x8f\x83\x21\x42\x68\
\x24\x22\x1c\xa8\x58\x35\x46\x43\x53\xb5\x40\xd3\x4a\x0c\x69\x89\
\xb6\x29\x6c\x69\xd3\xee\x47\x3f\x76\x67\x66\x77\x76\x66\x5f\x4f\
\x36\x88\xcf\xf9\xc9\xef\xf2\x3c\x3f\xa1\x94\xe2\x81\xe8\xfd\xa7\
\xae\x1a\x93\xb7\x17\x9f\x72\x9c\x6a\x97\x6d\xbb\xde\xf8\xc4\xdc\
\x4f\x96\xed\xde\xcc\xce\x9d\x74\x1f\x2c\x8b\xfb\x00\x72\xea\xf6\
\x52\xec\xcc\xc0\x8d\xbe\x68\x24\xd8\xeb\xd5\x94\x9e\xc9\x5a\x8c\
\xdc\xc8\xe0\xd8\x2e\x9e\xed\x96\xdd\x92\x73\x02\xc5\x47\xd9\xb9\
\x93\xfe\xff\x00\x4f\x3c\xdd\xdf\x74\xe4\xc5\xf6\x61\x11\x90\xcd\
\x8e\x61\xb0\xaa\x69\xcc\xe6\xcb\x48\xdf\xa7\x58\xb0\x58\x59\x5a\
\xa3\x94\x2d\x52\x5e\x2e\x5d\x2b\x17\xac\x97\xb2\x99\x13\x0b\x00\
\x81\x7f\x49\xcf\xec\x6d\xbd\x8c\xa1\x37\x97\x13\x31\xc2\x5b\xeb\
\x71\x35\x49\x2a\x6f\xe3\xaf\xd9\x6c\x4f\x87\x99\x9a\x09\x51\x4c\
\x44\x28\xaf\x94\xba\xec\x5c\xf1\x4b\xe0\x05\x00\x0d\xe0\xb9\x83\
\x9f\xbd\x1f\x8e\x9b\xbb\x2a\x51\x13\xbd\x21\xc9\x72\x2c\xca\xa2\
\x34\xb0\x0d\x83\x57\x9a\x0a\xbc\xdd\xbd\x91\x37\xf7\x47\x29\xeb\
\x92\xb2\x26\xf1\x0d\xfd\xf9\xc7\x7b\x3e\x3d\xba\x0e\x50\x4a\xbd\
\xa5\x4c\x83\xbc\x2f\x98\x29\x56\xb9\x97\xb3\xf1\x1c\x97\x87\x8a\
\x19\xda\x5a\xb6\xe0\x54\x3c\x3e\x3c\x7d\x19\x19\x0a\x12\x08\x07\
\x09\x45\x43\x6c\x4e\x27\x8f\x02\x52\x7e\xf2\x85\x1f\x74\xd1\xfa\
\xdc\xa8\x29\xcb\x86\x41\x09\x0d\x21\x04\xca\xab\xd1\x9a\x9f\xa0\
\x65\x73\x8a\x64\x62\x03\xb6\x2f\xd8\x12\x5a\x65\xa6\x60\xd0\xb9\
\xbd\x8e\x7c\xde\x4a\xae\x2e\x5b\xfd\x32\x1c\xdf\xd7\x11\xab\x8f\
\xbd\x6b\xc9\x00\x89\xfa\x18\x15\x25\x40\x00\x5e\x95\x03\x8d\x3e\
\xe7\xcf\x0f\x50\x75\x3d\x52\x11\xf8\xfe\xea\x38\x76\x30\x4d\x3e\
\x67\xe1\x58\x15\xf9\xfb\xe8\xec\xc5\x00\xb0\xe8\x2b\x85\xf4\x6b\
\xd4\x5c\x8f\xaa\x5f\x26\x20\x7c\x8e\x34\xdc\x63\xfa\xaf\x39\x82\
\x41\x93\xdf\xae\x8f\x73\x6b\x36\x47\xac\xe3\x75\xf4\x95\x0a\xe5\
\x8a\x47\x50\x13\x58\x4e\x75\x41\x28\xa5\x78\xe4\xc9\x8f\xe7\x65\
\x6a\xc3\xa6\x64\xd3\x46\xea\x53\x11\x0e\x6f\x5b\xe4\xe7\x1f\xbe\
\xc3\x4c\x34\x30\x56\x6a\x24\x5c\xb7\x0d\x21\x4c\x22\x02\x7c\xc7\
\x45\x54\x5c\xe6\xee\xe4\x17\xa6\x7e\x7c\xa7\x51\x03\x90\x1a\x23\
\xca\xa9\xa2\x1c\x8b\x43\x4d\x77\xb9\xf4\xf5\x57\xa4\x1a\xb7\x72\
\xb3\xb6\x93\x58\x43\x07\x42\x85\x50\xae\x47\x22\x24\x89\x85\x24\
\xf3\x8b\x45\x6a\xbe\x1a\x5e\x5f\xa1\xb0\x54\x3c\xd6\xb8\xc9\x28\
\xbd\xd6\x59\x60\xe0\xdc\x19\x76\x76\xee\xe1\x97\xf9\x26\xa4\x4c\
\x10\xf4\x7d\x52\x66\x80\x96\xfa\x30\xb9\x6c\x89\xbf\x67\x72\x08\
\x4d\x5b\xf3\x2b\xd5\xe3\xeb\x47\xfa\xbc\xef\xd1\xd8\xe4\xe4\x64\
\xe4\xec\xd9\x6f\x38\x70\xf0\x30\xc3\xd3\x09\xda\x5b\x5a\x59\xb3\
\xaa\xe8\x52\xb0\xba\x62\x31\x93\xb7\x30\x0c\x1d\x2d\x1a\xc6\x5b\
\x2e\x1d\x9b\x1e\x79\x2f\x03\x20\xdb\xda\xda\x76\x58\x96\xf5\xeb\
\x95\x2b\xdf\x9a\xfb\xf6\xee\xf7\x87\x33\x75\x56\xfc\xe1\xc7\x0c\
\x57\x68\x24\x92\x26\x79\xdb\x67\xb5\x26\xd0\x93\x71\x64\x48\xcf\
\xfb\x6b\xf6\x1b\x7f\x5e\xec\x3d\xb7\x2e\x50\x3a\x9d\x3e\x1e\x8f\
\xc7\x2f\xec\xde\xbd\xe7\xd9\xc1\xc1\xc1\x97\xa7\x67\x9b\x3f\x28\
\xd9\x6e\xcd\xae\xa1\x2d\x59\x6e\xac\xe2\xab\x4a\xc2\xd4\x6e\xe9\
\xae\x7b\x49\xdd\x5d\x7a\xf5\xfa\x85\xde\xb1\xff\xd8\xd8\xdd\xdd\
\xdd\xde\xd3\xd3\x73\x7a\x74\x74\xf4\xd4\xd0\xd0\xd0\x80\x10\x22\
\x05\xec\x00\x76\x01\x5d\x40\x1c\xf8\x03\x98\x00\xc6\x80\x3b\xea\
\x3e\x85\xff\x01\xeb\xf9\x7f\xc7\xb1\xde\x54\x6d\x00\x00\x00\x00\
\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x03\xb6\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xff\x61\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x37\x5c\x00\x00\x37\x5c\
\x01\xcb\xc7\xa4\xb9\x00\x00\x00\x06\x62\x4b\x47\x44\x00\xff\x00\
\xff\x00\xff\xa0\xbd\xa7\x93\x00\x00\x03\x28\x49\x44\x41\x54\x78\
\xda\x75\x92\x5b\x48\x93\x61\x18\xc7\xff\xdf\x3e\xf2\xd8\xb9\x70\
\x98\x41\x75\x63\x45\x46\x84\xdd\x74\x22\x0c\xea\x22\xa2\xc3\x45\
\x17\x19\xd9\x41\xd3\x9d\x9c\x3b\x1f\xdc\xd1\x22\x2d\x6d\x6b\xe5\
\x37\x91\x8a\x72\xd3\xcd\x39\x4f\xe5\x74\x82\xe6\x66\x90\xb9\x42\
\x8b\x0a\x5a\xd8\x61\xe4\x5d\x4a\x12\x23\x3a\xd8\xe1\xed\x5d\x48\
\x10\xb1\x1f\xfc\xee\xde\xff\xf3\x3e\xfc\x79\x90\x0c\x8f\xb7\x05\
\x07\x0f\x1d\x80\xcb\xd5\x04\xce\x59\xcf\xd8\x2f\xdb\x20\x91\x88\
\x37\xf8\xdb\xfd\x8d\x43\x43\x83\xb7\x3c\xde\xe6\x1d\x4f\x9f\x3d\
\x41\x52\x9c\x0d\x1c\x14\x4a\x19\xca\x04\x67\x98\xcd\xf9\x9b\xb0\
\x73\xd7\x76\x7e\x28\x34\x34\x19\x8f\xc7\x49\x9b\xdf\xf7\xc9\x5a\
\x65\x36\xbc\x8d\xbd\x41\x52\xba\xbb\xbb\x50\x2e\x95\xd0\x21\x72\
\xb6\xb8\xe4\x14\x84\x22\x41\xf1\xf8\xe3\x31\x32\x35\xf5\xfe\xb3\
\xc5\x62\x5e\x5b\x77\xa9\x16\xd7\xae\x5f\x63\xfe\x0b\xce\xcc\x7c\
\x40\x38\x1c\x46\xe4\x61\x04\xaf\xdf\x4c\xc0\xd7\xe6\xe5\x95\x9c\
\x39\x89\x7a\xee\x4a\x5f\x4f\xe0\x0e\x99\x9e\x9e\x22\xde\x56\x4f\
\x51\x30\x18\x44\x8b\xc7\x9d\xfb\x4f\x78\xf8\x5e\x08\x09\x94\x6a\
\x15\x0d\xd4\xa3\xa3\xb3\x9d\x9d\x98\x78\x89\x47\x8f\x22\x9b\x9a\
\x5b\xdc\xdf\x04\x62\xf1\x8f\x50\x38\xf4\xab\xb3\xab\x63\xe6\xf6\
\x9d\xee\x57\x2e\x77\x53\xeb\xdf\x70\x6d\x5d\x0d\x2d\xeb\x0a\x2d\
\xcf\x0d\x9b\xfd\x42\xa2\x38\x36\xfa\x32\x8a\xb1\xb1\x31\xfe\x68\
\x64\x74\xa4\xcd\xef\x27\x47\x8e\x16\xfe\xe4\x1a\x1a\x7e\x86\xc2\
\x43\xc4\x6e\xb7\xbd\x16\x89\x45\xab\x90\x40\xae\xac\x80\x4a\xa3\
\x80\x46\xa7\x82\x5c\x21\xc5\xd9\x73\x55\x6c\xa0\x2f\x80\xf0\x70\
\x68\xab\x5c\x21\x8f\xe5\x6f\xc9\x27\x03\x83\x03\xd3\xd5\x35\xd5\
\xbe\x8b\xb5\x17\x6b\x9c\x4e\xae\x2c\x8b\x9f\x95\x95\x96\x96\x0a\
\x58\xaa\x4c\xd0\x1b\xb4\x30\x9a\xf4\x74\x75\x39\x23\x10\x96\xf1\
\x8e\x17\x15\xd1\x2d\xea\x04\x87\x0e\x1f\xfc\x92\xbd\x22\x9b\x88\
\x25\xe2\x17\x8f\x9f\x8c\xe7\xce\xce\x7e\xc5\x83\xd1\x11\xa6\xbf\
\x3f\x88\xc1\xbb\x83\xb0\x5a\xad\x0c\x08\x21\x18\x89\xdc\x87\x5a\
\xab\xe4\xd9\x1c\x56\x28\x54\xe5\x69\x6a\x8d\xf2\xc6\x9e\xbd\x7b\
\x48\xce\xca\x1c\x42\x07\x8e\xc7\xe3\x1f\xb3\x13\xef\xcc\x56\x2b\
\xeb\x6e\x76\x53\x5d\x6c\xde\xc6\x3c\x66\xdb\xb6\xad\xc0\xf1\xa2\
\x63\xa8\x34\x6a\x59\xa1\xb8\x14\xa7\x4b\x4e\xac\x91\x2b\x65\x0f\
\x0b\x8f\x15\x92\x82\xdd\x05\xf4\x67\xd1\xe8\x8b\xe8\xf3\x65\x84\
\x7c\x47\x57\x77\x27\x2f\xd8\xdf\x47\x8b\x1e\xc6\xbb\xc9\x49\x70\
\x9c\x03\x7f\x30\x59\x0c\x3c\xa5\x5a\x06\x71\xb9\x70\x9f\x4e\xaf\
\x99\x36\x18\x0d\x44\x28\x12\x12\xa5\x5a\x71\xaf\xa7\xb7\x6b\x51\
\x6c\x32\x8a\x26\xd7\x4d\xde\x8d\x9b\xd7\x41\x5b\x47\x5b\xbb\x0f\
\x81\x9e\x0e\xfc\xa5\xa0\x60\x37\xa3\x50\xc9\x2e\xd0\x43\x21\x15\
\xb2\x8a\x59\xa3\xc9\x48\x2a\x8d\xba\xbb\xe7\xce\x9b\xe7\x57\xd7\
\xe9\x60\x77\x5c\x62\xec\x0e\x1b\x38\xe7\x55\x7a\x38\x8d\x88\xc5\
\xa2\xf8\x07\x5d\xa5\xda\x68\x30\xe9\x34\x15\x32\x69\xa8\xb8\xa4\
\x98\x68\xf5\xea\x9e\x52\xc1\xc9\x74\xad\xd4\x0b\x81\xa8\x94\x07\
\x4a\x66\x66\x26\x92\x62\xb6\x18\x3c\xad\x3e\xcf\x3c\xbd\x41\xc3\
\xe9\xf4\xea\xde\x8f\x5f\x26\x98\x8e\x40\x23\xea\x9d\x0e\x34\xb7\
\x34\x25\x4a\xfe\x63\x32\xe8\x06\x9a\xfd\xd4\x5e\x89\x54\x74\x7e\
\xf5\x9a\x55\xf3\xd3\xd3\xd3\x17\xa7\xa4\xa6\x2c\x07\xb0\x94\xba\
\x84\xba\x88\xba\x80\x9a\x41\x4d\xa3\xa6\x50\x59\x2a\x83\x04\xeb\
\xd7\xaf\x43\xee\xda\xdc\x05\xa9\x94\x8c\x8c\x0c\x3e\xcb\xb2\x39\
\x00\xb2\xe7\xe4\x53\x97\xcf\x0d\x5a\x48\xcd\x9c\x1b\x32\x8f\xca\
\x03\xe5\x37\x40\x64\x67\x7f\x6c\xb6\xdc\xf4\x00\x00\x00\x22\x7a\
\x54\x58\x74\x53\x6f\x66\x74\x77\x61\x72\x65\x00\x00\x78\xda\x2b\
\x2f\x2f\xd7\xcb\xcc\xcb\x2e\x4e\x4e\x2c\x48\xd5\xcb\x2f\x4a\x07\
\x00\x36\xd8\x06\x58\x10\x53\xca\x5c\x00\x00\x00\x00\x49\x45\x4e\
\x44\xae\x42\x60\x82\
"

qt_resource_name = "\
\x00\x05\
\x00\x6f\xa6\x53\
\x00\x69\
\x00\x63\x00\x6f\x00\x6e\x00\x73\
\x00\x0e\
\x06\x0c\xe6\x07\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x64\x00\x6f\x00\x77\x00\x6e\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x09\
\x06\xc7\x98\x67\
\x00\x61\
\x00\x62\x00\x6f\x00\x75\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x0b\x63\x58\x07\
\x00\x73\
\x00\x74\x00\x6f\x00\x70\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x0c\xac\x40\xd6\
\x00\x62\
\x00\x75\x00\x73\x00\x79\x00\x2e\x00\x67\x00\x69\x00\x66\
\x00\x08\
\x0f\x07\x5a\xc7\
\x00\x65\
\x00\x78\x00\x69\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x07\
\x08\x73\x57\x87\
\x00\x61\
\x00\x70\x00\x70\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x09\
\x08\x97\xa2\x07\
\x00\x73\
\x00\x74\x00\x61\x00\x72\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x06\x7c\x5a\x07\
\x00\x63\
\x00\x6f\x00\x70\x00\x79\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x08\xc8\x58\x67\
\x00\x73\
\x00\x61\x00\x76\x00\x65\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x09\
\x0b\x85\x83\x07\
\x00\x63\
\x00\x6c\x00\x65\x00\x61\x00\x72\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0a\
\x09\xb2\x67\xc7\
\x00\x63\
\x00\x61\x00\x6e\x00\x63\x00\x65\x00\x6c\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0a\
\x00\x4a\x9d\x27\
\x00\x6f\
\x00\x6e\x00\x6c\x00\x69\x00\x6e\x00\x65\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x08\
\x0c\x33\x5a\x87\
\x00\x68\
\x00\x65\x00\x6c\x00\x70\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0b\
\x06\xba\xa1\x47\
\x00\x6f\
\x00\x70\x00\x74\x00\x69\x00\x6f\x00\x6e\x00\x73\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0f\
\x0e\x5e\x99\xe7\
\x00\x70\
\x00\x72\x00\x65\x00\x66\x00\x65\x00\x72\x00\x65\x00\x6e\x00\x63\x00\x65\x00\x73\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct = "\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x0f\x00\x00\x00\x02\
\x00\x00\x01\x16\x00\x00\x00\x00\x00\x01\x00\x00\x20\xac\
\x00\x00\x00\x10\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x00\xb8\x00\x00\x00\x00\x00\x01\x00\x00\x16\x1a\
\x00\x00\x01\x46\x00\x00\x00\x00\x00\x01\x00\x00\x26\xc0\
\x00\x00\x00\x32\x00\x00\x00\x00\x00\x01\x00\x00\x01\xc0\
\x00\x00\x00\x8c\x00\x00\x00\x00\x00\x01\x00\x00\x0f\xe0\
\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x01\x00\x00\x14\x21\
\x00\x00\x00\xce\x00\x00\x00\x00\x00\x01\x00\x00\x18\x03\
\x00\x00\x00\xfc\x00\x00\x00\x00\x00\x01\x00\x00\x1d\xd6\
\x00\x00\x00\x4a\x00\x00\x00\x00\x00\x01\x00\x00\x04\xe7\
\x00\x00\x00\xe4\x00\x00\x00\x00\x00\x01\x00\x00\x1b\x4e\
\x00\x00\x01\x30\x00\x00\x00\x00\x00\x01\x00\x00\x24\x10\
\x00\x00\x00\x60\x00\x00\x00\x00\x00\x01\x00\x00\x06\xde\
\x00\x00\x01\x62\x00\x00\x00\x00\x00\x01\x00\x00\x2a\x8d\
\x00\x00\x00\x76\x00\x00\x00\x00\x00\x01\x00\x00\x0c\x92\
"

def qInitResources():
    QtCore.qRegisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)

def qCleanupResources():
    QtCore.qUnregisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)

qInitResources()

########NEW FILE########
__FILENAME__ = linkchecker_ui_debug
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ui/debug.ui'
#
# Created: Fri Feb 28 21:24:59 2014
#      by: PyQt4 UI code generator 4.9.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_DebugDialog(object):
    def setupUi(self, DebugDialog):
        DebugDialog.setObjectName(_fromUtf8("DebugDialog"))
        DebugDialog.setWindowModality(QtCore.Qt.ApplicationModal)
        DebugDialog.resize(564, 547)
        self.verticalLayout = QtGui.QVBoxLayout(DebugDialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.frame = QtGui.QFrame(DebugDialog)
        self.frame.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.frame)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.textEdit = QtGui.QPlainTextEdit(self.frame)
        self.textEdit.setUndoRedoEnabled(False)
        self.textEdit.setReadOnly(True)
        self.textEdit.setPlainText(_fromUtf8(""))
        self.textEdit.setObjectName(_fromUtf8("textEdit"))
        self.verticalLayout_2.addWidget(self.textEdit)
        self.verticalLayout.addWidget(self.frame)

        self.retranslateUi(DebugDialog)
        QtCore.QMetaObject.connectSlotsByName(DebugDialog)

    def retranslateUi(self, DebugDialog):
        DebugDialog.setWindowTitle(_("LinkChecker debug log"))


########NEW FILE########
__FILENAME__ = linkchecker_ui_editor
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ui/editor.ui'
#
# Created: Mon Dec 12 19:00:37 2011
#      by: PyQt4 UI code generator 4.8.6
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_EditorDialog(object):
    def setupUi(self, EditorDialog):
        EditorDialog.setObjectName(_fromUtf8("EditorDialog"))
        EditorDialog.setWindowModality(QtCore.Qt.ApplicationModal)
        EditorDialog.resize(640, 600)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(EditorDialog.sizePolicy().hasHeightForWidth())
        EditorDialog.setSizePolicy(sizePolicy)
        EditorDialog.setWindowTitle(_("LinkChecker source view"))
        self.verticalLayout = QtGui.QVBoxLayout(EditorDialog)
        self.verticalLayout.setMargin(0)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.menubar = QtGui.QMenuBar(EditorDialog)
        self.menubar.setObjectName(_fromUtf8("menubar"))
        self.menuFile = QtGui.QMenu(self.menubar)
        self.menuFile.setTitle(_("&File"))
        self.menuFile.setObjectName(_fromUtf8("menuFile"))
        self.verticalLayout.addWidget(self.menubar)
        self.frame = QtGui.QFrame(EditorDialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame.sizePolicy().hasHeightForWidth())
        self.frame.setSizePolicy(sizePolicy)
        self.frame.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame.setFrameShadow(QtGui.QFrame.Plain)
        self.frame.setLineWidth(0)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.verticalLayout.addWidget(self.frame)
        self.actionSave = QtGui.QAction(EditorDialog)
        self.actionSave.setText(_("&Save"))
        self.actionSave.setShortcut(_("Ctrl+S"))
        self.actionSave.setObjectName(_fromUtf8("actionSave"))
        self.menuFile.addAction(self.actionSave)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(EditorDialog)
        QtCore.QMetaObject.connectSlotsByName(EditorDialog)

    def retranslateUi(self, EditorDialog):
        pass


########NEW FILE########
__FILENAME__ = linkchecker_ui_main
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ui/main.ui'
#
# Created: Fri Feb 28 21:24:58 2014
#      by: PyQt4 UI code generator 4.9.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName(_fromUtf8("MainWindow"))
        MainWindow.resize(713, 627)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/app.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        MainWindow.setStatusTip(_fromUtf8(""))
        self.centralwidget = QtGui.QWidget(MainWindow)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setMargin(4)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout()
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.label = QtGui.QLabel(self.centralwidget)
        self.label.setObjectName(_fromUtf8("label"))
        self.horizontalLayout_3.addWidget(self.label)
        spacerItem = QtGui.QSpacerItem(4, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem)
        self.urlinput = LineEdit(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.urlinput.sizePolicy().hasHeightForWidth())
        self.urlinput.setSizePolicy(sizePolicy)
        self.urlinput.setMaxLength(2048)
        self.urlinput.setObjectName(_fromUtf8("urlinput"))
        self.horizontalLayout_3.addWidget(self.urlinput)
        spacerItem1 = QtGui.QSpacerItem(10, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        self.controlButton = QtGui.QPushButton(self.centralwidget)
        self.controlButton.setStatusTip(_fromUtf8(""))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/start.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.controlButton.setIcon(icon1)
        self.controlButton.setDefault(True)
        self.controlButton.setObjectName(_fromUtf8("controlButton"))
        self.horizontalLayout_3.addWidget(self.controlButton)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_4 = QtGui.QHBoxLayout()
        self.horizontalLayout_4.setSizeConstraint(QtGui.QLayout.SetDefaultConstraint)
        self.horizontalLayout_4.setContentsMargins(0, 0, -1, -1)
        self.horizontalLayout_4.setObjectName(_fromUtf8("horizontalLayout_4"))
        self.label_29 = QtGui.QLabel(self.centralwidget)
        self.label_29.setObjectName(_fromUtf8("label_29"))
        self.horizontalLayout_4.addWidget(self.label_29)
        self.label_32 = QtGui.QLabel(self.centralwidget)
        self.label_32.setObjectName(_fromUtf8("label_32"))
        self.horizontalLayout_4.addWidget(self.label_32)
        self.label_active = QtGui.QLabel(self.centralwidget)
        self.label_active.setMinimumSize(QtCore.QSize(40, 0))
        self.label_active.setObjectName(_fromUtf8("label_active"))
        self.horizontalLayout_4.addWidget(self.label_active)
        self.label_30 = QtGui.QLabel(self.centralwidget)
        self.label_30.setObjectName(_fromUtf8("label_30"))
        self.horizontalLayout_4.addWidget(self.label_30)
        self.label_queued = QtGui.QLabel(self.centralwidget)
        self.label_queued.setMinimumSize(QtCore.QSize(40, 0))
        self.label_queued.setObjectName(_fromUtf8("label_queued"))
        self.horizontalLayout_4.addWidget(self.label_queued)
        self.label_28 = QtGui.QLabel(self.centralwidget)
        self.label_28.setObjectName(_fromUtf8("label_28"))
        self.horizontalLayout_4.addWidget(self.label_28)
        self.label_checked = QtGui.QLabel(self.centralwidget)
        self.label_checked.setMinimumSize(QtCore.QSize(50, 0))
        self.label_checked.setObjectName(_fromUtf8("label_checked"))
        self.horizontalLayout_4.addWidget(self.label_checked)
        self.label_15 = QtGui.QLabel(self.centralwidget)
        self.label_15.setObjectName(_fromUtf8("label_15"))
        self.horizontalLayout_4.addWidget(self.label_15)
        self.label_busy = QtGui.QLabel(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(16)
        sizePolicy.setVerticalStretch(16)
        sizePolicy.setHeightForWidth(self.label_busy.sizePolicy().hasHeightForWidth())
        self.label_busy.setSizePolicy(sizePolicy)
        self.label_busy.setMinimumSize(QtCore.QSize(16, 16))
        self.label_busy.setObjectName(_fromUtf8("label_busy"))
        self.horizontalLayout_4.addWidget(self.label_busy)
        self.label_status = QtGui.QLabel(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_status.sizePolicy().hasHeightForWidth())
        self.label_status.setSizePolicy(sizePolicy)
        self.label_status.setText(_fromUtf8(""))
        self.label_status.setObjectName(_fromUtf8("label_status"))
        self.horizontalLayout_4.addWidget(self.label_status)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        self.treeView = QtGui.QTreeView(self.centralwidget)
        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeView.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.treeView.setAlternatingRowColors(True)
        self.treeView.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        self.treeView.setRootIsDecorated(False)
        self.treeView.setUniformRowHeights(True)
        self.treeView.setItemsExpandable(False)
        self.treeView.setSortingEnabled(False)
        self.treeView.setAllColumnsShowFocus(True)
        self.treeView.setExpandsOnDoubleClick(False)
        self.treeView.setObjectName(_fromUtf8("treeView"))
        self.verticalLayout.addWidget(self.treeView)
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.url_properties = QtGui.QGroupBox(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.url_properties.sizePolicy().hasHeightForWidth())
        self.url_properties.setSizePolicy(sizePolicy)
        self.url_properties.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.url_properties.setObjectName(_fromUtf8("url_properties"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.url_properties)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.frame = QtGui.QFrame(self.url_properties)
        self.frame.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame.setFrameShadow(QtGui.QFrame.Plain)
        self.frame.setLineWidth(0)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.formLayout = QtGui.QFormLayout(self.frame)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.ExpandingFieldsGrow)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.label_2 = QtGui.QLabel(self.frame)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label_2)
        self.prop_url = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_url.sizePolicy().hasHeightForWidth())
        self.prop_url.setSizePolicy(sizePolicy)
        self.prop_url.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_url.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_url.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_url.setText(_fromUtf8(""))
        self.prop_url.setTextFormat(QtCore.Qt.RichText)
        self.prop_url.setOpenExternalLinks(True)
        self.prop_url.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_url.setObjectName(_fromUtf8("prop_url"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.prop_url)
        self.label_3 = QtGui.QLabel(self.frame)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_3)
        self.prop_name = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_name.sizePolicy().hasHeightForWidth())
        self.prop_name.setSizePolicy(sizePolicy)
        self.prop_name.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_name.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_name.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_name.setText(_fromUtf8(""))
        self.prop_name.setTextFormat(QtCore.Qt.PlainText)
        self.prop_name.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_name.setObjectName(_fromUtf8("prop_name"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.FieldRole, self.prop_name)
        self.label_4 = QtGui.QLabel(self.frame)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.label_4)
        self.prop_parenturl = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_parenturl.sizePolicy().hasHeightForWidth())
        self.prop_parenturl.setSizePolicy(sizePolicy)
        self.prop_parenturl.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_parenturl.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_parenturl.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_parenturl.setText(_fromUtf8(""))
        self.prop_parenturl.setTextFormat(QtCore.Qt.RichText)
        self.prop_parenturl.setOpenExternalLinks(True)
        self.prop_parenturl.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_parenturl.setObjectName(_fromUtf8("prop_parenturl"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.FieldRole, self.prop_parenturl)
        self.label_5 = QtGui.QLabel(self.frame)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.label_5)
        self.prop_base = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_base.sizePolicy().hasHeightForWidth())
        self.prop_base.setSizePolicy(sizePolicy)
        self.prop_base.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_base.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_base.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_base.setText(_fromUtf8(""))
        self.prop_base.setTextFormat(QtCore.Qt.RichText)
        self.prop_base.setOpenExternalLinks(False)
        self.prop_base.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_base.setObjectName(_fromUtf8("prop_base"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.FieldRole, self.prop_base)
        self.label_7 = QtGui.QLabel(self.frame)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.LabelRole, self.label_7)
        self.prop_checktime = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_checktime.sizePolicy().hasHeightForWidth())
        self.prop_checktime.setSizePolicy(sizePolicy)
        self.prop_checktime.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_checktime.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_checktime.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_checktime.setText(_fromUtf8(""))
        self.prop_checktime.setTextFormat(QtCore.Qt.PlainText)
        self.prop_checktime.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_checktime.setObjectName(_fromUtf8("prop_checktime"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.FieldRole, self.prop_checktime)
        self.label_8 = QtGui.QLabel(self.frame)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.LabelRole, self.label_8)
        self.prop_dltime = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_dltime.sizePolicy().hasHeightForWidth())
        self.prop_dltime.setSizePolicy(sizePolicy)
        self.prop_dltime.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_dltime.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_dltime.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_dltime.setText(_fromUtf8(""))
        self.prop_dltime.setTextFormat(QtCore.Qt.PlainText)
        self.prop_dltime.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_dltime.setObjectName(_fromUtf8("prop_dltime"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.FieldRole, self.prop_dltime)
        self.label_9 = QtGui.QLabel(self.frame)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.LabelRole, self.label_9)
        self.prop_size = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_size.sizePolicy().hasHeightForWidth())
        self.prop_size.setSizePolicy(sizePolicy)
        self.prop_size.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_size.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_size.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_size.setText(_fromUtf8(""))
        self.prop_size.setTextFormat(QtCore.Qt.PlainText)
        self.prop_size.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_size.setObjectName(_fromUtf8("prop_size"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.FieldRole, self.prop_size)
        self.label_10 = QtGui.QLabel(self.frame)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.formLayout.setWidget(8, QtGui.QFormLayout.LabelRole, self.label_10)
        self.prop_info = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_info.sizePolicy().hasHeightForWidth())
        self.prop_info.setSizePolicy(sizePolicy)
        self.prop_info.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_info.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_info.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_info.setText(_fromUtf8(""))
        self.prop_info.setTextFormat(QtCore.Qt.PlainText)
        self.prop_info.setWordWrap(True)
        self.prop_info.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_info.setObjectName(_fromUtf8("prop_info"))
        self.formLayout.setWidget(8, QtGui.QFormLayout.FieldRole, self.prop_info)
        self.label_11 = QtGui.QLabel(self.frame)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.formLayout.setWidget(9, QtGui.QFormLayout.LabelRole, self.label_11)
        self.prop_warning = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_warning.sizePolicy().hasHeightForWidth())
        self.prop_warning.setSizePolicy(sizePolicy)
        self.prop_warning.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_warning.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_warning.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_warning.setText(_fromUtf8(""))
        self.prop_warning.setTextFormat(QtCore.Qt.PlainText)
        self.prop_warning.setScaledContents(True)
        self.prop_warning.setWordWrap(True)
        self.prop_warning.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_warning.setObjectName(_fromUtf8("prop_warning"))
        self.formLayout.setWidget(9, QtGui.QFormLayout.FieldRole, self.prop_warning)
        self.label_12 = QtGui.QLabel(self.frame)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.formLayout.setWidget(10, QtGui.QFormLayout.LabelRole, self.label_12)
        self.prop_result = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_result.sizePolicy().hasHeightForWidth())
        self.prop_result.setSizePolicy(sizePolicy)
        self.prop_result.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_result.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_result.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_result.setText(_fromUtf8(""))
        self.prop_result.setTextFormat(QtCore.Qt.PlainText)
        self.prop_result.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_result.setObjectName(_fromUtf8("prop_result"))
        self.formLayout.setWidget(10, QtGui.QFormLayout.FieldRole, self.prop_result)
        self.label_16 = QtGui.QLabel(self.frame)
        self.label_16.setObjectName(_fromUtf8("label_16"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.LabelRole, self.label_16)
        self.prop_modified = QtGui.QLabel(self.frame)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.prop_modified.sizePolicy().hasHeightForWidth())
        self.prop_modified.setSizePolicy(sizePolicy)
        self.prop_modified.setMinimumSize(QtCore.QSize(300, 0))
        self.prop_modified.setFrameShape(QtGui.QFrame.StyledPanel)
        self.prop_modified.setFrameShadow(QtGui.QFrame.Sunken)
        self.prop_modified.setText(_fromUtf8(""))
        self.prop_modified.setTextFormat(QtCore.Qt.PlainText)
        self.prop_modified.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.prop_modified.setObjectName(_fromUtf8("prop_modified"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.FieldRole, self.prop_modified)
        self.horizontalLayout_2.addWidget(self.frame)
        self.horizontalLayout.addWidget(self.url_properties)
        self.statistics = QtGui.QFrame(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.statistics.sizePolicy().hasHeightForWidth())
        self.statistics.setSizePolicy(sizePolicy)
        self.statistics.setLineWidth(0)
        self.statistics.setObjectName(_fromUtf8("statistics"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.statistics)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.groupBox = QtGui.QGroupBox(self.statistics)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())
        self.groupBox.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.groupBox.setFont(font)
        self.groupBox.setObjectName(_fromUtf8("groupBox"))
        self.gridLayout = QtGui.QGridLayout(self.groupBox)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_24 = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_24.sizePolicy().hasHeightForWidth())
        self.label_24.setSizePolicy(sizePolicy)
        self.label_24.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_24.setObjectName(_fromUtf8("label_24"))
        self.gridLayout.addWidget(self.label_24, 0, 0, 1, 1)
        self.stats_valid_urls = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_valid_urls.sizePolicy().hasHeightForWidth())
        self.stats_valid_urls.setSizePolicy(sizePolicy)
        self.stats_valid_urls.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_valid_urls.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_valid_urls.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_valid_urls.setText(_fromUtf8(""))
        self.stats_valid_urls.setTextFormat(QtCore.Qt.RichText)
        self.stats_valid_urls.setOpenExternalLinks(True)
        self.stats_valid_urls.setObjectName(_fromUtf8("stats_valid_urls"))
        self.gridLayout.addWidget(self.stats_valid_urls, 0, 1, 1, 1)
        self.label_26 = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_26.sizePolicy().hasHeightForWidth())
        self.label_26.setSizePolicy(sizePolicy)
        self.label_26.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_26.setObjectName(_fromUtf8("label_26"))
        self.gridLayout.addWidget(self.label_26, 0, 2, 1, 1)
        self.stats_warnings = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_warnings.sizePolicy().hasHeightForWidth())
        self.stats_warnings.setSizePolicy(sizePolicy)
        self.stats_warnings.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_warnings.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_warnings.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_warnings.setText(_fromUtf8(""))
        self.stats_warnings.setTextFormat(QtCore.Qt.RichText)
        self.stats_warnings.setOpenExternalLinks(True)
        self.stats_warnings.setObjectName(_fromUtf8("stats_warnings"))
        self.gridLayout.addWidget(self.stats_warnings, 0, 3, 1, 1)
        self.label_25 = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_25.sizePolicy().hasHeightForWidth())
        self.label_25.setSizePolicy(sizePolicy)
        self.label_25.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_25.setObjectName(_fromUtf8("label_25"))
        self.gridLayout.addWidget(self.label_25, 1, 0, 1, 1)
        self.stats_invalid_urls = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_invalid_urls.sizePolicy().hasHeightForWidth())
        self.stats_invalid_urls.setSizePolicy(sizePolicy)
        self.stats_invalid_urls.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_invalid_urls.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_invalid_urls.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_invalid_urls.setText(_fromUtf8(""))
        self.stats_invalid_urls.setTextFormat(QtCore.Qt.RichText)
        self.stats_invalid_urls.setOpenExternalLinks(True)
        self.stats_invalid_urls.setObjectName(_fromUtf8("stats_invalid_urls"))
        self.gridLayout.addWidget(self.stats_invalid_urls, 1, 1, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox)
        self.groupBox_3 = QtGui.QGroupBox(self.statistics)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_3.sizePolicy().hasHeightForWidth())
        self.groupBox_3.setSizePolicy(sizePolicy)
        self.groupBox_3.setObjectName(_fromUtf8("groupBox_3"))
        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox_3)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_6 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_6.sizePolicy().hasHeightForWidth())
        self.label_6.setSizePolicy(sizePolicy)
        self.label_6.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_2.addWidget(self.label_6, 0, 0, 1, 1)
        self.stats_content_image = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_image.sizePolicy().hasHeightForWidth())
        self.stats_content_image.setSizePolicy(sizePolicy)
        self.stats_content_image.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_image.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_image.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_image.setText(_fromUtf8(""))
        self.stats_content_image.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_image.setOpenExternalLinks(True)
        self.stats_content_image.setObjectName(_fromUtf8("stats_content_image"))
        self.gridLayout_2.addWidget(self.stats_content_image, 0, 1, 1, 1)
        self.label_13 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_13.sizePolicy().hasHeightForWidth())
        self.label_13.setSizePolicy(sizePolicy)
        self.label_13.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_13.setObjectName(_fromUtf8("label_13"))
        self.gridLayout_2.addWidget(self.label_13, 0, 2, 1, 1)
        self.stats_content_text = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_text.sizePolicy().hasHeightForWidth())
        self.stats_content_text.setSizePolicy(sizePolicy)
        self.stats_content_text.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_text.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_text.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_text.setText(_fromUtf8(""))
        self.stats_content_text.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_text.setOpenExternalLinks(True)
        self.stats_content_text.setObjectName(_fromUtf8("stats_content_text"))
        self.gridLayout_2.addWidget(self.stats_content_text, 0, 3, 1, 1)
        self.label_27 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_27.sizePolicy().hasHeightForWidth())
        self.label_27.setSizePolicy(sizePolicy)
        self.label_27.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_27.setObjectName(_fromUtf8("label_27"))
        self.gridLayout_2.addWidget(self.label_27, 0, 4, 1, 1)
        self.stats_content_application = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_application.sizePolicy().hasHeightForWidth())
        self.stats_content_application.setSizePolicy(sizePolicy)
        self.stats_content_application.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_application.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_application.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_application.setText(_fromUtf8(""))
        self.stats_content_application.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_application.setOpenExternalLinks(True)
        self.stats_content_application.setObjectName(_fromUtf8("stats_content_application"))
        self.gridLayout_2.addWidget(self.stats_content_application, 0, 5, 1, 1)
        self.label_17 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_17.sizePolicy().hasHeightForWidth())
        self.label_17.setSizePolicy(sizePolicy)
        self.label_17.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_17.setObjectName(_fromUtf8("label_17"))
        self.gridLayout_2.addWidget(self.label_17, 1, 0, 1, 1)
        self.stats_content_audio = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_audio.sizePolicy().hasHeightForWidth())
        self.stats_content_audio.setSizePolicy(sizePolicy)
        self.stats_content_audio.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_audio.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_audio.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_audio.setText(_fromUtf8(""))
        self.stats_content_audio.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_audio.setOpenExternalLinks(True)
        self.stats_content_audio.setObjectName(_fromUtf8("stats_content_audio"))
        self.gridLayout_2.addWidget(self.stats_content_audio, 1, 1, 1, 1)
        self.label_21 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_21.sizePolicy().hasHeightForWidth())
        self.label_21.setSizePolicy(sizePolicy)
        self.label_21.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_21.setObjectName(_fromUtf8("label_21"))
        self.gridLayout_2.addWidget(self.label_21, 1, 2, 1, 1)
        self.stats_content_video = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_video.sizePolicy().hasHeightForWidth())
        self.stats_content_video.setSizePolicy(sizePolicy)
        self.stats_content_video.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_video.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_video.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_video.setText(_fromUtf8(""))
        self.stats_content_video.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_video.setOpenExternalLinks(True)
        self.stats_content_video.setObjectName(_fromUtf8("stats_content_video"))
        self.gridLayout_2.addWidget(self.stats_content_video, 1, 3, 1, 1)
        self.stats_content_other = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_other.sizePolicy().hasHeightForWidth())
        self.stats_content_other.setSizePolicy(sizePolicy)
        self.stats_content_other.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_other.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_other.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_other.setText(_fromUtf8(""))
        self.stats_content_other.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_other.setOpenExternalLinks(True)
        self.stats_content_other.setObjectName(_fromUtf8("stats_content_other"))
        self.gridLayout_2.addWidget(self.stats_content_other, 2, 5, 1, 1)
        self.label_23 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_23.sizePolicy().hasHeightForWidth())
        self.label_23.setSizePolicy(sizePolicy)
        self.label_23.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_23.setObjectName(_fromUtf8("label_23"))
        self.gridLayout_2.addWidget(self.label_23, 2, 4, 1, 1)
        self.stats_content_mail = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_content_mail.sizePolicy().hasHeightForWidth())
        self.stats_content_mail.setSizePolicy(sizePolicy)
        self.stats_content_mail.setMinimumSize(QtCore.QSize(40, 0))
        self.stats_content_mail.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_content_mail.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_content_mail.setText(_fromUtf8(""))
        self.stats_content_mail.setTextFormat(QtCore.Qt.RichText)
        self.stats_content_mail.setOpenExternalLinks(True)
        self.stats_content_mail.setObjectName(_fromUtf8("stats_content_mail"))
        self.gridLayout_2.addWidget(self.stats_content_mail, 1, 5, 1, 1)
        self.label_22 = QtGui.QLabel(self.groupBox_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_22.sizePolicy().hasHeightForWidth())
        self.label_22.setSizePolicy(sizePolicy)
        self.label_22.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_22.setObjectName(_fromUtf8("label_22"))
        self.gridLayout_2.addWidget(self.label_22, 1, 4, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_3)
        self.groupBox_2 = QtGui.QGroupBox(self.statistics)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_2.sizePolicy().hasHeightForWidth())
        self.groupBox_2.setSizePolicy(sizePolicy)
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.gridLayout_3 = QtGui.QGridLayout(self.groupBox_2)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.label_18 = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_18.sizePolicy().hasHeightForWidth())
        self.label_18.setSizePolicy(sizePolicy)
        self.label_18.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_18.setObjectName(_fromUtf8("label_18"))
        self.gridLayout_3.addWidget(self.label_18, 0, 0, 1, 1)
        self.stats_url_minlen = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_url_minlen.sizePolicy().hasHeightForWidth())
        self.stats_url_minlen.setSizePolicy(sizePolicy)
        self.stats_url_minlen.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_url_minlen.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_url_minlen.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_url_minlen.setText(_fromUtf8(""))
        self.stats_url_minlen.setTextFormat(QtCore.Qt.RichText)
        self.stats_url_minlen.setOpenExternalLinks(True)
        self.stats_url_minlen.setObjectName(_fromUtf8("stats_url_minlen"))
        self.gridLayout_3.addWidget(self.stats_url_minlen, 0, 1, 1, 1)
        self.label_20 = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_20.sizePolicy().hasHeightForWidth())
        self.label_20.setSizePolicy(sizePolicy)
        self.label_20.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_20.setObjectName(_fromUtf8("label_20"))
        self.gridLayout_3.addWidget(self.label_20, 0, 2, 1, 1)
        self.stats_url_avglen = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_url_avglen.sizePolicy().hasHeightForWidth())
        self.stats_url_avglen.setSizePolicy(sizePolicy)
        self.stats_url_avglen.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_url_avglen.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_url_avglen.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_url_avglen.setText(_fromUtf8(""))
        self.stats_url_avglen.setTextFormat(QtCore.Qt.RichText)
        self.stats_url_avglen.setOpenExternalLinks(True)
        self.stats_url_avglen.setObjectName(_fromUtf8("stats_url_avglen"))
        self.gridLayout_3.addWidget(self.stats_url_avglen, 0, 3, 1, 1)
        self.label_19 = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_19.sizePolicy().hasHeightForWidth())
        self.label_19.setSizePolicy(sizePolicy)
        self.label_19.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_19.setObjectName(_fromUtf8("label_19"))
        self.gridLayout_3.addWidget(self.label_19, 1, 0, 1, 1)
        self.stats_url_maxlen = QtGui.QLabel(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stats_url_maxlen.sizePolicy().hasHeightForWidth())
        self.stats_url_maxlen.setSizePolicy(sizePolicy)
        self.stats_url_maxlen.setMinimumSize(QtCore.QSize(30, 0))
        self.stats_url_maxlen.setFrameShape(QtGui.QFrame.StyledPanel)
        self.stats_url_maxlen.setFrameShadow(QtGui.QFrame.Sunken)
        self.stats_url_maxlen.setText(_fromUtf8(""))
        self.stats_url_maxlen.setTextFormat(QtCore.Qt.RichText)
        self.stats_url_maxlen.setOpenExternalLinks(True)
        self.stats_url_maxlen.setObjectName(_fromUtf8("stats_url_maxlen"))
        self.gridLayout_3.addWidget(self.stats_url_maxlen, 1, 1, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_2)
        self.horizontalLayout.addWidget(self.statistics)
        self.verticalLayout.addLayout(self.horizontalLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtGui.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 713, 20))
        self.menubar.setObjectName(_fromUtf8("menubar"))
        self.menuEdit = QtGui.QMenu(self.menubar)
        self.menuEdit.setObjectName(_fromUtf8("menuEdit"))
        self.menuFile = QtGui.QMenu(self.menubar)
        self.menuFile.setObjectName(_fromUtf8("menuFile"))
        self.menuHelp = QtGui.QMenu(self.menubar)
        self.menuHelp.setObjectName(_fromUtf8("menuHelp"))
        MainWindow.setMenuBar(self.menubar)
        self.statusBar = QtGui.QStatusBar(MainWindow)
        self.statusBar.setObjectName(_fromUtf8("statusBar"))
        MainWindow.setStatusBar(self.statusBar)
        self.actionAbout = QtGui.QAction(MainWindow)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/about.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionAbout.setIcon(icon2)
        self.actionAbout.setObjectName(_fromUtf8("actionAbout"))
        self.actionHelp = QtGui.QAction(MainWindow)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/help.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionHelp.setIcon(icon3)
        self.actionHelp.setObjectName(_fromUtf8("actionHelp"))
        self.actionViewOnline = QtGui.QAction(MainWindow)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/online.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionViewOnline.setIcon(icon4)
        self.actionViewOnline.setObjectName(_fromUtf8("actionViewOnline"))
        self.actionOptions = QtGui.QAction(MainWindow)
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/preferences.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionOptions.setIcon(icon5)
        self.actionOptions.setObjectName(_fromUtf8("actionOptions"))
        self.actionCopyToClipboard = QtGui.QAction(MainWindow)
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/copy.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionCopyToClipboard.setIcon(icon6)
        self.actionCopyToClipboard.setObjectName(_fromUtf8("actionCopyToClipboard"))
        self.actionViewParentOnline = QtGui.QAction(MainWindow)
        self.actionViewParentOnline.setIcon(icon4)
        self.actionViewParentOnline.setObjectName(_fromUtf8("actionViewParentOnline"))
        self.actionViewParentSource = QtGui.QAction(MainWindow)
        self.actionViewParentSource.setIcon(icon4)
        self.actionViewParentSource.setObjectName(_fromUtf8("actionViewParentSource"))
        self.actionDebug = QtGui.QAction(MainWindow)
        self.actionDebug.setObjectName(_fromUtf8("actionDebug"))
        self.actionViewProperties = QtGui.QAction(MainWindow)
        self.actionViewProperties.setObjectName(_fromUtf8("actionViewProperties"))
        self.actionSave = QtGui.QAction(MainWindow)
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/save.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionSave.setIcon(icon7)
        self.actionSave.setObjectName(_fromUtf8("actionSave"))
        self.actionQuit = QtGui.QAction(MainWindow)
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/exit.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionQuit.setIcon(icon8)
        self.actionQuit.setObjectName(_fromUtf8("actionQuit"))
        self.actionCheckUpdates = QtGui.QAction(MainWindow)
        self.actionCheckUpdates.setObjectName(_fromUtf8("actionCheckUpdates"))
        self.actionDonate = QtGui.QAction(MainWindow)
        self.actionDonate.setObjectName(_fromUtf8("actionDonate"))
        self.actionOpen_project = QtGui.QAction(MainWindow)
        self.actionOpen_project.setObjectName(_fromUtf8("actionOpen_project"))
        self.actionSave_project = QtGui.QAction(MainWindow)
        self.actionSave_project.setObjectName(_fromUtf8("actionSave_project"))
        self.menuEdit.addAction(self.actionOptions)
        self.menuFile.addAction(self.actionOpen_project)
        self.menuFile.addAction(self.actionSave_project)
        self.menuFile.addAction(self.actionSave)
        self.menuFile.addAction(self.actionQuit)
        self.menuHelp.addAction(self.actionAbout)
        self.menuHelp.addAction(self.actionHelp)
        self.menuHelp.addAction(self.actionDebug)
        self.menuHelp.addAction(self.actionCheckUpdates)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuEdit.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())
        self.label.setBuddy(self.urlinput)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        MainWindow.setWindowTitle(_("LinkChecker"))
        self.label.setText(_("URL:"))
        self.controlButton.setToolTip(_("Start checking the given URL."))
        self.controlButton.setText(QtGui.QApplication.translate("MainWindow", "Start", "Start checking URL", QtGui.QApplication.UnicodeUTF8))
        self.label_29.setText(_("URLs: "))
        self.label_32.setText(_("active"))
        self.label_active.setText(_("0"))
        self.label_30.setText(_("queued"))
        self.label_queued.setText(_("0"))
        self.label_28.setText(_("checked"))
        self.label_checked.setText(_("0"))
        self.label_15.setText(_("Info:"))
        self.label_busy.setText(_("-"))
        self.url_properties.setTitle(_("URL properties"))
        self.label_2.setText(_("URL"))
        self.label_3.setText(_("Name"))
        self.label_4.setText(_("Parent URL"))
        self.label_5.setText(_("Base"))
        self.label_7.setText(_("Check time"))
        self.label_8.setText(_("D/L time"))
        self.label_9.setText(_("Size"))
        self.label_10.setText(_("Info"))
        self.label_11.setText(_("Warning"))
        self.label_12.setText(_("Result"))
        self.label_16.setText(_("Modified"))
        self.groupBox.setTitle(_("Check results"))
        self.label_24.setText(_("Valid URLs"))
        self.label_26.setText(_("Warnings"))
        self.label_25.setText(_("Invalid URLs"))
        self.groupBox_3.setTitle(_("Content type statistics"))
        self.label_6.setText(_("Image"))
        self.label_13.setText(_("Text"))
        self.label_27.setText(_("Application"))
        self.label_17.setText(_("Audio"))
        self.label_21.setText(_("Video"))
        self.label_23.setText(_("Other"))
        self.label_22.setText(_("Mail"))
        self.groupBox_2.setTitle(_("URL statistics"))
        self.label_18.setText(_("Min. length"))
        self.label_20.setText(_("Avg. length"))
        self.label_19.setText(_("Max. length"))
        self.menuEdit.setTitle(_("&Edit"))
        self.menuFile.setTitle(_("&File"))
        self.menuHelp.setTitle(_("&Help"))
        self.actionAbout.setText(_("A&bout"))
        self.actionAbout.setIconText(_("About"))
        self.actionHelp.setText(_("&Help"))
        self.actionHelp.setIconText(_("Help"))
        self.actionViewOnline.setText(_("View online"))
        self.actionViewOnline.setToolTip(_("View URL online"))
        self.actionOptions.setText(_("&Options"))
        self.actionOptions.setIconText(_("Options"))
        self.actionCopyToClipboard.setText(_("Copy to clipboard"))
        self.actionCopyToClipboard.setToolTip(_("Copy URL to clipboard"))
        self.actionCopyToClipboard.setShortcut(_("Ctrl+C"))
        self.actionViewParentOnline.setText(_("View parent online"))
        self.actionViewParentOnline.setToolTip(_("View parent URL online"))
        self.actionViewParentSource.setText(_("View parent source"))
        self.actionViewParentSource.setToolTip(_("View parent URL source"))
        self.actionDebug.setText(_("Show debug"))
        self.actionViewProperties.setText(_("View properties"))
        self.actionViewProperties.setToolTip(_("View URL properties"))
        self.actionSave.setText(_("Save &results..."))
        self.actionQuit.setText(_("&Quit"))
        self.actionQuit.setShortcut(_("Ctrl+Q"))
        self.actionCheckUpdates.setText(_("Check for updates"))
        self.actionDonate.setText(_("Donate"))
        self.actionOpen_project.setText(_("&Open project..."))
        self.actionOpen_project.setIconText(_("Open project"))
        self.actionOpen_project.setShortcut(_("Ctrl+O"))
        self.actionSave_project.setText(_("&Save project..."))
        self.actionSave_project.setShortcut(_("Ctrl+S"))

from lineedit import LineEdit
import linkchecker_rc

########NEW FILE########
__FILENAME__ = linkchecker_ui_options
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ui/options.ui'
#
# Created: Fri Feb 28 21:24:59 2014
#      by: PyQt4 UI code generator 4.9.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_Options(object):
    def setupUi(self, Options):
        Options.setObjectName(_fromUtf8("Options"))
        Options.resize(455, 550)
        Options.setMinimumSize(QtCore.QSize(400, 550))
        self.verticalLayout_3 = QtGui.QVBoxLayout(Options)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.groupBox_2 = QtGui.QGroupBox(Options)
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.verticalLayout = QtGui.QVBoxLayout(self.groupBox_2)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(self.groupBox_2)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.formLayout = QtGui.QFormLayout(self.widget)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.ExpandingFieldsGrow)
        self.formLayout.setMargin(0)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.label = QtGui.QLabel(self.widget)
        self.label.setObjectName(_fromUtf8("label"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label)
        self.recursionlevel = QtGui.QSpinBox(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.recursionlevel.sizePolicy().hasHeightForWidth())
        self.recursionlevel.setSizePolicy(sizePolicy)
        self.recursionlevel.setMinimumSize(QtCore.QSize(0, 25))
        self.recursionlevel.setMinimum(-1)
        self.recursionlevel.setMaximum(100)
        self.recursionlevel.setProperty("value", -1)
        self.recursionlevel.setObjectName(_fromUtf8("recursionlevel"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.recursionlevel)
        self.label_2 = QtGui.QLabel(self.widget)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_2)
        self.verbose = QtGui.QCheckBox(self.widget)
        self.verbose.setEnabled(True)
        self.verbose.setText(_fromUtf8(""))
        self.verbose.setObjectName(_fromUtf8("verbose"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.FieldRole, self.verbose)
        self.label_4 = QtGui.QLabel(self.widget)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.label_4)
        self.debug = QtGui.QCheckBox(self.widget)
        self.debug.setText(_fromUtf8(""))
        self.debug.setObjectName(_fromUtf8("debug"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.FieldRole, self.debug)
        self.verticalLayout.addWidget(self.widget)
        spacerItem = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem)
        self.label_5 = QtGui.QLabel(self.groupBox_2)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.verticalLayout.addWidget(self.label_5)
        self.warninglines = QtGui.QPlainTextEdit(self.groupBox_2)
        self.warninglines.setMaximumSize(QtCore.QSize(16777215, 150))
        self.warninglines.setObjectName(_fromUtf8("warninglines"))
        self.verticalLayout.addWidget(self.warninglines)
        self.label_6 = QtGui.QLabel(self.groupBox_2)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.verticalLayout.addWidget(self.label_6)
        self.ignorelines = QtGui.QPlainTextEdit(self.groupBox_2)
        self.ignorelines.setMaximumSize(QtCore.QSize(16777215, 150))
        self.ignorelines.setObjectName(_fromUtf8("ignorelines"))
        self.verticalLayout.addWidget(self.ignorelines)
        self.verticalLayout_3.addWidget(self.groupBox_2)
        self.groupBox = QtGui.QGroupBox(Options)
        self.groupBox.setObjectName(_fromUtf8("groupBox"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.groupBox)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.label_3 = QtGui.QLabel(self.groupBox)
        self.label_3.setWordWrap(True)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.verticalLayout_2.addWidget(self.label_3)
        spacerItem1 = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout_2.addItem(spacerItem1)
        self.user_config_filename = QtGui.QLabel(self.groupBox)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.user_config_filename.sizePolicy().hasHeightForWidth())
        self.user_config_filename.setSizePolicy(sizePolicy)
        self.user_config_filename.setFrameShape(QtGui.QFrame.NoFrame)
        self.user_config_filename.setLineWidth(0)
        self.user_config_filename.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.user_config_filename.setWordWrap(True)
        self.user_config_filename.setMargin(0)
        self.user_config_filename.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        self.user_config_filename.setObjectName(_fromUtf8("user_config_filename"))
        self.verticalLayout_2.addWidget(self.user_config_filename)
        self.user_config_button = QtGui.QPushButton(self.groupBox)
        self.user_config_button.setEnabled(False)
        self.user_config_button.setToolTip(_fromUtf8(""))
        self.user_config_button.setObjectName(_fromUtf8("user_config_button"))
        self.verticalLayout_2.addWidget(self.user_config_button)
        self.verticalLayout_3.addWidget(self.groupBox)
        spacerItem2 = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem2)
        self.widget_2 = QtGui.QWidget(Options)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.closeButton = QtGui.QPushButton(self.widget_2)
        self.closeButton.setObjectName(_fromUtf8("closeButton"))
        self.horizontalLayout.addWidget(self.closeButton)
        spacerItem3 = QtGui.QSpacerItem(317, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.verticalLayout_3.addWidget(self.widget_2)

        self.retranslateUi(Options)
        QtCore.QMetaObject.connectSlotsByName(Options)

    def retranslateUi(self, Options):
        Options.setWindowTitle(_("Options"))
        self.groupBox_2.setTitle(_("Checking options"))
        self.label.setToolTip(_("Check recursively all links up to given depth. A negative depth will enable infinite recursion."))
        self.label.setText(_("Recursive depth"))
        self.recursionlevel.setToolTip(_("Check recursively all links up to given depth. A negative depth will enable infinite recursion."))
        self.label_2.setToolTip(_("Log all checked URLs once. Default is to log only errors and warnings."))
        self.label_2.setText(_("Verbose output"))
        self.verbose.setToolTip(_("Log all checked URLs once. Default is to log only errors and warnings."))
        self.label_4.setText(_("Debug"))
        self.label_5.setText(_("Warn when one of these strings are found (one per line):"))
        self.label_6.setText(_("Ignore URLs matching one of these patterns (one per line):"))
        self.groupBox.setTitle(_("Configuration file"))
        self.label_3.setText(_("The configuration file holds advanced options and can be edited with an integrated text editor."))
        self.user_config_filename.setToolTip(_("Overrides system wide configuration file settings."))
        self.user_config_filename.setText(_("/home/user/.linkchecker/linkcheckerrc"))
        self.user_config_button.setText(_("Edit"))
        self.closeButton.setText(_("Close"))


########NEW FILE########
__FILENAME__ = logger
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from logging import Handler
from ..logger import _Logger


class GuiLogHandler (Handler, object):
    """Delegate log messages to the UI."""

    def __init__ (self, signal):
        """Save widget."""
        super(GuiLogHandler, self).__init__()
        self.signal = signal

    def emit (self, record):
        """Emit a record. It gets logged in the debug widget."""
        self.signal.emit(self.format(record))


class SignalLogger (_Logger):
    """Use Qt signals for logged URLs and statistics."""

    LoggerName = "gui"

    def __init__ (self, **args):
        """Store signals for URL and statistic data."""
        super(SignalLogger, self).__init__(**args)
        self.log_url_signal = args["signal"]
        self.log_stats_signal = args["stats"]

    def start_fileoutput (self):
        """Override fileoutput handling of base class."""
        pass

    def close_fileoutput (self):
        """Override fileoutput handling of base class."""
        pass

    def log_url (self, url_data):
        """Emit URL data which gets logged in the main window."""
        self.log_url_signal.emit(url_data)

    def end_output (self, **kwargs):
        """Emit statistic data which gets logged in the main window."""
        self.stats.downloaded_bytes = kwargs.get("downloaded_bytes")
        self.log_stats_signal.emit(self.stats)


class StatusLogger (object):
    """GUI status logger, signaling to progress labels."""

    def __init__ (self, signal):
        """Store given signal object."""
        self.signal = signal

    def log_status (self, checked, in_progress, queued, duration, num_urls):
        """Emit signal with given status information."""
        self.signal.emit(checked, in_progress, queued, duration, num_urls)

########NEW FILE########
__FILENAME__ = options
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
from PyQt4 import QtGui
from .linkchecker_ui_options import Ui_Options
from .editor import EditorWindow
from ..fileutil import is_writable
from .. import configuration


class LinkCheckerOptions (QtGui.QDialog, Ui_Options):
    """Hold options for current URL to check."""

    def __init__ (self, parent=None):
        """Reset all options and initialize the editor window."""
        super(LinkCheckerOptions, self).__init__(parent)
        self.setupUi(self)
        self.editor = EditorWindow(self)
        self.closeButton.clicked.connect(self.close)
        self.user_config_button.clicked.connect(self.edit_user_config)
        self.reset()

    def reset (self):
        """Reset GUI and config options."""
        self.user_config = configuration.get_user_config()
        self.reset_gui_options()
        self.reset_config_options()

    def reset_gui_options (self):
        """Reset GUI options to default values."""
        self.recursionlevel.setValue(-1)
        self.verbose.setChecked(False)
        self.debug.setChecked(False)
        self.warninglines.setPlainText(u"")
        self.ignorelines.setPlainText(u"")

    def reset_config_options (self):
        """Reset configuration file edit buttons."""
        self.user_config_writable = is_writable(self.user_config)
        set_edit_button(self.user_config, self.user_config_button,
                        self.user_config_filename, self.user_config_writable)

    def edit_user_config (self):
        """Show editor for user specific configuration file."""
        return start_editor(self.user_config, self.user_config_writable,
                            self.editor)

    def get_options (self):
        """Return option data as dictionary."""
        return dict(
            debug=self.debug.isChecked(),
            verbose=self.verbose.isChecked(),
            recursionlevel=self.recursionlevel.value(),
            warninglines=unicode(self.warninglines.toPlainText()),
            ignorelines=unicode(self.ignorelines.toPlainText()),
        )

    def set_options (self, data):
        """Set GUI options from given data."""
        if data.get("debug") is not None:
            self.debug.setChecked(data["debug"])
        if data.get("verbose") is not None:
            self.verbose.setChecked(data["verbose"])
        if data.get("recursionlevel") is not None:
            self.recursionlevel.setValue(data["recursionlevel"])
        if data.get("warninglines") is not None:
            self.warninglines.setPlainText(data["warninglines"])
        if data.get("ignorelines") is not None:
            self.ignorelines.setPlainText(data["ignorelines"])


def start_editor (filename, writable, editor):
    """Start editor for given filename."""
    if not os.path.isfile(filename):
        # file vanished
        return
    editor.load(filename)
    # all config files are in INI format
    editor.setContentType("text/plain+ini")
    editor.editor.setReadOnly(not writable)
    editor.show()


def set_edit_button (filename, button, label, writable):
    """Update edit button depending on writable flag of file."""
    label.setText(filename)
    if os.path.isfile(filename):
        button.setEnabled(True)
        if writable:
            button.setText(_(u"Edit"))
        else:
            button.setText(_(u"Read"))
    else:
        button.setEnabled(False)
        button.setText(_(u"File not found"))

########NEW FILE########
__FILENAME__ = projects
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import re
import os
import shutil
from PyQt4 import QtGui
from ..configuration import get_user_config, confparse
from ..url import url_split
from ..fileutil import is_readable, is_writable

ProjectExt = ".lcp"
ProjectFilter = _("LinkChecker project (*%(ext)s)") % dict(ext=ProjectExt)


class ProjectParser (confparse.LCConfigParser):

    def __init__ (self, config, gui_options, urlinput):
        super(ProjectParser, self).__init__(config)
        # has set_options(data) function
        self.gui_options = gui_options
        # has setText(url) function
        self.urlinput = urlinput

    def read (self, files):
        super(ProjectParser, self).read(files)
        self.read_project_config()
        self.read_gui_config()

    def read_project_config(self):
        section = "project"
        if not self.has_section(section):
            return
        option = "url"
        if self.has_option(section, option):
            url = self.get(section, option)
            self.urlinput.setText(url)
        else:
            self.urlinput.setText(u"")

    def read_gui_config(self):
        section = "gui"
        if not self.has_section(section):
            return
        data = {}
        option = "debug"
        if self.has_option(section, option):
             data[option] = self.getboolean(section, option)
        option = "verbose"
        if self.has_option(section, option):
             data[option] = self.getboolean(section, option)
        option = "recursionlevel"
        if self.has_option(section, option):
             data[option] = self.getint(section, option)
        option = "warninglines"
        if self.has_option(section, option):
             data[option] = self.get(section, option)
        option = "ignorelines"
        if self.has_option(section, option):
             data[option] = self.get(section, option)
        self.gui_options.set_options(data)

    def write (self, fp):
        """Write project configuration to given file object."""
        self.write_project_config()
        self.write_gui_config()
        super(ProjectParser, self).write(fp)

    def write_project_config(self):
        """Write project section configuration."""
        section = "project"
        self.add_section(section)
        self.set(section, "url", self.urlinput.text())

    def write_gui_config(self):
        """Write gui section configuration."""
        section = "gui"
        self.add_section(section)
        for key, value in self.gui_options.get_options().items():
            self.set(section, key, value)


def url_to_filename(url, extension):
    value = unicode(url)
    # filter host and document
    parts = url_split(url)
    value = parts[1]+parts[3]
    # normalize
    import unicodedata
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
    # replace non-alpha characters and convert to lowercase
    value = re.sub('[^\w-]+', '_', value).strip().lower()
    # add extension
    return value + extension


def saveproject(parent, url):
    """Save a project file."""
    try:
        msg = saveproject_msg(parent, url)
    except StandardError as errmsg:
        msg = str(errmsg)
    parent.set_statusmsg(msg)

def saveproject_msg(parent, url):
    """Save a project file and return status message."""
    title = _("Save LinkChecker project")
    func = QtGui.QFileDialog.getSaveFileName
    suggestedname = url_to_filename(url, ProjectExt)
    res = func(parent, title, suggestedname, ProjectFilter)
    if not res:
        # user canceled
        return _("Canceled saving a project file.")
    filename = unicode(res)
    d = dict(filename=filename)
    if not is_writable(filename):
        return _("Could not write project file %(filename)s.") % d
    user_config = get_user_config()
    if is_readable(user_config):
        # Copy user config to filename since this is the current
        # configuration.
        # This way it is not necessary to write the parent.config
        # dictionary back to a file.
        shutil.copy(user_config, filename)
        filter_comments = True
    else:
        # use default config (ie. do not write anything)
        filter_comments = False
    write_header(filename, filter_comments)
    parser = ProjectParser(parent.config, parent.options, parent.urlinput)
    with open(filename, 'a') as fp:
        parser.write(fp)
    return _("Project file %(filename)s saved successfully.") % d


def write_header(filename, filter_comments):
    """Write header and filter comment lines if file already exists."""
    lines = [
        '# This is a generated LinkChecker project file. Do not edit'+os.linesep,
    ]
    if filter_comments:
        with open(filename, 'r') as fp:
            for line in fp:
                if not line.lstrip().startswith((';', '#')):
                    lines.append(line)
    with open(filename, 'w') as fp:
        for line in lines:
            fp.write(line)


def openproject (parent):
    """Select and load a project file."""
    try:
        msg = openproject_msg(parent)
    except StandardError as errmsg:
        msg = str(errmsg)
    parent.set_statusmsg(msg)


def openproject_msg(parent):
    """Select and load a project file. Returns message to display
    which indicates if file has been loaded successful."""
    title = _("Open LinkChecker project")
    func = QtGui.QFileDialog.getOpenFileName
    directory = ""
    filename = func(parent, title, directory, ProjectFilter)
    if not filename:
        # user canceled
        return _("Canceled opening a project file.")
    if not is_readable(filename):
        return _("Could not read project file %(filename)s.") % dict(filename=filename)
    return loadproject(filename, parent.config, parent.options, parent.urlinput)


def loadproject(parent, filename):
    """Load a project file."""
    try:
        msg = loadproject_msg(parent, filename)
    except StandardError as errmsg:
        args = dict(filename=filename, err=errmsg)
        msg = _("Could not load project %(filename)s: %(err)s") % args
    parent.set_statusmsg(msg)


def loadproject_msg(parent, filename):
    """Load a project file. Returns message to display which indicates if
    file has been loaded successful."""
    parser = ProjectParser(parent.config, parent.options, parent.urlinput)
    parser.read([filename])
    d = dict(filename=filename)
    return _("Project file %(filename)s loaded successfully.") % d


########NEW FILE########
__FILENAME__ = properties
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
from .. import strformat


def set_properties (widget, data):
    """Write URL data values into widget text fields."""
    if data.base_url and data.url:
        widget.prop_url.setText(u'<a href="%(url)s">%(base_url)s</a>' % \
                              dict(url=data.url, base_url=data.base_url))
    else:
        widget.prop_url.setText(u"")
    widget.prop_name.setText(data.name)
    if data.parent_url:
        widget.prop_parenturl.setText(u'<a href="%(url)s">%(url)s</a>' % \
                              dict(url=data.parent_url))
    else:
        widget.prop_parenturl.setText(u"")
    widget.prop_base.setText(data.base_ref)
    widget.prop_checktime.setText(_("%.3f seconds") % data.checktime)
    if data.dltime >= 0:
        widget.prop_dltime.setText(_("%.3f seconds") % data.dltime)
    else:
        widget.prop_dltime.setText(u"")
    if data.size >= 0:
        widget.prop_size.setText(strformat.strsize(data.size))
    else:
        widget.prop_size.setText(u"")
    if data.modified:
        widget.prop_modified.setText(data.modified.isoformat(" "))
    else:
        widget.prop_modified.setText(u"")
    widget.prop_info.setText(wrap(data.info, 65))
    warning_msgs = [x[1] for x in data.warnings]
    widget.prop_warning.setText(wrap(warning_msgs, 65))
    if data.valid:
        result = u"Valid"
    else:
        result = u"Error"
    if data.result:
        result += u": %s" % data.result
    widget.prop_result.setText(result)


def clear_properties (widget):
    """Reset URL data values in widget text fields."""
    widget.prop_url.setText(u"")
    widget.prop_name.setText(u"")
    widget.prop_parenturl.setText(u"")
    widget.prop_base.setText(u"")
    widget.prop_checktime.setText(u"")
    widget.prop_dltime.setText(u"")
    widget.prop_size.setText(u"")
    widget.prop_info.setText(u"")
    widget.prop_warning.setText(u"")
    widget.prop_result.setText(u"")


def wrap (lines, width):
    """Format lines with given line-width."""
    sep = os.linesep+os.linesep
    text = sep.join(lines)
    kwargs = dict(break_long_words=False, break_on_hyphens=False)
    return strformat.wrap(text, width, **kwargs)

########NEW FILE########
__FILENAME__ = recentdocs
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
from PyQt4 import QtCore

EmptyQVariant = QtCore.QVariant()


class RecentDocumentModel(QtCore.QAbstractListModel):
    """Model class for list of recent documents."""

    def __init__ (self, parent=None, documents=[], maxentries=10):
        """Set document list."""
        super(RecentDocumentModel, self).__init__(parent)
        self.maxentries = maxentries
        self.documents = documents[:maxentries]

    def rowCount (self, parent=QtCore.QModelIndex()):
        """Return number of documents."""
        return len(self.documents)

    def index (self, row, column=0, parent=QtCore.QModelIndex()):
        """Return index of document in given row."""
        return self.createIndex(row, column)

    def data (self, index, role=QtCore.Qt.DisplayRole):
        """Return data at given index for given role."""
        V = QtCore.QVariant
        if not index.isValid() or \
           not (0 <= index.row() < len(self.documents)) or \
           index.column() != 0:
            return EmptyQVariant
        if role == QtCore.Qt.DisplayRole:
            return V(self.documents[index.row()])
        return EmptyQVariant

    def headerData (self, section, orientation, role):
        """Return header column data for given parameters."""
        return EmptyQVariant

    def flags (self, index):
        """Return flags that given valid item index is enabled and
        selected."""
        if not index.isValid():
            return 0
        return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def clear (self):
        """Empty the document list."""
        self.beginResetModel()
        self.documents = []
        self.endResetModel()

    def add_document (self, document):
        """Add document to model."""
        if not document:
            return False
        assert isinstance(document, unicode)
        while document in self.documents:
            row = self.documents.index(document)
            self.beginRemoveRows(QtCore.QModelIndex(), row, row)
            del self.documents[row]
            self.endRemoveRows()
        while len(self.documents) >= self.maxentries:
            row = len(self.documents) - 1
            self.beginRemoveRows(QtCore.QModelIndex(), row, row)
            del self.documents[row]
            self.endRemoveRows()
        self.beginInsertRows(QtCore.QModelIndex(), 0, 0)
        self.documents.insert(0, document)
        self.endInsertRows()
        return True

    def get_documents (self):
        """Return copy of document list."""
        return self.documents[:]

########NEW FILE########
__FILENAME__ = settings
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Read and store QSettings for this application."""

from PyQt4 import QtCore


def save_point (qpoint):
    """Ensure positive X and Y values of point."""
    qpoint.setX(max(0, qpoint.x()))
    qpoint.setY(max(0, qpoint.y()))
    return qpoint


def save_size (qsize):
    """Ensure minimum width and height values of the given size."""
    qsize.setWidth(max(400, qsize.width()))
    qsize.setHeight(max(400, qsize.height()))
    return qsize


class Settings (object):
    """Save and read GUI settings."""

    def __init__ (self, base, appname):
        """Initialize a QSettings object."""
        self.settings = QtCore.QSettings(base, appname)

    def read_geometry (self):
        """Return stored size and position of main window."""
        data = dict(size=None, pos=None)
        self.settings.beginGroup('mainwindow')
        if self.settings.contains('size'):
            data["size"] = save_size(self.settings.value('size').toSize())
        if self.settings.contains('pos'):
            data["pos"] = save_point(self.settings.value('pos').toPoint())
        self.settings.endGroup()
        return data

    def save_geometry (self, data):
        """Save size and position of main window."""
        size = save_size(data["size"])
        pos = save_point(data["pos"])
        self.settings.beginGroup('mainwindow')
        self.settings.setValue("size", QtCore.QVariant(size))
        self.settings.setValue("pos", QtCore.QVariant(pos))
        self.settings.endGroup()

    def read_treeviewcols (self):
        """Return widths of URL treeview columns."""
        data = dict(col1=200, col2=200, col3=150)
        self.settings.beginGroup('treeview')
        for key in ("col1", "col2", "col3"):
            if self.settings.contains(key):
                value, ok = self.settings.value(key).toInt()
                if ok:
                    if value < 50:
                        value = 50
                    elif value > 500:
                        value = 500
                    data[key] = value
        self.settings.endGroup()
        return data

    def save_treeviewcols (self, data):
        """Save widths of URL treeview columns."""
        self.settings.beginGroup('treeview')
        for key in ("col1", "col2", "col3"):
            self.settings.setValue(key, QtCore.QVariant(data[key]))
        self.settings.endGroup()

    def read_options (self):
        """Return stored GUI options."""
        data = dict(debug=None, verbose=None,
            recursionlevel=None, warninglines=None, ignorelines=None)
        self.settings.beginGroup('output')
        for key in ("debug", "verbose"):
            if self.settings.contains(key):
                data[key] = self.settings.value(key).toBool()
        self.settings.endGroup()
        self.settings.beginGroup('checking')
        if self.settings.contains('recursionlevel'):
            value, ok = self.settings.value('recursionlevel').toInt()
            if ok:
                if value < -1:
                    value = -1
                elif value > 100:
                    # 100 is the maximum GUI option value
                    value = 100
            else:
                value = -1
            data['recursionlevel'] = value
        if self.settings.contains('warninglines'):
            value = self.settings.value('warninglines').toString()
            data['warninglines'] = unicode(value)
        if self.settings.contains('ignorelines'):
            value = self.settings.value('ignorelines').toString()
            data['ignorelines'] = unicode(value)
        self.settings.endGroup()
        return data

    def save_options (self, data):
        """Save GUI options."""
        self.settings.beginGroup('output')
        for key in ("debug", "verbose"):
            self.settings.setValue(key, QtCore.QVariant(data[key]))
        self.settings.endGroup()
        self.settings.beginGroup('checking')
        for key in ("recursionlevel", "warninglines", "ignorelines"):
            self.settings.setValue(key, QtCore.QVariant(data[key]))
        self.settings.endGroup()

    def read_recent_documents (self):
        """Return list of recent documents."""
        self.settings.beginGroup('recent')
        data = self.settings.value('documents').toStringList()
        self.settings.endGroup()
        return [unicode(doc) for doc in data]

    def save_recent_documents (self, data):
        """Save list of recent documents."""
        self.settings.beginGroup('recent')
        self.settings.setValue('documents', QtCore.QVariant(data))
        self.settings.endGroup()

    def read_misc(self):
        """Get misc options."""
        data = dict(saveresultas=None)
        self.settings.beginGroup('misc')
        key = 'saveresultas'
        value = self.settings.value(key).toString()
        data[key] = unicode(value)
        self.settings.endGroup()
        return data

    def save_misc(self, data):
        """Save misc options."""
        self.settings.beginGroup('misc')
        key = 'saveresultas'
        self.settings.setValue(key, QtCore.QVariant(data[key]))
        self.settings.endGroup()

    def sync (self):
        """Synchronize QSettings object to disk."""
        self.settings.sync()

########NEW FILE########
__FILENAME__ = statistics
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from ..logger import ContentTypes

def set_statistics (widget, statistics):
    """Set statistic information in given widget."""
    widget.stats_url_minlen.setText(u"%d" % statistics.min_url_length)
    widget.stats_url_maxlen.setText(u"%d" % statistics.max_url_length)
    widget.stats_url_avglen.setText(u"%d" % statistics.avg_url_length)
    widget.stats_valid_urls.setText(u"%d" % (statistics.number - statistics.errors))
    if statistics.errors > 0:
        color = '#aa0000'
    else:
        color = '#00aa00'
    style = "QLabel {font-weight:bold; color:%s;}" % color
    widget.stats_invalid_urls.setStyleSheet(style)
    widget.stats_invalid_urls.setText(u"%d" % statistics.errors)
    widget.stats_warnings.setText(u"%d" % statistics.warnings)
    for key, value in statistics.link_types.items():
        getattr(widget, "stats_content_%s"%key).setText(u"%d" % value)


def clear_statistics (widget):
    """Reset statistic information in given widget."""
    widget.stats_url_minlen.setText(u"")
    widget.stats_url_maxlen.setText(u"")
    widget.stats_url_avglen.setText(u"")
    widget.stats_valid_urls.setText(u"")
    widget.stats_invalid_urls.setText(u"")
    widget.stats_warnings.setText(u"")
    for key in ContentTypes:
        getattr(widget, "stats_content_%s"%key).setText(u"")

########NEW FILE########
__FILENAME__ = syntax
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from PyQt4 import QtCore, QtGui


def format (color, style=''):
    """Return a QTextCharFormat with the given attributes."""
    format = QtGui.QTextCharFormat()
    format.setForeground(getattr(QtCore.Qt, color))
    if 'bold' in style:
        format.setFontWeight(QtGui.QFont.Bold)
    if 'italic' in style:
        format.setFontItalic(True)
    return format


class Highlighter (QtGui.QSyntaxHighlighter):
    """Base class for all highlighters."""

    def __init__ (self, document):
        """Initialize rules and styles."""
        super(Highlighter, self).__init__(document)
        self.rules = []
        self.styles = {}

    def highlightBlock(self, text):
        """Highlight a text block."""
        for expression, format in self.rules:
            # get first match
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                # jump to next match
                index = expression.indexIn(text, index + length)
        self.setCurrentBlockState(0)

    def addRule (self, pattern, style):
        """Add a rule pattern with given style."""
        self.rules.append((QtCore.QRegExp(pattern), self.styles[style]))


class XmlHighlighter (Highlighter):
    """XML syntax highlighter."""

    def __init__(self, document):
        """Set XML syntax rules."""
        super(XmlHighlighter, self).__init__(document)
        self.styles.update({
            'keyword': format('darkBlue'),
            'attribute': format('darkGreen'),
            'comment': format('darkYellow'),
            'string': format('darkMagenta'),
        })
        # keywords
        for reg in ('/>', '>', '<!?[a-zA-Z0-9_]+'):
            self.addRule(reg, 'keyword')
        # attributes
        self.addRule(r"\b[A-Za-z0-9_]+(?=\s*\=)", 'attribute')
        # double-quoted string, possibly containing escape sequences
        self.addRule(r'"[^"\\]*(\\.[^"\\]*)*"', 'string')
        # single-quoted string, possibly containing escape sequences
        self.addRule(r"'[^'\\]*(\\.[^'\\]*)*'", 'string')
        # comments
        self.addRule(r"<!--[^>]*-->", 'comment')

# Treat HTML as XML
HtmlHighlighter = XmlHighlighter

class IniHighlighter (Highlighter):
    """INI syntax highlighter."""

    def __init__(self, document):
        """Set INI syntax rules."""
        super(IniHighlighter, self).__init__(document)
        self.styles.update({
            'section': format('darkBlue'),
            'property': format('darkGreen'),
            'comment': format('darkYellow'),
        })
        self.addRule(r'\b\[[a-zA-Z0-9_]+\]\b', 'section')
        self.addRule(r'\b[a-zA-Z0-9_]+\](?=\s*\=)', 'property')
        self.addRule(r'#[^\n]*', 'comment')

########NEW FILE########
__FILENAME__ = updater
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from PyQt4 import QtCore, QtGui
from .. import updater, configuration


class UpdateThread (QtCore.QThread):
    """Thread to check for updated versions."""

    def reset (self):
        """Reset version information."""
        self.result = self.value = None

    def run (self):
        """Check for updated version."""
        self.result, self.value = updater.check_update()


class UpdateDialog (QtGui.QMessageBox):
    """Dialog displaying results of an update check."""

    def __init__ (self, parent=None):
        """Initialize dialog and start background update thread."""
        super(UpdateDialog, self).__init__(parent)
        title = _('%(app)s update information') % dict(app=configuration.App)
        self.setWindowTitle(title)
        self.thread = UpdateThread()
        self.thread.finished.connect(self.update)

    def reset (self):
        """Reset dialog and restart update check."""
        self.thread.reset()
        self.thread.start()
        self.setIcon(QtGui.QMessageBox.Information)
        self.setText(_('Checking for updates...'))

    def update (self):
        """Display update thread result (which must be available)."""
        result, value = self.thread.result, self.thread.value
        if result:
            if value is None:
                # no update available: display info
                text = _('Congratulations: the latest version '
                         '%(app)s is installed.')
                attrs = dict(app=configuration.App)
            else:
                version, url = value
                if url is None:
                    # current version is newer than online version
                    text = _('Detected local or development version %(currentversion)s. '
                             'Available version of %(app)s is %(version)s.')
                else:
                    # display update link
                    text = _('A new version %(version)s of %(app)s is '
                             'available for <a href="%(url)s">download</a>.')
                attrs = dict(version=version, app=configuration.AppName,
                             url=url, currentversion=configuration.Version)
        else:
            # value is an error message or None if UpdateThread has been
            # terminated
            if value is None:
                value = _('update thread has been terminated')
            self.setIcon(QtGui.QMessageBox.Warning)
            text = _('An error occured while checking for an '
                     'update of %(app)s: %(error)s.')
            attrs = dict(error=value, app=configuration.AppName)
        self.setText(text % attrs)

########NEW FILE########
__FILENAME__ = urlmodel
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import operator
from PyQt4 import QtCore, QtGui
from .. import strformat


Headers = [_(u"Parent"), _(u"URL"), _(u"Name"), _(u"Result")]
EmptyQVariant = QtCore.QVariant()


class UrlItem (object):
    """URL item storing info to be displayed."""

    def __init__ (self, url_data):
        """Save given URL data and initialize display and tooltip texts."""
        # url_data is of type CompactUrlData
        self.url_data = url_data
        # format display and tooltips
        self.init_display()
        self.init_tooltips()

    def __getitem__ (self, key):
        """Define easy index access (used for sorting):
           0: Parent URL
           1: URL
           2: URL name
           3: Result
        """
        if not isinstance(key, int):
            raise TypeError("invalid index %r" % key)
        if key == 0:
            return (self.url_data.parent_url, self.url_data.line,
                    self.url_data.column)
        elif key == 1:
            return self.url_data.url
        elif key == 2:
            return self.url_data.name
        elif key == 3:
            return (self.url_data.valid, self.url_data.result)
        raise IndexError("invalid index %d" % key)

    def init_display (self):
        """Store formatted display texts from URL data."""
        # result
        if self.url_data.valid:
            if self.url_data.warnings:
                self.result_color = QtCore.Qt.darkYellow
                text = u"\n".join(x[1] for x in self.url_data.warnings)
                result = u"Warning: %s" % strformat.limit(text, length=25)
            else:
                self.result_color = QtCore.Qt.darkGreen
                result = u"Valid"
                if self.url_data.result:
                    result += u": %s" % self.url_data.result
        else:
            self.result_color = QtCore.Qt.darkRed
            result = u"Error"
            if self.url_data.result:
                result += u": %s" % self.url_data.result
        # Parent URL
        if self.url_data.parent_url:
            parent = u"%s%s%s" % (self.url_data.parent_url,
                (_(", line %d") % self.url_data.line),
                (_(", col %d") % self.url_data.column))
        else:
            parent = u""
        # display values
        self.display = [
            # Parent URL
            parent,
            # URL
            unicode(self.url_data.url),
            # Name
            self.url_data.name,
            # Result
            result,
        ]

    def init_tooltips (self):
        """Store formatted tooltip texts from URL data."""
        # Display warnings in result tooltip
        if self.url_data.warnings:
            text = u"\n".join(x[1] for x in self.url_data.warnings)
            result = strformat.wrap(text, 60)
        else:
            result = u""
        self.tooltips = [
            # Parent URL
            u"",
            # URL
            unicode(self.url_data.url),
            # Name
            self.url_data.name,
            # Result
            result,
        ]


class UrlItemModel(QtCore.QAbstractItemModel):
    """Model class for list of URL items."""

    def __init__ (self, parent=None):
        """Set empty URL item list."""
        super(UrlItemModel, self).__init__(parent)
        # list of UrlItem objects
        self.urls = []

    def rowCount (self, parent=QtCore.QModelIndex()):
        """Return number of URL items."""
        return len(self.urls)

    def columnCount (self, parent=QtCore.QModelIndex()):
        """Return number of header columns."""
        return len(Headers)

    def parent (self, child=QtCore.QModelIndex()):
        """Return empty QModelIndex since the URL list is not hierarchical."""
        return QtCore.QModelIndex()

    def index (self, row, column, parent=QtCore.QModelIndex()):
        """Return index of URL item in given row and column."""
        return self.createIndex(row, column)

    def data (self, index, role=QtCore.Qt.DisplayRole):
        """Return URL item data at given index for given role."""
        V = QtCore.QVariant
        if not index.isValid() or \
           not (0 <= index.row() < len(self.urls)):
            return EmptyQVariant
        urlitem = self.urls[index.row()]
        column = index.column()
        if role == QtCore.Qt.DisplayRole:
            return V(urlitem.display[column])
        elif role == QtCore.Qt.ToolTipRole:
            return V(urlitem.tooltips[column])
        elif role == QtCore.Qt.TextColorRole and column == 3:
            return QtGui.QColor(urlitem.result_color)
        else:
            return EmptyQVariant

    def headerData (self, section, orientation, role):
        """Return header column data for given parameters."""
        if orientation == QtCore.Qt.Horizontal and \
           role == QtCore.Qt.DisplayRole:
            return Headers[section]
        return EmptyQVariant

    def flags (self, index):
        """Return flags that given valid item index is enabled and
        selected."""
        if not index.isValid():
            return 0
        return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def clear (self):
        """Empty the URL item list."""
        self.beginResetModel()
        self.urls = []
        self.endResetModel()

    def log_url (self, url_data):
        """Add URL data to tree model."""
        row = self.rowCount()
        self.beginInsertRows(QtCore.QModelIndex(), row, row)
        self.urls.append(UrlItem(url_data))
        self.endInsertRows()
        return True

    def getUrlItem (self, index):
        """Get URL item object at given index."""
        if not index.isValid() or \
           not (0 <= index.row() < len(self.urls)):
            return None
        return self.urls[index.row()]

    def sort (self, column, order=QtCore.Qt.AscendingOrder):
        """Sort URL items by given column and order."""
        self.layoutAboutToBeChanged.emit()
        reverse = (order == QtCore.Qt.DescendingOrder)
        self.urls.sort(key=operator.itemgetter(column), reverse=reverse)
        self.layoutChanged.emit()

########NEW FILE########
__FILENAME__ = urlsave
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
from PyQt4 import QtGui, QtCore

FilterHtml = _("HTML output (*.html)")
FilterText = _("Text output (*.txt)")
FilterXml = _("XML output (*.xml)")
FilterCsv = _("CSV output (*.csv)")

LoggerFilters = (
    FilterHtml,
    FilterText,
    FilterXml,
    FilterCsv,
)

Logtype2Filter = {
    'html': FilterHtml,
    'text': FilterText,
    'xml': FilterXml,
    'csv': FilterCsv,
}
Filter2Logtype = {v: k for k, v in Logtype2Filter.items()}

Logtype2FileExt = {
    "html": ".html",
    "text": ".txt",
    "xml": ".xml",
    "csv": ".csv",
}

def urlsave (parent, config, urls):
    """Save URL results in file."""
    filename, logtype = get_save_filename(parent)
    if not filename:
        # user canceled
        return
    filename = unicode(filename)
    kwargs = dict(fileoutput=1, filename=filename, encoding="utf_8_sig")
    logger = config.logger_new(logtype, **kwargs)
    logger.start_output()
    for urlitem in urls:
        do_print = True
        logger.log_filter_url(urlitem.url_data, do_print)
    # inject the saved statistics before printing them
    logger.stats = config['logger'].stats
    logger.end_output()
    return logtype


def get_save_filename (parent):
    """Open file save dialog for given parent window and base directory.
    Return dialog result."""
    title = _("Save check results")
    func = QtGui.QFileDialog.getSaveFileName
    logtype = parent.saveresultas if parent.saveresultas else 'html'
    filters = ";;".join(sortwithfirst(LoggerFilters, Logtype2Filter[logtype]))
    filename = "linkchecker-out" + Logtype2FileExt[logtype]
    selectedFilter = QtCore.QString()
    res = func(parent, title, filename, filters, selectedFilter)
    logtype = Filter2Logtype.get(unicode(selectedFilter))
    return res, logtype


def sortwithfirst(sequence, firstelement):
    """Move firstelement in a sequence to the first position."""
    res = []
    for elem in sequence:
        if elem == firstelement:
            res.insert(0, elem)
        else:
            res.append(elem)
    return res

########NEW FILE########
__FILENAME__ = validator
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Provide custom validators."""

from PyQt4 import QtGui
import re


def check_regex (value):
    """Check if given string value can be compiled with re.compile()."""
    try:
        re.compile(value)
    except re.error:
        return False
    else:
        return True


class PyRegexValidator (QtGui.QValidator):
    """Validate input that it is a valid Python regular expression."""

    def validate (self, input, pos):
        if check_regex(unicode(input)):
            return (QtGui.QValidator.Acceptable, pos)
        return (QtGui.QValidator.Intermediate, pos)

    def fixup (self, input):
        while not check_regex(unicode(input)):
            input.chop(1)

########NEW FILE########
__FILENAME__ = gzip2
# -*- coding: iso-8859-1 -*-
"""Functions that read and write gzipped files.

The user of the file doesn't have to worry about the compression,
but random access is not allowed."""

# Copied from Python source; License: Python License
# Copyright Guido van Rossum <guido@cwi.nl> and others
# based on Andrew Kuchling's minigzip.py distributed with the zlib module

import struct, sys, time, os
import zlib
import __builtin__

__all__ = ["GzipFile","open"]

FTEXT, FHCRC, FEXTRA, FNAME, FCOMMENT = 1, 2, 4, 8, 16

READ, WRITE = 1, 2

def write32u(output, value):
    # The L format writes the bit pattern correctly whether signed
    # or unsigned.
    output.write(struct.pack("<L", value))

def read32(input):
    return struct.unpack("<I", input.read(4))[0]

def open(filename, mode="rb", compresslevel=9):
    """Shorthand for GzipFile(filename, mode, compresslevel).

    The filename argument is required; mode defaults to 'rb'
    and compresslevel defaults to 9.

    """
    return GzipFile(filename, mode, compresslevel)

class GzipFile:
    """The GzipFile class simulates most of the methods of a file object with
    the exception of the readinto() and truncate() methods.

    """

    myfileobj = None
    max_read_chunk = 10 * 1024 * 1024   # 10Mb

    def __init__(self, filename=None, mode=None,
                 compresslevel=9, fileobj=None, mtime=None):
        """Constructor for the GzipFile class.

        At least one of fileobj and filename must be given a
        non-trivial value.

        The new class instance is based on fileobj, which can be a regular
        file, a StringIO object, or any other object which simulates a file.
        It defaults to None, in which case filename is opened to provide
        a file object.

        When fileobj is not None, the filename argument is only used to be
        included in the gzip file header, which may includes the original
        filename of the uncompressed file.  It defaults to the filename of
        fileobj, if discernible; otherwise, it defaults to the empty string,
        and in this case the original filename is not included in the header.

        The mode argument can be any of 'r', 'rb', 'a', 'ab', 'w', or 'wb',
        depending on whether the file will be read or written.  The default
        is the mode of fileobj if discernible; otherwise, the default is 'rb'.
        Be aware that only the 'rb', 'ab', and 'wb' values should be used
        for cross-platform portability.

        The compresslevel argument is an integer from 0 to 9 controlling the
        level of compression; 1 is fastest and produces the least compression,
        and 9 is slowest and produces the most compression. 0 is no compression
        at all. The default is 9.

        The mtime argument is an optional numeric timestamp to be written
        to the stream when compressing.  All gzip compressed streams
        are required to contain a timestamp.  If omitted or None, the
        current time is used.  This module ignores the timestamp when
        decompressing; however, some programs, such as gunzip, make use
        of it.  The format of the timestamp is the same as that of the
        return value of time.time() and of the st_mtime member of the
        object returned by os.stat().

        """

        # Make sure we don't inadvertently enable universal newlines on the
        # underlying file object - in read mode, this causes data corruption.
        if mode:
            mode = mode.replace('U', '')
        # guarantee the file is opened in binary mode on platforms
        # that care about that sort of thing
        if mode and 'b' not in mode:
            mode += 'b'
        if fileobj is None:
            fileobj = self.myfileobj = __builtin__.open(filename, mode or 'rb')
        if filename is None:
            # Issue #13781: os.fdopen() creates a fileobj with a bogus name
            # attribute. Avoid saving this in the gzip header's filename field.
            if hasattr(fileobj, 'name') and fileobj.name != '<fdopen>':
                filename = fileobj.name
            else:
                filename = ''
        if mode is None:
            if hasattr(fileobj, 'mode'): mode = fileobj.mode
            else: mode = 'rb'

        if mode[0:1] == 'r':
            self.mode = READ
            # Set flag indicating start of a new member
            self._new_member = True
            self.extrabuf = ""
            self.extrasize = 0
            self.name = filename
            # Starts small, scales exponentially
            self.min_readsize = 100

        elif mode[0:1] == 'w' or mode[0:1] == 'a':
            self.mode = WRITE
            self._init_write(filename)
            self.compress = zlib.compressobj(compresslevel,
                                             zlib.DEFLATED,
                                             -zlib.MAX_WBITS,
                                             zlib.DEF_MEM_LEVEL,
                                             0)
        else:
            raise IOError("Mode %r not supported" % mode)

        self.fileobj = fileobj
        self.offset = 0
        self.mtime = mtime

        if self.mode == WRITE:
            self._write_gzip_header()

    @property
    def filename(self):
        import warnings
        warnings.warn("use the name attribute", DeprecationWarning, 2)
        if self.mode == WRITE and self.name[-3:] != ".gz":
            return self.name + ".gz"
        return self.name

    def __repr__(self):
        s = repr(self.fileobj)
        return '<gzip ' + s[1:-1] + ' ' + hex(id(self)) + '>'

    def _check_closed(self):
        """Raises a ValueError if the underlying file object has been closed.

        """
        if self.closed:
            raise ValueError('I/O operation on closed file.')

    def _init_write(self, filename):
        self.name = filename
        self.crc = zlib.crc32("") & 0xffffffffL
        self.size = 0
        self.writebuf = []
        self.bufsize = 0

    def _write_gzip_header(self):
        self.fileobj.write('\037\213')             # magic header
        self.fileobj.write('\010')                 # compression method
        fname = os.path.basename(self.name)
        if fname.endswith(".gz"):
            fname = fname[:-3]
        flags = 0
        if fname:
            flags = FNAME
        self.fileobj.write(chr(flags))
        mtime = self.mtime
        if mtime is None:
            mtime = time.time()
        write32u(self.fileobj, long(mtime))
        self.fileobj.write('\002')
        self.fileobj.write('\377')
        if fname:
            self.fileobj.write(fname + '\000')

    def _init_read(self):
        self.crc = zlib.crc32("") & 0xffffffffL
        self.size = 0

    def _read_gzip_header(self):
        magic = self.fileobj.read(2)
        if magic != '\037\213':
            raise IOError('Not a gzipped file')
        method = ord( self.fileobj.read(1) )
        if method != 8:
            raise IOError('Unknown compression method')
        flag = ord( self.fileobj.read(1) )
        self.mtime = read32(self.fileobj)
        # extraflag = self.fileobj.read(1)
        # os = self.fileobj.read(1)
        self.fileobj.read(2)

        if flag & FEXTRA:
            # Read & discard the extra field, if present
            xlen = ord(self.fileobj.read(1))
            xlen = xlen + 256*ord(self.fileobj.read(1))
            self.fileobj.read(xlen)
        if flag & FNAME:
            # Read and discard a null-terminated string containing the filename
            while True:
                s = self.fileobj.read(1)
                if not s or s=='\000':
                    break
        if flag & FCOMMENT:
            # Read and discard a null-terminated string containing a comment
            while True:
                s = self.fileobj.read(1)
                if not s or s=='\000':
                    break
        if flag & FHCRC:
            self.fileobj.read(2)     # Read & discard the 16-bit header CRC


    def write(self,data):
        self._check_closed()
        if self.mode != WRITE:
            import errno
            raise IOError(errno.EBADF, "write() on read-only GzipFile object")

        if self.fileobj is None:
            raise ValueError, "write() on closed GzipFile object"
        if len(data) > 0:
            self.size = self.size + len(data)
            self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
            self.fileobj.write( self.compress.compress(data) )
            self.offset += len(data)
        return len(data)

    def read(self, size=-1):
        self._check_closed()
        if self.mode != READ:
            import errno
            raise IOError(errno.EBADF, "read() on write-only GzipFile object")

        if self.extrasize <= 0 and self.fileobj is None:
            return ''

        readsize = 1024
        if size < 0:        # get the whole thing
            try:
                while True:
                    self._read(readsize)
                    readsize = min(self.max_read_chunk, readsize * 2)
            except EOFError:
                size = self.extrasize
        else:               # just get some more of it
            try:
                while size > self.extrasize:
                    self._read(readsize)
                    readsize = min(self.max_read_chunk, readsize * 2)
            except EOFError:
                if size > self.extrasize:
                    size = self.extrasize

        chunk = self.extrabuf[:size]
        self.extrabuf = self.extrabuf[size:]
        self.extrasize = self.extrasize - size

        self.offset += size
        return chunk

    def _unread(self, buf):
        self.extrabuf = buf + self.extrabuf
        self.extrasize = len(buf) + self.extrasize
        self.offset -= len(buf)

    def _read(self, size=1024):
        if self.fileobj is None:
            raise EOFError("Reached EOF")

        if self._new_member:
            # If the _new_member flag is set, we have to
            # jump to the next member, if there is one.

            # First, check if we're at the end of the file;
            # if so, it's time to stop; no more members to read.
            pos = self.fileobj.tell()   # Save current position
            self.fileobj.seek(0, 2)     # Seek to end of file
            if pos == self.fileobj.tell():
                raise EOFError("Reached EOF")
            else:
                self.fileobj.seek( pos ) # Return to original position

            self._init_read()
            self._read_gzip_header()
            self.decompress = zlib.decompressobj(-zlib.MAX_WBITS)
            self._new_member = False

        # Read a chunk of data from the file
        buf = self.fileobj.read(size)

        # If the EOF has been reached, flush the decompression object
        # and mark this object as finished.

        if buf == "":
            uncompress = self.decompress.flush()
            self._read_eof()
            self._add_read_data( uncompress )
            raise EOFError('Reached EOF')

        uncompress = self.decompress.decompress(buf)
        self._add_read_data( uncompress )

        if self.decompress.unused_data != "":
            # Ending case: we've come to the end of a member in the file,
            # so seek back to the start of the unused data, finish up
            # this member, and read a new gzip header.
            # (The number of bytes to seek back is the length of the unused
            # data, minus 8 because _read_eof() will rewind a further 8 bytes)
            rewind = -len(self.decompress.unused_data)+8
            if rewind > 0:
                # too few unused data encountered, assume EOF
                errmsg = "Unexpected EOF: %r" % self.decompress.unused_data
                raise EOFError(errmsg)
            self.fileobj.seek(rewind, 1)

            # Check the CRC and file size, and set the flag so we read
            # a new member on the next call
            self._read_eof()
            self._new_member = True

    def _add_read_data(self, data):
        self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
        self.extrabuf = self.extrabuf + data
        self.extrasize = self.extrasize + len(data)
        self.size = self.size + len(data)

    def _read_eof(self):
        # We've read to the end of the file, so we have to rewind in order
        # to reread the 8 bytes containing the CRC and the file size.
        # We check the that the computed CRC and size of the
        # uncompressed data matches the stored values.  Note that the size
        # stored is the true file size mod 2**32.
        self.fileobj.seek(-8, 1)
        crc32 = read32(self.fileobj)
        isize = read32(self.fileobj)  # may exceed 2GB
        if crc32 != self.crc:
            raise IOError("CRC check failed %s != %s" % (hex(crc32),
                                                         hex(self.crc)))
        elif isize != (self.size & 0xffffffffL):
            raise IOError, "Incorrect length of data produced"

        # Gzip files can be padded with zeroes and still have archives.
        # Consume all zero bytes and set the file position to the first
        # non-zero byte. See http://www.gzip.org/#faq8
        c = "\x00"
        while c == "\x00":
            c = self.fileobj.read(1)
        if c:
            self.fileobj.seek(-1, 1)

    @property
    def closed(self):
        return self.fileobj is None

    def close(self):
        if self.fileobj is None:
            return
        if self.mode == WRITE:
            self.fileobj.write(self.compress.flush())
            write32u(self.fileobj, self.crc)
            # self.size may exceed 2GB, or even 4GB
            write32u(self.fileobj, self.size & 0xffffffffL)
            self.fileobj = None
        elif self.mode == READ:
            self.fileobj = None
        if self.myfileobj:
            self.myfileobj.close()
            self.myfileobj = None

    def __del__(self):
        try:
            if (self.myfileobj is None and
                self.fileobj is None):
                return
        except AttributeError:
            return
        self.close()

    def flush(self,zlib_mode=zlib.Z_SYNC_FLUSH):
        self._check_closed()
        if self.mode == WRITE:
            # Ensure the compressor's buffer is flushed
            self.fileobj.write(self.compress.flush(zlib_mode))
            self.fileobj.flush()

    def fileno(self):
        """Invoke the underlying file object's fileno() method.

        This will raise AttributeError if the underlying file object
        doesn't support fileno().
        """
        return self.fileobj.fileno()

    def isatty(self):
        return False

    def tell(self):
        return self.offset

    def rewind(self):
        '''Return the uncompressed stream file position indicator to the
        beginning of the file'''
        if self.mode != READ:
            raise IOError("Can't rewind in write mode")
        self.fileobj.seek(0)
        self._new_member = True
        self.extrabuf = ""
        self.extrasize = 0
        self.offset = 0

    def readable(self):
        return self.mode == READ

    def writable(self):
        return self.mode == WRITE

    def seekable(self):
        return True

    def seek(self, offset, whence=0):
        if whence:
            if whence == 1:
                offset = self.offset + offset
            else:
                raise ValueError('Seek from end not supported')
        if self.mode == WRITE:
            if offset < self.offset:
                raise IOError('Negative seek in write mode')
            count = offset - self.offset
            for i in xrange(count // 1024):
                self.write(1024 * '\0')
            self.write((count % 1024) * '\0')
        elif self.mode == READ:
            if offset < self.offset:
                # for negative seek, rewind and do positive seek
                self.rewind()
            count = offset - self.offset
            for i in xrange(count // 1024):
                self.read(1024)
            self.read(count % 1024)

        return self.offset

    def readline(self, size=-1):
        if size < 0:
            size = sys.maxint
            readsize = self.min_readsize
        else:
            readsize = size
        bufs = []
        while size != 0:
            c = self.read(readsize)
            i = c.find('\n')

            # We set i=size to break out of the loop under two
            # conditions: 1) there's no newline, and the chunk is
            # larger than size, or 2) there is a newline, but the
            # resulting line would be longer than 'size'.
            if (size <= i) or (i == -1 and len(c) > size):
                i = size - 1

            if i >= 0 or c == '':
                bufs.append(c[:i + 1])    # Add portion of last chunk
                self._unread(c[i + 1:])   # Push back rest of chunk
                break

            # Append chunk to list, decrease 'size',
            bufs.append(c)
            size = size - len(c)
            readsize = min(size, readsize * 2)
        if readsize > self.min_readsize:
            self.min_readsize = min(readsize, self.min_readsize * 2, 512)
        return ''.join(bufs) # Return resulting line

    def readlines(self, sizehint=0):
        # Negative numbers result in reading all the lines
        if sizehint <= 0:
            sizehint = sys.maxint
        L = []
        while sizehint > 0:
            line = self.readline()
            if line == "":
                break
            L.append(line)
            sizehint = sizehint - len(line)

        return L

    def writelines(self, L):
        for line in L:
            self.write(line)

    def __iter__(self):
        return self

    def next(self):
        line = self.readline()
        if line:
            return line
        else:
            raise StopIteration

    def __enter__(self):
        if self.fileobj is None:
            raise ValueError("I/O operation on closed GzipFile object")
        return self

    def __exit__(self, *args):
        self.close()


def _test():
    # Act like gzip; with -d, act like gunzip.
    # The input file is not deleted, however, nor are any other gzip
    # options or features supported.
    args = sys.argv[1:]
    decompress = args and args[0] == "-d"
    if decompress:
        args = args[1:]
    if not args:
        args = ["-"]
    for arg in args:
        if decompress:
            if arg == "-":
                f = GzipFile(filename="", mode="rb", fileobj=sys.stdin)
                g = sys.stdout
            else:
                if arg[-3:] != ".gz":
                    print "filename doesn't end in .gz:", repr(arg)
                    continue
                f = open(arg, "rb")
                g = __builtin__.open(arg[:-3], "wb")
        else:
            if arg == "-":
                f = sys.stdin
                g = GzipFile(filename="", mode="wb", fileobj=sys.stdout)
            else:
                f = __builtin__.open(arg, "rb")
                g = open(arg + ".gz", "wb")
        while True:
            chunk = f.read(1024)
            if not chunk:
                break
            g.write(chunk)
        if g is not sys.stdout:
            g.close()
        if f is not sys.stdin:
            f.close()

if __name__ == '__main__':
    _test()

########NEW FILE########
__FILENAME__ = htmllib
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Default HTML parser handler classes.
"""

import sys


class HtmlPrinter (object):
    """
    Handles all functions by printing the function name and attributes.
    """

    def __init__ (self, fd=sys.stdout):
        """
        Write to given file descriptor.

        @param fd: file like object (default=sys.stdout)
        @type fd: file
        """
        self.fd = fd

    def _print (self, *attrs):
        """
        Print function attributes to stored file descriptor.

        @param attrs: list of values to print
        @type attrs: tuple
        @return: None
        """
        print >> self.fd, self.mem, attrs

    def __getattr__ (self, name):
        """
        Remember the called method name in self.mem.

        @param name: attribute name
        @type name: string
        @return: method which just prints out its arguments
        @rtype: a bound function object
        """
        self.mem = name
        return self._print


class HtmlPrettyPrinter (object):
    """
    Print out all parsed HTML data in encoded form.
    Also stores error and warnings messages.
    """

    def __init__ (self, fd=sys.stdout, encoding="iso8859-1"):
        """
        Write to given file descriptor in given encoding.

        @param fd: file like object (default=sys.stdout)
        @type fd: file
        @param encoding: encoding (default=iso8859-1)
        @type encoding: string
        """
        self.fd = fd
        self.encoding = encoding

    def comment (self, data):
        """
        Print HTML comment.

        @param data: the comment
        @type data: string
        @return: None
        """
        data = data.encode(self.encoding, "ignore")
        self.fd.write("<!--%s-->" % data)

    def start_element (self, tag, attrs):
        """
        Print HTML start element.

        @param tag: tag name
        @type tag: string
        @param attrs: tag attributes
        @type attrs: dict
        @return: None
        """
        self._start_element(tag, attrs, ">")

    def start_end_element (self, tag, attrs):
        """
        Print HTML start-end element.

        @param tag: tag name
        @type tag: string
        @param attrs: tag attributes
        @type attrs: dict
        @return: None
        """
        self._start_element(tag, attrs, "/>")

    def _start_element (self, tag, attrs, end):
        """
        Print HTML element with end string.

        @param tag: tag name
        @type tag: string
        @param attrs: tag attributes
        @type attrs: dict
        @param end: either > or />
        @type end: string
        @return: None
        """
        tag = tag.encode(self.encoding, "ignore")
        self.fd.write("<%s" % tag.replace("/", ""))
        for key, val in attrs.items():
            key = key.encode(self.encoding, "ignore")
            if val is None:
                self.fd.write(" %s" % key)
            else:
                val = val.encode(self.encoding, "ignore")
                self.fd.write(' %s="%s"' % (key, quote_attrval(val)))
        self.fd.write(end)

    def end_element (self, tag):
        """
        Print HTML end element.

        @param tag: tag name
        @type tag: string
        @return: None
        """
        tag = tag.encode(self.encoding, "ignore")
        self.fd.write("</%s>" % tag)

    def doctype (self, data):
        """
        Print HTML document type.

        @param data: the document type
        @type data: string
        @return: None
        """
        data = data.encode(self.encoding, "ignore")
        self.fd.write("<!DOCTYPE%s>" % data)

    def pi (self, data):
        """
        Print HTML pi.

        @param data: the tag data
        @type data: string
        @return: None
        """
        data = data.encode(self.encoding, "ignore")
        self.fd.write("<?%s?>" % data)

    def cdata (self, data):
        """
        Print HTML cdata.

        @param data: the character data
        @type data: string
        @return: None
        """
        data = data.encode(self.encoding, "ignore")
        self.fd.write("<![CDATA[%s]]>" % data)

    def characters (self, data):
        """
        Print characters.

        @param data: the character data
        @type data: string
        @return: None
        """
        data = data.encode(self.encoding, "ignore")
        self.fd.write(data)


def quote_attrval (s):
    """
    Quote a HTML attribute to be able to wrap it in double quotes.

    @param s: the attribute string to quote
    @type s: string
    @return: the quoted HTML attribute
    @rtype: string
    """
    res = []
    for c in s:
        if ord(c) <= 127:
            # ASCII
            if c == u'&':
                res.append(u"&amp;")
            elif c == u'"':
                res.append(u"&quot;")
            else:
                res.append(c)
        else:
            res.append(u"&#%d;" % ord(c))
    return u"".join(res)

########NEW FILE########
__FILENAME__ = linkname
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2001-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Parse names of title tags and link types.
"""

import re
from .. import HtmlParser, strformat


imgtag_re = re.compile(r"(?i)\s+alt\s*=\s*"+\
                       r"""(?P<name>("[^"\n]*"|'[^'\n]*'|[^\s>]+))""")
img_re = re.compile(r"""(?i)<\s*img\s+("[^"\n]*"|'[^'\n]*'|[^>])+>""")


def endtag_re (tag):
    """Return matcher for given end tag"""
    return re.compile(r"(?i)</%s\s*>" % tag)

a_end_search = endtag_re("a").search
title_end_search = endtag_re("title").search


def _unquote (txt):
    """Resolve entities and remove markup from txt."""
    return HtmlParser.resolve_entities(strformat.remove_markup(txt))


def image_name (txt):
    """Return the alt part of the first <img alt=""> tag in txt."""
    mo = imgtag_re.search(txt)
    if mo:
        name = strformat.unquote(mo.group('name').strip())
        return  _unquote(name)
    return u''


def href_name (txt):
    """Return the name part of the first <a href="">name</a> link in txt."""
    name = u""
    endtag = a_end_search(txt)
    if not endtag:
        return name
    name = txt[:endtag.start()]
    if img_re.search(name):
        return image_name(name)
    return _unquote(name)


def title_name (txt):
    """Return the part of the first <title>name</title> in txt."""
    name = u""
    endtag = title_end_search(txt)
    if not endtag:
        return name
    name = txt[:endtag.start()]
    return _unquote(name)

########NEW FILE########
__FILENAME__ = linkparse
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2001-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Find link tags in HTML text.
"""

import re
from .. import strformat, log, LOG_CHECK, url as urlutil
from . import linkname

MAX_NAMELEN = 256
MAX_TITLELEN = 256

unquote = strformat.unquote

# HTML4/5 link tags
# ripped mainly from HTML::Tagset.pm with HTML5 added
LinkTags = {
    'a':        [u'href'],
    'applet':   [u'archive', u'src'],
    'area':     [u'href'],
    'audio':    [u'src'], # HTML5
    'bgsound':  [u'src'],
    'blockquote': [u'cite'],
    'body':     [u'background'],
    'button':   [u'formaction'], # HTML5
    'del':      [u'cite'],
    'embed':    [u'pluginspage', u'src'],
    'form':     [u'action'],
    'frame':    [u'src', u'longdesc'],
    'head':     [u'profile'],
    'html':     [u'manifest'], # HTML5
    'iframe':   [u'src', u'longdesc'],
    'ilayer':   [u'background'],
    'img':      [u'src', u'lowsrc', u'longdesc', u'usemap', u'srcset'],
    'input':    [u'src', u'usemap', u'formaction'],
    'ins':      [u'cite'],
    'isindex':  [u'action'],
    'layer':    [u'background', u'src'],
    'link':     [u'href'],
    'meta':     [u'content', u'href'],
    'object':   [u'classid', u'data', u'archive', u'usemap', u'codebase'],
    'q':        [u'cite'],
    'script':   [u'src'],
    'source':   [u'src'], # HTML5
    'table':    [u'background'],
    'td':       [u'background'],
    'th':       [u'background'],
    'tr':       [u'background'],
    'track':    [u'src'], # HTML5
    'video':    [u'src'], # HTML5
    'xmp':      [u'href'],
    None:       [u'style', u'itemtype'],
}

# HTML anchor tags
AnchorTags = {
    'a': [u'name'],
    None: [u'id'],
}

# WML tags
WmlTags = {
    'a':   [u'href'],
    'go':  [u'href'],
    'img': [u'src'],
}


# matcher for <meta http-equiv=refresh> tags
refresh_re = re.compile(ur"(?i)^\d+;\s*url=(?P<url>.+)$")
_quoted_pat = ur"('[^']+'|\"[^\"]+\"|[^\)\s]+)"
css_url_re = re.compile(ur"url\(\s*(?P<url>%s)\s*\)" % _quoted_pat)
swf_url_re = re.compile("(?i)%s" % urlutil.safe_url_pattern)
c_comment_re = re.compile(ur"/\*.*?\*/", re.DOTALL)


def strip_c_comments (text):
    """Remove C/CSS-style comments from text. Note that this method also
    deliberately removes comments inside of strings."""
    return c_comment_re.sub('', text)


class StopParse (StandardError):
    """Raised when parsing should stop."""
    pass


class TitleFinder (object):
    """Find title tags in HTML text."""

    def __init__ (self):
        """Initialize title."""
        super(TitleFinder, self).__init__()
        log.debug(LOG_CHECK, "HTML title parser")
        self.title = None

    def start_element (self, tag, attrs):
        """Search for <title> tag."""
        if tag == 'title':
            data = self.parser.peek(MAX_TITLELEN)
            data = data.decode(self.parser.encoding, "ignore")
            self.title = linkname.title_name(data)
            raise StopParse("found <title> tag")
        elif tag == 'body':
            raise StopParse("found <body> tag")


class TagFinder (object):
    """Base class handling HTML start elements.
    TagFinder instances are used as HtmlParser handlers."""

    def __init__ (self):
        """Initialize local variables."""
        super(TagFinder, self).__init__()
        # parser object will be initialized when it is used as
        # a handler object
        self.parser = None

    def start_element (self, tag, attrs):
        """Does nothing, override in a subclass."""
        pass

    def start_end_element (self, tag, attrs):
        """Delegate a combined start/end element (eg. <br/>) to
        the start_element method. Ignore the end element part."""
        self.start_element(tag, attrs)


class MetaRobotsFinder (TagFinder):
    """Class for finding robots.txt meta values in HTML."""

    def __init__ (self):
        """Initialize follow and index flags."""
        super(MetaRobotsFinder, self).__init__()
        log.debug(LOG_CHECK, "meta robots finder")
        self.follow = self.index = True

    def start_element (self, tag, attrs):
        """Search for meta robots.txt "nofollow" and "noindex" flags."""
        if tag == 'meta' and attrs.get('name') == 'robots':
            val = attrs.get_true('content', u'').lower().split(u',')
            self.follow = u'nofollow' not in val
            self.index = u'noindex' not in val
            raise StopParse("found <meta name=robots> tag")
        elif tag == 'body':
            raise StopParse("found <body> tag")


def is_meta_url (attr, attrs):
    """Check if the meta attributes contain a URL."""
    res = False
    if attr == "content":
        equiv = attrs.get_true('http-equiv', u'').lower()
        scheme = attrs.get_true('scheme', u'').lower()
        res = equiv in (u'refresh',) or scheme in (u'dcterms.uri',)
    if attr == "href":
        rel = attrs.get_true('rel', u'').lower()
        res = rel in (u'shortcut icon', u'icon')
    return res


def is_form_get(attr, attrs):
    """Check if this is a GET form action URL."""
    res = False
    if attr == "action":
        method = attrs.get_true('method', u'').lower()
        res = method != 'post'
    return res


class LinkFinder (TagFinder):
    """Find HTML links, and apply them to the callback function with the
    format (url, lineno, column, name, codebase)."""

    def __init__ (self, callback, tags):
        """Store content in buffer and initialize URL list."""
        super(LinkFinder, self).__init__()
        self.callback = callback
        # set universal tag attributes using tagname None
        self.universal_attrs = set(tags.get(None, []))
        self.tags = dict()
        for  tag, attrs in tags.items():
            self.tags[tag] = set(attrs)
            # add universal tag attributes
            self.tags[tag].update(self.universal_attrs)
        self.base_ref = u''

    def start_element (self, tag, attrs):
        """Search for links and store found URLs in a list."""
        log.debug(LOG_CHECK, "LinkFinder tag %s attrs %s", tag, attrs)
        log.debug(LOG_CHECK, "line %d col %d old line %d old col %d", self.parser.lineno(), self.parser.column(), self.parser.last_lineno(), self.parser.last_column())
        if tag == "base" and not self.base_ref:
            self.base_ref = unquote(attrs.get_true("href", u''))
        tagattrs = self.tags.get(tag, self.universal_attrs)
        # parse URLs in tag (possibly multiple URLs in CSS styles)
        for attr in tagattrs.intersection(attrs):
            if tag == "meta" and not is_meta_url(attr, attrs):
                continue
            if tag == "form" and not is_form_get(attr, attrs):
                continue
            # name of this link
            name = self.get_link_name(tag, attrs, attr)
            # possible codebase
            base = u''
            if tag  == 'applet':
                base = unquote(attrs.get_true('codebase', u''))
            if not base:
                base = self.base_ref
            # note: value can be None
            value = unquote(attrs.get(attr))
            if tag == 'link' and attrs.get('rel') == 'dns-prefetch':
                if ':' in value:
                    value = value.split(':', 1)[1]
                value = 'dns:' + value.rstrip('/')
            # parse tag for URLs
            self.parse_tag(tag, attr, value, name, base)
        log.debug(LOG_CHECK, "LinkFinder finished tag %s", tag)

    def get_link_name (self, tag, attrs, attr):
        """Parse attrs for link name. Return name of link."""
        if tag == 'a' and attr == 'href':
            # Look for name only up to MAX_NAMELEN characters
            data = self.parser.peek(MAX_NAMELEN)
            data = data.decode(self.parser.encoding, "ignore")
            name = linkname.href_name(data)
            if not name:
                name = unquote(attrs.get_true('title', u''))
        elif tag == 'img':
            name = unquote(attrs.get_true('alt', u''))
            if not name:
                name = unquote(attrs.get_true('title', u''))
        else:
            name = u""
        return name

    def parse_tag (self, tag, attr, value, name, base):
        """Add given url data to url list."""
        assert isinstance(tag, unicode), repr(tag)
        assert isinstance(attr, unicode), repr(attr)
        assert isinstance(name, unicode), repr(name)
        assert isinstance(base, unicode), repr(base)
        assert isinstance(value, unicode) or value is None, repr(value)
        # look for meta refresh
        if tag == u'meta' and value:
            mo = refresh_re.match(value)
            if mo:
                self.found_url(mo.group("url"), name, base)
            elif attr != 'content':
                self.found_url(value, name, base)
        elif attr == u'style' and value:
            for mo in css_url_re.finditer(value):
                url = unquote(mo.group("url"), matching=True)
                self.found_url(url, name, base)
        elif attr == u'archive':
            for url in value.split(u','):
                self.found_url(url, name, base)
        elif attr == u'srcset':
            for img_candidate in value.split(u','):
                url = img_candidate.split()[0]
                self.found_url(url, name, base)
        else:
            self.found_url(value, name, base)

    def found_url(self, url, name, base):
        """Add newly found URL to queue."""
        assert isinstance(url, unicode) or url is None, repr(url)
        self.callback(url, line=self.parser.last_lineno(),
                      column=self.parser.last_column(), name=name, base=base)

########NEW FILE########
__FILENAME__ = httputil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import base64
from datetime import datetime


DEFAULT_KEEPALIVE = 300

MAX_HEADER_BYTES = 8*1024


def encode_base64 (s):
    """Encode given string in base64, excluding trailing newlines."""
    return base64.b64encode(s)


def x509_to_dict(x509):
    """Parse a x509 pyopenssl object to a dictionary with keys
    subject, subjectAltName and optional notAfter.
    """
    from requests.packages.urllib3.contrib.pyopenssl import get_subj_alt_name
    res = {
            'subject': (
                (('commonName', x509.get_subject().CN),),
            ),
            'subjectAltName': [
                ('DNS', value)
                for value in get_subj_alt_name(x509)
            ]
    }
    notAfter = x509.get_notAfter()
    if notAfter is not None:
        parsedtime = asn1_generaltime_to_seconds(notAfter)
        if parsedtime is not None:
            res['notAfter'] = parsedtime.strftime('%b %d %H:%M:%S %Y')
            if parsedtime.tzinfo is None:
                res['notAfter'] += ' GMT'
        else:
            # give up parsing, just set the string
            res['notAfter'] = notAfter
    return res


def asn1_generaltime_to_seconds(timestr):
    """The given string has one of the following formats
    YYYYMMDDhhmmssZ
    YYYYMMDDhhmmss+hhmm
    YYYYMMDDhhmmss-hhmm
    @return: a datetime object or None on error
    """
    res = None
    timeformat = "%Y%m%d%H%M%S"
    try:
        res = datetime.strptime(timestr, timeformat + 'Z')
    except ValueError:
        try:
            res = datetime.strptime(timestr, timeformat + '%z')
        except ValueError:
            pass
    return res

def has_header_value (headers, name, value):
    """
    Look in headers for a specific header name and value.
    Both name and value are case insensitive.

    @return: True if header name and value are found
    @rtype: bool
    """
    name = name.lower()
    value = value.lower()
    for hname, hvalue in headers:
        if hname.lower()==name and hvalue.lower()==value:
            return True
    return False


def http_persistent (response):
    """
    See if the HTTP connection can be kept open according the the
    header values found in the response object.

    @param response: response instance
    @type response: httplib.HTTPResponse
    @return: True if connection is persistent
    @rtype: bool
    """
    headers = response.getheaders()
    if response.version == 11:
        return not has_header_value(headers, 'Connection', 'Close')
    return has_header_value(headers, "Connection", "Keep-Alive")


def http_keepalive (headers):
    """
    Get HTTP keepalive value, either from the Keep-Alive header or a
    default value.

    @param headers: HTTP headers
    @type headers: dict
    @return: keepalive in seconds
    @rtype: int
    """
    keepalive = headers.get("Keep-Alive")
    if keepalive is not None:
        try:
            keepalive = int(keepalive[8:].strip())
        except (ValueError, OverflowError):
            keepalive = DEFAULT_KEEPALIVE
    else:
        keepalive = DEFAULT_KEEPALIVE
    return keepalive


def get_content_type (headers):
    """
    Get the MIME type from the Content-Type header value, or
    'application/octet-stream' if not found.

    @return: MIME type
    @rtype: string
    """
    ptype = headers.get('Content-Type', 'application/octet-stream')
    if ";" in ptype:
        # split off not needed extension info
        ptype = ptype.split(';')[0]
    return ptype.strip().lower()


def get_charset(headers):
    """
    Get the charset encoding from the Content-Type header value, or
    None if not found.

    @return: the content charset encoding
    @rtype: string or None
    """
    from linkcheck.HtmlParser import get_ctype_charset
    return get_ctype_charset(headers.get('Content-Type', ''))


def get_content_encoding (headers):
    """
    Get the content encoding from the Content-Encoding header value, or
    an empty string if not found.

    @return: encoding string
    @rtype: string
    """
    return headers.get("Content-Encoding", "").strip()

########NEW FILE########
__FILENAME__ = i18n
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Application internationalization support.
"""

# i18n suppport
import os
import locale
import gettext
import sys
import codecs

# more supported languages are added in init()
supported_languages = set(['en'])
default_language = default_encoding = None
default_directory = None
default_domain = None

def install_builtin (translator, do_unicode):
    """Install _() and _n() gettext methods into default namespace."""
    import __builtin__
    if do_unicode:
        __builtin__.__dict__['_'] = translator.ugettext
        # also install ngettext
        __builtin__.__dict__['_n'] = translator.ungettext
    else:
        __builtin__.__dict__['_'] = translator.gettext
        # also install ngettext
        __builtin__.__dict__['_n'] = translator.ngettext

class Translator (gettext.GNUTranslations):
    """A translation class always installing its gettext methods into the
    default namespace."""

    def install (self, do_unicode):
        """Install gettext methods into the default namespace."""
        install_builtin(self, do_unicode)


class NullTranslator (gettext.NullTranslations):
    """A dummy translation class always installing its gettext methods into
    the default namespace."""

    def install (self, do_unicode):
        """Install gettext methods into the default namespace."""
        install_builtin(self, do_unicode)


def init (domain, directory, loc=None):
    """Initialize this gettext i18n module. Searches for supported languages
    and installs the gettext translator class."""
    global default_language, default_encoding, default_domain, default_directory
    default_directory = directory
    default_domain = domain
    if os.path.isdir(directory):
        # get supported languages
        for lang in os.listdir(directory):
            path = os.path.join(directory, lang, 'LC_MESSAGES')
            mo_file = os.path.join(path, '%s.mo' % domain)
            if os.path.exists(mo_file):
                supported_languages.add(lang)
    if loc is None:
        loc, encoding = get_locale()
    else:
        encoding = get_locale()[1]
    if loc in supported_languages:
        default_language = loc
    else:
        default_language = "en"
    # Even if the default language is not supported, the encoding should
    # be installed. Otherwise the Python installation is borked.
    default_encoding = encoding
    install_language(default_language)


def install_language(language):
    """Install translation service routines into default namespace."""
    translator = get_translator(default_domain, default_directory,
        languages=[get_lang(language)], fallback=True)
    do_unicode = True
    translator.install(do_unicode)


def get_translator (domain, directory, languages=None,
                    translatorklass=Translator, fallback=False,
                    fallbackklass=NullTranslator):
    """Search the appropriate GNUTranslations class."""
    translator = gettext.translation(domain, localedir=directory,
            languages=languages, class_=translatorklass, fallback=fallback)
    if not isinstance(translator, gettext.GNUTranslations) and fallbackklass:
        translator = fallbackklass()
    return translator


def get_lang (lang):
    """Return lang if it is supported, or the default language."""
    if lang in supported_languages:
        return lang
    return default_language


def get_headers_lang (headers):
    """Return preferred supported language in given HTTP headers."""
    if 'Accept-Language' not in headers:
        return default_language
    languages = headers['Accept-Language'].split(",")
    # sort with preference values
    pref_languages = []
    for lang in languages:
        pref = 1.0
        if ";" in lang:
            lang, _pref = lang.split(';', 1)
            try:
                pref = float(_pref)
            except ValueError:
                pass
        pref_languages.append((pref, lang))
    pref_languages.sort()
    # search for lang
    for lang in (x[1] for x in pref_languages):
        if lang in supported_languages:
            return lang
    return default_language


def get_locale ():
    """Search the default platform locale and norm it.
    @returns (locale, encoding)
    @rtype (string, string)"""
    try:
        loc, encoding = locale.getdefaultlocale()
    except ValueError:
        # locale configuration is broken - ignore that
        loc, encoding = None, None
    if loc is None:
        loc = "C"
    else:
        loc = norm_locale(loc)
    if encoding is None:
        encoding = "ascii"
    return (loc, encoding)


def norm_locale (loc):
    """Normalize a locale."""
    loc = locale.normalize(loc)
    # split up the locale into its base components
    pos = loc.find('@')
    if pos >= 0:
        loc = loc[:pos]
    pos = loc.find('.')
    if pos >= 0:
        loc = loc[:pos]
    pos = loc.find('_')
    if pos >= 0:
        loc = loc[:pos]
    return loc


lang_names = {
    'en': u'English',
    'de': u'Deutsch',
}
lang_transis = {
    'de': {'en': u'German'},
    'en': {'de': u'Englisch'},
}

def lang_name (lang):
    """Return full name of given language."""
    return lang_names[lang]


def lang_trans (lang, curlang):
    """Return translated full name of given language."""
    return lang_transis[lang][curlang]


def get_encoded_writer (out=sys.stdout, encoding=None, errors='replace'):
    """Get wrapped output writer with given encoding and error handling."""
    if encoding is None:
        encoding = default_encoding
    Writer = codecs.getwriter(encoding)
    return Writer(out, errors)

########NEW FILE########
__FILENAME__ = lc_cgi
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Functions used by the WSGI script.
"""

import cgi
import os
import threading
import locale
import re
import time
import urlparse
from . import configuration, strformat, checker, director, get_link_pat, \
    init_i18n, url as urlutil
from .decorators import synchronized

# 5 minutes timeout for requests
MAX_REQUEST_SECONDS = 300
# character set encoding for HTML output
HTML_ENCODING = 'utf-8'


def application(environ, start_response):
    """WSGI interface: start an URL check."""
    # the environment variable CONTENT_LENGTH may be empty or missing
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0

    # When the method is POST the query string will be sent
    # in the HTTP request body which is passed by the WSGI server
    # in the file like wsgi.input environment variable.
    if request_body_size > 0:
        request_body = environ['wsgi.input'].read(request_body_size)
    else:
        request_body = environ['wsgi.input'].read()
    form = cgi.parse_qs(request_body)

    status = '200 OK'
    start_response(status, get_response_headers())
    for output in checklink(form=form, env=environ):
        yield output


_supported_langs = ('de', 'C')
# map language -> locale name
lang_locale = {
    'de': 'de_DE',
    'C': 'C',
    'en': 'en_EN',
}
_is_level = re.compile(r'^(0|1|2|3|-1)$').match

class LCFormError (StandardError):
    """Form related errors."""
    pass


def get_response_headers():
    """Get list of response headers in key-value form."""
    return [("Content-type", "text/html"),
            ("Cache-Control", "no-cache"),
            ("Pragma:", "no-cache")
           ]


def formvalue (form, key):
    """Get value with given key from WSGI form."""
    field = form.get(key)
    if isinstance(field, list):
        field = field[0]
    return field


_lock = threading.Lock()
class ThreadsafeIO (object):
    """Thread-safe unicode I/O class."""

    def __init__(self):
        """Initialize buffer."""
        self.buf = []
        self.closed = False

    @synchronized(_lock)
    def write (self, data):
        """Write given unicode data to buffer."""
        assert isinstance(data, unicode)
        if self.closed:
            raise IOError("Write on closed I/O object")
        if data:
            self.buf.append(data)

    @synchronized(_lock)
    def get_data (self):
        """Get bufferd unicode data."""
        data = u"".join(self.buf)
        self.buf = []
        return data

    @synchronized(_lock)
    def close (self):
        """Reset buffer and close this I/O object."""
        self.buf = []
        self.closed = True


def encode(s):
    """Encode given string in HTML encoding."""
    return s.encode(HTML_ENCODING, 'ignore')


def checklink (form=None, env=os.environ):
    """Validates the CGI form and checks the given links."""
    if form is None:
        form = {}
    try:
        checkform(form, env)
    except LCFormError as errmsg:
        log(env, errmsg)
        yield encode(format_error(errmsg))
        return
    out = ThreadsafeIO()
    config = get_configuration(form, out)
    url = strformat.stripurl(formvalue(form, "url"))
    aggregate = director.get_aggregate(config)
    url_data = checker.get_url_from(url, 0, aggregate, extern=(0, 0))
    aggregate.urlqueue.put(url_data)
    for html_str in start_check(aggregate, out):
        yield encode(html_str)
    out.close()


def start_check (aggregate, out):
    """Start checking in background and write encoded output to out."""
    # check in background
    t = threading.Thread(target=director.check_urls, args=(aggregate,))
    t.start()
    # time to wait for new data
    sleep_seconds = 2
    # current running time
    run_seconds = 0
    while not aggregate.is_finished():
        yield out.get_data()
        time.sleep(sleep_seconds)
        run_seconds += sleep_seconds
        if run_seconds > MAX_REQUEST_SECONDS:
            director.abort(aggregate)
            break
    yield out.get_data()


def get_configuration(form, out):
    """Initialize a CGI configuration."""
    config = configuration.Configuration()
    config["recursionlevel"] = int(formvalue(form, "level"))
    config["logger"] = config.logger_new('html', fd=out, encoding=HTML_ENCODING)
    config["threads"] = 2
    if "anchors" in form:
        config["enabledplugins"].append("AnchorCheck")
    if "errors" not in form:
        config["verbose"] = True
    # avoid checking of local files or other nasty stuff
    pat = "!^%s$" % urlutil.safe_url_pattern
    config["externlinks"].append(get_link_pat(pat, strict=True))
    return config


def get_host_name (form):
    """Return host name of given URL."""
    return urlparse.urlparse(formvalue(form, "url"))[1]


def checkform (form, env):
    """Check form data. throw exception on error
    Be sure to NOT print out any user-given data as HTML code, so use
    only plain strings as exception text."""
    # check lang support
    if "language" in form:
        lang = formvalue(form, 'language')
        if lang in _supported_langs:
            localestr = lang_locale[lang]
            try:
                # XXX this is not thread-safe, so think of something else
                locale.setlocale(locale.LC_ALL, localestr)
                init_i18n()
            except locale.Error as errmsg:
                log(env, "could not set locale %r: %s" % (localestr, errmsg))
        else:
            raise LCFormError(_("unsupported language %r") % lang)
    # check url syntax
    if "url" in form:
        url = formvalue(form, "url")
        if not url or url == "http://":
            raise LCFormError(_("empty url was given"))
        if not urlutil.is_safe_url(url):
            raise LCFormError(_("disallowed url %r was given") % url)
    else:
        raise LCFormError(_("no url was given"))
    # check recursion level
    if "level" in form:
        level = formvalue(form, "level")
        if not _is_level(level):
            raise LCFormError(_("invalid recursion level %r") % level)
    # check options
    for option in ("anchors", "errors", "intern"):
        if option in form:
            value = formvalue(form, option)
            if value != "on":
                raise LCFormError(_("invalid %s option %r") % (option, value))


def log (env, msg):
    """Log message to WSGI error output."""
    logfile = env['wsgi.errors']
    logfile.write(msg + "\n")


def dump (env, form):
    """Log environment and form."""
    for var, value in env.items():
        log(env, var+"="+value)
    for key in form:
        log(env, str(formvalue(form, key)))


def format_error (why):
    """Format standard error page.
    @param why: error message
    @ptype why: unicode
    @return: HTML page content
    @rtype: unicode
    """
    return _("""<!DOCTYPE HTML>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>LinkChecker Online Error</title></head>
<body text=#192c83 bgcolor=#fff7e5 link=#191c83 vlink=#191c83 alink=#191c83>
<blockquote>
<b>Error: %s</b><br/>
The LinkChecker Online script has encountered an error. Please ensure
that your provided URL link begins with <code>http://</code> and
contains only these characters: <code>A-Za-z0-9./_~-</code><br/><br/>
Errors are logged.
</blockquote>
</body>
</html>""") % cgi.escape(why)

########NEW FILE########
__FILENAME__ = loader
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
"""
Functions to load plugin modules.

Example usage:
    modules = loader.get_package_modules('plugins')
    plugins = loader.get_plugins(modules, PluginClass)
"""
from __future__ import print_function
import os
import sys
import zipfile
import importlib
import imp
from .fileutil import is_writable_by_others


def is_frozen ():
    """Return True if running inside a py2exe- or py2app-generated
    executable."""
    return hasattr(sys, "frozen")


def check_writable_by_others(filename):
    """Check if file is writable by others on POSIX systems.
    On non-POSIX systems the check is ignored."""
    if os.name != 'posix':
        # XXX on non-posix systems other bits are relevant
        return
    return is_writable_by_others(filename)


def get_package_modules(packagename):
    """Find all valid modules in the given package which must be a folder
    in the same directory as this loader.py module. A valid module has
    a .py extension, and is importable.
    @return: all loaded valid modules
    @rtype: iterator of module
    """
    if is_frozen():
        # find modules in library.zip filename
        zipname = os.path.dirname(os.path.dirname(__file__))
        parentmodule = os.path.basename(os.path.dirname(__file__))
        with zipfile.ZipFile(zipname, 'r') as f:
            prefix = "%s/%s/" % (parentmodule, packagename)
            modnames = [os.path.splitext(n[len(prefix):])[0]
              for n in f.namelist()
              if n.startswith(prefix) and "__init__" not in n]
    else:
        dirname = os.path.join(os.path.dirname(__file__), packagename)
        modnames = [x[:-3] for x in get_importable_files(dirname)]
    for modname in modnames:
        try:
            name ="..%s.%s" % (packagename, modname)
            yield importlib.import_module(name, __name__)
        except ImportError as msg:
            print("WARN: could not load module %s: %s" % (modname, msg))


def get_folder_modules(folder, parentpackage):
    """."""
    if check_writable_by_others(folder):
        print("ERROR: refuse to load modules from world writable folder %r" % folder)
        return
    for filename in get_importable_files(folder):
        fullname = os.path.join(folder, filename)
        modname = parentpackage+"."+filename[:-3]
        try:
            yield imp.load_source(modname, fullname)
        except ImportError as msg:
            print("WARN: could not load file %s: %s" % (fullname, msg))


def get_importable_files(folder):
    """Find all module files in the given folder that end with '.py' and
    don't start with an underscore.
    @return module names
    @rtype: iterator of string
    """
    for fname in os.listdir(folder):
        if fname.endswith('.py') and not fname.startswith('_'):
            fullname = os.path.join(folder, fname)
            if check_writable_by_others(fullname):
                print("ERROR: refuse to load module from world writable file %r" % fullname)
            else:
                yield fname


def get_plugins(modules, classes):
    """Find all given (sub-)classes in all modules.
    @param modules: the modules to search
    @ptype modules: iterator of modules
    @return: found classes
    @rytpe: iterator of class objects
    """
    for module in modules:
        for plugin in get_module_plugins(module, classes):
            yield plugin


def get_module_plugins(module, classes):
    """Return all subclasses of a class in the module.
    If the module defines __all__, only those entries will be searched,
    otherwise all objects not starting with '_' will be searched.
    """
    try:
        names = module.__all__
    except AttributeError:
        names = [x for x in vars(module) if not x.startswith('_')]
    for name in names:
        try:
            obj = getattr(module, name)
        except AttributeError:
            continue
        try:
            for classobj in classes:
                if issubclass(obj, classobj):
                    yield obj
        except TypeError:
            continue

########NEW FILE########
__FILENAME__ = lock
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Locking utility class.
"""
import threading
from . import log, LOG_THREAD

def get_lock (name, debug=False):
    """Get a new lock.
    @param debug: if True, acquire() and release() will have debug messages
    @ptype debug: boolean, default is False
    @return: a lock object
    @rtype: threading.Lock or DebugLock
    """
    lock = threading.Lock()
    # for thread debugging, use the DebugLock wrapper
    if debug:
        lock = DebugLock(lock, name)
    return lock


class DebugLock (object):
    """Debugging lock class."""

    def __init__ (self, lock, name):
        """Store lock and name parameters."""
        self.lock = lock
        self.name = name

    def acquire (self, blocking=1):
        """Acquire lock."""
        threadname = threading.currentThread().getName()
        log.debug(LOG_THREAD, "Acquire %s for %s", self.name, threadname)
        self.lock.acquire(blocking)
        log.debug(LOG_THREAD, "...acquired %s for %s", self.name, threadname)

    def release (self):
        """Release lock."""
        threadname = threading.currentThread().getName()
        log.debug(LOG_THREAD, "Release %s for %s", self.name, threadname)
        self.lock.release()


def get_semaphore(name, value=None, debug=False):
    """Get a new semaphore.
    @param value: if not None, a BoundedSemaphore will be used
    @ptype debug: int or None
    @param debug: if True, acquire() and release() will have debug messages
    @ptype debug: boolean, default is False
    @return: a semaphore object
    @rtype: threading.Semaphore or threading.BoundedSemaphore or DebugLock
    """
    if value is None:
        lock = threading.Semaphore()
    else:
        lock = threading.BoundedSemaphore(value)
    if debug:
        lock = DebugLock(lock, name)
    return lock

########NEW FILE########
__FILENAME__ = log
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2003-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Logging and debug functions.
"""

import logging
import os
import inspect
import traceback
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

# memory leak debugging
#import gc
#gc.enable()
#gc.set_debug(gc.DEBUG_LEAK)

PRINT_LOCALVARS = False
def _stack_format (stack):
    """Format a stack trace to a message.

    @return: formatted stack message
    @rtype: string
    """
    s = StringIO()
    s.write('Traceback:')
    s.write(os.linesep)
    for frame, fname, lineno, method, lines, dummy in reversed(stack):
        s.write('  File %r, line %d, in %s' % (fname, lineno, method))
        s.write(os.linesep)
        s.write('    %s' % lines[0].lstrip())
        if PRINT_LOCALVARS:
            for key, value in frame.f_locals.items():
                s.write("      %s = " % key)
                # be careful not to cause a new error in the error output
                try:
                    s.write(repr(value))
                    s.write(os.linesep)
                except StandardError:
                    s.write("error in repr() call%s" % os.linesep)
    return s.getvalue()


def _log (fun, msg, args, **kwargs):
    """Log a message with given function. Optional the following keyword
    arguments are supported:
    traceback(bool) - if True print traceback of current function
    exception(bool) - if True print last exception traceback

    @return: None
    """
    fun(msg, *args)
    if kwargs.get("traceback"):
        # note: get rid of last parts of the stack
        fun(_stack_format(inspect.stack()[2:]))
    if kwargs.get("exception"):
        fun(traceback.format_exc())


def debug (logname, msg, *args, **kwargs):
    """Log a debug message.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.DEBUG):
        _log(log.debug, msg, args, **kwargs)


def info (logname, msg, *args, **kwargs):
    """Log an informational message.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.INFO):
        _log(log.info, msg, args, **kwargs)


def warn (logname, msg, *args, **kwargs):
    """Log a warning.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.WARN):
        _log(log.warn, msg, args, **kwargs)


def error (logname, msg, *args, **kwargs):
    """Log an error.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.ERROR):
        _log(log.error, msg, args, **kwargs)


def critical (logname, msg, *args, **kwargs):
    """Log a critical error.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.CRITICAL):
        _log(log.critical, msg, args, **kwargs)


def exception (logname, msg, *args, **kwargs):
    """Log an exception.

    return: None
    """
    log = logging.getLogger(logname)
    if log.isEnabledFor(logging.ERROR):
        _log(log.exception, msg, args, **kwargs)


def is_debug (logname):
    """See if logger is on debug level."""
    return logging.getLogger(logname).isEnabledFor(logging.DEBUG)


def shutdown ():
    """Flush and close all log handlers."""
    logging.shutdown()

########NEW FILE########
__FILENAME__ = logconf
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Logging configuration
"""
import logging.config
import sys
from . import ansicolor

# application log areas
LOG_ROOT = "linkcheck"
LOG_CMDLINE = "linkcheck.cmdline"
LOG_CHECK = "linkcheck.check"
LOG_CACHE = "linkcheck.cache"
LOG_GUI = "linkcheck.gui"
LOG_THREAD = "linkcheck.thread"
LOG_PLUGIN = "linkcheck.plugin"
lognames = {
    "cmdline": LOG_CMDLINE,
    "checking": LOG_CHECK,
    "cache": LOG_CACHE,
    "gui": LOG_GUI,
    "thread": LOG_THREAD,
    "plugin": LOG_PLUGIN,
    "all": LOG_ROOT,
}

lognamelist = ", ".join(repr(name) for name in lognames)

# logging configuration
configdict = {
    'version': 1,
    'loggers': {
    },
    'root': {
      'level': 'DEBUG',
    },
}

def init_log_config(handler=None):
    """
    Set up the application logging (not to be confused with check
    loggers). When debug is not None it is expected to be a list of
    logger names for which debugging will be enabled.

    """
    for applog in lognames.values():
        # propagate except for root app logger 'linkcheck'
        propagate = (applog != LOG_ROOT)
        configdict['loggers'][applog] = dict(level='INFO', propagate=propagate)

    logging.config.dictConfig(configdict)
    if handler is None:
        handler = ansicolor.ColoredStreamHandler(strm=sys.stderr)
    add_loghandler(handler)


def add_loghandler (handler):
    """Add log handler to root logger LOG_ROOT and set formatting."""
    logging.getLogger(LOG_ROOT).addHandler(handler)
    format = "%(levelname)s %(asctime)s %(threadName)s %(message)s"
    handler.setFormatter(logging.Formatter(format))


def remove_loghandler (handler):
    """Remove log handler from root logger LOG_ROOT."""
    logging.getLogger(LOG_ROOT).removeHandler(handler)


def reset_loglevel():
    """Reset log level to display only warnings and errors."""
    set_loglevel(['all'], logging.WARN)


def set_debug(loggers):
    """Set debugging log level."""
    set_loglevel(loggers, logging.DEBUG)


def set_loglevel(loggers, level):
    """Set logging levels for given loggers."""
    if not loggers:
        return
    if 'all' in loggers:
        loggers = lognames.keys()
    for key in loggers:
        logging.getLogger(lognames[key]).setLevel(level)

########NEW FILE########
__FILENAME__ = blacklist
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A blacklist logger.
"""

import os
import codecs
from . import _Logger


class BlacklistLogger (_Logger):
    """
    Updates a blacklist of wrong links. If a link on the blacklist
    is working (again), it is removed from the list. So after n days
    we have only links on the list which failed for n days.
    """

    LoggerName = "blacklist"

    LoggerArgs = {
        "filename": "~/.linkchecker/blacklist",
    }

    def __init__ (self, **kwargs):
        """Intialize with old blacklist data (if found, else not)."""
        args = self.get_args(kwargs)
        super(BlacklistLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.blacklist = {}
        if self.filename is not None and os.path.exists(self.filename):
            self.read_blacklist()

    def comment (self, s, **args):
        """
        Write nothing.
        """
        pass

    def log_url (self, url_data):
        """
        Put invalid url in blacklist, delete valid url from blacklist.
        """
        key = (url_data.parent_url, url_data.cache_url)
        key = repr(key)
        if key in self.blacklist:
            if url_data.valid:
                del self.blacklist[key]
            else:
                self.blacklist[key] += 1
        else:
            if not url_data.valid:
                self.blacklist[key] = 1

    def end_output (self, **kwargs):
        """
        Write blacklist file.
        """
        self.write_blacklist()

    def read_blacklist (self):
        """
        Read a previously stored blacklist from file fd.
        """
        with codecs.open(self.filename, 'r', self.output_encoding,
                         self.codec_errors) as fd:
            for line in fd:
                line = line.rstrip()
                if line.startswith('#') or not line:
                    continue
                value, key = line.split(None, 1)
                self.blacklist[key] = int(value)

    def write_blacklist (self):
        """
        Write the blacklist.
        """
        oldmask = os.umask(0077)
        for key, value in self.blacklist.items():
            self.write(u"%d %s%s" % (value, repr(key), os.linesep))
        self.close_fileoutput()
        # restore umask
        os.umask(oldmask)

########NEW FILE########
__FILENAME__ = csvlog
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A CSV logger.
"""
import csv
import os
from cStringIO import StringIO
from . import _Logger
from .. import strformat

Columns = (
    u"urlname", u"parentname", u"baseref", u"result", u"warningstring",
    u"infostring", u"valid", u"url", u"line", u"column", u"name",
    u"dltime", u"size", u"checktime", u"cached", u"level", u"modified",
)


class CSVLogger (_Logger):
    """
    CSV output, consisting of one line per entry. Entries are
    separated by a separator (a semicolon per default).
    """

    LoggerName = "csv"

    LoggerArgs = {
        "filename": "linkchecker-out.csv",
        'separator': ';',
        "quotechar": '"',
        "dialect": "excel",
    }

    def __init__ (self, **kwargs):
        """Store default separator and (os dependent) line terminator."""
        args = self.get_args(kwargs)
        super(CSVLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.separator = args['separator']
        self.quotechar = args['quotechar']
        self.dialect = args['dialect']
        self.linesep = os.linesep

    def comment (self, s, **args):
        """Write CSV comment."""
        self.writeln(s=u"# %s" % s, **args)

    def start_output (self):
        """Write checking start info as csv comment."""
        super(CSVLogger, self).start_output()
        row = []
        if self.has_part("intro"):
            self.write_intro()
            self.flush()
        else:
            # write empty string to initialize file output
            self.write(u"")
        self.queue = StringIO()
        self.writer = csv.writer(self.queue, dialect=self.dialect,
               delimiter=self.separator, lineterminator=self.linesep,
               quotechar=self.quotechar)
        for s in Columns:
            if self.has_part(s):
                row.append(s)
        if row:
            self.writerow(row)

    def log_url (self, url_data):
        """Write csv formatted url check info."""
        row = []
        if self.has_part("urlname"):
            row.append(url_data.base_url)
        if self.has_part("parentname"):
            row.append(url_data.parent_url)
        if self.has_part("baseref"):
            row.append(url_data.base_ref)
        if self.has_part("result"):
            row.append(url_data.result)
        if self.has_part("warningstring"):
            row.append(self.linesep.join(x[1] for x in url_data.warnings))
        if self.has_part("infostring"):
            row.append(self.linesep.join(url_data.info))
        if self.has_part("valid"):
            row.append(url_data.valid)
        if self.has_part("url"):
            row.append(url_data.url)
        if self.has_part("line"):
            row.append(url_data.line)
        if self.has_part("column"):
            row.append(url_data.column)
        if self.has_part("name"):
            row.append(url_data.name)
        if self.has_part("dltime"):
            row.append(url_data.dltime)
        if self.has_part("dlsize"):
            row.append(url_data.size)
        if self.has_part("checktime"):
            row.append(url_data.checktime)
        if self.has_part("cached"):
            row.append(0)
        if self.has_part("level"):
            row.append(url_data.level)
        if self.has_part("modified"):
            row.append(self.format_modified(url_data.modified))
        self.writerow(map(strformat.unicode_safe, row))
        self.flush()

    def writerow (self, row):
        """Write one row in CSV format."""
        self.writer.writerow([s.encode("utf-8", self.codec_errors) for s in row])
        # Fetch UTF-8 output from the queue ...
        data = self.queue.getvalue()
        data = data.decode("utf-8")
        # ... and write to the target stream
        self.write(data)
        # empty queue
        self.queue.truncate(0)

    def end_output (self, **kwargs):
        """Write end of checking info as csv comment."""
        if self.has_part("outro"):
            self.write_outro()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = customxml
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
An XML logger.
"""
from . import xmllog
from .. import strformat


class CustomXMLLogger (xmllog._XMLLogger):
    """
    XML custom output for easy post-processing.
    """

    LoggerName = "xml"

    LoggerArgs = {
        "filename": "linkchecker-out.xml",
    }

    def start_output (self):
        """
        Write start of checking info as xml comment.
        """
        super(CustomXMLLogger, self).start_output()
        self.xml_start_output()
        attrs = {"created": strformat.strtime(self.starttime)}
        self.xml_starttag(u'linkchecker', attrs)
        self.flush()

    def log_url (self, url_data):
        """
        Log URL data in custom XML format.
        """
        self.xml_starttag(u'urldata')
        if self.has_part('url'):
            self.xml_tag(u"url", unicode(url_data.base_url))
        if url_data.name and self.has_part('name'):
            self.xml_tag(u"name", unicode(url_data.name))
        if url_data.parent_url and self.has_part('parenturl'):
            attrs = {
                u'line': u"%d" % url_data.line,
                u'column': u"%d" % url_data.column,
            }
            self.xml_tag(u"parent", unicode(url_data.parent_url),
                         attrs=attrs)
        if url_data.base_ref and self.has_part('base'):
            self.xml_tag(u"baseref", unicode(url_data.base_ref))
        if self.has_part("realurl"):
            self.xml_tag(u"realurl", unicode(url_data.url))
        if self.has_part("extern"):
            self.xml_tag(u"extern", u"%d" % (1 if url_data.extern else 0))
        if url_data.dltime >= 0 and self.has_part("dltime"):
            self.xml_tag(u"dltime", u"%f" % url_data.dltime)
        if url_data.size >= 0 and self.has_part("dlsize"):
            self.xml_tag(u"dlsize", u"%d" % url_data.size)
        if url_data.checktime and self.has_part("checktime"):
            self.xml_tag(u"checktime", u"%f" % url_data.checktime)
        if self.has_part("level"):
            self.xml_tag(u"level", u"%d" % url_data.level)
        if url_data.info and self.has_part('info'):
            self.xml_starttag(u"infos")
            for info in url_data.info:
                self.xml_tag(u"info", info)
            self.xml_endtag(u"infos")
        if url_data.modified and self.has_part('modified'):
            self.xml_tag(u"modified", self.format_modified(url_data.modified))
        if url_data.warnings and self.has_part('warning'):
            self.xml_starttag(u"warnings")
            for tag, data in url_data.warnings:
                attrs = {}
                if tag:
                    attrs["tag"] = tag
                self.xml_tag(u"warning", data, attrs)
            self.xml_endtag(u"warnings")
        if self.has_part("result"):
            attrs = {}
            if url_data.result:
                attrs["result"] = url_data.result
            self.xml_tag(u"valid", u"%d" % (1 if url_data.valid else 0), attrs)
        self.xml_endtag(u'urldata')
        self.flush()

    def end_output (self, **kwargs):
        """
        Write XML end tag.
        """
        self.xml_endtag(u"linkchecker")
        self.xml_end_output()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = dot
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A DOT graph format logger. The specification has been taken from
http://www.graphviz.org/doc/info/lang.html
"""
from .graph import _GraphLogger


class DOTLogger (_GraphLogger):
    """
    Generates .dot sitemap graphs. Use graphviz to see the sitemap graph.
    """

    LoggerName = "dot"

    LoggerArgs = {
        "filename": "linkchecker-out.dot",
        "encoding": "ascii",
    }

    def start_output (self):
        """Write start of checking info as DOT comment."""
        super(DOTLogger, self).start_output()
        if self.has_part("intro"):
            self.write_intro()
            self.writeln()
        self.writeln(u"digraph G {")
        self.writeln(u"  graph [")
        self.writeln(u"    charset=\"%s\"," % self.get_charset_encoding())
        self.writeln(u"  ];")
        self.flush()

    def comment (self, s, **args):
        """Write DOT comment."""
        self.write(u"// ")
        self.writeln(s=s, **args)

    def log_url (self, url_data):
        """Write one node."""
        node = self.get_node(url_data)
        if node is not None:
            self.writeln(u'  "%s" [' % dotquote(node["label"]))
            if self.has_part("realurl"):
                self.writeln(u'    href="%s",' % dotquote(node["url"]))
            if node["dltime"] >= 0 and self.has_part("dltime"):
                self.writeln(u"    dltime=%d," % node["dltime"])
            if node["size"] >= 0 and self.has_part("dlsize"):
                self.writeln(u"    size=%d," % node["size"])
            if node["checktime"] and self.has_part("checktime"):
                self.writeln(u"    checktime=%d," % node["checktime"])
            if self.has_part("extern"):
                self.writeln(u"    extern=%d," % node["extern"])
            self.writeln(u"  ];")

    def write_edge (self, node):
        """Write edge from parent to node."""
        source = dotquote(self.nodes[node["parent_url"]]["label"])
        target = dotquote(node["label"])
        self.writeln(u'  "%s" -> "%s" [' % (source, target))
        self.writeln(u'    label="%s",' % dotquote(node["edge"]))
        if self.has_part("result"):
            self.writeln(u"    valid=%d," % node["valid"])
        self.writeln(u"  ];")

    def end_graph (self):
        """Write end of graph marker."""
        self.writeln(u"}")


def dotquote (s):
    """Quote string for usage in DOT output format."""
    return s.replace('"', '\\"')

########NEW FILE########
__FILENAME__ = gml
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A gml logger.
"""
from .graph import _GraphLogger


class GMLLogger (_GraphLogger):
    """GML means Graph Modeling Language. Use a GML tool to see
    the sitemap graph."""

    LoggerName = 'gml'

    LoggerArgs = {
        "filename": "linkchecker-out.gml",
    }

    def start_output (self):
        """Write start of checking info as gml comment."""
        super(GMLLogger, self).start_output()
        if self.has_part("intro"):
            self.write_intro()
            self.writeln()
        self.writeln(u"graph [")
        self.writeln(u"  directed 1")
        self.flush()

    def comment (self, s, **args):
        """Write GML comment."""
        self.writeln(s=u'comment "%s"' % s, **args)

    def log_url (self, url_data):
        """Write one node."""
        node = self.get_node(url_data)
        if node:
            self.writeln(u"  node [")
            self.writeln(u"    id     %d" % node["id"])
            self.writeln(u'    label  "%s"' % node["label"])
            if self.has_part("realurl"):
                self.writeln(u'    url  "%s"' % node["url"])
            if node["dltime"] >= 0 and self.has_part("dltime"):
                self.writeln(u"    dltime %d" % node["dltime"])
            if node["size"] >= 0 and self.has_part("dlsize"):
                self.writeln(u"    size %d" % node["size"])
            if node["checktime"] and self.has_part("checktime"):
                self.writeln(u"    checktime %d" % node["checktime"])
            if self.has_part("extern"):
                self.writeln(u"    extern %d" % node["extern"])
            self.writeln(u"  ]")

    def write_edge (self, node):
        """Write one edge."""
        self.writeln(u"  edge [")
        self.writeln(u'    label  "%s"' % node["edge"])
        self.writeln(u"    source %d" % self.nodes[node["parent_url"]]["id"])
        self.writeln(u"    target %d" % node["id"])
        if self.has_part("result"):
            self.writeln(u"    valid  %d" % node["valid"])
        self.writeln(u"  ]")

    def end_graph (self):
        """Write end of graph marker."""
        self.writeln(u"]")

########NEW FILE########
__FILENAME__ = graph
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Base class for graph loggers.
"""
from . import _Logger
from ..decorators import notimplemented
import re


class _GraphLogger (_Logger):
    """Provide base method to get node data."""

    def __init__ (self, **kwargs):
        """Initialize graph node list and internal id counter."""
        args = self.get_args(kwargs)
        super(_GraphLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.nodes = {}
        self.nodeid = 0

    def log_filter_url(self, url_data, do_print):
        """Update accounting data and log all valid URLs regardless the
        do_print flag.
        """
        self.stats.log_url(url_data, do_print)
        # ignore the do_print flag and determine ourselves if we filter the url
        if url_data.valid:
            self.log_url(url_data)

    def get_node (self, url_data):
        """Return new node data or None if node already exists."""
        if not url_data.url:
            return None
        elif url_data.url in self.nodes:
            return None
        node = {
            "url": url_data.url,
            "parent_url": url_data.parent_url,
            "id": self.nodeid,
            "label": quote(url_data.title if url_data.title else url_data.name),
            "extern": 1 if url_data.extern else 0,
            "checktime": url_data.checktime,
            "size": url_data.size,
            "dltime": url_data.dltime,
            "edge": quote(url_data.name),
            "valid": 1 if url_data.valid else 0,
        }
        self.nodes[node["url"]] = node
        self.nodeid += 1
        return node

    def write_edges (self):
        """
        Write all edges we can find in the graph in a brute-force manner.
        """
        for node in self.nodes.values():
            if node["parent_url"] in self.nodes:
                self.write_edge(node)
        self.flush()

    @notimplemented
    def write_edge (self, node):
        """Write edge data for one node and its parent."""
        pass

    @notimplemented
    def end_graph (self):
        """Write end-of-graph marker."""
        pass

    def end_output (self, **kwargs):
        """Write edges and end of checking info as gml comment."""
        self.write_edges()
        self.end_graph()
        if self.has_part("outro"):
            self.write_outro()
        self.close_fileoutput()


_disallowed = re.compile(r"[^a-zA-Z0-9 '#(){}\-\[\]\.,;:\!\?]+")

def quote (s):
    """Replace disallowed characters in node or edge labels.
    Also remove whitespace from beginning or end of label."""
    return _disallowed.sub(" ", s).strip()

########NEW FILE########
__FILENAME__ = gxml
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A GraphXML logger.
"""

from .xmllog import _XMLLogger
from .graph import _GraphLogger


class GraphXMLLogger (_XMLLogger, _GraphLogger):
    """XML output mirroring the GML structure. Easy to parse with any XML
    tool."""

    LoggerName = 'gxml'

    LoggerArgs =  {
        "filename": "linkchecker-out.gxml",
    }

    def __init__ (self, **kwargs):
        """Initialize graph node list and internal id counter."""
        args = self.get_args(kwargs)
        super(GraphXMLLogger, self).__init__(**args)
        self.nodes = {}
        self.nodeid = 0

    def start_output (self):
        """Write start of checking info as xml comment."""
        super(GraphXMLLogger, self).start_output()
        self.xml_start_output()
        self.xml_starttag(u'GraphXML')
        self.xml_starttag(u'graph', attrs={u"isDirected": u"true"})
        self.flush()

    def log_url (self, url_data):
        """Write one node and all possible edges."""
        node = self.get_node(url_data)
        if node:
            self.xml_starttag(u'node', attrs={u"name": u"%d" % node["id"]})
            self.xml_tag(u"label", node["label"])
            if self.has_part("realurl"):
                self.xml_tag(u"url", node["url"])
            self.xml_starttag(u"data")
            if node["dltime"] >= 0 and self.has_part("dltime"):
                self.xml_tag(u"dltime", u"%f" % node["dltime"])
            if node["size"] >= 0 and self.has_part("dlsize"):
                self.xml_tag(u"size", u"%d" % node["size"])
            if node["checktime"] and self.has_part("checktime"):
                self.xml_tag(u"checktime", u"%f" % node["checktime"])
            if self.has_part("extern"):
                self.xml_tag(u"extern", u"%d" % node["extern"])
            self.xml_endtag(u"data")
            self.xml_endtag(u"node")

    def write_edge (self, node):
        """Write one edge."""
        attrs = {
            u"source": u"%d" % self.nodes[node["parent_url"]]["id"],
            u"target": u"%d" % node["id"],
        }
        self.xml_starttag(u"edge", attrs=attrs)
        self.xml_tag(u"label", node["label"])
        self.xml_starttag(u"data")
        if self.has_part("result"):
            self.xml_tag(u"valid", u"%d" % node["valid"])
        self.xml_endtag(u"data")
        self.xml_endtag(u"edge")

    def end_output (self, **kwargs):
        """Finish graph output, and print end of checking info as xml
        comment."""
        self.xml_endtag(u"graph")
        self.xml_endtag(u"GraphXML")
        self.xml_end_output()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = html
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A HTML logger.
"""
import time
import cgi
import os
from . import _Logger
from .. import strformat, configuration


# ss=1 enables show source
validate_html = "http://validator.w3.org/check?ss=1&amp;uri=%(uri)s"
# options are the default
validate_css = "http://jigsaw.w3.org/css-validator/validator?" \
               "uri=%(uri)s&amp;warning=1&amp;profile=css2&amp;usermedium=all"

HTML_HEADER = """<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=%(encoding)s"/>
<title>%(title)s</title>
<style type="text/css">
<!--
 h2 { font-family: Verdana,sans-serif; font-size: 22pt; font-weight: bold; }
 body { font-family: Arial,sans-serif; font-size: 11pt; background-color: %(body)s; }
 td { font-family: Arial,sans-serif; font-size: 11pt; }
 code { font-family: Courier; }
 a:link {color: %(link)s;}
 a:visited {color: %(vlink)s;}
 a:active {color: %(alink)s;}
 a:hover { color: #34a4ef; }
 table { border-collapse:collapse; }
 table, th, td { border: 1px solid black; padding: 2px; }
 td.url { background-color: %(url)s }
 td.valid { background-color: %(valid)s }
 td.error { background-color: %(error)s }
 td.warning { background-color: %(warning)s }
-->
</style>
</head>
<body>
"""


class HtmlLogger (_Logger):
    """Logger with HTML output."""

    LoggerName = 'html'

    LoggerArgs =  {
        "filename":        "linkchecker-out.html",
        'colorbackground': '#fff7e5',
        'colorurl':        '#dcd5cf',
        'colorborder':     '#000000',
        'colorlink':       '#191c83',
        'colorwarning':    '#e0954e',
        'colorerror':      '#db4930',
        'colorok':         '#3ba557',
    }

    def __init__ (self, **kwargs):
        """Initialize default HTML color values."""
        args = self.get_args(kwargs)
        super(HtmlLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.colorbackground = args['colorbackground']
        self.colorurl = args['colorurl']
        self.colorborder = args['colorborder']
        self.colorlink = args['colorlink']
        self.colorwarning = args['colorwarning']
        self.colorerror = args['colorerror']
        self.colorok = args['colorok']

    def part (self, name):
        """Return non-space-breakable part name."""
        return super(HtmlLogger, self).part(name).replace(" ", "&nbsp;")

    def comment (self, s, **args):
        """Write HTML comment."""
        self.write(u"<!-- ")
        self.write(s, **args)
        self.write(u" -->")

    def start_output (self):
        """Write start of checking info."""
        super(HtmlLogger, self).start_output()
        header = {
            "encoding": self.get_charset_encoding(),
            "title": configuration.App,
            "body": self.colorbackground,
            "link": self.colorlink,
            "vlink": self.colorlink,
            "alink": self.colorlink,
            "url": self.colorurl,
            "error": self.colorerror,
            "valid": self.colorok,
            "warning": self.colorwarning,
        }
        self.write(HTML_HEADER % header)
        self.comment("Generated by %s" % configuration.App)
        if self.has_part('intro'):
            self.write(u"<h2>"+configuration.App+
                       "</h2><br/><blockquote>"+
                       configuration.Freeware+"<br/><br/>"+
                       (_("Start checking at %s") %
                       strformat.strtime(self.starttime))+
                       os.linesep+"<br/>")
            self.check_date()
        self.flush()

    def log_url (self, url_data):
        """Write url checking info as HTML."""
        self.write_table_start()
        if self.has_part("url"):
            self.write_url(url_data)
        if url_data.name and self.has_part("name"):
            self.write_name(url_data)
        if url_data.parent_url and self.has_part("parenturl"):
            self.write_parent(url_data)
        if url_data.base_ref and self.has_part("base"):
            self.write_base(url_data)
        if url_data.url and self.has_part("realurl"):
            self.write_real(url_data)
        if url_data.dltime >= 0 and self.has_part("dltime"):
            self.write_dltime(url_data)
        if url_data.size >= 0 and self.has_part("dlsize"):
            self.write_size(url_data)
        if url_data.checktime and self.has_part("checktime"):
            self.write_checktime(url_data)
        if url_data.info and self.has_part("info"):
            self.write_info(url_data)
        if url_data.modified and self.has_part("modified"):
            self.write_modified(url_data)
        if url_data.warnings and self.has_part("warning"):
            self.write_warning(url_data)
        if self.has_part("result"):
            self.write_result(url_data)
        self.write_table_end()
        self.flush()

    def write_table_start (self):
        """Start html table."""
        self.writeln(u'<br/><br/><table>')

    def write_table_end (self):
        """End html table."""
        self.write(u'</table><br/>')

    def write_id (self):
        """Write ID for current URL."""
        self.writeln(u"<tr>")
        self.writeln(u'<td>%s</td>' % self.part("id"))
        self.write(u"<td>%d</td></tr>" % self.stats.number)

    def write_url (self, url_data):
        """Write url_data.base_url."""
        self.writeln(u"<tr>")
        self.writeln(u'<td class="url">%s</td>' % self.part("url"))
        self.write(u'<td class="url">')
        self.write(u"`%s'" % cgi.escape(url_data.base_url))
        self.writeln(u"</td></tr>")

    def write_name (self, url_data):
        """Write url_data.name."""
        args = (self.part("name"), cgi.escape(url_data.name))
        self.writeln(u"<tr><td>%s</td><td>`%s'</td></tr>" % args)

    def write_parent (self, url_data):
        """Write url_data.parent_url."""
        self.write(u"<tr><td>"+self.part("parenturl")+
                   u'</td><td><a target="top" href="'+
                   url_data.parent_url+u'">'+
                   cgi.escape(url_data.parent_url)+u"</a>")
        if url_data.line > 0:
            self.write(_(", line %d") % url_data.line)
        if url_data.column > 0:
            self.write(_(", col %d") % url_data.column)
        if url_data.page > 0:
            self.write(_(", page %d") % url_data.page)
        if not url_data.valid:
            # on errors show HTML and CSS validation for parent url
            vhtml = validate_html % {'uri': url_data.parent_url}
            vcss = validate_css % {'uri': url_data.parent_url}
            self.writeln()
            self.writeln(u'(<a href="'+vhtml+u'">HTML</a>)')
            self.write(u'(<a href="'+vcss+u'">CSS</a>)')
        self.writeln(u"</td></tr>")

    def write_base (self, url_data):
        """Write url_data.base_ref."""
        self.writeln(u"<tr><td>"+self.part("base")+u"</td><td>"+
                     cgi.escape(url_data.base_ref)+u"</td></tr>")

    def write_real (self, url_data):
        """Write url_data.url."""
        self.writeln("<tr><td>"+self.part("realurl")+u"</td><td>"+
                     u'<a target="top" href="'+url_data.url+
                     u'">'+cgi.escape(url_data.url)+u"</a></td></tr>")

    def write_dltime (self, url_data):
        """Write url_data.dltime."""
        self.writeln(u"<tr><td>"+self.part("dltime")+u"</td><td>"+
                     (_("%.3f seconds") % url_data.dltime)+
                     u"</td></tr>")

    def write_size (self, url_data):
        """Write url_data.size."""
        self.writeln(u"<tr><td>"+self.part("dlsize")+u"</td><td>"+
                     strformat.strsize(url_data.size)+
                     u"</td></tr>")

    def write_checktime (self, url_data):
        """Write url_data.checktime."""
        self.writeln(u"<tr><td>"+self.part("checktime")+u"</td><td>"+
                     (_("%.3f seconds") % url_data.checktime)+u"</td></tr>")

    def write_info (self, url_data):
        """Write url_data.info."""
        sep = u"<br/>"+os.linesep
        text = sep.join(cgi.escape(x) for x in url_data.info)
        self.writeln(u'<tr><td valign="top">' + self.part("info")+
               u"</td><td>"+text+u"</td></tr>")

    def write_modified(self, url_data):
        """Write url_data.modified."""
        text = cgi.escape(self.format_modified(url_data.modified))
        self.writeln(u'<tr><td valign="top">' + self.part("modified") +
            u"</td><td>"+text+u"</td></tr>")

    def write_warning (self, url_data):
        """Write url_data.warnings."""
        sep = u"<br/>"+os.linesep
        text = sep.join(cgi.escape(x[1]) for x in url_data.warnings)
        self.writeln(u'<tr><td class="warning" '+
                     u'valign="top">' + self.part("warning") +
                     u'</td><td class="warning">' + text + u"</td></tr>")

    def write_result (self, url_data):
        """Write url_data.result."""
        if url_data.valid:
            self.write(u'<tr><td class="valid">')
            self.write(self.part("result"))
            self.write(u'</td><td class="valid">')
            self.write(cgi.escape(_("Valid")))
        else:
            self.write(u'<tr><td class="error">')
            self.write(self.part("result"))
            self.write(u'</td><td class="error">')
            self.write(cgi.escape(_("Error")))
        if url_data.result:
            self.write(u": "+cgi.escape(url_data.result))
        self.writeln(u"</td></tr>")

    def write_stats (self):
        """Write check statistic infos."""
        self.writeln(u'<br/><i>%s</i><br/>' % _("Statistics"))
        if self.stats.number > 0:
            self.writeln(_(
              "Content types: %(image)d image, %(text)d text, %(video)d video, "
              "%(audio)d audio, %(application)d application, %(mail)d mail"
              " and %(other)d other.") % self.stats.link_types)
            self.writeln(u"<br/>")
            self.writeln(_("URL lengths: min=%(min)d, max=%(max)d, avg=%(avg)d.") %
                         dict(min=self.stats.min_url_length,
                         max=self.stats.max_url_length,
                         avg=self.stats.avg_url_length))
        else:
            self.writeln(_("No statistics available since no URLs were checked."))
        self.writeln(u"<br/>")

    def write_outro (self):
        """Write end of check message."""
        self.writeln(u"<br/>")
        self.write(_("That's it.")+" ")
        if self.stats.number >= 0:
            self.write(_n("%d link checked.", "%d links checked.",
                       self.stats.number) % self.stats.number)
            self.write(u" ")
        self.write(_n("%d warning found", "%d warnings found",
             self.stats.warnings_printed) % self.stats.warnings_printed)
        if self.stats.warnings != self.stats.warnings_printed:
            self.write(_(" (%d ignored or duplicates not printed)") %
                (self.stats.warnings - self.stats.warnings_printed))
        self.write(u". ")
        self.write(_n("%d error found", "%d errors found",
             self.stats.errors_printed) % self.stats.errors_printed)
        if self.stats.errors != self.stats.errors_printed:
            self.write(_(" (%d duplicates not printed)") %
                (self.stats.errors - self.stats.errors_printed))
        self.writeln(u".")
        self.writeln(u"<br/>")
        num = self.stats.internal_errors
        if num:
            self.write(_n("There was %(num)d internal error.",
                "There were %(num)d internal errors.", num) % {"num": num})
            self.writeln(u"<br/>")
        self.stoptime = time.time()
        duration = self.stoptime - self.starttime
        self.writeln(_("Stopped checking at %(time)s (%(duration)s)") %
             {"time": strformat.strtime(self.stoptime),
              "duration": strformat.strduration_long(duration)})
        self.writeln(u'</blockquote><br/><hr><small>'+
                     configuration.HtmlAppInfo+u"<br/>")
        self.writeln(_("Get the newest version at %s") %
           (u'<a href="'+configuration.Url+u'" target="_top">'+
            configuration.Url+u"</a>.<br/>"))
        self.writeln(_("Write comments and bugs to %s") %
           (u'<a href="'+configuration.SupportUrl+u'">'+
            configuration.SupportUrl+u"</a>.<br/>"))
        self.writeln(_("Support this project at %s") %
           (u'<a href="'+configuration.DonateUrl+u'">'+
            configuration.DonateUrl+u"</a>."))
        self.writeln(u"</small></body></html>")

    def end_output (self, **kwargs):
        """Write end of checking info as HTML."""
        if self.has_part("stats"):
            self.write_stats()
        if self.has_part("outro"):
            self.write_outro()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = none
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A dummy logger.
"""
from . import _Logger


class NoneLogger (_Logger):
    """
    Dummy logger printing nothing.
    """

    LoggerName = 'none'

    def comment (self, s, **args):
        """
        Do nothing.
        """
        pass

    def start_output (self):
        """
        Do nothing.
        """
        pass

    def log_url (self, url_data):
        """Do nothing."""
        pass

    def end_output (self, **kwargs):
        """
        Do nothing.
        """
        pass

########NEW FILE########
__FILENAME__ = sitemapxml
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A sitemap XML logger.
"""
from . import xmllog
from .. import log, LOG_CHECK

ChangeFreqs = (
    'always',
    'hourly',
    'daily',
    'weekly',
    'monthly',
    'yearly',
    'never',
)

HTTP_SCHEMES = (u'http:', u'https:')
HTML_TYPES = ('text/html', "application/xhtml+xml")

class SitemapXmlLogger (xmllog._XMLLogger):
    """Sitemap XML output according to http://www.sitemaps.org/protocol.html
    """

    LoggerName = 'sitemap'

    LoggerArgs = {
        "filename": "linkchecker-out.sitemap.xml",
        "encoding": "utf-8",
    }

    def __init__ (self, **kwargs):
        """Initialize graph node list and internal id counter."""
        args = self.get_args(kwargs)
        super(SitemapXmlLogger, self).__init__(**args)
        # All URLs must have the given prefix, which is determined
        # by the first logged URL.
        self.prefix = None
        # If first URL does not have a valid HTTP scheme, disable this
        # logger
        self.disabled = False
        if 'frequency' in args:
            if args['frequency'] not in ChangeFreqs:
                raise ValueError("Invalid change frequency %r" % args['frequency'])
            self.frequency = args['frequency']
        else:
            self.frequency = 'daily'
        self.priority = None
        if 'priority' in args:
            self.priority = float(args['priority'])

    def start_output (self):
        """Write start of checking info as xml comment."""
        super(SitemapXmlLogger, self).start_output()
        self.xml_start_output()
        attrs = {u"xmlns": u"http://www.sitemaps.org/schemas/sitemap/0.9"}
        self.xml_starttag(u'urlset', attrs)
        self.flush()

    def log_filter_url(self, url_data, do_print):
        """Update accounting data and determine if URL should be included
        in the sitemap.
        """
        self.stats.log_url(url_data, do_print)
        if self.disabled:
            return
        # initialize prefix and priority
        if self.prefix is None:
            if not url_data.url.startswith(HTTP_SCHEMES):
                log.warn(LOG_CHECK, "Sitemap URL %r does not start with http: or https:.", url_data.url)
                self.disabled = True
                return
            self.prefix = url_data.url
            # first URL (ie. the homepage) gets priority 1.0 per default
            priority = 1.0
        elif url_data.url == self.prefix:
            return
        else:
            # all other pages get priority 0.5 per default
            priority = 0.5
        if self.priority is not None:
            priority = self.priority
         # ignore the do_print flag and determine ourselves if we filter the url
        if (url_data.valid
            and url_data.url.startswith(HTTP_SCHEMES)
            and url_data.url.startswith(self.prefix)
            and url_data.content_type in HTML_TYPES):
            self.log_url(url_data, priority=priority)

    def log_url (self, url_data, priority=None):
        """Log URL data in sitemap format."""
        self.xml_starttag(u'url')
        self.xml_tag(u'loc', url_data.url)
        if url_data.modified:
            self.xml_tag(u'lastmod', self.format_modified(url_data.modified, sep="T"))
        self.xml_tag(u'changefreq', self.frequency)
        self.xml_tag(u'priority', "%.2f" % priority)
        self.xml_endtag(u'url')
        self.flush()

    def end_output (self, **kwargs):
        """Write XML end tag."""
        self.xml_endtag(u"urlset")
        self.xml_end_output()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = sql
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
A SQL logger.
"""

import os
from . import _Logger
from .. import url as urlutil


def sqlify (s):
    """
    Escape special SQL chars and strings.
    """
    if not s:
        return "NULL"
    return "'%s'" % s.replace("'", "''").replace(os.linesep, r"\n")


def intify (s):
    """
    Coerce a truth value to 0/1.

    @param s: an object (usually a string)
    @type s: object
    @return: 1 if object truth value is True, else 0
    @rtype: number
    """
    if s:
        return 1
    return 0


class SQLLogger (_Logger):
    """
    SQL output, should work with any SQL database (not tested).
    """

    LoggerName = 'sql'

    LoggerArgs = {
        "filename": "linkchecker-out.sql",
        'separator': ';',
        'dbname': 'linksdb',
    }

    def __init__ (self, **kwargs):
        """Initialize database access data."""
        args = self.get_args(kwargs)
        super(SQLLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.dbname = args['dbname']
        self.separator = args['separator']

    def comment (self, s, **args):
        """
        Write SQL comment.
        """
        self.write(u"-- ")
        self.writeln(s=s, **args)

    def start_output (self):
        """
        Write start of checking info as sql comment.
        """
        super(SQLLogger, self).start_output()
        if self.has_part("intro"):
            self.write_intro()
            self.writeln()
            self.flush()

    def log_url (self, url_data):
        """
        Store url check info into the database.
        """
        self.writeln(u"insert into %(table)s(urlname,"
              "parentname,baseref,valid,result,warning,info,url,line,col,"
              "name,checktime,dltime,size,cached,level,modified) values ("
              "%(base_url)s,"
              "%(url_parent)s,"
              "%(base_ref)s,"
              "%(valid)d,"
              "%(result)s,"
              "%(warning)s,"
              "%(info)s,"
              "%(url)s,"
              "%(line)d,"
              "%(column)d,"
              "%(name)s,"
              "%(checktime)d,"
              "%(dltime)d,"
              "%(size)d,"
              "%(cached)d,"
              "%(level)d,"
              "%(modified)s"
              ")%(separator)s" %
              {'table': self.dbname,
               'base_url': sqlify(url_data.base_url),
               'url_parent': sqlify((url_data.parent_url)),
               'base_ref': sqlify((url_data.base_ref)),
               'valid': intify(url_data.valid),
               'result': sqlify(url_data.result),
               'warning': sqlify(os.linesep.join(x[1] for x in url_data.warnings)),
               'info': sqlify(os.linesep.join(url_data.info)),
               'url': sqlify(urlutil.url_quote(url_data.url)),
               'line': url_data.line,
               'column': url_data.column,
               'name': sqlify(url_data.name),
               'checktime': url_data.checktime,
               'dltime': url_data.dltime,
               'size': url_data.size,
               'cached': 0,
               'separator': self.separator,
               "level": url_data.level,
               "modified": sqlify(self.format_modified(url_data.modified)),
              })
        self.flush()

    def end_output (self, **kwargs):
        """
        Write end of checking info as sql comment.
        """
        if self.has_part("outro"):
            self.write_outro()
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = text
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
The default text logger.
"""
import time
from . import _Logger
from .. import ansicolor, strformat, configuration, i18n


class TextLogger (_Logger):
    """
    A text logger, colorizing the output if possible.

    Informal text output format spec:
    Output consists of a set of URL logs separated by one or more
    blank lines.
    A URL log consists of two or more lines. Each line consists of
    keyword and data, separated by whitespace.
    Unknown keywords will be ignored.
    """

    LoggerName = 'text'

    LoggerArgs = {
        "filename": "linkchecker-out.txt",
        'colorparent':  "default",
        'colorurl':     "default",
        'colorname':    "default",
        'colorreal':    "cyan",
        'colorbase':    "purple",
        'colorvalid':   "bold;green",
        'colorinvalid': "bold;red",
        'colorinfo':    "default",
        'colorwarning': "bold;yellow",
        'colordltime':  "default",
        'colordlsize':  "default",
        'colorreset':   "default",
    }

    def __init__ (self, **kwargs):
        """Initialize error counter and optional file output."""
        args = self.get_args(kwargs)
        super(TextLogger, self).__init__(**args)
        self.output_encoding = args.get("encoding", i18n.default_encoding)
        self.init_fileoutput(args)
        self.colorparent = args.get('colorparent', 'default')
        self.colorurl = args.get('colorurl', 'default')
        self.colorname = args.get('colorname', 'default')
        self.colorreal = args.get('colorreal', 'default')
        self.colorbase = args.get('colorbase', 'default')
        self.colorvalid = args.get('colorvalid', 'default')
        self.colorinvalid = args.get('colorinvalid', 'default')
        self.colorinfo = args.get('colorinfo', 'default')
        self.colorwarning = args.get('colorwarning', 'default')
        self.colordltime = args.get('colordltime', 'default')
        self.colordlsize = args.get('colordlsize', 'default')
        self.colorreset = args.get('colorreset', 'default')

    def init_fileoutput (self, args):
        """Colorize file output if possible."""
        super(TextLogger, self).init_fileoutput(args)
        if self.fd is not None:
            self.fd = ansicolor.Colorizer(self.fd)

    def start_fileoutput (self):
        """Needed to make file descriptor color aware."""
        init_color = self.fd is None
        super(TextLogger, self).start_fileoutput()
        if init_color:
            self.fd = ansicolor.Colorizer(self.fd)

    def start_output (self):
        """Write generic start checking info."""
        super(TextLogger, self).start_output()
        if self.has_part('intro'):
            self.write_intro()
        self.flush()

    def write_intro (self):
        """Log introduction text."""
        self.writeln(configuration.AppInfo)
        self.writeln(configuration.Freeware)
        self.writeln(_("Get the newest version at %(url)s") %
                     {'url': configuration.Url})
        self.writeln(_("Write comments and bugs to %(url)s") %
                     {'url': configuration.SupportUrl})
        self.writeln(_("Support this project at %(url)s") %
                     {'url': configuration.DonateUrl})
        self.check_date()
        self.writeln()
        self.writeln(_("Start checking at %s") %
                     strformat.strtime(self.starttime))

    def log_url (self, url_data):
        """Write url checking info."""
        self.writeln()
        if self.has_part('url'):
            self.write_url(url_data)
        if url_data.name and self.has_part('name'):
            self.write_name(url_data)
        if url_data.parent_url and self.has_part('parenturl'):
            self.write_parent(url_data)
        if url_data.base_ref and self.has_part('base'):
            self.write_base(url_data)
        if url_data.url and self.has_part('realurl'):
            self.write_real(url_data)
        if url_data.checktime and self.has_part('checktime'):
            self.write_checktime(url_data)
        if url_data.dltime >= 0 and self.has_part('dltime'):
            self.write_dltime(url_data)
        if url_data.size >= 0 and self.has_part('dlsize'):
            self.write_size(url_data)
        if url_data.info and self.has_part('info'):
            self.write_info(url_data)
        if url_data.modified and self.has_part('modified'):
            self.write_modified(url_data)
        if url_data.warnings and self.has_part('warning'):
            self.write_warning(url_data)
        if self.has_part('result'):
            self.write_result(url_data)
        self.flush()

    def write_id (self):
        """Write unique ID of url_data."""
        self.writeln()
        self.write(self.part('id') + self.spaces('id'))
        self.writeln(u"%d" % self.stats.number, color=self.colorinfo)

    def write_url (self, url_data):
        """Write url_data.base_url."""
        self.write(self.part('url') + self.spaces('url'))
        txt = strformat.strline(url_data.base_url)
        self.writeln(txt, color=self.colorurl)

    def write_name (self, url_data):
        """Write url_data.name."""
        self.write(self.part("name") + self.spaces("name"))
        self.writeln(strformat.strline(url_data.name), color=self.colorname)

    def write_parent (self, url_data):
        """Write url_data.parent_url."""
        self.write(self.part('parenturl') + self.spaces("parenturl"))
        txt = url_data.parent_url
        if url_data.line > 0:
            txt += _(", line %d") % url_data.line
        if url_data.column > 0:
            txt += _(", col %d") % url_data.column
        if url_data.page > 0:
            txt += _(", page %d") % url_data.page
        self.writeln(txt, color=self.colorparent)

    def write_base (self, url_data):
        """Write url_data.base_ref."""
        self.write(self.part("base") + self.spaces("base"))
        self.writeln(url_data.base_ref, color=self.colorbase)

    def write_real (self, url_data):
        """Write url_data.url."""
        self.write(self.part("realurl") + self.spaces("realurl"))
        self.writeln(unicode(url_data.url), color=self.colorreal)

    def write_dltime (self, url_data):
        """Write url_data.dltime."""
        self.write(self.part("dltime") + self.spaces("dltime"))
        self.writeln(_("%.3f seconds") % url_data.dltime,
                     color=self.colordltime)

    def write_size (self, url_data):
        """Write url_data.size."""
        self.write(self.part("dlsize") + self.spaces("dlsize"))
        self.writeln(strformat.strsize(url_data.size),
                     color=self.colordlsize)

    def write_checktime (self, url_data):
        """Write url_data.checktime."""
        self.write(self.part("checktime") + self.spaces("checktime"))
        self.writeln(_("%.3f seconds") % url_data.checktime,
                     color=self.colordltime)

    def write_info (self, url_data):
        """Write url_data.info."""
        self.write(self.part("info") + self.spaces("info"))
        self.writeln(self.wrap(url_data.info, 65), color=self.colorinfo)

    def write_modified(self, url_data):
        """Write url_data.modified."""
        self.write(self.part("modified") + self.spaces("modified"))
        self.writeln(self.format_modified(url_data.modified))

    def write_warning (self, url_data):
        """Write url_data.warning."""
        self.write(self.part("warning") + self.spaces("warning"))
        warning_msgs = [u"[%s] %s" % x for x in url_data.warnings]
        self.writeln(self.wrap(warning_msgs, 65), color=self.colorwarning)

    def write_result (self, url_data):
        """Write url_data.result."""
        self.write(self.part("result") + self.spaces("result"))
        if url_data.valid:
            color = self.colorvalid
            self.write(_("Valid"), color=color)
        else:
            color = self.colorinvalid
            self.write(_("Error"), color=color)
        if url_data.result:
            self.write(u": " + url_data.result, color=color)
        self.writeln()

    def write_outro (self, interrupt=False):
        """Write end of checking message."""
        self.writeln()
        if interrupt:
            self.writeln(_("The check has been interrupted; results are not complete."))
        self.write(_("That's it.") + " ")
        self.write(_n("%d link", "%d links",
                      self.stats.number) % self.stats.number)
        self.write(u" ")
        if self.stats.num_urls is not None:
            self.write(_n("in %d URL", "in %d URLs",
                          self.stats.num_urls) % self.stats.num_urls)
        self.write(u" checked. ")
        warning_text = _n("%d warning found", "%d warnings found",
             self.stats.warnings_printed) % self.stats.warnings_printed
        if self.stats.warnings_printed:
            warning_color = self.colorwarning
        else:
            warning_color = self.colorinfo
        self.write(warning_text, color=warning_color)
        if self.stats.warnings != self.stats.warnings_printed:
            self.write(_(" (%d ignored or duplicates not printed)") %
                (self.stats.warnings - self.stats.warnings_printed))
        self.write(u". ")
        error_text = _n("%d error found", "%d errors found",
             self.stats.errors_printed) % self.stats.errors_printed
        if self.stats.errors_printed:
            error_color = self.colorinvalid
        else:
            error_color = self.colorvalid
        self.write(error_text, color=error_color)
        if self.stats.errors != self.stats.errors_printed:
            self.write(_(" (%d duplicates not printed)") %
                (self.stats.errors - self.stats.errors_printed))
        self.writeln(u".")
        num = self.stats.internal_errors
        if num:
            self.writeln(_n("There was %(num)d internal error.",
                "There were %(num)d internal errors.", num) % {"num": num})
        self.stoptime = time.time()
        duration = self.stoptime - self.starttime
        self.writeln(_("Stopped checking at %(time)s (%(duration)s)") %
             {"time": strformat.strtime(self.stoptime),
              "duration": strformat.strduration_long(duration)})

    def write_stats (self):
        """Write check statistic info."""
        self.writeln()
        self.writeln(_("Statistics:"))
        if self.stats.downloaded_bytes is not None:
            self.writeln(_("Downloaded: %s.") % strformat.strsize(self.stats.downloaded_bytes))
        if self.stats.number > 0:
            self.writeln(_(
              "Content types: %(image)d image, %(text)d text, %(video)d video, "
              "%(audio)d audio, %(application)d application, %(mail)d mail"
              " and %(other)d other.") % self.stats.link_types)
            self.writeln(_("URL lengths: min=%(min)d, max=%(max)d, avg=%(avg)d.") %
                         dict(min=self.stats.min_url_length,
                         max=self.stats.max_url_length,
                         avg=self.stats.avg_url_length))
        else:
            self.writeln(_("No statistics available since no URLs were checked."))

    def end_output (self, **kwargs):
        """Write end of output info, and flush all output buffers."""
        self.stats.downloaded_bytes = kwargs.get("downloaded_bytes")
        self.stats.num_urls = kwargs.get("num_urls")
        if self.has_part('stats'):
            self.write_stats()
        if self.has_part('outro'):
            self.write_outro(interrupt=kwargs.get("interrupt"))
        self.close_fileoutput()

########NEW FILE########
__FILENAME__ = xmllog
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Base class for XML loggers.
"""

import xml.sax.saxutils
from . import _Logger


xmlattr_entities = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
}


def xmlquote (s):
    """
    Quote characters for XML.
    """
    return xml.sax.saxutils.escape(s)


def xmlquoteattr (s):
    """
    Quote XML attribute, ready for inclusion with double quotes.
    """
    return xml.sax.saxutils.escape(s, xmlattr_entities)


class _XMLLogger (_Logger):
    """Base class for XML output; easy to parse with any XML tool."""

    def __init__ (self, **kwargs):
        """ Initialize graph node list and internal id counter. """
        args = self.get_args(kwargs)
        super(_XMLLogger, self).__init__(**args)
        self.init_fileoutput(args)
        self.indent = u"  "
        self.level = 0

    def comment (self, s, **args):
        """
        Write XML comment.
        """
        self.write(u"<!-- ")
        self.write(s, **args)
        self.writeln(u" -->")

    def xml_start_output (self):
        """
        Write start of checking info as xml comment.
        """
        self.writeln(u'<?xml version="1.0" encoding="%s"?>' %
             xmlquoteattr(self.get_charset_encoding()))
        if self.has_part("intro"):
            self.write_intro()
            self.writeln()

    def xml_end_output (self):
        """
        Write end of checking info as xml comment.
        """
        if self.has_part("outro"):
            self.write_outro()

    def xml_starttag (self, name, attrs=None):
        """
        Write XML start tag.
        """
        self.write(self.indent*self.level)
        self.write(u"<%s" % xmlquote(name))
        if attrs:
            for name, value in attrs.items():
                args = (xmlquote(name), xmlquoteattr(value))
                self.write(u' %s="%s"' % args)
        self.writeln(u">")
        self.level += 1

    def xml_endtag (self, name):
        """
        Write XML end tag.
        """
        self.level -= 1
        assert self.level >= 0
        self.write(self.indent*self.level)
        self.writeln(u"</%s>" % xmlquote(name))

    def xml_tag (self, name, content, attrs=None):
        """
        Write XML tag with content.
        """
        self.write(self.indent*self.level)
        self.write(u"<%s" % xmlquote(name))
        if attrs:
            for aname, avalue in attrs.items():
                args = (xmlquote(aname), xmlquoteattr(avalue))
                self.write(u' %s="%s"' % args)
        self.writeln(u">%s</%s>" % (xmlquote(content), xmlquote(name)))

########NEW FILE########
__FILENAME__ = mem
# -*- coding: iso-8859-1 -*-
# Copyright: Jean Brouwers
# License:
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
"""
Copied from the Python Cookbook recipe at
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/286222

To find the memory usage in a particular section of code these
functions are typically used as follows::
    m0 = memory()
    ...
    m1 = memory(m0)
"""

import os

_proc_status = '/proc/%d/status' % os.getpid()

_scale = {'kB': 1024.0, 'mB': 1024.0*1024.0,
          'KB': 1024.0, 'MB': 1024.0*1024.0}

def _VmB (VmKey):
    """Parse /proc/<pid>/status file for given key.

    @return: requested number value of status entry
    @rtype: float
    """
    if os.name != 'posix':
        # not supported
        return 0.0
    global _proc_status, _scale
    # get pseudo file /proc/<pid>/status
    try:
        t = open(_proc_status)
        v = t.read()
        t.close()
    except IOError:
        # unsupported platform (non-Linux?)
        return 0.0
    # get VmKey line e.g. 'VmRSS:  9999  kB\n ...'
    i = v.index(VmKey)
    v = v[i:].split(None, 3)  # whitespace
    if len(v) < 3:
        return 0.0  # invalid format?
    # convert Vm value to bytes
    return float(v[1]) * _scale[v[2]]


def memory (since=0.0):
    """Get memory usage.

    @return: memory usage in bytes
    @rtype: float
    """
    return _VmB('VmSize:') - since


def resident (since=0.0):
    """Get resident memory usage.

    @return: resident memory usage in bytes
    @rtype: float
    """
    return _VmB('VmRSS:') - since


def stacksize (since=0.0):
    """Get stack size.

    @return: stack size in bytes
    @rtype: float
    """
    return _VmB('VmStk:') - since

########NEW FILE########
__FILENAME__ = memoryutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Memory utilities.
"""
import gc
import pprint
from . import strformat, log, LOG_CHECK
from .fileutil import get_temp_file

# Message to display when meliae package is not installed
MemoryDebugMsg = strformat.format_feature_warning(module=u'meliae',
            feature=u'memory debugging',
            url=u'https://launchpad.net/meliae')


def write_memory_dump():
    """Dump memory to a temporary filename with the meliae package.
    @return: JSON filename where memory dump has been written to
    @rtype: string
    """
    # first do a full garbage collection run
    gc.collect()
    if gc.garbage:
        log.warn(LOG_CHECK, "Unreachabe objects: %s", pprint.pformat(gc.garbage))
    from meliae import scanner
    fo, filename = get_temp_file(mode='wb', suffix='.json', prefix='lcdump_')
    try:
        scanner.dump_all_objects(fo)
    finally:
        fo.close()
    return filename


########NEW FILE########
__FILENAME__ = mimeutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
File and path utilities.
"""

import os
import re
import mimetypes

from . import log
from .logconf import LOG_CHECK

mimedb = None

def init_mimedb():
    """Initialize the local MIME database."""
    global mimedb
    try:
        mimedb = mimetypes.MimeTypes(strict=False)
    except StandardError as msg:
        log.error(LOG_CHECK, "could not initialize MIME database: %s" % msg)
        return
    # For Opera bookmark files (opera6.adr)
    add_mimetype(mimedb, 'text/plain', '.adr')
    # To recognize PHP files as HTML with content check.
    add_mimetype(mimedb, 'application/x-httpd-php', '.php')
    # To recognize WML files
    add_mimetype(mimedb, 'text/vnd.wap.wml', '.wml')


def add_mimetype(mimedb, mimetype, extension):
    """Add or replace a mimetype to be used with the given extension."""
    # If extension is already a common type, strict=True must be used.
    strict = extension in mimedb.types_map[True]
    mimedb.add_type(mimetype, extension, strict=strict)


# if file extension lookup was unsuccessful, look at the content
PARSE_CONTENTS = {
    "text/html": re.compile(r'^(?i)<(!DOCTYPE html|html|head|title)'),
    "text/plain+opera": re.compile(r'^Opera Hotlist'),
    "text/plain+chromium": re.compile(r'^{\s*"checksum":'),
    "text/plain+linkchecker": re.compile(r'(?i)^# LinkChecker URL list'),
    "application/xml+sitemapindex": re.compile(r'(?i)<\?xml[^<]+<sitemapindex\s+'),
    "application/xml+sitemap": re.compile(r'(?i)<\?xml[^<]+<urlset\s+'),
}

def guess_mimetype (filename, read=None):
    """Return MIME type of file, or 'application/octet-stream' if it could
    not be determined."""
    mime, encoding = None, None
    if mimedb:
        mime, encoding = mimedb.guess_type(filename, strict=False)
    basename = os.path.basename(filename)
    # Special case for Safari Bookmark files
    if not mime and basename == 'Bookmarks.plist':
        return 'application/x-plist+safari'
    # Special case for Google Chrome Bookmark files.
    if not mime and basename == 'Bookmarks':
        mime = 'text/plain'
    # Some mime types can be differentiated further with content reading.
    if mime in ("text/plain", "application/xml", "text/xml") and read is not None:
        read_mime = guess_mimetype_read(read)
        if read_mime is not None:
            mime = read_mime
    if not mime:
        mime = "application/octet-stream"
    elif ";" in mime:
        # split off not needed extension info
        mime = mime.split(';')[0]
    return mime.strip().lower()


def guess_mimetype_read(read):
    """Try to read some content and do a poor man's file(1)."""
    mime = None
    try:
        data = read()[:70]
    except Exception:
        pass
    else:
        for cmime, ro in PARSE_CONTENTS.items():
            if ro.search(data):
                mime = cmime
                break
    return mime


init_mimedb()

########NEW FILE########
__FILENAME__ = iputil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2003-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Ip number related utility functions.
"""

import re
import socket
import struct
from .. import log, LOG_CHECK


# IP Adress regular expressions
# Note that each IPv4 octet can be encoded in dezimal, hexadezimal and octal.
_ipv4_num = r"\d{1,3}"
_ipv4_hex = r"0*[\da-f]{1,2}"
_ipv4_oct = r"0+[0-7]{0, 3}"
# XXX
_ipv4_num_4 = r"%s\.%s\.%s\.%s" % ((_ipv4_num,) * 4)
_ipv4_re = re.compile(r"^%s$" % _ipv4_num_4)
_ipv4_hex_4 = r"%s\.%s\.%s\.%s" % ((_ipv4_hex,) * 4)
# IPv4 encoded in octal, eg. 0x42.0x66.0x0d.0x63
_ipv4_oct = r"0*[0-7]{1,3}"
_ipv4_hex_4 = r"%s\.%s\.%s\.%s" % ((_ipv4_hex,) * 4)


# IPv6; See also rfc2373
_ipv6_num = r"[\da-f]{1,4}"
_ipv6_re = re.compile(r"^%s:%s:%s:%s:%s:%s:%s:%s$" % ((_ipv6_num,) * 8))
_ipv6_ipv4_re = re.compile(r"^%s:%s:%s:%s:%s:%s:" % ((_ipv6_num,) * 6) + \
                           r"%s$" % _ipv4_num_4)
_ipv6_abbr_re = re.compile(r"^((%s:){0,6}%s)?::((%s:){0,6}%s)?$" % \
                            ((_ipv6_num,) * 4))
_ipv6_ipv4_abbr_re = re.compile(r"^((%s:){0,4}%s)?::((%s:){0,5})?" % \
                           ((_ipv6_num,) * 3) + \
                           "%s$" % _ipv4_num_4)
# netmask regex
_host_netmask_re = re.compile(r"^%s/%s$" % (_ipv4_num_4, _ipv4_num_4))
_host_cidrmask_re = re.compile(r"^%s/\d{1,2}$" % _ipv4_num_4)


def expand_ipv6 (ip, num):
    """
    Expand an IPv6 address with included :: to num octets.

    @raise: ValueError on invalid IP addresses
    """
    i = ip.find("::")
    prefix = ip[:i]
    suffix = ip[i + 2:]
    count = prefix.count(":") + suffix.count(":")
    if prefix:
        count += 1
        prefix = prefix + ":"
    if suffix:
        count += 1
        suffix = ":" + suffix
    if count >= num:
        raise ValueError("invalid ipv6 number: %s" % ip)
    fill = (num - count - 1) * "0:" + "0"
    return prefix + fill + suffix


def expand_ip (ip):
    """
    ipv6 addresses are expanded to full 8 octets, all other
    addresses are left untouched
    return a tuple (ip, num) where num==1 if ip is a numeric ip, 0
    otherwise.
    """
    if _ipv4_re.match(ip) or \
       _ipv6_re.match(ip) or \
       _ipv6_ipv4_re.match(ip):
        return (ip, 1)
    if _ipv6_abbr_re.match(ip):
        return (expand_ipv6(ip, 8), 1)
    if _ipv6_ipv4_abbr_re.match(ip):
        i = ip.rfind(":") + 1
        return (expand_ipv6(ip[:i], 6) + ip[i:], 1)
    return (ip, 0)


def is_valid_ip (ip):
    """
    Return True if given ip is a valid IPv4 or IPv6 address.
    """
    return is_valid_ipv4(ip) or is_valid_ipv6(ip)


def is_valid_ipv4 (ip):
    """
    Return True if given ip is a valid IPv4 address.
    """
    if not _ipv4_re.match(ip):
        return False
    a, b, c, d = [int(i) for i in ip.split(".")]
    return a <= 255 and b <= 255 and c <= 255 and d <= 255


def is_valid_ipv6 (ip):
    """
    Return True if given ip is a valid IPv6 address.
    """
    # XXX this is not complete: check ipv6 and ipv4 semantics too here
    if not (_ipv6_re.match(ip) or _ipv6_ipv4_re.match(ip) or
            _ipv6_abbr_re.match(ip) or _ipv6_ipv4_abbr_re.match(ip)):
        return False
    return True


def is_valid_cidrmask (mask):
    """
    Check if given mask is a valid network bitmask in CIDR notation.
    """
    return 0 <= mask <= 32


def dq2num (ip):
    """
    Convert decimal dotted quad string to long integer.
    """
    return struct.unpack('!L', socket.inet_aton(ip))[0]


def num2dq (n):
    """
    Convert long int to dotted quad string.
    """
    return socket.inet_ntoa(struct.pack('!L', n))


def cidr2mask (n):
    """
    Return a mask where the n left-most of 32 bits are set.
    """
    return ((1L << n) - 1) << (32 - n)


def netmask2mask (ip):
    """
    Return a mask of bits as a long integer.
    """
    return dq2num(ip)


def mask2netmask (mask):
    """
    Return dotted quad string as netmask.
    """
    return num2dq(mask)


def dq2net (ip, mask):
    """
    Return a tuple (network ip, network mask) for given ip and mask.
    """
    return dq2num(ip) & mask


def dq_in_net (n, mask):
    """
    Return True iff numerical ip n is in given network.
    """
    return (n & mask) == mask


def host_in_set (ip, hosts, nets):
    """
    Return True if given ip is in host or network list.
    """
    if ip in hosts:
        return True
    if is_valid_ipv4(ip):
        n = dq2num(ip)
        for net in nets:
            if dq_in_net(n, net):
                return True
    return False


def strhosts2map (strhosts):
    """
    Convert a string representation of hosts and networks to
    a tuple (hosts, networks).
    """
    return hosts2map([s.strip() for s in strhosts.split(",") if s])


def hosts2map (hosts):
    """
    Return a set of named hosts, and a list of subnets (host/netmask
    adresses).
    Only IPv4 host/netmasks are supported.
    """
    hostset = set()
    nets = []
    for host in hosts:
        if _host_cidrmask_re.match(host):
            host, mask = host.split("/")
            mask = int(mask)
            if not is_valid_cidrmask(mask):
                log.error(LOG_CHECK,
                          "CIDR mask %d is not a valid network mask", mask)
                continue
            if not is_valid_ipv4(host):
                log.error(LOG_CHECK, "host %r is not a valid ip address", host)
                continue
            nets.append(dq2net(host, cidr2mask(mask)))
        elif _host_netmask_re.match(host):
            host, mask = host.split("/")
            if not is_valid_ipv4(host):
                log.error(LOG_CHECK, "host %r is not a valid ip address", host)
                continue
            if not is_valid_ipv4(mask):
                log.error(LOG_CHECK,
                          "mask %r is not a valid ip network mask", mask)
                continue
            nets.append(dq2net(host, netmask2mask(mask)))
        elif is_valid_ip(host):
            hostset.add(expand_ip(host)[0])
        else:
            hostset |= set(resolve_host(host))
    return (hostset, nets)


def map2hosts (hostmap):
    """
    Convert a tuple (hosts, networks) into a host/network list
    suitable for storing in a config file.
    """
    ret = hostmap[0].copy()
    for net, mask in hostmap[1]:
        ret.add("%s/%d" % (num2dq(net), mask2netmask(mask)))
    return ret


def lookup_ips (ips):
    """
    Return set of host names that resolve to given ips.
    """
    hosts = set()
    for ip in ips:
        try:
            hosts.add(socket.gethostbyaddr(ip)[0])
        except socket.error:
            hosts.add(ip)
    return hosts


def resolve_host (host):
    """
    @host: hostname or IP address
    Return list of ip numbers for given host.
    """
    ips = []
    try:
        for res in socket.getaddrinfo(host, None, 0, socket.SOCK_STREAM):
            # res is a tuple (address family, socket type, protocol,
            #  canonical name, socket address)
            # add first ip of socket address
            ips.append(res[4][0])
    except socket.error:
        log.info(LOG_CHECK, "Ignored invalid host %r", host)
    return ips


def obfuscate_ip(ip):
    """Obfuscate given host in IP form.
    @ip: IPv4 address string
    @return: hexadecimal IP string ('0x1ab...')
    @raise: ValueError on invalid IP addresses
    """
    if is_valid_ipv4(ip):
        res = "0x%s" % "".join(hex(int(x))[2:] for x in ip.split("."))
    else:
        raise ValueError('Invalid IP value %r' % ip)
    assert is_obfuscated_ip(res),  '%r obfuscation error' % res
    return res


is_obfuscated_ip = re.compile(r"^(0x[a-f0-9]+|[0-9]+)$").match

########NEW FILE########
__FILENAME__ = sitemap
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Main functions for link parsing
"""
from xml.parsers.expat import ParserCreate


class XmlTagUrlParser(object):
    """Parse XML files and find URLs in text content of a tag name."""

    def __init__(self, tag):
        """Initialize the parser."""
        self.tag = tag
        self.parser = ParserCreate()
        self.parser.buffer_text = True
        self.parser.returns_unicode = True
        self.parser.StartElementHandler = self.start_element
        self.parser.EndElementHandler = self.end_element
        self.parser.CharacterDataHandler = self.char_data

    def parse(self, url_data):
        """Parse XML URL data."""
        self.url_data = url_data
        self.loc = False
        self.url = u""
        data = url_data.get_content()
        isfinal = True
        self.parser.Parse(data, isfinal)

    def start_element(self, name, attrs):
        """Set tag status for start element."""
        self.in_tag = (name == self.tag)
        self.url = u""

    def end_element(self, name):
        """If end tag is our tag, call add_url()."""
        self.in_tag = False
        if name == self.tag:
            self.add_url()

    def add_url(self):
        """Add non-empty URLs to the queue."""
        if self.url:
            self.url_data.add_url(self.url, line=self.parser.CurrentLineNumber,
                column=self.parser.CurrentColumnNumber)
            self.url = u""

    def char_data(self, data):
        """If inside the wanted tag, append data to URL."""
        if self.loc:
            self.url += data


def parse_sitemap(url_data):
    """Parse XML sitemap data."""
    XmlTagUrlParser(u"loc").parse(url_data)


def parse_sitemapindex(url_data):
    """Parse XML sitemap index data."""
    XmlTagUrlParser(u"loc").parse(url_data)


########NEW FILE########
__FILENAME__ = anchorcheck
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Check HTML anchors
"""
from . import _ContentPlugin
from .. import log, LOG_PLUGIN, url as urlutil
from ..htmlutil import linkparse
from ..parser import find_links


class AnchorCheck(_ContentPlugin):
    """Checks validity of HTML anchors."""

    def applies_to(self, url_data):
        """Check for HTML anchor existence."""
        return url_data.is_html() and url_data.anchor

    def check(self, url_data):
        """Check content for invalid anchors."""
        log.debug(LOG_PLUGIN, "checking content for invalid anchors")
        # list of parsed anchors
        self.anchors = []
        find_links(url_data, self.add_anchor, linkparse.AnchorTags)
        self.check_anchor(url_data)

    def add_anchor (self, url, line, column, name, base):
        """Add anchor URL."""
        self.anchors.append((url, line, column, name, base))

    def check_anchor(self, url_data):
        """If URL is valid, parseable and has an anchor, check it.
        A warning is logged and True is returned if the anchor is not found.
        """
        log.debug(LOG_PLUGIN, "checking anchor %r in %s", url_data.anchor, self.anchors)
        enc = lambda anchor: urlutil.url_quote_part(anchor, encoding=url_data.encoding)
        if any(x for x in self.anchors if enc(x[0]) == url_data.anchor):
            return
        if self.anchors:
            anchornames = sorted(set(u"`%s'" % x[0] for x in self.anchors))
            anchors = u", ".join(anchornames)
        else:
            anchors = u"-"
        args = {"name": url_data.anchor, "anchors": anchors}
        msg = u"%s %s" % (_("Anchor `%(name)s' not found.") % args,
                          _("Available anchors: %(anchors)s.") % args)
        url_data.add_warning(msg)

########NEW FILE########
__FILENAME__ = httpheaderinfo
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Add HTTP server name information
"""
from . import _ConnectionPlugin


class HttpHeaderInfo(_ConnectionPlugin):
    """Add HTTP header info for each URL"""

    def __init__(self, config):
        """Initialize configuration."""
        super(HttpHeaderInfo, self).__init__(config)
        self.prefixes = tuple(config["prefixes"])

    def applies_to(self, url_data):
        """Check for HTTP and prefix config."""
        return self.prefixes and url_data.is_http()

    def check(self, url_data):
        """Check content for invalid anchors."""
        headers = []
        for name, value in url_data.headers.items():
            if name.startswith(self.prefixes):
                headers.append(name)
        if headers:
            items = [u"%s=%s" % (name.capitalize(), url_data.headers[name]) for name in headers]
            info = u"HTTP headers %s" % u", ".join(items)
            url_data.add_info(info)

    @classmethod
    def read_config(cls, configparser):
        """Read configuration file options."""
        config = dict()
        section = cls.__name__
        option = "prefixes"
        if configparser.has_option(section, option):
            value = configparser.get(section, option)
            names = [x.strip().lower() for x in value.split(",")]
        else:
            names = []
        config[option] = names
        return config


########NEW FILE########
__FILENAME__ = locationinfo
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Store and retrieve country names for IPs.
"""
from . import _ConnectionPlugin
import os
import sys
import socket
from ..lock import get_lock
from ..decorators import synchronized
from ..strformat import unicode_safe
from .. import log, LOG_PLUGIN

class LocationInfo(_ConnectionPlugin):
    """Adds the country and if possible city name of the URL host as info.
    Needs GeoIP or pygeoip and a local country or city lookup DB installed."""

    def __init__(self, config):
        """Check for geoip module."""
        if not geoip:
            log.warn(LOG_PLUGIN, "GeoIP or pygeoip not found for LocationInfo plugin.")
        super(LocationInfo, self).__init__(config)

    def applies_to(self, url_data):
        """Check for validity, host existence and geoip module."""
        return url_data.valid and url_data.host and geoip

    def check(self, url_data):
        """Try to ask GeoIP database for country info."""
        location = get_location(url_data.host)
        if location:
            url_data.add_info(_("URL is located in %(location)s.") %
            {"location": _(location)})

# It is unknown if the geoip library is already thread-safe, so
# no risks should be taken here by using a lock.
_lock = get_lock("geoip")

def get_geoip_dat ():
    """Find a GeoIP database, preferring city over country lookup."""
    datafiles = ("GeoIPCity.dat", "GeoIP.dat")
    if os.name == 'nt':
        paths = (sys.exec_prefix, r"c:\geoip")
    else:
        paths = ("/usr/local/share/GeoIP", "/usr/share/GeoIP")
    for path in paths:
        for datafile in datafiles:
            filename = os.path.join(path, datafile)
            if os.path.isfile(filename):
                return filename

# try importing both the C-library GeoIP and the pure-python pygeoip
geoip_dat = get_geoip_dat()
geoip = None
if geoip_dat:
    try:
        import GeoIP
        geoip = GeoIP.open(geoip_dat, GeoIP.GEOIP_STANDARD)
        geoip_error = GeoIP.error
    except ImportError:
        try:
            import pygeoip
            geoip = pygeoip.GeoIP(geoip_dat)
            geoip_error = pygeoip.GeoIPError
        except ImportError:
            pass
    if geoip_dat.endswith('GeoIPCity.dat'):
        get_geoip_record = lambda host: geoip.record_by_name(host)
    else:
        get_geoip_record = lambda host: {'country_name': geoip.country_name_by_name(host)}


@synchronized(_lock)
def get_location (host):
    """Get translated country and optional city name.

    @return: country with optional city or an boolean False if not found
    """
    if geoip is None:
        # no geoip available
        return None
    try:
        record = get_geoip_record(host)
    except (geoip_error, socket.error):
        log.debug(LOG_PLUGIN, "Geoip error for %r", host, exception=True)
        # ignore lookup errors
        return None
    value = u""
    if record and record.get("city"):
        value += unicode_safe(record["city"])
    if record and record.get("country_name"):
        if value:
            value += u", "
        value += unicode_safe(record["country_name"])
    return value

########NEW FILE########
__FILENAME__ = parsepdf
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Parse links in PDF files with pdfminer.
"""
from cStringIO import StringIO
from . import _ParserPlugin
try:
    from pdfminer.pdfparser import PDFParser
    from pdfminer.pdfdocument import PDFDocument
    from pdfminer.pdftypes import PDFStream, PDFObjRef
    from pdfminer.pdfpage import PDFPage
    from pdfminer.psparser import PSException
except ImportError:
    has_pdflib = False
else:
    has_pdflib = True
from .. import log, LOG_PLUGIN, strformat



def search_url(obj, url_data, pageno, seen_objs):
    """Recurse through a PDF object, searching for URLs."""
    if isinstance(obj, PDFObjRef):
        if obj.objid in seen_objs:
            # prevent recursive loops
            return
        seen_objs.add(obj.objid)
        obj = obj.resolve()
    if isinstance(obj, dict):
        for key, value in obj.items():
            if key == 'URI' and isinstance(value, basestring):
                # URIs should be 7bit ASCII encoded, but be safe and encode
                # to unicode
                # XXX this does not use an optional specified base URL
                url = strformat.unicode_safe(value)
                url_data.add_url(url, page=pageno)
            else:
                search_url(value, url_data, pageno, seen_objs)
    elif isinstance(obj, list):
        for elem in obj:
            search_url(elem, url_data, pageno, seen_objs)
    elif isinstance(obj, PDFStream):
        search_url(obj.attrs, url_data, pageno, seen_objs)


class PdfParser(_ParserPlugin):
    """PDF parsing plugin."""

    def __init__(self, config):
        """Check for pdfminer."""
        if not has_pdflib:
            log.warn(LOG_PLUGIN, "pdfminer not found for PdfParser plugin")
        super(PdfParser, self).__init__(config)

    def applies_to(self, url_data, pagetype=None):
        """Check for PDF pagetype."""
        return has_pdflib and pagetype == 'pdf'

    def check(self, url_data):
        """Parse PDF data."""
        # XXX user authentication from url_data
        password = ''
        data = url_data.get_content()
        # PDFParser needs a seekable file object
        fp = StringIO(data)
        try:
            parser = PDFParser(fp)
            doc = PDFDocument(parser, password=password)
            for (pageno, page) in enumerate(PDFPage.create_pages(doc), start=1):
                if "Contents" in page.attrs:
                    search_url(page.attrs["Contents"], url_data, pageno, set())
                if "Annots" in page.attrs:
                    search_url(page.attrs["Annots"], url_data, pageno, set())
        except PSException, msg:
            if not msg.args:
                # at least show the class name
                msg = repr(msg)
            log.warn(LOG_PLUGIN, "Error parsing PDF file: %s", msg)

########NEW FILE########
__FILENAME__ = parseword
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Parse hyperlinks in Word files.
"""
from . import _ParserPlugin
try:
    import win32com
    import pythoncom
    has_win32com = True
    Error = pythoncom.com_error
except ImportError:
    has_win32com = False
    Error = StandardError
from .. import fileutil, log, LOG_PLUGIN


_initialized = False
def init_win32com ():
    """Initialize the win32com.client cache."""
    global _initialized 
    if _initialized:
        return
    import win32com.client
    if win32com.client.gencache.is_readonly:
        #allow gencache to create the cached wrapper objects
        win32com.client.gencache.is_readonly = False
        # under py2exe the call in gencache to __init__() does not happen
        # so we use Rebuild() to force the creation of the gen_py folder
        # Note that the python...\win32com.client.gen_py dir must not exist
        # to allow creation of the cache in %temp% for py2exe.
        # This is ensured by excluding win32com.gen_py in setup.py
        win32com.client.gencache.Rebuild()
    _initialized = True


def has_word ():
    """Determine if Word is available on the current system."""
    if not has_win32com:
        return False
    try:
        import _winreg as winreg
    except ImportError:
        import winreg
    try:
        key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "Word.Application")
        winreg.CloseKey(key)
        return True
    except (EnvironmentError, ImportError):
        pass
    return False


def constants (name):
    """Helper to return constants. Avoids importing win32com.client in
    other modules."""
    return getattr(win32com.client.constants, name)


def get_word_app ():
    """Return open Word.Application handle, or None if Word is not available
    on this system."""
    if not has_word():
        return None
    # Since this function is called from different threads, initialize
    # the COM layer.
    pythoncom.CoInitialize()
    import win32com.client
    app = win32com.client.gencache.EnsureDispatch("Word.Application")
    app.Visible = False
    return app


def close_word_app (app):
    """Close Word application object."""
    app.Quit()


def open_wordfile (app, filename):
    """Open given Word file with application object."""
    return app.Documents.Open(filename, ReadOnly=True,
      AddToRecentFiles=False, Visible=False, NoEncodingDialog=True)


def close_wordfile (doc):
    """Close word file."""
    doc.Close()


class WordParser(_ParserPlugin):
    """Word parsing plugin."""

    def __init__(self, config):
        """Check for pdfminer."""
        init_win32com()
        if not has_word():
            log.warn(LOG_PLUGIN, "Microsoft Word not found for WordParser plugin")
        super(WordParser, self).__init__(config)

    def applies_to(self, url_data, pagetype=None):
        """Check for Word pagetype."""
        return has_word() and pagetype == 'word'

    def check(self, url_data):
        """Parse Word data."""
        filename = get_temp_filename()
        # open word file and parse hyperlinks
        try:
            app = get_word_app()
            try:
                doc = open_wordfile(app, filename)
                if doc is None:
                    raise Error("could not open word file %r" % filename)
                try:
                    for link in doc.Hyperlinks:
                        line = get_line_number(link.Range)
                        name=link.TextToDisplay
                        url_data.add_url(link.Address, name=name, line=line)
                finally:
                    close_wordfile(doc)
            finally:
                close_word_app(app)
        except Error as msg:
            log.warn(LOG_PLUGIN, "Error parsing word file: %s", msg)


def get_line_number(doc, wrange):
    """Get line number for given range object."""
    lineno = 1
    wrange.Select()
    wdFirstCharacterLineNumber = constants("wdFirstCharacterLineNumber")
    wdGoToLine = constants("wdGoToLine")
    wdGoToPrevious = constants("wdGoToPrevious")
    while True:
        curline = doc.Selection.Information(wdFirstCharacterLineNumber)
        doc.Selection.GoTo(wdGoToLine, wdGoToPrevious, Count=1, Name="")
        lineno += 1
        prevline = doc.Selection.Information(wdFirstCharacterLineNumber)
        if prevline == curline:
            break
    return lineno


def get_temp_filename (content):
    """Get temporary filename for content to parse."""
    # store content in temporary file
    fd, filename = fileutil.get_temp_file(mode='wb', suffix='.doc',
        prefix='lc_')
    try:
        fd.write(content)
    finally:
        fd.close()
    return filename


########NEW FILE########
__FILENAME__ = regexcheck
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Check page content with regular expression.
"""
import re
from . import _ContentPlugin
from .. import log, LOG_PLUGIN


class RegexCheck(_ContentPlugin):
    """Define a regular expression which prints a warning if it matches
    any content of the checked link. This applies only to valid pages,
    so we can get their content.

    Use this to check for pages that contain some form of error
    message, for example 'This page has moved' or 'Oracle
    Application error'.

    Note that multiple values can be combined in the regular expression,
    for example "(This page has moved|Oracle Application error)"."""

    def __init__(self, config):
        """Set warning regex from config."""
        super(RegexCheck, self).__init__(config)
        self.warningregex = None
        pattern = config["warningregex"]
        if pattern:
            try:
                self.warningregex = re.compile(pattern)
            except re.error as msg:
                log.warn(LOG_PLUGIN, "Invalid regex pattern %r: %s" % (pattern, msg))

    def applies_to(self, url_data):
        """Check for warningregex, extern flag and parseability."""
        return self.warningregex and not url_data.extern[0] and url_data.is_parseable()

    def check(self, url_data):
        """Check content."""
        log.debug(LOG_PLUGIN, "checking content for warning regex")
        content = url_data.get_content()
        # add warnings for found matches, up to the maximum allowed number
        match = self.warningregex.search(content)
        if match:
            # calculate line number for match
            line = content.count('\n', 0, match.start())
            # add a warning message
            msg = _("Found %(match)r at line %(line)d in link contents.")
            url_data.add_warning(msg % {"match": match.group(), "line": line})

    @classmethod
    def read_config(cls, configparser):
        """Read configuration file options."""
        config = dict()
        section = cls.__name__
        option = "warningregex"
        if configparser.has_option(section, option):
            value = configparser.get(section, option)
        else:
            value = None
        config[option] = value
        return config

########NEW FILE########
__FILENAME__ = sslcertcheck
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Handle https links.
"""
import time
import threading
from . import _ConnectionPlugin
from .. import strformat, LinkCheckerError
from ..decorators import synchronized

_lock = threading.Lock()

# configuration option names
sslcertwarndays = "sslcertwarndays"

class SslCertificateCheck(_ConnectionPlugin):
    """Check SSL certificate expiration date. Only internal https: links
    will be checked. A domain will only be checked once to avoid duplicate
    warnings.
    The expiration warning time can be configured with the sslcertwarndays
    option."""

    def __init__(self, config):
        """Initialize clamav configuration."""
        super(SslCertificateCheck, self).__init__(config)
        self.warn_ssl_cert_secs_valid = config[sslcertwarndays] * strformat.SECONDS_PER_DAY
        # do not check hosts multiple times
        self.checked_hosts = set()

    def applies_to(self, url_data):
        """Check validity, scheme, extern and url_connection."""
        return url_data.valid and url_data.scheme == 'https' and \
          not url_data.extern[0] and url_data.url_connection is not None

    @synchronized(_lock)
    def check(self, url_data):
        """Run all SSL certificate checks that have not yet been done.
        OpenSSL already checked the SSL notBefore and notAfter dates.
        """
        host = url_data.urlparts[1]
        if host in self.checked_hosts:
            return
        self.checked_hosts.add(host)
        cert = url_data.ssl_cert
        config = url_data.aggregate.config
        if cert and 'notAfter' in cert:
            self.check_ssl_valid_date(url_data, cert)
        elif config['sslverify']:
            msg = _('certificate did not include "notAfter" information')
            url_data.add_warning(msg)
        else:
            msg = _('SSL verification is disabled; enable the sslverify option')
            url_data.add_warning(msg)

    def check_ssl_valid_date(self, url_data, cert):
        """Check if the certificate is still valid, or if configured check
        if it's at least a number of days valid.
        """
        import ssl
        try:
            notAfter = ssl.cert_time_to_seconds(cert['notAfter'])
        except ValueError as msg:
            msg = _('Invalid SSL certficate "notAfter" value %r') % cert['notAfter']
            url_data.add_warning(msg)
            return
        curTime = time.time()
        # Calculate seconds until certifcate expires. Can be negative if
        # the certificate is already expired.
        secondsValid = notAfter - curTime
        args = dict(expire=cert['notAfter'])
        if secondsValid < 0:
            msg = _('SSL certficate is expired on %(expire)s.')
            url_data.add_warning(msg % args)
        else:
            args['valid'] = strformat.strduration_long(secondsValid)
            if secondsValid < self.warn_ssl_cert_secs_valid:
                msg = _('SSL certificate expires on %(expire)s and is only %(valid)s valid.')
                url_data.add_warning(msg % args)
            else:
                msg = _('SSL certificate expires on %(expire)s and is %(valid)s valid.')
                url_data.add_info(msg % args)

    @classmethod
    def read_config(cls, configparser):
        """Read configuration file options."""
        config = dict()
        section = cls.__name__
        option = sslcertwarndays
        if configparser.has_option(section, option):
            num = configparser.getint(section, option)
            if num > 0:
                config[option] = num
            else:
                msg = _("invalid value for %s: %d must not be less than %d") % (option, num, 0)
                raise LinkCheckerError(msg)
        else:
            # set the default
            config[option] = 30
        return config

########NEW FILE########
__FILENAME__ = syntaxchecks
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import threading
import time
import requests
from xml.dom.minidom import parseString
from . import _ContentPlugin
from .. import log, LOG_PLUGIN
from ..decorators import synchronized


_w3_time_lock = threading.Lock()


class W3Timer(object):
    """Ensure W3C apis are not hammered."""

    # every X seconds
    SleepSeconds = 2

    def __init__(self):
        """Remember last API call."""
        self.last_w3_call = 0

    @synchronized(_w3_time_lock)
    def check_w3_time (self):
        """Make sure the W3C validators are at most called once a second."""
        if time.time() - self.last_w3_call < W3Timer.SleepSeconds:
            time.sleep(W3Timer.SleepSeconds)
        self.last_w3_call = time.time()


class HtmlSyntaxCheck(_ContentPlugin):
    """Check the syntax of HTML pages with the online W3C HTML validator.
    See http://validator.w3.org/docs/api.html.
    """
    def __init__(self, config):
        """Initialize plugin."""
        super(HtmlSyntaxCheck, self).__init__(config)
        self.timer = W3Timer()

    def applies_to(self, url_data):
        """Check for HTML and extern."""
        return url_data.is_html() and not url_data.extern[0]

    def check(self, url_data):
        """Check HTML syntax of given URL."""
        self.timer.check_w3_time()
        session = url_data.session
        try:
            body = {'uri': url_data.url, 'output': 'soap12'}
            response = session.post('http://validator.w3.org/check', data=body)
            response.raise_for_status()
            if response.headers.get('x-w3c-validator-status', 'Invalid') == 'Valid':
                url_data.add_info(u"W3C Validator: %s" % _("valid HTML syntax"))
                return
            check_w3_errors(url_data, response.text, "W3C HTML")
        except requests.exceptions.RequestException:
            pass # ignore service failures
        except Exception as msg:
            log.warn(LOG_PLUGIN, _("HTML syntax check plugin error: %(msg)s ") % {"msg": msg})


class CssSyntaxCheck(_ContentPlugin):
    """Check the syntax of HTML pages with the online W3C CSS validator.
    See http://jigsaw.w3.org/css-validator/manual.html#expert.
    """

    def __init__(self, config):
        """Initialize plugin."""
        super(CssSyntaxCheck, self).__init__(config)
        self.timer = W3Timer()

    def applies_to(self, url_data):
        """Check for CSS and extern."""
        return url_data.is_css() and not url_data.extern[0]

    def check(self, url_data):
        """Check CSS syntax of given URL."""
        self.timer.check_w3_time()
        session = url_data.session
        try:
            url = 'http://jigsaw.w3.org/css-validator/validator'
            params = {
                'uri': url_data.url,
                'warning': '2',
                'output': 'soap12',
            }
            response = session.get(url, params=params)
            response.raise_for_status()
            if response.headers.get('X-W3C-Validator-Status', 'Invalid') == 'Valid':
                url_data.add_info(u"W3C Validator: %s" % _("valid CSS syntax"))
                return
            check_w3_errors(url_data, response.text, "W3C HTML")
        except requests.exceptions.RequestException:
            pass # ignore service failures
        except Exception as msg:
            log.warn(LOG_PLUGIN, _("CSS syntax check plugin error: %(msg)s ") % {"msg": msg})


def check_w3_errors (url_data, xml, w3type):
    """Add warnings for W3C HTML or CSS errors in xml format.
    w3type is either "W3C HTML" or "W3C CSS"."""
    dom = parseString(xml)
    for error in dom.getElementsByTagName('m:error'):
        warnmsg = _("%(w3type)s validation error at line %(line)s col %(column)s: %(msg)s")
        attrs = {
            "w3type": w3type,
            "line": getXmlText(error, "m:line"),
            "column": getXmlText(error, "m:col"),
            "msg": getXmlText(error, "m:message"),
        }
        url_data.add_warning(warnmsg % attrs)


def getXmlText (parent, tag):
    """Return XML content of given tag in parent element."""
    elem = parent.getElementsByTagName(tag)[0]
    # Yes, the DOM standard is awful.
    rc = []
    for node in elem.childNodes:
        if node.nodeType == node.TEXT_NODE:
            rc.append(node.data)
    return ''.join(rc)

########NEW FILE########
__FILENAME__ = viruscheck
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Check page content for virus infection with clamav.
"""
import os
import socket
from . import _ContentPlugin
from .. import log, LOG_PLUGIN
from ..socketutil import create_socket


class VirusCheck(_ContentPlugin):
    """Checks the page content for virus infections with clamav.
    A local clamav daemon must be installed."""

    def __init__(self, config):
        """Initialize clamav configuration."""
        super(VirusCheck, self).__init__(config)
        # XXX read config
        self.clamav_conf = get_clamav_conf(canonical_clamav_conf())
        if not self.clamav_conf:
            log.warn(LOG_PLUGIN, "clamav daemon not found for VirusCheck plugin")

    def applies_to(self, url_data):
        """Check for clamav and extern."""
        return self.clamav_conf and not url_data.extern[0]

    def check(self, url_data):
        """Try to ask GeoIP database for country info."""
        data = url_data.get_content()
        infected, errors = scan(data, self.clamav_conf)
        if infected or errors:
            for msg in infected:
                url_data.add_warning(u"Virus scan infection: %s" % msg)
            for msg in errors:
                url_data.add_warning(u"Virus scan error: %s" % msg)
        else:
            url_data.add_info("No viruses in data found.")

    @classmethod
    def read_config(cls, configparser):
        """Read configuration file options."""
        config = dict()
        section = cls.__name__
        option = "clamavconf"
        if configparser.has_option(section, option):
            value = configparser.get(section, option)
        else:
            value = None
        config[option] = value
        return config


class ClamavError (Exception):
    """Raised on clamav errors."""
    pass


class ClamdScanner (object):
    """Virus scanner using a clamd daemon process."""

    def __init__ (self, clamav_conf):
        """Initialize clamd daemon process sockets."""
        self.infected = []
        self.errors = []
        self.sock, self.host = clamav_conf.new_connection()
        self.sock_rcvbuf = \
             self.sock.getsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF)
        self.wsock = self.new_scansock()

    def new_scansock (self):
        """Return a connected socket for sending scan data to it."""
        port = None
        try:
            self.sock.sendall("STREAM")
            port = None
            for dummy in range(60):
                data = self.sock.recv(self.sock_rcvbuf)
                i = data.find("PORT")
                if i != -1:
                    port = int(data[i+5:])
                    break
        except socket.error:
            self.sock.close()
            raise
        if port is None:
            raise ClamavError(_("clamd is not ready for stream scanning"))
        sockinfo = get_sockinfo(self.host, port=port)
        wsock = create_socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            wsock.connect(sockinfo[0][4])
        except socket.error:
            wsock.close()
            raise
        return wsock

    def scan (self, data):
        """Scan given data for viruses."""
        self.wsock.sendall(data)

    def close (self):
        """Get results and close clamd daemon sockets."""
        self.wsock.close()
        data = self.sock.recv(self.sock_rcvbuf)
        while data:
            if "FOUND\n" in data:
                self.infected.append(data)
            if "ERROR\n" in data:
                self.errors.append(data)
            data = self.sock.recv(self.sock_rcvbuf)
        self.sock.close()


def canonical_clamav_conf ():
    """Default clamav configs for various platforms."""
    if os.name == 'posix':
        clamavconf = "/etc/clamav/clamd.conf"
    elif os.name == 'nt':
        clamavconf = r"c:\clamav-devel\etc\clamd.conf"
    else:
        clamavconf = "clamd.conf"
    return clamavconf


def get_clamav_conf(filename):
    """Initialize clamav configuration."""
    if os.path.isfile(filename):
        return ClamavConfig(filename)
    log.warn(LOG_PLUGIN, "No ClamAV config file found at %r.", filename)


def get_sockinfo (host, port=None):
    """Return socket.getaddrinfo for given host and port."""
    family, socktype = socket.AF_INET, socket.SOCK_STREAM
    return socket.getaddrinfo(host, port, family, socktype)


class ClamavConfig (dict):
    """Clamav configuration wrapper, with clamd connection method."""

    def __init__ (self, filename):
        """Parse clamav configuration file."""
        super(ClamavConfig, self).__init__()
        self.parseconf(filename)
        if self.get('ScannerDaemonOutputFormat'):
            raise ClamavError(_("ScannerDaemonOutputFormat must be disabled"))
        if self.get('TCPSocket') and self.get('LocalSocket'):
            raise ClamavError(_("only one of TCPSocket and LocalSocket must be enabled"))

    def parseconf (self, filename):
        """Parse clamav configuration from given file."""
        with open(filename) as fd:
            # yet another config format, sigh
            for line in fd:
                line = line.strip()
                if not line or line.startswith("#"):
                    # ignore empty lines and comments
                    continue
                split = line.split(None, 1)
                if len(split) == 1:
                    self[split[0]] = True
                else:
                    self[split[0]] = split[1]

    def new_connection (self):
        """Connect to clamd for stream scanning.

        @return: tuple (connected socket, host)
        """
        if self.get('LocalSocket'):
            host = 'localhost'
            sock = self.create_local_socket()
        elif self.get('TCPSocket'):
            host = self.get('TCPAddr', 'localhost')
            sock = self.create_tcp_socket(host)
        else:
            raise ClamavError(_("one of TCPSocket or LocalSocket must be enabled"))
        return sock, host

    def create_local_socket (self):
        """Create local socket, connect to it and return socket object."""
        sock = create_socket(socket.AF_UNIX, socket.SOCK_STREAM)
        addr = self['LocalSocket']
        try:
            sock.connect(addr)
        except socket.error:
            sock.close()
            raise
        return sock

    def create_tcp_socket (self, host):
        """Create tcp socket, connect to it and return socket object."""
        port = int(self['TCPSocket'])
        sockinfo = get_sockinfo(host, port=port)
        sock = create_socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.connect(sockinfo[0][4])
        except socket.error:
            sock.close()
            raise
        return sock


def scan (data, clamconf):
    """Scan data for viruses.
    @return (infection msgs, errors)
    @rtype ([], [])
    """
    try:
        scanner = ClamdScanner(clamconf)
    except socket.error:
        errmsg = _("Could not connect to ClamAV daemon.")
        return ([], [errmsg])
    try:
        scanner.scan(data)
    finally:
        scanner.close()
    return scanner.infected, scanner.errors

########NEW FILE########
__FILENAME__ = robotparser2
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Robots.txt parser.

The robots.txt Exclusion Protocol is implemented as specified in
http://www.robotstxt.org/wc/norobots-rfc.html
"""
import urlparse
import urllib
import time
import requests
from . import log, LOG_CHECK, configuration

__all__ = ["RobotFileParser"]

ACCEPT_ENCODING = 'x-gzip,gzip,deflate'

class RobotFileParser (object):
    """This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file."""

    def __init__ (self, url='', proxy=None, user=None, password=None):
        """Initialize internal entry lists and store given url and
        credentials."""
        self.set_url(url)
        self.proxy = proxy
        self.user = user
        self.password = password
        self._reset()

    def _reset (self):
        """Reset internal flags and entry lists."""
        self.entries = []
        self.default_entry = None
        self.disallow_all = False
        self.allow_all = False
        self.last_checked = 0
        # list of tuples (sitemap url, line number)
        self.sitemap_urls = []

    def mtime (self):
        """Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        @return: last modified in time.time() format
        @rtype: number
        """
        return self.last_checked

    def modified (self):
        """Set the time the robots.txt file was last fetched to the
        current time."""
        self.last_checked = time.time()

    def set_url (self, url):
        """Set the URL referring to a robots.txt file."""
        self.url = url
        self.host, self.path = urlparse.urlparse(url)[1:3]

    def read (self):
        """Read the robots.txt URL and feeds it to the parser."""
        self._reset()
        headers = {
            'User-Agent': configuration.UserAgent,
            'Accept-Encoding': ACCEPT_ENCODING,
        }
        try:
            response = requests.get(self.url, headers=headers)
            response.raise_for_status()
            content_type = response.headers.get('content-type')
            if content_type and content_type.lower().startswith('text/plain'):
                self.parse(response.iter_lines())
            else:
                log.debug(LOG_CHECK, "%r allow all (no text content)", self.url)
                self.allow_all = True
        except requests.HTTPError, x:
            if x.response.status_code in (401, 403):
                self.disallow_all = True
                log.debug(LOG_CHECK, "%r disallow all (code %d)", self.url, x.response.status_code)
            else:
                self.allow_all = True
                log.debug(LOG_CHECK, "%r allow all (HTTP error)", self.url)
        except requests.exceptions.Timeout:
            raise
        except requests.exceptions.RequestException:
            # no network or other failure
            self.allow_all = True
            log.debug(LOG_CHECK, "%r allow all (request error)", self.url)

    def _add_entry (self, entry):
        """Add a parsed entry to entry list.

        @return: None
        """
        if "*" in entry.useragents:
            # the default entry is considered last
            self.default_entry = entry
        else:
            self.entries.append(entry)

    def parse (self, lines):
        """Parse the input lines from a robot.txt file.
        We allow that a user-agent: line is not preceded by
        one or more blank lines.

        @return: None
        """
        log.debug(LOG_CHECK, "%r parse lines", self.url)
        state = 0
        linenumber = 0
        entry = Entry()

        for line in lines:
            line = line.strip()
            linenumber += 1
            if not line:
                if state == 1:
                    log.debug(LOG_CHECK, "%r line %d: allow or disallow directives without any user-agent line", self.url, linenumber)
                    entry = Entry()
                    state = 0
                elif state == 2:
                    self._add_entry(entry)
                    entry = Entry()
                    state = 0
            # remove optional comment and strip line
            i = line.find('#')
            if i >= 0:
                line = line[:i]
            line = line.strip()
            if not line:
                continue
            line = line.split(':', 1)
            if len(line) == 2:
                line[0] = line[0].strip().lower()
                line[1] = urllib.unquote(line[1].strip())
                if line[0] == "user-agent":
                    if state == 2:
                        log.debug(LOG_CHECK, "%r line %d: missing blank line before user-agent directive", self.url, linenumber)
                        self._add_entry(entry)
                        entry = Entry()
                    entry.useragents.append(line[1])
                    state = 1
                elif line[0] == "disallow":
                    if state == 0:
                        log.debug(LOG_CHECK, "%r line %d: missing user-agent directive before this line", self.url, linenumber)
                        pass
                    else:
                        entry.rulelines.append(RuleLine(line[1], False))
                        state = 2
                elif line[0] == "allow":
                    if state == 0:
                        log.debug(LOG_CHECK, "%r line %d: missing user-agent directive before this line", self.url, linenumber)
                        pass
                    else:
                        entry.rulelines.append(RuleLine(line[1], True))
                        state = 2
                elif line[0] == "crawl-delay":
                    if state == 0:
                        log.debug(LOG_CHECK, "%r line %d: missing user-agent directive before this line", self.url, linenumber)
                        pass
                    else:
                        try:
                            entry.crawldelay = max(0, int(line[1]))
                            state = 2
                        except (ValueError, OverflowError):
                            log.debug(LOG_CHECK, "%r line %d: invalid delay number %r", self.url, linenumber, line[1])
                            pass
                elif line[0] == "sitemap":
                    # Note that sitemap URLs must be absolute according to
                    # http://www.sitemaps.org/protocol.html#submit_robots
                    # But this should be checked by the calling layer.
                    self.sitemap_urls.append((line[1], linenumber))
                else:
                    log.debug(LOG_CHECK, "%r line %d: unknown key %r", self.url, linenumber, line[0])
                    pass
            else:
                log.debug(LOG_CHECK, "%r line %d: malformed line %r", self.url, linenumber, line)
                pass
        if state in (1, 2):
            self.entries.append(entry)
        self.modified()
        log.debug(LOG_CHECK, "Parsed rules:\n%s", str(self))

    def can_fetch (self, useragent, url):
        """Using the parsed robots.txt decide if useragent can fetch url.

        @return: True if agent can fetch url, else False
        @rtype: bool
        """
        log.debug(LOG_CHECK, "%r check allowance for:\n  user agent: %r\n  url: %r ...", self.url, useragent, url)
        if not isinstance(useragent, str):
            useragent = useragent.encode("ascii", "ignore")
        if not isinstance(url, str):
            url = url.encode("ascii", "ignore")
        if self.disallow_all:
            log.debug(LOG_CHECK, " ... disallow all.")
            return False
        if self.allow_all:
            log.debug(LOG_CHECK, " ... allow all.")
            return True
        # search for given user agent matches
        # the first match counts
        url = urllib.quote(urlparse.urlparse(urllib.unquote(url))[2]) or "/"
        for entry in self.entries:
            if entry.applies_to(useragent):
                return entry.allowance(url)
        # try the default entry last
        if self.default_entry is not None:
            return self.default_entry.allowance(url)
        # agent not found ==> access granted
        log.debug(LOG_CHECK, " ... agent not found, allow.")
        return True

    def get_crawldelay (self, useragent):
        """Look for a configured crawl delay.

        @return: crawl delay in seconds or zero
        @rtype: integer >= 0
        """
        for entry in self.entries:
            if entry.applies_to(useragent):
                return entry.crawldelay
        return 0

    def __str__ (self):
        """Constructs string representation, usable as contents of a
        robots.txt file.

        @return: robots.txt format
        @rtype: string
        """
        lines = [str(entry) for entry in self.entries]
        if self.default_entry is not None:
            lines.append(str(self.default_entry))
        return "\n\n".join(lines)


class RuleLine (object):
    """A rule line is a single "Allow:" (allowance==1) or "Disallow:"
    (allowance==0) followed by a path.
    """

    def __init__ (self, path, allowance):
        """Initialize with given path and allowance info."""
        if path == '' and not allowance:
            # an empty value means allow all
            allowance = True
            path = '/'
        self.path = urllib.quote(path)
        self.allowance = allowance

    def applies_to (self, path):
        """Look if given path applies to this rule.

        @return: True if pathname applies to this rule, else False
        @rtype: bool
        """
        return self.path == "*" or path.startswith(self.path)

    def __str__ (self):
        """Construct string representation in robots.txt format.

        @return: robots.txt format
        @rtype: string
        """
        return ("Allow" if self.allowance else "Disallow")+": "+self.path


class Entry (object):
    """An entry has one or more user-agents and zero or more rulelines."""

    def __init__ (self):
        """Initialize user agent and rule list."""
        self.useragents = []
        self.rulelines = []
        self.crawldelay = 0

    def __str__ (self):
        """string representation in robots.txt format.

        @return: robots.txt format
        @rtype: string
        """
        lines = ["User-agent: %s" % agent for agent in self.useragents]
        if self.crawldelay:
            lines.append("Crawl-delay: %d" % self.crawldelay)
        lines.extend([str(line) for line in self.rulelines])
        return "\n".join(lines)

    def applies_to (self, useragent):
        """Check if this entry applies to the specified agent.

        @return: True if this entry applies to the agent, else False.
        @rtype: bool
        """
        if not useragent:
            return True
        useragent = useragent.lower()
        for agent in self.useragents:
            if agent == '*':
                # we have the catch-all agent
                return True
            if agent.lower() in useragent:
                return True
        return False

    def allowance (self, filename):
        """Preconditions:
        - our agent applies to this entry
        - filename is URL decoded

        Check if given filename is allowed to acces this entry.

        @return: True if allowed, else False
        @rtype: bool
        """
        for line in self.rulelines:
            log.debug(LOG_CHECK, "%s %s %s", filename, str(line), line.allowance)
            if line.applies_to(filename):
                log.debug(LOG_CHECK, " ... rule line %s", line)
                return line.allowance
        log.debug(LOG_CHECK, " ... no rule lines of %s applied to %s; allowed.", self.useragents, filename)
        return True

########NEW FILE########
__FILENAME__ = socketutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2008-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import socket


# test for IPv6, both in Python build and in kernel build
has_ipv6 = False
if socket.has_ipv6:
    # python has ipv6 compiled in, but the operating system also
    # has to support it.
    try:
        socket.socket(socket.AF_INET6, socket.SOCK_STREAM).close()
        has_ipv6 = True
    except socket.error as msg:
        # only catch these one:
        # socket.error: (97, 'Address family not supported by protocol')
        # socket.error: (10047, 'Address family not supported by protocol')
        # socket.error: (43, 'Protocol not supported')
        if msg.args[0] not in (97, 10047, 43):
            raise


def create_socket (family, socktype, proto=0, timeout=60):
    """
    Create a socket with given family and type. If SSL context
    is given an SSL socket is created.
    """
    sock = socket.socket(family, socktype, proto=proto)
    sock.settimeout(timeout)
    socktypes_inet = [socket.AF_INET]
    if has_ipv6:
        socktypes_inet.append(socket.AF_INET6)
    if family in socktypes_inet and socktype == socket.SOCK_STREAM:
        # disable NAGLE algorithm, which means sending pending data
        # immediately, possibly wasting bandwidth but improving
        # responsiveness for fast networks
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    return sock

########NEW FILE########
__FILENAME__ = strformat
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Some functions have been taken and adjusted from the quodlibet
# source. Quodlibet is (C) 2004-2005 Joe Wreschnig, Michael Urman
# and licensed under the GNU General Public License version 2.
"""
Various string utility functions. Note that these functions are not
necessarily optimised for large strings, so use with care.
"""
# some handy time constants
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 60 * SECONDS_PER_MINUTE
SECONDS_PER_DAY = 24 * SECONDS_PER_HOUR

import re
import textwrap
import codecs
import os
import math
import time
import urlparse
import locale
import pydoc
from . import i18n


def unicode_safe (s, encoding=i18n.default_encoding, errors='replace'):
    """Get unicode string without raising encoding errors. Unknown
    characters of the given encoding will be ignored.

    @param s: the string to be decoded
    @type s: any object except None
    @return: if s is already unicode, return s unchanged; else return
        decoded unicode string of str(s)
    @rtype: unicode
    """
    assert s is not None, "argument to unicode_safe was None"
    if isinstance(s, unicode):
        # s is already unicode, nothing to do
        return s
    return unicode(str(s), encoding, errors)


def ascii_safe (s):
    """Get ASCII string without raising encoding errors. Unknown
    characters of the given encoding will be ignored.

    @param s: the Unicode string to be encoded
    @type s: unicode or None
    @return: encoded ASCII version of s, or None if s was None
    @rtype: string
    """
    if isinstance(s, unicode):
        s = s.encode('ascii', 'ignore')
    return s


def is_ascii (s):
    """Test if a string can be encoded in ASCII."""
    try:
        s.encode('ascii', 'strict')
        return True
    except (UnicodeEncodeError, UnicodeDecodeError):
        return False


def is_encoding (text):
    """Check if string is a valid encoding."""
    try:
        return codecs.lookup(text)
    except (LookupError, ValueError):
        return False


def url_unicode_split (url):
    """Like urlparse.urlsplit(), but always returning unicode parts."""
    return [unicode_safe(s) for s in urlparse.urlsplit(url)]


def unquote (s, matching=False):
    """Remove leading and ending single and double quotes.
    The quotes need to match if matching is True. Only one quote from each
    end will be stripped.

    @return: if s evaluates to False, return s as is, else return
        string with stripped quotes
    @rtype: unquoted string, or s unchanged if it is evaluting to False
    """
    if not s:
        return s
    if len(s) < 2:
        return s
    if matching:
        if s[0] in ("\"'") and s[0] == s[-1]:
            s = s[1:-1]
    else:
        if s[0] in ("\"'"):
            s = s[1:]
        if s[-1] in ("\"'"):
            s = s[:-1]
    return s


_para_mac = r"(?:%(sep)s)(?:(?:%(sep)s)\s*)+" % {'sep': '\r'}
_para_posix = r"(?:%(sep)s)(?:(?:%(sep)s)\s*)+" % {'sep': '\n'}
_para_win = r"(?:%(sep)s)(?:(?:%(sep)s)\s*)+" % {'sep': '\r\n'}
_para_ro = re.compile("%s|%s|%s" % (_para_mac, _para_posix, _para_win))

def get_paragraphs (text):
    """A new paragraph is considered to start at a line which follows
    one or more blank lines (lines containing nothing or just spaces).
    The first line of the text also starts a paragraph."""
    if not text:
        return []
    return _para_ro.split(text)


def wrap (text, width, **kwargs):
    """Adjust lines of text to be not longer than width. The text will be
    returned unmodified if width <= 0.
    See textwrap.wrap() for a list of supported kwargs.
    Returns text with lines no longer than given width."""
    if width <= 0 or not text:
        return text
    ret = []
    for para in get_paragraphs(text):
        text = " ".join(para.strip().split())
        ret.extend(textwrap.wrap(text, width, **kwargs))
    return os.linesep.join(ret)


def indent (text, indent_string="  "):
    """Indent each line of text with the given indent string."""
    lines = str(text).splitlines()
    return os.linesep.join("%s%s" % (indent_string, x) for x in lines)


def get_line_number (s, index):
    r"""Return the line number of s[index] or zero on errors.
    Lines are assumed to be separated by the ASCII character '\n'."""
    i = 0
    if index < 0:
        return 0
    line = 1
    while i < index:
        if s[i] == '\n':
            line += 1
        i += 1
    return line


def paginate (text):
    """Print text in pages of lines."""
    pydoc.pager(text)


_markup_re = re.compile("<.*?>", re.DOTALL)

def remove_markup (s):
    """Remove all <*> html markup tags from s."""
    mo = _markup_re.search(s)
    while mo:
        s = s[0:mo.start()] + s[mo.end():]
        mo = _markup_re.search(s)
    return s


def strsize (b, grouping=True):
    """Return human representation of bytes b. A negative number of bytes
    raises a value error."""
    if b < 0:
        raise ValueError("Invalid negative byte number")
    if b < 1024:
        return u"%sB" % locale.format("%d", b, grouping)
    if b < 1024 * 10:
        return u"%sKB" % locale.format("%d", (b // 1024), grouping)
    if b < 1024 * 1024:
        return u"%sKB" % locale.format("%.2f", (float(b) / 1024), grouping)
    if b < 1024 * 1024 * 10:
        return u"%sMB" % locale.format("%.2f", (float(b) / (1024*1024)), grouping)
    if b < 1024 * 1024 * 1024:
        return u"%sMB" % locale.format("%.1f", (float(b) / (1024*1024)), grouping)
    if b < 1024 * 1024 * 1024 * 10:
        return u"%sGB" % locale.format("%.2f", (float(b) / (1024*1024*1024)), grouping)
    return u"%sGB" % locale.format("%.1f", (float(b) / (1024*1024*1024)), grouping)


def strtime (t, func=time.localtime):
    """Return ISO 8601 formatted time."""
    return time.strftime("%Y-%m-%d %H:%M:%S", func(t)) + strtimezone()


# from quodlibet
def strduration (duration):
    """Turn a time value in seconds into hh:mm:ss or mm:ss."""
    if duration < 0:
        duration = abs(duration)
        prefix = "-"
    else:
        prefix = ""
    duration = math.ceil(duration)
    if duration >= SECONDS_PER_HOUR: # 1 hour
        # time, in hours:minutes:seconds
        return "%s%02d:%02d:%02d" % (prefix, duration // SECONDS_PER_HOUR,
                                   (duration % SECONDS_PER_HOUR) // SECONDS_PER_MINUTE,
                                    duration % SECONDS_PER_MINUTE)
    else:
        # time, in minutes:seconds
        return "%s%02d:%02d" % (prefix, duration // SECONDS_PER_MINUTE,
                                 duration % SECONDS_PER_MINUTE)


# from quodlibet
def strduration_long (duration, do_translate=True):
    """Turn a time value in seconds into x hours, x minutes, etc."""
    if do_translate:
        # use global translator functions
        global _, _n
    else:
        # do not translate
        _ = lambda x: x
        _n = lambda a, b, n: a if n==1 else b
    if duration < 0:
        duration = abs(duration)
        prefix = "-"
    else:
        prefix = ""
    if duration < 1:
        return _("%(prefix)s%(duration).02f seconds") % \
               {"prefix": prefix, "duration": duration}
    # translation dummies
    _n("%d second", "%d seconds", 1)
    _n("%d minute", "%d minutes", 1)
    _n("%d hour", "%d hours", 1)
    _n("%d day", "%d days", 1)
    _n("%d year", "%d years", 1)
    cutoffs = [
        (60, "%d second", "%d seconds"),
        (60, "%d minute", "%d minutes"),
        (24, "%d hour", "%d hours"),
        (365, "%d day", "%d days"),
        (None, "%d year", "%d years"),
    ]
    time_str = []
    for divisor, single, plural in cutoffs:
        if duration < 1:
            break
        if divisor is None:
            duration, unit = 0, duration
        else:
            duration, unit = divmod(duration, divisor)
        if unit:
            time_str.append(_n(single, plural, unit) % unit)
    time_str.reverse()
    if len(time_str) > 2:
        time_str.pop()
    return "%s%s" % (prefix, ", ".join(time_str))


def strtimezone ():
    """Return timezone info, %z on some platforms, but not supported on all.
    """
    if time.daylight:
        zone = time.altzone
    else:
        zone = time.timezone
    return "%+04d" % (-zone//SECONDS_PER_HOUR)


def stripurl(s):
    """Remove any lines from string after the first line.
    Also remove whitespace at start and end from given string."""
    if not s:
        return s
    return s.splitlines()[0].strip()


def limit (s, length=72):
    """If the length of the string exceeds the given limit, it will be cut
    off and three dots will be appended.

    @param s: the string to limit
    @type s: string
    @param length: maximum length
    @type length: non-negative integer
    @return: limited string, at most length+3 characters long
    """
    assert length >= 0, "length limit must be a non-negative integer"
    if not s or len(s) <= length:
        return s
    if length == 0:
        return ""
    return "%s..." % s[:length]


def strline (s):
    """Display string representation on one line."""
    return strip_control_chars(u"`%s'" % unicode(s).replace(u"\n", u"\\n"))


def format_feature_warning (**kwargs):
    """Format warning that a module could not be imported and that it should
    be installed for a certain URL.
    """
    return _("Could not import %(module)s for %(feature)s. Install %(module)s from %(url)s to use this feature.") % kwargs


def strip_control_chars(text):
    """Remove console control characters from text."""
    if text:
        return re.sub(r"[\x01-\x1F\x7F]", "", text)
    return text

########NEW FILE########
__FILENAME__ = threader
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Support for managing threads.
"""
import threading


class StoppableThread (threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__ (self):
        """Store stop event."""
        super(StoppableThread, self).__init__()
        self._stop = threading.Event()

    def stop (self):
        """Set stop event."""
        self._stop.set()

    def stopped (self, timeout=None):
        """Return True if stop event is set."""
        return self._stop.wait(timeout)

########NEW FILE########
__FILENAME__ = trace
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
from __future__ import print_function
import re
import linecache
import time
import sys
import thread
import threading

# tracing
_trace_ignore = set()
_trace_filter = set()


def trace_ignore (names):
    """Add given names to trace ignore set, or clear set if names is None."""
    if names is None:
        _trace_ignore.clear()
    else:
        _trace_ignore.update(names)


def trace_filter (patterns):
    """Add given patterns to trace filter set or clear set if patterns is
    None."""
    if patterns is None:
        _trace_filter.clear()
    else:
        _trace_filter.update(re.compile(pat) for pat in patterns)


def _trace (frame, event, arg):
    """Trace function calls."""
    if event in ('call', 'c_call'):
        _trace_line(frame, event, arg)
    elif event in ('return', 'c_return'):
        _trace_line(frame, event, arg)
        print("  return:", arg)
    #elif event in ('exception', 'c_exception'):
    #    _trace_line(frame, event, arg)
    return _trace


def _trace_full (frame, event, arg):
    """Trace every executed line."""
    if event == "line":
        _trace_line(frame, event, arg)
    else:
        _trace(frame, event, arg)
    return _trace_full


def _trace_line (frame, event, arg):
    """Print current executed line."""
    name = frame.f_globals["__name__"]
    if name in _trace_ignore:
        return _trace_line
    for pat in _trace_filter:
        if not pat.match(name):
            return _trace_line
    lineno = frame.f_lineno
    filename = frame.f_globals["__file__"]
    if filename.endswith((".pyc", ".pyo")):
        filename = filename[:-1]
    line = linecache.getline(filename, lineno)
    tid = thread.get_ident()
    tname = threading.currentThread().getName()
    args = (tid, tname, time.time(), line.rstrip(), name, lineno)
    print("THREAD(%d) %r %.2f %s # %s:%d" % args)


def trace_on (full=False):
    """Start tracing of the current thread (and the current thread only)."""
    if full:
        sys.settrace(_trace_full)
    else:
        sys.settrace(_trace)


def trace_off ():
    """Stop tracing of the current thread (and the current thread only)."""
    sys.settrace(None)

########NEW FILE########
__FILENAME__ = updater
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Function to check for updates.
"""

import os
from .configuration import Version as CurrentVersion
from .url import get_content
from distutils.version import StrictVersion

# Use the Freecode submit file as source since that file gets updated
# only when releasing a new version.
UPDATE_URL = "https://raw.github.com/wummel/linkchecker/master/linkchecker.freecode"
VERSION_TAG = 'Version:'
if os.name == 'nt':
    URL_TAG = 'Windows-installer-URL:'
else:
    URL_TAG = 'Source-Package-URL:'


def check_update ():
    """Return the following values:
       (False, errmsg) - online version could not be determined
       (True, None) - user has newest version
       (True, (version, url string)) - update available
       (True, (version, None)) - current version is newer than online version
    """
    version, value = get_online_version()
    if version is None:
        # value is an error message
        return False, value
    if version == CurrentVersion:
        # user has newest version
        return True, None
    if is_newer_version(version):
        # value is an URL linking to the update package
        return True, (version, value)
    # user is running a local or development version
    return True, (version, None)


def get_online_version ():
    """Download update info and parse it."""
    # prevent getting a cached answer
    headers = {'Pragma': 'no-cache', 'Cache-Control': 'no-cache'}
    content, info = get_content(UPDATE_URL, addheaders=headers)
    if content is None:
        return content, info
    version, url = None, None
    for line in content.splitlines():
        if line.startswith(VERSION_TAG):
            version = line.split(':', 1)[1].strip()
        elif line.startswith(URL_TAG):
            url = line.split(':', 1)[1].strip()
            url = url.replace('${version}', version)
    return version, url


def is_newer_version (version):
    """Check if given version is newer than current version."""
    return StrictVersion(version) > StrictVersion(CurrentVersion)

########NEW FILE########
__FILENAME__ = url
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Functions for parsing and matching URL strings.
"""

import re
import os
import urlparse
import urllib
import requests
from . import log, LOG_CHECK

for scheme in ('ldap', 'irc'):
    if scheme not in urlparse.uses_netloc:
        urlparse.uses_netloc.append(scheme)

# The character set to encode non-ASCII characters in a URL. See also
# http://tools.ietf.org/html/rfc2396#section-2.1
# Note that the encoding is not really specified, but most browsers
# encode in UTF-8 when no encoding is specified by the HTTP headers,
# else they use the page encoding for followed link. See als
# http://code.google.com/p/browsersec/wiki/Part1#Unicode_in_URLs
url_encoding = "utf-8"


# constants defining url part indexes
SCHEME = 0
HOSTNAME = DOMAIN = 1
PORT = 2
DOCUMENT = 3

default_ports = {
    'http': 80,
    'https': 443,
    'nntps': 563,
    'ftp': 21,
}

# adapted from David Wheelers "Secure Programming for Linux and Unix HOWTO"
# http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/\
# filter-html.html#VALIDATING-URIS
_basic = {
    "_path": r"\-\_\.\!\~\*\'\(\),",
    "_hex_safe": r"2-9a-f",
    "_hex_full": r"0-9a-f",
    "_part": r"([a-z0-9][-a-z0-9]{0,61}|[a-z])",
}
_safe_char = r"([a-z0-9%(_path)s\+]|"\
             r"(%%[%(_hex_safe)s][%(_hex_full)s]))" % _basic
_safe_scheme_pattern = r"(https?|ftp)"
_safe_domain_pattern = r"(%(_part)s(\.%(_part)s)*\.?)" % _basic
_safe_host_pattern = _safe_domain_pattern+r"(:(80|8080|8000|443))?" % _basic
_safe_path_pattern = r"((/([a-z0-9%(_path)s]|"\
                     r"(%%[%(_hex_safe)s][%(_hex_full)s]))+)*/?)" % _basic
_safe_fragment_pattern = r"%s*" % _safe_char
_safe_cgi = r"%s+(=(%s|/)+)?" % (_safe_char, _safe_char)
_safe_query_pattern = r"(%s(&%s)*)?" % (_safe_cgi, _safe_cgi)
_safe_param_pattern = r"(%s(;%s)*)?" % (_safe_cgi, _safe_cgi)
safe_url_pattern = r"%s://%s%s(#%s)?" % \
    (_safe_scheme_pattern, _safe_host_pattern,
     _safe_path_pattern, _safe_fragment_pattern)

is_safe_char = re.compile("(?i)^%s$" % _safe_char).match
is_safe_url = re.compile("(?i)^%s$" % safe_url_pattern).match
is_safe_domain = re.compile("(?i)^%s$" % _safe_domain_pattern).match
is_safe_host = re.compile("(?i)^%s$" % _safe_host_pattern).match
is_safe_path = re.compile("(?i)^%s$" % _safe_path_pattern).match
is_safe_parameter = re.compile("(?i)^%s$" % _safe_param_pattern).match
is_safe_query = re.compile("(?i)^%s$" % _safe_query_pattern).match
is_safe_fragment = re.compile("(?i)^%s$" % _safe_fragment_pattern).match


# snatched form urlparse.py
def splitparams (path):
    """Split off parameter part from path.
    Returns tuple (path-without-param, param)
    """
    if '/' in path:
        i = path.find(';', path.rfind('/'))
    else:
        i = path.find(';')
    if i < 0:
        return path, ''
    return path[:i], path[i+1:]


def is_numeric_port (portstr):
    """return: integer port (== True) iff portstr is a valid port number,
           False otherwise
    """
    if portstr.isdigit():
        port = int(portstr)
        # 65536 == 2**16
        if 0 < port < 65536:
            return port
    return False


def safe_host_pattern (host):
    """Return regular expression pattern with given host for URL testing."""
    return "(?i)%s://%s%s(#%s)?" % \
     (_safe_scheme_pattern, host, _safe_path_pattern, _safe_fragment_pattern)


def parse_qsl (qs, keep_blank_values=0, strict_parsing=0):
    """Parse a query given as a string argument.

    @param qs: URL-encoded query string to be parsed
    @type qs: string
    @param keep_blank_values: flag indicating whether blank values in
        URL encoded queries should be treated as blank strings.  A
        true value indicates that blanks should be retained as blank
        strings.  The default false value indicates that blank values
        are to be ignored and treated as if they were  not included.
    @type keep_blank_values: bool
    @param strict_parsing: flag indicating what to do with parsing errors. If
        false (the default), errors are silently ignored. If true,
        errors raise a ValueError exception.
    @type strict_parsing: bool
    @returns: list of triples (key, value, separator) where key and value
      are the splitted CGI parameter and separator the used separator
      for this CGI parameter which is either a semicolon or an ampersand
    @rtype: list of triples
    """
    pairs = []
    name_value_amp = qs.split('&')
    for name_value in name_value_amp:
        if ';' in name_value:
            pairs.extend([x, ';'] for x in name_value.split(';'))
            pairs[-1][1] = '&'
        else:
            pairs.append([name_value, '&'])
    pairs[-1][1] = ''
    r = []
    for name_value, sep in pairs:
        nv = name_value.split('=', 1)
        if len(nv) != 2:
            if strict_parsing:
                raise ValueError("bad query field: %r" % name_value)
            elif len(nv) == 1:
                # None value indicates missing equal sign
                nv = (nv[0], None)
            else:
                continue
        if nv[1] or keep_blank_values:
            name = urllib.unquote(nv[0].replace('+', ' '))
            if nv[1]:
                value = urllib.unquote(nv[1].replace('+', ' '))
            else:
                value = nv[1]
            r.append((name, value, sep))
    return r


def idna_encode (host):
    """Encode hostname as internationalized domain name (IDN) according
    to RFC 3490.
    @raise: UnicodeError if hostname is not properly IDN encoded.
    """
    if host and isinstance(host, unicode):
        try:
            host.encode('ascii')
            return host, False
        except UnicodeError:
            uhost = host.encode('idna').decode('ascii')
            return uhost, uhost != host
    return host, False


def url_fix_host (urlparts):
    """Unquote and fix hostname. Returns is_idn."""
    if not urlparts[1]:
        urlparts[2] = urllib.unquote(urlparts[2])
        return False
    userpass, netloc = urllib.splituser(urlparts[1])
    if userpass:
        userpass = urllib.unquote(userpass)
    netloc, is_idn = idna_encode(urllib.unquote(netloc).lower())
    # a leading backslash in path causes urlsplit() to add the
    # path components up to the first slash to host
    # try to find this case...
    i = netloc.find("\\")
    if i != -1:
        # ...and fix it by prepending the misplaced components to the path
        comps = netloc[i:] # note: still has leading backslash
        if not urlparts[2] or urlparts[2] == '/':
            urlparts[2] = comps
        else:
            urlparts[2] = "%s%s" % (comps, urllib.unquote(urlparts[2]))
        netloc = netloc[:i]
    else:
        # a leading ? in path causes urlsplit() to add the query to the
        # host name
        i = netloc.find("?")
        if i != -1:
            netloc, urlparts[3] = netloc.split('?', 1)
        # path
        urlparts[2] = urllib.unquote(urlparts[2])
    if userpass:
        # append AT for easy concatenation
        userpass += "@"
    else:
        userpass = ""
    if urlparts[0] in default_ports:
        dport = default_ports[urlparts[0]]
        host, port = splitport(netloc, port=dport)
        if host.endswith("."):
            host = host[:-1]
        if port != dport:
            host = "%s:%d" % (host, port)
        netloc = host
    urlparts[1] = userpass+netloc
    return is_idn


def url_fix_common_typos (url):
    """Fix common typos in given URL like forgotten colon."""
    if url.startswith("http//"):
        url = "http://" + url[6:]
    elif url.startswith("https//"):
        url = "https://" + url[7:]
    return url


def url_fix_mailto_urlsplit (urlparts):
    """Split query part of mailto url if found."""
    if "?" in urlparts[2]:
        urlparts[2], urlparts[3] = urlparts[2].split('?', 1)


def url_parse_query (query, encoding=None):
    """Parse and re-join the given CGI query."""
    if isinstance(query, unicode):
        if encoding is None:
            encoding = url_encoding
        query = query.encode(encoding, 'ignore')
    # if ? is in the query, split it off, seen at msdn.microsoft.com
    append = ""
    while '?' in query:
        query, rest = query.rsplit('?', 1)
        append = '?'+url_parse_query(rest)+append
    l = []
    for k, v, sep in parse_qsl(query, True):
        k = url_quote_part(k, '/-:,;')
        if v:
            v = url_quote_part(v, '/-:,;')
            l.append("%s=%s%s" % (k, v, sep))
        elif v is None:
            l.append("%s%s" % (k, sep))
        else:
            # some sites do not work when the equal sign is missing
            l.append("%s=%s" % (k, sep))
    return ''.join(l) + append


def urlunsplit (urlparts):
    """Same as urlparse.urlunsplit but with extra UNC path handling
    for Windows OS."""
    res = urlparse.urlunsplit(urlparts)
    if os.name == 'nt' and urlparts[0] == 'file' and '|' not in urlparts[2]:
        # UNC paths must have 4 slashes: 'file:////server/path'
        # Depending on the path in urlparts[2], urlparse.urlunsplit()
        # left only two or three slashes. This is fixed below
        repl = 'file://' if urlparts[2].startswith('//') else 'file:/'
        res = res.replace('file:', repl)
    return res


def url_norm (url, encoding=None):
    """Normalize the given URL which must be quoted. Supports unicode
    hostnames (IDNA encoding) according to RFC 3490.

    @return: (normed url, idna flag)
    @rtype: tuple of length two
    """
    if isinstance(url, unicode):
        # try to decode the URL to ascii since urllib.unquote()
        # handles non-unicode strings differently
        try:
            url = url.encode('ascii')
        except UnicodeEncodeError:
            pass
        encode_unicode = True
    else:
        encode_unicode = False
    urlparts = list(urlparse.urlsplit(url))
    # scheme
    urlparts[0] = urllib.unquote(urlparts[0]).lower()
    # mailto: urlsplit is broken
    if urlparts[0] == 'mailto':
        url_fix_mailto_urlsplit(urlparts)
    # host (with path or query side effects)
    is_idn = url_fix_host(urlparts)
    # query
    urlparts[3] = url_parse_query(urlparts[3], encoding=encoding)
    if urlparts[0] in urlparse.uses_relative:
        # URL has a hierarchical path we should norm
        if not urlparts[2]:
            # Empty path is allowed if both query and fragment are also empty.
            # Note that in relative links, urlparts[0] might be empty.
            # In this case, do not make any assumptions.
            if urlparts[0] and (urlparts[3] or urlparts[4]):
                urlparts[2] = '/'
        else:
            # fix redundant path parts
            urlparts[2] = collapse_segments(urlparts[2])
    # anchor
    urlparts[4] = urllib.unquote(urlparts[4])
    # quote parts again
    urlparts[0] = url_quote_part(urlparts[0], encoding=encoding) # scheme
    urlparts[1] = url_quote_part(urlparts[1], safechars='@:', encoding=encoding) # host
    urlparts[2] = url_quote_part(urlparts[2], safechars=_nopathquote_chars, encoding=encoding) # path
    urlparts[4] = url_quote_part(urlparts[4], encoding=encoding) # anchor
    res = urlunsplit(urlparts)
    if url.endswith('#') and not urlparts[4]:
        # re-append trailing empty fragment
        res += '#'
    if encode_unicode:
        res = unicode(res)
    return (res, is_idn)


_slashes_ro = re.compile(r"/+")
_thisdir_ro = re.compile(r"^\./")
_samedir_ro = re.compile(r"/\./|/\.$")
_parentdir_ro = re.compile(r"^/(\.\./)+|/(?!\.\./)[^/]+/\.\.(/|$)")
_relparentdir_ro = re.compile(r"^(?!\.\./)[^/]+/\.\.(/|$)")
def collapse_segments (path):
    """Remove all redundant segments from the given URL path.
    Precondition: path is an unquoted url path"""
    # replace backslashes
    # note: this is _against_ the specification (which would require
    # backslashes to be left alone, and finally quoted with '%5C')
    # But replacing has several positive effects:
    # - Prevents path attacks on Windows systems (using \.. parent refs)
    # - Fixes bad URLs where users used backslashes instead of slashes.
    #   This is a far more probable case than users having an intentional
    #   backslash in the path name.
    path = path.replace('\\', '/')
    # shrink multiple slashes to one slash
    path = _slashes_ro.sub("/", path)
    # collapse redundant path segments
    path = _thisdir_ro.sub("", path)
    path = _samedir_ro.sub("/", path)
    # collapse parent path segments
    # note: here we exploit the fact that the replacements happen
    # to be from left to right (see also _parentdir_ro above)
    newpath = _parentdir_ro.sub("/", path)
    while newpath != path:
        path = newpath
        newpath = _parentdir_ro.sub("/", path)
    # collapse parent path segments of relative paths
    # (ie. without leading slash)
    newpath = _relparentdir_ro.sub("", path)
    while newpath != path:
        path = newpath
        newpath = _relparentdir_ro.sub("", path)
    return path


url_is_absolute = re.compile("^[a-z]+:", re.I).match


def url_quote (url):
    """Quote given URL."""
    if not url_is_absolute(url):
        return document_quote(url)
    urlparts = list(urlparse.urlsplit(url))
    urlparts[0] = url_quote_part(urlparts[0]) # scheme
    urlparts[1] = url_quote_part(urlparts[1], ':') # host
    urlparts[2] = url_quote_part(urlparts[2], '/=,') # path
    urlparts[3] = url_quote_part(urlparts[3], '&=,') # query
    l = []
    for k, v, sep in parse_qsl(urlparts[3], True): # query
        k = url_quote_part(k, '/-:,;')
        if v:
            v = url_quote_part(v, '/-:,;')
            l.append("%s=%s%s" % (k, v, sep))
        else:
            l.append("%s%s" % (k, sep))
    urlparts[3] = ''.join(l)
    urlparts[4] = url_quote_part(urlparts[4]) # anchor
    return urlunsplit(urlparts)


def url_quote_part (s, safechars='/', encoding=None):
    """Wrap urllib.quote() to support unicode strings. A unicode string
    is first converted to UTF-8. After that urllib.quote() is called."""
    if isinstance(s, unicode):
        if encoding is None:
            encoding = url_encoding
        s = s.encode(encoding, 'ignore')
    return urllib.quote(s, safechars)

def document_quote (document):
    """Quote given document."""
    doc, query = urllib.splitquery(document)
    doc = url_quote_part(doc, '/=,')
    if query:
        return "%s?%s" % (doc, query)
    return doc


def match_url (url, domainlist):
    """Return True if host part of url matches an entry in given domain list.
    """
    if not url:
        return False
    return match_host(url_split(url)[1], domainlist)


def match_host (host, domainlist):
    """Return True if host matches an entry in given domain list."""
    if not host:
        return False
    for domain in domainlist:
        if domain.startswith('.'):
            if host.endswith(domain):
                return True
        elif host == domain:
            return True
    return False


_nopathquote_chars = "-;/=,~*+()@!"
if os.name == 'nt':
    _nopathquote_chars += "|"
_safe_url_chars = re.escape(_nopathquote_chars + "_:.&#%?[]!")+"a-zA-Z0-9"
_safe_url_chars_ro = re.compile(r"^[%s]*$" % _safe_url_chars)
def url_needs_quoting (url):
    """Check if url needs percent quoting. Note that the method does
    only check basic character sets, and not any other syntax.
    The URL might still be syntactically incorrect even when
    it is properly quoted.
    """
    if url.rstrip() != url:
        # handle trailing whitespace as a special case
        # since '$' matches immediately before a end-of-line
        return True
    return not _safe_url_chars_ro.match(url)


def url_split (url):
    """Split url in a tuple (scheme, hostname, port, document) where
    hostname is always lowercased.
    Precondition: url is syntactically correct URI (eg has no whitespace)
    """
    scheme, netloc = urllib.splittype(url)
    host, document = urllib.splithost(netloc)
    port = default_ports.get(scheme, 0)
    if host:
        host = host.lower()
        host, port = splitport(host, port=port)
    return scheme, host, port, document


def url_unsplit (parts):
    """Rejoin URL parts to a string."""
    if parts[2] == default_ports.get(parts[0]):
        return "%s://%s%s" % (parts[0], parts[1], parts[3])
    return "%s://%s:%d%s" % parts


def splitport (host, port=0):
    """Split optional port number from host. If host has no port number,
    the given default port is returned.

    @param host: host name
    @ptype host: string
    @param port: the port number (default 0)
    @ptype port: int

    @return: tuple of (host, port)
    @rtype: tuple of (string, int)
    """
    if ":" in host:
        shost, sport = host.split(":", 1)
        iport = is_numeric_port(sport)
        if iport:
            host, port = shost, iport
        elif not sport:
            # empty port, ie. the host was "hostname:"
            host = shost
        else:
            # For an invalid non-empty port leave the host name as is
            pass
    return host, port


def get_content(url, user=None, password=None, proxy=None, data=None,
                addheaders=None):
    """Get URL content and info.

    @return: (decoded text content of URL, headers) or
             (None, errmsg) on error.
    @rtype: tuple (String, dict) or (None, String)
    """
    from . import configuration
    headers = {
        'User-Agent': configuration.UserAgent,
    }
    if addheaders:
        headers.update(addheaders)
    method = 'GET'
    kwargs = dict(headers=headers)
    if user and password:
        kwargs['auth'] = (user, password)
    if data:
        kwargs['data'] = data
        method = 'POST'
    if proxy:
        kwargs['proxy'] = dict(http=proxy)
    from .configuration import get_share_file
    try:
        kwargs["verify"] = get_share_file('cacert.pem')
    except ValueError:
        pass
    try:
        response = requests.request(method, url, **kwargs)
        return response.text, response.headers
    except (requests.exceptions.RequestException,
            requests.exceptions.BaseHTTPError) as msg:
        log.warn(LOG_CHECK, ("Could not get content of URL %(url)s: %(msg)s.") \
          % {"url": url, "msg": str(msg)})
        return None, str(msg)


def shorten_duplicate_content_url(url):
    """Remove anchor part and trailing index.html from URL."""
    if '#' in url:
        url = url.split('#', 1)[0]
    if url.endswith('index.html'):
        return url[:-10]
    if url.endswith('index.htm'):
        return url[:-9]
    return url


def is_duplicate_content_url(url1, url2):
    """Check if both URLs are allowed to point to the same content."""
    if url1 == url2:
        return True
    if url2 in url1:
        url1 = shorten_duplicate_content_url(url1)
        if not url2.endswith('/') and url1.endswith('/'):
            url2 += '/'
        return url1 == url2
    if url1 in url2:
        url2 = shorten_duplicate_content_url(url2)
        if not url1.endswith('/') and url2.endswith('/'):
            url1 += '/'
        return url1 == url2
    return False

########NEW FILE########
__FILENAME__ = winutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Windows utility functions."""

def get_shell_folder (name):
    """Get Windows Shell Folder locations from the registry."""
    try:
        import _winreg as winreg
    except ImportError:
        import winreg
    lm = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
    try:
        key = winreg.OpenKey(lm, r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
        try:
            return winreg.QueryValueEx(key, name)[0]
        finally:
            key.Close()
    finally:
        lm.Close()

########NEW FILE########
__FILENAME__ = msgfmt
# -*- coding: iso-8859-1 -*-
# License: Python license
# Copyright by Martin v. Lwis <loewis@informatik.hu-berlin.de>
# Plural forms support added by alexander smishlajev <alex@tycobka.lv>
"""
Generate binary message catalog from textual translation description.

This program converts a textual Uniforum-style message catalog (.po file) into
a binary GNU catalog (.mo file).  This is essentially the same function as the
GNU msgfmt program, however, it is a simpler implementation.

Usage: msgfmt.py [OPTIONS] filename.po

Options:
    -o file
    --output-file=file
        Specify the output file to write to.  If omitted, output will go to a
        file named filename.mo (based off the input file name).

    -h
    --help
        Print this message and exit.

    -V
    --version
        Display version information and exit.
"""

import sys
import os
import getopt
import struct
import array

__version__ = "1.1"

MESSAGES = {}


def usage (ecode, msg=''):
    """Print usage and msg and exit with given code."""
    print >> sys.stderr, __doc__
    if msg:
        print >> sys.stderr, msg
    sys.exit(ecode)


def add (msgid, transtr, fuzzy):
    """Add a non-fuzzy translation to the dictionary."""
    if not fuzzy and transtr and not transtr.startswith('\0'):
        MESSAGES[msgid] = transtr


def generate ():
    """Return the generated output."""
    keys = MESSAGES.keys()
    # the keys are sorted in the .mo file
    keys.sort()
    offsets = []
    ids = strs = ''
    for _id in keys:
        # For each string, we need size and file offset.  Each string is NUL
        # terminated; the NUL does not count into the size.
        offsets.append((len(ids), len(_id), len(strs), len(MESSAGES[_id])))
        ids += _id + '\0'
        strs += MESSAGES[_id] + '\0'
    # The header is 7 32-bit unsigned integers.  We don't use hash tables, so
    # the keys start right after the index tables.
    # translated string.
    keystart = 7*4+16*len(keys)
    # and the values start after the keys
    valuestart = keystart + len(ids)
    koffsets = []
    voffsets = []
    # The string table first has the list of keys, then the list of values.
    # Each entry has first the size of the string, then the file offset.
    for o1, l1, o2, l2 in offsets:
        koffsets += [l1, o1+keystart]
        voffsets += [l2, o2+valuestart]
    offsets = koffsets + voffsets
    output = struct.pack("Iiiiiii",
                         0x950412deL,       # Magic
                         0,                 # Version
                         len(keys),         # # of entries
                         7*4,               # start of key index
                         7*4+len(keys)*8,   # start of value index
                         0, 0)              # size and offset of hash table
    output += array.array("i", offsets).tostring()
    output += ids
    output += strs
    return output


def make (filename, outfile):
    ID = 1
    STR = 2
    MESSAGES.clear()

    # Compute .mo name from .po name and arguments
    if filename.endswith('.po'):
        infile = filename
    else:
        infile = filename + '.po'
    if outfile is None:
        outfile = os.path.splitext(infile)[0] + '.mo'

    try:
        lines = open(infile).readlines()
    except IOError, msg:
        print >> sys.stderr, msg
        sys.exit(1)

    section = None
    fuzzy = 0

    # Parse the catalog
    msgid = msgstr = ''
    lno = 0
    for l in lines:
        lno += 1
        # If we get a comment line after a msgstr, this is a new entry
        if l[0] == '#' and section == STR:
            add(msgid, msgstr, fuzzy)
            section = None
            fuzzy = 0
        # Record a fuzzy mark
        if l[:2] == '#,' and (l.find('fuzzy') >= 0):
            fuzzy = 1
        # Skip comments
        if l[0] == '#':
            continue
        # Start of msgid_plural section, separate from singular form with \0
        if l.startswith('msgid_plural'):
            msgid += '\0'
            l = l[12:]
        # Now we are in a msgid section, output previous section
        elif l.startswith('msgid'):
            if section == STR:
                add(msgid, msgstr, fuzzy)
            section = ID
            l = l[5:]
            msgid = msgstr = ''
        # Now we are in a msgstr section
        elif l.startswith('msgstr'):
            section = STR
            l = l[6:]
            # Check for plural forms
            if l.startswith('['):
                # Separate plural forms with \0
                if not l.startswith('[0]'):
                    msgstr += '\0'
                # Ignore the index - must come in sequence
                l = l[l.index(']') + 1:]
        # Skip empty lines
        l = l.strip()
        if not l:
            continue
        # XXX: Does this always follow Python escape semantics?
        l = eval(l)
        if section == ID:
            msgid += l
        elif section == STR:
            msgstr += l
        else:
            print >> sys.stderr, 'Syntax error on %s:%d' % (infile, lno), \
                  'before:'
            print >> sys.stderr, l
            sys.exit(1)
    # Add last entry
    if section == STR:
        add(msgid, msgstr, fuzzy)

    # Compute output
    output = generate()

    try:
        open(outfile,"wb").write(output)
    except IOError,msg:
        print >> sys.stderr, msg


def main ():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hVo:',
                                   ['help', 'version', 'output-file='])
    except getopt.error, msg:
        usage(1, msg)

    outfile = None
    # parse options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-V', '--version'):
            print >> sys.stderr, "msgfmt.py", __version__
            sys.exit(0)
        elif opt in ('-o', '--output-file'):
            outfile = arg
    # do it
    if not args:
        print >> sys.stderr, 'No input file given'
        print >> sys.stderr, "Try `msgfmt --help' for more information."
        return

    for filename in args:
        make(filename, outfile)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = analyze_memdump
#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Analyze a memory dump by the meliae module.
"""
import sys
import os
import codecs
import cgi
from linkcheck import strformat

def main (filename):
    om = print_memorydump(filename)
    dirname, basename = os.path.split(filename)
    basename = os.path.splitext(basename)[0]
    basedir = os.path.join(dirname, basename)
    if not os.path.isdir(basedir):
        os.mkdir(basedir)
    write_htmlfiles(om, basedir)

def print_memorydump(filename):
    from meliae import loader
    om = loader.load(filename, collapse=True)
    om.remove_expensive_references()
    print om.summarize()
    return om

def write_htmlfiles(om, basedir):
    om.compute_parents()
    open_files = {}
    for obj in om.objs.itervalues():
        fp = get_file(obj.type_str, open_files, basedir)
        write_html_obj(fp, obj, om.objs)
    close_files(open_files)

def get_file(type_str, open_files, basedir):
    """Get already opened file, or open and initialize a new one."""
    if type_str not in open_files:
        filename = type_str+".html"
        encoding = 'utf-8'
        fd = codecs.open(os.path.join(basedir, filename), 'w', encoding)
        open_files[type_str] = fd
        write_html_header(fd, type_str, encoding)
    return open_files[type_str]

def close_files(open_files):
    for fp in open_files.values():
        write_html_footer(fp)
        fp.close()

HtmlHeader = u"""
<!doctype html>
<head>
    <meta charset="%s">
</head>
<body>
"""

def write_html_header(fp, type_str, encoding):
    fp.write(HtmlHeader % encoding)
    fp.write(u"<h1>Type %s</h1>\n" % type_str)
    fp.write(u"<table><tr><th>Address</th><th>Name</th><th>Size</th><th>Parents</th><th>References</th></tr>\n")

def get_children(obj, objs):
    res = []
    for address in obj.children:
        if address in objs:
            child = objs[address]
            url = u"#%d" % address
            if child.type_str != obj.type_str:
                url = child.type_str + u".html" + url
            entry = u'<a href="%s">%d</a>' % (url, address)
        else:
            entry = u"%d" % address
        res.append(entry)
    return res

def get_parents(obj, objs):
    res = []
    for address in obj.parents:
        if address in objs:
            parent = objs[address]
            url = u"#%d" % address
            if parent.type_str != obj.type_str:
                url = parent.type_str + u".html" + url
            entry = u'<a href="%s">%d</a>' % (url, address)
        else:
            entry = u"%d" % address
        res.append(entry)
    return res

def write_html_obj(fp, obj, objs):
    if obj.value is None:
        value = u"None"
    else:
        value = cgi.escape(str(obj.value))
    attrs = dict(
        address=obj.address,
        size=strformat.strsize(obj.size),
        children=u",".join(get_children(obj, objs)),
        parents=u",".join(get_parents(obj, objs)),
        value=value,
    )
    fp.write(u"<tr><td>%(address)d</td><td>%(value)s</td><td>%(size)s</td><td>%(children)s</td></tr>\n" % attrs)

def write_html_footer(fp):
    fp.write(u"</table></body></html>")

if __name__ == '__main__':
    filename = sys.argv[1]
    main(filename)

########NEW FILE########
__FILENAME__ = debugparse
#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Parse HTML given as file parameter or piped to stdin.
"""
import sys
import os
sys.path.append(os.getcwd())
import linkcheck.HtmlParser.htmlsax
import linkcheck.HtmlParser.htmllib


def main (text):
    parser = linkcheck.HtmlParser.htmlsax.parser()
    handler = linkcheck.HtmlParser.htmllib.HtmlPrinter()
    parser.handler = handler
    # debug lexer
    #parser.debug(1)
    parser.feed(text)
    parser.flush()

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        text = sys.stdin.read()
    else:
        filename = sys.argv[1]
        with open(filename) as fp:
            text = fp.read()
    main(text)

########NEW FILE########
__FILENAME__ = removeafter
#!/usr/bin/env python
# Copyright (C) 2012-2014 Bastian Kleineidam
"""Remove all lines after a given marker line.
"""
from __future__ import print_function
import fileinput
import sys

def main(args):
    """Remove lines after marker."""
    filename = args[0]
    marker = args[1]
    for line in fileinput.input(filename, inplace=1):
        print(line.rstrip())
        if line.startswith(marker):
            break

if __name__ == '__main__':
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = update_iana_uri_schemes
import sys
import re
import csv
import requests

iana_uri_schemes = "https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml"
# CSV format: URI Scheme,Template,Description,Reference
csv_iana_uri_schemes_permanent = 'https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv'
csv_iana_uri_schemes_provisional = 'https://www.iana.org/assignments/uri-schemes/uri-schemes-2.csv'
csv_iana_uri_schemes_historical = 'https://www.iana.org/assignments/uri-schemes/uri-schemes-3.csv'

iana_uri_schemes_permanent = {}
iana_uri_schemes_provisional = {}
iana_uri_schemes_historical = {}
iana_uri_schemes_other = {
    "clsid":      "Microsoft specific",
    "find" :      "Mozilla specific",
    "isbn" :      "ISBN (int. book numbers)",
    "javascript": "JavaScript",
}

filter_uri_schemes_permanent = (
    "file",
    "ftp",
    "http",
    "https",
    "mailto",
    "news",
    "nntp",
)

template = '''
# from %(uri)s
ignored_schemes_permanent = r"""
%(permanent)s
"""

ignored_schemes_provisional = r"""
%(provisional)s
"""

ignored_schemes_historical = r"""
%(historical)s
"""

ignored_schemes_other = r"""
%(other)s
"""

ignored_schemes = "^(%%s%%s%%s%%s)$" %% (
    ignored_schemes_permanent,
    ignored_schemes_provisional,
    ignored_schemes_historical,
    ignored_schemes_other,
)
ignored_schemes_re = re.compile(ignored_schemes, re.VERBOSE)

is_unknown_scheme = ignored_schemes_re.match
'''

def main(args):
    parse_csv_file(csv_iana_uri_schemes_permanent, iana_uri_schemes_permanent)
    parse_csv_file(csv_iana_uri_schemes_provisional, iana_uri_schemes_provisional)
    parse_csv_file(csv_iana_uri_schemes_historical, iana_uri_schemes_historical)
    for scheme in iana_uri_schemes_other:
        if (scheme in iana_uri_schemes_permanent or
            scheme in iana_uri_schemes_provisional or
            scheme in iana_uri_schemes_historical):
            raise ValueError(scheme)
    for scheme in filter_uri_schemes_permanent:
        if scheme in iana_uri_schemes_permanent:
            del iana_uri_schemes_permanent[scheme]
    args = dict(
        uri = iana_uri_schemes,
        permanent = get_regex(iana_uri_schemes_permanent),
        provisional = get_regex(iana_uri_schemes_provisional),
        historical = get_regex(iana_uri_schemes_historical), 
        other = get_regex(iana_uri_schemes_other),
    )
    res = template % args
    print res
    return 0

def get_regex(schemes):
    expr = ["|%s # %s" % (re.escape(scheme).ljust(10), description)
            for scheme, description in sorted(schemes.items())]
    return "\n".join(expr)


def parse_csv_file(url, res):
    """Parse given URL and write res with {scheme -> description}"""
    response = requests.get(url, stream=True)
    reader = csv.reader(response.iter_lines())
    first_row = True
    for row in reader:
        if first_row:
            # skip first row
            first_row = False
        else:
            scheme, template, description, reference = row
            res[scheme] = description

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))


########NEW FILE########
__FILENAME__ = viewprof
#!/usr/bin/env python
"""
View yappi profiling data.

Usage: $0 <filename>
"""
import sys
import yappi

def main(args):
    filename = args[0]
    stats = yappi.YFuncStats()
    stats.add(filename)
    stats.print_all()


if __name__ == '__main__':
   main(sys.argv[1:])


########NEW FILE########
__FILENAME__ = ftpserver
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Define http test support classes for LinkChecker tests.
"""
import os
import time
import threading
import pytest
from ftplib import FTP
from . import LinkCheckTest


TIMEOUT = 5

class FtpServerTest (LinkCheckTest):
    """Start/stop an FTP server that can be used for testing."""

    def __init__ (self, methodName='runTest'):
        """Init test class and store default ftp server port."""
        super(FtpServerTest, self).__init__(methodName=methodName)
        self.host = 'localhost'
        self.port = None

    def setUp (self):
        """Start a new FTP server in a new thread."""
        self.port = start_server(self.host, 0)
        self.assertFalse(self.port is None)

    def tearDown (self):
        """Send stop request to server."""
        try:
            stop_server(self.host, self.port)
        except Exception:
            pass


def start_server (host, port):
    def line_logger(msg):
        if "kill" in msg:
            raise KeyboardInterrupt()

    try:
        from pyftpdlib import ftpserver
    except ImportError:
        pytest.skip("pyftpdlib is not available")
        return
    authorizer = ftpserver.DummyAuthorizer()
    datadir = os.path.join(os.path.dirname(__file__), 'data')
    authorizer.add_anonymous(datadir)

    # Instantiate FTP handler class
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    ftp_handler.timeout = TIMEOUT
    ftpserver.logline = line_logger

    # Define a customized banner (string returned when client connects)
    ftp_handler.banner = "pyftpdlib %s based ftpd ready." % ftpserver.__ver__

    # Instantiate FTP server class and listen to host:port
    address = (host, port)
    server = ftpserver.FTPServer(address, ftp_handler)
    port = server.address[1]
    t = threading.Thread(None, server.serve_forever)
    t.start()
    # wait for server to start up
    tries = 0
    while tries < 5:
        tries += 1
        try:
            ftp = FTP()
            ftp.connect(host, port, TIMEOUT)
            ftp.login()
            ftp.close()
            break
        except:
            time.sleep(0.5)
    return port


def stop_server (host, port):
    """Stop a running FTP server."""
    ftp = FTP()
    ftp.connect(host, port, TIMEOUT)
    ftp.login()
    try:
        ftp.sendcmd("kill")
    except EOFError:
        pass
    ftp.close()

########NEW FILE########
__FILENAME__ = httpserver
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Define http test support classes for LinkChecker tests.
"""

import SimpleHTTPServer
import BaseHTTPServer
import httplib
import time
import threading
import cgi
import urllib
from cStringIO import StringIO
from . import LinkCheckTest


class StoppableHttpRequestHandler (SimpleHTTPServer.SimpleHTTPRequestHandler, object):
    """
    HTTP request handler with QUIT stopping the server.
    """

    def do_QUIT (self):
        """
        Send 200 OK response, and set server.stop to True.
        """
        self.send_response(200)
        self.end_headers()
        self.server.stop = True

    def log_message (self, format, *args):
        """
        Logging is disabled.
        """
        pass

# serve .xhtml files as application/xhtml+xml
StoppableHttpRequestHandler.extensions_map.update({
        '.xhtml': 'application/xhtml+xml',
})


class StoppableHttpServer (BaseHTTPServer.HTTPServer, object):
    """
    HTTP server that reacts to self.stop flag.
    """

    def serve_forever (self):
        """
        Handle one request at a time until stopped.
        """
        self.stop = False
        while not self.stop:
            self.handle_request()


class NoQueryHttpRequestHandler (StoppableHttpRequestHandler):
    """
    Handler ignoring the query part of requests and sending dummy directory
    listings.
    """

    def remove_path_query (self):
        """
        Remove everything after a question mark.
        """
        i = self.path.find('?')
        if i != -1:
            self.path = self.path[:i]

    def get_status(self):
        dummy, status = self.path.rsplit('/', 1)
        status = int(status)
        if status in self.responses:
             return status
        return 500

    def do_GET (self):
        """
        Removes query part of GET request.
        """
        self.remove_path_query()
        if "status/" in self.path:
            status = self.get_status()
            self.send_response(status)
            self.end_headers()
            if  status >= 200 and status not in (204, 304):
                self.wfile.write("testcontent")
        else:
            super(NoQueryHttpRequestHandler, self).do_GET()

    def do_HEAD (self):
        """
        Removes query part of HEAD request.
        """
        self.remove_path_query()
        if "status/" in self.path:
            self.send_response(self.get_status())
            self.end_headers()
        else:
            super(NoQueryHttpRequestHandler, self).do_HEAD()

    def list_directory(self, path):
        """Helper to produce a directory listing (absent index.html).

        Return value is either a file object, or None (indicating an
        error).  In either case, the headers are sent, making the
        interface the same as for send_head().

        """
        f = StringIO()
        f.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">')
        f.write("<html>\n<title>Dummy directory listing</title>\n")
        f.write("<body>\n<h2>Dummy test directory listing</h2>\n")
        f.write("<hr>\n<ul>\n")
        list = ["example1.txt", "example2.html", "example3"]
        for name in list:
            displayname = linkname = name
            f.write('<li><a href="%s">%s</a>\n'
                    % (urllib.quote(linkname), cgi.escape(displayname)))
        f.write("</ul>\n<hr>\n</body>\n</html>\n")
        length = f.tell()
        f.seek(0)
        self.send_response(200)
        encoding = "utf-8"
        self.send_header("Content-type", "text/html; charset=%s" % encoding)
        self.send_header("Content-Length", str(length))
        self.end_headers()
        return f


class HttpServerTest (LinkCheckTest):
    """
    Start/stop an HTTP server that can be used for testing.
    """

    def __init__ (self, methodName='runTest'):
        """
        Init test class and store default http server port.
        """
        super(HttpServerTest, self).__init__(methodName=methodName)
        self.port = None
        self.handler = NoQueryHttpRequestHandler

    def setUp(self):
        """Start a new HTTP server in a new thread."""
        self.port = start_server(self.handler)
        assert self.port is not None

    def tearDown(self):
        """Send QUIT request to http server."""
        stop_server(self.port)

    def get_url(self, filename):
        """Get HTTP URL for filename."""
        return u"http://localhost:%d/tests/checker/data/%s" % (self.port, filename)



def start_server (handler):
    """Start an HTTP server thread and return its port number."""
    server_address = ('localhost', 0)
    handler.protocol_version = "HTTP/1.0"
    httpd = StoppableHttpServer(server_address, handler)
    port = httpd.server_port
    t = threading.Thread(None, httpd.serve_forever)
    t.start()
    # wait for server to start up
    while True:
        try:
            conn = httplib.HTTPConnection("localhost:%d" % port)
            conn.request("GET", "/")
            conn.getresponse()
            break
        except:
            time.sleep(0.5)
    return port


def stop_server (port):
    """Stop an HTTP server thread."""
    conn = httplib.HTTPConnection("localhost:%d" % port)
    conn.request("QUIT", "/")
    conn.getresponse()


def get_cookie (maxage=2000):
    data = (
        ("Comment", "justatest"),
        ("Max-Age", "%d" % maxage),
        ("Path", "/"),
        ("Version", "1"),
        ("Foo", "Bar"),
    )
    return "; ".join('%s="%s"' % (key, value) for key, value in data)


class CookieRedirectHttpRequestHandler (NoQueryHttpRequestHandler):
    """Handler redirecting certain requests, and setting cookies."""

    def end_headers (self):
        """Send cookie before ending headers."""
        self.send_header("Set-Cookie", get_cookie())
        self.send_header("Set-Cookie", get_cookie(maxage=0))
        super(CookieRedirectHttpRequestHandler, self).end_headers()

    def redirect (self):
        """Redirect request."""
        path = self.path.replace("redirect", "newurl")
        self.send_response(302)
        self.send_header("Location", path)
        self.end_headers()

    def redirect_newhost (self):
        """Redirect request to a new host."""
        path = "http://www.example.com/"
        self.send_response(302)
        self.send_header("Location", path)
        self.end_headers()

    def redirect_newscheme (self):
        """Redirect request to a new scheme."""
        if "file" in self.path:
            path = "file:README.md"
        else:
            path = "ftp://example.com/"
        self.send_response(302)
        self.send_header("Location", path)
        self.end_headers()

    def do_GET (self):
        """Handle redirections for GET."""
        if "redirect_newscheme" in self.path:
            self.redirect_newscheme()
        elif "redirect_newhost" in self.path:
            self.redirect_newhost()
        elif "redirect" in self.path:
            self.redirect()
        else:
            super(CookieRedirectHttpRequestHandler, self).do_GET()

    def do_HEAD (self):
        """Handle redirections for HEAD."""
        if "redirect_newscheme" in self.path:
            self.redirect_newscheme()
        elif "redirect_newhost" in self.path:
            self.redirect_newhost()
        elif "redirect" in self.path:
            self.redirect()
        else:
            super(CookieRedirectHttpRequestHandler, self).do_HEAD()

########NEW FILE########
__FILENAME__ = telnetserver
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Define http test support classes for LinkChecker tests.
"""
import sys
import os
import time
import threading
import telnetlib
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "..", "third_party", "miniboa-r42"))
import miniboa
from . import LinkCheckTest


TIMEOUT = 5

class TelnetServerTest (LinkCheckTest):
    """Start/stop a Telnet server that can be used for testing."""

    def __init__ (self, methodName='runTest'):
        """Init test class and store default ftp server port."""
        super(TelnetServerTest, self).__init__(methodName=methodName)
        self.host = 'localhost'
        self.port = None

    def get_url(self, user=None, password=None):
        if user is not None:
            if password is not None:
                netloc = u"%s:%s@%s" % (user, password, self.host)
            else:
                netloc = u"%s@%s" % (user, self.host)
        else:
            netloc = self.host
        return u"telnet://%s:%d" % (netloc, self.port)

    def setUp (self):
        """Start a new Telnet server in a new thread."""
        self.port = start_server(self.host, 0)
        self.assertFalse(self.port is None)

    def tearDown(self):
        """Send QUIT request to telnet server."""
        try:
            stop_server(self.host, self.port)
        except Exception:
            pass


def start_server (host, port):
    # Instantiate Telnet server class and listen to host:port
    clients = []
    def on_connect(client):
        clients.append(client)
        client.send("Telnet test server\n")
    server = miniboa.TelnetServer(port=port, host=host, on_connect=on_connect)
    port = server.server_socket.getsockname()[1]
    t = threading.Thread(None, serve_forever, args=(server, clients))
    t.start()
    # wait for server to start up
    tries = 0
    while tries < 5:
        tries += 1
        try:
            client = telnetlib.Telnet(timeout=TIMEOUT)
            client.open(host, port)
            client.write("exit\n")
            break
        except:
            time.sleep(0.5)
    return port


def stop_server (host, port):
    """Stop a running FTP server."""
    client = telnetlib.Telnet(timeout=TIMEOUT)
    client.open(host, port)
    client.write("stop\n")


def serve_forever(server, clients):
    """Run poll loop for server."""
    while True:
        server.poll()
        for client in clients:
            if client.active and client.cmd_ready:
                if not handle_cmd(client):
                    return

def handle_cmd(client):
    """Handle telnet clients."""
    msg = client.get_command().lower()
    if msg == 'exit':
        client.active = False
    elif msg == 'stop':
        return False
    return True

########NEW FILE########
__FILENAME__ = test_anchor
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test html anchor parsing and checking.
"""
from . import LinkCheckTest


class TestAnchor (LinkCheckTest):
    """
    Test anchor checking of HTML pages.
    """

    def test_anchor (self):
        confargs = {"enabledplugins": ["AnchorCheck"]}
        url = u"file://%(curdir)s/%(datadir)s/anchor.html" % self.get_attrs()
        nurl = self.norm(url)
        anchor = "broken"
        urlanchor = url + "#" + anchor
        resultlines = [
            u"url %s" % urlanchor,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"warning Anchor `%s' not found. Available anchors: `myid:'." % anchor,
            u"valid",
        ]
        self.direct(urlanchor, resultlines, confargs=confargs)


########NEW FILE########
__FILENAME__ = test_base
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test html <base> tag parsing.
"""
from . import LinkCheckTest


class TestBase (LinkCheckTest):
    """
    Test links of base*.html files.
    """

    def test_base1 (self):
        self.file_test("base1.html")

    def test_base2 (self):
        self.file_test("base2.html")

    def test_base3 (self):
        self.file_test("base3.html")

    def test_base4 (self):
        self.file_test("base4.html")

########NEW FILE########
__FILENAME__ = test_bookmarks
# -*- coding: utf-8 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test bookmark file parsing.
"""
from . import LinkCheckTest
from .. import need_network, need_biplist
import os


class TestBookmarks (LinkCheckTest):
    """
    Test bookmark link checking and content parsing.
    """

    @need_network
    def _test_firefox_bookmarks (self):
        # firefox 3 bookmark file parsing
        self.file_test("places.sqlite")

    @need_network
    def _test_opera_bookmarks (self):
        # Opera bookmark file parsing
        self.file_test("opera6.adr")

    @need_network
    def _test_chromium_bookmarks (self):
        # Chromium and Google Chrome bookmark file parsing
        self.file_test("Bookmarks")

    @need_network
    def test_safari_bookmarks_xml (self):
        # Safari bookmark file parsing (for plaintext plist files)
        self.file_test(os.path.join("plist_xml", "Bookmarks.plist"))

    @need_network
    @need_biplist
    def test_safari_bookmarks_binary (self):
        # Safari bookmark file parsing (for binary plist files)
        self.file_test(os.path.join("plist_binary", "Bookmarks.plist"))

########NEW FILE########
__FILENAME__ = test_error
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test error checking.
"""
from . import LinkCheckTest


class TestError (LinkCheckTest):
    """
    Test unrecognized or syntactically wrong links.
    """

    def test_unrecognized (self):
        # Unrecognized scheme
        url = u"hutzli:"
        attrs = self.get_attrs(url=url)
        attrs['nurl'] = self.norm("file://%(curdir)s/%(url)s" % attrs)
        resultlines = [
            u"url file://%(curdir)s/%(url)s" % attrs,
            u"cache key %(nurl)s" % attrs,
            u"real url %(nurl)s" % attrs,
            u"error",
        ]
        self.direct(url, resultlines)

    def test_invalid1 (self):
        # invalid scheme chars
        url = u":"
        attrs = self.get_attrs(url=url)
        attrs['nurl'] = self.norm("file://%(curdir)s/%(url)s" % attrs)
        resultlines = [
            u"url file://%(curdir)s/%(url)s" % attrs,
            u"cache key %(nurl)s" % attrs,
            u"real url %(nurl)s" % attrs,
            u"name %(url)s" % attrs,
            u"error",
        ]
        self.direct(url, resultlines)

    def test_invalid2 (self):
        # missing scheme alltogether
        url = u""
        attrs = self.get_attrs(url=url)
        attrs['nurl'] = self.norm("file://%(curdir)s/%(url)s" % attrs)
        resultlines = [
            u"url file://%(curdir)s/%(url)s" % attrs,
            u"cache key %(nurl)s" % attrs,
            u"real url %(nurl)s" % attrs,
            u"name %(url)s" % attrs,
            u"error",
        ]
        self.direct(url, resultlines)

    def test_invalid3 (self):
        # really fucked up
        url = u"@][ @] "
        attrs = self.get_attrs(url=url)
        attrs['nurl'] = self.norm("file://%(curdir)s/%(url)s" % attrs)
        resultlines = [
            u"url file://%(curdir)s/%(url)s" % attrs,
            u"cache key %(nurl)s" % attrs,
            u"real url %(nurl)s" % attrs,
            u"name %(url)s" % attrs,
            u"error",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_file
# -*- coding: utf-8 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test file parsing.
"""
import os
import sys
import zipfile
from tests import need_word, need_pdflib
from . import LinkCheckTest, get_file


def unzip (filename, targetdir):
    """Unzip given zipfile into targetdir."""
    if isinstance(targetdir, unicode):
        targetdir = str(targetdir)
    zf = zipfile.ZipFile(filename)
    for name in zf.namelist():
        if name.endswith('/'):
            os.mkdir(os.path.join(targetdir, name), 0700)
        else:
            outfile = open(os.path.join(targetdir, name), 'wb')
            try:
                outfile.write(zf.read(name))
            finally:
                outfile.close()


class TestFile (LinkCheckTest):
    """
    Test file:// link checking (and file content parsing).
    """

    def test_html (self):
        self.file_test("file.html")

    def test_wml (self):
        self.file_test("file.wml")

    def test_text (self):
        self.file_test("file.txt")

    def test_asc (self):
        self.file_test("file.asc")

    def test_css (self):
        self.file_test("file.css")

    def test_php (self):
        self.file_test("file.php")

    @need_word
    def test_word (self):
        confargs = dict(enabledplugins=["WordParser"])
        self.file_test("file.doc", confargs=confargs)

    @need_pdflib
    def test_pdf(self):
        confargs = dict(enabledplugins=["PdfParser"])
        self.file_test("file.pdf", confargs=confargs)

    def test_urllist (self):
        self.file_test("urllist.txt")

    def test_directory_listing (self):
        # unpack non-unicode filename which cannot be stored
        # in the SF subversion repository
        if os.name != 'posix' or sys.platform != 'linux2':
            return
        dirname = get_file("dir")
        if not os.path.isdir(dirname):
            unzip(dirname + ".zip", os.path.dirname(dirname))
        self.file_test("dir")

    def test_unicode_filename (self):
        # a unicode filename
        self.file_test(u".bin")

    def test_good_file (self):
        url = u"file://%(curdir)s/%(datadir)s/file.txt" % self.get_attrs()
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_bad_file (self):
        if os.name == 'nt':
            # Fails on NT platforms and I am too lazy to fix
            # Cause: url get quoted %7C which gets lowercased to
            # %7c and this fails.
            return
        url = u"file:/%(curdir)s/%(datadir)s/file.txt" % self.get_attrs()
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"error",
        ]
        self.direct(url, resultlines)

    def test_good_file_missing_dslash (self):
        # good file (missing double slash)
        attrs = self.get_attrs()
        url = u"file:%(curdir)s/%(datadir)s/file.txt" % attrs
        resultlines = [
            u"url %s" % url,
            u"cache key file://%(curdir)s/%(datadir)s/file.txt" % attrs,
            u"real url file://%(curdir)s/%(datadir)s/file.txt" % attrs,
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_good_dir (self):
        url = u"file://%(curdir)s/%(datadir)s/" % self.get_attrs()
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_good_dir_space (self):
        url = u"file://%(curdir)s/%(datadir)s/a b/" % self.get_attrs()
        nurl = self.norm(url)
        url2 = u"file://%(curdir)s/%(datadir)s/a b/el.html" % self.get_attrs()
        nurl2 = self.norm(url2)
        url3 = u"file://%(curdir)s/%(datadir)s/a b/t.txt" % self.get_attrs()
        nurl3 = self.norm(url3)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
            u"url el.html",
            u"cache key %s" % nurl2,
            u"real url %s" % nurl2,
            u"name el.html",
            u"valid",
            u"url t.txt",
            u"cache key %s" % nurl3,
            u"real url %s" % nurl3,
            u"name t.txt",
            u"valid",
            u"url t.txt",
            u"cache key %s" % nurl3,
            u"real url %s" % nurl3,
            u"name External link",
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=2)

########NEW FILE########
__FILENAME__ = test_frames
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2009 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test html <frame> tag parsing.
"""
from . import LinkCheckTest


class TestFrames (LinkCheckTest):
    """
    Test link checking of HTML framesets.
    """

    def test_frames (self):
        self.file_test("frames.html")

########NEW FILE########
__FILENAME__ = test_ftp
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
FTP checking.
"""
from .. import need_pyftpdlib
from .ftpserver import FtpServerTest


class TestFtp (FtpServerTest):
    """Test ftp: link checking."""

    @need_pyftpdlib
    def test_ftp (self):
        # ftp two slashes
        url = u"ftp://%s:%d/" % (self.host, self.port)
        resultlines = [
          u"url %s" % url,
          u"cache key %s" % url,
          u"real url %s" % url,
          u"valid",
        ]
        # ftp use/password
        user = "anonymous"
        passwd = "Ftp"
        url = u"ftp://%s:%s@%s:%d/" % (user, passwd, self.host, self.port)
        resultlines = [
          u"url %s" % url,
          u"cache key %s" % url,
          u"real url %s" % url,
          u"valid",
        ]
        self.direct(url, resultlines)
        # ftp one slash
        url = u"ftp:/%s:%d/" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key None",
            u"real url %s" % nurl,
            u"error",
        ]
        self.direct(url, resultlines)
        # missing path
        url = u"ftp://%s:%d" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines)
        # missing trailing dir slash
        url = u"ftp://%s:%d/base" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
        u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s/" % nurl,
            u"warning Missing trailing directory slash in ftp url.",
            u"valid",
        ]
        self.direct(url, resultlines)
        # ftp two dir slashes
        url = u"ftp://%s:%d//base/" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines)
        # ftp many dir slashes
        url = u"ftp://%s:%d////////base/" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines)
        # ftp three slashes
        url = u"ftp:///%s:%d/" % (self.host, self.port)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key None",
            u"real url %s" % nurl,
            u"error",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_http
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http checking.
"""
from .httpserver import HttpServerTest, CookieRedirectHttpRequestHandler

class TestHttp (HttpServerTest):
    """Test http:// link checking."""

    def __init__(self, methodName='runTest'):
        super(TestHttp, self).__init__(methodName=methodName)
        self.handler = CookieRedirectHttpRequestHandler

    def test_html (self):
        confargs = dict(recursionlevel=1)
        self.file_test("http.html", confargs=confargs)
        self.file_test("http_lowercase.html", confargs=confargs)
        self.file_test("http_quotes.html", confargs=confargs)
        self.file_test("http_slash.html", confargs=confargs)
        self.file_test("http.xhtml", confargs=confargs)
        self.file_test("http_file.html", confargs=confargs)

    def test_status(self):
        for status in sorted(self.handler.responses.keys()):
            self._test_status(status)

    def _test_status(self, status):
        url = u"http://localhost:%d/status/%d" % (self.port, status)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
        ]
        if status in (204,):
            resultlines.append(u"warning No Content")
        if (status != 101 and status < 200) or status >= 400:
            result = u"error"
        else:
            result = u"valid"
        resultlines.append(result)
        self.direct(url, resultlines, recursionlevel=0)

########NEW FILE########
__FILENAME__ = test_httpbin
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http stuff with httpbin.org.
"""
import re
from . import LinkCheckTest


def get_httpbin_url(path):
    """Get httpbin URL. Note that this also could be a local
    httpbin installation, but right now this uses the official site."""
    return u"http://httpbin.org%s" % path


class TestHttpbin(LinkCheckTest):
    """Test http:// link redirection checking."""

    def test_http_link(self):
        linkurl = u"http://www.example.com"
        nlinkurl = self.norm(linkurl)
        url = get_httpbin_url(u"/response-headers?Link=<%s>;rel=previous" % linkurl)
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
            u"url %s" % linkurl,
            u"cache key %s" % nlinkurl,
            u"real url %s" % nlinkurl,
            u"name Link: header previous",
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=1)

    def test_basic_auth(self):
        user = u"testuser"
        password = u"testpassword"
        url = get_httpbin_url(u"/basic-auth/%s/%s" % (user, password))
        nurl = self.norm(url)
        entry = dict(
            user=user,
            password=password,
            pattern=re.compile(r'.*'),
        )
        confargs = dict(authentication=[entry])
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines, confargs=confargs)

########NEW FILE########
__FILENAME__ = test_https
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test news checking.
"""
from tests import need_network
from . import LinkCheckTest


class TestHttps (LinkCheckTest):
    """
    Test https: link checking.
    """

    @need_network
    def test_https (self):
        url = u"https://www.amazon.com/"
        rurl = u"http://www.amazon.com/"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % rurl,
            #u"info SSL cipher RC4-SHA, TLSv1/SSLv3.",
            u"info Redirected to `%s'." % rurl,
            u"valid",
        ]
        confargs = dict(
            #enabledplugins=['SslCertificateCheck'],
            #SslCertificateCheck=dict(sslcertwarndays=10),
        )
        self.direct(url, resultlines, recursionlevel=0, confargs=confargs)

########NEW FILE########
__FILENAME__ = test_https_redirect
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http checking.
"""
from .httpserver import HttpServerTest, CookieRedirectHttpRequestHandler

class TestHttpsRedirect (HttpServerTest):
    """Test https:// link redirection checking."""

    def __init__(self, methodName='runTest'):
        super(TestHttpsRedirect, self).__init__(methodName=methodName)
        self.handler = RedirectHttpsRequestHandler

    def test_redirect (self):
        url = u"http://localhost:%d/redirect1" % self.port
        nurl = url
        #rurl = u"https://localhost:%d/newurl1" % self.port
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % url,
            # XXX the redirect fails because this is not an SSL server
            #u"info Redirected to `%s'." % rurl.replace('http:', 'https:'),
            #u"valid",
            #u"url %s" % rurl,
            #u"cache key %s" % rurl,
            #u"real url %s" % rurl,
            u"error",
        ]
        self.direct(url, resultlines, recursionlevel=0)


class RedirectHttpsRequestHandler (CookieRedirectHttpRequestHandler):

    def redirect (self):
        """Redirect request."""
        path = self.path.replace("redirect", "newurl")
        port = self.server.server_address[1]
        url = "https://localhost:%d%s" % (port, path)
        self.send_response(302)
        self.send_header("Location", url)
        self.end_headers()


########NEW FILE########
__FILENAME__ = test_http_misc
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http checking.
"""
import os
import sys
from .httpserver import HttpServerTest
from linkcheck.network import iputil

class TestHttpMisc (HttpServerTest):
    """Test http:// misc link checking."""

    def test_html (self):
        self.swf_test()
        self.obfuscate_test()

    def swf_test (self):
        url = self.get_url(u"test.swf")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
            u"url http://www.example.org/",
            u"cache key http://www.example.org/",
            u"real url http://www.example.org/",
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=1)

    def obfuscate_test (self):
        if os.name != "posix" or sys.platform != 'linux2':
            return
        host = "www.heise.de"
        ip = iputil.resolve_host(host)[0]
        url = u"http://%s/" % iputil.obfuscate_ip(ip)
        rurl = u"http://%s/" % ip
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % rurl,
            u"real url %s" % rurl,
            u"info Access denied by robots.txt, checked only syntax.",
            u"warning URL %s has obfuscated IP address %s" % (url, ip),
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=0)

########NEW FILE########
__FILENAME__ = test_http_redirect
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http checking.
"""
from .httpserver import HttpServerTest, CookieRedirectHttpRequestHandler

class TestHttpRedirect (HttpServerTest):
    """Test http:// link redirection checking."""

    def __init__(self, methodName='runTest'):
        super(TestHttpRedirect, self).__init__(methodName=methodName)
        self.handler = CookieRedirectHttpRequestHandler

    def test_redirect (self):
        self.redirect1()
        self.redirect2()
        self.redirect3()
        self.redirect4()
        self.redirect5()

    def redirect1 (self):
        url = u"http://localhost:%d/redirect1" % self.port
        nurl = url
        rurl = url.replace("redirect", "newurl")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % rurl,
            u"info Redirected to `%s'." % rurl,
            u"error",
        ]
        self.direct(url, resultlines, recursionlevel=0)

    def redirect2 (self):
        url = u"http://localhost:%d/tests/checker/data/redirect.html" % \
              self.port
        nurl = url
        rurl = url.replace("redirect", "newurl")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % rurl,
            u"info Redirected to `%s'." % rurl,
            u"valid",
            u"url newurl.html",
            u"cache key %s" % nurl,
            u"real url %s" % rurl,
            u"name Recursive Redirect",
            # XXX the info is copied from the cached result
            u"info Redirected to `%s'." % rurl,
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=99)

    def redirect3 (self):
        url = u"http://localhost:%d/tests/checker/data/redir.html" % self.port
        resultlines = self.get_resultlines("redir.html")
        self.direct(url, resultlines, recursionlevel=1)

    def redirect4 (self):
        url = u"http://localhost:%d/redirect_newscheme_ftp" % self.port
        nurl = url
        #rurl = u"ftp://example.com/"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            # don't allow ftp redirects
            #u"info Redirected to `%s'." % rurl,
            #u"valid",
            #u"url %s" % rurl,
            #u"cache key %s" % rurl,
            #u"real url %s" % rurl,
            u"error",
        ]
        self.direct(url, resultlines, recursionlevel=99)

    def redirect5 (self):
        url = u"http://localhost:%d/redirect_newscheme_file" % self.port
        nurl = url
        #rurl = u"file:README"
        #rnurl = u"file:///README"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            # don't allow file redirects
            #u"info Redirected to `%s'." % rurl,
            #u"warning Redirection to url `%s' is not allowed." % rnurl,
            u"error",
        ]
        self.direct(url, resultlines, recursionlevel=99)

    def redirect6(self):
        #max_redirect = 10
        # url = "http://httpbin.org/redirect/" + max_redirect --> valid
        # url = "http://httpbin.org/redirect/" + (max_redirect+1) --> error
        pass # XXX

########NEW FILE########
__FILENAME__ = test_http_robots
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test http checking.
"""
from .httpserver import HttpServerTest

class TestHttpRobots (HttpServerTest):
    """Test robots.txt link checking behaviour."""

    def test_html (self):
        self.robots_txt_test()
        self.robots_txt2_test()

    def robots_txt_test (self):
        url = u"http://localhost:%d/robots.txt" % self.port
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=5)

    def robots_txt2_test (self):
        url = u"http://localhost:%d/secret" % self.port
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"info Access denied by robots.txt, checked only syntax.",
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=5)

########NEW FILE########
__FILENAME__ = test_internpat
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2007-2009 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test internal pattern construction
"""
import linkcheck.director
import linkcheck.configuration
from __init__ import LinkCheckTest, get_url_from


class TestInternpat (LinkCheckTest):
    """Test internal pattern."""

    def test_trailing_slash (self):
        # Make sure a trailing slash is not lost
        config = linkcheck.configuration.Configuration()
        aggregate = linkcheck.director.get_aggregate(config)
        url = "http://example.org/foo/"
        url_data = get_url_from(url, 0, aggregate)
        internpat = url_data.get_intern_pattern()
        self.assertTrue(internpat.endswith('/'))

########NEW FILE########
__FILENAME__ = test_mail_bad
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test mail checking of bad mail addresses.
"""
from . import MailTest


class TestMailBad (MailTest):
    """Test mailto: link checking."""

    def test_error_mail (self):
        # too long or too short
        self.mail_error(u"mailto:@")
        self.mail_error(u"mailto:@example.org")
        self.mail_error(u"mailto:a@")
        self.mail_error(u"mailto:%s@example.org" % (u"a"*65))
        self.mail_error(u'mailto:a@%s.com' % (u"a"*64))
        # local part quoted
        self.mail_error(u'mailto:"a""@example.com', cache_key=u'mailto:a')
        self.mail_error(u'mailto:""a"@example.com', cache_key=u'mailto:""a"@example.com')
        self.mail_error(u'mailto:"a\\"@example.com', cache_key=u'mailto:a"@example.com')
        # local part unqouted
        self.mail_error(u'mailto:.a@example.com')
        self.mail_error(u'mailto:a.@example.com')
        self.mail_error(u'mailto:a..b@example.com')
        # domain part
        self.mail_error(u'mailto:a@a_b.com')
        self.mail_error(u'mailto:a@example.com.')
        self.mail_error(u'mailto:a@example.com.111')
        self.mail_error(u'mailto:a@example..com')
        # other
        # ? extension forbidden in <> construct
        self.mail_error(u"mailto:Bastian Kleineidam <calvin@users.sourceforge.net?foo=bar>",
            cache_key=u"mailto:calvin@users.sourceforge.net?foo=bar")

########NEW FILE########
__FILENAME__ = test_mail_good
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test mail checking.
"""
from tests import need_network
from . import MailTest


class TestMailGood (MailTest):
    """
    Test mailto: link checking.
    """

    @need_network
    def test_good_mail (self):
        # some good mailto addrs
        url = self.norm(u"mailto:Dude <calvin@users.sourceforge.net> , "\
                "Killer <calvin@users.sourceforge.net>?subject=bla")
        resultlines = [
          u"url %s" % url,
          u"cache key mailto:calvin@users.sourceforge.net",
          u"real url %s" % url,
          u"valid",
        ]
        self.direct(url, resultlines)
        url = self.norm(u"mailto:Bastian Kleineidam <calvin@users.sourceforge.net>?"\
                "bcc=calvin%40users.sourceforge.net")
        resultlines = [
          u"url %s" % url,
          u"cache key mailto:calvin@users.sourceforge.net",
          u"real url %s" % url,
          u"valid",
        ]
        self.direct(url, resultlines)
        url = self.norm(u"mailto:Bastian Kleineidam <calvin@users.sourceforge.net>")
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:calvin@users.sourceforge.net",
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = self.norm(u"mailto:o'hara@users.sourceforge.net")
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:o'hara@users.sourceforge.net",
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = self.norm(u"mailto:?to=calvin@users.sourceforge.net&subject=blubb&"
                       u"cc=calvin_cc@users.sourceforge.net&CC=calvin_CC@users.sourceforge.net")
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:calvin@users.sourceforge.net,"
             u"calvin_CC@users.sourceforge.net,calvin_cc@users.sourceforge.net",
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = self.norm(u"mailto:news-admins@freecode.com?subject="
                "Re:%20[fm%20#11093]%20(news-admins)%20Submission%20"
                "report%20-%20Pretty%20CoLoRs")
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:news-admins@freecode.com",
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)

    @need_network
    def test_warn_mail (self):
        # some mailto addrs with warnings
        # contains non-quoted characters
        url = u"mailto:calvin@users.sourceforge.net?subject="
        qurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:calvin@users.sourceforge.net",
            u"real url %s" % qurl,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"mailto:calvin@users.sourceforge.net?subject=Halli hallo"
        qurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:calvin@users.sourceforge.net",
            u"real url %s" % qurl,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"mailto:"
        resultlines = [
            u"url %s" % url,
            u"cache key mailto:",
            u"real url %s" % url,
            u"warning No mail addresses or email subject found in `%s'." % url,
            u"valid",
        ]
        self.direct(url, resultlines)

    def _mail_valid_unverified(self, char):
        # valid mail addresses
        addr = u'abc%sdef@sourceforge.net' % char
        url = u"mailto:%s" % addr
        self.mail_valid(url,
          cache_key=url)

    @need_network
    def test_valid_mail1 (self):
        for char in u"!#$&'":
            self._mail_valid_unverified(char)

    @need_network
    def test_valid_mail2 (self):
        for char in u"*+-/=":
            self._mail_valid_unverified(char)

    @need_network
    def test_valid_mail3 (self):
        for char in u"^_`.":
            self._mail_valid_unverified(char)

    @need_network
    def test_valid_mail4 (self):
        for char in u"{|}~":
            self._mail_valid_unverified(char)

    @need_network
    def test_unicode_mail (self):
        mailto = u"mailto:lvin@users.sourceforge.net"
        url = self.norm(mailto, encoding="iso-8859-1")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % mailto,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)

    @need_network
    def test_mail_subject(self):
        url = u"mailto:?subject=Halli hallo"
        nurl = self.norm(url)
        curl = u"mailto:"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % curl,
            u"real url %s" % nurl,
            u"valid",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_misc
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2009 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test miscellaneous html tag parsing.
"""
from . import LinkCheckTest


class TestMisc (LinkCheckTest):
    """
    Test link checking of HTML tags.
    """

    def test_misc (self):
        self.file_test("misc.html")

    def test_html5 (self):
        self.file_test("html5.html")

    def test_archive (self):
        self.file_test("archive.html")

########NEW FILE########
__FILENAME__ = test_news
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2010,2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test news checking.
"""
import pytest
from tests import need_newsserver, limit_time
from . import LinkCheckTest

# Changes often, as servers tend to get invalid. Thus it is necessary
# to enable the has_newsserver() resource manually.
NNTP_SERVER = "news.uni-stuttgart.de"
# info string returned by news server
NNTP_INFO = u"200 news.uni-stuttgart.de InterNetNews NNRP server " \
            u"INN 2.5.2 ready (no posting)"
# Most free NNTP servers are slow, so don't waist a lot of time running those.
NNTP_TIMEOUT_SECS = 30

# disabled for now until some stable news server comes up
@pytest.mark.skipif("True")
class TestNews (LinkCheckTest):
    """Test nntp: and news: link checking."""

    def newstest (self, url, resultlines):
        self.direct(url, resultlines)

    def test_news_without_host (self):
        # news testing
        url = u"news:comp.os.linux.misc"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"warning No NNTP server was specified, skipping this URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)
        # no group
        url = u"news:"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"warning No NNTP server was specified, skipping this URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    def test_snews_with_group (self):
        url = u"snews:de.comp.os.unix.linux.misc"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"warning No NNTP server was specified, skipping this URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    def test_illegal_syntax (self):
        # illegal syntax
        url = u"news:$%&/`(%"
        qurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % qurl,
            u"real url %s" % qurl,
            u"warning No NNTP server was specified, skipping this URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    @need_newsserver(NNTP_SERVER)
    @limit_time(NNTP_TIMEOUT_SECS, skip=True)
    def test_nntp_with_host (self):
        url = u"nntp://%s/comp.lang.python" % NNTP_SERVER
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"info %s" % NNTP_INFO,
            u"info News group comp.lang.python found.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    @need_newsserver(NNTP_SERVER)
    @limit_time(NNTP_TIMEOUT_SECS, skip=True)
    def test_article_span (self):
        url = u"nntp://%s/comp.lang.python/1-5" % NNTP_SERVER
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"info %s" % NNTP_INFO,
            u"info News group comp.lang.python found.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    def test_article_span_no_host (self):
        url = u"news:comp.lang.python/1-5"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"warning No NNTP server was specified, skipping this URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)

    @need_newsserver(NNTP_SERVER)
    @limit_time(NNTP_TIMEOUT_SECS, skip=True)
    def test_host_no_group (self):
        url = u"nntp://%s/" % NNTP_SERVER
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"info %s" % NNTP_INFO,
            u"warning No newsgroup specified in NNTP URL.",
            u"valid",
        ]
        self.newstest(url, resultlines)

########NEW FILE########
__FILENAME__ = test_noproxy
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test proxy handling.
"""
import httpserver
from test.test_support import EnvironmentVarGuard

class TestProxy (httpserver.HttpServerTest):
    """Test no_proxy env var handling."""

    def test_noproxy (self):
        # set env vars
        with EnvironmentVarGuard() as env:
            env.set("http_proxy", "http://example.org:8877")
            env.set("no_proxy", "localhost:%d" % self.port)
            self.noproxy_test()

    def noproxy_test(self):
        # Test setting proxy and no_proxy env variable.
        url = self.get_url(u"favicon.ico")
        nurl = url
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Ignoring proxy setting `http://example.org:8877'.",
            u"valid",
        ]
        self.direct(url, resultlines, recursionlevel=0)

########NEW FILE########
__FILENAME__ = test_telnet
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test telnet checking.
"""
from .telnetserver import TelnetServerTest


class TestTelnet (TelnetServerTest):
    """Test telnet: link checking."""

    def test_telnet_error (self):
        url = u"telnet:"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key None",
            u"real url %s" % nurl,
            u"error",
        ]
        self.direct(url, resultlines)

    def test_telnet_localhost (self):
        url = self.get_url()
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = self.get_url(user=u"test")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = self.get_url(user=u"test", password=u"test")
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % url,
            u"real url %s" % url,
            u"valid",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_unknown
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test checking of unknown URLs.
"""
from . import LinkCheckTest


class TestUnknown (LinkCheckTest):
    """Test unknown URL scheme checking."""

    def test_skype (self):
        url = u"skype:"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Skype URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_irc (self):
        url = u"irc://example.org"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Irc URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"ircs://example.org"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Ircs URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_steam (self):
        url = u"steam://connect/example.org"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Steam URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_feed (self):
        url = u"feed:https://example.com/entries.atom"
        nurl = u"feed:https%3A/example.com/entries.atom"
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Feed URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"feed://example.com/entries.atom"
        nurl = self.norm(url)
        resultlines = [
            u"url %s" % url,
            u"cache key %s" % nurl,
            u"real url %s" % nurl,
            u"info Feed URL ignored.",
            u"valid",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_urllen
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2012-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test URL length checks.
"""
from . import LinkCheckTest
from linkcheck.checker.const import URL_MAX_LENGTH


class TestURLLength(LinkCheckTest):
    """
    Test URL lengths.
    """

    def test_url_warn(self):
        url = u"http://www.example.org/" + (u"a" * URL_MAX_LENGTH)
        attrs = self.get_attrs(url=url)
        attrs['nurl'] = self.norm(url)
        resultlines = [
            u"url %(nurl)s" % attrs,
            u"cache key %(nurl)s" % attrs,
            u"real url %(nurl)s" % attrs,
            u"warning URL length %d is longer than %d." % (len(url), URL_MAX_LENGTH),
            u"error",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_whitespace
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test whitespace handling.
"""
from . import LinkCheckTest


class TestWhitespace (LinkCheckTest):
    """
    Test whitespace in URLs.
    """

    def test_leading_whitespace (self):
        # Leading whitespace
        url = u" http://www.example.org/"
        attrs = self.get_attrs(url=url)
        attrs['surl'] = url.strip()
        resultlines = [
            u"url %(surl)s" % attrs,
            u"cache key %(surl)s" % attrs,
            u"real url %(surl)s" % attrs,
            u"warning Leading or trailing whitespace in URL `%(url)s'." % attrs,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"\nhttp://www.example.org/"
        attrs = self.get_attrs(url=url)
        attrs['surl'] = url.strip()
        resultlines = [
            u"url %(surl)s" % attrs,
            u"cache key %(surl)s" % attrs,
            u"real url %(surl)s" % attrs,
            u"warning Leading or trailing whitespace in URL `%(url)s'." % attrs,
            u"valid",
        ]
        self.direct(url, resultlines)

    def test_trailing_whitespace (self):
        # Trailing whitespace
        url = u"http://www.example.org/ "
        resultlines = [
            u"url %s" % url.strip(),
            u"cache key %s" % url.strip(),
            u"real url %s" % url.strip(),
            u"warning Leading or trailing whitespace in URL `%s'." % url,
            u"valid",
        ]
        self.direct(url, resultlines)
        url = u"http://www.example.org/\n"
        resultlines = [
            u"url %s" % url.strip(),
            u"cache key %s" % url.strip(),
            u"real url %s" % url.strip(),
            u"warning Leading or trailing whitespace in URL `%s'." % url,
            u"valid",
        ]
        self.direct(url, resultlines)

########NEW FILE########
__FILENAME__ = test_config
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test config parsing.
"""

import unittest
import os
import linkcheck.configuration


def get_file (filename=None):
    """Get file name located within 'data' directory."""
    directory = os.path.join("tests", "configuration", "data")
    if filename:
        return unicode(os.path.join(directory, filename))
    return unicode(directory)


class TestConfig (unittest.TestCase):
    """Test configuration parsing."""

    def test_confparse (self):
        config = linkcheck.configuration.Configuration()
        files = [get_file("config0.ini")]
        config.read(files)
        # checking section
        for scheme in ("http", "https", "ftp"):
            self.assertTrue(scheme in config["allowedschemes"])
        self.assertEqual(config["threads"], 5)
        self.assertEqual(config["timeout"], 42)
        self.assertEqual(config["aborttimeout"], 99)
        self.assertEqual(config["recursionlevel"], 1)
        self.assertEqual(config["nntpserver"], "example.org")
        self.assertEqual(config["cookiefile"], "blablabla")
        self.assertEqual(config["useragent"], "Example/0.0")
        self.assertEqual(config["debugmemory"], 1)
        self.assertEqual(config["localwebroot"], "foo")
        self.assertEqual(config["sslverify"], "/path/to/cacerts.crt")
        self.assertEqual(config["maxnumurls"], 1000)
        self.assertEqual(config["maxrunseconds"], 1)
        self.assertEqual(config["maxfilesizeparse"], 100)
        self.assertEqual(config["maxfilesizedownload"], 100)
        # filtering section
        patterns = [x["pattern"].pattern for x in config["externlinks"]]
        for prefix in ("ignore_", "nofollow_"):
            for suffix in ("1", "2"):
                key = "%simadoofus%s" % (prefix, suffix)
                self.assertTrue(key in patterns)
        for key in ("url-unicode-domain",):
            self.assertTrue(key in config["ignorewarnings"])
        self.assertTrue(config["checkextern"])
        # authentication section
        patterns = [x["pattern"].pattern for x in config["authentication"]]
        for suffix in ("1", "2"):
            key = "imadoofus%s" % suffix
            self.assertTrue(key in patterns)
        self.assertTrue("http://www.example.com/" in patterns)
        self.assertTrue("http://www.example.com/nopass" in patterns)
        self.assertEqual(config["loginurl"], "http://www.example.com/")
        self.assertEqual(config["loginuserfield"], "mylogin")
        self.assertEqual(config["loginpasswordfield"], "mypassword")
        self.assertEqual(config["loginextrafields"]["name1"], "value1")
        self.assertEqual(config["loginextrafields"]["name 2"], "value 2")
        self.assertEqual(len(config["loginextrafields"]), 2)
        # output section
        self.assertTrue(linkcheck.log.is_debug(linkcheck.LOG_THREAD))
        self.assertFalse(config["status"])
        self.assertTrue(isinstance(config["logger"], linkcheck.logger.customxml.CustomXMLLogger))
        self.assertTrue(config["verbose"])
        self.assertTrue(config["warnings"])
        self.assertFalse(config["quiet"])
        self.assertEqual(len(config["fileoutput"]), 8)
        # plugins
        for plugin in ("AnchorCheck", "CssSyntaxCheck", "HtmlSyntaxCheck", "LocationInfo", "RegexCheck", "SslCertificateCheck", "VirusCheck", "HttpHeaderInfo"):
            self.assertTrue(plugin in config["enabledplugins"])
        # text logger section
        self.assertEqual(config["text"]["filename"], "imadoofus.txt")
        self.assertEqual(config["text"]["parts"], ["realurl"])
        self.assertEqual(config["text"]["encoding"], "utf-8")
        self.assertEqual(config["text"]["colorparent"], "blink;red")
        self.assertEqual(config["text"]["colorurl"], "blink;red")
        self.assertEqual(config["text"]["colorname"], "blink;red")
        self.assertEqual(config["text"]["colorreal"], "blink;red")
        self.assertEqual(config["text"]["colorbase"], "blink;red")
        self.assertEqual(config["text"]["colorvalid"], "blink;red")
        self.assertEqual(config["text"]["colorinvalid"], "blink;red")
        self.assertEqual(config["text"]["colorinfo"], "blink;red")
        self.assertEqual(config["text"]["colorwarning"], "blink;red")
        self.assertEqual(config["text"]["colordltime"], "blink;red")
        self.assertEqual(config["text"]["colorreset"], "blink;red")
        # gml logger section
        self.assertEqual(config["gml"]["filename"], "imadoofus.gml")
        self.assertEqual(config["gml"]["parts"], ["realurl"])
        self.assertEqual(config["gml"]["encoding"], "utf-8")
        # dot logger section
        self.assertEqual(config["dot"]["filename"], "imadoofus.dot")
        self.assertEqual(config["dot"]["parts"], ["realurl"])
        self.assertEqual(config["dot"]["encoding"], "utf-8")
        # csv logger section
        self.assertEqual(config["csv"]["filename"], "imadoofus.csv")
        self.assertEqual(config["csv"]["parts"], ["realurl"])
        self.assertEqual(config["csv"]["encoding"], "utf-8")
        self.assertEqual(config["csv"]["separator"], ";")
        self.assertEqual(config["csv"]["quotechar"], "'")
        # sql logger section
        self.assertEqual(config["sql"]["filename"], "imadoofus.sql")
        self.assertEqual(config["sql"]["parts"], ["realurl"])
        self.assertEqual(config["sql"]["encoding"], "utf-8")
        self.assertEqual(config["sql"]["separator"], ";")
        self.assertEqual(config["sql"]["dbname"], "linksdb")
        # html logger section
        self.assertEqual(config["html"]["filename"], "imadoofus.html")
        self.assertEqual(config["html"]["parts"], ["realurl"])
        self.assertEqual(config["html"]["encoding"], "utf-8")
        self.assertEqual(config["html"]["colorbackground"], "#ff0000")
        self.assertEqual(config["html"]["colorurl"], "#ff0000")
        self.assertEqual(config["html"]["colorborder"], "#ff0000")
        self.assertEqual(config["html"]["colorlink"], "#ff0000")
        self.assertEqual(config["html"]["colorwarning"], "#ff0000")
        self.assertEqual(config["html"]["colorerror"], "#ff0000")
        self.assertEqual(config["html"]["colorok"], "#ff0000")
        # blacklist logger section
        self.assertEqual(config["blacklist"]["filename"], "blacklist")
        self.assertEqual(config["blacklist"]["encoding"], "utf-8")
        # xml logger section
        self.assertEqual(config["xml"]["filename"], "imadoofus.xml")
        self.assertEqual(config["xml"]["parts"], ["realurl"])
        self.assertEqual(config["xml"]["encoding"], "utf-8")
        # gxml logger section
        self.assertEqual(config["gxml"]["filename"], "imadoofus.gxml")
        self.assertEqual(config["gxml"]["parts"], ["realurl"])
        self.assertEqual(config["gxml"]["encoding"], "utf-8")

    def test_confparse_error1 (self):
        config = linkcheck.configuration.Configuration()
        files = [get_file("config1.ini")]
        self.assertRaises(linkcheck.LinkCheckerError, config.read, files)

    def test_confparse_error2 (self):
        config = linkcheck.configuration.Configuration()
        files = [get_file("config2.ini")]
        self.assertRaises(linkcheck.LinkCheckerError, config.read, files)

########NEW FILE########
__FILENAME__ = test_csvlog
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2010 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import unittest
import os
from linkcheck.logger.csvlog import CSVLogger


class TestCsvLogger (unittest.TestCase):

    def test_parts (self):
        args = dict(
            filename=os.path.join(os.path.dirname(__file__), "testlog.csv"),
            parts=["realurl"],
            fileoutput=1,
            separator=";",
            quotechar='"',
        )
        logger = CSVLogger(**args)
        try:
            logger.start_output()
        finally:
            logger.end_output()
            os.remove(args["filename"])

########NEW FILE########
__FILENAME__ = test_cgi
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test cgi form routines.
"""
import unittest
import wsgiref
import urllib
from StringIO import StringIO
from wsgiref.util import setup_testing_defaults
from linkcheck.lc_cgi import checkform, checklink, LCFormError, application
from linkcheck.strformat import limit

class TestWsgi (unittest.TestCase):
    """Test wsgi application."""

    def test_form_valid_url (self):
        # Check url validity.
        env = dict()
        form = dict(url="http://www.example.com/", level="1")
        checkform(form, env)

    def test_form_empty_url (self):
        # Check with empty url.
        env = dict()
        form = dict(url="", level="0")
        self.assertRaises(LCFormError, checkform, form, env)

    def test_form_default_url (self):
        # Check with default url.
        env = dict()
        form = dict(url="http://", level="0")
        self.assertRaises(LCFormError, checkform, form, env)

    def test_form_invalid_url (self):
        # Check url (in)validity.
        env = dict()
        form = dict(url="http://www.foo bar/", level="0")
        self.assertRaises(LCFormError, checkform, form, env)

    def test_checklink (self):
        form = dict(url="http://www.example.com/", level="0")
        checklink(form)

    def test_application (self):
        form = dict(url="http://www.example.com/", level="0")
        formdata = urllib.urlencode(form)
        environ = {'wsgi.input': StringIO(formdata)}
        setup_testing_defaults(environ)
        test_response = ""
        test_headers = [None]
        test_status = [None]
        def start_response(status, headers):
            test_status[0] = status
            test_headers[0] = headers
        for str_data in application(environ, start_response):
            if not isinstance(str_data, str):
                err = "answer is not a byte string: %r" % limit(str_data, 30)
                self.assertTrue(False, err)
            test_response += str_data
        self.assertEqual(test_status[0], '200 OK')
        self.assertTrue("Generated by LinkChecker" in test_response)

########NEW FILE########
__FILENAME__ = test_clamav
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test virus filter.
"""
import unittest
from tests import need_clamav
from linkcheck.plugins import viruscheck as clamav


class TestClamav (unittest.TestCase):

    def setUp(self):
        self.clamav_conf = clamav.get_clamav_conf("/etc/clamav/clamd.conf")

    @need_clamav
    def testClean (self):
        data = ""
        infected, errors = clamav.scan(data, self.clamav_conf)
        self.assertFalse(infected)
        self.assertFalse(errors)

    @need_clamav
    def testInfected (self):
        # from the clamav test direcotry: the clamav test file as html data
        data = '<a href="data:application/octet-stream;base64,' \
           'TVpQAAIAAAAEAA8A//8AALgAAAAhAAAAQAAaAAAAAAAAAAAAAAAAAAAAAAAAAA' \
           'AAAAAAAAAAAAAAAAAAAAEAALtxEEAAM8BQUIvzU1NQsClAMARmrHn5ujEAeA2t' \
           'UP9mcA4fvjEA6eX/tAnNIbRMzSFiDAoBAnB2FwIeTgwEL9rMEAAAAAAAAAAAAA' \
           'AAAAAAwBAAAIAQAAAAAAAAAAAAAAAAAADaEAAA9BAAAAAAAAAAAAAAAAAAAAAA' \
           'AAAAAAAAS0VSTkVMMzIuRExMAABFeGl0UHJvY2VzcwBVU0VSMzIuRExMAENMQU' \
           '1lc3NhZ2VCb3hBAOYQAAAAAAAAPz8/P1BFAABMAQEAYUNhQgAAAAAAAAAA4ACO' \
           'gQsBAhkABAAAAAYAAAAAAABAEAAAABAAAEAAAAAAAEAAABAAAAACAAABAAAAAA' \
           'AAAAMACgAAAAAAACAAAAAEAAAAAAAAAgAAAAAAEAAAIAAAAAAQAAAQAAAAAAAA' \
           'EAAAAAAAAAAAAAAAhBAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' \
           'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' \
           'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAW0NMQU1BVl' \
           '0AEAAAABAAAAACAAABAAAAAAAAAAAAAAAAAAAAAAAAwA==">t</a>'
        infected, errors = clamav.scan(data, self.clamav_conf)
        msg = 'stream: ClamAV-Test-File(2d1206194bd704385e37000be6113f73:781) FOUND\n'
        self.assertTrue(msg in infected)
        self.assertFalse(errors)

########NEW FILE########
__FILENAME__ = test_console
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test console operations.
"""

import unittest
import linkcheck.director.console


class TestConsole (unittest.TestCase):
    """Test console operations."""

    def test_internal_error (self):
        linkcheck.director.console.internal_error()

########NEW FILE########
__FILENAME__ = test_containers
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test container routines.
"""

import unittest
import random
import linkcheck.containers


class TestAttrDict (unittest.TestCase):

    def setUp (self):
        self.d = linkcheck.containers.AttrDict()

    def test_access (self):
        self.d["test"] = 1
        self.assertEqual(self.d.test, self.d["test"])
        self.assertEqual(self.d.test, 1)

    def test_method (self):
        self.d["get"] = 1
        self.assertTrue(isinstance(self.d.get, type({}.get)))


class TestListDict (unittest.TestCase):
    """Test list dictionary routines."""

    def setUp (self):
        """Set up self.d as empty listdict."""
        self.d = linkcheck.containers.ListDict()

    def test_insertion_order (self):
        self.assertTrue(not self.d)
        self.d[2] = 1
        self.d[1] = 2
        self.assertTrue(2 in self.d)
        self.assertTrue(1 in self.d)

    def test_deletion_order (self):
        self.assertTrue(not self.d)
        self.d[2] = 1
        self.d[1] = 2
        del self.d[1]
        self.assertTrue(2 in self.d)
        self.assertTrue(1 not in self.d)

    def test_update_order (self):
        self.assertTrue(not self.d)
        self.d[2] = 1
        self.d[1] = 2
        self.d[1] = 1
        self.assertEqual(self.d[1], 1)

    def test_sorting (self):
        self.assertTrue(not self.d)
        toinsert = random.sample(xrange(10000000), 60)
        for x in toinsert:
            self.d[x] = x
        for i, k in enumerate(self.d.keys()):
            self.assertEqual(self.d[k], toinsert[i])
        for i, k in enumerate(self.d.iterkeys()):
            self.assertEqual(self.d[k], toinsert[i])
        for x in self.d.values():
            self.assertTrue(x in toinsert)
        for x in self.d.itervalues():
            self.assertTrue(x in toinsert)
        for x, y in self.d.items():
            self.assertTrue(x in toinsert)
            self.assertTrue(y in toinsert)
        for x, y in self.d.iteritems():
            self.assertTrue(x in toinsert)
            self.assertTrue(y in toinsert)

    def test_clear (self):
        self.assertTrue(not self.d)
        self.d[2] = 1
        self.d[1] = 3
        self.d.clear()
        self.assertTrue(not self.d)

    def test_get_true (self):
        self.assertTrue(not self.d)
        self.d["a"] = 0
        self.d["b"] = 1
        self.assertEqual(self.d.get_true("a", 2), 2)
        self.assertEqual(self.d.get_true("b", 2), 1)


class TestCaselessDict (unittest.TestCase):
    """Test caseless dictionary routines."""

    def setUp (self):
        """Set up self.d as empty caseless dict."""
        self.d = linkcheck.containers.CaselessDict()

    def test_insert (self):
        self.assertTrue(not self.d)
        self.d["a"] = 1
        self.assertTrue("a" in self.d)
        self.assertTrue("A" in self.d)
        self.d["aBcD"] = 2
        self.assertTrue("abcd" in self.d)
        self.assertTrue("Abcd" in self.d)
        self.assertTrue("ABCD" in self.d)

    def test_delete (self):
        self.assertTrue(not self.d)
        self.d["a"] = 1
        del self.d["A"]
        self.assertTrue("a" not in self.d)
        self.assertTrue("A" not in self.d)

    def test_update (self):
        self.assertTrue(not self.d)
        self.d["a"] = 1
        self.d["A"] = 2
        self.assertEqual(self.d["a"], 2)

    def test_clear (self):
        self.assertTrue(not self.d)
        self.d["a"] = 5
        self.d["b"] = 6
        self.d.clear()
        self.assertTrue(not self.d)

    def test_containment (self):
        self.assertTrue(not self.d)
        self.assertTrue("A" not in self.d)
        self.assertTrue("a" not in self.d)
        self.d["a"] = 5
        self.assertTrue("A" in self.d)
        self.assertTrue("a" in self.d)

    def test_setdefault (self):
        self.assertTrue(not self.d)
        self.d["a"] = 5
        self.assertEqual(self.d.setdefault("A", 6), 5)
        self.assertEqual(self.d.setdefault("b", 7), 7)

    def test_get (self):
        self.assertTrue(not self.d)
        self.d["a"] = 42
        self.assertEqual(self.d.get("A"), 42)
        self.assertTrue(self.d.get("B") is None)

    def test_update2 (self):
        self.assertTrue(not self.d)
        self.d["a"] = 42
        self.d.update({"A": 43})
        self.assertEqual(self.d["a"], 43)

    def test_fromkeys (self):
        self.assertTrue(not self.d)
        keys = ["a", "A", "b", "C"]
        d1 = self.d.fromkeys(keys, 42)
        for key in keys:
            self.assertEqual(d1[key], 42)

    def test_pop (self):
        self.assertTrue(not self.d)
        self.d["a"] = 42
        self.assertEqual(self.d.pop("A"), 42)
        self.assertTrue(not self.d)
        self.assertRaises(KeyError, self.d.pop, "A")

    def test_popitem (self):
        self.assertTrue(not self.d)
        self.d["a"] = 42
        self.assertEqual(self.d.popitem(), ("a", 42))
        self.assertTrue(not self.d)
        self.assertRaises(KeyError, self.d.popitem)


class TestCaselessSortedDict (unittest.TestCase):
    """Test caseless sorted dictionary routines."""

    def setUp (self):
        """Set up self.d as empty caseless sorted dict."""
        self.d = linkcheck.containers.CaselessSortedDict()

    def test_sorted (self):
        self.assertTrue(not self.d)
        self.d["b"] = 6
        self.d["a"] = 7
        self.d["C"] = 8
        prev = None
        for key in self.d.keys():
            if prev is not None:
                self.assertTrue(key > prev)
            prev = key
        prev = None
        for key, value in self.d.items():
            self.assertEqual(value, self.d[key])
            if prev is not None:
                self.assertTrue(key > prev)
            prev = key


class TestLFUCache (unittest.TestCase):
    """Test LFU cache implementation."""

    def setUp (self):
        """Set up self.d as empty LFU cache with default size of 1000."""
        self.size = 1000
        self.d = linkcheck.containers.LFUCache(self.size)

    def test_num_uses (self):
        self.assertTrue(not self.d)
        self.d["a"] = 1
        self.assertTrue("a" in self.d)
        self.assertEqual(self.d.uses("a"), 0)
        dummy = self.d["a"]
        self.assertEqual(self.d.uses("a"), 1)

    def test_values (self):
        self.assertTrue(not self.d)
        self.d["a"] = 1
        self.d["b"] = 2
        self.assertEqual(set([1, 2]), set(self.d.values()))
        self.assertEqual(set([1, 2]), set(self.d.itervalues()))

    def test_popitem (self):
        self.assertTrue(not self.d)
        self.d["a"] = 42
        self.assertEqual(self.d.popitem(), ("a", 42))
        self.assertTrue(not self.d)
        self.assertRaises(KeyError, self.d.popitem)

    def test_shrink (self):
        self.assertTrue(not self.d)
        for i in range(self.size):
            self.d[i] = i
        self.d[1001] = 1001
        self.assertTrue(950 <= len(self.d) <= self.size)


class TestEnum (unittest.TestCase):

    def test_enum (self):
        e = linkcheck.containers.enum("a", "b", "c")
        self.assertEqual(e.a, 0)
        self.assertEqual(e.b, 1)
        self.assertEqual(e.c, 2)
        self.assertEqual(e, (0, 1, 2))

########NEW FILE########
__FILENAME__ = test_cookies
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test cookie routines.
"""

import unittest
import linkcheck.cookies


class TestCookies (unittest.TestCase):
    """Test cookie routines."""

    def test_cookie_parse_multiple_headers (self):
        lines = [
            'Host: example.org',
            'Path: /hello',
            'Set-cookie: ID="smee"',
            'Set-cookie: spam="egg"',
        ]
        from_headers = linkcheck.cookies.from_headers
        cookies = from_headers("\r\n".join(lines))
        self.assertEqual(len(cookies), 2)
        for cookie in cookies:
            self.assertEqual(cookie.domain, "example.org")
            self.assertEqual(cookie.path, "/hello")
        self.assertEqual(cookies[0].name, 'ID')
        self.assertEqual(cookies[0].value, 'smee')
        self.assertEqual(cookies[1].name, 'spam')
        self.assertEqual(cookies[1].value, 'egg')

    def test_cookie_parse_multiple_values (self):
        lines = [
            'Host: example.org',
            'Set-cookie: baggage="elitist"; comment="hologram"',
        ]
        from_headers = linkcheck.cookies.from_headers
        cookies = from_headers("\r\n".join(lines))
        self.assertEqual(len(cookies), 2)
        for cookie in cookies:
            self.assertEqual(cookie.domain, "example.org")
            self.assertEqual(cookie.path, "/")
        self.assertEqual(cookies[0].name, 'baggage')
        self.assertEqual(cookies[0].value, 'elitist')
        self.assertEqual(cookies[1].name, 'comment')
        self.assertEqual(cookies[1].value, 'hologram')

    def test_cookie_parse_error (self):
        lines = [
            ' Host: imaweevil.org',
            'Set-cookie: baggage="elitist"; comment="hologram"',
        ]
        from_headers = linkcheck.cookies.from_headers
        self.assertRaises(ValueError, from_headers, "\r\n".join(lines))

########NEW FILE########
__FILENAME__ = test_decorators
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2010 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test decorators.
"""

import unittest
import time
from cStringIO import StringIO
import linkcheck.decorators


class TestDecorators (unittest.TestCase):
    """
    Test decorators.
    """

    def test_timeit (self):
        @linkcheck.decorators.timed()
        def f ():
            return 42
        self.assertEqual(f(), 42)

    def test_timeit2 (self):
        log = StringIO()
        @linkcheck.decorators.timed(log=log, limit=0)
        def f ():
            time.sleep(1)
            return 42
        self.assertEqual(f(), 42)
        self.assertTrue(log.getvalue())

########NEW FILE########
__FILENAME__ = test_dummy
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test dummy object.
"""

import unittest
import linkcheck.dummy


class TestDummy (unittest.TestCase):
    """
    Test dummy object.
    """

    def test_creation (self):
        dummy = linkcheck.dummy.Dummy()
        dummy = linkcheck.dummy.Dummy("1")
        dummy = linkcheck.dummy.Dummy("1", "2")
        dummy = linkcheck.dummy.Dummy(a=1, b=2)
        dummy = linkcheck.dummy.Dummy("1", a=None, b=2)

    def test_attributes (self):
        dummy = linkcheck.dummy.Dummy()
        dummy.hulla
        dummy.hulla.bulla
        dummy.hulla = 1
        del dummy.wulla
        del dummy.wulla.mulla

    def test_methods (self):
        dummy = linkcheck.dummy.Dummy()
        dummy.hulla()
        dummy.hulla().bulla()
        if "a" in dummy:
            pass

    def test_indexes (self):
        dummy = linkcheck.dummy.Dummy()
        len(dummy)
        dummy[1] = dummy[2]
        dummy[1][-1]
        dummy[1:3] = None
        del dummy[1]
        del dummy[2]
        del dummy[2:3]
        str(dummy)
        repr(dummy)
        unicode(dummy)

########NEW FILE########
__FILENAME__ = test_filenames
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test filename routines.
"""

import unittest
import os
from linkcheck.checker.fileurl import get_nt_filename
from . import need_windows


class TestFilenames (unittest.TestCase):
    """
    Test filename routines.
    """

    @need_windows
    def test_nt_filename (self):
        path = os.getcwd()
        realpath = get_nt_filename(path)
        self.assertEqual(path, realpath)
        path = 'c:\\'
        realpath = get_nt_filename(path)
        self.assertEqual(path, realpath)
        # XXX Only works on my computer.
        # Is there a Windows UNC share that is always available for tests?
        #path = '\\Vboxsrv\share\msg.txt'
        #realpath = get_nt_filename(path)
        #self.assertEqual(path, realpath)

########NEW FILE########
__FILENAME__ = test_fileutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test file utility functions.
"""

import unittest
import linkcheck.fileutil

file_existing = __file__
file_non_existing = "ZZZ.i_dont_exist"


class TestFileutil (unittest.TestCase):
    """Test file utility functions."""

    def test_size (self):
        self.assertTrue(linkcheck.fileutil.get_size(file_existing) > 0)
        self.assertEqual(linkcheck.fileutil.get_size(file_non_existing), -1)

    def test_mtime (self):
        self.assertTrue(linkcheck.fileutil.get_mtime(file_existing) > 0)
        self.assertEqual(linkcheck.fileutil.get_mtime(file_non_existing), 0)

########NEW FILE########
__FILENAME__ = test_ftpparse
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2010 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test ftpparse routine.
"""

import unittest
from linkcheck.ftpparse import ftpparse

patterns = (
    # EPLF format
    # http://pobox.com/~djb/proto/eplf.html
    ("+i8388621.29609,m824255902,/,\tdev",
     dict(name='dev', tryretr=False, trycwd=True)),
    ("+i8388621.44468,m839956783,r,s10376,\tRFCEPLF",
     dict(name='RFCEPLF', tryretr=True, trycwd=False)),
    # UNIX-style listing, without inum and without blocks
    ("-rw-r--r--   1 root     other        531 Jan 29 03:26 README",
     dict(name='README', tryretr=True, trycwd=False)),
    ("dr-xr-xr-x   2 root     other        512 Apr  8  1994 etc",
     dict(name='etc', tryretr=False, trycwd=True)),
    ("dr-xr-xr-x   2 root     512 Apr  8  1994 etc",
     dict(name='etc', tryretr=False, trycwd=True)),
    ("lrwxrwxrwx   1 root     other          7 Jan 25 00:17 bin -> usr/bin",
     dict(name='usr/bin', tryretr=True, trycwd=True)),
    # Also produced by Microsoft's FTP servers for Windows:
    ("----------   1 owner    group         1803128 Jul 10 10:18 ls-lR.Z",
     dict(name='ls-lR.Z', tryretr=True, trycwd=False)),
    ("d---------   1 owner    group               0 May  9 19:45 Softlib",
     dict(name='Softlib', tryretr=False, trycwd=True)),
    # Also WFTPD for MSDOS:
    ("-rwxrwxrwx   1 noone    nogroup      322 Aug 19  1996 message.ftp",
     dict(name='message.ftp', tryretr=True, trycwd=False)),
    # Also NetWare:
    ("d [R----F--] supervisor            512       Jan 16 18:53    login",
     dict(name='login', tryretr=False, trycwd=True)),
    ("- [R----F--] rhesus             214059       Oct 20 15:27    cx.exe",
     dict(name='cx.exe', tryretr=True, trycwd=False)),
    # Also NetPresenz for the Mac:
    ("-------r--         326  1391972  1392298 Nov 22  1995 MegaPhone.sit",
     dict(name='MegaPhone.sit', tryretr=True, trycwd=False)),
    ("drwxrwxr-x               folder        2 May 10  1996 network",
     dict(name='network', tryretr=False, trycwd=True)),
    # MultiNet (some spaces removed from examples)
    ("00README.TXT;1      2 30-DEC-1996 17:44 [SYSTEM] (RWED,RWED,RE,RE)",
     dict(name='00README.TXT', tryretr=True, trycwd=False)),
    ("CORE.DIR;1          1  8-SEP-1996 16:09 [SYSTEM] (RWE,RWE,RE,RE)",
     dict(name='CORE', tryretr=False, trycwd=True)),
    # and non-MutliNet VMS:
    ("CII-MANUAL.TEX;1  213/216  29-JAN-1996 03:33:12  [ANONYMOU,ANONYMOUS]   (RWED,RWED,,)",
     dict(name='CII-MANUAL.TEX', tryretr=True, trycwd=False)),
    # MSDOS format
    ("04-27-00  09:09PM       <DIR>          licensed",
     dict(name='licensed', tryretr=False, trycwd=True)),
    ("07-18-00  10:16AM       <DIR>          pub",
     dict(name='pub', tryretr=False, trycwd=True)),
    ("04-14-00  03:47PM                  589 readme.htm",
     dict(name='readme.htm', tryretr=True, trycwd=False)),
    # Some useless lines, safely ignored:
    ("Total of 11 Files, 10966 Blocks.", None), # (VMS)
    ("total 14786", None), # (UNIX)
    ("DISK$ANONFTP:[ANONYMOUS]", None), # (VMS)
    ("Directory DISK$PCSA:[ANONYM]", None), # (VMS)
    ("", None),
)


class TestFtpparse (unittest.TestCase):
    """
    Test FTP LIST line parsing.
    """

    def test_ftpparse (self):
        for line, expected in patterns:
            res = ftpparse(line)
            self.assertEqual(expected, res,
                "got %r\nexpected %r\n%r" % (res, expected, line))

########NEW FILE########
__FILENAME__ = test_gui
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009-2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
import unittest
import sys
from tests import need_pyqt, need_x11


class TestGui (unittest.TestCase):
    """Test OMT GUI client."""

    @need_pyqt
    @need_x11
    def test_gui (self):
        from PyQt4 import QtCore, QtGui, QtTest
        from linkcheck.gui import LinkCheckerMain
        app = QtGui.QApplication(sys.argv)
        window = LinkCheckerMain()
        window.show()
        QtTest.QTest.mouseClick(window.controlButton, QtCore.Qt.LeftButton)
        window.close()
        del window
        del app

########NEW FILE########
__FILENAME__ = test_linkchecker
# -*- coding: utf-8 -*-
# Copyright (C) 2014 Bastian Kleineidam
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import unittest
import sys
from . import linkchecker_cmd, run_checked


def run_with_options(options, cmd=linkchecker_cmd):
    """Run a command with given options."""
    run_checked([sys.executable, cmd] + options)


class TestLinkchecker (unittest.TestCase):
    """Test the linkchecker commandline client."""

    def test_linkchecker(self):
        # test some single options
        for option in ("-V", "--version", "-h", "--help", "--list-plugins", "-Dall"):
            run_with_options([option])
        # unknown option
        self.assertRaises(OSError, run_with_options, ['--imadoofus'])

########NEW FILE########
__FILENAME__ = test_linkname
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2009 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test linkname routines.
"""

import unittest
from linkcheck.htmlutil import linkname


class TestLinkname (unittest.TestCase):
    """
    Test href and image name parsing.
    """

    def image_name_test (self, txt, expected):
        """
        Helper function calling linkname.image_name().
        """
        self.assertEqual(linkname.image_name(txt), expected)

    def href_name_test (self, txt, expected):
        """
        Helper function calling linkname.href_name().
        """
        self.assertEqual(linkname.href_name(txt), expected)

    def test_image_name (self):
        """
        Test image name parsing.
        """
        self.image_name_test("<img src='' alt=''></a>", '')
        self.image_name_test("<img src alt=abc></a>", 'abc')

    def test_href_name (self):
        """
        Test href name parsing.
        """
        self.href_name_test("<b>guru guru</a>", 'guru guru')
        self.href_name_test("a\njo</a>", "a\njo")
        self.href_name_test("test<</a>", "test<")
        self.href_name_test("test</</a>", "test</")
        self.href_name_test("test</a</a>", "test</a")
        self.href_name_test("test", "")
        self.href_name_test("\n", "")
        self.href_name_test("", "")
        self.href_name_test('"</a>"foo', '"')
        self.href_name_test("<img src='' alt=''></a>", '')
        self.href_name_test("<img src alt=abc></a>", 'abc')

########NEW FILE########
__FILENAME__ = test_linkparser
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test linkparser routines.
"""

import unittest
from linkcheck.htmlutil import linkparse
import linkcheck.HtmlParser.htmlsax


class TestLinkparser (unittest.TestCase):
    """
    Test link parsing.
    """

    def _test_one_link (self, content, url):
        self.count_url = 0
        h = linkparse.LinkFinder(self._test_one_url(url), linkparse.LinkTags)
        p = linkcheck.HtmlParser.htmlsax.parser(h)
        h.parser = p
        try:
            p.feed(content)
            p.flush()
        except linkparse.StopParse:
            pass
        h.parser = None
        p.handler = None
        self.assertEqual(self.count_url, 1)

    def _test_one_url (self, origurl):
        """Return parser callback function."""
        def callback (url, line, column, name, base):
            self.count_url += 1
            self.assertEqual(origurl, url)
        return callback

    def _test_no_link (self, content):
        def callback (url, line, column, name, base):
            self.assertTrue(False, 'URL %r found' % url)
        h = linkparse.LinkFinder(callback, linkparse.LinkTags)
        p = linkcheck.HtmlParser.htmlsax.parser(h)
        h.parser = p
        try:
            p.feed(content)
            p.flush()
        except linkparse.StopParse:
            pass
        h.parser = None
        p.handler = None

    def test_href_parsing (self):
        # Test <a href> parsing.
        content = u'<a href="%s">'
        url = u"alink"
        self._test_one_link(content % url, url)
        url = u" alink"
        self._test_one_link(content % url, url)
        url = u"alink "
        self._test_one_link(content % url, url)
        url = u" alink "
        self._test_one_link(content % url, url)

    def test_img_srcset_parsing(self):
        content = u'<img srcset="%s 1x">'
        url = u"imagesmall.jpg"
        self._test_one_link(content % url, url)

    def test_itemtype_parsing(self):
        content = u'<div itemtype="%s">'
        url = u"http://example.org/Movie"
        self._test_one_link(content % url, url)

    def test_form_parsing(self):
        # Test <form action> parsing
        content = u'<form action="%s">'
        url = u"alink"
        self._test_one_link(content % url, url)
        content = u'<form action="%s" method="POST">'
        url = u"alink"
        self._test_no_link(content % url)

    def test_css_parsing (self):
        # Test css style attribute parsing.
        content = u'<table style="background: url(%s) no-repeat" >'
        url = u"alink"
        self._test_one_link(content % url, url)
        content = u'<table style="background: url(%s) no-repeat" >'
        self._test_one_link(content % url, url)
        content = u'<table style="background: url(%s ) no-repeat" >'
        self._test_one_link(content % url, url)
        content = u'<table style="background: url( %s ) no-repeat" >'
        self._test_one_link(content % url, url)
        content = u'<table style="background: url(\'%s\') no-repeat" >'
        self._test_one_link(content % url, url)
        content = u"<table style='background: url(\"%s\") no-repeat' >"
        self._test_one_link(content % url, url)
        content = u'<table style="background: url(\'%s\' ) no-repeat" >'
        self._test_one_link(content % url, url)
        content = u"<table style='background: url( \"%s\") no-repeat' >"
        self._test_one_link(content % url, url)

    def test_comment_stripping (self):
        strip = linkparse.strip_c_comments
        content = "/* url('http://example.org')*/"
        self.assertEqual(strip(content), "")
        content = "/* * * **/"
        self.assertEqual(strip(content), "")
        content = "/* * /* * **//* */"
        self.assertEqual(strip(content), "")
        content = "a/* */b/* */c"
        self.assertEqual(strip(content), "abc")

########NEW FILE########
__FILENAME__ = test_mimeutil
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2010-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test mime utility functions.
"""

import unittest
import os
from . import get_file
import linkcheck.mimeutil

class TestMiMeutil (unittest.TestCase):
    """Test file utility functions."""

    def mime_test (self, filename, mime_expected):
        absfilename = get_file(filename)
        with open(absfilename) as fd:
            mime = linkcheck.mimeutil.guess_mimetype(absfilename, read=fd.read)
        self.assertEqual(mime, mime_expected)

    def test_mime (self):
        filename = os.path.join("plist_binary", "Bookmarks.plist")
        self.mime_test(filename, "application/x-plist+safari")
        filename = os.path.join("plist_xml", "Bookmarks.plist")
        self.mime_test(filename, "application/x-plist+safari")
        self.mime_test("file.wml", "text/vnd.wap.wml")
        self.mime_test("sitemap.xml", "application/xml+sitemap")
        self.mime_test("sitemapindex.xml", "application/xml+sitemapindex")

########NEW FILE########
__FILENAME__ = test_network
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2008-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test network functions.
"""

import unittest
from tests import need_posix, need_network, need_linux
import linkcheck.network
from linkcheck.network import iputil


class TestNetwork (unittest.TestCase):
    """Test network functions."""

    @need_posix
    def test_ifreq_size (self):
        self.assertTrue(linkcheck.network.ifreq_size() > 0)

    @need_posix
    def test_interfaces (self):
        ifc = linkcheck.network.IfConfig()
        ifc.getInterfaceList()

    @need_network
    @need_linux
    def test_iputils (self):
        # note: need a hostname whose reverse lookup of the IP is the same host
        host = "dinsdale.python.org"
        ips = iputil.resolve_host(host)
        self.assertTrue(len(ips) > 0)
        for ip in ips:
            if iputil.is_valid_ipv4(ip):
                obfuscated = iputil.obfuscate_ip(ip)
                self.assertTrue(iputil.is_obfuscated_ip(obfuscated))
                hosts = iputil.lookup_ips([obfuscated])
                self.assertTrue(host in hosts)

########NEW FILE########
__FILENAME__ = test_parser
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test html parsing.
"""

import linkcheck.HtmlParser.htmlsax
import linkcheck.HtmlParser.htmllib
from cStringIO import StringIO
import unittest


# list of tuples
# (<test pattern>, <expected parse output>)
parsetests = [
    # start tags
    ("""<a  b="c" >""", """<a b="c">"""),
    ("""<a  b='c' >""", """<a b="c">"""),
    ("""<a  b=c" >""", """<a b="c">"""),
    ("""<a  b=c' >""", """<a b="c'">"""),
    ("""<a  b="c >""", """<a  b="c >"""),
    ("""<a  b="" >""", """<a b="">"""),
    ("""<a  b='' >""", """<a b="">"""),
    ("""<a  b=>""", """<a b="">"""),
    ("""<a  b= >""", """<a b="">"""),
    ("""<a  =c>""", """<a c>"""),
    ("""<a  =c >""", """<a c>"""),
    ("""<a  =>""", """<a>"""),
    ("""<a  = >""", """<a>"""),
    ("""<a  b= "c" >""", """<a b="c">"""),
    ("""<a  b ="c" >""", """<a b="c">"""),
    ("""<a  b = "c" >""", """<a b="c">"""),
    ("""<a >""", """<a>"""),
    ("""< a>""", """<a>"""),
    ("""< a >""", """<a>"""),
    ("""<>""", """<>"""),
    ("""< >""", """< >"""),
    ("""<a>""", """<a>"""),
    ("""<a a="b">""", """<a a="b">"""),
    ("""<a a="b">""", """<a a="b&#228;">"""),
    # multiple attribute names should be ignored...
    ("""<a b="c" b="c" >""", """<a b="c">"""),
    # ... but which one wins - in our implementation the last one
    ("""<a b="c" b="d" >""", """<a b="d">"""),
    # reduce test
    ("""<a  b="c"><""", """<a b="c"><"""),
    ("""d>""", """d>"""),
    # numbers in tag
    ("""<h1>bla</h1>""", """<h1>bla</h1>"""),
    # more start tags
    ("""<a  b=c"><a b="c">""", """<a b="c"><a b="c">"""),
    ("""<a  b=/c/></a><br>""", """<a b="/c/"></a><br>"""),
    ("""<br/>""", """<br>"""),
    ("""<a  b="50%"><br>""", """<a b="50%"><br>"""),
    # comments
    ("""<!---->< 1>""", """<!----><1>"""),
    ("""<!-- a - b -->< 2>""", """<!-- a - b --><2>"""),
    ("""<!----->< 3>""", """<!-----><3>"""),
    ("""<!------>< 4>""", """<!------><4>"""),
    ("""<!------->< 5>""", """<!-------><5>"""),
    ("""<!-- -->< 7>""", """<!-- --><7>"""),
    ("""<!---- />-->""", """<!---- />-->"""),
    ("""<!-- a-2 -->< 9>""", """<!-- a-2 --><9>"""),
    ("""<!-- --- -->< 10>""", """<!-- --- --><10>"""),
    ("""<!>""", """<!---->"""), # empty comment
    # invalid comments
    ("""<!-- -- >< 8>""", """<!-- --><8>"""),
    ("""<!---- >< 6>""", """<!----><6>"""),
    ("""<!- blubb ->""", """<!-- blubb -->"""),
    ("""<! -- blubb -->""", """<!-- blubb -->"""),
    ("""<!-- blubb -- >""", """<!-- blubb -->"""),
    ("""<! blubb !>< a>""", """<!--blubb !--><a>"""),
    ("""<! blubb >< a>""", """<!--blubb --><a>"""),
    # end tags
    ("""</a>""", """</a>"""),
    ("""</ a>""", """</a>"""),
    ("""</ a >""", """</a>"""),
    ("""</a >""", """</a>"""),
    ("""< / a>""", """</a>"""),
    ("""< /a>""", """</a>"""),
    ("""</a>""", """</a>"""),
    # start and end tag (HTML doctype assumed)
    ("""<a/>""", """<a/>"""),
    ("""<meta/>""", """<meta>"""),
    ("""<MetA/>""", """<meta>"""),
    # declaration tags
    ("""<!DOCtype adrbook SYSTEM "adrbook.dtd">""",
     """<!DOCTYPE adrbook SYSTEM "adrbook.dtd">"""),
    # misc
    ("""<?xmL version="1.0" encoding="latin1"?>""",
     """<?xmL version="1.0" encoding="latin1"?>"""),
    # javascript
    ("""<script >\n</script>""", """<script>\n</script>"""),
    ("""<sCrIpt lang="a">bla </a> fasel</scripT>""",
     """<script lang="a">bla </a> fasel</script>"""),
    ("""<script ><!--bla//-->// </script >""",
     """<script><!--bla//-->// </script>"""),
    # line continuation (Dr. Fun webpage)
    ("""<img bo\\\nrder=0 >""", """<img border="0">"""),
    ("""<img align="mid\\\ndle">""", """<img align="middle">"""),
    ("""<img align='mid\\\ndle'>""", """<img align="middle">"""),
    # href with $
    ("""<a href="123$456">""", """<a href="123$456">"""),
    # quoting
    ("""<a  href=/ >""", """<a href="/">"""),
    ("""<a  href= />""", """<a href="/">"""),
    ("""<a  href= >""", """<a href="">"""),
    ("""<a  href="'" >""", """<a href="'">"""),
    ("""<a  href='"' >""", """<a href="&quot;">"""),
    ("""<a  href="bla" %]" >""", """<a href="bla">"""),
    ("""<a  href=bla" >""", """<a href="bla">"""),
    ("""<a onmouseover=blubb('nav1','',"""\
     """'/images/nav.gif',1);move(this); b="c">""",
     """<a onmouseover="blubb('nav1','',"""\
     """'/images/nav.gif',1);move(this);" b="c">"""),
    ("""<a onClick=location.href('/index.htm') b="c">""",
     """<a onclick="location.href('/index.htm')" b="c">"""),
    # entity resolving
    ("""<a  href="&#6D;ailto:" >""", """<a href="ailto:">"""),
    ("""<a  href="&amp;ailto:" >""", """<a href="&amp;ailto:">"""),
    ("""<a  href="&amp;amp;ailto:" >""", """<a href="&amp;amp;ailto:">"""),
    ("""<a  href="&hulla;ailto:" >""", """<a href="ailto:">"""),
    ("""<a  href="&#109;ailto:" >""", """<a href="mailto:">"""),
    ("""<a  href="&#x6D;ailto:" >""", """<a href="mailto:">"""),
    # note that \u8156 is not valid encoding and therefore gets removed
    ("""<a  href="&#8156;ailto:" >""", """<a href="ailto:">"""),
    # non-ascii characters
    ("""<zgr> fahr </langsamer> {""",
     """<zgr> fahr </langsamer> {"""),
    # mailto link
    ("""<a  href=mailto:calvin@LocalHost?subject=Hallo&to=michi>1</a>""",
     """<a href="mailto:calvin@LocalHost?subject=Hallo&amp;to=michi">1</a>"""),
    # doctype XHTML
    ("""<!DOCTYPe html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><MeTa a="b"/>""",
     """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><meta a="b"/>"""),
    # meta tag with charset encoding
    ("""<meta http-equiv="content-type" content>""",
     """<meta http-equiv="content-type" content>"""),
    ("""<meta http-equiv="content-type" content=>""",
     """<meta http-equiv="content-type" content="">"""),
    ("""<meta http-equiv="content-type" content="hulla">""",
     """<meta http-equiv="content-type" content="hulla">"""),
    ("""<meta http-equiv="content-type" content="text/html; charset=iso8859-1">""",
     """<meta http-equiv="content-type" content="text/html; charset=iso8859-1">"""),
    ("""<meta http-equiv="content-type" content="text/html; charset=hulla">""",
     """<meta http-equiv="content-type" content="text/html; charset=hulla">"""),
    # CDATA
    ("""<![CDATA[<a>hallo</a>]]>""", """<![CDATA[<a>hallo</a>]]>"""),
    # missing > in end tag
    ("""</td <td  a="b" >""", """</td><td a="b">"""),
    ("""</td<td  a="b" >""", """</td><td a="b">"""),
    # missing beginning quote
    ("""<td a=b">""", """<td a="b">"""),
    # stray < before start tag
    ("""<0.<td  a="b" >""", """<0.<td a="b">"""),
    # stray < before end tag
    ("""<0.</td >""", """<0.</td>"""),
    # missing end quote (XXX TODO)
    #("""<td a="b>\n""", """<td a="b">\n"""),
    #("""<td a="b></td>\na""", """<td a="b"></td>\na"""),
    #("""<a  b="c><a b="c>\n""", """<a b="c"><a b="c">\n"""),
    #("""<td a="b c="d"></td>\n""", """<td a="b" c="d"></td>\n"""),
    # HTML5 tags
    ("""<audio  src=bla>""", """<audio src="bla">"""),
    ("""<button  formaction=bla>""", """<button formaction="bla">"""),
    ("""<html  manifest=bla>""", """<html manifest="bla">"""),
    ("""<source  src=bla>""", """<source src="bla">"""),
    ("""<track  src=bla>""", """<track src="bla">"""),
    ("""<video  src=bla>""", """<video src="bla">"""),
]

flushtests = [
    ("<", "<"),
    ("<a", "<a"),
    ("<!a", "<!a"),
    ("<?a", "<?a"),
]


class TestParser (unittest.TestCase):
    """
    Test html parser.
    """

    def setUp (self):
        """
        Initialize two internal html parsers to be used for testing.
        """
        self.htmlparser = linkcheck.HtmlParser.htmlsax.parser()
        self.htmlparser2 = linkcheck.HtmlParser.htmlsax.parser()

    def test_parse (self):
        # Parse all test patterns in one go.
        for _in, _out in parsetests:
            out = StringIO()
            handler = linkcheck.HtmlParser.htmllib.HtmlPrettyPrinter(out)
            self.htmlparser.handler = handler
            self.htmlparser.feed(_in)
            self.check_results(self.htmlparser, _in, _out, out)

    def check_results (self, htmlparser, _in, _out, out):
        """
        Check parse results.
        """
        htmlparser.flush()
        res = out.getvalue()
        msg = "Test error; in: %r, out: %r, expect: %r" % \
           (_in, res, _out)
        self.assertEqual(res, _out, msg=msg)
        htmlparser.reset()

    def test_feed (self):
        # Parse all test patterns sequentially.
        for _in, _out in parsetests:
            out = StringIO()
            handler = linkcheck.HtmlParser.htmllib.HtmlPrettyPrinter(out)
            self.htmlparser.handler = handler
            for c in _in:
                self.htmlparser.feed(c)
            self.check_results(self.htmlparser, _in, _out, out)

    def test_interwoven (self):
        # Parse all test patterns on two parsers interwoven.
        for _in, _out in parsetests:
            out = StringIO()
            out2 = StringIO()
            handler = linkcheck.HtmlParser.htmllib.HtmlPrettyPrinter(out)
            self.htmlparser.handler = handler
            handler2 = linkcheck.HtmlParser.htmllib.HtmlPrettyPrinter(out2)
            self.htmlparser2.handler = handler2
            for c in _in:
                self.htmlparser.feed(c)
                self.htmlparser2.feed(c)
            self.check_results(self.htmlparser, _in, _out, out)
            self.check_results(self.htmlparser2, _in, _out, out2)

    def test_handler (self):
        for _in, _out in parsetests:
            out = StringIO()
            out2 = StringIO()
            handler = linkcheck.HtmlParser.htmllib.HtmlPrinter(out)
            self.htmlparser.handler = handler
            handler2 = linkcheck.HtmlParser.htmllib.HtmlPrinter(out2)
            self.htmlparser2.handler = handler2
            for c in _in:
                self.htmlparser.feed(c)
                self.htmlparser2.feed(c)
            self.assertEqual(out.getvalue(), out2.getvalue())

    def test_flush (self):
        # Test parser flushing.
        for _in, _out in flushtests:
            out = StringIO()
            handler = linkcheck.HtmlParser.htmllib.HtmlPrettyPrinter(out)
            self.htmlparser.handler = handler
            self.htmlparser.feed(_in)
            self.check_results(self.htmlparser, _in, _out, out)

    def test_entities (self):
        # Test entity resolving.
        resolve = linkcheck.HtmlParser.resolve_entities
        for c in "abcdefghijklmnopqrstuvwxyz":
            self.assertEqual(resolve("&#%d;" % ord(c)), c)
        self.assertEqual(resolve("&#1114112;"), u"")

    def test_peek (self):
        # Test peek() parser function
        data = '<a href="test.html">name</a>'

        class NamePeeker (object):

            def start_element (self_handler, tag, attrs):
                # use self reference of TestParser instance
                self.assertRaises(TypeError, self.htmlparser.peek, -1)
                self.assertEqual(self.htmlparser.peek(0), "")
                self.assertEqual(self.htmlparser.peek(4), "name")

        self.htmlparser.handler = NamePeeker()
        self.htmlparser.feed(data)

    def test_encoding_detection (self):
        html = '<meta http-equiv="content-type" content="text/html; charset=UTF-8">'
        self.encoding_test(html, "utf-8")
        html = '<meta charset="UTF-8">'
        self.encoding_test(html, "utf-8")
        html = '<meta charset="hulla">'
        self.encoding_test(html, "iso8859-1")
        html = '<meta http-equiv="content-type" content="text/html; charset=blabla">'
        self.encoding_test(html, "iso8859-1")

    def encoding_test (self, html, expected):
        parser = linkcheck.HtmlParser.htmlsax.parser()
        self.assertEqual(parser.encoding, "iso8859-1")
        parser.feed(html)
        self.assertEqual(parser.encoding, expected)

########NEW FILE########
__FILENAME__ = test_po
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005 Joe Wreschnig
# Copyright (C) 2005-2010 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test gettext .po files.
"""

import unittest
import os
import glob
from tests import need_msgfmt, need_posix


pofiles = None

def get_pofiles ():
    """Find all .po files in this source."""
    global pofiles
    if pofiles is None:
        pofiles = []
        pofiles.extend(glob.glob("po/*.po"))
        pofiles.extend(glob.glob("doc/*.po"))
    return pofiles


class TestPo (unittest.TestCase):
    """Test .po file syntax."""

    @need_posix
    @need_msgfmt
    def test_pos (self):
        """Test .po files syntax."""
        for f in get_pofiles():
            ret = os.system("msgfmt -c -o - %s > /dev/null" % f)
            self.assertEqual(ret, 0, msg="PO-file syntax error in %r" % f)


class TestGTranslator (unittest.TestCase):
    """GTranslator displays a middot  for a space. Unfortunately, it
    gets copied with copy-and-paste, what a shame."""

    def test_gtranslator (self):
        """Test all pofiles for GTranslator brokenness."""
        for f in get_pofiles():
            fd = file(f)
            try:
                self.check_file(fd, f)
            finally:
                fd.close()

    def check_file (self, fd, f):
        """Test for GTranslator broken syntax."""
        for line in fd:
            if line.strip().startswith("#"):
                continue
            self.assertFalse("\xc2\xb7" in line,
                 "Broken GTranslator copy/paste in %r:\n%r" % (f, line))

########NEW FILE########
__FILENAME__ = test_robotparser
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2012 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test robots.txt parsing.
"""

import unittest
from tests import need_network
from linkcheck import configuration, robotparser2


class TestRobotParser (unittest.TestCase):
    """
    Test robots.txt parser (needs internet access).
    """

    def setUp (self):
        """Initialize self.rp as a robots.txt parser."""
        self.rp = robotparser2.RobotFileParser()

    def check (self, a, b):
        """Helper function comparing two results a and b."""
        if not b:
            ac = "access denied"
        else:
            ac = "access allowed"
        if a != b:
            self.fail("%s != %s (%s)" % (a, b, ac))

    @need_network
    def test_nonexisting_robots (self):
        # robots.txt that does not exist
        self.rp.set_url('http://www.lycos.com/robots.txt')
        self.rp.read()
        self.check(self.rp.can_fetch(configuration.UserAgent,
                                     'http://www.lycos.com/search'), True)

    @need_network
    def test_disallowed_robots (self):
        self.rp.set_url('http://google.com/robots.txt')
        self.rp.read()
        self.check(self.rp.can_fetch(configuration.UserAgent,
                                     "http://google.com/search"), False)

########NEW FILE########
__FILENAME__ = test_robotstxt
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2006-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test robots.txt parsing.
"""

import unittest
import linkcheck.robotparser2


class TestRobotsTxt (unittest.TestCase):
    """
    Test string formatting routines.
    """

    def setUp (self):
        """
        Initialize self.rp as a robots.txt parser.
        """
        self.rp = linkcheck.robotparser2.RobotFileParser()

    def test_robotstxt (self):
        lines = [
            "User-agent: *",
        ]
        self.rp.parse(lines)
        self.assertTrue(self.rp.mtime() > 0)
        self.assertEqual(str(self.rp), "\n".join(lines))

    def test_robotstxt2 (self):
        lines = [
            "User-agent: *",
            "Disallow: /search",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines))

    def test_robotstxt3 (self):
        lines = [
            "Disallow: /search",
            "",
            "Allow: /search",
            "",
            "Crawl-Delay: 5",
            "",
            "Blabla",
            "",
            "Bla: bla",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "")

    def test_robotstxt4 (self):
        lines = [
            "User-agent: Bla",
            "Disallow: /cgi-bin",
            "User-agent: *",
            "Disallow: /search",
        ]
        self.rp.parse(lines)
        lines.insert(2, "")
        self.assertEqual(str(self.rp), "\n".join(lines))

    def test_robotstxt5 (self):
        lines = [
            "#one line comment",
            "User-agent: Bla",
            "Disallow: /cgi-bin # comment",
            "Allow: /search",
        ]
        lines2 = [
            "User-agent: Bla",
            "Disallow: /cgi-bin",
            "Allow: /search",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))

    def test_robotstxt6 (self):
        lines = [
            "User-agent: Bla",
            "",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "")

    def test_robotstxt7 (self):
        lines = [
            "User-agent: Bla",
            "Allow: /",
            "",
            "User-agent: *",
            "Disallow: /",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines))
        self.assertTrue(self.rp.can_fetch("Bla", "/"))

    def test_crawldelay (self):
        lines = [
            "User-agent: Blubb",
            "Crawl-delay: 10",
            "",
            "User-agent: Hulla",
            "Crawl-delay: 5",
            "",
            "User-agent: *",
            "Crawl-delay: 1",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines))
        self.assertEqual(self.rp.get_crawldelay("Blubb"), 10)
        self.assertEqual(self.rp.get_crawldelay("Hulla"), 5)
        self.assertEqual(self.rp.get_crawldelay("Bulla"), 1)

    def test_crawldelay2 (self):
        lines = [
            "User-agent: Blubb",
            "Crawl-delay: X",
        ]
        self.rp.parse(lines)
        del lines[1]
        self.assertEqual(str(self.rp), "\n".join(lines))

    def check_urls (self, good, bad, agent="test_robotparser"):
        for url in good:
            self.check_url(agent, url, True)
        for url in bad:
            self.check_url(agent, url, False)

    def check_url (self, agent, url, can_fetch):
        if isinstance(url, tuple):
            agent, url = url
        res = self.rp.can_fetch(agent, url)
        if can_fetch:
            self.assertTrue(res, "%s disallowed" % url)
        else:
            self.assertFalse(res, "%s allowed" % url)

    def test_access1 (self):
        lines = [
            "User-agent: *",
            "Disallow: /cyberworld/map/ # This is an infinite virtual URL space",
            "Disallow: /tmp/ # these will soon disappear",
            "Disallow: /foo.html",
        ]
        lines2 = [
            "User-agent: *",
            "Disallow: /cyberworld/map/",
            "Disallow: /tmp/",
            "Disallow: /foo.html",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))
        good = ['/', '/test.html']
        bad = ['/cyberworld/map/index.html', '/tmp/xxx', '/foo.html']
        self.check_urls(good, bad)

    def test_access2 (self):
        lines = [
            "# robots.txt for http://www.example.com/",
            "",
            "User-agent: *",
            "Disallow: /cyberworld/map/ # This is an infinite virtual URL space",
            "",
            "# Cybermapper knows where to go.",
            "User-agent: cybermapper",
            "Disallow:",
            "",
        ]
        lines2 = [
            "User-agent: cybermapper",
            "Allow: /",
            "",
            "User-agent: *",
            "Disallow: /cyberworld/map/",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))
        good = ['/', '/test.html', ('cybermapper', '/cyberworld/map/index.html')]
        bad = ['/cyberworld/map/index.html']
        self.check_urls(good, bad)

    def test_access3 (self):
        lines = [
            "# go away",
            "User-agent: *",
            "Disallow: /",
        ]
        lines2 = [
            "User-agent: *",
            "Disallow: /",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))
        good = []
        bad = ['/cyberworld/map/index.html', '/', '/tmp/']
        self.check_urls(good, bad)

    def test_access4 (self):
        lines = [
            "User-agent: figtree",
            "Disallow: /tmp",
            "Disallow: /a%3cd.html",
            "Disallow: /a%2fb.html",
            "Disallow: /%7ejoe/index.html",
        ]
        lines2 = [
            "User-agent: figtree",
            "Disallow: /tmp",
            "Disallow: /a%3Cd.html",
            "Disallow: /a/b.html",
            "Disallow: /%7Ejoe/index.html",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))
        good = []
        bad = ['/tmp', '/tmp.html', '/tmp/a.html',
               '/a%3cd.html', '/a%3Cd.html', '/a%2fb.html',
               '/~joe/index.html', '/a/b.html',
        ]
        self.check_urls(good, bad, 'figtree')
        self.check_urls(good, bad, 'FigTree/1.0 Robot libwww-perl/5.04')

    def test_access5 (self):
        lines = [
            "User-agent: *",
            "Disallow: /tmp/",
            "Disallow: /a%3Cd.html",
            "Disallow: /a/b.html",
            "Disallow: /%7ejoe/index.html",
        ]
        lines2 = [
            "User-agent: *",
            "Disallow: /tmp/",
            "Disallow: /a%3Cd.html",
            "Disallow: /a/b.html",
            "Disallow: /%7Ejoe/index.html",
        ]
        self.rp.parse(lines)
        self.assertEqual(str(self.rp), "\n".join(lines2))
        good = ['/tmp'] # XFAIL: '/a%2fb.html'
        bad = ['/tmp/', '/tmp/a.html',
               '/a%3cd.html', '/a%3Cd.html', "/a/b.html",
               '/%7Ejoe/index.html']
        self.check_urls(good, bad)

    def test_access6 (self):
        lines = [
            "User-Agent: *",
            "Disallow: /.",
        ]
        self.rp.parse(lines)
        good = ['/foo.html']
        bad = [] # Bug report says "/" should be denied, but that is not in the RFC
        self.check_urls(good, bad)

    def test_access7 (self):
        lines = [
            "User-agent: Example",
            "Disallow: /example",
            "",
            "User-agent: *",
            "Disallow: /cgi-bin",
        ]
        self.rp.parse(lines)
        # test re.escape
        self.check_url("*", "/", True)
        # should match first agent
        self.check_url("", "/example", False)
        # test agent matching
        self.check_url("Example", "/example", False)
        self.check_url("Example/1.0", "/example", False)
        self.check_url("example", "/example", False)
        self.check_url("spam", "/cgi-bin", False)
        self.check_url("spam", "/cgi-bin/foo/bar", False)
        self.check_url("spam", "/cgi-bin?a=1", False)
        self.check_url("spam", "/", True)

    def test_sitemap(self):
        lines = [
            "Sitemap: bla",
        ]
        self.rp.parse(lines)
        self.assertTrue(len(self.rp.sitemap_urls) > 0)
        self.assertTrue(self.rp.sitemap_urls[0] == ("bla", 1))

########NEW FILE########
__FILENAME__ = test_strformat
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test string formatting operations.
"""

import unittest
import os
import time
import linkcheck.strformat


class TestStrFormat (unittest.TestCase):
    """
    Test string formatting routines.
    """

    def test_unquote (self):
        # Test quote stripping.
        u = linkcheck.strformat.unquote
        self.assertEqual(u(""), "")
        self.assertEqual(u(None), None)
        self.assertEqual(u("'"), "'")
        self.assertEqual(u("\""), "\"")
        self.assertEqual(u("\"\""), "")
        self.assertEqual(u("''"), "")
        self.assertEqual(u("'a'"), "a")
        self.assertEqual(u("'a\"'"), "a\"")
        self.assertEqual(u("'\"a'"), "\"a")
        self.assertEqual(u('"a\'"'), 'a\'')
        self.assertEqual(u('"\'a"'), '\'a')
        self.assertEqual(u("'a'", matching=True), "a")
        self.assertEqual(u('"a"', matching=True), "a")
        # even mis-matching quotes should be removed...
        self.assertEqual(u("'a\""), "a")
        self.assertEqual(u("\"a'"), "a")
        # ...but not when matching is True
        self.assertEqual(u("'a\"", matching=True), "'a\"")
        self.assertEqual(u("\"a'", matching=True), "\"a'")

    def test_wrap (self):
        # Test line wrapping.
        wrap = linkcheck.strformat.wrap
        s = "11%(sep)s22%(sep)s33%(sep)s44%(sep)s55" % {'sep': os.linesep}
        # testing width <= 0
        self.assertEqual(wrap(s, -1), s)
        self.assertEqual(wrap(s, 0), s)
        l = len(os.linesep)
        gap = " "
        s2 = "11%(gap)s22%(sep)s33%(gap)s44%(sep)s55" % \
             {'sep': os.linesep, 'gap': gap}
        # splitting lines
        self.assertEqual(wrap(s2, 2), s)
        # combining lines
        self.assertEqual(wrap(s, 4+l), s2)
        # misc
        self.assertEqual(wrap(s, -1), s)
        self.assertEqual(wrap(s, 0), s)
        self.assertEqual(wrap(None, 10), None)
        self.assertFalse(linkcheck.strformat.get_paragraphs(None))

    def test_remove_markup (self):
        # Test markup removing.
        self.assertEqual(linkcheck.strformat.remove_markup("<a>"), "")
        self.assertEqual(linkcheck.strformat.remove_markup("<>"), "")
        self.assertEqual(linkcheck.strformat.remove_markup("<<>"), "")
        self.assertEqual(linkcheck.strformat.remove_markup("a < b"), "a < b")

    def test_strsize (self):
        # Test byte size strings.
        self.assertRaises(ValueError, linkcheck.strformat.strsize, -1)
        self.assertEqual(linkcheck.strformat.strsize(0), "0B")
        self.assertEqual(linkcheck.strformat.strsize(1), "1B")
        self.assertEqual(linkcheck.strformat.strsize(2), "2B")
        self.assertEqual(linkcheck.strformat.strsize(1023, grouping=False), "1023B")
        self.assertEqual(linkcheck.strformat.strsize(1024), "1KB")
        self.assertEqual(linkcheck.strformat.strsize(1024*25), "25.00KB")
        self.assertEqual(linkcheck.strformat.strsize(1024*1024), "1.00MB")
        self.assertEqual(linkcheck.strformat.strsize(1024*1024*11), "11.0MB")
        self.assertEqual(linkcheck.strformat.strsize(1024*1024*1024),
            "1.00GB")
        self.assertEqual(linkcheck.strformat.strsize(1024*1024*1024*14),
            "14.0GB")

    def test_is_ascii (self):
        self.assertTrue(linkcheck.strformat.is_ascii("abcd./"))
        self.assertTrue(not linkcheck.strformat.is_ascii(""))
        self.assertTrue(not linkcheck.strformat.is_ascii(u""))

    def test_indent (self):
        s = "bla"
        self.assertEqual(linkcheck.strformat.indent(s, ""), s)
        self.assertEqual(linkcheck.strformat.indent(s, " "), " "+s)

    def test_stripurl (self):
        self.assertEqual(linkcheck.strformat.stripurl(u"a\tb"), u"a\tb")
        self.assertEqual(linkcheck.strformat.stripurl(u" a\t b"), u"a\t b")
        self.assertEqual(linkcheck.strformat.stripurl(u" ab\t\ra\nb"), u"ab")
        self.assertEqual(linkcheck.strformat.stripurl(None), None)
        self.assertEqual(linkcheck.strformat.stripurl(u""), u"")

    def test_limit (self):
        self.assertEqual(linkcheck.strformat.limit("", 0), "")
        self.assertEqual(linkcheck.strformat.limit("a", 0), "")
        self.assertEqual(linkcheck.strformat.limit("1", 1), "1")
        self.assertEqual(linkcheck.strformat.limit("11", 1), "1...")

    def test_strtime (self):
        zone = linkcheck.strformat.strtimezone()
        t = linkcheck.strformat.strtime(0, func=time.gmtime)
        self.assertEqual(t, "1970-01-01 00:00:00"+zone)

    def test_duration (self):
        duration = linkcheck.strformat.strduration
        self.assertEqual(duration(-0.5), "-00:01")
        self.assertEqual(duration(0), "00:00")
        self.assertEqual(duration(0.9), "00:01")
        self.assertEqual(duration(1), "00:01")
        self.assertEqual(duration(2), "00:02")
        self.assertEqual(duration(60), "01:00")
        self.assertEqual(duration(120), "02:00")
        self.assertEqual(duration(60*60), "01:00:00")
        self.assertEqual(duration(60*60*24), "24:00:00")

    def test_duration_long (self):
        duration = lambda s: linkcheck.strformat.strduration_long(s, do_translate=False)
        self.assertEqual(duration(-0.5), "-0.50 seconds")
        self.assertEqual(duration(0), "0.00 seconds")
        self.assertEqual(duration(0.9), "0.90 seconds")
        self.assertEqual(duration(1), "1 second")
        self.assertEqual(duration(2), "2 seconds")
        self.assertEqual(duration(60), "1 minute")
        self.assertEqual(duration(120), "2 minutes")
        self.assertEqual(duration(60*60), "1 hour")
        self.assertEqual(duration(60*60*24), "1 day")
        self.assertEqual(duration(60*60*24*365), "1 year")
        self.assertEqual(duration(60*60*24*365 + 60*60*24 + 2),
                         "1 year, 1 day")

    def test_linenumber (self):
        get_line_number = linkcheck.strformat.get_line_number
        self.assertEqual(get_line_number("a", -5), 0)
        self.assertEqual(get_line_number("a", 0), 1)
        self.assertEqual(get_line_number("a\nb", 2), 2)

    def test_encoding (self):
        is_encoding = linkcheck.strformat.is_encoding
        self.assertTrue(is_encoding('ascii'))
        self.assertFalse(is_encoding('hulla'))

    def test_unicode_safe (self):
        unicode_safe = linkcheck.strformat.unicode_safe
        self.assertEqual(unicode_safe("a"), u"a")
        self.assertEqual(unicode_safe(u"a"), u"a")

    def test_ascii_safe (self):
        ascii_safe = linkcheck.strformat.ascii_safe
        self.assertEqual(ascii_safe("a"), "a")
        self.assertEqual(ascii_safe(u"a"), "a")
        self.assertEqual(ascii_safe(u""), "")

    def test_strip_control_chars(self):
        strip = linkcheck.strformat.strip_control_chars
        self.assertEqual(strip(""), "")
        self.assertEqual(strip(u""), u"")
        self.assertEqual(strip("a"), "a")
        self.assertEqual(strip(u"a"), u"a")
        self.assertEqual(strip(""), "")
        self.assertEqual(strip(u""), u"")
        self.assertEqual(strip("\x01"), "")
        self.assertEqual(strip(u"\x01"), u"")

########NEW FILE########
__FILENAME__ = test_updater
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test update check functionality.
"""

import unittest
from tests import need_network
import linkcheck.updater


class TestUpdater (unittest.TestCase):
    """Test update check."""

    @need_network
    def test_updater (self):
        res, value = linkcheck.updater.check_update()
        self.assertTrue(type(res) == bool)
        if res:
            self.assertTrue(value is None or isinstance(value, tuple))
            if isinstance(value, tuple):
                self.assertEqual(len(value), 2)
                version, url = value
                self.assertTrue(isinstance(version, basestring))
                self.assertTrue(url is None or isinstance(url, basestring))
        else:
            self.assertTrue(isinstance(value, unicode))

########NEW FILE########
__FILENAME__ = test_url
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test url routines.
"""
from . import need_network, need_posix, need_windows
import unittest
import os
import re
import linkcheck.url

# 'ftp://user:pass@ftp.foo.net/foo/bar':
#     'ftp://user:pass@ftp.foo.net/foo/bar',
# 'http://USER:pass@www.Example.COM/foo/bar':
#     'http://USER:pass@www.example.com/foo/bar',
# '-':                             '-',

# All portions of the URI must be utf-8 encoded NFC form Unicode strings
#valid:  http://example.com/?q=%C3%87   (C-cedilla U+00C7)
#valid: http://example.com/?q=%E2%85%A0 (Roman numeral one U+2160)
#invalid: http://example.com/?q=%C7      (C-cedilla ISO-8859-1)
#invalid: http://example.com/?q=C%CC%A7
#         (Latin capital letter C + Combining cedilla U+0327)


def url_norm (url, encoding=None):
    return linkcheck.url.url_norm(url, encoding=encoding)[0]


class TestUrl (unittest.TestCase):
    """Test url norming and quoting."""

    def urlnormtest (self, url, nurl, encoding=None):
        self.assertFalse(linkcheck.url.url_needs_quoting(nurl),
            "Result URL %r must not need quoting" % nurl)
        nurl1 = url_norm(url, encoding=encoding)
        self.assertFalse(linkcheck.url.url_needs_quoting(nurl1),
            "Normed URL %r needs quoting" % nurl)
        self.assertEqual(nurl1, nurl)

    def test_pathattack (self):
        # Windows winamp path attack prevention.
        url = "http://server/..%5c..%5c..%5c..%5c..%5c..%5c..%5c.."\
              "%5ccskin.zip"
        nurl = "http://server/cskin.zip"
        self.assertEqual(linkcheck.url.url_quote(url_norm(url)), nurl)

    def test_safe_patterns (self):
        is_safe_host = linkcheck.url.is_safe_host
        safe_host_pattern = linkcheck.url.safe_host_pattern
        self.assertTrue(is_safe_host("example.org"))
        self.assertTrue(is_safe_host("example.org:80"))
        self.assertTrue(not is_safe_host("example.org:21"))
        pat = safe_host_pattern("example.org")
        ro = re.compile(pat)
        self.assertTrue(ro.match("http://example.org:80/"))

    def test_url_quote (self):
        url_quote = linkcheck.url.url_quote
        url = "http://a:80/bcd"
        self.assertEqual(url_quote(url), url)
        url = "http://a:80/bcd?"
        url2 = "http://a:80/bcd"
        self.assertEqual(url_quote(url), url2)
        url = "http://a:80/bcd?a=b"
        url2 = "http://a:80/bcd?a=b"
        self.assertEqual(url_quote(url), url2)
        url = "a/b"
        self.assertEqual(url_quote(url), url)
        url = "bcd?"
        url2 = "bcd"
        self.assertEqual(url_quote(url), url2)
        url = "bcd?a=b"
        url2 = "bcd?a=b"
        self.assertEqual(url_quote(url), url2)

    def test_norm_quote (self):
        # Test url norm quoting.
        url = "http://groups.google.com/groups?hl=en&lr&ie=UTF-8&"\
              "threadm=3845B54D.E546F9BD%40monmouth.com&rnum=2&"\
              "prev=/groups%3Fq%3Dlogitech%2Bwingman%2Bextreme%2Bdigital"\
              "%2B3d%26hl%3Den%26lr%3D%26ie%3DUTF-8%26selm%3D3845B54D.E5"\
              "46F9BD%2540monmouth.com%26rnum%3D2"
        self.urlnormtest(url, url)
        url = "http://redirect.alexa.com/redirect?"\
              "http://www.offeroptimizer.com"
        self.urlnormtest(url, url)
        url = "http://www.lesgensducinema.com/photo/Philippe%20Nahon.jpg"
        self.urlnormtest(url, url)
        # Only perform percent-encoding where it is essential.
        url = "http://example.com/%7Ejane"
        nurl = "http://example.com/~jane"
        self.urlnormtest(url, nurl)
        url = "http://example.com/%7ejane"
        self.urlnormtest(url, nurl)
        # Always use uppercase A-through-F characters when percent-encoding.
        url = "http://example.com/?q=1%2a2"
        nurl = "http://example.com/?q=1%2A2"
        self.urlnormtest(url, nurl)
        # the no-quote chars
        url = "http://example.com/a*+-();b"
        self.urlnormtest(url, url)
        url = "http://linkchecker.git.sourceforge.net/git/gitweb.cgi?p=linkchecker/linkchecker;a=blob;f=doc/changelog.txt;hb=HEAD"
        self.urlnormtest(url, url)
        url = "http://www.company.com/path/doc.html?url=/path2/doc2.html?foo=bar"
        self.urlnormtest(url, url)
        url = "http://example.com/#a b"
        nurl = "http://example.com/#a%20b"
        self.urlnormtest(url, nurl)
        url = "http://example.com/?u=http://example2.com?b=c "
        nurl = "http://example.com/?u=http://example2.com?b=c%20"
        self.urlnormtest(url, nurl)
        url = "http://example.com/?u=http://example2.com?b="
        nurl = "http://example.com/?u=http://example2.com?b="
        self.urlnormtest(url, nurl)
        url = "http://localhost:8001/?quoted="
        nurl = "http://localhost:8001/?quoted=%FC"
        self.urlnormtest(url, nurl, encoding="iso-8859-1")
        url = "http://host/?a=b/c+d="
        nurl = "http://host/?a=b/c%20d%3D"
        self.urlnormtest(url, nurl)

    def test_norm_case_sensitivity (self):
        # Test url norm case sensitivity.
        # Always provide the URI scheme in lowercase characters.
        url = "HTTP://example.com/"
        nurl = "http://example.com/"
        self.urlnormtest(url, nurl)
        # Always provide the host, if any, in lowercase characters.
        url = "http://EXAMPLE.COM/"
        nurl = "http://example.com/"
        self.urlnormtest(url, nurl)
        url = "http://EXAMPLE.COM:55/"
        nurl = "http://example.com:55/"
        self.urlnormtest(url, nurl)

    def test_norm_defaultport (self):
        # Test url norm default port recognition.
        # For schemes that define a port, use an empty port if the default
        # is desired
        url = "http://example.com:80/"
        nurl = "http://example.com/"
        self.urlnormtest(url, nurl)
        url = "http://example.com:8080/"
        nurl = "http://example.com:8080/"
        self.urlnormtest(url, nurl)

    def test_norm_host_dot (self):
        # Test url norm host dot removal.
        url = "http://example.com./"
        nurl = "http://example.com/"
        self.urlnormtest(url, nurl)
        url = "http://example.com.:81/"
        nurl = "http://example.com:81/"
        self.urlnormtest(url, nurl)

    def test_norm_fragment (self):
        # Test url norm fragment preserving.
        # Empty fragment identifiers must be preserved:
        url = "http://www.w3.org/2000/01/rdf-schema#"
        nurl = url
        self.urlnormtest(url, nurl)
        url = "http://example.org/foo/ #a=1,2,3"
        nurl = "http://example.org/foo/%20#a%3D1%2C2%2C3"
        self.urlnormtest(url, nurl)

    def test_norm_empty_path (self):
        # Test url norm empty path handling.
        # For schemes that define an empty path to be equivalent to a
        # path of "/", use "/".
        url = "http://example.com"
        nurl = "http://example.com"
        self.urlnormtest(url, nurl)
        url = "http://example.com?a=b"
        nurl = "http://example.com/?a=b"
        self.urlnormtest(url, nurl)
        url = "http://example.com#foo"
        nurl = "http://example.com/#foo"
        self.urlnormtest(url, nurl)

    def test_norm_path_backslashes (self):
        # Test url norm backslash path handling.
        # note: this is not RFC conform (see url.py for more info)
        url = r"http://example.com\test.html"
        nurl = "http://example.com/test.html"
        self.urlnormtest(url, nurl)
        url = r"http://example.com/a\test.html"
        nurl = "http://example.com/a/test.html"
        self.urlnormtest(url, nurl)
        url = r"http://example.com\a\test.html"
        nurl = "http://example.com/a/test.html"
        self.urlnormtest(url, nurl)
        url = r"http://example.com\a/test.html"
        nurl = "http://example.com/a/test.html"
        self.urlnormtest(url, nurl)

    def test_norm_path_slashes (self):
        # Test url norm slashes in path handling.
        # reduce duplicate slashes
        url = "http://example.com//a/test.html"
        nurl = "http://example.com/a/test.html"
        self.urlnormtest(url, nurl)
        url = "http://example.com//a/b/"
        nurl = "http://example.com/a/b/"
        self.urlnormtest(url, nurl)

    def test_norm_path_dots (self):
        # Test url norm dots in path handling.
        # Prevent dot-segments appearing in non-relative URI paths.
        url = "http://example.com/a/./b"
        nurl = "http://example.com/a/b"
        self.urlnormtest(url, nurl)
        url = "http://example.com/a/../a/b"
        self.urlnormtest(url, nurl)
        url = "http://example.com/../a/b"
        self.urlnormtest(url, nurl)

    def test_norm_path_relative_dots (self):
        # Test url norm relative path handling with dots.
        # normalize redundant path segments
        url = '/foo/bar/.'
        nurl = '/foo/bar/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/./'
        nurl = '/foo/bar/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/..'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../baz'
        nurl = '/foo/baz'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../..'
        nurl = '/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../../'
        nurl = '/'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../../baz'
        nurl = '/baz'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../../../baz'
        nurl = '/baz'
        self.urlnormtest(url, nurl)
        url = '/foo/bar/../../../../baz'
        nurl = '/baz'
        self.urlnormtest(url, nurl)
        url = '/./foo'
        nurl = '/foo'
        self.urlnormtest(url, nurl)
        url = '/../foo'
        nurl = '/foo'
        self.urlnormtest(url, nurl)
        url = '/foo.'
        nurl = url
        self.urlnormtest(url, nurl)
        url = '/.foo'
        nurl = url
        self.urlnormtest(url, nurl)
        url = '/foo..'
        nurl = url
        self.urlnormtest(url, nurl)
        url = '/..foo'
        nurl = url
        self.urlnormtest(url, nurl)
        url = '/./../foo'
        nurl = '/foo'
        self.urlnormtest(url, nurl)
        url = '/./foo/.'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = '/foo/./bar'
        nurl = '/foo/bar'
        self.urlnormtest(url, nurl)
        url = '/foo/../bar'
        nurl = '/bar'
        self.urlnormtest(url, nurl)
        url = '../../../images/miniXmlButton.gif'
        nurl = url
        self.urlnormtest(url, nurl)
        url = '/a..b/../images/miniXmlButton.gif'
        nurl = '/images/miniXmlButton.gif'
        self.urlnormtest(url, nurl)
        url = '/.a.b/../foo/'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = '/..a.b/../foo/'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = 'b/../../foo/'
        nurl = '../foo/'
        self.urlnormtest(url, nurl)
        url = './foo'
        nurl = 'foo'
        self.urlnormtest(url, nurl)

    def test_norm_path_relative_slashes (self):
        # Test url norm relative path handling with slashes.
        url = '/foo//'
        nurl = '/foo/'
        self.urlnormtest(url, nurl)
        url = '/foo///bar//'
        nurl = '/foo/bar/'
        self.urlnormtest(url, nurl)

    def test_mail_url (self):
        # Test mailto URLs.
        # no netloc and no path
        url = 'mailto:'
        nurl = url
        self.urlnormtest(url, nurl)
        # standard email
        url = 'mailto:user@www.example.org'
        nurl = url
        self.urlnormtest(url, nurl)
        # emails with subject
        url = 'mailto:user@www.example.org?subject=a_b'
        nurl = url
        self.urlnormtest(url, nurl)
        url = 'mailto:business.inquiries@designingpatterns.com?subject=Business%20Inquiry'
        nurl = url
        self.urlnormtest(url, nurl)

    def test_norm_other (self):
        # Test norming of other schemes.
        url = 'news:'
        nurl = 'news:'
        self.urlnormtest(url, nurl)
        url = 'snews:'
        nurl = 'snews://'
        self.urlnormtest(url, nurl)
        url = 'nntp:'
        nurl = 'nntp://'
        self.urlnormtest(url, nurl)
        url = "news:!$%&/()="
        nurl = 'news:!%24%25%26/()='
        self.urlnormtest(url, nurl)
        url = "news:comp.infosystems.www.servers.unix"
        nurl = url
        self.urlnormtest(url, nurl)
        # javascript url
        url = "javascript:loadthis()"
        nurl = url
        self.urlnormtest(url, nurl)
        # ldap url # XXX failing on Travis build
        #url = "ldap://[2001:db8::7]/c=GB?objectClass?one"
        #nurl = "ldap://%5B2001:db8::7%5D/c=GB?objectClass?one"
        #self.urlnormtest(url, nurl)
        url = "tel:+1-816-555-1212"
        nurl = url
        self.urlnormtest(url, nurl)
        url = "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"
        nurl = "urn:oasis%3Anames%3Aspecification%3Adocbook%3Adtd%3Axml%3A4.1.2"
        self.urlnormtest(url, nurl)

    def test_norm_with_auth (self):
        # Test norming of URLs with authentication tokens.
        url = "telnet://User@www.example.org"
        nurl = url
        self.urlnormtest(url, nurl)
        url = "telnet://User:Pass@www.example.org"
        nurl = url
        self.urlnormtest(url, nurl)
        url = "http://User:Pass@www.example.org/"
        nurl = url
        self.urlnormtest(url, nurl)

    @need_posix
    def test_norm_file1 (self):
        url = "file:///a/b.txt"
        nurl = url
        self.urlnormtest(url, nurl)

    @need_windows
    def test_norm_file2 (self):
        url = "file:///C|/a/b.txt"
        nurl = url
        self.urlnormtest(url, nurl)

    @need_posix
    def test_norm_file_unicode (self):
        url = u"file:///a/b.txt"
        nurl = url
        self.urlnormtest(url, nurl)
        url = u"file:///a/.txt"
        nurl = u"file:///a/%E4.txt"
        self.urlnormtest(url, nurl, encoding="iso-8859-1")
        #url = u"file:///\u041c\u043e\u0448\u043a\u043e\u0432\u0430.bin"
        #nurl = u"file:///a.bin" # XXX
        #self.urlnormtest(url, nurl)

    def test_norm_invalid (self):
        url = u"?:"
        nurl = u"%E4%F6%FC?:"
        self.urlnormtest(url, nurl, encoding="iso-8859-1")

    def test_fixing (self):
        # Test url fix method.
        url = "http//www.example.org"
        nurl = "http://www.example.org"
        self.assertEqual(linkcheck.url.url_fix_common_typos(url), nurl)
        url = u"http//www.example.org"
        nurl = u"http://www.example.org"
        self.assertEqual(linkcheck.url.url_fix_common_typos(url), nurl)
        url = u"https//www.example.org"
        nurl = u"https://www.example.org"
        self.assertEqual(linkcheck.url.url_fix_common_typos(url), nurl)

    def test_valid (self):
        # Test url validity functions.
        u = "http://www.example.com"
        self.assertTrue(linkcheck.url.is_safe_url(u), u)
        u = "http://www.example.com/"
        self.assertTrue(linkcheck.url.is_safe_url(u), u)
        u = "http://www.example.com/~calvin"
        self.assertTrue(linkcheck.url.is_safe_url(u), u)
        u = "http://www.example.com/a,b"
        self.assertTrue(linkcheck.url.is_safe_url(u), u)
        u = "http://www.example.com#anchor55"
        self.assertTrue(linkcheck.url.is_safe_url(u), u)

    def test_needs_quoting (self):
        # Test url quoting necessity.
        url = "mailto:<calvin@example.org>?subject=Halli Hallo"
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))
        url = " http://www.example.com/"
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))
        url = "http://www.example.com/ "
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))
        url = "http://www.example.com/\n"
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))
        url = "\nhttp://www.example.com/"
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))
        url = "http://www.example.com/#a!"
        self.assertTrue(not linkcheck.url.url_needs_quoting(url), repr(url))
        url = "http://www.example.com/#a b"
        self.assertTrue(linkcheck.url.url_needs_quoting(url), repr(url))

    def test_absolute_url (self):
        url = "hutzli:"
        self.assertTrue(linkcheck.url.url_is_absolute(url), repr(url))
        url = "file:/"
        self.assertTrue(linkcheck.url.url_is_absolute(url), repr(url))
        url = ":"
        self.assertTrue(not linkcheck.url.url_is_absolute(url), repr(url))
        url = "/a/b?http://"
        self.assertTrue(not linkcheck.url.url_is_absolute(url), repr(url))

    def test_nopathquote_chars (self):
        if os.name == 'nt':
            url = "file:///c|/msys/"
            nurl = url
            self.assertEqual(url_norm(url), nurl)
            self.assertTrue(not linkcheck.url.url_needs_quoting(url))
        url = "http://hulla/a/b/!?c=d"
        nurl = url
        self.assertEqual(url_norm(url), nurl)

    def test_idn_encoding (self):
        # Test idna encoding.
        url = u'www.ko.de'
        idna_encode = linkcheck.url.idna_encode
        encurl, is_idn = idna_encode(url)
        self.assertTrue(is_idn)
        self.assertTrue(encurl)
        url = u''
        encurl, is_idn = idna_encode(url)
        self.assertFalse(is_idn)
        self.assertFalse(encurl)
        url = u".."
        self.assertRaises(UnicodeError, idna_encode, url)

    def test_match_host (self):
        # Test host matching.
        match_host = linkcheck.url.match_host
        match_url = linkcheck.url.match_url
        self.assertTrue(not match_host("", []))
        self.assertTrue(not match_host("", [".localhost"]))
        self.assertTrue(not match_host("localhost", []))
        self.assertTrue(not match_host("localhost", [".localhost"]))
        self.assertTrue(match_host("a.localhost", [".localhost"]))
        self.assertTrue(match_host("localhost", ["localhost"]))
        self.assertTrue(not match_url("", []))
        self.assertTrue(not match_url("a", []))
        self.assertTrue(match_url("http://example.org/hulla", ["example.org"]))

    def test_splitparam (self):
        # Path parameter split test.
        p = [
            ("", ("", "")),
            ("/", ("/", "")),
            ("a", ("a", "")),
            ("a;", ("a", "")),
            ("a/b;c/d;e", ("a/b;c/d", "e")),
        ]
        for x in p:
            self._splitparam(x)

    def _splitparam (self, x):
        self.assertEqual(linkcheck.url.splitparams(x[0]), (x[1][0], x[1][1]))

    def test_cgi_split (self):
        # Test cgi parameter splitting.
        u = "scid=kb;en-us;Q248840"
        self.assertEqual(linkcheck.url.url_parse_query(u), u)
        u = "scid=kb;en-us;Q248840&b=c;hulla=bulla"
        self.assertEqual(linkcheck.url.url_parse_query(u), u)

    def test_long_cgi (self):
        u = "/test%s;" % ("?a="*1000)
        self.assertEqual(linkcheck.url.url_parse_query(u), u)

    def test_port (self):
        is_numeric_port = linkcheck.url.is_numeric_port
        self.assertTrue(is_numeric_port("80"))
        self.assertTrue(is_numeric_port("1"))
        self.assertFalse(is_numeric_port("0"))
        self.assertFalse(is_numeric_port("66000"))
        self.assertFalse(is_numeric_port("-1"))
        self.assertFalse(is_numeric_port("a"))

    def test_split (self):
        url_split = linkcheck.url.url_split
        url_unsplit = linkcheck.url.url_unsplit
        url = "http://example.org/whoops"
        self.assertEqual(url_unsplit(url_split(url)), url)
        url = "http://example.org:123/whoops"
        self.assertEqual(url_unsplit(url_split(url)), url)

    def test_safe_domain (self):
        is_safe_domain = linkcheck.url.is_safe_domain
        self.assertFalse(is_safe_domain(u"a..example.com"))
        self.assertFalse(is_safe_domain(u"a_b.example.com"))
        self.assertTrue(is_safe_domain(u"a-b.example.com"))
        self.assertTrue(is_safe_domain(u"x1.example.com"))

    @need_network
    def test_get_content (self):
        linkcheck.url.get_content('http://www.debian.org/')

    def test_duplicate_urls(self):
        is_dup = linkcheck.url.is_duplicate_content_url
        self.assertTrue(is_dup("http://example.org", "http://example.org"))
        self.assertTrue(is_dup("http://example.org/", "http://example.org"))
        self.assertTrue(is_dup("http://example.org", "http://example.org/"))
        self.assertTrue(is_dup("http://example.org/index.html", "http://example.org"))
        self.assertTrue(is_dup("http://example.org", "http://example.org/index.html"))
        self.assertTrue(is_dup("http://example.org/index.htm", "http://example.org"))
        self.assertTrue(is_dup("http://example.org", "http://example.org/index.htm"))

    def test_splitport(self):
        splitport = linkcheck.url.splitport
        netloc = "hostname"
        host, port = splitport(netloc, 99)
        self.assertEqual(host, netloc)
        self.assertEqual(port, 99)
        netloc = "hostname:"
        host, port = splitport(netloc, 99)
        self.assertEqual(host, "hostname")
        self.assertEqual(port, 99)
        netloc = "hostname:42"
        host, port = splitport(netloc, 99)
        self.assertEqual(host, "hostname")
        self.assertEqual(port, 42)
        netloc = "hostname:foo"
        host, port = splitport(netloc, 99)
        self.assertEqual(host, netloc)
        self.assertEqual(port, 99)

########NEW FILE########
__FILENAME__ = test_urlbuild
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2004-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Test url build method from url data objects.
"""

import unittest
import linkcheck.configuration
import linkcheck.director
import linkcheck.checker.urlbase
from linkcheck.checker import get_url_from


def get_test_aggregate ():
    """
    Initialize a test configuration object.
    """
    config = linkcheck.configuration.Configuration()
    config['logger'] = config.logger_new('none')
    return linkcheck.director.get_aggregate(config)


class TestUrlBuild (unittest.TestCase):
    """
    Test url building.
    """

    def test_http_build (self):
        parent_url = "http://localhost:8001/tests/checker/data/http.html"
        base_url = "http://foo"
        recursion_level = 0
        aggregate = get_test_aggregate()
        o = get_url_from(base_url, recursion_level, aggregate, parent_url=parent_url)
        o.build_url()
        self.assertEqual(o.url, u'http://foo')

    def test_urljoin (self):
        parent_url = "http://localhost:8001/test"
        base_url = ";param=value"
        res = linkcheck.checker.urlbase.urljoin(parent_url, base_url)
        self.assertEqual(res, 'http://localhost:8001/;param=value')

    def test_urljoin_file (self):
        parent_url = "file:///a/b.html"
        base_url = "?c=d"
        recursion_level = 0
        aggregate = get_test_aggregate()
        o = get_url_from(base_url, recursion_level,
               aggregate, parent_url=parent_url)
        o.build_url()
        self.assertEqual(o.url, parent_url)

    def test_http_build2 (self):
        parent_url = u'http://example.org/test?a=b&c=d'
        base_url = u'#usemap'
        recursion_level = 0
        aggregate = get_test_aggregate()
        o = get_url_from(base_url, recursion_level, aggregate, parent_url=parent_url)
        o.build_url()
        self.assertEqual(o.url, parent_url+base_url)

########NEW FILE########
__FILENAME__ = dnssec
# Copyright (C) 2003-2007, 2009, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Common DNSSEC-related functions and constants."""

import cStringIO
import struct
import time

import dns.exception
import dns.hash
import dns.name
import dns.node
import dns.rdataset
import dns.rdata
import dns.rdatatype
import dns.rdataclass

class UnsupportedAlgorithm(dns.exception.DNSException):
    """Raised if an algorithm is not supported."""
    pass

class ValidationFailure(dns.exception.DNSException):
    """The DNSSEC signature is invalid."""
    pass

RSAMD5 = 1
DH = 2
DSA = 3
ECC = 4
RSASHA1 = 5
DSANSEC3SHA1 = 6
RSASHA1NSEC3SHA1 = 7
RSASHA256 = 8
RSASHA512 = 10
INDIRECT = 252
PRIVATEDNS = 253
PRIVATEOID = 254

_algorithm_by_text = {
    'RSAMD5' : RSAMD5,
    'DH' : DH,
    'DSA' : DSA,
    'ECC' : ECC,
    'RSASHA1' : RSASHA1,
    'DSANSEC3SHA1' : DSANSEC3SHA1,
    'RSASHA1NSEC3SHA1' : RSASHA1NSEC3SHA1,
    'RSASHA256' : RSASHA256,
    'RSASHA512' : RSASHA512,
    'INDIRECT' : INDIRECT,
    'PRIVATEDNS' : PRIVATEDNS,
    'PRIVATEOID' : PRIVATEOID,
    }

# We construct the inverse mapping programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mapping not to be true inverse.

_algorithm_by_value = dict([(y, x) for x, y in _algorithm_by_text.iteritems()])

def algorithm_from_text(text):
    """Convert text into a DNSSEC algorithm value
    @rtype: int"""

    value = _algorithm_by_text.get(text.upper())
    if value is None:
        value = int(text)
    return value

def algorithm_to_text(value):
    """Convert a DNSSEC algorithm value to text
    @rtype: string"""

    text = _algorithm_by_value.get(value)
    if text is None:
        text = str(value)
    return text

def _to_rdata(record, origin):
    s = cStringIO.StringIO()
    record.to_wire(s, origin=origin)
    return s.getvalue()

def key_id(key, origin=None):
    rdata = _to_rdata(key, origin)
    if key.algorithm == RSAMD5:
        return (ord(rdata[-3]) << 8) + ord(rdata[-2])
    else:
        total = 0
        for i in range(len(rdata) // 2):
            total += (ord(rdata[2 * i]) << 8) + ord(rdata[2 * i + 1])
        if len(rdata) % 2 != 0:
            total += ord(rdata[len(rdata) - 1]) << 8
        total += ((total >> 16) & 0xffff);
        return total & 0xffff

def make_ds(name, key, algorithm, origin=None):
    if algorithm.upper() == 'SHA1':
        dsalg = 1
        hash = dns.hash.get('SHA1')()
    elif algorithm.upper() == 'SHA256':
        dsalg = 2
        hash = dns.hash.get('SHA256')()
    else:
        raise UnsupportedAlgorithm, 'unsupported algorithm "%s"' % algorithm

    if isinstance(name, (str, unicode)):
        name = dns.name.from_text(name, origin)
    hash.update(name.canonicalize().to_wire())
    hash.update(_to_rdata(key, origin))
    digest = hash.digest()

    dsrdata = struct.pack("!HBB", key_id(key), key.algorithm, dsalg) + digest
    return dns.rdata.from_wire(dns.rdataclass.IN, dns.rdatatype.DS, dsrdata, 0,
                               len(dsrdata))

def _find_key(keys, rrsig):
    value = keys.get(rrsig.signer)
    if value is None:
        return None
    if isinstance(value, dns.node.Node):
        try:
            rdataset = node.find_rdataset(dns.rdataclass.IN,
                                          dns.rdatatype.DNSKEY)
        except KeyError:
            return None
    else:
        rdataset = value
    for rdata in rdataset:
        if rdata.algorithm == rrsig.algorithm and \
               key_id(rdata) == rrsig.key_tag:
            return rdata
    return None

def _is_rsa(algorithm):
    return algorithm in (RSAMD5, RSASHA1,
                         RSASHA1NSEC3SHA1, RSASHA256,
                         RSASHA512)

def _is_dsa(algorithm):
    return algorithm in (DSA, DSANSEC3SHA1)

def _is_md5(algorithm):
    return algorithm == RSAMD5

def _is_sha1(algorithm):
    return algorithm in (DSA, RSASHA1,
                         DSANSEC3SHA1, RSASHA1NSEC3SHA1)

def _is_sha256(algorithm):
    return algorithm == RSASHA256

def _is_sha512(algorithm):
    return algorithm == RSASHA512

def _make_hash(algorithm):
    if _is_md5(algorithm):
        return dns.hash.get('MD5')()
    if _is_sha1(algorithm):
        return dns.hash.get('SHA1')()
    if _is_sha256(algorithm):
        return dns.hash.get('SHA256')()
    if _is_sha512(algorithm):
        return dns.hash.get('SHA512')()
    raise ValidationFailure, 'unknown hash for algorithm %u' % algorithm

def _make_algorithm_id(algorithm):
    if _is_md5(algorithm):
        oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05]
    elif _is_sha1(algorithm):
        oid = [0x2b, 0x0e, 0x03, 0x02, 0x1a]
    elif _is_sha256(algorithm):
        oid = [0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01]
    elif _is_sha512(algorithm):
        oid = [0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03]
    else:
        raise ValidationFailure, 'unknown algorithm %u' % algorithm
    olen = len(oid)
    dlen = _make_hash(algorithm).digest_size
    idbytes = [0x30] + [8 + olen + dlen] + \
              [0x30, olen + 4] + [0x06, olen] + oid + \
              [0x05, 0x00] + [0x04, dlen]
    return ''.join(map(chr, idbytes))

def _validate_rrsig(rrset, rrsig, keys, origin=None, now=None):
    """Validate an RRset against a single signature rdata

    The owner name of the rrsig is assumed to be the same as the owner name
    of the rrset.

    @param rrset: The RRset to validate
    @type rrset: dns.rrset.RRset or (dns.name.Name, dns.rdataset.Rdataset)
    tuple
    @param rrsig: The signature rdata
    @type rrsig: dns.rrset.Rdata
    @param keys: The key dictionary.
    @type keys: a dictionary keyed by dns.name.Name with node or rdataset values
    @param origin: The origin to use for relative names
    @type origin: dns.name.Name or None
    @param now: The time to use when validating the signatures.  The default
    is the current time.
    @type now: int
    """

    if isinstance(origin, (str, unicode)):
        origin = dns.name.from_text(origin, dns.name.root)

    key = _find_key(keys, rrsig)
    if not key:
        raise ValidationFailure, 'unknown key'

    # For convenience, allow the rrset to be specified as a (name, rdataset)
    # tuple as well as a proper rrset
    if isinstance(rrset, tuple):
        rrname = rrset[0]
        rdataset = rrset[1]
    else:
        rrname = rrset.name
        rdataset = rrset

    if now is None:
        now = time.time()
    if rrsig.expiration < now:
        raise ValidationFailure, 'expired'
    if rrsig.inception > now:
        raise ValidationFailure, 'not yet valid'

    hash = _make_hash(rrsig.algorithm)

    if _is_rsa(rrsig.algorithm):
        keyptr = key.key
        (bytes,) = struct.unpack('!B', keyptr[0:1])
        keyptr = keyptr[1:]
        if bytes == 0:
            (bytes,) = struct.unpack('!H', keyptr[0:2])
            keyptr = keyptr[2:]
        rsa_e = keyptr[0:bytes]
        rsa_n = keyptr[bytes:]
        keylen = len(rsa_n) * 8
        pubkey = Crypto.PublicKey.RSA.construct(
            (Crypto.Util.number.bytes_to_long(rsa_n),
             Crypto.Util.number.bytes_to_long(rsa_e)))
        sig = (Crypto.Util.number.bytes_to_long(rrsig.signature),)
    elif _is_dsa(rrsig.algorithm):
        keyptr = key.key
        (t,) = struct.unpack('!B', keyptr[0:1])
        keyptr = keyptr[1:]
        octets = 64 + t * 8
        dsa_q = keyptr[0:20]
        keyptr = keyptr[20:]
        dsa_p = keyptr[0:octets]
        keyptr = keyptr[octets:]
        dsa_g = keyptr[0:octets]
        keyptr = keyptr[octets:]
        dsa_y = keyptr[0:octets]
        pubkey = Crypto.PublicKey.DSA.construct(
            (Crypto.Util.number.bytes_to_long(dsa_y),
             Crypto.Util.number.bytes_to_long(dsa_g),
             Crypto.Util.number.bytes_to_long(dsa_p),
             Crypto.Util.number.bytes_to_long(dsa_q)))
        (dsa_r, dsa_s) = struct.unpack('!20s20s', rrsig.signature[1:])
        sig = (Crypto.Util.number.bytes_to_long(dsa_r),
               Crypto.Util.number.bytes_to_long(dsa_s))
    else:
        raise ValidationFailure, 'unknown algorithm %u' % rrsig.algorithm

    hash.update(_to_rdata(rrsig, origin)[:18])
    hash.update(rrsig.signer.to_digestable(origin))

    if rrsig.labels < len(rrname) - 1:
        suffix = rrname.split(rrsig.labels + 1)[1]
        rrname = dns.name.from_text('*', suffix)
    rrnamebuf = rrname.to_digestable(origin)
    rrfixed = struct.pack('!HHI', rdataset.rdtype, rdataset.rdclass,
                          rrsig.original_ttl)
    rrlist = sorted(rdataset);
    for rr in rrlist:
        hash.update(rrnamebuf)
        hash.update(rrfixed)
        rrdata = rr.to_digestable(origin)
        rrlen = struct.pack('!H', len(rrdata))
        hash.update(rrlen)
        hash.update(rrdata)

    digest = hash.digest()

    if _is_rsa(rrsig.algorithm):
        # PKCS1 algorithm identifier goop
        digest = _make_algorithm_id(rrsig.algorithm) + digest
        padlen = keylen // 8 - len(digest) - 3
        digest = chr(0) + chr(1) + chr(0xFF) * padlen + chr(0) + digest
    elif _is_dsa(rrsig.algorithm):
        pass
    else:
        # Raise here for code clarity; this won't actually ever happen
        # since if the algorithm is really unknown we'd already have
        # raised an exception above
        raise ValidationFailure, 'unknown algorithm %u' % rrsig.algorithm

    if not pubkey.verify(digest, sig):
        raise ValidationFailure, 'verify failure'

def _validate(rrset, rrsigset, keys, origin=None, now=None):
    """Validate an RRset

    @param rrset: The RRset to validate
    @type rrset: dns.rrset.RRset or (dns.name.Name, dns.rdataset.Rdataset)
    tuple
    @param rrsigset: The signature RRset
    @type rrsigset: dns.rrset.RRset or (dns.name.Name, dns.rdataset.Rdataset)
    tuple
    @param keys: The key dictionary.
    @type keys: a dictionary keyed by dns.name.Name with node or rdataset values
    @param origin: The origin to use for relative names
    @type origin: dns.name.Name or None
    @param now: The time to use when validating the signatures.  The default
    is the current time.
    @type now: int
    """

    if isinstance(origin, (str, unicode)):
        origin = dns.name.from_text(origin, dns.name.root)

    if isinstance(rrset, tuple):
        rrname = rrset[0]
    else:
        rrname = rrset.name

    if isinstance(rrsigset, tuple):
        rrsigname = rrsigset[0]
        rrsigrdataset = rrsigset[1]
    else:
        rrsigname = rrsigset.name
        rrsigrdataset = rrsigset

    rrname = rrname.choose_relativity(origin)
    rrsigname = rrname.choose_relativity(origin)
    if rrname != rrsigname:
        raise ValidationFailure, "owner names do not match"

    for rrsig in rrsigrdataset:
        try:
            _validate_rrsig(rrset, rrsig, keys, origin, now)
            return
        except ValidationFailure, e:
            pass
    raise ValidationFailure, "no RRSIGs validated"

def _need_pycrypto(*args, **kwargs):
    raise NotImplementedError, "DNSSEC validation requires pycrypto"

try:
    import Crypto.PublicKey.RSA
    import Crypto.PublicKey.DSA
    import Crypto.Util.number
    validate = _validate
    validate_rrsig = _validate_rrsig
except ImportError:
    validate = _need_pycrypto
    validate_rrsig = _need_pycrypto

########NEW FILE########
__FILENAME__ = e164
# Copyright (C) 2006, 2007, 2009, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS E.164 helpers

@var public_enum_domain: The DNS public ENUM domain, e164.arpa.
@type public_enum_domain: dns.name.Name object
"""

import dns.exception
import dns.name
import dns.resolver

public_enum_domain = dns.name.from_text('e164.arpa.')

def from_e164(text, origin=public_enum_domain):
    """Convert an E.164 number in textual form into a Name object whose
    value is the ENUM domain name for that number.
    @param text: an E.164 number in textual form.
    @type text: str
    @param origin: The domain in which the number should be constructed.
    The default is e164.arpa.
    @type: dns.name.Name object or None
    @rtype: dns.name.Name object
    """
    parts = [d for d in text if d.isdigit()]
    parts.reverse()
    return dns.name.from_text('.'.join(parts), origin=origin)

def to_e164(name, origin=public_enum_domain, want_plus_prefix=True):
    """Convert an ENUM domain name into an E.164 number.
    @param name: the ENUM domain name.
    @type name: dns.name.Name object.
    @param origin: A domain containing the ENUM domain name.  The
    name is relativized to this domain before being converted to text.
    @type: dns.name.Name object or None
    @param want_plus_prefix: if True, add a '+' to the beginning of the
    returned number.
    @rtype: str
    """
    if not origin is None:
        name = name.relativize(origin)
    dlabels = [d for d in name.labels if (d.isdigit() and len(d) == 1)]
    if len(dlabels) != len(name.labels):
        raise dns.exception.SyntaxError('non-digit labels in ENUM domain name')
    dlabels.reverse()
    text = ''.join(dlabels)
    if want_plus_prefix:
        text = '+' + text
    return text

def query(number, domains, resolver=None):
    """Look for NAPTR RRs for the specified number in the specified domains.

    e.g. lookup('16505551212', ['e164.dnspython.org.', 'e164.arpa.'])
    """
    if resolver is None:
        resolver = dns.resolver.get_default_resolver()
    for domain in domains:
        if isinstance(domain, (str, unicode)):
            domain = dns.name.from_text(domain)
        qname = dns.e164.from_e164(number, domain)
        try:
            return resolver.query(qname, 'NAPTR')
        except dns.resolver.NXDOMAIN:
            pass
    raise dns.resolver.NXDOMAIN

########NEW FILE########
__FILENAME__ = edns
# Copyright (C) 2009, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""EDNS Options"""

NSID = 3

class Option(object):
    """Base class for all EDNS option types.
    """

    def __init__(self, otype):
        """Initialize an option.
        @param rdtype: The rdata type
        @type rdtype: int
        """
        self.otype = otype

    def to_wire(self, file):
        """Convert an option to wire format.
        """
        raise NotImplementedError

    def from_wire(cls, otype, wire, current, olen):
        """Build an EDNS option object from wire format

        @param otype: The option type
        @type otype: int
        @param wire: The wire-format message
        @type wire: string
        @param current: The offet in wire of the beginning of the rdata.
        @type current: int
        @param olen: The length of the wire-format option data
        @type olen: int
        @rtype: dns.ends.Option instance"""
        raise NotImplementedError

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        """Compare an ENDS option with another option of the same type.
        Return < 0 if self < other, 0 if self == other, and > 0 if self > other.
        """
        raise NotImplementedError

    def __eq__(self, other):
        if not isinstance(other, Option):
            return False
        if self.otype != other.otype:
            return False
        return self._cmp(other) == 0

    def __ne__(self, other):
        if not isinstance(other, Option):
            return False
        if self.otype != other.otype:
            return False
        return self._cmp(other) != 0

    def __lt__(self, other):
        if not isinstance(other, Option) or \
               self.otype != other.otype:
            return NotImplemented
        return self._cmp(other) < 0

    def __le__(self, other):
        if not isinstance(other, Option) or \
               self.otype != other.otype:
            return NotImplemented
        return self._cmp(other) <= 0

    def __ge__(self, other):
        if not isinstance(other, Option) or \
               self.otype != other.otype:
            return NotImplemented
        return self._cmp(other) >= 0

    def __gt__(self, other):
        if not isinstance(other, Option) or \
               self.otype != other.otype:
            return NotImplemented
        return self._cmp(other) > 0


class GenericOption(Option):
    """Generate Rdata Class

    This class is used for EDNS option types for which we have no better
    implementation.
    """

    def __init__(self, otype, data):
        super(GenericOption, self).__init__(otype)
        self.data = data

    def to_wire(self, file):
        file.write(self.data)

    def from_wire(cls, otype, wire, current, olen):
        return cls(otype, wire[current : current + olen])

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.data, other.data)

_type_to_class = {
}

def get_option_class(otype):
    cls = _type_to_class.get(otype)
    if cls is None:
        cls = GenericOption
    return cls

def option_from_wire(otype, wire, current, olen):
    """Build an EDNS option object from wire format

    @param otype: The option type
    @type otype: int
    @param wire: The wire-format message
    @type wire: string
    @param current: The offet in wire of the beginning of the rdata.
    @type current: int
    @param olen: The length of the wire-format option data
    @type olen: int
    @rtype: dns.ends.Option instance"""

    cls = get_option_class(otype)
    return cls.from_wire(otype, wire, current, olen)

########NEW FILE########
__FILENAME__ = entropy
# Copyright (C) 2009, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import os
import time
try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading

class EntropyPool(object):
    def __init__(self, seed=None):
        self.pool_index = 0
        self.digest = None
        self.next_byte = 0
        self.lock = _threading.Lock()
        try:
            import hashlib
            self.hash = hashlib.sha1()
            self.hash_len = 20
        except StandardError:
            try:
                import sha
                self.hash = sha.new()
                self.hash_len = 20
            except StandardError:
                import md5
                self.hash = md5.new()
                self.hash_len = 16
        self.pool = '\0' * self.hash_len
        if not seed is None:
            self.stir(seed)
            self.seeded = True
        else:
            self.seeded = False

    def stir(self, entropy, already_locked=False):
        if not already_locked:
            self.lock.acquire()
        try:
            bytes = [ord(c) for c in self.pool]
            for c in entropy:
                if self.pool_index == self.hash_len:
                    self.pool_index = 0
                b = ord(c) & 0xff
                bytes[self.pool_index] ^= b
                self.pool_index += 1
            self.pool = ''.join([chr(c) for c in bytes])
        finally:
            if not already_locked:
                self.lock.release()

    def _maybe_seed(self):
        if not self.seeded:
            try:
                seed = os.urandom(16)
            except StandardError:
                try:
                    r = file('/dev/urandom', 'r', 0)
                    try:
                        seed = r.read(16)
                    finally:
                        r.close()
                except StandardError:
                    seed = str(time.time())
            self.seeded = True
            self.stir(seed, True)

    def random_8(self):
        self.lock.acquire()
        self._maybe_seed()
        try:
            if self.digest is None or self.next_byte == self.hash_len:
                self.hash.update(self.pool)
                self.digest = self.hash.digest()
                self.stir(self.digest, True)
                self.next_byte = 0
            value = ord(self.digest[self.next_byte])
            self.next_byte += 1
        finally:
            self.lock.release()
        return value

    def random_16(self):
        return self.random_8() * 256 + self.random_8()

    def random_32(self):
        return self.random_16() * 65536 + self.random_16()

    def random_between(self, first, last):
        size = last - first + 1
        if size > 4294967296L:
            raise ValueError('too big')
        if size > 65536:
            rand = self.random_32
            max = 4294967295L
        elif size > 256:
            rand = self.random_16
            max = 65535
        else:
            rand = self.random_8
            max = 255
        return (first + size * rand() // (max + 1))

pool = EntropyPool()

def random_16():
    return pool.random_16()

def between(first, last):
    return pool.random_between(first, last)

########NEW FILE########
__FILENAME__ = exception
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Common DNS Exceptions."""

class DNSException(StandardError):
    """Abstract base class shared by all dnspython exceptions."""
    pass

class FormError(DNSException):
    """DNS message is malformed."""
    pass

class SyntaxError(DNSException):
    """Text input is malformed."""
    pass

class UnexpectedEnd(SyntaxError):
    """Raised if text input ends unexpectedly."""
    pass

class TooBig(DNSException):
    """The message is too big."""
    pass

class Timeout(DNSException):
    """The operation timed out."""
    pass

########NEW FILE########
__FILENAME__ = flags
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Message Flags."""

# Standard DNS flags

QR = 0x8000
AA = 0x0400
TC = 0x0200
RD = 0x0100
RA = 0x0080
AD = 0x0020
CD = 0x0010

# EDNS flags

DO = 0x8000

_by_text = {
    'QR' : QR,
    'AA' : AA,
    'TC' : TC,
    'RD' : RD,
    'RA' : RA,
    'AD' : AD,
    'CD' : CD
}

_edns_by_text = {
    'DO' : DO
}


# We construct the inverse mappings programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mappings not to be true inverses.

_by_value = dict([(y, x) for x, y in _by_text.iteritems()])

_edns_by_value = dict([(y, x) for x, y in _edns_by_text.iteritems()])

def _order_flags(table):
    order = list(table.iteritems())
    order.sort()
    order.reverse()
    return order

_flags_order = _order_flags(_by_value)

_edns_flags_order = _order_flags(_edns_by_value)

def _from_text(text, table):
    flags = 0
    tokens = text.split()
    for t in tokens:
        flags = flags | table[t.upper()]
    return flags

def _to_text(flags, table, order):
    text_flags = []
    for k, v in order:
        if flags & k != 0:
            text_flags.append(v)
    return ' '.join(text_flags)

def from_text(text):
    """Convert a space-separated list of flag text values into a flags
    value.
    @rtype: int"""

    return _from_text(text, _by_text)

def to_text(flags):
    """Convert a flags value into a space-separated list of flag text
    values.
    @rtype: string"""

    return _to_text(flags, _by_value, _flags_order)


def edns_from_text(text):
    """Convert a space-separated list of EDNS flag text values into a EDNS
    flags value.
    @rtype: int"""

    return _from_text(text, _edns_by_text)

def edns_to_text(flags):
    """Convert an EDNS flags value into a space-separated list of EDNS flag
    text values.
    @rtype: string"""

    return _to_text(flags, _edns_by_value, _edns_flags_order)

########NEW FILE########
__FILENAME__ = hash
# Copyright (C) 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Hashing backwards compatibility wrapper"""

import sys

_hashes = None

def _need_later_python(alg):
    def func(*args, **kwargs):
        raise NotImplementedError("TSIG algorithm " + alg +
                                  " requires Python 2.5.2 or later")
    return func

def _setup():
    global _hashes
    _hashes = {}
    try:
        import hashlib
        _hashes['MD5'] = hashlib.md5
        _hashes['SHA1'] = hashlib.sha1
        _hashes['SHA224'] = hashlib.sha224
        _hashes['SHA256'] = hashlib.sha256
        if sys.hexversion >= 0x02050200:
            _hashes['SHA384'] = hashlib.sha384
            _hashes['SHA512'] = hashlib.sha512
        else:
            _hashes['SHA384'] = _need_later_python('SHA384')
            _hashes['SHA512'] = _need_later_python('SHA512')

        if sys.hexversion < 0x02050000:
            # hashlib doesn't conform to PEP 247: API for
            # Cryptographic Hash Functions, which hmac before python
            # 2.5 requires, so add the necessary items.
            class HashlibWrapper:
                def __init__(self, basehash):
                    self.basehash = basehash
                    self.digest_size = self.basehash().digest_size

                def new(self, *args, **kwargs):
                    return self.basehash(*args, **kwargs)

            for name in _hashes:
                _hashes[name] = HashlibWrapper(_hashes[name])

    except ImportError:
        import md5, sha
        _hashes['MD5'] =  md5
        _hashes['SHA1'] = sha

def get(algorithm):
    if _hashes is None:
        _setup()
    return _hashes[algorithm.upper()]

########NEW FILE########
__FILENAME__ = inet
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Generic Internet address helper functions."""

import socket

import dns.ipv4
import dns.ipv6


# We assume that AF_INET is always defined.

AF_INET = socket.AF_INET

# AF_INET6 might not be defined in the socket module, but we need it.
# We'll try to use the socket module's value, and if it doesn't work,
# we'll use our own value.

try:
    AF_INET6 = socket.AF_INET6
except AttributeError:
    AF_INET6 = 9999

def inet_pton(family, text):
    """Convert the textual form of a network address into its binary form.

    @param family: the address family
    @type family: int
    @param text: the textual address
    @type text: string
    @raises NotImplementedError: the address family specified is not
    implemented.
    @rtype: string
    """

    if family == AF_INET:
        return dns.ipv4.inet_aton(text)
    elif family == AF_INET6:
        return dns.ipv6.inet_aton(text)
    else:
        raise NotImplementedError

def inet_ntop(family, address):
    """Convert the binary form of a network address into its textual form.

    @param family: the address family
    @type family: int
    @param address: the binary address
    @type address: string
    @raises NotImplementedError: the address family specified is not
    implemented.
    @rtype: string
    """
    if family == AF_INET:
        return dns.ipv4.inet_ntoa(address)
    elif family == AF_INET6:
        return dns.ipv6.inet_ntoa(address)
    else:
        raise NotImplementedError

def af_for_address(text):
    """Determine the address family of a textual-form network address.

    @param text: the textual address
    @type text: string
    @raises ValueError: the address family cannot be determined from the input.
    @rtype: int
    """
    try:
        junk = dns.ipv4.inet_aton(text)
        return AF_INET
    except StandardError:
        try:
            junk = dns.ipv6.inet_aton(text)
            return AF_INET6
        except StandardError:
            raise ValueError

def is_multicast(text):
    """Is the textual-form network address a multicast address?

    @param text: the textual address
    @raises ValueError: the address family cannot be determined from the input.
    @rtype: bool
    """
    try:
        first = ord(dns.ipv4.inet_aton(text)[0])
        return (first >= 224 and first <= 239)
    except StandardError:
        try:
            first = ord(dns.ipv6.inet_aton(text)[0])
            return (first == 255)
        except StandardError:
            raise ValueError


########NEW FILE########
__FILENAME__ = ipv4
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""IPv4 helper functions."""

import socket
import sys

if sys.hexversion < 0x02030000 or sys.platform == 'win32':
    #
    # Some versions of Python 2.2 have an inet_aton which rejects
    # the valid IP address '255.255.255.255'.  It appears this
    # problem is still present on the Win32 platform even in 2.3.
    # We'll work around the problem.
    #
    def inet_aton(text):
        if text == '255.255.255.255':
            return '\xff' * 4
        else:
            return socket.inet_aton(text)
else:
    inet_aton = socket.inet_aton

inet_ntoa = socket.inet_ntoa

########NEW FILE########
__FILENAME__ = ipv6
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""IPv6 helper functions."""

import re

import dns.exception
import dns.ipv4

_leading_zero = re.compile(r'0+([0-9a-f]+)')

def inet_ntoa(address):
    """Convert a network format IPv6 address into text.

    @param address: the binary address
    @type address: string
    @rtype: string
    @raises ValueError: the address isn't 16 bytes long
    """

    if len(address) != 16:
        raise ValueError("IPv6 addresses are 16 bytes long")
    hex = address.encode('hex_codec')
    chunks = []
    i = 0
    l = len(hex)
    while i < l:
        chunk = hex[i : i + 4]
        # strip leading zeros.  we do this with an re instead of
        # with lstrip() because lstrip() didn't support chars until
        # python 2.2.2
        m = _leading_zero.match(chunk)
        if not m is None:
            chunk = m.group(1)
        chunks.append(chunk)
        i += 4
    #
    # Compress the longest subsequence of 0-value chunks to ::
    #
    best_start = 0
    best_len = 0
    start = -1
    last_was_zero = False
    for i in xrange(8):
        if chunks[i] != '0':
            if last_was_zero:
                end = i
                current_len = end - start
                if current_len > best_len:
                    best_start = start
                    best_len = current_len
                last_was_zero = False
        elif not last_was_zero:
            start = i
            last_was_zero = True
    if last_was_zero:
        end = 8
        current_len = end - start
        if current_len > best_len:
            best_start = start
            best_len = current_len
    if best_len > 0:
        if best_start == 0 and \
           (best_len == 6 or
            best_len == 5 and chunks[5] == 'ffff'):
            # We have an embedded IPv4 address
            if best_len == 6:
                prefix = '::'
            else:
                prefix = '::ffff:'
            hex = prefix + dns.ipv4.inet_ntoa(address[12:])
        else:
            hex = ':'.join(chunks[:best_start]) + '::' + \
                  ':'.join(chunks[best_start + best_len:])
    else:
        hex = ':'.join(chunks)
    return hex

_v4_ending = re.compile(r'(.*):(\d+)\.(\d+)\.(\d+)\.(\d+)$')
_colon_colon_start = re.compile(r'::.*')
_colon_colon_end = re.compile(r'.*::$')

def inet_aton(text):
    """Convert a text format IPv6 address into network format.

    @param text: the textual address
    @type text: string
    @rtype: string
    @raises dns.exception.SyntaxError: the text was not properly formatted
    """

    #
    # Our aim here is not something fast; we just want something that works.
    #

    if text == '::':
        text = '0::'
    #
    # Get rid of the icky dot-quad syntax if we have it.
    #
    m = _v4_ending.match(text)
    if not m is None:
        text = "%s:%04x:%04x" % (m.group(1),
                                 int(m.group(2)) * 256 + int(m.group(3)),
                                 int(m.group(4)) * 256 + int(m.group(5)))
    #
    # Try to turn '::<whatever>' into ':<whatever>'; if no match try to
    # turn '<whatever>::' into '<whatever>:'
    #
    m = _colon_colon_start.match(text)
    if not m is None:
        text = text[1:]
    else:
        m = _colon_colon_end.match(text)
        if not m is None:
            text = text[:-1]
    #
    # Now canonicalize into 8 chunks of 4 hex digits each
    #
    chunks = text.split(':')
    l = len(chunks)
    if l > 8:
        raise dns.exception.SyntaxError
    seen_empty = False
    canonical = []
    for c in chunks:
        if c == '':
            if seen_empty:
                raise dns.exception.SyntaxError
            seen_empty = True
            for i in xrange(0, 8 - l + 1):
                canonical.append('0000')
        else:
            lc = len(c)
            if lc > 4:
                raise dns.exception.SyntaxError
            if lc != 4:
                c = ('0' * (4 - lc)) + c
            canonical.append(c)
    if l < 8 and not seen_empty:
        raise dns.exception.SyntaxError
    text = ''.join(canonical)

    #
    # Finally we can go to binary.
    #
    try:
        return text.decode('hex_codec')
    except TypeError:
        raise dns.exception.SyntaxError

########NEW FILE########
__FILENAME__ = message
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Messages"""

import cStringIO
import random
import struct
import sys
import time

import dns.edns
import dns.exception
import dns.flags
import dns.name
import dns.opcode
import dns.entropy
import dns.rcode
import dns.rdata
import dns.rdataclass
import dns.rdatatype
import dns.rrset
import dns.renderer
import dns.tsig
import dns.wiredata

class ShortHeader(dns.exception.FormError):
    """Raised if the DNS packet passed to from_wire() is too short."""
    pass

class TrailingJunk(dns.exception.FormError):
    """Raised if the DNS packet passed to from_wire() has extra junk
    at the end of it."""
    pass

class UnknownHeaderField(dns.exception.DNSException):
    """Raised if a header field name is not recognized when converting from
    text into a message."""
    pass

class BadEDNS(dns.exception.FormError):
    """Raised if an OPT record occurs somewhere other than the start of
    the additional data section."""
    pass

class BadTSIG(dns.exception.FormError):
    """Raised if a TSIG record occurs somewhere other than the end of
    the additional data section."""
    pass

class UnknownTSIGKey(dns.exception.DNSException):
    """Raised if we got a TSIG but don't know the key."""
    pass

class Message(object):
    """A DNS message.

    @ivar id: The query id; the default is a randomly chosen id.
    @type id: int
    @ivar flags: The DNS flags of the message.  @see: RFC 1035 for an
    explanation of these flags.
    @type flags: int
    @ivar question: The question section.
    @type question: list of dns.rrset.RRset objects
    @ivar answer: The answer section.
    @type answer: list of dns.rrset.RRset objects
    @ivar authority: The authority section.
    @type authority: list of dns.rrset.RRset objects
    @ivar additional: The additional data section.
    @type additional: list of dns.rrset.RRset objects
    @ivar edns: The EDNS level to use.  The default is -1, no Edns.
    @type edns: int
    @ivar ednsflags: The EDNS flags
    @type ednsflags: long
    @ivar payload: The EDNS payload size.  The default is 0.
    @type payload: int
    @ivar options: The EDNS options
    @type options: list of dns.edns.Option objects
    @ivar request_payload: The associated request's EDNS payload size.
    @type request_payload: int
    @ivar keyring: The TSIG keyring to use.  The default is None.
    @type keyring: dict
    @ivar keyname: The TSIG keyname to use.  The default is None.
    @type keyname: dns.name.Name object
    @ivar keyalgorithm: The TSIG algorithm to use; defaults to
    dns.tsig.default_algorithm.  Constants for TSIG algorithms are defined
    in dns.tsig, and the currently implemented algorithms are
    HMAC_MD5, HMAC_SHA1, HMAC_SHA224, HMAC_SHA256, HMAC_SHA384, and
    HMAC_SHA512.
    @type keyalgorithm: string
    @ivar request_mac: The TSIG MAC of the request message associated with
    this message; used when validating TSIG signatures.   @see: RFC 2845 for
    more information on TSIG fields.
    @type request_mac: string
    @ivar fudge: TSIG time fudge; default is 300 seconds.
    @type fudge: int
    @ivar original_id: TSIG original id; defaults to the message's id
    @type original_id: int
    @ivar tsig_error: TSIG error code; default is 0.
    @type tsig_error: int
    @ivar other_data: TSIG other data.
    @type other_data: string
    @ivar mac: The TSIG MAC for this message.
    @type mac: string
    @ivar xfr: Is the message being used to contain the results of a DNS
    zone transfer?  The default is False.
    @type xfr: bool
    @ivar origin: The origin of the zone in messages which are used for
    zone transfers or for DNS dynamic updates.  The default is None.
    @type origin: dns.name.Name object
    @ivar tsig_ctx: The TSIG signature context associated with this
    message.  The default is None.
    @type tsig_ctx: hmac.HMAC object
    @ivar had_tsig: Did the message decoded from wire format have a TSIG
    signature?
    @type had_tsig: bool
    @ivar multi: Is this message part of a multi-message sequence?  The
    default is false.  This variable is used when validating TSIG signatures
    on messages which are part of a zone transfer.
    @type multi: bool
    @ivar first: Is this message standalone, or the first of a multi
    message sequence?  This variable is used when validating TSIG signatures
    on messages which are part of a zone transfer.
    @type first: bool
    @ivar index: An index of rrsets in the message.  The index key is
    (section, name, rdclass, rdtype, covers, deleting).  Indexing can be
    disabled by setting the index to None.
    @type index: dict
    """

    def __init__(self, id=None):
        if id is None:
            self.id = dns.entropy.random_16()
        else:
            self.id = id
        self.flags = 0
        self.question = []
        self.answer = []
        self.authority = []
        self.additional = []
        self.edns = -1
        self.ednsflags = 0
        self.payload = 0
        self.options = []
        self.request_payload = 0
        self.keyring = None
        self.keyname = None
        self.keyalgorithm = dns.tsig.default_algorithm
        self.request_mac = ''
        self.other_data = ''
        self.tsig_error = 0
        self.fudge = 300
        self.original_id = self.id
        self.mac = ''
        self.xfr = False
        self.origin = None
        self.tsig_ctx = None
        self.had_tsig = False
        self.multi = False
        self.first = True
        self.index = {}

    def __repr__(self):
        return '<DNS message, ID ' + `self.id` + '>'

    def __str__(self):
        return self.to_text()

    def to_text(self,  origin=None, relativize=True, **kw):
        """Convert the message to text.

        The I{origin}, I{relativize}, and any other keyword
        arguments are passed to the rrset to_wire() method.

        @rtype: string
        """

        s = cStringIO.StringIO()
        print >> s, 'id %d' % self.id
        print >> s, 'opcode %s' % \
              dns.opcode.to_text(dns.opcode.from_flags(self.flags))
        rc = dns.rcode.from_flags(self.flags, self.ednsflags)
        print >> s, 'rcode %s' % dns.rcode.to_text(rc)
        print >> s, 'flags %s' % dns.flags.to_text(self.flags)
        if self.edns >= 0:
            print >> s, 'edns %s' % self.edns
            if self.ednsflags != 0:
                print >> s, 'eflags %s' % \
                      dns.flags.edns_to_text(self.ednsflags)
            print >> s, 'payload', self.payload
        is_update = dns.opcode.is_update(self.flags)
        if is_update:
            print >> s, ';ZONE'
        else:
            print >> s, ';QUESTION'
        for rrset in self.question:
            print >> s, rrset.to_text(origin, relativize, **kw)
        if is_update:
            print >> s, ';PREREQ'
        else:
            print >> s, ';ANSWER'
        for rrset in self.answer:
            print >> s, rrset.to_text(origin, relativize, **kw)
        if is_update:
            print >> s, ';UPDATE'
        else:
            print >> s, ';AUTHORITY'
        for rrset in self.authority:
            print >> s, rrset.to_text(origin, relativize, **kw)
        print >> s, ';ADDITIONAL'
        for rrset in self.additional:
            print >> s, rrset.to_text(origin, relativize, **kw)
        #
        # We strip off the final \n so the caller can print the result without
        # doing weird things to get around eccentricities in Python print
        # formatting
        #
        return s.getvalue()[:-1]

    def __eq__(self, other):
        """Two messages are equal if they have the same content in the
        header, question, answer, and authority sections.
        @rtype: bool"""
        if not isinstance(other, Message):
            return False
        if self.id != other.id:
            return False
        if self.flags != other.flags:
            return False
        for n in self.question:
            if n not in other.question:
                return False
        for n in other.question:
            if n not in self.question:
                return False
        for n in self.answer:
            if n not in other.answer:
                return False
        for n in other.answer:
            if n not in self.answer:
                return False
        for n in self.authority:
            if n not in other.authority:
                return False
        for n in other.authority:
            if n not in self.authority:
                return False
        return True

    def __ne__(self, other):
        """Are two messages not equal?
        @rtype: bool"""
        return not self.__eq__(other)

    def is_response(self, other):
        """Is other a response to self?
        @rtype: bool"""
        if other.flags & dns.flags.QR == 0 or \
           self.id != other.id or \
           dns.opcode.from_flags(self.flags) != \
           dns.opcode.from_flags(other.flags):
            return False
        if dns.rcode.from_flags(other.flags, other.ednsflags) != \
               dns.rcode.NOERROR:
            return True
        if dns.opcode.is_update(self.flags):
            return True
        for n in self.question:
            if n not in other.question:
                return False
        for n in other.question:
            if n not in self.question:
                return False
        return True

    def section_number(self, section):
        if section is self.question:
            return 0
        elif section is self.answer:
            return 1
        elif section is self.authority:
            return 2
        elif section is self.additional:
            return 3
        else:
            raise ValueError('unknown section')

    def find_rrset(self, section, name, rdclass, rdtype,
                   covers=dns.rdatatype.NONE, deleting=None, create=False,
                   force_unique=False):
        """Find the RRset with the given attributes in the specified section.

        @param section: the section of the message to look in, e.g.
        self.answer.
        @type section: list of dns.rrset.RRset objects
        @param name: the name of the RRset
        @type name: dns.name.Name object
        @param rdclass: the class of the RRset
        @type rdclass: int
        @param rdtype: the type of the RRset
        @type rdtype: int
        @param covers: the covers value of the RRset
        @type covers: int
        @param deleting: the deleting value of the RRset
        @type deleting: int
        @param create: If True, create the RRset if it is not found.
        The created RRset is appended to I{section}.
        @type create: bool
        @param force_unique: If True and create is also True, create a
        new RRset regardless of whether a matching RRset exists already.
        @type force_unique: bool
        @raises KeyError: the RRset was not found and create was False
        @rtype: dns.rrset.RRset object"""

        key = (self.section_number(section),
               name, rdclass, rdtype, covers, deleting)
        if not force_unique:
            if not self.index is None:
                rrset = self.index.get(key)
                if not rrset is None:
                    return rrset
            else:
                for rrset in section:
                    if rrset.match(name, rdclass, rdtype, covers, deleting):
                        return rrset
        if not create:
            raise KeyError
        rrset = dns.rrset.RRset(name, rdclass, rdtype, covers, deleting)
        section.append(rrset)
        if not self.index is None:
            self.index[key] = rrset
        return rrset

    def get_rrset(self, section, name, rdclass, rdtype,
                  covers=dns.rdatatype.NONE, deleting=None, create=False,
                  force_unique=False):
        """Get the RRset with the given attributes in the specified section.

        If the RRset is not found, None is returned.

        @param section: the section of the message to look in, e.g.
        self.answer.
        @type section: list of dns.rrset.RRset objects
        @param name: the name of the RRset
        @type name: dns.name.Name object
        @param rdclass: the class of the RRset
        @type rdclass: int
        @param rdtype: the type of the RRset
        @type rdtype: int
        @param covers: the covers value of the RRset
        @type covers: int
        @param deleting: the deleting value of the RRset
        @type deleting: int
        @param create: If True, create the RRset if it is not found.
        The created RRset is appended to I{section}.
        @type create: bool
        @param force_unique: If True and create is also True, create a
        new RRset regardless of whether a matching RRset exists already.
        @type force_unique: bool
        @rtype: dns.rrset.RRset object or None"""

        try:
            rrset = self.find_rrset(section, name, rdclass, rdtype, covers,
                                    deleting, create, force_unique)
        except KeyError:
            rrset = None
        return rrset

    def to_wire(self, origin=None, max_size=0, **kw):
        """Return a string containing the message in DNS compressed wire
        format.

        Additional keyword arguments are passed to the rrset to_wire()
        method.

        @param origin: The origin to be appended to any relative names.
        @type origin: dns.name.Name object
        @param max_size: The maximum size of the wire format output; default
        is 0, which means 'the message's request payload, if nonzero, or
        65536'.
        @type max_size: int
        @raises dns.exception.TooBig: max_size was exceeded
        @rtype: string
        """

        if max_size == 0:
            if self.request_payload != 0:
                max_size = self.request_payload
            else:
                max_size = 65535
        if max_size < 512:
            max_size = 512
        elif max_size > 65535:
            max_size = 65535
        r = dns.renderer.Renderer(self.id, self.flags, max_size, origin)
        for rrset in self.question:
            r.add_question(rrset.name, rrset.rdtype, rrset.rdclass)
        for rrset in self.answer:
            r.add_rrset(dns.renderer.ANSWER, rrset, **kw)
        for rrset in self.authority:
            r.add_rrset(dns.renderer.AUTHORITY, rrset, **kw)
        if self.edns >= 0:
            r.add_edns(self.edns, self.ednsflags, self.payload, self.options)
        for rrset in self.additional:
            r.add_rrset(dns.renderer.ADDITIONAL, rrset, **kw)
        r.write_header()
        if not self.keyname is None:
            r.add_tsig(self.keyname, self.keyring[self.keyname],
                       self.fudge, self.original_id, self.tsig_error,
                       self.other_data, self.request_mac,
                       self.keyalgorithm)
            self.mac = r.mac
        return r.get_wire()

    def use_tsig(self, keyring, keyname=None, fudge=300,
                 original_id=None, tsig_error=0, other_data='',
                 algorithm=dns.tsig.default_algorithm):
        """When sending, a TSIG signature using the specified keyring
        and keyname should be added.

        @param keyring: The TSIG keyring to use; defaults to None.
        @type keyring: dict
        @param keyname: The name of the TSIG key to use; defaults to None.
        The key must be defined in the keyring.  If a keyring is specified
        but a keyname is not, then the key used will be the first key in the
        keyring.  Note that the order of keys in a dictionary is not defined,
        so applications should supply a keyname when a keyring is used, unless
        they know the keyring contains only one key.
        @type keyname: dns.name.Name or string
        @param fudge: TSIG time fudge; default is 300 seconds.
        @type fudge: int
        @param original_id: TSIG original id; defaults to the message's id
        @type original_id: int
        @param tsig_error: TSIG error code; default is 0.
        @type tsig_error: int
        @param other_data: TSIG other data.
        @type other_data: string
        @param algorithm: The TSIG algorithm to use; defaults to
        dns.tsig.default_algorithm
        """

        self.keyring = keyring
        if keyname is None:
            self.keyname = self.keyring.keys()[0]
        else:
            if isinstance(keyname, (str, unicode)):
                keyname = dns.name.from_text(keyname)
            self.keyname = keyname
        self.keyalgorithm = algorithm
        self.fudge = fudge
        if original_id is None:
            self.original_id = self.id
        else:
            self.original_id = original_id
        self.tsig_error = tsig_error
        self.other_data = other_data

    def use_edns(self, edns=0, ednsflags=0, payload=1280, request_payload=None, options=None):
        """Configure EDNS behavior.
        @param edns: The EDNS level to use.  Specifying None, False, or -1
        means 'do not use EDNS', and in this case the other parameters are
        ignored.  Specifying True is equivalent to specifying 0, i.e. 'use
        EDNS0'.
        @type edns: int or bool or None
        @param ednsflags: EDNS flag values.
        @type ednsflags: int
        @param payload: The EDNS sender's payload field, which is the maximum
        size of UDP datagram the sender can handle.
        @type payload: int
        @param request_payload: The EDNS payload size to use when sending
        this message.  If not specified, defaults to the value of payload.
        @type request_payload: int or None
        @param options: The EDNS options
        @type options: None or list of dns.edns.Option objects
        @see: RFC 2671
        """
        if edns is None or edns is False:
            edns = -1
        if edns is True:
            edns = 0
        if request_payload is None:
            request_payload = payload
        if edns < 0:
            ednsflags = 0
            payload = 0
            request_payload = 0
            options = []
        else:
            # make sure the EDNS version in ednsflags agrees with edns
            ednsflags &= 0xFF00FFFFL
            ednsflags |= (edns << 16)
            if options is None:
                options = []
        self.edns = edns
        self.ednsflags = ednsflags
        self.payload = payload
        self.options = options
        self.request_payload = request_payload

    def want_dnssec(self, wanted=True):
        """Enable or disable 'DNSSEC desired' flag in requests.
        @param wanted: Is DNSSEC desired?  If True, EDNS is enabled if
        required, and then the DO bit is set.  If False, the DO bit is
        cleared if EDNS is enabled.
        @type wanted: bool
        """
        if wanted:
            if self.edns < 0:
                self.use_edns()
            self.ednsflags |= dns.flags.DO
        elif self.edns >= 0:
            self.ednsflags &= ~dns.flags.DO

    def rcode(self):
        """Return the rcode.
        @rtype: int
        """
        return dns.rcode.from_flags(self.flags, self.ednsflags)

    def set_rcode(self, rcode):
        """Set the rcode.
        @param rcode: the rcode
        @type rcode: int
        """
        (value, evalue) = dns.rcode.to_flags(rcode)
        self.flags &= 0xFFF0
        self.flags |= value
        self.ednsflags &= 0x00FFFFFFL
        self.ednsflags |= evalue
        if self.ednsflags != 0 and self.edns < 0:
            self.edns = 0

    def opcode(self):
        """Return the opcode.
        @rtype: int
        """
        return dns.opcode.from_flags(self.flags)

    def set_opcode(self, opcode):
        """Set the opcode.
        @param opcode: the opcode
        @type opcode: int
        """
        self.flags &= 0x87FF
        self.flags |= dns.opcode.to_flags(opcode)

class _WireReader(object):
    """Wire format reader.

    @ivar wire: the wire-format message.
    @type wire: string
    @ivar message: The message object being built
    @type message: dns.message.Message object
    @ivar current: When building a message object from wire format, this
    variable contains the offset from the beginning of wire of the next octet
    to be read.
    @type current: int
    @ivar updating: Is the message a dynamic update?
    @type updating: bool
    @ivar one_rr_per_rrset: Put each RR into its own RRset?
    @type one_rr_per_rrset: bool
    @ivar zone_rdclass: The class of the zone in messages which are
    DNS dynamic updates.
    @type zone_rdclass: int
    """

    def __init__(self, wire, message, question_only=False,
                 one_rr_per_rrset=False):
        self.wire = dns.wiredata.maybe_wrap(wire)
        self.message = message
        self.current = 0
        self.updating = False
        self.zone_rdclass = dns.rdataclass.IN
        self.question_only = question_only
        self.one_rr_per_rrset = one_rr_per_rrset

    def _get_question(self, qcount):
        """Read the next I{qcount} records from the wire data and add them to
        the question section.
        @param qcount: the number of questions in the message
        @type qcount: int"""

        if self.updating and qcount > 1:
            raise dns.exception.FormError

        for i in xrange(0, qcount):
            (qname, used) = dns.name.from_wire(self.wire, self.current)
            if not self.message.origin is None:
                qname = qname.relativize(self.message.origin)
            self.current = self.current + used
            (rdtype, rdclass) = \
                     struct.unpack('!HH',
                                   self.wire[self.current:self.current + 4])
            self.current = self.current + 4
            self.message.find_rrset(self.message.question, qname,
                                    rdclass, rdtype, create=True,
                                    force_unique=True)
            if self.updating:
                self.zone_rdclass = rdclass

    def _get_section(self, section, count):
        """Read the next I{count} records from the wire data and add them to
        the specified section.
        @param section: the section of the message to which to add records
        @type section: list of dns.rrset.RRset objects
        @param count: the number of records to read
        @type count: int"""

        if self.updating or self.one_rr_per_rrset:
            force_unique = True
        else:
            force_unique = False
        seen_opt = False
        for i in xrange(0, count):
            rr_start = self.current
            (name, used) = dns.name.from_wire(self.wire, self.current)
            absolute_name = name
            if not self.message.origin is None:
                name = name.relativize(self.message.origin)
            self.current = self.current + used
            (rdtype, rdclass, ttl, rdlen) = \
                     struct.unpack('!HHIH',
                                   self.wire[self.current:self.current + 10])
            self.current = self.current + 10
            if rdtype == dns.rdatatype.OPT:
                if not section is self.message.additional or seen_opt:
                    raise BadEDNS
                self.message.payload = rdclass
                self.message.ednsflags = ttl
                self.message.edns = (ttl & 0xff0000) >> 16
                self.message.options = []
                current = self.current
                optslen = rdlen
                while optslen > 0:
                    (otype, olen) = \
                            struct.unpack('!HH',
                                          self.wire[current:current + 4])
                    current = current + 4
                    opt = dns.edns.option_from_wire(otype, self.wire, current, olen)
                    self.message.options.append(opt)
                    current = current + olen
                    optslen = optslen - 4 - olen
                seen_opt = True
            elif rdtype == dns.rdatatype.TSIG:
                if not (section is self.message.additional and
                        i == (count - 1)):
                    raise BadTSIG
                if self.message.keyring is None:
                    raise UnknownTSIGKey('got signed message without keyring')
                secret = self.message.keyring.get(absolute_name)
                if secret is None:
                    raise UnknownTSIGKey("key '%s' unknown" % name)
                self.message.tsig_ctx = \
                                      dns.tsig.validate(self.wire,
                                          absolute_name,
                                          secret,
                                          int(time.time()),
                                          self.message.request_mac,
                                          rr_start,
                                          self.current,
                                          rdlen,
                                          self.message.tsig_ctx,
                                          self.message.multi,
                                          self.message.first)
                self.message.had_tsig = True
            else:
                if ttl < 0:
                    ttl = 0
                if self.updating and \
                   (rdclass == dns.rdataclass.ANY or
                    rdclass == dns.rdataclass.NONE):
                    deleting = rdclass
                    rdclass = self.zone_rdclass
                else:
                    deleting = None
                if deleting == dns.rdataclass.ANY or \
                   (deleting == dns.rdataclass.NONE and \
                    section is self.message.answer):
                    covers = dns.rdatatype.NONE
                    rd = None
                else:
                    rd = dns.rdata.from_wire(rdclass, rdtype, self.wire,
                                             self.current, rdlen,
                                             self.message.origin)
                    covers = rd.covers()
                if self.message.xfr and rdtype == dns.rdatatype.SOA:
                    force_unique = True
                rrset = self.message.find_rrset(section, name,
                                                rdclass, rdtype, covers,
                                                deleting, True, force_unique)
                if not rd is None:
                    rrset.add(rd, ttl)
            self.current = self.current + rdlen

    def read(self):
        """Read a wire format DNS message and build a dns.message.Message
        object."""

        l = len(self.wire)
        if l < 12:
            raise ShortHeader
        (self.message.id, self.message.flags, qcount, ancount,
         aucount, adcount) = struct.unpack('!HHHHHH', self.wire[:12])
        self.current = 12
        if dns.opcode.is_update(self.message.flags):
            self.updating = True
        self._get_question(qcount)
        if self.question_only:
            return
        self._get_section(self.message.answer, ancount)
        self._get_section(self.message.authority, aucount)
        self._get_section(self.message.additional, adcount)
        if self.current != l:
            raise TrailingJunk
        if self.message.multi and self.message.tsig_ctx and \
               not self.message.had_tsig:
            self.message.tsig_ctx.update(self.wire)


def from_wire(wire, keyring=None, request_mac='', xfr=False, origin=None,
              tsig_ctx = None, multi = False, first = True,
              question_only = False, one_rr_per_rrset = False):
    """Convert a DNS wire format message into a message
    object.

    @param keyring: The keyring to use if the message is signed.
    @type keyring: dict
    @param request_mac: If the message is a response to a TSIG-signed request,
    I{request_mac} should be set to the MAC of that request.
    @type request_mac: string
    @param xfr: Is this message part of a zone transfer?
    @type xfr: bool
    @param origin: If the message is part of a zone transfer, I{origin}
    should be the origin name of the zone.
    @type origin: dns.name.Name object
    @param tsig_ctx: The ongoing TSIG context, used when validating zone
    transfers.
    @type tsig_ctx: hmac.HMAC object
    @param multi: Is this message part of a multiple message sequence?
    @type multi: bool
    @param first: Is this message standalone, or the first of a multi
    message sequence?
    @type first: bool
    @param question_only: Read only up to the end of the question section?
    @type question_only: bool
    @param one_rr_per_rrset: Put each RR into its own RRset
    @type one_rr_per_rrset: bool
    @raises ShortHeader: The message is less than 12 octets long.
    @raises TrailingJunk: There were octets in the message past the end
    of the proper DNS message.
    @raises BadEDNS: An OPT record was in the wrong section, or occurred more
    than once.
    @raises BadTSIG: A TSIG record was not the last record of the additional
    data section.
    @rtype: dns.message.Message object"""

    m = Message(id=0)
    m.keyring = keyring
    m.request_mac = request_mac
    m.xfr = xfr
    m.origin = origin
    m.tsig_ctx = tsig_ctx
    m.multi = multi
    m.first = first

    reader = _WireReader(wire, m, question_only, one_rr_per_rrset)
    reader.read()

    return m


class _TextReader(object):
    """Text format reader.

    @ivar tok: the tokenizer
    @type tok: dns.tokenizer.Tokenizer object
    @ivar message: The message object being built
    @type message: dns.message.Message object
    @ivar updating: Is the message a dynamic update?
    @type updating: bool
    @ivar zone_rdclass: The class of the zone in messages which are
    DNS dynamic updates.
    @type zone_rdclass: int
    @ivar last_name: The most recently read name when building a message object
    from text format.
    @type last_name: dns.name.Name object
    """

    def __init__(self, text, message):
        self.message = message
        self.tok = dns.tokenizer.Tokenizer(text)
        self.last_name = None
        self.zone_rdclass = dns.rdataclass.IN
        self.updating = False

    def _header_line(self, section):
        """Process one line from the text format header section."""

        token = self.tok.get()
        what = token.value
        if what == 'id':
            self.message.id = self.tok.get_int()
        elif what == 'flags':
            while True:
                token = self.tok.get()
                if not token.is_identifier():
                    self.tok.unget(token)
                    break
                self.message.flags = self.message.flags | \
                                     dns.flags.from_text(token.value)
            if dns.opcode.is_update(self.message.flags):
                self.updating = True
        elif what == 'edns':
            self.message.edns = self.tok.get_int()
            self.message.ednsflags = self.message.ednsflags | \
                                     (self.message.edns << 16)
        elif what == 'eflags':
            if self.message.edns < 0:
                self.message.edns = 0
            while True:
                token = self.tok.get()
                if not token.is_identifier():
                    self.tok.unget(token)
                    break
                self.message.ednsflags = self.message.ednsflags | \
                              dns.flags.edns_from_text(token.value)
        elif what == 'payload':
            self.message.payload = self.tok.get_int()
            if self.message.edns < 0:
                self.message.edns = 0
        elif what == 'opcode':
            text = self.tok.get_string()
            self.message.flags = self.message.flags | \
                      dns.opcode.to_flags(dns.opcode.from_text(text))
        elif what == 'rcode':
            text = self.tok.get_string()
            self.message.set_rcode(dns.rcode.from_text(text))
        else:
            raise UnknownHeaderField
        self.tok.get_eol()

    def _question_line(self, section):
        """Process one line from the text format question section."""

        token = self.tok.get(want_leading = True)
        if not token.is_whitespace():
            self.last_name = dns.name.from_text(token.value, None)
        name = self.last_name
        token = self.tok.get()
        if not token.is_identifier():
            raise dns.exception.SyntaxError
        # Class
        try:
            rdclass = dns.rdataclass.from_text(token.value)
            token = self.tok.get()
            if not token.is_identifier():
                raise dns.exception.SyntaxError
        except dns.exception.SyntaxError:
            raise dns.exception.SyntaxError
        except StandardError:
            rdclass = dns.rdataclass.IN
        # Type
        rdtype = dns.rdatatype.from_text(token.value)
        self.message.find_rrset(self.message.question, name,
                                rdclass, rdtype, create=True,
                                force_unique=True)
        if self.updating:
            self.zone_rdclass = rdclass
        self.tok.get_eol()

    def _rr_line(self, section):
        """Process one line from the text format answer, authority, or
        additional data sections.
        """

        deleting = None
        # Name
        token = self.tok.get(want_leading = True)
        if not token.is_whitespace():
            self.last_name = dns.name.from_text(token.value, None)
        name = self.last_name
        token = self.tok.get()
        if not token.is_identifier():
            raise dns.exception.SyntaxError
        # TTL
        try:
            ttl = int(token.value, 0)
            token = self.tok.get()
            if not token.is_identifier():
                raise dns.exception.SyntaxError
        except dns.exception.SyntaxError:
            raise dns.exception.SyntaxError
        except StandardError:
            ttl = 0
        # Class
        try:
            rdclass = dns.rdataclass.from_text(token.value)
            token = self.tok.get()
            if not token.is_identifier():
                raise dns.exception.SyntaxError
            if rdclass == dns.rdataclass.ANY or rdclass == dns.rdataclass.NONE:
                deleting = rdclass
                rdclass = self.zone_rdclass
        except dns.exception.SyntaxError:
            raise dns.exception.SyntaxError
        except StandardError:
            rdclass = dns.rdataclass.IN
        # Type
        rdtype = dns.rdatatype.from_text(token.value)
        token = self.tok.get()
        if not token.is_eol_or_eof():
            self.tok.unget(token)
            rd = dns.rdata.from_text(rdclass, rdtype, self.tok, None)
            covers = rd.covers()
        else:
            rd = None
            covers = dns.rdatatype.NONE
        rrset = self.message.find_rrset(section, name,
                                        rdclass, rdtype, covers,
                                        deleting, True, self.updating)
        if not rd is None:
            rrset.add(rd, ttl)

    def read(self):
        """Read a text format DNS message and build a dns.message.Message
        object."""

        line_method = self._header_line
        section = None
        while 1:
            token = self.tok.get(True, True)
            if token.is_eol_or_eof():
                break
            if token.is_comment():
                u = token.value.upper()
                if u == 'HEADER':
                    line_method = self._header_line
                elif u == 'QUESTION' or u == 'ZONE':
                    line_method = self._question_line
                    section = self.message.question
                elif u == 'ANSWER' or u == 'PREREQ':
                    line_method = self._rr_line
                    section = self.message.answer
                elif u == 'AUTHORITY' or u == 'UPDATE':
                    line_method = self._rr_line
                    section = self.message.authority
                elif u == 'ADDITIONAL':
                    line_method = self._rr_line
                    section = self.message.additional
                self.tok.get_eol()
                continue
            self.tok.unget(token)
            line_method(section)


def from_text(text):
    """Convert the text format message into a message object.

    @param text: The text format message.
    @type text: string
    @raises UnknownHeaderField:
    @raises dns.exception.SyntaxError:
    @rtype: dns.message.Message object"""

    # 'text' can also be a file, but we don't publish that fact
    # since it's an implementation detail.  The official file
    # interface is from_file().

    m = Message()

    reader = _TextReader(text, m)
    reader.read()

    return m

def from_file(f):
    """Read the next text format message from the specified file.

    @param f: file or string.  If I{f} is a string, it is treated
    as the name of a file to open.
    @raises UnknownHeaderField:
    @raises dns.exception.SyntaxError:
    @rtype: dns.message.Message object"""

    if sys.hexversion >= 0x02030000:
        # allow Unicode filenames; turn on universal newline support
        str_type = basestring
        opts = 'rU'
    else:
        str_type = str
        opts = 'r'
    if isinstance(f, str_type):
        f = file(f, opts)
        want_close = True
    else:
        want_close = False

    try:
        m = from_text(f)
    finally:
        if want_close:
            f.close()
    return m

def make_query(qname, rdtype, rdclass = dns.rdataclass.IN, use_edns=None,
               want_dnssec=False):
    """Make a query message.

    The query name, type, and class may all be specified either
    as objects of the appropriate type, or as strings.

    The query will have a randomly choosen query id, and its DNS flags
    will be set to dns.flags.RD.

    @param qname: The query name.
    @type qname: dns.name.Name object or string
    @param rdtype: The desired rdata type.
    @type rdtype: int
    @param rdclass: The desired rdata class; the default is class IN.
    @type rdclass: int
    @param use_edns: The EDNS level to use; the default is None (no EDNS).
    See the description of dns.message.Message.use_edns() for the possible
    values for use_edns and their meanings.
    @type use_edns: int or bool or None
    @param want_dnssec: Should the query indicate that DNSSEC is desired?
    @type want_dnssec: bool
    @rtype: dns.message.Message object"""

    if isinstance(qname, (str, unicode)):
        qname = dns.name.from_text(qname)
    if isinstance(rdtype, (str, unicode)):
        rdtype = dns.rdatatype.from_text(rdtype)
    if isinstance(rdclass, (str, unicode)):
        rdclass = dns.rdataclass.from_text(rdclass)
    m = Message()
    m.flags |= dns.flags.RD
    m.find_rrset(m.question, qname, rdclass, rdtype, create=True,
                 force_unique=True)
    m.use_edns(use_edns)
    m.want_dnssec(want_dnssec)
    return m

def make_response(query, recursion_available=False, our_payload=8192):
    """Make a message which is a response for the specified query.
    The message returned is really a response skeleton; it has all
    of the infrastructure required of a response, but none of the
    content.

    The response's question section is a shallow copy of the query's
    question section, so the query's question RRsets should not be
    changed.

    @param query: the query to respond to
    @type query: dns.message.Message object
    @param recursion_available: should RA be set in the response?
    @type recursion_available: bool
    @param our_payload: payload size to advertise in EDNS responses; default
    is 8192.
    @type our_payload: int
    @rtype: dns.message.Message object"""

    if query.flags & dns.flags.QR:
        raise dns.exception.FormError('specified query message is not a query')
    response = dns.message.Message(query.id)
    response.flags = dns.flags.QR | (query.flags & dns.flags.RD)
    if recursion_available:
        response.flags |= dns.flags.RA
    response.set_opcode(query.opcode())
    response.question = list(query.question)
    if query.edns >= 0:
        response.use_edns(0, 0, our_payload, query.payload)
    if not query.keyname is None:
        response.keyname = query.keyname
        response.keyring = query.keyring
        response.request_mac = query.mac
    return response

########NEW FILE########
__FILENAME__ = name
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Names.

@var root: The DNS root name.
@type root: dns.name.Name object
@var empty: The empty DNS name.
@type empty: dns.name.Name object
"""

import cStringIO
import struct
import sys

if sys.hexversion >= 0x02030000:
    import encodings.idna

import dns.exception
import dns.wiredata

NAMERELN_NONE = 0
NAMERELN_SUPERDOMAIN = 1
NAMERELN_SUBDOMAIN = 2
NAMERELN_EQUAL = 3
NAMERELN_COMMONANCESTOR = 4

class EmptyLabel(dns.exception.SyntaxError):
    """Raised if a label is empty."""
    pass

class BadEscape(dns.exception.SyntaxError):
    """Raised if an escaped code in a text format name is invalid."""
    pass

class BadPointer(dns.exception.FormError):
    """Raised if a compression pointer points forward instead of backward."""
    pass

class BadLabelType(dns.exception.FormError):
    """Raised if the label type of a wire format name is unknown."""
    pass

class NeedAbsoluteNameOrOrigin(dns.exception.DNSException):
    """Raised if an attempt is made to convert a non-absolute name to
    wire when there is also a non-absolute (or missing) origin."""
    pass

class NameTooLong(dns.exception.FormError):
    """Raised if a name is > 255 octets long."""
    pass

class LabelTooLong(dns.exception.SyntaxError):
    """Raised if a label is > 63 octets long."""
    pass

class AbsoluteConcatenation(dns.exception.DNSException):
    """Raised if an attempt is made to append anything other than the
    empty name to an absolute name."""
    pass

class NoParent(dns.exception.DNSException):
    """Raised if an attempt is made to get the parent of the root name
    or the empty name."""
    pass

_escaped = {
    '"' : True,
    '(' : True,
    ')' : True,
    '.' : True,
    ';' : True,
    '\\' : True,
    '@' : True,
    '$' : True
    }

def _escapify(label):
    """Escape the characters in label which need it.
    @returns: the escaped string
    @rtype: string"""
    text = ''
    for c in label:
        if c in _escaped:
            text += '\\' + c
        elif ord(c) > 0x20 and ord(c) < 0x7F:
            text += c
        else:
            text += '\\%03d' % ord(c)
    return text

def _validate_labels(labels):
    """Check for empty labels in the middle of a label sequence,
    labels that are too long, and for too many labels.
    @raises NameTooLong: the name as a whole is too long
    @raises LabelTooLong: an individual label is too long
    @raises EmptyLabel: a label is empty (i.e. the root label) and appears
    in a position other than the end of the label sequence"""

    l = len(labels)
    total = 0
    i = -1
    j = 0
    for label in labels:
        ll = len(label)
        total += ll + 1
        if ll > 63:
            raise LabelTooLong
        if i < 0 and label == '':
            i = j
        j += 1
    if total > 255:
        raise NameTooLong
    if i >= 0 and i != l - 1:
        raise EmptyLabel

class Name(object):
    """A DNS name.

    The dns.name.Name class represents a DNS name as a tuple of labels.
    Instances of the class are immutable.

    @ivar labels: The tuple of labels in the name. Each label is a string of
    up to 63 octets."""

    __slots__ = ['labels']

    def __init__(self, labels):
        """Initialize a domain name from a list of labels.
        @param labels: the labels
        @type labels: any iterable whose values are strings
        """

        super(Name, self).__setattr__('labels', tuple(labels))
        _validate_labels(self.labels)

    def __setattr__(self, name, value):
        raise TypeError("object doesn't support attribute assignment")

    def is_absolute(self):
        """Is the most significant label of this name the root label?
        @rtype: bool
        """

        return len(self.labels) > 0 and self.labels[-1] == ''

    def is_wild(self):
        """Is this name wild?  (I.e. Is the least significant label '*'?)
        @rtype: bool
        """

        return len(self.labels) > 0 and self.labels[0] == '*'

    def __hash__(self):
        """Return a case-insensitive hash of the name.
        @rtype: int
        """

        h = 0L
        for label in self.labels:
            for c in label:
                h += ( h << 3 ) + ord(c.lower())
        return int(h % sys.maxint)

    def fullcompare(self, other):
        """Compare two names, returning a 3-tuple (relation, order, nlabels).

        I{relation} describes the relation ship beween the names,
        and is one of: dns.name.NAMERELN_NONE,
        dns.name.NAMERELN_SUPERDOMAIN, dns.name.NAMERELN_SUBDOMAIN,
        dns.name.NAMERELN_EQUAL, or dns.name.NAMERELN_COMMONANCESTOR

        I{order} is < 0 if self < other, > 0 if self > other, and ==
        0 if self == other.  A relative name is always less than an
        absolute name.  If both names have the same relativity, then
        the DNSSEC order relation is used to order them.

        I{nlabels} is the number of significant labels that the two names
        have in common.
        """

        sabs = self.is_absolute()
        oabs = other.is_absolute()
        if sabs != oabs:
            if sabs:
                return (NAMERELN_NONE, 1, 0)
            else:
                return (NAMERELN_NONE, -1, 0)
        l1 = len(self.labels)
        l2 = len(other.labels)
        ldiff = l1 - l2
        if ldiff < 0:
            l = l1
        else:
            l = l2

        order = 0
        nlabels = 0
        namereln = NAMERELN_NONE
        while l > 0:
            l -= 1
            l1 -= 1
            l2 -= 1
            label1 = self.labels[l1].lower()
            label2 = other.labels[l2].lower()
            if label1 < label2:
                order = -1
                if nlabels > 0:
                    namereln = NAMERELN_COMMONANCESTOR
                return (namereln, order, nlabels)
            elif label1 > label2:
                order = 1
                if nlabels > 0:
                    namereln = NAMERELN_COMMONANCESTOR
                return (namereln, order, nlabels)
            nlabels += 1
        order = ldiff
        if ldiff < 0:
            namereln = NAMERELN_SUPERDOMAIN
        elif ldiff > 0:
            namereln = NAMERELN_SUBDOMAIN
        else:
            namereln = NAMERELN_EQUAL
        return (namereln, order, nlabels)

    def is_subdomain(self, other):
        """Is self a subdomain of other?

        The notion of subdomain includes equality.
        @rtype: bool
        """

        (nr, o, nl) = self.fullcompare(other)
        if nr == NAMERELN_SUBDOMAIN or nr == NAMERELN_EQUAL:
            return True
        return False

    def is_superdomain(self, other):
        """Is self a superdomain of other?

        The notion of subdomain includes equality.
        @rtype: bool
        """

        (nr, o, nl) = self.fullcompare(other)
        if nr == NAMERELN_SUPERDOMAIN or nr == NAMERELN_EQUAL:
            return True
        return False

    def canonicalize(self):
        """Return a name which is equal to the current name, but is in
        DNSSEC canonical form.
        @rtype: dns.name.Name object
        """

        return Name([x.lower() for x in self.labels])

    def __eq__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] == 0
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] != 0
        else:
            return True

    def __lt__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] < 0
        else:
            return NotImplemented

    def __le__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] <= 0
        else:
            return NotImplemented

    def __ge__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] >= 0
        else:
            return NotImplemented

    def __gt__(self, other):
        if isinstance(other, Name):
            return self.fullcompare(other)[1] > 0
        else:
            return NotImplemented

    def __repr__(self):
        return '<DNS name ' + self.__str__() + '>'

    def __str__(self):
        return self.to_text(False)

    def to_text(self, omit_final_dot = False):
        """Convert name to text format.
        @param omit_final_dot: If True, don't emit the final dot (denoting the
        root label) for absolute names.  The default is False.
        @rtype: string
        """

        if len(self.labels) == 0:
            return '@'
        if len(self.labels) == 1 and self.labels[0] == '':
            return '.'
        if omit_final_dot and self.is_absolute():
            l = self.labels[:-1]
        else:
            l = self.labels
        s = '.'.join(map(_escapify, l))
        return s

    def to_unicode(self, omit_final_dot = False):
        """Convert name to Unicode text format.

        IDN ACE lables are converted to Unicode.

        @param omit_final_dot: If True, don't emit the final dot (denoting the
        root label) for absolute names.  The default is False.
        @rtype: string
        """

        if len(self.labels) == 0:
            return u'@'
        if len(self.labels) == 1 and self.labels[0] == '':
            return u'.'
        if omit_final_dot and self.is_absolute():
            l = self.labels[:-1]
        else:
            l = self.labels
        s = u'.'.join([encodings.idna.ToUnicode(_escapify(x)) for x in l])
        return s

    def to_digestable(self, origin=None):
        """Convert name to a format suitable for digesting in hashes.

        The name is canonicalized and converted to uncompressed wire format.

        @param origin: If the name is relative and origin is not None, then
        origin will be appended to it.
        @type origin: dns.name.Name object
        @raises NeedAbsoluteNameOrOrigin: All names in wire format are
        absolute.  If self is a relative name, then an origin must be supplied;
        if it is missing, then this exception is raised
        @rtype: string
        """

        if not self.is_absolute():
            if origin is None or not origin.is_absolute():
                raise NeedAbsoluteNameOrOrigin
            labels = list(self.labels)
            labels.extend(list(origin.labels))
        else:
            labels = self.labels
        dlabels = ["%s%s" % (chr(len(x)), x.lower()) for x in labels]
        return ''.join(dlabels)

    def to_wire(self, file = None, compress = None, origin = None):
        """Convert name to wire format, possibly compressing it.

        @param file: the file where the name is emitted (typically
        a cStringIO file).  If None, a string containing the wire name
        will be returned.
        @type file: file or None
        @param compress: The compression table.  If None (the default) names
        will not be compressed.
        @type compress: dict
        @param origin: If the name is relative and origin is not None, then
        origin will be appended to it.
        @type origin: dns.name.Name object
        @raises NeedAbsoluteNameOrOrigin: All names in wire format are
        absolute.  If self is a relative name, then an origin must be supplied;
        if it is missing, then this exception is raised
        """

        if file is None:
            file = cStringIO.StringIO()
            want_return = True
        else:
            want_return = False

        if not self.is_absolute():
            if origin is None or not origin.is_absolute():
                raise NeedAbsoluteNameOrOrigin
            labels = list(self.labels)
            labels.extend(list(origin.labels))
        else:
            labels = self.labels
        i = 0
        for label in labels:
            n = Name(labels[i:])
            i += 1
            if not compress is None:
                pos = compress.get(n)
            else:
                pos = None
            if not pos is None:
                value = 0xc000 + pos
                s = struct.pack('!H', value)
                file.write(s)
                break
            else:
                if not compress is None and len(n) > 1:
                    pos = file.tell()
                    if pos < 0xc000:
                        compress[n] = pos
                l = len(label)
                file.write(chr(l))
                if l > 0:
                    file.write(label)
        if want_return:
            return file.getvalue()

    def __len__(self):
        """The length of the name (in labels).
        @rtype: int
        """

        return len(self.labels)

    def __getitem__(self, index):
        return self.labels[index]

    def __getslice__(self, start, stop):
        return self.labels[start:stop]

    def __add__(self, other):
        return self.concatenate(other)

    def __sub__(self, other):
        return self.relativize(other)

    def split(self, depth):
        """Split a name into a prefix and suffix at depth.

        @param depth: the number of labels in the suffix
        @type depth: int
        @raises ValueError: the depth was not >= 0 and <= the length of the
        name.
        @returns: the tuple (prefix, suffix)
        @rtype: tuple
        """

        l = len(self.labels)
        if depth == 0:
            return (self, dns.name.empty)
        elif depth == l:
            return (dns.name.empty, self)
        elif depth < 0 or depth > l:
            raise ValueError('depth must be >= 0 and <= the length of the name')
        return (Name(self[: -depth]), Name(self[-depth :]))

    def concatenate(self, other):
        """Return a new name which is the concatenation of self and other.
        @rtype: dns.name.Name object
        @raises AbsoluteConcatenation: self is absolute and other is
        not the empty name
        """

        if self.is_absolute() and len(other) > 0:
            raise AbsoluteConcatenation
        labels = list(self.labels)
        labels.extend(list(other.labels))
        return Name(labels)

    def relativize(self, origin):
        """If self is a subdomain of origin, return a new name which is self
        relative to origin.  Otherwise return self.
        @rtype: dns.name.Name object
        """

        if not origin is None and self.is_subdomain(origin):
            return Name(self[: -len(origin)])
        else:
            return self

    def derelativize(self, origin):
        """If self is a relative name, return a new name which is the
        concatenation of self and origin.  Otherwise return self.
        @rtype: dns.name.Name object
        """

        if not self.is_absolute():
            return self.concatenate(origin)
        else:
            return self

    def choose_relativity(self, origin=None, relativize=True):
        """Return a name with the relativity desired by the caller.  If
        origin is None, then self is returned.  Otherwise, if
        relativize is true the name is relativized, and if relativize is
        false the name is derelativized.
        @rtype: dns.name.Name object
        """

        if origin:
            if relativize:
                return self.relativize(origin)
            else:
                return self.derelativize(origin)
        else:
            return self

    def parent(self):
        """Return the parent of the name.
        @rtype: dns.name.Name object
        @raises NoParent: the name is either the root name or the empty name,
        and thus has no parent.
        """
        if self == root or self == empty:
            raise NoParent
        return Name(self.labels[1:])

root = Name([''])
empty = Name([])

def from_unicode(text, origin = root):
    """Convert unicode text into a Name object.

    Lables are encoded in IDN ACE form.

    @rtype: dns.name.Name object
    """

    if not isinstance(text, unicode):
        raise ValueError("input to from_unicode() must be a unicode string")
    if not (origin is None or isinstance(origin, Name)):
        raise ValueError("origin must be a Name or None")
    labels = []
    label = u''
    escaping = False
    edigits = 0
    total = 0
    if text == u'@':
        text = u''
    if text:
        if text == u'.':
            return Name([''])        # no Unicode "u" on this constant!
        for c in text:
            if escaping:
                if edigits == 0:
                    if c.isdigit():
                        total = int(c)
                        edigits += 1
                    else:
                        label += c
                        escaping = False
                else:
                    if not c.isdigit():
                        raise BadEscape
                    total *= 10
                    total += int(c)
                    edigits += 1
                    if edigits == 3:
                        escaping = False
                        label += chr(total)
            elif c == u'.' or c == u'\u3002' or \
                 c == u'\uff0e' or c == u'\uff61':
                if len(label) == 0:
                    raise EmptyLabel
                labels.append(encodings.idna.ToASCII(label))
                label = u''
            elif c == u'\\':
                escaping = True
                edigits = 0
                total = 0
            else:
                label += c
        if escaping:
            raise BadEscape
        if len(label) > 0:
            labels.append(encodings.idna.ToASCII(label))
        else:
            labels.append('')
    if (len(labels) == 0 or labels[-1] != '') and not origin is None:
        labels.extend(list(origin.labels))
    return Name(labels)

def from_text(text, origin = root):
    """Convert text into a Name object.
    @rtype: dns.name.Name object
    """

    if not isinstance(text, str):
        if isinstance(text, unicode) and sys.hexversion >= 0x02030000:
            return from_unicode(text, origin)
        else:
            raise ValueError("input to from_text() must be a string")
    if not (origin is None or isinstance(origin, Name)):
        raise ValueError("origin must be a Name or None")
    labels = []
    label = ''
    escaping = False
    edigits = 0
    total = 0
    if text == '@':
        text = ''
    if text:
        if text == '.':
            return Name([''])
        for c in text:
            if escaping:
                if edigits == 0:
                    if c.isdigit():
                        total = int(c)
                        edigits += 1
                    else:
                        label += c
                        escaping = False
                else:
                    if not c.isdigit():
                        raise BadEscape
                    total *= 10
                    total += int(c)
                    edigits += 1
                    if edigits == 3:
                        escaping = False
                        label += chr(total)
            elif c == '.':
                if len(label) == 0:
                    raise EmptyLabel
                labels.append(label)
                label = ''
            elif c == '\\':
                escaping = True
                edigits = 0
                total = 0
            else:
                label += c
        if escaping:
            raise BadEscape
        if len(label) > 0:
            labels.append(label)
        else:
            labels.append('')
    if (len(labels) == 0 or labels[-1] != '') and not origin is None:
        labels.extend(list(origin.labels))
    return Name(labels)

def from_wire(message, current):
    """Convert possibly compressed wire format into a Name.
    @param message: the entire DNS message
    @type message: string
    @param current: the offset of the beginning of the name from the start
    of the message
    @type current: int
    @raises dns.name.BadPointer: a compression pointer did not point backwards
    in the message
    @raises dns.name.BadLabelType: an invalid label type was encountered.
    @returns: a tuple consisting of the name that was read and the number
    of bytes of the wire format message which were consumed reading it
    @rtype: (dns.name.Name object, int) tuple
    """

    if not isinstance(message, str):
        raise ValueError("input to from_wire() must be a byte string")
    message = dns.wiredata.maybe_wrap(message)
    labels = []
    biggest_pointer = current
    hops = 0
    count = ord(message[current])
    current += 1
    cused = 1
    while count != 0:
        if count < 64:
            labels.append(message[current : current + count].unwrap())
            current += count
            if hops == 0:
                cused += count
        elif count >= 192:
            current = (count & 0x3f) * 256 + ord(message[current])
            if hops == 0:
                cused += 1
            if current >= biggest_pointer:
                raise BadPointer
            biggest_pointer = current
            hops += 1
        else:
            raise BadLabelType
        count = ord(message[current])
        current += 1
        if hops == 0:
            cused += 1
    labels.append('')
    return (Name(labels), cused)

########NEW FILE########
__FILENAME__ = namedict
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS name dictionary"""

import dns.name

class NameDict(dict):

    """A dictionary whose keys are dns.name.Name objects.
    @ivar max_depth: the maximum depth of the keys that have ever been
    added to the dictionary.
    @type max_depth: int
    """

    def __init__(self, *args, **kwargs):
        super(NameDict, self).__init__(*args, **kwargs)
        self.max_depth = 0

    def __setitem__(self, key, value):
        if not isinstance(key, dns.name.Name):
            raise ValueError('NameDict key must be a name')
        depth = len(key)
        if depth > self.max_depth:
            self.max_depth = depth
        super(NameDict, self).__setitem__(key, value)

    def get_deepest_match(self, name):
        """Find the deepest match to I{name} in the dictionary.

        The deepest match is the longest name in the dictionary which is
        a superdomain of I{name}.

        @param name: the name
        @type name: dns.name.Name object
        @rtype: (key, value) tuple
        """

        depth = len(name)
        if depth > self.max_depth:
            depth = self.max_depth
        for i in xrange(-depth, 0):
            n = dns.name.Name(name[i:])
            if n in self:
                return (n, self[n])
        v = self[dns.name.empty]
        return (dns.name.empty, v)

########NEW FILE########
__FILENAME__ = node
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS nodes.  A node is a set of rdatasets."""

import StringIO

import dns.rdataset
import dns.rdatatype
import dns.renderer

class Node(object):
    """A DNS node.

    A node is a set of rdatasets

    @ivar rdatasets: the node's rdatasets
    @type rdatasets: list of dns.rdataset.Rdataset objects"""

    __slots__ = ['rdatasets']

    def __init__(self):
        """Initialize a DNS node.
        """

        self.rdatasets = [];

    def to_text(self, name, **kw):
        """Convert a node to text format.

        Each rdataset at the node is printed.  Any keyword arguments
        to this method are passed on to the rdataset's to_text() method.
        @param name: the owner name of the rdatasets
        @type name: dns.name.Name object
        @rtype: string
        """

        s = StringIO.StringIO()
        for rds in self.rdatasets:
            print >> s, rds.to_text(name, **kw)
        return s.getvalue()[:-1]

    def __repr__(self):
        return '<DNS node ' + str(id(self)) + '>'

    def __eq__(self, other):
        """Two nodes are equal if they have the same rdatasets.

        @rtype: bool
        """
        #
        # This is inefficient.  Good thing we don't need to do it much.
        #
        for rd in self.rdatasets:
            if rd not in other.rdatasets:
                return False
        for rd in other.rdatasets:
            if rd not in self.rdatasets:
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __len__(self):
        return len(self.rdatasets)

    def __iter__(self):
        return iter(self.rdatasets)

    def find_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE,
                      create=False):
        """Find an rdataset matching the specified properties in the
        current node.

        @param rdclass: The class of the rdataset
        @type rdclass: int
        @param rdtype: The type of the rdataset
        @type rdtype: int
        @param covers: The covered type.  Usually this value is
        dns.rdatatype.NONE, but if the rdtype is dns.rdatatype.SIG or
        dns.rdatatype.RRSIG, then the covers value will be the rdata
        type the SIG/RRSIG covers.  The library treats the SIG and RRSIG
        types as if they were a family of
        types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).  This makes RRSIGs much
        easier to work with than if RRSIGs covering different rdata
        types were aggregated into a single RRSIG rdataset.
        @type covers: int
        @param create: If True, create the rdataset if it is not found.
        @type create: bool
        @raises KeyError: An rdataset of the desired type and class does
        not exist and I{create} is not True.
        @rtype: dns.rdataset.Rdataset object
        """

        for rds in self.rdatasets:
            if rds.match(rdclass, rdtype, covers):
                return rds
        if not create:
            raise KeyError
        rds = dns.rdataset.Rdataset(rdclass, rdtype)
        self.rdatasets.append(rds)
        return rds

    def get_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE,
                     create=False):
        """Get an rdataset matching the specified properties in the
        current node.

        None is returned if an rdataset of the specified type and
        class does not exist and I{create} is not True.

        @param rdclass: The class of the rdataset
        @type rdclass: int
        @param rdtype: The type of the rdataset
        @type rdtype: int
        @param covers: The covered type.
        @type covers: int
        @param create: If True, create the rdataset if it is not found.
        @type create: bool
        @rtype: dns.rdataset.Rdataset object or None
        """

        try:
            rds = self.find_rdataset(rdclass, rdtype, covers, create)
        except KeyError:
            rds = None
        return rds

    def delete_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE):
        """Delete the rdataset matching the specified properties in the
        current node.

        If a matching rdataset does not exist, it is not an error.

        @param rdclass: The class of the rdataset
        @type rdclass: int
        @param rdtype: The type of the rdataset
        @type rdtype: int
        @param covers: The covered type.
        @type covers: int
        """

        rds = self.get_rdataset(rdclass, rdtype, covers)
        if not rds is None:
            self.rdatasets.remove(rds)

    def replace_rdataset(self, replacement):
        """Replace an rdataset.

        It is not an error if there is no rdataset matching I{replacement}.

        Ownership of the I{replacement} object is transferred to the node;
        in other words, this method does not store a copy of I{replacement}
        at the node, it stores I{replacement} itself.
        """

        self.delete_rdataset(replacement.rdclass, replacement.rdtype,
                             replacement.covers)
        self.rdatasets.append(replacement)

########NEW FILE########
__FILENAME__ = opcode
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Opcodes."""

import dns.exception

QUERY = 0
IQUERY = 1
STATUS = 2
NOTIFY = 4
UPDATE = 5

_by_text = {
    'QUERY' : QUERY,
    'IQUERY' : IQUERY,
    'STATUS' : STATUS,
    'NOTIFY' : NOTIFY,
    'UPDATE' : UPDATE
}

# We construct the inverse mapping programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mapping not to be true inverse.

_by_value = dict([(y, x) for x, y in _by_text.iteritems()])


class UnknownOpcode(dns.exception.DNSException):
    """Raised if an opcode is unknown."""
    pass

def from_text(text):
    """Convert text into an opcode.

    @param text: the textual opcode
    @type text: string
    @raises UnknownOpcode: the opcode is unknown
    @rtype: int
    """

    if text.isdigit():
        value = int(text)
        if value >= 0 and value <= 15:
            return value
    value = _by_text.get(text.upper())
    if value is None:
        raise UnknownOpcode
    return value

def from_flags(flags):
    """Extract an opcode from DNS message flags.

    @param flags: int
    @rtype: int
    """

    return (flags & 0x7800) >> 11

def to_flags(value):
    """Convert an opcode to a value suitable for ORing into DNS message
    flags.
    @rtype: int
    """

    return (value << 11) & 0x7800

def to_text(value):
    """Convert an opcode to text.

    @param value: the opcdoe
    @type value: int
    @raises UnknownOpcode: the opcode is unknown
    @rtype: string
    """

    text = _by_value.get(value)
    if text is None:
        text = str(value)
    return text

def is_update(flags):
    """True if the opcode in flags is UPDATE.

    @param flags: DNS flags
    @type flags: int
    @rtype: bool
    """

    if (from_flags(flags) == UPDATE):
        return True
    return False

########NEW FILE########
__FILENAME__ = query
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Talk to a DNS server."""

from __future__ import generators

import errno
import select
import socket
import struct
import sys
import time

import dns.exception
import dns.inet
import dns.name
import dns.message
import dns.rdataclass
import dns.rdatatype

class UnexpectedSource(dns.exception.DNSException):
    """Raised if a query response comes from an unexpected address or port."""
    pass

class BadResponse(dns.exception.FormError):
    """Raised if a query response does not respond to the question asked."""
    pass

def _compute_expiration(timeout):
    if timeout is None:
        return None
    else:
        return time.time() + timeout

def _poll_for(fd, readable, writable, error, timeout):
    """
    @param fd: File descriptor (int).
    @param readable: Whether to wait for readability (bool).
    @param writable: Whether to wait for writability (bool).
    @param expiration: Deadline timeout (expiration time, in seconds (float)).

    @return True on success, False on timeout
    """
    event_mask = 0
    if readable:
        event_mask |= select.POLLIN
    if writable:
        event_mask |= select.POLLOUT
    if error:
        event_mask |= select.POLLERR

    pollable = select.poll()
    pollable.register(fd, event_mask)

    if timeout:
        event_list = pollable.poll(long(timeout * 1000))
    else:
        event_list = pollable.poll()

    return bool(event_list)

def _select_for(fd, readable, writable, error, timeout):
    """
    @param fd: File descriptor (int).
    @param readable: Whether to wait for readability (bool).
    @param writable: Whether to wait for writability (bool).
    @param expiration: Deadline timeout (expiration time, in seconds (float)).

    @return True on success, False on timeout
    """
    rset, wset, xset = [], [], []

    if readable:
        rset = [fd]
    if writable:
        wset = [fd]
    if error:
        xset = [fd]

    if timeout is None:
        (rcount, wcount, xcount) = select.select(rset, wset, xset)
    else:
        (rcount, wcount, xcount) = select.select(rset, wset, xset, timeout)

    return bool((rcount or wcount or xcount))

def _wait_for(fd, readable, writable, error, expiration):
    done = False
    while not done:
        if expiration is None:
            timeout = None
        else:
            timeout = expiration - time.time()
            if timeout <= 0.0:
                raise dns.exception.Timeout
        try:
            if not _polling_backend(fd, readable, writable, error, timeout):
                raise dns.exception.Timeout
        except select.error, e:
            if e.args[0] != errno.EINTR:
                raise e
        done = True

def _set_polling_backend(fn):
    """
    Internal API. Do not use.
    """
    global _polling_backend

    _polling_backend = fn

if hasattr(select, 'poll'):
    # Prefer poll() on platforms that support it because it has no
    # limits on the maximum value of a file descriptor (plus it will
    # be more efficient for high values).
    _polling_backend = _poll_for
else:
    _polling_backend = _select_for

def _wait_for_readable(s, expiration):
    _wait_for(s, True, False, True, expiration)

def _wait_for_writable(s, expiration):
    _wait_for(s, False, True, True, expiration)

def _addresses_equal(af, a1, a2):
    # Convert the first value of the tuple, which is a textual format
    # address into binary form, so that we are not confused by different
    # textual representations of the same address
    n1 = dns.inet.inet_pton(af, a1[0])
    n2 = dns.inet.inet_pton(af, a2[0])
    return n1 == n2 and a1[1:] == a2[1:]

def udp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,
        ignore_unexpected=False, one_rr_per_rrset=False):
    """Return the response obtained after sending a query via UDP.

    @param q: the query
    @type q: dns.message.Message
    @param where: where to send the message
    @type where: string containing an IPv4 or IPv6 address
    @param timeout: The number of seconds to wait before the query times out.
    If None, the default, wait forever.
    @type timeout: float
    @param port: The port to which to send the message.  The default is 53.
    @type port: int
    @param af: the address family to use.  The default is None, which
    causes the address family to use to be inferred from the form of of where.
    If the inference attempt fails, AF_INET is used.
    @type af: int
    @rtype: dns.message.Message object
    @param source: source address.  The default is the IPv4 wildcard address.
    @type source: string
    @param source_port: The port from which to send the message.
    The default is 0.
    @type source_port: int
    @param ignore_unexpected: If True, ignore responses from unexpected
    sources.  The default is False.
    @type ignore_unexpected: bool
    @param one_rr_per_rrset: Put each RR into its own RRset
    @type one_rr_per_rrset: bool
    """

    wire = q.to_wire()
    if af is None:
        try:
            af = dns.inet.af_for_address(where)
        except StandardError:
            af = dns.inet.AF_INET
    if af == dns.inet.AF_INET:
        destination = (where, port)
        if source is not None:
            source = (source, source_port)
    elif af == dns.inet.AF_INET6:
        destination = (where, port, 0, 0)
        if source is not None:
            source = (source, source_port, 0, 0)
    s = socket.socket(af, socket.SOCK_DGRAM, 0)
    try:
        expiration = _compute_expiration(timeout)
        s.setblocking(0)
        if source is not None:
            s.bind(source)
        _wait_for_writable(s, expiration)
        s.sendto(wire, destination)
        while 1:
            _wait_for_readable(s, expiration)
            (wire, from_address) = s.recvfrom(65535)
            if _addresses_equal(af, from_address, destination) or \
                    (dns.inet.is_multicast(where) and \
                         from_address[1:] == destination[1:]):
                break
            if not ignore_unexpected:
                raise UnexpectedSource('got a response from '
                                       '%s instead of %s' % (from_address,
                                                             destination))
    finally:
        s.close()
    r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,
                              one_rr_per_rrset=one_rr_per_rrset)
    if not q.is_response(r):
        raise BadResponse
    return r

def _net_read(sock, count, expiration):
    """Read the specified number of bytes from sock.  Keep trying until we
    either get the desired amount, or we hit EOF.
    A Timeout exception will be raised if the operation is not completed
    by the expiration time.
    """
    s = ''
    while count > 0:
        _wait_for_readable(sock, expiration)
        n = sock.recv(count)
        if n == '':
            raise EOFError
        count = count - len(n)
        s = s + n
    return s

def _net_write(sock, data, expiration):
    """Write the specified data to the socket.
    A Timeout exception will be raised if the operation is not completed
    by the expiration time.
    """
    current = 0
    l = len(data)
    while current < l:
        _wait_for_writable(sock, expiration)
        current += sock.send(data[current:])

def _connect(s, address):
    try:
        s.connect(address)
    except socket.error:
        (ty, v) = sys.exc_info()[:2]
        if v[0] != errno.EINPROGRESS and \
               v[0] != errno.EWOULDBLOCK and \
               v[0] != errno.EALREADY:
            raise v

def tcp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,
        one_rr_per_rrset=False):
    """Return the response obtained after sending a query via TCP.

    @param q: the query
    @type q: dns.message.Message object
    @param where: where to send the message
    @type where: string containing an IPv4 or IPv6 address
    @param timeout: The number of seconds to wait before the query times out.
    If None, the default, wait forever.
    @type timeout: float
    @param port: The port to which to send the message.  The default is 53.
    @type port: int
    @param af: the address family to use.  The default is None, which
    causes the address family to use to be inferred from the form of of where.
    If the inference attempt fails, AF_INET is used.
    @type af: int
    @rtype: dns.message.Message object
    @param source: source address.  The default is the IPv4 wildcard address.
    @type source: string
    @param source_port: The port from which to send the message.
    The default is 0.
    @type source_port: int
    @param one_rr_per_rrset: Put each RR into its own RRset
    @type one_rr_per_rrset: bool
    """

    wire = q.to_wire()
    if af is None:
        try:
            af = dns.inet.af_for_address(where)
        except StandardError:
            af = dns.inet.AF_INET
    if af == dns.inet.AF_INET:
        destination = (where, port)
        if source is not None:
            source = (source, source_port)
    elif af == dns.inet.AF_INET6:
        destination = (where, port, 0, 0)
        if source is not None:
            source = (source, source_port, 0, 0)
    s = socket.socket(af, socket.SOCK_STREAM, 0)
    try:
        expiration = _compute_expiration(timeout)
        s.setblocking(0)
        if source is not None:
            s.bind(source)
        _connect(s, destination)

        l = len(wire)

        # copying the wire into tcpmsg is inefficient, but lets us
        # avoid writev() or doing a short write that would get pushed
        # onto the net
        tcpmsg = struct.pack("!H", l) + wire
        _net_write(s, tcpmsg, expiration)
        ldata = _net_read(s, 2, expiration)
        (l,) = struct.unpack("!H", ldata)
        wire = _net_read(s, l, expiration)
    finally:
        s.close()
    r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,
                              one_rr_per_rrset=one_rr_per_rrset)
    if not q.is_response(r):
        raise BadResponse
    return r

def xfr(where, zone, rdtype=dns.rdatatype.AXFR, rdclass=dns.rdataclass.IN,
        timeout=None, port=53, keyring=None, keyname=None, relativize=True,
        af=None, lifetime=None, source=None, source_port=0, serial=0,
        use_udp=False, keyalgorithm=dns.tsig.default_algorithm):
    """Return a generator for the responses to a zone transfer.

    @param where: where to send the message
    @type where: string containing an IPv4 or IPv6 address
    @param zone: The name of the zone to transfer
    @type zone: dns.name.Name object or string
    @param rdtype: The type of zone transfer.  The default is
    dns.rdatatype.AXFR.
    @type rdtype: int or string
    @param rdclass: The class of the zone transfer.  The default is
    dns.rdatatype.IN.
    @type rdclass: int or string
    @param timeout: The number of seconds to wait for each response message.
    If None, the default, wait forever.
    @type timeout: float
    @param port: The port to which to send the message.  The default is 53.
    @type port: int
    @param keyring: The TSIG keyring to use
    @type keyring: dict
    @param keyname: The name of the TSIG key to use
    @type keyname: dns.name.Name object or string
    @param relativize: If True, all names in the zone will be relativized to
    the zone origin.  It is essential that the relativize setting matches
    the one specified to dns.zone.from_xfr().
    @type relativize: bool
    @param af: the address family to use.  The default is None, which
    causes the address family to use to be inferred from the form of of where.
    If the inference attempt fails, AF_INET is used.
    @type af: int
    @param lifetime: The total number of seconds to spend doing the transfer.
    If None, the default, then there is no limit on the time the transfer may
    take.
    @type lifetime: float
    @rtype: generator of dns.message.Message objects.
    @param source: source address.  The default is the IPv4 wildcard address.
    @type source: string
    @param source_port: The port from which to send the message.
    The default is 0.
    @type source_port: int
    @param serial: The SOA serial number to use as the base for an IXFR diff
    sequence (only meaningful if rdtype == dns.rdatatype.IXFR).
    @type serial: int
    @param use_udp: Use UDP (only meaningful for IXFR)
    @type use_udp: bool
    @param keyalgorithm: The TSIG algorithm to use; defaults to
    dns.tsig.default_algorithm
    @type keyalgorithm: string
    """

    if isinstance(zone, (str, unicode)):
        zone = dns.name.from_text(zone)
    if isinstance(rdtype, (str, unicode)):
        rdtype = dns.rdatatype.from_text(rdtype)
    q = dns.message.make_query(zone, rdtype, rdclass)
    if rdtype == dns.rdatatype.IXFR:
        rrset = dns.rrset.from_text(zone, 0, 'IN', 'SOA',
                                    '. . %u 0 0 0 0' % serial)
        q.authority.append(rrset)
    if not keyring is None:
        q.use_tsig(keyring, keyname, algorithm=keyalgorithm)
    wire = q.to_wire()
    if af is None:
        try:
            af = dns.inet.af_for_address(where)
        except StandardError:
            af = dns.inet.AF_INET
    if af == dns.inet.AF_INET:
        destination = (where, port)
        if source is not None:
            source = (source, source_port)
    elif af == dns.inet.AF_INET6:
        destination = (where, port, 0, 0)
        if source is not None:
            source = (source, source_port, 0, 0)
    if use_udp:
        if rdtype != dns.rdatatype.IXFR:
            raise ValueError('cannot do a UDP AXFR')
        s = socket.socket(af, socket.SOCK_DGRAM, 0)
    else:
        s = socket.socket(af, socket.SOCK_STREAM, 0)
    s.setblocking(0)
    if source is not None:
        s.bind(source)
    expiration = _compute_expiration(lifetime)
    _connect(s, destination)
    l = len(wire)
    if use_udp:
        _wait_for_writable(s, expiration)
        s.send(wire)
    else:
        tcpmsg = struct.pack("!H", l) + wire
        _net_write(s, tcpmsg, expiration)
    done = False
    soa_rrset = None
    soa_count = 0
    if relativize:
        origin = zone
        oname = dns.name.empty
    else:
        origin = None
        oname = zone
    tsig_ctx = None
    first = True
    while not done:
        mexpiration = _compute_expiration(timeout)
        if mexpiration is None or mexpiration > expiration:
            mexpiration = expiration
        if use_udp:
            _wait_for_readable(s, expiration)
            (wire, from_address) = s.recvfrom(65535)
        else:
            ldata = _net_read(s, 2, mexpiration)
            (l,) = struct.unpack("!H", ldata)
            wire = _net_read(s, l, mexpiration)
        r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,
                                  xfr=True, origin=origin, tsig_ctx=tsig_ctx,
                                  multi=True, first=first,
                                  one_rr_per_rrset=(rdtype==dns.rdatatype.IXFR))
        tsig_ctx = r.tsig_ctx
        first = False
        answer_index = 0
        delete_mode = False
        expecting_SOA = False
        if soa_rrset is None:
            if not r.answer or r.answer[0].name != oname:
                raise dns.exception.FormError
            rrset = r.answer[0]
            if rrset.rdtype != dns.rdatatype.SOA:
                raise dns.exception.FormError("first RRset is not an SOA")
            answer_index = 1
            soa_rrset = rrset.copy()
            if rdtype == dns.rdatatype.IXFR:
                if soa_rrset[0].serial == serial:
                    #
                    # We're already up-to-date.
                    #
                    done = True
                else:
                    expecting_SOA = True
        #
        # Process SOAs in the answer section (other than the initial
        # SOA in the first message).
        #
        for rrset in r.answer[answer_index:]:
            if done:
                raise dns.exception.FormError("answers after final SOA")
            if rrset.rdtype == dns.rdatatype.SOA and rrset.name == oname:
                if expecting_SOA:
                    if rrset[0].serial != serial:
                        raise dns.exception.FormError("IXFR base serial mismatch")
                    expecting_SOA = False
                elif rdtype == dns.rdatatype.IXFR:
                    delete_mode = not delete_mode
                if rrset == soa_rrset and not delete_mode:
                    done = True
            elif expecting_SOA:
                #
                # We made an IXFR request and are expecting another
                # SOA RR, but saw something else, so this must be an
                # AXFR response.
                #
                rdtype = dns.rdatatype.AXFR
                expecting_SOA = False
        if done and q.keyring and not r.had_tsig:
            raise dns.exception.FormError("missing TSIG")
        yield r
    s.close()

########NEW FILE########
__FILENAME__ = rcode
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Result Codes."""

import dns.exception

NOERROR = 0
FORMERR = 1
SERVFAIL = 2
NXDOMAIN = 3
NOTIMP = 4
REFUSED = 5
YXDOMAIN = 6
YXRRSET = 7
NXRRSET = 8
NOTAUTH = 9
NOTZONE = 10
BADVERS = 16

_by_text = {
    'NOERROR' : NOERROR,
    'FORMERR' : FORMERR,
    'SERVFAIL' : SERVFAIL,
    'NXDOMAIN' : NXDOMAIN,
    'NOTIMP' : NOTIMP,
    'REFUSED' : REFUSED,
    'YXDOMAIN' : YXDOMAIN,
    'YXRRSET' : YXRRSET,
    'NXRRSET' : NXRRSET,
    'NOTAUTH' : NOTAUTH,
    'NOTZONE' : NOTZONE,
    'BADVERS' : BADVERS
}

# We construct the inverse mapping programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mapping not to be a true inverse.

_by_value = dict([(y, x) for x, y in _by_text.iteritems()])


class UnknownRcode(dns.exception.DNSException):
    """Raised if an rcode is unknown."""
    pass

def from_text(text):
    """Convert text into an rcode.

    @param text: the texual rcode
    @type text: string
    @raises UnknownRcode: the rcode is unknown
    @rtype: int
    """

    if text.isdigit():
        v = int(text)
        if v >= 0 and v <= 4095:
            return v
    v = _by_text.get(text.upper())
    if v is None:
        raise UnknownRcode
    return v

def from_flags(flags, ednsflags):
    """Return the rcode value encoded by flags and ednsflags.

    @param flags: the DNS flags
    @type flags: int
    @param ednsflags: the EDNS flags
    @type ednsflags: int
    @raises ValueError: rcode is < 0 or > 4095
    @rtype: int
    """

    value = (flags & 0x000f) | ((ednsflags >> 20) & 0xff0)
    if value < 0 or value > 4095:
        raise ValueError('rcode must be >= 0 and <= 4095')
    return value

def to_flags(value):
    """Return a (flags, ednsflags) tuple which encodes the rcode.

    @param value: the rcode
    @type value: int
    @raises ValueError: rcode is < 0 or > 4095
    @rtype: (int, int) tuple
    """

    if value < 0 or value > 4095:
        raise ValueError('rcode must be >= 0 and <= 4095')
    v = value & 0xf
    ev = long(value & 0xff0) << 20
    return (v, ev)

def to_text(value):
    """Convert rcode into text.

    @param value: the rcode
    @type value: int
    @rtype: string
    """

    text = _by_value.get(value)
    if text is None:
        text = str(value)
    return text

########NEW FILE########
__FILENAME__ = rdata
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS rdata.

@var _rdata_modules: A dictionary mapping a (rdclass, rdtype) tuple to
the module which implements that type.
@type _rdata_modules: dict
@var _module_prefix: The prefix to use when forming modules names.  The
default is 'dns.rdtypes'.  Changing this value will break the library.
@type _module_prefix: string
@var _hex_chunk: At most this many octets that will be represented in each
chunk of hexstring that _hexify() produces before whitespace occurs.
@type _hex_chunk: int"""

import cStringIO

import dns.exception
import dns.name
import dns.rdataclass
import dns.rdatatype
import dns.tokenizer
import dns.wiredata

_hex_chunksize = 32

def _hexify(data, chunksize=None):
    """Convert a binary string into its hex encoding, broken up into chunks
    of I{chunksize} characters separated by a space.

    @param data: the binary string
    @type data: string
    @param chunksize: the chunk size.  Default is L{dns.rdata._hex_chunksize}
    @rtype: string
    """

    if chunksize is None:
        chunksize = _hex_chunksize
    hex = data.encode('hex_codec')
    l = len(hex)
    if l > chunksize:
        chunks = []
        i = 0
        while i < l:
            chunks.append(hex[i : i + chunksize])
            i += chunksize
        hex = ' '.join(chunks)
    return hex

_base64_chunksize = 32

def _base64ify(data, chunksize=None):
    """Convert a binary string into its base64 encoding, broken up into chunks
    of I{chunksize} characters separated by a space.

    @param data: the binary string
    @type data: string
    @param chunksize: the chunk size.  Default is
    L{dns.rdata._base64_chunksize}
    @rtype: string
    """

    if chunksize is None:
        chunksize = _base64_chunksize
    b64 = data.encode('base64_codec')
    b64 = b64.replace('\n', '')
    l = len(b64)
    if l > chunksize:
        chunks = []
        i = 0
        while i < l:
            chunks.append(b64[i : i + chunksize])
            i += chunksize
        b64 = ' '.join(chunks)
    return b64

__escaped = {
    '"' : True,
    '\\' : True,
    }

def _escapify(qstring):
    """Escape the characters in a quoted string which need it.

    @param qstring: the string
    @type qstring: string
    @returns: the escaped string
    @rtype: string
    """

    text = ''
    for c in qstring:
        if c in __escaped:
            text += '\\' + c
        elif ord(c) >= 0x20 and ord(c) < 0x7F:
            text += c
        else:
            text += '\\%03d' % ord(c)
    return text

def _truncate_bitmap(what):
    """Determine the index of greatest byte that isn't all zeros, and
    return the bitmap that contains all the bytes less than that index.

    @param what: a string of octets representing a bitmap.
    @type what: string
    @rtype: string
    """

    for i in xrange(len(what) - 1, -1, -1):
        if what[i] != '\x00':
            break
    return ''.join(what[0 : i + 1])

class Rdata(object):
    """Base class for all DNS rdata types.
    """

    __slots__ = ['rdclass', 'rdtype']

    def __init__(self, rdclass, rdtype):
        """Initialize an rdata.
        @param rdclass: The rdata class
        @type rdclass: int
        @param rdtype: The rdata type
        @type rdtype: int
        """

        self.rdclass = rdclass
        self.rdtype = rdtype

    def covers(self):
        """DNS SIG/RRSIG rdatas apply to a specific type; this type is
        returned by the covers() function.  If the rdata type is not
        SIG or RRSIG, dns.rdatatype.NONE is returned.  This is useful when
        creating rdatasets, allowing the rdataset to contain only RRSIGs
        of a particular type, e.g. RRSIG(NS).
        @rtype: int
        """

        return dns.rdatatype.NONE

    def extended_rdatatype(self):
        """Return a 32-bit type value, the least significant 16 bits of
        which are the ordinary DNS type, and the upper 16 bits of which are
        the "covered" type, if any.
        @rtype: int
        """

        return self.covers() << 16 | self.rdtype

    def to_text(self, origin=None, relativize=True, **kw):
        """Convert an rdata to text format.
        @rtype: string
        """
        raise NotImplementedError

    def to_wire(self, file, compress = None, origin = None):
        """Convert an rdata to wire format.
        @rtype: string
        """

        raise NotImplementedError

    def to_digestable(self, origin = None):
        """Convert rdata to a format suitable for digesting in hashes.  This
        is also the DNSSEC canonical form."""
        f = cStringIO.StringIO()
        self.to_wire(f, None, origin)
        return f.getvalue()

    def validate(self):
        """Check that the current contents of the rdata's fields are
        valid.  If you change an rdata by assigning to its fields,
        it is a good idea to call validate() when you are done making
        changes.
        """
        dns.rdata.from_text(self.rdclass, self.rdtype, self.to_text())

    def __repr__(self):
        covers = self.covers()
        if covers == dns.rdatatype.NONE:
            ctext = ''
        else:
            ctext = '(' + dns.rdatatype.to_text(covers) + ')'
        return '<DNS ' + dns.rdataclass.to_text(self.rdclass) + ' ' + \
               dns.rdatatype.to_text(self.rdtype) + ctext + ' rdata: ' + \
               str(self) + '>'

    def __str__(self):
        return self.to_text()

    def _cmp(self, other):
        """Compare an rdata with another rdata of the same rdtype and
        rdclass.  Return < 0 if self < other in the DNSSEC ordering,
        0 if self == other, and > 0 if self > other.
        """

        raise NotImplementedError

    def __eq__(self, other):
        if not isinstance(other, Rdata):
            return False
        if self.rdclass != other.rdclass or \
           self.rdtype != other.rdtype:
            return False
        return self._cmp(other) == 0

    def __ne__(self, other):
        if not isinstance(other, Rdata):
            return True
        if self.rdclass != other.rdclass or \
           self.rdtype != other.rdtype:
            return True
        return self._cmp(other) != 0

    def __lt__(self, other):
        if not isinstance(other, Rdata) or \
               self.rdclass != other.rdclass or \
               self.rdtype != other.rdtype:
            return NotImplemented
        return self._cmp(other) < 0

    def __le__(self, other):
        if not isinstance(other, Rdata) or \
               self.rdclass != other.rdclass or \
               self.rdtype != other.rdtype:
            return NotImplemented
        return self._cmp(other) <= 0

    def __ge__(self, other):
        if not isinstance(other, Rdata) or \
               self.rdclass != other.rdclass or \
               self.rdtype != other.rdtype:
            return NotImplemented
        return self._cmp(other) >= 0

    def __gt__(self, other):
        if not isinstance(other, Rdata) or \
               self.rdclass != other.rdclass or \
               self.rdtype != other.rdtype:
            return NotImplemented
        return self._cmp(other) > 0

    def __hash__(self):
        return hash(self.to_digestable(dns.name.root))

    def _wire_cmp(self, other):
        # A number of types compare rdata in wire form, so we provide
        # the method here instead of duplicating it.
        #
        # We specifiy an arbitrary origin of '.' when doing the
        # comparison, since the rdata may have relative names and we
        # can't convert a relative name to wire without an origin.
        b1 = cStringIO.StringIO()
        self.to_wire(b1, None, dns.name.root)
        b2 = cStringIO.StringIO()
        other.to_wire(b2, None, dns.name.root)
        return cmp(b1.getvalue(), b2.getvalue())

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        """Build an rdata object from text format.

        @param rdclass: The rdata class
        @type rdclass: int
        @param rdtype: The rdata type
        @type rdtype: int
        @param tok: The tokenizer
        @type tok: dns.tokenizer.Tokenizer
        @param origin: The origin to use for relative names
        @type origin: dns.name.Name
        @param relativize: should names be relativized?
        @type relativize: bool
        @rtype: dns.rdata.Rdata instance
        """

        raise NotImplementedError

    from_text = classmethod(from_text)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        """Build an rdata object from wire format

        @param rdclass: The rdata class
        @type rdclass: int
        @param rdtype: The rdata type
        @type rdtype: int
        @param wire: The wire-format message
        @type wire: string
        @param current: The offet in wire of the beginning of the rdata.
        @type current: int
        @param rdlen: The length of the wire-format rdata
        @type rdlen: int
        @param origin: The origin to use for relative names
        @type origin: dns.name.Name
        @rtype: dns.rdata.Rdata instance
        """

        raise NotImplementedError

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        """Convert any domain names in the rdata to the specified
        relativization.
        """

        pass


class GenericRdata(Rdata):
    """Generate Rdata Class

    This class is used for rdata types for which we have no better
    implementation.  It implements the DNS "unknown RRs" scheme.
    """

    __slots__ = ['data']

    def __init__(self, rdclass, rdtype, data):
        super(GenericRdata, self).__init__(rdclass, rdtype)
        self.data = data

    def to_text(self, origin=None, relativize=True, **kw):
        return r'\# %d ' % len(self.data) + _hexify(self.data)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        token = tok.get()
        if not token.is_identifier() or token.value != '\#':
            raise dns.exception.SyntaxError(r'generic rdata does not start with \#')
        length = tok.get_int()
        chunks = []
        while 1:
            token = tok.get()
            if token.is_eol_or_eof():
                break
            chunks.append(token.value)
        hex = ''.join(chunks)
        data = hex.decode('hex_codec')
        if len(data) != length:
            raise dns.exception.SyntaxError('generic rdata hex data has wrong length')
        return cls(rdclass, rdtype, data)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(self.data)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        return cls(rdclass, rdtype, wire[current : current + rdlen])

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.data, other.data)

_rdata_modules = {}
_module_prefix = 'dns.rdtypes'

def get_rdata_class(rdclass, rdtype):

    def import_module(name):
        mod = __import__(name)
        components = name.split('.')
        for comp in components[1:]:
            mod = getattr(mod, comp)
        return mod

    mod = _rdata_modules.get((rdclass, rdtype))
    rdclass_text = dns.rdataclass.to_text(rdclass)
    rdtype_text = dns.rdatatype.to_text(rdtype)
    rdtype_text = rdtype_text.replace('-', '_')
    if not mod:
        mod = _rdata_modules.get((dns.rdatatype.ANY, rdtype))
        if not mod:
            try:
                mod = import_module('.'.join([_module_prefix,
                                              rdclass_text, rdtype_text]))
                _rdata_modules[(rdclass, rdtype)] = mod
            except ImportError:
                try:
                    mod = import_module('.'.join([_module_prefix,
                                                  'ANY', rdtype_text]))
                    _rdata_modules[(dns.rdataclass.ANY, rdtype)] = mod
                except ImportError:
                    mod = None
    if mod:
        cls = getattr(mod, rdtype_text)
    else:
        cls = GenericRdata
    return cls

def from_text(rdclass, rdtype, tok, origin = None, relativize = True):
    """Build an rdata object from text format.

    This function attempts to dynamically load a class which
    implements the specified rdata class and type.  If there is no
    class-and-type-specific implementation, the GenericRdata class
    is used.

    Once a class is chosen, its from_text() class method is called
    with the parameters to this function.

    @param rdclass: The rdata class
    @type rdclass: int
    @param rdtype: The rdata type
    @type rdtype: int
    @param tok: The tokenizer
    @type tok: dns.tokenizer.Tokenizer
    @param origin: The origin to use for relative names
    @type origin: dns.name.Name
    @param relativize: Should names be relativized?
    @type relativize: bool
    @rtype: dns.rdata.Rdata instance"""

    if isinstance(tok, str):
        tok = dns.tokenizer.Tokenizer(tok)
    cls = get_rdata_class(rdclass, rdtype)
    if cls != GenericRdata:
        # peek at first token
        token = tok.get()
        tok.unget(token)
        if token.is_identifier() and \
           token.value == r'\#':
            #
            # Known type using the generic syntax.  Extract the
            # wire form from the generic syntax, and then run
            # from_wire on it.
            #
            rdata = GenericRdata.from_text(rdclass, rdtype, tok, origin,
                                           relativize)
            return from_wire(rdclass, rdtype, rdata.data, 0, len(rdata.data),
                             origin)
    return cls.from_text(rdclass, rdtype, tok, origin, relativize)

def from_wire(rdclass, rdtype, wire, current, rdlen, origin = None):
    """Build an rdata object from wire format

    This function attempts to dynamically load a class which
    implements the specified rdata class and type.  If there is no
    class-and-type-specific implementation, the GenericRdata class
    is used.

    Once a class is chosen, its from_wire() class method is called
    with the parameters to this function.

    @param rdclass: The rdata class
    @type rdclass: int
    @param rdtype: The rdata type
    @type rdtype: int
    @param wire: The wire-format message
    @type wire: string
    @param current: The offet in wire of the beginning of the rdata.
    @type current: int
    @param rdlen: The length of the wire-format rdata
    @type rdlen: int
    @param origin: The origin to use for relative names
    @type origin: dns.name.Name
    @rtype: dns.rdata.Rdata instance"""

    wire = dns.wiredata.maybe_wrap(wire)
    cls = get_rdata_class(rdclass, rdtype)
    return cls.from_wire(rdclass, rdtype, wire, current, rdlen, origin)

########NEW FILE########
__FILENAME__ = rdataclass
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Rdata Classes.

@var _by_text: The rdata class textual name to value mapping
@type _by_text: dict
@var _by_value: The rdata class value to textual name mapping
@type _by_value: dict
@var _metaclasses: If an rdataclass is a metaclass, there will be a mapping
whose key is the rdatatype value and whose value is True in this dictionary.
@type _metaclasses: dict"""

import re

import dns.exception

RESERVED0 = 0
IN = 1
CH = 3
HS = 4
NONE = 254
ANY = 255

_by_text = {
    'RESERVED0' : RESERVED0,
    'IN' : IN,
    'CH' : CH,
    'HS' : HS,
    'NONE' : NONE,
    'ANY' : ANY
    }

# We construct the inverse mapping programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mapping not to be true inverse.

_by_value = dict([(y, x) for x, y in _by_text.iteritems()])

# Now that we've built the inverse map, we can add class aliases to
# the _by_text mapping.

_by_text.update({
    'INTERNET' : IN,
    'CHAOS' : CH,
    'HESIOD' : HS
    })

_metaclasses = {
    NONE : True,
    ANY : True
    }

_unknown_class_pattern = re.compile('CLASS([0-9]+)$', re.I);

class UnknownRdataclass(dns.exception.DNSException):
    """Raised when a class is unknown."""
    pass

def from_text(text):
    """Convert text into a DNS rdata class value.
    @param text: the text
    @type text: string
    @rtype: int
    @raises dns.rdataclass.UnknownRdataClass: the class is unknown
    @raises ValueError: the rdata class value is not >= 0 and <= 65535
    """

    value = _by_text.get(text.upper())
    if value is None:
        match = _unknown_class_pattern.match(text)
        if match == None:
            raise UnknownRdataclass
        value = int(match.group(1))
        if value < 0 or value > 65535:
            raise ValueError("class must be between >= 0 and <= 65535")
    return value

def to_text(value):
    """Convert a DNS rdata class to text.
    @param value: the rdata class value
    @type value: int
    @rtype: string
    @raises ValueError: the rdata class value is not >= 0 and <= 65535
    """

    if value < 0 or value > 65535:
        raise ValueError("class must be between >= 0 and <= 65535")
    text = _by_value.get(value)
    if text is None:
        text = 'CLASS' + `value`
    return text

def is_metaclass(rdclass):
    """True if the class is a metaclass.
    @param rdclass: the rdata class
    @type rdclass: int
    @rtype: bool"""

    if rdclass in _metaclasses:
        return True
    return False

########NEW FILE########
__FILENAME__ = rdataset
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS rdatasets (an rdataset is a set of rdatas of a given type and class)"""

import random
import StringIO
import struct

import dns.exception
import dns.rdatatype
import dns.rdataclass
import dns.rdata
import dns.set

# define SimpleSet here for backwards compatibility
SimpleSet = dns.set.Set

class DifferingCovers(dns.exception.DNSException):
    """Raised if an attempt is made to add a SIG/RRSIG whose covered type
    is not the same as that of the other rdatas in the rdataset."""
    pass

class IncompatibleTypes(dns.exception.DNSException):
    """Raised if an attempt is made to add rdata of an incompatible type."""
    pass

class Rdataset(dns.set.Set):
    """A DNS rdataset.

    @ivar rdclass: The class of the rdataset
    @type rdclass: int
    @ivar rdtype: The type of the rdataset
    @type rdtype: int
    @ivar covers: The covered type.  Usually this value is
    dns.rdatatype.NONE, but if the rdtype is dns.rdatatype.SIG or
    dns.rdatatype.RRSIG, then the covers value will be the rdata
    type the SIG/RRSIG covers.  The library treats the SIG and RRSIG
    types as if they were a family of
    types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).  This makes RRSIGs much
    easier to work with than if RRSIGs covering different rdata
    types were aggregated into a single RRSIG rdataset.
    @type covers: int
    @ivar ttl: The DNS TTL (Time To Live) value
    @type ttl: int
    """

    __slots__ = ['rdclass', 'rdtype', 'covers', 'ttl']

    def __init__(self, rdclass, rdtype, covers=dns.rdatatype.NONE):
        """Create a new rdataset of the specified class and type.

        @see: the description of the class instance variables for the
        meaning of I{rdclass} and I{rdtype}"""

        super(Rdataset, self).__init__()
        self.rdclass = rdclass
        self.rdtype = rdtype
        self.covers = covers
        self.ttl = 0

    def _clone(self):
        obj = super(Rdataset, self)._clone()
        obj.rdclass = self.rdclass
        obj.rdtype = self.rdtype
        obj.covers = self.covers
        obj.ttl = self.ttl
        return obj

    def update_ttl(self, ttl):
        """Set the TTL of the rdataset to be the lesser of the set's current
        TTL or the specified TTL.  If the set contains no rdatas, set the TTL
        to the specified TTL.
        @param ttl: The TTL
        @type ttl: int"""

        if len(self) == 0:
            self.ttl = ttl
        elif ttl < self.ttl:
            self.ttl = ttl

    def add(self, rd, ttl=None):
        """Add the specified rdata to the rdataset.

        If the optional I{ttl} parameter is supplied, then
        self.update_ttl(ttl) will be called prior to adding the rdata.

        @param rd: The rdata
        @type rd: dns.rdata.Rdata object
        @param ttl: The TTL
        @type ttl: int"""

        #
        # If we're adding a signature, do some special handling to
        # check that the signature covers the same type as the
        # other rdatas in this rdataset.  If this is the first rdata
        # in the set, initialize the covers field.
        #
        if self.rdclass != rd.rdclass or self.rdtype != rd.rdtype:
            raise IncompatibleTypes
        if not ttl is None:
            self.update_ttl(ttl)
        if self.rdtype == dns.rdatatype.RRSIG or \
           self.rdtype == dns.rdatatype.SIG:
            covers = rd.covers()
            if len(self) == 0 and self.covers == dns.rdatatype.NONE:
                self.covers = covers
            elif self.covers != covers:
                raise DifferingCovers
        if dns.rdatatype.is_singleton(rd.rdtype) and len(self) > 0:
            self.clear()
        super(Rdataset, self).add(rd)

    def union_update(self, other):
        self.update_ttl(other.ttl)
        super(Rdataset, self).union_update(other)

    def intersection_update(self, other):
        self.update_ttl(other.ttl)
        super(Rdataset, self).intersection_update(other)

    def update(self, other):
        """Add all rdatas in other to self.

        @param other: The rdataset from which to update
        @type other: dns.rdataset.Rdataset object"""

        self.update_ttl(other.ttl)
        super(Rdataset, self).update(other)

    def __repr__(self):
        if self.covers == 0:
            ctext = ''
        else:
            ctext = '(' + dns.rdatatype.to_text(self.covers) + ')'
        return '<DNS ' + dns.rdataclass.to_text(self.rdclass) + ' ' + \
               dns.rdatatype.to_text(self.rdtype) + ctext + ' rdataset>'

    def __str__(self):
        return self.to_text()

    def __eq__(self, other):
        """Two rdatasets are equal if they have the same class, type, and
        covers, and contain the same rdata.
        @rtype: bool"""

        if not isinstance(other, Rdataset):
            return False
        if self.rdclass != other.rdclass or \
           self.rdtype != other.rdtype or \
           self.covers != other.covers:
            return False
        return super(Rdataset, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def to_text(self, name=None, origin=None, relativize=True,
                override_rdclass=None, **kw):
        """Convert the rdataset into DNS master file format.

        @see: L{dns.name.Name.choose_relativity} for more information
        on how I{origin} and I{relativize} determine the way names
        are emitted.

        Any additional keyword arguments are passed on to the rdata
        to_text() method.

        @param name: If name is not None, emit a RRs with I{name} as
        the owner name.
        @type name: dns.name.Name object
        @param origin: The origin for relative names, or None.
        @type origin: dns.name.Name object
        @param relativize: True if names should names be relativized
        @type relativize: bool"""
        if not name is None:
            name = name.choose_relativity(origin, relativize)
            ntext = str(name)
            pad = ' '
        else:
            ntext = ''
            pad = ''
        s = StringIO.StringIO()
        if not override_rdclass is None:
            rdclass = override_rdclass
        else:
            rdclass = self.rdclass
        if len(self) == 0:
            #
            # Empty rdatasets are used for the question section, and in
            # some dynamic updates, so we don't need to print out the TTL
            # (which is meaningless anyway).
            #
            print >> s, '%s%s%s %s' % (ntext, pad,
                                       dns.rdataclass.to_text(rdclass),
                                       dns.rdatatype.to_text(self.rdtype))
        else:
            for rd in self:
                print >> s, '%s%s%d %s %s %s' % \
                      (ntext, pad, self.ttl, dns.rdataclass.to_text(rdclass),
                       dns.rdatatype.to_text(self.rdtype),
                       rd.to_text(origin=origin, relativize=relativize, **kw))
        #
        # We strip off the final \n for the caller's convenience in printing
        #
        return s.getvalue()[:-1]

    def to_wire(self, name, file, compress=None, origin=None,
                override_rdclass=None, want_shuffle=True):
        """Convert the rdataset to wire format.

        @param name: The owner name of the RRset that will be emitted
        @type name: dns.name.Name object
        @param file: The file to which the wire format data will be appended
        @type file: file
        @param compress: The compression table to use; the default is None.
        @type compress: dict
        @param origin: The origin to be appended to any relative names when
        they are emitted.  The default is None.
        @returns: the number of records emitted
        @rtype: int
        """

        if not override_rdclass is None:
            rdclass =  override_rdclass
            want_shuffle = False
        else:
            rdclass = self.rdclass
        file.seek(0, 2)
        if len(self) == 0:
            name.to_wire(file, compress, origin)
            stuff = struct.pack("!HHIH", self.rdtype, rdclass, 0, 0)
            file.write(stuff)
            return 1
        else:
            if want_shuffle:
                l = list(self)
                random.shuffle(l)
            else:
                l = self
            for rd in l:
                name.to_wire(file, compress, origin)
                stuff = struct.pack("!HHIH", self.rdtype, rdclass,
                                    self.ttl, 0)
                file.write(stuff)
                start = file.tell()
                rd.to_wire(file, compress, origin)
                end = file.tell()
                assert end - start < 65536
                file.seek(start - 2)
                stuff = struct.pack("!H", end - start)
                file.write(stuff)
                file.seek(0, 2)
            return len(self)

    def match(self, rdclass, rdtype, covers):
        """Returns True if this rdataset matches the specified class, type,
        and covers"""
        if self.rdclass == rdclass and \
           self.rdtype == rdtype and \
           self.covers == covers:
            return True
        return False

def from_text_list(rdclass, rdtype, ttl, text_rdatas):
    """Create an rdataset with the specified class, type, and TTL, and with
    the specified list of rdatas in text format.

    @rtype: dns.rdataset.Rdataset object
    """

    if isinstance(rdclass, (str, unicode)):
        rdclass = dns.rdataclass.from_text(rdclass)
    if isinstance(rdtype, (str, unicode)):
        rdtype = dns.rdatatype.from_text(rdtype)
    r = Rdataset(rdclass, rdtype)
    r.update_ttl(ttl)
    for t in text_rdatas:
        rd = dns.rdata.from_text(r.rdclass, r.rdtype, t)
        r.add(rd)
    return r

def from_text(rdclass, rdtype, ttl, *text_rdatas):
    """Create an rdataset with the specified class, type, and TTL, and with
    the specified rdatas in text format.

    @rtype: dns.rdataset.Rdataset object
    """

    return from_text_list(rdclass, rdtype, ttl, text_rdatas)

def from_rdata_list(ttl, rdatas):
    """Create an rdataset with the specified TTL, and with
    the specified list of rdata objects.

    @rtype: dns.rdataset.Rdataset object
    """

    if len(rdatas) == 0:
        raise ValueError("rdata list must not be empty")
    r = None
    for rd in rdatas:
        if r is None:
            r = Rdataset(rd.rdclass, rd.rdtype)
            r.update_ttl(ttl)
            first_time = False
        r.add(rd)
    return r

def from_rdata(ttl, *rdatas):
    """Create an rdataset with the specified TTL, and with
    the specified rdata objects.

    @rtype: dns.rdataset.Rdataset object
    """

    return from_rdata_list(ttl, rdatas)

########NEW FILE########
__FILENAME__ = rdatatype
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Rdata Types.

@var _by_text: The rdata type textual name to value mapping
@type _by_text: dict
@var _by_value: The rdata type value to textual name mapping
@type _by_value: dict
@var _metatypes: If an rdatatype is a metatype, there will be a mapping
whose key is the rdatatype value and whose value is True in this dictionary.
@type _metatypes: dict
@var _singletons: If an rdatatype is a singleton, there will be a mapping
whose key is the rdatatype value and whose value is True in this dictionary.
@type _singletons: dict"""

import re

import dns.exception

NONE = 0
A = 1
NS = 2
MD = 3
MF = 4
CNAME = 5
SOA = 6
MB = 7
MG = 8
MR = 9
NULL = 10
WKS = 11
PTR = 12
HINFO = 13
MINFO = 14
MX = 15
TXT = 16
RP = 17
AFSDB = 18
X25 = 19
ISDN = 20
RT = 21
NSAP = 22
NSAP_PTR = 23
SIG = 24
KEY = 25
PX = 26
GPOS = 27
AAAA = 28
LOC = 29
NXT = 30
SRV = 33
NAPTR = 35
KX = 36
CERT = 37
A6 = 38
DNAME = 39
OPT = 41
APL = 42
DS = 43
SSHFP = 44
IPSECKEY = 45
RRSIG = 46
NSEC = 47
DNSKEY = 48
DHCID = 49
NSEC3 = 50
NSEC3PARAM = 51
HIP = 55
SPF = 99
UNSPEC = 103
TKEY = 249
TSIG = 250
IXFR = 251
AXFR = 252
MAILB = 253
MAILA = 254
ANY = 255
TA = 32768
DLV = 32769

_by_text = {
    'NONE' : NONE,
    'A' : A,
    'NS' : NS,
    'MD' : MD,
    'MF' : MF,
    'CNAME' : CNAME,
    'SOA' : SOA,
    'MB' : MB,
    'MG' : MG,
    'MR' : MR,
    'NULL' : NULL,
    'WKS' : WKS,
    'PTR' : PTR,
    'HINFO' : HINFO,
    'MINFO' : MINFO,
    'MX' : MX,
    'TXT' : TXT,
    'RP' : RP,
    'AFSDB' : AFSDB,
    'X25' : X25,
    'ISDN' : ISDN,
    'RT' : RT,
    'NSAP' : NSAP,
    'NSAP-PTR' : NSAP_PTR,
    'SIG' : SIG,
    'KEY' : KEY,
    'PX' : PX,
    'GPOS' : GPOS,
    'AAAA' : AAAA,
    'LOC' : LOC,
    'NXT' : NXT,
    'SRV' : SRV,
    'NAPTR' : NAPTR,
    'KX' : KX,
    'CERT' : CERT,
    'A6' : A6,
    'DNAME' : DNAME,
    'OPT' : OPT,
    'APL' : APL,
    'DS' : DS,
    'SSHFP' : SSHFP,
    'IPSECKEY' : IPSECKEY,
    'RRSIG' : RRSIG,
    'NSEC' : NSEC,
    'DNSKEY' : DNSKEY,
    'DHCID' : DHCID,
    'NSEC3' : NSEC3,
    'NSEC3PARAM' : NSEC3PARAM,
    'HIP' : HIP,
    'SPF' : SPF,
    'UNSPEC' : UNSPEC,
    'TKEY' : TKEY,
    'TSIG' : TSIG,
    'IXFR' : IXFR,
    'AXFR' : AXFR,
    'MAILB' : MAILB,
    'MAILA' : MAILA,
    'ANY' : ANY,
    'TA' : TA,
    'DLV' : DLV,
    }

# We construct the inverse mapping programmatically to ensure that we
# cannot make any mistakes (e.g. omissions, cut-and-paste errors) that
# would cause the mapping not to be true inverse.

_by_value = dict([(y, x) for x, y in _by_text.iteritems()])


_metatypes = {
    OPT : True
    }

_singletons = {
    SOA : True,
    NXT : True,
    DNAME : True,
    NSEC : True,
    # CNAME is technically a singleton, but we allow multiple CNAMEs.
    }

_unknown_type_pattern = re.compile('TYPE([0-9]+)$', re.I);

class UnknownRdatatype(dns.exception.DNSException):
    """Raised if a type is unknown."""
    pass

def from_text(text):
    """Convert text into a DNS rdata type value.
    @param text: the text
    @type text: string
    @raises dns.rdatatype.UnknownRdatatype: the type is unknown
    @raises ValueError: the rdata type value is not >= 0 and <= 65535
    @rtype: int"""

    value = _by_text.get(text.upper())
    if value is None:
        match = _unknown_type_pattern.match(text)
        if match == None:
            raise UnknownRdatatype
        value = int(match.group(1))
        if value < 0 or value > 65535:
            raise ValueError("type must be between >= 0 and <= 65535")
    return value

def to_text(value):
    """Convert a DNS rdata type to text.
    @param value: the rdata type value
    @type value: int
    @raises ValueError: the rdata type value is not >= 0 and <= 65535
    @rtype: string"""

    if value < 0 or value > 65535:
        raise ValueError("type must be between >= 0 and <= 65535")
    text = _by_value.get(value)
    if text is None:
        text = 'TYPE' + `value`
    return text

def is_metatype(rdtype):
    """True if the type is a metatype.
    @param rdtype: the type
    @type rdtype: int
    @rtype: bool"""

    if rdtype >= TKEY and rdtype <= ANY or rdtype in _metatypes:
        return True
    return False

def is_singleton(rdtype):
    """True if the type is a singleton.
    @param rdtype: the type
    @type rdtype: int
    @rtype: bool"""

    if rdtype in _singletons:
        return True
    return False

########NEW FILE########
__FILENAME__ = AFSDB
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.mxbase

class AFSDB(dns.rdtypes.mxbase.UncompressedDowncasingMX):
    """AFSDB record

    @ivar subtype: the subtype value
    @type subtype: int
    @ivar hostname: the hostname name
    @type hostname: dns.name.Name object"""

    # Use the property mechanism to make "subtype" an alias for the
    # "preference" attribute, and "hostname" an alias for the "exchange"
    # attribute.
    #
    # This lets us inherit the UncompressedMX implementation but lets
    # the caller use appropriate attribute names for the rdata type.
    #
    # We probably lose some performance vs. a cut-and-paste
    # implementation, but this way we don't copy code, and that's
    # good.

    def get_subtype(self):
        return self.preference

    def set_subtype(self, subtype):
        self.preference = subtype

    subtype = property(get_subtype, set_subtype)

    def get_hostname(self):
        return self.exchange

    def set_hostname(self, hostname):
        self.exchange = hostname

    hostname = property(get_hostname, set_hostname)

########NEW FILE########
__FILENAME__ = CERT
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import struct

import dns.exception
import dns.dnssec
import dns.rdata
import dns.tokenizer

_ctype_by_value = {
    1 : 'PKIX',
    2 : 'SPKI',
    3 : 'PGP',
    253 : 'URI',
    254 : 'OID',
    }

_ctype_by_name = {
    'PKIX' : 1,
    'SPKI' : 2,
    'PGP' : 3,
    'URI' : 253,
    'OID' : 254,
    }

def _ctype_from_text(what):
    v = _ctype_by_name.get(what)
    if not v is None:
        return v
    return int(what)

def _ctype_to_text(what):
    v = _ctype_by_value.get(what)
    if not v is None:
        return v
    return str(what)

class CERT(dns.rdata.Rdata):
    """CERT record

    @ivar certificate_type: certificate type
    @type certificate_type: int
    @ivar key_tag: key tag
    @type key_tag: int
    @ivar algorithm: algorithm
    @type algorithm: int
    @ivar certificate: the certificate or CRL
    @type certificate: string
    @see: RFC 2538"""

    __slots__ = ['certificate_type', 'key_tag', 'algorithm', 'certificate']

    def __init__(self, rdclass, rdtype, certificate_type, key_tag, algorithm,
                 certificate):
        super(CERT, self).__init__(rdclass, rdtype)
        self.certificate_type = certificate_type
        self.key_tag = key_tag
        self.algorithm = algorithm
        self.certificate = certificate

    def to_text(self, origin=None, relativize=True, **kw):
        certificate_type = _ctype_to_text(self.certificate_type)
        return "%s %d %s %s" % (certificate_type, self.key_tag,
                                dns.dnssec.algorithm_to_text(self.algorithm),
                                dns.rdata._base64ify(self.certificate))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        certificate_type = _ctype_from_text(tok.get_string())
        key_tag = tok.get_uint16()
        algorithm = dns.dnssec.algorithm_from_text(tok.get_string())
        if algorithm < 0 or algorithm > 255:
            raise dns.exception.SyntaxError("bad algorithm type")
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        b64 = ''.join(chunks)
        certificate = b64.decode('base64_codec')
        return cls(rdclass, rdtype, certificate_type, key_tag,
                   algorithm, certificate)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        prefix = struct.pack("!HHB", self.certificate_type, self.key_tag,
                             self.algorithm)
        file.write(prefix)
        file.write(self.certificate)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        prefix = wire[current : current + 5].unwrap()
        current += 5
        rdlen -= 5
        if rdlen < 0:
            raise dns.exception.FormError
        (certificate_type, key_tag, algorithm) = struct.unpack("!HHB", prefix)
        certificate = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, certificate_type, key_tag, algorithm,
                   certificate)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        f = cStringIO.StringIO()
        self.to_wire(f)
        wire1 = f.getvalue()
        f.seek(0)
        f.truncate()
        other.to_wire(f)
        wire2 = f.getvalue()
        f.close()

        return cmp(wire1, wire2)

########NEW FILE########
__FILENAME__ = CNAME
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.nsbase

class CNAME(dns.rdtypes.nsbase.NSBase):
    """CNAME record

    Note: although CNAME is officially a singleton type, dnspython allows
    non-singleton CNAME rdatasets because such sets have been commonly
    used by BIND and other nameservers for load balancing."""
    pass

########NEW FILE########
__FILENAME__ = DLV
# Copyright (C) 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.dsbase

class DLV(dns.rdtypes.dsbase.DSBase):
    """DLV record"""
    pass

########NEW FILE########
__FILENAME__ = DNAME
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


import dns.rdtypes.nsbase

class DNAME(dns.rdtypes.nsbase.UncompressedNS):
    """DNAME record"""
    def to_digestable(self, origin = None):
        return self.target.to_digestable(origin)

########NEW FILE########
__FILENAME__ = DNSKEY
# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.exception
import dns.dnssec
import dns.rdata

# flag constants
SEP = 0x0001
REVOKE = 0x0080
ZONE = 0x0100

class DNSKEY(dns.rdata.Rdata):
    """DNSKEY record

    @ivar flags: the key flags
    @type flags: int
    @ivar protocol: the protocol for which this key may be used
    @type protocol: int
    @ivar algorithm: the algorithm used for the key
    @type algorithm: int
    @ivar key: the public key
    @type key: string"""

    __slots__ = ['flags', 'protocol', 'algorithm', 'key']

    def __init__(self, rdclass, rdtype, flags, protocol, algorithm, key):
        super(DNSKEY, self).__init__(rdclass, rdtype)
        self.flags = flags
        self.protocol = protocol
        self.algorithm = algorithm
        self.key = key

    def to_text(self, origin=None, relativize=True, **kw):
        return '%d %d %d %s' % (self.flags, self.protocol, self.algorithm,
                                dns.rdata._base64ify(self.key))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        flags = tok.get_uint16()
        protocol = tok.get_uint8()
        algorithm = dns.dnssec.algorithm_from_text(tok.get_string())
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        b64 = ''.join(chunks)
        key = b64.decode('base64_codec')
        return cls(rdclass, rdtype, flags, protocol, algorithm, key)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        header = struct.pack("!HBB", self.flags, self.protocol, self.algorithm)
        file.write(header)
        file.write(self.key)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        if rdlen < 4:
            raise dns.exception.FormError
        header = struct.unpack('!HBB', wire[current : current + 4])
        current += 4
        rdlen -= 4
        key = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, header[0], header[1], header[2],
                   key)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        hs = struct.pack("!HBB", self.flags, self.protocol, self.algorithm)
        ho = struct.pack("!HBB", other.flags, other.protocol, other.algorithm)
        v = cmp(hs, ho)
        if v == 0:
            v = cmp(self.key, other.key)
        return v

########NEW FILE########
__FILENAME__ = DS
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.dsbase

class DS(dns.rdtypes.dsbase.DSBase):
    """DS record"""
    pass

########NEW FILE########
__FILENAME__ = GPOS
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.tokenizer

def _validate_float_string(what):
    if what[0] == '-' or what[0] == '+':
        what = what[1:]
    if what.isdigit():
        return
    (left, right) = what.split('.')
    if left == '' and right == '':
        raise dns.exception.FormError
    if not left == '' and not left.isdigit():
        raise dns.exception.FormError
    if not right == '' and not right.isdigit():
        raise dns.exception.FormError

class GPOS(dns.rdata.Rdata):
    """GPOS record

    @ivar latitude: latitude
    @type latitude: string
    @ivar longitude: longitude
    @type longitude: string
    @ivar altitude: altitude
    @type altitude: string
    @see: RFC 1712"""

    __slots__ = ['latitude', 'longitude', 'altitude']

    def __init__(self, rdclass, rdtype, latitude, longitude, altitude):
        super(GPOS, self).__init__(rdclass, rdtype)
        if isinstance(latitude, float) or \
           isinstance(latitude, int) or \
           isinstance(latitude, long):
            latitude = str(latitude)
        if isinstance(longitude, float) or \
           isinstance(longitude, int) or \
           isinstance(longitude, long):
            longitude = str(longitude)
        if isinstance(altitude, float) or \
           isinstance(altitude, int) or \
           isinstance(altitude, long):
            altitude = str(altitude)
        _validate_float_string(latitude)
        _validate_float_string(longitude)
        _validate_float_string(altitude)
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude

    def to_text(self, origin=None, relativize=True, **kw):
        return '%s %s %s' % (self.latitude, self.longitude, self.altitude)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        latitude = tok.get_string()
        longitude = tok.get_string()
        altitude = tok.get_string()
        tok.get_eol()
        return cls(rdclass, rdtype, latitude, longitude, altitude)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.latitude)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.latitude)
        l = len(self.longitude)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.longitude)
        l = len(self.altitude)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.altitude)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l > rdlen:
            raise dns.exception.FormError
        latitude = wire[current : current + l].unwrap()
        current += l
        rdlen -= l
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l > rdlen:
            raise dns.exception.FormError
        longitude = wire[current : current + l].unwrap()
        current += l
        rdlen -= l
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l != rdlen:
            raise dns.exception.FormError
        altitude = wire[current : current + l].unwrap()
        return cls(rdclass, rdtype, latitude, longitude, altitude)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        v = cmp(self.latitude, other.latitude)
        if v == 0:
            v = cmp(self.longitude, other.longitude)
            if v == 0:
                v = cmp(self.altitude, other.altitude)
        return v

    def _get_float_latitude(self):
        return float(self.latitude)

    def _set_float_latitude(self, value):
        self.latitude = str(value)

    float_latitude = property(_get_float_latitude, _set_float_latitude,
                              doc="latitude as a floating point value")

    def _get_float_longitude(self):
        return float(self.longitude)

    def _set_float_longitude(self, value):
        self.longitude = str(value)

    float_longitude = property(_get_float_longitude, _set_float_longitude,
                               doc="longitude as a floating point value")

    def _get_float_altitude(self):
        return float(self.altitude)

    def _set_float_altitude(self, value):
        self.altitude = str(value)

    float_altitude = property(_get_float_altitude, _set_float_altitude,
                              doc="altitude as a floating point value")

########NEW FILE########
__FILENAME__ = HINFO
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.tokenizer

class HINFO(dns.rdata.Rdata):
    """HINFO record

    @ivar cpu: the CPU type
    @type cpu: string
    @ivar os: the OS type
    @type os: string
    @see: RFC 1035"""

    __slots__ = ['cpu', 'os']

    def __init__(self, rdclass, rdtype, cpu, os):
        super(HINFO, self).__init__(rdclass, rdtype)
        self.cpu = cpu
        self.os = os

    def to_text(self, origin=None, relativize=True, **kw):
        return '"%s" "%s"' % (dns.rdata._escapify(self.cpu),
                              dns.rdata._escapify(self.os))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        cpu = tok.get_string()
        os = tok.get_string()
        tok.get_eol()
        return cls(rdclass, rdtype, cpu, os)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.cpu)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.cpu)
        l = len(self.os)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.os)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l > rdlen:
            raise dns.exception.FormError
        cpu = wire[current : current + l].unwrap()
        current += l
        rdlen -= l
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l != rdlen:
            raise dns.exception.FormError
        os = wire[current : current + l].unwrap()
        return cls(rdclass, rdtype, cpu, os)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        v = cmp(self.cpu, other.cpu)
        if v == 0:
            v = cmp(self.os, other.os)
        return v

########NEW FILE########
__FILENAME__ = HIP
# Copyright (C) 2010, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import string
import struct

import dns.exception
import dns.rdata
import dns.rdatatype

class HIP(dns.rdata.Rdata):
    """HIP record

    @ivar hit: the host identity tag
    @type hit: string
    @ivar algorithm: the public key cryptographic algorithm
    @type algorithm: int
    @ivar key: the public key
    @type key: string
    @ivar servers: the rendezvous servers
    @type servers: list of dns.name.Name objects
    @see: RFC 5205"""

    __slots__ = ['hit', 'algorithm', 'key', 'servers']

    def __init__(self, rdclass, rdtype, hit, algorithm, key, servers):
        super(HIP, self).__init__(rdclass, rdtype)
        self.hit = hit
        self.algorithm = algorithm
        self.key = key
        self.servers = servers

    def to_text(self, origin=None, relativize=True, **kw):
        hit = self.hit.encode('hex-codec')
        key = self.key.encode('base64-codec').replace('\n', '')
        text = ''
        servers = []
        for server in self.servers:
            servers.append(str(server.choose_relativity(origin, relativize)))
        if len(servers) > 0:
            text += (' ' + ' '.join(servers))
        return '%u %s %s%s' % (self.algorithm, hit, key, text)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        algorithm = tok.get_uint8()
        hit = tok.get_string().decode('hex-codec')
        if len(hit) > 255:
            raise dns.exception.SyntaxError("HIT too long")
        key = tok.get_string().decode('base64-codec')
        servers = []
        while 1:
            token = tok.get()
            if token.is_eol_or_eof():
                break
            server = dns.name.from_text(token.value, origin)
            server.choose_relativity(origin, relativize)
            servers.append(server)
        return cls(rdclass, rdtype, hit, algorithm, key, servers)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        lh = len(self.hit)
        lk = len(self.key)
        file.write(struct.pack("!BBH", lh, self.algorithm, lk))
        file.write(self.hit)
        file.write(self.key)
        for server in self.servers:
            server.to_wire(file, None, origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (lh, algorithm, lk) = struct.unpack('!BBH',
                                            wire[current : current + 4])
        current += 4
        rdlen -= 4
        hit = wire[current : current + lh].unwrap()
        current += lh
        rdlen -= lh
        key = wire[current : current + lk].unwrap()
        current += lk
        rdlen -= lk
        servers = []
        while rdlen > 0:
            (server, cused) = dns.name.from_wire(wire[: current + rdlen],
                                                 current)
            current += cused
            rdlen -= cused
            if not origin is None:
                server = server.relativize(origin)
            servers.append(server)
        return cls(rdclass, rdtype, hit, algorithm, key, servers)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        servers = []
        for server in self.servers:
            server = server.choose_relativity(origin, relativize)
            servers.append(server)
        self.servers = servers

    def _cmp(self, other):
        b1 = cStringIO.StringIO()
        lh = len(self.hit)
        lk = len(self.key)
        b1.write(struct.pack("!BBH", lh, self.algorithm, lk))
        b1.write(self.hit)
        b1.write(self.key)
        b2 = cStringIO.StringIO()
        lh = len(other.hit)
        lk = len(other.key)
        b2.write(struct.pack("!BBH", lh, other.algorithm, lk))
        b2.write(other.hit)
        b2.write(other.key)
        v = cmp(b1.getvalue(), b2.getvalue())
        if v != 0:
            return v
        ls = len(self.servers)
        lo = len(other.servers)
        count = min(ls, lo)
        i = 0
        while i < count:
            v = cmp(self.servers[i], other.servers[i])
            if v != 0:
                return v
            i += 1
        return ls - lo

########NEW FILE########
__FILENAME__ = ISDN
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.tokenizer

class ISDN(dns.rdata.Rdata):
    """ISDN record

    @ivar address: the ISDN address
    @type address: string
    @ivar subaddress: the ISDN subaddress (or '' if not present)
    @type subaddress: string
    @see: RFC 1183"""

    __slots__ = ['address', 'subaddress']

    def __init__(self, rdclass, rdtype, address, subaddress):
        super(ISDN, self).__init__(rdclass, rdtype)
        self.address = address
        self.subaddress = subaddress

    def to_text(self, origin=None, relativize=True, **kw):
        if self.subaddress:
            return '"%s" "%s"' % (dns.rdata._escapify(self.address),
                                  dns.rdata._escapify(self.subaddress))
        else:
            return '"%s"' % dns.rdata._escapify(self.address)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_string()
        t = tok.get()
        if not t.is_eol_or_eof():
            tok.unget(t)
            subaddress = tok.get_string()
        else:
            tok.unget(t)
            subaddress = ''
        tok.get_eol()
        return cls(rdclass, rdtype, address, subaddress)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.address)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.address)
        l = len(self.subaddress)
        if l > 0:
            assert l < 256
            byte = chr(l)
            file.write(byte)
            file.write(self.subaddress)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l > rdlen:
            raise dns.exception.FormError
        address = wire[current : current + l].unwrap()
        current += l
        rdlen -= l
        if rdlen > 0:
            l = ord(wire[current])
            current += 1
            rdlen -= 1
            if l != rdlen:
                raise dns.exception.FormError
            subaddress = wire[current : current + l].unwrap()
        else:
            subaddress = ''
        return cls(rdclass, rdtype, address, subaddress)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        v = cmp(self.address, other.address)
        if v == 0:
            v = cmp(self.subaddress, other.subaddress)
        return v

########NEW FILE########
__FILENAME__ = LOC
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import struct

import dns.exception
import dns.rdata

_pows = (1L, 10L, 100L, 1000L, 10000L, 100000L, 1000000L, 10000000L,
         100000000L, 1000000000L, 10000000000L)

def _exponent_of(what, desc):
    exp = None
    for i in xrange(len(_pows)):
        if what // _pows[i] == 0L:
            exp = i - 1
            break
    if exp is None or exp < 0:
        raise dns.exception.SyntaxError("%s value out of bounds" % desc)
    return exp

def _float_to_tuple(what):
    if what < 0:
        sign = -1
        what *= -1
    else:
        sign = 1
    what = long(round(what * 3600000))
    degrees = int(what // 3600000)
    what -= degrees * 3600000
    minutes = int(what // 60000)
    what -= minutes * 60000
    seconds = int(what // 1000)
    what -= int(seconds * 1000)
    what = int(what)
    return (degrees * sign, minutes, seconds, what)

def _tuple_to_float(what):
    if what[0] < 0:
        sign = -1
        value = float(what[0]) * -1
    else:
        sign = 1
        value = float(what[0])
    value += float(what[1]) / 60.0
    value += float(what[2]) / 3600.0
    value += float(what[3]) / 3600000.0
    return sign * value

def _encode_size(what, desc):
    what = long(what);
    exponent = _exponent_of(what, desc) & 0xF
    base = what // pow(10, exponent) & 0xF
    return base * 16 + exponent

def _decode_size(what, desc):
    exponent = what & 0x0F
    if exponent > 9:
        raise dns.exception.SyntaxError("bad %s exponent" % desc)
    base = (what & 0xF0) >> 4
    if base > 9:
        raise dns.exception.SyntaxError("bad %s base" % desc)
    return long(base) * pow(10, exponent)

class LOC(dns.rdata.Rdata):
    """LOC record

    @ivar latitude: latitude
    @type latitude: (int, int, int, int) tuple specifying the degrees, minutes,
    seconds, and milliseconds of the coordinate.
    @ivar longitude: longitude
    @type longitude: (int, int, int, int) tuple specifying the degrees,
    minutes, seconds, and milliseconds of the coordinate.
    @ivar altitude: altitude
    @type altitude: float
    @ivar size: size of the sphere
    @type size: float
    @ivar horizontal_precision: horizontal precision
    @type horizontal_precision: float
    @ivar vertical_precision: vertical precision
    @type vertical_precision: float
    @see: RFC 1876"""

    __slots__ = ['latitude', 'longitude', 'altitude', 'size',
                 'horizontal_precision', 'vertical_precision']

    def __init__(self, rdclass, rdtype, latitude, longitude, altitude,
                 size=1.0, hprec=10000.0, vprec=10.0):
        """Initialize a LOC record instance.

        The parameters I{latitude} and I{longitude} may be either a 4-tuple
        of integers specifying (degrees, minutes, seconds, milliseconds),
        or they may be floating point values specifying the number of
        degrees.  The other parameters are floats."""

        super(LOC, self).__init__(rdclass, rdtype)
        if isinstance(latitude, int) or isinstance(latitude, long):
            latitude = float(latitude)
        if isinstance(latitude, float):
            latitude = _float_to_tuple(latitude)
        self.latitude = latitude
        if isinstance(longitude, int) or isinstance(longitude, long):
            longitude = float(longitude)
        if isinstance(longitude, float):
            longitude = _float_to_tuple(longitude)
        self.longitude = longitude
        self.altitude = float(altitude)
        self.size = float(size)
        self.horizontal_precision = float(hprec)
        self.vertical_precision = float(vprec)

    def to_text(self, origin=None, relativize=True, **kw):
        if self.latitude[0] > 0:
            lat_hemisphere = 'N'
            lat_degrees = self.latitude[0]
        else:
            lat_hemisphere = 'S'
            lat_degrees = -1 * self.latitude[0]
        if self.longitude[0] > 0:
            long_hemisphere = 'E'
            long_degrees = self.longitude[0]
        else:
            long_hemisphere = 'W'
            long_degrees = -1 * self.longitude[0]
        text = "%d %d %d.%03d %s %d %d %d.%03d %s %0.2fm" % (
            lat_degrees, self.latitude[1], self.latitude[2], self.latitude[3],
            lat_hemisphere, long_degrees, self.longitude[1], self.longitude[2],
            self.longitude[3], long_hemisphere, self.altitude / 100.0
            )

        if self.size != 1.0 or self.horizontal_precision != 10000.0 or \
           self.vertical_precision != 10.0:
            text += " %0.2fm %0.2fm %0.2fm" % (
                self.size / 100.0, self.horizontal_precision / 100.0,
                self.vertical_precision / 100.0
            )
        return text

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        latitude = [0, 0, 0, 0]
        longitude = [0, 0, 0, 0]
        size = 1.0
        hprec = 10000.0
        vprec = 10.0

        latitude[0] = tok.get_int()
        t = tok.get_string()
        if t.isdigit():
            latitude[1] = int(t)
            t = tok.get_string()
            if '.' in t:
                (seconds, milliseconds) = t.split('.')
                if not seconds.isdigit():
                    raise dns.exception.SyntaxError('bad latitude seconds value')
                latitude[2] = int(seconds)
                if latitude[2] >= 60:
                    raise dns.exception.SyntaxError('latitude seconds >= 60')
                l = len(milliseconds)
                if l == 0 or l > 3 or not milliseconds.isdigit():
                    raise dns.exception.SyntaxError('bad latitude milliseconds value')
                if l == 1:
                    m = 100
                elif l == 2:
                    m = 10
                else:
                    m = 1
                latitude[3] = m * int(milliseconds)
                t = tok.get_string()
            elif t.isdigit():
                latitude[2] = int(t)
                t = tok.get_string()
        if t == 'S':
            latitude[0] *= -1
        elif t != 'N':
            raise dns.exception.SyntaxError('bad latitude hemisphere value')

        longitude[0] = tok.get_int()
        t = tok.get_string()
        if t.isdigit():
            longitude[1] = int(t)
            t = tok.get_string()
            if '.' in t:
                (seconds, milliseconds) = t.split('.')
                if not seconds.isdigit():
                    raise dns.exception.SyntaxError('bad longitude seconds value')
                longitude[2] = int(seconds)
                if longitude[2] >= 60:
                    raise dns.exception.SyntaxError('longitude seconds >= 60')
                l = len(milliseconds)
                if l == 0 or l > 3 or not milliseconds.isdigit():
                    raise dns.exception.SyntaxError('bad longitude milliseconds value')
                if l == 1:
                    m = 100
                elif l == 2:
                    m = 10
                else:
                    m = 1
                longitude[3] = m * int(milliseconds)
                t = tok.get_string()
            elif t.isdigit():
                longitude[2] = int(t)
                t = tok.get_string()
        if t == 'W':
            longitude[0] *= -1
        elif t != 'E':
            raise dns.exception.SyntaxError('bad longitude hemisphere value')

        t = tok.get_string()
        if t[-1] == 'm':
            t = t[0 : -1]
        altitude = float(t) * 100.0        # m -> cm

        token = tok.get().unescape()
        if not token.is_eol_or_eof():
            value = token.value
            if value[-1] == 'm':
                value = value[0 : -1]
            size = float(value) * 100.0        # m -> cm
            token = tok.get().unescape()
            if not token.is_eol_or_eof():
                value = token.value
                if value[-1] == 'm':
                    value = value[0 : -1]
                hprec = float(value) * 100.0        # m -> cm
                token = tok.get().unescape()
                if not token.is_eol_or_eof():
                    value = token.value
                    if value[-1] == 'm':
                        value = value[0 : -1]
                        vprec = float(value) * 100.0        # m -> cm
                        tok.get_eol()

        return cls(rdclass, rdtype, latitude, longitude, altitude,
                   size, hprec, vprec)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        if self.latitude[0] < 0:
            sign = -1
            degrees = long(-1 * self.latitude[0])
        else:
            sign = 1
            degrees = long(self.latitude[0])
        milliseconds = (degrees * 3600000 +
                        self.latitude[1] * 60000 +
                        self.latitude[2] * 1000 +
                        self.latitude[3]) * sign
        latitude = 0x80000000L + milliseconds
        if self.longitude[0] < 0:
            sign = -1
            degrees = long(-1 * self.longitude[0])
        else:
            sign = 1
            degrees = long(self.longitude[0])
        milliseconds = (degrees * 3600000 +
                        self.longitude[1] * 60000 +
                        self.longitude[2] * 1000 +
                        self.longitude[3]) * sign
        longitude = 0x80000000L + milliseconds
        altitude = long(self.altitude) + 10000000L
        size = _encode_size(self.size, "size")
        hprec = _encode_size(self.horizontal_precision, "horizontal precision")
        vprec = _encode_size(self.vertical_precision, "vertical precision")
        wire = struct.pack("!BBBBIII", 0, size, hprec, vprec, latitude,
                           longitude, altitude)
        file.write(wire)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (version, size, hprec, vprec, latitude, longitude, altitude) = \
                  struct.unpack("!BBBBIII", wire[current : current + rdlen])
        if latitude > 0x80000000L:
            latitude = float(latitude - 0x80000000L) / 3600000
        else:
            latitude = -1 * float(0x80000000L - latitude) / 3600000
        if latitude < -90.0 or latitude > 90.0:
            raise dns.exception.FormError("bad latitude")
        if longitude > 0x80000000L:
            longitude = float(longitude - 0x80000000L) / 3600000
        else:
            longitude = -1 * float(0x80000000L - longitude) / 3600000
        if longitude < -180.0 or longitude > 180.0:
            raise dns.exception.FormError("bad longitude")
        altitude = float(altitude) - 10000000.0
        size = _decode_size(size, "size")
        hprec = _decode_size(hprec, "horizontal precision")
        vprec = _decode_size(vprec, "vertical precision")
        return cls(rdclass, rdtype, latitude, longitude, altitude,
                   size, hprec, vprec)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        f = cStringIO.StringIO()
        self.to_wire(f)
        wire1 = f.getvalue()
        f.seek(0)
        f.truncate()
        other.to_wire(f)
        wire2 = f.getvalue()
        f.close()

        return cmp(wire1, wire2)

    def _get_float_latitude(self):
        return _tuple_to_float(self.latitude)

    def _set_float_latitude(self, value):
        self.latitude = _float_to_tuple(value)

    float_latitude = property(_get_float_latitude, _set_float_latitude,
                              doc="latitude as a floating point value")

    def _get_float_longitude(self):
        return _tuple_to_float(self.longitude)

    def _set_float_longitude(self, value):
        self.longitude = _float_to_tuple(value)

    float_longitude = property(_get_float_longitude, _set_float_longitude,
                               doc="longitude as a floating point value")

########NEW FILE########
__FILENAME__ = MX
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.mxbase

class MX(dns.rdtypes.mxbase.MXBase):
    """MX record"""
    pass

########NEW FILE########
__FILENAME__ = NS
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.nsbase

class NS(dns.rdtypes.nsbase.NSBase):
    """NS record"""
    pass

########NEW FILE########
__FILENAME__ = NSEC
# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO

import dns.exception
import dns.rdata
import dns.rdatatype
import dns.name

class NSEC(dns.rdata.Rdata):
    """NSEC record

    @ivar next: the next name
    @type next: dns.name.Name object
    @ivar windows: the windowed bitmap list
    @type windows: list of (window number, string) tuples"""

    __slots__ = ['next', 'windows']

    def __init__(self, rdclass, rdtype, next, windows):
        super(NSEC, self).__init__(rdclass, rdtype)
        self.next = next
        self.windows = windows

    def to_text(self, origin=None, relativize=True, **kw):
        next = self.next.choose_relativity(origin, relativize)
        text = ''
        for (window, bitmap) in self.windows:
            bits = []
            for i in xrange(0, len(bitmap)):
                byte = ord(bitmap[i])
                for j in xrange(0, 8):
                    if byte & (0x80 >> j):
                        bits.append(dns.rdatatype.to_text(window * 256 + \
                                                          i * 8 + j))
            text += (' ' + ' '.join(bits))
        return '%s%s' % (next, text)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        next = tok.get_name()
        next = next.choose_relativity(origin, relativize)
        rdtypes = []
        while 1:
            token = tok.get().unescape()
            if token.is_eol_or_eof():
                break
            nrdtype = dns.rdatatype.from_text(token.value)
            if nrdtype == 0:
                raise dns.exception.SyntaxError("NSEC with bit 0")
            if nrdtype > 65535:
                raise dns.exception.SyntaxError("NSEC with bit > 65535")
            rdtypes.append(nrdtype)
        rdtypes.sort()
        window = 0
        octets = 0
        prior_rdtype = 0
        bitmap = ['\0'] * 32
        windows = []
        for nrdtype in rdtypes:
            if nrdtype == prior_rdtype:
                continue
            prior_rdtype = nrdtype
            new_window = nrdtype // 256
            if new_window != window:
                windows.append((window, ''.join(bitmap[0:octets])))
                bitmap = ['\0'] * 32
                window = new_window
            offset = nrdtype % 256
            byte = offset // 8
            bit = offset % 8
            octets = byte + 1
            bitmap[byte] = chr(ord(bitmap[byte]) | (0x80 >> bit))
        windows.append((window, ''.join(bitmap[0:octets])))
        return cls(rdclass, rdtype, next, windows)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        self.next.to_wire(file, None, origin)
        for (window, bitmap) in self.windows:
            file.write(chr(window))
            file.write(chr(len(bitmap)))
            file.write(bitmap)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (next, cused) = dns.name.from_wire(wire[: current + rdlen], current)
        current += cused
        rdlen -= cused
        windows = []
        while rdlen > 0:
            if rdlen < 3:
                raise dns.exception.FormError("NSEC too short")
            window = ord(wire[current])
            octets = ord(wire[current + 1])
            if octets == 0 or octets > 32:
                raise dns.exception.FormError("bad NSEC octets")
            current += 2
            rdlen -= 2
            if rdlen < octets:
                raise dns.exception.FormError("bad NSEC bitmap length")
            bitmap = wire[current : current + octets].unwrap()
            current += octets
            rdlen -= octets
            windows.append((window, bitmap))
        if not origin is None:
            next = next.relativize(origin)
        return cls(rdclass, rdtype, next, windows)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.next = self.next.choose_relativity(origin, relativize)

    def _cmp(self, other):
        return self._wire_cmp(other)

########NEW FILE########
__FILENAME__ = NSEC3
# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import base64
import cStringIO
import string
import struct

import dns.exception
import dns.rdata
import dns.rdatatype

b32_hex_to_normal = string.maketrans('0123456789ABCDEFGHIJKLMNOPQRSTUV',
                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567')
b32_normal_to_hex = string.maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
                                     '0123456789ABCDEFGHIJKLMNOPQRSTUV')

# hash algorithm constants
SHA1 = 1

# flag constants
OPTOUT = 1

class NSEC3(dns.rdata.Rdata):
    """NSEC3 record

    @ivar algorithm: the hash algorithm number
    @type algorithm: int
    @ivar flags: the flags
    @type flags: int
    @ivar iterations: the number of iterations
    @type iterations: int
    @ivar salt: the salt
    @type salt: string
    @ivar next: the next name hash
    @type next: string
    @ivar windows: the windowed bitmap list
    @type windows: list of (window number, string) tuples"""

    __slots__ = ['algorithm', 'flags', 'iterations', 'salt', 'next', 'windows']

    def __init__(self, rdclass, rdtype, algorithm, flags, iterations, salt,
                 next, windows):
        super(NSEC3, self).__init__(rdclass, rdtype)
        self.algorithm = algorithm
        self.flags = flags
        self.iterations = iterations
        self.salt = salt
        self.next = next
        self.windows = windows

    def to_text(self, origin=None, relativize=True, **kw):
        next = base64.b32encode(self.next).translate(b32_normal_to_hex).lower()
        if self.salt == '':
            salt = '-'
        else:
            salt = self.salt.encode('hex-codec')
        text = ''
        for (window, bitmap) in self.windows:
            bits = []
            for i in xrange(0, len(bitmap)):
                byte = ord(bitmap[i])
                for j in xrange(0, 8):
                    if byte & (0x80 >> j):
                        bits.append(dns.rdatatype.to_text(window * 256 + \
                                                          i * 8 + j))
            text += (' ' + ' '.join(bits))
        return '%u %u %u %s %s%s' % (self.algorithm, self.flags, self.iterations,
                                     salt, next, text)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        algorithm = tok.get_uint8()
        flags = tok.get_uint8()
        iterations = tok.get_uint16()
        salt = tok.get_string()
        if salt == '-':
            salt = ''
        else:
            salt = salt.decode('hex-codec')
        next = tok.get_string().upper().translate(b32_hex_to_normal)
        next = base64.b32decode(next)
        rdtypes = []
        while 1:
            token = tok.get().unescape()
            if token.is_eol_or_eof():
                break
            nrdtype = dns.rdatatype.from_text(token.value)
            if nrdtype == 0:
                raise dns.exception.SyntaxError("NSEC3 with bit 0")
            if nrdtype > 65535:
                raise dns.exception.SyntaxError("NSEC3 with bit > 65535")
            rdtypes.append(nrdtype)
        rdtypes.sort()
        window = 0
        octets = 0
        prior_rdtype = 0
        bitmap = ['\0'] * 32
        windows = []
        for nrdtype in rdtypes:
            if nrdtype == prior_rdtype:
                continue
            prior_rdtype = nrdtype
            new_window = nrdtype // 256
            if new_window != window:
                windows.append((window, ''.join(bitmap[0:octets])))
                bitmap = ['\0'] * 32
                window = new_window
            offset = nrdtype % 256
            byte = offset // 8
            bit = offset % 8
            octets = byte + 1
            bitmap[byte] = chr(ord(bitmap[byte]) | (0x80 >> bit))
        windows.append((window, ''.join(bitmap[0:octets])))
        return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, windows)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.salt)
        file.write(struct.pack("!BBHB", self.algorithm, self.flags,
                               self.iterations, l))
        file.write(self.salt)
        l = len(self.next)
        file.write(struct.pack("!B", l))
        file.write(self.next)
        for (window, bitmap) in self.windows:
            file.write(chr(window))
            file.write(chr(len(bitmap)))
            file.write(bitmap)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (algorithm, flags, iterations, slen) = struct.unpack('!BBHB',
                                                             wire[current : current + 5])
        current += 5
        rdlen -= 5
        salt = wire[current : current + slen].unwrap()
        current += slen
        rdlen -= slen
        (nlen, ) = struct.unpack('!B', wire[current])
        current += 1
        rdlen -= 1
        next = wire[current : current + nlen].unwrap()
        current += nlen
        rdlen -= nlen
        windows = []
        while rdlen > 0:
            if rdlen < 3:
                raise dns.exception.FormError("NSEC3 too short")
            window = ord(wire[current])
            octets = ord(wire[current + 1])
            if octets == 0 or octets > 32:
                raise dns.exception.FormError("bad NSEC3 octets")
            current += 2
            rdlen -= 2
            if rdlen < octets:
                raise dns.exception.FormError("bad NSEC3 bitmap length")
            bitmap = wire[current : current + octets].unwrap()
            current += octets
            rdlen -= octets
            windows.append((window, bitmap))
        return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, windows)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        b1 = cStringIO.StringIO()
        self.to_wire(b1)
        b2 = cStringIO.StringIO()
        other.to_wire(b2)
        return cmp(b1.getvalue(), b2.getvalue())

########NEW FILE########
__FILENAME__ = NSEC3PARAM
# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import struct

import dns.exception
import dns.rdata

class NSEC3PARAM(dns.rdata.Rdata):
    """NSEC3PARAM record

    @ivar algorithm: the hash algorithm number
    @type algorithm: int
    @ivar flags: the flags
    @type flags: int
    @ivar iterations: the number of iterations
    @type iterations: int
    @ivar salt: the salt
    @type salt: string"""

    __slots__ = ['algorithm', 'flags', 'iterations', 'salt']

    def __init__(self, rdclass, rdtype, algorithm, flags, iterations, salt):
        super(NSEC3PARAM, self).__init__(rdclass, rdtype)
        self.algorithm = algorithm
        self.flags = flags
        self.iterations = iterations
        self.salt = salt

    def to_text(self, origin=None, relativize=True, **kw):
        if self.salt == '':
            salt = '-'
        else:
            salt = self.salt.encode('hex-codec')
        return '%u %u %u %s' % (self.algorithm, self.flags, self.iterations, salt)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        algorithm = tok.get_uint8()
        flags = tok.get_uint8()
        iterations = tok.get_uint16()
        salt = tok.get_string()
        if salt == '-':
            salt = ''
        else:
            salt = salt.decode('hex-codec')
        return cls(rdclass, rdtype, algorithm, flags, iterations, salt)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.salt)
        file.write(struct.pack("!BBHB", self.algorithm, self.flags,
                               self.iterations, l))
        file.write(self.salt)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (algorithm, flags, iterations, slen) = struct.unpack('!BBHB',
                                                             wire[current : current + 5])
        current += 5
        rdlen -= 5
        salt = wire[current : current + slen].unwrap()
        current += slen
        rdlen -= slen
        if rdlen != 0:
            raise dns.exception.FormError
        return cls(rdclass, rdtype, algorithm, flags, iterations, salt)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        b1 = cStringIO.StringIO()
        self.to_wire(b1)
        b2 = cStringIO.StringIO()
        other.to_wire(b2)
        return cmp(b1.getvalue(), b2.getvalue())

########NEW FILE########
__FILENAME__ = PTR
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.nsbase

class PTR(dns.rdtypes.nsbase.NSBase):
    """PTR record"""
    pass

########NEW FILE########
__FILENAME__ = RP
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.name

class RP(dns.rdata.Rdata):
    """RP record

    @ivar mbox: The responsible person's mailbox
    @type mbox: dns.name.Name object
    @ivar txt: The owner name of a node with TXT records, or the root name
    if no TXT records are associated with this RP.
    @type txt: dns.name.Name object
    @see: RFC 1183"""

    __slots__ = ['mbox', 'txt']

    def __init__(self, rdclass, rdtype, mbox, txt):
        super(RP, self).__init__(rdclass, rdtype)
        self.mbox = mbox
        self.txt = txt

    def to_text(self, origin=None, relativize=True, **kw):
        mbox = self.mbox.choose_relativity(origin, relativize)
        txt = self.txt.choose_relativity(origin, relativize)
        return "%s %s" % (str(mbox), str(txt))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        mbox = tok.get_name()
        txt = tok.get_name()
        mbox = mbox.choose_relativity(origin, relativize)
        txt = txt.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, mbox, txt)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        self.mbox.to_wire(file, None, origin)
        self.txt.to_wire(file, None, origin)

    def to_digestable(self, origin = None):
        return self.mbox.to_digestable(origin) + \
            self.txt.to_digestable(origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (mbox, cused) = dns.name.from_wire(wire[: current + rdlen],
                                           current)
        current += cused
        rdlen -= cused
        if rdlen <= 0:
            raise dns.exception.FormError
        (txt, cused) = dns.name.from_wire(wire[: current + rdlen],
                                          current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            mbox = mbox.relativize(origin)
            txt = txt.relativize(origin)
        return cls(rdclass, rdtype, mbox, txt)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.mbox = self.mbox.choose_relativity(origin, relativize)
        self.txt = self.txt.choose_relativity(origin, relativize)

    def _cmp(self, other):
        v = cmp(self.mbox, other.mbox)
        if v == 0:
            v = cmp(self.txt, other.txt)
        return v

########NEW FILE########
__FILENAME__ = RRSIG
# Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import calendar
import struct
import time

import dns.dnssec
import dns.exception
import dns.rdata
import dns.rdatatype

class BadSigTime(dns.exception.DNSException):
    """Raised when a SIG or RRSIG RR's time cannot be parsed."""
    pass

def sigtime_to_posixtime(what):
    if len(what) != 14:
        raise BadSigTime
    year = int(what[0:4])
    month = int(what[4:6])
    day = int(what[6:8])
    hour = int(what[8:10])
    minute = int(what[10:12])
    second = int(what[12:14])
    return calendar.timegm((year, month, day, hour, minute, second,
                            0, 0, 0))

def posixtime_to_sigtime(what):
    return time.strftime('%Y%m%d%H%M%S', time.gmtime(what))

class RRSIG(dns.rdata.Rdata):
    """RRSIG record

    @ivar type_covered: the rdata type this signature covers
    @type type_covered: int
    @ivar algorithm: the algorithm used for the sig
    @type algorithm: int
    @ivar labels: number of labels
    @type labels: int
    @ivar original_ttl: the original TTL
    @type original_ttl: long
    @ivar expiration: signature expiration time
    @type expiration: long
    @ivar inception: signature inception time
    @type inception: long
    @ivar key_tag: the key tag
    @type key_tag: int
    @ivar signer: the signer
    @type signer: dns.name.Name object
    @ivar signature: the signature
    @type signature: string"""

    __slots__ = ['type_covered', 'algorithm', 'labels', 'original_ttl',
                 'expiration', 'inception', 'key_tag', 'signer',
                 'signature']

    def __init__(self, rdclass, rdtype, type_covered, algorithm, labels,
                 original_ttl, expiration, inception, key_tag, signer,
                 signature):
        super(RRSIG, self).__init__(rdclass, rdtype)
        self.type_covered = type_covered
        self.algorithm = algorithm
        self.labels = labels
        self.original_ttl = original_ttl
        self.expiration = expiration
        self.inception = inception
        self.key_tag = key_tag
        self.signer = signer
        self.signature = signature

    def covers(self):
        return self.type_covered

    def to_text(self, origin=None, relativize=True, **kw):
        return '%s %d %d %d %s %s %d %s %s' % (
            dns.rdatatype.to_text(self.type_covered),
            self.algorithm,
            self.labels,
            self.original_ttl,
            posixtime_to_sigtime(self.expiration),
            posixtime_to_sigtime(self.inception),
            self.key_tag,
            self.signer,
            dns.rdata._base64ify(self.signature)
            )

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        type_covered = dns.rdatatype.from_text(tok.get_string())
        algorithm = dns.dnssec.algorithm_from_text(tok.get_string())
        labels = tok.get_int()
        original_ttl = tok.get_ttl()
        expiration = sigtime_to_posixtime(tok.get_string())
        inception = sigtime_to_posixtime(tok.get_string())
        key_tag = tok.get_int()
        signer = tok.get_name()
        signer = signer.choose_relativity(origin, relativize)
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        b64 = ''.join(chunks)
        signature = b64.decode('base64_codec')
        return cls(rdclass, rdtype, type_covered, algorithm, labels,
                   original_ttl, expiration, inception, key_tag, signer,
                   signature)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        header = struct.pack('!HBBIIIH', self.type_covered,
                             self.algorithm, self.labels,
                             self.original_ttl, self.expiration,
                             self.inception, self.key_tag)
        file.write(header)
        self.signer.to_wire(file, None, origin)
        file.write(self.signature)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        header = struct.unpack('!HBBIIIH', wire[current : current + 18])
        current += 18
        rdlen -= 18
        (signer, cused) = dns.name.from_wire(wire[: current + rdlen], current)
        current += cused
        rdlen -= cused
        if not origin is None:
            signer = signer.relativize(origin)
        signature = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, header[0], header[1], header[2],
                   header[3], header[4], header[5], header[6], signer,
                   signature)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.signer = self.signer.choose_relativity(origin, relativize)

    def _cmp(self, other):
        return self._wire_cmp(other)


########NEW FILE########
__FILENAME__ = RT
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.mxbase

class RT(dns.rdtypes.mxbase.UncompressedDowncasingMX):
    """RT record"""
    pass

########NEW FILE########
__FILENAME__ = SOA
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.exception
import dns.rdata
import dns.name

class SOA(dns.rdata.Rdata):
    """SOA record

    @ivar mname: the SOA MNAME (master name) field
    @type mname: dns.name.Name object
    @ivar rname: the SOA RNAME (responsible name) field
    @type rname: dns.name.Name object
    @ivar serial: The zone's serial number
    @type serial: int
    @ivar refresh: The zone's refresh value (in seconds)
    @type refresh: int
    @ivar retry: The zone's retry value (in seconds)
    @type retry: int
    @ivar expire: The zone's expiration value (in seconds)
    @type expire: int
    @ivar minimum: The zone's negative caching time (in seconds, called
    "minimum" for historical reasons)
    @type minimum: int
    @see: RFC 1035"""

    __slots__ = ['mname', 'rname', 'serial', 'refresh', 'retry', 'expire',
                 'minimum']

    def __init__(self, rdclass, rdtype, mname, rname, serial, refresh, retry,
                 expire, minimum):
        super(SOA, self).__init__(rdclass, rdtype)
        self.mname = mname
        self.rname = rname
        self.serial = serial
        self.refresh = refresh
        self.retry = retry
        self.expire = expire
        self.minimum = minimum

    def to_text(self, origin=None, relativize=True, **kw):
        mname = self.mname.choose_relativity(origin, relativize)
        rname = self.rname.choose_relativity(origin, relativize)
        return '%s %s %d %d %d %d %d' % (
            mname, rname, self.serial, self.refresh, self.retry,
            self.expire, self.minimum )

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        mname = tok.get_name()
        rname = tok.get_name()
        mname = mname.choose_relativity(origin, relativize)
        rname = rname.choose_relativity(origin, relativize)
        serial = tok.get_uint32()
        refresh = tok.get_ttl()
        retry = tok.get_ttl()
        expire = tok.get_ttl()
        minimum = tok.get_ttl()
        tok.get_eol()
        return cls(rdclass, rdtype, mname, rname, serial, refresh, retry,
                   expire, minimum )

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        self.mname.to_wire(file, compress, origin)
        self.rname.to_wire(file, compress, origin)
        five_ints = struct.pack('!IIIII', self.serial, self.refresh,
                                self.retry, self.expire, self.minimum)
        file.write(five_ints)

    def to_digestable(self, origin = None):
        return self.mname.to_digestable(origin) + \
            self.rname.to_digestable(origin) + \
            struct.pack('!IIIII', self.serial, self.refresh,
                        self.retry, self.expire, self.minimum)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (mname, cused) = dns.name.from_wire(wire[: current + rdlen], current)
        current += cused
        rdlen -= cused
        (rname, cused) = dns.name.from_wire(wire[: current + rdlen], current)
        current += cused
        rdlen -= cused
        if rdlen != 20:
            raise dns.exception.FormError
        five_ints = struct.unpack('!IIIII',
                                  wire[current : current + rdlen])
        if not origin is None:
            mname = mname.relativize(origin)
            rname = rname.relativize(origin)
        return cls(rdclass, rdtype, mname, rname,
                   five_ints[0], five_ints[1], five_ints[2], five_ints[3],
                   five_ints[4])

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.mname = self.mname.choose_relativity(origin, relativize)
        self.rname = self.rname.choose_relativity(origin, relativize)

    def _cmp(self, other):
        v = cmp(self.mname, other.mname)
        if v == 0:
            v = cmp(self.rname, other.rname)
            if v == 0:
                self_ints = struct.pack('!IIIII', self.serial, self.refresh,
                                        self.retry, self.expire, self.minimum)
                other_ints = struct.pack('!IIIII', other.serial, other.refresh,
                                         other.retry, other.expire,
                                         other.minimum)
                v = cmp(self_ints, other_ints)
        return v

########NEW FILE########
__FILENAME__ = SPF
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.txtbase

class SPF(dns.rdtypes.txtbase.TXTBase):
    """SPF record

    @see: RFC 4408"""
    pass

########NEW FILE########
__FILENAME__ = SSHFP
# Copyright (C) 2005-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.rdata
import dns.rdatatype

class SSHFP(dns.rdata.Rdata):
    """SSHFP record

    @ivar algorithm: the algorithm
    @type algorithm: int
    @ivar fp_type: the digest type
    @type fp_type: int
    @ivar fingerprint: the fingerprint
    @type fingerprint: string
    @see: draft-ietf-secsh-dns-05.txt"""

    __slots__ = ['algorithm', 'fp_type', 'fingerprint']

    def __init__(self, rdclass, rdtype, algorithm, fp_type,
                 fingerprint):
        super(SSHFP, self).__init__(rdclass, rdtype)
        self.algorithm = algorithm
        self.fp_type = fp_type
        self.fingerprint = fingerprint

    def to_text(self, origin=None, relativize=True, **kw):
        return '%d %d %s' % (self.algorithm,
                             self.fp_type,
                             dns.rdata._hexify(self.fingerprint,
                                               chunksize=128))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        algorithm = tok.get_uint8()
        fp_type = tok.get_uint8()
        fingerprint = tok.get_string()
        fingerprint = fingerprint.decode('hex_codec')
        tok.get_eol()
        return cls(rdclass, rdtype, algorithm, fp_type, fingerprint)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        header = struct.pack("!BB", self.algorithm, self.fp_type)
        file.write(header)
        file.write(self.fingerprint)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        header = struct.unpack("!BB", wire[current : current + 2])
        current += 2
        rdlen -= 2
        fingerprint = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, header[0], header[1], fingerprint)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        hs = struct.pack("!BB", self.algorithm, self.fp_type)
        ho = struct.pack("!BB", other.algorithm, other.fp_type)
        v = cmp(hs, ho)
        if v == 0:
            v = cmp(self.fingerprint, other.fingerprint)
        return v

########NEW FILE########
__FILENAME__ = TXT
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.txtbase

class TXT(dns.rdtypes.txtbase.TXTBase):
    """TXT record"""
    pass

########NEW FILE########
__FILENAME__ = X25
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.tokenizer

class X25(dns.rdata.Rdata):
    """X25 record

    @ivar address: the PSDN address
    @type address: string
    @see: RFC 1183"""

    __slots__ = ['address']

    def __init__(self, rdclass, rdtype, address):
        super(X25, self).__init__(rdclass, rdtype)
        self.address = address

    def to_text(self, origin=None, relativize=True, **kw):
        return '"%s"' % dns.rdata._escapify(self.address)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_string()
        tok.get_eol()
        return cls(rdclass, rdtype, address)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        l = len(self.address)
        assert l < 256
        byte = chr(l)
        file.write(byte)
        file.write(self.address)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        l = ord(wire[current])
        current += 1
        rdlen -= 1
        if l != rdlen:
            raise dns.exception.FormError
        address = wire[current : current + l].unwrap()
        return cls(rdclass, rdtype, address)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.address, other.address)

########NEW FILE########
__FILENAME__ = dsbase
# Copyright (C) 2010, 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.rdata
import dns.rdatatype

class DSBase(dns.rdata.Rdata):
    """Base class for rdata that is like a DS record

    @ivar key_tag: the key tag
    @type key_tag: int
    @ivar algorithm: the algorithm
    @type algorithm: int
    @ivar digest_type: the digest type
    @type digest_type: int
    @ivar digest: the digest
    @type digest: int
    @see: draft-ietf-dnsext-delegation-signer-14.txt"""

    __slots__ = ['key_tag', 'algorithm', 'digest_type', 'digest']

    def __init__(self, rdclass, rdtype, key_tag, algorithm, digest_type,
                 digest):
        super(DSBase, self).__init__(rdclass, rdtype)
        self.key_tag = key_tag
        self.algorithm = algorithm
        self.digest_type = digest_type
        self.digest = digest

    def to_text(self, origin=None, relativize=True, **kw):
        return '%d %d %d %s' % (self.key_tag, self.algorithm,
                                self.digest_type,
                                dns.rdata._hexify(self.digest,
                                                  chunksize=128))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        key_tag = tok.get_uint16()
        algorithm = tok.get_uint8()
        digest_type = tok.get_uint8()
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        digest = ''.join(chunks)
        digest = digest.decode('hex_codec')
        return cls(rdclass, rdtype, key_tag, algorithm, digest_type,
                   digest)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        header = struct.pack("!HBB", self.key_tag, self.algorithm,
                             self.digest_type)
        file.write(header)
        file.write(self.digest)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        header = struct.unpack("!HBB", wire[current : current + 4])
        current += 4
        rdlen -= 4
        digest = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, header[0], header[1], header[2], digest)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        hs = struct.pack("!HBB", self.key_tag, self.algorithm,
                         self.digest_type)
        ho = struct.pack("!HBB", other.key_tag, other.algorithm,
                         other.digest_type)
        v = cmp(hs, ho)
        if v == 0:
            v = cmp(self.digest, other.digest)
        return v

########NEW FILE########
__FILENAME__ = A
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.ipv4
import dns.rdata
import dns.tokenizer

class A(dns.rdata.Rdata):
    """A record.

    @ivar address: an IPv4 address
    @type address: string (in the standard "dotted quad" format)"""

    __slots__ = ['address']

    def __init__(self, rdclass, rdtype, address):
        super(A, self).__init__(rdclass, rdtype)
        # check that it's OK
        junk = dns.ipv4.inet_aton(address)
        self.address = address

    def to_text(self, origin=None, relativize=True, **kw):
        return self.address

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_identifier()
        tok.get_eol()
        return cls(rdclass, rdtype, address)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(dns.ipv4.inet_aton(self.address))

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        address = dns.ipv4.inet_ntoa(wire[current : current + rdlen])
        return cls(rdclass, rdtype, address)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        sa = dns.ipv4.inet_aton(self.address)
        oa = dns.ipv4.inet_aton(other.address)
        return cmp(sa, oa)

########NEW FILE########
__FILENAME__ = AAAA
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.inet
import dns.rdata
import dns.tokenizer

class AAAA(dns.rdata.Rdata):
    """AAAA record.

    @ivar address: an IPv6 address
    @type address: string (in the standard IPv6 format)"""

    __slots__ = ['address']

    def __init__(self, rdclass, rdtype, address):
        super(AAAA, self).__init__(rdclass, rdtype)
        # check that it's OK
        junk = dns.inet.inet_pton(dns.inet.AF_INET6, address)
        self.address = address

    def to_text(self, origin=None, relativize=True, **kw):
        return self.address

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_identifier()
        tok.get_eol()
        return cls(rdclass, rdtype, address)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(dns.inet.inet_pton(dns.inet.AF_INET6, self.address))

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        address = dns.inet.inet_ntop(dns.inet.AF_INET6,
                                     wire[current : current + rdlen])
        return cls(rdclass, rdtype, address)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        sa = dns.inet.inet_pton(dns.inet.AF_INET6, self.address)
        oa = dns.inet.inet_pton(dns.inet.AF_INET6, other.address)
        return cmp(sa, oa)

########NEW FILE########
__FILENAME__ = APL
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import struct

import dns.exception
import dns.inet
import dns.rdata
import dns.tokenizer

class APLItem(object):
    """An APL list item.

    @ivar family: the address family (IANA address family registry)
    @type family: int
    @ivar negation: is this item negated?
    @type negation: bool
    @ivar address: the address
    @type address: string
    @ivar prefix: the prefix length
    @type prefix: int
    """

    __slots__ = ['family', 'negation', 'address', 'prefix']

    def __init__(self, family, negation, address, prefix):
        self.family = family
        self.negation = negation
        self.address = address
        self.prefix = prefix

    def __str__(self):
        if self.negation:
            return "!%d:%s/%s" % (self.family, self.address, self.prefix)
        else:
            return "%d:%s/%s" % (self.family, self.address, self.prefix)

    def to_wire(self, file):
        if self.family == 1:
            address = dns.inet.inet_pton(dns.inet.AF_INET, self.address)
        elif self.family == 2:
            address = dns.inet.inet_pton(dns.inet.AF_INET6, self.address)
        else:
            address = self.address.decode('hex_codec')
        #
        # Truncate least significant zero bytes.
        #
        last = 0
        for i in xrange(len(address) - 1, -1, -1):
            if address[i] != chr(0):
                last = i + 1
                break
        address = address[0 : last]
        l = len(address)
        assert l < 128
        if self.negation:
            l |= 0x80
        header = struct.pack('!HBB', self.family, self.prefix, l)
        file.write(header)
        file.write(address)

class APL(dns.rdata.Rdata):
    """APL record.

    @ivar items: a list of APL items
    @type items: list of APL_Item
    @see: RFC 3123"""

    __slots__ = ['items']

    def __init__(self, rdclass, rdtype, items):
        super(APL, self).__init__(rdclass, rdtype)
        self.items = items

    def to_text(self, origin=None, relativize=True, **kw):
        return ' '.join(map(lambda x: str(x), self.items))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        items = []
        while 1:
            token = tok.get().unescape()
            if token.is_eol_or_eof():
                break
            item = token.value
            if item[0] == '!':
                negation = True
                item = item[1:]
            else:
                negation = False
            (family, rest) = item.split(':', 1)
            family = int(family)
            (address, prefix) = rest.split('/', 1)
            prefix = int(prefix)
            item = APLItem(family, negation, address, prefix)
            items.append(item)

        return cls(rdclass, rdtype, items)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        for item in self.items:
            item.to_wire(file)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        items = []
        while 1:
            if rdlen < 4:
                raise dns.exception.FormError
            header = struct.unpack('!HBB', wire[current : current + 4])
            afdlen = header[2]
            if afdlen > 127:
                negation = True
                afdlen -= 128
            else:
                negation = False
            current += 4
            rdlen -= 4
            if rdlen < afdlen:
                raise dns.exception.FormError
            address = wire[current : current + afdlen].unwrap()
            l = len(address)
            if header[0] == 1:
                if l < 4:
                    address += '\x00' * (4 - l)
                address = dns.inet.inet_ntop(dns.inet.AF_INET, address)
            elif header[0] == 2:
                if l < 16:
                    address += '\x00' * (16 - l)
                address = dns.inet.inet_ntop(dns.inet.AF_INET6, address)
            else:
                #
                # This isn't really right according to the RFC, but it
                # seems better than throwing an exception
                #
                address = address.encode('hex_codec')
            current += afdlen
            rdlen -= afdlen
            item = APLItem(header[0], negation, address, header[1])
            items.append(item)
            if rdlen == 0:
                break
        return cls(rdclass, rdtype, items)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        f = cStringIO.StringIO()
        self.to_wire(f)
        wire1 = f.getvalue()
        f.seek(0)
        f.truncate()
        other.to_wire(f)
        wire2 = f.getvalue()
        f.close()

        return cmp(wire1, wire2)

########NEW FILE########
__FILENAME__ = DHCID
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception

class DHCID(dns.rdata.Rdata):
    """DHCID record

    @ivar data: the data (the content of the RR is opaque as far as the
    DNS is concerned)
    @type data: string
    @see: RFC 4701"""

    __slots__ = ['data']

    def __init__(self, rdclass, rdtype, data):
        super(DHCID, self).__init__(rdclass, rdtype)
        self.data = data

    def to_text(self, origin=None, relativize=True, **kw):
        return dns.rdata._base64ify(self.data)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        b64 = ''.join(chunks)
        data = b64.decode('base64_codec')
        return cls(rdclass, rdtype, data)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(self.data)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        data = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, data)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.data, other.data)

########NEW FILE########
__FILENAME__ = IPSECKEY
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import struct

import dns.exception
import dns.inet
import dns.name

class IPSECKEY(dns.rdata.Rdata):
    """IPSECKEY record

    @ivar precedence: the precedence for this key data
    @type precedence: int
    @ivar gateway_type: the gateway type
    @type gateway_type: int
    @ivar algorithm: the algorithm to use
    @type algorithm: int
    @ivar gateway: the public key
    @type gateway: None, IPv4 address, IPV6 address, or domain name
    @ivar key: the public key
    @type key: string
    @see: RFC 4025"""

    __slots__ = ['precedence', 'gateway_type', 'algorithm', 'gateway', 'key']

    def __init__(self, rdclass, rdtype, precedence, gateway_type, algorithm,
                 gateway, key):
        super(IPSECKEY, self).__init__(rdclass, rdtype)
        if gateway_type == 0:
            if gateway != '.' and not gateway is None:
                raise SyntaxError('invalid gateway for gateway type 0')
            gateway = None
        elif gateway_type == 1:
            # check that it's OK
            junk = dns.inet.inet_pton(dns.inet.AF_INET, gateway)
        elif gateway_type == 2:
            # check that it's OK
            junk = dns.inet.inet_pton(dns.inet.AF_INET6, gateway)
        elif gateway_type == 3:
            pass
        else:
            raise SyntaxError('invalid IPSECKEY gateway type: %d' % gateway_type)
        self.precedence = precedence
        self.gateway_type = gateway_type
        self.algorithm = algorithm
        self.gateway = gateway
        self.key = key

    def to_text(self, origin=None, relativize=True, **kw):
        if self.gateway_type == 0:
            gateway = '.'
        elif self.gateway_type == 1:
            gateway = self.gateway
        elif self.gateway_type == 2:
            gateway = self.gateway
        elif self.gateway_type == 3:
            gateway = str(self.gateway.choose_relativity(origin, relativize))
        else:
            raise ValueError('invalid gateway type')
        return '%d %d %d %s %s' % (self.precedence, self.gateway_type,
                                   self.algorithm, gateway,
                                   dns.rdata._base64ify(self.key))

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        precedence = tok.get_uint8()
        gateway_type = tok.get_uint8()
        algorithm = tok.get_uint8()
        if gateway_type == 3:
            gateway = tok.get_name().choose_relativity(origin, relativize)
        else:
            gateway = tok.get_string()
        chunks = []
        while 1:
            t = tok.get().unescape()
            if t.is_eol_or_eof():
                break
            if not t.is_identifier():
                raise dns.exception.SyntaxError
            chunks.append(t.value)
        b64 = ''.join(chunks)
        key = b64.decode('base64_codec')
        return cls(rdclass, rdtype, precedence, gateway_type, algorithm,
                   gateway, key)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        header = struct.pack("!BBB", self.precedence, self.gateway_type,
                             self.algorithm)
        file.write(header)
        if self.gateway_type == 0:
            pass
        elif self.gateway_type == 1:
            file.write(dns.inet.inet_pton(dns.inet.AF_INET, self.gateway))
        elif self.gateway_type == 2:
            file.write(dns.inet.inet_pton(dns.inet.AF_INET6, self.gateway))
        elif self.gateway_type == 3:
            self.gateway.to_wire(file, None, origin)
        else:
            raise ValueError('invalid gateway type')
        file.write(self.key)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        if rdlen < 3:
            raise dns.exception.FormError
        header = struct.unpack('!BBB', wire[current : current + 3])
        gateway_type = header[1]
        current += 3
        rdlen -= 3
        if gateway_type == 0:
            gateway = None
        elif gateway_type == 1:
            gateway = dns.inet.inet_ntop(dns.inet.AF_INET,
                                         wire[current : current + 4])
            current += 4
            rdlen -= 4
        elif gateway_type == 2:
            gateway = dns.inet.inet_ntop(dns.inet.AF_INET6,
                                         wire[current : current + 16])
            current += 16
            rdlen -= 16
        elif gateway_type == 3:
            (gateway, cused) = dns.name.from_wire(wire[: current + rdlen],
                                                  current)
            current += cused
            rdlen -= cused
        else:
            raise dns.exception.FormError('invalid IPSECKEY gateway type')
        key = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, header[0], gateway_type, header[2],
                   gateway, key)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        f = cStringIO.StringIO()
        self.to_wire(f)
        wire1 = f.getvalue()
        f.seek(0)
        f.truncate()
        other.to_wire(f)
        wire2 = f.getvalue()
        f.close()

        return cmp(wire1, wire2)

########NEW FILE########
__FILENAME__ = KX
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.mxbase

class KX(dns.rdtypes.mxbase.UncompressedMX):
    """KX record"""
    pass

########NEW FILE########
__FILENAME__ = NAPTR
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.exception
import dns.name
import dns.rdata

def _write_string(file, s):
    l = len(s)
    assert l < 256
    byte = chr(l)
    file.write(byte)
    file.write(s)

class NAPTR(dns.rdata.Rdata):
    """NAPTR record

    @ivar order: order
    @type order: int
    @ivar preference: preference
    @type preference: int
    @ivar flags: flags
    @type flags: string
    @ivar service: service
    @type service: string
    @ivar regexp: regular expression
    @type regexp: string
    @ivar replacement: replacement name
    @type replacement: dns.name.Name object
    @see: RFC 3403"""

    __slots__ = ['order', 'preference', 'flags', 'service', 'regexp',
                 'replacement']

    def __init__(self, rdclass, rdtype, order, preference, flags, service,
                 regexp, replacement):
        super(NAPTR, self).__init__(rdclass, rdtype)
        self.order = order
        self.preference = preference
        self.flags = flags
        self.service = service
        self.regexp = regexp
        self.replacement = replacement

    def to_text(self, origin=None, relativize=True, **kw):
        replacement = self.replacement.choose_relativity(origin, relativize)
        return '%d %d "%s" "%s" "%s" %s' % \
               (self.order, self.preference,
                dns.rdata._escapify(self.flags),
                dns.rdata._escapify(self.service),
                dns.rdata._escapify(self.regexp),
                self.replacement)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        order = tok.get_uint16()
        preference = tok.get_uint16()
        flags = tok.get_string()
        service = tok.get_string()
        regexp = tok.get_string()
        replacement = tok.get_name()
        replacement = replacement.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, order, preference, flags, service,
                   regexp, replacement)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        two_ints = struct.pack("!HH", self.order, self.preference)
        file.write(two_ints)
        _write_string(file, self.flags)
        _write_string(file, self.service)
        _write_string(file, self.regexp)
        self.replacement.to_wire(file, compress, origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (order, preference) = struct.unpack('!HH', wire[current : current + 4])
        current += 4
        rdlen -= 4
        strings = []
        for i in xrange(3):
            l = ord(wire[current])
            current += 1
            rdlen -= 1
            if l > rdlen or rdlen < 0:
                raise dns.exception.FormError
            s = wire[current : current + l].unwrap()
            current += l
            rdlen -= l
            strings.append(s)
        (replacement, cused) = dns.name.from_wire(wire[: current + rdlen],
                                                  current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            replacement = replacement.relativize(origin)
        return cls(rdclass, rdtype, order, preference, strings[0], strings[1],
                   strings[2], replacement)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.replacement = self.replacement.choose_relativity(origin,
                                                              relativize)

    def _cmp(self, other):
        sp = struct.pack("!HH", self.order, self.preference)
        op = struct.pack("!HH", other.order, other.preference)
        v = cmp(sp, op)
        if v == 0:
            v = cmp(self.flags, other.flags)
            if v == 0:
                v = cmp(self.service, other.service)
                if v == 0:
                    v = cmp(self.regexp, other.regexp)
                    if v == 0:
                        v = cmp(self.replacement, other.replacement)
        return v

########NEW FILE########
__FILENAME__ = NSAP
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.exception
import dns.rdata
import dns.tokenizer

class NSAP(dns.rdata.Rdata):
    """NSAP record.

    @ivar address: a NASP
    @type address: string
    @see: RFC 1706"""

    __slots__ = ['address']

    def __init__(self, rdclass, rdtype, address):
        super(NSAP, self).__init__(rdclass, rdtype)
        self.address = address

    def to_text(self, origin=None, relativize=True, **kw):
        return "0x%s" % self.address.encode('hex_codec')

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_string()
        t = tok.get_eol()
        if address[0:2] != '0x':
            raise dns.exception.SyntaxError('string does not start with 0x')
        address = address[2:].replace('.', '')
        if len(address) % 2 != 0:
            raise dns.exception.SyntaxError('hexstring has odd length')
        address = address.decode('hex_codec')
        return cls(rdclass, rdtype, address)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(self.address)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        address = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, address)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.address, other.address)

########NEW FILE########
__FILENAME__ = NSAP_PTR
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import dns.rdtypes.nsbase

class NSAP_PTR(dns.rdtypes.nsbase.UncompressedNS):
    """NSAP-PTR record"""
    pass

########NEW FILE########
__FILENAME__ = PX
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.exception
import dns.rdata
import dns.name

class PX(dns.rdata.Rdata):
    """PX record.

    @ivar preference: the preference value
    @type preference: int
    @ivar map822: the map822 name
    @type map822: dns.name.Name object
    @ivar mapx400: the mapx400 name
    @type mapx400: dns.name.Name object
    @see: RFC 2163"""

    __slots__ = ['preference', 'map822', 'mapx400']

    def __init__(self, rdclass, rdtype, preference, map822, mapx400):
        super(PX, self).__init__(rdclass, rdtype)
        self.preference = preference
        self.map822 = map822
        self.mapx400 = mapx400

    def to_text(self, origin=None, relativize=True, **kw):
        map822 = self.map822.choose_relativity(origin, relativize)
        mapx400 = self.mapx400.choose_relativity(origin, relativize)
        return '%d %s %s' % (self.preference, map822, mapx400)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        preference = tok.get_uint16()
        map822 = tok.get_name()
        map822 = map822.choose_relativity(origin, relativize)
        mapx400 = tok.get_name(None)
        mapx400 = mapx400.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, preference, map822, mapx400)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        pref = struct.pack("!H", self.preference)
        file.write(pref)
        self.map822.to_wire(file, None, origin)
        self.mapx400.to_wire(file, None, origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (preference, ) = struct.unpack('!H', wire[current : current + 2])
        current += 2
        rdlen -= 2
        (map822, cused) = dns.name.from_wire(wire[: current + rdlen],
                                               current)
        if cused > rdlen:
            raise dns.exception.FormError
        current += cused
        rdlen -= cused
        if not origin is None:
            map822 = map822.relativize(origin)
        (mapx400, cused) = dns.name.from_wire(wire[: current + rdlen],
                                              current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            mapx400 = mapx400.relativize(origin)
        return cls(rdclass, rdtype, preference, map822, mapx400)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.map822 = self.map822.choose_relativity(origin, relativize)
        self.mapx400 = self.mapx400.choose_relativity(origin, relativize)

    def _cmp(self, other):
        sp = struct.pack("!H", self.preference)
        op = struct.pack("!H", other.preference)
        v = cmp(sp, op)
        if v == 0:
            v = cmp(self.map822, other.map822)
            if v == 0:
                v = cmp(self.mapx400, other.mapx400)
        return v

########NEW FILE########
__FILENAME__ = SRV
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import struct

import dns.exception
import dns.rdata
import dns.name

class SRV(dns.rdata.Rdata):
    """SRV record

    @ivar priority: the priority
    @type priority: int
    @ivar weight: the weight
    @type weight: int
    @ivar port: the port of the service
    @type port: int
    @ivar target: the target host
    @type target: dns.name.Name object
    @see: RFC 2782"""

    __slots__ = ['priority', 'weight', 'port', 'target']

    def __init__(self, rdclass, rdtype, priority, weight, port, target):
        super(SRV, self).__init__(rdclass, rdtype)
        self.priority = priority
        self.weight = weight
        self.port = port
        self.target = target

    def to_text(self, origin=None, relativize=True, **kw):
        target = self.target.choose_relativity(origin, relativize)
        return '%d %d %d %s' % (self.priority, self.weight, self.port,
                                target)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        priority = tok.get_uint16()
        weight = tok.get_uint16()
        port = tok.get_uint16()
        target = tok.get_name(None)
        target = target.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, priority, weight, port, target)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        three_ints = struct.pack("!HHH", self.priority, self.weight, self.port)
        file.write(three_ints)
        self.target.to_wire(file, compress, origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (priority, weight, port) = struct.unpack('!HHH',
                                                 wire[current : current + 6])
        current += 6
        rdlen -= 6
        (target, cused) = dns.name.from_wire(wire[: current + rdlen],
                                             current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            target = target.relativize(origin)
        return cls(rdclass, rdtype, priority, weight, port, target)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.target = self.target.choose_relativity(origin, relativize)

    def _cmp(self, other):
        sp = struct.pack("!HHH", self.priority, self.weight, self.port)
        op = struct.pack("!HHH", other.priority, other.weight, other.port)
        v = cmp(sp, op)
        if v == 0:
            v = cmp(self.target, other.target)
        return v

########NEW FILE########
__FILENAME__ = WKS
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import socket
import struct

import dns.ipv4
import dns.rdata

_proto_tcp = socket.getprotobyname('tcp')
_proto_udp = socket.getprotobyname('udp')

class WKS(dns.rdata.Rdata):
    """WKS record

    @ivar address: the address
    @type address: string
    @ivar protocol: the protocol
    @type protocol: int
    @ivar bitmap: the bitmap
    @type bitmap: string
    @see: RFC 1035"""

    __slots__ = ['address', 'protocol', 'bitmap']

    def __init__(self, rdclass, rdtype, address, protocol, bitmap):
        super(WKS, self).__init__(rdclass, rdtype)
        self.address = address
        self.protocol = protocol
        self.bitmap = bitmap

    def to_text(self, origin=None, relativize=True, **kw):
        bits = []
        for i in xrange(0, len(self.bitmap)):
            byte = ord(self.bitmap[i])
            for j in xrange(0, 8):
                if byte & (0x80 >> j):
                    bits.append(str(i * 8 + j))
        text = ' '.join(bits)
        return '%s %d %s' % (self.address, self.protocol, text)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        address = tok.get_string()
        protocol = tok.get_string()
        if protocol.isdigit():
            protocol = int(protocol)
        else:
            protocol = socket.getprotobyname(protocol)
        bitmap = []
        while 1:
            token = tok.get().unescape()
            if token.is_eol_or_eof():
                break
            if token.value.isdigit():
                serv = int(token.value)
            else:
                if protocol != _proto_udp and protocol != _proto_tcp:
                    raise NotImplementedError("protocol must be TCP or UDP")
                if protocol == _proto_udp:
                    protocol_text = "udp"
                else:
                    protocol_text = "tcp"
                serv = socket.getservbyname(token.value, protocol_text)
            i = serv // 8
            l = len(bitmap)
            if l < i + 1:
                for j in xrange(l, i + 1):
                    bitmap.append('\x00')
            bitmap[i] = chr(ord(bitmap[i]) | (0x80 >> (serv % 8)))
        bitmap = dns.rdata._truncate_bitmap(bitmap)
        return cls(rdclass, rdtype, address, protocol, bitmap)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        file.write(dns.ipv4.inet_aton(self.address))
        protocol = struct.pack('!B', self.protocol)
        file.write(protocol)
        file.write(self.bitmap)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        address = dns.ipv4.inet_ntoa(wire[current : current + 4])
        protocol, = struct.unpack('!B', wire[current + 4 : current + 5])
        current += 5
        rdlen -= 5
        bitmap = wire[current : current + rdlen].unwrap()
        return cls(rdclass, rdtype, address, protocol, bitmap)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        sa = dns.ipv4.inet_aton(self.address)
        oa = dns.ipv4.inet_aton(other.address)
        v = cmp(sa, oa)
        if v == 0:
            sp = struct.pack('!B', self.protocol)
            op = struct.pack('!B', other.protocol)
            v = cmp(sp, op)
            if v == 0:
                v = cmp(self.bitmap, other.bitmap)
        return v

########NEW FILE########
__FILENAME__ = mxbase
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""MX-like base classes."""

import cStringIO
import struct

import dns.exception
import dns.rdata
import dns.name

class MXBase(dns.rdata.Rdata):
    """Base class for rdata that is like an MX record.

    @ivar preference: the preference value
    @type preference: int
    @ivar exchange: the exchange name
    @type exchange: dns.name.Name object"""

    __slots__ = ['preference', 'exchange']

    def __init__(self, rdclass, rdtype, preference, exchange):
        super(MXBase, self).__init__(rdclass, rdtype)
        self.preference = preference
        self.exchange = exchange

    def to_text(self, origin=None, relativize=True, **kw):
        exchange = self.exchange.choose_relativity(origin, relativize)
        return '%d %s' % (self.preference, exchange)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        preference = tok.get_uint16()
        exchange = tok.get_name()
        exchange = exchange.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, preference, exchange)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        pref = struct.pack("!H", self.preference)
        file.write(pref)
        self.exchange.to_wire(file, compress, origin)

    def to_digestable(self, origin = None):
        return struct.pack("!H", self.preference) + \
            self.exchange.to_digestable(origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (preference, ) = struct.unpack('!H', wire[current : current + 2])
        current += 2
        rdlen -= 2
        (exchange, cused) = dns.name.from_wire(wire[: current + rdlen],
                                               current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            exchange = exchange.relativize(origin)
        return cls(rdclass, rdtype, preference, exchange)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.exchange = self.exchange.choose_relativity(origin, relativize)

    def _cmp(self, other):
        sp = struct.pack("!H", self.preference)
        op = struct.pack("!H", other.preference)
        v = cmp(sp, op)
        if v == 0:
            v = cmp(self.exchange, other.exchange)
        return v

class UncompressedMX(MXBase):
    """Base class for rdata that is like an MX record, but whose name
    is not compressed when converted to DNS wire format, and whose
    digestable form is not downcased."""

    def to_wire(self, file, compress = None, origin = None):
        super(UncompressedMX, self).to_wire(file, None, origin)

    def to_digestable(self, origin = None):
        f = cStringIO.StringIO()
        self.to_wire(f, None, origin)
        return f.getvalue()

class UncompressedDowncasingMX(MXBase):
    """Base class for rdata that is like an MX record, but whose name
    is not compressed when convert to DNS wire format."""

    def to_wire(self, file, compress = None, origin = None):
        super(UncompressedDowncasingMX, self).to_wire(file, None, origin)

########NEW FILE########
__FILENAME__ = nsbase
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""NS-like base classes."""

import cStringIO

import dns.exception
import dns.rdata
import dns.name

class NSBase(dns.rdata.Rdata):
    """Base class for rdata that is like an NS record.

    @ivar target: the target name of the rdata
    @type target: dns.name.Name object"""

    __slots__ = ['target']

    def __init__(self, rdclass, rdtype, target):
        super(NSBase, self).__init__(rdclass, rdtype)
        self.target = target

    def to_text(self, origin=None, relativize=True, **kw):
        target = self.target.choose_relativity(origin, relativize)
        return str(target)

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        target = tok.get_name()
        target = target.choose_relativity(origin, relativize)
        tok.get_eol()
        return cls(rdclass, rdtype, target)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        self.target.to_wire(file, compress, origin)

    def to_digestable(self, origin = None):
        return self.target.to_digestable(origin)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        (target, cused) = dns.name.from_wire(wire[: current + rdlen],
                                             current)
        if cused != rdlen:
            raise dns.exception.FormError
        if not origin is None:
            target = target.relativize(origin)
        return cls(rdclass, rdtype, target)

    from_wire = classmethod(from_wire)

    def choose_relativity(self, origin = None, relativize = True):
        self.target = self.target.choose_relativity(origin, relativize)

    def _cmp(self, other):
        return cmp(self.target, other.target)

class UncompressedNS(NSBase):
    """Base class for rdata that is like an NS record, but whose name
    is not compressed when convert to DNS wire format, and whose
    digestable form is not downcased."""

    def to_wire(self, file, compress = None, origin = None):
        super(UncompressedNS, self).to_wire(file, None, origin)

    def to_digestable(self, origin = None):
        f = cStringIO.StringIO()
        self.to_wire(f, None, origin)
        return f.getvalue()

########NEW FILE########
__FILENAME__ = txtbase
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""TXT-like base class."""

import dns.exception
import dns.rdata
import dns.tokenizer

class TXTBase(dns.rdata.Rdata):
    """Base class for rdata that is like a TXT record

    @ivar strings: the text strings
    @type strings: list of string
    @see: RFC 1035"""

    __slots__ = ['strings']

    def __init__(self, rdclass, rdtype, strings):
        super(TXTBase, self).__init__(rdclass, rdtype)
        if isinstance(strings, str):
            strings = [ strings ]
        self.strings = strings[:]

    def to_text(self, origin=None, relativize=True, **kw):
        txt = ''
        prefix = ''
        for s in self.strings:
            txt += '%s"%s"' % (prefix, dns.rdata._escapify(s))
            prefix = ' '
        return txt

    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):
        strings = []
        while 1:
            token = tok.get().unescape()
            if token.is_eol_or_eof():
                break
            if not (token.is_quoted_string() or token.is_identifier()):
                raise dns.exception.SyntaxError("expected a string")
            if len(token.value) > 255:
                raise dns.exception.SyntaxError("string too long")
            strings.append(token.value)
        if len(strings) == 0:
            raise dns.exception.UnexpectedEnd
        return cls(rdclass, rdtype, strings)

    from_text = classmethod(from_text)

    def to_wire(self, file, compress = None, origin = None):
        for s in self.strings:
            l = len(s)
            assert l < 256
            byte = chr(l)
            file.write(byte)
            file.write(s)

    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):
        strings = []
        while rdlen > 0:
            l = ord(wire[current])
            current += 1
            rdlen -= 1
            if l > rdlen:
                raise dns.exception.FormError
            s = wire[current : current + l].unwrap()
            current += l
            rdlen -= l
            strings.append(s)
        return cls(rdclass, rdtype, strings)

    from_wire = classmethod(from_wire)

    def _cmp(self, other):
        return cmp(self.strings, other.strings)

########NEW FILE########
__FILENAME__ = renderer
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Help for building DNS wire format messages"""

import cStringIO
import struct
import random
import time

import dns.exception
import dns.tsig

QUESTION = 0
ANSWER = 1
AUTHORITY = 2
ADDITIONAL = 3

class Renderer(object):
    """Helper class for building DNS wire-format messages.

    Most applications can use the higher-level L{dns.message.Message}
    class and its to_wire() method to generate wire-format messages.
    This class is for those applications which need finer control
    over the generation of messages.

    Typical use::

        r = dns.renderer.Renderer(id=1, flags=0x80, max_size=512)
        r.add_question(qname, qtype, qclass)
        r.add_rrset(dns.renderer.ANSWER, rrset_1)
        r.add_rrset(dns.renderer.ANSWER, rrset_2)
        r.add_rrset(dns.renderer.AUTHORITY, ns_rrset)
        r.add_edns(0, 0, 4096)
        r.add_rrset(dns.renderer.ADDTIONAL, ad_rrset_1)
        r.add_rrset(dns.renderer.ADDTIONAL, ad_rrset_2)
        r.write_header()
        r.add_tsig(keyname, secret, 300, 1, 0, '', request_mac)
        wire = r.get_wire()

    @ivar output: where rendering is written
    @type output: cStringIO.StringIO object
    @ivar id: the message id
    @type id: int
    @ivar flags: the message flags
    @type flags: int
    @ivar max_size: the maximum size of the message
    @type max_size: int
    @ivar origin: the origin to use when rendering relative names
    @type origin: dns.name.Name object
    @ivar compress: the compression table
    @type compress: dict
    @ivar section: the section currently being rendered
    @type section: int (dns.renderer.QUESTION, dns.renderer.ANSWER,
    dns.renderer.AUTHORITY, or dns.renderer.ADDITIONAL)
    @ivar counts: list of the number of RRs in each section
    @type counts: int list of length 4
    @ivar mac: the MAC of the rendered message (if TSIG was used)
    @type mac: string
    """

    def __init__(self, id=None, flags=0, max_size=65535, origin=None):
        """Initialize a new renderer.

        @param id: the message id
        @type id: int
        @param flags: the DNS message flags
        @type flags: int
        @param max_size: the maximum message size; the default is 65535.
        If rendering results in a message greater than I{max_size},
        then L{dns.exception.TooBig} will be raised.
        @type max_size: int
        @param origin: the origin to use when rendering relative names
        @type origin: dns.name.Namem or None.
        """

        self.output = cStringIO.StringIO()
        if id is None:
            self.id = random.randint(0, 65535)
        else:
            self.id = id
        self.flags = flags
        self.max_size = max_size
        self.origin = origin
        self.compress = {}
        self.section = QUESTION
        self.counts = [0, 0, 0, 0]
        self.output.write('\x00' * 12)
        self.mac = ''

    def _rollback(self, where):
        """Truncate the output buffer at offset I{where}, and remove any
        compression table entries that pointed beyond the truncation
        point.

        @param where: the offset
        @type where: int
        """

        self.output.seek(where)
        self.output.truncate()
        keys_to_delete = []
        for k, v in self.compress.iteritems():
            if v >= where:
                keys_to_delete.append(k)
        for k in keys_to_delete:
            del self.compress[k]

    def _set_section(self, section):
        """Set the renderer's current section.

        Sections must be rendered order: QUESTION, ANSWER, AUTHORITY,
        ADDITIONAL.  Sections may be empty.

        @param section: the section
        @type section: int
        @raises dns.exception.FormError: an attempt was made to set
        a section value less than the current section.
        """

        if self.section != section:
            if self.section > section:
                raise dns.exception.FormError
            self.section = section

    def add_question(self, qname, rdtype, rdclass=dns.rdataclass.IN):
        """Add a question to the message.

        @param qname: the question name
        @type qname: dns.name.Name
        @param rdtype: the question rdata type
        @type rdtype: int
        @param rdclass: the question rdata class
        @type rdclass: int
        """

        self._set_section(QUESTION)
        before = self.output.tell()
        qname.to_wire(self.output, self.compress, self.origin)
        self.output.write(struct.pack("!HH", rdtype, rdclass))
        after = self.output.tell()
        if after >= self.max_size:
            self._rollback(before)
            raise dns.exception.TooBig
        self.counts[QUESTION] += 1

    def add_rrset(self, section, rrset, **kw):
        """Add the rrset to the specified section.

        Any keyword arguments are passed on to the rdataset's to_wire()
        routine.

        @param section: the section
        @type section: int
        @param rrset: the rrset
        @type rrset: dns.rrset.RRset object
        """

        self._set_section(section)
        before = self.output.tell()
        n = rrset.to_wire(self.output, self.compress, self.origin, **kw)
        after = self.output.tell()
        if after >= self.max_size:
            self._rollback(before)
            raise dns.exception.TooBig
        self.counts[section] += n

    def add_rdataset(self, section, name, rdataset, **kw):
        """Add the rdataset to the specified section, using the specified
        name as the owner name.

        Any keyword arguments are passed on to the rdataset's to_wire()
        routine.

        @param section: the section
        @type section: int
        @param name: the owner name
        @type name: dns.name.Name object
        @param rdataset: the rdataset
        @type rdataset: dns.rdataset.Rdataset object
        """

        self._set_section(section)
        before = self.output.tell()
        n = rdataset.to_wire(name, self.output, self.compress, self.origin,
                             **kw)
        after = self.output.tell()
        if after >= self.max_size:
            self._rollback(before)
            raise dns.exception.TooBig
        self.counts[section] += n

    def add_edns(self, edns, ednsflags, payload, options=None):
        """Add an EDNS OPT record to the message.

        @param edns: The EDNS level to use.
        @type edns: int
        @param ednsflags: EDNS flag values.
        @type ednsflags: int
        @param payload: The EDNS sender's payload field, which is the maximum
        size of UDP datagram the sender can handle.
        @type payload: int
        @param options: The EDNS options list
        @type options: list of dns.edns.Option instances
        @see: RFC 2671
        """

        # make sure the EDNS version in ednsflags agrees with edns
        ednsflags &= 0xFF00FFFFL
        ednsflags |= (edns << 16)
        self._set_section(ADDITIONAL)
        before = self.output.tell()
        self.output.write(struct.pack('!BHHIH', 0, dns.rdatatype.OPT, payload,
                                      ednsflags, 0))
        if not options is None:
            lstart = self.output.tell()
            for opt in options:
                stuff = struct.pack("!HH", opt.otype, 0)
                self.output.write(stuff)
                start = self.output.tell()
                opt.to_wire(self.output)
                end = self.output.tell()
                assert end - start < 65536
                self.output.seek(start - 2)
                stuff = struct.pack("!H", end - start)
                self.output.write(stuff)
                self.output.seek(0, 2)
            lend = self.output.tell()
            assert lend - lstart < 65536
            self.output.seek(lstart - 2)
            stuff = struct.pack("!H", lend - lstart)
            self.output.write(stuff)
            self.output.seek(0, 2)
        after = self.output.tell()
        if after >= self.max_size:
            self._rollback(before)
            raise dns.exception.TooBig
        self.counts[ADDITIONAL] += 1

    def add_tsig(self, keyname, secret, fudge, id, tsig_error, other_data,
                 request_mac, algorithm=dns.tsig.default_algorithm):
        """Add a TSIG signature to the message.

        @param keyname: the TSIG key name
        @type keyname: dns.name.Name object
        @param secret: the secret to use
        @type secret: string
        @param fudge: TSIG time fudge
        @type fudge: int
        @param id: the message id to encode in the tsig signature
        @type id: int
        @param tsig_error: TSIG error code; default is 0.
        @type tsig_error: int
        @param other_data: TSIG other data.
        @type other_data: string
        @param request_mac: This message is a response to the request which
        had the specified MAC.
        @type request_mac: string
        @param algorithm: the TSIG algorithm to use
        @type algorithm: dns.name.Name object
        """

        self._set_section(ADDITIONAL)
        before = self.output.tell()
        s = self.output.getvalue()
        (tsig_rdata, self.mac, ctx) = dns.tsig.sign(s,
                                                    keyname,
                                                    secret,
                                                    int(time.time()),
                                                    fudge,
                                                    id,
                                                    tsig_error,
                                                    other_data,
                                                    request_mac,
                                                    algorithm=algorithm)
        keyname.to_wire(self.output, self.compress, self.origin)
        self.output.write(struct.pack('!HHIH', dns.rdatatype.TSIG,
                                      dns.rdataclass.ANY, 0, 0))
        rdata_start = self.output.tell()
        self.output.write(tsig_rdata)
        after = self.output.tell()
        assert after - rdata_start < 65536
        if after >= self.max_size:
            self._rollback(before)
            raise dns.exception.TooBig
        self.output.seek(rdata_start - 2)
        self.output.write(struct.pack('!H', after - rdata_start))
        self.counts[ADDITIONAL] += 1
        self.output.seek(10)
        self.output.write(struct.pack('!H', self.counts[ADDITIONAL]))
        self.output.seek(0, 2)

    def write_header(self):
        """Write the DNS message header.

        Writing the DNS message header is done asfter all sections
        have been rendered, but before the optional TSIG signature
        is added.
        """

        self.output.seek(0)
        self.output.write(struct.pack('!HHHHHH', self.id, self.flags,
                                      self.counts[0], self.counts[1],
                                      self.counts[2], self.counts[3]))
        self.output.seek(0, 2)

    def get_wire(self):
        """Return the wire format message.

        @rtype: string
        """

        return self.output.getvalue()

########NEW FILE########
__FILENAME__ = resolver
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS stub resolver.

@var default_resolver: The default resolver object
@type default_resolver: dns.resolver.Resolver object"""

import socket
import sys
import os
import time

import dns.exception
import dns.message
import dns.name
import dns.query
import dns.rcode
import dns.rdataclass
import dns.rdatatype

if sys.platform == 'win32':
    import _winreg

class NXDOMAIN(dns.exception.DNSException):
    """The query name does not exist."""
    pass

# The definition of the Timeout exception has moved from here to the
# dns.exception module.  We keep dns.resolver.Timeout defined for
# backwards compatibility.

Timeout = dns.exception.Timeout

class NoAnswer(dns.exception.DNSException):
    """The response did not contain an answer to the question."""
    pass

class NoNameservers(dns.exception.DNSException):
    """No non-broken nameservers are available to answer the query."""
    pass

class NotAbsolute(dns.exception.DNSException):
    """Raised if an absolute domain name is required but a relative name
    was provided."""
    pass

class NoRootSOA(dns.exception.DNSException):
    """Raised if for some reason there is no SOA at the root name.
    This should never happen!"""
    pass

class NoMetaqueries(dns.exception.DNSException):
    """Metaqueries are not allowed."""
    pass


class Answer(object):
    """DNS stub resolver answer

    Instances of this class bundle up the result of a successful DNS
    resolution.

    For convenience, the answer object implements much of the sequence
    protocol, forwarding to its rrset.  E.g. "for a in answer" is
    equivalent to "for a in answer.rrset", "answer[i]" is equivalent
    to "answer.rrset[i]", and "answer[i:j]" is equivalent to
    "answer.rrset[i:j]".

    Note that CNAMEs or DNAMEs in the response may mean that answer
    node's name might not be the query name.

    @ivar qname: The query name
    @type qname: dns.name.Name object
    @ivar rdtype: The query type
    @type rdtype: int
    @ivar rdclass: The query class
    @type rdclass: int
    @ivar response: The response message
    @type response: dns.message.Message object
    @ivar rrset: The answer
    @type rrset: dns.rrset.RRset object
    @ivar expiration: The time when the answer expires
    @type expiration: float (seconds since the epoch)
    @ivar canonical_name: The canonical name of the query name
    @type canonical_name: dns.name.Name object
    """
    def __init__(self, qname, rdtype, rdclass, response,
                 raise_on_no_answer=True):
        self.qname = qname
        self.rdtype = rdtype
        self.rdclass = rdclass
        self.response = response
        min_ttl = -1
        rrset = None
        for count in xrange(0, 15):
            try:
                rrset = response.find_rrset(response.answer, qname,
                                            rdclass, rdtype)
                if min_ttl == -1 or rrset.ttl < min_ttl:
                    min_ttl = rrset.ttl
                break
            except KeyError:
                if rdtype != dns.rdatatype.CNAME:
                    try:
                        crrset = response.find_rrset(response.answer,
                                                     qname,
                                                     rdclass,
                                                     dns.rdatatype.CNAME)
                        if min_ttl == -1 or crrset.ttl < min_ttl:
                            min_ttl = crrset.ttl
                        for rd in crrset:
                            qname = rd.target
                            break
                        continue
                    except KeyError:
                        if raise_on_no_answer:
                            raise NoAnswer("DNS response had no answer")
                if raise_on_no_answer:
                    raise NoAnswer("DNS response had no answer")
        if rrset is None and raise_on_no_answer:
            raise NoAnswer("DNS response had no answer")
        self.canonical_name = qname
        self.rrset = rrset
        if rrset is None:
            while 1:
                # Look for a SOA RR whose owner name is a superdomain
                # of qname.
                try:
                    srrset = response.find_rrset(response.authority, qname,
                                                rdclass, dns.rdatatype.SOA)
                    if min_ttl == -1 or srrset.ttl < min_ttl:
                        min_ttl = srrset.ttl
                    if srrset[0].minimum < min_ttl:
                        min_ttl = srrset[0].minimum
                    break
                except KeyError:
                    try:
                        qname = qname.parent()
                    except dns.name.NoParent:
                        break
        self.expiration = time.time() + min_ttl

    def __str__ (self):
        return str(self.rrset)

    def __getattr__(self, attr):
        if attr == 'name':
            return self.rrset.name
        elif attr == 'ttl':
            return self.rrset.ttl
        elif attr == 'covers':
            return self.rrset.covers
        elif attr == 'rdclass':
            return self.rrset.rdclass
        elif attr == 'rdtype':
            return self.rrset.rdtype
        else:
            raise AttributeError(attr)

    def __len__(self):
        return len(self.rrset)

    def __iter__(self):
        return iter(self.rrset)

    def __getitem__(self, i):
        return self.rrset[i]

    def __delitem__(self, i):
        del self.rrset[i]

    def __getslice__(self, i, j):
        return self.rrset[i:j]

    def __delslice__(self, i, j):
        del self.rrset[i:j]


class Cache(object):
    """Simple DNS answer cache.

    @ivar data: A dictionary of cached data
    @type data: dict
    @ivar cleaning_interval: The number of seconds between cleanings.  The
    default is 300 (5 minutes).
    @type cleaning_interval: float
    @ivar next_cleaning: The time the cache should next be cleaned (in seconds
    since the epoch.)
    @type next_cleaning: float
    """

    def __init__(self, cleaning_interval=300.0):
        """Initialize a DNS cache.

        @param cleaning_interval: the number of seconds between periodic
        cleanings.  The default is 300.0
        @type cleaning_interval: float.
        """

        self.data = {}
        self.cleaning_interval = cleaning_interval
        self.next_cleaning = time.time() + self.cleaning_interval

    def maybe_clean(self):
        """Clean the cache if it's time to do so."""

        now = time.time()
        if self.next_cleaning <= now:
            keys_to_delete = []
            for (k, v) in self.data.iteritems():
                if v.expiration <= now:
                    keys_to_delete.append(k)
            for k in keys_to_delete:
                del self.data[k]
            now = time.time()
            self.next_cleaning = now + self.cleaning_interval

    def get(self, key):
        """Get the answer associated with I{key}.  Returns None if
        no answer is cached for the key.
        @param key: the key
        @type key: (dns.name.Name, int, int) tuple whose values are the
        query name, rdtype, and rdclass.
        @rtype: dns.resolver.Answer object or None
        """

        self.maybe_clean()
        v = self.data.get(key)
        if v is None or v.expiration <= time.time():
            return None
        return v

    def put(self, key, value):
        """Associate key and value in the cache.
        @param key: the key
        @type key: (dns.name.Name, int, int) tuple whose values are the
        query name, rdtype, and rdclass.
        @param value: The answer being cached
        @type value: dns.resolver.Answer object
        """

        self.maybe_clean()
        self.data[key] = value

    def flush(self, key=None):
        """Flush the cache.

        If I{key} is specified, only that item is flushed.  Otherwise
        the entire cache is flushed.

        @param key: the key to flush
        @type key: (dns.name.Name, int, int) tuple or None
        """

        if not key is None:
            if key in self.data:
                del self.data[key]
        else:
            self.data = {}
            self.next_cleaning = time.time() + self.cleaning_interval


class Resolver(object):
    """DNS stub resolver

    @ivar domain: The domain of this host
    @type domain: dns.name.Name object
    @ivar nameservers: A list of nameservers to query.  Each nameserver is
    a string which contains the IP address of a nameserver.
    @type nameservers: list of strings
    @ivar search: The search list.  If the query name is a relative name,
    the resolver will construct an absolute query name by appending the search
    names one by one to the query name.
    @type search: list of dns.name.Name objects
    @ivar port: The port to which to send queries.  The default is 53.
    @type port: int
    @ivar timeout: The number of seconds to wait for a response from a
    server, before timing out.
    @type timeout: float
    @ivar lifetime: The total number of seconds to spend trying to get an
    answer to the question.  If the lifetime expires, a Timeout exception
    will occur.
    @type lifetime: float
    @ivar keyring: The TSIG keyring to use.  The default is None.
    @type keyring: dict
    @ivar keyname: The TSIG keyname to use.  The default is None.
    @type keyname: dns.name.Name object
    @ivar keyalgorithm: The TSIG key algorithm to use.  The default is
    dns.tsig.default_algorithm.
    @type keyalgorithm: string
    @ivar edns: The EDNS level to use.  The default is -1, no Edns.
    @type edns: int
    @ivar ednsflags: The EDNS flags
    @type ednsflags: int
    @ivar payload: The EDNS payload size.  The default is 0.
    @type payload: int
    @ivar cache: The cache to use.  The default is None.
    @type cache: dns.resolver.Cache object
    """
    def __init__(self, filename='/etc/resolv.conf', configure=True):
        """Initialize a resolver instance.

        @param filename: The filename of a configuration file in
        standard /etc/resolv.conf format.  This parameter is meaningful
        only when I{configure} is true and the platform is POSIX.
        @type filename: string or file object
        @param configure: If True (the default), the resolver instance
        is configured in the normal fashion for the operating system
        the resolver is running on.  (I.e. a /etc/resolv.conf file on
        POSIX systems and from the registry on Windows systems.)
        @type configure: bool"""

        self.reset()
        if configure:
            if sys.platform == 'win32':
                self.read_registry()
            elif filename:
                self.read_resolv_conf(filename)
                self.read_local_hosts()
        if len(self.search) == 0:
            self.search.add(self.domain)

    def reset(self):
        """Reset all resolver configuration to the defaults."""
        self.domain = \
            dns.name.Name(dns.name.from_text(socket.gethostname())[1:])
        if len(self.domain) == 0:
            self.domain = dns.name.root
        self.nameservers = []
        self.localhosts = set([
          'localhost',
          'loopback',
          '127.0.0.1',
          '0.0.0.0',
          '::1',
          'ip6-localhost',
          'ip6-loopback',
        ])
        # connected and active network interfaces
        self.interfaces = set()
        self.search = set()
        self.search_patterns = ['www.%s.com', 'www.%s.org', 'www.%s.net', ]
        self.port = 53
        self.timeout = 2.0
        self.lifetime = 30.0
        self.keyring = None
        self.keyname = None
        self.keyalgorithm = dns.tsig.default_algorithm
        self.edns = -1
        self.ednsflags = 0
        self.payload = 0
        self.cache = None

    def read_resolv_conf(self, f):
        """Process f as a file in the /etc/resolv.conf format.  If f is
        a string, it is used as the name of the file to open; otherwise it
        is treated as the file itself."""
        if isinstance(f, basestring):
            try:
                f = open(f, 'r')
            except IOError:
                # /etc/resolv.conf doesn't exist, can't be read, etc.
                # We'll just use the default resolver configuration.
                self.nameservers = ['127.0.0.1']
                return
            want_close = True
        else:
            want_close = False
        try:
            for l in f:
                l = l.strip()
                if len(l) == 0 or l[0] == '#' or l[0] == ';':
                    continue
                tokens = l.split()
                if len(tokens) < 2:
                    continue
                if tokens[0] == 'nameserver':
                    self.nameservers.append(tokens[1])
                elif tokens[0] == 'domain':
                    self.domain = dns.name.from_text(tokens[1])
                elif tokens[0] == 'search':
                    for suffix in tokens[1:]:
                        self.search.add(dns.name.from_text(suffix))
        finally:
            if want_close:
                f.close()
        if len(self.nameservers) == 0:
            self.nameservers.append('127.0.0.1')

    def read_local_hosts (self):
        self.add_addrinfo(socket.gethostname())
        # add system specific hosts for all enabled interfaces
        self.add_addrinfo('localhost', interface=True)
        for addr in self.read_local_ifaddrs():
            self.add_addrinfo(addr, interface=True)

    def read_local_ifaddrs (self):
        """
        IP addresses for all active interfaces.
        @return: list of IP addresses
        @rtype: list of strings
        """
        if os.name != 'posix':
            # only POSIX is supported right now
            return []
        try:
            from linkcheck.network import IfConfig
        except ImportError:
            return []
        ifaddrs = []
        ifc = IfConfig()
        for iface in ifc.getInterfaceList(flags=IfConfig.IFF_UP):
            addr = ifc.getAddr(iface)
            if addr:
                ifaddrs.append(addr)
        return ifaddrs

    def add_addrinfo (self, host, interface=False):
        try:
            addrinfo = socket.gethostbyaddr(host)
        except socket.error:
            self.localhosts.add(host.lower())
            if interface:
                self.interfaces.add(host.lower())
            return
        self.localhosts.add(addrinfo[0].lower())
        if interface:
            self.interfaces.add(addrinfo[0].lower())
        for h in addrinfo[1]:
            self.localhosts.add(h.lower())
        for h in addrinfo[2]:
            self.localhosts.add(h.lower())

    def _determine_split_char(self, entry):

        # The windows registry irritatingly changes the list element
        # delimiter in between ' ' and ',' (and vice-versa) in various
        # versions of windows.

        if entry.find(' ') >= 0:
            split_char = ' '
        elif entry.find(',') >= 0:
            split_char = ','
        else:
            # probably a singleton; treat as a space-separated list.
            split_char = ' '
        return split_char

    def _config_win32_nameservers(self, nameservers):
        """Configure a NameServer registry entry."""
        # we call str() on nameservers to convert it from unicode to ascii
        nameservers = str(nameservers)
        split_char = self._determine_split_char(nameservers)
        ns_list = nameservers.split(split_char)
        for ns in ns_list:
            if not ns in self.nameservers:
                self.nameservers.append(ns)

    def _config_win32_domain(self, domain):
        """Configure a Domain registry entry."""
        # we call str() on domain to convert it from unicode to ascii
        self.domain = dns.name.from_text(str(domain))

    def _config_win32_search(self, search):
        """Configure a Search registry entry."""
        # we call str() on search to convert it from unicode to ascii
        search = str(search)
        split_char = self._determine_split_char(search)
        search_list = search.split(split_char)
        for s in search_list:
            if not s in self.search:
                self.search.add(dns.name.from_text(s))

    def _config_win32_add_ifaddr (self, key, name):
        """Add interface ip address to self.localhosts."""
        try:
            ip, rtype = _winreg.QueryValueEx(key, name)
            if isinstance(ip, basestring) and ip:
                ip = str(ip).lower()
                self.localhosts.add(ip)
                self.interfaces.add(ip)
        except WindowsError:
            pass

    def _config_win32_fromkey(self, key):
        """Extract DNS info from a registry key."""
        try:
            enable_dhcp, rtype = _winreg.QueryValueEx(key, 'EnableDHCP')
        except WindowsError:
            enable_dhcp = False
        if enable_dhcp:
            try:
                servers, rtype = _winreg.QueryValueEx(key, 'DhcpNameServer')
            except WindowsError:
                servers = None
            if servers:
                self._config_win32_nameservers(servers)
                try:
                    dom, rtype = _winreg.QueryValueEx(key, 'DhcpDomain')
                    if dom:
                        self._config_win32_domain(servers)
                except WindowsError:
                    pass
            self._config_win32_add_ifaddr(key, 'DhcpIPAddress')
        else:
            try:
                servers, rtype = _winreg.QueryValueEx(key, 'NameServer')
            except WindowsError:
                servers = None
            if servers:
                self._config_win32_nameservers(servers)
                try:
                    dom, rtype = _winreg.QueryValueEx(key, 'Domain')
                    if dom:
                        self._config_win32_domain(servers)
                except WindowsError:
                    pass
            self._config_win32_add_ifaddr(key, 'IPAddress')
        try:
            search, rtype = _winreg.QueryValueEx(key, 'SearchList')
        except WindowsError:
            search = None
        if search:
            self._config_win32_search(search)

    def read_registry(self):
        """Extract resolver configuration from the Windows registry."""
        lm = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
        want_scan = False
        try:
            try:
                # XP, 2000
                tcp_params = _winreg.OpenKey(lm,
                                             r'SYSTEM\CurrentControlSet'
                                             r'\Services\Tcpip\Parameters')
                want_scan = True
            except EnvironmentError:
                # ME
                tcp_params = _winreg.OpenKey(lm,
                                             r'SYSTEM\CurrentControlSet'
                                             r'\Services\VxD\MSTCP')
            try:
                self._config_win32_fromkey(tcp_params)
            finally:
                tcp_params.Close()
            if want_scan:
                interfaces = _winreg.OpenKey(lm,
                                             r'SYSTEM\CurrentControlSet'
                                             r'\Services\Tcpip\Parameters'
                                             r'\Interfaces')
                try:
                    i = 0
                    while True:
                        try:
                            guid = _winreg.EnumKey(interfaces, i)
                            i += 1
                            key = _winreg.OpenKey(interfaces, guid)
                            if not self._win32_is_nic_enabled(lm, guid, key):
                                continue
                            try:
                                self._config_win32_fromkey(key)
                            finally:
                                key.Close()
                        except EnvironmentError:
                            break
                finally:
                    interfaces.Close()
        finally:
            lm.Close()

    def _win32_is_nic_enabled(self, lm, guid, interface_key):
         # Look in the Windows Registry to determine whether the network
         # interface corresponding to the given guid is enabled.

         # (Code contributed by Paul Marks, thanks!)

         try:
             # This hard-coded location seems to be consistent, at least
             # from Windows 2000 through Vista.
             connection_key = _winreg.OpenKey(
                 lm,
                 r'SYSTEM\CurrentControlSet\Control\Network'
                 r'\{4D36E972-E325-11CE-BFC1-08002BE10318}'
                 r'\%s\Connection' % guid)

             try:
                 # The PnpInstanceID points to a key inside Enum
                 (pnp_id, ttype) = _winreg.QueryValueEx(
                     connection_key, 'PnpInstanceID')

                 if ttype != _winreg.REG_SZ:
                     raise ValueError

                 device_key = _winreg.OpenKey(
                     lm, r'SYSTEM\CurrentControlSet\Enum\%s' % pnp_id)

                 try:
                     # Get ConfigFlags for this device
                     (flags, ttype) = _winreg.QueryValueEx(
                         device_key, 'ConfigFlags')

                     if ttype != _winreg.REG_DWORD:
                         raise ValueError

                     # Based on experimentation, bit 0x1 indicates that the
                     # device is disabled.
                     return not (flags & 0x1)

                 finally:
                     device_key.Close()
             finally:
                 connection_key.Close()
         except (EnvironmentError, ValueError):
             # Pre-vista, enabled interfaces seem to have a non-empty
             # NTEContextList; this was how dnspython detected enabled
             # nics before the code above was contributed.  We've retained
             # the old method since we don't know if the code above works
             # on Windows 95/98/ME.
             try:
                 (nte, ttype) = _winreg.QueryValueEx(interface_key,
                                                     'NTEContextList')
                 return nte is not None
             except WindowsError:
                 return False

    def _compute_timeout(self, start):
        now = time.time()
        if now < start:
            if start - now > 1:
                # Time going backwards is bad.  Just give up.
                raise Timeout
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        duration = now - start
        if duration >= self.lifetime:
            raise Timeout
        return min(self.lifetime - duration, self.timeout)

    def query(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
              tcp=False, source=None, raise_on_no_answer=True):
        """Query nameservers to find the answer to the question.

        The I{qname}, I{rdtype}, and I{rdclass} parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.  E.g. For I{rdtype} the integer 2 and the
        the string 'NS' both mean to query for records with DNS rdata type NS.

        @param qname: the query name
        @type qname: dns.name.Name object or string
        @param rdtype: the query type
        @type rdtype: int or string
        @param rdclass: the query class
        @type rdclass: int or string
        @param tcp: use TCP to make the query (default is False).
        @type tcp: bool
        @param source: bind to this IP address (defaults to machine default IP).
        @type source: IP address in dotted quad notation
        @param raise_on_no_answer: raise NoAnswer if there's no answer
        (defaults is True).
        @type raise_on_no_answer: bool
        @rtype: dns.resolver.Answer instance
        @raises Timeout: no answers could be found in the specified lifetime
        @raises NXDOMAIN: the query name does not exist
        @raises NoAnswer: the response did not contain an answer and
        raise_on_no_answer is True.
        @raises NoNameservers: no non-broken nameservers are available to
        answer the question."""

        if isinstance(qname, basestring):
            qname = dns.name.from_text(qname, None)
        if isinstance(rdtype, basestring):
            rdtype = dns.rdatatype.from_text(rdtype)
        if dns.rdatatype.is_metatype(rdtype):
            raise NoMetaqueries
        if isinstance(rdclass, basestring):
            rdclass = dns.rdataclass.from_text(rdclass)
        if dns.rdataclass.is_metaclass(rdclass):
            raise NoMetaqueries
        qnames_to_try = []
        if qname.is_absolute():
            qnames_to_try.append(qname)
        else:
            if len(qname) > 1:
                qnames_to_try.append(qname.concatenate(dns.name.root))
            if self.search:
                for suffix in self.search:
                    qnames_to_try.append(qname.concatenate(suffix))
            else:
                qnames_to_try.append(qname.concatenate(self.domain))
        all_nxdomain = True
        start = time.time()
        for qname in qnames_to_try:
            if self.cache:
                answer = self.cache.get((qname, rdtype, rdclass))
                if answer:
                    return answer
            request = dns.message.make_query(qname, rdtype, rdclass)
            if not self.keyname is None:
                request.use_tsig(self.keyring, self.keyname,
                                 algorithm=self.keyalgorithm)
            request.use_edns(self.edns, self.ednsflags, self.payload)
            response = None

            # make a copy of the servers list so we can alter it later.

            nameservers = self.nameservers[:]
            backoff = 0.10
            while response is None:
                if len(nameservers) == 0:
                    raise NoNameservers("No DNS servers %s could answer the query %s" % \
                      (str(self.nameservers), str(qname)))
                for nameserver in nameservers[:]:
                    timeout = self._compute_timeout(start)
                    try:
                        if tcp:
                            response = dns.query.tcp(request, nameserver,
                                                     timeout, self.port,
                                                     source=source)
                        else:
                            response = dns.query.udp(request, nameserver,
                                                     timeout, self.port,
                                                     source=source)
                    except (socket.error, dns.exception.Timeout):

                        # Communication failure or timeout.  Go to the
                        # next server

                        response = None
                        continue
                    except dns.query.UnexpectedSource:

                        # Who knows?  Keep going.

                        response = None
                        continue
                    except dns.exception.FormError:

                        # We don't understand what this server is
                        # saying.  Take it out of the mix and
                        # continue.

                        nameservers.remove(nameserver)
                        response = None
                        continue
                    rcode = response.rcode()
                    if rcode == dns.rcode.NOERROR or \
                           rcode == dns.rcode.NXDOMAIN:
                        break

                    # We got a response, but we're not happy with the
                    # rcode in it.  Remove the server from the mix if
                    # the rcode isn't SERVFAIL.

                    if rcode != dns.rcode.SERVFAIL:
                        nameservers.remove(nameserver)
                    response = None

                if response is not None:
                    break
                # All nameservers failed!

                if len(nameservers) > 0:

                    # But we still have servers to try.  Sleep a bit
                    # so we don't pound them!

                    timeout = self._compute_timeout(start)
                    sleep_time = min(timeout, backoff)
                    backoff *= 2
                    time.sleep(sleep_time)
            if response.rcode() == dns.rcode.NXDOMAIN:
                continue
            all_nxdomain = False
            break
        if all_nxdomain:
            raise NXDOMAIN("Domain does not exist")
        answer = Answer(qname, rdtype, rdclass, response,
                        raise_on_no_answer)
        if self.cache:
            self.cache.put((qname, rdtype, rdclass), answer)
        return answer

    def use_tsig(self, keyring, keyname=None,
                 algorithm=dns.tsig.default_algorithm):
        """Add a TSIG signature to the query.

        @param keyring: The TSIG keyring to use; defaults to None.
        @type keyring: dict
        @param keyname: The name of the TSIG key to use; defaults to None.
        The key must be defined in the keyring.  If a keyring is specified
        but a keyname is not, then the key used will be the first key in the
        keyring.  Note that the order of keys in a dictionary is not defined,
        so applications should supply a keyname when a keyring is used, unless
        they know the keyring contains only one key.
        @param algorithm: The TSIG key algorithm to use.  The default
        is dns.tsig.default_algorithm.
        @type algorithm: string"""
        self.keyring = keyring
        if keyname is None:
            self.keyname = self.keyring.keys()[0]
        else:
            self.keyname = keyname
        self.keyalgorithm = algorithm

    def use_edns(self, edns, ednsflags, payload):
        """Configure Edns.

        @param edns: The EDNS level to use.  The default is -1, no Edns.
        @type edns: int
        @param ednsflags: The EDNS flags
        @type ednsflags: int
        @param payload: The EDNS payload size.  The default is 0.
        @type payload: int"""

        if edns is None:
            edns = -1
        self.edns = edns
        self.ednsflags = ednsflags
        self.payload = payload

default_resolver = None

def get_default_resolver():
    """Get the default resolver, initializing it if necessary."""
    global default_resolver
    if default_resolver is None:
        default_resolver = Resolver()
    return default_resolver

def query(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
          tcp=False, source=None, raise_on_no_answer=True, resolver=None):
    """Query nameservers to find the answer to the question.

    This is a convenience function that uses the default resolver
    object to make the query.
    @see: L{dns.resolver.Resolver.query} for more information on the
    parameters."""
    if resolver is None:
        resolver = get_default_resolver()
    return resolver.query(qname, rdtype, rdclass, tcp, source, raise_on_no_answer)

def zone_for_name(name, rdclass=dns.rdataclass.IN, tcp=False, resolver=None):
    """Find the name of the zone which contains the specified name.

    @param name: the query name
    @type name: absolute dns.name.Name object or string
    @param rdclass: The query class
    @type rdclass: int
    @param tcp: use TCP to make the query (default is False).
    @type tcp: bool
    @param resolver: the resolver to use
    @type resolver: dns.resolver.Resolver object or None
    @rtype: dns.name.Name"""

    if isinstance(name, basestring):
        name = dns.name.from_text(name, dns.name.root)
    if resolver is None:
        resolver = get_default_resolver()
    if not name.is_absolute():
        raise NotAbsolute(name)
    while 1:
        try:
            answer = resolver.query(name, dns.rdatatype.SOA, rdclass, tcp)
            if answer.rrset.name == name:
                return name
            # otherwise we were CNAMEd or DNAMEd and need to look higher
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
            pass
        try:
            name = name.parent()
        except dns.name.NoParent:
            raise NoRootSOA

########NEW FILE########
__FILENAME__ = reversename
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Reverse Map Names.

@var ipv4_reverse_domain: The DNS IPv4 reverse-map domain, in-addr.arpa.
@type ipv4_reverse_domain: dns.name.Name object
@var ipv6_reverse_domain: The DNS IPv6 reverse-map domain, ip6.arpa.
@type ipv6_reverse_domain: dns.name.Name object
"""

import dns.name
import dns.ipv6
import dns.ipv4

ipv4_reverse_domain = dns.name.from_text('in-addr.arpa.')
ipv6_reverse_domain = dns.name.from_text('ip6.arpa.')

def from_address(text):
    """Convert an IPv4 or IPv6 address in textual form into a Name object whose
    value is the reverse-map domain name of the address.
    @param text: an IPv4 or IPv6 address in textual form (e.g. '127.0.0.1',
    '::1')
    @type text: str
    @rtype: dns.name.Name object
    """
    try:
        parts = list(dns.ipv6.inet_aton(text).encode('hex_codec'))
        origin = ipv6_reverse_domain
    except StandardError:
        parts = ['%d' % ord(byte) for byte in dns.ipv4.inet_aton(text)]
        origin = ipv4_reverse_domain
    parts.reverse()
    return dns.name.from_text('.'.join(parts), origin=origin)

def to_address(name):
    """Convert a reverse map domain name into textual address form.
    @param name: an IPv4 or IPv6 address in reverse-map form.
    @type name: dns.name.Name object
    @rtype: str
    """
    if name.is_subdomain(ipv4_reverse_domain):
        name = name.relativize(ipv4_reverse_domain)
        labels = list(name.labels)
        labels.reverse()
        text = '.'.join(labels)
        # run through inet_aton() to check syntax and make pretty.
        return dns.ipv4.inet_ntoa(dns.ipv4.inet_aton(text))
    elif name.is_subdomain(ipv6_reverse_domain):
        name = name.relativize(ipv6_reverse_domain)
        labels = list(name.labels)
        labels.reverse()
        parts = []
        i = 0
        l = len(labels)
        while i < l:
            parts.append(''.join(labels[i:i+4]))
            i += 4
        text = ':'.join(parts)
        # run through inet_aton() to check syntax and make pretty.
        return dns.ipv6.inet_ntoa(dns.ipv6.inet_aton(text))
    else:
        raise dns.exception.SyntaxError('unknown reverse-map address family')

########NEW FILE########
__FILENAME__ = rrset
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS RRsets (an RRset is a named rdataset)"""

import dns.name
import dns.rdataset
import dns.rdataclass
import dns.renderer

class RRset(dns.rdataset.Rdataset):
    """A DNS RRset (named rdataset).

    RRset inherits from Rdataset, and RRsets can be treated as
    Rdatasets in most cases.  There are, however, a few notable
    exceptions.  RRsets have different to_wire() and to_text() method
    arguments, reflecting the fact that RRsets always have an owner
    name.
    """

    __slots__ = ['name', 'deleting']

    def __init__(self, name, rdclass, rdtype, covers=dns.rdatatype.NONE,
                 deleting=None):
        """Create a new RRset."""

        super(RRset, self).__init__(rdclass, rdtype, covers)
        self.name = name
        self.deleting = deleting

    def _clone(self):
        obj = super(RRset, self)._clone()
        obj.name = self.name
        obj.deleting = self.deleting
        return obj

    def __repr__(self):
        if self.covers == 0:
            ctext = ''
        else:
            ctext = '(' + dns.rdatatype.to_text(self.covers) + ')'
        if not self.deleting is None:
            dtext = ' delete=' + dns.rdataclass.to_text(self.deleting)
        else:
            dtext = ''
        return '<DNS ' + str(self.name) + ' ' + \
               dns.rdataclass.to_text(self.rdclass) + ' ' + \
               dns.rdatatype.to_text(self.rdtype) + ctext + dtext + ' RRset>'

    def __str__(self):
        return self.to_text()

    def __eq__(self, other):
        """Two RRsets are equal if they have the same name and the same
        rdataset

        @rtype: bool"""
        if not isinstance(other, RRset):
            return False
        if self.name != other.name:
            return False
        return super(RRset, self).__eq__(other)

    def match(self, name, rdclass, rdtype, covers, deleting=None):
        """Returns True if this rrset matches the specified class, type,
        covers, and deletion state."""

        if not super(RRset, self).match(rdclass, rdtype, covers):
            return False
        if self.name != name or self.deleting != deleting:
            return False
        return True

    def to_text(self, origin=None, relativize=True, **kw):
        """Convert the RRset into DNS master file format.

        @see: L{dns.name.Name.choose_relativity} for more information
        on how I{origin} and I{relativize} determine the way names
        are emitted.

        Any additional keyword arguments are passed on to the rdata
        to_text() method.

        @param origin: The origin for relative names, or None.
        @type origin: dns.name.Name object
        @param relativize: True if names should names be relativized
        @type relativize: bool"""

        return super(RRset, self).to_text(self.name, origin, relativize,
                                          self.deleting, **kw)

    def to_wire(self, file, compress=None, origin=None, **kw):
        """Convert the RRset to wire format."""

        return super(RRset, self).to_wire(self.name, file, compress, origin,
                                          self.deleting, **kw)

    def to_rdataset(self):
        """Convert an RRset into an Rdataset.

        @rtype: dns.rdataset.Rdataset object
        """
        return dns.rdataset.from_rdata_list(self.ttl, list(self))


def from_text_list(name, ttl, rdclass, rdtype, text_rdatas):
    """Create an RRset with the specified name, TTL, class, and type, and with
    the specified list of rdatas in text format.

    @rtype: dns.rrset.RRset object
    """

    if isinstance(name, (str, unicode)):
        name = dns.name.from_text(name, None)
    if isinstance(rdclass, (str, unicode)):
        rdclass = dns.rdataclass.from_text(rdclass)
    if isinstance(rdtype, (str, unicode)):
        rdtype = dns.rdatatype.from_text(rdtype)
    r = RRset(name, rdclass, rdtype)
    r.update_ttl(ttl)
    for t in text_rdatas:
        rd = dns.rdata.from_text(r.rdclass, r.rdtype, t)
        r.add(rd)
    return r

def from_text(name, ttl, rdclass, rdtype, *text_rdatas):
    """Create an RRset with the specified name, TTL, class, and type and with
    the specified rdatas in text format.

    @rtype: dns.rrset.RRset object
    """

    return from_text_list(name, ttl, rdclass, rdtype, text_rdatas)

def from_rdata_list(name, ttl, rdatas):
    """Create an RRset with the specified name and TTL, and with
    the specified list of rdata objects.

    @rtype: dns.rrset.RRset object
    """

    if isinstance(name, (str, unicode)):
        name = dns.name.from_text(name, None)

    if len(rdatas) == 0:
        raise ValueError("rdata list must not be empty")
    r = None
    for rd in rdatas:
        if r is None:
            r = RRset(name, rd.rdclass, rd.rdtype)
            r.update_ttl(ttl)
            first_time = False
        r.add(rd)
    return r

def from_rdata(name, ttl, *rdatas):
    """Create an RRset with the specified name and TTL, and with
    the specified rdata objects.

    @rtype: dns.rrset.RRset object
    """

    return from_rdata_list(name, ttl, rdatas)

########NEW FILE########
__FILENAME__ = set
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""A simple Set class."""

class Set(object):
    """A simple set class.

    Sets are not in Python until 2.3, and rdata are not immutable so
    we cannot use sets.Set anyway.  This class implements subset of
    the 2.3 Set interface using a list as the container.

    @ivar items: A list of the items which are in the set
    @type items: list"""

    __slots__ = ['items']

    def __init__(self, items=None):
        """Initialize the set.

        @param items: the initial set of items
        @type items: any iterable or None
        """

        self.items = []
        if not items is None:
            for item in items:
                self.add(item)

    def __repr__(self):
        return "dns.simpleset.Set(%s)" % repr(self.items)

    def add(self, item):
        """Add an item to the set."""
        if not item in self.items:
            self.items.append(item)

    def remove(self, item):
        """Remove an item from the set."""
        self.items.remove(item)

    def discard(self, item):
        """Remove an item from the set if present."""
        try:
            self.items.remove(item)
        except ValueError:
            pass

    def _clone(self):
        """Make a (shallow) copy of the set.

        There is a 'clone protocol' that subclasses of this class
        should use.  To make a copy, first call your super's _clone()
        method, and use the object returned as the new instance.  Then
        make shallow copies of the attributes defined in the subclass.

        This protocol allows us to write the set algorithms that
        return new instances (e.g. union) once, and keep using them in
        subclasses.
        """

        cls = self.__class__
        obj = cls.__new__(cls)
        obj.items = list(self.items)
        return obj

    def __copy__(self):
        """Make a (shallow) copy of the set."""
        return self._clone()

    def copy(self):
        """Make a (shallow) copy of the set."""
        return self._clone()

    def union_update(self, other):
        """Update the set, adding any elements from other which are not
        already in the set.
        @param other: the collection of items with which to update the set
        @type other: Set object
        """
        if not isinstance(other, Set):
            raise ValueError('other must be a Set instance')
        if self is other:
            return
        for item in other.items:
            self.add(item)

    def intersection_update(self, other):
        """Update the set, removing any elements from other which are not
        in both sets.
        @param other: the collection of items with which to update the set
        @type other: Set object
        """
        if not isinstance(other, Set):
            raise ValueError('other must be a Set instance')
        if self is other:
            return
        # we make a copy of the list so that we can remove items from
        # the list without breaking the iterator.
        for item in list(self.items):
            if item not in other.items:
                self.items.remove(item)

    def difference_update(self, other):
        """Update the set, removing any elements from other which are in
        the set.
        @param other: the collection of items with which to update the set
        @type other: Set object
        """
        if not isinstance(other, Set):
            raise ValueError('other must be a Set instance')
        if self is other:
            self.items = []
        else:
            for item in other.items:
                self.discard(item)

    def union(self, other):
        """Return a new set which is the union of I{self} and I{other}.

        @param other: the other set
        @type other: Set object
        @rtype: the same type as I{self}
        """

        obj = self._clone()
        obj.union_update(other)
        return obj

    def intersection(self, other):
        """Return a new set which is the intersection of I{self} and I{other}.

        @param other: the other set
        @type other: Set object
        @rtype: the same type as I{self}
        """

        obj = self._clone()
        obj.intersection_update(other)
        return obj

    def difference(self, other):
        """Return a new set which I{self} - I{other}, i.e. the items
        in I{self} which are not also in I{other}.

        @param other: the other set
        @type other: Set object
        @rtype: the same type as I{self}
        """

        obj = self._clone()
        obj.difference_update(other)
        return obj

    def __or__(self, other):
        return self.union(other)

    def __and__(self, other):
        return self.intersection(other)

    def __add__(self, other):
        return self.union(other)

    def __sub__(self, other):
        return self.difference(other)

    def __ior__(self, other):
        self.union_update(other)
        return self

    def __iand__(self, other):
        self.intersection_update(other)
        return self

    def __iadd__(self, other):
        self.union_update(other)
        return self

    def __isub__(self, other):
        self.difference_update(other)
        return self

    def update(self, other):
        """Update the set, adding any elements from other which are not
        already in the set.
        @param other: the collection of items with which to update the set
        @type other: any iterable type"""
        for item in other:
            self.add(item)

    def clear(self):
        """Make the set empty."""
        self.items = []

    def __eq__(self, other):
        # Yes, this is inefficient but the sets we're dealing with are
        # usually quite small, so it shouldn't hurt too much.
        for item in self.items:
            if not item in other.items:
                return False
        for item in other.items:
            if not item in self.items:
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __len__(self):
        return len(self.items)

    def __iter__(self):
        return iter(self.items)

    def __getitem__(self, i):
        return self.items[i]

    def __delitem__(self, i):
        del self.items[i]

    def __getslice__(self, i, j):
        return self.items[i:j]

    def __delslice__(self, i, j):
        del self.items[i:j]

    def issubset(self, other):
        """Is I{self} a subset of I{other}?

        @rtype: bool
        """

        if not isinstance(other, Set):
            raise ValueError('other must be a Set instance')
        for item in self.items:
            if not item in other.items:
                return False
        return True

    def issuperset(self, other):
        """Is I{self} a superset of I{other}?

        @rtype: bool
        """

        if not isinstance(other, Set):
            raise ValueError('other must be a Set instance')
        for item in other.items:
            if not item in self.items:
                return False
        return True

########NEW FILE########
__FILENAME__ = tokenizer
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Tokenize DNS master file format"""

import cStringIO
import sys

import dns.exception
import dns.name
import dns.ttl

_DELIMITERS = {
    ' ' : True,
    '\t' : True,
    '\n' : True,
    ';' : True,
    '(' : True,
    ')' : True,
    '"' : True }

_QUOTING_DELIMITERS = { '"' : True }

EOF = 0
EOL = 1
WHITESPACE = 2
IDENTIFIER = 3
QUOTED_STRING = 4
COMMENT = 5
DELIMITER = 6

class UngetBufferFull(dns.exception.DNSException):
    """Raised when an attempt is made to unget a token when the unget
    buffer is full."""
    pass

class Token(object):
    """A DNS master file format token.

    @ivar ttype: The token type
    @type ttype: int
    @ivar value: The token value
    @type value: string
    @ivar has_escape: Does the token value contain escapes?
    @type has_escape: bool
    """

    def __init__(self, ttype, value='', has_escape=False):
        """Initialize a token instance.

        @param ttype: The token type
        @type ttype: int
        @ivar value: The token value
        @type value: string
        @ivar has_escape: Does the token value contain escapes?
        @type has_escape: bool
        """
        self.ttype = ttype
        self.value = value
        self.has_escape = has_escape

    def is_eof(self):
        return self.ttype == EOF

    def is_eol(self):
        return self.ttype == EOL

    def is_whitespace(self):
        return self.ttype == WHITESPACE

    def is_identifier(self):
        return self.ttype == IDENTIFIER

    def is_quoted_string(self):
        return self.ttype == QUOTED_STRING

    def is_comment(self):
        return self.ttype == COMMENT

    def is_delimiter(self):
        return self.ttype == DELIMITER

    def is_eol_or_eof(self):
        return (self.ttype == EOL or self.ttype == EOF)

    def __eq__(self, other):
        if not isinstance(other, Token):
            return False
        return (self.ttype == other.ttype and
                self.value == other.value)

    def __ne__(self, other):
        if not isinstance(other, Token):
            return True
        return (self.ttype != other.ttype or
                self.value != other.value)

    def __str__(self):
        return '%d "%s"' % (self.ttype, self.value)

    def unescape(self):
        if not self.has_escape:
            return self
        unescaped = ''
        l = len(self.value)
        i = 0
        while i < l:
            c = self.value[i]
            i += 1
            if c == '\\':
                if i >= l:
                    raise dns.exception.UnexpectedEnd
                c = self.value[i]
                i += 1
                if c.isdigit():
                    if i >= l:
                        raise dns.exception.UnexpectedEnd
                    c2 = self.value[i]
                    i += 1
                    if i >= l:
                        raise dns.exception.UnexpectedEnd
                    c3 = self.value[i]
                    i += 1
                    if not (c2.isdigit() and c3.isdigit()):
                        raise dns.exception.SyntaxError
                    c = chr(int(c) * 100 + int(c2) * 10 + int(c3))
            unescaped += c
        return Token(self.ttype, unescaped)

    # compatibility for old-style tuple tokens

    def __len__(self):
        return 2

    def __iter__(self):
        return iter((self.ttype, self.value))

    def __getitem__(self, i):
        if i == 0:
            return self.ttype
        elif i == 1:
            return self.value
        else:
            raise IndexError

class Tokenizer(object):
    """A DNS master file format tokenizer.

    A token is a (type, value) tuple, where I{type} is an int, and
    I{value} is a string.  The valid types are EOF, EOL, WHITESPACE,
    IDENTIFIER, QUOTED_STRING, COMMENT, and DELIMITER.

    @ivar file: The file to tokenize
    @type file: file
    @ivar ungotten_char: The most recently ungotten character, or None.
    @type ungotten_char: string
    @ivar ungotten_token: The most recently ungotten token, or None.
    @type ungotten_token: (int, string) token tuple
    @ivar multiline: The current multiline level.  This value is increased
    by one every time a '(' delimiter is read, and decreased by one every time
    a ')' delimiter is read.
    @type multiline: int
    @ivar quoting: This variable is true if the tokenizer is currently
    reading a quoted string.
    @type quoting: bool
    @ivar eof: This variable is true if the tokenizer has encountered EOF.
    @type eof: bool
    @ivar delimiters: The current delimiter dictionary.
    @type delimiters: dict
    @ivar line_number: The current line number
    @type line_number: int
    @ivar filename: A filename that will be returned by the L{where} method.
    @type filename: string
    """

    def __init__(self, f=sys.stdin, filename=None):
        """Initialize a tokenizer instance.

        @param f: The file to tokenize.  The default is sys.stdin.
        This parameter may also be a string, in which case the tokenizer
        will take its input from the contents of the string.
        @type f: file or string
        @param filename: the name of the filename that the L{where} method
        will return.
        @type filename: string
        """

        if isinstance(f, str):
            f = cStringIO.StringIO(f)
            if filename is None:
                filename = '<string>'
        else:
            if filename is None:
                if f is sys.stdin:
                    filename = '<stdin>'
                else:
                    filename = '<file>'
        self.file = f
        self.ungotten_char = None
        self.ungotten_token = None
        self.multiline = 0
        self.quoting = False
        self.eof = False
        self.delimiters = _DELIMITERS
        self.line_number = 1
        self.filename = filename

    def _get_char(self):
        """Read a character from input.
        @rtype: string
        """

        if self.ungotten_char is None:
            if self.eof:
                c = ''
            else:
                c = self.file.read(1)
                if c == '':
                    self.eof = True
                elif c == '\n':
                    self.line_number += 1
        else:
            c = self.ungotten_char
            self.ungotten_char = None
        return c

    def where(self):
        """Return the current location in the input.

        @rtype: (string, int) tuple.  The first item is the filename of
        the input, the second is the current line number.
        """

        return (self.filename, self.line_number)

    def _unget_char(self, c):
        """Unget a character.

        The unget buffer for characters is only one character large; it is
        an error to try to unget a character when the unget buffer is not
        empty.

        @param c: the character to unget
        @type c: string
        @raises UngetBufferFull: there is already an ungotten char
        """

        if not self.ungotten_char is None:
            raise UngetBufferFull
        self.ungotten_char = c

    def skip_whitespace(self):
        """Consume input until a non-whitespace character is encountered.

        The non-whitespace character is then ungotten, and the number of
        whitespace characters consumed is returned.

        If the tokenizer is in multiline mode, then newlines are whitespace.

        @rtype: int
        """

        skipped = 0
        while True:
            c = self._get_char()
            if c != ' ' and c != '\t':
                if (c != '\n') or not self.multiline:
                    self._unget_char(c)
                    return skipped
            skipped += 1

    def get(self, want_leading = False, want_comment = False):
        """Get the next token.

        @param want_leading: If True, return a WHITESPACE token if the
        first character read is whitespace.  The default is False.
        @type want_leading: bool
        @param want_comment: If True, return a COMMENT token if the
        first token read is a comment.  The default is False.
        @type want_comment: bool
        @rtype: Token object
        @raises dns.exception.UnexpectedEnd: input ended prematurely
        @raises dns.exception.SyntaxError: input was badly formed
        """

        if not self.ungotten_token is None:
            token = self.ungotten_token
            self.ungotten_token = None
            if token.is_whitespace():
                if want_leading:
                    return token
            elif token.is_comment():
                if want_comment:
                    return token
            else:
                return token
        skipped = self.skip_whitespace()
        if want_leading and skipped > 0:
            return Token(WHITESPACE, ' ')
        token = ''
        ttype = IDENTIFIER
        has_escape = False
        while True:
            c = self._get_char()
            if c == '' or c in self.delimiters:
                if c == '' and self.quoting:
                    raise dns.exception.UnexpectedEnd
                if token == '' and ttype != QUOTED_STRING:
                    if c == '(':
                        self.multiline += 1
                        self.skip_whitespace()
                        continue
                    elif c == ')':
                        if not self.multiline > 0:
                            raise dns.exception.SyntaxError
                        self.multiline -= 1
                        self.skip_whitespace()
                        continue
                    elif c == '"':
                        if not self.quoting:
                            self.quoting = True
                            self.delimiters = _QUOTING_DELIMITERS
                            ttype = QUOTED_STRING
                            continue
                        else:
                            self.quoting = False
                            self.delimiters = _DELIMITERS
                            self.skip_whitespace()
                            continue
                    elif c == '\n':
                        return Token(EOL, '\n')
                    elif c == ';':
                        while 1:
                            c = self._get_char()
                            if c == '\n' or c == '':
                                break
                            token += c
                        if want_comment:
                            self._unget_char(c)
                            return Token(COMMENT, token)
                        elif c == '':
                            if self.multiline:
                                raise dns.exception.SyntaxError('unbalanced parentheses')
                            return Token(EOF)
                        elif self.multiline:
                            self.skip_whitespace()
                            token = ''
                            continue
                        else:
                            return Token(EOL, '\n')
                    else:
                        # This code exists in case we ever want a
                        # delimiter to be returned.  It never produces
                        # a token currently.
                        token = c
                        ttype = DELIMITER
                else:
                    self._unget_char(c)
                break
            elif self.quoting:
                if c == '\\':
                    c = self._get_char()
                    if c == '':
                        raise dns.exception.UnexpectedEnd
                    if c.isdigit():
                        c2 = self._get_char()
                        if c2 == '':
                            raise dns.exception.UnexpectedEnd
                        c3 = self._get_char()
                        if c == '':
                            raise dns.exception.UnexpectedEnd
                        if not (c2.isdigit() and c3.isdigit()):
                            raise dns.exception.SyntaxError
                        c = chr(int(c) * 100 + int(c2) * 10 + int(c3))
                elif c == '\n':
                    raise dns.exception.SyntaxError('newline in quoted string')
            elif c == '\\':
                #
                # It's an escape.  Put it and the next character into
                # the token; it will be checked later for goodness.
                #
                token += c
                has_escape = True
                c = self._get_char()
                if c == '' or c == '\n':
                    raise dns.exception.UnexpectedEnd
            token += c
        if token == '' and ttype != QUOTED_STRING:
            if self.multiline:
                raise dns.exception.SyntaxError('unbalanced parentheses')
            ttype = EOF
        return Token(ttype, token, has_escape)

    def unget(self, token):
        """Unget a token.

        The unget buffer for tokens is only one token large; it is
        an error to try to unget a token when the unget buffer is not
        empty.

        @param token: the token to unget
        @type token: Token object
        @raises UngetBufferFull: there is already an ungotten token
        """

        if not self.ungotten_token is None:
            raise UngetBufferFull
        self.ungotten_token = token

    def next(self):
        """Return the next item in an iteration.
        @rtype: (int, string)
        """

        token = self.get()
        if token.is_eof():
            raise StopIteration
        return token

    def __iter__(self):
        return self

    # Helpers

    def get_int(self):
        """Read the next token and interpret it as an integer.

        @raises dns.exception.SyntaxError:
        @rtype: int
        """

        token = self.get().unescape()
        if not token.is_identifier():
            raise dns.exception.SyntaxError('expecting an identifier')
        if not token.value.isdigit():
            raise dns.exception.SyntaxError('expecting an integer')
        return int(token.value)

    def get_uint8(self):
        """Read the next token and interpret it as an 8-bit unsigned
        integer.

        @raises dns.exception.SyntaxError:
        @rtype: int
        """

        value = self.get_int()
        if value < 0 or value > 255:
            raise dns.exception.SyntaxError('%d is not an unsigned 8-bit integer' % value)
        return value

    def get_uint16(self):
        """Read the next token and interpret it as a 16-bit unsigned
        integer.

        @raises dns.exception.SyntaxError:
        @rtype: int
        """

        value = self.get_int()
        if value < 0 or value > 65535:
            raise dns.exception.SyntaxError('%d is not an unsigned 16-bit integer' % value)
        return value

    def get_uint32(self):
        """Read the next token and interpret it as a 32-bit unsigned
        integer.

        @raises dns.exception.SyntaxError:
        @rtype: int
        """

        token = self.get().unescape()
        if not token.is_identifier():
            raise dns.exception.SyntaxError('expecting an identifier')
        if not token.value.isdigit():
            raise dns.exception.SyntaxError('expecting an integer')
        value = long(token.value)
        if value < 0 or value > 4294967296L:
            raise dns.exception.SyntaxError('%d is not an unsigned 32-bit integer' % value)
        return value

    def get_string(self, origin=None):
        """Read the next token and interpret it as a string.

        @raises dns.exception.SyntaxError:
        @rtype: string
        """

        token = self.get().unescape()
        if not (token.is_identifier() or token.is_quoted_string()):
            raise dns.exception.SyntaxError('expecting a string')
        return token.value

    def get_identifier(self, origin=None):
        """Read the next token and raise an exception if it is not an identifier.

        @raises dns.exception.SyntaxError:
        @rtype: string
        """

        token = self.get().unescape()
        if not token.is_identifier():
            raise dns.exception.SyntaxError('expecting an identifier')
        return token.value

    def get_name(self, origin=None):
        """Read the next token and interpret it as a DNS name.

        @raises dns.exception.SyntaxError:
        @rtype: dns.name.Name object"""

        token = self.get()
        if not token.is_identifier():
            raise dns.exception.SyntaxError('expecting an identifier')
        return dns.name.from_text(token.value, origin)

    def get_eol(self):
        """Read the next token and raise an exception if it isn't EOL or
        EOF.

        @raises dns.exception.SyntaxError:
        @rtype: string
        """

        token = self.get()
        if not token.is_eol_or_eof():
            raise dns.exception.SyntaxError('expected EOL or EOF, got %d "%s"' % (token.ttype, token.value))
        return token.value

    def get_ttl(self):
        token = self.get().unescape()
        if not token.is_identifier():
            raise dns.exception.SyntaxError('expecting an identifier')
        return dns.ttl.from_text(token.value)

########NEW FILE########
__FILENAME__ = tsig
# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS TSIG support."""

import hmac
import struct
import sys

import dns.exception
import dns.hash
import dns.rdataclass
import dns.name

class BadTime(dns.exception.DNSException):
    """Raised if the current time is not within the TSIG's validity time."""
    pass

class BadSignature(dns.exception.DNSException):
    """Raised if the TSIG signature fails to verify."""
    pass

class PeerError(dns.exception.DNSException):
    """Base class for all TSIG errors generated by the remote peer"""
    pass

class PeerBadKey(PeerError):
    """Raised if the peer didn't know the key we used"""
    pass

class PeerBadSignature(PeerError):
    """Raised if the peer didn't like the signature we sent"""
    pass

class PeerBadTime(PeerError):
    """Raised if the peer didn't like the time we sent"""
    pass

class PeerBadTruncation(PeerError):
    """Raised if the peer didn't like amount of truncation in the TSIG we sent"""
    pass

# TSIG Algorithms

HMAC_MD5 = dns.name.from_text("HMAC-MD5.SIG-ALG.REG.INT")
HMAC_SHA1 = dns.name.from_text("hmac-sha1")
HMAC_SHA224 = dns.name.from_text("hmac-sha224")
HMAC_SHA256 = dns.name.from_text("hmac-sha256")
HMAC_SHA384 = dns.name.from_text("hmac-sha384")
HMAC_SHA512 = dns.name.from_text("hmac-sha512")

default_algorithm = HMAC_MD5

BADSIG = 16
BADKEY = 17
BADTIME = 18
BADTRUNC = 22

def sign(wire, keyname, secret, time, fudge, original_id, error,
         other_data, request_mac, ctx=None, multi=False, first=True,
         algorithm=default_algorithm):
    """Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata
    for the input parameters, the HMAC MAC calculated by applying the
    TSIG signature algorithm, and the TSIG digest context.
    @rtype: (string, string, hmac.HMAC object)
    @raises ValueError: I{other_data} is too long
    @raises NotImplementedError: I{algorithm} is not supported
    """

    (algorithm_name, digestmod) = get_algorithm(algorithm)
    if first:
        ctx = hmac.new(secret, digestmod=digestmod)
        ml = len(request_mac)
        if ml > 0:
            ctx.update(struct.pack('!H', ml))
            ctx.update(request_mac)
    id = struct.pack('!H', original_id)
    ctx.update(id)
    ctx.update(wire[2:])
    if first:
        ctx.update(keyname.to_digestable())
        ctx.update(struct.pack('!H', dns.rdataclass.ANY))
        ctx.update(struct.pack('!I', 0))
    long_time = time + 0L
    upper_time = (long_time >> 32) & 0xffffL
    lower_time = long_time & 0xffffffffL
    time_mac = struct.pack('!HIH', upper_time, lower_time, fudge)
    pre_mac = algorithm_name + time_mac
    ol = len(other_data)
    if ol > 65535:
        raise ValueError('TSIG Other Data is > 65535 bytes')
    post_mac = struct.pack('!HH', error, ol) + other_data
    if first:
        ctx.update(pre_mac)
        ctx.update(post_mac)
    else:
        ctx.update(time_mac)
    mac = ctx.digest()
    mpack = struct.pack('!H', len(mac))
    tsig_rdata = pre_mac + mpack + mac + id + post_mac
    if multi:
        ctx = hmac.new(secret)
        ml = len(mac)
        ctx.update(struct.pack('!H', ml))
        ctx.update(mac)
    else:
        ctx = None
    return (tsig_rdata, mac, ctx)

def hmac_md5(wire, keyname, secret, time, fudge, original_id, error,
             other_data, request_mac, ctx=None, multi=False, first=True,
             algorithm=default_algorithm):
    return sign(wire, keyname, secret, time, fudge, original_id, error,
                other_data, request_mac, ctx, multi, first, algorithm)

def validate(wire, keyname, secret, now, request_mac, tsig_start, tsig_rdata,
             tsig_rdlen, ctx=None, multi=False, first=True):
    """Validate the specified TSIG rdata against the other input parameters.

    @raises FormError: The TSIG is badly formed.
    @raises BadTime: There is too much time skew between the client and the
    server.
    @raises BadSignature: The TSIG signature did not validate
    @rtype: hmac.HMAC object"""

    (adcount,) = struct.unpack("!H", wire[10:12])
    if adcount == 0:
        raise dns.exception.FormError
    adcount -= 1
    new_wire = wire[0:10] + struct.pack("!H", adcount) + wire[12:tsig_start]
    current = tsig_rdata
    (aname, used) = dns.name.from_wire(wire, current)
    current = current + used
    (upper_time, lower_time, fudge, mac_size) = \
                 struct.unpack("!HIHH", wire[current:current + 10])
    time = ((upper_time + 0L) << 32) + (lower_time + 0L)
    current += 10
    mac = wire[current:current + mac_size]
    current += mac_size
    (original_id, error, other_size) = \
                  struct.unpack("!HHH", wire[current:current + 6])
    current += 6
    other_data = wire[current:current + other_size]
    current += other_size
    if current != tsig_rdata + tsig_rdlen:
        raise dns.exception.FormError
    if error != 0:
        if error == BADSIG:
            raise PeerBadSignature
        elif error == BADKEY:
            raise PeerBadKey
        elif error == BADTIME:
            raise PeerBadTime
        elif error == BADTRUNC:
            raise PeerBadTruncation
        else:
            raise PeerError('unknown TSIG error code %d' % error)
    time_low = time - fudge
    time_high = time + fudge
    if now < time_low or now > time_high:
        raise BadTime
    (junk, our_mac, ctx) = sign(new_wire, keyname, secret, time, fudge,
                                original_id, error, other_data,
                                request_mac, ctx, multi, first, aname)
    if (our_mac != mac):
        raise BadSignature
    return ctx

_hashes = None

def _maybe_add_hash(tsig_alg, hash_alg):
    try:
        _hashes[tsig_alg] = dns.hash.get(hash_alg)
    except KeyError:
        pass

def _setup_hashes():
    global _hashes
    _hashes = {}
    _maybe_add_hash(HMAC_SHA224, 'SHA224')
    _maybe_add_hash(HMAC_SHA256, 'SHA256')
    _maybe_add_hash(HMAC_SHA384, 'SHA384')
    _maybe_add_hash(HMAC_SHA512, 'SHA512')
    _maybe_add_hash(HMAC_SHA1, 'SHA1')
    _maybe_add_hash(HMAC_MD5, 'MD5')

def get_algorithm(algorithm):
    """Returns the wire format string and the hash module to use for the
    specified TSIG algorithm

    @rtype: (string, hash constructor)
    @raises NotImplementedError: I{algorithm} is not supported
    """

    global _hashes
    if _hashes is None:
        _setup_hashes()

    if isinstance(algorithm, (str, unicode)):
        algorithm = dns.name.from_text(algorithm)

    if sys.hexversion < 0x02050200 and \
       (algorithm == HMAC_SHA384 or algorithm == HMAC_SHA512):
        raise NotImplementedError("TSIG algorithm " + str(algorithm) +
                                  " requires Python 2.5.2 or later")

    try:
        return (algorithm.to_digestable(), _hashes[algorithm])
    except KeyError:
        raise NotImplementedError("TSIG algorithm " + str(algorithm) +
                                  " is not supported")

########NEW FILE########
__FILENAME__ = tsigkeyring
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""A place to store TSIG keys."""

import base64

import dns.name

def from_text(textring):
    """Convert a dictionary containing (textual DNS name, base64 secret) pairs
    into a binary keyring which has (dns.name.Name, binary secret) pairs.
    @rtype: dict"""

    keyring = {}
    for keytext in textring:
        keyname = dns.name.from_text(keytext)
        secret = base64.decodestring(textring[keytext])
        keyring[keyname] = secret
    return keyring

def to_text(keyring):
    """Convert a dictionary containing (dns.name.Name, binary secret) pairs
    into a text keyring which has (textual DNS name, base64 secret) pairs.
    @rtype: dict"""

    textring = {}
    for keyname in keyring:
        keytext = dns.name.to_text(keyname)
        secret = base64.encodestring(keyring[keyname])
        textring[keytext] = secret
    return textring

########NEW FILE########
__FILENAME__ = ttl
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS TTL conversion."""

import dns.exception

class BadTTL(dns.exception.SyntaxError):
    pass

def from_text(text):
    """Convert the text form of a TTL to an integer.

    The BIND 8 units syntax for TTLs (e.g. '1w6d4h3m10s') is supported.

    @param text: the textual TTL
    @type text: string
    @raises dns.ttl.BadTTL: the TTL is not well-formed
    @rtype: int
    """

    if text.isdigit():
        total = long(text)
    else:
        if not text[0].isdigit():
            raise BadTTL
        total = 0L
        current = 0L
        for c in text:
            if c.isdigit():
                current *= 10
                current += long(c)
            else:
                c = c.lower()
                if c == 'w':
                    total += current * 604800L
                elif c == 'd':
                    total += current * 86400L
                elif c == 'h':
                    total += current * 3600L
                elif c == 'm':
                    total += current * 60L
                elif c == 's':
                    total += current
                else:
                    raise BadTTL("unknown unit '%s'" % c)
                current = 0
        if not current == 0:
            raise BadTTL("trailing integer")
    if total < 0L or total > 2147483647L:
        raise BadTTL("TTL should be between 0 and 2^31 - 1 (inclusive)")
    return total

########NEW FILE########
__FILENAME__ = update
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Dynamic Update Support"""

import dns.message
import dns.name
import dns.opcode
import dns.rdata
import dns.rdataclass
import dns.rdataset
import dns.tsig

class Update(dns.message.Message):
    def __init__(self, zone, rdclass=dns.rdataclass.IN, keyring=None,
                 keyname=None, keyalgorithm=dns.tsig.default_algorithm):
        """Initialize a new DNS Update object.

        @param zone: The zone which is being updated.
        @type zone: A dns.name.Name or string
        @param rdclass: The class of the zone; defaults to dns.rdataclass.IN.
        @type rdclass: An int designating the class, or a string whose value
        is the name of a class.
        @param keyring: The TSIG keyring to use; defaults to None.
        @type keyring: dict
        @param keyname: The name of the TSIG key to use; defaults to None.
        The key must be defined in the keyring.  If a keyring is specified
        but a keyname is not, then the key used will be the first key in the
        keyring.  Note that the order of keys in a dictionary is not defined,
        so applications should supply a keyname when a keyring is used, unless
        they know the keyring contains only one key.
        @type keyname: dns.name.Name or string
        @param keyalgorithm: The TSIG algorithm to use; defaults to
        dns.tsig.default_algorithm.  Constants for TSIG algorithms are defined
        in dns.tsig, and the currently implemented algorithms are
        HMAC_MD5, HMAC_SHA1, HMAC_SHA224, HMAC_SHA256, HMAC_SHA384, and
        HMAC_SHA512.
        @type keyalgorithm: string
        """
        super(Update, self).__init__()
        self.flags |= dns.opcode.to_flags(dns.opcode.UPDATE)
        if isinstance(zone, (str, unicode)):
            zone = dns.name.from_text(zone)
        self.origin = zone
        if isinstance(rdclass, str):
            rdclass = dns.rdataclass.from_text(rdclass)
        self.zone_rdclass = rdclass
        self.find_rrset(self.question, self.origin, rdclass, dns.rdatatype.SOA,
                        create=True, force_unique=True)
        if not keyring is None:
            self.use_tsig(keyring, keyname, algorithm=keyalgorithm)

    def _add_rr(self, name, ttl, rd, deleting=None, section=None):
        """Add a single RR to the update section."""

        if section is None:
            section = self.authority
        covers = rd.covers()
        rrset = self.find_rrset(section, name, self.zone_rdclass, rd.rdtype,
                                covers, deleting, True, True)
        rrset.add(rd, ttl)

    def _add(self, replace, section, name, *args):
        """Add records.  The first argument is the replace mode.  If
        false, RRs are added to an existing RRset; if true, the RRset
        is replaced with the specified contents.  The second
        argument is the section to add to.  The third argument
        is always a name.  The other arguments can be:

                - rdataset...

                - ttl, rdata...

                - ttl, rdtype, string..."""

        if isinstance(name, (str, unicode)):
            name = dns.name.from_text(name, None)
        if isinstance(args[0], dns.rdataset.Rdataset):
            for rds in args:
                if replace:
                    self.delete(name, rds.rdtype)
                for rd in rds:
                    self._add_rr(name, rds.ttl, rd, section=section)
        else:
            args = list(args)
            ttl = int(args.pop(0))
            if isinstance(args[0], dns.rdata.Rdata):
                if replace:
                    self.delete(name, args[0].rdtype)
                for rd in args:
                    self._add_rr(name, ttl, rd, section=section)
            else:
                rdtype = args.pop(0)
                if isinstance(rdtype, str):
                    rdtype = dns.rdatatype.from_text(rdtype)
                if replace:
                    self.delete(name, rdtype)
                for s in args:
                    rd = dns.rdata.from_text(self.zone_rdclass, rdtype, s,
                                             self.origin)
                    self._add_rr(name, ttl, rd, section=section)

    def add(self, name, *args):
        """Add records.  The first argument is always a name.  The other
        arguments can be:

                - rdataset...

                - ttl, rdata...

                - ttl, rdtype, string..."""
        self._add(False, self.authority, name, *args)

    def delete(self, name, *args):
        """Delete records.  The first argument is always a name.  The other
        arguments can be:

                - I{nothing}

                - rdataset...

                - rdata...

                - rdtype, [string...]"""

        if isinstance(name, (str, unicode)):
            name = dns.name.from_text(name, None)
        if len(args) == 0:
            rrset = self.find_rrset(self.authority, name, dns.rdataclass.ANY,
                                    dns.rdatatype.ANY, dns.rdatatype.NONE,
                                    dns.rdatatype.ANY, True, True)
        elif isinstance(args[0], dns.rdataset.Rdataset):
            for rds in args:
                for rd in rds:
                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)
        else:
            args = list(args)
            if isinstance(args[0], dns.rdata.Rdata):
                for rd in args:
                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)
            else:
                rdtype = args.pop(0)
                if isinstance(rdtype, (str, unicode)):
                    rdtype = dns.rdatatype.from_text(rdtype)
                if len(args) == 0:
                    rrset = self.find_rrset(self.authority, name,
                                            self.zone_rdclass, rdtype,
                                            dns.rdatatype.NONE,
                                            dns.rdataclass.ANY,
                                            True, True)
                else:
                    for s in args:
                        rd = dns.rdata.from_text(self.zone_rdclass, rdtype, s,
                                                 self.origin)
                        self._add_rr(name, 0, rd, dns.rdataclass.NONE)

    def replace(self, name, *args):
        """Replace records.  The first argument is always a name.  The other
        arguments can be:

                - rdataset...

                - ttl, rdata...

                - ttl, rdtype, string...

        Note that if you want to replace the entire node, you should do
        a delete of the name followed by one or more calls to add."""

        self._add(True, self.authority, name, *args)

    def present(self, name, *args):
        """Require that an owner name (and optionally an rdata type,
        or specific rdataset) exists as a prerequisite to the
        execution of the update.  The first argument is always a name.
        The other arguments can be:

                - rdataset...

                - rdata...

                - rdtype, string..."""

        if isinstance(name, (str, unicode)):
            name = dns.name.from_text(name, None)
        if len(args) == 0:
            rrset = self.find_rrset(self.answer, name,
                                    dns.rdataclass.ANY, dns.rdatatype.ANY,
                                    dns.rdatatype.NONE, None,
                                    True, True)
        elif isinstance(args[0], dns.rdataset.Rdataset) or \
             isinstance(args[0], dns.rdata.Rdata) or \
             len(args) > 1:
            if not isinstance(args[0], dns.rdataset.Rdataset):
                # Add a 0 TTL
                args = list(args)
                args.insert(0, 0)
            self._add(False, self.answer, name, *args)
        else:
            rdtype = args[0]
            if isinstance(rdtype, (str, unicode)):
                rdtype = dns.rdatatype.from_text(rdtype)
            rrset = self.find_rrset(self.answer, name,
                                    dns.rdataclass.ANY, rdtype,
                                    dns.rdatatype.NONE, None,
                                    True, True)

    def absent(self, name, rdtype=None):
        """Require that an owner name (and optionally an rdata type) does
        not exist as a prerequisite to the execution of the update."""

        if isinstance(name, (str, unicode)):
            name = dns.name.from_text(name, None)
        if rdtype is None:
            rrset = self.find_rrset(self.answer, name,
                                    dns.rdataclass.NONE, dns.rdatatype.ANY,
                                    dns.rdatatype.NONE, None,
                                    True, True)
        else:
            if isinstance(rdtype, (str, unicode)):
                rdtype = dns.rdatatype.from_text(rdtype)
            rrset = self.find_rrset(self.answer, name,
                                    dns.rdataclass.NONE, rdtype,
                                    dns.rdatatype.NONE, None,
                                    True, True)

    def to_wire(self, origin=None, max_size=65535):
        """Return a string containing the update in DNS compressed wire
        format.
        @rtype: string"""
        if origin is None:
            origin = self.origin
        return super(Update, self).to_wire(origin, max_size)

########NEW FILE########
__FILENAME__ = version
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""dnspython release version information."""

MAJOR = 1
MINOR = 9
MICRO = 5
RELEASELEVEL = 0x0f
SERIAL = 0

if RELEASELEVEL == 0x0f:
    version = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
elif RELEASELEVEL == 0x00:
    version = '%d.%d.%dx%d' % \
              (MAJOR, MINOR, MICRO, SERIAL)
else:
    version = '%d.%d.%d%x%d' % \
              (MAJOR, MINOR, MICRO, RELEASELEVEL, SERIAL)

hexversion = MAJOR << 24 | MINOR << 16 | MICRO << 8 | RELEASELEVEL << 4 | \
             SERIAL

########NEW FILE########
__FILENAME__ = wiredata
# Copyright (C) 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Wire Data Helper"""

import sys

import dns.exception

class WireData(str):
    # WireData is a string with stricter slicing
    def __getitem__(self, key):
        try:
            return WireData(super(WireData, self).__getitem__(key))
        except IndexError:
            raise dns.exception.FormError
    def __getslice__(self, i, j):
        try:
            if j == sys.maxint:
                # handle the case where the right bound is unspecified
                j = len(self)
            if i < 0 or j < 0:
                raise dns.exception.FormError
            # If it's not an empty slice, access left and right bounds
            # to make sure they're valid
            if i != j:
                super(WireData, self).__getitem__(i)
                super(WireData, self).__getitem__(j - 1)
            return WireData(super(WireData, self).__getslice__(i, j))
        except IndexError:
            raise dns.exception.FormError
    def __iter__(self):
        i = 0
        while 1:
            try:
                yield self[i]
                i += 1
            except dns.exception.FormError:
                raise StopIteration
    def unwrap(self):
        return str(self)

def maybe_wrap(wire):
    if not isinstance(wire, WireData):
        return WireData(wire)
    else:
        return wire

########NEW FILE########
__FILENAME__ = zone
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS Zones."""

from __future__ import generators

import sys

import dns.exception
import dns.name
import dns.node
import dns.rdataclass
import dns.rdatatype
import dns.rdata
import dns.rrset
import dns.tokenizer
import dns.ttl

class BadZone(dns.exception.DNSException):
    """The zone is malformed."""
    pass

class NoSOA(BadZone):
    """The zone has no SOA RR at its origin."""
    pass

class NoNS(BadZone):
    """The zone has no NS RRset at its origin."""
    pass

class UnknownOrigin(BadZone):
    """The zone's origin is unknown."""
    pass

class Zone(object):
    """A DNS zone.

    A Zone is a mapping from names to nodes.  The zone object may be
    treated like a Python dictionary, e.g. zone[name] will retrieve
    the node associated with that name.  The I{name} may be a
    dns.name.Name object, or it may be a string.  In the either case,
    if the name is relative it is treated as relative to the origin of
    the zone.

    @ivar rdclass: The zone's rdata class; the default is class IN.
    @type rdclass: int
    @ivar origin: The origin of the zone.
    @type origin: dns.name.Name object
    @ivar nodes: A dictionary mapping the names of nodes in the zone to the
    nodes themselves.
    @type nodes: dict
    @ivar relativize: should names in the zone be relativized?
    @type relativize: bool
    @cvar node_factory: the factory used to create a new node
    @type node_factory: class or callable
    """

    node_factory = dns.node.Node

    __slots__ = ['rdclass', 'origin', 'nodes', 'relativize']

    def __init__(self, origin, rdclass=dns.rdataclass.IN, relativize=True):
        """Initialize a zone object.

        @param origin: The origin of the zone.
        @type origin: dns.name.Name object
        @param rdclass: The zone's rdata class; the default is class IN.
        @type rdclass: int"""

        self.rdclass = rdclass
        self.origin = origin
        self.nodes = {}
        self.relativize = relativize

    def __eq__(self, other):
        """Two zones are equal if they have the same origin, class, and
        nodes.
        @rtype: bool
        """

        if not isinstance(other, Zone):
            return False
        if self.rdclass != other.rdclass or \
           self.origin != other.origin or \
           self.nodes != other.nodes:
            return False
        return True

    def __ne__(self, other):
        """Are two zones not equal?
        @rtype: bool
        """

        return not self.__eq__(other)

    def _validate_name(self, name):
        if isinstance(name, (str, unicode)):
            name = dns.name.from_text(name, None)
        elif not isinstance(name, dns.name.Name):
            raise KeyError("name parameter must be convertable to a DNS name")
        if name.is_absolute():
            if not name.is_subdomain(self.origin):
                raise KeyError("name parameter must be a subdomain of the zone origin")
            if self.relativize:
                name = name.relativize(self.origin)
        return name

    def __getitem__(self, key):
        key = self._validate_name(key)
        return self.nodes[key]

    def __setitem__(self, key, value):
        key = self._validate_name(key)
        self.nodes[key] = value

    def __delitem__(self, key):
        key = self._validate_name(key)
        del self.nodes[key]

    def __iter__(self):
        return self.nodes.iterkeys()

    def iterkeys(self):
        return self.nodes.iterkeys()

    def keys(self):
        return self.nodes.keys()

    def itervalues(self):
        return self.nodes.itervalues()

    def values(self):
        return self.nodes.values()

    def iteritems(self):
        return self.nodes.iteritems()

    def items(self):
        return self.nodes.items()

    def get(self, key):
        key = self._validate_name(key)
        return self.nodes.get(key)

    def __contains__(self, other):
        return other in self.nodes

    def find_node(self, name, create=False):
        """Find a node in the zone, possibly creating it.

        @param name: the name of the node to find
        @type name: dns.name.Name object or string
        @param create: should the node be created if it doesn't exist?
        @type create: bool
        @raises KeyError: the name is not known and create was not specified.
        @rtype: dns.node.Node object
        """

        name = self._validate_name(name)
        node = self.nodes.get(name)
        if node is None:
            if not create:
                raise KeyError
            node = self.node_factory()
            self.nodes[name] = node
        return node

    def get_node(self, name, create=False):
        """Get a node in the zone, possibly creating it.

        This method is like L{find_node}, except it returns None instead
        of raising an exception if the node does not exist and creation
        has not been requested.

        @param name: the name of the node to find
        @type name: dns.name.Name object or string
        @param create: should the node be created if it doesn't exist?
        @type create: bool
        @rtype: dns.node.Node object or None
        """

        try:
            node = self.find_node(name, create)
        except KeyError:
            node = None
        return node

    def delete_node(self, name):
        """Delete the specified node if it exists.

        It is not an error if the node does not exist.
        """

        name = self._validate_name(name)
        if name in self.nodes:
            del self.nodes[name]

    def find_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,
                      create=False):
        """Look for rdata with the specified name and type in the zone,
        and return an rdataset encapsulating it.

        The I{name}, I{rdtype}, and I{covers} parameters may be
        strings, in which case they will be converted to their proper
        type.

        The rdataset returned is not a copy; changes to it will change
        the zone.

        KeyError is raised if the name or type are not found.
        Use L{get_rdataset} if you want to have None returned instead.

        @param name: the owner name to look for
        @type name: DNS.name.Name object or string
        @param rdtype: the rdata type desired
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        @param create: should the node and rdataset be created if they do not
        exist?
        @type create: bool
        @raises KeyError: the node or rdata could not be found
        @rtype: dns.rrset.RRset object
        """

        name = self._validate_name(name)
        if isinstance(rdtype, (str, unicode)):
            rdtype = dns.rdatatype.from_text(rdtype)
        if isinstance(covers, (str, unicode)):
            covers = dns.rdatatype.from_text(covers)
        node = self.find_node(name, create)
        return node.find_rdataset(self.rdclass, rdtype, covers, create)

    def get_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,
                     create=False):
        """Look for rdata with the specified name and type in the zone,
        and return an rdataset encapsulating it.

        The I{name}, I{rdtype}, and I{covers} parameters may be
        strings, in which case they will be converted to their proper
        type.

        The rdataset returned is not a copy; changes to it will change
        the zone.

        None is returned if the name or type are not found.
        Use L{find_rdataset} if you want to have KeyError raised instead.

        @param name: the owner name to look for
        @type name: DNS.name.Name object or string
        @param rdtype: the rdata type desired
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        @param create: should the node and rdataset be created if they do not
        exist?
        @type create: bool
        @rtype: dns.rrset.RRset object
        """

        try:
            rdataset = self.find_rdataset(name, rdtype, covers, create)
        except KeyError:
            rdataset = None
        return rdataset

    def delete_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """Delete the rdataset matching I{rdtype} and I{covers}, if it
        exists at the node specified by I{name}.

        The I{name}, I{rdtype}, and I{covers} parameters may be
        strings, in which case they will be converted to their proper
        type.

        It is not an error if the node does not exist, or if there is no
        matching rdataset at the node.

        If the node has no rdatasets after the deletion, it will itself
        be deleted.

        @param name: the owner name to look for
        @type name: DNS.name.Name object or string
        @param rdtype: the rdata type desired
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        """

        name = self._validate_name(name)
        if isinstance(rdtype, (str, unicode)):
            rdtype = dns.rdatatype.from_text(rdtype)
        if isinstance(covers, (str, unicode)):
            covers = dns.rdatatype.from_text(covers)
        node = self.get_node(name)
        if not node is None:
            node.delete_rdataset(self.rdclass, rdtype, covers)
            if len(node) == 0:
                self.delete_node(name)

    def replace_rdataset(self, name, replacement):
        """Replace an rdataset at name.

        It is not an error if there is no rdataset matching I{replacement}.

        Ownership of the I{replacement} object is transferred to the zone;
        in other words, this method does not store a copy of I{replacement}
        at the node, it stores I{replacement} itself.

        If the I{name} node does not exist, it is created.

        @param name: the owner name
        @type name: DNS.name.Name object or string
        @param replacement: the replacement rdataset
        @type replacement: dns.rdataset.Rdataset
        """

        if replacement.rdclass != self.rdclass:
            raise ValueError('replacement.rdclass != zone.rdclass')
        node = self.find_node(name, True)
        node.replace_rdataset(replacement)

    def find_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """Look for rdata with the specified name and type in the zone,
        and return an RRset encapsulating it.

        The I{name}, I{rdtype}, and I{covers} parameters may be
        strings, in which case they will be converted to their proper
        type.

        This method is less efficient than the similar
        L{find_rdataset} because it creates an RRset instead of
        returning the matching rdataset.  It may be more convenient
        for some uses since it returns an object which binds the owner
        name to the rdata.

        This method may not be used to create new nodes or rdatasets;
        use L{find_rdataset} instead.

        KeyError is raised if the name or type are not found.
        Use L{get_rrset} if you want to have None returned instead.

        @param name: the owner name to look for
        @type name: DNS.name.Name object or string
        @param rdtype: the rdata type desired
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        @raises KeyError: the node or rdata could not be found
        @rtype: dns.rrset.RRset object
        """

        name = self._validate_name(name)
        if isinstance(rdtype, (str, unicode)):
            rdtype = dns.rdatatype.from_text(rdtype)
        if isinstance(covers, (str, unicode)):
            covers = dns.rdatatype.from_text(covers)
        rdataset = self.nodes[name].find_rdataset(self.rdclass, rdtype, covers)
        rrset = dns.rrset.RRset(name, self.rdclass, rdtype, covers)
        rrset.update(rdataset)
        return rrset

    def get_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """Look for rdata with the specified name and type in the zone,
        and return an RRset encapsulating it.

        The I{name}, I{rdtype}, and I{covers} parameters may be
        strings, in which case they will be converted to their proper
        type.

        This method is less efficient than the similar L{get_rdataset}
        because it creates an RRset instead of returning the matching
        rdataset.  It may be more convenient for some uses since it
        returns an object which binds the owner name to the rdata.

        This method may not be used to create new nodes or rdatasets;
        use L{find_rdataset} instead.

        None is returned if the name or type are not found.
        Use L{find_rrset} if you want to have KeyError raised instead.

        @param name: the owner name to look for
        @type name: DNS.name.Name object or string
        @param rdtype: the rdata type desired
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        @rtype: dns.rrset.RRset object
        """

        try:
            rrset = self.find_rrset(name, rdtype, covers)
        except KeyError:
            rrset = None
        return rrset

    def iterate_rdatasets(self, rdtype=dns.rdatatype.ANY,
                          covers=dns.rdatatype.NONE):
        """Return a generator which yields (name, rdataset) tuples for
        all rdatasets in the zone which have the specified I{rdtype}
        and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,
        then all rdatasets will be matched.

        @param rdtype: int or string
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        """

        if isinstance(rdtype, (str, unicode)):
            rdtype = dns.rdatatype.from_text(rdtype)
        if isinstance(covers, (str, unicode)):
            covers = dns.rdatatype.from_text(covers)
        for (name, node) in self.iteritems():
            for rds in node:
                if rdtype == dns.rdatatype.ANY or \
                   (rds.rdtype == rdtype and rds.covers == covers):
                    yield (name, rds)

    def iterate_rdatas(self, rdtype=dns.rdatatype.ANY,
                       covers=dns.rdatatype.NONE):
        """Return a generator which yields (name, ttl, rdata) tuples for
        all rdatas in the zone which have the specified I{rdtype}
        and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,
        then all rdatas will be matched.

        @param rdtype: int or string
        @type rdtype: int or string
        @param covers: the covered type (defaults to None)
        @type covers: int or string
        """

        if isinstance(rdtype, (str, unicode)):
            rdtype = dns.rdatatype.from_text(rdtype)
        if isinstance(covers, (str, unicode)):
            covers = dns.rdatatype.from_text(covers)
        for (name, node) in self.iteritems():
            for rds in node:
                if rdtype == dns.rdatatype.ANY or \
                   (rds.rdtype == rdtype and rds.covers == covers):
                    for rdata in rds:
                        yield (name, rds.ttl, rdata)

    def to_file(self, f, sorted=True, relativize=True, nl=None):
        """Write a zone to a file.

        @param f: file or string.  If I{f} is a string, it is treated
        as the name of a file to open.
        @param sorted: if True, the file will be written with the
        names sorted in DNSSEC order from least to greatest.  Otherwise
        the names will be written in whatever order they happen to have
        in the zone's dictionary.
        @param relativize: if True, domain names in the output will be
        relativized to the zone's origin (if possible).
        @type relativize: bool
        @param nl: The end of line string.  If not specified, the
        output will use the platform's native end-of-line marker (i.e.
        LF on POSIX, CRLF on Windows, CR on Macintosh).
        @type nl: string or None
        """

        if sys.hexversion >= 0x02030000:
            # allow Unicode filenames
            str_type = basestring
        else:
            str_type = str
        if nl is None:
            opts = 'w'
        else:
            opts = 'wb'
        if isinstance(f, str_type):
            f = file(f, opts)
            want_close = True
        else:
            want_close = False
        try:
            if sorted:
                names = self.keys()
                names.sort()
            else:
                names = self.iterkeys()
            for n in names:
                l = self[n].to_text(n, origin=self.origin,
                                    relativize=relativize)
                if nl is None:
                    print >> f, l
                else:
                    f.write(l)
                    f.write(nl)
        finally:
            if want_close:
                f.close()

    def check_origin(self):
        """Do some simple checking of the zone's origin.

        @raises dns.zone.NoSOA: there is no SOA RR
        @raises dns.zone.NoNS: there is no NS RRset
        @raises KeyError: there is no origin node
        """
        if self.relativize:
            name = dns.name.empty
        else:
            name = self.origin
        if self.get_rdataset(name, dns.rdatatype.SOA) is None:
            raise NoSOA
        if self.get_rdataset(name, dns.rdatatype.NS) is None:
            raise NoNS


class _MasterReader(object):
    """Read a DNS master file

    @ivar tok: The tokenizer
    @type tok: dns.tokenizer.Tokenizer object
    @ivar ttl: The default TTL
    @type ttl: int
    @ivar last_name: The last name read
    @type last_name: dns.name.Name object
    @ivar current_origin: The current origin
    @type current_origin: dns.name.Name object
    @ivar relativize: should names in the zone be relativized?
    @type relativize: bool
    @ivar zone: the zone
    @type zone: dns.zone.Zone object
    @ivar saved_state: saved reader state (used when processing $INCLUDE)
    @type saved_state: list of (tokenizer, current_origin, last_name, file)
    tuples.
    @ivar current_file: the file object of the $INCLUDed file being parsed
    (None if no $INCLUDE is active).
    @ivar allow_include: is $INCLUDE allowed?
    @type allow_include: bool
    @ivar check_origin: should sanity checks of the origin node be done?
    The default is True.
    @type check_origin: bool
    """

    def __init__(self, tok, origin, rdclass, relativize, zone_factory=Zone,
                 allow_include=False, check_origin=True):
        if isinstance(origin, (str, unicode)):
            origin = dns.name.from_text(origin)
        self.tok = tok
        self.current_origin = origin
        self.relativize = relativize
        self.ttl = 0
        self.last_name = None
        self.zone = zone_factory(origin, rdclass, relativize=relativize)
        self.saved_state = []
        self.current_file = None
        self.allow_include = allow_include
        self.check_origin = check_origin

    def _eat_line(self):
        while 1:
            token = self.tok.get()
            if token.is_eol_or_eof():
                break

    def _rr_line(self):
        """Process one line from a DNS master file."""
        # Name
        if self.current_origin is None:
            raise UnknownOrigin
        token = self.tok.get(want_leading = True)
        if not token.is_whitespace():
            self.last_name = dns.name.from_text(token.value, self.current_origin)
        else:
            token = self.tok.get()
            if token.is_eol_or_eof():
                # treat leading WS followed by EOL/EOF as if they were EOL/EOF.
                return
            self.tok.unget(token)
        name = self.last_name
        if not name.is_subdomain(self.zone.origin):
            self._eat_line()
            return
        if self.relativize:
            name = name.relativize(self.zone.origin)
        token = self.tok.get()
        if not token.is_identifier():
            raise dns.exception.SyntaxError
        # TTL
        try:
            ttl = dns.ttl.from_text(token.value)
            token = self.tok.get()
            if not token.is_identifier():
                raise dns.exception.SyntaxError
        except dns.ttl.BadTTL:
            ttl = self.ttl
        # Class
        try:
            rdclass = dns.rdataclass.from_text(token.value)
            token = self.tok.get()
            if not token.is_identifier():
                raise dns.exception.SyntaxError
        except dns.exception.SyntaxError:
            raise
        except StandardError:
            rdclass = self.zone.rdclass
        if rdclass != self.zone.rdclass:
            raise dns.exception.SyntaxError("RR class is not zone's class")
        # Type
        try:
            rdtype = dns.rdatatype.from_text(token.value)
        except StandardError:
            raise dns.exception.SyntaxError("unknown rdatatype '%s'" % token.value)
        n = self.zone.nodes.get(name)
        if n is None:
            n = self.zone.node_factory()
            self.zone.nodes[name] = n
        try:
            rd = dns.rdata.from_text(rdclass, rdtype, self.tok,
                                     self.current_origin, False)
        except dns.exception.SyntaxError:
            # Catch and reraise.
            (ty, va) = sys.exc_info()[:2]
            raise va
        except StandardError:
            # All exceptions that occur in the processing of rdata
            # are treated as syntax errors.  This is not strictly
            # correct, but it is correct almost all of the time.
            # We convert them to syntax errors so that we can emit
            # helpful filename:line info.
            (ty, va) = sys.exc_info()[:2]
            raise dns.exception.SyntaxError("caught exception %s: %s" % (str(ty), str(va)))

        rd.choose_relativity(self.zone.origin, self.relativize)
        covers = rd.covers()
        rds = n.find_rdataset(rdclass, rdtype, covers, True)
        rds.add(rd, ttl)

    def read(self):
        """Read a DNS master file and build a zone object.

        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
        """

        try:
            while 1:
                token = self.tok.get(True, True).unescape()
                if token.is_eof():
                    if not self.current_file is None:
                        self.current_file.close()
                    if len(self.saved_state) > 0:
                        (self.tok,
                         self.current_origin,
                         self.last_name,
                         self.current_file,
                         self.ttl) = self.saved_state.pop(-1)
                        continue
                    break
                elif token.is_eol():
                    continue
                elif token.is_comment():
                    self.tok.get_eol()
                    continue
                elif token.value[0] == '$':
                    u = token.value.upper()
                    if u == '$TTL':
                        token = self.tok.get()
                        if not token.is_identifier():
                            raise dns.exception.SyntaxError("bad $TTL")
                        self.ttl = dns.ttl.from_text(token.value)
                        self.tok.get_eol()
                    elif u == '$ORIGIN':
                        self.current_origin = self.tok.get_name()
                        self.tok.get_eol()
                        if self.zone.origin is None:
                            self.zone.origin = self.current_origin
                    elif u == '$INCLUDE' and self.allow_include:
                        token = self.tok.get()
                        if not token.is_quoted_string():
                            raise dns.exception.SyntaxError("bad filename in $INCLUDE")
                        filename = token.value
                        token = self.tok.get()
                        if token.is_identifier():
                            new_origin = dns.name.from_text(token.value, \
                                                            self.current_origin)
                            self.tok.get_eol()
                        elif not token.is_eol_or_eof():
                            raise dns.exception.SyntaxError("bad origin in $INCLUDE")
                        else:
                            new_origin = self.current_origin
                        self.saved_state.append((self.tok,
                                                 self.current_origin,
                                                 self.last_name,
                                                 self.current_file,
                                                 self.ttl))
                        self.current_file = file(filename, 'r')
                        self.tok = dns.tokenizer.Tokenizer(self.current_file,
                                                           filename)
                        self.current_origin = new_origin
                    else:
                        raise dns.exception.SyntaxError("Unknown master file directive '" + u + "'")
                    continue
                self.tok.unget(token)
                self._rr_line()
        except dns.exception.SyntaxError, detail:
            (filename, line_number) = self.tok.where()
            if detail is None:
                detail = "syntax error"
            raise dns.exception.SyntaxError("%s:%d: %s" % (filename, line_number, detail))

        # Now that we're done reading, do some basic checking of the zone.
        if self.check_origin:
            self.zone.check_origin()

def from_text(text, origin = None, rdclass = dns.rdataclass.IN,
              relativize = True, zone_factory=Zone, filename=None,
              allow_include=False, check_origin=True):
    """Build a zone object from a master file format string.

    @param text: the master file format input
    @type text: string.
    @param origin: The origin of the zone; if not specified, the first
    $ORIGIN statement in the master file will determine the origin of the
    zone.
    @type origin: dns.name.Name object or string
    @param rdclass: The zone's rdata class; the default is class IN.
    @type rdclass: int
    @param relativize: should names be relativized?  The default is True
    @type relativize: bool
    @param zone_factory: The zone factory to use
    @type zone_factory: function returning a Zone
    @param filename: The filename to emit when describing where an error
    occurred; the default is '<string>'.
    @type filename: string
    @param allow_include: is $INCLUDE allowed?
    @type allow_include: bool
    @param check_origin: should sanity checks of the origin node be done?
    The default is True.
    @type check_origin: bool
    @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
    @raises dns.zone.NoNS: No NS RRset was found at the zone origin
    @rtype: dns.zone.Zone object
    """

    # 'text' can also be a file, but we don't publish that fact
    # since it's an implementation detail.  The official file
    # interface is from_file().

    if filename is None:
        filename = '<string>'
    tok = dns.tokenizer.Tokenizer(text, filename)
    reader = _MasterReader(tok, origin, rdclass, relativize, zone_factory,
                           allow_include=allow_include,
                           check_origin=check_origin)
    reader.read()
    return reader.zone

def from_file(f, origin = None, rdclass = dns.rdataclass.IN,
              relativize = True, zone_factory=Zone, filename=None,
              allow_include=True, check_origin=True):
    """Read a master file and build a zone object.

    @param f: file or string.  If I{f} is a string, it is treated
    as the name of a file to open.
    @param origin: The origin of the zone; if not specified, the first
    $ORIGIN statement in the master file will determine the origin of the
    zone.
    @type origin: dns.name.Name object or string
    @param rdclass: The zone's rdata class; the default is class IN.
    @type rdclass: int
    @param relativize: should names be relativized?  The default is True
    @type relativize: bool
    @param zone_factory: The zone factory to use
    @type zone_factory: function returning a Zone
    @param filename: The filename to emit when describing where an error
    occurred; the default is '<file>', or the value of I{f} if I{f} is a
    string.
    @type filename: string
    @param allow_include: is $INCLUDE allowed?
    @type allow_include: bool
    @param check_origin: should sanity checks of the origin node be done?
    The default is True.
    @type check_origin: bool
    @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
    @raises dns.zone.NoNS: No NS RRset was found at the zone origin
    @rtype: dns.zone.Zone object
    """

    if sys.hexversion >= 0x02030000:
        # allow Unicode filenames; turn on universal newline support
        str_type = basestring
        opts = 'rU'
    else:
        str_type = str
        opts = 'r'
    if isinstance(f, str_type):
        if filename is None:
            filename = f
        f = file(f, opts)
        want_close = True
    else:
        if filename is None:
            filename = '<file>'
        want_close = False

    try:
        z = from_text(f, origin, rdclass, relativize, zone_factory,
                      filename, allow_include, check_origin)
    finally:
        if want_close:
            f.close()
    return z

def from_xfr(xfr, zone_factory=Zone, relativize=True):
    """Convert the output of a zone transfer generator into a zone object.

    @param xfr: The xfr generator
    @type xfr: generator of dns.message.Message objects
    @param relativize: should names be relativized?  The default is True.
    It is essential that the relativize setting matches the one specified
    to dns.query.xfr().
    @type relativize: bool
    @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
    @raises dns.zone.NoNS: No NS RRset was found at the zone origin
    @rtype: dns.zone.Zone object
    """

    z = None
    for r in xfr:
        if z is None:
            if relativize:
                origin = r.origin
            else:
                origin = r.answer[0].name
            rdclass = r.answer[0].rdclass
            z = zone_factory(origin, rdclass, relativize=relativize)
        for rrset in r.answer:
            znode = z.nodes.get(rrset.name)
            if not znode:
                znode = z.node_factory()
                z.nodes[rrset.name] = znode
            zrds = znode.find_rdataset(rrset.rdclass, rrset.rdtype,
                                       rrset.covers, True)
            zrds.update_ttl(rrset.ttl)
            for rd in rrset:
                rd.choose_relativity(z.origin, relativize)
                zrds.add(rd)
    z.check_origin()
    return z

########NEW FILE########
__FILENAME__ = bugs
# Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.rdata
import dns.rdataclass
import dns.rdatatype
import dns.ttl

class BugsTestCase(unittest.TestCase):

    def test_float_LOC(self):
        rdata = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.LOC,
                                    "30 30 0.000 N 100 30 0.000 W 10.00m 20m 2000m 20m")
        self.failUnless(rdata.float_latitude == 30.5)
        self.failUnless(rdata.float_longitude == -100.5)

    def test_SOA_BIND8_TTL(self):
        rdata1 = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.SOA,
                                     "a b 100 1s 1m 1h 1d")
        rdata2 = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.SOA,
                                     "a b 100 1 60 3600 86400")
        self.failUnless(rdata1 == rdata2)

    def test_TTL_bounds_check(self):
        def bad():
            ttl = dns.ttl.from_text("2147483648")
        self.failUnlessRaises(dns.ttl.BadTTL, bad)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = dnssec
# Copyright (C) 2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.dnssec
import dns.name
import dns.rdata
import dns.rdataclass
import dns.rdatatype
import dns.rrset

abs_dnspython_org = dns.name.from_text('dnspython.org')

abs_keys = { abs_dnspython_org :
             dns.rrset.from_text('dnspython.org.', 3600, 'IN', 'DNSKEY',
                                 '257 3 5 AwEAAenVTr9L1OMlL1/N2ta0Qj9LLLnnmFWIr1dJoAsWM9BQfsbV7kFZ XbAkER/FY9Ji2o7cELxBwAsVBuWn6IUUAJXLH74YbC1anY0lifjgt29z SwDzuB7zmC7yVYZzUunBulVW4zT0tg1aePbpVL2EtTL8VzREqbJbE25R KuQYHZtFwG8S4iBxJUmT2Bbd0921LLxSQgVoFXlQx/gFV2+UERXcJ5ce iX6A6wc02M/pdg/YbJd2rBa0MYL3/Fz/Xltre0tqsImZGxzi6YtYDs45 NC8gH+44egz82e2DATCVM1ICPmRDjXYTLldQiWA2ZXIWnK0iitl5ue24 7EsWJefrIhE=',
                                 '256 3 5 AwEAAdSSghOGjU33IQZgwZM2Hh771VGXX05olJK49FxpSyuEAjDBXY58 LGU9R2Zgeecnk/b9EAhFu/vCV9oECtiTCvwuVAkt9YEweqYDluQInmgP NGMJCKdSLlnX93DkjDw8rMYv5dqXCuSGPlKChfTJOLQxIAxGloS7lL+c 0CTZydAF')
         }

rel_keys = { dns.name.empty :
             dns.rrset.from_text('@', 3600, 'IN', 'DNSKEY',
                                 '257 3 5 AwEAAenVTr9L1OMlL1/N2ta0Qj9LLLnnmFWIr1dJoAsWM9BQfsbV7kFZ XbAkER/FY9Ji2o7cELxBwAsVBuWn6IUUAJXLH74YbC1anY0lifjgt29z SwDzuB7zmC7yVYZzUunBulVW4zT0tg1aePbpVL2EtTL8VzREqbJbE25R KuQYHZtFwG8S4iBxJUmT2Bbd0921LLxSQgVoFXlQx/gFV2+UERXcJ5ce iX6A6wc02M/pdg/YbJd2rBa0MYL3/Fz/Xltre0tqsImZGxzi6YtYDs45 NC8gH+44egz82e2DATCVM1ICPmRDjXYTLldQiWA2ZXIWnK0iitl5ue24 7EsWJefrIhE=',
                                 '256 3 5 AwEAAdSSghOGjU33IQZgwZM2Hh771VGXX05olJK49FxpSyuEAjDBXY58 LGU9R2Zgeecnk/b9EAhFu/vCV9oECtiTCvwuVAkt9YEweqYDluQInmgP NGMJCKdSLlnX93DkjDw8rMYv5dqXCuSGPlKChfTJOLQxIAxGloS7lL+c 0CTZydAF')
         }

when = 1290250287

abs_soa = dns.rrset.from_text('dnspython.org.', 3600, 'IN', 'SOA',
                              'howl.dnspython.org. hostmaster.dnspython.org. 2010020047 3600 1800 604800 3600')

abs_other_soa = dns.rrset.from_text('dnspython.org.', 3600, 'IN', 'SOA',
                                    'foo.dnspython.org. hostmaster.dnspython.org. 2010020047 3600 1800 604800 3600')

abs_soa_rrsig = dns.rrset.from_text('dnspython.org.', 3600, 'IN', 'RRSIG',
                                    'SOA 5 2 3600 20101127004331 20101119213831 61695 dnspython.org. sDUlltRlFTQw5ITFxOXW3TgmrHeMeNpdqcZ4EXxM9FHhIlte6V9YCnDw t6dvM9jAXdIEi03l9H/RAd9xNNW6gvGMHsBGzpvvqFQxIBR2PoiZA1mX /SWHZFdbt4xjYTtXqpyYvrMK0Dt7bUYPadyhPFCJ1B+I8Zi7B5WJEOd0 8vs=')

rel_soa = dns.rrset.from_text('@', 3600, 'IN', 'SOA',
                              'howl hostmaster 2010020047 3600 1800 604800 3600')

rel_other_soa = dns.rrset.from_text('@', 3600, 'IN', 'SOA',
                                    'foo hostmaster 2010020047 3600 1800 604800 3600')

rel_soa_rrsig = dns.rrset.from_text('@', 3600, 'IN', 'RRSIG',
                                    'SOA 5 2 3600 20101127004331 20101119213831 61695 @ sDUlltRlFTQw5ITFxOXW3TgmrHeMeNpdqcZ4EXxM9FHhIlte6V9YCnDw t6dvM9jAXdIEi03l9H/RAd9xNNW6gvGMHsBGzpvvqFQxIBR2PoiZA1mX /SWHZFdbt4xjYTtXqpyYvrMK0Dt7bUYPadyhPFCJ1B+I8Zi7B5WJEOd0 8vs=')

sep_key = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DNSKEY,
                              '257 3 5 AwEAAenVTr9L1OMlL1/N2ta0Qj9LLLnnmFWIr1dJoAsWM9BQfsbV7kFZ XbAkER/FY9Ji2o7cELxBwAsVBuWn6IUUAJXLH74YbC1anY0lifjgt29z SwDzuB7zmC7yVYZzUunBulVW4zT0tg1aePbpVL2EtTL8VzREqbJbE25R KuQYHZtFwG8S4iBxJUmT2Bbd0921LLxSQgVoFXlQx/gFV2+UERXcJ5ce iX6A6wc02M/pdg/YbJd2rBa0MYL3/Fz/Xltre0tqsImZGxzi6YtYDs45 NC8gH+44egz82e2DATCVM1ICPmRDjXYTLldQiWA2ZXIWnK0iitl5ue24 7EsWJefrIhE=')

good_ds = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DS,
                              '57349 5 2 53A79A3E7488AB44FFC56B2D1109F0699D1796DD977E72108B841F96 E47D7013')

when2 = 1290425644

abs_example = dns.name.from_text('example')

abs_dsa_keys = { abs_example :
                 dns.rrset.from_text('example.', 86400, 'IN', 'DNSKEY',
                                     '257 3 3 CI3nCqyJsiCJHTjrNsJOT4RaszetzcJPYuoH3F9ZTVt3KJXncCVR3bwn 1w0iavKljb9hDlAYSfHbFCp4ic/rvg4p1L8vh5s8ToMjqDNl40A0hUGQ Ybx5hsECyK+qHoajilUX1phYSAD8d9WAGO3fDWzUPBuzR7o85NiZCDxz yXuNVfni0uhj9n1KYhEO5yAbbruDGN89wIZcxMKuQsdUY2GYD93ssnBv a55W6XRABYWayKZ90WkRVODLVYLSn53Pj/wwxGH+XdhIAZJXimrZL4yl My7rtBsLMqq8Ihs4Tows7LqYwY7cp6y/50tw6pj8tFqMYcPUjKZV36l1 M/2t5BVg3i7IK61Aidt6aoC3TDJtzAxg3ZxfjZWJfhHjMJqzQIfbW5b9 q1mjFsW5EUv39RaNnX+3JWPRLyDqD4pIwDyqfutMsdk/Py3paHn82FGp CaOg+nicqZ9TiMZURN/XXy5JoXUNQ3RNvbHCUiPUe18KUkY6mTfnyHld 1l9YCWmzXQVClkx/hOYxjJ4j8Ife58+Obu5X',
                                     '256 3 3 CJE1yb9YRQiw5d2xZrMUMR+cGCTt1bp1KDCefmYKmS+Z1+q9f42ETVhx JRiQwXclYwmxborzIkSZegTNYIV6mrYwbNB27Q44c3UGcspb3PiOw5TC jNPRYEcdwGvDZ2wWy+vkSV/S9tHXY8O6ODiE6abZJDDg/RnITyi+eoDL R3KZ5n/V1f1T1b90rrV6EewhBGQJpQGDogaXb2oHww9Tm6NfXyo7SoMM pbwbzOckXv+GxRPJIQNSF4D4A9E8XCksuzVVdE/0lr37+uoiAiPia38U 5W2QWe/FJAEPLjIp2eTzf0TrADc1pKP1wrA2ASpdzpm/aX3IB5RPp8Ew S9U72eBFZJAUwg635HxJVxH1maG6atzorR566E+e0OZSaxXS9o1o6QqN 3oPlYLGPORDiExilKfez3C/x/yioOupW9K5eKF0gmtaqrHX0oq9s67f/ RIM2xVaKHgG9Vf2cgJIZkhv7sntujr+E4htnRmy9P9BxyFxsItYxPI6Z bzygHAZpGhlI/7ltEGlIwKxyTK3ZKBm67q7B')
                 }

abs_dsa_soa = dns.rrset.from_text('example.', 86400, 'IN', 'SOA',
                                  'ns1.example. hostmaster.example. 2 10800 3600 604800 86400')

abs_other_dsa_soa = dns.rrset.from_text('example.', 86400, 'IN', 'SOA',
                                        'ns1.example. hostmaster.example. 2 10800 3600 604800 86401')

abs_dsa_soa_rrsig = dns.rrset.from_text('example.', 86400, 'IN', 'RRSIG',
                                        'SOA 3 1 86400 20101129143231 20101122112731 42088 example. CGul9SuBofsktunV8cJs4eRs6u+3NCS3yaPKvBbD+pB2C76OUXDZq9U=')

example_sep_key = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DNSKEY,
                                      '257 3 3 CI3nCqyJsiCJHTjrNsJOT4RaszetzcJPYuoH3F9ZTVt3KJXncCVR3bwn 1w0iavKljb9hDlAYSfHbFCp4ic/rvg4p1L8vh5s8ToMjqDNl40A0hUGQ Ybx5hsECyK+qHoajilUX1phYSAD8d9WAGO3fDWzUPBuzR7o85NiZCDxz yXuNVfni0uhj9n1KYhEO5yAbbruDGN89wIZcxMKuQsdUY2GYD93ssnBv a55W6XRABYWayKZ90WkRVODLVYLSn53Pj/wwxGH+XdhIAZJXimrZL4yl My7rtBsLMqq8Ihs4Tows7LqYwY7cp6y/50tw6pj8tFqMYcPUjKZV36l1 M/2t5BVg3i7IK61Aidt6aoC3TDJtzAxg3ZxfjZWJfhHjMJqzQIfbW5b9 q1mjFsW5EUv39RaNnX+3JWPRLyDqD4pIwDyqfutMsdk/Py3paHn82FGp CaOg+nicqZ9TiMZURN/XXy5JoXUNQ3RNvbHCUiPUe18KUkY6mTfnyHld 1l9YCWmzXQVClkx/hOYxjJ4j8Ife58+Obu5X')

example_ds_sha1 = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DS,
                                      '18673 3 1 71b71d4f3e11bbd71b4eff12cde69f7f9215bbe7')

example_ds_sha256 = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DS,
                                        '18673 3 2 eb8344cbbf07c9d3d3d6c81d10c76653e28d8611a65e639ef8f716e4e4e5d913')

class DNSSECValidatorTestCase(unittest.TestCase):

    def testAbsoluteRSAGood(self):
        dns.dnssec.validate(abs_soa, abs_soa_rrsig, abs_keys, None, when)

    def testAbsoluteRSABad(self):
        def bad():
            dns.dnssec.validate(abs_other_soa, abs_soa_rrsig, abs_keys, None,
                                when)
        self.failUnlessRaises(dns.dnssec.ValidationFailure, bad)

    def testRelativeRSAGood(self):
        dns.dnssec.validate(rel_soa, rel_soa_rrsig, rel_keys,
                            abs_dnspython_org, when)

    def testRelativeRSABad(self):
        def bad():
            dns.dnssec.validate(rel_other_soa, rel_soa_rrsig, rel_keys,
                                abs_dnspython_org, when)
        self.failUnlessRaises(dns.dnssec.ValidationFailure, bad)

    def testMakeSHA256DS(self):
        ds = dns.dnssec.make_ds(abs_dnspython_org, sep_key, 'SHA256')
        self.failUnless(ds == good_ds)

    def testAbsoluteDSAGood(self):
        dns.dnssec.validate(abs_dsa_soa, abs_dsa_soa_rrsig, abs_dsa_keys, None,
                            when2)

    def testAbsoluteDSABad(self):
        def bad():
            dns.dnssec.validate(abs_other_dsa_soa, abs_dsa_soa_rrsig,
                                abs_dsa_keys, None, when2)
        self.failUnlessRaises(dns.dnssec.ValidationFailure, bad)

    def testMakeExampleSHA1DS(self):
        ds = dns.dnssec.make_ds(abs_example, example_sep_key, 'SHA1')
        self.failUnless(ds == example_ds_sha1)

    def testMakeExampleSHA256DS(self):
        ds = dns.dnssec.make_ds(abs_example, example_sep_key, 'SHA256')
        self.failUnless(ds == example_ds_sha256)

if __name__ == '__main__':
    import_ok = False
    try:
        import Crypto.Util.number
        import_ok = True
    except:
        pass
    if import_ok:
        unittest.main()
    else:
        print 'skipping DNSSEC tests because pycrypto is not installed'

########NEW FILE########
__FILENAME__ = flags
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.flags
import dns.rcode
import dns.opcode

class FlagsTestCase(unittest.TestCase):

    def test_rcode1(self):
        self.failUnless(dns.rcode.from_text('FORMERR') ==  dns.rcode.FORMERR)

    def test_rcode2(self):
        self.failUnless(dns.rcode.to_text(dns.rcode.FORMERR) == "FORMERR")

    def test_rcode3(self):
        self.failUnless(dns.rcode.to_flags(dns.rcode.FORMERR) == (1, 0))

    def test_rcode4(self):
        self.failUnless(dns.rcode.to_flags(dns.rcode.BADVERS) == \
                        (0, 0x01000000))

    def test_rcode6(self):
        self.failUnless(dns.rcode.from_flags(0, 0x01000000) == \
                        dns.rcode.BADVERS)

    def test_rcode6(self):
        self.failUnless(dns.rcode.from_flags(5, 0) == dns.rcode.REFUSED)

    def test_rcode7(self):
        def bad():
            dns.rcode.to_flags(4096)
        self.failUnlessRaises(ValueError, bad)

    def test_flags1(self):
        self.failUnless(dns.flags.from_text("RA RD AA QR") == \
                        dns.flags.QR|dns.flags.AA|dns.flags.RD|dns.flags.RA)

    def test_flags2(self):
        flags = dns.flags.QR|dns.flags.AA|dns.flags.RD|dns.flags.RA
        self.failUnless(dns.flags.to_text(flags) == "QR AA RD RA")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = message
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import os
import unittest

import dns.exception
import dns.message

query_text = """id 1234
opcode QUERY
rcode NOERROR
flags RD
edns 0
eflags DO
payload 4096
;QUESTION
wwww.dnspython.org. IN A
;ANSWER
;AUTHORITY
;ADDITIONAL"""

goodhex = '04d201000001000000000001047777777709646e73707974686f6e' \
          '036f726700000100010000291000000080000000'

goodwire = goodhex.decode('hex_codec')

answer_text = """id 1234
opcode QUERY
rcode NOERROR
flags QR AA RD
;QUESTION
dnspython.org. IN SOA
;ANSWER
dnspython.org. 3600 IN SOA woof.dnspython.org. hostmaster.dnspython.org. 2003052700 3600 1800 604800 3600
;AUTHORITY
dnspython.org. 3600 IN NS ns1.staff.nominum.org.
dnspython.org. 3600 IN NS ns2.staff.nominum.org.
dnspython.org. 3600 IN NS woof.play-bow.org.
;ADDITIONAL
woof.play-bow.org. 3600 IN A 204.152.186.150
"""

goodhex2 = '04d2 8500 0001 0001 0003 0001' \
           '09646e73707974686f6e036f726700 0006 0001' \
           'c00c 0006 0001 00000e10 0028 ' \
               '04776f6f66c00c 0a686f73746d6173746572c00c' \
               '7764289c 00000e10 00000708 00093a80 00000e10' \
           'c00c 0002 0001 00000e10 0014' \
               '036e7331057374616666076e6f6d696e756dc016' \
           'c00c 0002 0001 00000e10 0006 036e7332c063' \
           'c00c 0002 0001 00000e10 0010 04776f6f6608706c61792d626f77c016' \
           'c091 0001 0001 00000e10 0004 cc98ba96'


goodwire2 = goodhex2.replace(' ', '').decode('hex_codec')

query_text_2 = """id 1234
opcode QUERY
rcode 4095
flags RD
edns 0
eflags DO
payload 4096
;QUESTION
wwww.dnspython.org. IN A
;ANSWER
;AUTHORITY
;ADDITIONAL"""

goodhex3 = '04d2010f0001000000000001047777777709646e73707974686f6e' \
          '036f726700000100010000291000ff0080000000'

goodwire3 = goodhex3.decode('hex_codec')

class MessageTestCase(unittest.TestCase):

    def test_comparison_eq1(self):
        q1 = dns.message.from_text(query_text)
        q2 = dns.message.from_text(query_text)
        self.failUnless(q1 == q2)

    def test_comparison_ne1(self):
        q1 = dns.message.from_text(query_text)
        q2 = dns.message.from_text(query_text)
        q2.id = 10
        self.failUnless(q1 != q2)

    def test_comparison_ne2(self):
        q1 = dns.message.from_text(query_text)
        q2 = dns.message.from_text(query_text)
        q2.question = []
        self.failUnless(q1 != q2)

    def test_comparison_ne3(self):
        q1 = dns.message.from_text(query_text)
        self.failUnless(q1 != 1)

    def test_EDNS_to_wire1(self):
        q = dns.message.from_text(query_text)
        w = q.to_wire()
        self.failUnless(w == goodwire)

    def test_EDNS_from_wire1(self):
        m = dns.message.from_wire(goodwire)
        self.failUnless(str(m) == query_text)

    def test_EDNS_to_wire2(self):
        q = dns.message.from_text(query_text_2)
        w = q.to_wire()
        self.failUnless(w == goodwire3)

    def test_EDNS_from_wire2(self):
        m = dns.message.from_wire(goodwire3)
        self.failUnless(str(m) == query_text_2)

    def test_TooBig(self):
        def bad():
            q = dns.message.from_text(query_text)
            for i in xrange(0, 25):
                rrset = dns.rrset.from_text('foo%d.' % i, 3600,
                                            dns.rdataclass.IN,
                                            dns.rdatatype.A,
                                            '10.0.0.%d' % i)
                q.additional.append(rrset)
            w = q.to_wire(max_size=512)
        self.failUnlessRaises(dns.exception.TooBig, bad)

    def test_answer1(self):
        a = dns.message.from_text(answer_text)
        wire = a.to_wire(want_shuffle=False)
        self.failUnless(wire == goodwire2)

    def test_TrailingJunk(self):
        def bad():
            badwire = goodwire + '\x00'
            m = dns.message.from_wire(badwire)
        self.failUnlessRaises(dns.message.TrailingJunk, bad)

    def test_ShortHeader(self):
        def bad():
            badwire = '\x00' * 11
            m = dns.message.from_wire(badwire)
        self.failUnlessRaises(dns.message.ShortHeader, bad)

    def test_RespondingToResponse(self):
        def bad():
            q = dns.message.make_query('foo', 'A')
            r1 = dns.message.make_response(q)
            r2 = dns.message.make_response(r1)
        self.failUnlessRaises(dns.exception.FormError, bad)

    def test_ExtendedRcodeSetting(self):
        m = dns.message.make_query('foo', 'A')
        m.set_rcode(4095)
        self.failUnless(m.rcode() == 4095)
        m.set_rcode(2)
        self.failUnless(m.rcode() == 2)

    def test_EDNSVersionCoherence(self):
        m = dns.message.make_query('foo', 'A')
        m.use_edns(1)
        self.failUnless((m.ednsflags >> 16) & 0xFF == 1)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = name
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import cStringIO
import socket

import dns.name
import dns.reversename
import dns.e164

class NameTestCase(unittest.TestCase):
    def setUp(self):
        self.origin = dns.name.from_text('example.')

    def testFromTextRel1(self):
        n = dns.name.from_text('foo.bar')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testFromTextRel2(self):
        n = dns.name.from_text('foo.bar', origin=self.origin)
        self.failUnless(n.labels == ('foo', 'bar', 'example', ''))

    def testFromTextRel3(self):
        n = dns.name.from_text('foo.bar', origin=None)
        self.failUnless(n.labels == ('foo', 'bar'))

    def testFromTextRel4(self):
        n = dns.name.from_text('@', origin=None)
        self.failUnless(n == dns.name.empty)

    def testFromTextRel5(self):
        n = dns.name.from_text('@', origin=self.origin)
        self.failUnless(n == self.origin)

    def testFromTextAbs1(self):
        n = dns.name.from_text('foo.bar.')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testTortureFromText(self):
        good = [
            r'.',
            r'a',
            r'a.',
            r'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
            r'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
            r'\000.\008.\010.\032.\046.\092.\099.\255',
            r'\\',
            r'\..\.',
            r'\\.\\',
            r'!"#%&/()=+-',
            r'\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255',
            ]
        bad = [
            r'..',
            r'.a',
            r'\\..',
            '\\',                # yes, we don't want the 'r' prefix!
            r'\0',
            r'\00',
            r'\00Z',
            r'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
            r'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
            r'\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255.\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255',
            ]
        for t in good:
            try:
                n = dns.name.from_text(t)
            except:
                self.fail("good test '%s' raised an exception" % t)
        for t in bad:
            caught = False
            try:
                n = dns.name.from_text(t)
            except:
                caught = True
            if not caught:
                self.fail("bad test '%s' did not raise an exception" % t)

    def testImmutable1(self):
        def bad():
            self.origin.labels = ()
        self.failUnlessRaises(TypeError, bad)

    def testImmutable2(self):
        def bad():
            self.origin.labels[0] = 'foo'
        self.failUnlessRaises(TypeError, bad)

    def testAbs1(self):
        self.failUnless(dns.name.root.is_absolute())

    def testAbs2(self):
        self.failUnless(not dns.name.empty.is_absolute())

    def testAbs3(self):
        self.failUnless(self.origin.is_absolute())

    def testAbs3(self):
        n = dns.name.from_text('foo', origin=None)
        self.failUnless(not n.is_absolute())

    def testWild1(self):
        n = dns.name.from_text('*.foo', origin=None)
        self.failUnless(n.is_wild())

    def testWild2(self):
        n = dns.name.from_text('*a.foo', origin=None)
        self.failUnless(not n.is_wild())

    def testWild3(self):
        n = dns.name.from_text('a.*.foo', origin=None)
        self.failUnless(not n.is_wild())

    def testWild4(self):
        self.failUnless(not dns.name.root.is_wild())

    def testWild5(self):
        self.failUnless(not dns.name.empty.is_wild())

    def testHash1(self):
        n1 = dns.name.from_text('fOo.COM')
        n2 = dns.name.from_text('foo.com')
        self.failUnless(hash(n1) == hash(n2))

    def testCompare1(self):
        n1 = dns.name.from_text('a')
        n2 = dns.name.from_text('b')
        self.failUnless(n1 < n2)
        self.failUnless(n2 > n1)

    def testCompare2(self):
        n1 = dns.name.from_text('')
        n2 = dns.name.from_text('b')
        self.failUnless(n1 < n2)
        self.failUnless(n2 > n1)

    def testCompare3(self):
        self.failUnless(dns.name.empty < dns.name.root)
        self.failUnless(dns.name.root > dns.name.empty)

    def testCompare4(self):
        self.failUnless(dns.name.root != 1)

    def testCompare5(self):
        self.failUnless(dns.name.root < 1 or dns.name.root > 1)

    def testSubdomain1(self):
        self.failUnless(not dns.name.empty.is_subdomain(dns.name.root))

    def testSubdomain2(self):
        self.failUnless(not dns.name.root.is_subdomain(dns.name.empty))

    def testSubdomain3(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(n.is_subdomain(self.origin))

    def testSubdomain4(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(n.is_subdomain(dns.name.root))

    def testSubdomain5(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(n.is_subdomain(n))

    def testSuperdomain1(self):
        self.failUnless(not dns.name.empty.is_superdomain(dns.name.root))

    def testSuperdomain2(self):
        self.failUnless(not dns.name.root.is_superdomain(dns.name.empty))

    def testSuperdomain3(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(self.origin.is_superdomain(n))

    def testSuperdomain4(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(dns.name.root.is_superdomain(n))

    def testSuperdomain5(self):
        n = dns.name.from_text('foo', origin=self.origin)
        self.failUnless(n.is_superdomain(n))

    def testCanonicalize1(self):
        n = dns.name.from_text('FOO.bar', origin=self.origin)
        c = n.canonicalize()
        self.failUnless(c.labels == ('foo', 'bar', 'example', ''))

    def testToText1(self):
        n = dns.name.from_text('FOO.bar', origin=self.origin)
        t = n.to_text()
        self.failUnless(t == 'FOO.bar.example.')

    def testToText2(self):
        n = dns.name.from_text('FOO.bar', origin=self.origin)
        t = n.to_text(True)
        self.failUnless(t == 'FOO.bar.example')

    def testToText3(self):
        n = dns.name.from_text('FOO.bar', origin=None)
        t = n.to_text()
        self.failUnless(t == 'FOO.bar')

    def testToText4(self):
        t = dns.name.empty.to_text()
        self.failUnless(t == '@')

    def testToText5(self):
        t = dns.name.root.to_text()
        self.failUnless(t == '.')

    def testToText6(self):
        n = dns.name.from_text('FOO bar', origin=None)
        t = n.to_text()
        self.failUnless(t == r'FOO\032bar')

    def testToText7(self):
        n = dns.name.from_text(r'FOO\.bar', origin=None)
        t = n.to_text()
        self.failUnless(t == r'FOO\.bar')

    def testToText8(self):
        n = dns.name.from_text(r'\070OO\.bar', origin=None)
        t = n.to_text()
        self.failUnless(t == r'FOO\.bar')

    def testSlice1(self):
        n = dns.name.from_text(r'a.b.c.', origin=None)
        s = n[:]
        self.failUnless(s == ('a', 'b', 'c', ''))

    def testSlice2(self):
        n = dns.name.from_text(r'a.b.c.', origin=None)
        s = n[:2]
        self.failUnless(s == ('a', 'b'))

    def testSlice3(self):
        n = dns.name.from_text(r'a.b.c.', origin=None)
        s = n[2:]
        self.failUnless(s == ('c', ''))

    def testEmptyLabel1(self):
        def bad():
            n = dns.name.Name(['a', '', 'b'])
        self.failUnlessRaises(dns.name.EmptyLabel, bad)

    def testEmptyLabel2(self):
        def bad():
            n = dns.name.Name(['', 'b'])
        self.failUnlessRaises(dns.name.EmptyLabel, bad)

    def testEmptyLabel3(self):
        n = dns.name.Name(['b', ''])
        self.failUnless(n)

    def testLongLabel(self):
        n = dns.name.Name(['a' * 63])
        self.failUnless(n)

    def testLabelTooLong(self):
        def bad():
            n = dns.name.Name(['a' * 64, 'b'])
        self.failUnlessRaises(dns.name.LabelTooLong, bad)

    def testLongName(self):
        n = dns.name.Name(['a' * 63, 'a' * 63, 'a' * 63, 'a' * 62])
        self.failUnless(n)

    def testNameTooLong(self):
        def bad():
            n = dns.name.Name(['a' * 63, 'a' * 63, 'a' * 63, 'a' * 63])
        self.failUnlessRaises(dns.name.NameTooLong, bad)

    def testConcat1(self):
        n1 = dns.name.Name(['a', 'b'])
        n2 = dns.name.Name(['c', 'd'])
        e = dns.name.Name(['a', 'b', 'c', 'd'])
        r = n1 + n2
        self.failUnless(r == e)

    def testConcat2(self):
        n1 = dns.name.Name(['a', 'b'])
        n2 = dns.name.Name([])
        e = dns.name.Name(['a', 'b'])
        r = n1 + n2
        self.failUnless(r == e)

    def testConcat2(self):
        n1 = dns.name.Name([])
        n2 = dns.name.Name(['a', 'b'])
        e = dns.name.Name(['a', 'b'])
        r = n1 + n2
        self.failUnless(r == e)

    def testConcat3(self):
        n1 = dns.name.Name(['a', 'b', ''])
        n2 = dns.name.Name([])
        e = dns.name.Name(['a', 'b', ''])
        r = n1 + n2
        self.failUnless(r == e)

    def testConcat4(self):
        n1 = dns.name.Name(['a', 'b'])
        n2 = dns.name.Name(['c', ''])
        e = dns.name.Name(['a', 'b', 'c', ''])
        r = n1 + n2
        self.failUnless(r == e)

    def testConcat5(self):
        def bad():
            n1 = dns.name.Name(['a', 'b', ''])
            n2 = dns.name.Name(['c'])
            r = n1 + n2
        self.failUnlessRaises(dns.name.AbsoluteConcatenation, bad)

    def testBadEscape(self):
        def bad():
            n = dns.name.from_text(r'a.b\0q1.c.')
            print n
        self.failUnlessRaises(dns.name.BadEscape, bad)

    def testDigestable1(self):
        n = dns.name.from_text('FOO.bar')
        d = n.to_digestable()
        self.failUnless(d == '\x03foo\x03bar\x00')

    def testDigestable2(self):
        n1 = dns.name.from_text('FOO.bar')
        n2 = dns.name.from_text('foo.BAR.')
        d1 = n1.to_digestable()
        d2 = n2.to_digestable()
        self.failUnless(d1 == d2)

    def testDigestable3(self):
        d = dns.name.root.to_digestable()
        self.failUnless(d == '\x00')

    def testDigestable4(self):
        n = dns.name.from_text('FOO.bar', None)
        d = n.to_digestable(dns.name.root)
        self.failUnless(d == '\x03foo\x03bar\x00')

    def testBadDigestable(self):
        def bad():
            n = dns.name.from_text('FOO.bar', None)
            d = n.to_digestable()
        self.failUnlessRaises(dns.name.NeedAbsoluteNameOrOrigin, bad)

    def testToWire1(self):
        n = dns.name.from_text('FOO.bar')
        f = cStringIO.StringIO()
        compress = {}
        n.to_wire(f, compress)
        self.failUnless(f.getvalue() == '\x03FOO\x03bar\x00')

    def testToWire2(self):
        n = dns.name.from_text('FOO.bar')
        f = cStringIO.StringIO()
        compress = {}
        n.to_wire(f, compress)
        n.to_wire(f, compress)
        self.failUnless(f.getvalue() == '\x03FOO\x03bar\x00\xc0\x00')

    def testToWire3(self):
        n1 = dns.name.from_text('FOO.bar')
        n2 = dns.name.from_text('foo.bar')
        f = cStringIO.StringIO()
        compress = {}
        n1.to_wire(f, compress)
        n2.to_wire(f, compress)
        self.failUnless(f.getvalue() == '\x03FOO\x03bar\x00\xc0\x00')

    def testToWire4(self):
        n1 = dns.name.from_text('FOO.bar')
        n2 = dns.name.from_text('a.foo.bar')
        f = cStringIO.StringIO()
        compress = {}
        n1.to_wire(f, compress)
        n2.to_wire(f, compress)
        self.failUnless(f.getvalue() == '\x03FOO\x03bar\x00\x01\x61\xc0\x00')

    def testToWire5(self):
        n1 = dns.name.from_text('FOO.bar')
        n2 = dns.name.from_text('a.foo.bar')
        f = cStringIO.StringIO()
        compress = {}
        n1.to_wire(f, compress)
        n2.to_wire(f, None)
        self.failUnless(f.getvalue() == \
                        '\x03FOO\x03bar\x00\x01\x61\x03foo\x03bar\x00')

    def testToWire6(self):
        n = dns.name.from_text('FOO.bar')
        v = n.to_wire()
        self.failUnless(v == '\x03FOO\x03bar\x00')

    def testBadToWire(self):
        def bad():
            n = dns.name.from_text('FOO.bar', None)
            f = cStringIO.StringIO()
            compress = {}
            n.to_wire(f, compress)
        self.failUnlessRaises(dns.name.NeedAbsoluteNameOrOrigin, bad)

    def testSplit1(self):
        n = dns.name.from_text('foo.bar.')
        (prefix, suffix) = n.split(2)
        ep = dns.name.from_text('foo', None)
        es = dns.name.from_text('bar.', None)
        self.failUnless(prefix == ep and suffix == es)

    def testSplit2(self):
        n = dns.name.from_text('foo.bar.')
        (prefix, suffix) = n.split(1)
        ep = dns.name.from_text('foo.bar', None)
        es = dns.name.from_text('.', None)
        self.failUnless(prefix == ep and suffix == es)

    def testSplit3(self):
        n = dns.name.from_text('foo.bar.')
        (prefix, suffix) = n.split(0)
        ep = dns.name.from_text('foo.bar.', None)
        es = dns.name.from_text('', None)
        self.failUnless(prefix == ep and suffix == es)

    def testSplit4(self):
        n = dns.name.from_text('foo.bar.')
        (prefix, suffix) = n.split(3)
        ep = dns.name.from_text('', None)
        es = dns.name.from_text('foo.bar.', None)
        self.failUnless(prefix == ep and suffix == es)

    def testBadSplit1(self):
        def bad():
            n = dns.name.from_text('foo.bar.')
            (prefix, suffix) = n.split(-1)
        self.failUnlessRaises(ValueError, bad)

    def testBadSplit2(self):
        def bad():
            n = dns.name.from_text('foo.bar.')
            (prefix, suffix) = n.split(4)
        self.failUnlessRaises(ValueError, bad)

    def testRelativize1(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = dns.name.from_text('bar.', None)
        e = dns.name.from_text('a.foo', None)
        self.failUnless(n.relativize(o) == e)

    def testRelativize2(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = n
        e = dns.name.empty
        self.failUnless(n.relativize(o) == e)

    def testRelativize3(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = dns.name.from_text('blaz.', None)
        e = n
        self.failUnless(n.relativize(o) == e)

    def testRelativize4(self):
        n = dns.name.from_text('a.foo', None)
        o = dns.name.root
        e = n
        self.failUnless(n.relativize(o) == e)

    def testDerelativize1(self):
        n = dns.name.from_text('a.foo', None)
        o = dns.name.from_text('bar.', None)
        e = dns.name.from_text('a.foo.bar.', None)
        self.failUnless(n.derelativize(o) == e)

    def testDerelativize2(self):
        n = dns.name.empty
        o = dns.name.from_text('a.foo.bar.', None)
        e = o
        self.failUnless(n.derelativize(o) == e)

    def testDerelativize3(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = dns.name.from_text('blaz.', None)
        e = n
        self.failUnless(n.derelativize(o) == e)

    def testChooseRelativity1(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = dns.name.from_text('bar.', None)
        e = dns.name.from_text('a.foo', None)
        self.failUnless(n.choose_relativity(o, True) == e)

    def testChooseRelativity2(self):
        n = dns.name.from_text('a.foo.bar.', None)
        o = dns.name.from_text('bar.', None)
        e = n
        self.failUnless(n.choose_relativity(o, False) == e)

    def testChooseRelativity3(self):
        n = dns.name.from_text('a.foo', None)
        o = dns.name.from_text('bar.', None)
        e = dns.name.from_text('a.foo.bar.', None)
        self.failUnless(n.choose_relativity(o, False) == e)

    def testChooseRelativity4(self):
        n = dns.name.from_text('a.foo', None)
        o = None
        e = n
        self.failUnless(n.choose_relativity(o, True) == e)

    def testChooseRelativity5(self):
        n = dns.name.from_text('a.foo', None)
        o = None
        e = n
        self.failUnless(n.choose_relativity(o, False) == e)

    def testChooseRelativity6(self):
        n = dns.name.from_text('a.foo.', None)
        o = None
        e = n
        self.failUnless(n.choose_relativity(o, True) == e)

    def testChooseRelativity7(self):
        n = dns.name.from_text('a.foo.', None)
        o = None
        e = n
        self.failUnless(n.choose_relativity(o, False) == e)

    def testFromWire1(self):
        w = '\x03foo\x00\xc0\x00'
        (n1, cused1) = dns.name.from_wire(w, 0)
        (n2, cused2) = dns.name.from_wire(w, cused1)
        en1 = dns.name.from_text('foo.')
        en2 = en1
        ecused1 = 5
        ecused2 = 2
        self.failUnless(n1 == en1 and cused1 == ecused1 and \
                        n2 == en2 and cused2 == ecused2)

    def testFromWire1(self):
        w = '\x03foo\x00\x01a\xc0\x00\x01b\xc0\x05'
        current = 0
        (n1, cused1) = dns.name.from_wire(w, current)
        current += cused1
        (n2, cused2) = dns.name.from_wire(w, current)
        current += cused2
        (n3, cused3) = dns.name.from_wire(w, current)
        en1 = dns.name.from_text('foo.')
        en2 = dns.name.from_text('a.foo.')
        en3 = dns.name.from_text('b.a.foo.')
        ecused1 = 5
        ecused2 = 4
        ecused3 = 4
        self.failUnless(n1 == en1 and cused1 == ecused1 and \
                        n2 == en2 and cused2 == ecused2 and \
                        n3 == en3 and cused3 == ecused3)

    def testBadFromWire1(self):
        def bad():
            w = '\x03foo\xc0\x04'
            (n, cused) = dns.name.from_wire(w, 0)
        self.failUnlessRaises(dns.name.BadPointer, bad)

    def testBadFromWire2(self):
        def bad():
            w = '\x03foo\xc0\x05'
            (n, cused) = dns.name.from_wire(w, 0)
        self.failUnlessRaises(dns.name.BadPointer, bad)

    def testBadFromWire3(self):
        def bad():
            w = '\xbffoo'
            (n, cused) = dns.name.from_wire(w, 0)
        self.failUnlessRaises(dns.name.BadLabelType, bad)

    def testBadFromWire4(self):
        def bad():
            w = '\x41foo'
            (n, cused) = dns.name.from_wire(w, 0)
        self.failUnlessRaises(dns.name.BadLabelType, bad)

    def testParent1(self):
        n = dns.name.from_text('foo.bar.')
        self.failUnless(n.parent() == dns.name.from_text('bar.'))
        self.failUnless(n.parent().parent() == dns.name.root)

    def testParent2(self):
        n = dns.name.from_text('foo.bar', None)
        self.failUnless(n.parent() == dns.name.from_text('bar', None))
        self.failUnless(n.parent().parent() == dns.name.empty)

    def testParent3(self):
        def bad():
            n = dns.name.root
            n.parent()
        self.failUnlessRaises(dns.name.NoParent, bad)

    def testParent4(self):
        def bad():
            n = dns.name.empty
            n.parent()
        self.failUnlessRaises(dns.name.NoParent, bad)

    def testFromUnicode1(self):
        n = dns.name.from_text(u'foo.bar')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testFromUnicode2(self):
        n = dns.name.from_text(u'foo\u1234bar.bar')
        self.failUnless(n.labels == ('xn--foobar-r5z', 'bar', ''))

    def testFromUnicodeAlternateDot1(self):
        n = dns.name.from_text(u'foo\u3002bar')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testFromUnicodeAlternateDot2(self):
        n = dns.name.from_text(u'foo\uff0ebar')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testFromUnicodeAlternateDot3(self):
        n = dns.name.from_text(u'foo\uff61bar')
        self.failUnless(n.labels == ('foo', 'bar', ''))

    def testToUnicode1(self):
        n = dns.name.from_text(u'foo.bar')
        s = n.to_unicode()
        self.failUnless(s == u'foo.bar.')

    def testToUnicode2(self):
        n = dns.name.from_text(u'foo\u1234bar.bar')
        s = n.to_unicode()
        self.failUnless(s == u'foo\u1234bar.bar.')

    def testToUnicode3(self):
        n = dns.name.from_text('foo.bar')
        s = n.to_unicode()
        self.failUnless(s == u'foo.bar.')

    def testReverseIPv4(self):
        e = dns.name.from_text('1.0.0.127.in-addr.arpa.')
        n = dns.reversename.from_address('127.0.0.1')
        self.failUnless(e == n)

    def testReverseIPv6(self):
        e = dns.name.from_text('1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.')
        n = dns.reversename.from_address('::1')
        self.failUnless(e == n)

    def testBadReverseIPv4(self):
        def bad():
            n = dns.reversename.from_address('127.0.foo.1')
        self.failUnlessRaises(socket.error, bad)

    def testBadReverseIPv6(self):
        def bad():
            n = dns.reversename.from_address('::1::1')
        self.failUnlessRaises(socket.error, bad)

    def testForwardIPv4(self):
        n = dns.name.from_text('1.0.0.127.in-addr.arpa.')
        e = '127.0.0.1'
        text = dns.reversename.to_address(n)
        self.failUnless(text == e)

    def testForwardIPv6(self):
        n = dns.name.from_text('1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.')
        e = '::1'
        text = dns.reversename.to_address(n)
        self.failUnless(text == e)

    def testE164ToEnum(self):
        text = '+1 650 555 1212'
        e = dns.name.from_text('2.1.2.1.5.5.5.0.5.6.1.e164.arpa.')
        n = dns.e164.from_e164(text)
        self.failUnless(n == e)

    def testEnumToE164(self):
        n = dns.name.from_text('2.1.2.1.5.5.5.0.5.6.1.e164.arpa.')
        e = '+16505551212'
        text = dns.e164.to_e164(n)
        self.failUnless(text == e)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = namedict
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.name
import dns.namedict

class NameTestCase(unittest.TestCase):

    def setUp(self):
        self.ndict = dns.namedict.NameDict()
        n1 = dns.name.from_text('foo.bar.')
        n2 = dns.name.from_text('bar.')
        self.ndict[n1] = 1
        self.ndict[n2] = 2
        self.rndict = dns.namedict.NameDict()
        n1 = dns.name.from_text('foo.bar', None)
        n2 = dns.name.from_text('bar', None)
        self.rndict[n1] = 1
        self.rndict[n2] = 2

    def testDepth(self):
        self.failUnless(self.ndict.max_depth == 3)

    def testLookup1(self):
        k = dns.name.from_text('foo.bar.')
        self.failUnless(self.ndict[k] == 1)

    def testLookup2(self):
        k = dns.name.from_text('foo.bar.')
        self.failUnless(self.ndict.get_deepest_match(k)[1] == 1)

    def testLookup3(self):
        k = dns.name.from_text('a.b.c.foo.bar.')
        self.failUnless(self.ndict.get_deepest_match(k)[1] == 1)

    def testLookup4(self):
        k = dns.name.from_text('a.b.c.bar.')
        self.failUnless(self.ndict.get_deepest_match(k)[1] == 2)

    def testLookup5(self):
        def bad():
            n = dns.name.from_text('a.b.c.')
            (k, v) = self.ndict.get_deepest_match(n)
        self.failUnlessRaises(KeyError, bad)

    def testLookup6(self):
        def bad():
            (k, v) = self.ndict.get_deepest_match(dns.name.empty)
        self.failUnlessRaises(KeyError, bad)

    def testLookup7(self):
        self.ndict[dns.name.empty] = 100
        n = dns.name.from_text('a.b.c.')
        (k, v) = self.ndict.get_deepest_match(n)
        self.failUnless(v == 100)

    def testLookup8(self):
        def bad():
            self.ndict['foo'] = 100
        self.failUnlessRaises(ValueError, bad)

    def testRelDepth(self):
        self.failUnless(self.rndict.max_depth == 2)

    def testRelLookup1(self):
        k = dns.name.from_text('foo.bar', None)
        self.failUnless(self.rndict[k] == 1)

    def testRelLookup2(self):
        k = dns.name.from_text('foo.bar', None)
        self.failUnless(self.rndict.get_deepest_match(k)[1] == 1)

    def testRelLookup3(self):
        k = dns.name.from_text('a.b.c.foo.bar', None)
        self.failUnless(self.rndict.get_deepest_match(k)[1] == 1)

    def testRelLookup4(self):
        k = dns.name.from_text('a.b.c.bar', None)
        self.failUnless(self.rndict.get_deepest_match(k)[1] == 2)

    def testRelLookup7(self):
        self.rndict[dns.name.empty] = 100
        n = dns.name.from_text('a.b.c', None)
        (k, v) = self.rndict.get_deepest_match(n)
        self.failUnless(v == 100)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = ntoaaton
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.exception
import dns.ipv6

class NtoAAtoNTestCase(unittest.TestCase):

    def test_aton1(self):
        a = dns.ipv6.inet_aton('::')
        self.failUnless(a == '\x00' * 16)

    def test_aton2(self):
        a = dns.ipv6.inet_aton('::1')
        self.failUnless(a == '\x00' * 15 + '\x01')

    def test_aton3(self):
        a = dns.ipv6.inet_aton('::10.0.0.1')
        self.failUnless(a == '\x00' * 12 + '\x0a\x00\x00\x01')

    def test_aton4(self):
        a = dns.ipv6.inet_aton('abcd::dcba')
        self.failUnless(a == '\xab\xcd' + '\x00' * 12 + '\xdc\xba')

    def test_aton5(self):
        a = dns.ipv6.inet_aton('1:2:3:4:5:6:7:8')
        self.failUnless(a == \
                        '00010002000300040005000600070008'.decode('hex_codec'))

    def test_bad_aton1(self):
        def bad():
            a = dns.ipv6.inet_aton('abcd:dcba')
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def test_bad_aton2(self):
        def bad():
            a = dns.ipv6.inet_aton('abcd::dcba::1')
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def test_bad_aton3(self):
        def bad():
            a = dns.ipv6.inet_aton('1:2:3:4:5:6:7:8:9')
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def test_aton1(self):
        a = dns.ipv6.inet_aton('::')
        self.failUnless(a == '\x00' * 16)

    def test_aton2(self):
        a = dns.ipv6.inet_aton('::1')
        self.failUnless(a == '\x00' * 15 + '\x01')

    def test_aton3(self):
        a = dns.ipv6.inet_aton('::10.0.0.1')
        self.failUnless(a == '\x00' * 12 + '\x0a\x00\x00\x01')

    def test_aton4(self):
        a = dns.ipv6.inet_aton('abcd::dcba')
        self.failUnless(a == '\xab\xcd' + '\x00' * 12 + '\xdc\xba')

    def test_ntoa1(self):
        b = '00010002000300040005000600070008'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '1:2:3:4:5:6:7:8')

    def test_ntoa2(self):
        b = '\x00' * 16
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::')

    def test_ntoa3(self):
        b = '\x00' * 15 + '\x01'
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::1')

    def test_ntoa4(self):
        b = '\x80' + '\x00' * 15
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '8000::')

    def test_ntoa5(self):
        b = '\x01\xcd' + '\x00' * 12 + '\x03\xef'
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '1cd::3ef')

    def test_ntoa6(self):
        b = 'ffff00000000ffff000000000000ffff'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == 'ffff:0:0:ffff::ffff')

    def test_ntoa7(self):
        b = '00000000ffff000000000000ffffffff'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '0:0:ffff::ffff:ffff')

    def test_ntoa8(self):
        b = 'ffff0000ffff00000000ffff00000000'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == 'ffff:0:ffff::ffff:0:0')

    def test_ntoa9(self):
        b = '0000000000000000000000000a000001'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::10.0.0.1')

    def test_ntoa10(self):
        b = '0000000000000000000000010a000001'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::1:a00:1')

    def test_ntoa11(self):
        b = '00000000000000000000ffff0a000001'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::ffff:10.0.0.1')

    def test_ntoa12(self):
        b = '000000000000000000000000ffffffff'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::255.255.255.255')

    def test_ntoa13(self):
        b = '00000000000000000000ffffffffffff'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::ffff:255.255.255.255')

    def test_ntoa14(self):
        b = '0000000000000000000000000001ffff'.decode('hex_codec')
        t = dns.ipv6.inet_ntoa(b)
        self.failUnless(t == '::0.1.255.255')

    def test_bad_ntoa1(self):
        def bad():
            a = dns.ipv6.inet_ntoa('')
        self.failUnlessRaises(ValueError, bad)

    def test_bad_ntoa2(self):
        def bad():
            a = dns.ipv6.inet_ntoa('\x00' * 17)
        self.failUnlessRaises(ValueError, bad)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = rdtypeandclass
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.rdataclass
import dns.rdatatype

class RdTypeAndClassTestCase(unittest.TestCase):

    # Classes

    def test_class_meta1(self):
        self.failUnless(dns.rdataclass.is_metaclass(dns.rdataclass.ANY))

    def test_class_meta2(self):
        self.failUnless(not dns.rdataclass.is_metaclass(dns.rdataclass.IN))

    def test_class_bytext1(self):
        self.failUnless(dns.rdataclass.from_text('IN') == dns.rdataclass.IN)

    def test_class_bytext2(self):
        self.failUnless(dns.rdataclass.from_text('CLASS1') ==
                        dns.rdataclass.IN)

    def test_class_bytext_bounds1(self):
        self.failUnless(dns.rdataclass.from_text('CLASS0') == 0)
        self.failUnless(dns.rdataclass.from_text('CLASS65535') == 65535)

    def test_class_bytext_bounds2(self):
        def bad():
            junk = dns.rdataclass.from_text('CLASS65536')
        self.failUnlessRaises(ValueError, bad)

    def test_class_bytext_unknown(self):
        def bad():
            junk = dns.rdataclass.from_text('XXX')
        self.failUnlessRaises(dns.rdataclass.UnknownRdataclass, bad)

    def test_class_totext1(self):
        self.failUnless(dns.rdataclass.to_text(dns.rdataclass.IN) == 'IN')

    def test_class_totext1(self):
        self.failUnless(dns.rdataclass.to_text(999) == 'CLASS999')

    def test_class_totext_bounds1(self):
        def bad():
            junk = dns.rdataclass.to_text(-1)
        self.failUnlessRaises(ValueError, bad)

    def test_class_totext_bounds2(self):
        def bad():
            junk = dns.rdataclass.to_text(65536)
        self.failUnlessRaises(ValueError, bad)

    # Types

    def test_type_meta1(self):
        self.failUnless(dns.rdatatype.is_metatype(dns.rdatatype.ANY))

    def test_type_meta2(self):
        self.failUnless(dns.rdatatype.is_metatype(dns.rdatatype.OPT))

    def test_type_meta3(self):
        self.failUnless(not dns.rdatatype.is_metatype(dns.rdatatype.A))

    def test_type_singleton1(self):
        self.failUnless(dns.rdatatype.is_singleton(dns.rdatatype.SOA))

    def test_type_singleton2(self):
        self.failUnless(not dns.rdatatype.is_singleton(dns.rdatatype.A))

    def test_type_bytext1(self):
        self.failUnless(dns.rdatatype.from_text('A') == dns.rdatatype.A)

    def test_type_bytext2(self):
        self.failUnless(dns.rdatatype.from_text('TYPE1') ==
                        dns.rdatatype.A)

    def test_type_bytext_bounds1(self):
        self.failUnless(dns.rdatatype.from_text('TYPE0') == 0)
        self.failUnless(dns.rdatatype.from_text('TYPE65535') == 65535)

    def test_type_bytext_bounds2(self):
        def bad():
            junk = dns.rdatatype.from_text('TYPE65536')
        self.failUnlessRaises(ValueError, bad)

    def test_type_bytext_unknown(self):
        def bad():
            junk = dns.rdatatype.from_text('XXX')
        self.failUnlessRaises(dns.rdatatype.UnknownRdatatype, bad)

    def test_type_totext1(self):
        self.failUnless(dns.rdatatype.to_text(dns.rdatatype.A) == 'A')

    def test_type_totext1(self):
        self.failUnless(dns.rdatatype.to_text(999) == 'TYPE999')

    def test_type_totext_bounds1(self):
        def bad():
            junk = dns.rdatatype.to_text(-1)
        self.failUnlessRaises(ValueError, bad)

    def test_type_totext_bounds2(self):
        def bad():
            junk = dns.rdatatype.to_text(65536)
        self.failUnlessRaises(ValueError, bad)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = resolver
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import select
import sys
import time
import unittest

import dns.name
import dns.message
import dns.name
import dns.rdataclass
import dns.rdatatype
import dns.resolver

resolv_conf = """
    /t/t
# comment 1
; comment 2
domain foo
nameserver 10.0.0.1
nameserver 10.0.0.2
"""

message_text = """id 1234
opcode QUERY
rcode NOERROR
flags QR AA RD
;QUESTION
example. IN A
;ANSWER
example. 1 IN A 10.0.0.1
;AUTHORITY
;ADDITIONAL
"""

class BaseResolverTests(object):

    if sys.platform != 'win32':
        def testRead(self):
            f = cStringIO.StringIO(resolv_conf)
            r = dns.resolver.Resolver(f)
            self.failUnless(r.nameservers == ['10.0.0.1', '10.0.0.2'] and
                            r.domain == dns.name.from_text('foo'))

    def testCacheExpiration(self):
        message = dns.message.from_text(message_text)
        name = dns.name.from_text('example.')
        answer = dns.resolver.Answer(name, dns.rdatatype.A, dns.rdataclass.IN,
                                     message)
        cache = dns.resolver.Cache()
        cache.put((name, dns.rdatatype.A, dns.rdataclass.IN), answer)
        time.sleep(2)
        self.failUnless(cache.get((name, dns.rdatatype.A, dns.rdataclass.IN))
                        is None)

    def testCacheCleaning(self):
        message = dns.message.from_text(message_text)
        name = dns.name.from_text('example.')
        answer = dns.resolver.Answer(name, dns.rdatatype.A, dns.rdataclass.IN,
                                     message)
        cache = dns.resolver.Cache(cleaning_interval=1.0)
        cache.put((name, dns.rdatatype.A, dns.rdataclass.IN), answer)
        time.sleep(2)
        self.failUnless(cache.get((name, dns.rdatatype.A, dns.rdataclass.IN))
                        is None)

    def testZoneForName1(self):
        name = dns.name.from_text('www.dnspython.org.')
        ezname = dns.name.from_text('dnspython.org.')
        zname = dns.resolver.zone_for_name(name)
        self.failUnless(zname == ezname)

    def testZoneForName2(self):
        name = dns.name.from_text('a.b.www.dnspython.org.')
        ezname = dns.name.from_text('dnspython.org.')
        zname = dns.resolver.zone_for_name(name)
        self.failUnless(zname == ezname)

    def testZoneForName3(self):
        name = dns.name.from_text('dnspython.org.')
        ezname = dns.name.from_text('dnspython.org.')
        zname = dns.resolver.zone_for_name(name)
        self.failUnless(zname == ezname)

    def testZoneForName4(self):
        def bad():
            name = dns.name.from_text('dnspython.org', None)
            zname = dns.resolver.zone_for_name(name)
        self.failUnlessRaises(dns.resolver.NotAbsolute, bad)

class PollingMonkeyPatchMixin(object):
    def setUp(self):
        self.__native_polling_backend = dns.query._polling_backend
        dns.query._set_polling_backend(self.polling_backend())

        unittest.TestCase.setUp(self)

    def tearDown(self):
        dns.query._set_polling_backend(self.__native_polling_backend)

        unittest.TestCase.tearDown(self)

class SelectResolverTestCase(PollingMonkeyPatchMixin, BaseResolverTests, unittest.TestCase):
    def polling_backend(self):
        return dns.query._select_for

if hasattr(select, 'poll'):
    class PollResolverTestCase(PollingMonkeyPatchMixin, BaseResolverTests, unittest.TestCase):
        def polling_backend(self):
            return dns.query._poll_for

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = rrset
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.rrset

class RRsetTestCase(unittest.TestCase):

    def testEqual1(self):
        r1 = dns.rrset.from_text('foo', 300, 'in', 'a', '10.0.0.1', '10.0.0.2')
        r2 = dns.rrset.from_text('FOO', 300, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 == r2)

    def testEqual2(self):
        r1 = dns.rrset.from_text('foo', 300, 'in', 'a', '10.0.0.1', '10.0.0.2')
        r2 = dns.rrset.from_text('FOO', 600, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 == r2)

    def testNotEqual1(self):
        r1 = dns.rrset.from_text('fooa', 30, 'in', 'a', '10.0.0.1', '10.0.0.2')
        r2 = dns.rrset.from_text('FOO', 30, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 != r2)

    def testNotEqual2(self):
        r1 = dns.rrset.from_text('foo', 30, 'in', 'a', '10.0.0.1', '10.0.0.3')
        r2 = dns.rrset.from_text('FOO', 30, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 != r2)

    def testNotEqual3(self):
        r1 = dns.rrset.from_text('foo', 30, 'in', 'a', '10.0.0.1', '10.0.0.2',
                                 '10.0.0.3')
        r2 = dns.rrset.from_text('FOO', 30, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 != r2)

    def testNotEqual4(self):
        r1 = dns.rrset.from_text('foo', 30, 'in', 'a', '10.0.0.1')
        r2 = dns.rrset.from_text('FOO', 30, 'in', 'a', '10.0.0.2', '10.0.0.1')
        self.failUnless(r1 != r2)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = set
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.set

# for convenience
S = dns.set.Set

class SimpleSetTestCase(unittest.TestCase):

    def testLen1(self):
        s1 = S()
        self.failUnless(len(s1) == 0)

    def testLen2(self):
        s1 = S([1, 2, 3])
        self.failUnless(len(s1) == 3)

    def testLen3(self):
        s1 = S([1, 2, 3, 3, 3])
        self.failUnless(len(s1) == 3)

    def testUnion1(self):
        s1 = S([1, 2, 3])
        s2 = S([1, 2, 3])
        e = S([1, 2, 3])
        self.failUnless(s1 | s2 == e)

    def testUnion2(self):
        s1 = S([1, 2, 3])
        s2 = S([])
        e = S([1, 2, 3])
        self.failUnless(s1 | s2 == e)

    def testUnion3(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 4])
        e = S([1, 2, 3, 4])
        self.failUnless(s1 | s2 == e)

    def testIntersection1(self):
        s1 = S([1, 2, 3])
        s2 = S([1, 2, 3])
        e = S([1, 2, 3])
        self.failUnless(s1 & s2 == e)

    def testIntersection2(self):
        s1 = S([0, 1, 2, 3])
        s2 = S([1, 2, 3, 4])
        e = S([1, 2, 3])
        self.failUnless(s1 & s2 == e)

    def testIntersection3(self):
        s1 = S([1, 2, 3])
        s2 = S([])
        e = S([])
        self.failUnless(s1 & s2 == e)

    def testIntersection4(self):
        s1 = S([1, 2, 3])
        s2 = S([5, 4])
        e = S([])
        self.failUnless(s1 & s2 == e)

    def testDifference1(self):
        s1 = S([1, 2, 3])
        s2 = S([5, 4])
        e = S([1, 2, 3])
        self.failUnless(s1 - s2 == e)

    def testDifference2(self):
        s1 = S([1, 2, 3])
        s2 = S([])
        e = S([1, 2, 3])
        self.failUnless(s1 - s2 == e)

    def testDifference3(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2])
        e = S([1])
        self.failUnless(s1 - s2 == e)

    def testDifference4(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2, 1])
        e = S([])
        self.failUnless(s1 - s2 == e)

    def testSubset1(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2, 1])
        self.failUnless(s1.issubset(s2))

    def testSubset2(self):
        s1 = S([1, 2, 3])
        self.failUnless(s1.issubset(s1))

    def testSubset3(self):
        s1 = S([])
        s2 = S([1, 2, 3])
        self.failUnless(s1.issubset(s2))

    def testSubset4(self):
        s1 = S([1])
        s2 = S([1, 2, 3])
        self.failUnless(s1.issubset(s2))

    def testSubset5(self):
        s1 = S([])
        s2 = S([])
        self.failUnless(s1.issubset(s2))

    def testSubset6(self):
        s1 = S([1, 4])
        s2 = S([1, 2, 3])
        self.failUnless(not s1.issubset(s2))

    def testSuperset1(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2, 1])
        self.failUnless(s1.issuperset(s2))

    def testSuperset2(self):
        s1 = S([1, 2, 3])
        self.failUnless(s1.issuperset(s1))

    def testSuperset3(self):
        s1 = S([1, 2, 3])
        s2 = S([])
        self.failUnless(s1.issuperset(s2))

    def testSuperset4(self):
        s1 = S([1, 2, 3])
        s2 = S([1])
        self.failUnless(s1.issuperset(s2))

    def testSuperset5(self):
        s1 = S([])
        s2 = S([])
        self.failUnless(s1.issuperset(s2))

    def testSuperset6(self):
        s1 = S([1, 2, 3])
        s2 = S([1, 4])
        self.failUnless(not s1.issuperset(s2))

    def testUpdate1(self):
        s1 = S([1, 2, 3])
        u = (4, 5, 6)
        e = S([1, 2, 3, 4, 5, 6])
        s1.update(u)
        self.failUnless(s1 == e)

    def testUpdate2(self):
        s1 = S([1, 2, 3])
        u = []
        e = S([1, 2, 3])
        s1.update(u)
        self.failUnless(s1 == e)

    def testGetitem(self):
        s1 = S([1, 2, 3])
        i0 = s1[0]
        i1 = s1[1]
        i2 = s1[2]
        s2 = S([i0, i1, i2])
        self.failUnless(s1 == s2)

    def testGetslice(self):
        s1 = S([1, 2, 3])
        slice = s1[0:2]
        self.failUnless(len(slice) == 2)
        item = s1[2]
        slice.append(item)
        s2 = S(slice)
        self.failUnless(s1 == s2)

    def testDelitem(self):
        s1 = S([1, 2, 3])
        del s1[0]
        i1 = s1[0]
        i2 = s1[1]
        self.failUnless(i1 != i2)
        self.failUnless(i1 == 1 or i1 == 2 or i1 == 3)
        self.failUnless(i2 == 1 or i2 == 2 or i2 == 3)

    def testDelslice(self):
        s1 = S([1, 2, 3])
        del s1[0:2]
        i1 = s1[0]
        self.failUnless(i1 == 1 or i1 == 2 or i1 == 3)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = tokenizer
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.exception
import dns.tokenizer

Token = dns.tokenizer.Token

class TokenizerTestCase(unittest.TestCase):

    def testQuotedString1(self):
        tok = dns.tokenizer.Tokenizer(r'"foo"')
        token = tok.get()
        self.failUnless(token == Token(dns.tokenizer.QUOTED_STRING, 'foo'))

    def testQuotedString2(self):
        tok = dns.tokenizer.Tokenizer(r'""')
        token = tok.get()
        self.failUnless(token == Token(dns.tokenizer.QUOTED_STRING, ''))

    def testQuotedString3(self):
        tok = dns.tokenizer.Tokenizer(r'"\"foo\""')
        token = tok.get()
        self.failUnless(token == Token(dns.tokenizer.QUOTED_STRING, '"foo"'))

    def testQuotedString4(self):
        tok = dns.tokenizer.Tokenizer(r'"foo\010bar"')
        token = tok.get()
        self.failUnless(token == Token(dns.tokenizer.QUOTED_STRING, 'foo\x0abar'))

    def testQuotedString5(self):
        def bad():
            tok = dns.tokenizer.Tokenizer(r'"foo')
            token = tok.get()
        self.failUnlessRaises(dns.exception.UnexpectedEnd, bad)

    def testQuotedString6(self):
        def bad():
            tok = dns.tokenizer.Tokenizer(r'"foo\01')
            token = tok.get()
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def testQuotedString7(self):
        def bad():
            tok = dns.tokenizer.Tokenizer('"foo\nbar"')
            token = tok.get()
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def testEmpty1(self):
        tok = dns.tokenizer.Tokenizer('')
        token = tok.get()
        self.failUnless(token.is_eof())

    def testEmpty2(self):
        tok = dns.tokenizer.Tokenizer('')
        token1 = tok.get()
        token2 = tok.get()
        self.failUnless(token1.is_eof() and token2.is_eof())

    def testEOL(self):
        tok = dns.tokenizer.Tokenizer('\n')
        token1 = tok.get()
        token2 = tok.get()
        self.failUnless(token1.is_eol() and token2.is_eof())

    def testWS1(self):
        tok = dns.tokenizer.Tokenizer(' \n')
        token1 = tok.get()
        self.failUnless(token1.is_eol())

    def testWS2(self):
        tok = dns.tokenizer.Tokenizer(' \n')
        token1 = tok.get(want_leading=True)
        self.failUnless(token1.is_whitespace())

    def testComment1(self):
        tok = dns.tokenizer.Tokenizer(' ;foo\n')
        token1 = tok.get()
        self.failUnless(token1.is_eol())

    def testComment2(self):
        tok = dns.tokenizer.Tokenizer(' ;foo\n')
        token1 = tok.get(want_comment = True)
        token2 = tok.get()
        self.failUnless(token1 == Token(dns.tokenizer.COMMENT, 'foo') and
                        token2.is_eol())

    def testComment3(self):
        tok = dns.tokenizer.Tokenizer(' ;foo bar\n')
        token1 = tok.get(want_comment = True)
        token2 = tok.get()
        self.failUnless(token1 == Token(dns.tokenizer.COMMENT, 'foo bar') and
                        token2.is_eol())

    def testMultiline1(self):
        tok = dns.tokenizer.Tokenizer('( foo\n\n bar\n)')
        tokens = list(iter(tok))
        self.failUnless(tokens == [Token(dns.tokenizer.IDENTIFIER, 'foo'),
                                   Token(dns.tokenizer.IDENTIFIER, 'bar')])

    def testMultiline2(self):
        tok = dns.tokenizer.Tokenizer('( foo\n\n bar\n)\n')
        tokens = list(iter(tok))
        self.failUnless(tokens == [Token(dns.tokenizer.IDENTIFIER, 'foo'),
                                   Token(dns.tokenizer.IDENTIFIER, 'bar'),
                                   Token(dns.tokenizer.EOL, '\n')])
    def testMultiline3(self):
        def bad():
            tok = dns.tokenizer.Tokenizer('foo)')
            tokens = list(iter(tok))
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def testMultiline4(self):
        def bad():
            tok = dns.tokenizer.Tokenizer('((foo)')
            tokens = list(iter(tok))
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

    def testUnget1(self):
        tok = dns.tokenizer.Tokenizer('foo')
        t1 = tok.get()
        tok.unget(t1)
        t2 = tok.get()
        self.failUnless(t1 == t2 and t1.ttype == dns.tokenizer.IDENTIFIER and \
                        t1.value == 'foo')

    def testUnget2(self):
        def bad():
            tok = dns.tokenizer.Tokenizer('foo')
            t1 = tok.get()
            tok.unget(t1)
            tok.unget(t1)
        self.failUnlessRaises(dns.tokenizer.UngetBufferFull, bad)

    def testGetEOL1(self):
        tok = dns.tokenizer.Tokenizer('\n')
        t = tok.get_eol()
        self.failUnless(t == '\n')

    def testGetEOL2(self):
        tok = dns.tokenizer.Tokenizer('')
        t = tok.get_eol()
        self.failUnless(t == '')

    def testEscapedDelimiter1(self):
        tok = dns.tokenizer.Tokenizer(r'ch\ ld')
        t = tok.get()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == r'ch\ ld')

    def testEscapedDelimiter2(self):
        tok = dns.tokenizer.Tokenizer(r'ch\032ld')
        t = tok.get()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == r'ch\032ld')

    def testEscapedDelimiter3(self):
        tok = dns.tokenizer.Tokenizer(r'ch\ild')
        t = tok.get()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == r'ch\ild')

    def testEscapedDelimiter1u(self):
        tok = dns.tokenizer.Tokenizer(r'ch\ ld')
        t = tok.get().unescape()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == r'ch ld')

    def testEscapedDelimiter2u(self):
        tok = dns.tokenizer.Tokenizer(r'ch\032ld')
        t = tok.get().unescape()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == 'ch ld')

    def testEscapedDelimiter3u(self):
        tok = dns.tokenizer.Tokenizer(r'ch\ild')
        t = tok.get().unescape()
        self.failUnless(t.ttype == dns.tokenizer.IDENTIFIER and t.value == r'child')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = update
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import unittest

import dns.update
import dns.rdata
import dns.rdataset

goodhex = '0001 2800 0001 0005 0007 0000' \
          '076578616d706c6500 0006 0001' \
          '03666f6fc00c 00ff 00ff 00000000 0000' \
          'c019 0001 00ff 00000000 0000' \
          '03626172c00c 0001 0001 00000000 0004 0a000005' \
          '05626c617a32c00c 00ff 00fe 00000000 0000' \
          'c049 0001 00fe 00000000 0000' \
          'c019 0001 00ff 00000000 0000' \
          'c019 0001 0001 0000012c 0004 0a000001' \
          'c019 0001 0001 0000012c 0004 0a000002' \
          'c035 0001 0001 0000012c 0004 0a000003' \
          'c035 0001 00fe 00000000 0004 0a000004' \
          '04626c617ac00c 0001 00ff 00000000 0000' \
          'c049 00ff 00ff 00000000 0000'

goodwire = goodhex.replace(' ', '').decode('hex_codec')

update_text="""id 1
opcode UPDATE
rcode NOERROR
;ZONE
example. IN SOA
;PREREQ
foo ANY ANY
foo ANY A
bar 0 IN A 10.0.0.5
blaz2 NONE ANY
blaz2 NONE A
;UPDATE
foo ANY A
foo 300 IN A 10.0.0.1
foo 300 IN A 10.0.0.2
bar 300 IN A 10.0.0.3
bar 0 NONE A 10.0.0.4
blaz ANY A
blaz2 ANY ANY
"""

class UpdateTestCase(unittest.TestCase):

    def test_to_wire1(self):
        update = dns.update.Update('example')
        update.id = 1
        update.present('foo')
        update.present('foo', 'a')
        update.present('bar', 'a', '10.0.0.5')
        update.absent('blaz2')
        update.absent('blaz2', 'a')
        update.replace('foo', 300, 'a', '10.0.0.1', '10.0.0.2')
        update.add('bar', 300, 'a', '10.0.0.3')
        update.delete('bar', 'a', '10.0.0.4')
        update.delete('blaz','a')
        update.delete('blaz2')
        self.failUnless(update.to_wire() == goodwire)

    def test_to_wire2(self):
        update = dns.update.Update('example')
        update.id = 1
        update.present('foo')
        update.present('foo', 'a')
        update.present('bar', 'a', '10.0.0.5')
        update.absent('blaz2')
        update.absent('blaz2', 'a')
        update.replace('foo', 300, 'a', '10.0.0.1', '10.0.0.2')
        update.add('bar', 300, dns.rdata.from_text(1, 1, '10.0.0.3'))
        update.delete('bar', 'a', '10.0.0.4')
        update.delete('blaz','a')
        update.delete('blaz2')
        self.failUnless(update.to_wire() == goodwire)

    def test_to_wire3(self):
        update = dns.update.Update('example')
        update.id = 1
        update.present('foo')
        update.present('foo', 'a')
        update.present('bar', 'a', '10.0.0.5')
        update.absent('blaz2')
        update.absent('blaz2', 'a')
        update.replace('foo', 300, 'a', '10.0.0.1', '10.0.0.2')
        update.add('bar', dns.rdataset.from_text(1, 1, 300, '10.0.0.3'))
        update.delete('bar', 'a', '10.0.0.4')
        update.delete('blaz','a')
        update.delete('blaz2')
        self.failUnless(update.to_wire() == goodwire)

    def test_from_text1(self):
        update = dns.message.from_text(update_text)
        w = update.to_wire(origin=dns.name.from_text('example'),
                           want_shuffle=False)
        self.failUnless(w == goodwire)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = zone
# Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import cStringIO
import filecmp
import os
import unittest

import dns.exception
import dns.rdata
import dns.rdataclass
import dns.rdatatype
import dns.rrset
import dns.zone

example_text = """$TTL 3600
$ORIGIN example.
@ soa foo bar 1 2 3 4 5
@ ns ns1
@ ns ns2
ns1 a 10.0.0.1
ns2 a 10.0.0.2
$TTL 300
$ORIGIN foo.example.
bar mx 0 blaz
"""

example_text_output = """@ 3600 IN SOA foo bar 1 2 3 4 5
@ 3600 IN NS ns1
@ 3600 IN NS ns2
bar.foo 300 IN MX 0 blaz.foo
ns1 3600 IN A 10.0.0.1
ns2 3600 IN A 10.0.0.2
"""

something_quite_similar = """@ 3600 IN SOA foo bar 1 2 3 4 5
@ 3600 IN NS ns1
@ 3600 IN NS ns2
bar.foo 300 IN MX 0 blaz.foo
ns1 3600 IN A 10.0.0.1
ns2 3600 IN A 10.0.0.3
"""

something_different = """@ 3600 IN SOA fooa bar 1 2 3 4 5
@ 3600 IN NS ns11
@ 3600 IN NS ns21
bar.fooa 300 IN MX 0 blaz.fooa
ns11 3600 IN A 10.0.0.11
ns21 3600 IN A 10.0.0.21
"""

ttl_example_text = """$TTL 1h
$ORIGIN example.
@ soa foo bar 1 2 3 4 5
@ ns ns1
@ ns ns2
ns1 1d1s a 10.0.0.1
ns2 1w1D1h1m1S a 10.0.0.2
"""

no_soa_text = """$TTL 1h
$ORIGIN example.
@ ns ns1
@ ns ns2
ns1 1d1s a 10.0.0.1
ns2 1w1D1h1m1S a 10.0.0.2
"""

no_ns_text = """$TTL 1h
$ORIGIN example.
@ soa foo bar 1 2 3 4 5
"""

include_text = """$INCLUDE "example"
"""

bad_directive_text = """$FOO bar
$ORIGIN example.
@ soa foo bar 1 2 3 4 5
@ ns ns1
@ ns ns2
ns1 1d1s a 10.0.0.1
ns2 1w1D1h1m1S a 10.0.0.2
"""

_keep_output = False

class ZoneTestCase(unittest.TestCase):

    def testFromFile1(self):
        z = dns.zone.from_file('example', 'example')
        ok = False
        try:
            z.to_file('example1.out', nl='\x0a')
            ok = filecmp.cmp('example1.out', 'example1.good')
        finally:
            if not _keep_output:
                os.unlink('example1.out')
        self.failUnless(ok)

    def testFromFile2(self):
        z = dns.zone.from_file('example', 'example', relativize=False)
        ok = False
        try:
            z.to_file('example2.out', relativize=False, nl='\x0a')
            ok = filecmp.cmp('example2.out', 'example2.good')
        finally:
            if not _keep_output:
                os.unlink('example2.out')
        self.failUnless(ok)

    def testFromText(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        f = cStringIO.StringIO()
        names = z.nodes.keys()
        names.sort()
        for n in names:
            print >> f, z[n].to_text(n)
        self.failUnless(f.getvalue() == example_text_output)

    def testTorture1(self):
        #
        # Read a zone containing all our supported RR types, and
        # for each RR in the zone, convert the rdata into wire format
        # and then back out, and see if we get equal rdatas.
        #
        f = cStringIO.StringIO()
        o = dns.name.from_text('example.')
        z = dns.zone.from_file('example', o)
        for (name, node) in z.iteritems():
            for rds in node:
                for rd in rds:
                    f.seek(0)
                    f.truncate()
                    rd.to_wire(f, origin=o)
                    wire = f.getvalue()
                    rd2 = dns.rdata.from_wire(rds.rdclass, rds.rdtype,
                                              wire, 0, len(wire),
                                              origin = o)
                    self.failUnless(rd == rd2)

    def testEqual(self):
        z1 = dns.zone.from_text(example_text, 'example.', relativize=True)
        z2 = dns.zone.from_text(example_text_output, 'example.',
                                relativize=True)
        self.failUnless(z1 == z2)

    def testNotEqual1(self):
        z1 = dns.zone.from_text(example_text, 'example.', relativize=True)
        z2 = dns.zone.from_text(something_quite_similar, 'example.',
                                relativize=True)
        self.failUnless(z1 != z2)

    def testNotEqual2(self):
        z1 = dns.zone.from_text(example_text, 'example.', relativize=True)
        z2 = dns.zone.from_text(something_different, 'example.',
                                relativize=True)
        self.failUnless(z1 != z2)

    def testNotEqual3(self):
        z1 = dns.zone.from_text(example_text, 'example.', relativize=True)
        z2 = dns.zone.from_text(something_different, 'example2.',
                                relativize=True)
        self.failUnless(z1 != z2)

    def testFindRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rds = z.find_rdataset('@', 'soa')
        exrds = dns.rdataset.from_text('IN', 'SOA', 300, 'foo bar 1 2 3 4 5')
        self.failUnless(rds == exrds)

    def testFindRdataset2(self):
        def bad():
            z = dns.zone.from_text(example_text, 'example.', relativize=True)
            rds = z.find_rdataset('@', 'loc')
        self.failUnlessRaises(KeyError, bad)

    def testFindRRset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rrs = z.find_rrset('@', 'soa')
        exrrs = dns.rrset.from_text('@', 300, 'IN', 'SOA', 'foo bar 1 2 3 4 5')
        self.failUnless(rrs == exrrs)

    def testFindRRset2(self):
        def bad():
            z = dns.zone.from_text(example_text, 'example.', relativize=True)
            rrs = z.find_rrset('@', 'loc')
        self.failUnlessRaises(KeyError, bad)

    def testGetRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rds = z.get_rdataset('@', 'soa')
        exrds = dns.rdataset.from_text('IN', 'SOA', 300, 'foo bar 1 2 3 4 5')
        self.failUnless(rds == exrds)

    def testGetRdataset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rds = z.get_rdataset('@', 'loc')
        self.failUnless(rds == None)

    def testGetRRset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rrs = z.get_rrset('@', 'soa')
        exrrs = dns.rrset.from_text('@', 300, 'IN', 'SOA', 'foo bar 1 2 3 4 5')
        self.failUnless(rrs == exrrs)

    def testGetRRset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rrs = z.get_rrset('@', 'loc')
        self.failUnless(rrs == None)

    def testReplaceRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rdataset = dns.rdataset.from_text('in', 'ns', 300, 'ns3', 'ns4')
        z.replace_rdataset('@', rdataset)
        rds = z.get_rdataset('@', 'ns')
        self.failUnless(rds is rdataset)

    def testReplaceRdataset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        rdataset = dns.rdataset.from_text('in', 'txt', 300, '"foo"')
        z.replace_rdataset('@', rdataset)
        rds = z.get_rdataset('@', 'txt')
        self.failUnless(rds is rdataset)

    def testDeleteRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        z.delete_rdataset('@', 'ns')
        rds = z.get_rdataset('@', 'ns')
        self.failUnless(rds is None)

    def testDeleteRdataset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        z.delete_rdataset('ns1', 'a')
        node = z.get_node('ns1')
        self.failUnless(node is None)

    def testNodeFindRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        node = z['@']
        rds = node.find_rdataset(dns.rdataclass.IN, dns.rdatatype.SOA)
        exrds = dns.rdataset.from_text('IN', 'SOA', 300, 'foo bar 1 2 3 4 5')
        self.failUnless(rds == exrds)

    def testNodeFindRdataset2(self):
        def bad():
            z = dns.zone.from_text(example_text, 'example.', relativize=True)
            node = z['@']
            rds = node.find_rdataset(dns.rdataclass.IN, dns.rdatatype.LOC)
        self.failUnlessRaises(KeyError, bad)

    def testNodeGetRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        node = z['@']
        rds = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.SOA)
        exrds = dns.rdataset.from_text('IN', 'SOA', 300, 'foo bar 1 2 3 4 5')
        self.failUnless(rds == exrds)

    def testNodeGetRdataset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        node = z['@']
        rds = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.LOC)
        self.failUnless(rds == None)

    def testNodeDeleteRdataset1(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        node = z['@']
        rds = node.delete_rdataset(dns.rdataclass.IN, dns.rdatatype.SOA)
        rds = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.SOA)
        self.failUnless(rds == None)

    def testNodeDeleteRdataset2(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        node = z['@']
        rds = node.delete_rdataset(dns.rdataclass.IN, dns.rdatatype.LOC)
        rds = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.LOC)
        self.failUnless(rds == None)

    def testIterateRdatasets(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        ns = [n for n, r in z.iterate_rdatasets('A')]
        ns.sort()
        self.failUnless(ns == [dns.name.from_text('ns1', None),
                               dns.name.from_text('ns2', None)])

    def testIterateAllRdatasets(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        ns = [n for n, r in z.iterate_rdatasets()]
        ns.sort()
        self.failUnless(ns == [dns.name.from_text('@', None),
                               dns.name.from_text('@', None),
                               dns.name.from_text('bar.foo', None),
                               dns.name.from_text('ns1', None),
                               dns.name.from_text('ns2', None)])

    def testIterateRdatas(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        l = list(z.iterate_rdatas('A'))
        l.sort()
        exl = [(dns.name.from_text('ns1', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.A,
                                    '10.0.0.1')),
               (dns.name.from_text('ns2', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.A,
                                    '10.0.0.2'))]
        self.failUnless(l == exl)

    def testIterateAllRdatas(self):
        z = dns.zone.from_text(example_text, 'example.', relativize=True)
        l = list(z.iterate_rdatas())
        l.sort()
        exl = [(dns.name.from_text('@', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.NS,
                                    'ns1')),
               (dns.name.from_text('@', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.NS,
                                    'ns2')),
               (dns.name.from_text('@', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.SOA,
                                    'foo bar 1 2 3 4 5')),
               (dns.name.from_text('bar.foo', None),
                300,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.MX,
                                    '0 blaz.foo')),
               (dns.name.from_text('ns1', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.A,
                                    '10.0.0.1')),
               (dns.name.from_text('ns2', None),
                3600,
                dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.A,
                                    '10.0.0.2'))]
        self.failUnless(l == exl)

    def testTTLs(self):
        z = dns.zone.from_text(ttl_example_text, 'example.', relativize=True)
        n = z['@']
        rds = n.get_rdataset(dns.rdataclass.IN, dns.rdatatype.SOA)
        self.failUnless(rds.ttl == 3600)
        n = z['ns1']
        rds = n.get_rdataset(dns.rdataclass.IN, dns.rdatatype.A)
        self.failUnless(rds.ttl == 86401)
        n = z['ns2']
        rds = n.get_rdataset(dns.rdataclass.IN, dns.rdatatype.A)
        self.failUnless(rds.ttl == 694861)

    def testNoSOA(self):
        def bad():
            z = dns.zone.from_text(no_soa_text, 'example.',
                                   relativize=True)
        self.failUnlessRaises(dns.zone.NoSOA, bad)

    def testNoNS(self):
        def bad():
            z = dns.zone.from_text(no_ns_text, 'example.',
                                   relativize=True)
        self.failUnlessRaises(dns.zone.NoNS, bad)

    def testInclude(self):
        z1 = dns.zone.from_text(include_text, 'example.', relativize=True,
                                allow_include=True)
        z2 = dns.zone.from_file('example', 'example.', relativize=True)
        self.failUnless(z1 == z2)

    def testBadDirective(self):
        def bad():
            z = dns.zone.from_text(bad_directive_text, 'example.',
                                   relativize=True)
        self.failUnlessRaises(dns.exception.SyntaxError, bad)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = chat_demo
#!/usr/bin/env python
#------------------------------------------------------------------------------
#   chat_demo.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
Chat Room Demo for Miniboa.
"""

from miniboa import TelnetServer

IDLE_TIMEOUT = 300
CLIENT_LIST = []
SERVER_RUN = True


def on_connect(client):
    """
    Sample on_connect function.
    Handles new connections.
    """
    print "++ Opened connection to %s" % client.addrport()
    broadcast('%s joins the conversation.\n' % client.addrport() )
    CLIENT_LIST.append(client)
    client.send("Welcome to the Chat Server, %s.\n" % client.addrport() )


def on_disconnect(client):
    """
    Sample on_disconnect function.
    Handles lost connections.
    """
    print "-- Lost connection to %s" % client.addrport()
    CLIENT_LIST.remove(client)
    broadcast('%s leaves the conversation.\n' % client.addrport() )


def kick_idle():
    """
    Looks for idle clients and disconnects them by setting active to False.
    """
    ## Who hasn't been typing?
    for client in CLIENT_LIST:
        if client.idle() > IDLE_TIMEOUT:
            print('-- Kicking idle lobby client from %s' % client.addrport())
            client.active = False


def process_clients():
    """
    Check each client, if client.cmd_ready == True then there is a line of
    input available via client.get_command().
    """
    for client in CLIENT_LIST:
        if client.active and client.cmd_ready:
            ## If the client sends input echo it to the chat room
            chat(client)


def broadcast(msg):
    """
    Send msg to every client.
    """
    for client in CLIENT_LIST:
        client.send(msg)


def chat(client):
    """
    Echo whatever client types to everyone.
    """
    global SERVER_RUN
    msg = client.get_command()
    print '%s says, "%s"' % (client.addrport(), msg)

    for guest in CLIENT_LIST:
        if guest != client:
            guest.send('%s says, %s\n' % (client.addrport(), msg))
        else:
            guest.send('You say, %s\n' % msg)

    cmd = msg.lower()
    ## bye = disconnect
    if cmd == 'bye':
        client.active = False
    ## shutdown == stop the server
    elif cmd == 'shutdown':
        SERVER_RUN = False


#------------------------------------------------------------------------------
#       Main
#------------------------------------------------------------------------------

if __name__ == '__main__':

    ## Simple chat server to demonstrate connection handling via the
    ## async and telnet modules.

    ## Create a telnet server with a port, address,
    ## a function to call with new connections
    ## and one to call with lost connections.

    telnet_server = TelnetServer(
        port=7777,
        address='',
        on_connect=on_connect,
        on_disconnect=on_disconnect,
        timeout = .05
        )

    print(">> Listening for connections on port %d.  CTRL-C to break."
        % telnet_server.port)

    ## Server Loop
    while SERVER_RUN:
        telnet_server.poll()        ## Send, Recv, and look for new connections
        kick_idle()                 ## Check for idle clients
        process_clients()           ## Check for client input

    print(">> Server shutdown.")

########NEW FILE########
__FILENAME__ = handler_demo
#!/usr/bin/env python
#------------------------------------------------------------------------------
#   handler_demo.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
Example of using on_connect and on_disconnect handlers.
"""

from miniboa import TelnetServer


CLIENTS = []


def my_on_connect(client):
    """
    Example on_connect handler.
    """
    client.send('You connected from %s\n' % client.addrport())
    if CLIENTS:
        client.send('Also connected are:\n')
        for neighbor in CLIENTS:
            client.send('%s\n' % neighbor.addrport())
    else:
        client.send('Sadly, you are alone.\n')
    CLIENTS.append(client)


def my_on_disconnect(client):
    """
    Example on_disconnect handler.
    """
    CLIENTS.remove(client)


server = TelnetServer()
server.on_connect=my_on_connect
server.on_disconnect=my_on_disconnect

print "\n\nStarting server on port %d.  CTRL-C to interrupt.\n" % server.port
while True:
    server.poll()

########NEW FILE########
__FILENAME__ = hello_demo
#!/usr/bin/env python
#------------------------------------------------------------------------------
#   hello_demo.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
As simple as it gets.

Launch the Telnet server on the default port and greet visitors using the
placeholder 'on_connect()' function.  Does nothing else.
"""

from miniboa import TelnetServer

server = TelnetServer()
print "\n\nStarting server on port %d.  CTRL-C to interrupt.\n" % server.port
while True:
    server.poll()

########NEW FILE########
__FILENAME__ = async
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
#   miniboa/async.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
Handle Asynchronous Telnet Connections.
"""

import socket
import select
import sys

from miniboa.telnet import TelnetClient
from miniboa.error import BogConnectionLost

## Cap sockets to 512 on Windows because winsock can only process 512 at time
if sys.platform == 'win32':
    MAX_CONNECTIONS = 512
## Cap sockets to 1000 on Linux because you can only have 1024 file descriptors
else:
    MAX_CONNECTIONS = 1000


#-----------------------------------------------------Dummy Connection Handlers

def _on_connect(client):
    """
    Placeholder new connection handler.
    """
    print "++ Opened connection to %s, sending greeting..." % client.addrport()
    client.send("Greetings from Miniboa! "
        " Now it's time to add your code.\n")

def _on_disconnect(client):
    """
    Placeholder lost connection handler.
    """
    print "-- Lost connection to %s" % client.addrport()


#-----------------------------------------------------------------Telnet Server

class TelnetServer(object):
    """
    Poll sockets for new connections and sending/receiving data from clients.
    """
    def __init__(self, port=7777, host='', on_connect=_on_connect,
            on_disconnect=_on_disconnect, timeout=0.005):
        """
        Create a new Telnet Server.

        port -- Port to listen for new connection on.  On UNIX-like platforms,
            you made need root access to use ports under 1025.

        host -- Address of the LOCAL network interface to listen on.  You
            can usually leave this blank unless you want to restrict traffic
            to a specific network device.  This will usually NOT be the same
            as the Internet address of your server.

        on_connect -- function to call with new telnet connections

        on_disconnect -- function to call when a client's connection dies,
            either through a terminated session or client.active being set
            to False.

        timeout -- amount of time that Poll() will wait from user inport
            before returning.  Also frees a slice of CPU time.
        """

        self.port = port
        self.host = host
        self.on_connect = on_connect
        self.on_disconnect = on_disconnect
        self.timeout = timeout

        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind((host, port))
        self.address = server_socket.getsockname()
        server_socket.listen(5)

        self.server_socket = server_socket
        self.server_fileno = server_socket.fileno()

        ## Dictionary of active clients,
        ## key = file descriptor, value = TelnetClient (see miniboa.telnet)
        self.clients = {}

    def client_count(self):
        """
        Returns the number of active connections.
        """
        return len(self.clients)

    def client_list(self):
        """
        Returns a list of connected clients.
        """
        return self.clients.values()


    def poll(self):
        """
        Perform a non-blocking scan of recv and send states on the server
        and client connection sockets.  Process new connection requests,
        read incomming data, and send outgoing data.  Sends and receives may
        be partial.
        """
        #print len(self.connections)
        ## Build a list of connections to test for receive data pending
        recv_list = [self.server_fileno]    # always add the server

        for client in self.clients.values():
            if client.active:
                recv_list.append(client.fileno)
            ## Delete inactive connections from the dictionary
            else:
                #print "-- Lost connection to %s" % client.addrport()
                #client.sock.close()
                self.on_disconnect(client)
                del self.clients[client.fileno]


        ## Build a list of connections that need to send data
        send_list = []
        for client in self.clients.values():
            if client.send_pending:
                send_list.append(client.fileno)

        ## Get active socket file descriptors from select.select()
        try:
            rlist, slist, elist = select.select(recv_list, send_list, [],
                self.timeout)

        except select.error, err:
            ## If we can't even use select(), game over man, game over
            print >> sys.stderr, ("!! FATAL SELECT error '%d:%s'!"
                % (err[0], err[1]))
            sys.exit(1)

        ## Process socket file descriptors with data to recieve
        for sock_fileno in rlist:

            ## If it's coming from the server's socket then this is a new
            ## connection request.
            if sock_fileno == self.server_fileno:

                try:
                    sock, addr_tup = self.server_socket.accept()

                except socket.error, err:
                    print >> sys.stderr, ("!! ACCEPT error '%d:%s'." %
                        (err[0], err[1]))
                    continue

                ## Check for maximum connections
                if self.client_count() >= MAX_CONNECTIONS:
                    print '?? Refusing new connection; maximum in use.'
                    sock.close()
                    continue

                new_client = TelnetClient(sock, addr_tup)
                #print "++ Opened connection to %s" % new_client.addrport()
                ## Add the connection to our dictionary and call handler
                self.clients[new_client.fileno] = new_client
                self.on_connect(new_client)

            else:
                ## Call the connection's recieve method
                try:
                    self.clients[sock_fileno].socket_recv()
                except BogConnectionLost:
                    self.clients[sock_fileno].deactivate()

        ## Process sockets with data to send
        for sock_fileno in slist:
            ## Call the connection's send method
            self.clients[sock_fileno].socket_send()

########NEW FILE########
__FILENAME__ = error
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
#   miniboa/error.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

class BogConnectionLost(Exception):
    """
    Custom exception to signal a lost connection to the Telnet Server.
    """
    pass

########NEW FILE########
__FILENAME__ = telnet
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
#   miniboa/telnet.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
Manage one Telnet client connected via a TCP/IP socket.
"""

import socket
import time

from miniboa.error import BogConnectionLost
from miniboa.xterm import colorize
from miniboa.xterm import word_wrap


#---[ Telnet Notes ]-----------------------------------------------------------
# (See RFC 854 for more information)
#
# Negotiating a Local Option
# --------------------------
#
# Side A begins with:
#
#    "IAC WILL/WONT XX"   Meaning "I would like to [use|not use] option XX."
#
# Side B replies with either:
#
#    "IAC DO XX"     Meaning "OK, you may use option XX."
#    "IAC DONT XX"   Meaning "No, you cannot use option XX."
#
#
# Negotiating a Remote Option
# ----------------------------
#
# Side A begins with:
#
#    "IAC DO/DONT XX"  Meaning "I would like YOU to [use|not use] option XX."
#
# Side B replies with either:
#
#    "IAC WILL XX"   Meaning "I will begin using option XX"
#    "IAC WONT XX"   Meaning "I will not begin using option XX"
#
#
# The syntax is designed so that if both parties receive simultaneous requests
# for the same option, each will see the other's request as a positive
# acknowledgement of it's own.
#
# If a party receives a request to enter a mode that it is already in, the
# request should not be acknowledged.

## Where you see DE in my comments I mean 'Distant End', e.g. the client.

UNKNOWN = -1

#--[ Telnet Commands ]---------------------------------------------------------

SE      = chr(240)      # End of subnegotiation parameters
NOP     = chr(241)      # No operation
DATMK   = chr(242)      # Data stream portion of a sync.
BREAK   = chr(243)      # NVT Character BRK
IP      = chr(244)      # Interrupt Process
AO      = chr(245)      # Abort Output
AYT     = chr(246)      # Are you there
EC      = chr(247)      # Erase Character
EL      = chr(248)      # Erase Line
GA      = chr(249)      # The Go Ahead Signal
SB      = chr(250)      # Sub-option to follow
WILL    = chr(251)      # Will; request or confirm option begin
WONT    = chr(252)      # Wont; deny option request
DO      = chr(253)      # Do = Request or confirm remote option
DONT    = chr(254)      # Don't = Demand or confirm option halt
IAC     = chr(255)      # Interpret as Command
SEND    = chr(001)      # Sub-process negotiation SEND command
IS      = chr(000)      # Sub-process negotiation IS command

#--[ Telnet Options ]----------------------------------------------------------

BINARY  = chr(  0)      # Transmit Binary
ECHO    = chr(  1)      # Echo characters back to sender
RECON   = chr(  2)      # Reconnection
SGA     = chr(  3)      # Suppress Go-Ahead
TTYPE   = chr( 24)      # Terminal Type
NAWS    = chr( 31)      # Negotiate About Window Size
LINEMO  = chr( 34)      # Line Mode


#-----------------------------------------------------------------Telnet Option

class TelnetOption(object):
    """
    Simple class used to track the status of an extended Telnet option.
    """
    def __init__(self):
        self.local_option = UNKNOWN     # Local state of an option
        self.remote_option = UNKNOWN    # Remote state of an option
        self.reply_pending = False      # Are we expecting a reply?


#------------------------------------------------------------------------Telnet

class TelnetClient(object):

    """
    Represents a client connection via Telnet.

    First argument is the socket discovered by the Telnet Server.
    Second argument is the tuple (ip address, port number).
    """

    def __init__(self, sock, addr_tup):
        self.protocol = 'telnet'
        self.active = True          # Turns False when the connection is lost
        self.sock = sock            # The connection's socket
        self.fileno = sock.fileno() # The socket's file descriptor
        self.address = addr_tup[0]  # The client's remote TCP/IP address
        self.port = addr_tup[1]     # The client's remote port
        self.terminal_type = 'unknown client' # set via request_terminal_type()
        self.use_ansi = True
        self.columns = 80
        self.rows = 24
        self.send_pending = False
        self.send_buffer = ''
        self.recv_buffer = ''
        self.bytes_sent = 0
        self.bytes_received = 0
        self.cmd_ready = False
        self.command_list = []
        self.connect_time = time.time()
        self.last_input_time = time.time()

        ## State variables for interpreting incoming telnet commands
        self.telnet_got_iac = False # Are we inside an IAC sequence?
        self.telnet_got_cmd = None  # Did we get a telnet command?
        self.telnet_got_sb = False  # Are we inside a subnegotiation?
        self.telnet_opt_dict = {}   # Mapping for up to 256 TelnetOptions
        self.telnet_echo = False    # Echo input back to the client?
        self.telnet_echo_password = False  # Echo back '*' for passwords?
        self.telnet_sb_buffer = ''  # Buffer for sub-negotiations

#    def __del__(self):

#        print "Telnet destructor called"
#        pass

    def get_command(self):
        """
        Get a line of text that was received from the DE. The class's
        cmd_ready attribute will be true if lines are available.
        """
        cmd = None
        count = len(self.command_list)
        if count > 0:
            cmd = self.command_list.pop(0)
        ## If that was the last line, turn off lines_pending
        if count == 1:
            self.cmd_ready = False
        return cmd

    def send(self, text):
        """
        Send raw text to the distant end.
        """
        if text:
            self.send_buffer += text.replace('\n', '\r\n')
            self.send_pending = True

    def send_cc(self, text):
        """
        Send text with caret codes converted to ansi.
        """
        self.send(colorize(text, self.use_ansi))

    def send_wrapped(self, text):
        """
        Send text padded and wrapped to the user's screen width.
        """
        lines = word_wrap(text, self.columns)
        for line in lines:
            self.send_cc(line + '\n')

    def deactivate(self):
        """
        Set the client to disconnect on the next server poll.
        """
        self.active = False

    def addrport(self):
        """
        Return the DE's IP address and port number as a string.
        """
        return "%s:%s" % (self.address, self.port)

    def idle(self):
        """
        Returns the number of seconds that have elasped since the DE
        last sent us some input.
        """
        return time.time() - self.last_input_time

    def duration(self):
        """
        Returns the number of seconds the DE has been connected.
        """
        return time.time() - self.connect_time

    def request_do_sga(self):
        """
        Request DE to Suppress Go-Ahead.  See RFC 858.
        """
        self._iac_do(SGA)
        self._note_reply_pending(SGA, True)

    def request_will_echo(self):
        """
        Tell the DE that we would like to echo their text.  See RFC 857.
        """
        self._iac_will(ECHO)
        self._note_reply_pending(ECHO, True)
        self.telnet_echo = True

    def request_wont_echo(self):
        """
        Tell the DE that we would like to stop echoing their text.
        See RFC 857.
        """
        self._iac_wont(ECHO)
        self._note_reply_pending(ECHO, True)
        self.telnet_echo = False

    def password_mode_on(self):
        """
        Tell DE we will echo (but don't) so typed passwords don't show.
        """
        self._iac_will(ECHO)
        self._note_reply_pending(ECHO, True)

    def password_mode_off(self):
        """
        Tell DE we are done echoing (we lied) and show typing again.
        """
        self._iac_wont(ECHO)
        self._note_reply_pending(ECHO, True)

    def request_naws(self):
        """
        Request to Negotiate About Window Size.  See RFC 1073.
        """
        self._iac_do(NAWS)
        self._note_reply_pending(NAWS, True)

    def request_terminal_type(self):
        """
        Begins the Telnet negotiations to request the terminal type from
        the client.  See RFC 779.
        """
        self._iac_do(TTYPE)
        self._note_reply_pending(TTYPE, True)

    def socket_send(self):
        """
        Called by TelnetServer when send data is ready.
        """
        if len(self.send_buffer):
            try:
                sent = self.sock.send(self.send_buffer)
            except socket.error, err:
                print("!! SEND error '%d:%s' from %s" % (err[0], err[1],
                    self.addrport()))
                self.active = False
                return
            self.bytes_sent += sent
            self.send_buffer = self.send_buffer[sent:]
        else:
            self.send_pending = False

    def socket_recv(self):
        """
        Called by TelnetServer when recv data is ready.
        """
        try:
            data = self.sock.recv(2048)
        except socket.error, ex:
            print ("?? socket.recv() error '%d:%s' from %s" %
                (ex[0], ex[1], self.addrport()))
            raise BogConnectionLost()

        ## Did they close the connection?
        size = len(data)
        if size == 0:
            raise BogConnectionLost()

        ## Update some trackers
        self.last_input_time = time.time()
        self.bytes_received += size

        ## Test for telnet commands
        for byte in data:
            self._iac_sniffer(byte)

        ## Look for newline characters to get whole lines from the buffer
        while True:
            mark = self.recv_buffer.find('\n')
            if mark == -1:
                break
            cmd = self.recv_buffer[:mark].strip()
            self.command_list.append(cmd)
            self.cmd_ready = True
            self.recv_buffer = self.recv_buffer[mark+1:]

    def _recv_byte(self, byte):
        """
        Non-printable filtering currently disabled because it did not play
        well with extended character sets.
        """
        ## Filter out non-printing characters
        #if (byte >= ' ' and byte <= '~') or byte == '\n':
        if self.telnet_echo:
            self._echo_byte(byte)
        self.recv_buffer += byte

    def _echo_byte(self, byte):
        """
        Echo a character back to the client and convert LF into CR\LF.
        """
        if byte == '\n':
            self.send_buffer += '\r'
        if self.telnet_echo_password:
            self.send_buffer += '*'
        else:
            self.send_buffer += byte

    def _iac_sniffer(self, byte):
        """
        Watches incomming data for Telnet IAC sequences.
        Passes the data, if any, with the IAC commands stripped to
        _recv_byte().
        """
        ## Are we not currently in an IAC sequence coming from the DE?
        if self.telnet_got_iac is False:

            if byte == IAC:
                ## Well, we are now
                self.telnet_got_iac = True
                return

            ## Are we currenty in a sub-negotion?
            elif self.telnet_got_sb is True:
                ## Sanity check on length
                if len(self.telnet_sb_buffer) < 64:
                    self.telnet_sb_buffer += byte
                else:
                    self.telnet_got_sb = False
                    self.telnet_sb_buffer = ""
                return

            else:
                ## Just a normal NVT character
                self._recv_byte(byte)
                return

        ## Byte handling when already in an IAC sequence sent from the DE

        else:

            ## Did we get sent a second IAC?
            if byte == IAC and self.telnet_got_sb is True:
                ## Must be an escaped 255 (IAC + IAC)
                self.telnet_sb_buffer += byte
                self.telnet_got_iac = False
                return

            ## Do we already have an IAC + CMD?
            elif self.telnet_got_cmd:
                ## Yes, so handle the option
                self._three_byte_cmd(byte)
                return

            ## We have IAC but no CMD
            else:

                ## Is this the middle byte of a three-byte command?
                if byte == DO:
                    self.telnet_got_cmd = DO
                    return

                elif byte == DONT:
                    self.telnet_got_cmd = DONT
                    return

                elif byte == WILL:
                    self.telnet_got_cmd = WILL
                    return

                elif byte == WONT:
                    self.telnet_got_cmd = WONT
                    return

                else:
                    ## Nope, must be a two-byte command
                    self._two_byte_cmd(byte)


    def _two_byte_cmd(self, cmd):
        """
        Handle incoming Telnet commands that are two bytes long.
        """
        #print "got two byte cmd %d" % ord(cmd)

        if cmd == SB:
            ## Begin capturing a sub-negotiation string
            self.telnet_got_sb = True
            self.telnet_sb_buffer = ''

        elif cmd == SE:
            ## Stop capturing a sub-negotiation string
            self.telnet_got_sb = False
            self._sb_decoder()

        elif cmd == NOP:
            pass

        elif cmd == DATMK:
            pass

        elif cmd == IP:
            pass

        elif cmd == AO:
            pass

        elif cmd == AYT:
            pass

        elif cmd == EC:
            pass

        elif cmd == EL:
            pass

        elif cmd == GA:
            pass

        else:
            print "2BC: Should not be here."

        self.telnet_got_iac = False
        self.telnet_got_cmd = None

    def _three_byte_cmd(self, option):
        """
        Handle incoming Telnet commmands that are three bytes long.
        """
        cmd = self.telnet_got_cmd
        #print "got three byte cmd %d:%d" % (ord(cmd), ord(option))

        ## Incoming DO's and DONT's refer to the status of this end

        #---[ DO ]-------------------------------------------------------------

        if cmd == DO:

            if option == BINARY:

                if self._check_reply_pending(BINARY):
                    self._note_reply_pending(BINARY, False)
                    self._note_local_option(BINARY, True)

                elif (self._check_local_option(BINARY) is False or
                        self._check_local_option(BINARY) is UNKNOWN):
                    self._note_local_option(BINARY, True)
                    self._iac_will(BINARY)
                    ## Just nod

            elif option == ECHO:

                if self._check_reply_pending(ECHO):
                    self._note_reply_pending(ECHO, False)
                    self._note_local_option(ECHO, True)

                elif (self._check_local_option(ECHO) is False or
                        self._check_local_option(ECHO) is UNKNOWN):
                    self._note_local_option(ECHO, True)
                    self._iac_will(ECHO)
                    self.telnet_echo = True

            elif option == SGA:

                if self._check_reply_pending(SGA):
                    self._note_reply_pending(SGA, False)
                    self._note_local_option(SGA, True)

                elif (self._check_local_option(SGA) is False or
                        self._check_local_option(SGA) is UNKNOWN):
                    self._note_local_option(SGA, True)
                    self._iac_will(SGA)
                    ## Just nod

            else:

                ## ALL OTHER OTHERS = Default to refusing once
                if self._check_local_option(option) is UNKNOWN:
                    self._note_local_option(option, False)
                    self._iac_wont(option)


        #---[ DONT ]-----------------------------------------------------------

        elif cmd == DONT:

            if option == BINARY:

                if self._check_reply_pending(BINARY):
                    self._note_reply_pending(BINARY, False)
                    self._note_local_option(BINARY, False)

                elif (self._check_local_option(BINARY) is True or
                        self._check_local_option(BINARY) is UNKNOWN):
                    self._note_local_option(BINARY, False)
                    self._iac_wont(BINARY)
                    ## Just nod

            elif option == ECHO:

                if self._check_reply_pending(ECHO):
                    self._note_reply_pending(ECHO, False)
                    self._note_local_option(ECHO, True)
                    self.telnet_echo = False

                elif (self._check_local_option(BINARY) is True or
                        self._check_local_option(BINARY) is UNKNOWN):
                    self._note_local_option(ECHO, False)
                    self._iac_wont(ECHO)
                    self.telnet_echo = False

            elif option == SGA:

                if self._check_reply_pending(SGA):
                    self._note_reply_pending(SGA, False)
                    self._note_local_option(SGA, False)

                elif (self._check_remote_option(SGA) is True or
                        self._check_remote_option(SGA) is UNKNOWN):
                    self._note_local_option(SGA, False)
                    self._iac_will(SGA)
                    ## Just nod

            else:

                ## ALL OTHER OPTIONS = Default to ignoring
                pass


        ## Incoming WILL's and WONT's refer to the status of the DE

        #---[ WILL ]-----------------------------------------------------------

        elif cmd == WILL:

            if option == ECHO:

                ## Nutjob DE offering to echo the server...
                if self._check_remote_option(ECHO) is UNKNOWN:
                    self._note_remote_option(ECHO, False)
                    # No no, bad DE!
                    self._iac_dont(ECHO)

            elif option == NAWS:

                if self._check_reply_pending(NAWS):
                    self._note_reply_pending(NAWS, False)
                    self._note_remote_option(NAWS, True)
                    ## Nothing else to do, client follow with SB

                elif (self._check_remote_option(NAWS) is False or
                        self._check_remote_option(NAWS) is UNKNOWN):
                    self._note_remote_option(NAWS, True)
                    self._iac_do(NAWS)
                    ## Client should respond with SB

            elif option == SGA:

                if self._check_reply_pending(SGA):
                    self._note_reply_pending(SGA, False)
                    self._note_remote_option(SGA, True)

                elif (self._check_remote_option(SGA) is False or
                        self._check_remote_option(SGA) is UNKNOWN):
                    self._note_remote_option(SGA, True)
                    self._iac_do(SGA)
                    ## Just nod

            elif option == TTYPE:

                if self._check_reply_pending(TTYPE):
                    self._note_reply_pending(TTYPE, False)
                    self._note_remote_option(TTYPE, True)
                    ## Tell them to send their terminal type
                    self.send('%c%c%c%c%c%c' % (IAC, SB, TTYPE, SEND, IAC, SE))

                elif (self._check_remote_option(TTYPE) is False or
                        self._check_remote_option(TTYPE) is UNKNOWN):
                    self._note_remote_option(TTYPE, True)
                    self._iac_do(TTYPE)


        #---[ WONT ]-----------------------------------------------------------

        elif cmd == WONT:

            if option == ECHO:

                ## DE states it wont echo us -- good, they're not suppose to.
                if self._check_remote_option(ECHO) is UNKNOWN:
                    self._note_remote_option(ECHO, False)
                    self._iac_dont(ECHO)

            elif option == SGA:

                if self._check_reply_pending(SGA):
                    self._note_reply_pending(SGA, False)
                    self._note_remote_option(SGA, False)

                elif (self._check_remote_option(SGA) is True or
                        self._check_remote_option(SGA) is UNKNOWN):
                    self._note_remote_option(SGA, False)
                    self._iac_dont(SGA)

                if self._check_reply_pending(TTYPE):
                    self._note_reply_pending(TTYPE, False)
                    self._note_remote_option(TTYPE, False)

                elif (self._check_remote_option(TTYPE) is True or
                        self._check_remote_option(TTYPE) is UNKNOWN):
                    self._note_remote_option(TTYPE, False)
                    self._iac_dont(TTYPE)

        else:
            print "3BC: Should not be here."

        self.telnet_got_iac = False
        self.telnet_got_cmd = None

    def _sb_decoder(self):
        """
        Figures out what to do with a received sub-negotiation block.
        """
        #print "at decoder"
        bloc = self.telnet_sb_buffer
        if len(bloc) > 2:

            if bloc[0] == TTYPE and bloc[1] == IS:
                self.terminal_type = bloc[2:]
                #print "Terminal type = '%s'" % self.terminal_type

            if bloc[0] == NAWS:
                if len(bloc) != 5:
                    print "Bad length on NAWS SB:", len(bloc)
                else:
                    self.columns = (256 * ord(bloc[1])) + ord(bloc[2])
                    self.rows = (256 * ord(bloc[3])) + ord(bloc[4])

                #print "Screen is %d x %d" % (self.columns, self.rows)

        self.telnet_sb_buffer = ''


    #---[ State Juggling for Telnet Options ]----------------------------------

    ## Sometimes verbiage is tricky.  I use 'note' rather than 'set' here
    ## because (to me) set infers something happened.

    def _check_local_option(self, option):
        """Test the status of local negotiated Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        return self.telnet_opt_dict[option].local_option

    def _note_local_option(self, option, state):
        """Record the status of local negotiated Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        self.telnet_opt_dict[option].local_option = state

    def _check_remote_option(self, option):
        """Test the status of remote negotiated Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        return self.telnet_opt_dict[option].remote_option

    def _note_remote_option(self, option, state):
        """Record the status of local negotiated Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        self.telnet_opt_dict[option].remote_option = state

    def _check_reply_pending(self, option):
        """Test the status of requested Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        return self.telnet_opt_dict[option].reply_pending

    def _note_reply_pending(self, option, state):
        """Record the status of requested Telnet options."""
        if not self.telnet_opt_dict.has_key(option):
            self.telnet_opt_dict[option] = TelnetOption()
        self.telnet_opt_dict[option].reply_pending = state


    #---[ Telnet Command Shortcuts ]-------------------------------------------

    def _iac_do(self, option):
        """Send a Telnet IAC "DO" sequence."""
        self.send('%c%c%c' % (IAC, DO, option))

    def _iac_dont(self, option):
        """Send a Telnet IAC "DONT" sequence."""
        self.send('%c%c%c' % (IAC, DONT, option))

    def _iac_will(self, option):
        """Send a Telnet IAC "WILL" sequence."""
        self.send('%c%c%c' % (IAC, WILL, option))

    def _iac_wont(self, option):
        """Send a Telnet IAC "WONT" sequence."""
        self.send('%c%c%c' % (IAC, WONT, option))

########NEW FILE########
__FILENAME__ = xterm
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
#   mudlib/usr/xterm.py
#   Copyright 2009 Jim Storch
#   Licensed under the Apache License, Version 2.0 (the "License"); you may
#   not use this file except in compliance with the License. You may obtain a
#   copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#   License for the specific language governing permissions and limitations
#   under the License.
#------------------------------------------------------------------------------

"""
Support for color and formatting for Xterm style clients.
"""

import re


_PARA_BREAK = re.compile(r"(\n\s*\n)", re.MULTILINE)

#--[ Caret Code to ANSI TABLE ]------------------------------------------------

_ANSI_CODES = (
    ( '^k', '\x1b[22;30m' ),    # black
    ( '^K', '\x1b[1;30m' ),     # bright black (grey)
    ( '^r', '\x1b[22;31m' ),    # red
    ( '^R', '\x1b[1;31m' ),     # bright red
    ( '^g', '\x1b[22;32m' ),    # green
    ( '^G', '\x1b[1;32m' ),     # bright green
    ( '^y', '\x1b[22;33m' ),    # yellow
    ( '^Y', '\x1b[1;33m' ),     # bright yellow
    ( '^b', '\x1b[22;34m' ),    # blue
    ( '^B', '\x1b[1;34m' ),     # bright blue
    ( '^m', '\x1b[22;35m' ),    # magenta
    ( '^M', '\x1b[1;35m' ),     # bright magenta
    ( '^c', '\x1b[22;36m' ),    # cyan
    ( '^C', '\x1b[1;36m' ),     # bright cyan
    ( '^w', '\x1b[22;37m' ),    # white
    ( '^W', '\x1b[1;37m' ),     # bright white
    ( '^0', '\x1b[40m' ),       # black background
    ( '^1', '\x1b[41m' ),       # red background
    ( '^2', '\x1b[42m' ),       # green background
    ( '^3', '\x1b[43m' ),       # yellow background
    ( '^4', '\x1b[44m' ),       # blue background
    ( '^5', '\x1b[45m' ),       # magenta background
    ( '^6', '\x1b[46m' ),       # cyan background
    ( '^d', '\x1b[39m' ),       # default (should be white on black)
    ( '^I', '\x1b[7m' ),        # inverse text on
    ( '^i', '\x1b[27m' ),       # inverse text off
    ( '^~', '\x1b[0m' ),        # reset all
    ( '^U', '\x1b[4m' ),        # underline on
    ( '^u', '\x1b[24m' ),       # underline off
    ( '^!', '\x1b[1m' ),        # bold on
    ( '^.', '\x1b[22m'),        # bold off
    ( '^s', '\x1b[2J'),         # clear screen
    ( '^l', '\x1b[2K'),         # clear to end of line
    )


def strip_caret_codes(text):
    """
    Strip out any caret codes from a string.
    """
    ## temporarily escape out ^^
    text = text.replace('^^', '\x00')
    for token, foo in _ANSI_CODES:
        text = text.replace(token, '')
    return text.replace('\x00', '^')


def colorize(text, ansi=True):
    """
    If the client wants ansi, replace the tokens with ansi sequences --
    otherwise, simply strip them out.
    """
    if ansi:
        text = text.replace('^^', '\x00')
        for token, code in _ANSI_CODES:
            text = text.replace(token, code)
        text = text.replace('\x00', '^')
    else:
        text = strip_caret_codes(text)
    return text


def word_wrap(text, columns=80, indent=4, padding=2):
    """
    Given a block of text, breaks into a list of lines wrapped to
    length.
    """
    paragraphs = _PARA_BREAK.split(text)
    lines = []
    columns -= padding
    for para in paragraphs:
        if para.isspace():
            continue
        line = ' ' * indent
        for word in para.split():
            if (len(line) + 1 + len(word)) > columns:
                lines.append(line)
                line = ' ' * padding
                line += word
            else:
                line += ' ' + word
        if not line.isspace():
            lines.append(line)
    return lines

########NEW FILE########
