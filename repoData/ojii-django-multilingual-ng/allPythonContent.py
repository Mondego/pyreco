__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-multilingual-ng documentation build configuration file, created by
# sphinx-quickstart on Mon Mar  8 22:33:53 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('..'))
from multilingual import __version__

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-multilingual-ng'
copyright = u'2010, Jonas Obrist'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '.'.join(__version__.split('.')[:2])
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-multilingual-ngdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-multilingual-ng.tex', u'django-multilingual-ng Documentation',
   u'Jonas Obrist', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
"""Admin suppor for inlines

Peter Cicman, Divio GmbH, 2008
"""
from django.utils.text import capfirst, get_text_list
from django.contrib.admin.util import flatten_fieldsets
from django.http import HttpResponseRedirect
from django.utils.encoding import force_unicode

import re
from copy import deepcopy
from django.conf import settings
from django import forms
from django.contrib import admin
from django.db.models import Model
from django.forms.util import ErrorList, ValidationError
from django.forms.models import BaseInlineFormSet, ModelFormMetaclass
from django.utils.translation import ugettext as _
from django.template.loader import find_template
from django.template import TemplateDoesNotExist
from multilingual.languages import get_default_language
from multilingual.utils import GLL

MULTILINGUAL_PREFIX = '_ml__trans_'
MULTILINGUAL_INLINE_PREFIX = '_ml__inline_trans_'

def gll(func):
    def wrapped(cls, request, *args, **kwargs):
        cls.use_language = request.GET.get('lang', request.GET.get('language', get_default_language()))
        GLL.lock(cls.use_language)
        resp = func(cls, request, *args, **kwargs)
        GLL.release()
        return resp
    wrapped.__name__ = func.__name__
    wrapped.__doc__ = func.__doc__
    return wrapped

def standard_get_fill_check_field(stdopts):
    if hasattr(stdopts, 'translation_model'):
        opts = stdopts.translation_model._meta
        for field in opts.fields:
            if field.name in ('language_code', 'master'):
                continue
            if not (field.blank or field.null):
                return field.name
    return None

def relation_hack(form, fields, prefix=''):
    opts = form.instance._meta
    localm2m = [m2m.attname for m2m in opts.local_many_to_many]
    externalfk = [obj.field.related_query_name() for obj in opts.get_all_related_objects()]
    externalm2m = [m2m.get_accessor_name() for m2m in opts.get_all_related_many_to_many_objects()]
    for name, db_field in fields:
        full_name = '%s%s' % (prefix, name)
        if full_name in form.fields:
            value = getattr(form.instance, name, '')
            # check for (local) ForeignKeys
            if isinstance(value, Model):
                value = value.pk
            # check for (local) many to many fields
            elif name in localm2m:
                value = value.all()
            # check for (external) ForeignKeys
            elif name in externalfk:
                value = value.all()
            # check for (external) many to many fields
            elif name in externalm2m:
                value = value.all()
            form.fields[full_name].initial = value


class MultilingualInlineModelForm(forms.ModelForm):
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=':',
                 empty_permitted=False, instance=None):
        """
        Fill initial ML Fields
        """
        super(MultilingualInlineModelForm, self).__init__(data, files, auto_id,
            prefix, initial, error_class, label_suffix, empty_permitted, instance)
        
        # only read initial data if the object already exists, not if we're adding it!
        if self.instance.pk:
            relation_hack(self, get_translated_fields(self.instance), MULTILINGUAL_INLINE_PREFIX)


class MultilingualInlineFormSet(BaseInlineFormSet):
    def get_queryset(self):
        if self.queryset is not None:
            qs = self.queryset
        else:
            qs = self.model._default_manager.get_query_set()

        if not qs.ordered:
            qs = qs.order_by(self.model._meta.pk.name)

        if self.max_num > 0:
            _queryset = qs[:self.max_num]
        else:
            _queryset = qs
        return _queryset

    def save_new(self, form, commit=True):
        """
        NOTE: save_new method is completely overridden here, there's no
        other way to pretend double save otherwise. Just assign translated data
        to object  
        """
        kwargs = {self.fk.get_attname(): self.instance.pk}
        new_obj = self.model(**kwargs)
        self._prepare_multilingual_object(new_obj, form)
        return forms.save_instance(form, new_obj, exclude=[self._pk_field.name], commit=commit)
    
    def save_existing(self, form, instance, commit=True):
        """
        NOTE: save_new method is completely overridden here, there's no
        other way to pretend double save otherwise. Just assign translated data
        to object  
        """
        self._prepare_multilingual_object(instance, form)
        return forms.save_instance(form, instance, exclude=[self._pk_field.name], commit=commit)
    
    def _prepare_multilingual_object(self, obj, form):
        opts = obj._meta
        for realname, fieldname in self.ml_fields.items():
            field = opts.get_field_by_name(realname)[0]
            m = re.match(r'^%s(?P<field_name>.*)$' % MULTILINGUAL_INLINE_PREFIX, fieldname)
            if m:
                field.save_form_data(self.instance, form.cleaned_data[fieldname])
                setattr(obj, realname, getattr(self.instance, realname.rsplit('_', 1)[0]))
      
      
class MultilingualInlineAdmin(admin.TabularInline):
    formset = MultilingualInlineFormSet
    form = MultilingualInlineModelForm
    
    template = 'admin/multilingual/edit_inline/tabular.html'
    
    # css class added to inline box
    inline_css_class = None
    
    use_language = None
    
    fill_check_field = None
    #TODO: add some nice template
    
    def __init__(self, parent_model, admin_site):
        super(MultilingualInlineAdmin, self).__init__(parent_model, admin_site)
        if hasattr(self, 'use_fields'):
            # go around admin fields structure validation
            self.fields = self.use_fields
        
    def get_formset(self, request, obj=None, **kwargs):
        FormSet = super(MultilingualInlineAdmin, self).get_formset(request, obj, **kwargs)
        FormSet.use_language = GLL.language_code
        FormSet.ml_fields = {}
        for name, field in get_translated_fields(self.model, GLL.language_code):
            fieldname = '%s%s' % (MULTILINGUAL_INLINE_PREFIX, name)
            FormSet.form.base_fields[fieldname] = self.formfield_for_dbfield(field, request=request)
            FormSet.ml_fields[name] = fieldname
        return FormSet

    def queryset(self, request):
        """
        Filter objects which don't have a value in this language
        """
        qs = super(MultilingualInlineAdmin, self).queryset(request)
        # Don't now what the hell I was thinking here, but this code breaks stuff:
        #
        # checkfield = self.get_fill_check_field()
        # if checkfield is not None:
        #     kwargs = {str('%s_%s__isnull' % (checkfield, GLL.language_code)): False}
        #     from django.db.models.fields import CharField
        #     if isinstance(self.model._meta.translation_model._meta.get_field_by_name(checkfield)[0], CharField):
        #         kwargs[str('%s_%s__gt' % (checkfield, GLL.language_code))] = ''
        #     return qs.filter(**kwargs)
        return qs.filter(translations__language_code=GLL.language_code).distinct()
    
    def get_fill_check_field(self):
        if self.fill_check_field is None:
            self.fill_check_field = standard_get_fill_check_field(self.model._meta)
        return self.fill_check_field
    
    
class MultilingualModelAdminForm(forms.ModelForm):
    # for rendering / saving multilingual fields connecte to model, takes place
    # when admin per language is ussed
    
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=':',
                 empty_permitted=False, instance=None):
        """
        Fill up initial ML Fields
        """
        super(MultilingualModelAdminForm, self).__init__(data, files, auto_id, prefix,
                                                    initial, error_class, label_suffix,
                                                    empty_permitted, instance)
        # only try to fill intial data if we are not adding an object!
        if self.instance.pk:
            fields = [(f, getattr(self.instance, "%s_%s" % (f, GLL.language_code), '')) for f in self.ml_fields]
            relation_hack(self, fields)
    
    def clean(self):
        cleaned_data = super(MultilingualModelAdminForm, self).clean()
        self.validate_ml_unique()
        return cleaned_data
    
    def validate_ml_unique(self):
        form_errors = []
        
        if not hasattr(self.instance._meta, 'translation_model'):
            return
        for check in self.instance._meta.translation_model._meta.unique_together[:]:
            lookup_kwargs = {'language_code': GLL.language_code}
            for field_name in check:
                #local_name = "%s_%s" % (field_name, self.use_language)
                if self.cleaned_data.get(field_name) is not None:
                    lookup_kwargs[field_name] = self.cleaned_data.get(field_name) 
            
            if len(check) == 2 and 'master' in check and 'language_code' in check:
                continue
                
            qs = self.instance._meta.translation_model.objects.filter(**lookup_kwargs)
            if self.instance.pk is not None:
                qs = qs.exclude(master=self.instance.pk)
            
            if qs.count():
                model_name = capfirst(self.instance._meta.verbose_name)
                field_labels = []
                for field_name in check:
                    if field_name == "language_code":
                        field_labels.append(_("language"))
                    elif field_name == "master":
                        continue
                    else:
                        field_labels.append(self.instance._meta.translation_model._meta.get_field_by_name(field_name)[0].verbose_name)
                field_labels = get_text_list(field_labels, _('and'))
                form_errors.append(
                    _(u"%(model_name)s with this %(field_label)s already exists.") % \
                    {'model_name': unicode(model_name),
                     'field_label': unicode(field_labels)}
                )
        if form_errors:
            # Raise the unique together errors since they are considered
            # form-wide.
            raise ValidationError(form_errors)
                
    
    def save(self, commit=True):
        self._prepare_multilingual_object(self.instance, self)
        return super(MultilingualModelAdminForm, self).save(commit)    
        
        
    def _prepare_multilingual_object(self, obj, form):
        opts = self.instance._meta
        for name in self.ml_fields:
            field = opts.get_field_by_name(name)[0]
            # respect save_form_data
            field.save_form_data(self.instance, form.cleaned_data[name])
            setattr(obj, "%s_%s" % (name, GLL.language_code), getattr(self.instance, name))



class MultilingualModelAdmin(admin.ModelAdmin):
    
    # use special template to render tabs for languages on top
    change_form_template = "admin/multilingual/change_form.html"
    
    form = MultilingualModelAdminForm
    
    _multilingual_model_admin = True
    
    use_language = None
    
    fill_check_field = None
    
    _use_hacks = ['fieldsets', 'prepopulated_fields', 'readonly_fields']

    class Media:
        css = {
            'all': ('%smultilingual/admin/css/style.css' % settings.MEDIA_URL,)
        }
    
    def __init__(self, model, admin_site):
        for attr in self._use_hacks:
            if hasattr(self, 'use_%s' % attr):
                setattr(self, attr, getattr(self, 'use_%s' % attr))
        super(MultilingualModelAdmin, self).__init__(model, admin_site)
    
    def get_fill_check_field(self):
        if self.fill_check_field is None:
            self.fill_check_field = standard_get_fill_check_field(self.model._meta)
        return self.fill_check_field
    
    def get_form(self, request, obj=None, **kwargs):    
        # assign language to inlines, so they now how to render
        for inline in self.inline_instances:
            if isinstance(inline, MultilingualInlineAdmin):
                inline.use_language = GLL.language_code
        
        Form = super(MultilingualModelAdmin, self).get_form(request, obj, **kwargs)
        
        Form.ml_fields = {}
        for name, field in get_default_translated_fields(self.model):
            if not field.editable:
                continue
            form_field = self.formfield_for_dbfield(field, request=request)
            local_name = "%s_%s" % (name, GLL.language_code)
            Form.ml_fields[name] = form_field
            Form.base_fields[name] = form_field
            Form.use_language = GLL.language_code
        return Form
    
    def placeholder_plugin_filter(self, request, queryset):
        """
        This is only used on models which use placeholders from the django-cms
        """
        if not request:
            return queryset
        if GLL.is_active:
            return queryset.filter(language=GLL.language_code)
        return queryset
            
    @gll
    def change_view(self, *args, **kwargs):
        return super(MultilingualModelAdmin, self).change_view(*args, **kwargs)
    
    @gll
    def add_view(self, *args, **kwargs):
        return super(MultilingualModelAdmin, self).add_view(*args, **kwargs)
    
    @gll
    def delete_view(self, *args, **kwargs):
        return super(MultilingualModelAdmin, self).delete_view(*args, **kwargs)
    
    def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
        # add context variables
        filled_languages = []
        fill_check_field = self.get_fill_check_field()
        if obj and fill_check_field is not None:
            from django.db.models.fields import CharField
            kwargs = {'%s__isnull' % fill_check_field:False}
            if isinstance(self.model._meta.translation_model._meta.get_field_by_name(fill_check_field)[0], CharField):
                kwargs['%s__gt' % fill_check_field] = ''
            filled_languages = [t[0] for t in obj.translations.filter(**kwargs).values_list('language_code')]
        context.update({
            'current_language_index': GLL.language_code,
            'current_language_code': GLL.language_code,
            'filled_languages': filled_languages,
            'old_template': self.get_old_template(),
        })
        return super(MultilingualModelAdmin, self).render_change_form(request, context, add, change, form_url, obj)
    
    
    def get_old_template(self):
        opts = self.model._meta
        app_label = opts.app_label
        search_templates = [
            "admin/%s/%s/change_form.html" % (app_label, opts.object_name.lower()),
            "admin/%s/change_form.html" % app_label,
            "admin/change_form.html"
        ]
        for template in search_templates:
            try:
                find_template(template)
                return template
            except TemplateDoesNotExist:
                pass
                
    def response_change(self, request, obj):
        # because save & continue - so it shows the same language
        if request.POST.has_key("_continue"):
            opts = obj._meta
            msg = _('The %(name)s "%(obj)s" was changed successfully.') % {'name': force_unicode(opts.verbose_name), 'obj': force_unicode(obj)}
            self.message_user(request, msg + ' ' + _("You may edit it again below."))
            lang, path = request.GET.get('language', get_default_language()), request.path
            if lang:
                lang = "language=%s" % lang
            if request.REQUEST.has_key('_popup'):
                path += "?_popup=1" + "&%s" % lang
            else:
                path += "?%s" % lang
            return HttpResponseRedirect(path)
        return super(MultilingualModelAdmin, self).response_change(request, obj)
    

def get_translated_fields(model, language=None):
    meta = model._meta
    if not hasattr(meta, 'translated_fields'):
        if hasattr(meta, 'translation_model'):
            meta = meta.translation_model._meta
        else:
            return
    # returns all the translatable fields, except of the default ones
    if not language:
        for name, (field, non_default) in meta.translated_fields.items():
            if non_default: 
                yield name, field
    else:
        # if language is defined return fields in the same order, like they are defined in the 
        # translation class
        for field in meta.fields:
            if field.primary_key:
                continue
            name = field.name + "_%s" % language
            field = meta.translated_fields.get(name, None)
            if field:
                yield name, field[0]
        

def get_default_translated_fields(model):
    if hasattr(model._meta, 'translation_model'):
        for name, (field, non_default) in model._meta.translation_model._meta.translated_fields.items():
            if not non_default:
                yield name, field

########NEW FILE########
__FILENAME__ = compiler
"""
Django-multilingual: a QuerySet subclass for models with translatable
fields.

This file contains the implementation for QSRF Django.

Huge thanks to hubscher.remy for writing this!
"""
from django.db.models.sql.compiler import SQLCompiler

from multilingual.languages import (
    get_translation_table_alias,
    get_language_code_list,
    get_default_language,
    get_translated_field_alias)

__ALL__ = ['MultilingualSQLCompiler']

class MultilingualSQLCompiler(SQLCompiler):

    def pre_sql_setup(self):
        """
        Adds the JOINS and SELECTS for fetching multilingual data.
        """
        super(MultilingualSQLCompiler, self).pre_sql_setup()

        if not self.query.include_translation_data:
            return

        opts = self.query.model._meta
        qn = self.quote_name_unless_alias
        qn2 = self.connection.ops.quote_name

        if hasattr(opts, 'translation_model'):
            master_table_name = self.query.join((None, opts.db_table, None, None))
            translation_opts = opts.translation_model._meta
            trans_table_name = translation_opts.db_table
            for language_code in get_language_code_list():
                table_alias = get_translation_table_alias(trans_table_name,
                                                          language_code)
                trans_join = ("LEFT JOIN %s AS %s ON ((%s.master_id = %s.%s) AND (%s.language_code = '%s'))"
                           % (qn2(translation_opts.db_table),
                           qn2(table_alias),
                           qn2(table_alias),
                           qn(master_table_name),
                           qn2(opts.pk.column),
                           qn2(table_alias),
                           language_code))
                self.query.extra_join[table_alias] = trans_join

    
    def get_from_clause(self):
        """
        Add the JOINS for related multilingual fields filtering.
        """
        result = super(MultilingualSQLCompiler, self).get_from_clause()

        if not self.query.include_translation_data:
            return result

        from_ = result[0]
        for join in self.query.extra_join.values():
            from_.append(join)
        return (from_, result[1])

########NEW FILE########
__FILENAME__ = context_processors
from multilingual.languages import get_language_code_list, get_default_language_code
from multilingual.settings import LANG_DICT
from django.conf import settings


def multilingual(request):
    """
    Returns context variables containing information about available languages.
    """
    codes = sorted(get_language_code_list())
    return {'LANGUAGE_CODES': codes,
            'LANGUAGE_CODES_AND_NAMES': [(c, LANG_DICT.get(c, c)) for c in codes], 
            'DEFAULT_LANGUAGE_CODE': get_default_language_code(),
            'ADMIN_MEDIA_URL': settings.ADMIN_MEDIA_PREFIX}

########NEW FILE########
__FILENAME__ = exceptions
class TranslationDoesNotExist(Exception):
    """
    The requested translation does not exist
    """
    pass

class LanguageDoesNotExist(Exception):
    """
    The requested language does not exist
    """
    pass

########NEW FILE########
__FILENAME__ = fields
from django.db import models


class TranslationForeignKey(models.ForeignKey):
    """
    """
    def south_field_triple(self):
        from south.modelsinspector import introspector
        field_class = "django.db.models.fields.related.ForeignKey"
        args, kwargs = introspector(self)
        return (field_class, args, kwargs)
########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from multilingual.flatpages.models import MultilingualFlatPage
from django.utils.translation import ugettext_lazy as _
from multilingual.admin import MultilingualModelAdmin, MultilingualModelAdminForm


class MultilingualFlatpageForm(MultilingualModelAdminForm):
    url = forms.RegexField(label=_("URL"), max_length=100, regex=r'^[-\w/]+$',
        help_text = _("Example: '/about/contact/'. Make sure to have leading"
                      " and trailing slashes."),
        error_message = _("This value must contain only letters, numbers,"
                          " underscores, dashes or slashes."))

    class Meta:
        model = MultilingualFlatPage


class MultilingualFlatPageAdmin(MultilingualModelAdmin):
    form = MultilingualFlatpageForm
    use_fieldsets = (
        (None, {'fields': ('title', 'url', 'sites', 'content')}),
        (_('Advanced options'), {'classes': ('collapse',), 'fields': ('enable_comments', 'registration_required', 'template_name')}),
    )
    list_display = ('url', 'title')
    list_filter = ('sites', 'enable_comments', 'registration_required')
    search_fields = ('url', 'title')

admin.site.register(MultilingualFlatPage, MultilingualFlatPageAdmin)

########NEW FILE########
__FILENAME__ = middleware
from multilingual.flatpages.views import multilingual_flatpage
from django.http import Http404
from django.conf import settings

class FlatpageFallbackMiddleware(object):
    def process_response(self, request, response):
        if response.status_code != 404:
            return response # No need to check for a flatpage for non-404 responses.
        try:
            return multilingual_flatpage(request, request.path_info)
        # Return the original response if any errors happened. Because this
        # is a middleware, we can't assume the errors will be caught elsewhere.
        except Http404:
            return response
        except:
            if settings.DEBUG:
                raise
            return response

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.sites.models import Site
from django.utils.translation import ugettext_lazy as _
from multilingual.translation import Translation as TranslationBase
from multilingual.exceptions import TranslationDoesNotExist
from multilingual.manager import MultilingualManager


class MultilingualFlatPage(models.Model):
    # non-translatable fields first
    url = models.CharField(_('URL'), max_length=100, db_index=True)
    enable_comments = models.BooleanField(_('enable comments'))
    template_name = models.CharField(_('template name'), max_length=70, blank=True,
        help_text=_("Example: 'flatpages/contact_page.html'. If this isn't provided, the system will use 'flatpages/default.html'."))
    registration_required = models.BooleanField(_('registration required'), help_text=_("If this is checked, only logged-in users will be able to view the page."))
    sites = models.ManyToManyField(Site)
    
    objects = MultilingualManager()

    # And now the translatable fields
    class Translation(TranslationBase):
        """
        The definition of translation model.

        The multilingual machinery will automatically add these to the
        Category class:

         * get_title(language_id=None)
         * set_title(value, language_id=None)
         * get_content(language_id=None)
         * set_content(value, language_id=None)
         * title and content properties using the methods above
        """
        title = models.CharField(_('title'), max_length=200)
        content = models.TextField(_('content'), blank=True)

    class Meta:
        db_table = 'multilingual_flatpage'
        verbose_name = _('multilingual flat page')
        verbose_name_plural = _('multilingual flat pages')
        ordering = ('url',)

    def __unicode__(self):
        # note that you can use name and description fields as usual
        try:
            return u"%s -- %s" % (self.url, self.title)
        except TranslationDoesNotExist:
            return u"-not-available-"

    def get_absolute_url(self):
        return self.url

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

urlpatterns = patterns('multilingual.flatpages.views',
    (r'^(?P<url>.*)$', 'multilingual_flatpage'),
)

########NEW FILE########
__FILENAME__ = views
from multilingual.flatpages.models import MultilingualFlatPage
from django.template import loader, RequestContext
from django.shortcuts import get_object_or_404
from django.http import HttpResponse, HttpResponseRedirect
from django.conf import settings
from django.core.xheaders import populate_xheaders
from django.utils.safestring import mark_safe
from django.utils.translation import get_language
import multilingual

DEFAULT_TEMPLATE = 'flatpages/default.html'

def multilingual_flatpage(request, url):
    """
    Multilingual flat page view.

    Models: `multilingual.flatpages.models`
    Templates: Uses the template defined by the ``template_name`` field,
        or `flatpages/default.html` if template_name is not defined.
    Context:
        flatpage
            `flatpages.flatpages` object
    """
    if not url.endswith('/') and settings.APPEND_SLASH:
        return HttpResponseRedirect("%s/" % request.path)
    if not url.startswith('/'):
        url = "/" + url
    f = get_object_or_404(MultilingualFlatPage, url__exact=url, sites__id__exact=settings.SITE_ID)
    # If registration is required for accessing this page, and the user isn't
    # logged in, redirect to the login page.
    if f.registration_required and not request.user.is_authenticated():
        from django.contrib.auth.views import redirect_to_login
        return redirect_to_login(request.path)
    # Serve the content in the language defined by the Django translation module
    # if possible else serve the default language.
    f._default_language = get_language()
    if f.template_name:
        t = loader.select_template((f.template_name, DEFAULT_TEMPLATE))
    else:
        t = loader.get_template(DEFAULT_TEMPLATE)

    # To avoid having to always use the "|safe" filter in flatpage templates,
    # mark the title and content as already safe (since they are raw HTML
    # content in the first place).
    f.title = mark_safe(f.title)
    f.content = mark_safe(f.content)

    c = RequestContext(request, {
        'flatpage': f,
    })
    response = HttpResponse(t.render(c))
    populate_xheaders(request, response, MultilingualFlatPage, f.id)
    return response

########NEW FILE########
__FILENAME__ = languages
"""
Django-multilingual: language-related settings and functions.
"""

# Note: this file did become a mess and will have to be refactored
# after the configuration changes get in place.

#retrieve language settings from settings.py
from multilingual import settings

from django.utils.translation import ugettext_lazy as _
from multilingual.exceptions import LanguageDoesNotExist

try:
    from threading import local
except ImportError:
    from django.utils._threading_local import local

thread_locals = local()

def get_language_count():
    return len(settings.LANGUAGES)

def get_language_name(language_code):
    return settings.LANG_DICT[language_code]

def get_language_bidi(language_code):
    return language_code in settings.LANGUAGES_BIDI

def get_language_code_list():
    return settings.LANG_DICT.keys()

def get_language_choices():
    return settings.LANGUAGES

def set_default_language(language_code):
    """
    Set the default language for the whole translation mechanism.
    """
    thread_locals.DEFAULT_LANGUAGE = language_code

def get_default_language():
    """
    Return the language code set by set_default_language.
    """
    return getattr(thread_locals, 'DEFAULT_LANGUAGE',
                   settings.DEFAULT_LANGUAGE)
get_default_language_code = get_default_language

def _to_db_identifier(name):
    """
    Convert name to something that is usable as a field name or table
    alias in SQL.

    For the time being assume that the only possible problem with name
    is the presence of dashes.
    """
    return name.replace('-', '_')

def get_translation_table_alias(translation_table_name, language_code):
    """
    Return an alias for the translation table for a given language_code.
    Used in SQL queries.
    """
    return (translation_table_name
            + '_'
            + _to_db_identifier(language_code))

def get_language_idx(language_code):
    return get_language_code_list().index(language_code)

def get_translated_field_alias(field_name, language_code):
    """
    Return an alias for field_name field for a given language_code.
    Used in SQL queries.
    """
    return ('_trans_'
            + field_name
            + '_' + _to_db_identifier(language_code))
    
def get_fallbacks(language_code):
    fallbacks = settings.FALLBACK_LANGUAGES.get(language_code, [])
    if len(language_code) != 2 and settings.IMPLICIT_FALLBACK:
        if not language_code[:2] in fallbacks:
            fallbacks.insert(0, language_code[:2])
    if language_code is not None and language_code not in fallbacks:
        fallbacks.insert(0, language_code)
    return fallbacks

FALLBACK_FIELD_SUFFIX = '_any'
########NEW FILE########
__FILENAME__ = mlng_convert
from django.core.management.base import AppCommand
from django.db import models
from django.utils.importlib import import_module
from django.conf import settings
from django.db import connection
from django.core.management import call_command
from multilingual.utils import is_multilingual_model
from multilingual.languages import get_language_choices
from inspect import isclass
from south.db import db


def get_code_by_id(lid):
    return settings.LANGUAGES[lid-1][0]

class Command(AppCommand):
    """
    Migrate the data from an id base translation table to a code based table.
    """    
    def handle(self, *args, **kwargs):
        if self.are_you_sure():
            super(Command, self).handle(*args, **kwargs)
            print self.style.HTTP_SUCCESS('Done.')
        else:
            print self.style.NOTICE('Aborted.')
        
    def are_you_sure(self):
        n = self.style.NOTICE
        e = self.style.ERROR
        print e("WARNING!") + n(" This command will ") + e("delete") + n(""" data from your database! All language_id  
columns in all multilingual tables of the apps you specified will be deleted.
Their values will be converted to the new language_code format. Please make a
backup of your database before running this command.""")
        answer = raw_input("Are you sure you want to continue? [yes/no]\n")
        if answer.lower() == 'yes':
            return True
        elif answer.lower() == 'no':
            return False
        while True:
            answer = raw_input("Please answer with either 'yes' or 'no'\n")
            if answer.lower() == 'yes':
                return True
            elif answer.lower() == 'no':
                return False
        
    def handle_app(self, app, **options):
        appname = app.__name__
        print 'handling app %s' % appname
        for obj in [getattr(app, name) for name in dir(app)]:
            if not isclass(obj):
                continue
            if not issubclass(obj, models.Model):
                continue
            if not is_multilingual_model(obj):
                continue
            print 'altering model %s' % obj
            table = obj._meta.translation_model._meta.db_table
            db.debug = True
            # do this in a transaction
            db.start_transaction()
            # first add the column with nullable values, and no index
            lc_field = models.CharField(max_length=15, blank=True, null=True)
            db.add_column(table, 'language_code', lc_field)
            # migrate the model
            print 'migrating data'
            # do the conversion server-side
            # all modern RDBMSs support the case statement
            update_sql = "UPDATE %s SET language_code = (CASE language_id %s END)" % (table, 
                ' '.join(
                    "WHEN %d THEN '%s'" % (lid, get_code_by_id(lid))
                    for lid in range(1, len(settings.LANGUAGES) + 1)
                    )
                )
            db.execute(update_sql)
            print 'deleting language_id column'
            db.delete_unique(table, ['language_id', 'master_id'])
            db.delete_column(table, 'language_id')
            print 'setting up constraints and indices'
            # alter the column to set not null
            lc_field.null = False
            db.alter_column(table, 'language_code', lc_field)
            ## we don't really need this indexed. all queries should hit the unique index
            #db.create_index(table, ['language_code'])
            # and create a unique index for master & language
            db.create_unique(table, ['language_code', 'master_id'])
            # south might fail to commit if we don't do it explicitly
            db.commit_transaction()


########NEW FILE########
__FILENAME__ = manager
from django.db import models

from multilingual.query import MultilingualModelQuerySet
from multilingual.languages import *


class MultilingualManager(models.Manager):
    """
    A manager for multilingual models.

    TO DO: turn this into a proxy manager that would allow developers
    to use any manager they need.  It should be sufficient to extend
    and additionaly filter or order querysets returned by that manager.
    """

    def get_query_set(self):
        return MultilingualModelQuerySet(self.model)
Manager = MultilingualManager # backwards compat, will be depricated
########NEW FILE########
__FILENAME__ = middleware
from django.utils.translation import get_language

from multilingual.exceptions import LanguageDoesNotExist
from multilingual.languages import set_default_language


class DefaultLanguageMiddleware(object):
    """
    Binds DEFAULT_LANGUAGE_CODE to django's currently selected language.

    The effect of enabling this middleware is that translated fields can be
    accessed by their name; i.e. model.field instead of model.field_en.
    """

    def process_request(self, request):
        assert hasattr(request, 'session'), "The DefaultLanguageMiddleware \
            middleware requires session middleware to be installed. Edit your \
            MIDDLEWARE_CLASSES setting to insert \
            'django.contrib.sessions.middleware.SessionMiddleware'."
        try:
            set_default_language(get_language())
        except LanguageDoesNotExist:
            # Try without the territory suffix
            set_default_language(get_language()[:2])

########NEW FILE########
__FILENAME__ = models
"""
Multilingual model support.

This code is put in multilingual.models to make Django execute it
during application initialization.

TO DO: remove it.  Right now multilingual must be imported directly
into any file that defines translatable models, so it will be
installed anyway.

This module is here only to make it easier to upgrade from versions
that did not require TranslatableModel.Translation classes to subclass
multilingual.Translation to versions that do.
"""

from translation import install_translation_library
install_translation_library()
########NEW FILE########
__FILENAME__ = query
"""
Django-multilingual: a QuerySet subclass for models with translatable
fields.

This file contains the implementation for QSRF Django.
"""

import datetime
from copy import deepcopy

from django.core.exceptions import FieldError
from django.db import connection
from django.db.models.fields import FieldDoesNotExist
from django.db.models.query import QuerySet, Q
from django.db.models.sql.query import Query
from django.db import connections, DEFAULT_DB_ALIAS
from django.db.models.sql.datastructures import (
    EmptyResultSet,
    Empty,
    MultiJoin)
from django.db.models.sql.constants import *
from django.db.models.sql.where import WhereNode, EverythingNode, AND, OR

try:
    # handle internal API changes in Django rev. 9700
    from django.db.models.sql.where import Constraint

    def constraint_tuple(alias, col, field, lookup_type, value):
        return (Constraint(alias, col, field), lookup_type, value)
except ImportError:
    # backwards compatibility, for Django versions 1.0 to rev. 9699
    def constraint_tuple(alias, col, field, lookup_type, value):
        return (alias, col, field, lookup_type, value)

from multilingual.languages import (
    get_translation_table_alias,
    get_language_code_list,
    get_default_language,
    get_translated_field_alias)

from compiler import MultilingualSQLCompiler

__ALL__ = ['MultilingualModelQuerySet']


class MultilingualQuery(Query):

    def __init__(self, model, where=WhereNode):
        self.extra_join = {}
        self.include_translation_data = True
        extra_select = {}
        super(MultilingualQuery, self).__init__(model, where=where)
        opts = self.model._meta
        qn = self.get_compiler(DEFAULT_DB_ALIAS).quote_name_unless_alias
        qn2 = self.get_compiler(DEFAULT_DB_ALIAS).connection.ops.quote_name
        master_table_name = opts.db_table
        translation_opts = opts.translation_model._meta
        trans_table_name = translation_opts.db_table
        if hasattr(opts, 'translation_model'):
            master_table_name = opts.db_table
            for language_code in get_language_code_list():
                for fname in [f.attname for f in translation_opts.fields]:
                    table_alias = get_translation_table_alias(trans_table_name,
                        language_code)
                    field_alias = get_translated_field_alias(fname,
                        language_code)
                    extra_select[field_alias] = qn2(table_alias) + '.' + qn2(fname)
            self.add_extra(extra_select, None, None, None, None, None)
            self._trans_extra_select_count = len(self.extra_select)

    def clone(self, klass=None, **kwargs):
        defaults = {
            'extra_join': self.extra_join,
            'include_translation_data': self.include_translation_data,
            }
        defaults.update(kwargs)
        return super(MultilingualQuery, self).clone(klass=klass, **defaults)

    def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,
            can_reuse=None, process_extras=True, force_having=False):
        """
        Copied from add_filter to generate WHERES for translation fields.
        """
        if force_having:
            import warnings
            warnings.warn("multilingual-ng doesn't support force_having (see Django ticket #11293)")
        arg, value = filter_expr
        parts = arg.split(LOOKUP_SEP)
        if not parts:
            raise FieldError("Cannot parse keyword query %r" % arg)

        # Work out the lookup type and remove it from 'parts', if necessary.
        if len(parts) == 1 or parts[-1] not in self.query_terms:
            lookup_type = 'exact'
        else:
            lookup_type = parts.pop()

        # Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all
        # uses of None as a query value.
        if value is None:
            if lookup_type != 'exact':
                raise ValueError("Cannot use None as a query value")
            lookup_type = 'isnull'
            value = True
        elif (value == '' and lookup_type == 'exact' and
              self.get_compiler(DEFAULT_DB_ALIAS).connection.features.interprets_empty_strings_as_nulls):
            lookup_type = 'isnull'
            value = True
        elif callable(value):
            value = value()

        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = trim or not negate

        try:
            field, target, opts, join_list, last, extra_filters = self.setup_joins(
                    parts, opts, alias, True, allow_many, can_reuse=can_reuse,
                    negate=negate, process_extras=process_extras)
        except MultiJoin, e:
            self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),
                    can_reuse)
            return

        #=======================================================================
        # Django Mulitlingual NG Specific Code START
        #=======================================================================
        if hasattr(opts, 'translation_model'):
            field_name = parts[-1]
            if field_name == 'pk':
                field_name = opts.pk.name
            translation_opts = opts.translation_model._meta
            if field_name in translation_opts.translated_fields.keys():
                field, model, direct, m2m = opts.get_field_by_name(field_name)
                if model == opts.translation_model:
                    language_code = translation_opts.translated_fields[field_name][1]
                    if language_code is None:
                        language_code = get_default_language()
                    master_table_name = opts.db_table
                    trans_table_alias = get_translation_table_alias(
                        model._meta.db_table, language_code)
                    new_table = (master_table_name + "__" + trans_table_alias)
                    self.where.add(constraint_tuple(new_table, field.column, field, lookup_type, value), connector)
                    return
        #=======================================================================
        # Django Mulitlingual NG Specific Code END
        #=======================================================================
        final = len(join_list)
        penultimate = last.pop()
        if penultimate == final:
            penultimate = last.pop()
        if trim and len(join_list) > 1:
            extra = join_list[penultimate:]
            join_list = join_list[:penultimate]
            final = penultimate
            penultimate = last.pop()
            col = self.alias_map[extra[0]][LHS_JOIN_COL]
            for alias in extra:
                self.unref_alias(alias)
        else:
            col = target.column
        alias = join_list[-1]

        while final > 1:
            # An optimization: if the final join is against the same column as
            # we are comparing against, we can go back one step in the join
            # chain and compare against the lhs of the join instead (and then
            # repeat the optimization). The result, potentially, involves less
            # table joins.
            join = self.alias_map[alias]
            if col != join[RHS_JOIN_COL]:
                break
            self.unref_alias(alias)
            alias = join[LHS_ALIAS]
            col = join[LHS_JOIN_COL]
            join_list = join_list[:-1]
            final -= 1
            if final == penultimate:
                penultimate = last.pop()

        if (lookup_type == 'isnull' and value is True and not negate and
                final > 1):
            # If the comparison is against NULL, we need to use a left outer
            # join when connecting to the previous model. We make that
            # adjustment here. We don't do this unless needed as it's less
            # efficient at the database level.
            self.promote_alias(join_list[penultimate])

        if connector == OR:
            # Some joins may need to be promoted when adding a new filter to a
            # disjunction. We walk the list of new joins and where it diverges
            # from any previous joins (ref count is 1 in the table list), we
            # make the new additions (and any existing ones not used in the new
            # join list) an outer join.
            join_it = iter(join_list)
            table_it = iter(self.tables)
            join_it.next(), table_it.next()
            table_promote = False
            join_promote = False
            for join in join_it:
                table = table_it.next()
                if join == table and self.alias_refcount[join] > 1:
                    continue
                join_promote = self.promote_alias(join)
                if table != join:
                    table_promote = self.promote_alias(table)
                break
            self.promote_alias_chain(join_it, join_promote)
            self.promote_alias_chain(table_it, table_promote)

        self.where.add(constraint_tuple(alias, col, field, lookup_type, value), connector)

        if negate:
            self.promote_alias_chain(join_list)
            if lookup_type != 'isnull':
                if final > 1:
                    for alias in join_list:
                        if self.alias_map[alias][JOIN_TYPE] == self.LOUTER:
                            j_col = self.alias_map[alias][RHS_JOIN_COL]
                            entry = self.where_class()
                            entry.add(constraint_tuple(alias, j_col, None, 'isnull', True), AND)
                            entry.negate()
                            self.where.add(entry, AND)
                            break
                elif not (lookup_type == 'in' and not value) and field.null:
                    # Leaky abstraction artifact: We have to specifically
                    # exclude the "foo__in=[]" case from this handling, because
                    # it's short-circuited in the Where class.
                    entry = self.where_class()
                    entry.add(constraint_tuple(alias, col, None, 'isnull', True), AND)
                    entry.negate()
                    self.where.add(entry, AND)

        if can_reuse is not None:
            can_reuse.update(join_list)
        if process_extras:
            for filter in extra_filters:
                self.add_filter(filter, negate=negate, can_reuse=can_reuse,
                        process_extras=False)

    def _setup_joins_with_translation(self, names, opts, alias,
                                      dupe_multis, allow_many=True,
                                      allow_explicit_fk=False, can_reuse=None,
                                      negate=False, process_extras=True):
        """
        This is based on a full copy of Query.setup_joins because
        currently I see no way to handle it differently.

        TO DO: there might actually be a way, by splitting a single
        multi-name setup_joins call into separate calls.  Check it.

        -- marcin@elksoft.pl

        Compute the necessary table joins for the passage through the fields
        given in 'names'. 'opts' is the Options class for the current model
        (which gives the table we are joining to), 'alias' is the alias for the
        table we are joining to. If dupe_multis is True, any many-to-many or
        many-to-one joins will always create a new alias (necessary for
        disjunctive filters).

        Returns the final field involved in the join, the target database
        column (used for any 'where' constraint), the final 'opts' value and the
        list of tables joined.
        """
        joins = [alias]
        last = [0]
        dupe_set = set()
        exclusions = set()
        extra_filters = []
        for pos, name in enumerate(names):
            try:
                exclusions.add(int_alias)
            except NameError:
                pass
            exclusions.add(alias)
            last.append(len(joins))
            if name == 'pk':
                name = opts.pk.name
            try:
                field, model, direct, m2m = opts.get_field_by_name(name)
            except FieldDoesNotExist:
                for f in opts.fields:
                    if allow_explicit_fk and name == f.attname:
                        # XXX: A hack to allow foo_id to work in values() for
                        # backwards compatibility purposes. If we dropped that
                        # feature, this could be removed.
                        field, model, direct, m2m = opts.get_field_by_name(f.name)
                        break
                else:
                    names = opts.get_all_field_names() + self.aggregate_select.keys()
                    raise FieldError("Cannot resolve keyword %r into field. "
                            "Choices are: %s" % (name, ", ".join(names)))

            if not allow_many and (m2m or not direct):
                for alias in joins:
                    self.unref_alias(alias)
                raise MultiJoin(pos + 1)
            #===================================================================
            # Django Multilingual NG Specific Code START
            #===================================================================
            if hasattr(opts, 'translation_model'):
                translation_opts = opts.translation_model._meta
                if model == opts.translation_model:
                    language_code = translation_opts.translated_fields[name][1]
                    if language_code is None:
                        language_code = get_default_language()
                    #TODO: check alias
                    master_table_name = opts.db_table
                    trans_table_alias = get_translation_table_alias(
                        model._meta.db_table, language_code)
                    new_table = (master_table_name + "__" + trans_table_alias)
                    qn = self.get_compiler(DEFAULT_DB_ALIAS).quote_name_unless_alias
                    qn2 = self.get_compiler(DEFAULT_DB_ALIAS).connection.ops.quote_name
                    trans_join = ("JOIN %s AS %s ON ((%s.master_id = %s.%s) AND (%s.language_code = '%s'))"
                                 % (qn2(model._meta.db_table),
                                 qn2(new_table),
                                 qn2(new_table),
                                 qn(master_table_name),
                                 qn2(model._meta.pk.column),
                                 qn2(new_table),
                                 language_code))
                    self.extra_join[new_table] = trans_join
                    target = field
                    continue
            #===================================================================
            # Django Multilingual NG Specific Code END
            #===================================================================
            elif model:
                # The field lives on a base class of the current model.
                # Skip the chain of proxy to the concrete proxied model
                proxied_model = get_proxied_model(opts)

                for int_model in opts.get_base_chain(model):
                    if int_model is proxied_model:
                        opts = int_model._meta
                    else:
                        lhs_col = opts.parents[int_model].column
                        dedupe = lhs_col in opts.duplicate_targets
                        if dedupe:
                            exclusions.update(self.dupe_avoidance.get(
                                    (id(opts), lhs_col), ()))
                            dupe_set.add((opts, lhs_col))
                        opts = int_model._meta
                        alias = self.join((alias, opts.db_table, lhs_col,
                                opts.pk.column), exclusions=exclusions)
                        joins.append(alias)
                        exclusions.add(alias)
                        for (dupe_opts, dupe_col) in dupe_set:
                            self.update_dupe_avoidance(dupe_opts, dupe_col,
                                    alias)
            cached_data = opts._join_cache.get(name)
            orig_opts = opts
            dupe_col = direct and field.column or field.field.column
            dedupe = dupe_col in opts.duplicate_targets
            if dupe_set or dedupe:
                if dedupe:
                    dupe_set.add((opts, dupe_col))
                exclusions.update(self.dupe_avoidance.get((id(opts), dupe_col),
                        ()))

            if process_extras and hasattr(field, 'extra_filters'):
                extra_filters.extend(field.extra_filters(names, pos, negate))
            if direct:
                if m2m:
                    # Many-to-many field defined on the current model.
                    if cached_data:
                        (table1, from_col1, to_col1, table2, from_col2,
                                to_col2, opts, target) = cached_data
                    else:
                        table1 = field.m2m_db_table()
                        from_col1 = opts.pk.column
                        to_col1 = field.m2m_column_name()
                        opts = field.rel.to._meta
                        table2 = opts.db_table
                        from_col2 = field.m2m_reverse_name()
                        to_col2 = opts.pk.column
                        target = opts.pk
                        orig_opts._join_cache[name] = (table1, from_col1,
                                to_col1, table2, from_col2, to_col2, opts,
                                target)

                    int_alias = self.join((alias, table1, from_col1, to_col1),
                            dupe_multis, exclusions, nullable=True,
                            reuse=can_reuse)
                    if int_alias == table2 and from_col2 == to_col2:
                        joins.append(int_alias)
                        alias = int_alias
                    else:
                        alias = self.join(
                                (int_alias, table2, from_col2, to_col2),
                                dupe_multis, exclusions, nullable=True,
                                reuse=can_reuse)
                        joins.extend([int_alias, alias])
                elif field.rel:
                    # One-to-one or many-to-one field
                    if cached_data:
                        (table, from_col, to_col, opts, target) = cached_data
                    else:
                        opts = field.rel.to._meta
                        target = field.rel.get_related_field()
                        table = opts.db_table
                        from_col = field.column
                        to_col = target.column
                        orig_opts._join_cache[name] = (table, from_col, to_col,
                                opts, target)

                    alias = self.join((alias, table, from_col, to_col),
                            exclusions=exclusions, nullable=field.null)
                    joins.append(alias)
                else:
                    # Non-relation fields.
                    target = field
                    break
            else:
                orig_field = field
                field = field.field
                if m2m:
                    # Many-to-many field defined on the target model.
                    if cached_data:
                        (table1, from_col1, to_col1, table2, from_col2,
                                to_col2, opts, target) = cached_data
                    else:
                        table1 = field.m2m_db_table()
                        from_col1 = opts.pk.column
                        to_col1 = field.m2m_reverse_name()
                        opts = orig_field.opts
                        table2 = opts.db_table
                        from_col2 = field.m2m_column_name()
                        to_col2 = opts.pk.column
                        target = opts.pk
                        orig_opts._join_cache[name] = (table1, from_col1,
                                to_col1, table2, from_col2, to_col2, opts,
                                target)

                    int_alias = self.join((alias, table1, from_col1, to_col1),
                            dupe_multis, exclusions, nullable=True,
                            reuse=can_reuse)
                    alias = self.join((int_alias, table2, from_col2, to_col2),
                            dupe_multis, exclusions, nullable=True,
                            reuse=can_reuse)
                    joins.extend([int_alias, alias])
                else:
                    # One-to-many field (ForeignKey defined on the target model)
                    if cached_data:
                        (table, from_col, to_col, opts, target) = cached_data
                    else:
                        local_field = opts.get_field_by_name(
                                field.rel.field_name)[0]
                        opts = orig_field.opts
                        table = opts.db_table
                        from_col = local_field.column
                        to_col = field.column
                        target = opts.pk
                        orig_opts._join_cache[name] = (table, from_col, to_col,
                                opts, target)

                    alias = self.join((alias, table, from_col, to_col),
                            dupe_multis, exclusions, nullable=True,
                            reuse=can_reuse)
                    joins.append(alias)

            for (dupe_opts, dupe_col) in dupe_set:
                try:
                    self.update_dupe_avoidance(dupe_opts, dupe_col, int_alias)
                except NameError:
                    self.update_dupe_avoidance(dupe_opts, dupe_col, alias)

        if pos != len(names) - 1:
            if pos == len(names) - 2:
                raise FieldError("Join on field %r not permitted. Did you misspell %r for the lookup type?" % (name, names[pos + 1]))
            else:
                raise FieldError("Join on field %r not permitted." % name)

        return field, target, opts, joins, last, extra_filters

    def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,
            allow_explicit_fk=False, can_reuse=None, negate=False,
            process_extras=True):
        if not self.include_translation_data:
            return super(MultilingualQuery, self).setup_joins(names, opts, alias,
                                                              dupe_multis, allow_many,
                                                              allow_explicit_fk,
                                                              can_reuse, negate,
                                                              process_extras)
        else:
            return self._setup_joins_with_translation(names, opts, alias, dupe_multis,
                                                      allow_many, allow_explicit_fk,
                                                      can_reuse, negate, process_extras)

    def get_count(self, using=None):
        # optimize for the common special case: count without any
        # filters
        if ((not (self.select or self.where ))#or self.extra_where))
            and self.include_translation_data):
            obj = self.clone(extra_select = {},
                             extra_join = {},
                             include_translation_data = False)
            return obj.get_count(using)
        else:
            return super(MultilingualQuery, self).get_count(using)

    def get_compiler(self, using=None, connection=None):
        if using is None and connection is None:
            raise ValueError("Need either using or connection")
        if using:
            connection = connections[using]
        return MultilingualSQLCompiler(self, connection, using)


class MultilingualModelQuerySet(QuerySet):
    """
    A specialized QuerySet that knows how to handle translatable
    fields in ordering and filtering methods.
    """

    def __init__(self, model=None, query=None, using=None):
        query = query or MultilingualQuery(model)
        super(MultilingualModelQuerySet, self).__init__(model, query, using)
        self._field_name_cache = None
        
    def __deepcopy__(self, memo):
        """
        Deep copy of a QuerySet doesn't populate the cache
        """
        obj_dict = deepcopy(self.__dict__, memo)
        obj_dict['_iter'] = None
        #=======================================================================
        # Django Multilingual NG Specific Code START
        #=======================================================================
        obj = self.__class__(self.model) # add self.model as first argument
        #=======================================================================
        # Django Multilingual NG Specific Code END
        #=======================================================================
        obj.__dict__.update(obj_dict)
        return obj

    def for_language(self, language_code):
        """
        Set the default language for all objects returned with this
        query.
        """
        clone = self._clone()
        clone._default_language = language_code
        return clone

    def iterator(self):
        """
        Add the default language information to all returned objects.
        """
        default_language = getattr(self, '_default_language', None)
        for obj in super(MultilingualModelQuerySet, self).iterator():
            obj._default_language = default_language
            yield obj

    def _clone(self, klass=None, **kwargs):
        """
        Override _clone to preserve additional information needed by
        MultilingualModelQuerySet.
        """
        clone = super(MultilingualModelQuerySet, self)._clone(klass, **kwargs)
        clone._default_language = getattr(self, '_default_language', None)
        return clone

    def order_by(self, *field_names):
        if hasattr(self.model._meta, 'translation_model'):
            trans_opts = self.model._meta.translation_model._meta
            new_field_names = []
            for field_name in field_names:
                prefix = ''
                if field_name[0] == '-':
                    prefix = '-'
                    field_name = field_name[1:]
                field_and_lang = trans_opts.translated_fields.get(field_name)
                if field_and_lang:
                    field, language_code = field_and_lang
                    if language_code is None:
                        language_code = getattr(self, '_default_language', None)
                    real_name = get_translated_field_alias(field.attname,
                                                           language_code)
                    new_field_names.append(prefix + real_name)
                else:
                    new_field_names.append(prefix + field_name)
            return super(MultilingualModelQuerySet, self).extra(order_by=new_field_names)
        else:
            return super(MultilingualModelQuerySet, self).order_by(*field_names)
        
    def _get_all_field_names(self):
        if self._field_name_cache is None:
            self._field_name_cache = self.model._meta.get_all_field_names() + ['pk']
        return self._field_name_cache

    def values(self, *fields):
        for field in fields:
            if field not in self._get_all_field_names():
                raise NotImplementedError("Multilingual fields cannot be queried using queryset.values(...)")
        return super(MultilingualModelQuerySet, self).values(*fields)

    def values_list(self, *fields, **kwargs):
        for field in fields:
            if field not in self._get_all_field_names():
                raise NotImplementedError("Multilingual fields cannot be queried using queryset.values(...)")
        return super(MultilingualModelQuerySet, self).values_list(*fields, **kwargs)

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

LANGUAGES = settings.LANGUAGES

LANG_DICT = dict(LANGUAGES)

def get_fallback_languages():
    fallbacks = {}
    for lang in LANG_DICT:
        fallbacks[lang] = [lang]
        for other in LANG_DICT:
            if other != lang:
                fallbacks[lang].append(other)
    return fallbacks

FALLBACK_LANGUAGES = getattr(settings, 'MULTILINGUAL_FALLBACK_LANGUAGES',
                             get_fallback_languages())
    
IMPLICIT_FALLBACK = getattr(settings, 'MULTILINGUAL_IMPLICIT_FALLBACK', True)

DEFAULT_LANGUAGE = getattr(settings, 'MULTILINGUAL_DEFAULT_LANGUAGE', LANGUAGES[0][0])

mcp = "multilingual.context_processors.multilingual"
if mcp not in settings.TEMPLATE_CONTEXT_PROCESSORS:
    found = ','.join(settings.TEMPLATE_CONTEXT_PROCESSORS)
    raise ImproperlyConfigured(
        "django-multilingual-ng requires the '%s' context processor. "
        "Only found: %s" % (mcp, found)
    )
########NEW FILE########
__FILENAME__ = multilingual_tags
import math
import StringIO
import tokenize

from django import template
from django import forms
from django.template import Node, NodeList, Template, Context, resolve_variable
from django.template.loader import get_template, render_to_string
from django.conf import settings
from django.utils.html import escape
from multilingual.languages import (
    get_default_language,
    get_language_code_list,
    get_language_name,
    get_language_bidi,
    get_language_idx
)
from multilingual.utils import GLL

register = template.Library()


def language_name(language_code):
    """
    Return the name of the language with id=language_code
    """
    return get_language_name(language_code)


def language_bidi(language_code):
    """
    Return whether the language with id=language_code is written right-to-left.
    """
    return get_language_bidi(language_code)

def language_for_id(language_id):
    return get_language_idx(language_for_id)


class EditTranslationNode(template.Node):
    def __init__(self, form_name, field_name, language=None):
        self.form_name = form_name
        self.field_name = field_name
        self.language = language

    def render(self, context):
        form = resolve_variable(self.form_name, context)
        model = form._meta.model
        trans_model = model._meta.translation_model
        if self.language:
            language_code = self.language.resolve(context)
        else:
            language_code = get_default_language()
        real_name = "%s.%s.%s.%s" % (self.form_name,
                                     trans_model._meta.object_name.lower(),
                                     get_language_idx(language_code),
                                     self.field_name)
        return str(resolve_variable(real_name, context))


def do_edit_translation(parser, token):
    bits = token.split_contents()
    if len(bits) not in [3, 4]:
        raise template.TemplateSyntaxError, \
              "%r tag requires 3 or 4 arguments" % bits[0]
    if len(bits) == 4:
        language = parser.compile_filter(bits[3])
    else:
        language = None
    return EditTranslationNode(bits[1], bits[2], language)


def reorder_translation_formset_by_language_code(inline_admin_form):
    """
    Shuffle the forms in the formset of multilingual model in the
    order of their language_ids.
    """
    lang_to_form = dict([(form.form.initial['language_id'], form)
                         for form in inline_admin_form])
    return [lang_to_form[language_code] for language_code in
        get_language_code_list()]
    
class GLLNode(template.Node):
    def __init__(self, language_code, nodelist):
        self.language_code = language_code
        self.nodelist = nodelist
    
    def render(self, context):
        if self.language_code[0] == self.language_code[-1] and self.language_code[0] in ('"',"'"):
            language_code = self.language_code[1:-1]
        else:
            language_code = template.Variable(self.language_code).resolve(context) 
        GLL.lock(language_code)
        output = self.nodelist.render(context)
        GLL.release()
        return output
    
def gll(parser, token):
    bits = token.split_contents()
    if len(bits) != 2:
        raise template.TemplateSyntaxError("gll takes exactly one argument")
    language_code = bits[1]
    nodelist = parser.parse(('endgll',))
    parser.delete_first_token()
    return GLLNode(language_code, nodelist)

register.filter(language_for_id)
register.filter(language_name)
register.filter(language_bidi)
register.tag('edit_translation', do_edit_translation)
register.filter(reorder_translation_formset_by_language_code)
register.tag('gll', gll)
########NEW FILE########
__FILENAME__ = translation
"""
Support for models' internal Translation class.
"""

##TODO: this is messy and needs to be cleaned up

from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.db.models import signals
from django.db.models.base import ModelBase
from django.utils.translation import get_language
from multilingual.languages import *
from multilingual.exceptions import TranslationDoesNotExist
from multilingual.fields import TranslationForeignKey
from multilingual import manager
from multilingual.utils import GLL
# To Be Depricated
#from multilingual.utils import install_multilingual_modeladmin_new

from new import instancemethod

def translation_save_translated_fields(instance, **kwargs):
    """
    Save all the translations of instance in post_save signal handler.
    """
    if not hasattr(instance, '_translation_cache'):
        return
    for l_id, translation in instance._translation_cache.iteritems():
        # set the translation ID just in case the translation was
        # created while instance was not stored in the DB yet

        # note: we're using _get_pk_val here even though it is
        # private, since that's the most reliable way to get the value
        # on older Django (pk property did not exist yet)
        translation.master_id = instance._get_pk_val()
        translation.save()

def fill_translation_cache(instance):
    """
    Fill the translation cache using information received in the
    instance objects as extra fields.

    You can not do this in post_init because the extra fields are
    assigned by QuerySet.iterator after model initialization.
    """

    if hasattr(instance, '_translation_cache'):
        # do not refill the cache
        return
    instance._translation_cache = {}

    # unsafed instances cannot have translations
    if not instance.pk:
        return

    for language_code in get_language_code_list():
        # see if translation for language_code was in the query
        field_alias = get_translated_field_alias('code', language_code)
        if getattr(instance, field_alias, None) is not None:
            field_names = [f.attname for f in instance._meta.translation_model._meta.fields]

            # if so, create a translation object and put it in the cache
            field_data = {}
            for fname in field_names:
                field_data[fname] = getattr(instance,
                                            get_translated_field_alias(fname, language_code))

            translation = instance._meta.translation_model(**field_data)
            instance._translation_cache[language_code] = translation

    # In some situations an (existing in the DB) object is loaded
    # without using the normal QuerySet.  In such case fallback to
    # loading the translations using a separate query.

    # Unfortunately, this is indistinguishable from the situation when
    # an object does not have any translations.  Oh well, we'll have
    # to live with this for the time being.
    if len(instance._translation_cache.keys()) == 0:
        for translation in instance.translations.all():
            instance._translation_cache[translation.language_code] = translation

class TranslatedFieldProxy(property):
    """
    This is a proxy field to be set onto the main class to proxy to a translation.
    """
    def __init__(self, field_name, alias, field, language_code=None,
                 fallback=False):
        self.field_name = field_name
        self.field = field
        self.admin_order_field = alias
        self._language_code = language_code
        self.fallback = fallback
        
    @property
    def language_code(self):
        """
        If _language_code is None we are the _current field, so we use the
        currently used language for lookups.
        """
        if self._language_code:
            return self._language_code
        return get_language()

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        return getattr(obj, 'get_' + self.field_name)(self.language_code,
                                                      self.fallback)

    def __set__(self, obj, value):
        language_code = self.language_code

        return getattr(obj, 'set_' + self.field_name)(value, self.language_code)

    short_description = property(lambda self: self.field.short_description)

def getter_generator(field_name, short_description):
    """
    Generate get_'field name' method for field field_name.
    """
    def get_translation_field(cls, language_code=None, fallback=False):
        try:
            return cls.get_translation(language_code,
                                       fallback=fallback,
                                       field=field_name)
        except TranslationDoesNotExist:
            return None
    get_translation_field.short_description = short_description
    return get_translation_field

def setter_generator(field_name):
    """
    Generate set_'field name' method for field field_name.
    """
    def set_translation_field(cls, value, language_code=None):
        setattr(cls.get_translation(language_code, True),
                field_name, value)
    set_translation_field.short_description = "set " + field_name
    return set_translation_field

def get_translation(cls, language_code, create_if_necessary=False,
                    fallback=False, field=None):
    """
    Get a translation instance for the given `language_id_or_code`.

    If the translation does not exist:

    1. if `create_if_necessary` is True, this function will create one
    2. otherwise, if `fallback` is True, this function will search the
       list of languages looking for the first existing translation
    3. if all of the above fails to find a translation, raise the
    TranslationDoesNotExist exception
    """
    # fill the cache if necessary
    cls.fill_translation_cache()

    if language_code is None:
        language_code = getattr(cls, '_default_language', None)
    if language_code is None:
        language_code = get_default_language()

    force = False
    if GLL.is_active:
        language_code = GLL.language_code
        force = True

    if language_code in cls._translation_cache:
        transobj = cls._translation_cache.get(language_code, None)
        if field is None:
            return transobj    
        value = getattr(transobj, field)
        if value or force or (not fallback):
            return value

    if create_if_necessary:
        new_translation = cls._meta.translation_model(master=cls,
                                                      language_code=language_code)
        cls._translation_cache[language_code] = new_translation
        return new_translation
    # only fall backif we're not in 'force' mode (GLL)
    elif (not force) and fallback:
        for fb_lang_code in get_fallbacks(language_code):
            transobj = cls._translation_cache.get(fb_lang_code, None)
            if transobj:
                if field is None:
                    return transobj
                else:
                    value = getattr(transobj, field)
                    if value:
                        return value
    raise TranslationDoesNotExist(language_code)

class TranslationModel(object):
    """
    A superclass for translatablemodel.Translation inner classes.
    """

    def contribute_to_class(cls, main_cls, name):
        """
        Handle the inner 'Translation' class.
        """

        # delay the creation of the *Translation until the master model is
        # fully created
        signals.class_prepared.connect(cls.finish_multilingual_class,
                sender=main_cls, weak=False)

        # connect the post_save signal on master class to a handler
        # that saves translations
        signals.post_save.connect(translation_save_translated_fields,
                sender=main_cls)

    contribute_to_class = classmethod(contribute_to_class)

    def create_translation_attrs(cls, main_cls):
        """
        Creates get_'field name'(language_code) and set_'field
        name'(language_id) methods for all the translation fields.
        Adds the 'field name' properties too.

        Returns the translated_fields hash used in field lookups, see
        multilingual.query.  It maps field names to (field,
        language_id) tuples.
        """
        translated_fields = {}

        for fname, field in cls.__dict__.items():
            if isinstance(field, models.fields.Field):
                translated_fields[fname] = (field, None)

                # add get_'fname' and set_'fname' methods to main_cls
                getter = getter_generator(fname, getattr(field, 'verbose_name', fname))
                setattr(main_cls, 'get_' + fname, getter)

                setter = setter_generator(fname)
                setattr(main_cls, 'set_' + fname, setter)

                # add the 'fname' proxy property that allows reads
                # from and writing to the appropriate translation
                setattr(main_cls, fname,
                        TranslatedFieldProxy(fname, fname, field, fallback=True))

                # add the 'fname'_any fallback
                setattr(main_cls, fname + FALLBACK_FIELD_SUFFIX,
                        TranslatedFieldProxy(fname, fname, field, fallback=True))

                # create the 'fname'_'language_code' proxy properties
                for language_code in get_language_code_list():
                    fname_lng = fname + '_' + language_code.replace('-', '_')
                    translated_fields[fname_lng] = (field, language_code)
                    setattr(main_cls, fname_lng,
                            TranslatedFieldProxy(fname, fname_lng, field,
                                                 language_code))
                    # add the 'fname'_'language_code'_any fallback proxy
                    setattr(main_cls, fname_lng + FALLBACK_FIELD_SUFFIX,
                            TranslatedFieldProxy(fname, fname_lng, field,
                                                 language_code, fallback=True))
                fname_current = fname + '_current'
                setattr(main_cls, fname_current,
                        TranslatedFieldProxy(fname, fname_current, field, None))
                setattr(main_cls, fname_current + FALLBACK_FIELD_SUFFIX,
                        TranslatedFieldProxy(fname, fname_current, field, None, fallback=True))

        return translated_fields
    create_translation_attrs = classmethod(create_translation_attrs)

    def get_unique_fields(cls):
        """
        Return a list of fields with "unique" attribute, which needs to
        be augmented by the language.
        """
        unique_fields = []

        for fname, field in cls.__dict__.items():
            if isinstance(field, models.fields.Field):
                if getattr(field,'unique',False):
                    try:
                        field.unique = False
                    except AttributeError:
                        # newer Django defines unique as a property
                        # that uses _unique to store data.  We're
                        # jumping over the fence by setting _unique,
                        # so this sucks, but this happens early enough
                        # to be safe.
                        field._unique = False
                    unique_fields.append(fname)
        return unique_fields
    get_unique_fields = classmethod(get_unique_fields)

    def finish_multilingual_class(cls, *args, **kwargs):
        """
        Create a model with translations of a multilingual class.
        """

        main_cls = kwargs['sender']
        translation_model_name = main_cls.__name__ + "Translation"

        # create the model with all the translatable fields
        unique = [('language_code', 'master')]
        for f in cls.get_unique_fields():
            unique.append(('language_code',f))

        class TransMeta:
            pass

        try:
            meta = cls.Meta
        except AttributeError:
            meta = TransMeta

        meta.ordering = ('language_code',)
        meta.unique_together = tuple(unique)
        meta.app_label = main_cls._meta.app_label
        if not hasattr(meta, 'db_table'):
            meta.db_table = main_cls._meta.db_table + '_translation'

        trans_attrs = cls.__dict__.copy()
        trans_attrs['Meta'] = meta
        # TODO: increase the length of this field, but to what???
        trans_attrs['language_code'] = models.CharField(max_length=15, blank=True,
                                                        choices=get_language_choices(),
                                                        db_index=True)
        
        related_name = getattr(meta, 'related_name', 'translations')
        if hasattr(meta, 'related_name'):
            delattr(meta, 'related_name')
        
        edit_inline = True

        trans_attrs['master'] = TranslationForeignKey(main_cls, blank=False, null=False,
                                                      related_name=related_name,)
        trans_attrs['__str__'] = lambda self: ("%s object, language_code=%s"
                                               % (translation_model_name,
                                                  self.language_code))

        trans_model = ModelBase(translation_model_name, (models.Model,), trans_attrs)
        trans_model._meta.translated_fields = cls.create_translation_attrs(main_cls)
        trans_model._meta.related_name = related_name

        _old_init_name_map = main_cls._meta.__class__.init_name_map
        def init_name_map(self):
            cache = _old_init_name_map(self)
            for name, field_and_lang_id in trans_model._meta.translated_fields.items():
                #import sys; sys.stderr.write('TM %r\n' % trans_model)
                cache[name] = (field_and_lang_id[0], trans_model, True, False)
            return cache
        main_cls._meta.init_name_map = instancemethod(init_name_map,
                                                      main_cls._meta,
                                                      main_cls._meta.__class__)

        main_cls._meta.translation_model = trans_model
        main_cls._meta.force_language = None
        main_cls.Translation = trans_model
        main_cls.get_translation = get_translation
        main_cls.fill_translation_cache = fill_translation_cache

        # Note: don't fill the translation cache in post_init, as all
        # the extra values selected by QAddTranslationData will be
        # assigned AFTER init()
#        signals.post_init.connect(fill_translation_cache,
#                sender=main_cls)

    finish_multilingual_class = classmethod(finish_multilingual_class)
# The following will be deprecated:
Translation = TranslationModel

def install_translation_library():
    # modify ModelBase.__new__ so that it understands how to handle the
    # 'Translation' inner class

    if getattr(ModelBase, '_multilingual_installed', False):
        # don't install it twice
        return

    _old_new = ModelBase.__new__

    def multilingual_modelbase_new(cls, name, bases, attrs):
        if 'Translation' in attrs:
            if not issubclass(attrs['Translation'], Translation):
                raise ValueError, ("%s.Translation must be a subclass "
                                   + " of multilingual.Translation.") % (name,)

            # Make sure that if the class specifies objects then it is
            # a subclass of our Manager.
            #
            # Don't check other managers since someone might want to
            # have a non-multilingual manager, but assigning a
            # non-multilingual manager to objects would be a common
            # mistake.
            if ('objects' in attrs) and (not isinstance(attrs['objects'], manager.Manager)):
                raise ValueError, ("Model %s specifies translations, " +
                                   "so its 'objects' manager must be " +
                                   "a subclass of multilingual.Manager.") % (name,)

            # Change the default manager to multilingual.Manager.
            if not 'objects' in attrs:
                attrs['objects'] = manager.Manager()

        return _old_new(cls, name, bases, attrs)
    ModelBase.__new__ = staticmethod(multilingual_modelbase_new)
    ModelBase._multilingual_installed = True

    # To Be Deprecated
    #install_multilingual_modeladmin_new()

# install the library
install_translation_library()

########NEW FILE########
__FILENAME__ = utils
from multilingual.languages import get_default_language
try:
    from django.utils.decorators import auto_adapt_to_methods as method_decorator
except ImportError:
    from django.utils.decorators import method_decorator
try:
    from threading import local
except ImportError:
    from django.utils._threading_local import local

_thread_locals = local()
_thread_locals.gll_language_code = None

def is_multilingual_model(model):
    """
    Return True if `model` is a multilingual model.
    """
    return hasattr(model._meta, 'translation_model')


def _get_language_code():
    return getattr(_thread_locals, 'gll_language_code', None)

def _set_language_code(lang):
    setattr(_thread_locals, 'gll_language_code', lang)


class GLLError(Exception): pass


class GlobalLanguageLock(object):
    """
    The Global Language Lock can be used to force django-multilingual-ng to use
    a specific language and not try to fall back.
    """
    def lock(self, language_code):
        _set_language_code(language_code)
        
    def release(self):
        _set_language_code(None)
        
    @property
    def language_code(self):
        lang_code = _get_language_code()
        if lang_code is not None:
            return lang_code
        raise GLLError("The Global Language Lock is not active")
        
    @property
    def is_active(self):
        return _get_language_code() is not None
        
GLL = GlobalLanguageLock()


def gll_unlock_decorator(func):
    def _decorated(*args, **kwargs):
        if not GLL.is_active:
            return func(*args, **kwargs)
        language_code = GLL.language_code
        GLL.release()
        result = func(*args, **kwargs)
        GLL.lock(language_code)
        return result
    _decorated.__name__ = func.__name__
    _decorated.__doc__ = func.__doc__
    return _decorated
gll_unlock = method_decorator(gll_unlock_decorator)
########NEW FILE########
__FILENAME__ = validation
from django.core.exceptions import ImproperlyConfigured
from django.db import models

from multilingual.utils import is_multilingual_model


def get_field(cls, model, opts, label, field):
    """
    Just like django.contrib.admin.validation.get_field, but knows
    about translation models.
    """

    trans_model = model._meta.translation_model
    try:
        (f, lang_id) = trans_model._meta.translated_fields[field]
        return f
    except KeyError:
        # fall back to the old way -- see if model contains the field
        # directly
        pass

    try:
        return opts.get_field(field)
    except models.FieldDoesNotExist:
        raise ImproperlyConfigured("'%s.%s' refers to field '%s' that is " \
            "missing from model '%s'." \
            % (cls.__name__, label, field, model.__name__))


def validate_admin_registration(cls, model):
    """
    Validates a class specified as a model admin.

    Right now this means validating prepopulated_fields, as for
    multilingual models DM handles them by itself.
    """

    if not is_multilingual_model(model):
        return

    from django.contrib.admin.validation import check_isdict, check_isseq

    opts = model._meta

    # this is heavily based on django.contrib.admin.validation.
    if hasattr(cls, '_dm_prepopulated_fields'):
        check_isdict(cls, '_dm_prepopulated_fields', cls.prepopulated_fields)
        for field, val in cls._dm_prepopulated_fields.items():
            f = get_field(cls, model, opts, 'prepopulated_fields', field)
            if isinstance(f, (models.DateTimeField, models.ForeignKey,
                models.ManyToManyField)):
                raise ImproperlyConfigured("'%s.prepopulated_fields['%s']' "
                        "is either a DateTimeField, ForeignKey or "
                        "ManyToManyField. This isn't allowed."
                        % (cls.__name__, field))
            check_isseq(cls, "prepopulated_fields['%s']" % field, val)
            for idx, f in enumerate(val):
                get_field(cls, model,
                        opts, "prepopulated_fields['%s'][%d]"
                        % (f, idx), f)

########NEW FILE########
__FILENAME__ = runtests
import subprocess
import os
import sys
import unittest

thisdir = os.path.dirname(os.path.abspath(__file__))
os.chdir(thisdir + '/tests/')
sys.path.insert(0, thisdir)
os.environ['DJANGO_SETTINGS_MODULE'] = 'testproject.settings'

def call(command, output=False):
    pop = subprocess.Popen(command, shell=True, bufsize=1024,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        out = pop.stdout.read()
        err = pop.stderr.read()
        if out:
            print out
        if err:
            print err
        if not (out or err):
            break
        
def run():
    call("python %s/tests/bootstrap.py" % thisdir)
    call("%s/tests/bin/buildout -c %s/tests/buildout.cfg" % (thisdir, thisdir))
    call("%s/tests/bin/test" % thisdir, True)

if __name__ == '__main__':
    run()
########NEW FILE########
__FILENAME__ = bootstrap
##############################################################################
#
# Copyright (c) 2006 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Bootstrap a buildout-based project

Simply run this script in a directory containing a buildout.cfg.
The script accepts buildout command-line options, so you can
use the -c option to specify an alternate configuration file.

$Id$
"""

import os, shutil, sys, tempfile, urllib2
from optparse import OptionParser

tmpeggs = tempfile.mkdtemp()

is_jython = sys.platform.startswith('java')

# parsing arguments
parser = OptionParser()
parser.add_option("-v", "--version", dest="version",
                          help="use a specific zc.buildout version")
parser.add_option("-d", "--distribute",
                   action="store_true", dest="distribute", default=False,
                   help="Use Distribute rather than Setuptools.")

parser.add_option("-c", None, action="store", dest="config_file",
                   help=("Specify the path to the buildout configuration "
                         "file to be used."))

options, args = parser.parse_args()

# if -c was provided, we push it back into args for buildout' main function
if options.config_file is not None:
    args += ['-c', options.config_file]

if options.version is not None:
    VERSION = '==%s' % options.version
else:
    VERSION = ''

USE_DISTRIBUTE = options.distribute
args = args + ['bootstrap']

to_reload = False
try:
    import pkg_resources
    if not hasattr(pkg_resources, '_distribute'):
        to_reload = True
        raise ImportError
except ImportError:
    ez = {}
    if USE_DISTRIBUTE:
        exec urllib2.urlopen('http://python-distribute.org/distribute_setup.py'
                         ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0, no_fake=True)
    else:
        exec urllib2.urlopen('http://peak.telecommunity.com/dist/ez_setup.py'
                             ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0)

    if to_reload:
        reload(pkg_resources)
    else:
        import pkg_resources

if sys.platform == 'win32':
    def quote(c):
        if ' ' in c:
            return '"%s"' % c # work around spawn lamosity on windows
        else:
            return c
else:
    def quote (c):
        return c

cmd = 'from setuptools.command.easy_install import main; main()'
ws  = pkg_resources.working_set

if USE_DISTRIBUTE:
    requirement = 'distribute'
else:
    requirement = 'setuptools'

if is_jython:
    import subprocess

    assert subprocess.Popen([sys.executable] + ['-c', quote(cmd), '-mqNxd',
           quote(tmpeggs), 'zc.buildout' + VERSION],
           env=dict(os.environ,
               PYTHONPATH=
               ws.find(pkg_resources.Requirement.parse(requirement)).location
               ),
           ).wait() == 0

else:
    assert os.spawnle(
        os.P_WAIT, sys.executable, quote (sys.executable),
        '-c', quote (cmd), '-mqNxd', quote (tmpeggs), 'zc.buildout' + VERSION,
        dict(os.environ,
            PYTHONPATH=
            ws.find(pkg_resources.Requirement.parse(requirement)).location
            ),
        ) == 0

ws.add_entry(tmpeggs)
ws.require('zc.buildout' + VERSION)
import zc.buildout.buildout
zc.buildout.buildout.main(args)
shutil.rmtree(tmpeggs)

########NEW FILE########
__FILENAME__ = models
# DONT DELETE THIS!
########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'testproject.db'

TIME_ZONE = 'America/Chicago'

LANGUAGE_CODE = 'en'

LANGUAGES = (
    ('en', 'English'),
    ('ja', ''),
)

MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media')

MEDIA_URL = '/media/'

ADMIN_MEDIA_PREFIX = '/admin_media/'

SECRET_KEY = '23aq#z2r&z(_1j^3b(s=wi+wn!ss3o9)a82hrvtyx5_p9*zvpb'

SITE_ID = 1

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.doc.XViewMiddleware',
    'multilingual.flatpages.middleware.FlatpageFallbackMiddleware',
)

ROOT_URLCONF = 'testproject.urls'


INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.admin',
    'django.contrib.sites',
    'multilingual',
    'multilingual.flatpages',
    'testproject',
)

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "multilingual.context_processors.multilingual",
)

TEMPLATE_DIRS = (
    os.path.join(os.path.dirname(__file__), "templates"),
)

MULTILINGUAL_DEFAULT_LANGUAGE = 'en'
########NEW FILE########
__FILENAME__ = core
from django.test import TestCase
from multilingual.flatpages.models import MultilingualFlatPage
from multilingual.utils import GLL
from multilingual import languages
from django.utils.translation import activate

class CoreTestCase(TestCase):
    fixtures = ['testdata.json']
    
    def test_01_read(self):
        mfp = MultilingualFlatPage.objects.get(url='/test1/')
        self.assertEqual(mfp.title_en, 'MLFP-Title1-en')
        self.assertEqual(mfp.title_ja, 'MLFP-Title1-ja')
        self.assertEqual(mfp.content_en, 'MLFP-Content1-en')
        self.assertEqual(mfp.content_ja, 'MLFP-Content1-ja')
        
    def test_02_gll(self):
        mfp = MultilingualFlatPage.objects.get(url='/test2/')
        GLL.lock('en')
        self.assertEqual(mfp.title, None)
        self.assertEqual(mfp.content, None)
        GLL.release()
        GLL.lock('ja')
        self.assertEqual(mfp.title, 'MLFP-Title2-ja')
        self.assertEqual(mfp.content, 'MLFP-Content2-ja')
        GLL.release()
        
    def test_03_fallbacks(self):
        mfp = MultilingualFlatPage.objects.get(url='/test2/')
        self.assertEqual(mfp.title_ja_any, mfp.title_en_any)
        
    def test_04_magical_methods(self):
        # default lang is 'en'
        activate('en')
        mfp = MultilingualFlatPage.objects.get(url='/test2/')
        self.assertEqual(mfp.title, mfp.title_en_any)
        self.assertNotEqual(mfp.title_en, mfp.title_en_any)
        
    def test_05_default_language(self):
        self.assertEqual(languages.get_default_language(), 'en')
        languages.set_default_language('ja')
        self.assertEqual(languages.get_default_language(), 'ja')
        
    def test_06_get_fallbacks(self):
        self.assertEqual(languages.get_fallbacks('en'), ['en', 'ja'])
        self.assertEqual(languages.get_fallbacks('ja'), ['ja', 'en'])
        
    def test_07_implicit_fallbacks(self):
        self.assertEqual(languages.get_fallbacks('en-us'), ['en-us', 'en'])
        
    def test_08_get_current(self):
        mfp = MultilingualFlatPage.objects.get(url='/test1/')
        activate('ja')
        self.assertEqual(mfp.title_current, mfp.title_ja)
        self.assertEqual(mfp.title_current_any, mfp.title_ja)
        activate('en')
        self.assertEqual(mfp.title_current, mfp.title_en)
        self.assertEqual(mfp.title_current_any, mfp.title_en_any)
        mfp = MultilingualFlatPage.objects.get(url='/test2/')
        activate('en')
        self.assertEqual(mfp.title_current, None)
        self.assertEqual(mfp.title_current_any, mfp.title_ja)
########NEW FILE########
__FILENAME__ = flatpages
from django.test import TestCase
from django.contrib.sites.models import Site
from multilingual.flatpages.models import MultilingualFlatPage

class FlatpagesTestCase(TestCase):
    fixtures = ['testdata.json']
        
    def test_page(self):
        response = self.client.get('/test1/')
        self.assertEqual(response.status_code, 200)
        response = self.client.get('/test2/')
        self.assertEqual(response.status_code, 200)
        
    def test_language(self):
        response = self.client.get('/test1/', HTTP_ACCEPT_LANGUAGE='en')
        self.assertTrue('MLFP-Title1-en' in response.content and 'MLFP-Content1-en' in response.content)
        response = self.client.get('/test1/', HTTP_ACCEPT_LANGUAGE='ja')
        self.assertTrue('MLFP-Title1-ja' in response.content and 'MLFP-Content1-ja' in response.content)
########NEW FILE########
__FILENAME__ = templates
# -*- coding: utf-8 -*-
from django.test import TestCase
from django.template import Template, Context
from multilingual.flatpages.models import MultilingualFlatPage

class TemplateTestCase(TestCase):
    fixtures = ['testdata.json']
    def test_gll(self):
        mfp = MultilingualFlatPage.objects.get(url='/test1/')
        ctx = Context({'page': mfp})
        tpl = Template('{% load multilingual_tags %}{% gll "en" %}{{ page.title }}{% endgll %}')
        result = tpl.render(ctx)
        self.assertEqual(result, 'MLFP-Title1-en')
        tpl = Template('{% load multilingual_tags %}{% gll "ja" %}{{ page.title }}{% endgll %}')
        result = tpl.render(ctx)
        self.assertEqual(result, 'MLFP-Title1-ja')
        
    def test_language_name(self):
        tpl = Template('{% load multilingual_tags %}{{ lang|language_name }}')
        ctx = Context({'lang':'en'})
        result = tpl.render(ctx)
        self.assertEqual(result, 'English')
        ctx = Context({'lang':'ja'})
        result = tpl.render(ctx)
        self.assertEqual(result, u'')
########NEW FILE########
__FILENAME__ = urls

from django.conf.urls.defaults import patterns, include, handler500
from django.conf import settings
from django.contrib import admin
admin.autodiscover()

handler500 = 'django.views.defaults.server_error'
handler404 = 'django.views.defaults.page_not_found'

urlpatterns = patterns(
    '',
    (r'^admin/(.*)', admin.site.root),
    (r'^accounts/login/$', 'django.contrib.auth.views.login'),
)

if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^media/(?P<path>.*)$', 'django.views.static.serve',
         {'document_root': settings.MEDIA_ROOT}),
    )

########NEW FILE########
