__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pyoidc documentation build configuration file, created by
# sphinx-quickstart on Fri Apr  4 15:33:42 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import alabaster

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pyoidc'
copyright = u'2014, Roland Hedberg'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme_path = [alabaster.get_path()]
html_theme = 'alabaster'
html_sidebars = {
   '**': [
       'about.html',
       'navigation.html',
       'searchbox.html',
       'donate.html',
   ]
}

html_theme_options = {
   'description': '',
   'github_button': False,
   'github_user': 'its-dirg',
   'github_repo': 'saml2testGui',
   'github_banner': False,

}

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pyoidcdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'pyoidc.tex', u'pyoidc Documentation',
   u'Roland Hedberg', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyoidc', u'pyoidc Documentation',
     [u'Roland Hedberg'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'pyoidc', u'pyoidc Documentation',
   u'Roland Hedberg', 'pyoidc', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = as
#!/usr/bin/env python
"""
A very simple OAuth2 AS
"""
import logging
import re
import sys
import traceback

from authn_setup import authn_setup
from oic.oauth2.provider import Provider
from oic.oauth2.provider import AuthorizationEndpoint
from oic.oauth2.provider import TokenEndpoint
from oic.utils.authn.client import verify_client
from oic.utils.authz import Implicit
from oic.utils.http_util import wsgi_wrapper, NotFound, ServiceError

__author__ = 'roland'

# ============================================================================
# First define how logging is supposed to be done
# ============================================================================

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'oauth2_as.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.INFO)

# ============================================================================
# Endpoint functions
# ============================================================================


#noinspection PyUnusedLocal
def token(environ, start_response):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.token_endpoint)


#noinspection PyUnusedLocal
def authorization(environ, start_response):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.authorization_endpoint)


ENDPOINTS = [
    AuthorizationEndpoint(authorization),
    TokenEndpoint(token),
]


#noinspection PyUnusedLocal
def verify(environ, start_response):
    _oas = environ["oic.oas"]
    return wsgi_wrapper(environ, start_response, _oas.verify_endpoint)

# ---------------------------------------------------------------------------
# For static files


def static(environ, start_response, path):
    LOGGER.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)

URLS = [
    (r'^verify', verify),
]

for endp in ENDPOINTS:
    URLS.append(("^%s" % endp.etype, endp))

# ============================================================================
# The main web server function
# ============================================================================


def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as  `oic.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches call the `not_found` function.

    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the
        request is done
    :return: The response as a list of lines
    """
    global OAS

    #user = environ.get("REMOTE_USER", "")
    path = environ.get('PATH_INFO', '').lstrip('/')

    LOGGER.info("path: %s" % path)
    if path == "robots.txt":
        return static(environ, start_response, "static/robots.txt")

    environ["oic.oas"] = OAS

    if path.startswith("static/"):
        return static(environ, start_response, path)

    for regex, callback in URLS:
        match = re.search(regex, path)
        if match is not None:
            try:
                environ['oic.url_args'] = match.groups()[0]
            except IndexError:
                environ['oic.url_args'] = path

            LOGGER.debug("callback: %s" % callback)
            try:
                return callback(environ, start_response)
            except Exception, err:
                print >> sys.stderr, "%s" % err
                message = traceback.format_exception(*sys.exc_info())
                print >> sys.stderr, message
                LOGGER.exception("%s" % err)
                resp = ServiceError("%s" % err)
                return resp(environ, start_response)

    LOGGER.debug("unknown side: %s" % path)
    resp = NotFound("Couldn't find the side you asked for!")
    return resp(environ, start_response)


# ============================================================================
# Below is what's needed to start the server
# ============================================================================

START_MESG = "OAuth2 server starting listening on port:%s at %s"

if __name__ == "__main__":
    import argparse
    import shelve
    import importlib

    from cherrypy import wsgiserver
    from cherrypy.wsgiserver import ssl_pyopenssl

    # This is where session information is stored
    # This serve is stateful.
    from oic.utils.sdb import SessionDB

    # Parse the command arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', dest='debug', action='store_true')
    parser.add_argument('-p', dest='port', default=80, type=int)
    # Who it should report as being responsible for the authentication
    parser.add_argument('-A', dest='authn_as', default="")
    parser.add_argument('-c', dest='conf_path')
    parser.add_argument(dest="config")
    args = parser.parse_args()

    # Client data base
    cdb = shelve.open("client_db", writeback=True)

    # Load the configuration file, which must be a python file
    # The default; first look for it in the directory from where this program
    # is run.
    sys.path.insert(0, ".")
    # If a specific configuration directory is specified look there first
    if args.conf_path:
        sys.path.insert(0, args.conf_path)
    config = importlib.import_module(args.config)
    # Add port number information
    config.issuer = config.issuer % args.port
    config.SERVICE_URL = config.SERVICE_URL % args.port

    for cnf in config.AUTHN_METHOD.values():
        try:
            cnf["config"]["return_to"] = cnf["config"]["return_to"] % args.port
        except KeyError:
            pass

    # Initiate the authentication broker. This is the service that
    # chooses which authentication method that is to be used.

    broker = authn_setup(config)

    # dealing with authorization, this is just everything goes.
    authz = Implicit()

    # Initiate the OAuth2 provider instance
    OAS = Provider(config.issuer, SessionDB(), cdb, broker, authz,
                   client_authn=verify_client, symkey=config.SYM_KEY)

    # set some parameters
    try:
        OAS.cookie_ttl = config.COOKIETTL
    except AttributeError:
        pass

    try:
        OAS.cookie_name = config.COOKIENAME
    except AttributeError:
        pass

    if args.debug:
        LOGGER.setLevel(logging.DEBUG)
        OAS.debug = True

    if args.authn_as:
        OAS.authn_as = args.authn_as

    OAS.endpoints = ENDPOINTS

    if args.port == 80:
        OAS.baseurl = config.baseurl
    else:
        if config.baseurl.endswith("/"):
            config.baseurl = config.baseurl[:-1]
        OAS.baseurl = "%s:%d" % (config.baseurl, args.port)

    if not OAS.baseurl.endswith("/"):
        OAS.baseurl += "/"

    LOGGER.debug("URLS: '%s" % (URLS,))

    # Initiate the web server
    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', args.port), application)
    SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(config.SERVER_CERT,
                                                     config.SERVER_KEY,
                                                     config.CERT_CHAIN)

    LOGGER.info(START_MESG % (args.port, config.HOST))
    print START_MESG % (args.port, config.HOST)
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-
from mako.lookup import TemplateLookup

HOST = "localhost"
#HOST = "lingon.ladok.umu.se"
#HOST = "lingon.catalogix.se"

baseurl = "https://%s" % HOST
issuer = "%s:%%d" % baseurl

# Where to go for verifying the authentication info
SERVICE_URL = "%s/verify" % issuer
# Where to return the user after the authentication has been completed
RETURN_TO = "%s/authorization" % issuer

# This is used to pick a subset of users from the set of users that can
# authenticate at this server
VALIDATOR = {
    "type": "ldap",
    "conf": {
        "uri": "ldaps://ldap.umu.se",
        "base": "dc=umu, dc=se",
        "filter_pattern": "(uid=%s)",
        "user": "",
        "passwd": "",
        "attr": ["eduPersonScopedAffiliation", "eduPersonAffiliation"],
    },
    "args": {
        "verifyAttr": "eduPersonAffiliation",
        "verifyAttrValid": ['employee', 'staff', 'student']
    }
}

# ============================================================================
# Static password database
# The password interface is supposed to act as a dictionary. Which it in this
# case is.
# ============================================================================

PASSWD = {"diana": "krall",
          "babs": "howes",
          "upper": "crust",
          "rohe0002": "StevieRay",
          "haho0032": "qwerty"}

ROOT = './'

# ACR = Authentication Class Reference
# WEIGHT = your view on the strength of the method, higher value = better
# SERVICE_URL = After the authentication, this is where the user should be
#   redirected to.

AUTHN_METHOD = {
    # ..... If you want to use CAS authentication ....
    #"CAS" : {
    #     "ACR": "CAS",
    #     "WEIGHT": 1,
    #     "URL": SERVICE_URL,
    #     "validator": VALIDATOR,
    #     "config": {
    #          "server": "https://cas.umu.se",
    #          "return_to": RETURN_TO
    #     }
    #},
    "UserPassword": {
        "ACR": "PASSWORD",
        "WEIGHT": 1,
        "URL": SERVICE_URL,
        "config": {
            "lookup": TemplateLookup(directories=[ROOT + 'templates',
                                                  ROOT + 'htdocs'],
                                     module_directory=ROOT + 'modules',
                                     input_encoding='utf-8',
                                     output_encoding='utf-8'),
            "passwd": PASSWD,
            "return_to": RETURN_TO
        }
    },
}

AUTHN = "Simple"

COOKIENAME = 'pyoic'
COOKIETTL = 4 * 60  # 4 hours
SYM_KEY = "IfIwerelookingfo"  # 16 bytes for AES_128 which is the default
SERVER_CERT = "%s/certs/server.crt" % ROOT
SERVER_KEY = "%s/certs/server.key" % ROOT
#CERT_CHAIN="certs/chain.pem"
CERT_CHAIN = None
########NEW FILE########
__FILENAME__ = conf
from mako.lookup import TemplateLookup

PORT = 8666
HOST = "localhost"

BASE = "http://%s:%d/" % (HOST, PORT)

# If BASE is https these has to be specified
SERVER_KEY = ''
SERVER_CERT = ''
CA_BUNDLE = None

SCOPE = []

ROOT = "./"
LOOKUP = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                        module_directory=ROOT + 'modules',
                        input_encoding='utf-8', output_encoding='utf-8')

AS_CONF = {
    "AuthzServer@DIG": {
        "authorization_endpoint": "https://localhost:8080/authorization",
        "token_endpoint": "https://localhost:8080/token",
        "client_id": "YWwQiwQNWaeI",
        "client_secret": "cdb8c2f40110a5fdefe7e26ea26a0bd51fb3d1b9593d6a054c75abcb"
    }
}


########NEW FILE########
__FILENAME__ = rp
import importlib
from urllib import unquote
from urlparse import parse_qs
import argparse
import sys

from beaker.middleware import SessionMiddleware
from cherrypy import wsgiserver

from oic.oauth2.consumer import Consumer
from oic.utils.http_util import NotFound
from oic.utils.http_util import Response
from oic.utils.http_util import Redirect
from oic.utils.http_util import get_or_post

import logging

# ============================================================================
# First define how logging is supposed to be done
# ============================================================================

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'rp.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.INFO)

SERVER_ENV = {}
RP = None
RP_CONF = None
CONSUMER = {}

#class Httpd(object):
#    def http_request(self, url):
#        return requests.get(url, verify=False)


# ============================================================================
# Endpoint functions
# ============================================================================

def as_choice(environ, start_response):
    resp = Response(mako_template="as_choice.mako",
                    template_lookup=RP_CONF.LOOKUP,
                    headers=[])
    argv = {
        "as_list": RP_CONF.AS_CONF.keys(),
        "action": "as",
        "method": "POST"
    }
    return resp(environ, start_response, **argv)


#noinspection PyUnresolvedReferences
def static(environ, start_response, path):
    LOGGER.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)


# ============================================================================
# The main web server function
# ============================================================================

Token = {}

def application(environ, start_response):
    session = environ['beaker.session']

    path = environ.get('PATH_INFO', '').lstrip('/')
    if path == "robots.txt":
        return static(environ, start_response, "static/robots.txt")

    if path.startswith("static/"):
        return static(environ, start_response, path)

    if path == "logout":
        session.invalidate()
        resp = Redirect("static/log_out_message.html")
        return resp(environ, start_response)

    if path == "as":
        session["callback"] = True
        request = parse_qs(get_or_post(environ))
        _cli = CONSUMER[unquote(request["authzsrv"][0])]
        session["client"] = _cli
        resp = Redirect(_cli.begin(RP_CONF.BASE, path))
        return resp(environ, start_response)

    if path == "authz_cb":
        _cli = session["client"]
        request = get_or_post(environ)
        aresp = _cli.handle_authorization_response(request)
        rargs = {"code": aresp["code"]}
        atresp = _cli.do_access_token_request(request_args=rargs)
                                #extra_args=None, http_args=None,)
        # Access token should be stored somewhere for later usage
        Token[atresp["state"]] = atresp
        resp = Response("Got access token: %s" % atresp["access_token"])
        return resp(environ, start_response)

    return as_choice(environ, start_response)

# ============================================================================
# Below is what's needed to start the server
# ============================================================================

START_MESG = "OAuth2 relaying party listening on port:%s at %s"

if __name__ == '__main__':
    session_opts = {
        'session.type': 'memory',
        'session.cookie_expires': True,
        #'session.data_dir': './data',
        'session.auto': True,
        'session.timeout': 900
    }

    parser = argparse.ArgumentParser()
    parser.add_argument('-c', dest='conf_path')
    parser.add_argument(dest="config")
    args = parser.parse_args()

    # Load the configuration file, which must be a python file
    # The default; first look for it in the directory from where this program
    # is run.
    sys.path.insert(0, ".")
    # If a specific configuration directory is specified look there first
    if args.conf_path:
        sys.path.insert(0, args.conf_path)
    RP_CONF = importlib.import_module(args.config)

    # per AS instantiate a consumer
    for name, info in RP_CONF.AS_CONF.items():
        c_conf = {"client_id": info["client_id"]}

        CONSUMER[name] = Consumer(
            session_db={}, client_config=c_conf,
            server_info={
                "authorization_endpoint": info["authorization_endpoint"],
                "token_endpoint": info["token_endpoint"]},
            authz_page="authz_cb", response_type="code")

        CONSUMER[name].client_secret = info["client_secret"]

    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', RP_CONF.PORT),
                                        SessionMiddleware(application,
                                                          session_opts))

    if RP_CONF.BASE.startswith("https"):
        from cherrypy.wsgiserver import ssl_pyopenssl

        SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(
            RP_CONF.SERVER_CERT, RP_CONF.SERVER_KEY, RP_CONF.CA_BUNDLE)

    LOGGER.info(START_MESG % (RP_CONF.HOST, RP_CONF.PORT))
    print START_MESG % (RP_CONF.HOST, RP_CONF.PORT)
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()
########NEW FILE########
__FILENAME__ = claims_provider
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from oic.utils.keyio import keybundle_from_local_file
from oic.utils.userinfo import UserInfo

__author__ = 'rohe0002'

import logging
import re

from oic.utils.http_util import *
from oic.oic.message import OpenIDSchema

LOGGER = logging.getLogger("")
hdlr = logging.FileHandler('oc3cp.log')
formatter = logging.Formatter('%(asctime)s %(name)s:%(levelname)s %(message)s')
hdlr.setFormatter(formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.DEBUG)

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def verify_client(environ, req, cdb):
    identity = req["client_id"]
    secret = req["client_secret"]
    if identity:
        if identity in cdb:
            if cdb[identity]["client_secret"] == secret:
                return True

    return False


#noinspection PyUnusedLocal
def user_info(oicsrv, userdb, sub, client_id="", user_info_claims=None):
    #print >> sys.stderr, "claims: %s" % user_info_claims

    identity = userdb[sub]
    if user_info_claims:
        result = {}
        claims = user_info_claims["claims"]
        for key, restr in claims.items():
            try:
                result[key] = identity[key]
            except KeyError:
                if restr == {"essential": True}:
                    raise Exception("Missing property '%s'" % key)
    else:
        result = identity

    return OpenIDSchema(**result)


USER2MODE = {"diana": "aggregate",
             "upper": "distribute",
             "babs": "aggregate"}


#noinspection PyUnusedLocal
def claims_mode(info, uid):
    if USER2MODE[uid] == "aggregate":
        return True
    else:
        return False

FUNCTIONS = {
    "verify_client": verify_client,
    "userinfo": user_info,
    "claims_mode": claims_mode
}

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def userinfo(environ, start_response, handle):
    _oas = environ["oic.oas"]

    return _oas.userinfo_endpoint(environ, start_response, LOGGER)


#noinspection PyUnusedLocal
def check_id(environ, start_response, handle):
    _oas = environ["oic.oas"]

    return _oas.check_id_endpoint(environ, start_response, LOGGER)


#noinspection PyUnusedLocal
def op_info(environ, start_response, handle):
    _oas = environ["oic.oas"]

    return _oas.providerinfo_endpoint(environ, start_response, LOGGER)


#noinspection PyUnusedLocal
def userclaims(environ, start_response, handle):
    _oas = environ["oic.oas"]

    LOGGER.info("claims_endpoint")
    return _oas.claims_endpoint(environ, start_response, LOGGER)


#noinspection PyUnusedLocal
def registration(environ, start_response, handle):
    _oas = environ["oic.oas"]

    return _oas.registration_endpoint(environ, start_response)


#noinspection PyUnusedLocal
def userclaimsinfo(environ, start_response, handle):
    _oas = environ["oic.oas"]

    LOGGER.info("claims_info_endpoint")
    return _oas.claims_info_endpoint(environ, start_response, LOGGER)

# ----------------------------------------------------------------------------


def static(environ, start_response, path):

    _txt = open(path).read()
    if "x509" in path:
        content = "text/xml"
    else:
        content = "application/json"

    resp = Response(_txt, content=content)
    return resp(environ, start_response)

# ----------------------------------------------------------------------------

from oic.oic.provider import UserinfoEndpoint
#from oic.oic.provider import CheckIDEndpoint
from oic.oic.provider import RegistrationEndpoint
from oic.oic.claims_provider import UserClaimsEndpoint
from oic.oic.claims_provider import UserClaimsInfoEndpoint

ENDPOINTS = [
    UserinfoEndpoint(userinfo),
    #CheckIDEndpoint(check_id),
    RegistrationEndpoint(registration),
    UserClaimsEndpoint(userclaims),
    UserClaimsInfoEndpoint(userclaimsinfo)
]

URLS = [
    (r'^.well-known/openid-configuration', op_info)
]

for endp in ENDPOINTS:
    URLS.append(("^%s$" % endp.etype, endp))


def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as  `oic.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches call the `not_found` function.

    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the
        request is done
    :return: The response as a list of lines
    """
    global OAS

    #user = environ.get("REMOTE_USER", "")
    path = environ.get('PATH_INFO', '').lstrip('/')
    kaka = environ.get("HTTP_COOKIE", '')

    if kaka:
        handle = parse_cookie(OAS.name, OAS.seed, kaka)
        LOGGER.debug("Cookie: %s" % (kaka,))
    else:
        handle = ""

    environ["oic.oas"] = OAS

    LOGGER.info("path: %s" % path)
    if path in OAS.cert or path in OAS.jwk:
        return static(environ, start_response, path)
    else:
        for regex, callback in URLS:
            match = re.search(regex, path)
            if match is not None:
                try:
                    environ['oic.url_args'] = match.groups()[0]
                except IndexError:
                    environ['oic.url_args'] = path
                return callback(environ, start_response, handle)

    resp = NotFound("Couldn't find the side you asked for!")
    return resp(environ, start_response)


# ----------------------------------------------------------------------------

USERDB = {
    "diana": {
        "geolocation": {"longitude": 20.3076, "latitude": 63.8206},
    },
    "upper": {
        "geolocation": {"longitude": 17.0393, "latitude": 59.65075},
    },
    "babs": {
        "geolocation": {"longitude": 4.8890, "latitude": 52.3673},
    }
}


SERVER_DB = {}

if __name__ == '__main__':
    import argparse
    import json

    from cherrypy import wsgiserver
    from cherrypy.wsgiserver import ssl_builtin

    from oic.oic.claims_provider import ClaimsServer
    from oic.utils.sdb import SessionDB

    parser = argparse.ArgumentParser()
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-d', dest='debug', action='store_true')
    parser.add_argument('-p', dest='port', default=8093, type=int)
    parser.add_argument(dest="config")
    args = parser.parse_args()

    cdb = json.loads(open("claims_client.json").read())
    userinfo = UserInfo(USERDB)

    # in memory session storage

    config = json.loads(open(args.config).read())
    OAS = ClaimsServer(config["issuer"], SessionDB(), cdb, userinfo,
                       verify_client)

    if "keys" in config:
        for typ, info in config["keys"].items():
            OAS.keyjar.add_kb("", keybundle_from_local_file(info["key"], "rsa",
                                                            ["ver", "sig"]))
            try:
                OAS.jwks_uri.append(info["jwk"])
            except KeyError:
                pass

    #print URLS
    if args.debug:
        OAS.debug = True

    OAS.endpoints = ENDPOINTS
    if args.port == 80:
        OAS.baseurl = config["baseurl"]
    else:
        if config["baseurl"].endswith("/"):
            config["baseurl"] = config["baseurl"][:-1]
        OAS.baseurl = "%s:%d" % (config["baseurl"], args.port)

    if not OAS.baseurl.endswith("/"):
        OAS.baseurl += "/"

    OAS.claims_userinfo_endpoint = "%s%s" % (
        OAS.baseurl, UserClaimsInfoEndpoint.etype)

    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', args.port), application)
    SRV.ssl_adapter = ssl_builtin.BuiltinSSLAdapter("certs/server.crt",
                                                    "certs/server.key")

    LOGGER.info("Starting server")
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = create_jwk_from_cert
#!/usr/bin/env python

from oic.oauth2 import PBase
from oic.utils.keystore import KeyStore, x509_rsa_loads

__author__ = 'rohe0002'

def main(x509_file, out="keys.jwk"):
    pb = PBase()
    ks = KeyStore(pb.http_request)

    key = x509_rsa_loads(open(x509_file).read())
    ks.add_key(key, "rsa", "sig")

    f = open(out, "w")
    txt = ks.dumps("sig")
    f.write(txt)
    f.close()

if __name__ == "__main__":
    import sys
    main(*sys.argv[1:2])

########NEW FILE########
__FILENAME__ = oc_server
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import traceback

from exceptions import KeyError
from exceptions import Exception
from exceptions import OSError
from exceptions import IndexError
from exceptions import AttributeError
from exceptions import KeyboardInterrupt
from urlparse import parse_qs
from oic.utils.authn.client import verify_client

from oic.utils.authz import AuthzHandling
from oic.utils.keyio import KeyBundle, dump_jwks
from oic.utils.userinfo import UserInfo
from oic.utils.webfinger import WebFinger
from oic.utils.webfinger import OIC_ISSUER
from oic.utils.authn.authn_context import AuthnBroker

__author__ = 'rohe0002'

import logging
import re

from logging.handlers import BufferingHandler

from oic.oic.provider import Provider
from oic.oic.provider import EndSessionEndpoint

from oic.utils.http_util import *
from oic.oic.message import ProviderConfigurationResponse

from mako.lookup import TemplateLookup

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'oc.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

CPC = ('%(asctime)s %(name)s:%(levelname)s '
       '[%(client)s,%(path)s,%(cid)s] %(message)s')
cpc_formatter = logging.Formatter(CPC)

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.DEBUG)

_formatter = logging.Formatter(CPC)
fil_handl = logging.FileHandler(LOGFILE_NAME)
fil_handl.setFormatter(_formatter)

buf_handl = BufferingHandler(10000)
buf_handl.setFormatter(_formatter)

HANDLER = {"CPC-file": fil_handl, "CPC-buffer": buf_handl}
ACTIVE_HANDLER = "BASE"
URLMAP = {}

NAME = "pyoic"

OAS = None

PASSWD = {"diana": "krall",
          "babs": "howes",
          "upper": "crust",
          "rohe0002": "StevieRay",
          "haho0032": "qwerty"} #haho0032@hashog.umdc.umu.se


#noinspection PyUnusedLocal
def devnull(txt):
    pass


def create_session_logger(log_format="CPC"):
    global HANDLER

    logger = logging.getLogger("")
    try:
        logger.addHandler(HANDLER["%s-buffer" % log_format])
    except KeyError:
        _formatter = logging.Formatter(log_format)
        handl = BufferingHandler(10000)
        handl.setFormatter(_formatter)
        logger.addHandler(handl)

    logger.setLevel(logging.INFO)

    return logger


def replace_format_handler(logger, log_format="CPC"):
    global ACTIVE_HANDLER
    global HANDLER
    global LOGFILE_NAME

    if ACTIVE_HANDLER == log_format:
        return logger

    _handler = HANDLER["%s-file" % log_format]
    if _handler in logger.handlers:
        return logger

    # remove all present handler
    logger.handlers = []

    try:
        logger.addHandler(HANDLER["%s-file" % log_format])
    except KeyError:
        _formatter = logging.Formatter(log_format)
        handl = logging.FileHandler(LOGFILE_NAME)
        handl.setFormatter(_formatter)
        logger.addHandler(handl)

    ACTIVE_HANDLER = format
    return logger

# #noinspection PyUnusedLocal
# def simple_user_info(oicsrv, userdb, sub, client_id="",
#                      user_info_claims=None):
#     result = {"sub": "diana"}
#     return OpenIDSchema(**result)

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def safe(environ, start_response, logger):
    _oas = environ["oic.oas"]
    _srv = _oas.server
    _log_info = _oas.logger.info

    _log_info("- safe -")
    #_log_info("env: %s" % environ)
    #_log_info("handle: %s" % (handle,))

    try:
        authz = environ["HTTP_AUTHORIZATION"]
        (typ, code) = authz.split(" ")
        assert typ == "Bearer"
    except KeyError:
        resp = BadRequest("Missing authorization information")
        return resp(environ, start_response)

    try:
        _sinfo = _srv.sdb[code]
    except KeyError:
        resp = Unauthorized("Not authorized")
        return resp(environ, start_response)

    info = "'%s' secrets" % _sinfo["sub"]
    resp = Response(info)
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def css(environ, start_response, logger):
    try:
        info = open(environ["PATH_INFO"]).read()
        resp = Response(info)
    except (OSError, IOError):
        resp = NotFound(environ["PATH_INFO"])

    return resp(environ, start_response)

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def token(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.token_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def authorization(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.authorization_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def userinfo(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.userinfo_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def op_info(environ, start_response, logger):
    _oas = environ["oic.oas"]
    LOGGER.info("op_info")
    return wsgi_wrapper(environ, start_response, _oas.providerinfo_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def registration(environ, start_response, logger):
    _oas = environ["oic.oas"]

    if environ["REQUEST_METHOD"] == "POST":
        return wsgi_wrapper(environ, start_response, _oas.registration_endpoint,
                            logger=logger)
    elif environ["REQUEST_METHOD"] == "GET":
        return wsgi_wrapper(environ, start_response, _oas.read_registration,
                            logger=logger)
    else:
        resp = ServiceError("Method not supported")
        return resp(environ, start_response)


#noinspection PyUnusedLocal
def check_id(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.check_id_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def swd_info(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.discovery_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def trace_log(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.tracelog_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def endsession(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.endsession_endpoint,
                        logger=logger)

#noinspection PyUnusedLocal
def meta_info(environ, start_response, logger):
    """
    Returns something like this
     {"links":[
        {
            "rel":"http://openid.net/specs/connect/1.0/issuer",
            "href":"https://openidconnect.info/"
        }
     ]}
    """
    pass


def webfinger(environ, start_response, _):
    query = parse_qs(environ["QUERY_STRING"])
    try:
        assert query["rel"] == [OIC_ISSUER]
        resource = query["resource"][0]
    except KeyError:
        resp = BadRequest("Missing parameter in request")
    else:
        wf = WebFinger()
        resp = Response(wf.response(subject=resource, base=OAS.baseurl))
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def verify(environ, start_response, logger):
    _oas = environ["oic.oas"]
    return wsgi_wrapper(environ, start_response, _oas.verify_endpoint,
                        logger=logger)


def static_file(path):
    try:
        os.stat(path)
        return True
    except OSError:
        return False


#noinspection PyUnresolvedReferences
def static(environ, start_response, logger, path):
    logger.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)

# ----------------------------------------------------------------------------
from oic.oic.provider import AuthorizationEndpoint
from oic.oic.provider import TokenEndpoint
from oic.oic.provider import UserinfoEndpoint
#from oic.oic.provider import CheckIDEndpoint
from oic.oic.provider import RegistrationEndpoint

ENDPOINTS = [
    AuthorizationEndpoint(authorization),
    TokenEndpoint(token),
    UserinfoEndpoint(userinfo),
    #CheckIDEndpoint(check_id),
    RegistrationEndpoint(registration),
    EndSessionEndpoint(endsession),
]

URLS = [
    (r'^verify', verify),
    (r'^.well-known/openid-configuration', op_info),
    (r'^.well-known/simple-web-discovery', swd_info),
    (r'^.well-known/host-meta.json', meta_info),
    (r'^.well-known/webfinger', webfinger),
#    (r'^.well-known/webfinger', webfinger),
    (r'.+\.css$', css),
    (r'safe', safe),
#    (r'tracelog', trace_log),
]


def add_endpoints(extra):
    global URLS

    for endp in extra:
        URLS.append(("^%s" % endp.etype, endp))

# ----------------------------------------------------------------------------

ROOT = './'

LOOKUP = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                        module_directory=ROOT + 'modules',
                        input_encoding='utf-8', output_encoding='utf-8')

# ----------------------------------------------------------------------------


def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as  `oic.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches call the `not_found` function.

    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the
        request is done
    :return: The response as a list of lines
    """
    global OAS

    #user = environ.get("REMOTE_USER", "")
    path = environ.get('PATH_INFO', '').lstrip('/')

    logger = logging.getLogger('oicServer')

    if path == "robots.txt":
        return static(environ, start_response, logger, "static/robots.txt")

    environ["oic.oas"] = OAS
    
    #remote = environ.get("REMOTE_ADDR")
    #kaka = environ.get("HTTP_COOKIE", '')

    if path.startswith("static/"):
        return static(environ, start_response, logger, path)
#    elif path.startswith("oc_keys/"):
#        return static(environ, start_response, logger, path)

    for regex, callback in URLS:
        match = re.search(regex, path)
        if match is not None:
            try:
                environ['oic.url_args'] = match.groups()[0]
            except IndexError:
                environ['oic.url_args'] = path

            logger.info("callback: %s" % callback)
            try:
                return callback(environ, start_response, logger)
            except Exception, err:
                print >> sys.stderr, "%s" % err
                message = traceback.format_exception(*sys.exc_info())
                print >> sys.stderr, message
                logger.exception("%s" % err)
                resp = ServiceError("%s" % err)
                return resp(environ, start_response)

    LOGGER.debug("unknown side: %s" % path)
    resp = NotFound("Couldn't find the side you asked for!")
    return resp(environ, start_response)


# ----------------------------------------------------------------------------

class TestProvider(Provider):
    #noinspection PyUnusedLocal
    def __init__(self, name, sdb, cdb, function, userdb, urlmap=None,
                 debug=0, ca_certs="", jwt_keys=None):
        Provider.__init__(self, name, sdb, cdb, function, userdb, urlmap,
                          ca_certs, jwt_keys)
        self.test_mode = True
        self.trace_log = {}
        self.sessions = []
        self.max_sessions = 100

    def dump_tracelog(self, key):
        tlog = self.trace_log[key]
        for handler in tlog.handlers:
            if isinstance(handler, BufferingHandler):
                arr = []
                for record in handler.buffer:
                    arr.append(handler.format(record))

                return "\n".join(arr)
        return ""

    #noinspection PyUnusedLocal
    def tracelog_endpoint(self, environ, start_response, logger, **kwargs):
        handle = kwargs["handle"]
        tlog = self.trace_log[handle[0]]
        for handler in tlog.handlers:
            if isinstance(handler, BufferingHandler):
                arr = []
                for record in handler.buffer:
                    arr.append(handler.format(record))

                resp = Response("\n".join(arr), content="text/plain")
                return resp(environ, start_response)

        del self.trace_log[handle[0]]
        self.sessions.remove(handle[0])
        resp = Response("no info", content="text/plain")
        return resp(environ, start_response)

    def re_link_log(self, old, new):
        self.trace_log[new] = self.trace_log[old]

    def new_trace_log(self, key):
        _log = create_session_logger(key)
        if len(self.trace_log) > self.max_sessions:
            # remove the oldest
            oldest = self.sessions[0]
            del self.trace_log[oldest]
            self.sessions = self.sessions[1:]
        self.trace_log[key] = _log
        return _log


if __name__ == '__main__':
    import argparse
    import shelve
    import importlib

    from cherrypy import wsgiserver
    #from cherrypy.wsgiserver import ssl_builtin
    from cherrypy.wsgiserver import ssl_pyopenssl

    from oic.utils.sdb import SessionDB

    parser = argparse.ArgumentParser()
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-d', dest='debug', action='store_true')
    parser.add_argument('-p', dest='port', default=80, type=int)
    parser.add_argument('-t', dest='test', action='store_true')
    parser.add_argument('-X', dest='XpressConnect', action='store_true')
    parser.add_argument('-A', dest='authn_as', default="")
    parser.add_argument('-P', dest='provider_conf')
    parser.add_argument('-k', dest='insecure', action='store_true')
    parser.add_argument(dest="config")
    args = parser.parse_args()

    # Client data base
    cdb = shelve.open("client_db", writeback=True)

    sys.path.insert(0, ".")
    config = importlib.import_module(args.config)
    config.issuer = config.issuer % args.port
    config.SERVICE_URL = config.SERVICE_URL % args.port

    ac = AuthnBroker()

    for authkey, value in config.AUTHORIZATION.items():
        authn = None
        if "CAS" == authkey:
           from oic.utils.authn.user_cas import CasAuthnMethod
           from oic.utils.authn.ldap_member import UserLDAPMemberValidation
           config.LDAP_EXTRAVALIDATION.update(config.LDAP)
           authn = CasAuthnMethod(None, config.CAS_SERVER, config.SERVICE_URL,"%s/authorization" % config.issuer,
                                  UserLDAPMemberValidation(**config.LDAP_EXTRAVALIDATION))
        if "UserPassword" == authkey:
            from oic.utils.authn.user import UsernamePasswordMako
            authn = UsernamePasswordMako(None, "login.mako", LOOKUP, PASSWD,
                                         "%s/authorization" % config.issuer)
        if authn is not None:
            ac.add(config.AUTHORIZATION[authkey]["ACR"],
                   authn,
                   config.AUTHORIZATION[authkey]["WEIGHT"],
                   config.AUTHORIZATION[authkey]["URL"])

    # dealing with authorization
    authz = AuthzHandling()
    # authz = UserInfoConsent()
    # User info database
    if args.insecure:
        kwargs = {"verify_ssl": False}
    else:
        kwargs = {"verify_ssl": True}

    if args.test:
        URLS.append((r'tracelog', trace_log))
        OAS = TestProvider(config.issuer, SessionDB(), cdb, ac, None,
                           authz, config.SYM_KEY)
    elif args.XpressConnect:
        from XpressConnect import XpressConnectProvider

        OAS = XpressConnectProvider(config.issuer, SessionDB(), cdb, ac,
                                    None, authz, verify_client, config.SYM_KEY)
    else:
        OAS = Provider(config.issuer, SessionDB(), cdb, ac, None, authz,
                       verify_client, config.SYM_KEY, **kwargs)


    try:
        OAS.cookie_ttl = config.COOKIETTL
    except AttributeError:
        pass

    try:
        OAS.cookie_name = config.COOKIENAME
    except AttributeError:
        pass

    #print URLS
    if args.debug:
        OAS.debug = True
    if args.test:
        OAS.test_mode = True
    else:
        OAS.test_mode = False

    if args.authn_as:
        OAS.authn_as = args.authn_as

    if args.provider_conf:
        prc = ProviderConfigurationResponse().from_json(
            open(args.provider_conf).read())
        endpoints = []
        for key in prc.keys():
            if key.endswith("_endpoint"):
                endpoints.append(key)
    else:
        endpoints = ENDPOINTS

    add_endpoints(endpoints)
    OAS.endpoints = endpoints

    if args.port == 80:
        OAS.baseurl = config.baseurl
    else:
        if config.baseurl.endswith("/"):
            config.baseurl = config.baseurl[:-1]
        OAS.baseurl = "%s:%d" % (config.baseurl, args.port)

    if not OAS.baseurl.endswith("/"):
        OAS.baseurl += "/"

    try:
        OAS.keyjar[""] = []
        kbl = []
        for typ, info in config.keys.items():
            typ = typ.upper()
            LOGGER.info("OC server key init: %s, %s" % (typ, info))
            kb = KeyBundle(source="file://%s" % info["key"], fileformat="der",
                           keytype=typ)
            OAS.keyjar.add_kb("", kb)
            kbl.append(kb)

        try:
            new_name = "static/jwks.json"
            dump_jwks(kbl, new_name)
            OAS.jwks_uri.append("%s%s" % (OAS.baseurl, new_name))
        except KeyError:
            pass

        for b in OAS.keyjar[""]:
            LOGGER.info("OC3 server keys: %s" % b)
    except Exception, err:
        LOGGER.error("Key setup failed: %s" % err)
        OAS.key_setup("static", sig={"format": "jwk", "alg": "rsa"})

    if config.USERINFO == "LDAP":
        from oic.utils.userinfo.ldap_info import UserInfoLDAP
        OAS.userinfo = UserInfoLDAP(**config.LDAP)
    elif config.USERINFO == "SIMPLE":
        OAS.userinfo = UserInfo(config.USERDB)
    elif config.USERINFO == "DISTRIBUTED":
        from oic.utils.userinfo.distaggr import DistributedAggregatedUserInfo
        OAS.userinfo = DistributedAggregatedUserInfo(config.USERDB, OAS,
                                                     config.CLIENT_INFO)

    LOGGER.debug("URLS: '%s" % (URLS,))
    # Add the claims providers keys
    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', args.port), application)

    SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(config.SERVER_CERT,
                                                     config.SERVER_KEY,
                                                     config.CERT_CHAIN)

    LOGGER.info("OC server starting listening on port:%s" % args.port)
    print "OC server starting listening on port:%s" % args.port
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import logging
import sys
import os
import traceback

from exceptions import KeyError
from exceptions import Exception
from exceptions import OSError
from exceptions import IndexError
from exceptions import AttributeError
from exceptions import KeyboardInterrupt
from urlparse import parse_qs
from oic.utils.authn.client import verify_client

from oic.utils.authz import AuthzHandling
from oic.utils.keyio import KeyBundle, dump_jwks
from oic.utils.userinfo import UserInfo
from oic.utils.webfinger import WebFinger
from oic.utils.webfinger import OIC_ISSUER
from oic.utils.authn.authn_context import AuthnBroker

__author__ = 'rohe0002'

import re

from oic.oic.provider import Provider
from oic.oic.provider import EndSessionEndpoint
from oic.utils.http_util import *

from mako.lookup import TemplateLookup

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'oc.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

CPC = ('%(asctime)s %(name)s:%(levelname)s '
       '[%(client)s,%(path)s,%(cid)s] %(message)s')
cpc_formatter = logging.Formatter(CPC)

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.DEBUG)

URLMAP = {}
NAME = "pyoic"
OAS = None

PASSWD = {
    "diana": "krall",
    "babs": "howes",
    "upper": "crust"
}


# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def safe(environ, start_response, logger):
    _oas = environ["oic.oas"]
    _srv = _oas.server
    _log_info = _oas.logger.info

    _log_info("- safe -")
    #_log_info("env: %s" % environ)
    #_log_info("handle: %s" % (handle,))

    try:
        authz = environ["HTTP_AUTHORIZATION"]
        (typ, code) = authz.split(" ")
        assert typ == "Bearer"
    except KeyError:
        resp = BadRequest("Missing authorization information")
        return resp(environ, start_response)

    try:
        _sinfo = _srv.sdb[code]
    except KeyError:
        resp = Unauthorized("Not authorized")
        return resp(environ, start_response)

    info = "'%s' secrets" % _sinfo["sub"]
    resp = Response(info)
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def css(environ, start_response, logger):
    try:
        info = open(environ["PATH_INFO"]).read()
        resp = Response(info)
    except (OSError, IOError):
        resp = NotFound(environ["PATH_INFO"])

    return resp(environ, start_response)

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def token(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.token_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def authorization(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.authorization_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def userinfo(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.userinfo_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def op_info(environ, start_response, logger):
    _oas = environ["oic.oas"]
    LOGGER.info("op_info")
    return wsgi_wrapper(environ, start_response, _oas.providerinfo_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def registration(environ, start_response, logger):
    _oas = environ["oic.oas"]

    if environ["REQUEST_METHOD"] == "POST":
        return wsgi_wrapper(environ, start_response, _oas.registration_endpoint,
                            logger=logger)
    elif environ["REQUEST_METHOD"] == "GET":
        return wsgi_wrapper(environ, start_response, _oas.read_registration,
                            logger=logger)
    else:
        resp = ServiceError("Method not supported")
        return resp(environ, start_response)


#noinspection PyUnusedLocal
def check_id(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.check_id_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def swd_info(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.discovery_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def trace_log(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.tracelog_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def endsession(environ, start_response, logger):
    _oas = environ["oic.oas"]

    return wsgi_wrapper(environ, start_response, _oas.endsession_endpoint,
                        logger=logger)


#noinspection PyUnusedLocal
def meta_info(environ, start_response, logger):
    """
    Returns something like this::

         {"links":[
             {
                "rel":"http://openid.net/specs/connect/1.0/issuer",
                "href":"https://openidconnect.info/"
             }
         ]}

    """
    pass


def webfinger(environ, start_response, _):
    query = parse_qs(environ["QUERY_STRING"])
    try:
        assert query["rel"] == [OIC_ISSUER]
        resource = query["resource"][0]
    except KeyError:
        resp = BadRequest("Missing parameter in request")
    else:
        wf = WebFinger()
        resp = Response(wf.response(subject=resource, base=OAS.baseurl))
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def verify(environ, start_response, logger):
    _oas = environ["oic.oas"]
    return wsgi_wrapper(environ, start_response, _oas.verify_endpoint,
                        logger=logger)


def static_file(path):
    try:
        os.stat(path)
        return True
    except OSError:
        return False


#noinspection PyUnresolvedReferences
def static(environ, start_response, logger, path):
    logger.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)

# ----------------------------------------------------------------------------
from oic.oic.provider import AuthorizationEndpoint
from oic.oic.provider import TokenEndpoint
from oic.oic.provider import UserinfoEndpoint
from oic.oic.provider import RegistrationEndpoint

ENDPOINTS = [
    AuthorizationEndpoint(authorization),
    TokenEndpoint(token),
    UserinfoEndpoint(userinfo),
    RegistrationEndpoint(registration),
    EndSessionEndpoint(endsession),
]

URLS = [
    (r'^verify', verify),
    (r'^.well-known/openid-configuration', op_info),
    (r'^.well-known/simple-web-discovery', swd_info),
    (r'^.well-known/host-meta.json', meta_info),
    (r'^.well-known/webfinger', webfinger),
#    (r'^.well-known/webfinger', webfinger),
    (r'.+\.css$', css),
    (r'safe', safe),
#    (r'tracelog', trace_log),
]


def add_endpoints(extra):
    global URLS

    for endp in extra:
        URLS.append(("^%s" % endp.etype, endp))

# ----------------------------------------------------------------------------

ROOT = './'

LOOKUP = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                        module_directory=ROOT + 'modules',
                        input_encoding='utf-8', output_encoding='utf-8')

# ----------------------------------------------------------------------------


def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as  `oic.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches call the `not_found` function.

    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the
        request is done
    :return: The response as a list of lines
    """
    global OAS

    #user = environ.get("REMOTE_USER", "")
    path = environ.get('PATH_INFO', '').lstrip('/')

    logger = logging.getLogger('oicServer')

    if path == "robots.txt":
        return static(environ, start_response, logger, "static/robots.txt")

    environ["oic.oas"] = OAS
    
    #remote = environ.get("REMOTE_ADDR")
    #kaka = environ.get("HTTP_COOKIE", '')

    if path.startswith("static/"):
        return static(environ, start_response, logger, path)
#    elif path.startswith("oc_keys/"):
#        return static(environ, start_response, logger, path)

    for regex, callback in URLS:
        match = re.search(regex, path)
        if match is not None:
            try:
                environ['oic.url_args'] = match.groups()[0]
            except IndexError:
                environ['oic.url_args'] = path

            logger.info("callback: %s" % callback)
            try:
                return callback(environ, start_response, logger)
            except Exception, err:
                print >> sys.stderr, "%s" % err
                message = traceback.format_exception(*sys.exc_info())
                print >> sys.stderr, message
                logger.exception("%s" % err)
                resp = ServiceError("%s" % err)
                return resp(environ, start_response)

    LOGGER.debug("unknown side: %s" % path)
    resp = NotFound("Couldn't find the side you asked for!")
    return resp(environ, start_response)


# ----------------------------------------------------------------------------


if __name__ == '__main__':
    import argparse
    import shelve
    import importlib

    from cherrypy import wsgiserver
    from cherrypy.wsgiserver import ssl_pyopenssl

    from oic.utils.sdb import SessionDB

    parser = argparse.ArgumentParser()
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-d', dest='debug', action='store_true')
    parser.add_argument('-p', dest='port', default=80, type=int)
    parser.add_argument('-k', dest='insecure', action='store_true')
    parser.add_argument(dest="config")
    args = parser.parse_args()

    # Client data base
    cdb = shelve.open("client_db", writeback=True)

    sys.path.insert(0, ".")
    config = importlib.import_module(args.config)
    config.issuer = config.issuer % args.port
    config.SERVICE_URL = config.SERVICE_URL % args.port

    ac = AuthnBroker()

    for authkey, value in config.AUTHENTICATION.items():
        authn = None
        if "UserPassword" == authkey:
            from oic.utils.authn.user import UsernamePasswordMako
            authn = UsernamePasswordMako(None, "login.mako", LOOKUP, PASSWD,
                                         "%s/authorization" % config.issuer)
        if authn is not None:
            ac.add(config.AUTHENTICATION[authkey]["ACR"], authn,
                   config.AUTHENTICATION[authkey]["WEIGHT"],
                   config.AUTHENTICATION[authkey]["URL"])

    # dealing with authorization
    authz = AuthzHandling()

    kwargs = {
        "template_lookup": LOOKUP,
        "template": {"form_post": "form_response.mako"},
        #"template_args": {"form_post": {"action": "form_post"}}
    }

    # Should I care about verifying the certificates used other entities
    if args.insecure:
        kwargs["verify_ssl"] = False
    else:
        kwargs["verify_ssl"] = True

    OAS = Provider(config.issuer, SessionDB(), cdb, ac, None, authz,
                   verify_client, config.SYM_KEY, **kwargs)

    for authn in ac:
        authn.srv = OAS

    if config.USERINFO == "SIMPLE":
        # User info is a simple dictionary in this case statically defined in
        # the configuration file
        OAS.userinfo = UserInfo(config.USERDB)
    else:
        raise Exception("Unsupported userinfo source")

    try:
        OAS.cookie_ttl = config.COOKIETTL
    except AttributeError:
        pass

    try:
        OAS.cookie_name = config.COOKIENAME
    except AttributeError:
        pass

    #print URLS
    if args.debug:
        OAS.debug = True

    # All endpoints the OpenID Connect Provider should answer on
    add_endpoints(ENDPOINTS)
    OAS.endpoints = ENDPOINTS

    if args.port == 80:
        OAS.baseurl = config.baseurl
    else:
        if config.baseurl.endswith("/"):
            config.baseurl = config.baseurl[:-1]
        OAS.baseurl = "%s:%d" % (config.baseurl, args.port)

    if not OAS.baseurl.endswith("/"):
        OAS.baseurl += "/"

    # Add own keys for signing/encrypting JWTs
    try:
        OAS.keyjar[""] = []
        kbl = []
        for typ, info in config.keys.items():
            typ = typ.upper()
            LOGGER.info("OC server key init: %s, %s" % (typ, info))
            kb = KeyBundle(source="file://%s" % info["key"], fileformat="der",
                           keytype=typ)
            OAS.keyjar.add_kb("", kb)
            kbl.append(kb)

        try:
            new_name = "static/jwks.json"
            dump_jwks(kbl, new_name)
            OAS.jwks_uri.append("%s%s" % (OAS.baseurl, new_name))
        except KeyError:
            pass

        for b in OAS.keyjar[""]:
            LOGGER.info("OC3 server keys: %s" % b)
    except Exception, err:
        LOGGER.error("Key setup failed: %s" % err)
        OAS.key_setup("static", sig={"format": "jwk", "alg": "rsa"})

    # Setup the web server
    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', args.port), application)

    SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(config.SERVER_CERT,
                                                     config.SERVER_KEY,
                                                     config.CERT_CHAIN)

    LOGGER.info("OC server starting listening on port:%s" % args.port)
    print "OC server starting listening on port:%s" % args.port
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = oidc
import logging
import traceback
import sys
import requests
from oic.utils.http_util import Response
from oic.utils.authn.client import CLIENT_AUTHN_METHOD
from oic import oic
from oic.oauth2 import rndstr, PBase
from oic.oauth2.message import ErrorResponse

from oic.oic.message import AuthorizationResponse
from oic.oic.message import AuthorizationRequest
from oic.oic.message import AccessTokenResponse
from oic.utils.webfinger import WebFinger



__author__ = 'rolandh'

logger = logging.getLogger(__name__)


def token_secret_key(sid):
    return "token_secret_%s" % sid


SERVICE_NAME = "OIC"
FLOW_TYPE = "code"

CLIENT_CONFIG = {}


class OpenIDConnect(object):
    def __init__(self, attribute_map=None, authenticating_authority=None,
                 name="", registration_info=None, **kwargs):
        self.attribute_map = attribute_map
        self.authenticating_authority = authenticating_authority
        self.name = name

        for param in ["client_id", "client_secret"]:
            try:
                setattr(self, param, kwargs[param])
                del kwargs[param]
            except KeyError:
                setattr(self, param, "")

        self.extra = kwargs
        try:
            self.srv_discovery_url = kwargs["srv_discovery_url"]
        except KeyError:
            self.srv_discovery_url = None
        self.flow_type = FLOW_TYPE
        self.access_token_response = AccessTokenResponse
        self.client_cls = oic.Client
        self.authn_method = None
        self.registration_info = registration_info

    def dynamic(self, server_env, callback, logoutCallback, session, key):
        try:
            client = server_env["OIC_CLIENT"][key]
        except KeyError:
            client = self.client_cls(client_authn_method=CLIENT_AUTHN_METHOD)
            client.redirect_uris = [callback]
            client.post_logout_redirect_uris = [logoutCallback]

            _me = self.registration_info.copy()
            _me["redirect_uris"] = [callback]

            provider_conf = client.provider_config(self.srv_discovery_url)
            logger.debug("Got provider config: %s" % provider_conf)
            session.setProvider(provider_conf["issuer"])
            logger.debug("Registering RP")
            reg_info = client.register(provider_conf["registration_endpoint"],
                                       **_me)
            logger.debug("Registration response: %s" % reg_info)
            for prop in ["client_id", "client_secret"]:
                try:
                    setattr(client, prop, reg_info[prop])
                except KeyError:
                    pass
            try:
                server_env["OIC_CLIENT"][key] = client
            except KeyError:
                server_env["OIC_CLIENT"] = {key: client}
        return client

    def static(self, server_env, callback, logoutCallback, key):
        try:
            client = server_env["OIC_CLIENT"][key]
            logger.debug("Static client: %s" % server_env["OIC_CLIENT"])
        except KeyError:
            client = self.client_cls(client_authn_method=CLIENT_AUTHN_METHOD)
            client.redirect_uris = [callback]
            client.post_logout_redirect_uris = [logoutCallback]
            for typ in ["authorization", "token", "userinfo"]:
                endpoint = "%s_endpoint" % typ
                setattr(client, endpoint, self.extra[endpoint])

            client.client_id = self.client_id
            client.client_secret = self.client_secret

            if "keys" in self.extra:
                client.keyjar.add(self.extra["keys"][0], self.extra["keys"][1])

            try:
                server_env["OIC_CLIENT"][key] = client
            except KeyError:
                server_env["OIC_CLIENT"] = {key: client}
        return client

    #noinspection PyUnusedLocal
    def begin(self, environ, server_env, start_response, session, key):
        """Step 1: Get a access grant.

        :param environ:
        :param start_response:
        :param server_env:
        :param session:
        """
        try:
            logger.debug("FLOW type: %s" % self.flow_type)
            logger.debug("begin environ: %s" % server_env)
            client = session.getClient()
            if client is not None and self.srv_discovery_url:
                data = {"client_id": client.client_id}
                resp = requests.get(self.srv_discovery_url + "verifyClientId",
                            params=data, verify=False)
                if not resp.ok and resp.status_code == 400:
                    client = None
                    server_env["OIC_CLIENT"].pop(key, None)
            if client is None:
                callback = server_env["base_url"] + key
                logoutCallback = server_env["base_url"]
                if self.srv_discovery_url:
                    client = self.dynamic(server_env, callback, logoutCallback, session, key)
                else:
                    client = self.static(server_env, callback, logoutCallback, key)
                client.state = session.getState()
                session.setClient(client)

            acr_value = session.get_acr_value(client.authorization_endpoint)
            try:
                acr_values = client.provider_info["acr_values_supported"]
                session.set_acr_values(acr_values)
            except:
                acr_values = None

            if acr_value is None and acr_values is not None and len(acr_values) > 1:
                resp_headers = [("Location", str("/rpAcr"))]
                start_response("302 Found", resp_headers)
                return []
            elif acr_values is not None and len(acr_values) == 1:
                    acr_value = acr_values[0]
            return self.create_authnrequest(environ, server_env, start_response, session, acr_value)
        except Exception:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            return self.result(
                environ, start_response, server_env,
                (False, "Cannot find the OP! Please view your configuration."))

    #noinspection PyUnusedLocal
    def create_authnrequest(self, environ, server_env, start_response, session, acr_value):
        try:
            client = session.getClient()
            session.set_acr_value(client.authorization_endpoint, acr_value)
            request_args = {
                "response_type": self.flow_type,
                "scope": server_env["SCOPE"],
                "state": client.state,
            }

            if acr_value is not None:
                request_args["acr_values"] = acr_value

            if self.flow_type == "token":
                request_args["nonce"] = rndstr(16)
                session.setNonce(request_args["nonce"])
            else:
                use_nonce = getattr(self, "use_nonce", None)
                if use_nonce:
                    request_args["nonce"] = rndstr(16)
                    session.setNonce(request_args["nonce"])

            logger.info("client args: %s" % client.__dict__.items(), )
            logger.info("request_args: %s" % (request_args,))
            # User info claims
        except Exception:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            return self.result(
                environ, start_response, server_env,
                (False, "Cannot find the OP! Please view your configuration."))

        try:
            cis = client.construct_AuthorizationRequest(
                request_args=request_args)
            logger.debug("request: %s" % cis)

            url, body, ht_args, cis = client.uri_and_body(
                AuthorizationRequest, cis, method="GET",
                request_args=request_args)
            logger.debug("body: %s" % body)
        except Exception:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            return self.result(environ, start_response, server_env, (
                False, "Authorization request can not be performed!"))

        logger.info("URL: %s" % url)
        logger.debug("ht_args: %s" % ht_args)

        #session.setAuthn_auth(client.authorization_endpoint)
        #session.setAuthentication("VERIFY")

        #server_env["CACHE"][sid] = session
        session.setClient(client)
        resp_headers = [("Location", str(url))]
        if ht_args:
            resp_headers.extend([(a, b) for a, b in ht_args.items()])
        logger.debug("resp_headers: %s" % resp_headers)
        start_response("302 Found", resp_headers)
        return []

    def get_accesstoken(self, client, authresp):
        if self.srv_discovery_url:
            issuer = client.provider_info.keys()[0]
            #logger.debug("state: %s (%s)" % (client.state, msg["state"]))
            key = client.keyjar.get_verify_key(owner=issuer)
            kwargs = {"key": key}
            logger.debug("key: %s" % key)
        else:
            kwargs = {"keyjar": client.keyjar}

        if self.authn_method:
            kwargs["authn_method"] = self.authn_method

        # get the access token
        return client.do_access_token_request(
            state=authresp["state"], response_cls=self.access_token_response,
            **kwargs)

    #noinspection PyUnusedLocal
    def verify_token(self, client, access_token):
        return {}

    def get_userinfo(self, client, authresp, access_token, **kwargs):
        # use the access token to get some userinfo
        return client.do_user_info_request(state=authresp["state"],
                                           schema="openid",
                                           access_token=access_token,
                                           **kwargs)

    #noinspection PyUnusedLocal
    def phaseN(self, environ, query, server_env, session):
        """Step 2: Once the consumer has redirected the user back to the
        callback URL you can request the access token the user has
        approved."""

        client = session.getClient()
        logger.debug("info: %s" % query)
        logger.debug("keyjar: %s" % client.keyjar)

        authresp = client.parse_response(AuthorizationResponse, query,
                                         sformat="dict", keyjar=client.keyjar)

        if isinstance(authresp, ErrorResponse):
            return False, "Access denied"
        try:
            client.id_token = authresp["id_token"]
        except:
            pass
        #session.session_id = msg["state"]

        logger.debug("callback environ: %s" % environ)

        if self.flow_type == "code":
            # get the access token
            try:
                tokenresp = self.get_accesstoken(client, authresp)
            except Exception, err:
                logger.error("%s" % err)
                raise

            if isinstance(tokenresp, ErrorResponse):
                return (False, "Invalid response %s." % tokenresp["error"])

            access_token = tokenresp["access_token"]
        else:
            access_token = authresp["access_token"]

        userinfo = self.verify_token(client, access_token)

        inforesp = self.get_userinfo(client, authresp, access_token)

        if isinstance(inforesp, ErrorResponse):
            return False, "Invalid response %s." % inforesp["error"], session

        tot_info = userinfo.update(inforesp.to_dict())

        logger.debug("UserInfo: %s" % inforesp)

        return True, userinfo, access_token, client

    #noinspection PyUnusedLocal
    def callback(self, environ, server_env, start_response, query, session):
        """
        This is where we come back after the OP has done the
        Authorization Request.

        :param environ:
        :param server_env:
        :param start_response:
        :param query:
        :param session:
        :return:
        """
        _service = self.__class__.__name__

        logger.debug("[do_%s] environ: %s" % (_service, environ))
        logger.debug("[do_%s] query: %s" % (_service, query))

        try:
            result = self.phaseN(environ, query, server_env, session)
            session.setLogin(True)
            logger.debug("[do_%s] response: %s" % (_service, result))
        except Exception:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            result = (False, "An unknown exception has occurred.")

        return self.result(environ, start_response, server_env, result)

    def result(self, environ, start_response, server_env, result):
        resp = Response(mako_template="opresult.mako",
                        template_lookup=server_env["template_lookup"],
                        headers=[])
        argv = {
            "result": result
        }
        return resp(environ, start_response, **argv)

    def find_srv_discovery_url(self, resource):
        """
        Use Webfinger to find the OP, The input is a unique identifier
        of the user. Allowed forms are the acct, mail, http and https
        urls. If no protocol specification is given like if only an
        email like identifier is given. It will be translated if possible to
        one of the allowed formats.

        :param resource: unique identifier of the user.
        :return:
        """

        wf = WebFinger(httpd=PBase(ca_certs=self.extra["ca_bundle"]))
        return wf.discovery_query(resource)
########NEW FILE########
__FILENAME__ = rp_server
#!/usr/bin/env python
import urllib
import uuid
import requests
import hashlib
import base64
from jwkest.jws import alg2keytype
from beaker.middleware import SessionMiddleware
from cherrypy import wsgiserver
from mako.lookup import TemplateLookup
from urlparse import parse_qs

from oic.utils.http_util import NotFound, Response, ServiceError, Redirect
from oidc import OpenIDConnect

import conf

import logging

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'rp.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

CPC = ('%(asctime)s %(name)s:%(levelname)s '
       '[%(client)s,%(path)s,%(cid)s] %(message)s')
cpc_formatter = logging.Formatter(CPC)

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.DEBUG)

LOOKUP = TemplateLookup(directories=['templates', 'htdocs'],
                        module_directory='modules',
                        input_encoding='utf-8',
                        output_encoding='utf-8')

SERVER_ENV = {}
RP = None


def setup_server_env(conf):
    global SERVER_ENV
    global logger

    SERVER_ENV = dict([(k, v) for k, v in conf.__dict__.items()
                       if not k.startswith("__")])
    SERVER_ENV["template_lookup"] = LOOKUP
    SERVER_ENV["base_url"] = conf.BASE
    #SERVER_ENV["CACHE"] = {}
    SERVER_ENV["OIC_CLIENT"] = {}


class Httpd(object):
    def http_request(self, url):
        return requests.get(url, verify=False)


class Session(object):
    def __init__(self, session):
        self.session = session
        self.getCallback()
        self.getState()
        self.getNonce()
        self.getClient()
        self.get_acr_values()


    def clearSession(self):
        for key in self.session:
            self.session.pop(key, None)
        self.session.invalidate()

    def getCallback(self):
        return self.session.get("callback", False)

    def setCallback(self, value):
        self.session["callback"] = value

    def getState(self):
        return self.session.get("state", uuid.uuid4().urn)

    def setState(self, value):
        self.session["state"] = value

    def getNonce(self):
        return self.session.get("nonce", None)

    def setNonce(self, value):
        self.session["nonce"] = value

    def getClient(self):
        return self.session.get("client", None)

    def setClient(self, value):
        self.session["client"] = value

    def getLogin(self):
        return self.session.get("login", None)

    def setLogin(self, value):
        self.session["login"] = value

    def getProvider(self):
        return self.session.get("provider", None)

    def setProvider(self, value):
        self.session["provider"] = value

    def get_acr_values(self):
        return self.session.get("acrvalues", None)

    def set_acr_values(self, value):
        self.session["acrvalues"] = value

    def get_acr_value(self, server):
        return self.session.get(server + "ACR_VALUE", None)

    def set_acr_value(self, server, acr):
        self.session[server + "ACR_VALUE"] = acr

#noinspection PyUnresolvedReferences
def static(environ, start_response, logger, path):
    logger.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)


def opbyuid(environ, start_response):
    resp = Response(mako_template="opbyuid.mako",
                    template_lookup=LOOKUP,
                    headers=[])
    argv = {
    }
    return resp(environ, start_response, **argv)


def chooseAcrValue(environ, start_response, session):
    resp = Response(mako_template="acrvalue.mako",
                    template_lookup=LOOKUP,
                    headers=[])
    argv = {
        "acrvalues": session.get_acr_values()
    }
    return resp(environ, start_response, **argv)


def id_token_as_signed_jwt(client, alg="RS256"):
    if alg.startswith("HS"):
        ckey = client.keyjar.get_signing_key(alg2keytype(alg), "")
    else:
        ckey = client.keyjar.get_signing_key(alg2keytype(alg), "")
    _signed_jwt = client.id_token.to_jwt(key=ckey, algorithm=alg)
    return _signed_jwt


def application(environ, start_response):
    session = Session(environ['beaker.session'])

    path = environ.get('PATH_INFO', '').lstrip('/')
    if path == "robots.txt":
        return static(environ, start_response, LOGGER, "static/robots.txt")

    if path.startswith("static/"):
        return static(environ, start_response, LOGGER, path)

    query = parse_qs(environ["QUERY_STRING"])

    if path == "logout":
        try:
            logoutUrl = session.getClient().endsession_endpoint
            logoutUrl += "?" + urllib.urlencode(
                {"post_logout_redirect_uri": SERVER_ENV["base_url"]})
            try:
                logoutUrl += "&" + urllib.urlencode({
                    "id_token_hint": id_token_as_signed_jwt(
                        session.getClient(), "HS256")})
            except:
                pass
            session.clearSession()
            resp = Redirect(str(logoutUrl))
            return resp(environ, start_response)
        except:
            pass

    if session.getCallback():
        _uri = "%s%s" % (conf.BASE, path)
        for _cli in SERVER_ENV["OIC_CLIENT"].values():
            if _uri in _cli.redirect_uris:
                session.setCallback(False)
                func = getattr(RP, "callback")
                return func(environ, SERVER_ENV, start_response, query, session)

    if path == "rpAcr":
        return chooseAcrValue(environ, start_response, session)

    if path == "rpAuth":
    # Only called if multiple arc_values (that is authentications) exists.
        if "acr" in query and query["acr"][0] in session.get_acr_values():
            func = getattr(RP, "create_authnrequest")
            return func(environ, SERVER_ENV, start_response, session,
                        query["acr"][0])

    if session.getClient() is not None:
        session.setCallback(True)
        func = getattr(RP, "begin")
        return func(environ, SERVER_ENV, start_response, session, "")

    if path == "rp":
        if "uid" in query:
            try:
                link = RP.find_srv_discovery_url(resource=query["uid"][0])
            except requests.ConnectionError:
                resp = ServiceError("Webfinger lookup failed, connection error")
                return resp(environ, start_response)

            RP.srv_discovery_url = link
            md5 = hashlib.md5()
            md5.update(link)
            opkey = base64.b16encode(md5.digest())
            session.setCallback(True)
            func = getattr(RP, "begin")
            return func(environ, SERVER_ENV, start_response, session, opkey)

    return opbyuid(environ, start_response)


if __name__ == '__main__':
    setup_server_env(conf)

    session_opts = {
        'session.type': 'memory',
        'session.cookie_expires': True,
        #'session.data_dir': './data',
        'session.auto': True,
        'session.timeout': 900
    }

    RP = OpenIDConnect(registration_info=conf.ME,
                       ca_bundle=conf.CA_BUNDLE)

    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', conf.PORT),
                                        SessionMiddleware(application,
                                                          session_opts))

    if conf.BASE.startswith("https"):
        from cherrypy.wsgiserver import ssl_pyopenssl

        SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(
            conf.SERVER_CERT, conf.SERVER_KEY, conf.CA_BUNDLE)

    LOGGER.info("RP server starting listening on port:%s" % conf.PORT)
    print "RP server starting listening on port:%s" % conf.PORT
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = opchoice.mako
# -*- coding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 9
_modified_time = 1400148619.346786
_enable_loop = True
_template_filename = 'htdocs/opchoice.mako'
_template_uri = 'opchoice.mako'
_source_encoding = 'utf-8'
_exports = []


# SOURCE LINE 1

def op_choice(op_list):
    """
    Creates a dropdown list of OpenID Connect providers
    """
    element = "<select name=\"op\">"
    for name in op_list:
        element += "<option value=\"%s\">%s</option>" % (name, name)
    element += "</select>"
    return element


def render_body(context,**pageargs):
    __M_caller = context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        op_list = context.get('op_list', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 11
        __M_writer(u'\n\n<!DOCTYPE html>\n\n<html>\n  <head>\n    <title>pyoidc RP</title>\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <!-- Bootstrap -->\n    <link href="static/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">\n      <link href="static/style.css" rel="stylesheet" media="all">\n\n    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!--[if lt IE 9]>\n      <script src="../../assets/js/html5shiv.js"></script>\n      <script src="../../assets/js/respond.min.js"></script>\n    <![endif]-->\n  </head>\n  <body>\n\n    <!-- Static navbar -->\n    <div class="navbar navbar-default navbar-fixed-top">\n        <div class="navbar-header">\n          <a class="navbar-brand" href="#">pyoidc RP</a>\n        </div>\n    </div>\n\n    <div class="container">\n     <!-- Main component for a primary marketing message or call to action -->\n      <div class="jumbotron">\n        <form class="form-signin" action="rp" method="get">\n        <h1>OP by UID</h1>\n          <h3>Chose the OpenID Connect Provider: </h3>\n            <p>From this list</p>\n            ')
        # SOURCE LINE 45
        __M_writer(unicode(op_choice(op_list)))
        __M_writer(u'\n            <p> OR by providing your unique identifier at the OP. </p>\n            <input type="text" id="uid" name="uid" class="form-control" placeholder="UID" autofocus>\n            <button class="btn btn-lg btn-primary btn-block" type="submit">Start</button>\n        </form>\n      </div>\n\n    </div> <!-- /container -->\n    <!-- jQuery (necessary for Bootstrap\'s JavaScript plugins) -->\n    <script src="/static/jquery.min.1.9.1.js"></script>\n    <!-- Include all compiled plugins (below), or include individual files as needed -->\n    <script src="/static/bootstrap/js/bootstrap.min.js"></script>\n\n  </body>\n</html>')
        return ''
    finally:
        context.caller_stack._pop_frame()



########NEW FILE########
__FILENAME__ = opresult.mako
# -*- encoding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 6
_modified_time = 1398247566.423659
_template_filename='htdocs/opresult.mako'
_template_uri='opresult.mako'
_template_cache=cache.Cache(__name__, _modified_time)
_source_encoding='utf-8'
_exports = []


# SOURCE LINE 3

import htmlentitydefs
import re, string

# this pattern matches substrings of reserved and non-ASCII characters
pattern = re.compile(r"[&<>\"\x80-\xff]+")

# create character map
entity_map = {}

for i in range(256):
    entity_map[chr(i)] = "&#%d;" % i

for entity, char in htmlentitydefs.entitydefs.items():
    if entity_map.has_key(char):
        entity_map[char] = "&%s;" % entity

def escape_entity(m, get=entity_map.get):
    return string.join(map(get, m.group()), "")

def escape(string):
    return pattern.sub(escape_entity, string)

def create_result(userinfo):
  """
      Creates a display of user information.
      """
  element = "<p>You have successfully authenticated!</p>"

  for key, value in userinfo.items():
      element += "<div class='row'>"
      element += "<div class='col-md-3'>" +  escape(unicode(key).encode("utf-8")) + "</div>"
      element += "<div class='col-md-7'>" + escape(unicode(value).encode("utf-8")) + "</div>"
      element += "</div>"
  return element


def render_body(context,**pageargs):
    context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        userinfo = context.get('userinfo', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 1
        __M_writer(u'<!DOCTYPE html>\n\n')
        # SOURCE LINE 38
        __M_writer(u'\n\n<html>\n  <head>\n    <title>pyoidc RP</title>\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <!-- Bootstrap -->\n    <link href="static/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">\n      <link href="static/style.css" rel="stylesheet" media="all">\n\n    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!--[if lt IE 9]>\n      <script src="../../assets/js/html5shiv.js"></script>\n      <script src="../../assets/js/respond.min.js"></script>\n    <![endif]-->\n  </head>\n  <body>\n\n    <!-- Static navbar -->\n    <div class="navbar navbar-default navbar-fixed-top">\n        <div class="navbar-header">\n          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">\n            <span class="icon-bar"></span>\n            <span class="icon-bar"></span>\n            <span class="icon-bar"></span>\n          </button>\n          <a class="navbar-brand" href="#">pyoidc RP</a>\n        </div>\n        <div class="navbar-collapse collapse">\n          <ul class="nav navbar-nav">\n          </ul>\n          <ul class="nav navbar-nav navbar-right">\n            <li><a href="logout">Logout</a></li>\n          </ul>\n        </div><!--/.nav-collapse -->\n    </div>\n\n    <div class="container">\n     <!-- Main component for a primary marketing message or call to action -->\n      <div class="jumbotron">\n        <h1>OP result</h1>\n        ')
        # SOURCE LINE 79
        __M_writer(unicode(create_result(userinfo)))
        __M_writer(u'\n      </div>\n\n    </div> <!-- /container -->\n    <!-- jQuery (necessary for Bootstrap\'s JavaScript plugins) -->\n    <script src="/static/jquery.min.1.9.1.js"></script>\n    <!-- Include all compiled plugins (below), or include individual files as needed -->\n    <script src="/static/bootstrap/js/bootstrap.min.js"></script>\n\n\n  </body>\n</html>')
        return ''
    finally:
        context.caller_stack._pop_frame()



########NEW FILE########
__FILENAME__ = oidc
from oic.utils.http_util import Redirect
from oic.exception import MissingAttribute
from oic import oic
from oic.oauth2 import rndstr, ErrorResponse
from oic.oic import ProviderConfigurationResponse, AuthorizationResponse
from oic.oic import RegistrationResponse
from oic.oic import AuthorizationRequest
from oic.utils.authn.client import CLIENT_AUTHN_METHOD

__author__ = 'roland'

import logging

logger = logging.getLogger(__name__)


class OIDCError(Exception):
    pass


class Client(oic.Client):
    def __init__(self, client_id=None, ca_certs=None,
                 client_prefs=None, client_authn_method=None, keyjar=None,
                 verify_ssl=True, behaviour=None):
        oic.Client.__init__(self, client_id, ca_certs, client_prefs,
                            client_authn_method, keyjar, verify_ssl)
        if behaviour:
            self.behaviour = behaviour

    def create_authn_request(self, session, acr_value=None):
        session["state"] = rndstr()
        session["nonce"] = rndstr()
        request_args = {
            "response_type": self.behaviour["response_type"],
            "scope": self.behaviour["scope"],
            "state": session["state"],
            "nonce": session["nonce"],
            "redirect_uri": self.registration_response["redirect_uris"][0]
        }

        if acr_value is not None:
            request_args["acr_values"] = acr_value

        cis = self.construct_AuthorizationRequest(request_args=request_args)
        logger.debug("request: %s" % cis)

        url, body, ht_args, cis = self.uri_and_body(AuthorizationRequest, cis,
                                                    method="GET",
                                                    request_args=request_args)

        logger.debug("body: %s" % body)
        logger.info("URL: %s" % url)
        logger.debug("ht_args: %s" % ht_args)

        resp = Redirect(str(url))
        if ht_args:
            resp.headers.extend([(a, b) for a, b in ht_args.items()])
        logger.debug("resp_headers: %s" % resp.headers)
        return resp

    def callback(self, response):
        """
        This is the method that should be called when an AuthN response has been
        received from the OP.

        :param response: The URL returned by the OP
        :return:
        """
        authresp = self.parse_response(AuthorizationResponse, response,
                                       sformat="dict", keyjar=self.keyjar)

        if isinstance(authresp, ErrorResponse):
            return OIDCError("Access denied")

        try:
            self.id_token[authresp["state"]] = authresp["id_token"]
        except KeyError:
            pass

        if self.behaviour["response_type"] == "code":
            # get the access token
            try:
                args = {
                    "code": authresp["code"],
                    "redirect_uri": self.registration_response[
                        "redirect_uris"][0],
                    "client_id": self.client_id,
                    "client_secret": self.client_secret
                }

                atresp = self.do_access_token_request(
                    scope="openid", state=authresp["state"], request_args=args,
                    authn_method="client_secret_post")
            except Exception as err:
                logger.error("%s" % err)
                raise

            if isinstance(atresp, ErrorResponse):
                raise OIDCError("Invalid response %s." % atresp["error"])

        inforesp = self.do_user_info_request(state=authresp["state"])

        if isinstance(inforesp, ErrorResponse):
            raise OIDCError("Invalid response %s." % inforesp["error"])

        userinfo = inforesp.to_dict()

        logger.debug("UserInfo: %s" % inforesp)

        return userinfo


class OIDCClients(object):
    def __init__(self, config):
        """

        :param config: Imported configuration module
        :return:
        """
        self.client = {}
        self.client_cls = Client
        self.config = config

        for key, val in config.CLIENTS.items():
            if key == "":
                continue
            else:
                self.client[key] = self.create_client(**val)

    def create_client(self, userid="", **kwargs):
        """
        Do an instantiation of a client instance

        :param userid: An identifier of the user
        :param: Keyword arguments
            Keys are ["srv_discovery_url", "client_info", "client_registration",
            "provider_info"]
        :return: client instance
        """

        _key_set = set(kwargs.keys())
        args = {}
        for param in ["verify_ssl"]:
            try:
                args[param] = kwargs[param]
            except KeyError:
                pass
            else:
                _key_set.discard(param)

        client = self.client_cls(client_authn_method=CLIENT_AUTHN_METHOD,
                                 behaviour=kwargs["behaviour"], verify_ssl=self.config.VERIFY_SSL, **args)

        # The behaviour parameter is not significant for the election process
        _key_set.discard("behaviour")
        for param in ["allow"]:
            try:
                setattr(client, param, kwargs[param])
            except KeyError:
                pass
            else:
                _key_set.discard(param)

        if _key_set == set(["client_info"]):  # Everything dynamic
            # There has to be a userid
            if not userid:
                raise MissingAttribute("Missing userid specification")

            # Find the service that provides information about the OP
            issuer = client.wf.discovery_query(userid)
            # Gather OP information
            _ = client.provider_config(issuer)
            # register the client
            _ = client.register(client.provider_info["registration_endpoint"],
                                **kwargs["client_info"])
        elif _key_set == set(["client_info", "srv_discovery_url"]):
            # Ship the webfinger part
            # Gather OP information
            _ = client.provider_config(kwargs["srv_discovery_url"])
            # register the client
            _ = client.register(client.provider_info["registration_endpoint"],
                                **kwargs["client_info"])
        elif _key_set == set(["provider_info", "client_info"]):
            client.handle_provider_config(
                ProviderConfigurationResponse(**kwargs["provider_info"]),
                kwargs["provider_info"]["issuer"])
            _ = client.register(client.provider_info["registration_endpoint"],
                                **kwargs["client_info"])
        elif _key_set == set(["provider_info", "client_registration"]):
            client.handle_provider_config(
                ProviderConfigurationResponse(**kwargs["provider_info"]),
                kwargs["provider_info"]["issuer"])
            client.store_registration_info(RegistrationResponse(
                    **kwargs["client_registration"]))
        elif _key_set == set(["srv_discovery_url", "client_registration"]):
            _ = client.provider_config(kwargs["srv_discovery_url"])
            client.store_registration_info(RegistrationResponse(
                **kwargs["client_registration"]))
        else:
            raise Exception("Configuration error ?")

        return client

    def dynamic_client(self, userid):
        client = self.client_cls(client_authn_method=CLIENT_AUTHN_METHOD, verify_ssl=self.config.VERIFY_SSL)
        issuer = client.wf.discovery_query(userid)
        if issuer in self.client:
            return self.client[issuer]
        else:
            # Gather OP information
            _pcr = client.provider_config(issuer)
            # register the client
            _ = client.register(_pcr["registration_endpoint"],
                                **self.config.CLIENTS[""]["client_info"])
            try:
                client.behaviour.update(**self.config.CLIENTS[""]["behaviour"])
            except KeyError:
                pass

            self.client[issuer] = client
            return client

    def __getitem__(self, item):
        """
        Given a service or user identifier return a suitable client
        :param item:
        :return:
        """
        try:
            return self.client[item]
        except KeyError:
            return self.dynamic_client(item)

    def keys(self):
        return self.client.keys()
########NEW FILE########
__FILENAME__ = rp
#!/usr/bin/env python
import urllib
from jwkest.jws import alg2keytype
from mako.lookup import TemplateLookup
from urlparse import parse_qs

from oic.utils.http_util import NotFound
from oic.utils.http_util import Response
from oic.utils.http_util import Redirect

import logging

LOGGER = logging.getLogger("")
LOGFILE_NAME = 'rp.log'
hdlr = logging.FileHandler(LOGFILE_NAME)
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

CPC = ('%(asctime)s %(name)s:%(levelname)s '
       '[%(client)s,%(path)s,%(cid)s] %(message)s')
cpc_formatter = logging.Formatter(CPC)

hdlr.setFormatter(base_formatter)
LOGGER.addHandler(hdlr)
LOGGER.setLevel(logging.DEBUG)

LOOKUP = TemplateLookup(directories=['templates', 'htdocs'],
                        module_directory='modules',
                        input_encoding='utf-8',
                        output_encoding='utf-8')

SERVER_ENV = {}


#noinspection PyUnresolvedReferences
def static(environ, start_response, logger, path):
    logger.info("[static]sending: %s" % (path,))

    try:
        text = open(path).read()
        if path.endswith(".ico"):
            start_response('200 OK', [('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            start_response('200 OK', [('Content-Type', 'text/html')])
        elif path.endswith(".json"):
            start_response('200 OK', [('Content-Type', 'application/json')])
        elif path.endswith(".txt"):
            start_response('200 OK', [('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            start_response('200 OK', [('Content-Type', 'text/css')])
        else:
            start_response('200 OK', [('Content-Type', "text/xml")])
        return [text]
    except IOError:
        resp = NotFound()
        return resp(environ, start_response)


def opchoice(environ, start_response, clients):
    resp = Response(mako_template="opchoice.mako",
                    template_lookup=LOOKUP,
                    headers=[])
    argv = {
        "op_list": clients.keys()
    }
    return resp(environ, start_response, **argv)


def opresult(environ, start_response, userinfo):
    resp = Response(mako_template="opresult.mako",
                    template_lookup=LOOKUP,
                    headers=[])
    argv = {
        "userinfo": userinfo,
    }
    return resp(environ, start_response, **argv)


def operror(environ, start_response, error=None):
    resp = Response(mako_template="operror.mako",
                    template_lookup=LOOKUP,
                    headers=[])
    argv = {
        "error": error
    }
    return resp(environ, start_response, **argv)


#
def get_id_token(client, session):
    return client.grant[session["state"]].get_id_token()


# Produce a JWS, a signed JWT, containing a previously received ID token
def id_token_as_signed_jwt(client, id_token, alg="RS256"):
    ckey = client.keyjar.get_signing_key(alg2keytype(alg), "")
    _signed_jwt = id_token.to_jwt(key=ckey, algorithm=alg)
    return _signed_jwt


def clear_session(session):
    for key in session:
        session.pop(key, None)
    session.invalidate()


def application(environ, start_response):
    session = environ['beaker.session']

    path = environ.get('PATH_INFO', '').lstrip('/')
    if path == "robots.txt":
        return static(environ, start_response, LOGGER, "static/robots.txt")

    if path.startswith("static/"):
        return static(environ, start_response, LOGGER, path)

    query = parse_qs(environ["QUERY_STRING"])

    if path == "rp":  # After having chosen which OP to authenticate at
        if "uid" in query:
            client = CLIENTS.dynamic_client(query["uid"][0])
            session["op"] = client.provider_info["issuer"]
        else:
            client = CLIENTS[query["op"][0]]
            session["op"] = query["op"][0]

        try:
            resp = client.create_authn_request(session)
        except Exception:
            raise
        else:
            return resp(environ, start_response)
    elif path == "authz_cb":  # After having authenticated at the OP
        client = CLIENTS[session["op"]]
        try:
            userinfo = client.callback(query)
        except OIDCError as err:
            return operror(environ, start_response, "%s" % err)
        except Exception:
            raise
        else:
            return opresult(environ, start_response, userinfo)
    elif path == "logout":  # After the user has pressed the logout button
        client = CLIENTS[session["op"]]
        logout_url = client.endsession_endpoint
        try:
            # Specify to which URL the OP should return the user after
            # log out. That URL must be registered with the OP at client
            # registration.
            logout_url += "?" + urllib.urlencode(
                {"post_logout_redirect_uri": client.registration_response[
                    "post_logout_redirect_uris"][0]})
        except KeyError:
            pass
        else:
            # If there is an ID token send it along as a id_token_hint
            _idtoken = get_id_token(client, session)
            if _idtoken:
                logout_url += "&" + urllib.urlencode({
                    "id_token_hint": id_token_as_signed_jwt(client, _idtoken,
                                                            "HS256")})

        clear_session(session)
        resp = Redirect(str(logout_url))
        return resp(environ, start_response)

    return opchoice(environ, start_response, CLIENTS)


if __name__ == '__main__':
    from oidc import OIDCClients
    from oidc import OIDCError
    from beaker.middleware import SessionMiddleware
    from cherrypy import wsgiserver
    import conf

    session_opts = {
        'session.type': 'memory',
        'session.cookie_expires': True,
        'session.auto': True,
        'session.timeout': 900
    }

    CLIENTS = OIDCClients(conf)
    SERVER_ENV.update({"template_lookup": LOOKUP, "base_url": conf.BASE})

    SRV = wsgiserver.CherryPyWSGIServer(('0.0.0.0', conf.PORT),
                                        SessionMiddleware(application,
                                                          session_opts))

    if conf.BASE.startswith("https"):
        from cherrypy.wsgiserver import ssl_pyopenssl

        SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(
            conf.SERVER_CERT, conf.SERVER_KEY, conf.CA_BUNDLE)

    LOGGER.info("RP server starting listening on port:%s" % conf.PORT)
    print "RP server starting listening on port:%s" % conf.PORT
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = client_management
#!/usr/bin/env python
import shelve
import urllib
import urlparse
import argparse
import sys
from oic.oic.provider import secret
from oic.oauth2 import rndstr

__author__ = 'rolandh'


def pack_redirect_uri(redirect_uris):
    ruri = []
    for uri in redirect_uris:
        if urlparse.urlparse(uri).fragment:
            print >> sys.stderr, "Faulty redirect uri, contains fragment"
        base, query = urllib.splitquery(uri)
        if query:
            ruri.append((base, urlparse.parse_qs(query)))
        else:
            ruri.append((base, query))

    return ruri


class CDB(object):
    def __init__(self, filename):
        self.cdb = shelve.open(filename, writeback=True)
        self.seed = rndstr(32)

    def __getitem__(self, item):
        return self.cdb[item]

    def keys(self):
        return self.cdb.keys()

    def items(self):
        return self.cdb.items()

    def create(self, redirect_uris=None, policy_uri="", logo_uri=""):
        if redirect_uris is None:
            print 'Enter redirect_uris one at the time, end with a blank line: '
            redirect_uris = []
            while True:
                redirect_uri = raw_input('?: ')
                if redirect_uri:
                    redirect_uris.append(redirect_uri)
                else:
                    break
        if not policy_uri:
            policy_uri = raw_input("Enter policy_uri or just return: ")
        if not logo_uri:
            logo_uri = raw_input("Enter logo_uri or just return: ")

        client_id = rndstr(12)
        while client_id in self.cdb:
            client_id = rndstr(12)

        client_secret = secret(self.seed, client_id)

        self.cdb[client_id] = {
            "client_secret": client_secret,
            "client_id": client_id,
            "redirect_uris": pack_redirect_uri(redirect_uris),
            "policy_uri": policy_uri,
            "logo_uri": logo_uri,
        }

        return self.cdb[client_id]

    def __delitem__(self, key):
        del self.cdb[key]

    def __setitem__(self, key, value):
        self.cdb[key] = eval(value)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', dest='list', action='store_true',
                        help="list all client_ids")
    parser.add_argument('-d', dest='delete', action='store_true',
                        help="delete the entity with the given client_id")
    parser.add_argument('-c', dest='create', action='store_true',
                        help=("create a new client, returns the stored" ""
                              "information"))
    parser.add_argument('-s', dest='show', action='store_true',
                        help=("show information connected to a specific"
                              "client_id"))
    parser.add_argument('-i', dest='client_id',
                        help="a client_id on which to do an action")
    parser.add_argument('-r', dest='replace',
                        help=("information that should replace what's there"
                              "about a specific client_id"))
    parser.add_argument(dest="filename")
    args = parser.parse_args()

    cdb = CDB(args.filename)
    if args.list:
        print cdb.keys()
    elif args.client_id:
        if args.delete:
            del cdb[args.client_id]
        elif args.show:
            print cdb[args.client_id]
        elif args.replace:
            cdb[args.client_id] = args.replace
    elif args.create:
        print cdb.create()
    elif args.delete or args.show or args.replace:
        print "You have to specify a client_id !"
########NEW FILE########
__FILENAME__ = exception
__author__ = 'rohe0002'


class PyoidcError(Exception):
    pass


class MissingAttribute(PyoidcError):
    pass


class UnsupportedMethod(PyoidcError):
    pass


class AccessDenied(PyoidcError):
    pass


class UnknownClient(PyoidcError):
    pass


class MissingParameter(PyoidcError):
    pass


class UnknownAssertionType(PyoidcError):
    pass


class ParameterError(PyoidcError):
    pass


class URIError(PyoidcError):
    pass


class InvalidRequest(PyoidcError):
    pass


class RedirectURIError(PyoidcError):
    pass


class ParseError(PyoidcError):
    pass


class FailedAuthentication(PyoidcError):
    pass


class MissingSession(PyoidcError):
    pass


class NotForMe(PyoidcError):
    pass


class UnSupported(Exception):
    pass


class MessageException(PyoidcError):
    pass


class AuthzError(PyoidcError):
    pass


########NEW FILE########
__FILENAME__ = consumer
#!/usr/bin/env python
__author__ = 'rohe0002'

import time
import logging

from hashlib import md5

from oic.utils import http_util
from oic.oauth2 import Client
from oic.oauth2 import Grant
from oic.oauth2 import rndstr
from oic.oauth2.message import *

ENDPOINTS = ["authorization_endpoint", "token_endpoint", "userinfo_endpoint",
             "check_id_endpoint", "registration_endpoint",
             "token_revokation_endpoint"]

logger = logging.getLogger(__name__)
LOG_INFO = logger.info
LOG_DEBUG = logger.debug


def stateID(url, seed):
    """The hash of the time + server path + a seed makes an unique
    SID for each session.

    :param url: The base URL for this site
    :return: The hex version of the digest
    """
    ident = md5()
    ident.update(repr(time.time()))
    ident.update(url)
    ident.update(seed)
    return ident.hexdigest()


def factory(kaka, sdb, client_id, **kwargs):
    """
    Return the right Consumer instance dependent on what's in the cookie

    :param kaka: The cookie
    :param sdb: The session database
    :param kwargs: The Consumer configuration arguments
    :return: Consumer instance or None
    """
    part = http_util.cookie_parts(client_id, kaka)
    if part is None:
        return None

    cons = Consumer(sdb, **kwargs)
    cons.restore(part[0])
    http_util.parse_cookie(client_id, cons.seed, kaka)
    return cons


class UnknownState(PyoidcError):
    pass


class TokenError(PyoidcError):
    pass


class AuthzError(PyoidcError):
    pass


class ConfigurationError(PyoidcError):
    pass


class MissingAuthenticationInfo(PyoidcError):
    pass


class Consumer(Client):
    """ An OAuth2 consumer implementation

    """
    #noinspection PyUnusedLocal
    def __init__(self, session_db, client_config=None,
                 server_info=None, authz_page="", response_type="",
                 scope="", flow_type="", password=None):
        """ Initializes a Consumer instance.

        :param session_db: Where info are kept about sessions acts like a
            dictionary
        :param client_config: Client configuration
        :param server_info: Information about the server
        :param authz_page:
        :param response_type:
        :param scope:
        :param flow_type:
        """
        if client_config is None:
            client_config = {}

        Client.__init__(self, **client_config)

        self.authz_page = authz_page
        self.response_type = response_type
        self.scope = scope
        self.flow_type = flow_type
        self.password = password

        if server_info:
            for endpoint in ENDPOINTS:
                try:
                    setattr(self, endpoint, server_info[endpoint])
                except KeyError:
                    setattr(self, endpoint, None)
        else:
            for endpoint in ENDPOINTS:
                setattr(self, endpoint, None)

        self.sdb = session_db
        self.seed = rndstr()
        self._request = None

    def update(self, sid):
        """ Updates the instance variables from something stored in the
        session database. Will not overwrite something that's already there.
        Except for the grant dictionary !!

        :param sid: Session identifier
        """
        for key, val in self.sdb[sid].items():
            _val = getattr(self, key)
            if not _val and val:
                setattr(self, key, val)
            elif key == "grant" and val:
                _tmp = {}
                for state, info in _val.items():
                    try:
                        info.join(val[state])
                    except KeyError:
                        pass

                    _tmp[state] = info
                setattr(self, key, _tmp)

        return self

    def restore(self, sid):
        """ Restores the instance variables from something stored in the
        session database.

        :param sid: Session identifier
        """
        for key, val in self.sdb[sid].items():
            setattr(self, key, val)

    def _backup(self, sid):
        """ Stores dynamic instance variable values in the session store
        under a session identifier.

        :param sid: Session identifier
        """

        res = {
            "state": self.state,
            "grant": self.grant,
            "seed": self.seed,
            "redirect_uris": self.redirect_uris,
        }

        for endpoint in ENDPOINTS:
            res[endpoint] = getattr(self, endpoint, None)

        self.sdb[sid] = res

    #noinspection PyUnusedLocal,PyArgumentEqualDefault
    def begin(self, baseurl, request, response_type="", **kwargs):
        """ Begin the OAuth2 flow

        :param baseurl: The RPs base
        :param request: The Authorization query
        :param response_type: The response type the AS should use.
            Default 'code'.
        :return: A URL to which the user should be redirected
        """

        LOG_DEBUG("- begin -")

        # Store the request and the redirect uri used
        self.redirect_uris = ["%s%s" % (baseurl, self.authz_page)]
        self._request = request

        # Put myself in the dictionary of sessions, keyed on session-id
        if not self.seed:
            self.seed = rndstr()

        sid = stateID(request, self.seed)
        self.state = sid
        self.grant[sid] = Grant(seed=self.seed)
        self._backup(sid)
        self.sdb["seed:%s" % self.seed] = sid

        if not response_type:
            if self.response_type:
                response_type = self.response_type
            else:
                self.response_type = response_type = "code"

        location = self.request_info(
            AuthorizationRequest, method="GET", scope=self.scope,
            request_args={"state": sid, "response_type": response_type})[0]

        LOG_DEBUG("Redirecting to: %s" % (location,))

        return location

    #noinspection PyUnusedLocal
    def handle_authorization_response(self, query="", **kwargs):
        """
        This is where we get redirect back to after authorization at the
        authorization server has happened.

        :param query: The query part of the request
        :return: A AccessTokenResponse instance
        """

        LOG_DEBUG("- authorization - %s flow -" % self.flow_type)
        LOG_DEBUG("QUERY: %s" % query)

        if "code" in self.response_type:
            # Might be an error response
            try:
                aresp = self.parse_response(AuthorizationResponse,
                                            info=query, sformat="urlencoded")
            except Exception, err:
                logger.error("%s" % err)
                raise

            if isinstance(aresp, Message):
                if aresp.type().endswith("ErrorResponse"):
                    raise AuthzError(aresp["error"])

            try:
                self.update(aresp["state"])
            except KeyError:
                raise UnknownState(aresp["state"])

            self._backup(aresp["state"])

            return aresp
        else:  # implicit flow
            atr = self.parse_response(AccessTokenResponse,
                                      info=query, sformat="urlencoded",
                                      extended=True)

            if isinstance(atr, Message):
                if atr.type().endswith("ErrorResponse"):
                    raise TokenError(atr["error"])

            try:
                self.update(atr["state"])
            except KeyError:
                raise UnknownState(atr["state"])

            self.seed = self.grant[self.state].seed

            return atr

    def complete(self, query="", **kwargs):
        """
        :param query: The query part of the request URL
        """

        resp = self.handle_authorization_response(query, **kwargs)

        if resp.type() == "AuthorizationResponse":
            # Go get the access token
            resp = self.do_access_token_request(state=self.state)

        return resp

    def client_auth_info(self):
        """

        """
        if self.password:
            http_args = {"client_password": self.password}
            request_args = {}
            extra_args = {}
        elif self.client_secret:
            http_args = {}
            request_args = {"client_secret": self.client_secret,
                            "client_id": self.client_id}
            extra_args = {"auth_method": "bearer_body"}
        else:
            raise MissingAuthenticationInfo("Nothing to authenticate with")

        return request_args, http_args, extra_args

    #noinspection PyUnusedLocal
    def get_access_token_request(self, **kwargs):

        request_args, http_args, extra_args = self.client_auth_info()

        url, body, ht_args, csi = self.request_info(AccessTokenRequest,
                                                    request_args=request_args,
                                                    state=self.state,
                                                    **extra_args)

        if not http_args:
            http_args = ht_args
        else:
            http_args.update(http_args)

        return url, body, http_args
########NEW FILE########
__FILENAME__ = dynreg
import logging
import urllib
import urlparse
from oic.oic import OIDCONF_PATTERN
from oic.oic.message import ProviderConfigurationResponse, AuthorizationResponse
import requests
from oic.utils.keyio import KeyJar
from oic.utils.time_util import utc_time_sans_frac
from oic.oic.provider import secret
from oic.oic.provider import RegistrationEndpoint
from oic.oic.provider import Endpoint

from oic import oauth2
from oic.oauth2 import provider
from oic.oauth2 import VerificationError
from oic.oauth2 import rndstr
from oic.oauth2 import ErrorResponse
from oic.oauth2 import UnSupported
from oic.oauth2 import Message
from oic.oauth2 import message
from oic.oauth2 import SINGLE_REQUIRED_STRING
from oic.oauth2 import OPTIONAL_LIST_OF_SP_SEP_STRINGS
from oic.oauth2 import REQUIRED_LIST_OF_STRINGS
from oic.oauth2 import OPTIONAL_LIST_OF_STRINGS
from oic.oauth2 import SINGLE_OPTIONAL_STRING
from oic.oauth2 import SINGLE_OPTIONAL_INT
from oic.exception import UnknownAssertionType
from oic.exception import PyoidcError
from oic.exception import AuthzError

from oic.utils.authn.client import AuthnFailure
from oic.utils.http_util import Unauthorized, NoContent
from oic.utils.http_util import Response
from oic.utils.http_util import BadRequest
from oic.utils.http_util import Forbidden

logger = logging.getLogger(__name__)

__author__ = 'roland'

# -----------------------------------------------------------------------------


class InvalidRedirectUri(Exception):
    pass


class MissingPage(Exception):
    pass


class ModificationForbidden(Exception):
    pass


class RegistrationRequest(Message):
    c_param = {
        "redirect_uris": REQUIRED_LIST_OF_STRINGS,
        "client_name": SINGLE_OPTIONAL_STRING,
        "client_uri": SINGLE_OPTIONAL_STRING,
        "logo_uri": SINGLE_OPTIONAL_STRING,
        "contacts": OPTIONAL_LIST_OF_STRINGS,
        "tos_uri": SINGLE_OPTIONAL_STRING,
        "policy_uri": SINGLE_OPTIONAL_STRING,
        "token_endpoint_auth_method": SINGLE_OPTIONAL_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
        "grant_types": OPTIONAL_LIST_OF_STRINGS,
        "response_types": OPTIONAL_LIST_OF_STRINGS,
        "jwks_uri": SINGLE_OPTIONAL_STRING,
        "software_id": SINGLE_OPTIONAL_STRING,
        "software_version": SINGLE_OPTIONAL_STRING,
    }

    def verify(self, **kwargs):
        if "initiate_login_uri" in self:
            assert self["initiate_login_uri"].startswith("https:")

        if "redirect_uris" in self:
            for uri in self["redirect_uris"]:
                if urlparse.urlparse(uri).fragment:
                    raise InvalidRedirectUri(
                        "redirect_uri contains fragment: %s" % uri)

        for uri in ["client_uri", "logo_uri", "tos_uri", "policy_uri"]:
            if uri in self:
                try:
                    resp = requests.request("GET", self[uri],
                                            allow_redirects=True)
                except requests.ConnectionError:
                    raise MissingPage(self[uri])

                if not resp.status_code in [200, 201]:
                    raise MissingPage(self[uri])

        if "grant_types" in self and "response_types" in self:
            for typ in self["grant_types"]:
                if typ == "authorization_code":
                    try:
                        assert "code" in self["response_types"]
                    except AssertionError:
                        self["response_types"].append("code")
                elif typ == "implicit":
                    try:
                        assert "token" in self["response_types"]
                    except AssertionError:
                        self["response_types"].append("token")

        return super(RegistrationRequest, self).verify(**kwargs)


class ClientInfoResponse(RegistrationRequest):
    c_param = RegistrationRequest.c_param.copy()
    c_param.update({
        "client_id": SINGLE_REQUIRED_STRING,
        "client_secret": SINGLE_OPTIONAL_STRING,
        "client_id_issued_at": SINGLE_OPTIONAL_INT,
        "client_secret_expires_at": SINGLE_OPTIONAL_INT,
        "registration_access_token": SINGLE_REQUIRED_STRING,
        "registration_client_uri": SINGLE_REQUIRED_STRING
    })


class ClientRegistrationError(ErrorResponse):
    c_param = ErrorResponse.c_param.copy()
    c_param.update({"state": SINGLE_OPTIONAL_STRING})
    c_allowed_values = ErrorResponse.c_allowed_values.copy()
    c_allowed_values.update({"error": ["invalid_redirect_uri",
                                       "invalid_client_metadata",
                                       "invalid_client_id"]})


class ClientUpdateRequest(RegistrationRequest):
    c_param = RegistrationRequest.c_param.copy()
    c_param.update({
        "client_id": SINGLE_REQUIRED_STRING,
        "client_secret": SINGLE_OPTIONAL_STRING,
    })


MSG = {
    "RegistrationRequest": RegistrationRequest,
    "ClientInfoResponse": ClientInfoResponse,
    "ClientRegistrationError": ClientRegistrationError,
    "ClientUpdateRequest": ClientUpdateRequest
}


def factory(msgtype):
    try:
        return MSG[msgtype]
    except KeyError:
        return message.factory(msgtype)


# -----------------------------------------------------------------------------
class ClientInfoEndpoint(Endpoint):
    etype = "clientinfo"


class Provider(provider.Provider):
    def __init__(self, name, sdb, cdb, authn_broker, authz, client_authn,
                 symkey="", urlmap=None, iv=0, default_scope="",
                 ca_bundle=None, seed="", client_authn_methods=None,
                 authn_at_registration="", client_info_url="",
                 secret_lifetime=86400):
        provider.Provider.__init__(self, name, sdb, cdb, authn_broker, authz,
                                   client_authn, symkey, urlmap, iv,
                                   default_scope, ca_bundle)

        self.endp.extend([RegistrationEndpoint, ClientInfoEndpoint])

        # dictionary of client authentication methods
        self.client_authn_methods = client_authn_methods
        if authn_at_registration:
            assert authn_at_registration in client_authn_methods
        self.authn_at_registration = authn_at_registration
        self.seed = seed
        self.client_info_url = client_info_url
        self.secret_lifetime = secret_lifetime

    # @staticmethod
    # def _uris_to_dict(uris):
    #     ruri = {}
    #     for uri in uris:
    #         base, query = urllib.splitquery(uri)
    #         if query:
    #             try:
    #                 ruri[base].append(urlparse.parse_qs(query))
    #             except KeyError:
    #                 ruri[base] = [urlparse.parse_qs(query)]
    #         else:
    #             ruri[base] = [""]
    #     return ruri
    #
    # @staticmethod
    # def _dict_to_uris(spec):
    #     _uri = []
    #     for url, qlist in spec.items():
    #         for query in qlist:
    #             if query:
    #                 _uri.append("%s?%s" % (url, query))
    #             else:
    #                 _uri.append(url)
    #     return _uri

    @staticmethod
    def _uris_to_tuples(uris):
        tup = []
        for uri in uris:
            base, query = urllib.splitquery(uri)
            if query:
                tup.append((base, query))
            else:
                tup.append((base,""))
        return tup

    @staticmethod
    def _tuples_to_uris(items):
        _uri = []
        for url, query in items:
            if query:
                _uri.append("%s?%s" % (url, query))
            else:
                _uri.append(url)
        return _uri

    def create_new_client(self, request):
        """

        :param request: The Client registration request
        :return: The client_id
        """

        _cinfo = request.to_dict()

        # create new id and secret
        _id = rndstr(12)
        while _id in self.cdb:
            _id = rndstr(12)

        _cinfo["client_id"] = _id
        _cinfo["client_secret"] = secret(self.seed, _id)
        _cinfo["client_id_issued_at"] = utc_time_sans_frac()
        _cinfo["client_secret_expires_at"] = utc_time_sans_frac() + \
            self.secret_lifetime

        # If I support client info endpoint
        if ClientInfoEndpoint in self.endp:
            _cinfo["registration_access_token"] = rndstr(32)
            _cinfo["registration_client_uri"] = "%s%s?client_id=%s" % (
                self.client_info_url, ClientInfoEndpoint.etype, _id)

        if "redirect_uris" in request:
            _cinfo["redirect_uris"] = self._uris_to_tuples(
                request["redirect_uris"])

        self.cdb[_id] = _cinfo

        return _id

    def client_info(self, client_id):
        _cinfo = self.cdb[client_id].copy()
        try:
            _cinfo["redirect_uris"] = self._tuples_to_uris(
                _cinfo["redirect_uris"])
        except KeyError:
            pass

        msg = ClientInfoResponse(**_cinfo)
        return Response(msg.to_json(), content="application/json")

    def client_info_update(self, client_id, request):
        _cinfo = self.cdb[client_id].copy()
        try:
            _cinfo["redirect_uris"] = self._tuples_to_uris(
                _cinfo["redirect_uris"])
        except KeyError:
            pass

        for key, value in request.items():
            if key in ["client_secret", "client_id"]:
                # assure it's the same
                try:
                    assert value == _cinfo[key]
                except AssertionError:
                    raise ModificationForbidden("Not allowed to change")
            else:
                _cinfo[key] = value

        for key in _cinfo.keys():
            if key in ["client_id_issued_at", "client_secret_expires_at",
                       "registration_access_token","registration_client_uri"]:
                continue
            if key not in request:
                del _cinfo[key]

        if "redirect_uris" in request:
            _cinfo["redirect_uris"] = self._uris_to_tuples(
                request["redirect_uris"])

        self.cdb[client_id] = _cinfo

    def verify_client(self, environ, areq, authn_method, client_id=""):
        """

        :param environ: WSGI environ
        :param areq: The request
        :param authn_method: client authentication method
        :return:
        """

        if not client_id:
            client_id = self.get_client_id(areq, environ["HTTP_AUTHORIZATION"])

        try:
            method = self.client_authn_methods[authn_method]
        except KeyError:
            raise UnSupported()
        return method(self).verify(environ, client_id=client_id)

    def registration_endpoint(self, request, environ, **kwargs):
        """

        :param request: The request
        :param authn: Client authentication information
        :param kwargs: extra keyword arguments
        :return: A Response instance
        """

        _request = RegistrationRequest().deserialize(request, "json")
        try:
            _request.verify()
        except InvalidRedirectUri, err:
            msg = ClientRegistrationError(error="invalid_redirect_uri",
                                          error_description="%s" % err)
            return BadRequest(msg.to_json(), content="application/json")
        except (MissingPage, VerificationError), err:
            msg = ClientRegistrationError(error="invalid_client_metadata",
                                          error_description="%s" % err)
            return BadRequest(msg.to_json(), content="application/json")

        # authenticated client
        if self.authn_at_registration:
            try:
                _ = self.verify_client(environ, _request,
                                       self.authn_at_registration)
            except (AuthnFailure, UnknownAssertionType):
                return Unauthorized()

        client_id = self.create_new_client(_request)

        return self.client_info(client_id)

    def client_info_endpoint(self, request, environ,
                                           method="GET", query="", **kwargs):
        """
        Operations on this endpoint are switched through the use of different
        HTTP methods

        :param request: The request
        :param authn: Client authentication information
        :param method: HTTP method used for the request
        :param query: The query part of the URL used, this is where the
            client_id is supposed to reside.
        :param kwargs: extra keyword arguments
        :return: A Response instance
        """

        _query = urlparse.parse_qs(query)
        try:
            _id = _query["client_id"][0]
        except KeyError:
            return BadRequest("Missing query component")

        try:
            assert _id in self.cdb
        except AssertionError:
            return Unauthorized()

        # authenticated client
        try:
            _ = self.verify_client(environ, request, "bearer_header",
                                   client_id=_id)
        except (AuthnFailure, UnknownAssertionType):
            return Unauthorized()

        if method == "GET":
            return self.client_info(_id)
        elif method == "PUT":
            try:
                _request = ClientUpdateRequest().from_json(request)
            except ValueError:
                return BadRequest()

            try:
                _request.verify()
            except InvalidRedirectUri, err:
                msg = ClientRegistrationError(error="invalid_redirect_uri",
                                              error_description="%s" % err)
                return BadRequest(msg.to_json(), content="application/json")
            except (MissingPage, VerificationError), err:
                msg = ClientRegistrationError(error="invalid_client_metadata",
                                              error_description="%s" % err)
                return BadRequest(msg.to_json(), content="application/json")

            try:
                self.client_info_update(_id, _request)
                return self.client_info(_id)
            except ModificationForbidden:
                return Forbidden()
        elif method == "DELETE":
            try:
                del self.cdb[_id]
            except KeyError:
                return Unauthorized()
            else:
                return NoContent()

    def providerinfo_endpoint(self):
        pass


RESPONSE2ERROR = {
    "ClientInfoResponse": [ClientRegistrationError],
    "ClientUpdateRequest": [ClientRegistrationError]
}


class Client(oauth2.Client):
    def __init__(self, client_id=None, ca_certs=None,
                 client_authn_method=None, keyjar=None, verify_ssl=True):
        oauth2.Client.__init__(self, client_id=client_id, ca_certs=ca_certs,
                               client_authn_method=client_authn_method,
                               keyjar=keyjar, verify_ssl=verify_ssl)
        self.allow = {}
        self.request2endpoint.update({
            "RegistrationRequest": "registration_endpoint",
            "ClientUpdateRequest": "clientinfo_endpoint"
        })
        self.registration_response = None

    def construct_RegistrationRequest(self, request=RegistrationRequest,
                                      request_args=None, extra_args=None,
                                      **kwargs):

        if request_args is None:
            request_args = {}

        return self.construct_request(request, request_args, extra_args)

    def do_client_registration(self, request=RegistrationRequest,
                               body_type="", method="GET",
                               request_args=None, extra_args=None,
                               http_args=None,
                               response_cls=ClientInfoResponse,
                               **kwargs):

        url, body, ht_args, csi = self.request_info(request, method,
                                                    request_args, extra_args,
                                                    **kwargs)

        if http_args is None:
            http_args = ht_args
        else:
            http_args.update(http_args)

        resp = self.request_and_return(url, response_cls, method, body,
                                       body_type, http_args=http_args)

        return resp

    def do_client_read_request(self, request=ClientUpdateRequest,
                               body_type="", method="GET",
                               request_args=None, extra_args=None,
                               http_args=None,
                               response_cls=ClientInfoResponse,
                               **kwargs):

        url, body, ht_args, csi = self.request_info(request, method,
                                                    request_args, extra_args,
                                                    **kwargs)

        if http_args is None:
            http_args = ht_args
        else:
            http_args.update(http_args)

        resp = self.request_and_return(url, response_cls, method, body,
                                       body_type, http_args=http_args)

        return resp

    def do_client_update_request(self, request=ClientUpdateRequest,
                                 body_type="", method="PUT",
                                 request_args=None, extra_args=None,
                                 http_args=None,
                                 response_cls=ClientInfoResponse,
                                 **kwargs):

        url, body, ht_args, csi = self.request_info(request, method,
                                                    request_args, extra_args,
                                                    **kwargs)

        if http_args is None:
            http_args = ht_args
        else:
            http_args.update(http_args)

        resp = self.request_and_return(url, response_cls, method, body,
                                       body_type, http_args=http_args)

        return resp

    def do_client_delete_request(self, request=ClientUpdateRequest,
                                 body_type="", method="DELETE",
                                 request_args=None, extra_args=None,
                                 http_args=None,
                                 response_cls=ClientInfoResponse,
                                 **kwargs):

        url, body, ht_args, csi = self.request_info(request, method,
                                                    request_args, extra_args,
                                                    **kwargs)

        if http_args is None:
            http_args = ht_args
        else:
            http_args.update(http_args)

        resp = self.request_and_return(url, response_cls, method, body,
                                       body_type, http_args=http_args)

        return resp

    def handle_provider_config(self, pcr, issuer, keys=True, endpoints=True):
        """
        Deal with Provider Config Response
        :param pcr: The ProviderConfigResponse instance
        :param issuer: The one I thought should be the issuer of the config
        :param keys: Should I deal with keys
        :param endpoints: Should I deal with endpoints, that is store them
        as attributes in self.
        """

        if "issuer" in pcr:
            _pcr_issuer = pcr["issuer"]
            if pcr["issuer"].endswith("/"):
                if issuer.endswith("/"):
                    _issuer = issuer
                else:
                    _issuer = issuer + "/"
            else:
                if issuer.endswith("/"):
                    _issuer = issuer[:-1]
                else:
                    _issuer = issuer

            try:
                _ = self.allow["issuer_mismatch"]
            except KeyError:
                try:
                    assert _issuer == _pcr_issuer
                except AssertionError:
                    raise PyoidcError(
                        "provider info issuer mismatch '%s' != '%s'" % (
                            _issuer, _pcr_issuer))

            self.provider_info[_pcr_issuer] = pcr
        else:
            _pcr_issuer = issuer

        if endpoints:
            for key, val in pcr.items():
                if key.endswith("_endpoint"):
                    setattr(self, key, val)

        if keys:
            if self.keyjar is None:
                self.keyjar = KeyJar()

            self.keyjar.load_keys(pcr, _pcr_issuer)

    def provider_config(self, issuer, keys=True, endpoints=True,
                        response_cls=ProviderConfigurationResponse,
                        serv_pattern=OIDCONF_PATTERN):
        if issuer.endswith("/"):
            _issuer = issuer[:-1]
        else:
            _issuer = issuer

        url = serv_pattern % _issuer

        pcr = None
        r = self.http_request(url)
        if r.status_code == 200:
            pcr = response_cls().from_json(r.text)
        elif r.status_code == 302:
            while r.status_code == 302:
                r = self.http_request(r.headers["location"])
                if r.status_code == 200:
                    pcr = response_cls().from_json(r.text)
                    break

        if pcr is None:
            raise PyoidcError("Trying '%s', status %s" % (url, r.status_code))

        self.handle_provider_config(pcr, issuer, keys, endpoints)

        return pcr

    def store_registration_info(self, reginfo):
        self.registration_response = reginfo
        self.client_secret = reginfo["client_secret"]
        self.client_id = reginfo["client_id"]
        self.redirect_uris = reginfo["redirect_uris"]

    def handle_registration_info(self, response):
        if response.status_code == 200:
            resp = ClientInfoResponse().deserialize(response.text, "json")
            self.store_registration_info(resp)
        else:
            err = ErrorResponse().deserialize(response.text, "json")
            raise PyoidcError("Registration failed: %s" % err.get_json())

        return resp

    def register(self, url, **kwargs):
        """
        Register the client at an OP

        :param url: The OPs registration endpoint
        :param kwargs: parameters to the registration request
        :return:
        """
        req = self.construct_RegistrationRequest(request_args=kwargs)

        headers = {"content-type": "application/json"}

        rsp = self.http_request(url, "POST", data=req.to_json(),
                                headers=headers)

        return self.handle_registration_info(rsp)

    def parse_authz_response(self, query):
        aresp = self.parse_response(AuthorizationResponse,
                                    info=query,
                                    sformat="urlencoded",
                                    keyjar=self.keyjar)
        if aresp.type() == "ErrorResponse":
            logger.info("ErrorResponse: %s" % aresp)
            raise AuthzError(aresp.error)

        logger.info("Aresp: %s" % aresp)

        return aresp
########NEW FILE########
__FILENAME__ = message
import logging
import urllib
import urlparse
import json

from jwkest import b64d
import jwkest
from jwkest.jwe import JWE
from jwkest.jwk import keyitems2keyreps
from jwkest.jws import JWS
from oic.exception import PyoidcError
from oic.exception import MessageException

logger = logging.getLogger(__name__)


class MissingRequiredAttribute(MessageException):
    def __init__(self, attr):
        Exception.__init__(self)
        self.attr = attr

    def __str__(self):
        return "Missing required attribute '%s'" % self.attr


class MissingRequiredValue(MessageException):
    pass


class TooManyValues(MessageException):
    pass


class DecodeError(MessageException):
    pass


class GrantExpired(PyoidcError):
    pass


class OldAccessToken(PyoidcError):
    pass




ERRTXT = "On '%s': %s"


def gather_keys(comb, collection, jso, target):
    try:
        _id = jso[target]
    except KeyError:
        return comb

    try:
        _col = collection[_id]
    except KeyError:
        if _id.endswith("/"):
            _id = _id[:-1]
            try:
                _col = collection[_id]
            except KeyError:
                return comb
        else:
            return comb

    try:
        for typ, keys in _col.items():
            try:
                comb[typ].update(keys)
            except KeyError:
                comb[typ] = keys
    except KeyError:
        pass

    return comb


def swap_dict(dic):
    return dict([(val, key) for key, val in dic.items()])


class Message(object):
    c_param = {}
    c_default = {}
    c_allowed_values = {}

    def __init__(self, **kwargs):
        self._dict = self.c_default.copy()
        self.lax = False
        self.from_dict(kwargs)

    def type(self):
        return self.__class__.__name__

    def parameters(self):
        return self.c_param.keys()

    def set_defaults(self):
        for key, val in self.c_default.items():
            self._dict[key] = val

    def to_urlencoded(self, lev=0):
        """
        Creates a string using the application/x-www-form-urlencoded format

        :return: A string of the application/x-www-form-urlencoded format
        """

        _spec = self.c_param
        if not self.lax:
            for attribute, (_, req, _ser, _, na) in _spec.items():
                if req and attribute not in self._dict:
                    raise MissingRequiredAttribute("%s" % attribute)

        params = []

        for key, val in self._dict.items():
            try:
                (_, req, _ser, _, null_allowed) = _spec[key]
            except KeyError:  # extra attribute
                try:
                    _key, lang = key.split("#")
                    (_, req, _ser, _deser, null_allowed) = _spec[_key]
                except (ValueError, KeyError):
                    try:
                        (_, req, _ser, _, null_allowed) = _spec['*']
                    except KeyError:
                        _ser = None
                        null_allowed = False

            if val is None and null_allowed is False:
                continue
            elif isinstance(val, basestring):
                # Should I allow parameters with "" as value ???
                params.append((key, unicode(val)))
            elif isinstance(val, list):
                if _ser:
                    params.append((key, str(_ser(val, sformat="urlencoded",
                                                 lev=lev))))
                else:
                    for item in val:
                        params.append((key, str((unicode(item)).encode('utf-8'))))
            elif isinstance(val, Message):
                params.append((key, str(_ser(val, sformat="urlencoded",
                                             lev=lev))))
            elif val is None:
                params.append((key, val))
            else:
                try:
                    params.append((key, _ser(val, lev=lev)))
                except Exception:
                    params.append((key, str(val)))

        try:
            return urllib.urlencode(params)
        except UnicodeEncodeError:
            _val = []
            for k, v in params:
                try:
                    _val.append((k, unicode.encode(v, "utf-8")))
                except TypeError:
                    _val.append((k, v))
            return urllib.urlencode(_val)

    def serialize(self, method="urlencoded", lev=0, **kwargs):
        return getattr(self, "to_%s" % method)(lev=lev, **kwargs)

    def deserialize(self, info, method="urlencoded", **kwargs):
        try:
            func = getattr(self, "from_%s" % method)
        except AttributeError, err:
            raise Exception("Unknown method (%s)" % method)
        else:
            return func(info, **kwargs)

    def from_urlencoded(self, urlencoded, **kwargs):
        """
        from a string of the application/x-www-form-urlencoded format creates
        a class instance

        :param urlencoded: The string
        :return: An instance of the cls class
        """

        #parse_qs returns a dictionary with keys and values. The values are
        #always lists even if there is only one value in the list.
        #keys only appears once.

        if isinstance(urlencoded, basestring):
            pass
        elif isinstance(urlencoded, list):
            urlencoded = urlencoded[0]

        _spec = self.c_param

        for key, val in urlparse.parse_qs(urlencoded).items():
            try:
                (typ, _, _, _deser, null_allowed) = _spec[key]
            except KeyError:
                try:
                    _key, lang = key.split("#")
                    (typ, _, _, _deser, null_allowed) = _spec[_key]
                except (ValueError, KeyError):
                    try:
                        (typ, _, _, _deser, null_allowed) = _spec['*']
                    except KeyError:
                        if len(val) == 1:
                            val = val[0]

                        self._dict[key] = val
                        continue

            if isinstance(typ, list):
                if _deser:
                    self._dict[key] = _deser(val[0], "urlencoded")
                else:
                    self._dict[key] = val
            else:  # must be single value
                if len(val) == 1:
                    if _deser:
                        self._dict[key] = _deser(val[0], "urlencoded")
                    elif isinstance(val[0], typ):
                        self._dict[key] = val[0]
                    else:
                        try:
                            self._dict[key] = typ(val[0])
                        except KeyError:
                            raise ValueError
                else:
                    raise TooManyValues

        return self

    def to_dict(self, lev=0):
        """
        Return a dictionary representation of the class

        :return: A dict
        """

        _spec = self.c_param

        _res = {}
        lev += 1
        for key, val in self._dict.items():
            try:
                (_, req, _ser, _, null_allowed) = _spec[str(key)]
            except KeyError:
                try:
                    _key, lang = key.split("#")
                    (_, req, _ser, _, null_allowed) = _spec[_key]
                except (ValueError, KeyError):
                    try:
                        (_, req, _ser, _, null_allowed) = _spec['*']
                    except KeyError:
                        _ser = None

            if _ser:
                val = _ser(val, "json", lev)

            if isinstance(val, Message):
                _res[key] = val.to_dict(lev)
            elif isinstance(val, list) and isinstance(val[0], Message):
                _res[key] = [v.to_dict(lev) for v in val]
            else:
                _res[key] = val

        return _res

    def from_dict(self, dictionary, **kwargs):
        """
        Direct translation so the value for one key might be a list or a
        single value.

        :param dictionary: The info
        :return: A class instance or raise an exception on error
        """

        _spec = self.c_param

        for key, val in dictionary.items():
            # Earlier versions of python don't like unicode strings as
            # variable names
            if val == "" or val == [""]:
                continue

            skey = str(key)
            try:

                (vtyp, req, _, _deser, null_allowed) = _spec[key]
            except KeyError:
                # might be a parameter with a lang tag
                try:
                    _key, lang = skey.split("#")
                except ValueError:
                    try:
                        (vtyp, _, _, _deser, null_allowed) = _spec['*']
                        if val is None:
                            self._dict[key] = val
                            continue
                    except KeyError:
                        self._dict[key] = val
                        continue
                else:
                    try:
                        (vtyp, req, _, _deser, null_allowed) = _spec[_key]
                    except KeyError:
                        try:
                            (vtyp, _, _, _deser, null_allowed) = _spec['*']
                            if val is None:
                                self._dict[key] = val
                                continue
                        except KeyError:
                            self._dict[key] = val
                            continue

            self._add_value(skey, vtyp, key, val, _deser, null_allowed)
        return self

    def _add_value(self, skey, vtyp, key, val, _deser, null_allowed):
#        if not val:
#            return

        if isinstance(val, list):
            if (len(val) == 0 or val[0] is None) and null_allowed is False:
                return

        if isinstance(vtyp, list):
            vtype = vtyp[0]
            if isinstance(val, vtype):
                if issubclass(vtype, Message):
                    self._dict[skey] = [val]
                elif _deser:
                    try:
                        self._dict[skey] = _deser(val, sformat="urlencoded")
                    except Exception, exc:
                        raise DecodeError(ERRTXT % (key, exc))
                else:
                    setattr(self, skey, [val])
            elif isinstance(val, list):
                if _deser:
                    try:
                        val = _deser(val, sformat="dict")
                    except Exception, exc:
                        raise DecodeError(ERRTXT % (key, exc))

                if issubclass(vtype, Message):
                    try:
                        _val = []
                        for v in val:
                            _val.append(vtype(**dict([(str(x), y) for x, y
                                                      in v.items()])))
                        val = _val
                    except Exception, exc:
                        raise DecodeError(ERRTXT % (key, exc))
                else:
                    for v in val:
                        if not isinstance(v, vtype):
                            raise DecodeError(ERRTXT % (key,
                                                        "type != %s" % vtype))

                self._dict[skey] = val
            else:
                raise DecodeError(ERRTXT % (key, "type != %s" % vtype))
        else:
            if val is None:
                self._dict[skey] = None
            elif isinstance(val, vtyp):  # Not necessary to do anything
                self._dict[skey] = val
            else:
                if _deser:
                    try:
                        val = _deser(val, sformat="dict")
                    except Exception, exc:
                        raise DecodeError(ERRTXT % (key, exc))

                if isinstance(val, basestring):
                    self._dict[skey] = val
                elif isinstance(val, list):
                    if len(val) == 1:
                        self._dict[skey] = val[0]
                    elif not len(val):
                        pass
                    else:
                        raise TooManyValues(key)
                else:
                    self._dict[skey] = val

    def to_json(self, lev=0):
        if lev:
            return self.to_dict(lev + 1)
        else:
            return json.dumps(self.to_dict(1))

    def from_json(self, txt, **kwargs):
        return self.from_dict(json.loads(txt))

    def to_jwt(self, key=None, algorithm="", lev=0):
        """
        Create a signed JWT representation of the class instance

        :param key: The signing key
        :param algorithm: The signature algorithm to use
        :return: A signed JWT
        """

        _jws = JWS(self.to_json(lev), alg=algorithm)
        return _jws.sign_compact(key)

    def _add_key(self, keyjar, item, key):
        try:
            key.extend(keyjar.get_verify_key(owner=item))
        except KeyError:
            pass

    def from_jwt(self, txt, key=None, verify=True, keyjar=None, **kwargs):
        """
        Given a signed and/or encrypted JWT, verify its correctness and then
        create a class instance from the content.

        :param txt: The JWT
        :param key: keys that might be used to decrypt and/or verify the
            signature of the JWT
        :param verify: Whether the signature should be verified or not
        :return: A class instance
        """
        if key is None and keyjar is not None:
            key = keyjar.get_verify_key(owner="")
        elif key is None:
            key = {}

        header = json.loads(b64d(str(txt.split(".")[0])))
        logger.debug("header: %s" % (header,))

        try:
            htype = header["typ"]
        except KeyError:
            htype = None

        try:
            _kid = header["kid"]
        except KeyError:
            _kid = ""

        jso = None
        if htype == "JWE" or ("alg" in header and "enc" in header):  # encrypted
            if keyjar:
                dkeys = keyjar.get_decrypt_key(owner="")
            else:
                dkeys = {}
            txt = JWE().decrypt(txt, dkeys, "private")
            try:
                jso = json.loads(txt)
            except Exception:
                pass

        # assume htype == 'JWS'
        _jws = JWS()
        if not jso:
            try:
                jso = jwkest.unpack(txt)[1]
                if isinstance(jso, basestring):
                    jso = json.loads(jso)

                if "jku" in header:
                    if not keyjar.find(header["jku"], jso["iss"]):
                        # This is really questionable
                        try:
                            if kwargs["trusting"]:
                                keyjar.add(jso["iss"], header["jku"])
                        except KeyError:
                            pass

                if _kid:
                    _key = keyjar.get_key_by_kid(_kid, jso["iss"])
                    if _key:
                        key.append(_key)

                try:
                    self._add_key(keyjar, kwargs["opponent_id"], key)
                except KeyError:
                    pass

                if verify:
                    if keyjar:
                        for ent in ["iss", "aud", "client_id"]:
                            if ent not in jso:
                                continue
                            if ent == "aud":
                                # list or basestring
                                if isinstance(jso["aud"], basestring):
                                    _aud = [jso["aud"]]
                                else:
                                    _aud = jso["aud"]
                                for _e in _aud:
                                    self._add_key(keyjar, _e, key)
                            else:
                                self._add_key(keyjar, jso[ent], key)

                    _jws.verify_compact(txt, key)
            except Exception:
                raise

        return self.from_dict(jso)

    def __str__(self):
        return self.to_urlencoded()

    def _type_check(self, typ, _allowed, val, na=False):
        if typ is basestring:
            if val not in _allowed:
                raise ValueError("Not allowed value '%s'" % val)
        elif typ is int:
            if val not in _allowed:
                raise ValueError("Not allowed value '%s'" % val)
        elif isinstance(typ, list):
            if isinstance(val, list):
                #_typ = typ[0]
                for item in val:
                    if item not in _allowed:
                        raise ValueError("Not allowed value '%s'" % val)
        elif val is None and na is False:
            raise ValueError("Not allowed value '%s'" % val)

    #noinspection PyUnusedLocal
    def verify(self, **kwargs):
        """
        Make sure all the required values are there and that the values are
        of the correct type
        """
        _spec = self.c_param
        try:
            _allowed = self.c_allowed_values
        except KeyError:
            _allowed = {}

        for (attribute, (typ, required, _, _, na)) in _spec.items():
            if attribute == "*":
                continue

            try:
                val = self._dict[attribute]
            except KeyError:
                if required:
                    raise MissingRequiredAttribute("%s" % attribute)
                continue

            if attribute not in _allowed:
                continue

            if isinstance(typ, tuple):
                _ityp = None
                for _typ in typ:
                    try:
                        self._type_check(_typ, _allowed[attribute], val)
                        _ityp = _typ
                        break
                    except ValueError:
                        pass
                if _ityp is None:
                    raise ValueError("Not allowed value '%s'" % val)
            else:
                self._type_check(typ, _allowed[attribute], val, na)

        return True

    def keys(self):
        """
        Return a list of attribute/keys/parameters of this class that has
        values.

        :return: A list of attribute names
        """
        return self._dict.keys()

    def __getitem__(self, item):
        return self._dict[item]

    def items(self):
        return self._dict.items()

    def __contains__(self, item):
        return item in self._dict

    def request(self, location, fragment_enc=False):
        if fragment_enc:
            return "%s#%s" % (location, self.to_urlencoded())
        else:
            if "?" in location:
                return "%s&%s" % (location, self.to_urlencoded())
            else:
                return "%s?%s" % (location, self.to_urlencoded())

    def __setitem__(self, key, value):
        try:
            (vtyp, req, _, _deser, na) = self.c_param[key]
            self._add_value(str(key), vtyp, key, value, _deser, na)
        except KeyError:
            self._dict[key] = value

    def __eq__(self, other):
        if not isinstance(other, Message):
            return False
        if self.type() != other.type():
            return False

        if self._dict != other._dict:
            return False

        return True

#    def __getattr__(self, item):
#        return self._dict[item]

    def __delitem__(self, key):
        del self._dict[key]

    def extra(self):
        return dict([(key, val) for key, val in
                     self._dict.items() if key not in self.c_param])

    def only_extras(self):
        l = [key for key in self._dict.keys() if key in self.c_param]
        if not l:
            return True
        else:
            return False

    def update(self, item):
        if isinstance(item, dict):
            self._dict.update(item)
        elif isinstance(item, Message):
            for key, val in item.items():
                self._dict[key] = val
        else:
            raise ValueError("Wrong type of value")

    def to_jwe(self, keys, enc, alg, lev=0):
        """

        :param keys: Dictionary, keys are key type and key is the value
        :param enc: The encryption method to use
        :param alg: Encryption algorithm
        :param lev: Used for JSON construction
        :return: A JWE
        """
        krs = keyitems2keyreps(keys)
        _jwe = JWE(self.to_json(lev), alg=alg, enc=enc)
        return _jwe.encrypt(krs)

    def from_jwe(self, msg, keys):
        krs = keyitems2keyreps(keys)
        jwe = JWE()
        _res = jwe.decrypt(msg, krs)
        return self.from_json(_res[0])

# =============================================================================


def by_schema(cls, **kwa):
    return dict([(key, val) for key, val in kwa.items() if key in cls.c_param])


def add_non_standard(msg1, msg2):
    for key, val in msg2.extra().items():
        if key not in msg1.c_param:
            msg1[key] = val

# =============================================================================


#noinspection PyUnusedLocal
def list_serializer(vals, sformat="urlencoded", lev=0):
    if sformat == "urlencoded":
        return " ".join(vals)
    else:
        return vals


#noinspection PyUnusedLocal
def list_deserializer(val, sformat="urlencoded"):
    if sformat == "urlencoded":
        if isinstance(val, basestring):
            return val.split(" ")
        elif isinstance(val, list) and len(val) == 1:
            return val[0].split(" ")
    else:
        return val


#noinspection PyUnusedLocal
def sp_sep_list_serializer(vals, sformat="urlencoded", lev=0):
    if isinstance(vals, basestring):
        return vals
    else:
        return " ".join(vals)


#noinspection PyUnusedLocal
def sp_sep_list_deserializer(val, sformat="urlencoded"):
    if isinstance(val, basestring):
        return val.split(" ")
    elif isinstance(val, list) and len(val) == 1:
        return val[0].split(" ")
    else:
        return val


#noinspection PyUnusedLocal
def json_serializer(obj, sformat="urlencoded", lev=0):
    return json.dumps(obj)


#noinspection PyUnusedLocal
def json_deserializer(txt, sformat="urlencoded"):
    return json.loads(txt)

VTYPE = 0
VREQUIRED = 1
VSER = 2
VDESER = 3
VNULLALLOWED = 4

SINGLE_REQUIRED_STRING = (basestring, True, None, None, False)
SINGLE_OPTIONAL_STRING = (basestring, False, None, None, False)
SINGLE_OPTIONAL_INT = (int, False, None, None, False)
OPTIONAL_LIST_OF_STRINGS = ([basestring], False, list_serializer,
                            list_deserializer, False)
REQUIRED_LIST_OF_STRINGS = ([basestring], True, list_serializer,
                            list_deserializer, False)
OPTIONAL_LIST_OF_SP_SEP_STRINGS = ([basestring], False, sp_sep_list_serializer,
                                   sp_sep_list_deserializer, False)
REQUIRED_LIST_OF_SP_SEP_STRINGS = ([basestring], True, sp_sep_list_serializer,
                                   sp_sep_list_deserializer, False)
SINGLE_OPTIONAL_JSON = (basestring, False, json_serializer, json_deserializer,
                        False)

REQUIRED = [SINGLE_REQUIRED_STRING, REQUIRED_LIST_OF_STRINGS,
            REQUIRED_LIST_OF_SP_SEP_STRINGS]

#
# =============================================================================
#


class ErrorResponse(Message):
    c_param = {"error": SINGLE_REQUIRED_STRING,
               "error_description": SINGLE_OPTIONAL_STRING,
               "error_uri": SINGLE_OPTIONAL_STRING}


class AuthorizationErrorResponse(ErrorResponse):
    c_param = ErrorResponse.c_param.copy()
    c_param.update({"state": SINGLE_OPTIONAL_STRING})
    c_allowed_values = ErrorResponse.c_allowed_values.copy()
    c_allowed_values.update({"error": ["invalid_request",
                                       "unathorized_client",
                                       "access_denied",
                                       "unsupported_response_type",
                                       "invalid_scope", "server_error",
                                       "temporarily_unavailable"]})


class TokenErrorResponse(ErrorResponse):
    c_allowed_values = {"error": ["invalid_request", "invalid_client",
                                  "invalid_grant", "unauthorized_client",
                                  "unsupported_grant_type",
                                  "invalid_scope"]}


class AccessTokenRequest(Message):
    c_param = {"grant_type": SINGLE_REQUIRED_STRING,
               "code": SINGLE_REQUIRED_STRING,
               "redirect_uri": SINGLE_REQUIRED_STRING,
               #"scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
               "client_id": SINGLE_OPTIONAL_STRING,
               "client_secret": SINGLE_OPTIONAL_STRING}
    c_default = {"grant_type": "authorization_code"}


class AuthorizationRequest(Message):
    c_param = {
        "response_type": REQUIRED_LIST_OF_SP_SEP_STRINGS,
        "client_id": SINGLE_REQUIRED_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
        "redirect_uri": SINGLE_OPTIONAL_STRING,
        "state": SINGLE_OPTIONAL_STRING
    }


class AuthorizationResponse(Message):
    c_param = {
        "code": SINGLE_REQUIRED_STRING,
        "state": SINGLE_OPTIONAL_STRING
    }


class AccessTokenResponse(Message):
    c_param = {
        "access_token": SINGLE_REQUIRED_STRING,
        "token_type": SINGLE_REQUIRED_STRING,
        "expires_in": SINGLE_OPTIONAL_INT,
        "refresh_token": SINGLE_OPTIONAL_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
        "state": SINGLE_OPTIONAL_STRING
    }


class NoneResponse(Message):
    c_param = {
        "state": SINGLE_OPTIONAL_STRING
    }


class ROPCAccessTokenRequest(Message):
    c_param = {
        "grant_type": SINGLE_REQUIRED_STRING,
        "username": SINGLE_OPTIONAL_STRING,
        "password": SINGLE_OPTIONAL_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS
    }


class CCAccessTokenRequest(Message):
    c_param = {
        "grant_type": SINGLE_REQUIRED_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS
    }
    c_default = {"grant_type": "client_credentials"}
    c_allowed_values = {"grant_type": ["client_credentials"]}


class RefreshAccessTokenRequest(Message):
    c_param = {
        "grant_type": SINGLE_REQUIRED_STRING,
        "refresh_token": SINGLE_REQUIRED_STRING,
        "client_id": SINGLE_REQUIRED_STRING,
        "scope": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
        "client_secret": SINGLE_OPTIONAL_STRING
    }
    c_default = {"grant_type": "refresh_token"}
    c_allowed_values = {"grant_type": ["refresh_token"]}


class TokenRevocationRequest(Message):
    c_param = {"token": SINGLE_REQUIRED_STRING}


class ResourceRequest(Message):
    c_param = {"access_token": SINGLE_OPTIONAL_STRING}

MSG = {
    "Message": Message,
    "ErrorResponse": ErrorResponse,
    "AuthorizationErrorResponse": AuthorizationErrorResponse,
    "TokenErrorResponse": TokenErrorResponse,
    "AccessTokenRequest": AccessTokenRequest,
    "AuthorizationRequest": AuthorizationRequest,
    "AuthorizationResponse": AuthorizationResponse,
    "AccessTokenResponse": AccessTokenResponse,
    "NoneResponse": NoneResponse,
    "ROPCAccessTokenRequest": ROPCAccessTokenRequest,
    "CCAccessTokenRequest": CCAccessTokenRequest,
    "RefreshAccessTokenRequest": RefreshAccessTokenRequest,
    "TokenRevocationRequest": TokenRevocationRequest,
    "ResourceRequest": ResourceRequest,
}


def factory(msgtype):
    try:
        return MSG[msgtype]
    except KeyError:
        raise Exception("Unknown message type: %s" % msgtype)

if __name__ == "__main__":
    foo = AccessTokenRequest(grant_type="authorization_code",
                             code="foo",
                             redirect_uri="http://example.com/cb")
    print foo

########NEW FILE########
__FILENAME__ = provider
#!/usr/bin/env python
import traceback
import sys
import urllib
import urlparse
from oic.utils.sdb import AccessCodeUsed

__author__ = 'rohe0002'

import base64
import logging
import os

from oic.exception import MissingParameter
from oic.exception import URIError
from oic.exception import RedirectURIError
from oic.exception import ParameterError
from oic.exception import FailedAuthentication
from oic.exception import UnknownClient

from oic.oauth2.message import AccessTokenResponse
from oic.oauth2.message import ErrorResponse
from oic.oauth2.message import AuthorizationErrorResponse
from oic.oauth2.message import AuthorizationRequest
from oic.oauth2.message import add_non_standard
from oic.oauth2.message import AuthorizationResponse
from oic.oauth2.message import NoneResponse
from oic.oauth2.message import by_schema
from oic.oauth2.message import MissingRequiredAttribute
from oic.oauth2.message import TokenErrorResponse
from oic.oauth2.message import AccessTokenRequest

from oic.utils.http_util import BadRequest
from oic.utils.http_util import CookieDealer
from oic.utils.http_util import make_cookie
from oic.utils.http_util import Redirect
from oic.utils.http_util import Response

from oic.utils.authn.user import NoSuchAuthentication
from oic.utils.authn.user import ToOld
from oic.utils.authn.user import TamperAllert

from oic.oauth2 import rndstr
from oic.oauth2 import Server

logger = logging.getLogger(__name__)
LOG_INFO = logger.info
LOG_DEBUG = logger.debug


class Endpoint(object):
    etype = ""

    def __init__(self, func):
        self.func = func

    @property
    def name(self):
        return "%s_endpoint" % self.etype

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)


class AuthorizationEndpoint(Endpoint):
    etype = "authorization"


class TokenEndpoint(Endpoint):
    etype = "token"


def code_response(**kwargs):
    _areq = kwargs["areq"]
    _scode = kwargs["scode"]
    aresp = AuthorizationResponse()
    if "state" in _areq:
        aresp["state"] = _areq["state"]
    aresp["code"] = _scode
    add_non_standard(_areq, aresp)
    return aresp


def token_response(**kwargs):
    _areq = kwargs["areq"]
    _scode = kwargs["scode"]
    _sdb = kwargs["sdb"]
    _dic = _sdb.upgrade_to_token(_scode, issue_refresh=False)

    aresp = AccessTokenResponse(**by_schema(AccessTokenResponse, **_dic))
    if "state" in _areq:
        aresp["state"] = _areq["state"]

    return aresp


#noinspection PyUnusedLocal
def none_response(**kwargs):
    _areq = kwargs["areq"]
    aresp = NoneResponse()
    if "state" in _areq:
        aresp["state"] = _areq["state"]

    return aresp


def location_url(response_type, redirect_uri, query):
    if response_type in [["code"], ["token"], ["none"]]:
        return "%s?%s" % (redirect_uri, query)
    else:
        return "%s#%s" % (redirect_uri, query)


class Provider(object):
    endp = [AuthorizationEndpoint, TokenEndpoint]

    def __init__(self, name, sdb, cdb, authn_broker, authz, client_authn,
                 symkey="", urlmap=None, iv=0, default_scope="",
                 ca_bundle=None, verify_ssl=True, default_acr=""):
        self.name = name
        self.sdb = sdb
        self.cdb = cdb
        self.server = Server(ca_certs=ca_bundle, verify_ssl=verify_ssl)

        self.authn_broker = authn_broker
        if authn_broker is None:
            # default cookie function
            self.cookie_func = CookieDealer(srv=self).create_cookie
        else:
            self.cookie_func = self.authn_broker[0][0].create_cookie
            for item in self.authn_broker:
                item.srv = self

        self.authz = authz
        self.client_authn = client_authn
        self.symkey = symkey
        self.seed = rndstr()
        self.iv = iv or os.urandom(16)
        self.cookie_name = "pyoidc"
        self.default_scope = default_scope
        self.sso_ttl = 0
        self.default_acr = default_acr

        if urlmap is None:
            self.urlmap = {}
        else:
            self.urlmap = urlmap

        self.response_type_map = {
            "code": code_response,
            "token": token_response,
            "none": none_response,
        }

    def endpoints(self):
        for endp in self.endp:
            yield endp(None).name

    def subset(self, li1, li2):
        """
        Verify that all items in li1 appears in li2

        :param li1: List 1
        :param li2: List 2
        :return: True if all items in li1 appears in li2
        """
        for item in li1:
            try:
                assert item in li2
            except AssertionError:
                return False
        return True

    def get_client_id(self, req, authn):
        """
        Verify the client and return the client id

        :param req: The request
        :param authn: Authentication information from the HTTP header
        :return:
        """

        logger.debug("REQ: %s" % req.to_dict())
        if authn:
            if authn.startswith("Basic "):
                logger.debug("Basic auth")
                (_id, _secret) = base64.b64decode(authn[6:]).split(":")
                if _id not in self.cdb:
                    logger.debug("Unknown client_id")
                    raise FailedAuthentication("Unknown client_id")
                else:
                    try:
                        assert _secret == self.cdb[_id]["client_secret"]
                    except AssertionError:
                        logger.debug("Incorrect secret")
                        raise FailedAuthentication("Incorrect secret")
            else:
                try:
                    assert authn[:6].lower() == "bearer"
                    logger.debug("Bearer auth")
                    _token = authn[7:]
                except AssertionError:
                    raise FailedAuthentication("AuthZ type I don't know")

                try:
                    _id = self.cdb[_token]
                except KeyError:
                    logger.debug("Unknown access token")
                    raise FailedAuthentication("Unknown access token")
        else:
            try:
                _id = req["client_id"]
                if _id not in self.cdb:
                    logger.debug("Unknown client_id")
                    raise FailedAuthentication("Unknown client_id")
            except KeyError:
                raise FailedAuthentication("Missing client_id")

        return _id

    def authn_reply(self, areq, aresp, bsid, **kwargs):
        """

        :param areq: Authorization Request
        :param aresp: Authorization Response
        :param bsid: Session id
        :param kwargs: Additional keyword args
        :return:
        """
        if "redirect_uri" in areq:
            # TODO verify that the uri is reasonable
            redirect_uri = areq["redirect_uri"]
        else:
            redirect_uri = self.urlmap[areq["client_id"]]

        location = location_url(areq["response_type"], redirect_uri,
                                aresp.to_urlencoded())

        LOG_DEBUG("Redirected to: '%s' (%s)" % (location, type(location)))

        # set cookie containing session ID

        cookie = make_cookie(self.cookie_name, bsid, self.seed)

        return Redirect(str(location), headers=[cookie])

    def authn_response(self, areq, **kwargs):
        """

        :param areq: Authorization request
        :param kwargs: Extra keyword arguments
        :return:
        """
        scode = kwargs["code"]
        areq["response_type"].sort()
        _rtype = " ".join(areq["response_type"])
        return self.response_type_map[_rtype](areq=areq, scode=scode,
                                              sdb=self.sdb)

    @staticmethod
    def input(query="", post=None):
        # Support GET and POST
        if query:
            return query
        elif post:
            return post
        else:
            raise MissingParameter("No input")

    @staticmethod
    def _error_response(error, descr=None):
        logger.error("%s" % error)
        response = ErrorResponse(error=error, error_description=descr)
        return Response(response.to_json(), content="application/json",
                        status="400 Bad Request")

    @staticmethod
    def _error(error, descr=None):
        response = ErrorResponse(error=error, error_description=descr)
        return Response(response.to_json(), content="application/json",
                        status="400 Bad Request")

    @staticmethod
    def _authz_error(error, descr=None):

        response = AuthorizationErrorResponse(error=error)
        if descr:
            response["error_description"] = descr

        return Response(response.to_json(), content="application/json",
                        status="400 Bad Request")

    @staticmethod
    def _redirect_authz_error(error, redirect_uri, descr=None):
        err = ErrorResponse(error=error)
        if descr:
            err["error_description"] = descr
        location = err.request(redirect_uri)
        return Redirect(location)

    def _verify_redirect_uri(self, areq):
        """
        MUST NOT contain a fragment
        MAY contain query component

        :return: An error response if the redirect URI is faulty otherwise
            None
        """
        try:
            _redirect_uri = urlparse.unquote(areq["redirect_uri"])

            part = urlparse.urlparse(_redirect_uri)
            if part.fragment:
                raise URIError("Contains fragment")

            (_base, _query) = urllib.splitquery(_redirect_uri)
            if _query:
                _query = urlparse.parse_qs(_query)

            match = False
            for regbase, rquery in self.cdb[areq["client_id"]]["redirect_uris"]:
                if _base == regbase or _redirect_uri.startswith(regbase):
                    # every registered query component must exist in the
                    # redirect_uri
                    if rquery:
                        for key, vals in rquery.items():
                            assert key in _query
                            for val in vals:
                                assert val in _query[key]
                    match = True
                    break
            if not match:
                raise RedirectURIError("Doesn't match any registered uris")
            # ignore query components that are not registered
            return None
        except Exception, err:
            logger.error("Faulty redirect_uri: %s" % areq["redirect_uri"])
            try:
                _cinfo = self.cdb[areq["client_id"]]
            except KeyError:
                logger.info("Unknown client: %s" % areq["client_id"])
                raise UnknownClient(areq["client_id"])
            else:
                logger.info("Registered redirect_uris: %s" % _cinfo)
                raise RedirectURIError("Faulty redirect_uri: %s" % err)

    def get_redirect_uri(self, areq):
        """ verify that the redirect URI is reasonable

        :param areq: The Authorization request
        :return: Tuple of (redirect_uri, Response instance)
            Response instance is not None of matching redirect_uri failed
        """
        if 'redirect_uri' in areq:
            self._verify_redirect_uri(areq)
            uri = areq["redirect_uri"]
        else:
            raise ParameterError(
                "Missing redirect_uri and more than one or none registered")

        return uri

    def pick_auth(self, areq, comparision_type=""):
        """

        :param areq: AuthorizationRequest instance
        :param comparision_type: How to pick the authentication method
        :return: An authentication method and its authn class ref
        """
        if comparision_type == "any":
            return self.authn_broker[0]

        try:
            if len(self.authn_broker) == 1:
                    return self.authn_broker[0]
            else:
                try:
                    _values = areq["acr_values"]
                except KeyError:
                    _values = self.default_acr

                if isinstance(_values, basestring):
                    _values = [_values]

                if not comparision_type:
                    comparision_type = "exact"

                for _acr in _values:
                    res = self.authn_broker.pick(_acr, comparision_type)
                    if res:
                        #Return the best guess by pick.
                        return res[0]
        except KeyError:
            pass

        # return the best I have
        return None, None

    def authorization_endpoint(self, request="", cookie="", authn="", **kwargs):
        """ The AuthorizationRequest endpoint

        :param request: The client request
        """

        logger.debug("Request: '%s'" % request)
        # Same serialization used for GET and POST
        try:
            areq = self.server.parse_authorization_request(query=request)
        except MissingRequiredAttribute, err:
            logger.debug("%s" % err)
            return self._error("invalid_request", "%s" % err)
        except KeyError:
            areq = AuthorizationRequest().deserialize(request, "urlencoded")
            # verify the redirect_uri
            try:
                self.get_redirect_uri(areq)
            except (RedirectURIError, ParameterError), err:
                return self._error("invalid_request", "%s" % err)
        except Exception, err:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            logger.debug("Bad request: %s (%s)" % (err, err.__class__.__name__))
            return BadRequest("%s" % err)

        if not areq:
            logger.debug("No AuthzRequest")
            return self._error("invalid_request", "No parsable AuthzRequest")

        logger.debug("AuthzRequest: %s" % (areq.to_dict(),))
        try:
            redirect_uri = self.get_redirect_uri(areq)
        except (RedirectURIError, ParameterError), err:
            return self._error("invalid_request", "%s" % err)
        except UnknownClient, err:
            return self._error("unauthorized_client", "%s" % err)

        try:
            # verify that the request message is correct
            areq.verify()
        except (MissingRequiredAttribute, ValueError), err:
            return self._redirect_authz_error("invalid_request", redirect_uri,
                                              "%s" % err)

        # Check if the person is already authenticated
        a_args = {}
        if cookie:
            logger.debug("Cookie: %s" % cookie)
            a_args["cookie"] = cookie
        if authn:
            try:
                a_args["authorization"] = authn
            except KeyError:
                pass

        # Pick authentication method
        _authn, acr = self.pick_auth(areq=areq)

        if authn is None:
            return self._redirect_authz_error("invalid_request", redirect_uri)

        try:
            identity = _authn.authenticated_as(**a_args)
        except (NoSuchAuthentication, ToOld, TamperAllert):
            identity = None

        authn_args = {"query": request}

        cinfo = self.cdb[areq["client_id"]]
        for attr in ["policy_uri", "logo_uri"]:
            try:
                authn_args[attr] = cinfo[attr]
            except KeyError:
                pass

        # To authenticate or Not
        if identity is None:  # No!
            if "prompt" in areq and "none" in areq["prompt"]:
                # Need to authenticate but not allowed
                return self._redirect_authz_error("login_required",
                                                  redirect_uri)
            else:
                # Do authentication
                return _authn(**authn_args)
        else:
            user = identity["uid"]

        # If I get this far the person is already authenticated
        logger.debug("- authenticated -")
        logger.debug("AREQ keys: %s" % areq.keys())

        try:
            oidc_req = areq["request"]
        except KeyError:
            oidc_req = None

        skey = self.sdb.create_authz_session(user, areq, oidreq=oidc_req)

        # Now about the authorization step.
        try:
            permissions = self.authz.permissions(cookie)
            if not permissions:
                return self.authz(user, skey)
        except (ToOld, TamperAllert):
            return self.authz(user, areq, skey)

        return self.authz_part2(user, areq, skey, permissions, _authn)

    def authz_part2(self, user, areq, skey, permission=None, authn=None,
                    **kwargs):
        """
        After the authentication this is where you should end up

        :param user:
        :param areq: The Authorization Request
        :param skey: Session key
        :param permission: A permission specification
        :param authn: The Authentication Method used
        :param kwargs: possible other parameters
        :return: A redirect to the redirect_uri of the client
        """
        _log_debug = logger.debug
        _log_debug("- in authenticated() -")

        self.sdb.update(skey, "auz", permission)

        _log_debug("response type: %s" % areq["response_type"])

        # create the response
        aresp = AuthorizationResponse()
        try:
            aresp["state"] = areq["state"]
        except KeyError:
            pass

        if "response_type" in areq and \
                len(areq["response_type"]) == 1 and \
                "none" in areq["response_type"]:
            pass
        else:
            #if self.sdb.is_revoked(sinfo):
            #    return self._error(error="access_denied",
            #                       descr="Token is revoked")

            try:
                aresp["scope"] = areq["scope"]
            except KeyError:
                pass

            _log_debug("_dic: %s" % self.sdb[skey])

            rtype = set(areq["response_type"][:])
            if "code" in areq["response_type"]:
                #if issue_new_code:
                #    scode = self.sdb.duplicate(_sinfo)
                #    _sinfo = self.sdb[scode]

                _code = aresp["code"] = self.sdb.get_token(skey)
                rtype.remove("code")
            else:
                _code = self.sdb[skey]["code"]
                self.sdb.update(skey, "code", None)

            if "token" in rtype:
                self.sdb.upgrade_to_token(skey, issue_refresh=False,
                                          access_grant=_code)
                atr = AccessTokenResponse(**aresp.to_dict())
                aresp = atr
                _cont = self.sdb[skey]
                _log_debug("_dic: %s" % _cont)
                for key, val in _cont.items():
                    if key in aresp.parameters() and val is not None:
                        aresp[key] = val

                rtype.remove("token")

            if len(rtype):
                return BadRequest("Unknown response type")

        try:
            redirect_uri = self.get_redirect_uri(areq)
        except (RedirectURIError, ParameterError), err:
            return BadRequest("%s" % err)

        #self.sdb.store_session(skey)

        # so everything went well should set a SSO cookie
        headers = [authn.create_cookie(user, typ="sso", ttl=self.sso_ttl)]
        location = aresp.request(redirect_uri)
        logger.debug("Redirected to: '%s' (%s)" % (location, type(location)))
        return Redirect(str(location), headers=headers)

    def token_scope_check(self, areq, info):
        """ Not implemented here """
        # if not self.subset(areq["scope"], _info["scope"]):
        #     LOG_INFO("Asked for scope which is not subset of previous defined")
        #     err = TokenErrorResponse(error="invalid_scope")
        #     return Response(err.to_json(), content="application/json")
        return None

    def token_endpoint(self, authn="", **kwargs):
        """
        This is where clients come to get their access tokens
        """

        _sdb = self.sdb

        LOG_DEBUG("- token -")
        body = kwargs["request"]
        LOG_DEBUG("body: %s" % body)

        areq = AccessTokenRequest().deserialize(body, "urlencoded")

        try:
            client = self.client_authn(self, areq, authn)
        except FailedAuthentication, err:
            err = TokenErrorResponse(error="unathorized_client",
                                     error_description="%s" % err)
            return Response(err.to_json(), content="application/json",
                            status="401 Unauthorized")

        LOG_DEBUG("AccessTokenRequest: %s" % areq)

        try:
            assert areq["grant_type"] == "authorization_code"
        except AssertionError:
            err = TokenErrorResponse(error="invalid_request",
                                     error_description="Wrong grant type")
            return Response(err.to_json(), content="application/json",
                            status="401 Unauthorized")


        # assert that the code is valid
        _info = _sdb[areq["code"]]

        resp = self.token_scope_check(areq, _info)
        if resp:
            return resp

        # If redirect_uri was in the initial authorization request
        # verify that the one given here is the correct one.
        if "redirect_uri" in _info:
            assert areq["redirect_uri"] == _info["redirect_uri"]

        try:
            _tinfo = _sdb.upgrade_to_token(areq["code"])
        except AccessCodeUsed:
            err = TokenErrorResponse(error="invalid_grant",
                                     error_description="Access grant used")
            return Response(err.to_json(), content="application/json",
                            status="401 Unauthorized")


        LOG_DEBUG("_tinfo: %s" % _tinfo)
            
        atr = AccessTokenResponse(**by_schema(AccessTokenResponse, **_tinfo))

        LOG_DEBUG("AccessTokenResponse: %s" % atr)

        return Response(atr.to_json(), content="application/json")

    def verify_endpoint(self, request="", cookie=None, **kwargs):
        _req = urlparse.parse_qs(request)
        try:
            areq = urlparse.parse_qs(_req["query"][0])
        except KeyError:
            return BadRequest()

        authn, acr = self.pick_auth(areq=areq)
        kwargs["cookie"] = cookie
        return authn.verify(_req, **kwargs)

########NEW FILE########
__FILENAME__ = claims_provider
from oic.utils.keyio import KeyJar

__author__ = 'rohe0002'

import logging
from oic.oauth2 import rndstr

from oic.oic.message import OpenIDSchema
from oic.oic.message import Claims

from oic.oic import Server as OicServer
from oic.oic import Client
from oic.oic import REQUEST2ENDPOINT
from oic.oic import RESPONSE2ERROR

from oic.oic.provider import Provider
from oic.oic.provider import Endpoint

from oic.oauth2.message import Message
from oic.oauth2.message import SINGLE_REQUIRED_STRING
from oic.oauth2.message import SINGLE_OPTIONAL_STRING
from oic.oauth2.message import REQUIRED_LIST_OF_STRINGS

from oic.utils.http_util import Response
from oic.utils.authn.client import bearer_auth

# Used in claims.py
#from oic.oic.message import RegistrationRequest
#from oic.oic.message import RegistrationResponse

logger = logging.getLogger(__name__)


class UserClaimsRequest(Message):
    c_param = {"sub": SINGLE_REQUIRED_STRING,
               "client_id": SINGLE_REQUIRED_STRING,
               "client_secret": SINGLE_REQUIRED_STRING,
               "claims_names": REQUIRED_LIST_OF_STRINGS}


class UserClaimsResponse(Message):
    c_param = {"claims_names": REQUIRED_LIST_OF_STRINGS,
               "jwt": SINGLE_OPTIONAL_STRING,
               "endpoint": SINGLE_OPTIONAL_STRING,
               "access_token": SINGLE_OPTIONAL_STRING}

#    def verify(self, **kwargs):
#        if "jwt" in self:
#            # Try to decode the JWT, checks the signature
#            args = dict([(claim, kwargs[claim]) for claim in ["key","keyjar"] \
#                            if claim in kwargs])
#            try:
#                item = OpenIDSchema().from_jwt(str(self["jwt"]), **args)
#            except Exception, _err:
#                raise
#
#            if not item.verify(**kwargs):
#                return False
#
#        return super(self.__class__, self).verify(**kwargs)


class UserInfoClaimsRequest(Message):
    c_param = {"access_token": SINGLE_REQUIRED_STRING}


class OICCServer(OicServer):

    def parse_user_claims_request(self, info, sformat="urlencoded"):
        return self._parse_request(UserClaimsRequest, info, sformat)

    def parse_userinfo_claims_request(self, info, sformat="urlencoded"):
        return self._parse_request(UserInfoClaimsRequest, info, sformat)


class ClaimsServer(Provider):

    def __init__(self, name, sdb, cdb, userinfo, client_authn, urlmap=None,
                 ca_certs="", keyjar=None, hostname="", dist_claims_mode=None):
        Provider.__init__(self, name, sdb, cdb, None, userinfo, None,
                          client_authn, "", urlmap, ca_certs, keyjar,
                          hostname)

        if keyjar is None:
            keyjar = KeyJar(ca_certs)

        for cid, _dic in cdb.items():
            try:
                keyjar.add_symmetric(cid, _dic["client_secret"], ["sig", "ver"])
            except KeyError:
                pass

        self.srvmethod = OICCServer(keyjar=keyjar)
        self.dist_claims_mode = dist_claims_mode
        self.info_store = {}
        self.claims_userinfo_endpoint = ""

    def _aggregation(self, info):

        jwt_key = self.keyjar.get_signing_key()
        cresp = UserClaimsResponse(jwt=info.to_jwt(key=jwt_key,
                                                   algorithm="RS256"),
                                   claims_names=info.keys())

        logger.info("RESPONSE: %s" % (cresp.to_dict(),))
        return cresp

    #noinspection PyUnusedLocal
    def _distributed(self, info):
        # store the user info so it can be accessed later
        access_token = rndstr()
        self.info_store[access_token] = info
        return UserClaimsResponse(endpoint=self.claims_userinfo_endpoint,
                                  access_token=access_token,
                                  claims_names=info.keys())

    #noinspection PyUnusedLocal
    def do_aggregation(self, info, uid):
        return self.dist_claims_mode.aggregate(uid, info)

    #noinspection PyUnusedLocal
    def claims_endpoint(self, request, http_authz, *args):
        _log_info = logger.info

        ucreq = self.srvmethod.parse_user_claims_request(request)

        _log_info("request: %s" % ucreq)

        try:
            resp = self.client_authn(self, ucreq, http_authz)
        except Exception, err:
            _log_info("Failed to verify client due to: %s" % err)
            resp = False

        if "claims_names" in ucreq:
            args = dict([(n, {"optional": True}) for n in
                         ucreq["claims_names"]])
            uic = Claims(**args)
        else:
            uic = None

        _log_info("User info claims: %s" % uic)

        #oicsrv, userdb, subject, client_id="", user_info_claims=None
        info = self.userinfo(ucreq["sub"], user_info_claims=uic,
                             client_id=ucreq["client_id"])

        _log_info("User info: %s" % info)

        # Convert to message format
        info = OpenIDSchema(**info)

        if self.do_aggregation(info, ucreq["sub"]):
            cresp = self._aggregation(info)
        else:
            cresp = self._distributed(info)

        _log_info("response: %s" % cresp.to_dict())

        return Response(cresp.to_json(), content="application/json")

    def claims_info_endpoint(self, request, authn):
        _log_info = logger.info

        _log_info("Claims_info_endpoint query: '%s'" % request)

        ucreq = self.srvmethod.parse_userinfo_claims_request(request)
        #_log_info("request: %s" % ucreq)

        # Bearer header or body
        access_token = bearer_auth(ucreq, authn)
        uiresp = OpenIDSchema(**self.info_store[access_token])

        _log_info("returning: %s" % uiresp.to_dict())
        return Response(uiresp.to_json(), content="application/json")


class ClaimsClient(Client):

    def __init__(self, client_id=None, ca_certs=""):

        Client.__init__(self, client_id, ca_certs)

        self.request2endpoint = REQUEST2ENDPOINT.copy()
        self.request2endpoint["UserClaimsRequest"] = "userclaims_endpoint"
        self.response2error = RESPONSE2ERROR.copy()
        self.response2error["UserClaimsResponse"] = ["ErrorResponse"]

    #noinspection PyUnusedLocal
    def construct_UserClaimsRequest(self, request=UserClaimsRequest,
                                    request_args=None, extra_args=None,
                                    **kwargs):

        return self.construct_request(request, request_args, extra_args)

    def do_claims_request(self, request=UserClaimsRequest,
                          request_resp=UserClaimsResponse,
                          body_type="json",
                          method="POST", request_args=None, extra_args=None,
                          http_args=None):

        url, body, ht_args, csi = self.request_info(request, method=method,
                                                    request_args=request_args,
                                                    extra_args=extra_args)

        if http_args is None:
            http_args = ht_args
        else:
            http_args.update(http_args)

#        http_args = self.init_authentication_method(csi, "bearer_header",
#                                                    request_args)

        return self.request_and_return(url, request_resp, method, body,
                                       body_type, extended=False,
                                       http_args=http_args,
                                       key=self.keyjar.verify_keys(
                                           self.keyjar.match_owner(url)))


class UserClaimsEndpoint(Endpoint):
    etype = "userclaims"


class UserClaimsInfoEndpoint(Endpoint):
    etype = "userclaimsinfo"

########NEW FILE########
__FILENAME__ = consumer
#!/usr/bin/env python
import logging

__author__ = 'rohe0002'

import time
import os.path

from hashlib import md5

from oic.exception import PyoidcError
from oic.utils import http_util

from oic.oic import Client
from oic.oic import ENDPOINTS

from oic.oic.message import Claims, ClaimsRequest
from oic.oic.message import AuthorizationRequest
from oic.oic.message import AuthorizationResponse
from oic.oic.message import AccessTokenResponse

from oic.oauth2 import Grant
from oic.oauth2 import rndstr

from oic.oauth2.consumer import TokenError
from oic.oauth2.consumer import AuthzError
from oic.oauth2.consumer import UnknownState


logger = logging.getLogger(__name__)


def stateID(url, seed):
    """The hash of the time + server path + a seed makes an unique
    SID for each session.

    :param url: The base URL for this site
    :return: The hex version of the digest
    """
    ident = md5()
    ident.update(repr(time.time()))
    ident.update(url)
    ident.update(seed)
    return ident.hexdigest()


def factory(kaka, sdb, config):
    """
    Return the right Consumer instance dependent on what's in the cookie

    :param kaka: The cookie
    :param sdb: The session database
    :param config: The common Consumer configuration
    :return: Consumer instance or None
    """
    part = http_util.cookie_parts(config["name"], kaka)
    if part is None:
        return None

    cons = Consumer(sdb, config=config)
    cons.restore(part[0])
    http_util.parse_cookie(config["name"], cons.seed, kaka)
    return cons


def build_userinfo_claims(claims, sformat="signed", locale="us-en"):
    """
    config example::

        "userinfo":{
            "name": {"essential": true},
            "nickname": null,
            "email": {"essential": true},
            "email_verified": {"essential": true},
            "picture": null
        }

    """
    return Claims(format=sformat, **claims)


def clean_response(aresp):
    """
    Creates a new instance with only the standard attributes

    :param aresp: The original AccessTokenResponse
    :return: An AccessTokenResponse instance
    """
    atr = AccessTokenResponse()
    for prop in atr.parameters():
        try:
            atr[prop] = aresp[prop]
        except KeyError:
            pass

    return atr

IGNORE = ["request2endpoint", "response2error", "grant_class", "token_class"]

CONSUMER_PREF_ARGS = [
    "token_endpoint_auth_method",
    "subject_type",
    "require_signed_request_object",
    "userinfo_signed_response_algs",
    "userinfo_encrypted_response_alg",
    "userinfo_encrypted_response_enc",
    "userinfo_encrypted_response_int",
    "id_token_signed_response_algs",
    "id_token_encrypted_response_alg",
    "id_token_encrypted_response_enc",
    "id_token_encrypted_response_int",
    "request_object_signing_alg",
    "request_object_encryption_alg",
    "request_object_encryption_enc",
    "default_max_age",
    "require_auth_time",
    "default_acr_values"
]


class Consumer(Client):
    """ An OpenID Connect consumer implementation

    """
    #noinspection PyUnusedLocal
    def __init__(self, session_db, config, client_config=None,
                 server_info=None, debug=False, client_prefs=None):
        """ Initializes a Consumer instance.

        :param session_db: Where info are kept about sessions
        :param config: Configuration of the consumer
        :param client_config: Client configuration
        :param server_info: Information about the server
        :param client_prefs: Run time preferences, which are chosen
            depends on what the server can do.
        """
        if client_config is None:
            client_config = {}

        Client.__init__(self, **client_config)

        self.config = config
        if config:
            try:
                self.debug = config["debug"]
            except KeyError:
                self.debug = 0

        if server_info:
            for endpoint in ENDPOINTS:
                try:
                    setattr(self, endpoint, server_info[endpoint])
                except KeyError:
                    setattr(self, endpoint, "")

        self.sdb = session_db
        self.debug = debug
        self.seed = ""
        self.nonce = ""
        self.request_filename = ""
        self.user_info = None
        self.registration_expires_at = 0
        self.secret_type = "Bearer"

    def update(self, sid):
        """ Updates the instance variables from something stored in the
        session database. Will not overwrite something that's already there.
        Except for the grant dictionary !!

        :param sid: Session identifier
        """
        for key, val in self.sdb[sid].items():
            _val = getattr(self, key)
            if not _val and val:
                setattr(self, key, val)
            elif key == "grant" and val:
                val.update(_val)
                setattr(self, key, val)

    def restore(self, sid):
        """ Restores the instance variables from something stored in the
        session database.

        :param sid: Session identifier
        """
        for key, val in self.sdb[sid].items():
            setattr(self, key, val)

    def dictionary(self):
        return dict([(k, v) for k, v in
                     self.__dict__.items() if k not in IGNORE])

    def _backup(self, sid):
        """ Stores instance variable values in the session store under a
        session identifier.

        :param sid: Session identifier
        """
        self.sdb[sid] = self.dictionary()

    #noinspection PyUnusedLocal,PyArgumentEqualDefault
    def begin(self, scope="", response_type="", use_nonce=False, path="",
              requrl="", **kwargs):
        """ Begin the OIDC flow

        :param scope: Defines which user info claims is wanted
        :param response_type: Controls the parameters returned in the
            response from the Authorization Endpoint
        :param use_nonce: If not implicit flow nonce is optional.
            This defines if it should be used anyway.
        :param path: The path part of the redirect URL
        :param requrl: Request URL
        :return: A URL to which the user should be redirected
        """
        _log_info = logger.info

        if self.debug:
            _log_info("- begin -")

        _page = self.config["authz_page"]
        if not path.endswith("/"):
            if _page.startswith("/"):
                self.redirect_uris = [path + _page]
            else:
                self.redirect_uris = ["%s/%s" % (path, _page)]
        else:
            if _page.startswith("/"):
                self.redirect_uris = [path + _page[1:]]
            else:
                self.redirect_uris = ["%s/%s" % (path, _page)]

        # Put myself in the dictionary of sessions, keyed on session-id
        if not self.seed:
            self.seed = rndstr()

        if not scope:
            scope = self.config["scope"]
        if not response_type:
            response_type = self.config["response_type"]

        sid = stateID(path, self.seed)
        self.state = sid
        self.grant[sid] = Grant(seed=self.seed)

        self._backup(sid)
        self.sdb["seed:%s" % self.seed] = sid

        # Store the request and the redirect uri used
        self._request = requrl

        args = {
            "client_id": self.client_id,
            "state": sid,
            "response_type": response_type,
            "scope": scope,
        }

        # nonce is REQUIRED in implicit flow,
        # OPTIONAL on code flow.
        if "token" in response_type or use_nonce:
            self.nonce = rndstr(12)
            args["nonce"] = self.nonce

        if "max_age" in self.config:
            args["max_age"] = self.config["max_age"]

        _claims = None
        if "user_info" in self.config:
            _claims = ClaimsRequest(
                userinfo=Claims(**self.config["user_info"]))
        if "id_token" in self.config:
            if _claims:
                _claims["id_token"] = Claims(**self.config["id_token"])
            else:
                _claims = ClaimsRequest(
                    id_token=Claims(**self.config["id_token"]))

        if _claims:
            args["claims"] = _claims

        if "request_method" in self.config:
            areq = self.construct_AuthorizationRequest(
                request_args=args, extra_args=None,
                request_param="request")

            if self.config["request_method"] == "file":
                id_request = areq["request"]
                del areq["request"]
                _filedir = self.config["temp_dir"]
                _webpath = self.config["temp_path"]
                _name = rndstr(10)
                filename = os.path.join(_filedir, _name)
                while os.path.exists(filename):
                    _name = rndstr(10)
                    filename = os.path.join(_filedir, _name)
                fid = open(filename, mode="w")
                fid.write(id_request)
                fid.close()
                _webname = "%s%s%s" % (path, _webpath, _name)
                areq["request_uri"] = _webname
                self.request_uri = _webname
                self._backup(sid)
        else:
            if "userinfo_claims" in args:  # can only be carried in an IDRequest
                raise PyoidcError("Need a request method")

            areq = self.construct_AuthorizationRequest(AuthorizationRequest,
                                                       request_args=args)

        location = areq.request(self.authorization_endpoint)

        if self.debug:
            _log_info("Redirecting to: %s" % location)

        return location

    #noinspection PyUnusedLocal
    def parse_authz(self, query="", **kwargs):
        """
        This is where we get redirect back to after authorization at the
        authorization server has happened.

        :return: A AccessTokenResponse instance
        """

        _log_info = logger.info
        logger.debug("- authorization -")

        if not query:
            return http_util.BadRequest("Missing query")

        _log_info("response: %s" % query)
        
        if "code" in self.config["response_type"]:
            # Might be an error response
            _log_info("Expect Authorization Response")
            aresp = self.parse_response(AuthorizationResponse,
                                        info=query,
                                        sformat="urlencoded",
                                        keyjar=self.keyjar)
            if aresp.type() == "ErrorResponse":
                _log_info("ErrorResponse: %s" % aresp)
                raise AuthzError(aresp.error)

            _log_info("Aresp: %s" % aresp)

            _state = aresp["state"]
            try:
                self.update(_state)
            except KeyError:
                raise UnknownState(_state)

            self.redirect_uris = [self.sdb[_state]["redirect_uris"]]

            # May have token and id_token information too
            if "access_token" in aresp:
                atr = clean_response(aresp)
                self.access_token = atr
                # update the grant object
                self.get_grant(state=_state).add_token(atr)
            else:
                atr = None

            self._backup(_state)

            try:
                idt = aresp["id_token"]
            except KeyError:
                idt = None

            return aresp, atr, idt
        else:  # implicit flow
            _log_info("Expect Access Token Response")
            atr = self.parse_response(AccessTokenResponse, info=query,
                                      sformat="urlencoded",
                                      keyjar=self.keyjar)
            if atr.type() == "ErrorResponse":
                raise TokenError(atr["error"])

            idt = None
            return None, atr, idt

    def complete(self):
        """
        Do the access token request, the last step in a code flow.
        If Implicit flow was used then this method is never used.
        """
        args = {"redirect_uri": self.redirect_uris[0]}
        if "password" in self.config and self.config["password"]:
            logger.info("basic auth")
            http_args = {"password": self.config["password"]}
        elif self.client_secret:
            logger.info("request_body auth")
            http_args = {}
            args.update({"client_secret": self.client_secret,
                         "client_id": self.client_id,
                         "secret_type": self.secret_type})
        else:
            raise PyoidcError("Nothing to authenticate with")

        resp = self.do_access_token_request(state=self.state,
                                            request_args=args,
                                            http_args=http_args)

        logger.info("Access Token Response: %s" % resp)

        if resp.type() == "ErrorResponse":
            raise TokenError(resp.error)

        #self._backup(self.sdb["seed:%s" % _cli.seed])
        self._backup(self.state)

        return resp

    def refresh_token(self):
        pass
    
    #noinspection PyUnusedLocal
    def get_user_info(self):
        uinfo = self.do_user_info_request(state=self.state, schema="openid")

        if uinfo.type() == "ErrorResponse":
            raise TokenError(uinfo.error)

        self.user_info = uinfo
        self._backup(self.state)

        return uinfo

    def refresh_session(self):
        pass

    def check_session(self):
        """
        With python you could use PyQuery to get the onclick attribute of each
        anchor tag, parse that with a regular expression to get the placeId,
        build the /places/duplicates.jsp?inPID= URL yourself, use requests to
        load the content at that URL, then PyQuery again on the content to get
        the data you need.

        for iframe in mosoup("iframe"):
            mosoup.iframe.extract()

        It accepts postMessage requests from the relevant RP iframe and uses
        postMessage to post back the login status of the End-User at the OP.

        :return:
        """
        pass

    def end_session(self):
        pass

########NEW FILE########
__FILENAME__ = message
import time
from urlparse import urlparse

__author__ = 'rohe0002'

import urllib
import json
import logging

from oic.oauth2 import message
from oic.oauth2 import MissingRequiredValue
from oic.oauth2 import MissingRequiredAttribute
from oic.oauth2 import VerificationError
from oic.exception import InvalidRequest, NotForMe
from oic.exception import PyoidcError
from oic.oauth2.message import Message
from oic.oauth2.message import REQUIRED_LIST_OF_SP_SEP_STRINGS
from oic.oauth2.message import SINGLE_OPTIONAL_JSON
from oic.oauth2.message import SINGLE_OPTIONAL_STRING
from oic.oauth2.message import OPTIONAL_LIST_OF_STRINGS
from oic.oauth2.message import SINGLE_REQUIRED_STRING
from oic.oauth2.message import OPTIONAL_LIST_OF_SP_SEP_STRINGS
from oic.oauth2.message import SINGLE_OPTIONAL_INT
from oic.oauth2.message import REQUIRED_LIST_OF_STRINGS

import jwkest
from jwkest import jws

logger = logging.getLogger(__name__)


#noinspection PyUnusedLocal
def json_ser(val, sformat=None, lev=0):
    return json.dumps(val)


#noinspection PyUnusedLocal
def json_deser(val, sformat=None, lev=0):
    return json.loads(val)

# value type, required, serializer, deserializer, null value allowed
SINGLE_OPTIONAL_BOOLEAN = (bool, False, None, None, False)
SINGLE_OPTIONAL_JSON_WN = (dict, False, json_ser, json_deser, True)
SINGLE_REQUIRED_INT = (int, True, None, None, False)


#noinspection PyUnusedLocal
def idtoken_deser(val, sformat="urlencoded"):
    # id_token are always serialized as a JWT
    return IdToken().deserialize(val, "jwt")


# def idtokenclaim_deser(val, sformat="urlencoded"):
#     if sformat in ["dict", "json"]:
#         if not isinstance(val, basestring):
#             val = json.dumps(val)
#             sformat = "json"
#     return IDTokenClaim().deserialize(val, sformat)
#
#
# def userinfo_deser(val, sformat="urlencoded"):
#     if sformat in ["dict", "json"]:
#         if not isinstance(val, basestring):
#             val = json.dumps(val)
#             sformat = "json"
#     return UserInfoClaim().deserialize(val, sformat)

def address_deser(val, sformat="urlencoded"):
    if sformat in ["dict", "json"]:
        if not isinstance(val, basestring):
            val = json.dumps(val)
            sformat = "json"
    return AddressClaim().deserialize(val, sformat)


def claims_deser(val, sformat="urlencoded"):
    if sformat in ["dict", "json"]:
        if not isinstance(val, basestring):
            val = json.dumps(val)
            sformat = "json"
    return Claims().deserialize(val, sformat)


def msg_ser(inst, sformat, lev=0):
    if sformat in ["urlencoded", "json"]:
        if isinstance(inst, dict) or isinstance(inst, Message):
            res = inst.serialize(sformat, lev)
        else:
            res = inst
    elif sformat == "dict":
        if isinstance(inst, Message):
            res = inst.serialize(sformat, lev)
        elif isinstance(inst, dict):
            res = inst
        else:
            raise ValueError("%s" % type(inst))
    else:
        raise PyoidcError("Unknown sformat")

    return res


def msg_ser_json(inst, sformat="json", lev=0):
    # sformat = "json" always except when dict
    if sformat == "dict":
        if isinstance(inst, Message):
            res = inst.serialize(sformat, lev)
        elif isinstance(inst, dict):
            res = inst
        else:
            raise ValueError("%s" % type(inst))
    else:
        sformat = "json"
        if isinstance(inst, dict) or isinstance(inst, Message):
            res = inst.serialize(sformat, lev)
        else:
            res = inst

    return res


def msg_list_ser(insts, sformat, lev=0):
    return [msg_ser(inst, sformat, lev) for inst in insts]


def claims_ser(val, sformat="urlencoded", lev=0):
    # everything in c_extension
    if isinstance(val, basestring):
        item = val
    elif isinstance(val, list):
        item = val[0]
    else:
        item = val

    if isinstance(item, Message):
        return item.serialize(method=sformat, lev=lev + 1)

    if sformat == "urlencoded":
        res = urllib.urlencode(item)
    elif sformat == "json":
        if lev:
            res = item
        else:
            res = json.dumps(item)
    elif sformat == "dict":
        if isinstance(item, dict):
            res = item
        else:
            raise ValueError("%s" % type(item))
    else:
        raise PyoidcError("Unknown sformat")

    return res


def registration_request_deser(val, sformat="urlencoded"):
    if sformat in ["dict", "json"]:
        if not isinstance(val, basestring):
            val = json.dumps(val)
            sformat = "json"
    return RegistrationRequest().deserialize(val, sformat)


def claims_request_deser(val, sformat="json"):
    # never 'urlencoded'
    if sformat == "urlencoded":
        sformat = "json"
    if sformat in ["dict", "json"]:
        if not isinstance(val, basestring):
            val = json.dumps(val)
            sformat = "json"
    return ClaimsRequest().deserialize(val, sformat)


OPTIONAL_ADDRESS = (Message, False, msg_ser, address_deser, False)
OPTIONAL_LOGICAL = (bool, False, None, None, False)
OPTIONAL_MULTIPLE_Claims = (Message, False, claims_ser, claims_deser, False)
# SINGLE_OPTIONAL_USERINFO_CLAIM = (Message, False, msg_ser, userinfo_deser)
# SINGLE_OPTIONAL_ID_TOKEN_CLAIM = (Message, False, msg_ser, idtokenclaim_deser)

SINGLE_OPTIONAL_JWT = (basestring, False, msg_ser, None, False)
SINGLE_OPTIONAL_IDTOKEN = (basestring, False, msg_ser, None, False)

SINGLE_OPTIONAL_REGISTRATION_REQUEST = (Message, False, msg_ser,
                                        registration_request_deser, False)
SINGLE_OPTIONAL_CLAIMSREQ = (Message, False, msg_ser_json, claims_request_deser,
                             False)

# ----------------------------------------------------------------------------


SCOPE_CHARSET = []
for char in ['\x21', ('\x23', '\x5b'), ('\x5d', '\x7E')]:
    if isinstance(char, tuple):
        c = char[0]
        while c <= char[1]:
            SCOPE_CHARSET.append(c)
            c = chr(ord(c) + 1)
    else:
        SCOPE_CHARSET.append(set)


def check_char_set(string, allowed):
    for c in string:
        if c not in allowed:
            raise ValueError("'%c' not in the allowed character set" % c)


# -----------------------------------------------------------------------------

class RefreshAccessTokenRequest(message.RefreshAccessTokenRequest):
    pass


class TokenErrorResponse(message.TokenErrorResponse):
    pass


class AccessTokenResponse(message.AccessTokenResponse):
    c_param = message.AccessTokenResponse.c_param.copy()
    c_param.update({"id_token": SINGLE_OPTIONAL_STRING})

    def verify(self, **kwargs):
        if "id_token" in self:
            # Try to decode the JWT, checks the signature
            args = {}
            for arg in ["key", "keyjar"]:
                try:
                    args[arg] = kwargs[arg]
                except KeyError:
                    pass
            idt = IdToken().from_jwt(str(self["id_token"]), **args)
            if not idt.verify(**kwargs):
                return False

            # replace the JWT with the IdToken instance
            self["id_token"] = idt

        return super(AccessTokenResponse, self).verify(**kwargs)


class UserInfoRequest(Message):
    c_param = {
        "access_token": SINGLE_OPTIONAL_STRING,
    }


class AuthorizationResponse(message.AuthorizationResponse,
                            message.AccessTokenResponse):

    c_param = message.AuthorizationResponse.c_param.copy()
    c_param.update(message.AccessTokenResponse.c_param)
    c_param.update({
        "code": SINGLE_OPTIONAL_STRING,
        "nonce": SINGLE_OPTIONAL_STRING,
        "access_token": SINGLE_OPTIONAL_STRING,
        "token_type": SINGLE_OPTIONAL_STRING,
        "id_token": SINGLE_OPTIONAL_IDTOKEN
    })

    def verify(self, **kwargs):
        if "aud" in self:
            if "client_id" in kwargs:
                # check that it's for me
                if kwargs["client_id"] not in self["aud"]:
                    return False

        if "id_token" in self:
            # Try to decode the JWT, checks the signature
            args = {}
            for arg in ["key", "keyjar"]:
                try:
                    args[arg] = kwargs[arg]
                except KeyError:
                    pass
            idt = IdToken().from_jwt(str(self["id_token"]), **args)
            if not idt.verify(**kwargs):
                raise VerificationError("Could not verify id_token")

            hfunc = "HS" + jwkest.unpack(self["id_token"])[0]["alg"][-3:]

            if "access_token" in self:
                try:
                    assert "at_hash" in idt
                except AssertionError:
                    raise MissingRequiredAttribute("Missing at_hash property")
                try:
                    assert idt["at_hash"] == jws.left_hash(
                        self["access_token"], hfunc)
                except AssertionError:
                    raise VerificationError(
                        "Failed to verify access_token hash")

            if "code" in self:
                try:
                    assert "c_hash" in idt
                except AssertionError:
                    raise MissingRequiredAttribute("Missing c_hash property")
                try:
                    assert idt["c_hash"] == jws.left_hash(self["code"], hfunc)
                except AssertionError:
                    raise VerificationError("Failed to verify code hash")

            self["id_token"] = idt

        return super(AuthorizationResponse, self).verify(**kwargs)


class AuthorizationErrorResponse(message.AuthorizationErrorResponse):
    c_allowed_values = message.AuthorizationErrorResponse.c_allowed_values.copy()
    c_allowed_values["error"].extend(["interaction_required",
                                      "login_required",
                                      "session_selection_required",
                                      "consent_required",
                                      "invalid_request_uri",
                                      "invalid_request_object",
                                      "registration_not_supported",
                                      "request_not_supported"])


class AuthorizationRequest(message.AuthorizationRequest):
    c_param = message.AuthorizationRequest.c_param.copy()
    c_param.update(
        {
            "scope": REQUIRED_LIST_OF_SP_SEP_STRINGS,
            "redirect_uri": SINGLE_REQUIRED_STRING,
            "nonce": SINGLE_OPTIONAL_STRING,
            "display": SINGLE_OPTIONAL_STRING,
            "prompt": OPTIONAL_LIST_OF_STRINGS,
            "max_age": SINGLE_OPTIONAL_INT,
            "ui_locales": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
            "claims_locale": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
            "id_token_hint": SINGLE_OPTIONAL_STRING,
            "login_hint": SINGLE_OPTIONAL_STRING,
            "acr_values": OPTIONAL_LIST_OF_SP_SEP_STRINGS,
            "claims": SINGLE_OPTIONAL_CLAIMSREQ,
            "registration": SINGLE_OPTIONAL_JSON,
            "request": SINGLE_OPTIONAL_STRING,
            "request_uri": SINGLE_OPTIONAL_STRING,
            "session_state": SINGLE_OPTIONAL_STRING,
            "response_mode": SINGLE_OPTIONAL_STRING,
        }
    )
    c_allowed_values = message.AuthorizationRequest.c_allowed_values.copy()
    c_allowed_values.update({
        "display": ["page", "popup", "touch", "wap"],
        "prompt": ["none", "login", "consent", "select_account"]
    })

    def verify(self, **kwargs):
        """Authorization Request parameters that are OPTIONAL in the OAuth 2.0
        specification MAY be included in the OpenID Request Object without also
        passing them as OAuth 2.0 Authorization Request parameters, with one
        exception: The scope parameter MUST always be present in OAuth 2.0
        Authorization Request parameters.
        All parameter values that are present both in the OAuth 2.0
        Authorization Request and in the OpenID Request Object MUST exactly
        match."""
        args = {}
        for arg in ["key", "keyjar"]:
            try:
                args[arg] = kwargs[arg]
            except KeyError:
                pass

        if "request" in self:
            if isinstance(self["request"], basestring):
                # Try to decode the JWT, checks the signature
                oidr = OpenIDRequest().from_jwt(str(self["request"]), **args)

                # verify that nothing is change in the original message
                for key, val in oidr.items():
                    if key in self:
                        assert self[key] == val

                # replace the JWT with the parsed and verified instance
                self["request"] = oidr
        if "id_token" in self:
            if isinstance(self["id_token"], basestring):
                idt = IdToken().from_jwt(str(self["id_token"]), **args)
                self["id_token"] = idt

        if "response_type" not in self:
            raise MissingRequiredAttribute("response_type missing")

        _rt = self["response_type"]
        if "token" in _rt or "id_token" in _rt:
            try:
                assert "nonce" in self
            except AssertionError:
                raise MissingRequiredAttribute("Nonce missing")

        try:
            assert "openid" in self["scope"]
        except AssertionError:
            raise MissingRequiredValue("openid in scope")

        if "offline_access" in self["scope"]:
            try:
                assert "consent" in self["prompt"]
            except AssertionError:
                raise MissingRequiredValue("consent in prompt")

        if "prompt" in self:
            if "none" in self["prompt"] and len(self["prompt"]) > 1:
                raise InvalidRequest("prompt none combined with other value")

        return super(AuthorizationRequest, self).verify(**kwargs)


class AccessTokenRequest(message.AccessTokenRequest):
    c_param = message.AccessTokenRequest.c_param.copy()
    c_param.update({"client_assertion_type": SINGLE_OPTIONAL_STRING,
                    "client_assertion": SINGLE_OPTIONAL_STRING})

    c_allowed_values = {
        "client_assertion_type": [
            "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"],
    }


class AddressClaim(Message):
    c_param = {"formatted": SINGLE_OPTIONAL_STRING,
               "street_address": SINGLE_OPTIONAL_STRING,
               "locality": SINGLE_OPTIONAL_STRING,
               "region": SINGLE_OPTIONAL_STRING,
               "postal_code": SINGLE_OPTIONAL_STRING,
               "country": SINGLE_OPTIONAL_STRING}


class OpenIDSchema(Message):
    c_param = {"sub": SINGLE_REQUIRED_STRING,
               "name": SINGLE_OPTIONAL_STRING,
               "given_name": SINGLE_OPTIONAL_STRING,
               "family_name": SINGLE_OPTIONAL_STRING,
               "middle_name": SINGLE_OPTIONAL_STRING,
               "nickname": SINGLE_OPTIONAL_STRING,
               "preferred_username": SINGLE_OPTIONAL_STRING,
               "profile": SINGLE_OPTIONAL_STRING,
               "picture": SINGLE_OPTIONAL_STRING,
               "website": SINGLE_OPTIONAL_STRING,
               "email": SINGLE_OPTIONAL_STRING,
               "email_verified": SINGLE_OPTIONAL_BOOLEAN,
               "gender": SINGLE_OPTIONAL_STRING,
               "birthdate": SINGLE_OPTIONAL_STRING,
               "zoneinfo": SINGLE_OPTIONAL_STRING,
               "locale": SINGLE_OPTIONAL_STRING,
               "phone_number": SINGLE_OPTIONAL_STRING,
               "phone_number_verified": SINGLE_OPTIONAL_STRING,
               "address": OPTIONAL_ADDRESS,
               "updated_at": SINGLE_OPTIONAL_INT,
               "_claim_names": SINGLE_OPTIONAL_JSON,
               "_claim_sources": SINGLE_OPTIONAL_JSON}

    def verify(self, **kwargs):
        if "birthdate" in self:
            # Either YYYY-MM-DD or just YYYY
            try:
                _ = time.strptime(self["birthdate"], "%Y-%m-%d")
            except ValueError:
                try:
                    _ = time.strptime(self["birthdate"], "%Y")
                except ValueError:
                    raise VerificationError("Birthdate format error")

        return super(OpenIDSchema, self).verify(**kwargs)


class RegistrationRequest(Message):
    c_param = {
        "redirect_uris": REQUIRED_LIST_OF_STRINGS,
        "response_types": OPTIONAL_LIST_OF_STRINGS,
        "grant_types": OPTIONAL_LIST_OF_STRINGS,
        "application_type": SINGLE_OPTIONAL_STRING,
        "contacts": OPTIONAL_LIST_OF_STRINGS,
        "client_name": SINGLE_OPTIONAL_STRING,
        "logo_uri": SINGLE_OPTIONAL_STRING,
        "client_uri": SINGLE_OPTIONAL_STRING,
        "policy_uri": SINGLE_OPTIONAL_STRING,
        "tos_uri": SINGLE_OPTIONAL_STRING,
        "jwks_uri": SINGLE_OPTIONAL_STRING,
        "sector_identifier_uri": SINGLE_OPTIONAL_STRING,
        "subject_type": SINGLE_OPTIONAL_STRING,
        "id_token_signed_response_alg": SINGLE_OPTIONAL_STRING,
        "id_token_encrypted_response_alg": SINGLE_OPTIONAL_STRING,
        "id_token_encrypted_response_enc": SINGLE_OPTIONAL_STRING,
        "userinfo_signed_response_alg": SINGLE_OPTIONAL_STRING,
        "userinfo_encrypted_response_alg": SINGLE_OPTIONAL_STRING,
        "userinfo_encrypted_response_enc": SINGLE_OPTIONAL_STRING,
        "request_object_signing_alg": SINGLE_OPTIONAL_STRING,
        "request_object_encryption_alg": SINGLE_OPTIONAL_STRING,
        "request_object_encryption_enc": SINGLE_OPTIONAL_STRING,
        "token_endpoint_auth_method": SINGLE_OPTIONAL_STRING,
        "token_endpoint_auth_signing_alg": SINGLE_OPTIONAL_STRING,
        "default_max_age": SINGLE_OPTIONAL_INT,
        "require_auth_time": OPTIONAL_LOGICAL,
        "default_acr_values": OPTIONAL_LIST_OF_STRINGS,
        "initiate_login_uri": SINGLE_OPTIONAL_STRING,
        "request_uris": OPTIONAL_LIST_OF_STRINGS,
        #"client_id": SINGLE_OPTIONAL_STRING,
        #"client_secret": SINGLE_OPTIONAL_STRING,
        "access_token": SINGLE_OPTIONAL_STRING,
        "post_logout_redirect_uris": OPTIONAL_LIST_OF_STRINGS,
    }
    c_default = {"application_type": "web"}
    c_allowed_values = {"application_type": ["native", "web"],
                        "subject_type": ["public", "pairwise"]}

    def verify(self, **kwargs):
        if "initiate_login_uri" in self:
            assert self["initiate_login_uri"].startswith("https:")

        return super(RegistrationRequest, self).verify(**kwargs)


class RegistrationResponse(Message):
    """
    Response to client_register registration requests
    """
    c_param = {
        "client_id": SINGLE_REQUIRED_STRING,
        "client_secret": SINGLE_OPTIONAL_STRING,
        "registration_access_token": SINGLE_REQUIRED_STRING,
        "registration_client_uri": SINGLE_OPTIONAL_STRING,
        "client_id_issued_at": SINGLE_OPTIONAL_INT,
        "client_secret_expires_at": SINGLE_OPTIONAL_INT,
    }
    c_param.update(RegistrationRequest.c_param)

    def verify(self, **kwargs):
        """
        Implementations MUST either return both a Client Configuration Endpoint
        and a Registration Access Token or neither of them.
        :param kwargs:
        :return: True if the message is OK otherwise False
        """

        if "registration_client_uri" in self:
            if not "registration_access_token":
                raise VerificationError((
                    "Only one of registration_client_uri"
                    " and registration_access_token present"))
        elif "registration_access_token" in self:
            raise VerificationError((
                "Only one of registration_client_uri"
                " and registration_access_token present"))

        return super(RegistrationResponse, self).verify(**kwargs)


class ClientRegistrationErrorResponse(message.ErrorResponse):
    c_allowed_values = {"error": ["invalid_redirect_uri",
                                  "invalid_client_metadata"]}


class IdToken(OpenIDSchema):
    c_param = OpenIDSchema.c_param.copy()
    c_param.update({
        "iss": SINGLE_REQUIRED_STRING,
        "sub": SINGLE_REQUIRED_STRING,
        "aud": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string
        "exp": SINGLE_REQUIRED_INT,
        "iat": SINGLE_REQUIRED_INT,
        "auth_time": SINGLE_OPTIONAL_INT,
        "nonce": SINGLE_OPTIONAL_STRING,
        "at_hash": SINGLE_OPTIONAL_STRING,
        "c_hash": SINGLE_OPTIONAL_STRING,
        "acr": SINGLE_OPTIONAL_STRING,
        "amr": OPTIONAL_LIST_OF_STRINGS,
        "azp": OPTIONAL_LIST_OF_STRINGS,  # Array of strings or string
        "sub_jwk": SINGLE_OPTIONAL_STRING
    })

    def verify(self, **kwargs):
        if "aud" in self:
            if "client_id" in kwargs:
                # check that I'm among the recipients
                if kwargs["client_id"] not in self["aud"]:
                    raise NotForMe()

            if len(self["aud"]) > 1:  # Then azr has to be present and be one of
                                      # the values
                try:
                    assert "azr" in self
                except AssertionError:
                    raise VerificationError("azr missing")
                else:
                    try:
                        assert self["azr"] in self["aud"]
                    except AssertionError:
                        raise VerificationError(
                            "Missmatch between azr and aud claims")

        if "azr" in self:
            if "client_id" in kwargs:
                if kwargs["client_id"] != self["azp"]:
                    raise NotForMe()

        return super(IdToken, self).verify(**kwargs)


class RefreshSessionRequest(Message):
    c_param = {"id_token": SINGLE_REQUIRED_STRING,
               "redirect_url": SINGLE_REQUIRED_STRING,
               "state": SINGLE_REQUIRED_STRING}


class RefreshSessionResponse(Message):
    c_param = {"id_token": SINGLE_REQUIRED_STRING,
               "state": SINGLE_REQUIRED_STRING}


class CheckSessionRequest(Message):
    c_param = {"id_token": SINGLE_REQUIRED_STRING}


class CheckIDRequest(Message):
    c_param = {"access_token": SINGLE_REQUIRED_STRING}


class EndSessionRequest(Message):
    c_param = {
        "id_token_hint": SINGLE_OPTIONAL_STRING,
        "post_logout_redirect_uri": SINGLE_OPTIONAL_STRING
    }


class EndSessionResponse(Message):
    c_param = {"state": SINGLE_REQUIRED_STRING}


class Claims(Message):
    c_param = {"*": SINGLE_OPTIONAL_JSON_WN}


class ClaimsRequest(Message):
    c_param = {
        "userinfo": OPTIONAL_MULTIPLE_Claims,
        "id_token": OPTIONAL_MULTIPLE_Claims
    }


# class UserInfoClaim(Message):
#     c_param = {"claims": OPTIONAL_MULTIPLE_Claims,
#                "preferred_locale": SINGLE_OPTIONAL_STRING}
#
#
# class IDTokenClaim(Message):
#     c_param = {"claims": OPTIONAL_MULTIPLE_Claims,
#                "max_age": SINGLE_OPTIONAL_INT}


class OpenIDRequest(AuthorizationRequest):
    pass


class ProviderConfigurationResponse(Message):
    c_param = {
        "version": SINGLE_REQUIRED_STRING,
        "issuer": SINGLE_REQUIRED_STRING,
        "authorization_endpoint": SINGLE_OPTIONAL_STRING,
        "token_endpoint": SINGLE_OPTIONAL_STRING,
        "userinfo_endpoint": SINGLE_OPTIONAL_STRING,
        "jwks_uri": SINGLE_OPTIONAL_STRING,
        "registration_endpoint": SINGLE_OPTIONAL_STRING,
        "scopes_supported": OPTIONAL_LIST_OF_STRINGS,
        "response_types_supported": REQUIRED_LIST_OF_STRINGS,
        "response_modes_supported": OPTIONAL_LIST_OF_STRINGS,
        "grant_types_supported": REQUIRED_LIST_OF_STRINGS,
        "acr_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "subject_types_supported": REQUIRED_LIST_OF_STRINGS,
        "id_token_signing_alg_values_supported": REQUIRED_LIST_OF_STRINGS,
        "id_token_encryption_alg_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "id_token_encryption_enc_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "userinfo_signing_alg_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "userinfo_encryption_alg_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "userinfo_encryption_enc_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "request_object_signing_alg_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "request_object_encryption_alg_values_supported":
        OPTIONAL_LIST_OF_STRINGS,
        "request_object_encryption_enc_values_supported":
        OPTIONAL_LIST_OF_STRINGS,
        "token_endpoint_auth_methods_supported": OPTIONAL_LIST_OF_STRINGS,
        "token_endpoint_auth_signing_alg_values_supported":
        OPTIONAL_LIST_OF_STRINGS,
        "display_values_supported": OPTIONAL_LIST_OF_STRINGS,
        "claim_types_supported": OPTIONAL_LIST_OF_STRINGS,
        "claims_supported": OPTIONAL_LIST_OF_STRINGS,
        "service_documentation": SINGLE_OPTIONAL_STRING,
        "claims_locales_supported": OPTIONAL_LIST_OF_STRINGS,
        "ui_locales_supported": OPTIONAL_LIST_OF_STRINGS,
        "claims_parameter_supported": SINGLE_OPTIONAL_STRING,
        "request_parameter_supported": SINGLE_OPTIONAL_STRING,
        "request_uri_parameter_supported": SINGLE_OPTIONAL_STRING,
        "require_request_uri_registration": SINGLE_OPTIONAL_STRING,
        "op_policy_uri": SINGLE_OPTIONAL_STRING,
        "op_tos_uri": SINGLE_OPTIONAL_STRING
        #"check_session_iframe": SINGLE_OPTIONAL_STRING,
        #"end_session_endpoint": SINGLE_OPTIONAL_STRING,
        #"jwk_encryption_url": SINGLE_OPTIONAL_STRING,
        #"x509_url": SINGLE_REQUIRED_STRING,
        #"x509_encryption_url": SINGLE_OPTIONAL_STRING,
    }
    c_default = {"version": "3.0",
                 "token_endpoint_auth_methods_supported": "client_secret_basic",
                 "claims_parameter_supported": "false",
                 "request_parameter_supported": "false",
                 "request_uri_parameter_supported": "true",
                 "require_request_uri_registration": "true",
                 "grant_types_supported": ["authorization_code", "implicit"]}

    def verify(self, **kwargs):
        if "scopes_supported" in self:
            assert "openid" in self["scopes_supported"]
            for scope in self["scopes_supported"]:
                check_char_set(scope, SCOPE_CHARSET)

        parts = urlparse(self["issuer"])
        assert parts.scheme == "https"
        assert not parts.query and not parts.fragment

        return super(ProviderConfigurationResponse, self).verify(**kwargs)


class AuthnToken(Message):
    c_param = {
        "iss": SINGLE_REQUIRED_STRING,
        "sub": SINGLE_REQUIRED_STRING,
        "aud": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string
        "jti": SINGLE_REQUIRED_STRING,
        "exp": SINGLE_REQUIRED_INT,
        "iat": SINGLE_OPTIONAL_INT,
    }


class UserInfoErrorResponse(message.ErrorResponse):
    c_allowed_values = {"error": ["invalid_schema", "invalid_request",
                                  "invalid_token", "insufficient_scope"]}


class DiscoveryRequest(Message):
    c_param = {"principal": SINGLE_REQUIRED_STRING,
               "service": SINGLE_REQUIRED_STRING}


class DiscoveryResponse(Message):
    c_param = {"locations": REQUIRED_LIST_OF_STRINGS}


class ResourceRequest(Message):
    c_param = {"access_token": SINGLE_OPTIONAL_STRING}

SCOPE2CLAIMS = {
    "openid": ["sub"],
    "profile": ["name", "given_name", "family_name", "middle_name",
                "nickname", "profile", "picture", "website", "gender",
                "birthdate", "zoneinfo", "locale", "updated_at",
                "preferred_username"],
    "email": ["email", "email_verified"],
    "address": ["address"],
    "phone": ["phone_number", "phone_number_verified"],
    "offline_access": []
}

MSG = {
    "RefreshAccessTokenRequest": RefreshAccessTokenRequest,
    "TokenErrorResponse": TokenErrorResponse,
    "AccessTokenResponse": AccessTokenResponse,
    "UserInfoRequest": UserInfoRequest,
    "AuthorizationResponse": AuthorizationResponse,
    "AuthorizationErrorResponse": AuthorizationErrorResponse,
    "AuthorizationRequest": AuthorizationRequest,
    "AccessTokenRequest": AccessTokenRequest,
    "AddressClaim": AddressClaim,
    "OpenIDSchema": OpenIDSchema,
    "RegistrationRequest": RegistrationRequest,
    "RegistrationResponse": RegistrationResponse,
    "ClientRegistrationErrorResponse": ClientRegistrationErrorResponse,
    "IdToken": IdToken,
    "RefreshSessionRequest": RefreshSessionRequest,
    "RefreshSessionResponse": RefreshSessionResponse,
    "CheckSessionRequest": CheckSessionRequest,
    "CheckIDRequest": CheckIDRequest,
    "EndSessionRequest": EndSessionRequest,
    "EndSessionResponse": EndSessionResponse,
    "Claims": Claims,
    # "UserInfoClaim": UserInfoClaim,
    # "IDTokenClaim": IDTokenClaim,
    "OpenIDRequest": OpenIDRequest,
    "ProviderConfigurationResponse": ProviderConfigurationResponse,
    "AuthnToken": AuthnToken,
    "UserInfoErrorResponse": UserInfoErrorResponse,
    "DiscoveryRequest": DiscoveryRequest,
    "DiscoveryResponse": DiscoveryResponse,
    "ResourceRequest": ResourceRequest,
}


def factory(msgtype):
    try:
        return MSG[msgtype]
    except KeyError:
        if msgtype == "ErrorResponse":
            return message.ErrorResponse
        elif msgtype == "Message":
            return message.Message
        else:
            raise PyoidcError("Unknown message type: %s" % msgtype)

if __name__ == "__main__":
    atr = AccessTokenResponse(access_token="access_token",
                              token_type="token_type")
    print atr
    print atr.verify()

    atr = AccessTokenRequest(code="code", client_id="client_id",
                             redirect_uri="redirect_uri")
    print atr
    print atr.verify()
    uue = atr.serialize()
    atr = AccessTokenRequest().deserialize(uue, "urlencoded")
    print atr
########NEW FILE########
__FILENAME__ = provider
#!/usr/bin/env python
import json
import traceback
import urllib
import sys
from jwkest.jwe import JWE
from oic.utils.authn.user import NoSuchAuthentication
from oic.utils.authn.user import ToOld
from oic.utils.authn.user import TamperAllert
from oic.utils.time_util import utc_time_sans_frac
from oic.utils.keyio import KeyBundle
from oic.utils.keyio import key_export

from requests import ConnectionError

from oic.oauth2.message import by_schema
from oic.oic.message import RefreshAccessTokenRequest
from oic.oic.message import EndSessionRequest
from oic.oic.message import AuthorizationRequest
from oic.oic.message import Claims
from oic.oic.message import IdToken
from oic.oic.message import OpenIDSchema
from oic.oic.message import RegistrationResponse
from oic.oic.message import AuthorizationResponse
from oic.oic.message import OpenIDRequest
from oic.oic.message import AccessTokenResponse
from oic.oic.message import AccessTokenRequest
from oic.oic.message import TokenErrorResponse
from oic.oic.message import SCOPE2CLAIMS
from oic.oic.message import RegistrationRequest
from oic.oic.message import ClientRegistrationErrorResponse
from oic.oic.message import DiscoveryRequest
from oic.oic.message import ProviderConfigurationResponse
from oic.oic.message import DiscoveryResponse

from jwkest import jws, jwe
from jwkest.jws import alg2keytype

__author__ = 'rohe0002'

import random
import urlparse
import hmac
import time
import hashlib
import logging
import socket

from oic.oauth2.provider import Provider as AProvider
from oic.oauth2.provider import Endpoint

from oic.utils.http_util import Response
from oic.utils.http_util import Redirect
from oic.utils.http_util import BadRequest
from oic.utils.http_util import Unauthorized

from oic.oauth2 import MissingRequiredAttribute
from oic.oauth2 import rndstr

from oic.oic import Server

from oic.exception import *
from jwkest.jwe import JWEException

logger = logging.getLogger(__name__)

SWD_ISSUER = "http://openid.net/specs/connect/1.0/issuer"
STR = 5 * "_"


#noinspection PyUnusedLocal
def devnull(txt):
    pass


#noinspection PyUnusedLocal
def do_authorization(user):
    return ""


def secret(seed, sid):
    csum = hmac.new(seed, digestmod=hashlib.sha224)
    csum.update("%s" % time.time())
    csum.update("%f" % random.random())
    csum.update(sid)
    return csum.hexdigest()

#def update_info(aresp, sdict):
#    for prop in aresp._schema["param"].keys():
#        try:
#            aresp[prop] = sdict[prop]
#        except KeyError:
#            pass


def code_token_response(**kwargs):
    _areq = kwargs["areq"]
    _scode = kwargs["scode"]
    _sdb = kwargs["sdb"]

    aresp = AuthorizationResponse()

    for key in ["state", "nonce", "scope"]:
        try:
            aresp[key] = _areq[key]
        except KeyError:
            pass

    aresp["code"] = _scode

    _dic = _sdb.upgrade_to_token(_scode, issue_refresh=False)
    for prop in AccessTokenResponse.c_param.keys():
        try:
            aresp[prop] = _dic[prop]
        except KeyError:
            pass

    return aresp


def location_url(response_type, redirect_uri, query):
    if response_type in [["code"], ["token"], ["none"]]:
        return "%s?%s" % (redirect_uri, query)
    else:
        return "%s#%s" % (redirect_uri, query)


def construct_uri(item):
    (base_url, query) = item
    if query:
        return "%s?%s" % (base_url, urllib.urlencode(query))
    else:
        return base_url


class AuthorizationEndpoint(Endpoint):
    etype = "authorization"

class TokenEndpoint(Endpoint):
    etype = "token"


class UserinfoEndpoint(Endpoint):
    etype = "userinfo"


class RegistrationEndpoint(Endpoint) :
    etype = "registration"


class EndSessionEndpoint(Endpoint) :
    etype = "endsession"



class Provider(AProvider):
    def __init__(self, name, sdb, cdb, authn_broker, userinfo, authz,
                 client_authn, symkey, urlmap=None, ca_certs="", keyjar=None,
                 hostname="", template_lookup=None, template=None,
                 verify_ssl=True):

        AProvider.__init__(self, name, sdb, cdb, authn_broker, authz,
                           client_authn, symkey, urlmap, ca_bundle=ca_certs,
                           verify_ssl=verify_ssl)

        # Should be a OIC Server not an OAuth2 server
        self.server = Server(ca_certs=ca_certs, verify_ssl=verify_ssl)

        self.endp.extend([UserinfoEndpoint, RegistrationEndpoint,
                          EndSessionEndpoint])

        self.userinfo = userinfo

        if keyjar:
            self.server.keyjar = keyjar
        self.template_lookup = template_lookup
        self.template = template or {}
        self.keyjar = self.server.keyjar
        self.baseurl = ""
        self.cert = []
        self.cert_encryption = []

        self.cookie_name = "pyoidc"
        self.seed = ""
        self.sso_ttl = 0
        self.test_mode = False
        self.jwks_uri = []

        self.authn_as = None
        self.preferred_id_type = "public"
        self.hostname = hostname or socket.gethostname
        self.register_endpoint = "%s%s" % (self.baseurl, "register")

    def id_token_as_signed_jwt(self, session, loa="2", alg="RS256", code=None,
                               access_token=None, user_info=None):

        logger.debug("Signing alg: %s [%s]" % (alg, alg2keytype(alg)))
        _idt = self.server.make_id_token(session, loa, self.baseurl, alg, code,
                                         access_token, user_info)

        logger.debug("id_token: %s" % _idt.to_dict())
        # My signing key if its RS*, can use client secret if HS*
        if alg.startswith("HS"):
            logger.debug("client_id: %s" % session["client_id"])
            ckey = self.keyjar.get_signing_key(alg2keytype(alg),
                                               session["client_id"])
        else:
            if "" in self.keyjar:
                for b in self.keyjar[""]:
                    logger.debug("OC3 server keys: %s" % b)
                ckey = self.keyjar.get_signing_key(alg2keytype(alg), "")
            else:
                ckey = None
        logger.debug("ckey: %s" % ckey)
        _signed_jwt = _idt.to_jwt(key=ckey, algorithm=alg)

        return _signed_jwt

    def _parse_openid_request(self, request):
        return OpenIDRequest().from_jwt(request, keyjar=self.keyjar)

    def _parse_id_token(self, id_token, redirect_uri):
        try:
            return IdToken().from_jwt(id_token, keyjar=self.keyjar)
        except Exception, err:
            logger.error("Faulty id_token: %s" % id_token)
            logger.error("Exception: %s" % (err.__class__.__name__,))
            id_token = IdToken().from_jwt(id_token, verify=False)
            logger.error("IdToken: %s" % id_token.to_dict())
            return self._redirect_authz_error("invalid_id_token_object",
                                              redirect_uri)

    def get_sector_id(self, redirect_uri, client_info):
        """
        Pick the sector id given a number of factors
        :param redirect_uri: The redirect_uri used
        :param client_info: Information provided by the client in the
        client registration
        :return: A sector_id or None
        """

        _redirect_uri = urlparse.unquote(redirect_uri)

        part = urlparse.urlparse(_redirect_uri)
        if part.fragment:
            raise ValueError

        (_base, _query) = urllib.splitquery(_redirect_uri)

        sid = ""
        try:
            if _base in client_info["si_redirects"]:
                sid = client_info["sector_id"]
        except KeyError:
            try:
                uit = client_info["subject_type"]
                if uit == "pairwise":
                    sid = _base
            except KeyError:
                pass

        return sid

    def handle_oidc_request(self, areq, redirect_uri):
        if "request_uri" in areq:
            # Do a HTTP get
            try:
                _req = self.server.http_request(areq["request_uri"])
            except ConnectionError:
                return self._authz_error("invalid_request_uri")

            if not _req:
                return self._authz_error("invalid_request_uri")

            try:
                resq = self._parse_openid_request(_req.text)
            except Exception:
                return self._redirect_authz_error(
                    "invalid_openid_request_object", redirect_uri)

            areq["request"] = resq

        return areq

    @staticmethod
    def required_user(areq):
        req_user = ""
        try:
            oidc_req = areq["request"]
            try:
                req_user = oidc_req["claims"]["id_token"]["sub"]["value"]
            except KeyError:
                pass
        except KeyError:
            try:
                req_user = areq["id_token"]["sub"]
            except KeyError:
                pass

        return req_user

    @staticmethod
    def max_age(areq):
        try:
            return areq["request"]["max_age"]
        except KeyError:
            try:
                return areq["max_age"]
            except KeyError:
                return 0

    @staticmethod
    def re_authenticate(areq, authn):
        if "prompt" in areq and "login" in areq["prompt"]:
            if authn.done(areq):
                return True

        return False

    def pick_auth(self, areq, comparision_type=""):
        """

        :param areq: AuthorizationRequest instance
        :param comparision_type: How to pick the authentication method
        :return: An authentication method and its authn class ref
        """
        if comparision_type == "any":
            return self.authn_broker[0]

        try:
            if len(self.authn_broker) == 1:
                    return self.authn_broker[0]
            else:
                if "acr_values" in areq:
                    if not comparision_type:
                        comparision_type = "exact"

                for acr in areq["acr_values"]:
                    res = self.authn_broker.pick(acr, comparision_type)
                    if res:
                        #Return the best guess by pick.
                        return res[0]
        except KeyError:
            pass

        # return the best I have
        return None, None

    def verify_post_logout_redirect_uri(self, areq, cookie):
        try:
            redirect_uri = areq["post_logout_redirect_uri"]
            authn, acr = self.pick_auth(areq)
            uid = authn.authenticated_as(cookie)["uid"]
            client_info = self.cdb[self.sdb.getClient_id(uid)]
            if redirect_uri in client_info["post_logout_redirect_uris"]:
                return redirect_uri
        except:
            pass
        return None

    def is_session_revoked(self, request="", cookie=None):
        areq = urlparse.parse_qs(request)
        authn, acr = self.pick_auth(areq)
        identity = authn.authenticated_as(cookie)
        return self.sdb.is_revoke_uid(identity["uid"])

    def let_user_verify_logout(self, uid, esr, cookie, redirect_uri):
        if cookie:
            headers = [cookie]
        else:
            headers = []
        mte = self.template_lookup.get_template(self.template["verify_logout"])
        self.sdb.set_verified_logout(uid)
        if redirect_uri is not None:
            redirect = redirect_uri
        else:
            redirect = "/"
        try:
            tmp_id_token_hint = esr["id_token_hint"]
        except:
            tmp_id_token_hint = ""
        argv = {
            "id_token_hint": tmp_id_token_hint,
            "post_logout_redirect_uri": esr["post_logout_redirect_uri"],
            "key": self.sdb.get_verify_logout(uid),
            "redirect": redirect,
            "action": "/"+EndSessionEndpoint("").etype
        }
        return Response(mte.render(**argv), headers=[])

    def end_session_endpoint(self, request="", cookie=None, **kwargs):
        esr = EndSessionRequest().from_urlencoded(request)
        redirect_uri = self.verify_post_logout_redirect_uri(esr, cookie)
        if not redirect_uri:
            return self._error_response("Not allowed!")

        authn, acr = self.pick_auth(esr)

        if "id_token_hint" in esr:
            id_token_hint = OpenIDRequest().from_jwt(esr["id_token_hint"],
                                                     keyjar=self.keyjar,
                                                         verify=True)
            uid = id_token_hint["sub"]
        else:
            identity = authn.authenticated_as(cookie)
            try:
                uid = identity["uid"]
            except KeyError:
                return self._error_response("Not allowed!")

        #if self.sdb.get_verified_logout(uid):
        #    return self.let_user_verify_logout(uid, esr, cookie, redirect_uri)

        try:
            sid = self.sdb.get_sid_from_userid(uid)
        except KeyError:
            pass
            #If cleanup cannot be performed we will still invalidate the cookie.
        else:
            del self.sdb[sid]

        if redirect_uri is not None:
            return Redirect(str(redirect_uri), headers=[authn.delete_cookie()])

        return Response("", headers=[authn.delete_cookie()])

    def verify_endpoint(self, request="", cookie=None, **kwargs):
        """

        :param request:
        :param cookie:
        :param kwargs:
        :return:
        """
        logger.debug("verify request: %s" % request)

        _req = urlparse.parse_qs(request)
        if "query" in _req:
            try:
                # TODO FIX THIS !!! Why query ?
                areq = urlparse.parse_qs(_req["query"][0])
            except KeyError:
                return BadRequest()
        else:
            areq = _req

        logger.debug("REQ: %s" % areq)
        try:
            authn, acr = self.pick_auth(areq, "exact")
        except Exception, err:
            logger.exception("%s", err)
            raise

        kwargs["cookie"] = cookie
        return authn.verify(_req, **kwargs)

    def authorization_endpoint(self, request="", cookie=None, **kwargs):
        """ The AuthorizationRequest endpoint

        :param request: The client request
        """

        logger.debug("Request: '%s'" % request)
        # Same serialization used for GET and POST
        try:
            areq = self.server.parse_authorization_request(query=request)
        except MissingRequiredAttribute, err:
            logger.debug("%s" % err)
            return self._error("invalid_request", "%s" % err)
        except KeyError:
            areq = AuthorizationRequest().deserialize(request, "urlencoded")
            # verify the redirect_uri
            try:
                self.get_redirect_uri(areq)
            except (RedirectURIError, ParameterError), err:
                return self._error("invalid_request", "%s" % err)
        except Exception, err:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            logger.debug("Bad request: %s (%s)" % (err, err.__class__.__name__))
            return BadRequest("%s" % err)

        if not areq:
            logger.debug("No AuthzRequest")
            return self._error("invalid_request", "No parsable AuthzRequest")

        logger.debug("AuthzRequest: %s" % (areq.to_dict(),))
        try:
            redirect_uri = self.get_redirect_uri(areq)
        except (RedirectURIError, ParameterError, UnknownClient), err:
            return self._error("invalid_request", "%s" % err)

        try:
            # verify that the request message is correct
            areq.verify()
        except (MissingRequiredAttribute, ValueError), err:
            return self._redirect_authz_error("invalid_request", redirect_uri,
                                              "%s" % err)

        areq = self.handle_oidc_request(areq, redirect_uri)
        logger.debug("AuthzRequest+oidc_request: %s" % (areq.to_dict(),))

        req_user = self.required_user(areq)

        authn, authn_class_ref = self.pick_auth(areq)
        if not authn:
            authn, authn_class_ref = self.pick_auth(areq, "better")
            if not authn:
                authn, authn_class_ref = self.pick_auth(areq, "any")

        logger.debug("Cookie: %s" % cookie)
        try:
            try:
                _auth_info = kwargs["authn"]
            except KeyError:
                _auth_info = ""
            identity = authn.authenticated_as(cookie,
                                              authorization=_auth_info,
                                              max_age=self.max_age(areq))
        except (NoSuchAuthentication, ToOld, TamperAllert):
            identity = None

        # gather information to be used by the authentication method
        authn_args = {"query": request,
                      "as_user": req_user,
                      "authn_class_ref": authn_class_ref}

        cinfo = self.cdb[areq["client_id"]]
        for attr in ["policy_uri", "logo_uri"]:
            try:
                authn_args[attr] = cinfo[attr]
            except KeyError:
                pass

        # To authenticate or Not
        if identity is None:  # No!
            if "prompt" in areq and "none" in areq["prompt"]:
                # Need to authenticate but not allowed
                return self._redirect_authz_error("login_required",
                                                  redirect_uri)
            else:
                return authn(**authn_args)
        else:
            if self.re_authenticate(areq, authn):
                # demand re-authentication
                return authn(**authn_args)
            else:
                # I get back a dictionary
                user = identity["uid"]
                if req_user and req_user != user:
                    logger.debug("Wanted to be someone else!")
                    if "prompt" in areq and "none" in areq["prompt"]:
                        # Need to authenticate but not allowed
                        return self._redirect_authz_error("login_required",
                                                          redirect_uri)
                    else:
                        return authn(**authn_args)

        logger.debug("- authenticated -")
        logger.debug("AREQ keys: %s" % areq.keys())

        try:
            oidc_req = areq["request"]
        except KeyError:
            oidc_req = None

        sid = self.sdb.create_authz_session(user, areq, oidreq=oidc_req)
        return self.authz_part2(user, areq, sid)

    def userinfo_in_id_token_claims(self, session):
        """
        Put userinfo claims in the id token
        :param session:
        :return:
        """
        itc = self.server.id_token_claims(session)
        if not itc:
            return None

        _claims = by_schema(OpenIDSchema, **itc)

        if _claims:
            return self._collect_user_info(session, {"claims": _claims})
        else:
            return None

    def encrypt(self, payload, client_info, cid, val_type="id_token"):
        """
        Handles the encryption of a payload

        :param payload: The information to be encrypted
        :param client_info: Client information
        :param cid: Client id
        :return: The encrypted information as a JWT
        """

        alg = client_info["%s_encrypted_response_alg" % val_type]
        try:
            enc = client_info["%s_encrypted_response_enc" % val_type]
        except KeyError:
            enc = "A128CBC"

        keys = self.keyjar.get_encrypt_key(owner=cid)
        logger.debug("keys for %s: %s" % (
            cid, "["+", ".join([str(x) for x in self.keyjar[cid]]))+"]")
        logger.debug("alg=%s, enc=%s, val_type=%s" % (alg, enc, val_type))
        logger.debug("Encryption keys for %s: %s" % (cid, keys))

        # use the clients public key for encryption
        _jwe = JWE(payload, alg=alg, enc=enc)
        return _jwe.encrypt(keys, context="public")

    def sign_encrypt_id_token(self, sinfo, client_info, areq, code=None,
                              access_token=None, user_info=None):
        """
        Signed and or encrypt a IDToken

        :param sinfo: Session information
        :param client_info: Client information
        :param areq: The request
        :param code: Access grant
        :param access_token: Access Token
        :param user_info: User information
        :return: IDToken instance
        """

        try:
            alg = client_info["id_token_signed_response_alg"]
        except KeyError:
            alg = "RS256"

        id_token = self.id_token_as_signed_jwt(sinfo, alg=alg,
                                               code=code,
                                               access_token=access_token,
                                               user_info=user_info)

        # Then encrypt
        if "id_token_encrypted_response_alg" in client_info:
            id_token = self.encrypt(id_token, client_info, areq["client_id"],
                                    "id_token")

        return id_token

    def _access_token_endpoint(self, req, **kwargs):

        _sdb = self.sdb
        _log_debug = logger.debug

        client_info = self.cdb[req["client_id"]]

        assert req["grant_type"] == "authorization_code"

        _access_code = req["code"]
        # assert that the code is valid
        if self.sdb.is_revoked(_access_code):
            return self._error(error="access_denied", descr="Token is revoked")

        _info = _sdb[_access_code]

        # If redirect_uri was in the initial authorization request
        # verify that the one given here is the correct one.
        if "redirect_uri" in _info:
            try:
                assert req["redirect_uri"] == _info["redirect_uri"]
            except AssertionError:
                return self._error(error="access_denied",
                                   descr="redirect_uri mismatch")

        _log_debug("All checks OK")

        try:
            _tinfo = _sdb.upgrade_to_token(_access_code)
        except Exception, err:
            logger.error("%s" % err)
            # Should revoke the token issued to this access code
            _sdb.revoke_all_tokens(_access_code)
            return self._error(error="access_denied", descr="%s" % err)

        if "openid" in _info["scope"]:
            userinfo = self.userinfo_in_id_token_claims(_info)
            _idtoken = self.sign_encrypt_id_token(_info, client_info, req,
                                                  user_info=userinfo)
            _sdb.update_by_token(_access_code, "id_token", _idtoken)

        _log_debug("_tinfo: %s" % _tinfo)

        atr = AccessTokenResponse(**by_schema(AccessTokenResponse, **_tinfo))

        _log_debug("access_token_response: %s" % atr.to_dict())

        return Response(atr.to_json(), content="application/json")

    def _refresh_access_token_endpoint(self, req, **kwargs):
        _sdb = self.sdb
        _log_debug = logger.debug

        client_info = self.cdb[req["client_id"]]

        assert req["grant_type"] == "refresh_token"
        rtoken = req["refresh_token"]
        _info = _sdb.refresh_token(rtoken)

        if "openid" in _info["scope"]:
            userinfo = self.userinfo_in_id_token_claims(_info)
            _idtoken = self.sign_encrypt_id_token(_info, client_info, req,
                                                  user_info=userinfo)
            sid = _sdb.token.get_key(rtoken)
            _sdb.update(sid, "id_token", _idtoken)

        _log_debug("_info: %s" % _info)

        atr = AccessTokenResponse(**by_schema(AccessTokenResponse, **_info))

        _log_debug("access_token_response: %s" % atr.to_dict())

        return Response(atr.to_json(), content="application/json")

    #noinspection PyUnusedLocal
    def token_endpoint(self, request="", authn=None, **kwargs):
        """
        This is where clients come to get their access tokens

        :param request: The request
        :param authn: Authentication info, comes from HTTP header
        :returns:
        """
        logger.debug("- token -")
        logger.info("token_request: %s" % request)

        req = AccessTokenRequest().deserialize(request, "urlencoded")
        if "refresh_token" in req:
            req = RefreshAccessTokenRequest().deserialize(request, "urlencoded")

        logger.debug("%s: %s" % (req.__class__.__name__, req))

        try:
            client_id = self.client_authn(self, req, authn)
        except Exception, err:
            logger.error("Failed to verify client due to: %s" % err)
            client_id = ""

        if not client_id:
            err = TokenErrorResponse(error="unathorized_client")
            return Unauthorized(err.to_json(), content="application/json")

        if not "client_id" in req:  # Optional for access token request
            req["client_id"] = client_id

        if isinstance(req, AccessTokenRequest):
            try:
                return self._access_token_endpoint(req, **kwargs)
            except JWEException as err:
                return self._error_response("invalid_request",
                                            descr="%s" % err)

        else:
            return self._refresh_access_token_endpoint(req, **kwargs)

    def _collect_user_info(self, session, userinfo_claims=None):
        """
        Collect information about a user.
        This can happen in two cases, either when constructing an IdToken or
        when returning user info through the UserInfo endpoint

        :param session: Session information
        :param userinfo_claims: user info claims
        :return: User info
        """
        if userinfo_claims is None:
            uic = {}
            for scope in session["scope"]:
                try:
                    claims = dict([(name, None) for name in
                                   SCOPE2CLAIMS[scope]])
                    uic.update(claims)
                except KeyError:
                    pass

            if "oidreq" in session:
                oidreq = OpenIDRequest().deserialize(session["oidreq"], "json")
                logger.debug("OIDREQ: %s" % oidreq.to_dict())
                try:
                    _claims = oidreq["claims"]["userinfo"]
                except KeyError:
                    pass
                else:
                    for key, val in uic.items():
                        if key not in _claims:
                            _claims[key] = val
                    uic = _claims

                if uic:
                    userinfo_claims = Claims(**uic)
                else:
                    userinfo_claims = None
            elif uic:
                userinfo_claims = Claims(**uic)
            else:
                userinfo_claims = None

            logger.debug("userinfo_claim: %s" % userinfo_claims.to_dict())

        logger.debug("Session info: %s" % session)
        info = self.userinfo(session["local_sub"], userinfo_claims)

        info["sub"] = session["sub"]
        logger.debug("user_info_response: %s" % (info,))

        return info

    #noinspection PyUnusedLocal
    def userinfo_endpoint(self, request="", **kwargs):
        """
        :param request: The request in a string format
        """
        try:
            _log_debug = kwargs["logger"].debug
            _log_info = kwargs["logger"].info
        except KeyError:
            _log_debug = logger.debug
            _log_info = logger.info

        _sdb = self.sdb

        if not request or "access_token" not in request:
            _token = kwargs["authn"]
            assert _token.startswith("Bearer ")
            _token = _token[len("Bearer "):]
            logger.debug("Bearer token: '%s'" % _token)
        else:
            uireq = self.server.parse_user_info_request(data=request)
            logger.debug("user_info_request: %s" % uireq)
            _token = uireq["access_token"]

        # should be an access token
        typ, key = _sdb.token.type_and_key(_token)
        _log_debug("access_token type: '%s'" % (typ,))

        try:
            assert typ == "T"
        except AssertionError:
            raise FailedAuthentication("Wrong type of token")

        #_log_info("keys: %s" % self.sdb.keys())
        if _sdb.is_revoked(key):
            return self._error(error="access_denied", descr="Token is revoked")
        session = _sdb[key]

        # Scope can translate to userinfo_claims

        info = OpenIDSchema(**self._collect_user_info(session))

        # Should I return a JSON or a JWT ?
        _cinfo = self.cdb[session["client_id"]]
        try:
            if "userinfo_signed_response_alg" in _cinfo:
                algo = _cinfo["userinfo_signed_response_alg"]
                # Use my key for signing
                key = self.keyjar.get_signing_key(alg2keytype(algo), "")
                if not key:
                    return self._error(error="access_denied",
                                       descr="Missing signing key")
                jinfo = info.to_jwt(key, algo)
                content_type = "application/jwt"
                if "userinfo_encrypted_response_alg" in _cinfo:
                    # encrypt with clients public key
                    jinfo = self.encrypt(jinfo, _cinfo, session["client_id"],
                                         "userinfo")
            elif "userinfo_encrypted_response_alg" in _cinfo:
                jinfo = self.encrypt(info.to_json(), _cinfo, session["client_id"],
                                     "userinfo")
                content_type = "application/jwt"
            else:
                jinfo = info.to_json()
                content_type = "application/json"
        except JWEException:
            return self._error(error="access_denied",
                               descr="Could not encrypt")

        return Response(jinfo, content=content_type)

    #noinspection PyUnusedLocal
    def check_session_endpoint(self, request, **kwargs):
        """
        """
        try:
            _log_debug = kwargs["logger"].debug
            _log_info = kwargs["logger"].info
        except KeyError:
            _log_debug = logger.debug
            _log_info = logger.info

        if not request:
            _tok = kwargs["authn"]
            if not _tok:
                return self._error(error="access_denied", descr="Illegal token")
            else:
                info = "id_token=%s" % _tok

        if self.test_mode:
            _log_info("check_session_request: %s" % request)
        idt = self.server.parse_check_session_request(query=request)
        if self.test_mode:
            _log_info("check_session_response: %s" % idt.to_dict())

        return Response(idt.to_json(), content="application/json")

    @staticmethod
    def _verify_url(url, urlset):
        part = urlparse.urlparse(url)

        for reg, qp in urlset:
            _part = urlparse.urlparse(reg)
            if part.scheme == _part.scheme and part.netloc == _part.netloc:
                    return True

        return False

    def do_client_registration(self, request, client_id, ignore=None):
        if ignore is None:
            ignore = []

        _cinfo = self.cdb[client_id].copy()
        logger.debug("_cinfo: %s" % _cinfo)

        for key, val in request.items():
            if key not in ignore:
                _cinfo[key] = val

        if "post_logout_redirect_uris" in request:
            plruri = []
            for uri in request["post_logout_redirect_uris"]:
                if urlparse.urlparse(uri).fragment:
                    err = ClientRegistrationErrorResponse(
                        error="invalid_configuration_parameter",
                        error_description="post_logout_redirect_uris contains fragment")
                    return Response(err.to_json(),
                                    content="application/json",
                                    status="400 Bad Request")
                base, query = urllib.splitquery(uri)
                if query:
                    plruri.append((base, urlparse.parse_qs(query)))
                else:
                    plruri.append((base, query))
            _cinfo["post_logout_redirect_uris"] = plruri

        if "redirect_uris" in request:
            ruri = []
            for uri in request["redirect_uris"]:
                if urlparse.urlparse(uri).fragment:
                    err = ClientRegistrationErrorResponse(
                        error="invalid_configuration_parameter",
                        error_description="redirect_uri contains fragment")
                    return Response(err.to_json(),
                                    content="application/json",
                                    status="400 Bad Request")
                base, query = urllib.splitquery(uri)
                if query:
                    ruri.append((base, urlparse.parse_qs(query)))
                else:
                    ruri.append((base, query))
            _cinfo["redirect_uris"] = ruri

        if "sector_identifier_uri" in request:
            si_url = request["sector_identifier_uri"]
            try:
                res = self.server.http_request(si_url)
            except ConnectionError, err:
                logger.error("%s" % err)
                return self._error_response(
                    "invalid_configuration_parameter",
                    descr="Couldn't open sector_identifier_uri")

            if not res:
                return self._error_response(
                    "invalid_configuration_parameter",
                    descr="Couldn't open sector_identifier_uri")

            logger.debug("sector_identifier_uri => %s" % res.text)

            try:
                si_redirects = json.loads(res.text)
            except ValueError:
                return self._error_response(
                    "invalid_configuration_parameter",
                    descr="Error deserializing sector_identifier_uri content")

            if "redirect_uris" in request:
                logger.debug("redirect_uris: %s" % request["redirect_uris"])
                for uri in request["redirect_uris"]:
                    try:
                        assert uri in si_redirects
                    except AssertionError:
                        return self._error_response(
                            "invalid_configuration_parameter",
                            descr="redirect_uri missing from sector_identifiers"
                        )

            _cinfo["si_redirects"] = si_redirects
            _cinfo["sector_id"] = si_url
        elif "redirect_uris" in request:
            if len(request["redirect_uris"]) > 1:
                # check that the hostnames are the same
                host = ""
                for url in request["redirect_uris"]:
                    part = urlparse.urlparse(url)
                    _host = part.netloc.split(":")[0]
                    if not host:
                        host = _host
                    else:
                        try:
                            assert host == _host
                        except AssertionError:
                            return self._error_response(
                                "invalid_configuration_parameter",
                                descr=
                                "'sector_identifier_uri' must be registered")

        for item in ["policy_uri", "logo_uri"]:
            if item in request:
                if self._verify_url(request[item], _cinfo["redirect_uris"]):
                    _cinfo[item] = request[item]
                else:
                    return self._error_response(
                        "invalid_configuration_parameter",
                        descr="%s pointed to illegal URL" % item)

        try:
            self.keyjar.load_keys(request, client_id)
            try:
                logger.debug("keys for %s: [%s]" % (
                    client_id,
                    ",".join(["%s" % x for x in self.keyjar[client_id]])))
            except KeyError:
                pass
        except Exception, err:
            logger.error("Failed to load client keys: %s" % request.to_dict())
            logger.error("%s", err)
            err = ClientRegistrationErrorResponse(
                error="invalid_configuration_parameter",
                error_description="%s" % err)
            return Response(err.to_json(), content="application/json",
                            status="400 Bad Request")

        return _cinfo

    @staticmethod
    def comb_post_logout_redirect_uris(args):
        if "post_logout_redirect_uris" not in args:
            return

        val = []
        for base, query in args["post_logout_redirect_uris"]:
            if query:
                val.append("%s?%s" % (base, query))
            else:
                val.append(base)

        args["post_logout_redirect_uris"] = val

    @staticmethod
    def comb_redirect_uris(args):
        if "redirect_uris" not in args:
            return

        val = []
        for base, query in args["redirect_uris"]:
            if query:
                val.append("%s?%s" % (base, query))
            else:
                val.append(base)

        args["redirect_uris"] = val

    #noinspection PyUnusedLocal
    def l_registration_endpoint(self, request, authn=None, **kwargs):
        _log_debug = logger.debug
        _log_info = logger.info

        _log_debug("@registration_endpoint: <<%s>>" % request)

        try:
            request = RegistrationRequest().deserialize(request, "json")
        except ValueError:
            request = RegistrationRequest().deserialize(request)

        _log_info("registration_request:%s" % request.to_dict())
        resp_keys = request.keys()

        try:
            request.verify()
        except MessageException, err:
            if "type" not in request:
                return self._error(error="invalid_type", 
                                   descr="%s" % err)
            else:
                return self._error(error="invalid_configuration_parameter",
                                   descr="%s" % err)

        _keyjar = self.server.keyjar

        # create new id och secret
        client_id = rndstr(12)
        while client_id in self.cdb:
            client_id = rndstr(12)

        client_secret = secret(self.seed, client_id)

        _rat = rndstr(32)
        reg_enp = ""
        for endp in self.endp:
            if endp == RegistrationEndpoint:
                reg_enp = "%s%s" % (self.baseurl, endp.etype)
                break

        self.cdb[client_id] = {
            "client_id": client_id,
            "client_secret": client_secret,
            "registration_access_token": _rat,
            "registration_client_uri": "%s?client_id=%s" % (reg_enp, client_id),
            "client_secret_expires_at": utc_time_sans_frac() + 86400,
            "client_id_issued_at": utc_time_sans_frac()}

        self.cdb[_rat] = client_id

        _cinfo = self.do_client_registration(request, client_id,
                                             ignore=["redirect_uris",
                                                     "policy_uri",
                                                     "logo_uri"])
        if isinstance(_cinfo, Response):
            return _cinfo

        args = dict([(k, v) for k, v in _cinfo.items()
                     if k in RegistrationResponse.c_param])

        self.comb_redirect_uris(args)
        self.comb_post_logout_redirect_uris(args)
        response = RegistrationResponse(**args)

        # Add the client_secret as a symmetric key to the keyjar
        if client_secret:
            _kc = KeyBundle([{"kty": "oct", "key": client_secret,
                              "use": "ver"},
                             {"kty": "oct", "key": client_secret,
                              "use": "sig"}])
            try:
                _keyjar[client_id].append(_kc)
            except KeyError:
                _keyjar[client_id] = [_kc]

        self.cdb[client_id] = _cinfo
        _log_info("Client info: %s" % _cinfo)

        logger.debug("registration_response: %s" % response.to_dict())

        return Response(response.to_json(), content="application/json",
                        headers=[("Cache-Control", "no-store")])

    def registration_endpoint(self, request, authn=None, **kwargs):
        return self.l_registration_endpoint(request, authn, **kwargs)

    def read_registration(self, authn, request, **kwargs):
        """
        Read all information this server has on a client.
        Authorization is done by using the access token that was return as
        part of the client registration result.

        :param authn: The Authorization HTTP header
        :param request: The query part of the URL
        :param kwargs: Any other arguments
        :return:
        """

        logger.debug("authn: %s, request: %s" % (authn, request))

        # verify the access token, has to be key into the client information
        # database.
        assert authn.startswith("Bearer ")
        token = authn[len("Bearer "):]

        client_id = self.cdb[token]

        # extra check
        _info = urlparse.parse_qs(request)
        assert _info["client_id"][0] == client_id

        logger.debug("Client '%s' reads client info" % client_id)
        args = dict([(k, v) for k, v in self.cdb[client_id].items()
                     if k in RegistrationResponse.c_param])

        self.comb_redirect_uris(args)
        response = RegistrationResponse(**args)

        return Response(response.to_json(), content="application/json",
                        headers=[("Cache-Control", "no-store")])

    def create_providerinfo(self, pcr_class=ProviderConfigurationResponse):
        _provider_info = pcr_class(
            issuer=self.baseurl,
            token_endpoint_auth_methods_supported=[
                "client_secret_post", "client_secret_basic",
                "client_secret_jwt", "private_key_jwt"],
            scopes_supported=["openid"],
            response_types_supported=["code", "token", "id_token",
                                      "code token", "code id_token",
                                      "token id_token",
                                      "code token id_token"],
            response_modes_supported=['query', 'fragment', 'form_post'],
            subject_types_supported=["public", "pairwise"],
            grant_types_supported=[
                "authorization_code", "implicit",
                "urn:ietf:params:oauth:grant-type:jwt-bearer"],
            claim_types_supported=["normal", "aggregated", "distributed"],
            claims_supported=SCOPE2CLAIMS.keys(),
            claims_parameter_supported="true",
            request_parameter_supported="true",
            request_uri_parameter_supported="true",
            version="3.0"
        )

        sign_algs = jws.SIGNER_ALGS.keys()
        for typ in ["userinfo", "id_token", "request_object",
                    "token_endpoint_auth"]:
            _provider_info["%s_signing_alg_values_supported" % typ] = sign_algs

        algs = jwe.SUPPORTED["alg"]
        for typ in ["userinfo", "id_token", "request_object"]:
            _provider_info["%s_encryption_alg_values_supported" % typ] = algs

        encs = jwe.SUPPORTED["enc"]
        for typ in ["userinfo", "id_token", "request_object"]:
            _provider_info["%s_encryption_enc_values_supported" % typ] = encs

        if not self.baseurl.endswith("/"):
            self.baseurl += "/"

        #keys = self.keyjar.keys_by_owner(owner=".")
        if self.jwks_uri and self.keyjar:
            _provider_info["jwks_uri"] = self.jwks_uri

        #acr_values
        if self.authn_broker:
            acr_values = self.authn_broker.getAcrValuesString()
            if acr_values is not None:
                _provider_info["acr_values_supported"] = acr_values

        for endp in self.endp:
            #_log_info("# %s, %s" % (endp, endp.name))
            _provider_info[endp(None).name] = "%s%s" % (self.baseurl, endp.etype)

        return _provider_info

    #noinspection PyUnusedLocal
    def providerinfo_endpoint(self, handle="", **kwargs):
        _log_debug = logger.debug
        _log_info = logger.info

        _log_info("@providerinfo_endpoint")
        try:
            _response = self.create_providerinfo()
            _log_info("provider_info_response: %s" % (_response.to_dict(),))

            headers = [("Cache-Control", "no-store"), ("x-ffo", "bar")]
            if handle:
                (key, timestamp) = handle
                if key.startswith(STR) and key.endswith(STR):
                    cookie = self.cookie_func(key, self.cookie_name, "pinfo",
                                              self.sso_ttl)
                    headers.append(cookie)

            resp = Response(_response.to_json(), content="application/json",
                            headers=headers)
        except Exception, err:
            message = traceback.format_exception(*sys.exc_info())
            logger.error(message)
            resp = Response(message, content="html/text")

        return resp

    #noinspection PyUnusedLocal
    def discovery_endpoint(self, request, handle=None, **kwargs):
        """
        :param request:
        :param handle:
        """

        _log_debug = logger.debug

        _log_debug("@discovery_endpoint")

        request = DiscoveryRequest().deserialize(request, "urlencoded")
        _log_debug("discovery_request:%s" % (request.to_dict(),))

        try:
            assert request["service"] == SWD_ISSUER
        except AssertionError:
            return BadRequest("Unsupported service")

        # verify that the principal is one of mine

        _response = DiscoveryResponse(locations=[self.baseurl])

        _log_debug("discovery_response:%s" % (_response.to_dict(),))

        headers = [("Cache-Control", "no-store")]
        (key, timestamp) = handle
        if key.startswith(STR) and key.endswith(STR):
            cookie = self.cookie_func(key, self.cookie_name, "disc",
                                      self.sso_ttl)
            headers.append(cookie)

        return Response(_response.to_json(), content="application/json",
                        headers=headers)

    def authz_part2(self, user, areq, sid, **kwargs):
        """
        After the authentication this is where you should end up
        """
        _log_debug = logger.debug
        _log_debug("- in authenticated() -")

        # Do the authorization
        try:
            info = OpenIDSchema(**self._collect_user_info(self.sdb[sid]))
            permission = self.authz(user)
            self.sdb.update(sid, "permission", permission)
        except Exception:
            raise

        _log_debug("response type: %s" % areq["response_type"])

        # create the response
        aresp = AuthorizationResponse()
        try:
            aresp["state"] = areq["state"]
        except KeyError:
            pass

        if "response_type" in areq and \
                len(areq["response_type"]) == 1 and \
                "none" in areq["response_type"]:
            fragment_enc = False
        else:
            if self.sdb.is_revoked(sid):
                return self._error(error="access_denied",
                                   descr="Token is revoked")

            _sinfo = self.sdb[sid]

            try:
                aresp["scope"] = areq["scope"]
            except KeyError:
                pass

            _log_debug("_dic: %s" % _sinfo)

            rtype = set(areq["response_type"][:])
            if len(rtype) == 1 and "code" in rtype:
                fragment_enc = False
            else:
                fragment_enc = True

            if "code" in areq["response_type"]:
                #if issue_new_code:
                #    scode = self.sdb.duplicate(_sinfo)
                #    _sinfo = self.sdb[scode]

                _code = aresp["code"] = _sinfo["code"]
                rtype.remove("code")
            else:
                self.sdb[sid]["code"] = None
                _code = None

            if "token" in rtype:
                _dic = self.sdb.upgrade_to_token(issue_refresh=False, key=sid)

                _log_debug("_dic: %s" % _dic)
                for key, val in _dic.items():
                    if key in aresp.parameters() and val is not None:
                        aresp[key] = val

                rtype.remove("token")

            try:
                _access_token = aresp["access_token"]
            except KeyError:
                _access_token = None

            if "id_token" in areq["response_type"]:
                user_info = self.userinfo_in_id_token_claims(_sinfo)
                client_info = self.cdb[areq["client_id"]]

                id_token = self.sign_encrypt_id_token(
                    _sinfo, client_info, areq, code=_code,
                    access_token=_access_token, user_info=user_info)

                aresp["id_token"] = id_token
                _sinfo["id_token"] = id_token
                rtype.remove("id_token")

            if len(rtype):
                return BadRequest("Unknown response type")

        try:
            redirect_uri = self.get_redirect_uri(areq)
        except (RedirectURIError, ParameterError), err:
            return BadRequest("%s" % err)

        # Must not use HTTP unless implicit grant type and native application

        # Use of the nonce is REQUIRED for all requests where an ID Token is
        # returned directly from the Authorization Endpoint
        if "id_token" in aresp:
            try:
                assert "nonce" in areq
            except AssertionError:
                return self._error("invalid_request", "Missing nonce value")

        # so everything went well should set a SSO cookie
        headers = [self.cookie_func(user, typ="sso", ttl=self.sso_ttl)]

        # Now about the response_mode. Should not be set if it's obvious
        # from the response_type. Knows about 'query', 'fragment' and
        # 'form_post'.

        if "response_mode" in areq:
            resp_mode = areq["response_mode"]
            if resp_mode == "form_post":
                argv = {"form_args": aresp.to_dict(),
                        "action": redirect_uri}
                mte = self.template_lookup.get_template(
                    self.template["form_post"])
                return Response(mte.render(**argv), headers=headers)
            elif resp_mode == 'fragment' and not fragment_enc:
                # Can't be done
                return self._error("invalid_request", "wrong response_mode")
            elif resp_mode == 'query' and fragment_enc:
                # Can't be done
                return self._error("invalid_request", "wrong response_mode")

        # Just do whatever is the default
        location = aresp.request(redirect_uri, fragment_enc)
        logger.debug("Redirected to: '%s' (%s)" % (location, type(location)))
        return Redirect(str(location), headers=headers)

    def key_setup(self, local_path, vault="keys", sig=None, enc=None):
        """
        my keys
        :param local_path: The path to where the JWKs should be stored
        :param vault: Where the private key will be stored
        :param sig: Key for signature
        :param enc: Key for encryption
        :return: A URL the RP can use to download the key.
        """
        self.jwks_uri = key_export(self.baseurl, local_path, vault, self.keyjar,
                                   fqdn=self.hostname, sig=sig, enc=enc)

    def register_endpoint(self, request="", **kwargs):
        pass

    def endsession_endpoint(self, request="", **kwargs):
        """

        :param request:
        :param kwargs:
        :return: Either a Response instance or a tuple (Response, args)
        """
        return self.end_session_endpoint(request, **kwargs)

# -----------------------------------------------------------------------------


class Endpoint(object):
    etype = ""

    def __init__(self, func):
        self.func = func

    @property
    def name(self):
        return "%s_endpoint" % self.etype

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)



########NEW FILE########
__FILENAME__ = aes
#!/usr/bin/env python
import os
from Crypto import Random
from Crypto.Cipher import AES
from base64 import b64encode, b64decode

__author__ = 'rolandh'

POSTFIX_MODE = {
    "cbc": AES.MODE_CBC,
    "cfb": AES.MODE_CFB,
    "ecb": AES.MODE_CFB,
}

BLOCK_SIZE = 16


def build_cipher(key, iv, alg="aes_128_cbc"):
    """
    :param key: encryption key
    :param iv: init vector
    :param alg: cipher algorithm
    :return: A Cipher instance
    """
    typ, bits, cmode = alg.split("_")

    if not iv:
        iv = Random.new().read(AES.block_size)
    else:
        assert len(iv) == AES.block_size

    if bits not in ["128", "192", "256"]:
        raise Exception("Unsupported key length")
    try:
        assert len(key) == int(bits) >> 3
    except AssertionError:
        raise Exception("Wrong Key length")

    try:
        return AES.new(key, POSTFIX_MODE[cmode], iv), iv
    except KeyError:
        raise Exception("Unsupported chaining mode")


def encrypt(key, msg, iv=None, alg="aes_128_cbc", padding="PKCS#7",
            b64enc=True, block_size=BLOCK_SIZE):
    """
    :param key: The encryption key
    :param iv: init vector
    :param msg: Message to be encrypted
    :param padding: Which padding that should be used
    :param b64enc: Whether the result should be base64encoded
    :param block_size: If PKCS#7 padding which block size to use
    :return: The encrypted message
    """

    if padding == "PKCS#7":
        _block_size = block_size
    elif padding == "PKCS#5":
        _block_size = 8
    else:
        _block_size = 0

    if _block_size:
        plen = _block_size - (len(msg) % _block_size)
        c = chr(plen)
        msg += c*plen

    cipher, iv = build_cipher(key, iv, alg)
    cmsg = iv + cipher.encrypt(msg)
    if b64enc:
        return b64encode(cmsg)
    else:
        return cmsg


def decrypt(key, msg, iv=None, padding="PKCS#7", b64dec=True):
    """
    :param key: The encryption key
    :param iv: init vector
    :param msg: Base64 encoded message to be decrypted
    :return: The decrypted message
    """
    if b64dec:
        data = b64decode(msg)
    else:
        data = msg

    _iv = data[:AES.block_size]
    if iv:
        assert iv == _iv
    cipher, iv = build_cipher(key, iv)
    res = cipher.decrypt(data)[AES.block_size:]
    if padding in ["PKCS#5", "PKCS#7"]:
        res = res[:-ord(res[-1])]
    return res

if __name__ == "__main__":
    key_ = "1234523451234545"  # 16 byte key
    # Iff padded the message doesn't have to be multiple of 16 in length
    msg_ = "ToBeOrNotTobe W.S."
    iv_ = os.urandom(16)
    encrypted_msg = encrypt(key_, msg_, iv_)
    txt = decrypt(key_, encrypted_msg, iv_)
    assert txt == msg_

    encrypted_msg = encrypt(key_, msg_, 0)
    txt = decrypt(key_, encrypted_msg, 0)
    assert txt == msg_

########NEW FILE########
__FILENAME__ = authn_context
__author__ = 'rolandh'

UNSPECIFIED = "urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified"
INTERNETPROTOCOLPASSWORD = \
    'urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword'
MOBILETWOFACTORCONTRACT = \
    'urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract'
PASSWORDPROTECTEDTRANSPORT = \
    'urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport'
PASSWORD = 'urn:oasis:names:tc:SAML:2.0:ac:classes:Password'
TLSCLIENT = 'urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient'
TIMESYNCTOKEN = "urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken"

CMP_TYPE = ['exact', 'minimum', 'maximum', 'better']


class AuthnBroker(object):
    def __init__(self):
        self.db = {"info": {}, "key": {}}
        self.next = 0

    @staticmethod
    def exact(a, b):
        return a == b

    @staticmethod
    def minimum(a, b):
        return b >= a

    @staticmethod
    def maximum(a, b):
        return b <= a

    @staticmethod
    def better(a, b):
        return b > a

    def add(self, acr, method, level=0, authn_authority=""):
        """
        Adds a new authentication method.
        Assumes not more than one authentication method per type.

        :param acr: Add to what the authentication endpoint offers for this acr
        :param method: A identifier of the authentication method.
        :param level: security level, positive integers, 0 is lowest
        :return:
        """

        _info = {
            "ref": acr,
            "method": method,
            "level": level,
            "authn_auth": authn_authority
        }

        self.next += 1
        _ref = str(self.next)
        self.db["info"][_ref] = _info
        try:
            self.db["key"][acr].append(_ref)
        except KeyError:
            self.db["key"][acr] = [_ref]

    def remove(self, acr, method=None, level=0, authn_authority=""):
        try:
            _refs = self.db["key"][acr]
        except KeyError:
            return
        else:
            _remain = []
            for _ref in _refs:
                item = self.db["info"][_ref]
                if method and method != item["method"]:
                    _remain.append(_ref)
                if level and level != item["level"]:
                    _remain.append(_ref)
                if authn_authority and \
                        authn_authority != item["authn_authority"]:
                    _remain.append(_ref)
            if _remain:
                self.db[acr] = _remain

    @staticmethod
    def _cmp(item0, item1):
        v0 = item0[0]
        v1 = item1[0]
        if v0 > v1:
            return 1
        elif v0 == v1:
            return 0
        else:
            return -1

    def _pick_by_class_ref(self, acr, comparision_type="exact"):
        func = getattr(self, comparision_type)
        try:
            _refs = self.db["key"][acr]
        except KeyError:
            return []
        else:
            _info = self.db["info"]
            _item = _info[_refs[0]]
            _level = _item["level"]
            if comparision_type != "better":
                if _item["method"]:
                    res = [(_level, _item["method"], _item["ref"])]
                else:
                    res = []
            else:
                res = []

            for ref in _refs[1:]:
                item = _info[ref]
                res.append((item["level"], item["method"], item["ref"]))
                if func(_level, item["level"]):
                    _level = item["level"]
            res_other = []
            if comparision_type != "exact":
                for ref, _dic in _info.items():
                    if ref in _refs:
                        continue
                    elif func(_level, _dic["level"]):
                        if _dic["method"]:
                            _val = (_dic["level"], _dic["method"], _dic["ref"])
                            if _val not in res:
                                res_other.append(_val)
            # sort on level
            res.sort(self._cmp, reverse=True)
            res_other.sort(self._cmp, reverse=True)
            res.extend(res_other)

            return [(b, c) for a, b, c in res]

    def get_method(self, name):
        for key, item in self.db["info"].items():
            if item["method"].__class__.__name__ == name:
                return item["method"]
        raise KeyError("No method by that name")

    def pick(self, acr=None, comparision_type="minimum"):
        """
        Given the authentication context find zero or more places where
        the user could be sent next. Ordered according to security level.

        :param acr: The authentication class reference requested
        :param comparision_type: If the caller wants exact, at a minimum,
            ... this level
        :return: An URL
        """

        if not comparision_type:
            comparision_type = "minimum"

        if acr is None:
            # Anything else doesn't make sense
            return self._pick_by_class_ref(UNSPECIFIED, "minimum")
        else:
            return self._pick_by_class_ref(acr, comparision_type)

    @staticmethod
    def match(requested, provided):
        if requested == provided:
            return True
        else:
            return False

    def __getitem__(self, item):
        i = 0
        for key, info in self.db["info"].items():
            if i == item:
                return info["method"], info["ref"]
            i += 1

        raise IndexError()

    def getAcrValuesString(self):
        acr_values = None
        for item in self.db["info"].values():
            if acr_values is None:
                acr_values = item["ref"]
            else:
                acr_values += " " + item["ref"]
        return acr_values

    def __iter__(self):
        for item in self.db["info"].values():
            yield item["method"]
        raise StopIteration

    def __len__(self):
        return len(self.db["info"].keys())

########NEW FILE########
__FILENAME__ = client
import logging
from jwkest import Invalid
from jwkest import MissingKey
from jwkest.jws import alg2keytype
from oic.exception import UnknownAssertionType
from oic.exception import NotForMe
from oic.oauth2 import rndstr, VREQUIRED
from oic.oauth2 import SINGLE_OPTIONAL_STRING
from oic.oic import REQUEST2ENDPOINT
from oic.oic import DEF_SIGN_ALG
from oic.oic import AuthnToken
from oic.oic import JWT_BEARER
from oic.utils.time_util import utc_now


logger = logging.getLogger(__name__)

__author__ = 'rolandh'


class AuthnFailure(Exception):
    pass


# ========================================================================
def assertion_jwt(cli, keys, audience, algorithm):
    _now = utc_now()

    at = AuthnToken(iss=cli.client_id, sub=cli.client_id,
                    aud=audience, jti=rndstr(8),
                    exp=_now + 600, iat=_now)
    return at.to_jwt(key=keys, algorithm=algorithm)


class ClientAuthnMethod(object):
    def __init__(self, cli=None):
        """
        :param cli: Client instance
        """
        self.cli = cli

    def construct(self, **kwargs):
        """ Add authentication information to a request
        :return:
        """
        raise NotImplementedError

    def verify(self, **kwargs):
        """
        Verify authentication information in a request
        :param kwargs:
        :return:
        """
        raise NotImplementedError


class ClientSecretBasic(ClientAuthnMethod):
    """
    Clients that have received a client_secret value from the Authorization
    Server, authenticate with the Authorization Server in accordance with
    Section 3.2.1 of OAuth 2.0 [RFC6749] using HTTP Basic authentication scheme.
    """
    def construct(self, cis, request_args=None, http_args=None, **kwargs):
        """
        :param cis: Request class instance
        :param request_args: Request arguments
        :param http_args: HTTP arguments
        :return: dictionary of HTTP arguments
        """

        if http_args is None:
            http_args = {}

        try:
            passwd = kwargs["password"]
        except KeyError:
            try:
                passwd = http_args["password"]
            except KeyError:
                try:
                    passwd = cis["client_secret"]
                except KeyError:
                    passwd = self.cli.client_secret

        try:
            user = kwargs["user"]
        except KeyError:
            user = self.cli.client_id

        http_args["auth"] = (user, passwd)

        try:
            del cis["client_secret"]
        except KeyError:
            pass

        if cis and not cis.c_param["client_id"][VREQUIRED]:
            try:
                del cis["client_id"]
            except KeyError:
                pass

        return http_args

    def verify(self, areq, client_id, **kwargs):
        if self.cli.cdb[client_id]["client_secret"] == areq["client_secret"]:
            return client_id
        else:
            raise AuthnFailure()


class ClientSecretPost(ClientSecretBasic):
    """
    Clients that have received a client_secret value from the Authorization
    Server, authenticate with the Authorization Server in accordance with
    Section 3.2.1 of OAuth 2.0 [RFC6749] by including the Client Credentials in
    the request body.
    """
    def construct(self, cis, request_args=None, http_args=None, **kwargs):
        if "client_secret" not in cis:
            try:
                cis["client_secret"] = http_args["client_secret"]
                del http_args["client_secret"]
            except (KeyError, TypeError):
                if self.cli.client_secret:
                    cis["client_secret"] = self.cli.client_secret
                else:
                    raise AuthnFailure("Missing client secret")

        cis["client_id"] = self.cli.client_id

        return http_args


class BearerHeader(ClientAuthnMethod):
    def construct(self, cis=None, request_args=None, http_args=None,
                  **kwargs):
        """
        More complicated logic then I would have liked it to be

        :param cli: Client instance
        :param cis: Request class instance
        :param request_args: request arguments
        :param http_args: HTTP header arguments
        :param kwargs:
        :return:
        """

        if cis:
            if "access_token" in cis:
                _acc_token = cis["access_token"]
                del cis["access_token"]
                # Required under certain circumstances :-) not under other
                cis.c_param["access_token"] = SINGLE_OPTIONAL_STRING
            else:
                try:
                    _acc_token = request_args["access_token"]
                    del request_args["access_token"]
                except (KeyError, TypeError):
                    try:
                        _acc_token = kwargs["access_token"]
                    except KeyError:
                        try:
                            _ = kwargs["state"]
                        except KeyError:
                            if not self.cli.state:
                                raise Exception("Missing state specification")
                            kwargs["state"] = self.cli.state

                        _acc_token = self.cli.get_token(**kwargs).access_token
        else:
            try:
                _acc_token = kwargs["access_token"]
            except KeyError:
                _acc_token = request_args["access_token"]

        # Do I need to base64 encode the access token ? Probably !
        #_bearer = "Bearer %s" % base64.b64encode(_acc_token)
        _bearer = "Bearer %s" % _acc_token
        if http_args is None:
            http_args = {"headers": {}}
            http_args["headers"]["Authorization"] = _bearer
        else:
            try:
                http_args["headers"]["Authorization"] = _bearer
            except KeyError:
                http_args["headers"] = {"Authorization": _bearer}

        return http_args

    def verify(self, environ, **kwargs):
        try:
            cred = environ["HTTP_AUTHORIZATION"]
        except KeyError:
            raise AuthnFailure("missing authorization info")

        try:
            assert cred.startswith("Bearer ")
        except AssertionError:
            raise AuthnFailure("Wrong type of authorization token")

        label, token = cred.split(" ")
        return token


class BearerBody(ClientAuthnMethod):
    def construct(self, cis, request_args=None, http_args=None, **kwargs):
        if request_args is None:
            request_args = {}

        if "access_token" in cis:
            pass
        else:
            try:
                cis["access_token"] = request_args["access_token"]
            except KeyError:
                try:
                    _ = kwargs["state"]
                except KeyError:
                    if not self.cli.state:
                        raise Exception("Missing state specification")
                    kwargs["state"] = self.cli.state

                cis["access_token"] = self.cli.get_token(**kwargs).access_token

        return http_args


def bearer_auth(req, authn):
    """
    Pick out the access token, either in HTTP_Authorization header or
    in request body.

    :param req:
    :param authn:
    :return:
    """

    try:
        return req["access_token"]
    except KeyError:
        assert authn.startswith("Bearer ")
        return authn[7:]


class JWSAuthnMethod(ClientAuthnMethod):

    def choose_algorithm(self, entity, **kwargs):
        try:
            algorithm = kwargs["algorithm"]
        except KeyError:
            algorithm = DEF_SIGN_ALG[entity]
        if not algorithm:
            raise Exception("Missing algorithm specification")
        return algorithm

    def get_signing_key(self, algorithm):
        return self.cli.keyjar.get_signing_key(alg2keytype(algorithm))

    def construct(self, cis, request_args=None, http_args=None, **kwargs):
        """
        Constructs a client assertion and signs it with a key.
        The request is modified as a side effect.

        :param cis: The request
        :param request_args: request arguments
        :param http_args: HTTP arguments
        :param kwargs: Extra arguments
        :return: Constructed HTTP arguments, in this case none
        """

        # audience is the OP endpoint
        audience = self.cli._endpoint(REQUEST2ENDPOINT[cis.type()])

        algorithm = self.choose_algorithm(**kwargs)
        signing_key = self.get_signing_key(algorithm)

        cis["client_assertion"] = assertion_jwt(self.cli, signing_key, audience,
                                                algorithm)
        cis["client_assertion_type"] = JWT_BEARER

        try:
            del cis["client_secret"]
        except KeyError:
            pass

        return {}

    def verify(self, areq, **kwargs):
        try:
            bjwt = AuthnToken().from_jwt(areq["client_assertion"],
                                         keyjar=self.cli.keyjar)
        except (Invalid, MissingKey), err:
            logger.info("%s" % err)
            return False

        logger.debug("authntoken: %s" % bjwt.to_dict())
        logger.debug("known clients: %s" % self.cli.cdb.keys())
        try:
            # There might not be a client_id in the request
            assert str(bjwt["iss"]) in self.cli.cdb  # It's a client I know
        except KeyError:
            pass

        # aud can be a string or a list
        _aud = bjwt["aud"]
        logger.debug("audience: %s, baseurl: %s" % (_aud, self.cli.baseurl))
        try:
            if isinstance(_aud, basestring):
                assert str(_aud).startswith(self.cli.baseurl)
            else:
                for target in _aud:
                    if target.startswith(self.cli.baseurl):
                        return True
                raise NotForMe("Not for me!")
        except AssertionError:
            raise NotForMe("Not for me!")

        return True


class ClientSecretJWT(JWSAuthnMethod):
    """
    Clients that have received a client_secret value from the Authorization
    Server create a JWT using an HMAC SHA algorithm, such as HMAC SHA-256.
    The HMAC (Hash-based Message Authentication Code) is calculated using the
    bytes of the UTF-8 representation of the client_secret as the shared key.
    """
    def choose_algorithm(self, entity="client_secret_jwt", **kwargs):
        return JWSAuthnMethod.choose_algorithm(self, entity, **kwargs)

    def get_signing_key(self, algorithm):
        return self.cli.keyjar.get_signing_key(alg2keytype(algorithm))


class PrivateKeyJWT(JWSAuthnMethod):
    """
    Clients that have registered a public key sign a JWT using that key.
    """
    def choose_algorithm(self, entity="private_key_jwt", **kwargs):
        return JWSAuthnMethod.choose_algorithm(self, entity, **kwargs)

    def get_signing_key(self, algorithm):
        return self.cli.keyjar.get_signing_key(alg2keytype(algorithm), "")


#from oic.utils.authn.client_saml import SAML2_BEARER_ASSERTION_TYPE


CLIENT_AUTHN_METHOD = {
    "client_secret_basic": ClientSecretBasic,
    "client_secret_post": ClientSecretPost,
    "bearer_header": BearerHeader,
    "bearer_body": BearerBody,
    "client_secret_jwt": ClientSecretJWT,
    "private_key_jwt": PrivateKeyJWT,
}

TYPE_METHOD = [(JWT_BEARER, JWSAuthnMethod)]


def verify_client(inst, areq, authn, type_method=TYPE_METHOD):
    """

    :param areq: The request
    :param authn: client authentication information
    :return:
    """

    client_id = inst.get_client_id(areq, authn)

    logger.debug("Verified Client ID: %s" % client_id)

    if "client_secret" in areq:  # client_secret_post/client_secret_basic
        return ClientSecretBasic(inst).verify(areq, client_id)
    elif "client_assertion" in areq:  # client_secret_jwt or public_key_jwt
        for typ, method in type_method:
            if areq["client_assertion_type"] == typ:
                return method(inst).verify(areq)
        else:
            raise UnknownAssertionType(areq["client_assertion_type"])
    else:
        return client_id

########NEW FILE########
__FILENAME__ = client_saml
import base64
from oic.utils.authn.client import ClientAuthnMethod
from oic.utils.authn.client import CLIENT_AUTHN_METHOD

__author__ = 'rolandh'

SAML2_BEARER_ASSERTION_TYPE = \
    "urn:ietf:params:oauth:client-assertion-type:saml2-bearer"

try:
    from saml2.saml import assertion_from_string
except ImportError:
    pass
else:
    class SAML2AuthnMethod(ClientAuthnMethod):
        """
        Authenticating clients using the SAML2 assertion profile
        """
        def construct(self, cis, assertion=None, **kwargs):
            """

            :param cis: The request
            :param assertion: A SAML2 Assertion
            :param kwargs: Extra arguments
            :return: Constructed HTTP arguments, in this case none
            """

            cis["client_assertion"] = base64.urlsafe_b64encode(str(assertion))
            cis["client_assertion_type"] = SAML2_BEARER_ASSERTION_TYPE

        def verify(self, areq, **kwargs):
            xmlstr = base64.urlsafe_b64decode(areq["client_assertion"])
            try:
                assertion = assertion_from_string(xmlstr)
            except:
                return False
            return self._verify_saml2_assertion(assertion)

        def _verify_saml2_assertion(self, assertion):
            subject = assertion.subject
            #client_id = subject.name_id.text
            #who_ever_issued_it = assertion.issuer.text

            audience = []
            for ar in subject.audience_restiction:
                for aud in ar.audience:
                    audience.append(aud)

    CLIENT_AUTHN_METHOD["saml2_bearer"] = SAML2AuthnMethod

########NEW FILE########
__FILENAME__ = ldapc
import ldap
from oic.utils.authn.user import UsernamePasswordMako

SCOPE_MAP = {
    "base": ldap.SCOPE_BASE,
    "onelevel": ldap.SCOPE_ONELEVEL,
    "subtree": ldap.SCOPE_SUBTREE
}


class LDAPAuthn(UsernamePasswordMako):
    def __init__(self, srv, ldapsrv, return_to, pattern, mako_template,
                 template_lookup, ldap_user="", ldap_pwd=""):
        """
        :param srv: The server instance
        :param ldapsrv: Which LDAP server to us
        :param return_to: Where to send the user after authentication
        :param pattern: How to find the entry to log in to.
            Expected to be a dictionary where key is one of "dn" or "search".
            And the value a dictionary with values depends on the key:
            If "dn" only "pattern".
            If "search": "base", "filterstr", "scope"
                "base" and "filterstr" MUST be present
        :param ldap_user: If a search has to be done first which user to do
            that as. "" is a anonymous user
        :param ldap_pwd: The password for the ldap_user
        """
        UsernamePasswordMako.__init__(self, srv, mako_template, template_lookup,
                                      None, return_to)

        self.ldap = ldap.initialize(ldapsrv)
        self.ldap.protocol_version = 3
        self.ldap.set_option(ldap.OPT_REFERRALS, 0)
        self.pattern = pattern
        self.ldap_user = ldap_user
        self.ldap_pwd = ldap_pwd

    def _verify(self, pwd, user):
        """
        Verifies the username and password against a LDAP server
        :param pwd: The password
        :param user: The username
        :return: AssertionError if the LDAP verification failed.
        """
        try:
            _dn = self.pattern["dn"]["pattern"] % user
        except KeyError:
            try:
                _pat = self.pattern["search"]
            except:
                raise Exception("unknown pattern")
            else:
                args = {
                    "filterstr": _pat["filterstr"] % user,
                    "base": _pat["base"]}
                if not "scope" in args:
                    args["scope"] = ldap.SCOPE_SUBTREE
                else:
                    args["scope"] = SCOPE_MAP[args["scope"]]

                self.ldap.simple_bind_s(self.ldap_user, self.ldap_pwd)

                result = self.ldap.search_s(**args)
                # result is a list of tuples (dn, entry)
                if not result:
                    raise AssertionError()
                elif len(result) > 1:
                    raise AssertionError()
                else:
                    _dn = result[0][0]

        try:
            self.ldap.simple_bind_s(_dn, pwd)
        except Exception:
            raise AssertionError()

########NEW FILE########
__FILENAME__ = ldap_member
import logging
from oic.utils.userinfo.ldap_info import UserInfoLDAP

__author__ = 'haho0032'

logger = logging.getLogger(__name__)


class UserLDAPMemberValidation(UserInfoLDAP):

    def __init__(self, verify_attr=None, verify_attr_valid=None, **kwargs):
        UserInfoLDAP.__init__(self, **kwargs)
        self.verify_attr = verify_attr
        self.verify_attr_valid = verify_attr_valid

    def __call__(self, userid, **kwargs):
        result = UserInfoLDAP.__call__(self, userid, None, False)
        if self.verify_attr in result:
            for field in result[self.verify_attr]:
                if field in self.verify_attr_valid:
                    return True
        logger.warning(userid + "tries to use the service with the values " +
                       result)
        return False

########NEW FILE########
__FILENAME__ = user
import base64
import logging
import time
from urllib import urlencode
import urllib
from urlparse import parse_qs
from urlparse import urlsplit
import urlparse

#from oic.utils.aes_m2c import AES_decrypt
from oic.utils import aes
from oic.utils.http_util import Response
from oic.utils.http_util import CookieDealer
from oic.utils.http_util import InvalidCookieSign
from oic.utils.http_util import Redirect
from oic.utils.http_util import Unauthorized

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


class NoSuchAuthentication(Exception):
    pass


class TamperAllert(Exception):
    pass


class ToOld(Exception):
    pass


class FailedAuthentication(Exception):
    pass


class UserAuthnMethod(CookieDealer):
    def __init__(self, srv, ttl=5):
        CookieDealer.__init__(self, srv, ttl)
        self.query_param = "upm_answer"

    def __call__(self, *args, **kwargs):
        raise NotImplemented

    def authenticated_as(self, cookie=None, **kwargs):
        if cookie is None:
            return None
        else:
            logger.debug("kwargs: %s" % kwargs)

            try:
                val = self.getCookieValue(cookie, self.srv.cookie_name)
            except (InvalidCookieSign, AssertionError):
                val = None

            if val is None:
                return None
            else:
                uid, _ts, typ = val

            if typ == "uam":  # shortlived
                _now = int(time.mktime(time.gmtime()))
                if _now > (int(_ts) + int(self.cookie_ttl * 60)):
                    logger.debug("Authentication timed out")
                    raise ToOld("%d > (%d + %d)" % (_now, int(_ts),
                                                    int(self.cookie_ttl * 60)))
            else:
                if "max_age" in kwargs and kwargs["max_age"]:
                    _now = int(time.mktime(time.gmtime()))
                    if _now > (int(_ts) + int(kwargs["max_age"])):
                        logger.debug("Authentication too old")
                        raise ToOld("%d > (%d + %d)" % (
                            _now, int(_ts), int(kwargs["max_age"])))

            return {"uid": uid}

    def generate_return_url(self, return_to, uid):
        return create_return_url(return_to, uid, **{self.query_param: "true"})

    def verify(self, **kwargs):
        raise NotImplemented


def url_encode_params(params=None):
    if not isinstance(params, dict):
        raise Exception("You must pass in a dictionary!")
    params_list = []
    for k, v in params.items():
        if isinstance(v, list):
            params_list.extend([(k, x) for x in v])
        else:
            params_list.append((k, v))
    return urlencode(params_list)


def create_return_url(base, query, **kwargs):
    """
    Add a query string plus extra parameters to a base URL which may contain
    a query part already.

    :param base: redirect_uri may contain a query part, no fragment allowed.
    :param query: Old query part as a string
    :param kwargs: extra query parameters
    :return:
    """
    part = urlsplit(base)
    if part.fragment:
        raise ValueError("Base URL contained parts it shouldn't")

    for key, values in parse_qs(query).items():
        if key in kwargs:
            if isinstance(kwargs[key], basestring):
                kwargs[key] = [kwargs[key]]
            kwargs[key].extend(values)
        else:
            kwargs[key] = values

    if part.query:
        for key, values in parse_qs(part.query).items():
            if key in kwargs:
                if isinstance(kwargs[key], basestring):
                    kwargs[key] = [kwargs[key]]
                kwargs[key].extend(values)
            else:
                kwargs[key] = values

        _pre = base.split("?")[0]
    else:
        _pre = base

    logger.debug("kwargs: %s" % kwargs)
    if kwargs:
        return "%s?%s" % (_pre, url_encode_params(kwargs))
    else:
        return _pre


class UsernamePasswordMako(UserAuthnMethod):
    """Do user authentication using the normal username password form in a
    WSGI environment using Mako as template system"""

    def __init__(self, srv, mako_template, template_lookup, pwd, return_to="",
                 templ_arg_func=None, verification_endpoint="verify"):
        """
        :param srv: The server instance
        :param mako_template: Which Mako template to use
        :param pwd: Username/password dictionary like database
        :param return_to: Where to send the user after authentication
        :return:
        """
        UserAuthnMethod.__init__(self, srv)
        self.mako_template = mako_template
        self.template_lookup = template_lookup
        self.passwd = pwd
        self.return_to = return_to
        self.verification_endpoint = verification_endpoint
        if templ_arg_func:
            self.templ_arg_func = templ_arg_func
        else:
            self.templ_arg_func = self.template_args

    def template_args(self, **kwargs):
        """
        Method to override if necessary, dependent on the page layout
        and context

        :param kwargs:
        :return: dictionary of parameters used to build the Authn page
        """
        acr = None
        try:
            req = urlparse.parse_qs(kwargs["query"])
            acr = req["acr_values"][0]
        except KeyError:
            pass

        try:
            action = kwargs["action"]
        except KeyError:
            action = self.verification_endpoint

        argv = {"password": "",
                "action": action,
                "acr": acr}

        try:
            argv["login"] = kwargs["as_user"]
        except KeyError:
            argv["login"] = ""

        for param in ["policy_uri", "logo_uri", "query"]:
            try:
                argv[param] = kwargs[param]
            except KeyError:
                argv[param] = ""

        if "extra" in kwargs:
            for param in kwargs["extra"]:
                try:
                    argv[param] = kwargs[param]
                except KeyError:
                    argv[param] = ""

        return argv

    def __call__(self, cookie=None, **kwargs):
        """
        Put up the login form
        """
        if cookie:
            headers = [cookie]
        else:
            headers = []

        resp = Response(headers=headers)

        argv = self.templ_arg_func(**kwargs)
        logger.info("do_authentication argv: %s" % argv)
        mte = self.template_lookup.get_template(self.mako_template)
        resp.message = mte.render(**argv)
        return resp

    def _verify(self, pwd, user):
        assert pwd == self.passwd[user]

    def verify(self, request, **kwargs):
        """
        Verifies that the given username and password was correct
        :param request: Either the query part of a URL a urlencoded
        body of a HTTP message or a parse such.
        :param kwargs: Catch whatever else is sent.
        :return: redirect back to where ever the base applications
        wants the user after authentication.
        """

        logger.debug("verify(%s)" % request)
        if isinstance(request, basestring):
            _dict = parse_qs(request)
        elif isinstance(request, dict):
            _dict = request
        else:
            raise ValueError("Wrong type of input")

        logger.debug("dict: %s" % _dict)
        logger.debug("passwd: %s" % self.passwd)
        # verify username and password
        try:
            self._verify(_dict["password"][0], _dict["login"][0])
        except (AssertionError, KeyError):
            resp = Unauthorized("Unknown user or wrong password")
        else:
            cookie = self.create_cookie(_dict["login"][0], "upm")
            try:
                _qp = _dict["query"][0]
            except KeyError:
                _qp = ""
            try:
                return_to = self.generate_return_url(kwargs["return_to"], _qp)
            except KeyError:
                return_to = self.generate_return_url(self.return_to, _qp)
            resp = Redirect(return_to, headers=[cookie])

        return resp

    def done(self, areq):
        try:
            _ = areq[self.query_param]
            return False
        except KeyError:
            return True


class BasicAuthn(UserAuthnMethod):

    def __init__(self, srv, pwd, ttl=5):
        UserAuthnMethod.__init__(self, srv, ttl)
        self.passwd = pwd

    def verify_password(self, user, password):
        try:
            assert password == self.passwd[user]
        except (AssertionError, KeyError):
            raise FailedAuthentication()

    def authenticated_as(self, cookie=None, authorization="", **kwargs):
        """

        :param cookie: A HTTP Cookie
        :param authorization: The HTTP Authorization header
        :param args: extra args
        :param kwargs: extra key word arguments
        :return:
        """
        if authorization.startswith("Basic"):
            authorization = authorization[6:]

        (user, pwd) = base64.b64decode(authorization).split(":")
        user = urllib.unquote(user)
        self.verify_password(user, pwd)
        return {"uid": user}


class SymKeyAuthn(UserAuthnMethod):

    def __init__(self, srv, ttl, symkey):
        UserAuthnMethod.__init__(self, srv, ttl)
        self.symkey = symkey

    def authenticated_as(self, cookie=None, authorization="", **kwargs):
        """

        :param cookie: A HTTP Cookie
        :param authorization: The HTTP Authorization header
        :param args: extra args
        :param kwargs: extra key word arguments
        :return:
        """
        (encmsg, iv) = base64.b64decode(authorization).split(":")
        try:
            user = aes.decrypt(self.symkey, encmsg, iv)
        except (AssertionError, KeyError):
            raise FailedAuthentication()

        return {"uid": user}

########NEW FILE########
__FILENAME__ = user_cas
import json
import urllib
import urlparse
import uuid
import logging
import requests
import base64
import xml.etree.ElementTree as ET
from oic.utils.authn.user import UserAuthnMethod
from urlparse import parse_qs
from oic.utils.http_util import Redirect
from oic.utils.http_util import Unauthorized

logger = logging.getLogger(__name__)


#This class handles user authentication with CAS.
class CasAuthnMethod(UserAuthnMethod):
    #Standard login url for a CAS server.
    CONST_CASLOGIN = "/cas/login?"
    #Standard URL for validation of a ticket for a CAS server.
    CONST_CAS_VERIFY_TICKET = "/serviceValidate"
    #Standard name for the parameter containing a CAS ticket.
    CONST_TICKET = "ticket"
    #Standard name for the parameter containing the service url (callback url).
    CONST_SERVICE = "service"
    #A successful verification of a ticket against a CAS service will contain
    # this XML element.
    CONST_AUTHSUCCESS = "authenticationSuccess"
    #If a success full verification of a CAS ticket has been perform, the uid
    # will be containd in a XML element
    #with this name.
    CONST_USER = "user"
    #Used for preventing replay attacks.
    CONST_NONCE = "nonce"
    #Parameter name for queries to be sent back on the URL, after successful
    # authentication.
    CONST_QUERY = "query"
    #The name for the CAS cookie, containing query parameters and nonce.
    CONST_CAS_COOKIE = "cascookie"

    def __init__(self, srv, cas_server, service_url, return_to,
                 extra_validation=None):
        """
        Constructor for the class.
        :param srv: Usually none, but otherwise the oic server.
        :param cas_server: Base URL to the cas server.
        :param service_url: BASE url to the service that will use CAS. In
        this case the oic server's verify URL.
        :param return_to: The URL to return to after a successful
        authentication.
        """
        UserAuthnMethod.__init__(self, srv)
        self.cas_server = cas_server
        self.service_url = service_url
        self.return_to = return_to
        self.extra_validation = extra_validation

    def create_redirect(self, query):
        """
        Performs the redirect to the CAS server.

        :rtype : Response
        :param query: All query parameters to be added to the return_to URL
        after successful authentication.
        :return: A redirect response to the CAS server.
        """
        try:
            req = urlparse.parse_qs(query)
            acr = req['acr_values'][0]
        except KeyError:
            acr = None

        nonce = uuid.uuid4().get_urn()
        service_url = urllib.urlencode(
            {self.CONST_SERVICE: self.get_service_url(nonce, acr)})
        cas_url = self.cas_server + self.CONST_CASLOGIN + service_url
        cookie = self.create_cookie(
            '{"' + self.CONST_NONCE + '": "' + base64.b64encode(
                nonce) + '", "' +
            self.CONST_QUERY + '": "' + base64.b64encode(query) + '"}',
            self.CONST_CAS_COOKIE,
            self.CONST_CAS_COOKIE)
        return Redirect(cas_url, headers=[cookie])

    def handle_callback(self, ticket, service_url):
        """
        Handles the callback from the CAS server.

        :rtype : String
        :param ticket: Onetime CAS ticket to be validated.
        :param service_url: The URL the CAS server redirected to.
        :return: Uid if the login was successful otherwise None.
        """
        data = {self.CONST_TICKET: ticket, self.CONST_SERVICE: service_url}
        resp = requests.get(self.cas_server + self.CONST_CAS_VERIFY_TICKET,
                            params=data)
        root = ET.fromstring(resp.content)
        for l1 in root:
            if self.CONST_AUTHSUCCESS in l1.tag:
                for l2 in l1:
                    if self.CONST_USER in l2.tag:
                        if self.extra_validation is not None:
                            if self.extra_validation(l2.text):
                                return l2.text
                            else:
                                return None
                        return l2.text
        return None

    def __call__(self, query, *args, **kwargs):
        return self.create_redirect(query)

    def get_service_url(self, nonce, acr):
        """
        Creates the service url for the CAS server.

        :rtype : String
        :param nonce: The nonce to be added to the service url.
        :return: A service url with a nonce.
        """
        if acr is None:
            acr = ""
        return self.service_url + "?" + self.CONST_NONCE + "=" + nonce + \
            "&acr_values=" + acr

    def verify(self, request, cookie, **kwargs):
        """
        Verifies if the authentication was successful.

        :rtype : Response
        :param request: Contains the request parameters.
        :param cookie: Cookies sent with the request.
        :param kwargs: Any other parameters.
        :return: If the authentication was successful: a redirect to the
        return_to url. Otherwise a unauthorized response.
        :raise: ValueError
        """
        logger.debug("verify(%s)" % request)
        if isinstance(request, basestring):
            _dict = parse_qs(request)
        elif isinstance(request, dict):
            _dict = request
        else:
            raise ValueError("Wrong type of input")
        try:
            cas_cookie, _ts, _typ = self.getCookieValue(cookie,
                                                        self.CONST_CAS_COOKIE)
            data = json.loads(cas_cookie)
            nonce = base64.b64decode(data[self.CONST_NONCE])
            if nonce != _dict[self.CONST_NONCE][0]:
                logger.warning(
                    'Someone tried to login without a correct nonce!')
                return Unauthorized("You are not authorized!")
            acr = None
            try:
                acr = _dict["acr_values"][0]
            except KeyError:
                pass
            uid = self.handle_callback(_dict[self.CONST_TICKET],
                                       self.get_service_url(nonce, acr))
            if uid is None or uid == "":
                logger.info('Someone tried to login, but was denied by CAS!')
                return Unauthorized("You are not authorized!")
            cookie = self.create_cookie(uid, "casm")
            return_to = self.generate_return_url(self.return_to, uid)
            if '?' in return_to:
                return_to += "&"
            else:
                return_to += "?"
            return_to += base64.b64decode(data[self.CONST_QUERY])
            return Redirect(return_to, headers=[cookie])
        except:
            logger.fatal('Metod verify in user_cas.py had a fatal exception.',
                         exc_info=True)
            return Unauthorized("You are not authorized!")

########NEW FILE########
__FILENAME__ = authz
import logging
import time
from oic.utils.http_util import CookieDealer
from oic.utils.authn.user import ToOld

logger = logging.getLogger(__name__)


class AuthzHandling(CookieDealer):
    """ Class that allow an entity to manage authorization """

    def __init__(self):
        self.permdb = {}

    def __call__(self, *args, **kwargs):
        return ""

    def permissions(self, cookie=None, **kwargs):
        if cookie is None:
            return None
        else:
            logger.debug("kwargs: %s" % kwargs)

            val = self.getCookieValue(cookie, self.srv.cookie_name)
            if val is None:
                return None
            else:
                uid, _ts, typ = val

            if typ == "uam":  # shortlived
                _now = int(time.mktime(time.gmtime()))
                if _now > (int(_ts) + int(self.cookie_ttl * 60)):
                    logger.debug("Authentication timed out")
                    raise ToOld("%d > (%d + %d)" % (_now, int(_ts),
                                                    int(self.cookie_ttl * 60)))
            else:
                if "max_age" in kwargs and kwargs["max_age"]:
                    _now = int(time.mktime(time.gmtime()))
                    if _now > (int(_ts) + int(kwargs["max_age"])):
                        logger.debug("Authentication too old")
                        raise ToOld("%d > (%d + %d)" % (
                            _now, int(_ts), int(kwargs["max_age"])))

            return self.permdb[uid]


class UserInfoConsent(AuthzHandling):
    def __call__(self, user, userinfo, **kwargs):
        pass


class Implicit(AuthzHandling):
    def __init__(self, permission="implicit"):
        AuthzHandling.__init__(self)
        self.permission = permission

    def permissions(self, cookie=None, **kwargs):
        return self.permission
########NEW FILE########
__FILENAME__ = claims
__author__ = 'rolandh'


#noinspection PyUnusedLocal
class ClaimsMode(object):
    def __init__(self, user2mode):
        self.user2mode = user2mode

    def aggregate(self, uid, info=None):
        try:
            if self.user2mode[uid] == "aggregate":
                return True
        except KeyError:
            pass

        return False

########NEW FILE########
__FILENAME__ = http_util
__author__ = 'rohe0002'

import cgi
import time
import hashlib
import hmac

from urllib import quote

from oic.oauth2 import rndstr
from oic.exception import UnsupportedMethod
from oic.utils import time_util
from oic.utils.aes import encrypt
from oic.utils.aes import decrypt

from Cookie import SimpleCookie


class Response(object):
    _template = None
    _status = '200 OK'
    _content_type = 'text/html'
    _mako_template = None
    _mako_lookup = None

    def __init__(self, message=None, **kwargs):
        self.status = kwargs.get('status', self._status)
        self.response = kwargs.get('response', self._response)
        self.template = kwargs.get('template', self._template)
        self.mako_template = kwargs.get('mako_template', self._mako_template)
        self.mako_lookup = kwargs.get('template_lookup', self._mako_lookup)

        self.message = message

        self.headers = kwargs.get('headers', [])
        _content_type = kwargs.get('content', self._content_type)

        self.headers.append(('Content-type', _content_type))

    def __call__(self, environ, start_response, **kwargs):
        start_response(self.status, self.headers)
        return self.response(self.message, **kwargs)

    def _response(self, message="", **argv):
        if self.template:
            if ("Content-type", 'application/json') in self.headers:
                return [message]
            else:
                return [str(self.template % message)]
        elif self.mako_lookup and self.mako_template:
            argv["message"] = message
            mte = self.mako_lookup.get_template(self.mako_template)
            return [mte.render(**argv)]
        else:
            return [message]


class Created(Response):
    _status = "201 Created"


class Accepted(Response):
    _status = "202 Accepted"


class NonAuthoritativeInformation(Response):
    _status = "203 Non Authoritative Information"


class NoContent(Response):
    _status = "204 No Content"


class Redirect(Response):
    _template = '<html>\n<head><title>Redirecting to %s</title></head>\n' \
        '<body>\nYou are being redirected to <a href="%s">%s</a>\n' \
        '</body>\n</html>'
    _status = '302 Found'

    def __call__(self, environ, start_response, **kwargs):
        location = self.message
        self.headers.append(('location', location))
        start_response(self.status, self.headers)
        return self.response((location, location, location))


class SeeOther(Response):
    _template = '<html>\n<head><title>Redirecting to %s</title></head>\n' \
        '<body>\nYou are being redirected to <a href="%s">%s</a>\n' \
        '</body>\n</html>'
    _status = '303 See Other'

    def __call__(self, environ, start_response, **kwargs):
        location = self.message
        self.headers.append(('location', location))
        start_response(self.status, self.headers)
        return self.response((location, location, location))


class Forbidden(Response):
    _status = '403 Forbidden'
    _template = "<html>Not allowed to mess with: '%s'</html>"


class BadRequest(Response):
    _status = "400 Bad Request"
    _template = "<html>%s</html>"


class Unauthorized(Response):
    _status = "401 Unauthorized"
    _template = "<html>%s</html>"


class NotFound(Response):
    _status = '404 NOT FOUND'


class NotSupported(Response):
    _status = '405 Not Support'


class NotAcceptable(Response):
    _status = '406 Not Acceptable'


class ServiceError(Response):
    _status = '500 Internal Service Error'


class InvalidCookieSign(Exception):
    pass


R2C = {
    200: Response,
    201: Created,
    202: Accepted,
    203: NonAuthoritativeInformation,
    204: NoContent,
    302: Redirect,
    303: SeeOther,
    400: BadRequest,
    401: Unauthorized,
    403: Forbidden,
    404: NotFound,
    405: NotSupported,
    406: NotAcceptable,
    500: ServiceError,
}


def factory(code, message, **kwargs):
    return R2C[code](message, **kwargs)


def extract(environ, empty=False, err=False):
    """Extracts strings in form data and returns a dict.

    :param environ: WSGI environ
    :param empty: Stops on empty fields (default: Fault)
    :param err: Stops on errors in fields (default: Fault)
    """
    formdata = cgi.parse(environ['wsgi.input'], environ, empty, err)
    # Remove single entries from lists
    for key, value in formdata.iteritems():
        if len(value) == 1:
            formdata[key] = value[0]
    return formdata


def geturl(environ, query=True, path=True):
    """Rebuilds a request URL (from PEP 333).

    :param query: Is QUERY_STRING included in URI (default: True)
    :param path: Is path included in URI (default: True)
    """
    url = [environ['wsgi.url_scheme'] + '://']
    if environ.get('HTTP_HOST'):
        url.append(environ['HTTP_HOST'])
    else:
        url.append(environ['SERVER_NAME'])
        if environ['wsgi.url_scheme'] == 'https':
            if environ['SERVER_PORT'] != '443':
                url.append(':' + environ['SERVER_PORT'])
        else:
            if environ['SERVER_PORT'] != '80':
                url.append(':' + environ['SERVER_PORT'])
    if path:
        url.append(getpath(environ))
    if query and environ.get('QUERY_STRING'):
        url.append('?' + environ['QUERY_STRING'])
    return ''.join(url)


def getpath(environ):
    """Builds a path."""
    return ''.join([quote(environ.get('SCRIPT_NAME', '')),
                    quote(environ.get('PATH_INFO', ''))])


def _expiration(timeout, time_format=None):
    if timeout == "now":
        return time_util.instant(time_format)
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, time_format=time_format)


def cookie_signature(seed, *parts):
    """Generates a cookie signature."""
    sha1 = hmac.new(seed, digestmod=hashlib.sha1)
    for part in parts:
        if part:
            sha1.update(part)
    return sha1.hexdigest()


def make_cookie(name, load, seed, expire=0, domain="",  path="", timestamp=""):
    """
    Create and return a cookie

    :param name: Cookie name
    :param load: Cookie load
    :param seed: A seed for the HMAC function
    :param expire: Number of minutes before this cookie goes stale
    :param domain: The domain of the cookie
    :param path: The path specification for the cookie
    :param timestamp: A time stamp
    :return: A tuple to be added to headers
    """
    cookie = SimpleCookie()
    if not timestamp:
        timestamp = str(int(time.mktime(time.gmtime())))
    signature = cookie_signature(seed, load, timestamp)
    cookie[name] = "|".join([load, timestamp, signature])
    if path:
        cookie[name]["path"] = path
    if domain:
        cookie[name]["domain"] = domain
    if expire:
        cookie[name]["expires"] = _expiration(expire,
                                              "%a, %d-%b-%Y %H:%M:%S GMT")

    return tuple(cookie.output().split(": ", 1))


def parse_cookie(name, seed, kaka):
    """Parses and verifies a cookie value

    :param seed: A seed used for the HMAC signature
    :param kaka: The cookie
    :return: A tuple consisting of (payload, timestamp)
    """
    if not kaka:
        return None

    cookie_obj = SimpleCookie(kaka)
    morsel = cookie_obj.get(name)

    if morsel:
        parts = morsel.value.split("|")
        if len(parts) != 3:
            return None
        # verify the cookie signature
        sig = cookie_signature(seed, parts[0], parts[1])
        if sig != parts[2]:
            raise InvalidCookieSign()

        try:
            return parts[0].strip(), parts[1]
        except KeyError:
            return None
    else:
        return None


def cookie_parts(name, kaka):
    cookie_obj = SimpleCookie(kaka)
    morsel = cookie_obj.get(name)
    if morsel:
        return morsel.value.split("|")
    else:
        return None


def get_post(environ):
    # the environment variable CONTENT_LENGTH may be empty or missing
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0

    # When the method is POST the query string will be sent
    # in the HTTP request body which is passed by the WSGI server
    # in the file like wsgi.input environment variable.
    return environ['wsgi.input'].read(request_body_size)


def get_or_post(environ):
    _method = environ["REQUEST_METHOD"]

    if _method == "GET":
        data = environ.get("QUERY_STRING", "")
    elif _method == "POST":
        data = get_post(environ)
    else:
        raise UnsupportedMethod(_method)

    return data


def wsgi_wrapper(environ, start_response, func, **kwargs):
    request = None
    try:
        request = environ["QUERY_STRING"]
    except KeyError:
        pass

    if not request:
        try:
            request = get_post(environ)
        except KeyError:
            pass

    kwargs["request"] = request
    # authentication information
    try:
        kwargs["authn"] = environ["HTTP_AUTHORIZATION"]
    except KeyError:
        pass

    try:
        kwargs["cookie"] = environ["HTTP_COOKIE"]
    except KeyError:
        pass

    # intended audience
    kwargs["requrl"] = geturl(environ)
    kwargs["url"] = geturl(environ, query=False)
    kwargs["baseurl"] = geturl(environ, query=False, path=False)
    kwargs["path"] = getpath(environ)

    args = func(**kwargs)
    try:
        resp, argv = args
        return resp(environ, start_response, **argv)
    except TypeError:
        resp = args
        return resp(environ, start_response)
    except Exception as err:
        #logger.error("%s" % err)
        raise


class CookieDealer(object):
    def __init__(self, srv, ttl=5):
        self.srv = None
        self.init_srv(srv)
        # minutes before the interaction should be completed
        self.cookie_ttl = ttl  # N minutes
        self.pad_chr = " "

    def init_srv(self, srv):
        if srv:
            self.srv = srv

            for param in ["seed", "iv"]:
                if not getattr(srv, param, None):
                    setattr(srv, param, rndstr())

    def delete_cookie(self, cookie_name=None):
        if cookie_name is None:
            cookie_name = self.srv.cookie_name
        return self.create_cookie("", "", cookie_name=cookie_name, ttl=-1,
                                  kill=True)

    def create_cookie(self, value, typ, cookie_name=None, ttl=-1, kill=False):
        if kill:
            ttl = -1
        elif ttl < 0:
            ttl = self.cookie_ttl
        if cookie_name is None:
            cookie_name = self.srv.cookie_name
        timestamp = str(int(time.mktime(time.gmtime())))
        _msg = "::".join([value, timestamp, typ])
        if self.srv.symkey:
            # Pad the message to be multiples of 16 bytes in length
            lm = len(_msg)
            _msg = _msg.ljust(lm + 16 - lm % 16, self.pad_chr)
            info = encrypt(self.srv.symkey, _msg, self.srv.iv)
        else:
            info = _msg
        cookie = make_cookie(cookie_name, info, self.srv.seed,
                             expire=ttl, domain="", path="")
        return cookie

    def getCookieValue(self, cookie=None, cookie_name=None):
        return self.get_cookie_value(cookie, cookie_name)

    def get_cookie_value(self, cookie=None, cookie_name=None):
        """
        Return information stored in the Cookie

        :param cookie:
        :param cookie_name: The name of the cookie I'm looking for
        :return: tuple (value, timestamp, type)
        """
        if cookie is None or cookie_name is None:
            return None
        else:
            try:
                info, timestamp = parse_cookie(cookie_name,
                                               self.srv.seed, cookie)
            except (TypeError, AssertionError):
                return None
            else:
                if self.srv.symkey:
                    txt = decrypt(self.srv.symkey, info, self.srv.iv)
                    # strip spaces at the end
                    txt = txt.rstrip(self.pad_chr)
                else:
                    txt = info

                value, _ts, typ = txt.split("::")
                if timestamp == _ts:
                    return value, _ts, typ
        return None


########NEW FILE########
__FILENAME__ = keyio
import json
import time
from Crypto.PublicKey import RSA
from oic.exception import MessageException

__author__ = 'rohe0002'

import logging
import os
import urlparse
import sys
import traceback

from requests import request

from jwkest.jwk import rsa_load
from jwkest.jwk import RSAKey
from jwkest.jwk import ECKey
from jwkest.jwk import SYMKey

KEYLOADERR = "Failed to load %s key from '%s' (%s)"
logger = logging.getLogger(__name__)

# ======================================================================
traceback.format_exception(*sys.exc_info())


class UnknownKeyType(Exception):
    pass


K2C = {
    "RSA": RSAKey,
    "EC": ECKey,
    "oct": SYMKey,
#    "pkix": PKIX_key
}


class KeyBundle(object):
    def __init__(self, keys=None, source="", cache_time=300, verify_ssl=True,
                 fileformat="jwk", keytype="RSA", keyusage=None):
        """

        :param keys: A list of dictionaries
            with the keys ["kty", "key", "alg", "use", "kid"]
        :param source: Where the key set can be fetch from
        :param verify_ssl: Verify the SSL cert used by the server
        :param fileformat: For a local file either "jwk" or "der"
        :param keytype: Iff local file and 'der' format what kind of key it is.
        """

        self._keys = []
        self.remote = False
        self.verify_ssl = verify_ssl
        self.cache_time = cache_time
        self.time_out = 0
        self.etag = ""
        self.cache_control = None
        self.source = None
        self.fileformat = fileformat.lower()
        self.keytype = keytype
        self.keyusage = keyusage

        if keys:
            self.source = None
            if isinstance(keys, dict):
                self.do_keys([keys])
            else:
                self.do_keys(keys)
        else:
            if source.startswith("file://"):
                self.source = source[7:]
            elif source.startswith("http://") or source.startswith("https://"):
                self.source = source
                self.remote = True
            elif source == "":
                return
            else:
                raise Exception("Unsupported source type: %s" % source)

            if not self.remote:  # local file
                if self.fileformat == "jwk":
                    self.do_local_jwk(self.source)
                elif self.fileformat == "der":
                    self.do_local_der(self.source, self.keytype, self.keyusage)

    def do_keys(self, keys):
        """
        Go from JWK description to binary keys

        :param keys:
        :return:
        """
        for inst in keys:
            typ = inst["kty"]
            flag = 0
            for _typ in [typ, typ.lower(), typ.upper()]:
                try:
                    _key = K2C[_typ](**inst)
                except KeyError:
                    continue
                else:
                    _key.dc()
                    if _typ == "EC":
                        _key.ser = True
                    self._keys.append(_key)
                    flag = 1
                    break
            if not flag:
                raise UnknownKeyType(typ)

    def do_local_jwk(self, filename):
        self.do_keys(json.loads(open(filename).read())["keys"])

    def do_local_der(self, filename, keytype, keyusage):
        _bkey = None
        if keytype == "RSA":
            _bkey = rsa_load(filename)

        if not keyusage:
            keyusage = ["enc", "sig"]

        for use in keyusage:
            _key = K2C[keytype]()
            _key.key = _bkey

            if _bkey:
                _key.serialize()

            _key.use = use
            self._keys.append(_key)

    def do_remote(self):
        args = {"allow_redirects": True,
                "verify": self.verify_ssl,
                "timeout": 5.0}
        if self.etag:
            args["headers"] = {"If-None-Match": self.etag}

        r = request("GET", self.source, **args)

        if r.status_code == 304:  # file has not changed
            self.time_out = time.time() + self.cache_time
        elif r.status_code == 200:  # New content
            self.time_out = time.time() + self.cache_time

            self.do_keys(json.loads(r.text)["keys"])

            try:
                self.etag = r.headers["Etag"]
            except KeyError:
                pass
            try:
                self.cache_control = r.headers["Cache-Control"]
            except KeyError:
                pass

    def _uptodate(self):
        if self._keys is not []:
            if self.remote:  # verify that it's not to old
                if time.time() > self.time_out:
                    self.update()
        elif self.remote:
            self.update()

    def update(self):
        """
        Reload the key if necessary
        This is a forced update, will happen even if cache time has not elapsed
        """
        if self.source:
            # reread everything

            self._keys = []

            if self.remote is False:
                if self.fileformat == "jwk":
                    self.do_local_jwk(self.source)
                elif self.fileformat == "der":
                    self.do_local_der(self.source, self.keytype, self.keyusage)
            else:
                self.do_remote()

    def get(self, typ=""):
        """

        :param typ: Type of key (rsa, ec, oct, ..)
        :return: If typ is undefined all the keys as a dictionary
            otherwise the appropriate keys in a list
        """
        self._uptodate()
        _typs = [typ.lower(), typ.upper()]

        if typ:
            return [k for k in self._keys if k.kty in _typs]
        else:
            return self._keys

    def keys(self):
        self._uptodate()

        return self._keys

    def remove(self, typ, val=None):
        """

        :param typ: Type of key (rsa, ec, oct, ..)
        :param val: The key itself
        """
        if val:
            self._keys = [k for k in self._keys if
                          not (k.kty == typ and k.key == val.key)]
        else:
            self._keys = [k for k in self._keys if not k.kty == typ]

    def __str__(self):
        return str(self.jwks())

    def jwks(self):
        self._uptodate()
        return json.dumps({"keys": [k.to_dict() for k in self._keys]})

    def append(self, key):
        self._keys.append(key)

    def __len__(self):
        return len(self._keys)

    def get_key_with_kid(self, kid):
        for key in self._keys:
            if key.kid == kid:
                return key
        return None


def keybundle_from_local_file(filename, typ, usage):
    if typ.upper() == "RSA":
        kb = KeyBundle()
        k = RSAKey()
        k.load(filename)
        k.use = usage[0]
        kb.append(k)
        for use in usage[1:]:
            _k = RSAKey()
            _k.use = use
            _k.key = k.key
            kb.append(_k)
    elif typ.lower() == "jwk":
        kb = KeyBundle(source=filename, fileformat="jwk", keyusage=usage)
    else:
        raise Exception("Unsupported key type")

    return kb


def dump_jwks(kbl, target):
    """
    Write a JWK to a file

    :param kbl: List of KeyBundles
    :param target: Name of the file to which everything should be written
    """
    res = {"keys": []}
    for kb in kbl:
        res["keys"].extend([k.to_dict() for k in kb.keys()])

    try:
        f = open(target, 'w')
    except IOError:
        (head, tail) = os.path.split(target)
        os.makedirs(head)
        f = open(target, 'w')

    _txt = json.dumps(res)
    f.write(_txt)
    f.close()


class KeyJar(object):
    """ A keyjar contains a number of KeyBundles """

    def __init__(self, ca_certs=None, verify_ssl=True):
        """

        :param ca_certs:
        :param verify_ssl: Attempting SSL certificate verification
        :return:
        """
        self.spec2key = {}
        self.issuer_keys = {}
        self.ca_certs = ca_certs
        self.verify_ssl = verify_ssl

    def add_if_unique(self, issuer, use, keys):
        if use in self.issuer_keys[issuer] and self.issuer_keys[issuer][use]:
            for typ, key in keys:
                flag = 1
                for _typ, _key in self.issuer_keys[issuer][use]:
                    if _typ == typ and key is _key:
                        flag = 0
                        break
                if flag:
                    self.issuer_keys[issuer][use].append((typ, key))
        else:
            self.issuer_keys[issuer][use] = keys

    def add(self, issuer, url):
        """

        :param issuer: Who issued the keys
        :param url: Where can the key/-s be found
        """

        if "/localhost:" in url or "/localhost/" in url:
            kc = KeyBundle(source=url, verify_ssl=False)
        else:
            kc = KeyBundle(source=url, verify_ssl=self.verify_ssl)

        try:
            self.issuer_keys[issuer].append(kc)
        except KeyError:
            self.issuer_keys[issuer] = [kc]

        return kc

    def add_symmetric(self, issuer, key, usage):
        if not issuer in self.issuer_keys:
            self.issuer_keys[issuer] = []

        for use in usage:
            self.issuer_keys[""].append(KeyBundle([{"kty": "oct",
                                                    "key": key,
                                                    "use": use}]))

    def add_kb(self, issuer, kb):
        try:
            self.issuer_keys[issuer].append(kb)
        except KeyError:
            self.issuer_keys[issuer] = [kb]

    def __setitem__(self, issuer, val):
        if isinstance(val, basestring):
            val = [val]
        elif not isinstance(val, list):
            val = [val]

        self.issuer_keys[issuer] = val

    def get(self, use, key_type="", issuer=""):
        """

        :param use: A key useful for this usage (enc, dec, sig, ver)
        :param key_type: Type of key (rsa, ec, symmetric, ..)
        :param issuer: Who is responsible for the keys, "" == me
        :return: A possibly empty list of keys
        """

        if use == "dec":
            use = "enc"
        elif use == "ver":
            use = "sig"

        if issuer != "":
            try:
                _keys = self.issuer_keys[issuer]
            except KeyError:
                if issuer.endswith("/"):
                    try:
                        _keys = self.issuer_keys[issuer[:-1]]
                    except KeyError:
                        _keys = []
                else:
                    try:
                        _keys = self.issuer_keys[issuer + "/"]
                    except KeyError:
                        _keys = []
        else:
            _keys = self.issuer_keys[issuer]

        lst = []
        if _keys:
            for bundles in _keys:
                if key_type:
                    _keys = bundles.get(key_type)
                else:
                    _keys = bundles.keys()
                for key in _keys:
                    if not key.use or use == key.use:
                        lst.append(key)
        return lst

    def get_signing_key(self, key_type="", owner=""):
        return self.get("sig", key_type, owner)

    def get_verify_key(self, key_type="", owner=""):
        return self.get("ver", key_type, owner)

    def get_encrypt_key(self, key_type="", owner=""):
        return self.get("enc", key_type, owner)

    def get_decrypt_key(self, key_type="", owner=""):
        return self.get("dec", key_type, owner)

    def get_key_by_kid(self, kid, owner=""):
        """
        Return the key from a specific owner that has a specific kid

        :param kid: The key identifier
        :param owner: The owner of the key
        :return: a specific key instance or None
        """
        for kb in self.issuer_keys[owner]:
            _key = kb.get_key_with_kid(kid)
            if _key:
                return _key
        return None

    def __contains__(self, item):
        if item in self.issuer_keys:
            return True
        else:
            return False

    def x_keys(self, var, part):
        _func = getattr(self, "get_%s_key" % var)

        keys = _func(key_type="", owner=part)
        keys.extend(_func(key_type="", owner=""))
        return keys

    def verify_keys(self, part):
        """
        Keys for me and someone else.

        :param part: The other part
        :return: dictionary of keys
        """
        return self.x_keys("verify", part)

    def decrypt_keys(self, part):
        """
        Keys for me and someone else.

        :param part: The other part
        :return: dictionary of keys
        """

        return self.x_keys("decrypt", part)

    def __getitem__(self, issuer):
        return self.issuer_keys[issuer]

    def remove_key(self, issuer, key_type, key):
        try:
            kcs = self.issuer_keys[issuer]
        except KeyError:
            return

        for kc in kcs:
            kc.remove(key_type, key)
            if len(kc._keys) == 0:
                self.issuer_keys[issuer].remove(kc)

    def update(self, kj):
        for key, val in kj.issuer_keys.items():
            if isinstance(val, basestring):
                val = [val]
            elif not isinstance(val, list):
                val = [val]

            try:
                self.issuer_keys[key].extend(val)
            except KeyError:
                self.issuer_keys[key] = val

    def match_owner(self, url):
        for owner in self.issuer_keys.keys():
            if url.startswith(owner):
                return owner

        raise Exception("No keys for '%s'" % url)

    def __str__(self):
        _res = {}
        for k, vs in self.issuer_keys.items():
            _res[k] = [str(v) for v in vs]
        return "%s" % (_res,)

    def keys(self):
        self.issuer_keys.keys()

    def load_keys(self, pcr, issuer, replace=False):
        """
        Fetch keys from another server

        :param pcr: The provider information
        :param issuer: The provider URL
        :param replace: If all previously gathered keys from this provider
            should be replace.
        :return: Dictionary with usage as key and keys as values
        """

        logger.debug("loading keys for issuer: %s" % issuer)
        try:
            logger.debug("pcr: %s" % pcr)
        except MessageException:
            pass

        if issuer not in self.issuer_keys:
            self.issuer_keys[issuer] = []
        elif replace:
            self.issuer_keys[issuer] = []

        try:
            self.add(issuer, pcr["jwks_uri"])
        except KeyError:
            #  jwks should only be considered if no jwks_uri is present
            try:
                _keys = pcr["jwks"]["keys"]
                self.issuer_keys[issuer].append(KeyBundle(_keys))
            except KeyError:
                pass

    def find(self, source, issuer):
        """
        Find a key bundle
        :param source: A url
        :param issuer: The issuer of keys
        """
        try:
            for kb in self.issuer_keys[issuer]:
                if kb.source == source:
                    return kb
        except KeyError:
            return None

    def dump_issuer_keys(self, issuer):
        res = []
        try:
            for kb in self.issuer_keys[issuer]:
                res.extend([k.to_dict() for k in kb.keys()])
        except KeyError:
            pass

        return res

# =============================================================================


class RedirectStdStreams(object):
    def __init__(self, stdout=None, stderr=None):
        self._stdout = stdout or sys.stdout
        self._stderr = stderr or sys.stderr

    def __enter__(self):
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush(); self.old_stderr.flush()
        sys.stdout, sys.stderr = self._stdout, self._stderr

    #noinspection PyUnusedLocal
    def __exit__(self, exc_type, exc_value, traceback):
        self._stdout.flush(); self._stderr.flush()
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr


def key_setup(vault, **kwargs):
    """
    :param vault: Where the keys are kept
    :return: 2-tuple: result of urlsplit and a dictionary with
        parameter name as key and url and value
    """
    vault_path = proper_path(vault)

    if not os.path.exists(vault_path):
        os.makedirs(vault_path)

    kb = KeyBundle()
    kid = 1
    for usage in ["sig", "enc"]:
        if usage in kwargs:
            if kwargs[usage] is None:
                continue

            _args = kwargs[usage]
            if _args["alg"] == "RSA":
                try:
                    _key = rsa_load('%s%s' % (vault_path, "pyoidc"))
                except Exception:
                    devnull = open(os.devnull, 'w')
                    with RedirectStdStreams(stdout=devnull, stderr=devnull):
                        _key = create_and_store_rsa_key_pair(
                            path=vault_path)

                kb.append(RSAKey(key=_key, use=usage, kid=kid))
                kid += 1
                if usage == "sig" and "enc" not in kwargs:
                    kb.append(RSAKey(key=_key, use="enc", kid=kid))
                    kid += 1

    return kb


def key_export(baseurl, local_path, vault, keyjar, **kwargs):
    """
    :param baseurl: The base URL to which the key file names are added
    :param local_path: Where on the machine the export files are kept
    :param vault: Where the keys are kept
    :param keyjar: Where to store the exported keys
    :return: 2-tuple: result of urlsplit and a dictionary with
        parameter name as key and url and value
    """
    part = urlparse.urlsplit(baseurl)

    # deal with the export directory
    if part.path.endswith("/"):
        _path = part.path[:-1]
    else:
        _path = part.path[:]

    local_path = proper_path("%s/%s" % (_path, local_path))

    if not os.path.exists(local_path):
        os.makedirs(local_path)

    kb = key_setup(vault, **kwargs)

    try:
        keyjar[""].append(kb)
    except KeyError:
        keyjar[""] = kb

    # the local filename
    _export_filename = "%sjwks" % local_path

    f = open(_export_filename, "w")
    f.write("%s" % kb)
    f.close()

    _url = "%s://%s%s" % (part.scheme, part.netloc,
                          _export_filename[1:])

    return _url

# ================= create RSA key ======================


def create_and_store_rsa_key_pair(name="pyoidc", path=".", size=1024):
    """
    :param name: Name of the key file
    :param path: Path to where the key files are stored
    :param size: Seed the random number generator with <size> random bytes
    :return: RSA key
    """

    key = RSA.generate(size)

    if not path.endswith("/"):
        path += "/"

    f = open('%s%s' % (path, name),'w')
    f.write(key.exportKey('PEM'))
    f.close()

    _pub_key = key.publickey()
    f = open('%s%s.pub' % (path, name), 'w')
    f.write(_pub_key.exportKey('PEM'))
    f.close()

    return key


def proper_path(path):
    """
    Clean up the path specification so it looks like something I could use.
    "./" <path> "/"
    """
    if path.startswith("./"):
        pass
    elif path.startswith("/"):
        path = ".%s" % path
    elif path.startswith("."):
        while path.startswith("."):
            path = path[1:]
        if path.startswith("/"):
            path = ".%s" % path
    else:
        path = "./%s" % path

    if not path.endswith("/"):
        path += "/"

    return path

# ================= create certificate ======================
# heavily influenced by
# http://svn.osafoundation.org/m2crypto/trunk/tests/test_x509.py

#
#
# def make_req(bits, fqdn="example.com", rsa=None):
#     pk = EVP.PKey()
#     x = X509.Request()
#     if not rsa:
#         rsa = RSA.gen_key(bits, 65537, lambda: None)
#     pk.assign_rsa(rsa)
#     # Because rsa is messed with
#     rsa = pk.get_rsa()
#     x.set_pubkey(pk)
#     name = x.get_subject()
#     name.C = "SE"
#     name.CN = "OpenID Connect Test Server"
#     if fqdn:
#         ext1 = X509.new_extension('subjectAltName', fqdn)
#         extstack = X509.X509_Extension_Stack()
#         extstack.push(ext1)
#         x.add_extensions(extstack)
#     x.sign(pk, 'sha1')
#     return x, pk, rsa
#
#
# def make_cert(bits, fqdn="example.com", rsa=None):
#     req, pk, rsa = make_req(bits, fqdn=fqdn, rsa=rsa)
#     pkey = req.get_pubkey()
#     sub = req.get_subject()
#     cert = X509.X509()
#     cert.set_serial_number(1)
#     cert.set_version(2)
#     cert.set_subject(sub)
#     t = long(time.time()) + time.timezone
#     now = ASN1.ASN1_UTCTIME()
#     now.set_time(t)
#     nowPlusYear = ASN1.ASN1_UTCTIME()
#     nowPlusYear.set_time(t + 60 * 60 * 24 * 365)
#     cert.set_not_before(now)
#     cert.set_not_after(nowPlusYear)
#     issuer = X509.X509_Name()
#     issuer.CN = 'The code tester'
#     issuer.O = 'Umea University'
#     cert.set_issuer(issuer)
#     cert.set_pubkey(pkey)
#     cert.sign(pk, 'sha1')
#     return cert, rsa

########NEW FILE########
__FILENAME__ = sdb
import copy
import uuid
from oic.oic import AuthorizationRequest

__author__ = 'rohe0002'

import hmac
import hashlib
import random
import base64
import logging

from oic.oauth2 import rndstr
from oic.utils.time_util import utc_time_sans_frac

from Crypto.Cipher import AES

logger = logging.getLogger(__name__)


class ExpiredToken(Exception):
    pass


class WrongTokenType(Exception):
    pass


class AccessCodeUsed(Exception):
    pass


def pairwise_id(sub, sector_identifier, seed):
    return hashlib.sha256("%s%s%s" % (sub, sector_identifier, seed)).hexdigest()


class Crypt():
    def __init__(self, password, mode=AES.MODE_CBC):
        self.password = password or 'kitty'
        self.key = hashlib.sha256(password).digest()
        self.mode = mode

    def encrypt(self, text):
        # setting iv because the underlying AES module misbehaves
        # on certain platforms
        encryptor = AES.new(self.key, self.mode, IV="0" * 16)

        if len(text) % 16:
            text += ' ' * (16 - len(text) % 16)

        return encryptor.encrypt(text)

    def decrypt(self, ciphertext):
        decryptor = AES.new(self.key, self.mode, IV="0" * 16)
        return decryptor.decrypt(ciphertext)


class Token(object):
    def __init__(self, secret, password):
        self.secret = secret
        self._rndlen = 19
        self._sidlen = 28
        self.crypt = Crypt(password)

    def __call__(self, ttype="A", prev="", sid=None):
        if prev:
            ptyp, sid, tmp = self._split_token(prev)
            if not ttype:
                ttype = ptyp
        else:
            tmp = ""

        rnd = tmp
        while rnd == tmp:
            rnd = rndstr(self._rndlen)
            # Ultimate length multiple of 16

        return base64.b64encode(self.crypt.encrypt("%s%s%s" % (sid, ttype,
                                                               rnd)))

    def key(self, user="", areq=None):
        csum = hmac.new(self.secret, digestmod=hashlib.sha224)
        csum.update("%s" % utc_time_sans_frac())
        csum.update("%f" % random.random())
        if user:
            csum.update(user)

        if areq:
            try:
                csum.update(areq["state"])
            except KeyError:
                pass

            try:
                for val in areq["scope"]:
                    csum.update(val)
            except KeyError:
                pass

            try:
                csum.update(areq["redirect_uri"])
            except KeyError:
                pass

        return csum.digest()  # 28 bytes long, 224 bits

    def _split_token(self, token):
        plain = self.crypt.decrypt(base64.b64decode(token))
        # first _sidlen bytes are the sid
        _sid = plain[:self._sidlen]
        _type = plain[self._sidlen]
        _rnd = plain[self._sidlen + 1:]
        return _type, _sid, _rnd

    def type_and_key(self, token):
        a, b, c = self._split_token(token)
        return a, b

    def get_key(self, token):
        return self._split_token(token)[1]

    def get_type(self, token):
        return self._split_token(token)[0]


class SessionDB(object):
    def __init__(self, db=None, secret="Ab01FG65", token_expires_in=3600,
                 password="4-amino-1H-pyrimidine-2-one",
                 grant_expires_in=600, seed=""):
        if db:
            self._db = db
        else:
            self._db = {}
        self.token = Token(secret, password)
        self.token_expires_in = token_expires_in
        self.grant_expires_in = grant_expires_in
        self.uid2sid = {}
        self.seed = seed or secret

    def __getitem__(self, item):
        """
        :param item: authz grant code or refresh token
        """
        try:
            return self._db[item]
        except KeyError:
            try:
                sid = self.token.get_key(item)
            except Exception:
                raise KeyError
            return self._db[sid]

    def __setitem__(self, key, value):
        """
        :param key: authz grant code or refresh token
        """

        self._db[key] = value

    def keys(self):
        return self._db.keys()

    def update(self, key, attribute, value):
        if key in self._db:
            pass
        else:
            try:
                sid = self.token.get_key(key)
            except Exception:
                raise KeyError
            
            if sid not in self._db:
                raise KeyError
            else:
                key = sid

        self._db[key][attribute] = value

    def update_by_token(self, token, attribute, value):
        (typ, key) = self.token.type_and_key(token)
        return self.update(key, attribute, value)

    def do_userid(self, sid, sub, sector_id, preferred_id_type):
        old = [""]
        if preferred_id_type == "public":
            uid = sub
        else:
            uid = pairwise_id(sub, sector_id, self.seed)
            old.append(sub)

        logger.debug("uid: %s, old: %s" % (uid, old))
        self.uid2sid[uid] = sid

        for old_id in old:
            try:
                del self.uid2sid[old_id]
            except KeyError:
                pass

        logger.debug("uid2sid: %s" % self.uid2sid)
        self._db[sid]["local_sub"] = sub
        self._db[sid]["sub"] = uid

        return uid

    def create_authz_session(self, sub, areq, id_token=None, oidreq=None):
        """

        :param sub: Identifier for the user, this is the real identifier
        :param areq: The AuthorizationRequest instance
        :param id_token: An IDToken instance
        :param oidreq: An OpenIDRequest instance
        :return: The session identifier, which is the database key
        """

        sid = self.token.key(user=sub, areq=areq)
        access_grant = self.token(sid=sid)

        _dic = {
            "oauth_state": "authz",
            "local_sub": sub,
            "sub": sub,
            "code": access_grant,
            "code_used": False,
            "authzreq": areq.to_json(),
            "client_id": areq["client_id"],
            "revoked": False,
        }

        try:
            _val = areq["nonce"]
            if _val:
                _dic["nonce"] = _val
        except (AttributeError, KeyError):
            pass

        for key in ["redirect_uri", "state", "scope", "si_redirects"]:
            try:
                _dic[key] = areq[key]
            except KeyError:
                pass

        if id_token:
            _dic["id_token"] = id_token
        if oidreq:
            _dic["oidreq"] = oidreq.to_json()

        self._db[sid] = _dic
        self.uid2sid[sub] = sid
        return sid

    def get_token(self, key):
        if self._db[key]["oauth_state"] == "authz":
            return self._db[key]["code"]
        elif self._db[key]["oauth_state"] == "token":
            return self._db[key]["access_token"]

    def upgrade_to_token(self, token=None, issue_refresh=True, id_token="",
                         oidreq=None, key=None, access_grant=""):
        """

        :param token: The access grant
        :param issue_refresh: If a refresh token should be issued
        :param id_token: An IDToken instance
        :param oidreq: An OpenIDRequest instance
        :param key: The session key. One of token or key must be given.
        :return: The session information as a dictionary
        """
        if token:
            try:
                (typ, key) = self.token.type_and_key(token)
            except (ValueError, TypeError):
                (typ, key) = self.token.type_and_key(access_grant)
                token = access_grant

            if typ != "A":  # not a access grant
                raise WrongTokenType("Not a grant token")

            dic = self._db[key]

            if dic["code_used"]:
                raise AccessCodeUsed()
            _at = self.token("T", token)
            dic["code_used"] = True
        else:
            dic = self._db[key]
            _at = self.token("T", sid=key)

        dic["access_token"] = _at
        dic["access_token_scope"] = "?"
        dic["oauth_state"] = "token"
        dic["token_type"] = "Bearer"
        dic["expires_in"] = self.token_expires_in
        dic["token_expires_at"] = utc_time_sans_frac() + self.token_expires_in
        if id_token:
            dic["id_token"] = id_token
        if oidreq:
            dic["oidreq"] = oidreq

        if issue_refresh:
            dic["refresh_token"] = self.token("R", token)

        self._db[key] = dic
        return dic

    def refresh_token(self, rtoken):
        # assert that it is a refresh token
        typ = self.token.get_type(rtoken)
        if typ == "R":
            if not self.is_valid(rtoken):
                raise ExpiredToken()

            sid = self.token.get_key(rtoken)

            # This might raise an error
            dic = self._db[sid]

            access_token = self.token("T", prev=rtoken)

            dic["token_expires_at"] = utc_time_sans_frac() + self.token_expires_in
            #dic["client_id_issued_at"] = utc_time_sans_frac()
            dic["access_token"] = access_token
            self._db[sid] = dic
            #self._db[dic["xxxx"]] = dic
            return dic
        else:
            raise WrongTokenType("Not a refresh token!")

    def is_expired(self, sess):
        if "token_expires_at" in sess:
            if sess["token_expires_at"] < utc_time_sans_frac():
                return True

        return False

    def is_valid(self, token):
        typ, sid = self.token.type_and_key(token)

        _dic = self._db[sid]
        if typ == "A":
            if _dic["code"] != token:
                return False
            elif _dic["oauth_state"] != "authz":
                return False

            if self.is_expired(_dic):
                return False

        elif typ == "T":
            if _dic["access_token"] != token:
                return False

            if self.is_expired(_dic):
                return False

        elif typ == "R" and _dic["refresh_token"] != token:
            return False

        return True

    def is_revoked(self, sid):
        #typ, sid = self.token.type_and_key(token)
        try:
            return self[sid]["revoked"]
        except KeyError:
            return False

#    def set_oir(self, key, oir):
#        self._db[key] = oir.dictionary()
#
#    def get_oir(self, key):
#        return OpenIDRequest(**self._db[key])

    def revoke_token(self, token):
        # revokes either the refresh token or the access token

        typ, sid = self.token.type_and_key(token)

        _dict = self._db[sid]
        if typ == "A":
            _dict["code"] = ""
        elif typ == "T":
            _dict["access_token"] = ""
        elif typ == "R":
            _dict["refresh_token"] = ""
        else:
            pass

        return True

    def revoke_all_tokens(self, token):
        typ, sid = self.token.type_and_key(token)

        self._db[sid]["revoked"] = True

    def get_client_id(self, uid):
        _dict = self._db[self.uid2sid[uid]]
        return _dict["client_id"]

    def get_verified_Logout(self, uid):
        _dict = self._db[self.uid2sid[uid]]
        if "verified_logout" not in _dict:
            return None
        return _dict["verified_logout"]

    def set_verify_logout(self, uid):
        _dict = self._db[self.uid2sid[uid]]
        _dict["verified_logout"] = uuid.uuid4().urn

    def get_token_id(self, uid):
        _dict = self._db[self.uid2sid[uid]]
        return _dict["id_token"]

    def is_revoke_uid(self, uid):
        return self._db[self.uid2sid[uid]]["revoked"]

    def revoke_uid(self, uid):
        self._db[self.uid2sid[uid]]["revoked"] = True

    def get_sid_from_userid(self, uid):
        return self.uid2sid[uid]

    def duplicate(self, sinfo):
        _dic = copy.copy(sinfo)
        areq = AuthorizationRequest().from_json(_dic["authzreq"])
        sid = self.token.key(user=_dic["sub"], areq=areq)

        _dic["code"] = self.token(sid=sid)
        _dic["code_used"] = False

        for key in ["access_token", "access_token_scope", "oauth_state",
                    "token_type", "token_expires_at", "expires_in",
                    "client_id_issued_at", "id_token", "oidreq",
                    "refresh_token"]:
            try:
                del _dic[key]
            except KeyError:
                pass

        self._db[sid] = _dic
        self.uid2sid[_dic["sub"]] = sid
        return sid

    def read(self, token):
        (typ, key) = self.token.type_and_key(token)

        if typ != "T":  # not a access grant
            raise WrongTokenType("Not a grant token")

        return self._db[key]

########NEW FILE########
__FILENAME__ = stateless
import time
from oic.oic.message import SINGLE_REQUIRED_INT
from oic.oauth2 import Message
from oic.oauth2 import SINGLE_REQUIRED_STRING
from oic.oauth2 import SINGLE_OPTIONAL_STRING
from oic.utils.time_util import epoch_in_a_while

__author__ = 'roland'


class Content(Message):
    c_param = {
        "typ": SINGLE_REQUIRED_STRING,  # type of token
        "sub": SINGLE_REQUIRED_STRING,  # Which subject that authenticated
        "auz": SINGLE_OPTIONAL_STRING,  # Authorization information
        "aud": SINGLE_OPTIONAL_STRING,  # The intended receiver
        "val": SINGLE_REQUIRED_INT,     # Valid until
        "ref": SINGLE_OPTIONAL_STRING   # Refresh token
    }
    c_allowed_values = {"type": ["code", "access", "refresh"]}


class StateLess(object):
    def __init__(self, keys, enc_alg, enc_method, grant_validity=300,
                 access_validity=600, refresh_validity=0):
        self.keys = keys
        self.alg = enc_alg
        self.enc = enc_method
        self.validity = {"grant": grant_validity, "access": access_validity,
                         "refresh": refresh_validity}
        self.used_grants = []
        self.revoked = []

    def __getitem__(self, token):
        """
        :param token: authz grant code or refresh token
        :return: information about the session
        """
        return Content().from_jwe(token, self.keys)

    def get_token(self, cont):
        return cont.to_jwe(self.keys, self.enc, self.alg)

    def create_authz_session(self, sub, areq, **kwargs):
        """

        :param sub: Identifier for the user, this is the real identifier
        :param areq: The AuthorizationRequest instance
        :return: The session identifier, which is the database key
        """
        _cont = Content(typ="code", sub=sub, aud=areq["redirect_uri"],
                        val=epoch_in_a_while(self.validity["grant"]))

        #return _cont.to_jwe(self.keys, self.enc, self.alg)
        return _cont

    def upgrade_to_token(self, cont, issue_refresh=False):
        cont["typ"] = "access"
        cont["val"] = epoch_in_a_while(self.validity["access"])
        if issue_refresh:
            _c = Content(sub=cont["sub"], aud=cont["aud"], typ="refresh",
                         val=epoch_in_a_while(self.validity["refresh"]))
            cont["ref"] = _c.to_jwe(self.keys, self.enc, self.alg)

        return cont

    def refresh_token(self, rtoken):
        # assert that it is a refresh token
        _cont = Content().from_jwe(rtoken, self.keys)
        try:
            assert _cont["typ"] == "refresh"
        except AssertionError:
            raise Exception("Not a refresh token")

    def is_expired(self, token):
        _cont = Content().from_jwe(token, self.keys)
        if _cont["val"] < time.time():
            return True

    def is_valid(self, token):
        _cont = Content().from_jwe(token, self.keys)

        if _cont["val"] >= time.time():
            return False
        if token in self.revoked:
            return False
        else:
            return True

    def is_revoked(self, token):
        if token in self.revoked:
            return True
        else:
            return False

    def revoke_token(self, token):
        # revokes either the refresh token or the access token
        self.revoked.append(token)

    def store_session(self, cont):
        pass
########NEW FILE########
__FILENAME__ = time_util
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Implements some usefull functions when dealing with validity of
different types of information.
"""

import calendar
import re
import time
import sys

from datetime import timedelta
from datetime import datetime

TIME_FORMAT = "%Y-%m-%dT%H:%M:%SZ"
TIME_FORMAT_WITH_FRAGMENT = re.compile(
    "^(\d{4,4}-\d{2,2}-\d{2,2}T\d{2,2}:\d{2,2}:\d{2,2})\.\d*Z$")

# ---------------------------------------------------------------------------
# I'm sure this is implemented somewhere else can't find it now though, so I
# made an attempt.
#Implemented according to
#http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/
#adding-durations-to-dateTimes


def f_quotient(arg0, arg1, arg2=0):
    if arg2:
        return int((arg0 - arg1) / (arg2 - arg1))
    elif not arg0:
        return 0
    else:
        return int(arg0 / arg1)


def modulo(arg0, arg1, arg2=0):
    if arg2:
        return ((arg0 - arg1) % (arg2 - arg1)) + arg1
    else:
        return arg0 % arg1


def maximum_day_in_month_for(year, month):
    return calendar.monthrange(year, month)[1]


D_FORMAT = [
    ("Y", "tm_year"),
    ("M", "tm_mon"),
    ("D", "tm_mday"),
    ("T", None),
    ("H", "tm_hour"),
    ("M", "tm_min"),
    ("S", "tm_sec")
]


def parse_duration(duration):
    # (-)PnYnMnDTnHnMnS
    index = 0
    if duration[0] == '-':
        sign = '-'
        index += 1
    else:
        sign = '+'
    assert duration[index] == "P"
    index += 1

    dic = dict([(typ, 0) for (code, typ) in D_FORMAT])

    for code, typ in D_FORMAT:
        #print duration[index:], code
        if duration[index] == '-':
            raise Exception("Negation not allowed on individual items")
        if code == "T":
            if duration[index] == "T":
                index += 1
                if index == len(duration):
                    raise Exception("Not allowed to end with 'T'")
            else:
                raise Exception("Missing T")
        else:
            try:
                mod = duration[index:].index(code)
                try:
                    dic[typ] = int(duration[index:index + mod])
                except ValueError:
                    if code == "S":
                        try:
                            dic[typ] = float(duration[index:index + mod])
                        except ValueError:
                            raise Exception("Not a float")
                    else:
                        raise Exception(
                            "Fractions not allow on anything byt seconds")
                index = mod + index + 1
            except ValueError:
                dic[typ] = 0

        if index == len(duration):
            break

    return sign, dic


def add_duration(tid, duration):

    (sign, dur) = parse_duration(duration)

    if sign == '+':
        #Months
        temp = tid.tm_mon + dur["tm_mon"]
        month = modulo(temp, 1, 13)
        carry = f_quotient(temp, 1, 13)
        #Years
        year = tid.tm_year + dur["tm_year"] + carry
        # seconds
        temp = tid.tm_sec + dur["tm_sec"]
        secs = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # minutes
        temp = tid.tm_min + dur["tm_min"] + carry
        minutes = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # hours
        temp = tid.tm_hour + dur["tm_hour"] + carry
        hour = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # days
        if dur["tm_mday"] > maximum_day_in_month_for(year, month):
            temp_days = maximum_day_in_month_for(year, month)
        elif dur["tm_mday"] < 1:
            temp_days = 1
        else:
            temp_days = dur["tm_mday"]
        days = temp_days + tid.tm_mday + carry
        while True:
            if days < 1:
                pass
            elif days > maximum_day_in_month_for(year, month):
                days -= maximum_day_in_month_for(year, month)
                carry = 1
            else:
                break
            temp = month + carry
            month = modulo(temp, 1, 13)
            year += f_quotient(temp, 1, 13)

        return time.localtime(time.mktime((year, month, days, hour, minutes,
                                           secs, 0, 0, -1)))
    else:
        pass

# ---------------------------------------------------------------------------


def time_in_a_while(days=0, seconds=0, microseconds=0, milliseconds=0,
                    minutes=0, hours=0, weeks=0):
    """
    format of timedelta::
        timedelta([days[, seconds[, microseconds[, milliseconds[,
        minutes[, hours[, weeks]]]]]]])

    :return: UTC time
    """
    delta = timedelta(days, seconds, microseconds, milliseconds,
                      minutes, hours, weeks)
    return datetime.utcnow() + delta


def time_a_while_ago(days=0, seconds=0, microseconds=0, milliseconds=0,
                     minutes=0, hours=0, weeks=0):
    """
    format of timedelta::
        timedelta([days[, seconds[, microseconds[, milliseconds[,
        minutes[, hours[, weeks]]]]]]])
    """
    delta = timedelta(days, seconds, microseconds, milliseconds,
                      minutes, hours, weeks)
    return datetime.utcnow() - delta


def in_a_while(days=0, seconds=0, microseconds=0, milliseconds=0,
               minutes=0, hours=0, weeks=0, time_format=TIME_FORMAT):
    """
    format of timedelta::
        timedelta([days[, seconds[, microseconds[, milliseconds[,
        minutes[, hours[, weeks]]]]]]])
    """
    if not time_format:
        time_format = TIME_FORMAT

    return time_in_a_while(days, seconds, microseconds, milliseconds,
                           minutes, hours, weeks).strftime(time_format)


def a_while_ago(days=0, seconds=0, microseconds=0, milliseconds=0,
                minutes=0, hours=0, weeks=0, time_format=TIME_FORMAT):
    return time_a_while_ago(days, seconds, microseconds, milliseconds,
                            minutes, hours, weeks).strftime(time_format)

# ---------------------------------------------------------------------------


def shift_time(dtime, shift):
    """ Adds/deletes an integer amount of seconds from a datetime specification

    :param dtime: The datatime specification
    :param shift: The wanted time shift (+/-)
    :return: A shifted datatime specification
    """
    return dtime + timedelta(seconds=shift)

# ---------------------------------------------------------------------------


def str_to_time(timestr, time_format=TIME_FORMAT):
    """

    :param timestr:
    :param time_format:
    :return: UTC time
    """
    if not timestr:
        return 0
    try:
        then = time.strptime(timestr, time_format)
    except ValueError:  # assume it's a format problem
        try:
            elem = TIME_FORMAT_WITH_FRAGMENT.match(timestr)
        except Exception, exc:
            print >> sys.stderr, "Exception: %s on %s" % (exc, timestr)
            raise
        then = time.strptime(elem.groups()[0] + "Z", TIME_FORMAT)

    return time.gmtime(calendar.timegm(then))


def instant(time_format=TIME_FORMAT):
    return time.strftime(time_format, time.gmtime())

# ---------------------------------------------------------------------------


def utc_now():
    return calendar.timegm(time.gmtime())

# ---------------------------------------------------------------------------


def before(point):
    """ True if point datetime specification is before now """
    if not point:
        return True

    if isinstance(point, basestring):
        point = str_to_time(point)
    elif isinstance(point, int):
        point = time.gmtime(point)

    return time.gmtime() < point


def after(point):
    """ True if point datetime specification is equal or after now """
    if not point:
        return True
    else:
        return not before(point)


not_before = after

# 'not_on_or_after' is just an obscure name for 'before'
not_on_or_after = before

# a point is valid if it is now or sometime in the future, in other words,
# if it is not before now
valid = before


def later_than(after, before):
    """ True if then is later or equal to that """
    if isinstance(after, basestring):
        after = str_to_time(after)
    elif isinstance(after, int):
        after = time.gmtime(after)

    if isinstance(before, basestring):
        before = str_to_time(before)
    elif isinstance(before, int):
        before = time.gmtime(before)

    return after >= before


def utc_time_sans_frac():
    return int("%d" % time.mktime(time.gmtime()))


def time_sans_frac():
    return int("%d" % time.time())

def epoch_in_a_while(days=0, seconds=0, microseconds=0, milliseconds=0,
                     minutes=0, hours=0, weeks=0):
    """
    Return a point in the future as number of seconds since the epoch
    1970-01-01
    """
    return int("%d" % time.mktime(time_in_a_while(days, seconds, microseconds,
                                                  milliseconds, minutes, hours,
                                                  weeks).timetuple()))

########NEW FILE########
__FILENAME__ = distaggr
import copy
import logging
from oic.oic import OpenIDSchema
from oic.oic.claims_provider import ClaimsClient
from oic.utils.userinfo import UserInfo

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


class DistributedAggregatedUserInfo(UserInfo):

    def __init__(self, db, oidcsrv, client_info=None):
        UserInfo.__init__(self, db)
        self.oidcsrv = oidcsrv
        self.claims_clients = self.init_claims_clients(client_info)

        for key, cc in self.claims_clients.items():
            oidcsrv.keyjar.update(cc.keyjar)

    def dynamic_init_claims_client(self, issuer, req_args):
        cc = ClaimsClient()
        # dynamic provider info discovery
        cc.provider_config(issuer)
        resp = cc.do_registration_request(request_args=req_args)
        cc.client_id = resp.client_id
        cc.client_secret = resp.client_secret
        return cc

    def init_claims_clients(self, client_info):
        res = {}
        if client_info is None:
            return res

        for cid, specs in client_info.items():
            if "dynamic" in specs:
                cc = self.dynamic_init_claims_client(cid, specs["client"])
            else:
                cc = ClaimsClient(client_id=specs["client_id"])
                cc.client_secret = specs["client_secret"]
                try:
                    cc.keyjar.add(specs["client_id"], specs["jwks_uri"])
                except KeyError:
                    pass
                cc.userclaims_endpoint = specs["userclaims_endpoint"]
            res[cid] = cc
        return res

    def _collect_distributed(self, srv, cc, sub, what, alias=""):

        try:
            resp = cc.do_claims_request(request_args={"sub": sub,
                                                      "claims_names": what})
        except Exception:
            raise

        result = {"_claims_names": {}, "_claims_sources": {}}

        if not alias:
            alias = srv

        for key in resp["claims_names"]:
            result["_claims_names"][key] = alias

        if "jwt" in resp:
            result["_claims_sources"][alias] = {"JWT": resp["jwt"]}
        else:
            result["_claims_sources"][alias] = {"endpoint": resp["endpoint"]}
            if "access_token" in resp:
                result["_claims_sources"][alias]["access_token"] = resp[
                    "access_token"]

        return result

    def __call__(self, userid, user_info_claims=None, **kwargs):
        """
        :param userid: The local user id
        :param user_info_claims: Possible userinfo claims (a dictionary)
        :return: A schema dependent userinfo instance
        """

        logger.info("User_info about '%s'" % userid)
        identity = copy.copy(self.db[userid])

        if user_info_claims:
            result = {}
            missing = []
            optional = []
            if "claims" in user_info_claims:
                for key, restr in user_info_claims["claims"].items():
                    try:
                        result[key] = identity[key]
                    except KeyError:
                        if restr == {"essential": True}:
                            missing.append(key)
                        else:
                            optional.append(key)

            # Check if anything asked for is somewhere else
            if (missing or optional) and "_external_" in identity:
                cpoints = {}
                remaining = missing[:]
                missing.extend(optional)
                for key in missing:
                    for _srv, what in identity["_external_"].items():
                        if key in what:
                            try:
                                cpoints[_srv].append(key)
                            except KeyError:
                                cpoints[_srv] = [key]
                            try:
                                remaining.remove(key)
                            except ValueError:
                                pass

                if remaining:
                    raise Exception("Missing properties '%s'" % remaining)

                for srv, what in cpoints.items():
                    cc = self.oidcsrv.claims_clients[srv]
                    logger.debug("srv: %s, what: %s" % (srv, what))
                    _res = self._collect_distributed(srv, cc, userid, what)
                    logger.debug("Got: %s" % _res)
                    for key, val in _res.items():
                        if key in result:
                            result[key].update(val)
                        else:
                            result[key] = val

        else:
            # default is what "openid" demands which is sub
            #result = identity
            result = {"sub": userid}

        return OpenIDSchema(**result)

########NEW FILE########
__FILENAME__ = ldap_info
import logging
import ldap
from ldap import SCOPE_SUBTREE

from oic.utils.userinfo import UserInfo

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


OPENID2LDAP = {
    "sub": "uid",
    "name": "displayName",
    "given_name": "givenname",
    "family_name": "sn",
    "middle_name": "",
    "nickname":	"eduPersonNickname",
    "preferred_username": "uid",
    "profile": "labeledURI",
    "picture": "jpegPhoto",
    "website": "labeledURI",
    "email": "mail",
    #"email_verified":
    "gender": "schacGender",
    "birthdate": "schacDateOfBirth",
    #zoneinfo
    "locale": "preferredLanguage",
    "phone_number":	"telephoneNumber",
    #phone_number_verified
    "address": "postalAddress",
    "updated_at": ""  # Nothing equivalent
}

LDAP2USERINFO = dict([(v, k) for k, v in OPENID2LDAP.items()])


class UserInfoLDAP(UserInfo):
    def __init__(self, uri, base, filter_pattern, scope=SCOPE_SUBTREE,
                 tls=False, user="", passwd="", attr=None, attrsonly=False):
        UserInfo.__init__(self, None)
        self.ldapuri = uri
        self.base = base
        self.filter_pattern = filter_pattern
        self.scope = scope
        self.tls = tls
        self.attr = attr
        self.attrsonly = attrsonly
        self.ldapuser = user
        self.ldappasswd = passwd
        self.bind()
        self.ld = None

    def bind(self):
        self.ld = ldap.initialize(self.ldapuri)
        self.ld.protocol_version = ldap.VERSION3
        self.ld.simple_bind_s(self.ldapuser, self.ldappasswd)

    def __call__(self, userid, user_info_claims=None, first_only=True,
                 **kwargs):
        _filter = self.filter_pattern % userid
        logger.debug("CLAIMS: %s" % user_info_claims)
        _attr = self.attr
        if user_info_claims:
            try:
                _claims = user_info_claims["claims"]
            except KeyError:
                pass
            else:
                avaspec = {}
                for key, val in _claims.items():
                    try:
                        attr = OPENID2LDAP[key]
                    except KeyError:
                        pass
                    else:
                        try:
                            avaspec[attr].append(val)
                        except KeyError:
                            avaspec[attr] = [val]

                _attr.extend(avaspec.keys())

        arg = [self.base, self.scope, _filter, _attr, self.attrsonly]
        try:
            res = self.ld.search_s(*arg)
        except:
            try:
                self.ld.close()
            except:
                pass
            self.bind()
            res = self.ld.search_s(*arg)
        if len(res) == 1:
            # should only be one entry and the information per entry is
            # the tuple (dn, ava)
            newres = {}
            for key, val in res[0][1].items():
                if first_only:
                    val = val[0]  # if more than one just return the first
                try:
                    newres[LDAP2USERINFO[key]] = val
                except KeyError:
                    newres[key] = val
            return newres
        else:
            return {}
########NEW FILE########
__FILENAME__ = webfinger
# coding=utf-8
import json
import logging
import re
from urllib import urlencode
import urlparse
import requests
from oic.utils.time_util import in_a_while

__author__ = 'rolandh'

logger = logging.getLogger(__name__)

WF_URL = "https://%s/.well-known/webfinger"
OIC_ISSUER = "http://openid.net/specs/connect/1.0/issuer"


class Base(object):
    c_param = {}

    def __init__(self, dic=None):
        self._ava = {}
        if dic is not None:
            self.load(dic)

    def __setitem__(self, item, val):
        spec = self.c_param[item]
        try:
            t1, t2 = spec["type"]
            if t1 == list:  # Should always be
                assert not isinstance(val, basestring)
                assert isinstance(val, list)
                res = []
                if t2 == LINK:
                    for v in val:
                        res.append(LINK(v))
                else:
                    for v in val:
                        try:
                            assert isinstance(v, t2)
                        except AssertionError:
                            pass
                        res.append(v)
                self._ava[item] = res
        except TypeError:
            t2_type = spec["type"]
            try:
                assert isinstance(val, t2_type)
                self._ava[item] = val
            except AssertionError:
                pass

    def load(self, dictionary):
        for key, spec in self.c_param.items():
            if key not in dictionary and spec["required"] is True:
                raise AttributeError("Required attribute '%s' missing" % key)

        for key, val in dictionary.items():
            if val == "" or val == [""]:
                continue

            skey = str(key)
            try:
                self[skey] = val
            except KeyError:
                # ignore what I don't know
                pass

        return self

    def dump(self):
        res = {}
        for key in self.c_param.keys():
            try:
                val = self._ava[key]
            except KeyError:
                continue

            if self.c_param[key]["type"] == (list, LINK):
                sres = []
                for _val in val:
                    sres.append(_val.dump())
                val = sres
            res[key] = val
        return res

    def __repr__(self):
        return "%s" % self.dump()

    def verify(self):
        pass

    def __getitem__(self, item):
        return self._ava[item]

    def items(self):
        return self._ava.items()

    def keys(self):
        return self._ava.keys()

    def values(self):
        return self._ava.values()

    def __len__(self):
        return self._ava.__len__()

    def __contains__(self, item):
        return item in self._ava


class LINK(Base):
    c_param = {
        "rel": {"type": basestring, "required": True},
        "type": {"type": basestring, "required": False},
        "href": {"type": basestring, "required": False},
        "titles": {"type": dict, "required": False},
        "properties": {"type": dict, "required": False},
    }


class JRD(Base):
    c_param = {
        "expires": {"type": basestring, "required": False},
        "subject": {"type": basestring, "required": True},
        "aliases": {"type": (list, basestring), "required": False},
        "properties": {"type": dict, "required": False},
        "links": {"type": (list, LINK), "required": False},
    }

    def __init__(self, dic=None, days=0, seconds=0, minutes=0, hours=0,
                 weeks=0):
        Base.__init__(self, dic)
        self.expires_in(days, seconds, minutes, hours, weeks)

    def expires_in(self, days=0, seconds=0, minutes=0, hours=0, weeks=0):
        self._exp_days = days
        self._exp_secs = seconds
        self._exp_min = minutes
        self._exp_hour = hours
        self._exp_week = weeks

    def export(self):
        res = self.dump()
        res["expires"] = in_a_while(days=self._exp_days, seconds=self._exp_secs,
                                    minutes=self._exp_min, hours=self._exp_hour,
                                    weeks=self._exp_week)
        return res


# -- Normalization --
# A string of any other type is interpreted as a URI either the form of scheme
# "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
# path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
# normalized according to the following rules:
#
# If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
# portion, the string is interpreted as [userinfo "@"] host [":" port]
# path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
# If the userinfo component is present and all of the path component, query
# component, and port component are empty, the acct scheme is assumed. In this
# case, the normalized URI is formed by prefixing acct: to the string as the
# scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an
# at-sign character ('@') in the userinfo component, it needs to be
# percent-encoded as described in RFC 3986 [RFC3986].
# For all other inputs without a scheme portion, the https scheme is assumed,
# and the normalized URI is formed by prefixing https:// to the string as the
# scheme.
# If the resulting URI contains a fragment portion, it MUST be stripped off
# together with the fragment delimiter character "#".
# The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the
# resulting URI, and the WebFinger Host is the authority component.
#
# Note: Since the definition of authority in RFC 3986 [RFC3986] is
# [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
# identifier like userinfo@host:port, e.g., alice@example.com:8080.

class URINormalizer(object):
    def has_scheme(self, inp):
        if "://" in inp:
            return True
        else:
            authority = inp.replace('/', '#').replace('?', '#').split("#")[0]

            if ':' in authority:
                scheme_or_host, host_or_port = authority.split(':', 1)
                try:
                    # Assert it's not a port number
                    assert not re.match('^\d+$', host_or_port)
                except AssertionError:
                    return False
            else:
                return False
        return True

    def acct_scheme_assumed(self, inp):
        if '@' in inp:
            host = inp.split('@')[-1]
            return not (':' in host or '/' in host or '?' in host)
        else:
            return False

    def normalize(self, inp):
        if self.has_scheme(inp):
            pass
        elif self.acct_scheme_assumed(inp):
            inp = "acct:%s" % inp
        else:
            inp = "https://%s" % inp
        return inp.split("#")[0]  # strip fragment


class WebFinger(object):
    def __init__(self, default_rel=None, httpd=None):
        self.default_rel = default_rel
        self.httpd = httpd
        self.jrd = None

    def query(self, resource, rel=None):
        resource = URINormalizer().normalize(resource)

        info = [("resource", resource)]

        if rel is None:
            if self.default_rel:
                info.append(("rel", self.default_rel))
        elif isinstance(rel, basestring):
            info.append(("rel", rel))
        else:
            for val in rel:
                info.append(("rel", val))

        if resource.startswith("http"):
            part = urlparse.urlparse(resource)
            host = part.hostname
            if part.port is not None:
                host += ":" + str(part.port)
        elif resource.startswith("acct:"):
            host = resource.split('@')[-1]
            host = host.replace('/', '#').replace('?', '#').split("#")[0]
        elif resource.startswith("device:"):
            host = resource.split(':')[1]
        else:
            raise Exception("Unknown schema")

        return "%s?%s" % (WF_URL % host, urlencode(info))

    def load(self, item):
        return JRD(json.loads(item))

    def http_args(self, jrd=None):
        if jrd is None:
            if self.jrd:
                jrd = self.jrd
            else:
                return None

        return {
            "headers": {"Access-Control-Allow-Origin": "*",
                        "Content-Type": "application/json; charset=UTF-8"},
            "body": json.dumps(jrd.export())
        }

    def discovery_query(self, resource):
        """
        Given a resource find a OpenID connect OP to use

        :param resource: An identifier of an entity
        :return: A URL if an OpenID Connect OP could be found
        """

        logger.debug("Looking for OIDC OP for '%s'" % resource)
        url = self.query(resource, OIC_ISSUER)
        try:
            rsp = self.httpd.http_request(url)
        except requests.ConnectionError:
            raise

        if rsp.status_code == 200:
            self.jrd = self.load(rsp.text)
            for link in self.jrd["links"]:
                if link["rel"] == OIC_ISSUER:
                    return link["href"]
            return None
        elif rsp.status_code in [302, 301, 307]:
            return self.discovery_query(rsp.headers["location"])
        else:
            raise Exception(rsp.status_code)

    def response(self, subject, base):
        self.jrd = JRD()
        self.jrd["subject"] = subject
        link = LINK()
        link["rel"] = OIC_ISSUER
        link["href"] = base
        self.jrd["links"] = [link]
        return json.dumps(self.jrd.export())
########NEW FILE########
__FILENAME__ = dyn_test_keyio
from oic.oic.message import ProviderConfigurationResponse
from oic.utils.keyio import KeyJar

__author__ = 'rolandh'

PROVIDER_INFO = {
    "registration_endpoint": "https://connect-op.heroku.com/connect/client",
    "userinfo_endpoint": "https://connect-op.heroku.com/user_info",
    "token_endpoint_auth_types_supported": "client_secret_basic",
    "request_object_signing_alg_values_supported": "RS256",
    "user_id_types_supported": ["public", "pairwise"],
    "scopes_supported": ["openid", "profile", "email", "address", "phone"],
    "token_endpoint": "https://connect-op.heroku.com/access_tokens",
    "id_token_algs_supported": ["RS256"], "version": "3.0",
    "jwk_url": "https://connect-op.heroku.com/jwk.json",
    "response_types_supported": ["code", "token", "id_token", "code token",
                                 "code id_token", "id_token token",
                                 "code id_token token"],
    "authorization_endpoint": "https://connect-op.heroku.com/authorizations/new",
    "x509_url": "https://connect-op.heroku.com/cert.pem",
    "issuer": "https://connect-op.heroku.com"}

def test_provider():
    ks = KeyJar()
    pcr = ProviderConfigurationResponse().from_dict(PROVIDER_INFO)
    ks.load_keys(pcr, "https://connect-op.heroku.com")

    assert ks["https://connect-op.heroku.com"]

########NEW FILE########
__FILENAME__ = fakeoauth2srv
#!/usr/bin/env python
__author__ = 'rohe0002'

import urlparse

from oic.utils.sdb import SessionDB
from oic.oauth2 import Server
from oic.oauth2.message import *

class Response():
    def __init__(self, base=None):
        self.status_code = 200
        if base:
            for key, val in base.items():
                self.__setitem__(key, val)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, item):
        return getattr(self, item)

ENDPOINT = {
    "authorization_endpoint":"/authorization",
    "token_endpoint":"/token",
}

class MyFakeOAuth2Server(Server):
    def __init__(self, jwt_keys=None, name=""):
        Server.__init__(self, jwt_keys=jwt_keys)
        self.sdb = SessionDB()
        self.name = name
        self.client = {}
        self.registration_expires_in = 3600
        self.host = ""

    #noinspection PyUnusedLocal
    def http_request(self, url, method="GET", **kwargs):
        part = urlparse.urlparse(url)
        path = part[2]
        query = part[4]
        self.host = "%s://%s" % (part.scheme, part.netloc)

        response = Response
        response.status_code = 500
        response.text = ""

        if path == ENDPOINT["authorization_endpoint"]:
            assert method == "GET"
            response = self.authorization_endpoint(query)
        elif path == ENDPOINT["token_endpoint"]:
            assert method == "POST"
            response = self.token_endpoint(kwargs["data"])

        return response

    def authorization_endpoint(self, query):
        req = self.parse_authorization_request(query=query)
        sid = self.sdb.create_authz_session(user_id="user", areq=req)
        _info = self.sdb[sid]

        if "code" in req["response_type"]:
            if "token" in req["response_type"]:
                grant = _info["code"]
                _dict = self.sdb.upgrade_to_token(grant)
                _dict["oauth_state"]="authz",

                _dict = by_schema(AuthorizationResponse(), **_dict)
                resp = AuthorizationResponse(**_dict)
                #resp.code = grant
            else:
                resp = AuthorizationResponse(state=req["state"],
                                             code=_info["code"])

        else: # "implicit" in req.response_type:
            grant = _info["code"]
            params = AccessTokenResponse.c_param.keys()

            _dict = dict([(k,v) for k,
                                    v in self.sdb.upgrade_to_token(grant).items() if k in
                                                                                    params])
            try:
                del _dict["refresh_token"]
            except KeyError:
                pass

            resp = AccessTokenResponse(**_dict)

        location = resp.request(req["redirect_uri"])
        response= Response()
        response.headers = {"location":location}
        response.status_code = 302
        response.text = ""
        return response

    def token_endpoint(self, data):
        if "grant_type=refresh_token" in data:
            req = self.parse_refresh_token_request(body=data)
            _info = self.sdb.refresh_token(req["refresh_token"])
        elif "grant_type=authorization_code":
            req = self.parse_token_request(body=data)
            _info = self.sdb.update_to_token(req["code"])
        else:
            response = TokenErrorResponse(error="unsupported_grant_type")
            return response, ""

        resp = AccessTokenResponse(**by_schema(AccessTokenResponse, **_info))
        response = Response()
        response.headers = {"content-type":"application/json"}
        response.text = resp.to_json()

        return response



########NEW FILE########
__FILENAME__ = fakeoicsrv
#!/usr/bin/env python
from urlparse import parse_qs
from jwkest.jws import alg2keytype
from oic.oauth2.message import by_schema
from oic.utils.webfinger import WebFinger

__author__ = 'rohe0002'

from oic.utils.sdb import SessionDB
from oic.utils.time_util import utc_time_sans_frac

from oic.oic import Server

from oic.oic.message import *
from oic.oauth2 import rndstr

class Response():
    def __init__(self, base=None):
        self.status_code = 200
        if base:
            for key, val in base.items():
                self.__setitem__(key, val)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, item):
        return getattr(self, item)

ENDPOINT = {
    "authorization_endpoint": "/authorization",
    "token_endpoint": "/token",
    "user_info_endpoint": "/userinfo",
    "check_session_endpoint": "/check_session",
    "refresh_session_endpoint": "/refresh_session",
    "end_session_endpoint": "/end_session",
    "registration_endpoint": "/registration",
    "discovery_endpoint": "/discovery",
    "register_endpoint": "/register"
}


class MyFakeOICServer(Server):
    def __init__(self, name=""):
        Server.__init__(self)
        self.sdb = SessionDB()
        self.name = name
        self.client = {}
        self.registration_expires_in = 3600
        self.host = ""
        self.webfinger = WebFinger()

    #noinspection PyUnusedLocal
    def http_request(self, path, method="GET", **kwargs):
        part = urlparse(path)
        path = part[2]
        query = part[4]
        self.host = "%s://%s" % (part.scheme, part.netloc)

        response = Response
        response.status_code = 500
        response.text = ""

        if path == ENDPOINT["authorization_endpoint"]:
            assert method == "GET"
            response = self.authorization_endpoint(query)
        elif path == ENDPOINT["token_endpoint"]:
            assert method == "POST"
            response = self.token_endpoint(kwargs["data"])
        elif path == ENDPOINT["user_info_endpoint"]:
            assert method == "POST"
            response = self.userinfo_endpoint(kwargs["data"])
        elif path == ENDPOINT["refresh_session_endpoint"]:
            assert method == "GET"
            response = self.refresh_session_endpoint(query)
        elif path == ENDPOINT["check_session_endpoint"]:
            assert method == "GET"
            response = self.check_session_endpoint(query)
        elif path == ENDPOINT["end_session_endpoint"]:
            assert method == "GET"
            response = self.end_session_endpoint(query)
        elif path == ENDPOINT["registration_endpoint"]:
            if method == "POST":
                response = self.registration_endpoint(kwargs["data"])
        elif path == "/.well-known/webfinger":
            assert method == "GET"
            qdict = parse_qs(query)
            response.status_code = 200
            response.text = self.webfinger.response(qdict["resource"][0],
                                                    "%s/" % self.name)
        elif path == "/.well-known/openid-configuration":
            assert method == "GET"
            response = self.openid_conf()

        return response

    def authorization_endpoint(self, query):
        req = self.parse_authorization_request(query=query)
        sid = self.sdb.create_authz_session(sub="user", areq=req)
        _info = self.sdb[sid]
        _info["sub"] = _info["local_sub"]

        if "code" in req["response_type"]:
            if "token" in req["response_type"]:
                grant = _info["code"]
                _dict = self.sdb.upgrade_to_token(grant)
                _dict["oauth_state"] = "authz",

                _dict = by_schema(AuthorizationResponse(), **_dict)
                resp = AuthorizationResponse(**_dict)
                #resp.code = grant
            else:
                resp = AuthorizationResponse(state=req["state"],
                                             code=_info["code"])

        else:  # "implicit" in req.response_type:
            grant = _info["code"]
            params = AccessTokenResponse.c_param.keys()

            _dict = dict([(k, v) for k, v in
                          self.sdb.upgrade_to_token(grant).items() if k in
                                                                     params])
            try:
                del _dict["refresh_token"]
            except KeyError:
                pass

            if "id_token" in req["response_type"]:
                _idt = self.make_id_token(_info, issuer=self.name,
                                          access_token=_dict["access_token"])
                alg = "RS256"
                ckey = self.keyjar.get_signing_key(alg2keytype(alg),
                                                   _info["client_id"])
                _dict["id_token"] = _idt.to_jwt(key=ckey, algorithm=alg)

            resp = AccessTokenResponse(**_dict)

        location = resp.request(req["redirect_uri"])
        response = Response()
        response.headers = {"location": location}
        response.status_code = 302
        response.text = ""
        return response

    def token_endpoint(self, data):
        if "grant_type=refresh_token" in data:
            req = self.parse_refresh_token_request(body=data)
            _info = self.sdb.refresh_token(req["refresh_token"])
        elif "grant_type=authorization_code":
            req = self.parse_token_request(body=data)
            _info = self.sdb.upgrade_to_token(req["code"])
        else:
            response = TokenErrorResponse(error="unsupported_grant_type")
            return response, ""

        resp = AccessTokenResponse(**by_schema(AccessTokenResponse, **_info))
        response = Response()
        response.headers = {"content-type": "application/json"}
        response.text = resp.to_json()

        return response

    def userinfo_endpoint(self, data):

        _ = self.parse_user_info_request(data)
        _info = {
            "sub": "melgar",
            "name": "Melody Gardot",
            "nickname": "Mel",
            "email": "mel@example.com",
            "verified": True,
        }

        resp = OpenIDSchema(**_info)
        response = Response()
        response.headers = {"content-type": "application/json"}
        response.text = resp.to_json()

        return response

    def registration_endpoint(self, data):
        try:
            req = self.parse_registration_request(data, "json")
        except ValueError:
            req = self.parse_registration_request(data)

        client_secret = rndstr()
        expires = utc_time_sans_frac() + self.registration_expires_in
        kwargs = {}
        if "client_id" not in req:
            client_id = rndstr(10)
            registration_access_token = rndstr(20)
            _client_info = req.to_dict()
            kwargs.update(_client_info)
            _client_info.update({
                "client_secret": client_secret,
                "info": req.to_dict(),
                "expires": expires,
                "registration_access_token": registration_access_token,
                "registration_client_uri": "register_endpoint"
            })
            self.client[client_id] = _client_info
            kwargs["registration_access_token"] = registration_access_token
            kwargs["registration_client_uri"] = "register_endpoint"
            try:
                del kwargs["operation"]
            except KeyError:
                pass
        else:
            client_id = req.client_id
            _cinfo = self.client[req.client_id]
            _cinfo["info"].update(req.to_dict())
            _cinfo["client_secret"] = client_secret
            _cinfo["expires"] = expires

        resp = RegistrationResponse(client_id=client_id,
                                    client_secret=client_secret,
                                    client_secret_expires_at=expires,
                                    **kwargs)

        response = Response()
        response.headers = {"content-type": "application/json"}
        response.text = resp.to_json()

        return response

    def check_session_endpoint(self, query):
        try:
            idtoken = self.parse_check_session_request(query=query)
        except Exception:
            raise

        response = Response()
        response.text = idtoken.to_json()
        response.headers = {"content-type": "application/json"}
        return response

    #noinspection PyUnusedLocal
    def refresh_session_endpoint(self, query):
        try:
            req = self.parse_refresh_session_request(query=query)
        except Exception:
            raise

        resp = RegistrationResponse(client_id="anonymous",
                                    client_secret="hemligt")

        response = Response()
        response.headers = {"content-type": "application/json"}
        response.text = resp.to_json()
        return response

    def end_session_endpoint(self, query):
        try:
            req = self.parse_end_session_request(query=query)
        except Exception:
            raise

        # redirect back
        resp = EndSessionResponse(state=req["state"])

        url = resp.request(req["redirect_url"])

        response = Response()
        response.headers = {"location": url}
        response.status_code = 302  # redirect
        response.text = ""
        return response

    #noinspection PyUnusedLocal
    def add_credentials(self, user, passwd):
        return

    def openid_conf(self):
        endpoint = {}
        for point, path in ENDPOINT.items():
            endpoint[point] = "%s%s" % (self.host, path)

        signing_algs = jws.SIGNER_ALGS.keys()
        resp = ProviderConfigurationResponse(
            issuer=self.name,
            scopes_supported=["openid", "profile", "email", "address"],
            identifiers_supported=["public", "PPID"],
            flows_supported=["code", "token", "code token", "id_token",
                             "code id_token", "token id_token"],
            subject_types_supported=["pairwise", "public"],
            response_types_supported=["code", "token", "id_token",
                                      "code token", "code id_token",
                                      "token id_token", "code token id_token"],
            jwks_uri="http://example.com/oidc/jwks",
            id_token_signing_alg_values_supported=signing_algs,
            grant_types_supported=["authorization_code", "implicit"],
            **endpoint)

        response = Response()
        response.headers = {"content-type": "application/json"}
        response.text = resp.to_json()
        return response

########NEW FILE########
__FILENAME__ = numbers
#!/usr/bin/env python
# Borrowed from http://gorakhargosh.github.com/pyoauth/_modules/pyoauth/

from array import array
import struct
import math

def long_to_bytes(num, blocksize=0):
    """
    Convert a long integer to a byte string::

        long_to_bytes(n:long, blocksize:int) : string

    :param num:
        Long value
    :param blocksize:
        If optional blocksize is given and greater than zero, pad the front of
        the byte string with binary zeros so that the length is a multiple of
        blocksize.
    :returns:
        Byte string.
    """
    # after much testing, this algorithm was deemed to be the fastest
    s = ''
    num = long(num)
    pack = struct.pack
    while num > 0:
        s = pack('>I', num & 0xffffffffL) + s
        num >>= 32
        # strip off leading zeros
    for i in range(len(s)):
        if s[i] != '\000':
            break
    else:
        # only happens when n == 0
        s = '\000'
        i = 0
    s = s[i:]
    # add back some pad bytes.  this could be done more efficiently w.r.t. the
    # de-padding being done above, but sigh...
    if blocksize > 0 and len(s) % blocksize:
        s = (blocksize - len(s) % blocksize) * '\000' + s
    return s


def bytes_to_long(byte_string):
    """
    Convert a byte string to a long integer::

        bytes_to_long(byte_string) : long

    This is (essentially) the inverse of long_to_bytes().

    :param byte_string:
        A byte string.
    :returns:
        Long.
    """
    acc = 0L
    unpack = struct.unpack
    length = len(byte_string)
    if length % 4:
        extra = (4 - length % 4)
        byte_string = '\000' * extra + byte_string
        length = length + extra
    for i in range(0, length, 4):
        acc = (acc << 32) + unpack('>I', byte_string[i:i+4])[0]
    return acc

def mpi_to_long(mpi_byte_string):
    """
    Converts an OpenSSL-format MPI Bignum byte string into a long.

    :param mpi_byte_string:
        OpenSSL-format MPI Bignum byte string.
    :returns:
        Long value.
    """
    #Make sure this is a positive number
    assert (ord(mpi_byte_string[4]) & 0x80) == 0

    byte_array = bytes_to_bytearray(mpi_byte_string[4:])
    return bytearray_to_long(byte_array)


def long_to_mpi(num):
    """
    Converts a long value into an OpenSSL-format MPI Bignum byte string.

    :param num:
        Long value.
    :returns:
        OpenSSL-format MPI Bignum byte string.
    """
    byte_array = long_to_bytearray(num)
    ext = 0
    #If the high-order bit is going to be set,
    #add an extra byte of zeros
    if not (bit_count(num) & 0x7):
        ext = 1
    length = byte_count(num) + ext
    byte_array = bytearray_concat(bytearray_create_zeros(4+ext), byte_array)
    byte_array[0] = (length >> 24) & 0xFF
    byte_array[1] = (length >> 16) & 0xFF
    byte_array[2] = (length >> 8) & 0xFF
    byte_array[3] = length & 0xFF
    return bytearray_to_bytes(byte_array)

def bytearray_create(sequence):
    """
    Creates a byte array from a given sequence.

    :param sequence:
        The sequence from which a byte array will be created.
    :returns:
        A byte array.
    """
    return array('B', sequence)


def bytearray_create_zeros(count):
    """
    Creates a zero-filled byte array of with ``count`` bytes.

    :param count:
        The number of zero bytes.
    :returns:
        Zero-filled byte array.
    """
    return array('B', [0] * count)


def bytearray_concat(byte_array1, byte_array2):
    """
    Concatenates two byte arrays.

    :param byte_array1:
        Byte array 1
    :param byte_array2:
        Byte array 2
    :returns:
        Concatenated byte array.
    """
    return byte_array1 + byte_array2


def bytearray_to_bytes(byte_array):
    """
    Converts a byte array into a string.

    :param byte_array:
        The byte array.
    :returns:
        String.
    """
    return byte_array.tostring()


def bytes_to_bytearray(byte_string):
    """
    Converts a string into a byte array.

    :param byte_string:
        String value.
    :returns:
        Byte array.
    """
    byte_array = bytearray_create_zeros(0)
    byte_array.fromstring(byte_string)
    return byte_array


def bytearray_to_long(byte_array):
    """
    Converts a byte array to long.

    :param byte_array:
        The byte array.
    :returns:
        Long.
    """
    total = 0L
    multiplier = 1L
    for count in range(len(byte_array)-1, -1, -1):
        byte_val = byte_array[count]
        total += multiplier * byte_val
        multiplier *= 256
    return total


def long_to_bytearray(num):
    """
    Converts a long into a byte array.

    :param num:
        Long value
    :returns:
        Long.
    """
    bytes_count = byte_count(num)
    byte_array = bytearray_create_zeros(bytes_count)
    for count in range(bytes_count - 1, -1, -1):
        byte_array[count] = int(num % 256)
        num >>= 8
    return byte_array

def byte_count(num):
    """
    Determines the number of bytes in a long.

    :param num:
        Long value.
    :returns:
        The number of bytes in the long integer.
    """
    #if num == 0:
    #    return 0
    if not num:
        return 0
    bits = bit_count(num)
    return int(math.ceil(bits / 8.0))


def bit_count(num):
    """
    Determines the number of bits in a long value.

    :param num:
        Long value.
    :returns:
        Returns the number of bits in the long value.
    """
    #if num == 0:
    #    return 0
    if not num:
        return 0
    s = "%x" % num
    return ((len(s)-1)*4) +\
           {'0':0, '1':1, '2':2, '3':2,
            '4':3, '5':3, '6':3, '7':3,
            '8':4, '9':4, 'a':4, 'b':4,
            'c':4, 'd':4, 'e':4, 'f':4,
            }[s[0]]
########NEW FILE########
__FILENAME__ = pinit
from mako.lookup import TemplateLookup
from mako.runtime import UNDEFINED
from oic.utils.authn.authn_context import AuthnBroker
from oic.utils.authn.user import UsernamePasswordMako
from oic.utils.authn.client import verify_client
from oic.utils.authz import AuthzHandling
from oic.utils.userinfo import UserInfo

__author__ = 'rohe0002'

from oic.utils.sdb import SessionDB
from oic.oic.provider import Provider
from oic.utils.keyio import KeyBundle, keybundle_from_local_file
from oic.utils.keyio import KeyJar

CLIENT_CONFIG = {
    "client_id": "number5",
    "ca_certs": "/usr/local/etc/oic/ca_certs.txt",
    "client_timeout": 0
}

CONSUMER_CONFIG = {
    "authz_page": "/authz",
    "scope": ["openid"],
    "response_type": ["code"],
    "user_info": {
        "claims": {
            "name": None,
            "email": None,
            "nickname": None
        }
    },
    "request_method": "param"
}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://connect-op.heroku.com",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    "flows_supported": ["code", "token", "code token"],
}

CLIENT_SECRET = "abcdefghijklmnop"
CLIENT_ID = "client_1"

KC_SYM = KeyBundle([{"kty": "oct", "key": CLIENT_SECRET, "use": "ver"},
                     {"kty": "oct", "key": CLIENT_SECRET, "use": "sig"}])
KC_SYM2 = KeyBundle([{"kty": "oct", "key": "drickyoughurt", "use": "sig"},
                      {"kty": "oct", "key": "drickyoughurt", "use": "ver"}])

KC_RSA = keybundle_from_local_file("../oidc_example/op1/certs/mycert.key",
                                   "rsa", ["ver", "sig"])

KEYJAR = KeyJar()
KEYJAR[CLIENT_ID] = [KC_SYM, KC_RSA]
KEYJAR["number5"] = [KC_SYM2, KC_RSA]
KEYJAR[""] = KC_RSA

CDB = {
    "number5": {
        "password": "hemligt",
        "client_secret": "drickyoughurt",
        #"jwk_key": CONSUMER_CONFIG["key"],
        "redirect_uris": [("http://localhost:8087/authz", None)],
        },
    "a1b2c3": {
        "redirect_uris": [("http://localhost:8087/authz", None)]
    },
    "client0": {
        "redirect_uris": [("http://www.example.org/authz", None)]
    },
    CLIENT_ID: {
        "client_secret": CLIENT_SECRET,
        }

}

USERDB = {
    "user": {
        "name": "Hans Granberg",
        "nickname": "Hasse",
        "email": "hans@example.org",
        "verified": False,
        "sub": "user"
    }
}

URLMAP = {CLIENT_ID: ["https://example.com/authz"]}

PASSWD = {"user": "password"}

ROOT = '../oc3/'
tl = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                    module_directory=ROOT + 'modules',
                    input_encoding='utf-8', output_encoding='utf-8')

AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add(UNDEFINED,
                 UsernamePasswordMako(None, "login.mako", tl, PASSWD,
                                      "authenticated"))

# dealing with authorization
AUTHZ = AuthzHandling()
SYMKEY = "symmetric key used to encrypt cookie info"
USERINFO = UserInfo(USERDB)

provider_init = Provider("pyoicserv", SessionDB(), CDB, AUTHN_BROKER, USERINFO,
                         AUTHZ, verify_client, SYMKEY, urlmap=URLMAP,
                         keyjar=KEYJAR)

########NEW FILE########
__FILENAME__ = test_authn
import json
import os
import urllib
from urlparse import parse_qs
import jwkest
from jwkest.jwk import SYMKey
from jwkest.jws import JWS
from mako.lookup import TemplateLookup
from oic.oic import JWT_BEARER
from oic.utils.authn.client import ClientSecretJWT
from oic.utils.authn.client import PrivateKeyJWT
from oic.utils.http_util import Unauthorized
from oic.oauth2 import rndstr
from oic.oauth2 import Client
from oic.oauth2 import AccessTokenRequest
from oic.utils.authn.user import UsernamePasswordMako
from oic.utils.keyio import KeyBundle
from oic.utils.keyio import rsa_load

__author__ = 'rolandh'

PASSWD = {"user": "hemligt"}

ROOT = '../oidc_example/op1/'
tl = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                    module_directory=ROOT + 'modules',
                    input_encoding='utf-8', output_encoding='utf-8')

_key = rsa_load("%s/certs/mycert.key" % ROOT)

KC_RSA = KeyBundle([{"key": _key, "kty": "RSA", "use": "ver"},
                    {"key": _key, "kty": "RSA", "use": "sig"}])


def create_return_form_env(user, password, query):
    _dict = {
        "login": user,
        "password": password,
        "query": query
    }

    return urllib.urlencode(_dict)


class SRV(object):
    def __init__(self):
        pass


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_1():
    authn = UsernamePasswordMako(None, "login.mako", tl, PASSWD,
                                 "authorization_endpoint")
    assert authn.authenticated_as() is None


def test_2():
    authn = UsernamePasswordMako(None, "login.mako", tl, PASSWD,
                                 "authorization_endpoint")
    resp = authn(query="QUERY")
    print resp.message
    assert 'name="query" value="QUERY"' in resp.message
    assert 'name="login" value=""' in resp.message


def test_3():
    form = create_return_form_env("user", "hemligt", "query=foo")
    srv = SRV()
    srv.symkey = rndstr(16)
    srv.seed = rndstr()
    srv.iv = os.urandom(16)
    srv.cookie_name = "xyzxyz"

    authn = UsernamePasswordMako(srv, "login.mako", tl, PASSWD,
                                 "authorization_endpoint")
    response = authn.verify(parse_qs(form))
    assert response.message == "authorization_endpoint?query=foo&upm_answer=true"
    print len(response.headers) == 2
    flag = 0
    for param, val in response.headers:
        if param == "Set-Cookie":
            assert val.startswith('xyzxyz=')
            flag = 1
    assert flag == 1


# def test_4():
#     form = create_return_form_env("user", "hemligt", "QUERY")
#     srv = SRV()
#     srv.symkey = "symkey"
#     srv.seed = rndstr()
#     srv.iv = os.urandom(16)
#     srv.cookie_name = "xyzxyz"
#
#     authn = UsernamePasswordMako(srv, "login.mako", tl, PASSWD,
#                                  "authorization_endpoint")
#     response = authn.verify(parse_qs(form))
#
#     kaka = None
#     for param, val in response.headers:
#         if param == "Set-Cookie":
#             kaka = val
#             break
#
#     print response.headers
#     print kaka
#     print authn.active
#     user = authn.authenticated_as(kaka)
#     assert user == {"uid": "user"}


def test_5():
    form = create_return_form_env("user", "hemligt", "QUERY")
    srv = SRV()
    srv.symkey = rndstr(16)
    srv.seed = rndstr()
    srv.iv = os.urandom(16)
    srv.cookie_name = "xyzxyz"

    authn = UsernamePasswordMako(srv, "login.mako", tl, PASSWD,
                                 "authorization_endpoint")
    response = authn.verify(parse_qs(form))

    kaka = ""
    for param, val in response.headers:
        if param == "Set-Cookie":
            kaka = val
            break

    kaka = kaka.replace("1", "x")
    try:
        _ = authn.authenticated_as(kaka)
        assert False
    except Exception:
        assert True


def test_6():
    form = create_return_form_env("user", "secret", "QUERY")
    srv = SRV()
    srv.symkey = rndstr(16)
    srv.seed = rndstr()
    srv.iv = os.urandom(16)
    srv.cookie_name = "xyzxyz"

    authn = UsernamePasswordMako(srv, "login.mako", tl, PASSWD,
                                 "authorization_endpoint")
    response = authn.verify(parse_qs(form))
    assert isinstance(response, Unauthorized)


def test_client_secret_jwt():
    cli = Client("Foo")
    cli.token_endpoint = "https://example.com/token"
    cli.client_secret = "foobar"

    csj = ClientSecretJWT(cli)
    cis = AccessTokenRequest()

    http_args = csj.construct(cis, algorithm="HS256")
    print http_args
    assert cis["client_assertion_type"] == JWT_BEARER
    assert "client_assertion" in cis
    cas = cis["client_assertion"]
    header, claim, crypto, header_b64, claim_b64 = jwkest.unpack(cas)
    jso = json.loads(claim)
    assert _eq(jso.keys(), ["aud", "iss", "sub", "jti", "exp", "iat"])
    print header
    assert header == {'alg': 'HS256'}

    _rj = JWS()
    info = _rj.verify_compact(cas, [SYMKey(key=cli.client_secret)])

    _dict = json.loads(info)
    assert _eq(_dict.keys(), ["aud", "iss", "sub", "jti", "exp", "iat"])


def test_private_key_jwt():
    cli = Client("FOO")
    cli.token_endpoint = "https://example.com/token"
    cli.keyjar[""] = KC_RSA

    cis = AccessTokenRequest()
    pkj = PrivateKeyJWT(cli)
    http_args = pkj.construct(cis, algorithm="RS256")
    assert http_args == {}
    cas = cis["client_assertion"]
    header, claim, crypto, header_b64, claim_b64 = jwkest.unpack(cas)
    jso = json.loads(claim)
    assert _eq(jso.keys(), ["aud", "iss", "sub", "jti", "exp", "iat"])
    print header
    assert header == {'alg': 'RS256'}

if __name__ == "__main__":
    test_private_key_jwt()
########NEW FILE########
__FILENAME__ = test_authn_context
import socket
from mako.lookup import TemplateLookup
from oic.utils.authn.user import UsernamePasswordMako
from oic.utils.authn.authn_context import AuthnBroker, PASSWORD
from oic.utils.authn.user_cas import CasAuthnMethod
from oic.utils.authn.ldap_member import UserLDAPMemberValidation

__author__ = 'rolandh'

ROOT = './'

LOOKUP = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                        module_directory=ROOT + 'modules',
                        input_encoding='utf-8', output_encoding='utf-8')
PASSWD = {"diana": "krall",
          "babs": "howes",
          "upper": "crust",
          "rohe0002": "StevieRay",
          "haho0032": "qwerty"
}


def test():
    ac = AuthnBroker()
    issuer = "https://example.com/op"
    CAS_SERVER = ""
    SERVICE_URL = ""

    LDAP = {
        "uri": "ldaps://ldap.umu.se",
        "base": "dc=umu, dc=se",
        "filter_pattern": "(uid=%s)",
        "user": "",
        "passwd": "",
        "attr": ["eduPersonScopedAffiliation", "eduPersonAffiliation"],
    }

    LDAP_EXTRAVALIDATION = {
        "verify_attr": "eduPersonAffiliation",
        "verify_attr_valid": ['employee', 'staff', 'student']
    }
    LDAP_EXTRAVALIDATION.update(LDAP)

    ac.add(PASSWORD,
           UsernamePasswordMako(None, "login.mako", LOOKUP, PASSWD,
                                "%s/authorization" % issuer),
           10, "http://%s" % socket.gethostname())

    ac.add(PASSWORD,
           CasAuthnMethod(
               None, CAS_SERVER, SERVICE_URL,
               "%s/authorization" % issuer,
               UserLDAPMemberValidation(**LDAP_EXTRAVALIDATION)),
           20, "http://%s" % socket.gethostname())

    assert len(ac) == 2

    res = ac.pick(PASSWORD)

    assert res
    # list of two 2-tuples
    assert len(res) == 2
    assert res[0][0].__class__.__name__ == "CasAuthnMethod"
    assert res[1][0].__class__.__name__ == "UsernamePasswordMako"


if __name__ == "__main__":
    test()

########NEW FILE########
__FILENAME__ = test_http_util
from oic.utils.http_util import CookieDealer

__author__ = 'roland'


class DummyServer():
    def __init__(self):
        self.symkey = "0123456789012345"


def test_cookie_dealer_1():
    cd = CookieDealer(DummyServer())
    kaka = cd.create_cookie("Something to pass along", "sso", "Foobar")
    #print kaka
    value, _ts, typ = cd.get_cookie_value(kaka[1], "Foobar")
    assert value == "Something to pass along"
    assert typ == "sso"

if __name__ == "__main__":
    test_cookie_dealer_1()

########NEW FILE########
__FILENAME__ = test_keyio
import json
from jwkest.jwe import JWE

__author__ = 'rohe0002'

from oic.utils.keyio import key_export
from oic.utils.keyio import KeyJar
from oic.utils.keyio import KeyBundle
from oic.utils.keyio import keybundle_from_local_file
from oic.utils.keyio import RSAKey

from jwkest.jws import JWS, NoSuitableSigningKeys, WrongTypeOfKey


RSAKEY = "../oidc_example/op1/certs/mycert.key"
RSA0 = "rsa.key"

JWK0 = {"keys": [
    {'kty': 'RSA', 'e': 'AQAB', 'kid': "abc",
     'n': 'wf-wiusGhA-gleZYQAOPQlNUIucPiqXdPVyieDqQbXXOPBe3nuggtVzeq7pVFH1dZz4dY2Q2LA5DaegvP8kRvoSB_87ds3dy3Rfym_GUSc5B0l1TgEobcyaep8jguRoHto6GWHfCfKqoUYZq4N8vh4LLMQwLR6zi6Jtu82nB5k8'}
]}

JWK1 = {"keys": [
    {"n": "zkpUgEgXICI54blf6iWiD2RbMDCOO1jV0VSff1MFFnujM4othfMsad7H1kRo50YM5S_X9TdvrpdOfpz5aBaKFhT6Ziv0nhtcekq1eRl8mjBlvGKCE5XGk-0LFSDwvqgkJoFYInq7bu0a4JEzKs5AyJY75YlGh879k1Uu2Sv3ZZOunfV1O1Orta-NvS-aG_jN5cstVbCGWE20H0vFVrJKNx0Zf-u-aA-syM4uX7wdWgQ-owoEMHge0GmGgzso2lwOYf_4znanLwEuO3p5aabEaFoKNR4K6GjQcjBcYmDEE4CtfRU9AEmhcD1kleiTB9TjPWkgDmT9MXsGxBHf3AKT5w", "e": "AQAB", "kty": "RSA", "kid": "5-VBFv40P8D4I-7SFz7hMugTbPs"},
    {"k": "YTEyZjBlMDgxMGI4YWU4Y2JjZDFiYTFlZTBjYzljNDU3YWM0ZWNiNzhmNmFlYTNkNTY0NzMzYjE", "kty": "oct"},
    ]}


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_chain_1():
    kc = KeyBundle([{"kty": "oct", "key": "supersecret", "use": "sig"}])
    assert len(kc.get("oct")) == 1
    assert len(kc.get("rsa")) == 0
    assert kc.remote is False
    assert kc.source is None

    kc.update()  # Nothing should happen
    assert len(kc.get("oct")) == 1
    assert len(kc.get("rsa")) == 0
    assert kc.remote is False
    assert kc.source is None


def test_chain_2():
    kc = keybundle_from_local_file(RSAKEY, "rsa", ["ver","sig"])
    assert kc.remote is False
    assert len(kc.get("oct")) == 0
    assert len(kc.get("RSA")) == 2

    key = kc.get("RSA")[0]
    assert isinstance(key, RSAKey)

    kc.update()
    assert kc.remote is False
    assert len(kc.get("oct")) == 0
    assert len(kc.get("RSA")) == 2

    key = kc.get("RSA")[0]
    assert isinstance(key, RSAKey)


# remote testing is tricky
def test1():
    kj = KeyJar()
    url = key_export("http://example.com/keys/", "outbound", "secret",
                     keyjar=kj, sig={"alg": "rsa", "format": ["x509", "jwk"]})

    print url
    assert url == "http://example.com/keys/outbound/jwks"

URL = "https://openidconnect.info/jwk/jwk.json"


def test_keyjar_pairkeys():
    ks = KeyJar()
    ks[""] = KeyBundle([{"kty": "oct", "key": "a1b2c3d4", "use": "sig"},
                        {"kty": "oct", "key": "a1b2c3d4", "use": "ver"}])
    ks["http://www.example.org"] = KeyBundle([
        {"kty": "oct", "key": "e5f6g7h8", "use": "sig"},
        {"kty": "oct", "key": "e5f6g7h8", "use": "ver"}])
    ks["http://www.example.org"].append(
        keybundle_from_local_file(RSAKEY, "rsa", ["ver", "sig"]))

    collection = ks.verify_keys("http://www.example.org")
    assert len(collection) == 3
    assert len([k for k in collection if k.kty == "oct"]) == 2
    assert len([k for k in collection if k.kty == "RSA"]) == 1


def test_keyjar_remove_key():
    ks = KeyJar()
    ks[""] = KeyBundle([{"kty": "oct", "key": "a1b2c3d4", "use": "sig"},
                        {"kty": "oct", "key": "a1b2c3d4", "use": "ver"}])
    ks["http://www.example.org"] = [
        KeyBundle([
            {"kty": "oct", "key": "e5f6g7h8", "use": "sig"},
            {"kty": "oct", "key": "e5f6g7h8", "use": "ver"}]),
        keybundle_from_local_file(RSAKEY, "rsa", ["enc", "dec"])
    ]
    ks["http://www.example.com"] = keybundle_from_local_file(RSA0, "rsa",
                                                             ["enc", "dec"])

    coll = ks["http://www.example.org"]
    # coll is list of KeyBundles
    assert len(coll) == 2
    keys = ks.get_encrypt_key(key_type="RSA", owner="http://www.example.org")
    assert len(keys) == 1
    _key = keys[0]
    ks.remove_key("http://www.example.org", "RSA", _key)

    coll = ks["http://www.example.org"]
    assert len(coll) == 1  # Only one remaining key
    keys = ks.get_encrypt_key(key_type="rsa", owner="http://www.example.org")
    assert len(keys) == 0

    keys = ks.verify_keys("http://www.example.com")
    assert len(keys) == 1
    assert len([k for k in keys if k.kty == "oct"]) == 1

    keys = ks.decrypt_keys("http://www.example.org")
    assert keys == []


def test_local_jwk_file():
    kb = keybundle_from_local_file("file://jwk.json", "jwk", ["ver", "sig"])
    assert len(kb) == 1
    kj = KeyJar()
    kj.issuer_keys[""] = [kb]
    keys = kj.get_signing_key()
    assert len(keys) == 1
    key = keys[0]
    assert isinstance(key, RSAKey)
    assert key.kid == "abc"


def test_signing():
    # Signing is only possible if key is a private RSA key
    kb = keybundle_from_local_file("rsa.key", "rsa", ["ver", "sig"])
    assert len(kb) == 2
    kj = KeyJar()
    kj.issuer_keys[""] = [kb]
    keys = kj.get_signing_key()
    payload = "Please take a moment to register today"
    _jws = JWS(payload, alg="RS512")
    try:
        _jwt = _jws.sign_compact(keys)
        assert True
    except (NoSuitableSigningKeys, WrongTypeOfKey):
        assert False


def test_kid_usage():
    kb = keybundle_from_local_file("file://jwk.json", "jwk", ["ver", "sig"])
    kj = KeyJar()
    kj.issuer_keys["https://example.com"] = [kb]

    _key = kj.get_key_by_kid("abc", "https://example.com")
    assert _key
    assert _key.kid == "abc"


def test_dump_own_keys():
    kb = keybundle_from_local_file("file://jwk.json", "jwk", ["ver", "sig"])
    assert len(kb) == 1
    kj = KeyJar()
    kj.issuer_keys[""] = [kb]
    res = kj.dump_issuer_keys("")

    assert len(res) == 1
    assert res[0] == {
        'use': u'sig',
        'e': u'AQAB',
        'kty': u'RSA',
        'alg': u'RS256',
        'n': u'pKybs0WaHU_y4cHxWbm8Wzj66HtcyFn7Fh3n-99qTXu5yNa30MRYIYfSDwe9JVc1JUoGw41yq2StdGBJ40HxichjE-Yopfu3B58QlgJvToUbWD4gmTDGgMGxQxtv1En2yedaynQ73sDpIK-12JJDY55pvf-PCiSQ9OjxZLiVGKlClDus44_uv2370b9IN2JiEOF-a7JBqaTEYLPpXaoKWDSnJNonr79tL0T7iuJmO1l705oO3Y0TQ-INLY6jnKG_RpsvyvGNnwP9pMvcP1phKsWZ10ofuuhJGRp8IxQL9RfzT87OvF0RBSO1U73h09YP-corWDsnKIi6TbzRpN5YDw',
        'kid': u'abc'}


def test_no_use():
    kb = KeyBundle(JWK0["keys"])
    kj = KeyJar()
    kj.issuer_keys["abcdefgh"] = [kb]
    enc_key = kj.get_encrypt_key("RSA", "abcdefgh")
    assert enc_key != []


def test_enc_hmac():
    payload = {'nonce': 'CYeHPyA6Kmr_jy5HDHXykznu2BpDLm8ngbIJvhBoupI,',
               'sub': 'diana', 'iss': 'https://xenosmilus2.umdc.umu.se:8091/',
               'acr': '2', 'exp': 1401176001, 'iat': 1401096801,
               'aud': ['ApB7TBoKV1tV']}

    _jwe = JWE(json.dumps(payload), alg="A128KW", enc="A128CBC-HS256")

    kb = KeyBundle(JWK1["keys"])
    kj = KeyJar()
    kj.issuer_keys["abcdefgh"] = [kb]
    keys = kj.get_encrypt_key(owner="abcdefgh")

    for key in keys:
        key.deserialize()

    _enctxt = _jwe.encrypt(keys, context="public")
    assert _enctxt

    # and now for decryption

    msg, state = _jwe.decrypt(_enctxt, keys)

    assert json.loads(msg) == payload

if __name__ == "__main__":
    test_enc_hmac()
########NEW FILE########
__FILENAME__ = test_oauth2
#!/usr/bin/env python

__author__ = 'rohe0002'

import time
import base64
import random
import hmac
import hashlib
import json
import urllib

from oic.oauth2 import Grant
from oic.utils import time_util
from oic.oauth2 import Client
from oic.oauth2 import Server
from oic.oauth2 import Token
from oic.oauth2.message import *

from oic.utils.sdb import Crypt
from oic.utils.authn.client import ClientSecretBasic
from oic.utils.authn.client import ClientSecretPost
from oic.utils.authn.client import BearerBody
from oic.utils.authn.client import BearerHeader
from oic.utils.keyio import KeyBundle

from pytest import raises


def _eq(l1, l2):
    return set(l1) == set(l2)

# ----------------- GRANT --------------------

ACC_TOK_RESP = AccessTokenResponse(access_token="2YotnFZFEjr1zCsicMWpAA",
                                   token_type="example",
                                   refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
                                   example_parameter="example_value",
                                   scope=["inner", "outer"])


def test_grant():
    grant = Grant()
    assert grant
    assert grant.exp_in == 600

    grant = Grant(60)
    assert grant.exp_in == 60


def test_grant_from_code():
    ar = AuthorizationResponse(code="code", state="state")

    grant = Grant.from_code(ar)

    assert grant
    assert grant.code == "code"


def test_grant_add_code():
    ar = AuthorizationResponse(code="code", state="state")

    grant = Grant()
    grant.add_code(ar)
    assert grant
    assert grant.code == "code"


def test_grant_update():
    ar = AuthorizationResponse(code="code", state="state")

    grant = Grant()
    grant.update(ar)

    assert grant
    assert grant.code == "code"


def test_grant_set():
    ar = AuthorizationResponse(code="code", state="state")

    grant = Grant.from_code(ar)

    assert grant
    assert grant.code == "code"


def test_grant_add_token():
    grant = Grant()
    grant.update(ACC_TOK_RESP)

    assert len(grant.tokens) == 1
    token = grant.tokens[0]

    assert token.access_token == "2YotnFZFEjr1zCsicMWpAA"
    assert token.token_type == "example"
    assert token.refresh_token == "tGzv3JOkF0XG5Qx2TlKWIA"


def test_grant_set_3():
    err = ErrorResponse(error="invalid_request")
    grant = Grant()
    grant.update(err)

    assert len(grant.tokens) == 0


# ----------------- CLIENT --------------------
class TestOAuthClient():
    def setup_class(self):
        self.client = Client("1")
        self.client.redirect_uris = ["http://example.com/redirect"]

    def test_areq_1(self):
        ar = self.client.construct_AuthorizationRequest(
            request_args={"response_type": ["code"]})

        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert ar["client_id"] == "1"
        assert "state" not in ar
        assert "scope" not in ar

    def test_areq_2(self):
        self.client.state = "abc"
        req_args = {"response_type": ["code"], "scope": ["foo", "bar"]}
        ar = self.client.construct_AuthorizationRequest(request_args=req_args)

        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert ar["client_id"] == "1"
        assert ar["state"] == "abc"
        assert ar["scope"] == ["foo", "bar"]

    def test_areq_replace_default_state(self):
        self.client.state = "efg"
        req_args = {"response_type": ["code"], "scope": ["foo", "bar"]}
        ar = self.client.construct_AuthorizationRequest(request_args=req_args)

        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert ar["client_id"] == "1"
        assert ar["state"] == "efg"
        assert ar["scope"] == ["foo", "bar"]

    def test_parse_authz_resp_url(self):
        url = "https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=ghi"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=url, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "ghi"

        assert self.client.grant["ghi"]
        assert self.client.grant["ghi"].code == aresp["code"]
        assert self.client.grant["ghi"].grant_expiration_time

    def test_parse_authz_resp_query(self):
        query = "code=SplxlOBeZQQYbYS6WxSbIA&state=hij"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "hij"

        print self.client.grant.keys()
        assert self.client.grant["hij"]
        assert self.client.grant["hij"].code == aresp["code"]
        assert self.client.grant["hij"].grant_expiration_time

    def test_parse_authz_resp_query_multi_scope(self):
        query = "code=SplxlOBeZQQYbYS6WxAAAA&state=klm"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxAAAA"
        assert aresp["state"] == "klm"

        assert self.client.grant["klm"]
        assert self.client.grant["klm"].code == aresp["code"]
        assert self.client.grant["klm"].grant_expiration_time

        assert _eq(self.client.grant.keys(), ['ghi', 'hij', 'klm'])

    def test_parse_authz_resp_query_unknown_parameter(self):
        query = "code=SplxlOBeZQQYbYS6WxSbIA&state=xyz&foo=bar"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "xyz"

        print aresp.__dict__.keys()
        assert "foo" not in aresp.__dict__

        assert self.client.grant["xyz"]
        assert self.client.grant["xyz"].code == aresp["code"]
        assert self.client.grant["xyz"].grant_expiration_time

    def test_get_access_token_request_1(self):
        self.client.reset()
        self.client.redirect_uris = ["http://client.example.com/authz"]
        grant = Grant()
        grant.code = "AbCdEf"
        grant.grant_expiration_time = time_util.utc_time_sans_frac() + 30
        self.client.grant = {"stat": grant}

        # scope is default=""
        atr = self.client.construct_AccessTokenRequest(state="stat")

        assert atr["grant_type"] == "authorization_code"
        assert atr["code"] == "AbCdEf"
        assert atr["redirect_uri"] == "http://client.example.com/authz"

    def test_construct_access_token_request_fail(self):
        raises(Exception,
               'self.client.construct_AccessTokenRequest(state="unknown")')

    def test_get_access_token_request_override(self):
        self.client.reset()
        self.client.redirect_uris = ["http://client.example.com/authz"]
        grant = Grant()
        grant.code = "AbCdEf"
        grant.grant_expiration_time = time_util.utc_time_sans_frac() + 30
        self.client.grant = {"xyz": grant}

        atr = self.client.construct_AccessTokenRequest(state="xyz")

        assert atr["grant_type"] == "authorization_code"
        assert atr["code"] == "AbCdEf"
        assert atr["redirect_uri"] == "http://client.example.com/authz"

    def test_construct_request_no_input(self):
        self.client.response_type = ["code"]
        atr = self.client.construct_AuthorizationRequest()

        print atr
        assert atr["redirect_uri"] == "http://client.example.com/authz"
        assert atr["response_type"] == ["code"]
        assert atr["client_id"] == "1"

    def test_parse_access_token_response(self):
        jso = """{
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }"""

        self.client.parse_response(AccessTokenResponse,
                                   info="".join([
                                       x.strip() for x in jso.split("\n")]))

        assert self.client.grant
        _grant = self.client.grant[""]
        assert len(_grant.tokens) == 1
        token = _grant.tokens[0]
        assert token.access_token == "2YotnFZFEjr1zCsicMWpAA"
        assert token.token_type == "example"
        assert token.expires_in == 3600
        assert token.refresh_token == "tGzv3JOkF0XG5Qx2TlKWIA"

        # I'm dropping parameters I don't recognize
        assert "example_parameter" not in self.client.__dict__

        #assert self.client.access_token_is_valid()

    def test_get_access_token_refresh_1(self):
        print self.client.grant

        self.client.grant[""].grant_expiration_time = time.time() + 60
        self.client.grant[""].code = "access_code"
        token = self.client.grant[""].tokens[0]
        print token
        # Uses refresh_token from previous response
        atr = self.client.construct_RefreshAccessTokenRequest(token=token)

        print atr.to_dict()
        assert atr.type() == "RefreshAccessTokenRequest"
        assert atr["grant_type"] == "refresh_token"
        assert atr["refresh_token"] == "tGzv3JOkF0XG5Qx2TlKWIA"

    def test_get_access_token_refresh_2(self):
        self.client.grant["foo"] = Grant()
        _get = time_util.utc_time_sans_frac() + 60
        self.client.grant["foo"].grant_expiration_time = _get
        self.client.grant["foo"].code = "access_code"

        print self.client.grant["foo"]
        resp = AccessTokenResponse(refresh_token="refresh_with_me",
                                   access_token="access")

        self.client.grant["foo"].tokens.append(Token(resp))
        # Uses refresh_token from previous response
        atr = self.client.construct_RefreshAccessTokenRequest(state="foo")

        assert atr.type() == "RefreshAccessTokenRequest"
        assert atr["grant_type"] == "refresh_token"
        assert atr["refresh_token"] == "refresh_with_me"

    def test_parse_authz_err_response(self):
        ruri = "https://client.example.com/cb?error=access_denied&amp;state=xyz"

        resp = self.client.parse_response(AuthorizationResponse,
                                          info=ruri, sformat="urlencoded")

        print type(resp), resp
        assert resp.type() == "AuthorizationErrorResponse"

        assert resp["error"] == "access_denied"
        assert resp["state"] == "xyz"

    def test_return_non_existant_grant(self):
        assert self.client.grant_from_state("123456abcdef") is None

    def test_construct_request_with_extra_args(self):
        print self.client.__dict__.items()
        req = self.client.construct_AccessTokenRequest(
            state="foo", extra_args={"foo": "bar"})

        assert req
        print req.keys()
        assert _eq(req.keys(), ['code', 'grant_type', 'client_id',
                                'redirect_uri', 'foo'])
        assert req["foo"] == "bar"

    def test_construct_TokenRevocationRequest(self):
        req = self.client.construct_TokenRevocationRequest(state="foo")

        assert req
        print req.keys()
        assert _eq(req.keys(), ['token'])
        assert req["token"] == "access"

    def test_request_info_simple(self):
        self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(AuthorizationRequest)

        # default == "POST"
        assert uri == 'https://example.com/authz'
        assert body == "redirect_uri=http%3A%2F%2Fclient.example.com%2Fauthz&response_type=code&client_id=1"
        assert h_args == {'headers': {'content-type':
                                          'application/x-www-form-urlencoded'}}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(AuthorizationRequest,
                                                          method="GET")

        assert uri == 'https://example.com/authz?redirect_uri=http%3A%2F%2Fclient.example.com%2Fauthz&response_type=code&client_id=1'
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get_with_req_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET", request_args={"state": "init"})

        print uri
        assert uri == 'https://example.com/authz?state=init&redirect_uri=http%3A%2F%2Fclient.example.com%2Fauthz&response_type=code&client_id=1'
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get_with_extra_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET", extra_args={"rock": "little"})

        print uri
        assert uri == 'https://example.com/authz?redirect_uri=http%3A%2F%2Fclient.example.com%2Fauthz&response_type=code&client_id=1&rock=little'
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_with_req_and_extra_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest,
            method="GET",
            request_args={"state": "init"},
            extra_args={"rock": "little"})

        print uri
        assert uri == 'https://example.com/authz?state=init&redirect_uri=http%3A%2F%2Fclient.example.com%2Fauthz&response_type=code&client_id=1&rock=little'
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"


def test_get_authorization_request():
    client = Client()
    client.redirect_uris = ["https://www.example.com/authz"]
    client.client_id = "a1b2c3"
    args = {"response_type": ["code"]}
    ar = client.construct_AuthorizationRequest(request_args=args)
    assert ar["client_id"] == 'a1b2c3'
    assert ar["redirect_uri"] == 'https://www.example.com/authz'
    assert ar["response_type"] == ['code']

    client = Client()
    client.client_id = "a1b2c3"
    args = {"response_type": ["code"],
            "redirect_uri": "https://www.example.com/authz"}
    ar = client.construct_AuthorizationRequest(request_args=args)
    assert ar["client_id"] == 'a1b2c3'
    assert ar["redirect_uri"] == 'https://www.example.com/authz'
    assert ar["response_type"] == ['code']


def test_get_access_token_request():
    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant(1)
    grant.add_code(resp)

    client = Client()
    client.grant["openid"] = grant
    time.sleep(2)
    try:
        client.construct_AccessTokenRequest(state="openid")
    except Exception, err:
        assert err.__class__.__name__ == "GrantExpired"


def test_parse_access_token_response():
    client = Client()

    at = AccessTokenResponse(access_token="SlAV32hkKG", token_type="Bearer",
                             refresh_token="8xLOxBtZp8", expire_in=3600)

    atj = at.to_json()

    ATR = AccessTokenResponse
    atr = client.parse_response(ATR, info=atj)

    assert _eq(atr.keys(), ['access_token', 'token_type', u'expire_in',
                            'refresh_token'])

    uec = at.to_urlencoded()
    raises(ValueError, 'client.parse_response(ATR, info=uec)')

    uatr = client.parse_response(ATR, info=uec, sformat="urlencoded")
    assert _eq(uatr.keys(), ['access_token', 'token_type', 'expire_in',
                             'refresh_token'])

    huec = "%s?%s" % ("https://example.com/token", uec)

    uatr = client.parse_response(ATR, info=huec, sformat="urlencoded")
    assert _eq(uatr.keys(), ['access_token', 'token_type', 'expire_in',
                             'refresh_token'])

    err = ErrorResponse(error="invalid_request",
                        error_description="Something was missing",
                        error_uri="http://example.com/error_message.html")

    jerr = err.to_json()
    uerr = err.to_urlencoded()

    _ = client.parse_response(ATR, info=jerr)
    _ = client.parse_response(ATR, info=uerr, sformat="urlencoded")

    raises(Exception,
           'client.parse_response(ATR, info=jerr, sformat="urlencoded")')

    raises(Exception, "client.parse_response(ATR, info=uerr)")

    raises(Exception,
           'client.parse_response(ATR, info=jerr, sformat="focus")')


def test_parse_access_token_response_missing_attribute():
    at = AccessTokenResponse(access_token="SlAV32hkKG",
                             token_type="Bearer", refresh_token="8xLOxBtZp8",
                             expire_in=3600)

    atdict = at.to_dict()
    del atdict["access_token"]
    atj = json.dumps(atdict)
    print atj
    client = Client()
    ATR = AccessTokenResponse

    try:
        client.parse_response(ATR, info=atj)
    except Exception, err:
        assert err.__class__.__name__ == "MissingRequiredAttribute"

    atuec = urllib.urlencode(atdict)

    try:
        client.parse_response(ATR, info=atuec, sformat='urlencoded')
    except Exception, err:
        assert err.__class__.__name__ == "MissingRequiredAttribute"


def test_crypt():
    crypt = Crypt("4-amino-1H-pyrimidine-2-one")
    ctext = crypt.encrypt("Cytosine")
    plain = crypt.decrypt(ctext)
    print plain
    assert plain == 'Cytosine        '

    ctext = crypt.encrypt("cytidinetriphosp")
    plain = crypt.decrypt(ctext)

    assert plain == 'cytidinetriphosp'


def test_crypt2():
    db = {}
    csum = hmac.new("secret", digestmod=hashlib.sha224)
    csum.update("%s" % time.time())
    csum.update("%f" % random.random())
    txt = csum.digest()  # 28 bytes long, 224 bits
    print len(txt)
    db[txt] = "foobar"
    txt = "%saces" % txt  # another 4 bytes
    #print len(txt), txt
    crypt = Crypt("4-amino-1H-pyrimidine-2-one")
    ctext = crypt.encrypt(txt)
    onthewire = base64.b64encode(ctext)
    #print onthewire
    plain = crypt.decrypt(base64.b64decode(onthewire))
    #print len(plain), plain
    #assert plain == txt
    assert plain.endswith("aces")
    assert db[plain[:-4]] == "foobar"


def test_grant_init():
    grant = Grant()
    assert grant.grant_expiration_time == 0

    grant = Grant()
    assert grant.grant_expiration_time == 0


def test_grant_resp():
    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    assert grant.code == "code"
    assert grant.grant_expiration_time != 0

    grant = Grant(1)
    grant.add_code(resp)
    time.sleep(2)

    assert grant.is_valid() is False

    grant = Grant.from_code(resp)
    assert grant.code == "code"
    assert grant.grant_expiration_time != 0


def test_grant_access_token_1():
    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    atr = AccessTokenResponse(access_token="2YotnFZFEjr1zCsicMWpAA",
                              token_type="example", expires_in=1,
                              refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
                              example_parameter="example_value",
                              xscope=["inner", "outer"])

    token = Token(atr)
    grant.tokens.append(token)

    print grant.keys()
    assert _eq(grant.keys(), ['tokens', 'id_token', 'code', 'exp_in', 'seed',
                              'grant_expiration_time'])
    print token.keys()
    assert _eq(token.keys(), ['token_expiration_time', 'access_token',
                              'expires_in', 'example_parameter', 'token_type',
                              'xscope', 'refresh_token', 'scope',
                              'replaced'])

    assert token.access_token == "2YotnFZFEjr1zCsicMWpAA"
    assert token.token_type == "example"
    assert token.refresh_token == "tGzv3JOkF0XG5Qx2TlKWIA"
    assert token.example_parameter == "example_value"
    assert token.xscope == ["inner", "outer"]
    assert token.token_expiration_time != 0

    time.sleep(2)
    assert token.is_valid() is False


def test_grant_access_token_2():
    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    atr = AccessTokenResponse(access_token="2YotnFZFEjr1zCsicMWpAA",
                              token_type="example",
                              refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
                              example_parameter="example_value",
                              scope=["inner", "outer"])

    grant.add_token(atr)

    assert len(grant.tokens) == 1
    time.sleep(2)
    token = grant.tokens[0]
    assert token.is_valid() is True

    assert "%s" % grant != ""


def test_client_get_grant():
    cli = Client()

    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    cli.grant["state"] = grant

    gr1 = cli.grant_from_state("state")

    assert gr1.code == "code"


def test_client_parse_args():
    cli = Client()

    args = {
        "response_type": "",
        "client_id": "client_id",
        "redirect_uri": "http://example.com/authz",
        "scope": "scope",
        "state": "state",
    }

    ar_args = cli._parse_args(AuthorizationRequest, **args)

    assert _eq(ar_args.keys(), ['scope', 'state', 'redirect_uri',
                                'response_type', 'client_id'])


def test_client_parse_extra_args():
    cli = Client()

    args = {
        "response_type": "",
        "client_id": "client_id",
        "redirect_uri": "http://example.com/authz",
        "scope": "scope",
        "state": "state",
        "extra_session": "home"
    }
    ar_args = cli._parse_args(AuthorizationRequest, **args)

    assert _eq(ar_args.keys(), ['state', 'redirect_uri', 'response_type',
                                'client_id', 'scope', 'extra_session'])


def test_client_endpoint():
    cli = Client()
    cli.authorization_endpoint = "https://example.org/oauth2/as"
    cli.token_endpoint = "https://example.org/oauth2/token"
    cli.token_revocation_endpoint = "https://example.org/oauth2/token_rev"

    ae = cli._endpoint("authorization_endpoint")
    assert ae == "https://example.org/oauth2/as"
    te = cli._endpoint("token_endpoint")
    assert te == "https://example.org/oauth2/token"
    tre = cli._endpoint("token_revocation_endpoint")
    assert tre == "https://example.org/oauth2/token_rev"

    ae = cli._endpoint("authorization_endpoint", **{
        "authorization_endpoint": "https://example.com/as"})
    assert ae == "https://example.com/as"

    cli.token_endpoint = ""
    raises(Exception, 'cli._endpoint("token_endpoint")')
    raises(Exception, 'cli._endpoint("foo_endpoint")')


def test_server_parse_parse_authorization_request():
    srv = Server()
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold")

    uencq = ar.to_urlencoded()

    areq = srv.parse_authorization_request(query=uencq)

    assert areq.type() == "AuthorizationRequest"
    assert areq["response_type"] == ["code"]
    assert areq["client_id"] == "foobar"
    assert areq["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert areq["state"] == "cold"

    urluenc = "%s?%s" % ("https://example.com/authz", uencq)

    areq = srv.parse_authorization_request(url=urluenc)

    assert areq.type() == "AuthorizationRequest"
    assert areq["response_type"] == ["code"]
    assert areq["client_id"] == "foobar"
    assert areq["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert areq["state"] == "cold"


def test_server_parse_jwt_request():
    srv = Server()
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold")

    srv.keyjar["foobar"] = KeyBundle([
        {"kty": "oct", "key": "A1B2C3D4", "use": "ver"},
        {"kty": "oct", "key": "A1B2C3D4", "use": "sig"}])
    srv.keyjar[""] = KeyBundle([
        {"kty": "oct", "key": "A1B2C3D4", "use": "ver"},
        {"kty": "oct", "key": "A1B2C3D4", "use": "sig"}])

    keys = srv.keyjar.get_signing_key(owner="foobar")
    _jwt = ar.to_jwt(key=keys, algorithm="HS256")

    req = srv.parse_jwt_request(txt=_jwt)

    assert req.type() == "AuthorizationRequest"
    assert req["response_type"] == ["code"]
    assert req["client_id"] == "foobar"
    assert req["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert req["state"] == "cold"


def test_server_parse_token_request():
    atr = AccessTokenRequest(
        grant_type="authorization_code", code="SplxlOBeZQQYbYS6WxSbIA",
        redirect_uri="https://client.example.com/cb", extra="foo")

    uenc = atr.to_urlencoded()

    srv = Server()
    tr = srv.parse_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "AccessTokenRequest"
    assert _eq(tr.keys(), ['code', 'redirect_uri', 'grant_type', 'extra'])

    assert tr["grant_type"] == "authorization_code"
    assert tr["code"] == "SplxlOBeZQQYbYS6WxSbIA"

    tr = srv.parse_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "AccessTokenRequest"
    assert _eq(tr.keys(), ['code', 'grant_type', 'redirect_uri', 'extra'])

    assert tr["extra"] == "foo"


def test_server_parse_refresh_token_request():
    ratr = RefreshAccessTokenRequest(refresh_token="ababababab",
                                     client_id="Client_id")

    uenc = ratr.to_urlencoded()

    srv = Server()
    tr = srv.parse_refresh_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "RefreshAccessTokenRequest"
    assert tr["refresh_token"] == "ababababab"
    assert tr["client_id"] == "Client_id"


def test_client_secret_post():
    client = Client("A")
    client.client_secret = "boarding pass"

    cis = AccessTokenRequest(code="foo", redirect_uri="http://example.com")

    csp = ClientSecretPost(client)
    http_args = csp.construct(cis)

    print cis
    assert cis["client_id"] == "A"
    assert cis["client_secret"] == "boarding pass"
    print http_args
    assert http_args is None

    cis = AccessTokenRequest(code="foo", redirect_uri="http://example.com")

    request_args = {}
    http_args = csp.construct(cis, request_args,
                              http_args={"client_secret": "another"})

    print cis
    assert cis["client_id"] == "A"
    assert cis["client_secret"] == "another"
    print http_args
    assert http_args == {}


def test_client_secret_basic():
    client = Client("A")
    client.client_secret = "boarding pass"

    cis = AccessTokenRequest(code="foo", redirect_uri="http://example.com")

    csb = ClientSecretBasic(client)
    http_args = csb.construct(cis)

    assert http_args == {"auth": ("A", "boarding pass")}


def test_bearer_header():
    client = Client("A")
    client.client_secret = "boarding pass"

    request_args = {"access_token": "Sesame"}

    cis = ResourceRequest()

    bh = BearerHeader(client)
    http_args = bh.construct(cis, request_args)

    print cis
    print http_args
    assert http_args == {"headers": {"Authorization": "Bearer Sesame"}}


def test_bearer_header_with_http_args():
    client = Client("A")
    client.client_secret = "boarding pass"

    request_args = {"access_token": "Sesame"}

    cis = ResourceRequest()

    bh = BearerHeader(client)
    http_args = bh.construct(cis, request_args, http_args={"foo": "bar"})

    print cis
    print http_args
    assert _eq(http_args.keys(), ["foo", "headers"])
    assert http_args["headers"] == {"Authorization": "Bearer Sesame"}

    # -----------------

    request_args = {"access_token": "Sesame"}

    bh = BearerHeader(client)
    http_args = bh.construct(cis, request_args,
                             http_args={"headers": {"x-foo": "bar"}})

    print cis
    print http_args
    assert _eq(http_args.keys(), ["headers"])
    assert _eq(http_args["headers"].keys(), ["Authorization", "x-foo"])
    assert http_args["headers"]["Authorization"] == "Bearer Sesame"


def test_bearer_header_2():
    client = Client("A")
    client.client_secret = "boarding pass"

    bh = BearerHeader(client)
    cis = ResourceRequest(access_token="Sesame")

    http_args = bh.construct(cis)

    print cis
    assert "access_token" not in cis
    print http_args
    assert http_args == {"headers": {"Authorization": "Bearer Sesame"}}


def test_bearer_header_3():
    client = Client("A")
    client.client_secret = "boarding pass"
    client.state = "state"

    resp1 = AuthorizationResponse(code="auth_grant", state="state")
    client.parse_response(AuthorizationResponse, resp1.to_urlencoded(),
                          "urlencoded")
    resp2 = AccessTokenResponse(access_token="token1",
                                token_type="Bearer", expires_in=0,
                                state="state")
    client.parse_response(AccessTokenResponse, resp2.to_urlencoded(),
                          "urlencoded")

    cis = ResourceRequest()

    http_args = BearerHeader(client).construct(cis)

    print cis
    assert "access_token" not in cis
    print http_args
    assert http_args == {"headers": {"Authorization": "Bearer token1"}}


def test_bearer_body():
    client = Client("A")
    client.client_secret = "boarding pass"

    request_args = {"access_token": "Sesame"}

    cis = ResourceRequest()
    http_args = BearerBody(client).construct(cis, request_args)
    assert cis["access_token"] == "Sesame"
    print http_args
    assert http_args is None

    # ----------
    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    atr = AccessTokenResponse(access_token="2YotnFZFEjr1zCsicMWpAA",
                              token_type="example",
                              refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
                              example_parameter="example_value",
                              scope=["inner", "outer"])

    grant.add_token(atr)
    client.grant["state"] = grant

    cis = ResourceRequest()
    http_args = BearerBody(client).construct(cis, {}, state="state",
                                             scope="inner")
    assert cis["access_token"] == "2YotnFZFEjr1zCsicMWpAA"
    print http_args
    assert http_args is None


def test_bearer_body_get_token():
    client = Client("A")
    client.client_secret = "boarding pass"
    client.state = "state"

    resp1 = AuthorizationResponse(code="auth_grant", state="state")
    client.parse_response(AuthorizationResponse, resp1.to_urlencoded(),
                          "urlencoded")
    resp2 = AccessTokenResponse(access_token="token1",
                                token_type="Bearer", expires_in=0,
                                state="state")
    client.parse_response(AccessTokenResponse, resp2.to_urlencoded(),
                          "urlencoded")

    cis = ResourceRequest()

    _ = BearerBody(client).construct(cis)

    assert "access_token" in cis
    assert cis["access_token"] == "token1"

if __name__ == "__main__":
    test_client_secret_basic()
########NEW FILE########
__FILENAME__ = test_oauth2_consumer
__author__ = 'rohe0002'
import urllib

from pytest import raises

from oic.oauth2 import rndstr

from oic.oauth2.consumer import Consumer
from oic.oauth2.consumer import stateID
from oic.oauth2.consumer import factory

from oic.utils.http_util import make_cookie
from oic.oauth2.message import MissingRequiredAttribute
from oic.oauth2.message import AuthorizationResponse
from oic.oauth2.message import AuthorizationErrorResponse
from oic.oauth2.message import AccessTokenResponse
from oic.oauth2.message import TokenErrorResponse

from oic.oauth2.consumer import AuthzError

#from oic.oauth2.message import

# client_id=None, ca_certs=None,grant_expire_in=600, client_timeout=0,
# jwt_keys=None
CLIENT_CONFIG = {
    "client_id": "number5",
    "ca_certs": "/usr/local/etc/oic/ca_certs.txt",
}

CONSUMER_CONFIG = {
    "authz_page": "/authz",
    "flow_type": "code",
    #"password": args.passwd,
    "scope": ["openid"],
    "response_type": "code",
    #"expire_in": 600,
}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://connect-op.heroku.com",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    #"userinfo_endpoint":"http://localhost:8088/user_info",
    #"check_id_endpoint":"http://localhost:8088/id_token",
    #"registration_endpoint":"https://connect-op.heroku.com/connect/client",
    #"scopes_supported":["openid","profile","email","address","PPID"],
    "flows_supported": ["code", "token", "code token"],
    #"identifiers_supported":["public","ppid"],
    #"x509_url":"https://connect-op.heroku.com/cert.pem"
}

BASE_ENVIRON = {'SERVER_PROTOCOL': 'HTTP/1.1',
                'REQUEST_METHOD': 'GET',
                'QUERY_STRING': '',
                'HTTP_CONNECTION': 'keep-alive',
                'REMOTE_ADDR': '127.0.0.1',
                'wsgi.url_scheme': 'http',
                'SERVER_PORT': '8087',
                'PATH_INFO': '/register',
                'HTTP_HOST': 'localhost:8087',
                'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',

                'HTTP_ACCEPT_LANGUAGE': 'sv-se',
                'CONTENT_TYPE': 'text/plain',
                'REMOTE_HOST': '1.0.0.127.in-addr.arpa',
                'HTTP_ACCEPT_ENCODING': 'gzip, deflate',
                'COMMAND_MODE': 'unix2003'}


def test_stateID():
    seed = rndstr()
    sid0 = stateID("http://example.com/home", seed)
    sid1 = stateID("http://example.com/home", seed)
    assert sid0
    assert sid1
    assert sid0 != sid1


def test_init_consumer():
    cons = Consumer({}, client_config=CLIENT_CONFIG, server_info=SERVER_INFO,
                        **CONSUMER_CONFIG)
    assert cons

    cons._backup("123456")

    assert "123456" in cons.sdb

    cons = Consumer({}, client_config=CLIENT_CONFIG, **CONSUMER_CONFIG)
    assert cons.authorization_endpoint is None

    cons = Consumer({}, **CONSUMER_CONFIG)
    assert cons.authorization_endpoint is None


def test_factory():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)

    sid = stateID("https://example.org/", cons.seed)
    cons.state = sid
    cons._backup(sid)
    cons.sdb["seed:%s" % cons.seed] = sid

    kaka = make_cookie(CLIENT_CONFIG["client_id"], cons.state, cons.seed,
                       expire=360, path="/")

    _oac = factory(kaka[1], _session_db, CLIENT_CONFIG["client_id"],
                   client_config=CLIENT_CONFIG, server_info=SERVER_INFO,
                   **CONSUMER_CONFIG)

    assert _oac
    assert _oac.state == cons.state
    assert _oac.seed == cons.seed


def test_consumer_begin():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)

    loc = cons.begin("http://localhost:8087",
                     "http://localhost:8088/authorization")

    # state is dynamic
    params = {"scope": "openid",
              "state": cons.state,
              "redirect_uri": "http://localhost:8087/authz",
              "response_type": "code",
              "client_id": "number5"}

    url = "http://localhost:8088/authorization?%s" % urllib.urlencode(params)

    assert loc == url


def test_consumer_handle_authorization_response():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    _ = cons.begin("http://localhost:8087",
                   "http://localhost:8088/authorization")

    atr = AuthorizationResponse(code="SplxlOBeZQQYbYS6WxSbIA",
                                state=cons.state)

    res = cons.handle_authorization_response(query=atr.to_urlencoded())

    assert res.type() == "AuthorizationResponse"
    print cons.grant[cons.state]
    grant = cons.grant[cons.state]
    assert grant.code == "SplxlOBeZQQYbYS6WxSbIA"


def test_consumer_parse_authz_exception():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    _ = cons.begin("http://localhost:8087",
                   "http://localhost:8088/authorization")

    atr = AuthorizationResponse(code="SplxlOBeZQQYbYS6WxSbIA",
                                state=cons.state)

    adict = atr.to_dict()
    del adict["code"]
    QUERY_STRING = urllib.urlencode(adict)

    raises(MissingRequiredAttribute,
           "cons.handle_authorization_response(query=QUERY_STRING)")


def test_consumer_parse_authz_error():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    _ = cons.begin("http://localhost:8087",
                   "http://localhost:8088/authorization")

    atr = AuthorizationErrorResponse(error="access_denied", state=cons.state)

    QUERY_STRING = atr.to_urlencoded()

    raises(AuthzError,
           "cons.handle_authorization_response(query=QUERY_STRING)")


def test_consumer_parse_access_token():
    # implicit flow test
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True
    environ = BASE_ENVIRON

    cons.response_type = ["token"]
    _ = cons.begin("http://localhost:8087",
                   "http://localhost:8088/authorization")

    atr = AccessTokenResponse(access_token="2YotnFZFEjr1zCsicMWpAA",
                              token_type="example",
                              refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
                              example_parameter="example_value",
                              state=cons.state)

    res = cons.handle_authorization_response(query=atr.to_urlencoded())

    assert res.type() == "AccessTokenResponse"
    print cons.grant[cons.state]
    grant = cons.grant[cons.state]
    assert len(grant.tokens) == 1
    token = grant.tokens[0]
    assert token.access_token == "2YotnFZFEjr1zCsicMWpAA"


def test_consumer_parse_authz_error_2():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    _ = cons.begin("http://localhost:8087",
                   "http://localhost:8088/authorization")

    atr = TokenErrorResponse(error="invalid_client")
    QUERY_STRING = atr.to_urlencoded()

    raises(AuthzError,
           "cons.handle_authorization_response(query=QUERY_STRING)")


def test_consumer_client_auth_info():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.client_secret = "secret0"
    ra, ha, extra = cons.client_auth_info()
    assert ra == {'client_secret': 'secret0', 'client_id': 'number5'}
    assert ha == {}
    assert extra == {'auth_method': 'bearer_body'}


def test_consumer_client_get_access_token_reques():
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.client_secret = "secret0"
    cons.state = "state"
    cons.redirect_uris = ["https://www.example.com/oic/cb"]

    resp1 = AuthorizationResponse(code="auth_grant", state="state")
    cons.parse_response(AuthorizationResponse, resp1.to_urlencoded(),
                        "urlencoded")
    resp2 = AccessTokenResponse(access_token="token1",
                                token_type="Bearer", expires_in=0,
                                state="state")
    cons.parse_response(AccessTokenResponse, resp2.to_urlencoded(),
                        "urlencoded")

    url, body, http_args = cons.get_access_token_request()
    assert url == "http://localhost:8088/token"
    print body
    assert body == ("code=auth_grant&client_secret=secret0&"
                    "grant_type=authorization_code&client_id=number5&"
                    "redirect_uri=https%3A%2F%2Fwww.example.com%2Foic%2Fcb")
    assert http_args == {'headers': {
        'content-type': 'application/x-www-form-urlencoded'}}


########NEW FILE########
__FILENAME__ = test_oauth2_message
__author__ = 'rohe0002'

from oic.oauth2.message import *
from jwkest.jwk import SYMKey

from pytest import raises


class Dummy_Message(Message):
    c_param = {
        "req_str": SINGLE_REQUIRED_STRING,
        "opt_str": SINGLE_OPTIONAL_STRING,
        "opt_int": SINGLE_OPTIONAL_INT,
        "opt_str_list": OPTIONAL_LIST_OF_STRINGS,
        "req_str_list": REQUIRED_LIST_OF_STRINGS,
        "opt_json": SINGLE_OPTIONAL_JSON}


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_authz_req_urlencoded_1():
    ar = AuthorizationRequest(response_type=["code"], client_id="foobar")
    ue = ar.to_urlencoded()
    print ue
    assert ue == "response_type=code&client_id=foobar"


def test_authz_req_urlencoded_2():
    ar = AuthorizationRequest(response_type=["code"], client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold")

    ue = ar.to_urlencoded()
    print ue
    assert ue == "state=cold&redirect_uri=http%3A%2F%2Ffoobar.example.com%2Foaclient&response_type=code&client_id=foobar"



def test_authz_req_urlencoded_3():
    ar = AuthorizationRequest(response_type=["token"],
                              client_id="s6BhdRkqt3",
                              redirect_uri="https://client.example.com/cb",
                              state="xyz")

    ue = ar.to_urlencoded()
    print ue
    assert ue == "state=xyz&redirect_uri=https%3A%2F%2Fclient.example.com%2Fcb&response_type=token&client_id=s6BhdRkqt3"


def test_authz_req_urlencoded_4():
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar")

    urlencoded = ar.to_urlencoded()
    ar2 = AuthorizationRequest().deserialize(urlencoded, "urlencoded")

    print ar
    print ar2

    for attr in ar.c_param.keys():
        assert getattr(ar, attr) == getattr(ar2, attr)


def test_authz_req_urlencoded_5():
    ar = AuthorizationRequest(response_type=["code"], client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              scope=["foo", "bar"], state="cold")

    ue = ar.to_urlencoded()
    print ue
    assert ue == "scope=foo+bar&state=cold&redirect_uri=http%3A%2F%2Ffoobar.example.com%2Foaclient&response_type=code&client_id=foobar"


def test_authz_req_urlencoded_6():
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              scope=["foo", "bar"], state="cold")

    urlencoded = ar.to_urlencoded()
    ar2 = AuthorizationRequest().deserialize(urlencoded, "urlencoded")

    assert ar == ar2


def test_authz_req_urlencoded_7():
    ar = AuthorizationRequest(response_type=["code"])
    raises(MissingRequiredAttribute, ar.verify)


def test_authz_req_urlencoded_8():
    args = {"response_type": [10], "client_id": "foobar",
            "redirect_uri": "http://foobar.example.com/oaclient",
            "scope": ["foo", "bar"], "state": "cold"}

    raises(Exception, 'AuthorizationRequest(**args)')


def test_authz_req_urlencoded_9():
    txt = "scope=foo+bar&state=-11&redirect_uri=http%3A%2F%2Ffoobar.example.com%2Foaclient&response_type=code&client_id=foobar"

    ar = AuthorizationRequest().deserialize(txt, "urlencoded")
    print ar
    assert ar["state"] == "-11"


def test_authz_req_urlencoded_10():
    txt = "scope=openid&state=id-6a3fc96caa7fd5cb1c7d00ed66937134&redirect_uri=http%3A%2F%2Flocalhost%3A8087authz&response_type=code&client_id=a1b2c3"

    ar = AuthorizationRequest().deserialize(txt, "urlencoded")
    print ar
    assert ar["scope"] == ["openid"]
    assert ar["response_type"] == ["code"]


def test_authz_req_json_1():
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar")

    js = ar.serialize(method="json")
    print js
    assert js == '{"response_type": "code", "client_id": "foobar"}'


def test_authz_req_json_2():
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold")

    ue = ar.serialize(method="json")
    print ue
    assert ue == '{"state": "cold", "redirect_uri": "http://foobar.example.com/oaclient", "response_type": "code", "client_id": "foobar"}'


def test_authz_req_urlencoded_3():
    ar = AuthorizationRequest(response_type=["token"],
                              client_id="s6BhdRkqt3",
                              redirect_uri="https://client.example.com/cb",
                              state="xyz")

    ue = ar.serialize(method="json")
    print ue
    assert ue == '{"state": "xyz", "redirect_uri": "https://client.example.com/cb", "response_type": "token", "client_id": "s6BhdRkqt3"}'


def test_authz_req_urlencoded_4():
    ar = AuthorizationRequest(response_type=["code"],
                              client_id="foobar")

    jtxt = ar.serialize(method="json")

    ar2 = AuthorizationRequest().deserialize(jtxt, "json")

    print ar
    print ar2

    assert ar == ar2


def test_authz_req_x1():
    query = 'redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fauthz&response_type=code&client_id=0123456789'

    ar = AuthorizationRequest().deserialize(query, "urlencoded")

    print ar

    assert ar.verify()

# AuthorizationErrorResponse

def test_authz_err_resp_1():
    aer = AuthorizationErrorResponse(error="access_denied",
                                     state="xyz")

    assert aer
    print aer.__dict__.items()
    assert aer["error"] == "access_denied"
    assert aer["state"] == "xyz"


def test_authz_err_resp_2():
    aer = AuthorizationErrorResponse(error="access_denied",
                                     error_description="brewers has a four game series",
                                     foo="bar")

    assert aer
    print aer.__dict__.items()
    assert aer["error"] == "access_denied"
    assert aer["error_description"] == "brewers has a four game series"

# TokenErrorResponse

def test_authz_err_resp_1():
    ter = TokenErrorResponse(error="access_denied", state="xyz")

    assert ter
    print ter.__dict__.items()
    assert ter["error"] == "access_denied"
    assert _eq(ter.keys(), ['state', 'error'])


def test_authz_err_resp_2():
    ter = TokenErrorResponse(error="access_denied",
                             error_description="brewers has a four game series",
                             foo="bar")

    assert ter
    print ter.__dict__.items()
    assert ter["error"] == "access_denied"
    assert ter["error_description"] == "brewers has a four game series"
    assert ter["foo"] == "bar"

    assert "error" in ter
    assert "error_description" in ter
    assert "foo" in ter

# AccessTokenResponse

def test_accesstokenreponse_1():
    at = AccessTokenResponse(access_token="SlAV32hkKG",
                             token_type="Bearer", expires_in=3600)

    assert at
    atj = at.serialize(method="json")
    print atj
    assert atj == '{"token_type": "Bearer", "access_token": "SlAV32hkKG", "expires_in": 3600}'

# AccessTokenRequest

def test_extra():
    atr = AccessTokenRequest(grant_type="authorization_code",
                             code="SplxlOBeZQQYbYS6WxSbIA",
                             redirect_uri="https://client.example.com/cb",
                             extra="foo")

    assert atr
    query = atr.to_urlencoded()
    print query
    assert query == "code=SplxlOBeZQQYbYS6WxSbIA&redirect_uri=https%3A%2F" \
                    "%2Fclient.example.com%2Fcb&grant_type=authorization_code&extra=foo"

    atr2 = AccessTokenRequest().deserialize(query, "urlencoded")

    print atr.to_dict()
    print atr2.to_dict()
    assert atr == atr2

# AuthorizationResponse

def test_authz_resp_1():
    atr = AuthorizationResponse(code="SplxlOBeZQQYbYS6WxSbIA",
                                state="Fun_state", extra="foo")

    assert atr["code"] == "SplxlOBeZQQYbYS6WxSbIA"
    assert atr["state"] == "Fun_state"
    assert atr["extra"] == "foo"

# ROPCAccessTokenRequest

#noinspection PyArgumentEqualDefault
def test_ropc_acc_token_req():
    ropc = ROPCAccessTokenRequest(grant_type="password",
                                  username="johndoe", password="A3ddj3w")

    assert ropc["grant_type"] == "password"
    assert ropc["username"] == "johndoe"
    assert ropc["password"] == "A3ddj3w"

# CCAccessTokenRequest

def test_cc_acc_token_req():
    cc = CCAccessTokenRequest(scope="/foo")

    assert cc["grant_type"] == "client_credentials"
    assert cc["scope"] == ["/foo"]

# RefreshAccessTokenRequest

def test_ratr():
    ratr = RefreshAccessTokenRequest(refresh_token="ababababab",
                                     client_id="Client_id")

    assert ratr["grant_type"] == "refresh_token"
    assert ratr["refresh_token"] == "ababababab"
    assert ratr["client_id"] == "Client_id"

    assert ratr.verify()


def test_authz_load_dict():
    bib = {"scope": ["openid"],
           "state": "id-6da9ca0cc23959f5f33e8becd9b08cae",
           "redirect_uri": "http://localhost:8087authz",
           "response_type": ["code"],
           "client_id": "a1b2c3"}

    arq = AuthorizationRequest(**bib)

    assert arq["scope"] == bib["scope"]
    assert arq["response_type"] == bib["response_type"]
    assert arq["redirect_uri"] == bib["redirect_uri"]
    assert arq["state"] == bib["state"]
    assert arq["client_id"] == bib["client_id"]


def test_authz_req_set_json():
    argv = {"scope": ["openid"],
            "state": "id-b0be8bb64118c3ec5f70093a1174b039",
            "redirect_uri": "http://localhost:8087authz",
            "response_type": ["code"],
            "client_id": "a1b2c3"}

    arq = AuthorizationRequest(**argv)

    jstr = arq.serialize(method="json")

    jarq = AuthorizationRequest().deserialize(jstr, "json")

    assert jarq["scope"] == ["openid"]
    assert jarq["response_type"] == ["code"]
    assert jarq["redirect_uri"] == "http://localhost:8087authz"
    assert jarq["state"] == "id-b0be8bb64118c3ec5f70093a1174b039"
    assert jarq["client_id"] == "a1b2c3"


def test_sp_sep_list_deserializer():
    vals = sp_sep_list_deserializer("foo bar zen")
    assert len(vals) == 3
    assert _eq(vals, ["foo", "bar", "zen"])

    vals = sp_sep_list_deserializer(["foo bar zen"])
    assert len(vals) == 3
    assert _eq(vals, ["foo", "bar", "zen"])


def test_json_serializer():
    val = json_serializer({"foo": ["bar", "stool"]})
    print val
    assert val == '{"foo": ["bar", "stool"]}'


def test_json_deserializer():
    _dict = {"foo": ["bar", "stool"]}
    val = json_serializer(_dict)

    sdict = json_deserializer(val)
    assert _dict == sdict


def test_omit():
    err = ErrorResponse(error="invalid_request",
                        error_description="Something was missing",
                        error_uri="http://example.com/error_message.html")

    ue_str = err.to_urlencoded()
    del err["error_uri"]
    ueo_str = err.to_urlencoded()

    assert ue_str != ueo_str
    assert "error_message" not in ueo_str
    assert "error_message" in ue_str


def test_missing_required():
    err = ErrorResponse()
    assert "error" not in err

    raises(MissingRequiredAttribute, "err.to_urlencoded()")


def test_to_urlencoded():
    atr = AccessTokenResponse(
        access_token="2YotnFZFEjr1zCsicMWpAA",
        token_type="example",
        expires_in=3600,
        refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
        example_parameter="example_value",
        scope=["inner", "outer"])

    assert _eq(atr["scope"], ["inner", "outer"])

    uec = atr.to_urlencoded()
    print uec
    assert "inner+outer" in uec


def test_to_urlencoded_extended_omit():
    atr = AccessTokenResponse(
        access_token="2YotnFZFEjr1zCsicMWpAA",
        token_type="example",
        expires_in=3600,
        refresh_token="tGzv3JOkF0XG5Qx2TlKWIA",
        example_parameter="example_value",
        scope=["inner", "outer"],
        extra=["local", "external"],
        level=3)

    uec = atr.to_urlencoded()
    print uec
    assert "level=3" in uec
    assert "example_parameter=example_value" in uec
    assert "extra=local" in uec
    assert "extra=external" in uec
    del atr["extra"]
    ouec = atr.to_urlencoded()
    print ouec
    assert "level=3" in ouec
    assert "example_parameter=example_value" in ouec
    assert "extra=local" not in ouec
    assert uec != ouec
    assert len(uec) == (len(ouec) + len("extra=local") +
                        len("extra=external") + 2)

    atr2 = AccessTokenResponse().deserialize(uec, "urlencoded")
    print atr2.keys()
    assert _eq(atr2.keys(), ['access_token', 'expires_in', 'token_type',
                             'scope', 'refresh_token', 'level',
                             'example_parameter', 'extra'])

    atr3 = AccessTokenResponse().deserialize(ouec, "urlencoded")
    print atr3.keys()
    assert _eq(atr3.keys(), ['access_token', 'expires_in', 'token_type',
                             'scope', 'refresh_token', 'level',
                             'example_parameter'])

##noinspection PyUnusedLocal
#def test_to_urlencoded_to_many_values():
#    uec = "access_token=2YotnFZFEjr1zCsicMWpAA+AAA111BBB222CCC333"
#    raises(ValueError, "AccessTokenResponse.set_urlencoded(uec)")

#noinspection PyUnusedLocal
def test_to_set_json():
    """

    """
    item = Dummy_Message(req_str="Fair", opt_str="game", opt_int=9,
                         opt_str_list=["one", "two"],
                         req_str_list=["spike", "lee"],
                         opt_json='{"ford": "green"}')

    jso = item.serialize(method="json")
    print jso
    item2 = Dummy_Message().deserialize(jso, "json")
    print item2
    assert _eq(item2.keys(), ['opt_str', 'req_str', 'opt_json', 'req_str_list',
                              'opt_str_list', 'opt_int'])

    jso_1 = '{"req_str": "Fair", "req_str_list": ["spike", "lee"], "opt_int": [9]}'

    item3 = Dummy_Message().deserialize(jso_1, "json")

    assert _eq(item3.keys(), ['req_str', 'req_str_list', 'opt_int'])
    assert item3["opt_int"] == 9

    jso_2 = '{"req_str": "Fair", "req_str_list": ["spike", "lee"], "opt_int": [9, 10]}'
    raises(TooManyValues, 'Dummy_Message().deserialize(jso_2, "json")')

    jso_3 = '{"req_str": "Fair", "req_str_list": ["spike", "lee"], "extra": "out"}'
    item4 = Dummy_Message().deserialize(jso_3, "json")

    print item4
    assert _eq(item4.keys(), ['req_str', 'req_str_list', 'extra'])
    assert item4["extra"] == "out"

    item4 = Dummy_Message().deserialize(jso_3, "json")

    print item4
    assert _eq(item4.keys(), ['req_str', 'req_str_list', 'extra'])
    assert item4["extra"] == "out"


def test_to_from_jwt():
    item = Dummy_Message(req_str="Fair", opt_str="game", opt_int=9,
                         opt_str_list=["one", "two"],
                         req_str_list=["spike", "lee"],
                         opt_json='{"ford": "green"}')

    keys = [SYMKey(key="A1B2C3D4")]
    jws = item.to_jwt(keys, "HS256")

    print jws

    jitem = Dummy_Message().from_jwt(jws, key=keys)

    print jitem.keys()

    assert _eq(jitem.keys(), ['opt_str', 'req_str', 'opt_json',
                              'req_str_list', 'opt_str_list', 'opt_int'])


def test_TokenRevocationRequest():
    trr = TokenRevocationRequest(token="token")
    assert trr.verify()


def test_message():
    _dict = {"req_str": "Fair", "opt_str": "game", "opt_int": 9,
             "opt_str_list": ["one", "two"], "req_str_list": ["spike", "lee"],
             "opt_json": '{"ford": "green"}'}

    cls = Dummy_Message(**_dict)
    cls.verify()
    assert _eq(cls.keys(), ['opt_str', 'req_str', 'opt_json',
                            'req_str_list', 'opt_str_list', 'opt_int'])

    _dict = {"req_str": "Fair", "opt_str": "game", "opt_int": 9,
             "opt_str_list": ["one", "two"], "req_str_list": ["spike", "lee"],
             "opt_json": '{"ford": "green"}', "extra": "internal"}

    cls = Dummy_Message(**_dict)
    cls.verify()
    print cls.keys()
    assert _eq(cls.keys(), ['opt_str', 'req_str', 'extra', 'opt_json',
                            'req_str_list', 'opt_str_list', 'opt_int'])

    _dict = {"req_str": "Fair", "opt_str": "game", "opt_int": 9,
             "opt_str_list": ["one", "two"], "req_str_list": ["spike", "lee"]}

    cls = Dummy_Message(**_dict)
    cls.verify()
    assert _eq(cls.keys(), ['opt_str', 'req_str', 'req_str_list',
                            'opt_str_list', 'opt_int'])


def test_request():
    req = Dummy_Message(req_str="Fair",
                        req_str_list=["game"]).request("http://example.com")

    assert req == "http://example.com?req_str=Fair&req_str_list=game"


def test_multiple_response_types_urlencoded():
    ar = AuthorizationRequest(response_type=["code", "token"],
                              client_id="foobar")
    ue = ar.to_urlencoded()
    print ue
    assert ue == "response_type=code+token&client_id=foobar"

    are = AuthorizationRequest().deserialize(ue, "urlencoded")
    assert _eq(are.keys(), ["response_type", "client_id"])
    assert _eq(are["response_type"], ["code", "token"])


def test_multiple_scopes_urlencoded():
    ar = AuthorizationRequest(response_type=["code", "token"],
                              client_id="foobar", scope=["openid", "foxtrot"])
    ue = ar.to_urlencoded()
    print ue
    assert ue == "scope=openid+foxtrot&response_type=code+token&client_id=foobar"

    are = AuthorizationRequest().deserialize(ue, "urlencoded")
    assert _eq(are.keys(), ["response_type", "client_id", "scope"])
    assert _eq(are["response_type"], ["code", "token"])
    assert _eq(are["scope"], ["openid", "foxtrot"])


def test_multiple_response_types_json():
    ar = AuthorizationRequest(response_type=["code", "token"],
                              client_id="foobar")
    ue = ar.to_json()
    print ue
    assert ue == '{"response_type": "code token", "client_id": "foobar"}'

    are = AuthorizationRequest().deserialize(ue, "json")
    print are.keys()
    assert _eq(are.keys(), ["response_type", "client_id"])
    assert _eq(are["response_type"], ["code", "token"])


def test_multiple_scopes_json():
    ar = AuthorizationRequest(response_type=["code", "token"],
                              client_id="foobar", scope=["openid", "foxtrot"])
    ue = ar.to_json()
    print ue
    assert ue == '{"scope": "openid foxtrot", "response_type": "code token", "client_id": "foobar"}'

    are = AuthorizationRequest().deserialize(ue, "json")
    assert _eq(are.keys(), ["response_type", "client_id", "scope"])
    assert _eq(are["response_type"], ["code", "token"])
    assert _eq(are["scope"], ["openid", "foxtrot"])

if __name__ == "__main__":
    test_to_from_jwt()
########NEW FILE########
__FILENAME__ = test_oauth2_provider
from mako.lookup import TemplateLookup
from oic.oauth2 import rndstr
from oic.utils.authn.authn_context import AuthnBroker
from oic.utils.authn.client import verify_client
from oic.utils.authn.user import UserAuthnMethod
from oic.utils.authz import Implicit
from oic.utils.http_util import Response

from oic.oauth2.message import AuthorizationRequest
from oic.oauth2.message import AccessTokenRequest
from oic.oauth2.message import AccessTokenResponse
from oic.oauth2.message import TokenErrorResponse

from oic.utils import sdb
from oic.oauth2.consumer import Consumer
from oic.oauth2.provider import Provider

CLIENT_CONFIG = {
    "client_id": "client1",
    "ca_certs": "/usr/local/etc/oic/ca_certs.txt",
}

CONSUMER_CONFIG = {
    "authz_page": "/authz",
    "flow_type": "code",
    #"password": args.passwd,
    "scope": [],
    "response_type": "code",
    #"expire_in": 600,
}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://connect-op.heroku.com",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    #"userinfo_endpoint":"http://localhost:8088/user_info",
    #"check_id_endpoint":"http://localhost:8088/id_token",
    #"registration_endpoint":"https://connect-op.heroku.com/connect/client",
    #"scopes_supported":["openid","profile","email","address","PPID"],
    "flows_supported": ["code", "token", "code token"],
    #"identifiers_supported":["public","ppid"],
    #"x509_url":"https://connect-op.heroku.com/cert.pem"
}

CDB = {
    "a1b2c3": {
        "password": "hemligt",
        "client_secret": "drickyoughurt"
    },
    "client1": {
        "client_secret": "hemlighet",
        "redirect_uris": [("http://localhost:8087/authz", None)]
    }
}

PASSWD = {"user": "password"}

ROOT = '../oc3/'
tl = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                    module_directory=ROOT + 'modules',
                    input_encoding='utf-8', output_encoding='utf-8')


class DummyAuthn(UserAuthnMethod):
    def __init__(self, srv, user):
        UserAuthnMethod.__init__(self, srv)
        self.user = user

    def authenticated_as(self, cookie=None, **kwargs):
        return {"uid": self.user}

AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add("UNDEFINED", DummyAuthn(None, "username"))

# dealing with authorization
AUTHZ = Implicit()


def content_type(headers):
    for key, val in headers:
        if key == "Content-type":
            if val == "application/json":
                return "json"


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_provider_init():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client)

    assert provider

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        urlmap={"client1": ["https://example.com/authz"]})

    assert provider.urlmap["client1"] == ["https://example.com/authz"]


def test_provider_authorization_endpoint():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client)

    bib = {"scope": ["openid"],
           "state": "id-6da9ca0cc23959f5f33e8becd9b08cae",
           "redirect_uri": "http://localhost:8087authz",
           "response_type": ["code"],
           "client_id": "a1b2c3"}

    arq = AuthorizationRequest(**bib)

    QUERY_STRING = arq.to_urlencoded()

    resp = provider.authorization_endpoint(request=QUERY_STRING)

    assert isinstance(resp, Response)


def test_provider_authenticated():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client, symkey=rndstr(16))
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    location = cons.begin("http://localhost:8087",
                          "http://localhost:8088/authorization")

    query_string = location.split("?")[1]

    resp = provider.authorization_endpoint(query_string)
    assert resp.status == "302 Found"
    print resp.headers
    print resp.message
    if content_type(resp.headers) == "json":
        resp = resp.message
    else:
        resp = resp.message.split("?")[1]
    aresp = cons.handle_authorization_response(query=resp)

    print aresp.keys()
    assert aresp.type() == "AuthorizationResponse"
    assert _eq(aresp.keys(), ['state', 'code'])

    print cons.grant[cons.state].keys()
    assert _eq(cons.grant[cons.state].keys(), ['tokens', 'code', 'exp_in',
                                               'seed', 'id_token',
                                               'grant_expiration_time'])


def test_provider_authenticated_token():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client, symkey=rndstr(16))
    _session_db = {}
    cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
                    server_info=SERVER_INFO, **CONSUMER_CONFIG)
    cons.debug = True

    location = cons.begin("http://localhost:8087",
                          "http://localhost:8088/authorization",
                          "token")

    QUERY_STRING = location.split("?")[1]
    resp = provider.authorization_endpoint(QUERY_STRING)
    print resp.headers
    print resp.message
    txt = resp.message
    assert "access_token=" in txt
    assert "token_type=Bearer" in txt


# def test_provider_authenticated_none():
#     provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
#                         verify_client)
#     _session_db = {}
#     cons = Consumer(_session_db, client_config=CLIENT_CONFIG,
#                     server_info=SERVER_INFO, **CONSUMER_CONFIG)
#     cons.debug = True
#
#     location = cons.begin("http://localhost:8087",
#                           "http://localhost:8088/authorization",
#                           "none")
#
#     QUERY_STRING = location.split("?")[1]
#
#     resp2 = provider.authorization_endpoint(request=QUERY_STRING)
#
#     location = resp2.message
#     print location
#
#     assert location.startswith("http://localhost:8087/authz")
#     query = location.split("?")[1]
#     assert query.startswith("state=")
#     assert "&" not in query


def test_token_endpoint():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client, symkey=rndstr(16))

    authreq = AuthorizationRequest(state="state",
                                   redirect_uri="http://example.com/authz",
                                   client_id="client1")

    _sdb = provider.sdb
    sid = _sdb.token.key(user="sub", areq=authreq)
    access_grant = _sdb.token(sid=sid)
    _sdb[sid] = {
        "oauth_state": "authz",
        "sub": "sub",
        "authzreq": "",
        "client_id": "client1",
        "code": access_grant,
        "code_used": False,
        "redirect_uri": "http://example.com/authz"
    }

    # Construct Access token request
    areq = AccessTokenRequest(code=access_grant,
                              redirect_uri="http://example.com/authz",
                              client_id="client1", client_secret="hemlighet",)

    print areq.to_dict()
    resp = provider.token_endpoint(request=areq.to_urlencoded())
    print resp.message
    atr = AccessTokenResponse().deserialize(resp.message, "json")

    print atr.keys()
    assert _eq(atr.keys(), ['access_token', 'expires_in', 'token_type',
                            'refresh_token'])


def test_token_endpoint_unauth():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client, symkey=rndstr(16))

    authreq = AuthorizationRequest(state="state",
                                   redirect_uri="http://example.com/authz",
                                   client_id="client1")

    _sdb = provider.sdb
    sid = _sdb.token.key(user="sub", areq=authreq)
    access_grant = _sdb.token(sid=sid)
    _sdb[sid] = {
        "oauth_state": "authz",
        "sub": "sub",
        "authzreq": "",
        "client_id": "client1",
        "code": access_grant,
        "code_used": False,
        "redirect_uri": "http://example.com/authz"
    }

    # Construct Access token request
    areq = AccessTokenRequest(code=access_grant,
                              redirect_uri="http://example.com/authz",
                              client_id="client2", client_secret="hemlighet",)

    print areq.to_dict()
    resp = provider.token_endpoint(request=areq.to_urlencoded())
    print resp.message
    atr = TokenErrorResponse().deserialize(resp.message, "json")
    print atr.keys()
    assert _eq(atr.keys(), ['error_description', 'error'])

if __name__ == "__main__":
    test_provider_authenticated_token()
########NEW FILE########
__FILENAME__ = test_oic
#!/usr/bin/env python
#from oic.oauth2 import KeyStore

__author__ = 'rohe0002'

import time
import json
import urllib

from oic.oic import Grant
from oic.oic import Token
from oic.oic import Client
from oic.oic import Server

from oic.oic.message import IdToken, ClaimsRequest
#from oic.oic.message import AuthorizationErrorResponse
from oic.oic.message import Claims
from oic.oic.message import UserInfoRequest
from oic.oic.message import RegistrationRequest
from oic.oic.message import RefreshSessionRequest
from oic.oic.message import CheckSessionRequest
from oic.oic.message import EndSessionRequest
from oic.oic.message import RefreshAccessTokenRequest
from oic.oic.message import AccessTokenRequest
from oic.oic.message import OpenIDRequest
from oic.oic.message import AuthorizationRequest
from oic.oic.message import AccessTokenResponse
from oic.oic.message import AuthorizationResponse

from oic.oauth2.message import GrantExpired
from oic.oauth2.message import ErrorResponse
from oic.oauth2.message import MissingRequiredAttribute

from oic.utils import time_util
from oic.utils.time_util import utc_time_sans_frac
from oic.utils.keyio import KeyBundle, KeyJar, rsa_load

from jwkest import unpack
from jwkest.jws import left_hash
from jwkest.jws import alg2keytype

from pytest import raises

from fakeoicsrv import MyFakeOICServer


def _eq(l1, l2):
    s1 = set(l1)
    s2 = set(l2)
    return s1 == s2


CLIENT_SECRET = "abcdefghijklmnop"
CLIENT_ID = "client_1"

KC_SYM_S = KeyBundle({"kty": "oct", "key": "abcdefghijklmnop", "use": "sig"})

_key = rsa_load("../oidc_example/op1/certs/mycert.key")
KC_RSA = KeyBundle({"key": _key, "kty": "RSA", "use": "sig"})

KEYJ = KeyJar()
KEYJ[""] = [KC_RSA, KC_SYM_S]
KEYJ["client_1"] = [KC_SYM_S]

IDTOKEN = IdToken(iss="http://oic.example.org/", sub="sub",
                  aud=CLIENT_ID, exp=utc_time_sans_frac() + 86400,
                  nonce="N0nce",
                  iat=time.time())

# ----------------- CLIENT --------------------


class TestOICClient():
    def setup_class(self):
        self.client = Client(CLIENT_ID)
        self.client.redirect_uris = ["http://example.com/redirect"]
        self.client.client_secret = CLIENT_SECRET
        self.client.keyjar[""] = KC_RSA

    def test_areq_1(self):
        ar = self.client.construct_AuthorizationRequest(
            request_args={"response_type": ["code"]})

        print ar.to_dict()
        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert "state" not in ar
        assert "scope" not in ar

    def test_areq_2(self):
        self.client.state = "abc"
        req_args = {"response_type": ["code"], "scope": ["foo", "bar"]}
        ar = self.client.construct_AuthorizationRequest(request_args=req_args)

        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert ar["client_id"] == CLIENT_ID
        assert ar["state"] == "abc"
        assert ar["scope"] == ["foo", "bar"]

    def test_areq_replace_default_state(self):
        self.client.state = "efg"
        req_args = {"response_type": ["code"], "scope": ["foo", "bar"]}
        ar = self.client.construct_AuthorizationRequest(request_args=req_args)

        assert ar["redirect_uri"] == "http://example.com/redirect"
        assert ar["response_type"] == ["code"]
        assert ar["client_id"] == CLIENT_ID
        assert ar["state"] == "efg"
        assert ar["scope"] == ["foo", "bar"]

    def test_parse_authz_resp_url(self):
        url = "https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=ghi"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=url, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "ghi"

        assert self.client.grant["ghi"]
        assert self.client.grant["ghi"].code == aresp["code"]
        assert self.client.grant["ghi"].grant_expiration_time

    def test_parse_authz_resp_query(self):
        query = "code=SplxlOBeZQQYbYS6WxSbIA&state=hij"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "hij"

        print self.client.grant.keys()
        assert self.client.grant["hij"]
        assert self.client.grant["hij"].code == aresp["code"]
        assert self.client.grant["hij"].grant_expiration_time

    def test_parse_authz_resp_query_multi_scope(self):
        query = "code=SplxlOBeZQQYbYS6WxAAAA&state=klm"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxAAAA"
        assert aresp["state"] == "klm"

        assert self.client.grant["klm"]
        assert self.client.grant["klm"].code == aresp["code"]
        assert self.client.grant["klm"].grant_expiration_time

        assert _eq(self.client.grant.keys(), ['ghi', 'hij', 'klm'])

    def test_parse_authz_resp_query_unknown_parameter(self):
        query = "code=SplxlOBeZQQYbYS6WxSbIA&state=xyz&foo=bar"
        aresp = self.client.parse_response(AuthorizationResponse,
                                           info=query, sformat="urlencoded")

        assert aresp["code"] == "SplxlOBeZQQYbYS6WxSbIA"
        assert aresp["state"] == "xyz"

        print aresp.__dict__.keys()
        assert "foo" not in aresp.__dict__

        assert self.client.grant["xyz"]
        assert self.client.grant["xyz"].code == aresp["code"]
        assert self.client.grant["xyz"].grant_expiration_time

    def test_get_access_token_request_1(self):
        self.client.reset()
        self.client.redirect_uris = ["http://client.example.com/authz"]
        grant = Grant()
        grant.code = "AbCdEf"
        grant.grant_expiration_time = time_util.utc_time_sans_frac() + 30
        self.client.grant = {"stat": grant}

        # scope is default=""
        atr = self.client.construct_AccessTokenRequest(state="stat")

        assert atr["grant_type"] == "authorization_code"
        assert atr["code"] == "AbCdEf"
        assert atr["redirect_uri"] == "http://client.example.com/authz"

    def test_construct_access_token_request_fail(self):
        raises(Exception,
               'self.client.construct_AccessTokenRequest(state="unknown")')

    def test_get_access_token_request_override(self):
        self.client.reset()
        self.client.redirect_uris = ["http://client.example.com/authz"]
        grant = Grant()
        grant.code = "AbCdEf"
        grant.grant_expiration_time = time_util.utc_time_sans_frac() + 30
        self.client.grant = {"xyz": grant}

        atr = self.client.construct_AccessTokenRequest(state="xyz")

        assert atr["grant_type"] == "authorization_code"
        assert atr["code"] == "AbCdEf"
        assert atr["redirect_uri"] == "http://client.example.com/authz"

    def test_construct_request_no_input(self):
        self.client.response_type = ["code"]
        atr = self.client.construct_AuthorizationRequest(
            request_args={"scope": ["openid"], "response_type": ["code"]})

        print atr
        assert atr["redirect_uri"] == "http://client.example.com/authz"
        assert atr["response_type"] == ["code"]
        assert atr["client_id"] == CLIENT_ID

    def test_parse_access_token_response(self):
        jso = """{
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
    }"""

        self.client.parse_response(AccessTokenResponse,
                                   info="".join([
                                       x.strip() for x in jso.split("\n")]))

        assert self.client.grant
        _grant = self.client.grant[""]
        assert len(_grant.tokens) == 1
        token = _grant.tokens[0]
        assert token.access_token == "2YotnFZFEjr1zCsicMWpAA"
        assert token.token_type == "example"
        assert token.expires_in == 3600
        assert token.refresh_token == "tGzv3JOkF0XG5Qx2TlKWIA"

        # I'm dropping parameters I don't recognize
        assert "example_parameter" not in self.client.__dict__

        #assert self.client.access_token_is_valid()

    def test_get_access_token_refresh_1(self):
        print self.client.grant

        self.client.grant[""].grant_expiration_time = time.time() + 60
        self.client.grant[""].code = "access_code"
        token = self.client.grant[""].tokens[0]
        print token
        # Uses refresh_token from previous response
        atr = self.client.construct_RefreshAccessTokenRequest(token=token)

        assert atr.type() == "RefreshAccessTokenRequest"
        assert atr["grant_type"] == "refresh_token"
        assert atr["refresh_token"] == "tGzv3JOkF0XG5Qx2TlKWIA"

    def test_get_access_token_refresh_2(self):
        self.client.grant["foo"] = Grant()
        self.client.grant["foo"].grant_expiration_time = \
            utc_time_sans_frac() + 60
        self.client.grant["foo"].code = "access_code"

        print self.client.grant["foo"]
        resp = AccessTokenResponse()
        resp["refresh_token"] = "refresh_with_me"
        resp["access_token"] = "access"
        self.client.grant["foo"].tokens.append(Token(resp))
        # Uses refresh_token from previous response
        atr = self.client.construct_RefreshAccessTokenRequest(state="foo")

        assert atr.type() == "RefreshAccessTokenRequest"
        assert atr["grant_type"] == "refresh_token"
        assert atr["refresh_token"] == "refresh_with_me"

    def test_parse_authz_err_response(self):
        ruri = "https://client.example.com/cb?error=access_denied&amp;state=xyz"

        #print self.client.response2error[AuthorizationErrorResponse.__name__]
        resp = self.client.parse_response(AuthorizationResponse,
                                          info=ruri, sformat="urlencoded")

        print type(resp), resp
        assert resp.type() == "AuthorizationErrorResponse"

        assert resp["error"] == "access_denied"
        assert resp["state"] == "xyz"

    def test_return_non_existant_grant(self):
        assert self.client.grant_from_state("123456abcdef") is None

    def test_construct_request_with_extra_args(self):
        req = self.client.construct_AccessTokenRequest(
            state="foo", extra_args={"foo": "bar"})

        assert req
        print req.keys()
        assert _eq(req.keys(), ['code', 'grant_type', 'client_id',
                                'client_secret', 'redirect_uri', 'foo'])
        assert req["foo"] == "bar"

    def test_construct_TokenRevocationRequest(self):
        req = self.client.construct_TokenRevocationRequest(state="foo")

        assert req
        print req.keys()
        assert _eq(req.keys(), ['token'])
        assert req["token"] == "access"

    def test_request_info_simple(self):
        self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, request_args={"scope": ["openid"],
                                                "response_type": "token"})

        # default == "POST"
        assert uri == 'https://example.com/authz'
        areq = AuthorizationRequest().from_urlencoded(body)
        assert _eq(areq.keys(), ["nonce", "redirect_uri", "response_type",
                                 "client_id", "scope"])
        assert h_args == {'headers': {
            'content-type': 'application/x-www-form-urlencoded'}}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get(self):
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET",
            request_args={"scope": ["openid"], "response_type": "token"})

        (url, query) = uri.split("?")
        areq = AuthorizationRequest().from_urlencoded(query)
        assert _eq(areq.keys(), ["nonce", "redirect_uri", "response_type",
                                 "client_id", "scope"])
        assert areq["redirect_uri"] == "http://client.example.com/authz"

        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get_with_req_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET",
            request_args={"state": "init", "scope": ["openid"],
                          "response_type": "code"})

        print uri
        (url, query) = uri.split("?")
        areq = AuthorizationRequest().from_urlencoded(query)
        assert _eq(areq.keys(), ["redirect_uri", "response_type",
                                 "client_id", "state", "scope"])
        assert areq["state"]
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_simple_get_with_extra_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET",
            request_args={"scope": ["openid"], "response_type": "code"},
            extra_args={"rock": "little"})

        print uri
        (url, query) = uri.split("?")
        areq = AuthorizationRequest().from_urlencoded(query)
        assert _eq(areq.keys(), ["redirect_uri", "response_type",
                                 "client_id", "rock", "scope"])
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_request_info_with_req_and_extra_args(self):
        #self.client.authorization_endpoint = "https://example.com/authz"
        uri, body, h_args, cis = self.client.request_info(
            AuthorizationRequest, method="GET",
            request_args={"state": "init", "scope": ["openid"],
                          "response_type": "code"},
            extra_args={"rock": "little"})

        print uri
        (url, query) = uri.split("?")
        areq = AuthorizationRequest().from_urlencoded(query)
        assert _eq(areq.keys(), ["redirect_uri", "response_type",
                                 "client_id", "state", "rock", "scope"])
        assert body is None
        assert h_args == {}
        assert cis.type() == "AuthorizationRequest"

    def test_do_authorization_request(self):
        self.client.grant = {}
        self.client.redirect_uris = ["https://www.example.com/authz"]
        self.client.authorization_endpoint = \
            "http://oic.example.org/authorization"
        self.client.client_id = "a1b2c3"
        self.client.state = "state0"
        mfos = MyFakeOICServer()
        mfos.keyjar = KEYJ
        self.client.http_request = mfos.http_request

        args = {"response_type": ["code"],
                "scope": ["openid"]}
        result = self.client.do_authorization_request(state=self.client.state,
                                                      request_args=args)
        assert result.status_code == 302
        _loc = result.headers["location"]
        assert _loc.startswith(self.client.redirect_uris[0])
        _, query = _loc.split("?")

        self.client.parse_response(AuthorizationResponse, info=query,
                                   sformat="urlencoded")

    def test_access_token_request(self):
        self.client.token_endpoint = "http://oic.example.org/token"

        print self.client.grant.keys()
        print self.client.state
        print self.client.grant[self.client.state]

        resp = self.client.do_access_token_request(scope="openid")
        print resp
        print resp.keys()
        self.client.grant[self.client.state].add_token(resp)
        assert resp.type() == "AccessTokenResponse"
        assert _eq(resp.keys(), ['token_type', 'state', 'access_token',
                                 'expires_in', 'refresh_token', 'scope'])

    def test_do_user_info_request(self):
        self.client.userinfo_endpoint = "http://oic.example.org/userinfo"
        print self.client.grant.keys()
        print self.client.grant[self.client.state]
        resp = self.client.do_user_info_request(state=self.client.state)
        assert resp.type() == "OpenIDSchema"
        assert _eq(resp.keys(),
                   ['name', 'email', 'verified', 'nickname', 'sub'])
        assert resp["name"] == "Melody Gardot"

    def test_do_access_token_refresh(self):
        #token = self.client.get_token(scope="openid")

        resp = self.client.do_access_token_refresh(scope="openid")
        print resp
        assert resp.type() == "AccessTokenResponse"
        assert _eq(resp.keys(), ['token_type', 'state', 'access_token',
                                 'expires_in', 'refresh_token', 'scope'])

    def test_do_check_session_request(self):
        self.client.redirect_uris = ["https://www.example.com/authz"]
        self.client.client_id = CLIENT_ID
        self.client.check_session_endpoint = "https://example.org/check_session"

        # RSA signing
        alg = "RS256"
        ktyp = alg2keytype(alg)
        _sign_key = self.client.keyjar.get_signing_key(ktyp)
        print _sign_key
        args = {"id_token": IDTOKEN.to_jwt(key=_sign_key, algorithm=alg)}
        print self.client.keyjar.issuer_keys
        resp = self.client.do_check_session_request(request_args=args)

        assert resp.type() == "IdToken"
        assert _eq(resp.keys(), ['nonce', 'sub', 'aud', 'iss', 'exp', 'iat'])

    def test_do_end_session_request(self):
        self.client.redirect_uris = ["https://www.example.com/authz"]
        self.client.client_id = "a1b2c3"
        self.client.end_session_endpoint = "https://example.org/end_session"

        # RSA signing
        alg = "RS256"
        ktyp = alg2keytype(alg)
        _sign_key = self.client.keyjar.get_signing_key(ktyp)
        args = {"id_token": IDTOKEN.to_jwt(key=_sign_key, algorithm=alg),
                "redirect_url": "http://example.com/end"}

        resp = self.client.do_end_session_request(request_args=args,
                                                  state="state1")

        assert resp.status_code == 302
        assert resp.headers["location"].startswith("http://example.com/end")

    def test_do_registration_request(self):
        self.client.registration_endpoint = "https://example.org/registration"

        args = {"operation": "register",
                "application_type": "web",
                "application_name": "my service",
                "redirect_uri": "http://example.com/authz"}
        resp = self.client.do_registration_request(request_args=args)
        print resp
        print resp.keys()
        assert _eq(resp.keys(), ['redirect_uris', u'redirect_uri',
                                 'application_type', 'registration_client_uri',
                                 'client_secret_expires_at',
                                 'registration_access_token', 'client_id',
                                 'application_name', 'client_secret'])

    def test_do_user_info_request_with_access_token_refresh(self):
        self.client.userinfo_endpoint = "http://oic.example.org/userinfo"

        token = self.client.get_token(state=self.client.state, scope="openid")
        token.token_expiration_time = utc_time_sans_frac() - 86400

        resp = self.client.do_user_info_request(state=self.client.state)
        assert resp.type() == "OpenIDSchema"
        assert _eq(resp.keys(), ['name', 'email', 'verified', 'nickname',
                                 'sub'])
        assert resp["name"] == "Melody Gardot"

    def test_openid_request_with_request_1(self):
        claims = {
            "name": {"essential": True},
            "nickname": None,
            "email": {"essential": True},
            "verified": {"essential": True},
            "picture": None
        }

        areq = self.client.construct_AuthorizationRequest(
            request_args={
                "scope": "openid",
                "response_type": ["code"],
                "claims": ClaimsRequest(userinfo=Claims(**claims),
                                        id_token=Claims(auth_time=None,
                                                        acr={"values": ["2"]})),
                "max_age": 86400,
            },
            request_param="request")

        print areq.to_dict()
        assert areq
        assert "request" in areq

    def test_openid_request_with_request_2(self):
        areq = self.client.construct_AuthorizationRequest(
            request_args={"scope": "openid",
                          "response_type": ["code"],
                          "claims": {
                              "id_token": {"sub": {"value": "248289761001"}}}},
            request_param="request"
        )

        print areq
        assert areq
        assert areq.request

        jwtreq = OpenIDRequest().deserialize(areq["request"], "jwt",
                                             keyjar=self.client.keyjar)
        print
        print jwtreq
        print jwtreq.keys()
        assert _eq(jwtreq.keys(), ['claims', 'state',
                                   'redirect_uri', 'response_type',
                                   'client_id', 'scope'])


def test_get_authorization_request():
    client = Client()
    client.redirect_uris = ["https://www.example.com/authz"]
    client.client_id = "a1b2c3"
    args = {"response_type": ["code"]}
    ar = client.construct_AuthorizationRequest(request_args=args)
    assert ar["client_id"] == 'a1b2c3'
    assert ar["redirect_uri"] == 'https://www.example.com/authz'
    assert ar["response_type"] == ['code']

    client = Client()
    client.client_id = "a1b2c3"
    args = {"response_type": ["code"],
            "redirect_uri": "https://www.example.com/authz"}
    ar = client.construct_AuthorizationRequest(request_args=args)
    assert ar["client_id"] == 'a1b2c3'
    assert ar["redirect_uri"] == 'https://www.example.com/authz'
    assert ar["response_type"] == ['code']


def test_get_access_token_request():
    resp = AuthorizationResponse(code="code", state="state")

    grant = Grant(1)
    grant.add_code(resp)

    client = Client()
    client.grant["openid"] = grant
    time.sleep(2)
    raises(GrantExpired,
           'client.construct_AccessTokenRequest(state="openid")')


def test_parse_access_token_response():
    client = Client()

    at = AccessTokenResponse(access_token="SlAV32hkKG", token_type="Bearer",
                             refresh_token="8xLOxBtZp8", expires_in=3600)

    atj = at.to_json()

    ATR = AccessTokenResponse
    atr = client.parse_response(ATR, info=atj)

    assert _eq(atr.keys(), ['access_token', 'token_type', 'expires_in',
                            'refresh_token'])

    uec = at.to_urlencoded()
    raises(ValueError, 'client.parse_response(ATR, info=uec)')

    uatr = client.parse_response(ATR, info=uec, sformat="urlencoded")
    assert _eq(uatr.keys(), ['access_token', 'token_type', 'expires_in',
                             'refresh_token'])

    huec = "%s?%s" % ("https://example.com/token", uec)

    uatr = client.parse_response(ATR, info=huec, sformat="urlencoded")
    assert _eq(uatr.keys(), ['access_token', 'token_type', 'expires_in',
                             'refresh_token'])

    err = ErrorResponse(error="invalid_request",
                        error_description="Something was missing",
                        error_uri="http://example.com/error_message.html")

    jerr = err.to_json()
    uerr = err.to_urlencoded()

    _ = client.parse_response(ATR, info=jerr)
    _ = client.parse_response(ATR, info=uerr, sformat="urlencoded")

    raises(Exception,
           'client.parse_response(ATR, info=jerr, sformat="urlencoded")')

    raises(Exception, "client.parse_response(ATR, info=uerr)")

    raises(Exception,
           'client.parse_response(ATR, info=jerr, sformat="focus")')


#noinspection PyUnusedLocal
def test_parse_access_token_response_missing_attribute():
    at = AccessTokenResponse(access_token="SlAV32hkKG", token_type="Bearer",
                             refresh_token="8xLOxBtZp8", expires_in=3600)

    atdict = at.to_dict()
    del atdict["access_token"]
    atj = json.dumps(atdict)
    print atj
    client = Client()
    ATR = AccessTokenResponse

    raises(MissingRequiredAttribute, "client.parse_response(ATR, info=atj)")

    atuec = urllib.urlencode(atdict)

    raises(MissingRequiredAttribute,
           "client.parse_response(ATR, info=atuec, sformat='urlencoded')")


def test_client_get_grant():
    cli = Client()

    resp = AuthorizationResponse(code="code", state="state")
    grant = Grant()
    grant.add_code(resp)

    cli.grant["state"] = grant

    gr1 = cli.grant_from_state("state")

    assert gr1.code == "code"


def test_client_parse_args():
    cli = Client()

    args = {
        "response_type": "",
        "client_id": "client_id",
        "redirect_uri": "http://example.com/authz",
        "scope": "scope",
        "state": "state",
    }
    ar_args = cli._parse_args(AuthorizationRequest, **args)

    print ar_args.keys()
    assert _eq(ar_args.keys(), ['scope', 'state', 'redirect_uri',
                                'response_type', 'client_id'])


def test_client_parse_extra_args():
    cli = Client()

    args = {
        "response_type": "",
        "client_id": "client_id",
        "redirect_uri": "http://example.com/authz",
        "scope": "scope",
        "state": "state",
        "extra_session": "home"
    }
    ar_args = cli._parse_args(AuthorizationRequest, **args)

    print ar_args.keys()
    assert _eq(ar_args.keys(), ['state', 'redirect_uri', 'response_type',
                                'client_id', 'scope', 'extra_session'])


def test_client_endpoint():
    cli = Client()
    cli.authorization_endpoint = "https://example.org/oauth2/as"
    cli.token_endpoint = "https://example.org/oauth2/token"
    cli.token_revocation_endpoint = "https://example.org/oauth2/token_rev"

    ae = cli._endpoint("authorization_endpoint")
    assert ae == "https://example.org/oauth2/as"
    te = cli._endpoint("token_endpoint")
    assert te == "https://example.org/oauth2/token"
    tre = cli._endpoint("token_revocation_endpoint")
    assert tre == "https://example.org/oauth2/token_rev"

    ae = cli._endpoint("authorization_endpoint", **{
        "authorization_endpoint": "https://example.com/as"})
    assert ae == "https://example.com/as"

    cli.token_endpoint = ""
    raises(Exception, 'cli._endpoint("token_endpoint")')
    raises(Exception, 'cli._endpoint("foo_endpoint")')


def test_server_parse_parse_authorization_request():
    srv = Server()
    srv.keyjar = KEYJ
    ar = AuthorizationRequest(response_type=["code"], client_id="foobar",
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold", nonce="NONCE", scope=["openid"])

    uencq = ar.to_urlencoded()

    areq = srv.parse_authorization_request(query=uencq)

    assert areq.type() == "AuthorizationRequest"
    assert areq["response_type"] == ["code"]
    assert areq["client_id"] == "foobar"
    assert areq["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert areq["state"] == "cold"

    urluenc = "%s?%s" % ("https://example.com/authz", uencq)

    areq = srv.parse_authorization_request(url=urluenc)

    assert areq.type() == "AuthorizationRequest"
    assert areq["response_type"] == ["code"]
    assert areq["client_id"] == "foobar"
    assert areq["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert areq["state"] == "cold"


def test_server_parse_jwt_request():
    srv = Server()
    srv.keyjar = KEYJ
    ar = AuthorizationRequest(response_type=["code"], client_id=CLIENT_ID,
                              redirect_uri="http://foobar.example.com/oaclient",
                              state="cold", nonce="NONCE", scope=["openid"])

    _keys = srv.keyjar.get_verify_key(owner=CLIENT_ID)
    _jwt = ar.to_jwt(key=_keys, algorithm="HS256")

    req = srv.parse_jwt_request(txt=_jwt)

    assert req.type() == "AuthorizationRequest"
    assert req["response_type"] == ["code"]
    assert req["client_id"] == CLIENT_ID
    assert req["redirect_uri"] == "http://foobar.example.com/oaclient"
    assert req["state"] == "cold"


def test_server_parse_token_request():
    atr = AccessTokenRequest(grant_type="authorization_code",
                             code="SplxlOBeZQQYbYS6WxSbIA",
                             redirect_uri="https://client.example.com/cb",
                             client_id=CLIENT_ID, extra="foo")

    uenc = atr.to_urlencoded()

    srv = Server()
    srv.keyjar = KEYJ
    tr = srv.parse_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "AccessTokenRequest"
    assert _eq(tr.keys(), ['code', 'redirect_uri', 'grant_type', 'client_id',
                           'extra'])

    assert tr["grant_type"] == "authorization_code"
    assert tr["code"] == "SplxlOBeZQQYbYS6WxSbIA"

    tr = srv.parse_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "AccessTokenRequest"
    assert _eq(tr.keys(), ['code', 'grant_type', 'client_id', 'redirect_uri',
                           'extra'])

    assert tr["extra"] == "foo"


def test_server_parse_refresh_token_request():
    ratr = RefreshAccessTokenRequest(refresh_token="ababababab",
                                     client_id="Client_id")

    uenc = ratr.to_urlencoded()

    srv = Server()
    srv.keyjar = KEYJ
    tr = srv.parse_refresh_token_request(body=uenc)
    print tr.keys()

    assert tr.type() == "RefreshAccessTokenRequest"
    assert tr["refresh_token"] == "ababababab"
    assert tr["client_id"] == "Client_id"


def test_construct_UserInfoRequest():
    cli = Client()
    cli.userinfo_endpoint = "https://example.org/oauth2/userinfo"

    uir = cli.construct_UserInfoRequest(
        request_args={"access_token": "access_token"})
    print uir
    assert ("%s" % uir) == "access_token=access_token"


def test_construct_UserInfoRequest_2():
    cli = Client()
    cli.userinfo_endpoint = "https://example.org/oauth2/userinfo"
    cli.grant["foo"] = Grant()
    cli.grant["foo"].grant_expiration_time = time.time() + 60
    cli.grant["foo"].code = "access_code"

    resp = AccessTokenResponse(refresh_token="refresh_with_me",
                               access_token="access", id_token="IDTOKEN",
                               scope=["openid"])

    cli.grant["foo"].tokens.append(Token(resp))

    uir = cli.construct_UserInfoRequest(state="foo", scope=["openid"])
    print uir
    assert uir.keys() == ["access_token"]


def test_construct_CheckSessionRequest():
    cli = Client()
    cli.check_session_endpoint = "https://example.org/oauth2/check_session"

    csr = cli.construct_CheckSessionRequest(
        request_args={"id_token": "id_token"})
    print csr
    assert ("%s" % csr) == 'id_token=id_token'


def test_construct_CheckSessionRequest_2():
    cli = Client()
    cli.userinfo_endpoint = "https://example.org/oauth2/userinfo"
    cli.grant["foo"] = Grant()
    cli.grant["foo"].grant_expiration_time = time.time() + 60
    cli.grant["foo"].code = "access_code"

    resp = AccessTokenResponse(id_token="id_id_id_id",
                               access_token="access", scope=["openid"])

    cli.grant["foo"].tokens.append(Token(resp))

    uir = cli.construct_CheckSessionRequest(state="foo", scope=["openid"])
    print uir
    assert ("%s" % uir) == "id_token=id_id_id_id"


def test_construct_RegistrationRequest():
    cli = Client()
    cli.redirect_uris = ["http://example.com/authz"]

    request_args = {
        "type": "client_associate",
        "client_id": CLIENT_ID,
        "contacts": ["foo@example.com"],
        "application_type": "web",
        "application_name": "EXAMPLE OIC service",
    }

    crr = cli.construct_RegistrationRequest(request_args=request_args)

    print crr.keys()
    assert _eq(crr.keys(), ['application_name', 'application_type', 'type',
                            'client_id', 'contacts', 'redirect_uris'])


def test_construct_EndSessionRequest():
    cli = Client()
    cli.redirect_uris = ["http://example.com/authz"]
    cli.grant["foo"] = Grant()
    cli.grant["foo"].grant_expiration_time = time.time() + 60
    cli.grant["foo"].code = "access_code"

    resp = AccessTokenResponse(id_token="id_id_id_id",
                               access_token="access", scope=["openid"])

    cli.grant["foo"].tokens.append(Token(resp))

    args = {"redirect_url": "http://example.com/end"}
    esr = cli.construct_EndSessionRequest(state="foo", request_args=args)
    print esr.keys()
    assert _eq(esr.keys(), ['id_token', 'state', "redirect_url"])


def test_construct_OpenIDRequest():
    cli = Client()
    cli.client_id = CLIENT_ID
    cli.client_secret = CLIENT_SECRET
    cli.scope = ["openid", "profile"]
    cli.redirect_uris = ["https://client.example.com/cb"]

    request_args = {"response_type": "code id_token", "state": "af0ifjsldkj"}

    oidr = cli.construct_AuthorizationRequest(request_args=request_args)
    print oidr.keys()
    assert _eq(oidr.keys(), ['nonce', 'state', 'redirect_uri', 'response_type',
                             'client_id', 'scope'])


ARESP = AuthorizationResponse(code="code", state="state000")
TRESP = AccessTokenResponse(access_token="access_token", token_type="bearer",
                            expires_in=600, refresh_token="refresh",
                            scope=["openid"])


def test_userinfo_request():
    cli = Client()
    cli.userinfo_endpoint = "http://example.com/userinfo"

    info = ARESP.to_urlencoded()
    cli.parse_response(AuthorizationResponse, info,
                       sformat="urlencoded", state="state0")

    cli.parse_response(AccessTokenResponse, TRESP.to_json(), state="state0")

    path, body, method, h_args = cli.user_info_request(state="state0")

    assert path == "http://example.com/userinfo?access_token=access_token"
    assert method == "GET"
    assert body is None
    assert h_args == {}

    path, body, method, h_args = cli.user_info_request(method="POST",
                                                       state="state0")

    assert path == "http://example.com/userinfo"
    assert method == "POST"
    assert body == "access_token=access_token"
    assert h_args == {'headers': {
        'content-type': 'application/x-www-form-urlencoded'}}

    path, body, method, h_args = cli.user_info_request(method="POST",
                                                       state="state0")

    assert path == "http://example.com/userinfo"
    assert method == "POST"
    assert body == "access_token=access_token"
    assert h_args == {'headers': {
        'content-type': 'application/x-www-form-urlencoded'}}

#def test_do_user_indo_request():
#    cli = Client()
#    cli.userinfo_endpoint = "http://example.com/userinfo"
#
#    cli.http = MyFakeOICServer(KEYS)

# ----------------------------------------------------------------------------

TREQ = AccessTokenRequest(code="code", redirect_uri="http://example.com/authz",
                          client_id=CLIENT_ID)

AREQ = AuthorizationRequest(response_type="code", client_id="client_id",
                            redirect_uri="http://example.com/authz",
                            scope=["openid"], state="state0", nonce="N0nce")

UIREQ = UserInfoRequest(access_token="access_token")

REGREQ = RegistrationRequest(contacts=["roland.hedberg@adm.umu.se"],
                             redirect_uris=["http://example.org/jqauthz"],
                             application_name="pacubar", client_id=CLIENT_ID,
                             operation="register", application_type="web")

RSREQ = RefreshSessionRequest(id_token="id_token",
                              redirect_url="http://example.com/authz",
                              state="state0")

#key, type, usage, owner="."

alg = "HS256"
ktype = alg2keytype(alg)
keys = KC_SYM_S.get(ktype)
CSREQ = CheckSessionRequest(id_token=IDTOKEN.to_jwt(key=keys,
                                                    algorithm="HS256"))

ESREQ = EndSessionRequest(id_token=IDTOKEN.to_jwt(key=keys,
                                                  algorithm="HS256"),
                          redirect_url="http://example.org/jqauthz",
                          state="state0")

UINFO = Claims(name={"essential": True}, nickname=None,
               email={"essential": True},
               email_verified={"essential": True}, picture=None)

IDT2 = Claims(auth_time={"essential": True,
                         "acr": {"values": ["urn:mace:incommon:iap:silver"]}})

CLAIMS = ClaimsRequest(userinfo=UINFO, id_token=IDT2)

OIDREQ = OpenIDRequest(response_type=["code", "id_token"], client_id=CLIENT_ID,
                       redirect_uri="https://client.example.com/cb",
                       scope="openid profile", state="n-0S6_WzA2Mj",
                       nonce="af0ifjsldkj", max_age=86400, claims=CLAIMS)


def test_server_init():
    srv = Server()
    assert srv

    srv = Server()
    assert srv


def test_parse_urlencoded():
    loc = "http://example.com/userinfo?access_token=access_token"
    srv = Server()
    qdict = srv._parse_urlencoded(loc)
    assert _eq(qdict.keys(), ["access_token"])
    # all values as lists
    assert qdict["access_token"] == ["access_token"]


def test_parse_authorization_request():
    srv = Server()
    qdict = srv.parse_authorization_request(query=AREQ.to_urlencoded())
    assert _eq(qdict.keys(), ['nonce', 'state', 'redirect_uri',
                              'response_type', 'client_id', 'scope'])
    assert qdict["state"] == "state0"


def test_parse_token_request():
    srv = Server()
    qdict = srv.parse_token_request(body=TREQ.to_urlencoded())
    assert qdict.type() == "AccessTokenRequest"
    assert _eq(qdict.keys(), ['code', 'redirect_uri', 'client_id',
                              'grant_type'])
    assert qdict["client_id"] == CLIENT_ID
    assert qdict["code"] == "code"


def test_parse_userinfo_request():
    srv = Server()
    qdict = srv.parse_user_info_request(data=UIREQ.to_urlencoded())
    assert _eq(qdict.keys(), ['access_token'])
    assert qdict["access_token"] == "access_token"

    url = "https://example.org/userinfo?%s" % UIREQ.to_urlencoded()
    qdict = srv.parse_user_info_request(data=url)
    assert _eq(qdict.keys(), ['access_token'])
    assert qdict["access_token"] == "access_token"


def test_parse_registration_request():
    srv = Server()
    request = srv.parse_registration_request(data=REGREQ.to_urlencoded())
    assert request.type() == "RegistrationRequest"
    assert _eq(request.keys(), ['redirect_uris', 'contacts', 'client_id',
                                'application_name', 'operation',
                                'application_type'])
    assert request["application_name"] == "pacubar"
    assert request["operation"] == "register"


def test_parse_refresh_session_request():
    srv = Server()
    request = srv.parse_refresh_session_request(query=RSREQ.to_urlencoded())
    assert request.type() == "RefreshSessionRequest"
    assert _eq(request.keys(), ['id_token', 'state', 'redirect_url'])
    assert request["id_token"] == "id_token"

    url = "https://example.org/userinfo?%s" % RSREQ.to_urlencoded()
    request = srv.parse_refresh_session_request(url=url)
    assert request.type() == "RefreshSessionRequest"
    assert _eq(request.keys(), ['id_token', 'state', 'redirect_url'])
    assert request["id_token"] == "id_token"


def test_parse_check_session_request():
    srv = Server()
    srv.keyjar = KEYJ
    request = srv.parse_check_session_request(query=CSREQ.to_urlencoded())
    assert request.type() == "IdToken"
    assert _eq(request.keys(), ['nonce', 'sub', 'aud', 'iss', 'exp', 'iat'])
    assert request["aud"] == ["client_1"]


def test_parse_end_session_request():
    srv = Server()
    srv.keyjar = KEYJ

    request = srv.parse_end_session_request(query=ESREQ.to_urlencoded())
    assert request.type() == "EndSessionRequest"
    assert _eq(request.keys(), ['id_token', 'redirect_url', 'state'])
    assert request["state"] == "state0"

    assert request["id_token"]["aud"] == ["client_1"]


def test_parse_open_id_request():
    srv = Server()
    srv.keyjar = KEYJ

    request = srv.parse_open_id_request(data=OIDREQ.to_json(), sformat="json")
    assert request.type() == "OpenIDRequest"
    print request.keys()
    assert _eq(request.keys(), ['nonce', 'claims', 'state', 'redirect_uri',
                                'response_type', 'client_id', 'scope',
                                'max_age'])
    assert request["nonce"] == "af0ifjsldkj"

    print request["claims"]

    #assert request.userinfo.format == "signed"
    print request["claims"]["userinfo"]
    assert "email" in request["claims"]["userinfo"]


def test_make_id_token():
    srv = Server()
    srv.keyjar = KEYJ
    srv.keyjar["http://oic.example/rp"] = KC_RSA

    session = {"sub": "user0",
               "client_id": "http://oic.example/rp"}
    issuer = "http://oic.example/idp"
    code = "abcdefghijklmnop"
    _idt = srv.make_id_token(session, loa="2", issuer=issuer,
                             code=code, access_token="access_token")

    algo = "RS256"
    ckey = srv.keyjar.get_signing_key(alg2keytype(algo), session["client_id"])
    _signed_jwt = _idt.to_jwt(key=ckey, algorithm="RS256")

    idt = IdToken().from_jwt(_signed_jwt, keyjar=srv.keyjar)
    print idt
    header = unpack(_signed_jwt)

    lha = left_hash(code, func="HS" + header[0]["alg"][-3:])
    assert lha == idt["c_hash"]

    atr = AccessTokenResponse(id_token=_signed_jwt, access_token="access_token",
                              token_type="Bearer")
    atr["code"] = code
    assert atr.verify(keyjar=srv.keyjar)


if __name__ == "__main__":
    #t = TestOICClient()
    #t.setup_class()
    #t.test_do_check_session_request()

    test_userinfo_request()
########NEW FILE########
__FILENAME__ = test_oic_consumer
from oic.oic.message import AccessTokenResponse, AuthorizationResponse
from oic.utils.keyio import KeyBundle, keybundle_from_local_file
from oic.utils.keyio import KeyJar

__author__ = 'rohe0002'

from oic.oic import Server
from oic.oauth2 import rndstr

from oic.oic.consumer import Consumer
from oic.oic.consumer import IGNORE
from oic.oic.consumer import clean_response

from oic.utils.time_util import utc_time_sans_frac
from oic.utils.sdb import SessionDB

from fakeoicsrv import MyFakeOICServer

CLIENT_SECRET = "abcdefghijklmnop"
CLIENT_ID = "client_1"

KC_SYM_VS = KeyBundle({"kty": "oct", "key": "abcdefghijklmnop", "use": "ver"})
KC_SYM_S = KeyBundle({"kty": "oct", "key": "abcdefghijklmnop", "use": "sig"})

KC_RSA = keybundle_from_local_file("../oidc_example/op1/certs/mycert.key",
                                   "rsa", ["ver", "sig"])

SRVKEYS = KeyJar()
SRVKEYS[""] = [KC_RSA]
SRVKEYS["client_1"] = [KC_SYM_VS, KC_RSA]

CLIKEYS = KeyJar()
CLIKEYS["http://localhost:8088"] = [KC_RSA]
CLIKEYS[""] = [KC_SYM_VS]
CLIKEYS["http://example.com"] = [KC_RSA]

BASE_ENVIRON = {'SERVER_PROTOCOL': 'HTTP/1.1',
                'REQUEST_METHOD': 'GET',
                'QUERY_STRING': '',
                'HTTP_CONNECTION': 'keep-alive',
                'REMOTE_ADDR': '127.0.0.1',
                'wsgi.url_scheme': 'http',
                'SERVER_PORT': '8087',
                'PATH_INFO': '/register',
                'HTTP_HOST': 'localhost:8087',
                'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',

                'HTTP_ACCEPT_LANGUAGE': 'sv-se',
                'CONTENT_TYPE': 'text/plain',
                'REMOTE_HOST': '1.0.0.127.in-addr.arpa',
                'HTTP_ACCEPT_ENCODING': 'gzip, deflate',
                'COMMAND_MODE': 'unix2003'}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://localhost:8088",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    "userinfo_endpoint": "http://localhost:8088/userinfo",
    "flows_supported": ["code", "token"],
}

CONFIG = {
    "authz_page": "authz",
    "scope": ["openid"],
    "response_type": "code",
    "request_method": "parameter",
    #"temp_dir": "./tmp",
    #"flow_type":
    "password": "hemligt",
    "max_age": 3600,
    #client_secret
    "user_info": {
        "name": None,
    }
}

CLIENT_CONFIG = {"client_id": CLIENT_ID}


def start_response(status=200, headers=None):
    if headers is None:
        return "status=%s, headers={}" % (status, )
    else:
        return "status=%s, headers=%s" % (status, headers)


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_clean_response():
    atr = AccessTokenResponse(access_token="access_token",
                              token_type="bearer", expires_in=600,
                              refresh_token="refresh", steps=39, stalls="yes")

    catr = clean_response(atr)
    atr_keys = atr.keys()
    catr_keys = catr.keys()
    assert _eq(atr_keys, ['token_type', 'access_token', 'expires_in',
                          'refresh_token', 'steps', 'stalls'])
    assert _eq(catr_keys, ['token_type', 'access_token', 'expires_in',
                           'refresh_token'])


AUTHZ_URL = "http://example.com/authorization"
AUTHZ_ORG_URL = "http://example.org/authorization"


class TestOICConsumer():
    def setup_class(self):
        self.consumer = Consumer(SessionDB(), CONFIG, CLIENT_CONFIG,
                                 SERVER_INFO)
        self.consumer.client_secret = CLIENT_SECRET

    def test_init(self):
        assert self.consumer

    def test_backup_keys(self):
        keys = self.consumer.__dict__.keys()
        print keys
        _dict = self.consumer.dictionary()
        print _dict.keys()
        dkeys = [key for key in keys if key not in _dict.keys()]
        print dkeys
        assert _eq(dkeys, IGNORE)

    def test_backup_restore(self):
        _dict = self.consumer.__dict__.items()

        self.consumer._backup("sid")
        self.consumer.restore("sid")

        assert _dict == self.consumer.__dict__.items()

        self.consumer.authorization_endpoint = AUTHZ_URL

        assert _dict != self.consumer.__dict__.items()

        self.consumer.restore("sid")

        assert _dict == self.consumer.__dict__.items()

    def test_backup_restore_update(self):
        self.consumer.authorization_endpoint = AUTHZ_URL
        self.consumer.token_endpoint = "http://example.com/token"
        self.consumer.userinfo_endpoint = "http://example.com/userinfo"

        self.consumer._backup("sid")

        self.consumer.authorization_endpoint = AUTHZ_ORG_URL
        self.consumer.token_endpoint = "http://example.org/token"
        self.consumer.userinfo_endpoint = ""

        assert self.consumer.authorization_endpoint == AUTHZ_ORG_URL
        assert self.consumer.token_endpoint == "http://example.org/token"
        assert self.consumer.userinfo_endpoint == ""

        self.consumer.update("sid")

        assert self.consumer.authorization_endpoint == AUTHZ_ORG_URL
        assert self.consumer.token_endpoint == "http://example.org/token"
        assert self.consumer.userinfo_endpoint == "http://example.com/userinfo"

    def test_begin(self):
        self.consumer.authorization_endpoint = AUTHZ_URL
        self.consumer.keyjar[""].append(KC_RSA)
        #self.consumer.keyjar.set_sign_key(rsapub, "rsa")
        #self.consumer.keyjar.set_verify_key(rsapub, "rsa")

        srv = Server()
        srv.keyjar = SRVKEYS
        print "redirect_uris", self.consumer.redirect_uris
        print "config", self.consumer.config
        location = self.consumer.begin("openid", "code")
        print location
        authreq = srv.parse_authorization_request(url=location)
        print authreq.keys()
        assert _eq(authreq.keys(), ['request', 'state', 'max_age', 'claims',
                                    'response_type', 'client_id', 'scope',
                                    'redirect_uri'])

        assert authreq["state"] == self.consumer.state
        assert authreq["scope"] == self.consumer.config["scope"]
        assert authreq["client_id"] == self.consumer.client_id

    def test_begin_file(self):
        self.consumer.config["request_method"] = "file"
        self.consumer.config["temp_dir"] = "./file"
        self.consumer.config["temp_path"] = "/tmp/"
        self.consumer.config["authz_page"] = "/authz"
        srv = Server()
        srv.keyjar = SRVKEYS

        location = self.consumer.begin("openid", "code",
                                       path="http://localhost:8087")
        print location
        #vkeys = {".":srv.keyjar.get_verify_key()}
        authreq = srv.parse_authorization_request(url=location)
        print authreq.keys()
        assert _eq(authreq.keys(), ['max_age', 'state', 'redirect_uri',
                                    'response_type', 'client_id', 'scope',
                                    'claims', 'request_uri'])

        assert authreq["state"] == self.consumer.state
        assert authreq["scope"] == self.consumer.config["scope"]
        assert authreq["client_id"] == self.consumer.client_id
        assert authreq["redirect_uri"].startswith("http://localhost:8087/authz")

    def test_complete(self):
        mfos = MyFakeOICServer("http://localhost:8088")
        mfos.keyjar = SRVKEYS

        self.consumer.http_request = mfos.http_request
        self.consumer.state = "state0"
        self.consumer.nonce = rndstr()
        self.consumer.redirect_uris = ["https://example.com/cb"]
        args = {
            "client_id": self.consumer.client_id,
            "response_type": "code",
            "scope": ["openid"],
        }

        result = self.consumer.do_authorization_request(
            state=self.consumer.state, request_args=args)
        assert result.status_code == 302
        print "redirect_uris", self.consumer.redirect_uris
        print result.headers["location"]

        assert result.headers["location"].startswith(
            self.consumer.redirect_uris[0])
        _, query = result.headers["location"].split("?")

        #vkeys = {".": self.consumer.keyjar.get_verify_key()}

        self.consumer.parse_response(AuthorizationResponse, info=query,
                                     sformat="urlencoded")

        resp = self.consumer.complete()
        print resp
        assert resp.type() == "AccessTokenResponse"
        print resp.keys()
        assert _eq(resp.keys(), ['token_type', 'state', 'access_token',
                                 'scope', 'expires_in', 'refresh_token'])

        assert resp["state"] == self.consumer.state

    def test_parse_authz(self):
        mfos = MyFakeOICServer("http://localhost:8088")
        mfos.keyjar = SRVKEYS

        self.consumer.http_request = mfos.http_request
        self.consumer.state = "state0"
        self.consumer.nonce = rndstr()
        args = {
            "client_id": self.consumer.client_id,
            "response_type": "code",
            "scope": ["openid"],
        }

        result = self.consumer.do_authorization_request(
            state=self.consumer.state, request_args=args)

        print self.consumer.sdb.keys()
        print self.consumer.sdb["state0"].keys()
        part = self.consumer.parse_authz(query=result.headers["location"])
        print part
        atr = part[0]
        assert part[1] is None
        assert part[2] is None

        assert atr.type() == "AuthorizationResponse"
        assert atr["state"] == "state0"
        assert "code" in atr

    def test_parse_authz_implicit(self):
        self.consumer.config["response_type"] = "implicit"

        args = {
            "client_id": self.consumer.client_id,
            "response_type": "implicit",
            "scope": ["openid"],
        }

        result = self.consumer.do_authorization_request(
            state=self.consumer.state, request_args=args)

        part = self.consumer.parse_authz(query=result.headers["location"])
        print part
        assert part[0] is None
        atr = part[1]
        assert part[2] is None

        assert atr.type() == "AccessTokenResponse"
        assert atr["state"] == "state0"
        assert "access_token" in atr


def test_complete_secret_auth():
    consumer = Consumer(SessionDB(), CONFIG, CLIENT_CONFIG, SERVER_INFO)
    mfos = MyFakeOICServer("http://localhost:8088")
    mfos.keyjar = SRVKEYS
    consumer.http_request = mfos.http_request
    consumer.redirect_uris = ["http://example.com/authz"]
    consumer.state = "state0"
    consumer.nonce = rndstr()
    consumer.client_secret = "hemlig"
    consumer.secret_type = "basic"
    del consumer.config["password"]

    args = {
        "client_id": consumer.client_id,
        "response_type": "code",
        "scope": ["openid"],
    }

    result = consumer.do_authorization_request(state=consumer.state,
                                               request_args=args)
    assert result.status_code == 302
    assert result.headers["location"].startswith(consumer.redirect_uris[0])
    _, query = result.headers["location"].split("?")

    consumer.parse_response(AuthorizationResponse, info=query,
                            sformat="urlencoded")

    resp = consumer.complete()
    print resp
    assert resp.type() == "AccessTokenResponse"
    print resp.keys()
    assert _eq(resp.keys(), ['token_type', 'state', 'access_token',
                             'scope', 'expires_in', 'refresh_token'])

    assert resp["state"] == consumer.state


def test_complete_auth_token():
    consumer = Consumer(SessionDB(), CONFIG, CLIENT_CONFIG, SERVER_INFO)
    mfos = MyFakeOICServer("http://localhost:8088")
    mfos.keyjar = SRVKEYS
    consumer.http_request = mfos.http_request
    consumer.redirect_uris = ["http://example.com/authz"]
    consumer.state = "state0"
    consumer.nonce = rndstr()
    consumer.client_secret = "hemlig"
    consumer.secret_type = "basic"
    consumer.config["response_type"] = ["code", "token"]

    args = {
        "client_id": consumer.client_id,
        "response_type": consumer.config["response_type"],
        "scope": ["openid"],
    }

    result = consumer.do_authorization_request(state=consumer.state,
                                               request_args=args)
    consumer._backup("state0")

    assert result.status_code == 302
    #assert result.location.startswith(consumer.redirect_uri[0])
    _, query = result.headers["location"].split("?")
    print query
    part = consumer.parse_authz(query=query)
    print part
    auth = part[0]
    acc = part[1]
    assert part[2] is None

    #print auth.dictionary()
    #print acc.dictionary()
    assert auth.type() == "AuthorizationResponse"
    assert acc.type() == "AccessTokenResponse"
    print auth.keys()
    assert _eq(auth.keys(), ['nonce', 'code', 'access_token', 'expires_in',
                             'token_type', 'state', 'scope', 'refresh_token'])
    assert _eq(acc.keys(), ['token_type', 'state', 'access_token', 'scope',
                            'expires_in', 'refresh_token'])


def test_complete_auth_token_idtoken():
    consumer = Consumer(SessionDB(), CONFIG, CLIENT_CONFIG, SERVER_INFO)
    consumer.keyjar = CLIKEYS
    mfos = MyFakeOICServer("http://localhost:8088")
    mfos.keyjar = SRVKEYS
    consumer.http_request = mfos.http_request
    consumer.redirect_uris = ["http://example.com/authz"]
    consumer.state = "state0"
    consumer.nonce = rndstr()
    consumer.client_secret = "hemlig"
    consumer.secret_type = "basic"
    consumer.config["response_type"] = ["id_token", "token"]

    args = {
        "client_id": consumer.client_id,
        "response_type": consumer.config["response_type"],
        "scope": ["openid"],
    }

    result = consumer.do_authorization_request(state=consumer.state,
                                               request_args=args)
    consumer._backup("state0")

    assert result.status_code == 302
    #assert result.location.startswith(consumer.redirect_uri[0])
    _, query = result.headers["location"].split("?")
    print query
    part = consumer.parse_authz(query=query)
    print part
    auth = part[0]
    acc = part[1]
    assert part[2] is None

    #print auth.dictionary()
    #print acc.dictionary()
    assert auth is None
    assert acc.type() == "AccessTokenResponse"
    assert _eq(acc.keys(), ['access_token', 'id_token', 'expires_in',
                            'token_type', 'state', 'scope'])


def test_userinfo():
    consumer = Consumer(SessionDB(), CONFIG, CLIENT_CONFIG, SERVER_INFO)
    consumer.keyjar = CLIKEYS
    mfos = MyFakeOICServer("http://localhost:8088")
    mfos.keyjar = SRVKEYS
    consumer.http_request = mfos.http_request
    consumer.redirect_uris = ["http://example.com/authz"]
    consumer.state = "state0"
    consumer.nonce = rndstr()
    consumer.secret_type = "basic"
    consumer.set_client_secret("hemligt")
    consumer.keyjar = CLIKEYS

    args = {
        "client_id": consumer.client_id,
        "response_type": "code",
        "scope": ["openid"],
    }

    result = consumer.do_authorization_request(state=consumer.state,
                                               request_args=args)
    assert result.status_code == 302
    assert result.headers["location"].startswith(consumer.redirect_uris[0])
    _, query = result.headers["location"].split("?")

    consumer.parse_response(AuthorizationResponse, info=query,
                            sformat="urlencoded")

    consumer.complete()

    result = consumer.get_user_info()
    print result
    assert result.type() == "OpenIDSchema"
    assert _eq(result.keys(), ['name', 'email', 'verified', 'nickname', 'sub'])


def real_test_discover():
    c = Consumer(None, None)

    principal = "nav@connect-op.heroku.com"

    res = c.discover(principal)
    print res
    assert res.type() == "ProviderConfigurationResponse"
    print res.keys()
    assert _eq(res.keys(), ['registration_endpoint', 'scopes_supported',
                            'identifiers_supported', 'token_endpoint',
                            'flows_supported', 'version', 'userinfo_endpoint',
                            'authorization_endpoint', 'x509_url', 'issuer'])
    assert res.version == "3.0"
    print res.flows_supported
    assert _eq(res.flows_supported, ['code', 'token', 'id_token',
                                     'code token', 'code id_token',
                                     'id_token token'])


def test_discover():
    c = Consumer(None, None)
    mfos = MyFakeOICServer("http://localhost:8088")
    mfos.keyjar = SRVKEYS
    c.http_request = mfos.http_request

    principal = "foo@example.com"

    res = c.discover(principal)
    assert res == "http://localhost:8088/"

#def test_discover_redirect():
#    c = Consumer(None, None)
#    mfos = MyFakeOICServer(name="http://example.com/")
#    c.http_request = mfos.http_request
#
#    principal = "bar@example.org"
#
#    res = c.discover(principal)
#    assert res == "http://example.net/providerconf"


def test_provider_config():
    c = Consumer(None, None)
    mfos = MyFakeOICServer("http://example.com")
    mfos.keyjar = SRVKEYS
    c.http_request = mfos.http_request

    principal = "foo@example.com"

    res = c.discover(principal)
    info = c.provider_config(res)
    assert info.type() == "ProviderConfigurationResponse"
    print info.keys()
    assert _eq(info.keys(), ['registration_endpoint', 'jwks_uri',
                             'check_session_endpoint',
                             'refresh_session_endpoint', 'register_endpoint',
                             'subject_types_supported',
                             'token_endpoint_auth_methods_supported',
                             'id_token_signing_alg_values_supported',
                             'grant_types_supported', 'user_info_endpoint',
                             'claims_parameter_supported',
                             'request_parameter_supported',
                             'discovery_endpoint', 'issuer',
                             'authorization_endpoint', 'scopes_supported',
                             'require_request_uri_registration',
                             'identifiers_supported', 'token_endpoint',
                             'request_uri_parameter_supported', 'version',
                             'response_types_supported',
                             'end_session_endpoint', 'flows_supported'])

    assert info["end_session_endpoint"] == "http://example.com/end_session"


def test_client_register():
    c = Consumer(None, None)

    c.application_type = "web"
    c.application_name = "My super service"
    c.redirect_uris = ["http://example.com/authz"]
    c.contact = ["foo@example.com"]

    mfos = MyFakeOICServer("http://example.com")
    mfos.keyjar = SRVKEYS
    c.http_request = mfos.http_request
    location = c.discover("foo@example.com")
    info = c.provider_config(location)

    c.register(info["registration_endpoint"])
    assert c.client_id is not None
    assert c.client_secret is not None
    assert c.registration_expires > utc_time_sans_frac()


if __name__ == "__main__":
    #t = TestOICConsumer()
    #t.setup_class()
    #t.test_begin()
    test_client_register()
########NEW FILE########
__FILENAME__ = test_oic_message
# -*- coding: utf-8 -*-
__author__ = 'rohe0002'

import json

from oic.oic.message import ProviderConfigurationResponse, RegistrationResponse, AuthorizationRequest
from oic.oic.message import msg_ser
from oic.oic.message import claims_ser
from oic.oic.message import RegistrationRequest
from oic.oic.message import claims_deser
from oic.oic.message import AddressClaim
from oic.oic.message import address_deser
from oic.oic.message import Claims


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_ProviderConfigurationResponse():
    resp = {
        "authorization_endpoint": "https://server.example.com/connect/authorize",
        "issuer": "https://server.example.com",
        "token_endpoint": "https://server.example.com/connect/token",
        "token_endpoint_auth_methods_supported": ["client_secret_basic",
                                                  "private_key_jwt"],
        "userinfo_endpoint": "https://server.example.com/connect/user",
        "check_id_endpoint": "https://server.example.com/connect/check_id",
        "refresh_session_endpoint": "https://server.example.com/connect/refresh_session",
        "end_session_endpoint": "https://server.example.com/connect/end_session",
        "jwk_url": "https://server.example.com/jwk.json",
        "registration_endpoint": "https://server.example.com/connect/register",
        "scopes_supported": ["openid", "profile", "email", "address", "phone"],
        "response_types_supported": ["code", "code id_token", "token id_token"],
        "acrs_supported": ["1", "2", "http://id.incommon.org/assurance/bronze"],
        "user_id_types_supported": ["public", "pairwise"],
        "userinfo_algs_supported": ["HS256", "RS256", "A128CBC", "A128KW",
                                    "RSA1_5"],
        "id_token_algs_supported": ["HS256", "RS256", "A128CBC", "A128KW",
                                    "RSA1_5"],
        "request_object_algs_supported": ["HS256", "RS256", "A128CBC", "A128KW",
                                          "RSA1_5"]
    }

    pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), "json")

    assert _eq(pcr["user_id_types_supported"], ["public", "pairwise"])
    assert _eq(pcr["acrs_supported"],
               ["1", "2", "http://id.incommon.org/assurance/bronze"])


def test_example_response():
    resp = {
        "version": "3.0",
        "issuer": "https://server.example.com",
        "authorization_endpoint":
            "https://server.example.com/connect/authorize",
        "token_endpoint": "https://server.example.com/connect/token",
        "token_endpoint_auth_methods_supported": ["client_secret_basic",
                                                  "private_key_jwt"],
        "token_endpoint_alg_values_supported": ["RS256", "ES256"],
        "userinfo_endpoint": "https://server.example.com/connect/userinfo",
        "check_session_iframe":
            "https://server.example.com/connect/check_session",
        "end_session_endpoint":
            "https://server.example.com/connect/end_session",
        "jwks_uri": "https://server.example.com/jwks.json",
        "registration_endpoint": "https://server.example.com/connect/register",
        "scopes_supported": ["openid", "profile", "email", "address",
                             "phone", "offline_access"],
        "response_types_supported": ["code", "code id_token", "id_token",
                                     "token id_token"],
        "acr_values_supported": ["urn:mace:incommon:iap:silver",
                                 "urn:mace:incommon:iap:bronze"],
        "subject_types_supported": ["public", "pairwise"],
        "userinfo_signing_alg_values_supported": ["RS256", "ES256", "HS256"],
        "userinfo_encryption_alg_values_supported": ["RSA1_5", "A128KW"],
        "userinfo_encryption_enc_values_supported": ["A128CBC+HS256",
                                                     "A128GCM"],
        "id_token_signing_alg_values_supported": ["RS256", "ES256", "HS256"],
        "id_token_encryption_alg_values_supported": ["RSA1_5", "A128KW"],
        "id_token_encryption_enc_values_supported": ["A128CBC+HS256",
                                                     "A128GCM"],
        "request_object_signing_alg_values_supported": ["none", "RS256",
                                                        "ES256"],
        "display_values_supported": ["page", "popup"],
        "claim_types_supported": ["normal", "distributed"],
        "claims_supported": ["sub", "iss", "auth_time", "acr", "name",
                             "given_name", "family_name", "nickname", "profile",
                             "picture", "website", "email", "email_verified",
                             "locale", "zoneinfo",
                             "http://example.info/claims/groups"],
        "claims_parameter_supported": True,
        "service_documentation":
            "http://server.example.com/connect/service_documentation.html",
        "ui_locales_supported": ["en-US", "en-GB", "en-CA", "fr-FR", "fr-CA"]
    }

    pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), "json")
    rk = resp.keys()
    # parameters with default value if missing
    rk.extend(["grant_types_supported", "request_parameter_supported",
               "request_uri_parameter_supported",
               "require_request_uri_registration"])
    rk.sort()
    pk = pcr.keys()
    pk.sort()
    print rk
    print pk
    assert _eq(pk, rk)


def test_client_registration():
    msg = {
        "application_type": "web",
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example",
        "client_name#ja-Jpan-JP": "",
        "logo_uri": "https://client.example.org/logo.png",
        "subject_type": "pairwise",
        "sector_identifier_uri":
            "https://other.example.net/file_of_redirect_uris.json",
        "token_endpoint_auth_method": "client_secret_basic",
        "jwks_uri": "https://client.example.org/my_public_keys.jwks",
        "userinfo_encrypted_response_alg": "RSA1_5",
        "userinfo_encrypted_response_enc": "A128CBC+HS256",
        "contacts": ["ve7jtb@example.org", "mary@example.org"],
        "request_uris": [
            "https://client.example.org/rf.txt#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA"]
    }

    reg = RegistrationRequest().deserialize(json.dumps(msg), "json")

    assert _eq(msg.keys(), reg.keys())


def test_client_response():
    msg = {
        "client_id": "s6BhdRkqt3",
        "client_secret": "ZJYCqe3GGRvdrudKyZS0XhGv_Z45DuKhCUk0gBR1vZk",
        "client_secret_expires_at": 1577858400,
        "registration_access_token": "this.is.an.access.token.value.ffx83",
        "registration_client_uri":
            "https://server.example.com/connect/register?client_id=s6BhdRkqt3",
        "token_endpoint_auth_method": "client_secret_basic",
        "application_type": "web",
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example",
        "client_name#ja-Jpan-JP": "",
        "logo_uri": "https://client.example.org/logo.png",
        "subject_type": "pairwise",
        "sector_identifier_uri":
            "https://other.example.net/file_of_redirect_uris.json",
        "jwks_uri": "https://client.example.org/my_public_keys.jwks",
        "userinfo_encrypted_response_alg": "RSA1_5",
        "userinfo_encrypted_response_enc": "A128CBC+HS256",
        "contacts": ["ve7jtb@example.org", "mary@example.org"],
        "request_uris": [
            "https://client.example.org/rf.txt#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA"]
    }

    resp = RegistrationResponse().deserialize(json.dumps(msg), "json")

    assert _eq(msg.keys(), resp.keys())


def test_authz_request():
    example = "https://server.example.com/authorize?response_type=token%20id_token&client_id=0acf77d4-b486-4c99-bd76-074ed6a64ddf&redirect_uri=https%3A%2F%2Fclient.example.com%2Fcb&scope=openid%20profile&state=af0ifjsldkj&nonce=n-0S6_WzA2Mj"

    req = AuthorizationRequest().deserialize(example.split("?")[1],
                                             "urlencoded")

    print req.keys()
    assert _eq(req.keys(), ['nonce', 'state', 'redirect_uri', 'response_type',
                            'client_id', 'scope'])

    assert req["response_type"] == ["token", "id_token"]
    assert req["scope"] == ["openid", "profile"]


# def test_idtokenclaim_deser():
#     claims = Claims(weather={"acr": "2"})
#     pre = IDTokenClaim(claims=claims, max_age=3600)
#     idt = idtokenclaim_deser(pre.to_json(), sformat="json")
#     assert _eq(idt.keys(), ['claims', "max_age"])
#
#
# def test_userinfo_deser():
#     CLAIM = Claims(name={"essential": True}, nickname=None,
#                    email={"essential": True},
#                    email_verified={"essential": True}, picture=None)
#
#     pre_uic = UserInfoClaim(claims=CLAIM, format="signed")
#
#     uic = userinfo_deser(pre_uic.to_json(), sformat="json")
#     assert _eq(uic.keys(), ["claims", "format"])


def test_claims_deser_0():
    _dic = {
        "userinfo": {
            "given_name": {"essential": True},
            "nickname": None,
            "email": {"essential": True},
            "email_verified": {"essential": True},
            "picture": None,
            "http://example.info/claims/groups": None
        },
        "id_token": {
            "auth_time": {"essential": True},
            "acr": {"values": ["urn:mace:incommon:iap:silver"]}
        }
    }

    claims = claims_deser(json.dumps(_dic), sformat="json")
    assert _eq(claims.keys(), ["userinfo", "id_token"])


def test_claims_deser():
    pre = Claims(name={"essential": True}, nickname=None,
                 email={"essential": True},
                 email_verified={"essential": True}, picture=None)

    claims = claims_deser(pre.to_json(), sformat="json")
    assert _eq(claims.keys(), ['name', 'nickname', 'email', 'email_verified',
                               'picture'])

    claims = claims_deser(pre.to_dict(), sformat="dict")
    assert _eq(claims.keys(), ['name', 'nickname', 'email', 'email_verified',
                               'picture'])


def test_address_deser():
    pre = AddressClaim(street_address="Kasamark 114", locality="Umea",
                       country="Sweden")

    adc = address_deser(pre.to_json(), sformat="json")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])

    adc = address_deser(pre.to_dict(), sformat="json")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])


def test_msg_ser_json():
    pre = AddressClaim(street_address="Kasamark 114", locality="Umea",
                       country="Sweden")

    ser = msg_ser(pre, "json")

    adc = address_deser(ser, "json")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])


def test_msg_ser_urlencoded():
    pre = AddressClaim(street_address="Kasamark 114", locality="Umea",
                       country="Sweden")

    ser = msg_ser(pre, "urlencoded")

    adc = address_deser(ser, "urlencoded")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])


def test_msg_ser_dict():
    pre = AddressClaim(street_address="Kasamark 114", locality="Umea",
                       country="Sweden")

    ser = msg_ser(pre, "dict")

    adc = address_deser(ser, "dict")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])


def test_msg_ser_dictionary():
    pre = {"street_address": "Kasamark 114", "locality": "Umea",
           "country": "Sweden"}

    ser = msg_ser(pre, "dict")

    adc = address_deser(ser, "dict")
    assert _eq(adc.keys(), ['street_address', 'locality', 'country'])


CLAIMS = Claims(name={"essential": True}, nickname=None,
                email={"essential": True},
                email_verified={"essential": True}, picture=None)


def test_claims_ser_json():
    claims = claims_deser(claims_ser(CLAIMS, "json"), sformat="json")
    assert _eq(claims.keys(), ['name', 'nickname', 'email', 'email_verified',
                               'picture'])


def test_registration_request():
    req = RegistrationRequest(operation="register", default_max_age=10,
                              require_auth_time=True, default_acr="foo",
                              application_type="web",
                              redirect_uris=["https://example.com/authz_cb"])
    js = req.to_json()
    print js
    assert js == '{"redirect_uris": ["https://example.com/authz_cb"], "application_type": "web", "default_acr": "foo", "require_auth_time": true, "operation": "register", "default_max_age": 10}'
    ue = req.to_urlencoded()
    print ue
    assert ue == 'redirect_uris=https%3A%2F%2Fexample.com%2Fauthz_cb&application_type=web&default_acr=foo&require_auth_time=True&operation=register&default_max_age=10'


if __name__ == "__main__":
    test_claims_deser_0()
########NEW FILE########
__FILENAME__ = test_oic_provider
from mako.lookup import TemplateLookup
from oic.oauth2 import rndstr
from oic.utils.authn.authn_context import AuthnBroker
from oic.utils.authn.client import verify_client
from oic.utils.authn.user import UserAuthnMethod
from oic.utils.authz import AuthzHandling
from oic.utils.userinfo import UserInfo

from oic.exception import RedirectURIError

from oic.utils.keyio import KeyBundle
from oic.utils.keyio import KeyJar
from oic.utils.keyio import keybundle_from_local_file

from oic.oic.message import AuthorizationRequest
from oic.oic.message import RegistrationResponse
from oic.oic.message import OpenIDSchema
from oic.oic.message import AccessTokenResponse
from oic.oic.message import AccessTokenRequest
from oic.oic.message import TokenErrorResponse
from oic.oic.message import AuthorizationResponse
from oic.oic.message import UserInfoRequest
from oic.oic.message import CheckSessionRequest
from oic.oic.message import RegistrationRequest
from oic.oic.message import IdToken

from oic.utils.sdb import SessionDB
from oic.oic import Client
from oic.oic import make_openid_request

from oic.oic.consumer import Consumer
from oic.oic.provider import Provider

from oic.utils.time_util import epoch_in_a_while

__author__ = 'rohe0002'

CLIENT_CONFIG = {
    "client_id": "number5",
    "ca_certs": "/usr/local/etc/oic/ca_certs.txt",
}

CONSUMER_CONFIG = {
    "authz_page": "/authz",
    #"password": args.passwd,
    "scope": ["openid"],
    "response_type": ["code"],
    #"expire_in": 600,
    "user_info": {
        "name": None,
        "email": None,
        "nickname": None
    },
    "request_method": "param"
}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://connect-op.heroku.com",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    #"userinfo_endpoint":"http://localhost:8088/user_info",
    #"check_id_endpoint":"http://localhost:8088/id_token",
    #"registration_endpoint":"https://connect-op.heroku.com/connect/client",
    #"scopes_supported":["openid","profile","email","address","PPID"],
    "flows_supported": ["code", "token", "code token"],
    #"identifiers_supported":["public","ppid"],
    #"x509_url":"https://connect-op.heroku.com/cert.pem"
}

CLIENT_SECRET = "abcdefghijklmnop"
CLIENT_ID = "client_1"

KC_SYM = KeyBundle([{"kty": "oct", "key": CLIENT_SECRET, "use": "ver"},
                     {"kty": "oct", "key": CLIENT_SECRET, "use": "sig"}])
KC_SYM2 = KeyBundle([{"kty": "oct", "key": "drickyoughurt", "use": "sig"},
                      {"kty": "oct", "key": "drickyoughurt", "use": "ver"}])

KC_RSA = keybundle_from_local_file("../oidc_example/op1/certs/mycert.key",
                                   "RSA", ["ver", "sig"])

KEYJAR = KeyJar()
KEYJAR[CLIENT_ID] = [KC_SYM, KC_RSA]
KEYJAR["number5"] = [KC_SYM2, KC_RSA]
KEYJAR[""] = KC_RSA

CDB = {
    "number5": {
        "password": "hemligt",
        "client_secret": "drickyoughurt",
        #"jwk_key": CONSUMER_CONFIG["key"],
        "redirect_uris": [("http://localhost:8087/authz", None)],
    },
    "a1b2c3": {
        "redirect_uris": [("http://localhost:8087/authz", None)]
    },
    "client0": {
        "redirect_uris": [("http://www.example.org/authz", None)]
    },
    CLIENT_ID: {
        "client_secret": CLIENT_SECRET,
    }

}

USERDB = {
    "user": {
        "name": "Hans Granberg",
        "nickname": "Hasse",
        "email": "hans@example.org",
        "verified": False,
        "sub": "user"
    },
    "username": {
        "name": "Linda Lindgren",
        "nickname": "Linda",
        "email": "linda@example.com",
        "verified": True,
        "sub": "username"
    }
}

URLMAP = {CLIENT_ID: ["https://example.com/authz"]}

PASSWD = {"user": "password"}

ROOT = '../oc3/'
tl = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                    module_directory=ROOT + 'modules',
                    input_encoding='utf-8', output_encoding='utf-8')


class DummyAuthn(UserAuthnMethod):
    def __init__(self, srv, user):
        UserAuthnMethod.__init__(self, srv)
        self.user = user

    def authenticated_as(self, cookie=None,  **kwargs):
        return {"uid": self.user}

#AUTHN = UsernamePasswordMako(None, "login.mako", tl, PASSWD, "authenticated")
AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add("UNDEFINED", DummyAuthn(None, "username"))

# dealing with authorization
AUTHZ = AuthzHandling()
SYMKEY = rndstr(16)  # symmetric key used to encrypt cookie info
USERINFO = UserInfo(USERDB)

provider_init = Provider("pyoicserv", SessionDB(), CDB, AUTHN_BROKER, USERINFO,
                         AUTHZ, verify_client, SYMKEY, urlmap=URLMAP,
                         keyjar=KEYJAR)


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_server_init():
    server = provider_init

    assert server
    assert server.authn_broker == AUTHN_BROKER
    print server.urlmap
    assert server.urlmap["client_1"] == ["https://example.com/authz"]


def test_server_authorization_endpoint():
    server = provider_init

    bib = {"scope": ["openid"],
           "state": "id-6da9ca0cc23959f5f33e8becd9b08cae",
           "redirect_uri": "http://localhost:8087/authz",
           "response_type": ["code"],
           "client_id": "a1b2c3",
           "nonce": "Nonce"}

    arq = AuthorizationRequest(**bib)

    resp = server.authorization_endpoint(request=arq.to_urlencoded())

    print resp.message
    assert resp.message


def test_server_authorization_endpoint_request():
    server = provider_init

    bib = {"scope": ["openid"],
           "state": "id-6da9ca0cc23959f5f33e8becd9b08cae",
           "redirect_uri": "http://localhost:8087/authz",
           "response_type": ["code", "id_token"],
           "client_id": "a1b2c3",
           "nonce": "Nonce",
           "prompt": ["none"]}

    req = AuthorizationRequest(**bib)
    # want to be someone else !
    ic = {"sub": {"value": "userX"}}
    _keys = server.keyjar.get_signing_key(key_type="RSA")
    req["request"] = make_openid_request(req, _keys, idtoken_claims=ic,
                                         algorithm="RS256")

    resp = server.authorization_endpoint(request=req.to_urlencoded())

    print resp
    assert "error=login_required" in resp.message


def test_server_authorization_endpoint_id_token():
    provider = provider_init

    bib = {"scope": ["openid"],
           "state": "id-6da9ca0cc23959f5f33e8becd9b08cae",
           "redirect_uri": "http://localhost:8087/authz",
           "response_type": ["code", "id_token"],
           "client_id": "a1b2c3",
           "nonce": "Nonce",
           "prompt": ["none"]}

    req = AuthorizationRequest(**bib)
    AREQ = AuthorizationRequest(response_type="code",
                                client_id="client_1",
                                redirect_uri="http://example.com/authz",
                                scope=["openid"], state="state000")

    sdb = SessionDB()
    sid = sdb.create_authz_session("userX", AREQ)

    _info = sdb[sid]
    _user_info = IdToken(iss="https://foo.example.om", sub="foo",
                         aud=bib["client_id"], exp=epoch_in_a_while(minutes=10),
                         acr="2", nonce=bib["nonce"])

    print provider.keyjar.issuer_keys
    print _user_info.to_dict()
    idt = provider.id_token_as_signed_jwt(_info, access_token="access_token",
                                          user_info=_user_info)

    req["id_token"] = idt

    QUERY_STRING = req.to_urlencoded()

    resp = provider.authorization_endpoint(request=QUERY_STRING)

    print resp
    assert "error=login_required" in resp.message


def test_server_authenticated():
    server = provider_init
    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO, )
    cons.debug = True
    cons.keyjar[""] = KC_RSA

    location = cons.begin("openid", "code", path="http://localhost:8087")

    QUERY_STRING = location.split("?")[1]
    print QUERY_STRING
    resp = server.authorization_endpoint(request=QUERY_STRING)

    print resp.message

    assert resp.message.startswith("http://localhost:8087/authz")

    part = cons.parse_authz(query=location)
    
    aresp = part[0]
    assert part[1] is None
    assert part[2] is None

    #aresp = client.parse_response(AuthorizationResponse, location,
    #                              format="urlencoded",
    #                              state="id-6da9ca0cc23959f5f33e8becd9b08cae")

    print aresp.keys()
    assert aresp.type() == "AuthorizationResponse"
    assert _eq(aresp.keys(), ['request', 'state', 'redirect_uri',
                              'response_type', 'client_id', 'claims', 'scope'])

    print cons.grant[cons.state].keys()
    assert _eq(cons.grant[cons.state].keys(), ['tokens', 'id_token', 'exp_in',
                                               'seed', 'grant_expiration_time'])


def test_server_authenticated_1():
    server = provider_init
    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO, )
    cons.debug = True
    cons.keyjar[""] = KC_RSA

    location = cons.begin("openid", "code", path="http://localhost:8087")

    resp = server.authorization_endpoint(request=location.split("?")[1])

    print resp
    aresp = cons.parse_response(AuthorizationResponse, location,
                                sformat="urlencoded")

    print aresp.keys()
    assert aresp.type() == "AuthorizationResponse"
    assert _eq(aresp.keys(), ['request', 'state', 'redirect_uri', 'claims',
                              'response_type', 'client_id', 'scope'])


def test_server_authenticated_2():
    server = provider_init
    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO, )
    cons.debug = True
    cons.keyjar[""] = KC_RSA

    location = cons.begin(scope="openid email claims_in_id_token",
                          response_type="code id_token",
                          path="http://localhost:8087")

    print location
    resp = server.authorization_endpoint(request=location.split("?")[1])

    print resp.message

    part = cons.parse_authz(resp.message)

    print part
    aresp = part[0]
    assert part[1] is None
    assert part[2] is not None

    #aresp = cons.parse_response(AuthorizationResponse, location,
    #                            sformat="urlencoded")

    print aresp.keys()
    assert aresp.type() == "AuthorizationResponse"
    assert _eq(aresp.keys(), ['scope', 'state', 'code', 'id_token'])

    print cons.grant[cons.state].keys()
    assert _eq(cons.grant[cons.state].keys(), ['code', 'id_token', 'tokens',
                                               'exp_in',
                                               'grant_expiration_time', 'seed'])
    id_token = part[2]
    assert isinstance(id_token, IdToken)
    print id_token.keys()
    assert _eq(id_token.keys(), ['c_hash', 'sub', 'iss', 'acr', 'exp', 'iat',
                                 'aud', 'nonce'])


def test_server_authenticated_token():
    server = provider_init

    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO, )
    cons.debug = True
    cons.keyjar[""] = KC_RSA

    location = cons.begin("openid", response_type="token",
                          path="http://localhost:8087")

    resp = server.authorization_endpoint(request=location.split("?")[1])

    txt = resp.message
    assert "access_token=" in txt
    assert "token_type=Bearer" in txt


def test_server_authenticated_none():
    server = provider_init
    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO, )
    cons.debug = True
    cons.keyjar[""] = KC_RSA

    location = cons.begin("openid", response_type="none",
                          path="http://localhost:8087")

    resp = server.authorization_endpoint(request=location.split("?")[1])

    assert resp.message.startswith("http://localhost:8087/authz")
    query_part = resp.message.split("?")[1]
    print query_part
    assert "state" in query_part
    

def test_token_endpoint():
    server = provider_init

    authreq = AuthorizationRequest(state="state",
                                   redirect_uri="http://example.com/authz",
                                   client_id=CLIENT_ID)

    _sdb = server.sdb
    sid = _sdb.token.key(user="sub", areq=authreq)
    access_grant = _sdb.token(sid=sid)
    _sdb[sid] = {
        "oauth_state": "authz",
        "sub": "sub",
        "authzreq": "",
        "client_id": CLIENT_ID,
        "code": access_grant,
        "code_used": False,
        "scope": ["openid"],
        "redirect_uri": "http://example.com/authz"
    }

    # Construct Access token request
    areq = AccessTokenRequest(code=access_grant, client_id=CLIENT_ID,
                              redirect_uri="http://example.com/authz",
                              client_secret=CLIENT_SECRET)

    txt = areq.to_urlencoded()

    resp = server.token_endpoint(request=txt)
    print resp
    atr = AccessTokenResponse().deserialize(resp.message, "json")
    print atr.keys()
    assert _eq(atr.keys(), ['token_type', 'id_token', 'access_token', 'scope',
                            'expires_in', 'refresh_token'])


def test_token_endpoint_unauth():
    server = provider_init

    authreq = AuthorizationRequest(state="state",
                                   redirect_uri="http://example.com/authz",
                                   client_id="client_1")

    _sdb = server.sdb
    sid = _sdb.token.key(user="sub", areq=authreq)
    access_grant = _sdb.token(sid=sid)
    _sdb[sid] = {
        "oauth_state": "authz",
        "sub": "sub",
        "authzreq": "",
        "client_id": "client_1",
        "code": access_grant,
        "code_used": False,
        "scope": ["openid"],
        "redirect_uri": "http://example.com/authz"
    }

    # Construct Access token request
    areq = AccessTokenRequest(code=access_grant,
                              redirect_uri="http://example.com/authz",
                              client_id="client_1", client_secret="secret",)

    print areq.to_dict()
    txt = areq.to_urlencoded()

    resp = server.token_endpoint(request=txt, remote_user="client2",
                                 request_method="POST")
    print resp
    atr = TokenErrorResponse().deserialize(resp.message, "json")
    print atr.keys()
    assert _eq(atr.keys(), ['error'])


def test_authz_endpoint():
    server = provider_init

    cli = Client()
    cli.redirect_uris = ["http://www.example.org/authz"]
    cli.client_id = "client0"
    cli.state = "_state_"
    args = {"response_type": ["code", "token"], "scope": ["openid"]}
    req = cli.construct_AuthorizationRequest(request_args=args)

    resp = server.authorization_endpoint(request=req.to_urlencoded())
    print resp.message
    assert "token_type=Bearer" in resp.message
    assert "code=" in resp.message


def test_idtoken():
    server = provider_init
    AREQ = AuthorizationRequest(response_type="code", client_id=CLIENT_ID,
                                redirect_uri="http://example.com/authz",
                                scope=["openid"], state="state000")

    sid = server.sdb.create_authz_session("sub", AREQ)
    session = server.sdb[sid]

    id_token = server.id_token_as_signed_jwt(session)
    print id_token
    assert len(id_token.split(".")) == 3


def test_userinfo_endpoint():
    server = provider_init

    _session_db = {}
    cons = Consumer(_session_db, CONSUMER_CONFIG, CLIENT_CONFIG,
                    server_info=SERVER_INFO)
    cons.debug = True
    cons.client_secret = "drickyoughurt"
    cons.config["response_type"] = ["token"]
    cons.config["request_method"] = "parameter"
    cons.keyjar[""] = KC_RSA

    location = cons.begin("openid", "token", path="http://localhost:8087")

    resp = server.authorization_endpoint(request=location.split("?")[1])

    line = resp.message
    path, query = line.split("#")

    # redirect
    atr = AuthorizationResponse().deserialize(query, "urlencoded")

    uir = UserInfoRequest(access_token=atr["access_token"], schema="openid")

    resp3 = server.userinfo_endpoint(request=uir.to_urlencoded())
    ident = OpenIDSchema().deserialize(resp3.message, "json")
    print ident.keys()
    assert _eq(ident.keys(), ['nickname', 'sub', 'name', 'email'])
    assert ident["sub"] == USERDB["username"]["sub"]


def test_check_session_endpoint():
    server = provider_init
    print server.name

    session = {"sub": "UserID", "client_id": "number5"}
    idtoken = server.id_token_as_signed_jwt(session)
    csr = CheckSessionRequest(id_token=idtoken)

    info = server.check_session_endpoint(request=csr.to_urlencoded())
    print info
    idt = IdToken().deserialize(info.message, "json")
    print idt.keys()
    assert _eq(idt.keys(), ['sub', 'aud', 'iss', 'acr', 'exp', 'iat'])
    assert idt["iss"] == server.name


def test_registration_endpoint():
    server = provider_init

    req = RegistrationRequest()

    req["application_type"] = "web"
    req["client_name"] = "My super service"
    req["redirect_uris"] = ["http://example.com/authz"]
    req["contacts"] = ["foo@example.com"]

    print req.to_dict()

    resp = server.registration_endpoint(request=req.to_json())

    print resp.message
    regresp = RegistrationResponse().deserialize(resp.message, "json")
    print regresp.keys()
    assert _eq(regresp.keys(), ['redirect_uris', 'contacts', 'application_type',
                                'client_name', 'registration_client_uri',
                                'client_secret_expires_at',
                                'registration_access_token',
                                'client_id', 'client_secret',
                                'client_id_issued_at'])


def test_provider_key_setup():
    provider = Provider("pyoicserv", SessionDB(), None, None, None, None, None,
                        "")
    provider.baseurl = "http://www.example.com/"
    provider.key_setup("static", sig={"format": "jwk", "alg": "RSA"})

    keys = provider.keyjar.get_signing_key("RSA")
    assert len(keys) == 1
    assert provider.jwks_uri == "http://www.example.com/static/jwks"


def _client_id(cdb):
    cid = None
    for k, item in cdb.items():
        if item in cdb.keys():
            cid = item
            break

    return cid


def test_registered_redirect_uri_without_query_component():
    provider = Provider("FOO", {}, {}, None, None, None, None, "")
    rr = RegistrationRequest(operation="register",
                             redirect_uris=["http://example.org/cb"])

    registration_req = rr.to_json()

    provider.registration_endpoint(request=registration_req)

    correct = [
        "http://example.org/cb",
        "http://example.org/cb/foo",
        "http://example.org/cb?got=you",
        "http://example.org/cb/foo?got=you"
    ]
    faulty = [
        "http://example.org/foo",
        "http://example.com/cb",
    ]

    cid = _client_id(provider.cdb)

    for ruri in faulty:
        areq = AuthorizationRequest(redirect_uri=ruri,
                                    client_id=cid,
                                    response_type="code",
                                    scope="openid")

        print areq
        try:
            provider._verify_redirect_uri(areq)
            assert False
        except RedirectURIError:
            pass

    for ruri in correct:
        areq = AuthorizationRequest(redirect_uri=ruri,
                                    client_id=cid,
                                    response_type="code", scope="openid")

        print areq
        try:
            provider._verify_redirect_uri(areq)
        except RedirectURIError, err:
            print err
            assert False


def test_registered_redirect_uri_with_query_component():
    provider2 = Provider("FOOP", {}, {}, None, None, None, None, "")

    rr = RegistrationRequest(operation="register",
                             redirect_uris=["http://example.org/cb?foo=bar"])

    registration_req = rr.to_json()
    resp = provider2.registration_endpoint(request=registration_req)

    regresp = RegistrationResponse().from_json(resp.message)

    print regresp.to_dict()

    faulty = [
        "http://example.org/cb",
        "http://example.org/cb/foo",
        "http://example.org/cb?got=you",
        "http://example.org/cb?foo=you"
    ]
    correct = [
        "http://example.org/cb?foo=bar",
        "http://example.org/cb?foo=bar&got=you",
        "http://example.org/cb?foo=bar&foo=you"
    ]

    cid = regresp["client_id"]

    for ruri in faulty:
        areq = AuthorizationRequest(redirect_uri=ruri,
                                    client_id=cid,
                                    scope="openid",
                                    response_type="code")

        print areq
        try:
            provider2._verify_redirect_uri(areq)
        except RedirectURIError:
            pass

    for ruri in correct:
        areq = AuthorizationRequest(redirect_uri=ruri,
                                    client_id=cid, scope="openid",
                                    response_type="code")

        resp = provider2._verify_redirect_uri(areq)
        print resp
        assert resp is None

if __name__ == "__main__":
    test_userinfo_endpoint()
########NEW FILE########
__FILENAME__ = test_sdb
from oic.utils.time_util import utc_time_sans_frac

__author__ = 'rohe0002'

import time

from pytest import raises

from oic.utils.sdb import SessionDB
from oic.utils.sdb import ExpiredToken
from oic.oic.message import AuthorizationRequest
from oic.oic.message import OpenIDRequest

#from oic.oauth2 import message

AREQ = AuthorizationRequest(response_type="code", client_id="client1",
                            redirect_uri="http://example.com/authz",
                            scope=["openid"], state="state000")

AREQN = AuthorizationRequest(response_type="code", client_id="client1",
                             redirect_uri="http://example.com/authz",
                             scope=["openid"], state="state000",
                             nonce="something")

OIDR = OpenIDRequest(response_type="code", client_id="client1",
                     redirect_uri="http://example.com/authz", scope=["openid"],
                     state="state000")

OAUTH2_AREQ = AuthorizationRequest(response_type="code",
                                   client_id="client1",
                                   redirect_uri="http://example.com/authz",
                                   scope=["openid"], state="state000")


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_token():
    sdb = SessionDB()
    sid = sdb.token.key(areq=AREQ)
    assert len(sid) == 28

    sdb = SessionDB({"a": "b"})
    sid = sdb.token.key(areq=AREQ)
    assert len(sid) == 28


def test_new_token():
    sdb = SessionDB()
    sid = sdb.token.key(areq=AREQ)
    assert len(sid) == 28

    code2 = sdb.token('T', sid=sid)
    assert len(sid) == 28

    code3 = sdb.token(ttype="", prev=code2)
    assert code2 != code3
    
    sid2 = sdb.token.key(areq=AREQ, user="jones")
    assert len(sid2) == 28
    assert sid != sid2


def test_type_and_key():
    sdb = SessionDB()
    sid = sdb.token.key(areq=AREQ)
    code = sdb.token(sid=sid)
    print sid
    part = sdb.token.type_and_key(code)
    print part
    assert part[0] == "A"
    assert part[1] == sid


def test_setitem():
    sdb = SessionDB()
    sid = sdb.token.key(areq=AREQ)
    code = sdb.token(sid=sid)

    sdb[sid] = {"indo": "china"}

    info = sdb[sid]
    assert info == {"indo": "china"}

    info = sdb[code]
    assert info == {"indo": "china"}

    raises(KeyError, 'sdb["abcdefghijklmnop"]')


def test_update():
    sdb = SessionDB()
    sid = sdb.token.key(areq=AREQ)
    code = sdb.token(sid=sid)

    raises(KeyError, 'sdb.update(sid, "indo", "nebue")')
    raises(KeyError, 'sdb.update(code, "indo", "nebue")')

    sdb[sid] = {"indo": "china"}

    sdb.update(sid, "indo", "nebue")
    sdb.update(code, "indo", "second")

    raises(KeyError, 'sdb.update("abcdefghijklmnop", "indo", "bar")')

    #noinspection PyUnusedLocal
    sid2 = sdb.token.key(areq=AREQ)

    raises(KeyError, 'sdb.update(sid2, "indo", "bar")')


def test_create_authz_session():
    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)

    info = sdb[sid]
    print info
    assert info["oauth_state"] == "authz"

    sdb = SessionDB()
    # Missing nonce property
    sid = sdb.create_authz_session("sub", OAUTH2_AREQ)
    info = sdb[sid]
    print info
    assert info["oauth_state"] == "authz"

    sid2 = sdb.create_authz_session("sub", AREQN)

    info = sdb[sid2]
    print info
    assert info["nonce"] == "something"

    sid3 = sdb.create_authz_session("sub", AREQN, id_token="id_token")

    info = sdb[sid3]
    print info
    assert info["id_token"] == "id_token"

    sid4 = sdb.create_authz_session("sub", AREQN, oidreq=OIDR)

    info = sdb[sid4]
    print info
    assert "id_token" not in info
    assert "oidreq" in info


def test_create_authz_session_with_sector_id():
    sdb = SessionDB(seed="foo")
    uid = "sub"
    sid5 = sdb.create_authz_session(uid, AREQN, oidreq=OIDR)
    sdb.do_userid(sid5, uid, "http://example.com/si.jwt", "pairwise")

    info_1 = sdb[sid5]
    print info_1
    assert "id_token" not in info_1
    assert "oidreq" in info_1
    assert info_1["sub"] != "sub"
    user_id1 = info_1["sub"]

    sdb.do_userid(sid5, uid, "http://example.net/si.jwt", "pairwise")

    info_2 = sdb[sid5]
    print info_2
    assert info_2["sub"] != "sub"
    assert info_2["sub"] != user_id1


def test_upgrade_to_token():
    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)
    grant = sdb[sid]["code"]
    _dict = sdb.upgrade_to_token(grant)

    print _dict.keys()
    assert _eq(_dict.keys(), ['code', 'authzreq', 'token_type', 'local_sub',
                              'client_id', 'oauth_state', 'refresh_token',
                              'revoked', 'sub', 'access_token',
                              'token_expires_at', 'expires_in', 'state',
                              'redirect_uri', 'code_used', 'scope',
                              'access_token_scope'])

    raises(Exception, 'sdb.upgrade_to_token(grant)')

    raises(Exception, 'sdb.upgrade_to_token(_dict["access_token"]')

    sdb = SessionDB()
    sid = sdb.create_authz_session("another_user_id", AREQ)
    grant = sdb[sid]["code"]

    _dict = sdb.upgrade_to_token(grant, id_token="id_token", oidreq=OIDR)
    print _dict.keys()
    assert _eq(_dict.keys(), ['code', 'authzreq', 'id_token', 'token_type',
                              'local_sub', 'client_id', 'oauth_state',
                              'refresh_token', 'revoked', 'sub', 'oidreq',
                              'access_token', 'token_expires_at', 'expires_in',
                              'state', 'redirect_uri', 'code_used', 'scope',
                              'access_token_scope'])

    assert _dict["id_token"] == "id_token"
    assert _dict["oidreq"].type() == "OpenIDRequest"
    _ = _dict["access_token"]
    raises(Exception, 'sdb.upgrade_to_token(token)')


def test_refresh_token():
    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)
    grant = sdb[sid]["code"]
    _dict = sdb.upgrade_to_token(grant)
    dict1 = _dict.copy()

    rtoken = _dict["refresh_token"]
    time.sleep(1)
    dict2 = sdb.refresh_token(rtoken)
    print dict2
    
    assert dict1["token_expires_at"] != dict2["token_expires_at"]
    assert dict1["access_token"] != dict2["access_token"]

    raises(Exception, 'sdb.refresh_token(dict2["access_token"])')


def test_is_valid():
    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)
    grant = sdb[sid]["code"]

    assert sdb.is_valid(grant)

    _dict = sdb.upgrade_to_token(grant)
    assert sdb.is_valid(grant) is False
    token1 = _dict["access_token"]
    assert sdb.is_valid(token1)

    rtoken = _dict["refresh_token"]
    assert sdb.is_valid(rtoken)

    dict2 = sdb.refresh_token(rtoken)
    token2 = dict2["access_token"]
    assert sdb.is_valid(token2)

    # replace refresh_token

    dict2["refresh_token"] = token2
    assert sdb.is_valid(rtoken) is False
    
    # mess with the time-line

    dict2["token_expires_at"] = utc_time_sans_frac() - 86400
    assert sdb.is_valid(token2) is False

    # replace access_token

    dict2["access_token"] = token1
    assert sdb.is_valid(token2) is False

    sid = sdb.create_authz_session("another:user", AREQ)
    grant = sdb[sid]["code"]

    gdict = sdb[grant]
    gdict["token_expires_at"] = utc_time_sans_frac() - 86400
    assert sdb.is_valid(grant) is False


def test_revoke_token():
    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)

    grant = sdb[sid]["code"]
    _dict = sdb.upgrade_to_token(grant)

    token = _dict["access_token"]
    rtoken = _dict["refresh_token"]
    
    assert sdb.is_valid(token)

    sdb.revoke_token(token)
    assert sdb.is_valid(token) is False

    dict2 = sdb.refresh_token(rtoken)
    token = dict2["access_token"]
    assert sdb.is_valid(token)

    sdb.revoke_token(rtoken)
    assert sdb.is_valid(rtoken) is False

    raises(ExpiredToken, 'sdb.refresh_token(rtoken)')

    assert sdb.is_valid(token)

    # --- new token ----

    sdb = SessionDB()
    sid = sdb.create_authz_session("sub", AREQ)

    grant = sdb[sid]["code"]
    sdb.revoke_token(grant)
    assert sdb.is_valid(grant) is False

########NEW FILE########
__FILENAME__ = test_stateless
from oic.utils.stateless import StateLess

__author__ = 'roland'


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_access_code():
    keys = {"OCT": ["symmetric key123"]}
    st = StateLess(keys, enc_alg="A128KW", enc_method="A128CBC-HS256")
    con = st.create_authz_session("subject",
                                  {"redirect_uri": "https://example.com"})
    tok = st.get_token(con)

    _info = st[tok]
    print _info
    assert _eq(_info.keys(), ["typ", "aud", "val", "sub"])
    assert _info["sub"] == "subject"
    assert _info["typ"] == "code"
    assert _info["aud"] == "https://example.com"


def test_update_to_access_token():
    keys = {"OCT": ["symmetric key123"]}
    st = StateLess(keys, enc_alg="A128KW", enc_method="A128CBC-HS256")
    tok = st.create_authz_session("subject",
                                  {"redirect_uri": "https://example.com"})


if __name__ == "__main__":
    test_access_code()
########NEW FILE########
__FILENAME__ = test_time_util
__author__ = 'rohe0002'

#!/usr/bin/env python

#import calendar
from oic.utils.time_util import *

from pytest import raises


def test_f_quotient():
    assert f_quotient(-1, 3) == -1
    assert f_quotient(0, 3) == 0
    assert f_quotient(1, 3) == 0
    assert f_quotient(2, 3) == 0
    assert f_quotient(3, 3) == 1
    assert f_quotient(3.123, 3) == 1


def test_modulo():
    assert modulo(-1, 3) == 2
    assert modulo(0, 3) == 0
    assert modulo(1, 3) == 1
    assert modulo(2, 3) == 2
    assert modulo(3, 3) == 0
    x = 3.123
    assert modulo(3.123, 3) == x - 3


def test_f_quotient_2():
    assert f_quotient(0, 1, 13) == -1
    for i in range(1, 13):
        assert f_quotient(i, 1, 13) == 0
    assert f_quotient(13, 1, 13) == 1
    assert f_quotient(13.123, 1, 13) == 1


def test_modulo_2():
    assert modulo(0, 1, 13) == 12
    for i in range(1, 13):
        assert modulo(i, 1, 13) == i
    assert modulo(13, 1, 13) == 1
    #x = 0.123
    #assert modulo(13+x, 1, 13) == 1+x


def test_parse_duration():
    (sign, d) = parse_duration("P1Y3M5DT7H10M3.3S")
    assert sign == "+"
    assert d['tm_sec'] == 3.3
    assert d['tm_mon'] == 3
    assert d['tm_hour'] == 7
    assert d['tm_mday'] == 5
    assert d['tm_year'] == 1
    assert d['tm_min'] == 10


def test_add_duration_1():
    #2000-01-12T12:13:14Z	P1Y3M5DT7H10M3S	2001-04-17T19:23:17Z
    t = add_duration(str_to_time("2000-01-12T12:13:14Z"), "P1Y3M5DT7H10M3S")
    assert t.tm_year == 2001
    assert t.tm_mon == 4
    assert t.tm_mday == 17
    assert t.tm_hour == 19
    assert t.tm_min == 23
    assert t.tm_sec == 17


def test_add_duration_2():
    #2000-01-12 PT33H   2000-01-13
    t = add_duration(str_to_time("2000-01-12T00:00:00Z"), "PT33H")
    assert t.tm_year == 2000
    assert t.tm_mon == 1
    assert t.tm_mday == 14
    assert t.tm_hour == 9
    assert t.tm_min == 0
    assert t.tm_sec == 0


def test_str_to_time():   
    t = calendar.timegm(str_to_time("2000-01-12T00:00:00Z"))
    assert t == 947635200


def test_instant():
    inst = str_to_time(instant())
    now = time.gmtime()

    assert now >= inst


def test_valid():
    assert valid("2000-01-12T00:00:00Z") is False
    current_year = datetime.today().year
    assert valid("%d-01-12T00:00:00Z" % (current_year + 1)) is True
    this_instance = instant()
    time.sleep(1)
    assert valid(this_instance) is False  # unless on a very fast machine :-)
    soon = in_a_while(seconds=10)
    assert valid(soon) is True


def test_timeout():
    soon = in_a_while(seconds=1, time_format="")
    time.sleep(2)
    assert valid(soon) is False


def test_before():
    current_year = datetime.today().year
    assert before("%d-01-01T00:00:00Z" % current_year) is False
    assert before("%d-01-01T00:00:00Z" % (current_year + 1)) is True


def test_after():
    current_year = datetime.today().year
    assert after("%d-01-01T00:00:00Z" % (current_year + 1)) is False
    assert after("%d-01-01T00:00:00Z" % current_year) is True


def test_not_before():
    current_year = datetime.today().year
    assert not_before("%d-01-01T00:00:00Z" % (current_year + 1)) is False
    assert not_before("%d-01-01T00:00:00Z" % current_year) is True


def test_not_on_or_after():
    current_year = datetime.today().year
    assert not_on_or_after("%d-01-01T00:00:00Z" % (current_year + 1)) is True
    assert not_on_or_after("%d-01-01T00:00:00Z" % current_year) is False


def test_parse_duration_1():
    (sign, d) = parse_duration("-P1Y3M5DT7H10M3.3S")
    assert sign == "-"
    assert d['tm_sec'] == 3.3
    assert d['tm_mon'] == 3
    assert d['tm_hour'] == 7
    assert d['tm_mday'] == 5
    assert d['tm_year'] == 1
    assert d['tm_min'] == 10


def test_parse_duration_2():
    raises(Exception, 'parse_duration("-P1Y-3M5DT7H10M3.3S")')
    raises(Exception, 'parse_duration("-P1Y3M5DU7H10M3.3S")')
    raises(Exception, 'parse_duration("-P1Y3M5DT")')
    raises(Exception, 'parse_duration("-P1Y3M5DU7H10M3.S")')
    raises(Exception, 'parse_duration("-P1Y3M5DT7H10MxS")')
    raises(Exception, 'parse_duration("-P1Y4M4DT7H10.5M3S")')


def test_add_duration_2():
    #2000-01-12 PT33H   2000-01-13
    t = add_duration(str_to_time("2000-01-12T00:00:00Z"), "P32D")
    assert t.tm_year == 2000
    assert t.tm_mon == 2
    assert t.tm_mday == 12
    assert t.tm_hour == 0
    assert t.tm_min == 0
    assert t.tm_sec == 0
    assert t.tm_wday == 5
    assert t.tm_wday == 5
    assert t.tm_yday == 43
    assert t.tm_isdst == 0


def test_add_duration_3():
    #2000-01-12 PT33H   2000-01-13
    t = add_duration(str_to_time("2000-01-12T00:00:00Z"), "-P32D")
    assert t is None


def test_time_a_while_ago():
    dt = datetime.utcnow()
    t = time_a_while_ago(seconds=10)
    delta = dt - t  # slightly less than 10
    assert delta.seconds == 9
    assert delta.microseconds > 0


def test_a_while_ago():
    dt = time.mktime(time.gmtime())
    then = a_while_ago(seconds=10)
    t = time.mktime(str_to_time(then))
    delta = dt - t  # slightly less than 10
    print delta
    assert delta == 10


def test_shift_time():
    dt = datetime.utcnow()
    t = shift_time(dt, 10)
    delta = t - dt  # exactly 10
    assert delta.seconds == 10


def test_str_to_time_str_error():
    raises(Exception, 'str_to_time("2000-01-12T00:00:00ZABC")')


def test_str_to_time_1():
    t = str_to_time("")
    assert t == 0


def test_utc_now():
    t1 = utc_now()
    t2 = int("%d" % time.time())
    assert t1 == t2


def test_before_0():
    assert before("")
    assert before(0)


def test_before_int():
    now_local = int(time.time())
    assert before(now_local - 1) is False
    assert before(now_local + 2)


def test_later_than_int():
    now_local = int(time.time())
    assert later_than(now_local, now_local - 1)
    assert later_than(now_local - 1, now_local) is False


def test_later_than_str():
    a = in_a_while(seconds=10)
    b = in_a_while(seconds=20)
    assert later_than(b, a)
    assert later_than(a, b) is False

########NEW FILE########
__FILENAME__ = test_webfinger
from copy import copy
import json
from oic.utils.webfinger import URINormalizer
from oic.utils.webfinger import WebFinger
from oic.utils.webfinger import OIC_ISSUER

__author__ = 'rolandh'

# examples provided by Nat Sakimura
EXEMPEL = {
    "example.com": "https://example.com",
    "example.com:8080": "https://example.com:8080",
    "example.com/path": "https://example.com/path",
    "example.com?query": "https://example.com?query",
    "example.com#fragment": "https://example.com",
    "example.com:8080/path?query#fragment": "https://example.com:8080/path?query",
    "http://example.com": "http://example.com",
    "http://example.com:8080": "http://example.com:8080",
    "http://example.com/path": "http://example.com/path",
    "http://example.com?query": "http://example.com?query",
    "http://example.com#fragment": "http://example.com",
    "http://example.com:8080/path?query#fragment": "http://example.com:8080/path?query",
    "nov@example.com": "acct:nov@example.com",
    "nov@example.com:8080": "https://nov@example.com:8080",
    "nov@example.com/path": "https://nov@example.com/path",
    "nov@example.com?query": "https://nov@example.com?query",
    "nov@example.com#fragment": "acct:nov@example.com",
    "nov@example.com:8080/path?query#fragment": "https://nov@example.com:8080/path?query",
    "acct:nov@matake.jp": "acct:nov@matake.jp",
    "acct:nov@example.com:8080": "acct:nov@example.com:8080",
    "acct:nov@example.com/path": "acct:nov@example.com/path",
    "acct:nov@example.com?query": "acct:nov@example.com?query",
    "acct:nov@example.com#fragment": "acct:nov@example.com",
    "acct:nov@example.com:8080/path?query#fragment": "acct:nov@example.com:8080/path?query",
    "mailto:nov@matake.jp": "mailto:nov@matake.jp",
    "mailto:nov@example.com:8080": "mailto:nov@example.com:8080",
    "mailto:nov@example.com/path": "mailto:nov@example.com/path",
    "mailto:nov@example.com?query": "mailto:nov@example.com?query",
    "mailto:nov@example.com#fragment": "mailto:nov@example.com",
    "mailto:nov@example.com:8080/path?query#fragment": "mailto:nov@example.com:8080/path?query",
    "localhost": "https://localhost",
    "localhost:8080": "https://localhost:8080",
    "localhost/path": "https://localhost/path",
    "localhost?query": "https://localhost?query",
    "localhost#fragment": "https://localhost",
    "localhost/path?query#fragment": "https://localhost/path?query",
    "nov@localhost": "acct:nov@localhost",
    "nov@localhost:8080": "https://nov@localhost:8080",
    "nov@localhost/path": "https://nov@localhost/path",
    "nov@localhost?query": "https://nov@localhost?query",
    "nov@localhost#fragment": "acct:nov@localhost",
    "nov@localhost/path?query#fragment": "https://nov@localhost/path?query",
    "tel:+810312345678": "tel:+810312345678",
    "device:192.168.2.1": "device:192.168.2.1",
    "device:192.168.2.1:8080": "device:192.168.2.1:8080",
    "device:192.168.2.1/path": "device:192.168.2.1/path",
    "device:192.168.2.1?query": "device:192.168.2.1?query",
    "device:192.168.2.1#fragment": "device:192.168.2.1",
    "device:192.168.2.1/path?query#fragment": "device:192.168.2.1/path?query",
}


def test_normalize():
    for key, val in EXEMPEL.items():
        _val = URINormalizer().normalize(copy(key))
        assert val == _val


def test_wf0():
    wf = WebFinger()

    query = wf.query(resource="device:p1.example.com")

    assert query == 'https://p1.example.com/.well-known/webfinger?resource=device%3Ap1.example.com'


def test_wf1():
    wf = WebFinger()
    query = wf.query("acct:bob@example.com",
                     ["http://webfinger.net/rel/profile-page", "vcard"])

    assert query == """https://example.com/.well-known/webfinger?resource=acct%3Abob%40example.com&rel=http%3A%2F%2Fwebfinger.net%2Frel%2Fprofile-page&rel=vcard"""


def test_wf2():
    wf = WebFinger(OIC_ISSUER)

    query = wf.query("acct:carol@example.com")

    assert query == """https://example.com/.well-known/webfinger?resource=acct%3Acarol%40example.com&rel=http%3A%2F%2Fopenid.net%2Fspecs%2Fconnect%2F1.0%2Fissuer"""


EX0 = {
    "expires": "2012-11-16T19:41:35Z",
    "subject": "acct:bob@example.com",
    "aliases": [
        "http://www.example.com/~bob/"
    ],
    "properties": {
        "http://example.com/ns/role/": "employee"
    },
    "links": [
        {
            "rel": "http://webfinger.net/rel/avatar",
            "type": "image/jpeg",
            "href": "http://www.example.com/~bob/bob.jpg"
        },
        {
            "rel": "http://webfinger.net/rel/profile-page",
            "href": "http://www.example.com/~bob/"
        },
        {
            "rel": "blog",
            "type": "text/html",
            "href": "http://blogs.example.com/bob/",
            "titles": {
                "en-us": "The Magical World of Bob",
                "fr": "Le monde magique de Bob"
            }
        },
        {
            "rel": "vcard",
            "href": "https://www.example.com/~bob/bob.vcf"
        }
    ]
}


def test_wf4():
    wf = WebFinger()
    jrd0 = wf.load(json.dumps(EX0))

    print jrd0

    for link in jrd0["links"]:
        if link["rel"] == "blog":
            print link["href"]
            assert link["href"] == "http://blogs.example.com/bob/"


if __name__ == "__main__":
    test_wf0()
########NEW FILE########
__FILENAME__ = test_x_claims
#!/usr/bin/env python
from mako.runtime import UNDEFINED
from oic.utils.authn.authn_context import AuthnBroker
from oic.utils.claims import ClaimsMode
from oic.utils.sdb import SessionDB
from oic.utils.authn.client import verify_client
from oic.utils.authn.user import UserAuthnMethod
from oic.utils.authz import AuthzHandling
from oic.utils.userinfo import UserInfo
from pinit import KEYJAR

__author__ = 'rohe0002'

import sys

from oic.oic.message import OpenIDSchema
from oic.utils.keyio import keybundle_from_local_file

from oic.oic.claims_provider import ClaimsClient
from oic.oic.claims_provider import UserClaimsResponse
from oic.oic.claims_provider import UserClaimsRequest
from oic.oic.claims_provider import ClaimsServer


#noinspection PyUnusedLocal
def user_info(oicsrv, userdb, sub, client_id="", user_info_claims=None):
    #print >> sys.stderr, "claims: %s" % user_info_claims
    identity = userdb[sub]
    if user_info_claims:
        result = {}
        for key, restr in user_info_claims["claims"].items():
            try:
                result[key] = identity[key]
            except KeyError:
                if restr == {"essential": True}:
                    raise Exception("Missing property '%s'" % key)
    else:
        result = identity

    return OpenIDSchema(**result)


class LOG():
    def info(self, txt):
        print >> sys.stdout, "INFO: %s" % txt

    def error(self, txt):
        print >> sys.stdout, "ERROR: %s" % txt

    def debug(self, txt):
        print >> sys.stdout, "DEBUG: %s" % txt


#noinspection PyUnusedLocal
def start_response(status, headers=None):
    return

USERDB = {
    "diana": {
        "birthdate": "02/14/2012",
        "gender": "female"
    }
}

USERINFO = UserInfo(USERDB)

CDB = {
    "client_1": {"client_secret": "hemlig"}
}


class DummyAuthn(UserAuthnMethod):
    def __init__(self, srv, user):
        UserAuthnMethod.__init__(self, srv)
        self.user = user

    def authenticated_as(self, **kwargs):
        return {"uid": self.user}

AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add(UNDEFINED, DummyAuthn(None, "username"))

# dealing with authorization
AUTHZ = AuthzHandling()
SYMKEY = "symmetric key used to encrypt cookie info"

USER2MODE = {"diana": "aggregate",
             "upper": "distribute",
             "babs": "aggregate"}

# ============================================================================


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_1():
    cc = ClaimsClient(client_id="client_1")
    cc.client_secret = "hemlig"

    req = cc.construct_UserClaimsRequest(request_args={"sub": "norah",
                                         "claims_names": ["gender",
                                                          "birthdate"]})

    print req
    assert req.type() == "UserClaimsRequest"
    assert _eq(req.keys(), ['client_secret', 'claims_names', 'sub',
                            'client_id'])
    assert req["sub"] == "norah"
    assert req["client_id"] == "client_1"


def test_c2():
    cc = ClaimsClient(client_id="client_1")
    cc.client_secret = "hemlig"
    cc.userclaims_endpoint = "https://example.com/claims"
    request = UserClaimsRequest
    method = "POST"
    request_args = {"sub": "norah", "claims_names": ["gender", "birthdate"]}

    cc.request_info(request, method=method, request_args=request_args)


def test_srv1():

    info = user_info(None, USERDB, "diana")

    keys = {"hmac": "hemlig"}
    cresp = UserClaimsResponse(jwt=info.to_jwt(key=keys),
                               claims_names=info.keys())

    print cresp
    assert _eq(cresp.keys(), ["jwt", "claims_names"])
    assert _eq(cresp["claims_names"], ['gender', 'birthdate'])
    assert "jwt" in cresp


def test_srv2():
    cc = ClaimsClient(client_id="client_1")
    cc.client_secret = "hemlig"

    req = cc.construct_UserClaimsRequest(
        request_args={"sub": "diana", "claims_names": ["gender", "birthdate"]})

    srv = ClaimsServer("pyoicserv", SessionDB(), CDB, USERINFO, verify_client,
                       keyjar=KEYJAR, dist_claims_mode=ClaimsMode(USER2MODE))

    srv.keyjar[""] = keybundle_from_local_file("rsa.key", "rsa", ["ver", "sig"])

    assert srv

    resp = srv.claims_endpoint(req.to_urlencoded(), "")

    print resp.message

    ucr = UserClaimsResponse().deserialize(resp.message, "json")
    ucr.verify(keyjar=srv.keyjar)

    print ucr
    assert _eq(ucr["claims_names"], ["gender", "birthdate"])
    assert "jwt" in ucr

if __name__ == "__main__":
    test_1()
########NEW FILE########
__FILENAME__ = test_x_dynreg
from mako.lookup import TemplateLookup
from oic.utils.http_util import Response, NoContent, Unauthorized
from oic.utils.authn.authn_context import AuthnBroker
from oic.utils.authn.client import verify_client
from oic.utils.authn.client import BearerHeader
from oic.utils.authn.client import ClientSecretPost
from oic.utils.authn.client import ClientSecretBasic
from oic.utils.authn.user import UserAuthnMethod
from oic.utils.authz import Implicit

from oic.utils import sdb
from oic.oauth2.dynreg import Provider
from oic.oauth2.dynreg import RegistrationRequest
from oic.oauth2.dynreg import ClientInfoResponse
from oic.oauth2.dynreg import ClientRegistrationError

CLIENT_CONFIG = {
    "client_id": "client1",
    "ca_certs": "/usr/local/etc/oic/ca_certs.txt",
}

CONSUMER_CONFIG = {
    "authz_page": "/authz",
    "flow_type": "code",
    #"password": args.passwd,
    "scope": [],
    "response_type": "code",
    #"expire_in": 600,
}

SERVER_INFO = {
    "version": "3.0",
    "issuer": "https://connect-op.heroku.com",
    "authorization_endpoint": "http://localhost:8088/authorization",
    "token_endpoint": "http://localhost:8088/token",
    #"userinfo_endpoint":"http://localhost:8088/user_info",
    #"check_id_endpoint":"http://localhost:8088/id_token",
    #"registration_endpoint":"https://connect-op.heroku.com/connect/client",
    #"scopes_supported":["openid","profile","email","address","PPID"],
    "flows_supported": ["code", "token", "code token"],
    #"identifiers_supported":["public","ppid"],
    #"x509_url":"https://connect-op.heroku.com/cert.pem"
}

CDB = {
    "a1b2c3": {
        "password": "hemligt",
        "client_secret": "drickyoughurt"
    },
    "client1": {
        "client_secret": "hemlighet",
        "redirect_uris": [("http://localhost:8087/authz", None)]
    }
}

PASSWD = {"user": "password"}

ROOT = '../oc3/'
tl = TemplateLookup(directories=[ROOT + 'templates', ROOT + 'htdocs'],
                    module_directory=ROOT + 'modules',
                    input_encoding='utf-8', output_encoding='utf-8')


class DummyAuthn(UserAuthnMethod):
    def __init__(self, srv, user):
        UserAuthnMethod.__init__(self, srv)
        self.user = user

    def authenticated_as(self, cookie=None, **kwargs):
        return {"uid": self.user}


AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add("UNDEFINED", DummyAuthn(None, "username"))

# dealing with authorization
AUTHZ = Implicit()


def content_type(headers):
    for key, val in headers:
        if key == "Content-type":
            if val == "application/json":
                return "json"


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_provider_init():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client, client_info_url="https://example.com/as")

    assert provider


def test_client_registration():
    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/")

    request = RegistrationRequest(client_name="myself",
                                  redirect_uris=["https://example.com/rp"])

    resp = provider.registration_endpoint(request.to_json(), {})

    assert isinstance(resp, Response)

    _resp = ClientInfoResponse().from_json(resp.message)

    assert "client_id" in _resp


def test_client_registration_uri_error():
    args = {
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example Client",
        "client_name#ja-Jpan-JP":
            "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
        "token_endpoint_auth_method": "client_secret_basic",
        "scope": "read write dolphin",
        "logo_uri": "https://client.example.org/logo.png",
        "jwks_uri": "https://client.example.org/my_public_keys.jwks"
    }

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/")

    request = RegistrationRequest(**args)

    resp = provider.registration_endpoint(request.to_json(), {})

    assert isinstance(resp, Response)

    _resp = ClientRegistrationError().from_json(resp.message)

    assert "error" in _resp
    assert _resp["error"] == "invalid_client_metadata"


def test_client_registration_2():
    args = {
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example Client",
        "client_name#ja-Jpan-JP":
            "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
        "token_endpoint_auth_method": "client_secret_basic",
        "scope": "read write dolphin",
    }

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/",
                        client_authn_methods={
                            "client_secret_post": ClientSecretPost,
                            "client_secret_basic": ClientSecretBasic,
                            "bearer_header": BearerHeader})

    request = RegistrationRequest(**args)

    resp = provider.registration_endpoint(request.to_json(), {})

    assert isinstance(resp, Response)

    _resp = ClientInfoResponse().from_json(resp.message)

    assert "client_name#ja-Jpan-JP" in _resp.keys()
    assert "client_name" in _resp.keys()


def test_client_user_info_get():
    args = {
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example Client",
        "client_name#ja-Jpan-JP":
            "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
        "token_endpoint_auth_method": "client_secret_basic",
        "scope": "read write dolphin",
    }

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/",
                        client_authn_methods={
                            "client_secret_post": ClientSecretPost,
                            "client_secret_basic": ClientSecretBasic,
                            "bearer_header": BearerHeader})

    request = RegistrationRequest(**args)

    resp = provider.registration_endpoint(request.to_json(),
                                                 environ={})

    assert isinstance(resp, Response)

    _resp = ClientInfoResponse().from_json(resp.message)

    assert "client_name#ja-Jpan-JP" in _resp.keys()
    assert "client_name" in _resp.keys()

    resp = provider.client_info_endpoint(
        "",
        environ={"HTTP_AUTHORIZATION": "Bearer %s" % (
            _resp["registration_access_token"],)},
        query="client_id=%s" % _resp["client_id"])

    _resp_cir = ClientInfoResponse().from_json(resp.message)

    assert _resp == _resp_cir


def test_client_registration_update():
    args = {
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example Client",
        "client_name#ja-Jpan-JP":
            "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
        "token_endpoint_auth_method": "client_secret_basic",
        "scope": "read write dolphin",
    }

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/",
                        client_authn_methods={
                            "client_secret_post": ClientSecretPost,
                            "client_secret_basic": ClientSecretBasic,
                            "bearer_header": BearerHeader})

    request = RegistrationRequest(**args)

    resp = provider.registration_endpoint(request.to_json(),
                                                 environ={})

    assert isinstance(resp, Response)

    _resp = ClientInfoResponse().from_json(resp.message)

    assert "client_name#ja-Jpan-JP" in _resp.keys()
    assert "client_name" in _resp.keys()

    update = {
        "client_id": _resp["client_id"],
        "client_secret": _resp["client_secret"],
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/alt"],
        "scope": "read write dolphin",
        "grant_types": ["authorization_code", "refresh_token"],
        "token_endpoint_auth_method": "client_secret_basic",
        "jwks_uri": "https://client.example.org/my_public_keys.jwks",
        "client_name": "My New Example",
        "client_name#fr": "Mon Nouvel Exemple",
    }

    update_req = RegistrationRequest(**update)

    resp = provider.client_info_endpoint(
        update_req.to_json(),
        environ={"HTTP_AUTHORIZATION": "Bearer %s" % (
            _resp["registration_access_token"],)},
        method="PUT",
        query="client_id=%s" % _resp["client_id"])

    _resp_up = ClientInfoResponse().from_json(resp.message)

    print _resp_up


def test_client_registration_delete():
    args = {
        "redirect_uris": ["https://client.example.org/callback",
                          "https://client.example.org/callback2"],
        "client_name": "My Example Client",
        "client_name#ja-Jpan-JP":
            "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
        "token_endpoint_auth_method": "client_secret_basic",
        "scope": "read write dolphin",
    }

    provider = Provider("pyoicserv", sdb.SessionDB(), CDB, AUTHN_BROKER, AUTHZ,
                        verify_client,
                        client_info_url="https://example.com/as/",
                        client_authn_methods={
                            "client_secret_post": ClientSecretPost,
                            "client_secret_basic": ClientSecretBasic,
                            "bearer_header": BearerHeader})

    request = RegistrationRequest(**args)

    resp = provider.registration_endpoint(request.to_json(),
                                                 environ={})

    assert isinstance(resp, Response)

    _resp = ClientInfoResponse().from_json(resp.message)

    resp = provider.client_info_endpoint(
        "",
        environ={"HTTP_AUTHORIZATION": "Bearer %s" % (
            _resp["registration_access_token"],)},
        method="DELETE",
        query="client_id=%s" % _resp["client_id"])

    assert isinstance(resp, NoContent)

    # A read should fail

    resp = provider.client_info_endpoint(
        "",
        environ={"HTTP_AUTHORIZATION": "Bearer %s" % (
            _resp["registration_access_token"],)},
        query="client_id=%s" % _resp["client_id"])

    assert isinstance(resp, Unauthorized)

# -----------------------------------------------------------------------------

test_client_registration_delete()

########NEW FILE########
