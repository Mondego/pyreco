__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Facepy documentation build configuration file, created by
# sphinx-quickstart on Tue Dec 27 20:26:42 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../../'))

from facepy import __version__

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Facepy'
copyright = u'2011, Johannes Gorset'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'
html_style = 'rtd.css'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Facepydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Facepy.tex', u'Facepy Documentation',
   u'Johannes Gorset', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'facepy', u'Facepy Documentation',
     [u'Johannes Gorset'], 1)
]

########NEW FILE########
__FILENAME__ = exceptions
class FacepyError(Exception):
    """Base class for exceptions raised by Facepy."""


class FacebookError(FacepyError):
    """Exception for Facebook errors."""
    def __init__(self, message=None, code=None):
        self.message = message
        self.code = code

        if self.code:
            message = '[%s] %s' % (self.code, self.message)

        super(FacebookError, self).__init__(message)


class OAuthError(FacebookError):
    """Exception for Facebook errors specifically related to OAuth."""


class HTTPError(FacepyError):
    """Exception for transport errors."""


class SignedRequestError(FacepyError):
    """Exception for invalid signed requests."""

########NEW FILE########
__FILENAME__ = graph_api
try:
    import simplejson as json
except ImportError:
    import json  # flake8: noqa
import requests
import hashlib
import hmac

try:
    from urllib.parse import urlencode
except ImportError:
    from urllib import urlencode
from decimal import Decimal

import six

from facepy.exceptions import *


class GraphAPI(object):
    def __init__(self, oauth_token=False, url='https://graph.facebook.com', verify_ssl_certificate=True, appsecret=False, timeout=None):
        """
        Initialize GraphAPI with an OAuth access token.

        :param oauth_token: A string describing an OAuth access token.
        """
        self.oauth_token = oauth_token
        self.session = requests.session()
        self.url = url.strip('/')
        self.verify_ssl_certificate = verify_ssl_certificate
        self.appsecret = appsecret
        self.timeout = timeout

    @classmethod
    def for_application(self, id, secret_key):
        """
        Initialize GraphAPI with an OAuth access token for an application.

        :param id: An integer describing a Facebook application.
        :param secret_key: A String describing the Facebook application's secret key.
        """
        from facepy.utils import get_application_access_token

        return GraphAPI(get_application_access_token(id, secret_key))

    def get(self, path='', page=False, retry=3, **options):
        """
        Get an item from the Graph API.

        :param path: A string describing the path to the item.
        :param page: A boolean describing whether to return a generator that
                     iterates over each page of results.
        :param retry: An integer describing how many times the request may be retried.
        :param options: Graph API parameters such as 'limit', 'offset' or 'since'.

        Floating-point numbers will be returned as :class:`decimal.Decimal`
        instances.

        See `Facebook's Graph API documentation <http://developers.facebook.com/docs/reference/api/>`_
        for an exhaustive list of parameters.
        """
        response = self._query(
            method='GET',
            path=path,
            data=options,
            page=page,
            retry=retry
        )

        if response is False:
            raise FacebookError('Could not get "%s".' % path)

        return response

    def post(self, path='', retry=0, **data):
        """
        Post an item to the Graph API.

        :param path: A string describing the path to the item.
        :param retry: An integer describing how many times the request may be retried.
        :param data: Graph API parameters such as 'message' or 'source'.

        See `Facebook's Graph API documentation <http://developers.facebook.com/docs/reference/api/>`_
        for an exhaustive list of options.
        """
        response = self._query(
            method='POST',
            path=path,
            data=data,
            retry=retry
        )

        if response is False:
            raise FacebookError('Could not post to "%s"' % path)

        return response

    def delete(self, path, retry=3):
        """
        Delete an item in the Graph API.

        :param path: A string describing the path to the item.
        :param retry: An integer describing how many times the request may be retried.
        """
        response = self._query(
            method='DELETE',
            path=path,
            retry=retry
        )

        if response is False:
            raise FacebookError('Could not delete "%s"' % path)

        return response

    def search(self, term, type, page=False, retry=3, **options):
        """
        Search for an item in the Graph API.

        :param term: A string describing the search term.
        :param type: A string describing the type of items to search for.
        :param page: A boolean describing whether to return a generator that
                     iterates over each page of results.
        :param retry: An integer describing how many times the request may be retried.
        :param options: Graph API parameters, such as 'center' and 'distance'.

        Supported types are ``post``, ``user``, ``page``, ``event``, ``group``, ``place`` and ``checkin``.

        See `Facebook's Graph API documentation <http://developers.facebook.com/docs/reference/api/>`_
        for an exhaustive list of options.
        """
        SUPPORTED_TYPES = ['post', 'user', 'page', 'event', 'group', 'place', 'checkin']

        if type not in SUPPORTED_TYPES:
            raise ValueError('Unsupported type "%s". Supported types are %s' % (type, ', '.join(SUPPORTED_TYPES)))

        options = dict({
            'q': term,
            'type': type,
        }, **options)

        response = self._query('GET', 'search', options, page, retry)

        return response

    def batch(self, requests):
        """
        Make a batch request.

        :param requests: A list of dictionaries with keys 'method', 'relative_url' and optionally 'body'.

        Yields a list of responses and/or exceptions.
        """

        for request in requests:
            if 'body' in request:
                request['body'] = urlencode(request['body'])

        def _grouper(complete_list, n=1):
            """
            Batches a list into constant size chunks.

            :param complete_list: A input list (not a generator).
            :param n: The size of the chunk.

            Adapted from <http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python>
            """

            for i in range(0, len(complete_list), n):
                yield complete_list[i:i + n]

        responses = []

        # Maximum batch size for Facebook is 50 so split up requests
        # https://developers.facebook.com/docs/graph-api/making-multiple-requests/#limits
        for group in _grouper(requests, 50):
            responses += self.post(
                batch=json.dumps(group)
            )

        for response, request in zip(responses, requests):

            # Facilitate for empty Graph API responses.
            #
            # https://github.com/jgorset/facepy/pull/30
            if not response:
                yield None
                continue

            try:
                yield self._parse(response['body'])
            except FacepyError as exception:
                exception.request = request
                yield exception

    def fql(self, query, retry=3):
        """
        Use FQL to powerfully extract data from Facebook.

        :param query: A FQL query or FQL multiquery ({'query_name': "query",...})
        :param retry: An integer describing how many times the request may be retried.

        See `Facebook's FQL documentation <http://developers.facebook.com/docs/reference/fql/>`_
        for an exhaustive list of details.
        """
        return self._query(
            method='GET',
            path='fql?%s' % urlencode({'q': query}),
            retry=retry
        )

    def _query(self, method, path, data=None, page=False, retry=0):
        """
        Fetch an object from the Graph API and parse the output, returning a tuple where the first item
        is the object yielded by the Graph API and the second is the URL for the next page of results, or
        ``None`` if results have been exhausted.

        :param method: A string describing the HTTP method.
        :param path: A string describing the object in the Graph API.
        :param data: A dictionary of HTTP GET parameters (for GET requests) or POST data (for POST requests).
        :param page: A boolean describing whether to return an iterator that iterates over each page of results.
        :param retry: An integer describing how many times the request may be retried.
        """

        if(data):
            data = dict(
                 (k.replace('_sqbro_', '['), v) for k, v in data.items())
            data = dict(
                 (k.replace('_sqbrc_', ']'), v) for k, v in data.items())
            data = dict(
                 (k.replace('__', ':'), v) for k, v in data.items())
        data = data or {}

        def load(method, url, data):
            for key in data:
                value = data[key]

                if isinstance(value, (list, dict, set)):
                    data[key] = json.dumps(value)

            try:
                if method in ['GET', 'DELETE']:
                    response = self.session.request(method, url, params=data, allow_redirects=True,
                     verify=self.verify_ssl_certificate, timeout=self.timeout)

                if method in ['POST', 'PUT']:
                    files = {}

                    for key in data:
                        if hasattr(data[key], 'read'):
                            files[key] = data[key]

                    for key in files:
                        data.pop(key)

                    response = self.session.request(method, url, data=data, files=files,
                        verify=self.verify_ssl_certificate, timeout=self.timeout)
            except requests.RequestException as exception:
                raise HTTPError(exception)

            result = self._parse(response.content)

            try:
                next_url = result['paging']['next']
            except (KeyError, TypeError):
                next_url = None

            return result, next_url

        def paginate(method, url, data):
            while url:
                result, url = load(method, url, data)

                # Reset pagination parameters.
                for key in ['offset', 'until', 'since']:
                    if key in data:
                        del data[key]

                yield result

        # Convert option lists to comma-separated values.
        for key in data:
            if isinstance(data[key], (list, set, tuple)) and all([isinstance(item, six.string_types) for item in data[key]]):
                data[key] = ','.join(data[key])

        # Support absolute paths too
        if not path.startswith('/'):
            if six.PY2:
                path = '/' + six.text_type(path.decode('utf-8'))
            else:
                path = '/' + path

        url = '%s%s' % (self.url, path)

        if self.oauth_token:
            data['access_token'] = self.oauth_token

        if self.appsecret and self.oauth_token:
            data['appsecret_proof'] = self._generate_appsecret_proof()

        try:
            if page:
                return paginate(method, url, data)
            else:
                return load(method, url, data)[0]
        except FacepyError:
            if retry:
                return self._query(method, path, data, page, retry - 1)
            else:
                raise

    def _parse(self, data):
        """
        Parse the response from Facebook's Graph API.

        :param data: A string describing the Graph API's response.
        """
        # tests seems to pass a str, while real usage bytes which should be expected
        if type(data) == type(bytes()):
            data = data.decode('utf-8')
        try:
            data = json.loads(data, parse_float=Decimal)
        except ValueError:
            return data

        # Facebook's Graph API sometimes responds with 'true' or 'false'. Facebook offers no documentation
        # as to the prerequisites for this type of response, though it seems that it responds with 'true'
        # when objects are successfully deleted and 'false' upon attempting to delete or access an item that
        # one does not have access to.
        #
        # For example, the API would respond with 'false' upon attempting to query a feed item without having
        # the 'read_stream' extended permission. If you were to query the entire feed, however, it would respond
        # with an empty list instead.
        #
        # Genius.
        #
        # We'll handle this discrepancy as gracefully as we can by implementing logic to deal with this behavior
        # in the high-level access functions (get, post, delete etc.).
        if type(data) is dict:
            if 'error' in data:
                error = data['error']

                if error.get('type') == "OAuthException":
                    exception = OAuthError
                else:
                    exception = FacebookError

                raise exception(
                    error.get('message'),
                    error.get('code', None)
                )

            # Facebook occasionally reports errors in its legacy error format.
            if 'error_msg' in data:
                raise FacebookError(
                    data.get('error_msg'),
                    data.get('error_code', None)
                )

        return data

    def _generate_appsecret_proof(self):
        """
        Returns a SHA256 of the oauth_token signed by appsecret.
        https://developers.facebook.com/docs/graph-api/securing-requests/
        """
        if six.PY2:
            key = self.appsecret
            message = self.oauth_token
        else:
            key = bytes(self.appsecret, 'utf-8')
            message = bytes(self.oauth_token, 'utf-8')

        return hmac.new(key, message, hashlib.sha256).hexdigest()

    # Proxy exceptions for ease of use and backwards compatibility.
    FacebookError, OAuthError, HTTPError = FacebookError, OAuthError, HTTPError

########NEW FILE########
__FILENAME__ = signed_request
import base64
import hashlib
import hmac
try:
    import simplejson as json
except ImportError:
    import json  # flake8: noqa
import time

from datetime import datetime

from facepy.exceptions import *


class SignedRequest(object):
    """
    Facebook uses "signed requests" to communicate with applications on the Facebook platform. See `Facebook's
    documentation on authentication <https://developers.facebook.com/docs/authentication/signed_request/>`_
    for more information.
    """

    user = None
    """A ``SignedRequest.User`` instance describing the user that generated the signed request."""

    data = None
    """A string describing the contents of the ``app_data`` query string parameter."""

    page = None
    """A ``SignedRequest.Page`` instance describing the Facebook page that the signed request was generated from."""

    raw = None
    """A string describing the signed request in its original format."""

    def __init__(self, signed_request=None, application_secret_key=None, application_id=None):
        """
        Initialize a signed request.

        :param signed_request: A string describing a signed request.
        :param application_secret_key: A string describing a Facebook application's secret key.
        """
        self.signed_request = signed_request
        self.application_secret_key = application_secret_key
        self.application_id = application_id

        self.raw = self.parse(signed_request, application_secret_key)

        self.data = self.raw.get('app_data', None)

        self.page = self.Page(
            id=self.raw['page'].get('id'),
            is_liked=self.raw['page'].get('liked'),
            is_admin=self.raw['page'].get('admin')
        ) if 'page' in self.raw else None

        if not 'user' in self.raw:
            self.fetch_user_data_and_token()

        self.user = self.User(
            id=self.raw.get('user_id'),
            locale=self.raw['user'].get('locale', None),
            country=self.raw['user'].get('country', None),
            age=range(
                self.raw['user']['age']['min'],
                self.raw['user']['age']['max'] + 1 if 'max' in self.raw['user']['age'] else 100
            ) if 'age' in self.raw['user'] else None,
            oauth_token=self.User.OAuthToken(
                token=self.raw['oauth_token'],
                issued_at=datetime.fromtimestamp(self.raw['issued_at']),
                expires_at=datetime.fromtimestamp(self.raw['expires']) if self.raw['expires'] > 0 else None
            ) if 'oauth_token' in self.raw else None,
        )

    def fetch_user_data_and_token(self):
        from urlparse import parse_qs
        from . import GraphAPI, get_application_access_token

        app_token = get_application_access_token(self.application_id, self.application_secret_key)
        graph = GraphAPI(app_token)
        
        qs = graph.get('oauth/access_token', code=self.raw['code'], redirect_uri='', client_id=self.application_id, client_secret=self.application_secret_key)
        self.raw['oauth_token'] = parse_qs(qs)['access_token'][0]
        #import ipdb; ipdb.set_trace()
        self.raw['expires'] = time.time() + int(parse_qs(qs)['expires'][0])
        self.raw['user'] = graph.get(self.raw['user_id'])

    def parse(cls, signed_request, application_secret_key):
        """Parse a signed request, returning a dictionary describing its payload."""
        def decode(encoded):
            padding = '=' * (len(encoded) % 4)
            return base64.urlsafe_b64decode(encoded + padding)

        try:
            encoded_signature, encoded_payload = (str(string) for string in signed_request.split('.', 2))
            signature = decode(encoded_signature)
            signed_request_data = json.loads(decode(encoded_payload).decode('utf-8'))
        except (TypeError, ValueError):
            raise SignedRequestError("Signed request had a corrupt payload")

        if signed_request_data.get('algorithm', '').upper() != 'HMAC-SHA256':
            raise SignedRequestError("Signed request is using an unknown algorithm")

        expected_signature = hmac.new(application_secret_key.encode('utf-8'), msg=encoded_payload.encode('utf-8'),
                                      digestmod=hashlib.sha256).digest()
        if signature != expected_signature:
            raise SignedRequestError("Signed request signature mismatch")

        return signed_request_data

    parse = classmethod(parse)

    def generate(self):
        """Generate a signed request from this instance."""
        payload = {
            'algorithm': 'HMAC-SHA256'
        }

        if self.data:
            payload['app_data'] = self.data

        if self.page:
            payload['page'] = {}

            if self.page.id:
                payload['page']['id'] = self.page.id

            if self.page.is_liked:
                payload['page']['liked'] = self.page.is_liked

            if self.page.is_admin:
                payload['page']['admin'] = self.page.is_admin

        if self.user:
            payload['user'] = {}

            if self.user.country:
                payload['user']['country'] = self.user.country

            if self.user.locale:
                payload['user']['locale'] = self.user.locale

            if self.user.age:
                payload['user']['age'] = {
                    'min': self.user.age[0],
                    'max': self.user.age[-1]
                }

            if self.user.oauth_token:

                if self.user.oauth_token.token:
                    payload['oauth_token'] = self.user.oauth_token.token

                if self.user.oauth_token.expires_at is None:
                    payload['expires'] = 0
                else:
                    payload['expires'] = int(time.mktime(self.user.oauth_token.expires_at.timetuple()))

                if self.user.oauth_token.issued_at:
                    payload['issued_at'] = int(time.mktime(self.user.oauth_token.issued_at.timetuple()))

        if self.user.id:
            payload['user_id'] = self.user.id

        encoded_payload = base64.urlsafe_b64encode(
            json.dumps(payload, separators=(',', ':')).encode('utf-8')
        )

        encoded_signature = base64.urlsafe_b64encode(hmac.new(
            self.application_secret_key.encode('utf-8'),
            encoded_payload,
            hashlib.sha256
        ).digest())

        return '%(signature)s.%(payload)s' % {
            'signature': encoded_signature,
            'payload': encoded_payload
        }

    class Page(object):
        """
        A ``Page`` instance represents a Facebook page.
        """

        id = None
        """An integer describing the page's Facebook ID."""

        is_liked = None
        """A boolean describing whether or not the user likes the page."""

        is_admin = None
        """A bolean describing whether or nor the user is an administrator of the page."""

        url = None
        """A string describing the URL to the page."""

        def __init__(self, id, is_liked=False, is_admin=False):
            self.id, self.is_liked, self.is_admin = id, is_liked, is_admin

        @property
        def url(self):
            return 'http://facebook.com/%s' % self.id

    class User(object):
        """
        A ``User`` instance represents a Facebook user.
        """

        id = None
        """An integer describing the user's Facebook ID."""

        age = None
        """A range describing the user's age."""

        locale = None
        """A string describing the user's locale."""

        country = None
        """A string describing the user's country."""

        oauth_token = None
        """A ``SignedRequest.User.OAuthToken`` instance describing an OAuth access token."""

        def __init__(self, id, age=None, locale=None, country=None, oauth_token=None):
            self.id = id
            self.locale = locale
            self.country = country
            self.age = age
            self.oauth_token = oauth_token

        @property
        def profile_url(self):
            """A string describing the URL to the user's Facebook profile."""
            return 'http://facebook.com/%s' % self.id

        @property
        def has_authorized_application(self):
            """A boolean describing whether the user has authorized the application."""
            return bool(self.oauth_token)

        class OAuthToken(object):
            """
            An OAuth token represents an access token that may be used to query
            Facebook's Graph API on behalf of the user that issued it.
            """

            token = None
            """A string describing the access token."""

            issued_at = None
            """A ``datetime`` instance describing when the access token was issued."""

            expires_at = None
            """A ``datetime`` instance describing when the access token will expire, or ``None`` if it won't."""

            def __init__(self, token, issued_at, expires_at):
                self.token, self.issued_at, self.expires_at = token, issued_at, expires_at

            @property
            def has_expired(self):
                """A boolean describing whether the access token has expired."""
                if self.expires_at is None:
                    return False
                else:
                    return self.expires_at < datetime.now()

    # Proxy exceptions for ease of use and backwards compatibility.
    Error = SignedRequestError

########NEW FILE########
__FILENAME__ = utils
from datetime import datetime, timedelta

try:
    from urllib.parse import parse_qs
except ImportError:
    from urlparse import parse_qs

from facepy.graph_api import GraphAPI


def get_extended_access_token(access_token, application_id, application_secret_key):
    """
    Get an extended OAuth access token.

    :param access_token: A string describing an OAuth access token.
    :param application_id: An integer describing the Facebook application's ID.
    :param application_secret_key: A string describing the Facebook application's secret key.

    Returns a tuple with a string describing the extended access token and a datetime instance
    describing when it expires.
    """
    graph = GraphAPI()

    response = graph.get(
        path='oauth/access_token',
        client_id=application_id,
        client_secret=application_secret_key,
        grant_type='fb_exchange_token',
        fb_exchange_token=access_token
    )

    components = parse_qs(response)

    token = components['access_token'][0]

    try:
        expires_at = datetime.now() + timedelta(seconds=int(components['expires'][0]))
    except KeyError:  # there is no expiration
        expires_at = None

    return token, expires_at


def get_application_access_token(application_id, application_secret_key):
    """
    Get an OAuth access token for the given application.

    :param application_id: An integer describing a Facebook application's ID.
    :param application_secret_key: A string describing a Facebook application's secret key.
    """
    graph = GraphAPI()

    response = graph.get(
        path='oauth/access_token',
        client_id=application_id,
        client_secret=application_secret_key,
        grant_type='client_credentials'
    )

    data = parse_qs(response)

    try:
        return data['access_token'][0]
    except KeyError:
        raise GraphAPI.FacebookError('No access token given')

########NEW FILE########
__FILENAME__ = test_exceptions
"""Tests for the ``exceptions`` module."""
try:
    import cPickle as pickle
except ImportError:
    import pickle


from nose.tools import *

from facepy import *
from facepy.exceptions import FacebookError


def test_facepy_error():
    try:
        raise FacepyError('<message>')
    except FacepyError as exception:
        if hasattr(exception, "message"):
            assert_equal(exception.message, '<message>')
        assert_equal(exception.__str__(), '<message>')
        assert_equal(exception.__repr__(), 'FacepyError(\'<message>\',)')


def test_facebook_error():
    try:
        raise FacebookError('<message>', 100)
    except FacebookError as exception:
        assert_equal(exception.message, '<message>')
        assert_equal(exception.code, 100)
        assert_equal(exception.__str__(), '[100] <message>')
        assert_equal(exception.__repr__(), 'FacebookError(\'[100] <message>\',)')


def test_facebookerror_can_be_pickled():
    try:
        raise GraphAPI.FacebookError('<message>', '<code>')
    except FacepyError as exception:
        pickle.dumps(exception)


def test_oautherror_can_be_pickled():
    try:
        raise GraphAPI.OAuthError('<message>', '<code>')
    except FacepyError as exception:
        pickle.dumps(exception)


def test_httperror_can_be_pickled():
    try:
        raise GraphAPI.HTTPError('<message>')
    except FacepyError as exception:
        pickle.dumps(exception)

########NEW FILE########
__FILENAME__ = test_graph_api
# -*- coding:utf-8 -*-

"""Tests for the ``graph_api`` module."""
import json
import decimal
import hashlib
import hmac

from nose.tools import *
from mock import patch, MagicMock
from requests.exceptions import ConnectionError

from facepy import GraphAPI


patch = patch('requests.session')


def mock():
    global mock_request

    mock_request = patch.start()().request


def unmock():
    patch.stop()


@with_setup(mock, unmock)
def test_get():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'id': 1,
        'name': 'Thomas \'Herc\' Hauk',
        'first_name': 'Thomas',
        'last_name': 'Hauk',
        'link': 'http://facebook.com/herc',
        'username': 'herc',
    })

    graph.get('me')

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_get_with_nested_parameters():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'id': 1,
        'name': 'Thomas \'Herc\' Hauk',
        'first_name': 'Thomas',
        'last_name': 'Hauk',
        'link': 'http://facebook.com/herc',
        'username': 'herc',
    })

    graph.get('me', foo={'bar': 'baz'})

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>',
            'foo': '{"bar": "baz"}'
        }
    )


@with_setup(mock, unmock)
def test_get_with_appsecret():
    graph = GraphAPI('<access token>', appsecret='<appsecret>')

    mock_request.return_value.content = json.dumps({
        'id': 1,
        'name': 'Thomas \'Herc\' Hauk',
        'first_name': 'Thomas',
        'last_name': 'Hauk',
        'link': 'http://facebook.com/herc',
        'username': 'herc',
    })

    graph.get('me')

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>',
            'appsecret_proof': graph._generate_appsecret_proof()
        }
    )


@with_setup(mock, unmock)
def test_get_with_fields():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'id': 1,
        'first_name': 'Thomas',
        'last_name': 'Hauk'
    })

    graph.get('me', fields=['id', 'first_name', 'last_name'])

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>',
            'fields': 'id,first_name,last_name'
        }
    )

    graph.get('me', fields=('id', 'first_name', 'last_name'))

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>',
            'fields': 'id,first_name,last_name'
        }
    )


@with_setup(mock, unmock)
def test_get_with_fpnum():
    graph = GraphAPI('<access token>')
    mock_request.return_value.content = '{"payout": 0.94}'

    resp = graph.get('<paymend_id>')

    assert_equal(resp, {'payout': decimal.Decimal('0.94')})


@with_setup(mock, unmock)
def test_forbidden_get():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = 'false'

    assert_raises(GraphAPI.FacebookError, graph.get, 'me')


@with_setup(mock, unmock)
def test_paged_get():
    graph = GraphAPI('<access token>')
    limit = 2

    responses = [
        {
            'data': [
                {
                    'message': 'He\'s a complicated man. And the only one that understands him is his woman'
                }
            ] * 2,
            'paging': {
                'next': 'https://graph.facebook.com/herc/posts?limit=%(limit)s&offset=%(limit)s&access_token=<access token>' % {
                    'limit': limit
                }
            }
        },
        {
            'data': [
                {
                    'message': 'He\'s a complicated man. And the only one that understands him is his woman'
                }
            ],
            'paging': {
                'next': 'https://graph.facebook.com/herc/posts?limit=%(limit)s&offset=%(limit)s&access_token=<access token>' % {
                    'limit': limit
                }
            }
        },
        {
            'data': [],
            'paging': {
                'previous': 'https://graph.facebook.com/herc/posts?limit=%(limit)s&offset=%(limit)s&access_token=<access token>' % {
                    'limit': limit
                }
            }
        }
    ]

    def side_effect(*args, **kwargs):
        response = responses.pop(0)

        return MagicMock(content=json.dumps(response))

    mock_request.side_effect = side_effect

    pages = graph.get('herc/posts', page=True)

    for index, page in enumerate(pages):
        pass

    assert_equal(index, 2)


@with_setup(mock, unmock)
def test_pagination_without_paging_next():
    graph = GraphAPI('<access token>')
    limit = 2

    mock_request.return_value.content = json.dumps({
        'data': [
            {
                'message': 'He\'s a complicated man. And the only one that understands him is his woman',
            },
        ],
        'paging': {
        }
    })

    pages = graph.get('herc/posts', page=True, limit=limit)

    for index, page in enumerate(pages):
        pass

    assert_equal(index, 0)


@with_setup(mock, unmock)
def test_get_with_errors():
    graph = GraphAPI('<access token>')

    # Test errors
    mock_request.return_value.content = json.dumps({
        'error': {
            'code': 1,
            'message': 'An unknown error occurred'
        }
    })

    assert_raises(GraphAPI.FacebookError, graph.get, 'me')

    # Test legacy errors
    mock_request.return_value.content = json.dumps({
        'error_code': 1,
        'error_msg': 'An unknown error occurred',
    })

    assert_raises(GraphAPI.FacebookError, graph.get, 'me')

    # Test legacy errors without an error code
    mock_request.return_value.content = json.dumps({
        'error_msg': 'The action you\'re trying to publish is invalid'
    })

    assert_raises(GraphAPI.FacebookError, graph.get, 'me')


@with_setup(mock, unmock)
def test_fql():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'id': 1,
        'name': 'Thomas \'Herc\' Hauk',
        'first_name': 'Thomas',
        'last_name': 'Hauk',
        'link': 'http://facebook.com/herc',
        'username': 'herc',
    })

    try:
        graph.fql('SELECT id,name,first_name,last_name,username FROM user WHERE uid=me()')
    except GraphAPI.FacebookError:
        pass

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/fql?q=SELECT+id%2Cname%2Cfirst_name%2Clast_name%2Cusername+FROM+user+WHERE+uid%3Dme%28%29',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_post():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'id': 1
    })

    graph.post(
        path='me/feed',
        message='He\'s a complicated man. And the only one that understands him is his woman'
    )

    mock_request.assert_called_with(
        'POST',
        'https://graph.facebook.com/me/feed',
        files={},
        verify=True,
        timeout=None,
        data={
            'message': 'He\'s a complicated man. And the only one that understands him is his woman',
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_post_with_files():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = 'true'

    graph.post(
        path='me/photos',
        source=open('tests/fixtures/parrot.jpg')
    )


@with_setup(mock, unmock)
def test_forbidden_post():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = 'false'

    assert_raises(GraphAPI.FacebookError, graph.post, 'me')


@with_setup(mock, unmock)
def test_delete():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = 'true'

    graph.delete('1')

    mock_request.assert_called_with(
        'DELETE',
        'https://graph.facebook.com/1',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_forbidden_delete():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = 'false'

    assert_raises(GraphAPI.FacebookError, graph.delete, 'me')


@with_setup(mock, unmock)
def test_search():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'data': [
            {
                'message': 'I don\'t like your chair.'
            },
            {
                'message': 'Don\'t let your mouth get your ass in trouble.'
            }
        ]
    })

    graph.search(
        term='shaft quotes',
        type='post'
    )

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/search',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'q': 'shaft quotes',
            'type': 'post',
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_invalid_search():
    graph = GraphAPI('<access token>')

    assert_raises(ValueError, graph.search, 'shaft', 'movies')


@with_setup(mock, unmock)
def test_batch():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps([
        {
            'code': 200,
            'headers': [
                {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
            ],
            'body': '{"foo": "bar"}'
        }
    ])

    requests = [
        {'method': 'GET', 'relative_url': 'me/friends'},
        {'method': 'GET', 'relative_url': 'me/photos'},
        {'method': 'POST', 'relative_url': 'me/feed', 'body': {'message': 'Hi me.'}}
    ]

    batch = graph.batch(
        requests=requests
    )

    for item in batch:
        pass

    mock_request.assert_called_with(
        'POST',
        'https://graph.facebook.com/',
        files={},
        verify=True,
        timeout=None,
        data={
            'batch': json.dumps([
                {'method': 'GET', 'relative_url': 'me/friends'},
                {'method': 'GET', 'relative_url': 'me/photos'},
                {'method': 'POST', 'relative_url': 'me/feed', 'body': 'message=Hi+me.'}
            ]),
            'access_token': '<access token>'
        }
    )


@with_setup(mock, unmock)
def test_batch_with_empty_responses():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps([
        None,
        {
            'code': 200,
            'headers': [
                {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
            ],
            'body': '{"foo": "bar"}'
        }
    ])

    requests = [
        {'method': 'GET', 'relative_url': 'me/friends'},
        {'method': 'GET', 'relative_url': 'me/photos'}
    ]

    batch = graph.batch(
        requests=requests
    )

    assert list(batch) == [None, {'foo': 'bar'}]


@with_setup(mock, unmock)
def test_batch_with_errors():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps([
        {
            'code': 200,
            'headers': [
                {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
            ],
            'body': '{"foo": "bar"}'
        },
        {
            'code': 500,
            'headers': [
                {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
            ],
            'body': '{"error_code": 1, "error_msg": "An unknown error occurred"}'
        }
    ])

    requests = [
        {'method': 'GET', 'relative_url': 'me/friends'},
        {'method': 'GET', 'relative_url': 'me'}
    ]

    batch = graph.batch(requests)

    responses = list(batch)

    assert isinstance(responses[0], dict)
    assert isinstance(responses[1], Exception)


@with_setup(mock, unmock)
def test_batch_error_references_request():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps([
        {
            'code': 500,
            'headers': [
                {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
            ],
            'body': '{"error_code": 1, "error_msg": "An unknown error occurred"}'
        }
    ])

    requests = [
        {'method': 'GET', 'relative_url': 'me'}
    ]

    batch = graph.batch(requests)

    responses = list(batch)

    assert_equal(responses[0].request, requests[0])


@with_setup(mock, unmock)
def test_batch_over_50_requests():
    graph = GraphAPI('<access_token')

    def side_effect_batch_size(*args, **kwargs):
        batch_size = len(json.loads(kwargs['data']['batch']))
        if batch_size > 50:
            return MagicMock(content='{"error":{"message":"Too many requests in batch message. Maximum batch size is 50","type":"GraphBatchException"}}')
        else:
            return MagicMock(content=json.dumps([
                {
                    'code': 200,
                    'headers': [
                        {'name': 'Content-Type', 'value': 'text/javascript; charset=UTF-8'}
                    ],
                    'body': '{"foo": "bar"}'
                } for i in range(batch_size)
            ]))

    mock_request.side_effect = side_effect_batch_size

    requests = [dict(method="GET", relative_url="me?fields=username") for i in range(60)]

    batch = graph.batch(
        requests=requests
    )

    responses = list(batch)

    assert len(responses) == 60


@with_setup(mock, unmock)
def test_oauth_error():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'error': {
            'message': 'An active access token must be used to query information about the current user.',
            'type': 'OAuthException',
            'code': 2500
        }
    })

    assert_raises(GraphAPI.OAuthError, graph.get, 'me')


@with_setup(mock, unmock)
def test_query_transport_error():
    graph = GraphAPI('<access token>')

    mock_request.side_effect = ConnectionError('Max retries exceeded with url: /')

    assert_raises(GraphAPI.HTTPError, graph.get, 'me')


@with_setup(mock, unmock)
def test_retry():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({
        'error': {
            'code': 1,
            'message': 'An unknown error occurred'
        }
    })

    assert_raises(GraphAPI.FacebookError, graph.get, 'me', retry=3)
    assert_equal(len(mock_request.call_args_list), 4)


@with_setup(mock, unmock)
def test_get_unicode_url():
    graph = GraphAPI('<access token>')

    mock_request.return_value.content = json.dumps({})

    response = graph.get('https://www.facebook.com/christophernewportuniversity')

    assert_true(mock_request.called)
    assert_equal({}, response)


@with_setup(mock, unmock)
def test_timeouts():
    graph = GraphAPI('<access token>', timeout=1)

    mock_request.return_value.content = json.dumps({})

    graph.get('me')

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/me',
        allow_redirects=True,
        verify=True,
        timeout=1,
        params={
            'access_token': '<access token>'
        }
    )

########NEW FILE########
__FILENAME__ = test_signed_request
"""Tests for the ``signed_request`` module."""


from datetime import datetime, timedelta
from nose.tools import *

from facepy import SignedRequest


TEST_ACCESS_TOKEN = '181259711925270|1570a553ad6605705d1b7a5f.1-499729129|8XqMRhCWDKtpG-i_zRkHBDSsqqk'

TEST_SIGNED_REQUEST = u'' \
    'mnrG8Wc9CH_rh-GCqq97GFAPOh6AY7cMO8IYVKb6Pa4.eyJhbGdvcml0aG0iOi' \
    'JITUFDLVNIQTI1NiIsImV4cGlyZXMiOjAsImlzc3VlZF9hdCI6MTMwNjE3OTkw' \
    'NCwib2F1dGhfdG9rZW4iOiIxODEyNTk3MTE5MjUyNzB8MTU3MGE1NTNhZDY2MD' \
    'U3MDVkMWI3YTVmLjEtNDk5NzI5MTI5fDhYcU1SaENXREt0cEctaV96UmtIQkRT' \
    'c3FxayIsInVzZXIiOnsiY291bnRyeSI6Im5vIiwibG9jYWxlIjoiZW5fVVMiLC' \
    'JhZ2UiOnsibWluIjoyMX19LCJ1c2VyX2lkIjoiNDk5NzI5MTI5In0'

TEST_SIGNED_REQUEST_UNKNOWN_ALGORITHM = u'' \
    'HjPZBDNttKrX_DBxH-fD78wmqP5O7eDcvjE9ToayKb0=.eyJ1c2VyX2lkIjoiN' \
    'Dk5NzI5MTI5IiwiYWxnb3JpdGhtIjoiVU5LTk9XTl9BTEdPUklUSE0iLCJleHB' \
    'pcmVzIjowLCJvYXV0aF90b2tlbiI6IjE4MTI1OTcxMTkyNTI3MHwxNTcwYTU1M' \
    '2FkNjYwNTcwNWQxYjdhNWYuMS00OTk3MjkxMjl8OFhxTVJoQ1dES3RwRy1pX3p' \
    'Sa0hCRFNzcXFrIiwidXNlciI6eyJsb2NhbGUiOiJlbl9VUyIsImNvdW50cnkiO' \
    'iJubyIsImFnZSI6eyJtYXgiOjk5LCJtaW4iOjIxfX0sImlzc3VlZF9hdCI6MTM' \
    'wNjE3OTkwNH0='

TEST_SIGNED_REQUEST_MISSING_PAGE_DATA = u'' \
    '9B19RL7tj3nvf_SA8_PSFxTZxc7xA3LEjl2ww-OGRlk=.eyJ1c2VyX2lkIjoiN' \
    'Dk5NzI5MTI5IiwiYWxnb3JpdGhtIjoiSE1BQy1TSEEyNTYiLCJleHBpcmVzIjo' \
    'wLCJvYXV0aF90b2tlbiI6IjE4MTI1OTcxMTkyNTI3MHwxNTcwYTU1M2FkNjYwN' \
    'TcwNWQxYjdhNWYuMS00OTk3MjkxMjl8OFhxTVJoQ1dES3RwRy1pX3pSa0hCRFN' \
    'zcXFrIiwidXNlciI6eyJsb2NhbGUiOiJlbl9VUyIsImNvdW50cnkiOiJubyIsI' \
    'mFnZSI6eyJtYXgiOjk5LCJtaW4iOjIxfX0sImlzc3VlZF9hdCI6MTMwNjE3OTk' \
    'wNCwicGFnZSI6e319'

TEST_FACEBOOK_APPLICATION_SECRET_KEY = '214e4cb484c28c35f18a70a3d735999b'


def test_parse_signed_request():
    signed_request = SignedRequest.parse(
        signed_request=TEST_SIGNED_REQUEST,
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )

    assert signed_request == {
        'user_id': '499729129',
        'algorithm': 'HMAC-SHA256',
        'expires': 0,
        'oauth_token': '181259711925270|1570a553ad6605705d1b7a5f.1-499729129|8XqMRhCWDKtpG-i_zRkHBDSsqqk',
        'user': {
            'locale': 'en_US',
            'country': 'no',
            'age': {'min': 21}
        },
        'issued_at': 1306179904
    }


def test_parse_invalid_signed_request():
    assert_raises(
        SignedRequest.Error,
        SignedRequest,
        signed_request="<invalid signed request>",
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )


def test_initialize_signed_request():
    signed_request = SignedRequest(
        signed_request=TEST_SIGNED_REQUEST,
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )

    assert signed_request.user.id == '499729129'
    assert signed_request.user.oauth_token.token == TEST_ACCESS_TOKEN
    assert signed_request.user.oauth_token.expires_at is None

    assert signed_request.raw == {
        'user_id': '499729129',
        'algorithm': 'HMAC-SHA256',
        'expires': 0,
        'oauth_token': '181259711925270|1570a553ad6605705d1b7a5f.1-499729129|8XqMRhCWDKtpG-i_zRkHBDSsqqk',
        'user': {
            'locale': 'en_US',
            'country': 'no',
            'age': {'min': 21}
        },
        'issued_at': 1306179904
    }


def test_signed_request_missing_page_data():
    try:
        SignedRequest(TEST_SIGNED_REQUEST_MISSING_PAGE_DATA, TEST_FACEBOOK_APPLICATION_SECRET_KEY)
    except KeyError:
        raise AssertionError('Missing page data in signed request')


def test_signed_request_page_url():
    page = SignedRequest.Page(id=1)

    assert page.url == 'http://facebook.com/1'


def test_signed_request_user_profile_url():
    user = SignedRequest.User(id=1)

    assert user.profile_url == 'http://facebook.com/1'


def test_signed_request_user_has_authorized_application():
    oauth_token = SignedRequest.User.OAuthToken(
        token='<token>',
        issued_at=datetime.now(),
        expires_at=None
    )

    user = SignedRequest.User(id=1, oauth_token=oauth_token)

    assert user.has_authorized_application is True

    user = SignedRequest.User(id=1, oauth_token=None)

    assert user.has_authorized_application is False


def test_signed_request_user_oauth_token_has_expired():
    today = datetime.now()
    yesterday = today - timedelta(days=1)
    tomorrow = today + timedelta(days=1)

    oauth_token = SignedRequest.User.OAuthToken(
        token='<token>',
        issued_at=yesterday,
        expires_at=None,
    )

    assert oauth_token.has_expired is False

    oauth_token = SignedRequest.User.OAuthToken(
        token='<token>',
        issued_at=yesterday,
        expires_at=tomorrow
    )

    assert oauth_token.has_expired is False

    oauth_token = SignedRequest.User.OAuthToken(
        token='<token>',
        issued_at=yesterday,
        expires_at=yesterday
    )

    assert oauth_token.has_expired is True


def test_generate_signed_request():
    signed_request = SignedRequest(
        signed_request=TEST_SIGNED_REQUEST,
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )

    signed_request = signed_request.generate()


def test_parse_signed_request_unknown_algorithm():
    assert_raises(
        SignedRequest.Error,
        SignedRequest.parse,
        signed_request=TEST_SIGNED_REQUEST_UNKNOWN_ALGORITHM,
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )


def test_parse_signed_request_incorrect_signature():
    encoded_signature, _ = (str(string) for string in TEST_SIGNED_REQUEST_UNKNOWN_ALGORITHM.split('.', 2))
    _, encoded_payload = (str(string) for string in TEST_SIGNED_REQUEST.split('.', 2))

    assert_raises(
        SignedRequest.Error,
        SignedRequest.parse,
        signed_request=u"%s.%s" % (encoded_signature, encoded_payload),
        application_secret_key=TEST_FACEBOOK_APPLICATION_SECRET_KEY
    )

########NEW FILE########
__FILENAME__ = test_utils
"""Tests for the ``utils`` module."""

from datetime import datetime
from nose.tools import *
from mock import patch

from facepy import *


patch = patch('requests.session')


def mock():
    global mock_request

    mock_request = patch.start()().request


def unmock():
    patch.stop()


@with_setup(mock, unmock)
def test_get_extended_access_token():
    mock_request.return_value.content = 'access_token=<extended access token>&expires=5183994'

    access_token, expires_at = get_extended_access_token(
        '<access token>',
        '<application id>',
        '<application secret key>'
    )

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/oauth/access_token',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'client_id': '<application id>',
            'client_secret': '<application secret key>',
            'grant_type': 'fb_exchange_token',
            'fb_exchange_token': '<access token>'
        }
    )

    assert_equal(access_token, '<extended access token>')
    assert isinstance(expires_at, datetime)


@with_setup(mock, unmock)
def test_get_extended_access_token_no_expiry():
    mock_request.return_value.content = 'access_token=<extended access token>'

    access_token, expires_at = get_extended_access_token(
        '<access token>',
        '<application id>',
        '<application secret key>'
    )

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/oauth/access_token',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'client_id': '<application id>',
            'client_secret': '<application secret key>',
            'grant_type': 'fb_exchange_token',
            'fb_exchange_token': '<access token>'
        }
    )

    assert_equal(access_token, '<extended access token>')
    assert expires_at is None

@with_setup(mock, unmock)
def test_get_application_access_token():
    mock_request.return_value.content = 'access_token=...'

    access_token = get_application_access_token('<application id>', '<application secret key>')

    mock_request.assert_called_with(
        'GET',
        'https://graph.facebook.com/oauth/access_token',
        allow_redirects=True,
        verify=True,
        timeout=None,
        params={
            'client_id': '<application id>',
            'client_secret': '<application secret key>',
            'grant_type': 'client_credentials'
        }
    )

    assert_equal(access_token, '...')


@with_setup(mock, unmock)
def test_get_application_access_token_raises_error():
    mock_request.return_value.content = 'An unknown error occurred'

    assert_raises(
        GraphAPI.FacebookError,
        get_application_access_token,
        '<application id>',
        '<application secret key>'
    )

########NEW FILE########
